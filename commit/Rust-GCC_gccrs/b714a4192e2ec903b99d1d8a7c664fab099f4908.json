{"sha": "b714a4192e2ec903b99d1d8a7c664fab099f4908", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcxNGE0MTkyZTJlYzkwM2I5OWQxZDhhN2M2NjRmYWIwOTlmNDkwOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-07-08T20:48:04Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-07-08T20:48:04Z"}, "message": "gslice.h: Trivial formatting fixes.\n\n2004-07-08  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/gslice.h: Trivial formatting fixes.\n\t* include/bits/gslice_array.h: Likewise.\n\t* include/bits/indirect_array.h: Likewise.\n\t* include/bits/mask_array.h: Likewise.\n\t* include/bits/slice_array.h: Likewise.\n\t* include/bits/valarray_after.h: Likewise.\n\t* include/bits/valarray_array.h: Likewise.\n\t* include/bits/valarray_before.h: Likewise.\n\t* include/std/std_valarray.h: Likewise.\n\nFrom-SVN: r84312", "tree": {"sha": "c345e28ccd3636c8452b4c27d9d6316feb397664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c345e28ccd3636c8452b4c27d9d6316feb397664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b714a4192e2ec903b99d1d8a7c664fab099f4908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b714a4192e2ec903b99d1d8a7c664fab099f4908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b714a4192e2ec903b99d1d8a7c664fab099f4908", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b714a4192e2ec903b99d1d8a7c664fab099f4908/comments", "author": null, "committer": null, "parents": [{"sha": "d222b827dcf997b0d161a0741017df029fa4d5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d222b827dcf997b0d161a0741017df029fa4d5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d222b827dcf997b0d161a0741017df029fa4d5d9"}], "stats": {"total": 1436, "additions": 793, "deletions": 643}, "files": [{"sha": "4b0036b3bc6f1255fe8a367ac9953306e2e72f35", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -1,3 +1,15 @@\n+2004-07-08  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/gslice.h: Trivial formatting fixes.\n+\t* include/bits/gslice_array.h: Likewise.\n+\t* include/bits/indirect_array.h: Likewise.\n+\t* include/bits/mask_array.h: Likewise.\n+\t* include/bits/slice_array.h: Likewise.\n+\t* include/bits/valarray_after.h: Likewise.\n+\t* include/bits/valarray_array.h: Likewise.\n+\t* include/bits/valarray_before.h: Likewise.\n+\t* include/std/std_valarray.h: Likewise.\n+\n 2004-07-08  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR c++/16169"}, {"sha": "2dd2cab3e5a2e8a608f69f02fd2ec3fe6c5c3c08", "filename": "libstdc++-v3/include/bits/gslice.h", "status": "modified", "additions": 95, "deletions": 86, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -40,8 +40,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n-\n+namespace std\n+{\n   /**\n    *  @brief  Class defining multi-dimensional subset of an array.\n    *\n@@ -60,103 +60,112 @@ namespace std {\n    *  slice[0,2]==array[9], slice[1,0]==array[14], slice[1,1]==array[17],\n    *  slice[1,2]==array[20].\n    */\n-    class gslice\n+  class gslice\n+  {\n+  public:\n+    ///  Construct an empty slice.\n+    gslice ();\n+\n+    /**\n+     *  @brief  Construct a slice.\n+     *\n+     *  Constructs a slice with as many dimensions as the length of the @a l\n+     *  and @a s arrays.\n+     *\n+     *  @param  o  Offset in array of first element.\n+     *  @param  l  Array of dimension lengths.\n+     *  @param  s  Array of dimension strides between array elements.\n+     */\n+    gslice(size_t, const valarray<size_t>&, const valarray<size_t>&);\n+\n+    // XXX: the IS says the copy-ctor and copy-assignment operators are\n+    //      synthetized by the compiler but they are just unsuitable\n+    //      for a ref-counted semantic\n+    ///  Copy constructor.\n+    gslice(const gslice&);\n+\n+    ///  Destructor.\n+    ~gslice();\n+\n+    // XXX: See the note above.\n+    ///  Assignment operator.\n+    gslice& operator=(const gslice&);\n+\n+    ///  Return array offset of first slice element.\n+    size_t           start() const;\n+\n+    ///  Return array of sizes of slice dimensions.\n+    valarray<size_t> size() const;\n+    \n+    ///  Return array of array strides for each dimension.\n+    valarray<size_t> stride() const;\n+\n+  private:\n+    struct _Indexer\n     {\n-    public:\n-      ///  Construct an empty slice.\n-      gslice ();\n-\n-      /**\n-       *  @brief  Construct a slice.\n-       *\n-       *  Constructs a slice with as many dimensions as the length of the @a l\n-       *  and @a s arrays.\n-       *\n-       *  @param  o  Offset in array of first element.\n-       *  @param  l  Array of dimension lengths.\n-       *  @param  s  Array of dimension strides between array elements.\n-       */\n-      gslice(size_t, const valarray<size_t>&, const valarray<size_t>&);\n-\n-      // XXX: the IS says the copy-ctor and copy-assignment operators are\n-      //      synthetized by the compiler but they are just unsuitable\n-      //      for a ref-counted semantic\n-      ///  Copy constructor.\n-      gslice(const gslice&);\n-\n-      ///  Destructor.\n-      ~gslice();\n-\n-      // XXX: See the note above.\n-      ///  Assignment operator.\n-      gslice& operator=(const gslice&);\n-\n-      ///  Return array offset of first slice element.\n-      size_t           start() const;\n-\n-      ///  Return array of sizes of slice dimensions.\n-      valarray<size_t> size() const;\n-\n-      ///  Return array of array strides for each dimension.\n-      valarray<size_t> stride() const;\n-\n-    private:\n-      struct _Indexer {\n-\tsize_t _M_count;\n-\tsize_t _M_start;\n-\tvalarray<size_t> _M_size;\n-\tvalarray<size_t> _M_stride;\n-\tvalarray<size_t> _M_index; // Linear array of referenced indices\n-\t_Indexer(size_t, const valarray<size_t>&,\n-\t\t const valarray<size_t>&);\n-\tvoid _M_increment_use() { ++_M_count; }\n-\tsize_t _M_decrement_use() { return --_M_count; }\n-      };\n-\n-      _Indexer* _M_index;\n-\n-      template<typename _Tp> friend class valarray;\n+      size_t _M_count;\n+      size_t _M_start;\n+      valarray<size_t> _M_size;\n+      valarray<size_t> _M_stride;\n+      valarray<size_t> _M_index; // Linear array of referenced indices\n+      _Indexer(size_t, const valarray<size_t>&,\n+\t       const valarray<size_t>&);\n+      void\n+      _M_increment_use()\n+      { ++_M_count; }\n+      \n+      size_t\n+      _M_decrement_use()\n+      { return --_M_count; }\n     };\n \n-    inline size_t\n-    gslice::start () const\n-    { return _M_index ? _M_index->_M_start : 0; }\n+    _Indexer* _M_index;\n \n-    inline valarray<size_t>\n-    gslice::size () const\n-    { return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n+    template<typename _Tp> friend class valarray;\n+  };\n \n-    inline valarray<size_t>\n-    gslice::stride () const\n-    { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n+  inline size_t\n+  gslice::start () const\n+  { return _M_index ? _M_index->_M_start : 0; }\n \n-    inline gslice::gslice () : _M_index(0) {}\n+  inline valarray<size_t>\n+  gslice::size () const\n+  { return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n \n-    inline\n-    gslice::gslice(size_t __o, const valarray<size_t>& __l,\n-                   const valarray<size_t>& __s)\n-            : _M_index(new gslice::_Indexer(__o, __l, __s)) {}\n+  inline valarray<size_t>\n+  gslice::stride () const\n+  { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n \n-    inline\n-    gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n-    { if (_M_index) _M_index->_M_increment_use(); }\n+  inline gslice::gslice () : _M_index(0) {}\n \n-    inline\n-    gslice::~gslice()\n-    { if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index; }\n+  inline\n+  gslice::gslice(size_t __o, const valarray<size_t>& __l,\n+\t\t const valarray<size_t>& __s)\n+  : _M_index(new gslice::_Indexer(__o, __l, __s)) {}\n \n-    inline gslice&\n-    gslice::operator= (const gslice& __g)\n-    {\n-        if (__g._M_index) __g._M_index->_M_increment_use();\n-        if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index;\n-        _M_index = __g._M_index;\n-        return *this;\n-    }\n+  inline\n+  gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n+  { if (_M_index) _M_index->_M_increment_use(); }\n \n+  inline\n+  gslice::~gslice()\n+  {\n+    if (_M_index && _M_index->_M_decrement_use() == 0)\n+      delete _M_index;\n+  }\n \n-} // std::\n+  inline gslice&\n+  gslice::operator= (const gslice& __g)\n+  {\n+    if (__g._M_index)\n+      __g._M_index->_M_increment_use();\n+    if (_M_index && _M_index->_M_decrement_use() == 0)\n+      delete _M_index;\n+    _M_index = __g._M_index;\n+    return *this;\n+  }\n \n+} // std::\n \n #endif /* _GSLICE_H */\n "}, {"sha": "f0f9eec29aa1c4d31821368f4d6b8c4f9bceddc9", "filename": "libstdc++-v3/include/bits/gslice_array.h", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -40,8 +40,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n-\n+namespace std\n+{\n   /**\n    *  @brief  Reference to multi-dimensional subset of an array.\n    *\n@@ -97,27 +97,27 @@ namespace std {\n       void operator=(const _Tp&) const;\n \n       template<class _Dom>\n-        void operator=(const _Expr<_Dom,_Tp>&) const;\n+        void operator=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator*=(const _Expr<_Dom,_Tp>&) const;\n+        void operator*=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator/=(const _Expr<_Dom,_Tp>&) const;\n+        void operator/=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator%=(const _Expr<_Dom,_Tp>&) const;\n+        void operator%=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator+=(const _Expr<_Dom,_Tp>&) const;\n+        void operator+=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator-=(const _Expr<_Dom,_Tp>&) const;\n+        void operator-=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator^=(const _Expr<_Dom,_Tp>&) const;\n+        void operator^=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator&=(const _Expr<_Dom,_Tp>&) const;\n+        void operator&=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator|=(const _Expr<_Dom,_Tp>&) const;\n+        void operator|=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator<<=(const _Expr<_Dom,_Tp>&) const;\n+        void operator<<=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-        void operator>>=(const _Expr<_Dom,_Tp>&) const;\n+        void operator>>=(const _Expr<_Dom, _Tp>&) const;\n \n     private:\n       _Array<_Tp>    _M_array;\n@@ -137,13 +137,11 @@ namespace std {\n \t\t\t\t    const valarray<size_t>& __i)\n     : _M_array(__a), _M_index(__i) {}\n \n-\n   template<typename _Tp>\n     inline\n     gslice_array<_Tp>::gslice_array(const gslice_array<_Tp>& __a)\n     : _M_array(__a._M_array), _M_index(__a._M_index) {}\n \n-\n   template<typename _Tp>\n     inline gslice_array<_Tp>&\n     gslice_array<_Tp>::operator=(const gslice_array<_Tp>& __a)\n@@ -186,7 +184,7 @@ namespace std {\n     gslice_array<_Tp>::operator _Op##=(const valarray<_Tp>& __v) const\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       _Array_augmented_##_Name(_M_array, _Array<size_t>(_M_index),\t\\\n-\t\t\t      _Array<_Tp>(__v), __v.size());\t\t\\\n+\t\t\t       _Array<_Tp>(__v), __v.size());\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   template<typename _Tp>                                                \\"}, {"sha": "b5de990df36a540401247d7695977252e2e9cebc", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -156,7 +156,6 @@ namespace std\n        return *this;\n      }\n \n-\n   template<typename _Tp>\n      inline void\n      indirect_array<_Tp>::operator=(const _Tp& __t) const"}, {"sha": "03933578d409fa1acb9176217d362b91117c0b54", "filename": "libstdc++-v3/include/bits/mask_array.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -40,8 +40,8 @@\n \n #pragma GCC system_header\n \n-namespace std {\n-\n+namespace std\n+{\n   /**\n    *  @brief  Reference to selected subset of an array.\n    *\n@@ -128,13 +128,12 @@ namespace std {\n \n       const size_t       _M_sz;\n       const _Array<bool> _M_mask;\n-      const _Array<_Tp>   _M_array;\n+      const _Array<_Tp>  _M_array;\n \n       // not implemented\n       mask_array();\n     };\n \n-\n   template<typename _Tp>\n     inline mask_array<_Tp>::mask_array(const mask_array<_Tp>& a)\n     : _M_sz(a._M_sz), _M_mask(a._M_mask), _M_array(a._M_array) {}"}, {"sha": "42da0d224559737b47c9998e8bd1faf86c55d4e3", "filename": "libstdc++-v3/include/bits/slice_array.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -90,7 +90,7 @@ namespace std\n \n   inline\n   slice::slice(size_t __o, size_t __d, size_t __s)\n-    : _M_off(__o), _M_sz(__d), _M_st(__s) {}\n+  : _M_off(__o), _M_sz(__d), _M_st(__s) {}\n \n   inline size_t\n   slice::start() const\n@@ -160,34 +160,34 @@ namespace std\n       //        ~slice_array ();\n \n       template<class _Dom>\n-\tvoid operator=(const _Expr<_Dom,_Tp>&) const;\n+        void operator=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator*=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator*=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator/=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator/=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator%=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator%=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator+=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator+=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator-=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator-=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator^=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator^=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator&=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator&=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator|=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator|=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator<<=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator<<=(const _Expr<_Dom, _Tp>&) const;\n       template<class _Dom>\n-\tvoid operator>>=(const _Expr<_Dom,_Tp>&) const;\n+\tvoid operator>>=(const _Expr<_Dom, _Tp>&) const;\n \n     private:\n       friend class valarray<_Tp>;\n       slice_array(_Array<_Tp>, const slice&);\n \n-      const size_t     _M_sz;\n-      const size_t     _M_stride;\n+      const size_t      _M_sz;\n+      const size_t      _M_stride;\n       const _Array<_Tp> _M_array;\n \n       // not implemented"}, {"sha": "e2311275e458f10a7d2593ecd4942c866c2683bf", "filename": "libstdc++-v3/include/bits/valarray_after.h", "status": "modified", "additions": 214, "deletions": 181, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -1,6 +1,7 @@\n // The template and inlines for the -*- C++ -*- internal _Meta class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,92 +42,120 @@\n \n namespace std\n {\n-\n-    //\n-    // gslice_array closure.\n-    //\n-    template<class _Dom> class _GBase {\n+  //\n+  // gslice_array closure.\n+  //\n+  template<class _Dom>\n+    class _GBase\n+    {\n     public:\n-        typedef typename _Dom::value_type value_type;\n-\n-        _GBase (const _Dom& __e, const valarray<size_t>& __i)\n-                : _M_expr (__e), _M_index(__i) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_expr[_M_index[__i]]; }\n-        size_t size () const { return _M_index.size(); }\n+      typedef typename _Dom::value_type value_type;\n+      \n+      _GBase (const _Dom& __e, const valarray<size_t>& __i)\n+      : _M_expr (__e), _M_index(__i) {}\n+      \n+      value_type\n+      operator[] (size_t __i) const\n+      { return _M_expr[_M_index[__i]]; }\n+      \n+      size_t\n+      size () const\n+      { return _M_index.size(); }\n \n     private:\n-        const _Dom&\t _M_expr;\n-        const valarray<size_t>& _M_index;\n+      const _Dom&\t      _M_expr;\n+      const valarray<size_t>& _M_index;\n     };\n \n-    template<typename _Tp> class _GBase<_Array<_Tp> > {\n+  template<typename _Tp>\n+    class _GBase<_Array<_Tp> >\n+    {\n     public:\n-        typedef _Tp value_type;\n-\n-        _GBase (_Array<_Tp> __a, const valarray<size_t>& __i)\n-                : _M_array (__a), _M_index(__i) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_array._M_data[_M_index[__i]]; }\n-        size_t size () const { return _M_index.size(); }\n+      typedef _Tp value_type;\n+      \n+      _GBase (_Array<_Tp> __a, const valarray<size_t>& __i)\n+      : _M_array (__a), _M_index(__i) {}\n+      \n+      value_type\n+      operator[] (size_t __i) const\n+      { return _M_array._M_data[_M_index[__i]]; }\n+      \n+      size_t\n+      size () const\n+      { return _M_index.size(); }\n \n     private:\n-        const _Array<_Tp>     _M_array;\n-        const valarray<size_t>& _M_index;\n+      const _Array<_Tp>       _M_array;\n+      const valarray<size_t>& _M_index;\n     };\n \n-    template<class _Dom> struct _GClos<_Expr,_Dom> : _GBase<_Dom> {\n-        typedef _GBase<_Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-\n-        _GClos (const _Dom& __e, const valarray<size_t>& __i)\n-                : _Base (__e, __i) {}\n+  template<class _Dom>\n+    struct _GClos<_Expr, _Dom>\n+    : _GBase<_Dom>\n+    {\n+      typedef _GBase<_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _GClos (const _Dom& __e, const valarray<size_t>& __i)\n+      : _Base (__e, __i) {}\n     };\n \n-    template<typename _Tp>\n-    struct _GClos<_ValArray,_Tp> : _GBase<_Array<_Tp> > {\n-        typedef _GBase<_Array<_Tp> > _Base;\n-        typedef typename _Base::value_type value_type;\n-\n-        _GClos (_Array<_Tp> __a, const valarray<size_t>& __i)\n-                : _Base (__a, __i) {}\n+  template<typename _Tp>\n+    struct _GClos<_ValArray, _Tp>\n+    : _GBase<_Array<_Tp> >\n+    {\n+      typedef _GBase<_Array<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _GClos (_Array<_Tp> __a, const valarray<size_t>& __i)\n+      : _Base (__a, __i) {}\n     };\n \n-    //\n-    // indirect_array closure\n-    //\n-    template<class _Dom> class _IBase {\n+  //\n+  // indirect_array closure\n+  //\n+  template<class _Dom>\n+    class _IBase\n+    {\n     public:\n-        typedef typename _Dom::value_type value_type;\n+      typedef typename _Dom::value_type value_type;\n \n-        _IBase (const _Dom& __e, const valarray<size_t>& __i)\n-                : _M_expr (__e), _M_index (__i) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_expr[_M_index[__i]]; }\n-        size_t size() const { return _M_index.size(); }\n+      _IBase (const _Dom& __e, const valarray<size_t>& __i)\n+      : _M_expr (__e), _M_index (__i) {}\n+      \n+      value_type\n+      operator[] (size_t __i) const\n+      { return _M_expr[_M_index[__i]]; }\n+      \n+      size_t size() const { return _M_index.size(); }\n \n     private:\n-        const _Dom&\t    _M_expr;\n-        const valarray<size_t>& _M_index;\n+      const _Dom&\t      _M_expr;\n+      const valarray<size_t>& _M_index;\n     };\n \n-    template<class _Dom> struct _IClos<_Expr,_Dom> : _IBase<_Dom> {\n-        typedef _IBase<_Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-\n-        _IClos (const _Dom& __e, const valarray<size_t>& __i)\n-                : _Base (__e, __i) {}\n+  template<class _Dom>\n+    struct _IClos<_Expr, _Dom>\n+    : _IBase<_Dom>\n+    {\n+      typedef _IBase<_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _IClos (const _Dom& __e, const valarray<size_t>& __i)\n+      : _Base (__e, __i) {}\n     };\n \n-    template<typename _Tp>\n-    struct _IClos<_ValArray,_Tp>  : _IBase<valarray<_Tp> > {\n-        typedef _IBase<valarray<_Tp> > _Base;\n-        typedef _Tp value_type;\n-\n-        _IClos (const valarray<_Tp>& __a, const valarray<size_t>& __i)\n-                : _Base (__a, __i) {}\n+  template<typename _Tp>\n+    struct _IClos<_ValArray, _Tp>\n+    : _IBase<valarray<_Tp> >\n+    {\n+      typedef _IBase<valarray<_Tp> > _Base;\n+      typedef _Tp value_type;\n+      \n+      _IClos (const valarray<_Tp>& __a, const valarray<size_t>& __i)\n+      : _Base (__a, __i) {}\n     };\n-\n+  \n   //\n   // class _Expr\n   //\n@@ -146,17 +175,17 @@ namespace std\n       valarray<value_type> operator[](const valarray<bool>&) const;\n       valarray<value_type> operator[](const valarray<size_t>&) const;\n \n-      _Expr<_UnClos<__unary_plus,std::_Expr,_Clos>, value_type>\n-        operator+() const;\n+      _Expr<_UnClos<__unary_plus, std::_Expr, _Clos>, value_type>\n+      operator+() const;\n \n-      _Expr<_UnClos<__negate,std::_Expr,_Clos>, value_type>\n-        operator-() const;\n+      _Expr<_UnClos<__negate, std::_Expr, _Clos>, value_type>\n+      operator-() const;\n \n-      _Expr<_UnClos<__bitwise_not,std::_Expr,_Clos>, value_type>\n-        operator~() const;\n+      _Expr<_UnClos<__bitwise_not, std::_Expr, _Clos>, value_type>\n+      operator~() const;\n \n-      _Expr<_UnClos<__logical_not,std::_Expr,_Clos>, bool>\n-        operator!() const;\n+      _Expr<_UnClos<__logical_not, std::_Expr, _Clos>, bool>\n+      operator!() const;\n \n       size_t size() const;\n       value_type sum() const;\n@@ -176,41 +205,42 @@ namespace std\n \n   template<class _Clos, typename _Tp>\n     inline\n-    _Expr<_Clos,_Tp>::_Expr(const _Clos& __c) : _M_closure(__c) {}\n+    _Expr<_Clos, _Tp>::_Expr(const _Clos& __c) : _M_closure(__c) {}\n \n   template<class _Clos, typename _Tp>\n     inline const _Clos&\n-    _Expr<_Clos,_Tp>::operator()() const\n+    _Expr<_Clos, _Tp>::operator()() const\n     { return _M_closure; }\n \n   template<class _Clos, typename _Tp>\n     inline _Tp\n-    _Expr<_Clos,_Tp>::operator[](size_t __i) const\n+    _Expr<_Clos, _Tp>::operator[](size_t __i) const\n     { return _M_closure[__i]; }\n \n   template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[](slice __s) const\n+    _Expr<_Clos, _Tp>::operator[](slice __s) const\n     { return _M_closure[__s]; }\n \n   template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[](const gslice& __gs) const\n+    _Expr<_Clos, _Tp>::operator[](const gslice& __gs) const\n     { return _M_closure[__gs]; }\n \n   template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[](const valarray<bool>& __m) const\n+    _Expr<_Clos, _Tp>::operator[](const valarray<bool>& __m) const\n     { return _M_closure[__m]; }\n \n   template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[](const valarray<size_t>& __i) const\n+    _Expr<_Clos, _Tp>::operator[](const valarray<size_t>& __i) const\n     { return _M_closure[__i]; }\n \n   template<class _Clos, typename _Tp>\n     inline size_t\n-    _Expr<_Clos,_Tp>::size() const  { return _M_closure.size (); }\n+    _Expr<_Clos, _Tp>::size() const\n+    { return _M_closure.size (); }\n \n   template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n@@ -235,7 +265,7 @@ namespace std\n   // XXX: replace this with a more robust summation algorithm.\n   template<class _Clos, typename _Tp>\n     inline _Tp\n-    _Expr<_Clos,_Tp>::sum() const\n+    _Expr<_Clos, _Tp>::sum() const\n     {\n       size_t __n = _M_closure.size();\n       if (__n == 0)\n@@ -260,20 +290,20 @@ namespace std\n     { return __valarray_max(_M_closure); }\n \n   template<class _Dom, typename _Tp>\n-    inline _Expr<_UnClos<__logical_not,_Expr,_Dom>, bool>\n-    _Expr<_Dom,_Tp>::operator!() const\n+    inline _Expr<_UnClos<__logical_not, _Expr, _Dom>, bool>\n+    _Expr<_Dom, _Tp>::operator!() const\n     {\n-      typedef _UnClos<__logical_not,std::_Expr,_Dom> _Closure;\n-      return _Expr<_Closure,_Tp>(_Closure(this->_M_closure));\n+      typedef _UnClos<__logical_not, std::_Expr, _Dom> _Closure;\n+      return _Expr<_Closure, _Tp>(_Closure(this->_M_closure));\n     }\n \n #define _DEFINE_EXPR_UNARY_OPERATOR(_Op, _Name)                           \\\n   template<class _Dom, typename _Tp>                                      \\\n-    inline _Expr<_UnClos<_Name,std::_Expr,_Dom>,_Tp>                      \\\n-    _Expr<_Dom,_Tp>::operator _Op() const                                 \\\n+    inline _Expr<_UnClos<_Name, std::_Expr, _Dom>, _Tp>                   \\\n+    _Expr<_Dom, _Tp>::operator _Op() const                                \\\n     {                                                                     \\\n-      typedef _UnClos<_Name,std::_Expr,_Dom> _Closure;                    \\\n-      return _Expr<_Closure,_Tp>(_Closure(this->_M_closure));             \\\n+      typedef _UnClos<_Name, std::_Expr, _Dom> _Closure;                  \\\n+      return _Expr<_Closure, _Tp>(_Closure(this->_M_closure));            \\\n     }\n \n     _DEFINE_EXPR_UNARY_OPERATOR(+, __unary_plus)\n@@ -282,67 +312,70 @@ namespace std\n \n #undef _DEFINE_EXPR_UNARY_OPERATOR\n \n-\n #define _DEFINE_EXPR_BINARY_OPERATOR(_Op, _Name)                        \\\n   template<class _Dom1, class _Dom2>\t\t\t\t\t\\\n-  inline _Expr<_BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2>,                 \\\n-         typename __fun<_Name, typename _Dom1::value_type>::result_type>\\\n-  operator _Op(const _Expr<_Dom1,typename _Dom1::value_type>& __v,      \\\n-\t       const _Expr<_Dom2,typename _Dom2::value_type>& __w)      \\\n-  {                                                                     \\\n-    typedef typename _Dom1::value_type _Arg;                            \\\n-    typedef typename __fun<_Name, _Arg>::result_type _Value;            \\\n-    typedef _BinClos<_Name,_Expr,_Expr,_Dom1,_Dom2> _Closure;           \\\n-    return _Expr<_Closure,_Value>(_Closure(__v(), __w()));              \\\n-  }                                                                     \\\n+    inline _Expr<_BinClos<_Name, _Expr, _Expr, _Dom1, _Dom2>,           \\\n+           typename __fun<_Name, typename _Dom1::value_type>::result_type> \\\n+    operator _Op(const _Expr<_Dom1, typename _Dom1::value_type>& __v,   \\\n+\t         const _Expr<_Dom2, typename _Dom2::value_type>& __w)   \\\n+    {                                                                   \\\n+      typedef typename _Dom1::value_type _Arg;                          \\\n+      typedef typename __fun<_Name, _Arg>::result_type _Value;          \\\n+      typedef _BinClos<_Name, _Expr, _Expr, _Dom1, _Dom2> _Closure;     \\\n+      return _Expr<_Closure, _Value>(_Closure(__v(), __w()));           \\\n+    }                                                                   \\\n                                                                         \\\n-template<class _Dom>                                                    \\\n-inline _Expr<_BinClos<_Name,_Expr,_Constant,_Dom,typename _Dom::value_type>,\\\n-             typename __fun<_Name, typename _Dom::value_type>::result_type>\\\n-operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __v,          \\\n-             const typename _Dom::value_type& __t)                      \\\n-{                                                                       \\\n-  typedef typename _Dom::value_type _Arg;                               \\\n-  typedef typename __fun<_Name, _Arg>::result_type _Value;              \\\n-  typedef _BinClos<_Name,_Expr,_Constant,_Dom,_Arg> _Closure;           \\\n-  return _Expr<_Closure,_Value>(_Closure(__v(), __t));                  \\\n-}                                                                       \\\n+  template<class _Dom>                                                  \\\n+    inline _Expr<_BinClos<_Name, _Expr, _Constant, _Dom,                \\\n+                          typename _Dom::value_type>,                   \\\n+             typename __fun<_Name, typename _Dom::value_type>::result_type> \\\n+    operator _Op(const _Expr<_Dom, typename _Dom::value_type>& __v,     \\\n+                 const typename _Dom::value_type& __t)                  \\\n+    {                                                                   \\\n+      typedef typename _Dom::value_type _Arg;                           \\\n+      typedef typename __fun<_Name, _Arg>::result_type _Value;          \\\n+      typedef _BinClos<_Name, _Expr, _Constant, _Dom, _Arg> _Closure;   \\\n+      return _Expr<_Closure, _Value>(_Closure(__v(), __t));             \\\n+    }                                                                   \\\n                                                                         \\\n-template<class _Dom>                                                    \\\n-inline _Expr<_BinClos<_Name,_Constant,_Expr,typename _Dom::value_type,_Dom>,\\\n-             typename __fun<_Name, typename _Dom::value_type>::result_type>\\\n-operator _Op(const typename _Dom::value_type& __t,                      \\\n-             const _Expr<_Dom,typename _Dom::value_type>& __v)          \\\n-{                                                                       \\\n-  typedef typename _Dom::value_type _Arg;                               \\\n-  typedef typename __fun<_Name, _Arg>::result_type _Value;              \\\n-  typedef _BinClos<_Name,_Constant,_Expr,_Arg,_Dom> _Closure;           \\\n-  return _Expr<_Closure,_Value>(_Closure(__t, __v()));                  \\\n-}                                                                       \\\n+  template<class _Dom>                                                  \\\n+    inline _Expr<_BinClos<_Name, _Constant, _Expr,                      \\\n+                          typename _Dom::value_type, _Dom>,             \\\n+             typename __fun<_Name, typename _Dom::value_type>::result_type> \\\n+    operator _Op(const typename _Dom::value_type& __t,                  \\\n+                 const _Expr<_Dom, typename _Dom::value_type>& __v)     \\\n+    {                                                                   \\\n+      typedef typename _Dom::value_type _Arg;                           \\\n+      typedef typename __fun<_Name, _Arg>::result_type _Value;          \\\n+      typedef _BinClos<_Name, _Constant, _Expr, _Arg, _Dom> _Closure;   \\\n+      return _Expr<_Closure, _Value>(_Closure(__t, __v()));             \\\n+    }                                                                   \\\n                                                                         \\\n-template<class _Dom>                                                    \\\n-inline _Expr<_BinClos<_Name,_Expr,_ValArray,_Dom,typename _Dom::value_type>,\\\n-             typename __fun<_Name, typename _Dom::value_type>::result_type>\\\n-operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __e,          \\\n-             const valarray<typename _Dom::value_type>& __v)            \\\n-{                                                                       \\\n-  typedef typename _Dom::value_type _Arg;                               \\\n-  typedef typename __fun<_Name, _Arg>::result_type _Value;              \\\n-  typedef _BinClos<_Name,_Expr,_ValArray,_Dom,_Arg> _Closure;           \\\n-  return  _Expr<_Closure,_Value>(_Closure(__e(), __v));                 \\\n-}                                                                       \\\n+  template<class _Dom>                                                  \\\n+    inline _Expr<_BinClos<_Name, _Expr, _ValArray,                      \\\n+                          _Dom, typename _Dom::value_type>,             \\\n+             typename __fun<_Name, typename _Dom::value_type>::result_type> \\\n+    operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __e,      \\\n+                 const valarray<typename _Dom::value_type>& __v)        \\\n+    {                                                                   \\\n+      typedef typename _Dom::value_type _Arg;                           \\\n+      typedef typename __fun<_Name, _Arg>::result_type _Value;          \\\n+      typedef _BinClos<_Name, _Expr, _ValArray, _Dom, _Arg> _Closure;   \\\n+      return _Expr<_Closure, _Value>(_Closure(__e(), __v));             \\\n+    }                                                                   \\\n                                                                         \\\n-template<class _Dom>                                                    \\\n-inline _Expr<_BinClos<_Name,_ValArray,_Expr,typename _Dom::value_type,_Dom>,\\\n-             typename __fun<_Name, typename _Dom::value_type>::result_type>\\\n-operator _Op(const valarray<typename _Dom::value_type>& __v,            \\\n-             const _Expr<_Dom,typename _Dom::value_type>& __e)          \\\n-{                                                                       \\\n-  typedef typename _Dom::value_type _Tp;                                \\\n-  typedef typename __fun<_Name, _Tp>::result_type _Value;               \\\n-  typedef _BinClos<_Name,_ValArray,_Expr,_Tp,_Dom> _Closure;            \\\n-  return _Expr<_Closure,_Value> (_Closure (__v, __e ()));               \\\n-}\n+  template<class _Dom>                                                  \\\n+    inline _Expr<_BinClos<_Name, _ValArray, _Expr,                      \\\n+                 typename _Dom::value_type, _Dom>,                      \\\n+             typename __fun<_Name, typename _Dom::value_type>::result_type> \\\n+    operator _Op(const valarray<typename _Dom::value_type>& __v,        \\\n+                 const _Expr<_Dom, typename _Dom::value_type>& __e)     \\\n+    {                                                                   \\\n+      typedef typename _Dom::value_type _Tp;                            \\\n+      typedef typename __fun<_Name, _Tp>::result_type _Value;           \\\n+      typedef _BinClos<_Name, _ValArray, _Expr, _Tp, _Dom> _Closure;    \\\n+      return _Expr<_Closure, _Value>(_Closure(__v, __e ()));            \\\n+    }\n \n     _DEFINE_EXPR_BINARY_OPERATOR(+, __plus)\n     _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)\n@@ -367,20 +400,21 @@ operator _Op(const valarray<typename _Dom::value_type>& __v,            \\\n \n #define _DEFINE_EXPR_UNARY_FUNCTION(_Name)                               \\\n   template<class _Dom>                                                   \\\n-    inline _Expr<_UnClos<__##_Name,_Expr,_Dom>,typename _Dom::value_type>\\\n-    _Name(const _Expr<_Dom,typename _Dom::value_type>& __e)              \\\n+    inline _Expr<_UnClos<__##_Name, _Expr, _Dom>,                        \\\n+                 typename _Dom::value_type>                              \\\n+    _Name(const _Expr<_Dom, typename _Dom::value_type>& __e)             \\\n     {                                                                    \\\n       typedef typename _Dom::value_type _Tp;                             \\\n-      typedef _UnClos<__##_Name,_Expr,_Dom> _Closure;                    \\\n-      return _Expr<_Closure,_Tp>(_Closure(__e()));                       \\\n+      typedef _UnClos<__##_Name, _Expr, _Dom> _Closure;                  \\\n+      return _Expr<_Closure, _Tp>(_Closure(__e()));                      \\\n     }                                                                    \\\n                                                                          \\\n   template<typename _Tp>                                                 \\\n-    inline _Expr<_UnClos<__##_Name,_ValArray,_Tp>,_Tp>                   \\\n+    inline _Expr<_UnClos<__##_Name, _ValArray, _Tp>, _Tp>                \\\n     _Name(const valarray<_Tp>& __v)                                      \\\n     {                                                                    \\\n-      typedef _UnClos<__##_Name,_ValArray,_Tp> _Closure;                 \\\n-      return _Expr<_Closure,_Tp>(_Closure(__v));                         \\\n+      typedef _UnClos<__##_Name, _ValArray, _Tp> _Closure;               \\\n+      return _Expr<_Closure, _Tp>(_Closure(__v));                        \\\n     }\n \n     _DEFINE_EXPR_UNARY_FUNCTION(abs)\n@@ -402,86 +436,86 @@ operator _Op(const valarray<typename _Dom::value_type>& __v,            \\\n \n #define _DEFINE_EXPR_BINARY_FUNCTION(_Fun)                             \\\n   template<class _Dom1, class _Dom2>                                   \\\n-    inline _Expr<_BinClos<__##_Fun,_Expr,_Expr,_Dom1,_Dom2>,           \\\n+    inline _Expr<_BinClos<__##_Fun, _Expr, _Expr, _Dom1, _Dom2>,       \\\n \t\t typename _Dom1::value_type>                           \\\n-    _Fun(const _Expr<_Dom1,typename _Dom1::value_type>& __e1,          \\\n-\t  const _Expr<_Dom2,typename _Dom2::value_type>& __e2)         \\\n+    _Fun(const _Expr<_Dom1, typename _Dom1::value_type>& __e1,         \\\n+\t  const _Expr<_Dom2, typename _Dom2::value_type>& __e2)        \\\n     {                                                                  \\\n       typedef typename _Dom1::value_type _Tp;                          \\\n-      typedef _BinClos<__##_Fun,_Expr,_Expr,_Dom1,_Dom2> _Closure;     \\\n-      return _Expr<_Closure,_Tp>(_Closure(__e1(), __e2()));            \\\n+      typedef _BinClos<__##_Fun, _Expr, _Expr, _Dom1, _Dom2> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__e1(), __e2()));           \\\n     }                                                                  \\\n                                                                        \\\n   template<class _Dom>                                                 \\\n     inline _Expr<_BinClos<__##_Fun, _Expr, _ValArray, _Dom,            \\\n \t\t\t  typename _Dom::value_type>,                  \\\n \t\t typename _Dom::value_type>                            \\\n-    _Fun(const _Expr<_Dom,typename _Dom::value_type>& __e,             \\\n+    _Fun(const _Expr<_Dom, typename _Dom::value_type>& __e,            \\\n \t const valarray<typename _Dom::value_type>& __v)               \\\n     {                                                                  \\\n       typedef typename _Dom::value_type _Tp;                           \\\n-      typedef _BinClos<__##_Fun, _Expr, _ValArray, _Dom, _Tp> _Closure;\\\n-      return _Expr<_Closure,_Tp>(_Closure(__e(), __v));                \\\n+      typedef _BinClos<__##_Fun, _Expr, _ValArray, _Dom, _Tp> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__e(), __v));               \\\n     }                                                                  \\\n                                                                        \\\n   template<class _Dom>                                                 \\\n     inline _Expr<_BinClos<__##_Fun, _ValArray, _Expr,                  \\\n-\t\t\t  typename _Dom::value_type,_Dom>,             \\\n+\t\t\t  typename _Dom::value_type, _Dom>,            \\\n \t\t typename _Dom::value_type>                            \\\n     _Fun(const valarray<typename _Dom::valarray>& __v,                 \\\n-\t const _Expr<_Dom,typename _Dom::value_type>& __e)             \\\n+\t const _Expr<_Dom, typename _Dom::value_type>& __e)            \\\n     {                                                                  \\\n       typedef typename _Dom::value_type _Tp;                           \\\n-      typedef _BinClos<__##_Fun,_ValArray,_Expr,_Tp,_Dom> _Closure;    \\\n-      return _Expr<_Closure,_Tp>(_Closure(__v, __e()));                \\\n+      typedef _BinClos<__##_Fun, _ValArray, _Expr, _Tp, _Dom> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__v, __e()));               \\\n     }                                                                  \\\n                                                                        \\\n   template<class _Dom>                                                 \\\n-    inline _Expr<_BinClos<__##_Fun,_Expr,_Constant,_Dom,               \\\n+    inline _Expr<_BinClos<__##_Fun, _Expr, _Constant, _Dom,            \\\n \t\t\t  typename _Dom::value_type>,                  \\\n \t\t typename _Dom::value_type>                            \\\n     _Fun(const _Expr<_Dom, typename _Dom::value_type>& __e,            \\\n \t const typename _Dom::value_type& __t)                         \\\n     {                                                                  \\\n       typedef typename _Dom::value_type _Tp;                           \\\n-      typedef _BinClos<__##_Fun,_Expr,_Constant,_Dom,_Tp> _Closure;    \\\n-      return _Expr<_Closure,_Tp>(_Closure(__e(), __t));                \\\n+      typedef _BinClos<__##_Fun, _Expr, _Constant, _Dom, _Tp> _Closure;\\\n+      return _Expr<_Closure, _Tp>(_Closure(__e(), __t));               \\\n     }                                                                  \\\n                                                                        \\\n   template<class _Dom>                                                 \\\n-    inline _Expr<_BinClos<__##_Fun,_Constant,_Expr,                    \\\n-\t\t\t  typename _Dom::value_type,_Dom>,             \\\n+    inline _Expr<_BinClos<__##_Fun, _Constant, _Expr,                  \\\n+\t\t\t  typename _Dom::value_type, _Dom>,            \\\n \t\t typename _Dom::value_type>                            \\\n     _Fun(const typename _Dom::value_type& __t,                         \\\n-\t const _Expr<_Dom,typename _Dom::value_type>& __e)             \\\n+\t const _Expr<_Dom, typename _Dom::value_type>& __e)            \\\n     {                                                                  \\\n       typedef typename _Dom::value_type _Tp;                           \\\n-      typedef _BinClos<__##_Fun, _Constant,_Expr,_Tp,_Dom> _Closure;   \\\n-      return _Expr<_Closure,_Tp>(_Closure(__t, __e()));                \\\n+      typedef _BinClos<__##_Fun, _Constant, _Expr, _Tp, _Dom> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__t, __e()));               \\\n     }                                                                  \\\n                                                                        \\\n   template<typename _Tp>                                               \\\n-    inline _Expr<_BinClos<__##_Fun,_ValArray,_ValArray,_Tp,_Tp>, _Tp>  \\\n+    inline _Expr<_BinClos<__##_Fun, _ValArray, _ValArray, _Tp, _Tp>, _Tp> \\\n     _Fun(const valarray<_Tp>& __v, const valarray<_Tp>& __w)           \\\n     {                                                                  \\\n-      typedef _BinClos<__##_Fun,_ValArray,_ValArray,_Tp,_Tp> _Closure; \\\n-      return _Expr<_Closure,_Tp>(_Closure(__v, __w));                  \\\n+      typedef _BinClos<__##_Fun, _ValArray, _ValArray, _Tp, _Tp> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__v, __w));                 \\\n     }                                                                  \\\n                                                                        \\\n   template<typename _Tp>                                               \\\n-    inline _Expr<_BinClos<__##_Fun,_ValArray,_Constant,_Tp,_Tp>,_Tp>   \\\n+    inline _Expr<_BinClos<__##_Fun, _ValArray, _Constant, _Tp, _Tp>, _Tp> \\\n     _Fun(const valarray<_Tp>& __v, const _Tp& __t)                     \\\n     {                                                                  \\\n-      typedef _BinClos<__##_Fun,_ValArray,_Constant,_Tp,_Tp> _Closure; \\\n-      return _Expr<_Closure,_Tp>(_Closure(__v, __t));                  \\\n+      typedef _BinClos<__##_Fun, _ValArray, _Constant, _Tp, _Tp> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__v, __t));                 \\\n     }                                                                  \\\n \t\t\t\t\t\t\t\t       \\\n   template<typename _Tp>                                               \\\n-    inline _Expr<_BinClos<__##_Fun,_Constant,_ValArray,_Tp,_Tp>,_Tp>   \\\n+    inline _Expr<_BinClos<__##_Fun, _Constant, _ValArray, _Tp, _Tp>, _Tp> \\\n     _Fun(const _Tp& __t, const valarray<_Tp>& __v)                     \\\n     {                                                                  \\\n-      typedef _BinClos<__##_Fun,_Constant,_ValArray,_Tp,_Tp> _Closure; \\\n-      return _Expr<_Closure,_Tp>(_Closure(__t, __v));                  \\\n+      typedef _BinClos<__##_Fun, _Constant, _ValArray, _Tp, _Tp> _Closure; \\\n+      return _Expr<_Closure, _Tp>(_Closure(__t, __v));                 \\\n     }\n \n _DEFINE_EXPR_BINARY_FUNCTION(atan2)\n@@ -491,7 +525,6 @@ _DEFINE_EXPR_BINARY_FUNCTION(pow)\n \n } // std::\n \n-\n #endif /* _CPP_VALARRAY_AFTER_H */\n \n // Local Variables:"}, {"sha": "a104f7ba7527ba8f52d5b3c11d735e4feae73e61", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "modified", "additions": 229, "deletions": 161, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -79,7 +79,10 @@ namespace std\n        // valarrays aren't required to be exception safe.\n        inline static void\n        _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-       { while (__b != __e) new(__b++) _Tp(); }\n+       {\n+\t while (__b != __e)\n+\t   new(__b++) _Tp();\n+       }\n      };\n \n   template<typename _Tp>\n@@ -88,7 +91,7 @@ namespace std\n        // For fundamental types, it suffices to say 'memset()'\n        inline static void\n        _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n-       { std::memset(__b, 0, (__e - __b)*sizeof(_Tp)); }\n+       { std::memset(__b, 0, (__e - __b) * sizeof(_Tp)); }\n      };\n \n   template<typename _Tp>\n@@ -109,15 +112,21 @@ namespace std\n        // valarrays aren't required to be exception safe.\n        inline static void\n        _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e, const _Tp __t)\n-       { while (__b != __e) new(__b++) _Tp(__t); }\n+       {\n+\t while (__b != __e)\n+\t   new(__b++) _Tp(__t);\n+       }\n      };\n \n   template<typename _Tp>\n      struct _Array_init_ctor<_Tp, true>\n      {\n        inline static void\n        _S_do_it(_Tp* __restrict__ __b, _Tp* __restrict__ __e,  const _Tp __t)\n-       { while (__b != __e) *__b++ = __t; }\n+       {\n+\t while (__b != __e)\n+\t   *__b++ = __t;\n+       }\n      };\n \n   template<typename _Tp>\n@@ -141,7 +150,10 @@ namespace std\n        inline static void\n        _S_do_it(const _Tp* __restrict__ __b, const _Tp* __restrict__ __e,\n                 _Tp* __restrict__ __o)\n-       { while (__b != __e) new(__o++) _Tp(*__b++); }\n+       {\n+\t while (__b != __e)\n+\t   new(__o++) _Tp(*__b++);\n+       }\n      };\n \n   template<typename _Tp>\n@@ -170,9 +182,17 @@ namespace std\n                                 size_t __s, _Tp* __restrict__ __o)\n      {\n        if (__is_fundamental<_Tp>::_M_type)\n-         while (__n--) { *__o++ = *__a; __a += __s; }\n+         while (__n--)\n+\t   {\n+\t     *__o++ = *__a;\n+\t     __a += __s;\n+\t   }\n        else\n-         while (__n--) { new(__o++) _Tp(*__a);  __a += __s; }\n+         while (__n--)\n+\t   {\n+\t     new(__o++) _Tp(*__a);\n+\t     __a += __s;\n+\t   }\n      }\n \n   // copy-construct raw array [__o, *) from indexed array __a[__i[<__n>]]\n@@ -183,9 +203,11 @@ namespace std\n                                 _Tp* __restrict__ __o, size_t __n)\n      {\n        if (__is_fundamental<_Tp>::_M_type)\n-         while (__n--) *__o++ = __a[*__i++];\n+         while (__n--)\n+\t   *__o++ = __a[*__i++];\n        else\n-         while (__n--) new (__o++) _Tp(__a[*__i++]);\n+         while (__n--)\n+\t   new (__o++) _Tp(__a[*__i++]);\n      }\n \n   // Do the necessary cleanup when we're done with arrays.\n@@ -194,28 +216,41 @@ namespace std\n      __valarray_destroy_elements(_Tp* __restrict__ __b, _Tp* __restrict__ __e)\n      {\n        if (!__is_fundamental<_Tp>::_M_type)\n-         while (__b != __e) { __b->~_Tp(); ++__b; }\n+         while (__b != __e)\n+\t   {\n+\t     __b->~_Tp();\n+\t     ++__b;\n+\t   }\n      }\n \n   // Fill a plain array __a[<__n>] with __t\n   template<typename _Tp>\n      inline void\n-     __valarray_fill (_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n-     { while (__n--) *__a++ = __t; }\n+     __valarray_fill(_Tp* __restrict__ __a, size_t __n, const _Tp& __t)\n+     {\n+       while (__n--)\n+\t *__a++ = __t;\n+     }\n \n   // fill strided array __a[<__n-1 : __s>] with __t\n   template<typename _Tp>\n      inline void\n-     __valarray_fill (_Tp* __restrict__ __a, size_t __n,\n-                      size_t __s, const _Tp& __t)\n-     { for (size_t __i=0; __i<__n; ++__i, __a+=__s) *__a = __t; }\n+     __valarray_fill(_Tp* __restrict__ __a, size_t __n,\n+\t\t     size_t __s, const _Tp& __t)\n+     {\n+       for (size_t __i = 0; __i < __n; ++__i, __a += __s)\n+\t *__a = __t;\n+     }\n \n   // fill indir   ect array __a[__i[<__n>]] with __i\n   template<typename _Tp>\n      inline void\n      __valarray_fill(_Tp* __restrict__ __a, const size_t* __restrict__ __i,\n                      size_t __n, const _Tp& __t)\n-     { for (size_t __j=0; __j<__n; ++__j, ++__i) __a[*__i] = __t; }\n+     {\n+       for (size_t __j = 0; __j < __n; ++__j, ++__i)\n+\t __a[*__i] = __t;\n+     }\n \n   // copy plain array __a[<__n>] in __b[<__n>]\n   // For non-fundamental types, it is wrong to say 'memcpy()'\n@@ -224,7 +259,10 @@ namespace std\n      {\n        inline static void\n        _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)\n-       { while (__n--) *__b++ = *__a++; }\n+       {\n+\t while(__n--)\n+\t   *__b++ = *__a++;\n+       }\n      };\n \n   template<typename _Tp>\n@@ -239,7 +277,7 @@ namespace std\n   template<typename _Tp>\n      inline void\n      __valarray_copy(const _Tp* __restrict__ __a, size_t __n,\n-                      _Tp* __restrict__ __b)\n+\t\t     _Tp* __restrict__ __b)\n      {\n        _Array_copier<_Tp, __is_fundamental<_Tp>::_M_type>::\n          _S_do_it(__a, __n, __b);\n@@ -249,15 +287,21 @@ namespace std\n   template<typename _Tp>\n      inline void\n      __valarray_copy(const _Tp* __restrict__ __a, size_t __n, size_t __s,\n-                      _Tp* __restrict__ __b)\n-     { for (size_t __i=0; __i<__n; ++__i, ++__b, __a += __s) *__b = *__a; }\n+\t\t     _Tp* __restrict__ __b)\n+     {\n+       for (size_t __i = 0; __i < __n; ++__i, ++__b, __a += __s)\n+\t *__b = *__a;\n+     }\n \n   // Copy a plain array  __a[<__n>] into a strided array __b[<__n : __s>]\n   template<typename _Tp>\n      inline void\n      __valarray_copy(const _Tp* __restrict__ __a, _Tp* __restrict__ __b,\n-                      size_t __n, size_t __s)\n-     { for (size_t __i=0; __i<__n; ++__i, ++__a, __b+=__s) *__b = *__a; }\n+\t\t     size_t __n, size_t __s)\n+     {\n+       for (size_t __i = 0; __i < __n; ++__i, ++__a, __b += __s)\n+\t *__b = *__a;\n+     }\n \n   // Copy strided array __src[<__n : __s1>] into another\n   // strided array __dst[< : __s2>].  Their sizes must match.\n@@ -267,7 +311,7 @@ namespace std\n                      _Tp* __restrict__ __dst, size_t __s2)\n      {\n        for (size_t __i = 0; __i < __n; ++__i)\n-         __dst[__i * __s2] = __src [ __i * __s1];\n+         __dst[__i * __s2] = __src[__i * __s1];\n      }\n \n \n@@ -277,14 +321,20 @@ namespace std\n      __valarray_copy (const _Tp* __restrict__ __a,\n                       const size_t* __restrict__ __i,\n                       _Tp* __restrict__ __b, size_t __n)\n-     { for (size_t __j=0; __j<__n; ++__j, ++__b, ++__i) *__b = __a[*__i]; }\n+     {\n+       for (size_t __j = 0; __j < __n; ++__j, ++__b, ++__i)\n+\t *__b = __a[*__i];\n+     }\n \n   // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n      inline void\n      __valarray_copy (const _Tp* __restrict__ __a, size_t __n,\n                       _Tp* __restrict__ __b, const size_t* __restrict__ __i)\n-     { for (size_t __j=0; __j<__n; ++__j, ++__a, ++__i) __b[*__i] = *__a; }\n+     {\n+       for (size_t __j = 0; __j < __n; ++__j, ++__a, ++__i)\n+         __b[*__i] = *__a;\n+     }\n \n   // Copy the __n first elements of an indexed array __src[<__i>] into\n   // another indexed array __dst[<__j>].\n@@ -310,7 +360,8 @@ namespace std\n      __valarray_sum(const _Tp* __restrict__ __f, const _Tp* __restrict__ __l)\n      {\n        _Tp __r = _Tp();\n-       while (__f != __l) __r += *__f++;\n+       while (__f != __l)\n+\t __r += *__f++;\n        return __r;\n      }\n \n@@ -321,7 +372,8 @@ namespace std\n                         const _Tp* __restrict__ __l)\n      {\n        _Tp __r = _Tp(1);\n-       while (__f != __l) __r = __r * *__f++;\n+       while (__f != __l)\n+\t __r = __r * *__f++;\n        return __r;\n      }\n \n@@ -367,31 +419,31 @@ namespace std\n   template<typename _Tp>\n      struct _Array\n      {\n-       explicit _Array (size_t);\n-       explicit _Array (_Tp* const __restrict__);\n-       explicit _Array (const valarray<_Tp>&);\n-       _Array (const _Tp* __restrict__, size_t);\n+       explicit _Array(size_t);\n+       explicit _Array(_Tp* const __restrict__);\n+       explicit _Array(const valarray<_Tp>&);\n+       _Array(const _Tp* __restrict__, size_t);\n \n-       _Tp* begin () const;\n+       _Tp* begin() const;\n \n        _Tp* const __restrict__ _M_data;\n      };\n \n   template<typename _Tp>\n      inline void\n      __valarray_fill (_Array<_Tp> __a, size_t __n, const _Tp& __t)\n-     { std::__valarray_fill (__a._M_data, __n, __t); }\n+     { std::__valarray_fill(__a._M_data, __n, __t); }\n \n   template<typename _Tp>\n      inline void\n-     __valarray_fill (_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n-     { std::__valarray_fill (__a._M_data, __n, __s, __t); }\n+     __valarray_fill(_Array<_Tp> __a, size_t __n, size_t __s, const _Tp& __t)\n+     { std::__valarray_fill(__a._M_data, __n, __s, __t); }\n \n   template<typename _Tp>\n      inline void\n-     __valarray_fill (_Array<_Tp> __a, _Array<size_t> __i,\n-                      size_t __n, const _Tp& __t)\n-     { std::__valarray_fill (__a._M_data, __i._M_data, __n, __t); }\n+     __valarray_fill(_Array<_Tp> __a, _Array<size_t> __i,\n+\t\t     size_t __n, const _Tp& __t)\n+     { std::__valarray_fill(__a._M_data, __i._M_data, __n, __t); }\n \n   // Copy a plain array __a[<__n>] into a play array __b[<>]\n   template<typename _Tp>\n@@ -424,14 +476,14 @@ namespace std\n   template<typename _Tp>\n      inline void\n      __valarray_copy(_Array<_Tp> __a, _Array<size_t> __i,\n-                      _Array<_Tp> __b, size_t __n)\n+\t\t     _Array<_Tp> __b, size_t __n)\n      { std::__valarray_copy(__a._M_data, __i._M_data, __b._M_data, __n); }\n \n   // Copy a plain array __a[<__n>] in an indexed array __b[__i[<__n>]]\n   template<typename _Tp>\n      inline void\n      __valarray_copy(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b,\n-                      _Array<size_t> __i)\n+\t\t     _Array<size_t> __i)\n      { std::__valarray_copy(__a._M_data, __n, __b._M_data, __i._M_data); }\n \n   // Copy the __n first elements of an indexed array __src[<__i>] into\n@@ -447,22 +499,24 @@ namespace std\n \n   template<typename _Tp>\n      inline\n-     _Array<_Tp>::_Array (size_t __n)\n-       : _M_data(__valarray_get_storage<_Tp>(__n))\n+     _Array<_Tp>::_Array(size_t __n)\n+     : _M_data(__valarray_get_storage<_Tp>(__n))\n      { std::__valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n      inline\n-     _Array<_Tp>::_Array (_Tp* const __restrict__ __p) : _M_data (__p) {}\n+     _Array<_Tp>::_Array(_Tp* const __restrict__ __p)\n+     : _M_data (__p) {}\n \n   template<typename _Tp>\n-     inline _Array<_Tp>::_Array (const valarray<_Tp>& __v)\n-         : _M_data (__v._M_data) {}\n+     inline\n+     _Array<_Tp>::_Array(const valarray<_Tp>& __v)\n+     : _M_data (__v._M_data) {}\n \n   template<typename _Tp>\n      inline\n-     _Array<_Tp>::_Array (const _Tp* __restrict__ __b, size_t __s)\n-       : _M_data(__valarray_get_storage<_Tp>(__s))\n+     _Array<_Tp>::_Array(const _Tp* __restrict__ __b, size_t __s)\n+     : _M_data(__valarray_get_storage<_Tp>(__s))\n      { std::__valarray_copy_construct(__b, __s, _M_data); }\n \n   template<typename _Tp>\n@@ -471,138 +525,152 @@ namespace std\n      { return _M_data; }\n \n #define _DEFINE_ARRAY_FUNCTION(_Op, _Name)\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, const _Tp& __t)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p)\t\t\\\n-    *__p _Op##= __t;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t        \t\t\t\\\n+    inline void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __n, const _Tp& __t) \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (_Tp* __p = __a._M_data; __p < __a._M_data + __n; ++__p)\t\\\n+        *__p _Op##= __t;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, _Array<_Tp> __b)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  _Tp* __p = __a._M_data;\t\t\t\t\t\t\\\n-  for (_Tp* __q=__b._M_data; __q<__b._M_data+__n; ++__p, ++__q)\t\t\\\n-    *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    inline void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __n, _Array<_Tp> __b) \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __p = __a._M_data;\t\t\t\t\t\t\\\n+      for (_Tp* __q = __b._M_data; __q < __b._M_data + __n; ++__p, ++__q) \\\n+        *__p _Op##= *__q;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp, class _Dom>\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a,\t\t\t\t\\\n-                         const _Expr<_Dom,_Tp>& __e, size_t __n)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n-    for (size_t __i=0; __i<__n; ++__i, ++__p) *__p _Op##= __e[__i];\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a,\t        \t\t\\\n+                             const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __p(__a._M_data);\t\t\t\t\t\t\\\n+      for (size_t __i = 0; __i < __n; ++__i, ++__p)                     \\\n+        *__p _Op##= __e[__i];                                          \t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n, size_t __s,\t\\\n-\t\t\t _Array<_Tp> __b)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n-    for (_Tp* __p=__a._M_data; __p<__a._M_data+__s*__n; __p+=__s, ++__q) \\\n-      *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    inline void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __n, size_t __s,\t\\\n+\t                     _Array<_Tp> __b)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __q(__b._M_data);\t\t\t\t\t\t\\\n+      for (_Tp* __p = __a._M_data; __p < __a._M_data + __s * __n;       \\\n+\t   __p += __s, ++__q)                                           \\\n+        *__p _Op##= *__q;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, _Array<_Tp> __b,\t\t\\\n-\t\t\t size_t __n, size_t __s)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n-    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p, __q+=__s)\t\\\n-      *__p _Op##= *__q;\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    inline void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, _Array<_Tp> __b,\t\t\\\n+\t\t             size_t __n, size_t __s)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __q(__b._M_data);\t\t\t\t\t\t\\\n+      for (_Tp* __p = __a._M_data; __p < __a._M_data + __n;             \\\n+\t   ++__p, __q += __s)                                           \\\n+        *__p _Op##= *__q;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp, class _Dom>\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __s,\t\t\t\\\n-                          const _Expr<_Dom,_Tp>& __e, size_t __n)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n-    for (size_t __i=0; __i<__n; ++__i, __p+=__s) *__p _Op##= __e[__i];\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __s,\t\t\\\n+                             const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __p(__a._M_data);\t\t\t\t\t\t\\\n+      for (size_t __i = 0; __i < __n; ++__i, __p += __s)                \\\n+        *__p _Op##= __e[__i];                                          \t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, _Array<size_t> __i,\t\t\\\n-                          _Array<_Tp> __b, size_t __n)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n-    for (size_t* __j=__i._M_data; __j<__i._M_data+__n; ++__j, ++__q)\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    inline void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, _Array<size_t> __i,\t\\\n+                             _Array<_Tp> __b, size_t __n)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __q(__b._M_data);\t\t\t\t\t\t\\\n+      for (size_t* __j = __i._M_data; __j < __i._M_data + __n;          \\\n+           ++__j, ++__q)                                                \\\n         __a._M_data[*__j] _Op##= *__q;\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-inline void\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n,\t\t\t\\\n-                          _Array<_Tp> __b, _Array<size_t> __i)\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n-    for (size_t* __j=__i._M_data; __j<__i._M_data+__n; ++__j, ++__p)\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    inline void\t\t\t\t\t        \t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __n,\t\t\\\n+                             _Array<_Tp> __b, _Array<size_t> __i)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _Tp* __p(__a._M_data);\t\t\t\t\t\t\\\n+      for (size_t* __j = __i._M_data; __j<__i._M_data + __n;            \\\n+\t   ++__j, ++__p)                                                \\\n         *__p _Op##= __b._M_data[*__j];\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp, class _Dom>\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, _Array<size_t> __i,\t\t\\\n-                          const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    size_t* __j (__i._M_data);\t\t\t\t\t\t\\\n-    for (size_t __k=0; __k<__n; ++__k, ++__j)\t\t\t\t\\\n-      __a._M_data[*__j] _Op##= __e[__k];\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n+  template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, _Array<size_t> __i,\t\\\n+                             const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      size_t* __j(__i._M_data);\t        \t\t\t\t\\\n+      for (size_t __k = 0; __k<__n; ++__k, ++__j)\t\t\t\\\n+        __a._M_data[*__j] _Op##= __e[__k];\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, _Array<bool> __m,\t\t\\\n-                          _Array<_Tp> __b, size_t __n)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    bool* ok (__m._M_data);\t\t\t\t\t\t\\\n-    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n-    for (_Tp* __q=__b._M_data; __q<__b._M_data+__n; ++__q, ++ok, ++__p) { \\\n-        while (! *ok) {\t\t\t\t\t\t\t\\\n-            ++ok;\t\t\t\t\t\t\t\\\n-            ++__p;\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, _Array<bool> __m,         \\\n+                             _Array<_Tp> __b, size_t __n)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bool* __ok(__m._M_data);\t\t\t\t\t\t\\\n+      _Tp* __p(__a._M_data);\t\t\t\t\t\t\\\n+      for (_Tp* __q = __b._M_data; __q < __b._M_data + __n;             \\\n+\t   ++__q, ++__ok, ++__p)                                        \\\n+        {                                                               \\\n+          while (! *__ok)                                               \\\n+            {\t\t\t\t\t\t        \t\\\n+              ++__ok;\t\t\t\t\t\t\t\\\n+              ++__p;\t\t\t\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+          *__p _Op##= *__q;\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n-        *__p _Op##= *__q;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp>\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, size_t __n,\t\t\t\\\n-                         _Array<_Tp> __b, _Array<bool> __m)\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    bool* ok (__m._M_data);\t\t\t\t\t\t\\\n-    _Tp* __q (__b._M_data);\t\t\t\t\t\t\\\n-    for (_Tp* __p=__a._M_data; __p<__a._M_data+__n; ++__p, ++ok, ++__q) { \\\n-        while (! *ok) {\t\t\t\t\t\t\t\\\n-            ++ok;\t\t\t\t\t\t\t\\\n-            ++__q;\t\t\t\t\t\t\t\\\n+  template<typename _Tp>\t\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, size_t __n,\t\t\\\n+                             _Array<_Tp> __b, _Array<bool> __m)   \t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bool* __ok(__m._M_data);\t\t\t\t\t\t\\\n+      _Tp* __q(__b._M_data);\t\t\t\t\t\t\\\n+      for (_Tp* __p = __a._M_data; __p < __a._M_data + __n;             \\\n+\t   ++__p, ++__ok, ++__q)                                        \\\n+        {                                                               \\\n+          while (! *__ok)                                               \\\n+            {\t\t\t\t\t        \t\t\\\n+              ++__ok;\t\t\t\t\t\t\t\\\n+              ++__q;\t\t\t\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+          *__p _Op##= *__q;\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n-        *__p _Op##= *__q;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-template<typename _Tp, class _Dom>\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-_Array_augmented_##_Name (_Array<_Tp> __a, _Array<bool> __m,\t\t\\\n-                          const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    bool* ok(__m._M_data);\t\t\t\t\t\t\\\n-    _Tp* __p (__a._M_data);\t\t\t\t\t\t\\\n-    for (size_t __i=0; __i<__n; ++__i, ++ok, ++__p) {\t\t\t\\\n-        while (! *ok) {\t\t\t\t\t\t\t\\\n-            ++ok;\t\t\t\t\t\t\t\\\n-            ++__p;\t\t\t\t\t\t\t\\\n+  template<typename _Tp, class _Dom>\t\t\t\t\t\\\n+    void\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##_Name(_Array<_Tp> __a, _Array<bool> __m,  \t\\\n+                             const _Expr<_Dom, _Tp>& __e, size_t __n)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      bool* __ok(__m._M_data);\t\t\t\t\t\t\\\n+      _Tp* __p(__a._M_data);\t\t\t\t\t\t\\\n+      for (size_t __i = 0; __i < __n; ++__i, ++__ok, ++__p)             \\\n+        {\t                                           \t\t\\\n+          while (! *__ok)                                               \\\n+            {\t\t         \t\t\t\t\t\\\n+\t      ++__ok;\t\t\t\t\t\t\t\\\n+              ++__p;\t\t\t\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+          *__p _Op##= __e[__i];\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n-        *__p _Op##= __e[__i];\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+    }\n \n    _DEFINE_ARRAY_FUNCTION(+, __plus)\n    _DEFINE_ARRAY_FUNCTION(-, __minus)"}, {"sha": "e1576f07d42cb00449f09f2ffdd0af437e7d286f", "filename": "libstdc++-v3/include/bits/valarray_before.h", "status": "modified", "additions": 133, "deletions": 95, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -1,6 +1,7 @@\n // The template and inlines for the -*- C++ -*- internal _Meta class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -66,85 +67,99 @@ namespace std\n   struct __abs\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return abs(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return abs(__t); }\n   };\n \n   struct __cos\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return cos(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return cos(__t); }\n   };\n \n   struct __acos\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return acos(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return acos(__t); }\n   };\n \n   struct __cosh\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return cosh(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return cosh(__t); }\n   };\n \n   struct __sin\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sin(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return sin(__t); }\n   };\n \n   struct __asin\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return asin(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return asin(__t); }\n   };\n \n   struct __sinh\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sinh(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return sinh(__t); }\n   };\n \n   struct __tan\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return tan(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return tan(__t); }\n   };\n \n   struct __atan\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return atan(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return atan(__t); }\n   };\n \n   struct __tanh\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return tanh(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return tanh(__t); }\n   };\n \n   struct __exp\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return exp(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return exp(__t); }\n   };\n \n   struct __log\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return log(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return log(__t); }\n   };\n \n   struct __log10\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return log10(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return log10(__t); }\n   };\n \n   struct __sqrt\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sqrt(__t); }\n+      _Tp operator()(const _Tp& __t) const\n+      { return sqrt(__t); }\n   };\n \n   // In the past, we used to tailor operator applications semantics\n@@ -154,19 +169,22 @@ namespace std\n   struct __unary_plus\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return +__t; }\n+      _Tp operator()(const _Tp& __t) const\n+      { return +__t; }\n   };\n \n   struct __negate\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return -__t; }\n+      _Tp operator()(const _Tp& __t) const\n+      { return -__t; }\n   };\n \n   struct __bitwise_not\n   {\n     template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return ~__t; }\n+      _Tp operator()(const _Tp& __t) const\n+      { return ~__t; }\n   };\n \n   struct __plus\n@@ -381,9 +399,9 @@ namespace std\n       typedef bool result_type;\n     };\n \n-    //\n-    // Apply function taking a value/const reference closure\n-    //\n+  //\n+  // Apply function taking a value/const reference closure\n+  //\n \n   template<typename _Dom, typename _Arg>\n     class _FunBase\n@@ -392,16 +410,16 @@ namespace std\n       typedef typename _Dom::value_type value_type;\n \n       _FunBase(const _Dom& __e, value_type __f(_Arg))\n-\t: _M_expr(__e), _M_func(__f) {}\n+      : _M_expr(__e), _M_func(__f) {}\n \n       value_type operator[](size_t __i) const\n       { return _M_func (_M_expr[__i]); }\n \n       size_t size() const { return _M_expr.size ();}\n \n     private:\n-        const _Dom& _M_expr;\n-        value_type (*_M_func)(_Arg);\n+      const _Dom& _M_expr;\n+      value_type (*_M_func)(_Arg);\n     };\n \n   template<class _Dom>\n@@ -424,25 +442,26 @@ namespace std\n     };\n \n   template<class _Dom>\n-    struct _RefFunClos<_Expr,_Dom> :\n-        _FunBase<_Dom, const typename _Dom::value_type&>\n+    struct _RefFunClos<_Expr, _Dom>\n+    : _FunBase<_Dom, const typename _Dom::value_type&>\n     {\n       typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;\n       typedef typename _Base::value_type value_type;\n       typedef value_type _Tp;\n \n       _RefFunClos(const _Dom& __e, _Tp __f(const _Tp&))\n-\t: _Base(__e, __f) {}\n+      : _Base(__e, __f) {}\n     };\n \n   template<typename _Tp>\n-    struct _RefFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, const _Tp&>\n+    struct _RefFunClos<_ValArray, _Tp>\n+    : _FunBase<valarray<_Tp>, const _Tp&>\n     {\n       typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;\n       typedef _Tp value_type;\n \n       _RefFunClos(const valarray<_Tp>& __v, _Tp __f(const _Tp&))\n-\t: _Base(__v, __f) {}\n+      : _Base(__v, __f) {}\n     };\n \n   //\n@@ -462,13 +481,14 @@ namespace std\n       { return _Oper()(_M_expr[__i]); }\n \n       size_t size() const { return _M_expr.size(); }\n-\n+      \n     private:\n       const _Arg& _M_expr;\n     };\n \n   template<class _Oper, class _Dom>\n-    struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom>\n+    struct _UnClos<_Oper, _Expr, _Dom>\n+    : _UnBase<_Oper, _Dom>\n     {\n       typedef _Dom _Arg;\n       typedef _UnBase<_Oper, _Dom> _Base;\n@@ -478,7 +498,8 @@ namespace std\n     };\n \n   template<class _Oper, typename _Tp>\n-    struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> >\n+    struct _UnClos<_Oper, _ValArray, _Tp>\n+    : _UnBase<_Oper, valarray<_Tp> >\n     {\n       typedef valarray<_Tp> _Arg;\n       typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n@@ -496,11 +517,11 @@ namespace std\n     class _BinBase\n     {\n     public:\n-        typedef typename _FirstArg::value_type _Vt;\n-        typedef typename __fun<_Oper, _Vt>::result_type value_type;\n+      typedef typename _FirstArg::value_type _Vt;\n+      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n \n       _BinBase(const _FirstArg& __e1, const _SecondArg& __e2)\n-\t: _M_expr1(__e1), _M_expr2(__e2) {}\n+      : _M_expr1(__e1), _M_expr2(__e2) {}\n \n       value_type operator[](size_t __i) const\n       { return _Oper()(_M_expr1[__i], _M_expr2[__i]); }\n@@ -521,7 +542,7 @@ namespace std\n       typedef typename __fun<_Oper, _Vt>::result_type value_type;\n \n       _BinBase2(const _Clos& __e, const _Vt& __t)\n-\t: _M_expr1(__e), _M_expr2(__t) {}\n+      : _M_expr1(__e), _M_expr2(__t) {}\n \n       value_type operator[](size_t __i) const\n       { return _Oper()(_M_expr1[__i], _M_expr2); }\n@@ -541,7 +562,7 @@ namespace std\n       typedef typename __fun<_Oper, _Vt>::result_type value_type;\n \n       _BinBase1(const _Vt& __t, const _Clos& __e)\n-\t: _M_expr1(__t), _M_expr2(__e) {}\n+      : _M_expr1(__t), _M_expr2(__e) {}\n \n       value_type operator[](size_t __i) const\n       { return _Oper()(_M_expr1, _M_expr2[__i]); }\n@@ -555,52 +576,52 @@ namespace std\n \n   template<class _Oper, class _Dom1, class _Dom2>\n     struct _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>\n-        : _BinBase<_Oper,_Dom1,_Dom2>\n+    : _BinBase<_Oper, _Dom1, _Dom2>\n     {\n-      typedef _BinBase<_Oper,_Dom1,_Dom2> _Base;\n+      typedef _BinBase<_Oper, _Dom1, _Dom2> _Base;\n       typedef typename _Base::value_type value_type;\n \n       _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}\n     };\n \n   template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_ValArray,_ValArray,_Tp,_Tp>\n-      : _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> >\n+    struct _BinClos<_Oper,_ValArray, _ValArray, _Tp, _Tp>\n+    : _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> >\n     {\n-      typedef _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > _Base;\n+      typedef _BinBase<_Oper, valarray<_Tp>, valarray<_Tp> > _Base;\n       typedef _Tp value_type;\n \n       _BinClos(const valarray<_Tp>& __v, const valarray<_Tp>& __w)\n-\t: _Base(__v, __w) {}\n+      : _Base(__v, __w) {}\n     };\n \n   template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Expr,_ValArray,_Dom,typename _Dom::value_type>\n-      : _BinBase<_Oper,_Dom,valarray<typename _Dom::value_type> >\n+    struct _BinClos<_Oper, _Expr, _ValArray, _Dom, typename _Dom::value_type>\n+    : _BinBase<_Oper, _Dom, valarray<typename _Dom::value_type> >\n     {\n       typedef typename _Dom::value_type _Tp;\n       typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;\n       typedef typename _Base::value_type value_type;\n \n       _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)\n-\t: _Base(__e1, __e2) {}\n+      : _Base(__e1, __e2) {}\n     };\n \n   template<class _Oper, class _Dom>\n-    struct  _BinClos<_Oper,_ValArray,_Expr,typename _Dom::value_type,_Dom>\n-      : _BinBase<_Oper,valarray<typename _Dom::value_type>,_Dom>\n+    struct _BinClos<_Oper, _ValArray, _Expr, typename _Dom::value_type, _Dom>\n+    : _BinBase<_Oper, valarray<typename _Dom::value_type>,_Dom>\n     {\n       typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase<_Oper,valarray<_Tp>,_Dom> _Base;\n+      typedef _BinBase<_Oper, valarray<_Tp>, _Dom> _Base;\n       typedef typename _Base::value_type value_type;\n \n       _BinClos(const valarray<_Tp>& __e1, const _Dom& __e2)\n-\t: _Base(__e1, __e2) {}\n+      : _Base(__e1, __e2) {}\n     };\n \n   template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Expr,_Constant,_Dom,typename _Dom::value_type>\n-      : _BinBase2<_Oper,_Dom>\n+    struct _BinClos<_Oper, _Expr, _Constant, _Dom, typename _Dom::value_type>\n+    : _BinBase2<_Oper, _Dom>\n     {\n       typedef typename _Dom::value_type _Tp;\n       typedef _BinBase2<_Oper,_Dom> _Base;\n@@ -610,19 +631,19 @@ namespace std\n     };\n \n   template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Constant,_Expr,typename _Dom::value_type,_Dom>\n-      : _BinBase1<_Oper,_Dom>\n+    struct _BinClos<_Oper, _Constant, _Expr, typename _Dom::value_type, _Dom>\n+    : _BinBase1<_Oper, _Dom>\n     {\n       typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase1<_Oper,_Dom> _Base;\n+      typedef _BinBase1<_Oper, _Dom> _Base;\n       typedef typename _Base::value_type value_type;\n \n       _BinClos(const _Tp& __e1, const _Dom& __e2) : _Base(__e1, __e2) {}\n     };\n \n   template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_ValArray,_Constant,_Tp,_Tp>\n-      : _BinBase2<_Oper,valarray<_Tp> >\n+    struct _BinClos<_Oper, _ValArray, _Constant, _Tp, _Tp>\n+    : _BinBase2<_Oper, valarray<_Tp> >\n     {\n       typedef _BinBase2<_Oper,valarray<_Tp> > _Base;\n       typedef typename _Base::value_type value_type;\n@@ -631,69 +652,86 @@ namespace std\n     };\n \n   template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_Constant,_ValArray,_Tp,_Tp>\n-      : _BinBase1<_Oper,valarray<_Tp> >\n+    struct _BinClos<_Oper, _Constant, _ValArray, _Tp, _Tp>\n+    : _BinBase1<_Oper, valarray<_Tp> >\n     {\n-      typedef _BinBase1<_Oper,valarray<_Tp> > _Base;\n+      typedef _BinBase1<_Oper, valarray<_Tp> > _Base;\n       typedef typename _Base::value_type value_type;\n \n       _BinClos(const _Tp& __t, const valarray<_Tp>& __v) : _Base(__t, __v) {}\n     };\n \n-\n     //\n     // slice_array closure.\n     //\n-    template<typename _Dom>  class _SBase {\n+  template<typename _Dom> \n+    class _SBase\n+    {\n     public:\n-        typedef typename _Dom::value_type value_type;\n-\n-        _SBase (const _Dom& __e, const slice& __s)\n-                : _M_expr (__e), _M_slice (__s) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }\n-        size_t size() const { return _M_slice.size (); }\n+      typedef typename _Dom::value_type value_type;\n+      \n+      _SBase (const _Dom& __e, const slice& __s)\n+      : _M_expr (__e), _M_slice (__s) {}\n+        \n+      value_type\n+      operator[] (size_t __i) const\n+      { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }\n+        \n+      size_t\n+      size() const\n+      { return _M_slice.size (); }\n \n     private:\n-        const _Dom& _M_expr;\n-        const slice& _M_slice;\n+      const _Dom& _M_expr;\n+      const slice& _M_slice;\n     };\n \n-    template<typename _Tp> class _SBase<_Array<_Tp> > {\n+  template<typename _Tp>\n+    class _SBase<_Array<_Tp> >\n+    {\n     public:\n-        typedef _Tp value_type;\n-\n-        _SBase (_Array<_Tp> __a, const slice& __s)\n-                : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),\n-                  _M_stride (__s.stride()) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_array._M_data[__i * _M_stride]; }\n-        size_t size() const { return _M_size; }\n+      typedef _Tp value_type;\n+      \n+      _SBase (_Array<_Tp> __a, const slice& __s)\n+      : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),\n+\t_M_stride (__s.stride()) {}\n+        \n+      value_type\n+      operator[] (size_t __i) const\n+      { return _M_array._M_data[__i * _M_stride]; }\n+      \n+      size_t\n+      size() const\n+      { return _M_size; }\n \n     private:\n-        const _Array<_Tp> _M_array;\n-        const size_t _M_size;\n-        const size_t _M_stride;\n+      const _Array<_Tp> _M_array;\n+      const size_t _M_size;\n+      const size_t _M_stride;\n     };\n \n-    template<class _Dom> struct  _SClos<_Expr,_Dom> : _SBase<_Dom> {\n-        typedef _SBase<_Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-\n-        _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}\n+  template<class _Dom>\n+    struct _SClos<_Expr, _Dom>\n+    : _SBase<_Dom>\n+    {\n+      typedef _SBase<_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}\n     };\n \n-    template<typename _Tp>\n-    struct _SClos<_ValArray,_Tp> : _SBase<_Array<_Tp> > {\n-        typedef  _SBase<_Array<_Tp> > _Base;\n-        typedef _Tp value_type;\n-\n-        _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}\n+  template<typename _Tp>\n+    struct _SClos<_ValArray, _Tp>\n+    : _SBase<_Array<_Tp> >\n+    {\n+      typedef  _SBase<_Array<_Tp> > _Base;\n+      typedef _Tp value_type;\n+      \n+      _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}\n     };\n \n } // std::\n \n-\n #endif /* _CPP_VALARRAY_BEFORE_H */\n \n // Local Variables:"}, {"sha": "08ea90971a9935ef4f0f24c517a77f6fd8ce35bc", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b714a4192e2ec903b99d1d8a7c664fab099f4908/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=b714a4192e2ec903b99d1d8a7c664fab099f4908", "patch": "@@ -147,7 +147,8 @@ namespace std\n       valarray(const indirect_array<_Tp>&);\n \n       template<class _Dom>\n-\tvalarray(const _Expr<_Dom,_Tp>& __e);\n+\tvalarray(const _Expr<_Dom, _Tp>& __e);\n+\n       ~valarray();\n \n       // _lib.valarray.assign_ assignment:\n@@ -211,7 +212,7 @@ namespace std\n       valarray<_Tp>& operator=(const indirect_array<_Tp>&);\n \n       template<class _Dom> valarray<_Tp>&\n-\toperator= (const _Expr<_Dom,_Tp>&);\n+\toperator= (const _Expr<_Dom, _Tp>&);\n \n       // _lib.valarray.access_ element access:\n       /**\n@@ -237,7 +238,7 @@ namespace std\n        *  @param  s  The source slice.\n        *  @return  New valarray containing elements in @a s.\n        */\n-      _Expr<_SClos<_ValArray,_Tp>, _Tp> operator[](slice) const;\n+      _Expr<_SClos<_ValArray, _Tp>, _Tp> operator[](slice) const;\n \n       /**\n        *  @brief  Return a reference to an array subset.\n@@ -260,7 +261,7 @@ namespace std\n        *  @param  s  The source slice.\n        *  @return  Slice_array referencing elements indicated by @a s.\n        */\n-      _Expr<_GClos<_ValArray,_Tp>, _Tp> operator[](const gslice&) const;\n+      _Expr<_GClos<_ValArray, _Tp>, _Tp> operator[](const gslice&) const;\n \n       /**\n        *  @brief  Return a reference to an array subset.\n@@ -286,7 +287,7 @@ namespace std\n        *  @param  m  The valarray bitmask.\n        *  @return  New valarray containing elements indicated by @a m.\n        */\n-      valarray<_Tp>     \t operator[](const valarray<bool>&) const;\n+      valarray<_Tp>       operator[](const valarray<bool>&) const;\n \n       /**\n        *  @brief  Return a reference to an array subset.\n@@ -405,26 +406,25 @@ namespace std\n       valarray<_Tp>& operator>>=(const valarray<_Tp>&);\n \n       template<class _Dom>\n-\tvalarray<_Tp>& operator*=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator*=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator/=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator/=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator%=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator%=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator+=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator+=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator-=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator-=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator^=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator^=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator|=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator|=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator&=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator&=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-      valarray<_Tp>& operator<<=(const _Expr<_Dom,_Tp>&);\n+        valarray<_Tp>& operator<<=(const _Expr<_Dom, _Tp>&);\n       template<class _Dom>\n-\tvalarray<_Tp>& operator>>=(const _Expr<_Dom,_Tp>&);\n-\n+\tvalarray<_Tp>& operator>>=(const _Expr<_Dom, _Tp>&);\n \n       // _lib.valarray.members_ member functions:\n       ///  Return the number of elements in array.\n@@ -444,9 +444,6 @@ namespace std\n       ///  Return the maximum element using operator<().\n       _Tp    max() const;\t\n \n-  //           // FIXME: Extension\n-  //       _Tp    product () const;\n-\n       /**\n        *  @brief  Return a shifted array.\n        *\n@@ -491,7 +488,7 @@ namespace std\n        *  @param  func  Function of Tp returning Tp to apply.\n        *  @return  New valarray with transformed elements.\n        */\n-      _Expr<_ValFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(_Tp)) const;\n+      _Expr<_ValFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(_Tp)) const;\n \n       /**\n        *  @brief  Apply a function to the array.\n@@ -503,7 +500,7 @@ namespace std\n        *  @param  func  Function of const Tp& returning Tp to apply.\n        *  @return  New valarray with transformed elements.\n        */\n-      _Expr<_RefFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(const _Tp&)) const;\n+      _Expr<_RefFunClos<_ValArray, _Tp>, _Tp> apply(_Tp func(const _Tp&)) const;\n \n       /**\n        *  @brief  Resize array.\n@@ -528,15 +525,15 @@ namespace std\n     valarray<_Tp>::operator[](size_t __i) const\n     { \n       __glibcxx_requires_subscript(__i);\n-      return _M_data[__i]; \n+      return _M_data[__i];\n     }\n \n   template<typename _Tp>\n     inline _Tp&\n     valarray<_Tp>::operator[](size_t __i)\n     { \n       __glibcxx_requires_subscript(__i);\n-      return _M_data[__i]; \n+      return _M_data[__i];\n     }\n \n } // std::\n@@ -558,19 +555,19 @@ namespace std\n   template<typename _Tp>\n     inline \n     valarray<_Tp>::valarray(size_t __n) \n-\t: _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n     { std::__valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const _Tp& __t, size_t __n)\n-      : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n     { std::__valarray_fill_construct(_M_data, _M_data + __n, __t); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)\n-      : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n     { \n       _GLIBCXX_DEBUG_ASSERT(__p != 0 || __n == 0);\n       std::__valarray_copy_construct(__p, __p + __n, _M_data); \n@@ -579,13 +576,14 @@ namespace std\n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const valarray<_Tp>& __v)\n-      : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n-    { std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size, _M_data); }\n+    : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n+    { std::__valarray_copy_construct(__v._M_data, __v._M_data + _M_size,\n+\t\t\t\t     _M_data); }\n \n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const slice_array<_Tp>& __sa)\n-      : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n+    : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n     {\n       std::__valarray_copy\n \t(__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));\n@@ -594,8 +592,8 @@ namespace std\n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const gslice_array<_Tp>& __ga)\n-      : _M_size(__ga._M_index.size()),\n-\t_M_data(__valarray_get_storage<_Tp>(_M_size))\n+    : _M_size(__ga._M_index.size()),\n+      _M_data(__valarray_get_storage<_Tp>(_M_size))\n     {\n       std::__valarray_copy\n \t(__ga._M_array, _Array<size_t>(__ga._M_index),\n@@ -605,7 +603,7 @@ namespace std\n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const mask_array<_Tp>& __ma)\n-      : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n+    : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n     {\n       std::__valarray_copy\n \t(__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);\n@@ -614,7 +612,7 @@ namespace std\n   template<typename _Tp>\n     inline\n     valarray<_Tp>::valarray(const indirect_array<_Tp>& __ia)\n-      : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))\n+    : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))\n     {\n       std::__valarray_copy\n \t(__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);\n@@ -623,7 +621,7 @@ namespace std\n   template<typename _Tp> template<class _Dom>\n     inline\n     valarray<_Tp>::valarray(const _Expr<_Dom, _Tp>& __e)\n-      : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))\n+    : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))\n     { std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data)); }\n \n   template<typename _Tp>\n@@ -711,9 +709,7 @@ namespace std\n   template<typename _Tp>\n     inline slice_array<_Tp>\n     valarray<_Tp>::operator[](slice __s)\n-    {\n-      return slice_array<_Tp>(_Array<_Tp>(_M_data), __s);\n-    }\n+    { return slice_array<_Tp>(_Array<_Tp>(_M_data), __s); }\n \n   template<typename _Tp>\n     inline _Expr<_GClos<_ValArray,_Tp>, _Tp>\n@@ -784,13 +780,6 @@ namespace std\n       return std::__valarray_sum(_M_data, _M_data + _M_size);\n     }\n \n-//   template<typename _Tp>\n-//   inline _Tp\n-//   valarray<_Tp>::product () const\n-//   {\n-//       return __valarray_product(_M_data, _M_data + _M_size);\n-//   }\n-\n   template <class _Tp>\n      inline valarray<_Tp>\n      valarray<_Tp>::shift(int __n) const\n@@ -805,16 +794,19 @@ namespace std\n              std::__valarray_default_construct(__a, __a + __n);\n            else\n              {\n-               std::__valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n-               std::__valarray_default_construct(__a+_M_size-__n, __a + _M_size);\n+               std::__valarray_copy_construct(_M_data + __n,\n+\t\t\t\t\t      _M_data + _M_size, __a);\n+               std::__valarray_default_construct(__a + _M_size -__n,\n+\t\t\t\t\t\t __a + _M_size);\n              }\n          }\n        else                        // __n < 0: shift right\n          {                          \n-           std::__valarray_copy_construct (_M_data, _M_data+_M_size+__n, __a-__n);\n+           std::__valarray_copy_construct (_M_data, _M_data + _M_size + __n,\n+\t\t\t\t\t   __a - __n);\n            std::__valarray_default_construct(__a, __a - __n);\n          }\n-       return valarray<_Tp> (__a, _M_size);\n+       return valarray<_Tp>(__a, _M_size);\n      }\n \n   template <class _Tp>\n@@ -827,13 +819,15 @@ namespace std\n          std::__valarray_copy_construct(_M_data, _M_data + _M_size, __a);\n        else if (__n > 0)           // cshift left\n          {               \n-           std::__valarray_copy_construct(_M_data, _M_data+__n, __a+_M_size-__n);\n-           std::__valarray_copy_construct(_M_data+__n, _M_data + _M_size, __a);\n+           std::__valarray_copy_construct(_M_data, _M_data + __n,\n+\t\t\t\t\t  __a + _M_size - __n);\n+           std::__valarray_copy_construct(_M_data + __n, _M_data + _M_size,\n+\t\t\t\t\t  __a);\n          }\n        else                        // cshift right\n          {                       \n            std::__valarray_copy_construct\n-             (_M_data + _M_size+__n, _M_data + _M_size, __a);\n+             (_M_data + _M_size + __n, _M_data + _M_size, __a);\n            std::__valarray_copy_construct\n              (_M_data, _M_data + _M_size+__n, __a - __n);\n          }\n@@ -862,42 +856,42 @@ namespace std\n     valarray<_Tp>::min() const\n     {\n       _GLIBCXX_DEBUG_ASSERT(_M_size > 0);\n-      return *std::min_element (_M_data, _M_data+_M_size);\n+      return *std::min_element(_M_data, _M_data+_M_size);\n     }\n \n   template<typename _Tp>\n     inline _Tp\n     valarray<_Tp>::max() const\n     {\n       _GLIBCXX_DEBUG_ASSERT(_M_size > 0);\n-      return *std::max_element (_M_data, _M_data+_M_size);\n+      return *std::max_element(_M_data, _M_data+_M_size);\n     }\n   \n   template<class _Tp>\n-    inline _Expr<_ValFunClos<_ValArray,_Tp>,_Tp>\n+    inline _Expr<_ValFunClos<_ValArray, _Tp>, _Tp>\n     valarray<_Tp>::apply(_Tp func(_Tp)) const\n     {\n-      typedef _ValFunClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure,_Tp>(_Closure(*this, func));\n+      typedef _ValFunClos<_ValArray, _Tp> _Closure;\n+      return _Expr<_Closure, _Tp>(_Closure(*this, func));\n     }\n \n   template<class _Tp>\n-    inline _Expr<_RefFunClos<_ValArray,_Tp>,_Tp>\n+    inline _Expr<_RefFunClos<_ValArray, _Tp>, _Tp>\n     valarray<_Tp>::apply(_Tp func(const _Tp &)) const\n     {\n-      typedef _RefFunClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure,_Tp>(_Closure(*this, func));\n+      typedef _RefFunClos<_ValArray, _Tp> _Closure;\n+      return _Expr<_Closure, _Tp>(_Closure(*this, func));\n     }\n \n #define _DEFINE_VALARRAY_UNARY_OPERATOR(_Op, _Name)                     \\\n   template<typename _Tp>\t\t\t\t\t\t\\\n-  inline typename valarray<_Tp>::template _UnaryOp<_Name>::_Rt         \t\\\n-  valarray<_Tp>::operator _Op() const\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    typedef _UnClos<_Name,_ValArray,_Tp> _Closure;\t                \\\n-    typedef typename __fun<_Name, _Tp>::result_type _Rt;                \\\n-    return _Expr<_Closure, _Rt>(_Closure(*this));\t\t\t\\\n-  }\n+    inline typename valarray<_Tp>::template _UnaryOp<_Name>::_Rt      \t\\\n+    valarray<_Tp>::operator _Op() const\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      typedef _UnClos<_Name, _ValArray, _Tp> _Closure;\t                \\\n+      typedef typename __fun<_Name, _Tp>::result_type _Rt;              \\\n+      return _Expr<_Closure, _Rt>(_Closure(*this));\t\t\t\\\n+    }\n \n     _DEFINE_VALARRAY_UNARY_OPERATOR(+, __unary_plus)\n     _DEFINE_VALARRAY_UNARY_OPERATOR(-, __negate)\n@@ -941,7 +935,7 @@ _DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(>>, __shift_right)\n #define _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(_Op, _Name)          \\\n   template<class _Tp> template<class _Dom>\t\t\t\t\\\n     inline valarray<_Tp>&\t\t\t\t\t\t\\\n-    valarray<_Tp>::operator _Op##=(const _Expr<_Dom,_Tp>& __e)\t\t\\\n+    valarray<_Tp>::operator _Op##=(const _Expr<_Dom, _Tp>& __e)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       _Array_augmented_##_Name(_Array<_Tp>(_M_data), __e, _M_size);\t\\\n       return *this;\t\t\t\t\t\t\t\\\n@@ -963,35 +957,35 @@ _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(>>, __shift_right)\n \n #define _DEFINE_BINARY_OPERATOR(_Op, _Name)\t\t\t\t\\\n   template<typename _Tp>\t\t\t\t\t\t\\\n-    inline _Expr<_BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp>,           \\\n+    inline _Expr<_BinClos<_Name, _ValArray, _ValArray, _Tp, _Tp>,       \\\n                  typename __fun<_Name, _Tp>::result_type>               \\\n     operator _Op(const valarray<_Tp>& __v, const valarray<_Tp>& __w)\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       _GLIBCXX_DEBUG_ASSERT(__v.size() == __w.size());                  \\\n-      typedef _BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp> _Closure;     \\\n+      typedef _BinClos<_Name, _ValArray, _ValArray, _Tp, _Tp> _Closure; \\\n       typedef typename __fun<_Name, _Tp>::result_type _Rt;              \\\n       return _Expr<_Closure, _Rt>(_Closure(__v, __w));                  \\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   template<typename _Tp>\t\t\t\t\t\t\\\n-  inline _Expr<_BinClos<_Name,_ValArray,_Constant,_Tp,_Tp>,             \\\n-               typename __fun<_Name, _Tp>::result_type>                 \\\n-  operator _Op(const valarray<_Tp>& __v, const _Tp& __t)\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    typedef _BinClos<_Name,_ValArray,_Constant,_Tp,_Tp> _Closure;\t\\\n-    typedef typename __fun<_Name, _Tp>::result_type _Rt;                \\\n-    return _Expr<_Closure, _Rt>(_Closure(__v, __t));\t                \\\n-  }\t\t\t\t\t\t\t\t\t\\\n+    inline _Expr<_BinClos<_Name, _ValArray,_Constant, _Tp, _Tp>,        \\\n+                 typename __fun<_Name, _Tp>::result_type>               \\\n+    operator _Op(const valarray<_Tp>& __v, const _Tp& __t)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name, _ValArray, _Constant, _Tp, _Tp> _Closure;\t\\\n+      typedef typename __fun<_Name, _Tp>::result_type _Rt;              \\\n+      return _Expr<_Closure, _Rt>(_Closure(__v, __t));\t                \\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   template<typename _Tp>\t\t\t\t\t\t\\\n-  inline _Expr<_BinClos<_Name,_Constant,_ValArray,_Tp,_Tp>,             \\\n-               typename __fun<_Name, _Tp>::result_type>                 \\\n-  operator _Op(const _Tp& __t, const valarray<_Tp>& __v)\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    typedef _BinClos<_Name,_Constant,_ValArray,_Tp,_Tp> _Closure;       \\\n-    typedef typename __fun<_Name, _Tp>::result_type _Rt;                \\\n-    return _Expr<_Closure, _Tp>(_Closure(__t, __v));        \t        \\\n-  }\n+    inline _Expr<_BinClos<_Name, _Constant, _ValArray, _Tp, _Tp>,       \\\n+                 typename __fun<_Name, _Tp>::result_type>               \\\n+    operator _Op(const _Tp& __t, const valarray<_Tp>& __v)\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      typedef _BinClos<_Name, _Constant, _ValArray, _Tp, _Tp> _Closure; \\\n+      typedef typename __fun<_Name, _Tp>::result_type _Rt;              \\\n+      return _Expr<_Closure, _Tp>(_Closure(__t, __v));        \t        \\\n+    }\n \n _DEFINE_BINARY_OPERATOR(+, __plus)\n _DEFINE_BINARY_OPERATOR(-, __minus)"}]}