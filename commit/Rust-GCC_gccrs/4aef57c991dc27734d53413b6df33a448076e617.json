{"sha": "4aef57c991dc27734d53413b6df33a448076e617", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFlZjU3Yzk5MWRjMjc3MzRkNTM0MTNiNmRmMzNhNDQ4MDc2ZTYxNw==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-07-01T19:19:39Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-07-01T19:19:39Z"}, "message": "Add -mgnu-asm; change -mdec-asm to generate DEC assembler\n        compatible output.\n\n\t* common/config/pdp11/pdp11-common.c (pdp11_handle_option): Handle\n\t-munit-asm, -mgnu-asm, -mdec-asm.\n\t* config/pdp11/pdp11-protos.h (pdp11_gen_int_label): New.\n\t(pdp11_output_labelref): New.\n\t(pdp11_output_def): New.\n\t(pdp11_output_addr_vec_elt): New.\n\t* config/pdp11/pdp11.c: Use tab between opcode and operands.  Use\n\t%# and %@ format codes.\n\t(pdp11_option_override): New.\n\t(TARGET_ASM_FILE_START_FILE_DIRECTIVE): Define.\n\t(pdp11_output_ident): New.\n\t(pdp11_asm_named_section): New.\n\t(pdp11_asm_init_sections): New.\n\t(pdp11_file_start): New.\n\t(pdp11_file_end): New.\n\t(output_ascii): Use .ascii/.asciz for -mdec-asm.\n\t(pdp11_asm_print_operand): Update %# and %$ for -mdec-asm.  Add\n\t%o, like %c but octal.\n\t(pdp11_option_override): New.\n\t* config/pdp11/pdp11.h (TEXT_SECTION_ASM_OP): Update for\n\t-mdec-asm.\n\t(DATA_SECTION_ASM_OP): Ditto.\n\t(READONLY_DATA_SECTION_ASM_OP): New.\n\t(IS_ASM_LOGICAL_LINE_SEPARATOR): New.\n\t(ASM_GENERATE_INTERNAL_LABEL): Use new function.\n\t(ASM_OUTPUT_LABELREF): Ditto.\n\t(ASM_OUTPUT_DEF): Ditto.\n\t(ASM_OUTPUT_EXTERNAL): New.\n\t(ASM_OUTPUT_SOURCE_FILENAME): New.\n\t(ASM_OUTPUT_ADDR_VEC_ELT): Use new function.\n\t(ASM_OUTPUT_SKIP): Update for -mdec-asm.\n\t* config/pdp11/pdp11.md: Use tab between opcode and operands.  Use\n\t%# and %@ format codes.\n\t* config/pdp11/pdp11.opt (mgnu-asm): New.\n\t(mdec-asm): Conflicts with -mgnu-asm and -munix-asm.\n\t(munix-asm): Conflicts with -mdec-asm and -mgnu-asm.\n\t* doc/invoke.txt (PDP-11 Options): Add -mgnu-asm.\n\nFrom-SVN: r262289", "tree": {"sha": "de1e7ac89f0e6d95b98f24e5c54bfe66ffb270d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de1e7ac89f0e6d95b98f24e5c54bfe66ffb270d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4aef57c991dc27734d53413b6df33a448076e617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aef57c991dc27734d53413b6df33a448076e617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aef57c991dc27734d53413b6df33a448076e617", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aef57c991dc27734d53413b6df33a448076e617/comments", "author": null, "committer": null, "parents": [{"sha": "518ab2a0ecc0c3cacb73d8e054e71b78c492e36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518ab2a0ecc0c3cacb73d8e054e71b78c492e36b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518ab2a0ecc0c3cacb73d8e054e71b78c492e36b"}], "stats": {"total": 711, "additions": 501, "deletions": 210}, "files": [{"sha": "26dfb8589397939180327c15ee6f27c74f5018ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -1,3 +1,43 @@\n+2018-07-01  Paul Koning  <ni1d@arrl.net>\n+\n+\t* common/config/pdp11/pdp11-common.c (pdp11_handle_option): Handle\n+\t-munit-asm, -mgnu-asm, -mdec-asm.\n+\t* config/pdp11/pdp11-protos.h (pdp11_gen_int_label): New.\n+\t(pdp11_output_labelref): New.\n+\t(pdp11_output_def): New.\n+\t(pdp11_output_addr_vec_elt): New.\n+\t* config/pdp11/pdp11.c: Use tab between opcode and operands.  Use\n+\t%# and %@ format codes.\n+\t(pdp11_option_override): New.\n+\t(TARGET_ASM_FILE_START_FILE_DIRECTIVE): Define.\n+\t(pdp11_output_ident): New.\n+\t(pdp11_asm_named_section): New.\n+\t(pdp11_asm_init_sections): New.\n+\t(pdp11_file_start): New.\n+\t(pdp11_file_end): New.\n+\t(output_ascii): Use .ascii/.asciz for -mdec-asm.\n+\t(pdp11_asm_print_operand): Update %# and %$ for -mdec-asm.  Add\n+\t%o, like %c but octal.\n+\t(pdp11_option_override): New.\n+\t* config/pdp11/pdp11.h (TEXT_SECTION_ASM_OP): Update for\n+\t-mdec-asm.\n+\t(DATA_SECTION_ASM_OP): Ditto.\n+\t(READONLY_DATA_SECTION_ASM_OP): New.\n+\t(IS_ASM_LOGICAL_LINE_SEPARATOR): New.\n+\t(ASM_GENERATE_INTERNAL_LABEL): Use new function.\n+\t(ASM_OUTPUT_LABELREF): Ditto.\n+\t(ASM_OUTPUT_DEF): Ditto.\n+\t(ASM_OUTPUT_EXTERNAL): New.\n+\t(ASM_OUTPUT_SOURCE_FILENAME): New.\n+\t(ASM_OUTPUT_ADDR_VEC_ELT): Use new function.\n+\t(ASM_OUTPUT_SKIP): Update for -mdec-asm.\n+\t* config/pdp11/pdp11.md: Use tab between opcode and operands.  Use\n+\t%# and %@ format codes.\n+\t* config/pdp11/pdp11.opt (mgnu-asm): New.\n+\t(mdec-asm): Conflicts with -mgnu-asm and -munix-asm.\n+\t(munix-asm): Conflicts with -mdec-asm and -mgnu-asm.\n+\t* doc/invoke.txt (PDP-11 Options): Add -mgnu-asm.\n+\n 2018-07-01  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* tree-ssa-threadupdate.c (mark_threaded_blocks): Avoid"}, {"sha": "a6fdbc3ec48b995582ec71510ec3554735c8d3e6", "filename": "gcc/common/config/pdp11/pdp11-common.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -59,7 +59,16 @@ pdp11_handle_option (struct gcc_options *opts,\n       opts->x_target_flags &= ~MASK_40;\n       opts->x_target_flags |= MASK_45;\n       return true;\n-      \n+\n+    case OPT_munix_asm:\n+    case OPT_mgnu_asm:\n+      targetm_common.have_named_sections = false;\n+      return true;\n+\n+    case OPT_mdec_asm:\n+      targetm_common.have_named_sections = true;\n+      return true;\n+\n     default:\n       return true;\n     }"}, {"sha": "0ce72fdc3f7d3729f2ffc8579b6cbd90bd85c37d", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -51,3 +51,7 @@ extern void pdp11_asm_output_var (FILE *, const char *, int, int, bool);\n extern void pdp11_expand_prologue (void);\n extern void pdp11_expand_epilogue (void);\n extern poly_int64 pdp11_push_rounding (poly_int64);\n+extern void pdp11_gen_int_label (char *, const char *, int);\n+extern void pdp11_output_labelref (FILE *, const char *);\n+extern void pdp11_output_def (FILE *, const char *, const char *);\n+extern void pdp11_output_addr_vec_elt (FILE *, int);"}, {"sha": "bb29ce9b5370bf322cfcc71b32cda2f1677756f8", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 266, "deletions": 69, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -212,7 +212,7 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n #undef  TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n #define TARGET_PREFERRED_OUTPUT_RELOAD_CLASS pdp11_preferred_output_reload_class\n \n-#undef TARGET_LRA_P\n+#undef  TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n \n #undef  TARGET_LEGITIMATE_ADDRESS_P\n@@ -221,9 +221,30 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n #undef  TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE pdp11_conditional_register_usage\n \n+#undef  TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE pdp11_option_override\n+\n+#undef  TARGET_ASM_FILE_START_FILE_DIRECTIVE\n+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n+\n+#undef  TARGET_ASM_OUTPUT_IDENT\n+#define TARGET_ASM_OUTPUT_IDENT pdp11_output_ident\n+\n #undef  TARGET_ASM_FUNCTION_SECTION\n #define TARGET_ASM_FUNCTION_SECTION pdp11_function_section\n \n+#undef  TARGET_ASM_NAMED_SECTION\n+#define\tTARGET_ASM_NAMED_SECTION pdp11_asm_named_section\n+\n+#undef  TARGET_ASM_INIT_SECTIONS\n+#define TARGET_ASM_INIT_SECTIONS pdp11_asm_init_sections\n+\n+#undef  TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START pdp11_file_start\n+\n+#undef  TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END pdp11_file_end\n+\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND pdp11_asm_print_operand\n \n@@ -238,6 +259,7 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_HARD_REGNO_NREGS\n #define TARGET_HARD_REGNO_NREGS pdp11_hard_regno_nregs\n+\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK pdp11_hard_regno_mode_ok\n \n@@ -477,9 +499,9 @@ static const char *\n singlemove_string (rtx *operands)\n {\n   if (operands[1] != const0_rtx)\n-    return \"mov %1,%0\";\n+    return \"mov\\t%1,%0\";\n \n-  return \"clr %0\";\n+  return \"clr\\t%0\";\n }\n \n \f\n@@ -664,12 +686,12 @@ output_move_multiple (rtx *operands)\n   if (action[0] == dec_before)\n     {\n       operands[0] = XEXP (operands[0], 0);\n-      output_asm_insn (\"sub $4,%0\", operands);\n+      output_asm_insn (\"sub\\t%#4,%0\", operands);\n     }\n   if (action[1] == dec_before)\n     {\n       operands[1] = XEXP (operands[1], 0);\n-      output_asm_insn (\"sub $4,%1\", operands);\n+      output_asm_insn (\"sub\\t%#4,%1\", operands);\n     }\n \n   /* Do the words.  */\n@@ -680,63 +702,115 @@ output_move_multiple (rtx *operands)\n   if (action[0] == inc_after)\n     {\n       operands[0] = XEXP (operands[0], 0);\n-      output_asm_insn (\"add $4,%0\", operands);\n+      output_asm_insn (\"add\\t%#4,%0\", operands);\n     }\n   if (action[1] == inc_after)\n     {\n       operands[1] = XEXP (operands[1], 0);\n-      output_asm_insn (\"add $4,%1\", operands);\n+      output_asm_insn (\"add\\t%#4,%1\", operands);\n     }\n \n   return \"\";\n }\n \f\n+/* Build an internal label.  */\n+void\n+pdp11_gen_int_label (char *label, const char *prefix, int num)\n+{\n+  if (TARGET_DEC_ASM)\n+    /* +1 because GCC numbers labels starting at zero.  */\n+    sprintf (label, \"*%lu$\", num + 1);\n+  else\n+    sprintf (label, \"*%s_%lu\", prefix, num);\n+}\n+  \n /* Output an ascii string.  */\n void\n output_ascii (FILE *file, const char *p, int size)\n {\n-  int i;\n-\n-  /* This used to output .byte \"string\", which doesn't work with the UNIX\n-     assembler and I think not with DEC ones either.  */\n-  fprintf (file, \"\\t.byte \");\n-\n-  for (i = 0; i < size; i++)\n+  int i, c;\n+  const char *pseudo = \"\\t.ascii\\t\";\n+  bool delim = false;\n+  \n+  if (TARGET_DEC_ASM)\n+    {\n+      if (p[size - 1] == '\\0')\n+\t{\n+\t  pseudo = \"\\t.asciz\\t\";\n+\t  size--;\n+\t}\n+      fputs (pseudo, file);\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  c = *p++ & 0xff;\n+\t  if (c < 32 || c == '\"' || c > 126)\n+\t    {\n+\t      if (delim)\n+\t\tputc ('\"', file);\n+\t      fprintf (file, \"<%o%>\", c);\n+\t      delim = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!delim)\n+\t\tputc ('\"', file);\n+\t      delim = true;\n+\t      putc (c, file);\n+\t    }\n+\t}\n+      if (delim)\n+\tputc ('\"', file);\n+      putc ('\\n', file);\n+    }\n+  else\n     {\n-      register int c = p[i];\n-      if (c < 0)\n-\tc += 256;\n-      fprintf (file, \"%#o\", c);\n-      if (i < size - 1)\n-\tputc (',', file);\n+      fprintf (file, \"\\t.byte \");\n+\n+      for (i = 0; i < size; i++)\n+\t{\n+\t  fprintf (file, \"%#o\", *p++ & 0xff);\n+\t  if (i < size - 1)\n+\t    putc (',', file);\n+\t}\n+      putc ('\\n', file);\n     }\n-  putc ('\\n', file);\n }\n \n-\n void\n pdp11_asm_output_var (FILE *file, const char *name, int size,\n \t\t      int align, bool global)\n {\n   if (align > 8)\n-    fprintf (file, \"\\n\\t.even\\n\");\n+    fprintf (file, \"\\t.even\\n\");\n   if (global)\n     {\n       fprintf (file, \".globl \");\n       assemble_name (file, name);\n     }\n   fprintf (file, \"\\n\");\n   assemble_name (file, name);\n-  fprintf (file, \": .=.+ %#ho\\n\", (unsigned short)size);\n+  fputs (\":\", file);\n+  ASM_OUTPUT_SKIP (file, size);\n }\n \n+/* Special format operators handled here:\n+   # -- output the correct immediate operand marker for the assembler\n+        dialect.\n+   @ -- output the correct indirect marker for the assembler dialect.\n+   o -- emit a constant value as a number (not an immediate operand)\n+        in octal.  */\n static void\n pdp11_asm_print_operand (FILE *file, rtx x, int code)\n {\n   long sval[2];\n  \n   if (code == '#')\n-    fprintf (file, \"#\");\n+    {\n+      if (TARGET_DEC_ASM)\n+\tputc ('#', file);\n+      else\n+\tputc ('$', file);\n+    }\n   else if (code == '@')\n     {\n       if (TARGET_UNIX_ASM)\n@@ -751,11 +825,20 @@ pdp11_asm_print_operand (FILE *file, rtx x, int code)\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != SImode)\n     {\n       REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (x), sval);\n-      fprintf (file, \"$%#lo\", sval[0] >> 16);\n+      if (TARGET_DEC_ASM)\n+\tfprintf (file, \"#%lo\", (sval[0] >> 16) & 0xffff);\n+      else\n+\tfprintf (file, \"$%#lo\", (sval[0] >> 16) & 0xffff);\n     }\n   else\n     {\n-      putc ('$', file);\n+      if (code != 'o')\n+\t{\n+\t  if (TARGET_DEC_ASM)\n+\t    putc ('#', file);\n+\t  else\n+\t    putc ('$', file);\n+\t}\n       output_addr_const_pdp11 (file, x);\n     }\n }\n@@ -851,7 +934,9 @@ print_operand_address (FILE *file, register rtx addr)\n       if (!again && GET_CODE (addr) == CONST_INT)\n \t{\n \t  /* Absolute (integer number) address.  */\n-\t  if (!TARGET_UNIX_ASM)\n+\t  if (TARGET_DEC_ASM)\n+\t    fprintf (file, \"@#\");\n+\t  else if (!TARGET_UNIX_ASM)\n \t    fprintf (file, \"@$\");\n \t}\n       output_addr_const_pdp11 (file, addr);\n@@ -1088,13 +1173,13 @@ output_jump (rtx *operands, int ccnz, int length)\n   switch (length)\n     {\n     case 2:\n-      sprintf (buf, \"%s %%l1\", pos);\n+      sprintf (buf, \"%s\\t%%l1\", pos);\n       return buf;\n     case 6:\n       tmpop[0] = gen_label_rtx ();\n-      sprintf (buf, \"%s %%l0\", neg);\n+      sprintf (buf, \"%s\\t%%l0\", neg);\n       output_asm_insn (buf, tmpop);\n-      output_asm_insn (\"jmp %l1\", operands);\n+      output_asm_insn (\"jmp\\t%l1\", operands);\n       output_asm_label (tmpop[0]);\n       fputs (\":\\n\", asm_out_file);\n       return \"\";\n@@ -1290,7 +1375,7 @@ output_block_move(rtx *operands)\n \t    register int i;\n \t    \n \t    for (i = 1; i <= INTVAL (operands[2]); i++)\n-\t\toutput_asm_insn(\"movb (%1)+, (%0)+\", operands);\n+\t\toutput_asm_insn(\"movb\\t(%1)+,(%0)+\", operands);\n \n \t    return \"\";\n \t}\n@@ -1301,9 +1386,9 @@ output_block_move(rtx *operands)\n \t    register int i;\n \t    \n \t    for (i = 1; i <= INTVAL (operands[2]) / 2; i++)\n-\t\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\t\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n \t    if (INTVAL (operands[2]) & 1)\n-\t      output_asm_insn (\"movb (%1), (%0)\", operands);\n+\t      output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n \t    \n \t    return \"\";\n \t}\n@@ -1335,7 +1420,7 @@ output_block_move(rtx *operands)\n       \n       /* Loop count is byte count scaled by unroll.  */\n       operands[2] = GEN_INT (INTVAL (operands[2]) >> unroll);\n-      output_asm_insn (\"mov %2, %4\", operands);\n+      output_asm_insn (\"mov\\t%2,%4\", operands);\n     }\n     else\n     {\n@@ -1348,12 +1433,12 @@ output_block_move(rtx *operands)\n \tif (TARGET_40_PLUS && INTVAL (operands[3]) > 1)\n \t  {\n \t    unroll = 1;\n-\t    output_asm_insn (\"asr %4\", operands);\n+\t    output_asm_insn (\"asr\\t%4\", operands);\n \t  }\n \telse\n \t  {\n \t    unroll = 0;\n-\t    output_asm_insn (\"tst %4\", operands);\n+\t    output_asm_insn (\"tst\\t%4\", operands);\n \t  }\n \tsprintf (buf, \"beq movestrhi%d\", count + 1);\n \toutput_asm_insn (buf, NULL);\n@@ -1367,43 +1452,43 @@ output_block_move(rtx *operands)\n     switch (unroll)\n     {\n       case 0:\n-\toutput_asm_insn (\"movb (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"movb\\t(%1)+,(%0)+\", operands);\n \tbreak;\n \t\n       case 1:\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n \tbreak;\n \t\n       case 2:\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n \tbreak;\n \t\n       default:\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n-\toutput_asm_insn (\"mov (%1)+, (%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n+\toutput_asm_insn (\"mov\\t(%1)+,(%0)+\", operands);\n \tbreak;\n     }\n \n     /* Output the decrement and test.  */\n     if (TARGET_40_PLUS)\n       {\n-\tsprintf (buf, \"sob %%4, movestrhi%d\", count);\n+\tsprintf (buf, \"sob\\t%%4, movestrhi%d\", count);\n \toutput_asm_insn (buf, operands);\n       }\n     else\n       {\n-\toutput_asm_insn (\"dec %4\", operands);\n+\toutput_asm_insn (\"dec\\t%4\", operands);\n \tsprintf (buf, \"bgt movestrhi%d\", count);\n \toutput_asm_insn (buf, NULL);\n       }\n     count ++;\n \n     /* If constant odd byte count, move the last byte.  */\n     if (lastbyte)\n-      output_asm_insn (\"movb (%1), (%0)\", operands);\n+      output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n     else if (!CONSTANT_P (operands[2]))\n       {\n \t/* Output the destination label for the zero byte count check.  */\n@@ -1416,7 +1501,7 @@ output_block_move(rtx *operands)\n \t  {\n \t    sprintf (buf, \"bcc movestrhi%d\", count);\n \t    output_asm_insn (buf, NULL);\n-\t    output_asm_insn (\"movb (%1), (%0)\", operands);\n+\t    output_asm_insn (\"movb\\t(%1),(%0)\", operands);\n \t    sprintf (buf, \"\\nmovestrhi%d:\", count);\n \t    output_asm_insn (buf, NULL);\n \t    count++;\n@@ -1764,12 +1849,13 @@ output_addr_const_pdp11 (FILE *file, rtx x)\n \t  i = -i;\n \t  fprintf (file, \"-\");\n \t}\n-      fprintf (file, \"%#o\", i & 0xffff);\n+      if (TARGET_DEC_ASM)\n+\tfprintf (file, \"%o\", i & 0xffff);\n+      else\n+\tfprintf (file, \"%#o\", i & 0xffff);\n       break;\n \n     case CONST:\n-      /* This used to output parentheses around the expression,\n-\t but that does not work on the 386 (either ATT or BSD assembler).  */\n       output_addr_const_pdp11 (file, XEXP (x, 0));\n       break;\n \n@@ -1778,7 +1864,10 @@ output_addr_const_pdp11 (FILE *file, rtx x)\n \t{\n \t  /* We can use %o if the number is one word and positive.  */\n \t  gcc_assert (!CONST_DOUBLE_HIGH (x));\n-\t  fprintf (file, \"%#ho\", (unsigned short) CONST_DOUBLE_LOW (x));\n+\t  if (TARGET_DEC_ASM)\n+\t    fprintf (file, \"%ho\", CONST_DOUBLE_LOW (x) & 0xffff);\n+\t  else\n+\t    fprintf (file, \"%#ho\", CONST_DOUBLE_LOW (x) & 0xffff);\n \t}\n       else\n \t/* We can't handle floating point constants;\n@@ -1888,8 +1977,8 @@ bool\n pdp11_expand_shift (rtx *operands, rtx (*shift_sc) (rtx, rtx, rtx),\n \t\t    rtx (*shift_base) (rtx, rtx, rtx))\n {\n-  rtx dest, n, r, test;\n-  rtx_code_label *lb, *lb2;\n+  rtx r, test;\n+  rtx_code_label *lb;\n   \n   if (CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n     emit_insn ((*shift_sc) (operands[0], operands[1], operands[2]));\n@@ -1956,14 +2045,14 @@ pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n       switch (m)\n \t{\n \tcase E_QImode:\n-\t  output_asm_insn (\"rorb %0\", operands);\n+\t  output_asm_insn (\"rorb\\t%0\", operands);\n \t  break;\n \tcase E_HImode:\n-\t  output_asm_insn (\"ror %0\", operands);\n+\t  output_asm_insn (\"ror\\t%0\", operands);\n \t  break;\n \tcase E_SImode:\n-\t  output_asm_insn (\"ror %0\", exops[0]);\n-\t  output_asm_insn (\"ror %0\", exops[1]);\n+\t  output_asm_insn (\"ror\\t%0\", exops[0]);\n+\t  output_asm_insn (\"ror\\t%0\", exops[1]);\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -1979,14 +2068,14 @@ pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n \t  switch (m)\n \t    {\n \t    case E_QImode:\n-\t      output_asm_insn (\"asrb %0\", operands);\n+\t      output_asm_insn (\"asrb\\t%0\", operands);\n \t      break;\n \t    case E_HImode:\n-\t      output_asm_insn (\"asr %0\", operands);\n+\t      output_asm_insn (\"asr\\t%0\", operands);\n \t      break;\n \t    case E_SImode:\n-\t      output_asm_insn (\"asr %0\", exops[0]);\n-\t      output_asm_insn (\"ror %0\", exops[1]);\n+\t      output_asm_insn (\"asr\\t%0\", exops[0]);\n+\t      output_asm_insn (\"ror\\t%0\", exops[1]);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -1996,14 +2085,14 @@ pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n \t  switch (m)\n \t    {\n \t    case E_QImode:\n-\t      output_asm_insn (\"aslb %0\", operands);\n+\t      output_asm_insn (\"aslb\\t%0\", operands);\n \t      break;\n \t    case E_HImode:\n-\t      output_asm_insn (\"asl %0\", operands);\n+\t      output_asm_insn (\"asl\\t%0\", operands);\n \t      break;\n \t    case E_SImode:\n-\t      output_asm_insn (\"asl %0\", exops[1]);\n-\t      output_asm_insn (\"rol %0\", exops[0]);\n+\t      output_asm_insn (\"asl\\t%0\", exops[1]);\n+\t      output_asm_insn (\"rol\\t%0\", exops[0]);\n \t      break;\n \t    default:\n \t      gcc_unreachable ();\n@@ -2014,8 +2103,8 @@ pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n   if (!small)\n     {\n       /* Loop case, emit the count-down and branch if not done.  */\n-      output_asm_insn (\"dec %2\", operands);\n-      output_asm_insn (\"bne %l0\", lb);\n+      output_asm_insn (\"dec\\t%2\", operands);\n+      output_asm_insn (\"bne\\t%l0\", lb);\n     }\n   return \"\";\n }\n@@ -2159,6 +2248,114 @@ pdp11_function_section (tree decl ATTRIBUTE_UNUSED,\n   return NULL;\n }\n \n+/* Support #ident for DEC assembler, but don't process the\n+   auto-generated ident string that names the compiler (since its\n+   syntax is not correct for DEC .ident).  */\n+static void pdp11_output_ident (const char *ident)\n+{\n+  if (TARGET_DEC_ASM)\n+    {\n+      if (strncmp (ident, \"GCC:\", 4) != 0)\n+\tfprintf (asm_out_file, \"\\t.ident\\t\\\"%s\\\"\\n\", ident);\n+    }\n+  \n+}\n+\n+/* This emits a (user) label, which gets a \"_\" prefix except for DEC\n+   assembler output.  */\n+void\n+pdp11_output_labelref (FILE *file, const char *name)\n+{\n+  if (!TARGET_DEC_ASM)\n+    fputs (USER_LABEL_PREFIX, file);\n+  fputs (name, file);\n+}\n+\n+/* This equates name with value.  */\n+void\n+pdp11_output_def (FILE *file, const char *label1, const char *label2)\n+{\n+  if (TARGET_DEC_ASM)\n+    {\n+      assemble_name (file, label1);\n+      putc ('=', file);\n+      assemble_name (file, label2);\n+    }\n+  else\n+    {\n+      fputs (\".set\", file);\n+      assemble_name (file, label1);\n+      putc (',', file);\n+      assemble_name (file, label2);\n+    } \n+  putc ('\\n', file);\n+}\n+\n+void\n+pdp11_output_addr_vec_elt (FILE *file, int value)\n+{\n+  char buf[256];\n+\n+  pdp11_gen_int_label (buf, \"L\", value);\n+  if (!TARGET_UNIX_ASM)\n+    fprintf (file, \"\\t.word\");\n+  fprintf (file, \"\\t%s\\n\", buf + 1);\n+}\n+\n+/* This overrides some target hooks that are initializer elements so\n+   they can't be variables in the #define.  */\n+static void\n+pdp11_option_override (void)\n+{\n+  if (TARGET_DEC_ASM)\n+    {\n+      targetm.asm_out.open_paren  = \"<\";\n+      targetm.asm_out.close_paren = \">\";\n+    }\n+}\n+\n+static void\n+pdp11_asm_named_section (const char *name, unsigned int flags,\n+\t\t\t tree decl ATTRIBUTE_UNUSED)\n+{\n+  const char *rwro = (flags & SECTION_WRITE) ? \"rw\" : \"ro\";\n+  const char *insdat = (flags & SECTION_CODE) ? \"i\" : \"d\";\n+  \n+  gcc_assert (TARGET_DEC_ASM);\n+  fprintf (asm_out_file, \"\\t.psect\\t%s,con,%s,%s\\n\", name, insdat, rwro);\n+}\n+\n+static void\n+pdp11_asm_init_sections (void)\n+{\n+  if (TARGET_DEC_ASM)\n+    {\n+      bss_section = data_section;\n+    }\n+  else if (TARGET_GNU_ASM)\n+    {\n+      bss_section = get_unnamed_section (SECTION_WRITE | SECTION_BSS,\n+\t\t\t\t\t output_section_asm_op,\n+\t\t\t\t\t \".bss\");\n+    }\n+}\n+  \n+static void\n+pdp11_file_start (void)\n+{\n+  default_file_start ();\n+  \n+  if (TARGET_DEC_ASM)\n+    fprintf (asm_out_file, \"\\t.enabl\\tlsb,reg\\n\\n\");\n+}\n+\n+static void\n+pdp11_file_end (void)\n+{\n+  if (TARGET_DEC_ASM)\n+    fprintf (asm_out_file, \"\\t.end\\n\");\n+}\n+\n /* Implement TARGET_LEGITIMATE_CONSTANT_P.  */\n \n static bool"}, {"sha": "ff2f9a28bae4a7d67940ef025d451dbfb8e7df4d", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 59, "deletions": 26, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -45,6 +45,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #define TARGET_UNIX_ASM_DEFAULT\t0\n \n+/* \"Dialect\" just distinguishes between standard DEC mnemonics, which\n+   are also used by the GNU assembler, vs. Unix mnemonics and float\n+   register names.  So it is tied to the -munit-asm option, and treats\n+   -mgnu-asm and -mdec-asm as equivalent (both are dialect zero).  */\n #define ASSEMBLER_DIALECT\t(TARGET_UNIX_ASM ? 1 : 0)\n \n \f\n@@ -489,11 +493,19 @@ extern int may_call_alloca;\n \n /* Output before read-only data.  */\n \n-#define TEXT_SECTION_ASM_OP \"\\t.text\\n\"\n+#define TEXT_SECTION_ASM_OP \\\n+  ((TARGET_DEC_ASM) ? \"\\t.psect\\tcode,i,ro,con\" : \"\\t.text\")\n \n /* Output before writable data.  */\n \n-#define DATA_SECTION_ASM_OP \"\\t.data\\n\"\n+#define DATA_SECTION_ASM_OP \\\n+  ((TARGET_DEC_ASM) ? \"\\t.psect\\tdata,d,rw,con\" : \"\\t.data\")\n+\n+/* Output before read-only data.  Same as read-write data for non-DEC\n+   assemblers because they don't know about .rodata.  */\n+\n+#define READONLY_DATA_SECTION_ASM_OP \\\n+  ((TARGET_DEC_ASM) ? \"\\t.psect\\trodata,d,ro,con\" : \"\\t.data\")\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n@@ -504,38 +516,59 @@ extern int may_call_alloca;\n  \"cc\", \"fcc\" }\n \n /* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n \n-/* The prefix to add to user-visible assembler symbols.  */\n+/* The prefix to add to user-visible assembler symbols.  For the DEC\n+   assembler case, this is not used.  */\n \n #define USER_LABEL_PREFIX \"_\"\n \n+/* Line separators.  */\n+\n+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C, STR) \\\n+  ((C) == '\\n' || (!TARGET_DEC_ASM && (C) == ';'))\n+\n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n    This is suitable for output with `assemble_name'.  */\n \n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s_%lu\", PREFIX, (unsigned long)(NUM))\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM) \\\n+  pdp11_gen_int_label ((LABEL), (PREFIX), (NUM))\n+\n+/* Emit a string.  */\n \n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii (FILE, P, SIZE)\n \n-/* This is how to output an element of a case-vector that is absolute.  */\n+/* Print a label reference, with _ prefix if not DEC.  */\n \n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t%sL_%d\\n\", TARGET_UNIX_ASM ? \"\" : \".word \", VALUE)\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+  pdp11_output_labelref ((STREAM), (NAME))\n+\n+/* Equate a symbol to an expression.  */\n+\n+#define ASM_OUTPUT_DEF(STREAM, NAME, VALUE) \\\n+  pdp11_output_def (STREAM, NAME, VALUE)\n \n-/* This is how to output an element of a case-vector that is relative.\n-   Don't define this if it is not supported.  */\n+/* Mark a reference to an external symbol.  Needed for DEC assembler.  */\n \n-/* #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) */\n+#define ASM_OUTPUT_EXTERNAL(STREAM, DECL, NAME) \\\n+  if (TARGET_DEC_ASM) \\\n+    fprintf ((STREAM), \"\\t.globl\\t%s\\n\", (NAME))\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME) \\\n+  if (TARGET_DEC_ASM) \\\n+    fprintf ((STREAM), \".title\\t%s\\n\", (NAME))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  pdp11_output_addr_vec_elt (FILE, VALUE)\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes. \n-\n-   who needs this????\n */\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n@@ -551,35 +584,34 @@ extern int may_call_alloca;\n     }\n \n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.=.+ %#ho\\n\", (unsigned short)(SIZE))\n+  if (TARGET_DEC_ASM) \\\n+    fprintf (FILE, \"\\t.blkb\\t%ho\\n\", (SIZE) & 0xffff);\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.=.+ %#ho\\n\", (SIZE) & 0xffff);\n \n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n #define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)  \\\n-    pdp11_asm_output_var (FILE, NAME, SIZE, ALIGN, true)\n+  pdp11_asm_output_var (FILE, NAME, SIZE, ALIGN, true)\n \n \n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n-    pdp11_asm_output_var (FILE, NAME, SIZE, ALIGN, false)\n+  pdp11_asm_output_var (FILE, NAME, SIZE, ALIGN, false)\n \n /* Print a memory address as an operand to reference that memory location.  */\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n- print_operand_address (FILE, ADDR)\n+  print_operand_address (FILE, ADDR)\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\\\n-(\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tmov %s, -(sp)\\n\", reg_names[REGNO])\t\\\n-)\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\\\n+  fprintf (FILE, \"\\tmov\\t%s,-(sp)\\n\", reg_names[REGNO])\n \n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)                 \t\t\\\n-(                                                       \t\\\n-  fprintf (FILE, \"\\tmov (sp)+, %s\\n\", reg_names[REGNO])     \t\\\n-)\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\\\n+  fprintf (FILE, \"\\tmov\\t(sp)+,%s\\n\", reg_names[REGNO])\n \n #define TRAMPOLINE_SIZE 8\n #define TRAMPOLINE_ALIGNMENT 16\n@@ -588,6 +620,7 @@ extern int may_call_alloca;\n \n #define COMPARE_FLAG_MODE HImode\n \n+/* May be overridden by command option processing.  */\n #define TARGET_HAVE_NAMED_SECTIONS false\n \n /* pdp11-unknown-aout target has no support of C99 runtime */"}, {"sha": "ba85d7d8f8bafab2585051c1012c9077fa3c7bca", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -212,9 +212,9 @@\n   \"*\n {\n   if (which_alternative == 0 || which_alternative == 2)\n-    return \\\"{tstd|tstf} %0\\\";\n+    return \\\"{tstd|tstf}\\t%0\\\";\n   else\n-    return \\\"{cmpd|cmpf} %0, %1\\\";\n+    return \\\"{cmpd|cmpf}\\t%0,%1\\\";\n }\"\n   [(set_attr \"length\" \"2,2,4,4\")\n    (set_attr \"type\" \"fp\")]) \n@@ -232,12 +232,12 @@\n \t\t    (match_operand:PDPint 1 \"general_operand\" \"N,rR,Qi,N,rR,Qi\")))]\n   \"\"\n   \"@\n-   tst<PDPint:isfx> %0\n-   cmp<PDPint:isfx> %0,%1\n-   cmp<PDPint:isfx> %0,%1\n-   tst<PDPint:isfx> %0\n-   cmp<PDPint:isfx> %0,%1\n-   cmp<PDPint:isfx> %0,%1\"\n+   tst<PDPint:isfx>\\t%0\n+   cmp<PDPint:isfx>\\t%0,%1\n+   cmp<PDPint:isfx>\\t%0,%1\n+   tst<PDPint:isfx>\\t%0\n+   cmp<PDPint:isfx>\\t%0,%1\n+   cmp<PDPint:isfx>\\t%0,%1\"\n   [(set_attr \"length\" \"2,2,4,4,4,6\")])\n \n ;; sob instruction - FIXME: this doesn't do anything, need to use doloop_end.\n@@ -257,13 +257,13 @@\n   \"*\n {\n  if (get_attr_length (insn) == 2)\n-    return \\\"sob %0, %l1\\\";\n+    return \\\"sob\\t%0,%l1\\\";\n \n  /* emulate sob */\n  operands[2] = gen_label_rtx ();\n- output_asm_insn (\\\"dec %0\\\", operands);\n- output_asm_insn (\\\"beq %l2\\\", operands);\n- output_asm_insn (\\\"jmp %l1\\\", operands);\n+ output_asm_insn (\\\"dec\\t%0\\\", operands);\n+ output_asm_insn (\\\"beq\\t%l2\\\", operands);\n+ output_asm_insn (\\\"jmp\\t%l1\\\", operands);\n  \n  output_asm_label (operands[2]);\n  fputs (\\\":\\\\n\\\", asm_out_file);\n@@ -432,9 +432,9 @@\n   \"*\n {\n   if (operands[1] == const0_rtx)\n-    return \\\"clr<PDPint:isfx> %0\\\";\n+    return \\\"clr<PDPint:isfx>\\t%0\\\";\n \n-  return \\\"mov<PDPint:isfx> %1, %0\\\";\n+  return \\\"mov<PDPint:isfx>\\t%1,%0\\\";\n }\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n@@ -462,7 +462,7 @@\n   \"TARGET_FPU\"\n   \"*\n   gcc_assert (which_alternative < 2);\n-  return \\\"std %1, %0\\\";\n+  return \\\"std\\t%1,%0\\\";\n   \"\n   \"&& reload_completed\"\n   [(parallel [(set (match_dup 0)\n@@ -482,9 +482,9 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"@\n-  ldd %1, %0\n-  ldd %1, %0\n-  clrd %0\"\n+  ldd\\t%1,%0\n+  ldd\\t%1,%0\n+  clrd\\t%0\"\n   [(set_attr \"length\" \"2,4,2\")])\n \n ;; SFmode is easier because that uses convert load/store, which\n@@ -513,11 +513,11 @@\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n   \"@\n-  {ldcfd|movof} %1, %0\n-  {stcdf|movfo} %1, %0\n-  {ldcfd|movof} %1, %0\n-  {stcdf|movfo} %1, %0\n-  clrf %0\"\n+  {ldcfd|movof}\\t%1,%0\n+  {stcdf|movfo}\\t%1,%0\n+  {ldcfd|movof}\\t%1,%0\n+  {stcdf|movfo}\\t%1,%0\n+  clrf\\t%0\"\n   [(set_attr \"length\" \"2,2,4,4,2\")])\n \n ;; maybe fiddle a bit with move_ratio, then \n@@ -594,7 +594,7 @@\n \t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"a,a\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-   \"{stcdf|movfo} %1, %0\"\n+   \"{stcdf|movfo}\\t%1,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n \f\n@@ -615,7 +615,7 @@\n \t\t   (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,0\")))\n \t      (clobber (reg:CC CC_REGNUM))])]\n   \"reload_completed\"\n-  \"bic $0177400, %0\"\n+  \"bic\\t%#0177400,%0\"\n   [(set_attr \"length\" \"4,6\")])\n \t\t\t \n (define_expand \"zero_extendhisi2\"\n@@ -662,7 +662,7 @@\n \t(float_extend:DF (match_operand:SF 1 \"float_operand\" \"R,Q\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{ldcfd|movof} %1, %0\"\n+  \"{ldcfd|movof}\\t%1,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;; movb sign extends if destination is a register\n@@ -682,7 +682,7 @@\n \t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-  \"movb %1, %0\"\n+  \"movb\\t%1,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_insn_and_split \"extendhisi2\"\n@@ -713,16 +713,16 @@\n       latehalf[0] = operands[0];\n       operands[0] = adjust_address(operands[0], HImode, 2);\n   \n-      output_asm_insn(\\\"mov %1, %0\\\", operands);\n-      output_asm_insn(\\\"sxt %0\\\", latehalf);\n+      output_asm_insn(\\\"mov\\t%1,%0\\\", operands);\n+      output_asm_insn(\\\"sxt\\t%0\\\", latehalf);\n \n       return \\\"\\\";\n \n     case 1:\n \n       /* - auto-decrement - right direction ;-) */\n-      output_asm_insn(\\\"mov %1, %0\\\", operands);\n-      output_asm_insn(\\\"sxt %0\\\", operands);\n+      output_asm_insn(\\\"mov\\t%1,%0\\\", operands);\n+      output_asm_insn(\\\"sxt\\t%0\\\", operands);\n \n       return \\\"\\\";\n \n@@ -732,8 +732,8 @@\n       latehalf[0] = operands[0];\n       operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n \n-      output_asm_insn(\\\"mov %1, %0\\\", operands);\n-      output_asm_insn(\\\"sxt %0\\\", latehalf);\n+      output_asm_insn(\\\"mov\\t%1,%0\\\", operands);\n+      output_asm_insn(\\\"sxt\\t%0\\\", latehalf);\n \n       return \\\"\\\";\n \n@@ -773,16 +773,16 @@\n  \n        latehalf[0] = NULL; \n        latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n-       output_asm_insn(\\\"mov %1, -(sp)\\\", latehalf);\n-       output_asm_insn(\\\"mov %1, -(sp)\\\", operands);\n+       output_asm_insn(\\\"mov\\t%1,-(sp)\\\", latehalf);\n+       output_asm_insn(\\\"mov\\t%1,-(sp)\\\", operands);\n        \n        output_asm_insn(\\\"setl\\\", operands);\n-       output_asm_insn(\\\"{ldcld|movif} (sp)+, %0\\\", operands);\n+       output_asm_insn(\\\"{ldcld|movif}\\t(sp)+,%0\\\", operands);\n        output_asm_insn(\\\"seti\\\", operands);\n        return \\\"\\\";\n      }\n      else \n-       return \\\"setl\\;{ldcld|movif} %1, %0\\;seti\\\";\n+       return \\\"setl\\;{ldcld|movif}\\t%1,%0\\;seti\\\";\n   \"\n   [(set_attr \"length\" \"10,6,8\")])\n \n@@ -801,7 +801,7 @@\n \t(float:DF (match_operand:HI 1 \"general_operand\" \"rR,Qi\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{ldcid|movif} %1, %0\"\n+  \"{ldcid|movif}\\t%1,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \t\n ;; cut float to int\n@@ -831,15 +831,15 @@\n   \"* if (which_alternative ==0)\n      {\n        output_asm_insn(\\\"setl\\\", operands);\n-       output_asm_insn(\\\"{stcdl|movfi} %1, -(sp)\\\", operands);\n+       output_asm_insn(\\\"{stcdl|movfi}\\t%1,-(sp)\\\", operands);\n        output_asm_insn(\\\"seti\\\", operands);\n-       output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n+       output_asm_insn(\\\"mov\\t(sp)+,%0\\\", operands);\n        operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-       output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n+       output_asm_insn(\\\"mov\\t(sp)+,%0\\\", operands);\n        return \\\"\\\";\n      }\n      else \n-       return \\\"setl\\;{stcdl|movfi} %1, %0\\;seti\\\";\n+       return \\\"setl\\;{stcdl|movfi}\\t%1,%0\\;seti\\\";\n   \"\n   [(set_attr \"length\" \"10,6,8\")])\n \n@@ -861,7 +861,7 @@\n    (clobber (reg:CC CC_REGNUM))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{stcdi|movfi} %1, %0\"\n+  \"{stcdi|movfi}\\t%1,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n \f\n@@ -887,7 +887,7 @@\n \t      (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{addd|addf} %2, %0\"\n+  \"{addd|addf}\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_insn_and_split \"adddi3\"\n@@ -917,24 +917,24 @@\n   pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n   if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n-    output_asm_insn (\\\"add %1, %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[0]);\n   if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n-    output_asm_insn (\\\"add %1, %0\\\", exops[1]);\n-    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n   if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n   {\n-    output_asm_insn (\\\"add %1, %0\\\", exops[2]);\n-    output_asm_insn (\\\"adc %0\\\", exops[1]);\n-    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[2]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n   if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n   {\n-    output_asm_insn (\\\"add %1, %0\\\", exops[3]);\n-    output_asm_insn (\\\"adc %0\\\", exops[2]);\n-    output_asm_insn (\\\"adc %0\\\", exops[1]);\n-    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[3]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[2]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n \n   return \\\"\\\";\n@@ -977,11 +977,11 @@\n   pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n   if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n-    output_asm_insn (\\\"add %1, %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[0]);\n   if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n-    output_asm_insn (\\\"add %1, %0\\\", exops[1]);\n-    output_asm_insn (\\\"adc %0\\\", exops[0]);\n+    output_asm_insn (\\\"add\\t%1,%0\\\", exops[1]);\n+    output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n \n   return \\\"\\\";\n@@ -1012,12 +1012,12 @@\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       if (INTVAL(operands[2]) == 1)\n-\treturn \\\"inc %0\\\";\n+\treturn \\\"inc\\t%0\\\";\n       else if (INTVAL(operands[2]) == -1)\n-        return \\\"dec %0\\\";\n+        return \\\"dec\\t%0\\\";\n     }\n \n-  return \\\"add %2, %0\\\";\n+  return \\\"add\\t%2,%0\\\";\n }\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n@@ -1045,7 +1045,7 @@\n \t          (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{subd|subf} %2, %0\"\n+  \"{subd|subf}\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_insn_and_split \"subdi3\"\n@@ -1075,24 +1075,24 @@\n   pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n   if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[0]);\n   if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[1]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n   if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n   {\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[2]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[1]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[2]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n   if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n   {\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[3]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[2]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[1]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[3]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[2]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n \n   return \\\"\\\";\n@@ -1126,11 +1126,11 @@\n   pdp11_expand_operands (inops, exops, 2, NULL, either);\n   \n   if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[0]);\n   if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n-    output_asm_insn (\\\"sub %1, %0\\\", exops[1]);\n-    output_asm_insn (\\\"sbc %0\\\", exops[0]);\n+    output_asm_insn (\\\"sub\\t%1,%0\\\", exops[1]);\n+    output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n \n   return \\\"\\\";\n@@ -1164,12 +1164,12 @@\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       if (INTVAL(operands[2]) == 1)\n-\treturn \\\"dec %0\\\";\n+\treturn \\\"dec\\t%0\\\";\n       else if (INTVAL(operands[2]) == -1)\n-        return \\\"inc %0\\\";\n+        return \\\"inc\\t%0\\\";\n     }\n \n-  return \\\"sub %2, %0\\\";\n+  return \\\"sub\\t%2,%0\\\";\n }\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n@@ -1222,7 +1222,7 @@\n \t\t\t  (match_operand:PDPint 2 \"general_operand\" \"0,0,0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-  \"bic<PDPint:isfx> %1, %0\"\n+  \"bic<PDPint:isfx>\\t%1,%0\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n ;;- Bit set (inclusive or) instructions\n@@ -1244,7 +1244,7 @@\n \t     (match_operand:PDPint 2 \"general_operand\" \"rR,Qi,rR,Qi\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-  \"bis<PDPint:isfx> %2, %0\"\n+  \"bis<PDPint:isfx>\\t%2,%0\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n ;;- xor instructions\n@@ -1266,7 +1266,7 @@\n \t     (match_operand:HI 2 \"register_operand\" \"r,r\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS && reload_completed\"\n-  \"xor %2, %0\"\n+  \"xor\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- one complement instructions\n@@ -1287,7 +1287,7 @@\n \t(not:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n-  \"com<PDPint:isfx> %0\"\n+  \"com<PDPint:isfx>\\t%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- arithmetic shift instructions\n@@ -1329,15 +1329,15 @@\n \t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n \t               (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n   \"TARGET_40_PLUS\"\n-  \"ash %2, %0\"\n+  \"ash\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_insn \"aslsi_op\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n \t           (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n   \"TARGET_40_PLUS\"\n-  \"ashc %2, %0\"\n+  \"ashc\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;; Now the expanders that produce the insns defined above. \n@@ -1444,7 +1444,7 @@\n \t(abs:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{absd|absf} %0\"\n+  \"{absd|absf}\\t%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;; negate insns\n@@ -1464,7 +1464,7 @@\n \t(neg:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{negd|negf} %0\"\n+  \"{negd|negf}\\t%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_insn_and_split \"negdi2\"\n@@ -1488,14 +1488,14 @@\n   \n   pdp11_expand_operands (operands, exops, 1, NULL, either);\n \n-  output_asm_insn (\\\"com %0\\\", exops[3]);\n-  output_asm_insn (\\\"com %0\\\", exops[2]);\n-  output_asm_insn (\\\"com %0\\\", exops[1]);\n-  output_asm_insn (\\\"com %0\\\", exops[0]);\n-  output_asm_insn (\\\"add $1, %0\\\", exops[3]);\n-  output_asm_insn (\\\"adc %0\\\", exops[2]);\n-  output_asm_insn (\\\"adc %0\\\", exops[1]);\n-  output_asm_insn (\\\"adc %0\\\", exops[0]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[3]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[2]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n+  output_asm_insn (\\\"add\\t%#1,%0\\\", exops[3]);\n+  output_asm_insn (\\\"adc\\t%0\\\", exops[2]);\n+  output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n+  output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n \n   return \\\"\\\";\n }\n@@ -1522,10 +1522,10 @@\n   \n   pdp11_expand_operands (operands, exops, 1, NULL, either);\n \n-  output_asm_insn (\\\"com %0\\\", exops[1]);\n-  output_asm_insn (\\\"com %0\\\", exops[0]);\n-  output_asm_insn (\\\"add $1, %0\\\", exops[1]);\n-  output_asm_insn (\\\"adc %0\\\", exops[0]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n+  output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n+  output_asm_insn (\\\"add\\t%#1,%0\\\", exops[1]);\n+  output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n \n   return \\\"\\\";\n }\n@@ -1546,7 +1546,7 @@\n \t(neg:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n-  \"neg<PDPint:isfx> %0\"\n+  \"neg<PDPint:isfx>\\t%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n \n@@ -1558,8 +1558,8 @@\n   \"*\n {\n   if (get_attr_length (insn) == 2)\n-    return \\\"br %l0\\\";\n-  return \\\"jmp %l0\\\";\n+    return \\\"br\\t%l0\\\";\n+  return \\\"jmp\\t%l0\\\";\n }\"\n   [(set (attr \"length\") (if_then_else (ior (lt (minus (match_dup 0)\n \t\t\t\t\t\t      (pc))\n@@ -1575,9 +1575,9 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"@\n-  jmp (%0)\n-  jmp %@%0\n-  jmp %@%0\"\n+  jmp\\t(%0)\n+  jmp\\t%@%0\n+  jmp\\t%@%0\"\n   [(set_attr \"length\" \"2,2,4\")])\n \n ;; indirect jump.  TODO: this needs a constraint that allows memory\n@@ -1596,7 +1596,7 @@\n \t (match_operand:HI 1 \"general_operand\" \"g,g\"))]\n   ;;- Don't use operand 1 for most machines.\n   \"\"\n-  \"jsr pc, %0\"\n+  \"jsr pc,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- jump to subroutine\n@@ -1606,7 +1606,7 @@\n \t      (match_operand:HI 2 \"general_operand\" \"g,g\")))]\n   ;;- Don't use operand 2 for most machines.\n   \"\"\n-  \"jsr pc, %1\"\n+  \"jsr pc,%1\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_expand \"untyped_call\"\n@@ -1661,7 +1661,7 @@\n \t      (match_operand:DF 2 \"float_operand\" \"fR,QF\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{muld|mulf} %2, %0\"\n+  \"{muld|mulf}\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;; 16 bit result multiply.  This uses odd numbered registers.\n@@ -1683,7 +1683,7 @@\n \t      (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS && reload_completed\"\n-  \"mul %2, %0\"\n+  \"mul\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;; 32 bit result from 16 bit operands\n@@ -1706,7 +1706,7 @@\n \t      (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"rR,Qi\"))))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS && reload_completed\"\n-  \"mul %2, %0\"\n+  \"mul\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- divide\n@@ -1727,7 +1727,7 @@\n \t     (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n    (clobber (reg:CC FCC_REGNUM))]\n   \"TARGET_FPU && reload_completed\"\n-  \"{divd|divf} %2, %0\"\n+  \"{divd|divf}\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])\n \n (define_expand \"divmodhi4\"\n@@ -1773,5 +1773,5 @@\n \t(mod:HI (match_dup 1) (match_dup 2)))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS\"\n-   \"div %2,%0\"\n+   \"div\\t%2,%0\"\n   [(set_attr \"length\" \"2,4\")])"}, {"sha": "26a91a028ae0fd088683b1dd098c670ef8b8c04e", "filename": "gcc/config/pdp11/pdp11.opt", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -35,9 +35,13 @@ Target Report Mask(AC0)\n Return floating-point results in ac0 (fr0 in Unix assembler syntax).\n \n mdec-asm\n-Target RejectNegative Report InverseMask(UNIX_ASM)\n+Target RejectNegative Report Mask(DEC_ASM) Negative(mgnu-asm)\n Use the DEC assembler syntax.\n \n+mgnu-asm\n+Target RejectNegative Report Mask(GNU_ASM) Negative(munix-asm)\n+Use the GNU assembler syntax.\n+\n mfloat32\n Target Report Mask(FLOAT32)\n Use 32 bit float.\n@@ -67,5 +71,5 @@ Target Report Mask(SPLIT)\n Target has split I&D.\n \n munix-asm\n-Target RejectNegative Report Mask(UNIX_ASM)\n+Target RejectNegative Report Mask(UNIX_ASM) Negative(mdec-asm)\n Use UNIX assembler syntax."}, {"sha": "56cd122b0d7b420e2b16ceb02907860879d3b9d7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4aef57c991dc27734d53413b6df33a448076e617/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4aef57c991dc27734d53413b6df33a448076e617", "patch": "@@ -972,7 +972,7 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n -mint32  -mno-int16 -mint16  -mno-int32 @gol\n -mfloat32  -mno-float64 -mfloat64  -mno-float32 @gol\n--msplit -munix-asm  -mdec-asm}\n+-msplit -munix-asm  -mdec-asm -mgnu-asm}\n \n @emph{picoChip Options}\n @gccoptlist{-mae=@var{ae_type}  -mvliw-lookahead=@var{N} @gol\n@@ -22080,7 +22080,11 @@ Use Unix assembler syntax.\n \n @item -mdec-asm\n @opindex mdec-asm\n-Use DEC assembler syntax.  This is the default.\n+Use DEC assembler syntax.\n+\n+@item -mgnu-asm\n+@opindex mgnu-asm\n+Use GNU assembler syntax.  This is the default.\n @end table\n \n @node picoChip Options"}]}