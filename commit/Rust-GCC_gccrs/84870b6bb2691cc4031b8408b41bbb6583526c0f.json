{"sha": "84870b6bb2691cc4031b8408b41bbb6583526c0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4NzBiNmJiMjY5MWNjNDAzMWI4NDA4YjQxYmJiNjU4MzUyNmMwZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-10-19T09:35:03Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-10-19T09:35:03Z"}, "message": "Fix std::experimental::shared_ptr SFINAE constraints\n\n\t* include/experimental/bits/shared_ptr.h\n\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::_Compatible): Just use\n\tis_convertible for non-array specialization.\n\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::_UniqCompatible): New\n\tconstraint for conversions from unique_ptr.\n\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::__shared_ptr): Constrain.\n\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::reset): Likewise.\n\t(__sp_compatible_v): New variable template for trait.\n\t(__sp_is_constructible): New trait to check shared_ptr constraints.\n\t(__sp_is_constructible_v): New variable template for trait.\n\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::_SafeConv): New\n\tconstraint for construction/reset, using __sp_is_constructible_v.\n\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::_UniqCompatible): New\n\tconstraint for conversions from unique_ptr.\n\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::__shared_ptr): Constrain.\n\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::reset): Likewise.\n\t(shared_ptr::_SafeConv): Constraint for checking constructors.\n\t(shared_ptr(Tp1*), shared_ptr(_Tp1, _Deleter))\n\t(shared_ptr(_Tp1, _Deleter, _Alloc)): Constrain with _SafeConv.\n\t(shared_ptr(const weak_ptr<_Tp1>&)): Constrain with _Compatible.\n\t(shared_ptr(auto_ptr<_Tp1>&&)): Fix, remove TODO.\n\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc:\n\tRemove tests using invalid conversions.\n\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor_neg.cc:\n\tNew test.\n\t* testsuite/experimental/memory/shared_ptr/cons/torture.cc: New test.\n\t* testsuite/experimental/memory/shared_ptr/modifiers/reset.cc: Remove\n\ttests using invalid conversions.\n\t* testsuite/experimental/memory/shared_ptr/modifiers/reset_neg.cc: New\n\ttest.\n\t* testsuite/experimental/memory/shared_ptr/observers/use_count.cc:\n\tRemove tests using invalid conversions.\n\nFrom-SVN: r241331", "tree": {"sha": "dad6bafec631e0e2dc375fc508b4dd431b893529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dad6bafec631e0e2dc375fc508b4dd431b893529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84870b6bb2691cc4031b8408b41bbb6583526c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84870b6bb2691cc4031b8408b41bbb6583526c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84870b6bb2691cc4031b8408b41bbb6583526c0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84870b6bb2691cc4031b8408b41bbb6583526c0f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e182393e31609b0d1474cea18c69bbb6c287ae6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e182393e31609b0d1474cea18c69bbb6c287ae6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e182393e31609b0d1474cea18c69bbb6c287ae6b"}], "stats": {"total": 520, "additions": 407, "deletions": 113}, "files": [{"sha": "200a5bdbcdad05c129754488257a0d6ce28457b5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -1,5 +1,38 @@\n 2016-10-19  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/experimental/bits/shared_ptr.h\n+\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::_Compatible): Just use\n+\tis_convertible for non-array specialization.\n+\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::_UniqCompatible): New\n+\tconstraint for conversions from unique_ptr.\n+\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::__shared_ptr): Constrain.\n+\t(__shared_ptr<__libfund_v1<_Tp, false>, _Lp>::reset): Likewise.\n+\t(__sp_compatible_v): New variable template for trait.\n+\t(__sp_is_constructible): New trait to check shared_ptr constraints.\n+\t(__sp_is_constructible_v): New variable template for trait.\n+\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::_SafeConv): New\n+\tconstraint for construction/reset, using __sp_is_constructible_v.\n+\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::_UniqCompatible): New\n+\tconstraint for conversions from unique_ptr.\n+\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::__shared_ptr): Constrain.\n+\t(__shared_ptr<__libfund_v1<_Tp, true>, _Lp>::reset): Likewise.\n+\t(shared_ptr::_SafeConv): Constraint for checking constructors.\n+\t(shared_ptr(Tp1*), shared_ptr(_Tp1, _Deleter))\n+\t(shared_ptr(_Tp1, _Deleter, _Alloc)): Constrain with _SafeConv.\n+\t(shared_ptr(const weak_ptr<_Tp1>&)): Constrain with _Compatible.\n+\t(shared_ptr(auto_ptr<_Tp1>&&)): Fix, remove TODO.\n+\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc:\n+\tRemove tests using invalid conversions.\n+\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor_neg.cc:\n+\tNew test.\n+\t* testsuite/experimental/memory/shared_ptr/cons/torture.cc: New test.\n+\t* testsuite/experimental/memory/shared_ptr/modifiers/reset.cc: Remove\n+\ttests using invalid conversions.\n+\t* testsuite/experimental/memory/shared_ptr/modifiers/reset_neg.cc: New\n+\ttest.\n+\t* testsuite/experimental/memory/shared_ptr/observers/use_count.cc:\n+\tRemove tests using invalid conversions.\n+\n \tPR libstdc++/77990\n \t* include/bits/unique_ptr.h (__uniq_ptr_impl): New type to\n \tencapsulate implementation details."}, {"sha": "2e3da62c599e3aa2acea9459c318b57d9268e003", "filename": "libstdc++-v3/include/experimental/bits/shared_ptr.h", "status": "modified", "additions": 193, "deletions": 88, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -69,53 +69,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Tp, bool = is_array<_Tp>::value>\n     struct __libfund_v1 { using type = _Tp; };\n \n-  // helper for _Compatible\n-  template<typename _From_type, typename _To_type>\n-    struct __sp_compatible\n-    : is_convertible<_From_type*, _To_type*>::type\n-    { };\n-\n-  template<size_t _Nm, typename _Tp>\n-    struct __sp_compatible<_Tp[_Nm], _Tp[]>\n-    : true_type\n-    { };\n-\n-  template<size_t _Nm, typename _Tp>\n-    struct __sp_compatible<_Tp[_Nm], const _Tp[]>\n-    : true_type\n-    { };\n-\n   // Partial specialization for base class of experimental::shared_ptr<T>\n   // (i.e. the non-array form of experimental::shared_ptr)\n   template<typename _Tp, _Lock_policy _Lp>\n     class __shared_ptr<__libfund_v1<_Tp, false>, _Lp>\n     : private __shared_ptr<_Tp, _Lp>\n     {\n-      template<typename _Tp1, typename _Res = void>\n+      // For non-arrays, Y* is compatible with T* if Y* is convertible to T*.\n+      template<typename _Yp, typename _Res = void>\n \tusing _Compatible\n-\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value, _Res>;\n+\t  = enable_if_t<experimental::is_convertible_v<_Yp*, _Tp*>, _Res>;\n+\n+      template<typename _Yp, typename _Del,\n+\t       typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer,\n+\t       typename _Res = void>\n+\tusing _UniqCompatible = enable_if_t<\n+\t  experimental::is_convertible_v<_Yp*, _Tp*>\n+\t  && experimental::is_convertible_v<_Ptr, _Tp*>,\n+\t  _Res>;\n \n       using _Base_type = __shared_ptr<_Tp>;\n \n-      _Base_type&  _M_get_base() { return *this;}\n-      const _Base_type&  _M_get_base() const { return *this;}\n+      _Base_type&  _M_get_base() { return *this; }\n+      const _Base_type&  _M_get_base() const { return *this; }\n \n     public:\n       using element_type = _Tp;\n \n       constexpr __shared_ptr() noexcept = default;\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(_Tp1* __p)\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\texplicit\n+\t__shared_ptr(_Tp1* __p)\n \t: _Base_type(__p)\n \t{ }\n \n-      template<typename _Tp1, typename _Deleter>\n+      template<typename _Tp1, typename _Deleter, typename = _Compatible<_Tp1>>\n \t__shared_ptr(_Tp1* __p, _Deleter __d)\n \t: _Base_type(__p, __d)\n \t{ }\n \n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+      template<typename _Tp1, typename _Deleter, typename _Alloc,\n+\t       typename = _Compatible<_Tp1>>\n \t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n \t: _Base_type(__p, __d, __a)\n \t{ }\n@@ -152,21 +147,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Base_type(std::move((__r._M_get_base())))\n \t{ }\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\texplicit\n+\t__shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n \t: _Base_type(__r._M_get_base())\n \t{ }\n \n-      template<typename _Tp1, typename _Del, typename\n-\t      = _Compatible<remove_pointer_t<\n-\t\t\t    typename unique_ptr<_Tp1, _Del>::pointer>>>\n-\t  __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n-\t  : _Base_type(std::move(__r))\n-\t  { }\n+      template<typename _Tp1, typename _Del,\n+\t       typename = _UniqCompatible<_Tp1, _Del>>\n+\t__shared_ptr(unique_ptr<_Tp1, _Del>&& __r)\n+\t: _Base_type(std::move(__r))\n+\t{ }\n \n #if _GLIBCXX_USE_DEPRECATED\n       // Postcondition: use_count() == 1 and __r.get() == 0\n-      template<typename _Tp1>\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n \t__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n         : _Base_type(std::move(__r))\n \t{ }\n@@ -180,20 +175,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { __shared_ptr(nullptr).swap(*this); }\n \n       template<typename _Tp1>\n-\tvoid\n+\t_Compatible<_Tp1>\n \treset(_Tp1* __p)\n \t{\n \t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n \t  __shared_ptr(__p).swap(*this);\n \t}\n \n       template<typename _Tp1, typename _Deleter>\n-\tvoid\n+\t_Compatible<_Tp1>\n \treset(_Tp1* __p, _Deleter __d)\n \t{ __shared_ptr(__p, __d).swap(*this); }\n \n       template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\tvoid\n+\t_Compatible<_Tp1>\n \treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n \t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n \n@@ -216,9 +211,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(std::unique_ptr<_Tp1>&& __r)\n+      template<typename _Tp1, typename _Del>\n+\t_UniqCompatible<_Tp1, _Del, __shared_ptr&>\n+\toperator=(unique_ptr<_Tp1, _Del>&& __r)\n \t{\n \t  _Base_type::operator=(std::move(__r));\n \t  return *this;\n@@ -282,6 +277,77 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n     };\n \n+  // Helper traits for shared_ptr of array:\n+\n+  // Trait that tests if Y* is compatible with T*, for shared_ptr purposes.\n+  template<typename _Yp, typename _Tp>\n+    struct __sp_compatible\n+    : is_convertible<_Yp*, _Tp*>::type\n+    { };\n+\n+  template<size_t _Nm, typename _Tp>\n+    struct __sp_compatible<_Tp[_Nm], _Tp[]>\n+    : true_type\n+    { };\n+\n+  template<size_t _Nm, typename _Tp>\n+    struct __sp_compatible<_Tp[_Nm], const _Tp[]>\n+    : true_type\n+    { };\n+\n+  template<typename _Yp, typename _Tp>\n+    constexpr bool __sp_compatible_v\n+      = __sp_compatible<_Yp, _Tp>::value;\n+\n+  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n+  template<typename _Up, size_t _Nm, typename _Yp, typename = void>\n+    struct __sp_is_constructible_arrN\n+    : false_type\n+    { };\n+\n+  template<typename _Up, size_t _Nm, typename _Yp>\n+    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>\n+    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type\n+    { };\n+\n+  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n+  template<typename _Up, typename _Yp, typename = void>\n+    struct __sp_is_constructible_arr\n+    : false_type\n+    { };\n+\n+  template<typename _Up, typename _Yp>\n+    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>\n+    : is_convertible<_Yp(*)[], _Up(*)[]>::type\n+    { };\n+\n+  // Trait to check if shared_ptr<T> can be constructed from Y*.\n+  template<typename _Tp, typename _Yp>\n+    struct __sp_is_constructible;\n+\n+  // When T is U[N], Y(*)[N] shall be convertible to T*;\n+  template<typename _Up, size_t _Nm, typename _Yp>\n+    struct __sp_is_constructible<_Up[_Nm], _Yp>\n+    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type\n+    { };\n+\n+  // when T is U[], Y(*)[] shall be convertible to T*;\n+  template<typename _Up, typename _Yp>\n+    struct __sp_is_constructible<_Up[], _Yp>\n+    : __sp_is_constructible_arr<_Up, _Yp>::type\n+    { };\n+\n+  // otherwise, Y* shall be convertible to T*.\n+  template<typename _Tp, typename _Yp>\n+    struct __sp_is_constructible\n+    : is_convertible<_Yp*, _Tp*>::type\n+    { };\n+\n+  template<typename _Tp, typename _Yp>\n+    constexpr bool __sp_is_constructible_v\n+      = __sp_is_constructible<_Tp, _Yp>::value;\n+\n+\n   // Partial specialization for base class of experimental::shared_ptr<T[N]>\n   // and experimental::shared_ptr<T[]> (i.e. the array forms).\n   template<typename _Tp, _Lock_policy _Lp>\n@@ -299,31 +365,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ delete [] __p; }\n       };\n \n+      // Constraint for constructing/resetting with a pointer of type _Yp*:\n+      template<typename _Yp>\n+\tusing _SafeConv = enable_if_t<__sp_is_constructible_v<_Tp, _Yp>>;\n+\n+      // Constraint for constructing/assigning from smart_pointer<_Tp1>:\n       template<typename _Tp1, typename _Res = void>\n-\tusing _Compatible\n-\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value, _Res>;\n+\tusing _Compatible = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n+\n+      // Constraint for constructing/assigning from unique_ptr<_Tp1, _Del>:\n+      template<typename _Tp1, typename _Del,\n+\t       typename _Ptr = typename unique_ptr<_Tp1, _Del>::pointer,\n+\t       typename _Res = void>\n+\tusing _UniqCompatible = enable_if_t<\n+\t  __sp_compatible_v<_Tp1, _Tp>\n+\t  && experimental::is_convertible_v<_Ptr, element_type*>,\n+\t  _Res>;\n \n       using _Base_type = __shared_ptr<element_type>;\n \n-      _Base_type&  _M_get_base() { return *this;}\n-      const _Base_type&  _M_get_base() const { return *this;}\n+      _Base_type&  _M_get_base() { return *this; }\n+      const _Base_type&  _M_get_base() const { return *this; }\n \n     public:\n       constexpr __shared_ptr() noexcept\n       : _Base_type()\n       { }\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(_Tp1* __p)\n+      template<typename _Tp1, typename = _SafeConv<_Tp1>>\n+\texplicit\n+\t__shared_ptr(_Tp1* __p)\n \t: _Base_type(__p, _Array_deleter())\n \t{ }\n \n-      template<typename _Tp1, typename _Deleter>\n+      template<typename _Tp1, typename _Deleter, typename = _SafeConv<_Tp1>>\n \t__shared_ptr(_Tp1* __p, _Deleter __d)\n \t: _Base_type(__p, __d)\n \t{ }\n \n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+      template<typename _Tp1, typename _Deleter, typename _Alloc,\n+\t       typename = _SafeConv<_Tp1>>\n \t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n \t: _Base_type(__p, __d, __a)\n \t{ }\n@@ -360,22 +441,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Base_type(std::move((__r._M_get_base())))\n \t{ }\n \n-      template<typename _Tp1>\n-\texplicit __shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\texplicit\n+\t__shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n \t: _Base_type(__r._M_get_base())\n \t{ }\n \n-      template<typename _Tp1, typename _Del, typename\n-\t      = _Compatible<remove_pointer_t<\n-\t\t\t    typename unique_ptr<_Tp1, _Del>::pointer>>>\n-\t  __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n-\t  : _Base_type(std::move(__r))\n-\t  { }\n+      template<typename _Tp1, typename _Del,\n+\t       typename = _UniqCompatible<_Tp1, _Del>>\n+\t__shared_ptr(unique_ptr<_Tp1, _Del>&& __r)\n+\t: _Base_type(std::move(__r))\n+\t{ }\n \n #if _GLIBCXX_USE_DEPRECATED\n       // Postcondition: use_count() == 1 and __r.get() == 0\n-      template<typename _Tp1>\n-\t__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__shared_ptr(auto_ptr<_Tp1>&& __r)\n         : _Base_type(std::move(__r))\n \t{ }\n #endif\n@@ -388,20 +469,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { __shared_ptr(nullptr).swap(*this); }\n \n       template<typename _Tp1>\n-\tvoid\n+\t_SafeConv<_Tp1>\n \treset(_Tp1* __p)\n \t{\n \t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n \t  __shared_ptr(__p, _Array_deleter()).swap(*this);\n \t}\n \n       template<typename _Tp1, typename _Deleter>\n-\tvoid\n+\t_SafeConv<_Tp1>\n \treset(_Tp1* __p, _Deleter __d)\n \t{ __shared_ptr(__p, __d).swap(*this); }\n \n       template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\tvoid\n+\t_SafeConv<_Tp1>\n \treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n \t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n \n@@ -428,9 +509,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(std::unique_ptr<_Tp1>&& __r)\n+      template<typename _Tp1, typename _Del>\n+\t_UniqCompatible<_Tp1, _Del, __shared_ptr&>\n+\toperator=(unique_ptr<_Tp1, _Del>&& __r)\n \t{\n \t  _Base_type::operator=(std::move(__r));\n \t  return *this;\n@@ -439,7 +520,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #if _GLIBCXX_USE_DEPRECATED\n       template<typename _Tp1>\n \t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\toperator=(auto_ptr<_Tp1>&& __r)\n \t{\n \t  _Base_type::operator=(std::move(__r));\n \t  return *this;\n@@ -501,11 +582,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       template<typename _Tp1, typename _Res = void>\n \tusing _Compatible\n-\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value, _Res>;\n+\t  = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n \n       using _Base_type = __weak_ptr<remove_extent_t<_Tp>>;\n \n-      _Base_type&  _M_get_base() { return *this;}\n+      _Base_type&  _M_get_base() { return *this; }\n       const _Base_type&  _M_get_base() const { return *this; }\n \n     public:\n@@ -630,26 +711,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     class shared_ptr : public __shared_ptr<_Tp>\n     {\n+      using _Base_type = __shared_ptr<_Tp>;\n+\n+    public:\n+      using element_type = typename _Base_type::element_type;\n+\n+    private:\n+      // Constraint for construction from a pointer of type _Yp*:\n+      template<typename _Yp>\n+\tusing _SafeConv = enable_if_t<__sp_is_constructible_v<_Tp, _Yp>>;\n+\n       template<typename _Tp1, typename _Res = void>\n \tusing _Compatible\n-\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value, _Res>;\n+\t  = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n \n-      using _Base_type = __shared_ptr<_Tp>;\n+      template<typename _Tp1, typename _Del,\n+\t       typename _Ptr = typename unique_ptr<_Tp1, _Del>::pointer,\n+\t       typename _Res = void>\n+\tusing _UniqCompatible = enable_if_t<\n+\t  __sp_compatible_v<_Tp1, _Tp>\n+\t  && experimental::is_convertible_v<_Ptr, element_type*>,\n+\t  _Res>;\n \n     public:\n-      using element_type = typename _Base_type::element_type;\n \n       // 8.2.1.1, shared_ptr constructors\n       constexpr shared_ptr() noexcept = default;\n \n-      template<typename _Tp1>\n-\texplicit shared_ptr(_Tp1* __p) : _Base_type(__p) { }\n+      template<typename _Tp1, typename = _SafeConv<_Tp1>>\n+\texplicit\n+\tshared_ptr(_Tp1* __p) : _Base_type(__p) { }\n \n-      template<typename _Tp1, typename _Deleter>\n+      template<typename _Tp1, typename _Deleter, typename = _SafeConv<_Tp1>>\n \tshared_ptr(_Tp1* __p, _Deleter __d)\n \t: _Base_type(__p, __d) { }\n \n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+      template<typename _Tp1, typename _Deleter, typename _Alloc,\n+\t       typename = _SafeConv<_Tp1>>\n \tshared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n \t: _Base_type(__p, __d, __a) { }\n \n@@ -679,20 +777,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tshared_ptr(shared_ptr<_Tp1>&& __r) noexcept\n \t: _Base_type(std::move(__r)) { }\n \n-      template<typename _Tp1>\n-\texplicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\texplicit\n+\tshared_ptr(const weak_ptr<_Tp1>& __r)\n \t: _Base_type(__r) { }\n \n #if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n \tshared_ptr(std::auto_ptr<_Tp1>&& __r)\n-\t: _Base_type() { } // TODO\n+\t: _Base_type(std::move(__r)) { }\n #endif\n \n-      template<typename _Tp1, typename _Del, typename\n-\t= _Compatible<remove_pointer_t<\n-\t\t      typename unique_ptr<_Tp1, _Del>::pointer>>>\n-\tshared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+      template<typename _Tp1, typename _Del,\n+\t       typename = _UniqCompatible<_Tp1, _Del>>\n+\tshared_ptr(unique_ptr<_Tp1, _Del>&& __r)\n \t: _Base_type(std::move(__r)) { }\n \n       constexpr shared_ptr(nullptr_t __p)\n@@ -738,7 +836,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n       template <typename _Tp1, typename _Del>\n-\t_Compatible<_Tp1, shared_ptr&>\n+\t_UniqCompatible<_Tp1, _Del, shared_ptr&>\n \toperator=(unique_ptr<_Tp1, _Del>&& __r)\n \t{\n \t  _Base_type::operator=(std::move(__r));\n@@ -752,10 +850,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       template<typename _Alloc, typename... _Args>\n-      shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n-\t\t _Args&&... __args)\n-      : _Base_type(__tag, __a, std::forward<_Args>(__args)...)\n-      { }\n+\tshared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+\t\t   _Args&&... __args)\n+\t: _Base_type(__tag, __a, std::forward<_Args>(__args)...)\n+\t{ }\n \n       template<typename _Tp1, typename _Alloc, typename... _Args>\n \tfriend shared_ptr<_Tp1>\n@@ -926,8 +1024,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class weak_ptr : public __weak_ptr<_Tp>\n     {\n       template<typename _Tp1, typename _Res = void>\n-\tusing _Compatible\n-\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value, _Res>;\n+\tusing _Compatible = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n \n       using _Base_type = __weak_ptr<_Tp>;\n \n@@ -1147,6 +1244,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       shared_from_this() const\n       { return shared_ptr<const _Tp>(this->_M_weak_this); }\n \n+      weak_ptr<_Tp>\n+      weak_from_this() noexcept\n+      { return _M_weak_this; }\n+\n+      weak_ptr<const _Tp>\n+      weak_from_this() const noexcept\n+      { return _M_weak_this; }\n+\n     private:\n       template<typename _Tp1>\n \tvoid"}, {"sha": "1fff0225386a42b45be498e79d19b709adf68fef", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -23,40 +23,35 @@\n #include <testsuite_hooks.h>\n \n struct A { };\n-struct B : A { };\n \n // 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n \n // Construction from pointer\n-int\n+void\n test01()\n {\n-  A * const a = 0;\n+  A * const a = new A;\n   std::experimental::shared_ptr<A> p(a);\n-  VERIFY( p.get() == 0 );\n+  VERIFY( p.get() == a );\n   VERIFY( p.use_count() == 1 );\n-  return 0;\n }\n \n-int\n+void\n test02()\n {\n   A * const a = new A[5];\n   std::experimental::shared_ptr<A[5]> p(a);\n   VERIFY( p.get() == a );\n   VERIFY( p.use_count() == 1 );\n-  return 0;\n }\n \n-int\n+void\n test03()\n {\n-  B * const b = new B[5];\n-  std::experimental::shared_ptr<A[5]> p(b);\n-  VERIFY( p.get() == b );\n+  A * const a = new A[5];\n+  std::experimental::shared_ptr<A[]> p(a);\n+  VERIFY( p.get() == a );\n   VERIFY( p.use_count() == 1 );\n-\n-  return 0;\n }\n \n int"}, {"sha": "8fcd40ce8f0874e397c50807c130e904bac36c95", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/pointer_ctor_neg.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor_neg.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do compile { target c++14 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+\n+struct A { };\n+struct B : A { };\n+struct C { };\n+struct D { void operator()(B* p) const { delete[] p; } };\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Construction from pointer\n+void\n+test01()\n+{\n+  C * const c = nullptr;\n+  std::experimental::shared_ptr<A> p(c); // { dg-error \"no match\" }\n+}\n+\n+void\n+test02()\n+{\n+  B * const b = nullptr;\n+  std::experimental::shared_ptr<A[5]> p(b); // { dg-error \"no match\" }\n+}\n+\n+void\n+test03()\n+{\n+  B * const b = nullptr;\n+  std::experimental::shared_ptr<A[]> p(b); // { dg-error \"no match\" }\n+}"}, {"sha": "bade9d83dd45d5dc89d5416b11624bf171ed7146", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/torture.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Ftorture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Ftorture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Ftorture.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do compile { target c++14 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+\n+using namespace std::experimental;\n+\n+static_assert( !is_constructible_v<shared_ptr<int>, void*>,\n+    \"can query constructibility without forming invalid type void[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[2]>, void*>,\n+    \"can query constructibility without forming invalid type void[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[]>, void*>,\n+    \"can query constructibility without forming invalid type void[]\");\n+\n+static_assert( !is_constructible_v<shared_ptr<int>, void()>,\n+    \"can query constructibility without forming invalid type void()[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[2]>, void()>,\n+    \"can query constructibility without forming invalid type void()[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[]>, void()>,\n+    \"can query constructibility without forming invalid type void()[]\");\n+\n+static_assert( !is_constructible_v<shared_ptr<int>, void()>,\n+    \"can query constructibility without forming invalid type void(*)()[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[2]>, void()>,\n+    \"can query constructibility without forming invalid type void(*)()[]\");\n+static_assert( !is_constructible_v<shared_ptr<int[]>, void()>,\n+    \"can query constructibility without forming invalid type void(*)()[]\");\n+\n+using A = int[];\n+static_assert( !is_constructible_v<shared_ptr<int>, A*>,\n+    \"can query constructibility without forming invalid type int[][]\");\n+static_assert( !is_constructible_v<shared_ptr<int[2]>, A*>,\n+    \"can query constructibility without forming invalid type int[][]\");\n+static_assert( !is_constructible_v<shared_ptr<int[]>, A*>,\n+    \"can query constructibility without forming invalid type int[][]\");"}, {"sha": "631212fc4cd1493b193d19dd4025a6e0cb5ea175", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/unique_ptr_ctor.cc", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -26,17 +26,17 @@ int destroyed = 0;\n \n struct A : std::experimental::enable_shared_from_this<A>\n {\n-    ~A() { ++destroyed; }\n+  ~A() { ++destroyed; }\n };\n \n // 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n \n // Construction from unique_ptr<A[]>\n \n-int\n+void\n test01()\n {\n-  std::unique_ptr<A[]> up(new A[5]);\n+  std::unique_ptr<A> up(new A);\n   std::experimental::shared_ptr<A> sp(std::move(up));\n   VERIFY( up.get() == 0 );\n   VERIFY( sp.get() != 0 );\n@@ -45,14 +45,28 @@ test01()\n   VERIFY( sp->shared_from_this() != nullptr );\n \n   sp.reset();\n-  VERIFY( destroyed == 5 );\n+  VERIFY( destroyed == 1 );\n+  destroyed = 0;\n+}\n \n-  return 0;\n+void\n+test02()\n+{\n+  std::unique_ptr<A[]> up(new A[5]);\n+  std::experimental::shared_ptr<A[]> sp(std::move(up));\n+  VERIFY( up.get() == 0 );\n+  VERIFY( sp.get() != 0 );\n+  VERIFY( sp.use_count() == 1 );\n+\n+  VERIFY( sp[0].shared_from_this() != nullptr );\n+\n+  sp.reset();\n+  VERIFY( destroyed == 5 );\n }\n \n int\n main()\n {\n   test01();\n-  return 0;\n+  test02();\n }"}, {"sha": "8df0602f4f867c0a6f70449db65c609b3bec894e", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/modifiers/reset.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -23,10 +23,9 @@\n #include <testsuite_hooks.h>\n \n struct A { };\n-struct B : A { };\n struct D\n {\n-  void operator()(B* p) { delete [] p; ++delete_count; }\n+  void operator()(A* p) { delete [] p; ++delete_count; }\n   static long delete_count;\n };\n long D::delete_count = 0;\n@@ -51,7 +50,7 @@ int\n test02()\n {\n   A * const a = new A[5];\n-  B * const b = new B[5];\n+  A * const b = new A[5];\n   std::experimental::shared_ptr<A[5]> p1(a);\n   std::experimental::shared_ptr<A[5]> p2(p1);\n   p1.reset(b);\n@@ -66,7 +65,7 @@ test03()\n {\n   {\n     std::experimental::shared_ptr<A[5]> p1;\n-    p1.reset(new B[5], D());\n+    p1.reset(new A[5], D());\n   }\n   VERIFY( D::delete_count == 1 );\n "}, {"sha": "0332c4e7603e454a4c842c73151b83e525c3adab", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/modifiers/reset_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset_neg.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do compile { target c++14 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+\n+struct A { };\n+struct B : A { };\n+struct D\n+{\n+  void operator()(A* p) { delete [] p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// C++14 \u00a720.8.2.2.4\n+\n+// reset\n+void\n+test01()\n+{\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  p1.reset(new B[1]);           // { dg-error \"no matching function\" }\n+  p1.reset(new B[5], D());      // { dg-error \"no matching function\" }\n+  using constA = const A;\n+  p1.reset(new constA[5]);      // { dg-error \"no matching function\" }\n+  p1.reset(new constA[5], D()); // { dg-error \"no matching function\" }\n+}"}, {"sha": "a91a92a43b15531d4032777d99ef613b314f31f7", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/observers/use_count.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84870b6bb2691cc4031b8408b41bbb6583526c0f/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc?ref=84870b6bb2691cc4031b8408b41bbb6583526c0f", "patch": "@@ -23,7 +23,6 @@\n #include <testsuite_hooks.h>\n \n struct A { };\n-struct B : A { };\n \n // 8.2.1.2 shared_ptr observers [memory.smartptr.shared.obs]\n \n@@ -52,7 +51,7 @@ test03()\n {\n   std::experimental::shared_ptr<A[5]> p1(new A[5]);\n   std::experimental::shared_ptr<A[5]> p2(p1);\n-  p2.reset(new B[5]);\n+  p2.reset(new A[5]);\n   VERIFY( p1.use_count() == 1 );\n   VERIFY( p2.use_count() == 1 );\n }"}]}