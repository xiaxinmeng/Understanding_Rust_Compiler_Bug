{"sha": "03f82a6a634ddfa5828843b647c896968aee3702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmODJhNmE2MzRkZGZhNTgyODg0M2I2NDdjODk2OTY4YWVlMzcwMg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@codesourcery.com", "date": "2016-11-27T14:50:58Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2016-11-27T14:50:58Z"}, "message": "[Darwin] Fix PR57438 by avoiding empty function bodies and trailing labels.\n\nA.\nEmpty function bodies causes two problems for Darwin's linker (i) zero-length\nFDEs and (ii) coincident label addresses that might point to items of\ndiffering weakness.\n\nB.\nTrailing local labels can be problematic when they end a function because\nsimilarly they might apparently point to a following weak function, leading\nto the linker concluding that there's a pointer-diff to a weak symbol\n(which is not allowed).\n\nBoth conditions arise from __builtin_unreachable() lowering to a barrier.\n\nThe solution for both is to emit some finite amount of code; in the case of A\na trap is emitted, in the case of B a nop.\n\ngcc/\n\n2016-11-27  Iain Sandoe  <iain@codesourcery.com>\n\n\tPR target/57438\n\t* config/i386/i386.c (ix86_code_end): Note that we emitted code\n\twhere the function might otherwise appear empty for picbase thunks.\n\t(ix86_output_function_epilogue): If we find a zero-sized function\n\tassume that reaching it is UB and trap.  If we find a trailing label\n\tappend a nop.\n\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue): If we\n\tfind a zero-sized function assume that reaching it is UB and trap.\n\tIf we find a trailing label, append a nop.\n\ngcc/testsuite/\n\n2016-11-27  Iain Sandoe  <iain@codesourcery.com>\n\n\tPR target/57438\n\t* gcc.dg/pr57438-1.c: New Test.\n\t* gcc.dg/pr57438-2.c: New Test.\n\nFrom-SVN: r242897", "tree": {"sha": "140872532edd4731db6a4bb484ccd9c91f5cc3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140872532edd4731db6a4bb484ccd9c91f5cc3e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03f82a6a634ddfa5828843b647c896968aee3702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f82a6a634ddfa5828843b647c896968aee3702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f82a6a634ddfa5828843b647c896968aee3702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f82a6a634ddfa5828843b647c896968aee3702/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "987395fd6592568a578e9906727b3e7b0164bc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987395fd6592568a578e9906727b3e7b0164bc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/987395fd6592568a578e9906727b3e7b0164bc66"}], "stats": {"total": 193, "additions": 159, "deletions": 34}, "files": [{"sha": "a57eaab8b20e300da75bd9bda1fadf8f280608b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -1,3 +1,15 @@\n+2016-11-27  Iain Sandoe  <iain@codesourcery.com>\n+\n+\tPR target/57438\n+\t* config/i386/i386.c (ix86_code_end): Note that we emitted code\n+\twhere the function might otherwise appear empty for picbase thunks.\n+\t(ix86_output_function_epilogue): If we find a zero-sized function\n+\tassume that reaching it is UB and trap.  If we find a trailing label\n+\tappend a nop.\n+\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue): If we\n+\tfind a zero-sized function assume that reaching it is UB and trap.\n+\tIf we find a trailing label, append a nop.\n+\n 2016-11-27  Iain Sandoe  <iain@codesourcery.com>\n \n \tPR target/71767"}, {"sha": "5018ccb633aef756c13c273b70b65365fd40bc6a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -11920,6 +11920,9 @@ ix86_code_end (void)\n       current_function_decl = decl;\n       allocate_struct_function (decl, false);\n       init_function_start (decl);\n+      /* We're about to hide the function body from callees of final_* by\n+\t emitting it directly; tell them we're a thunk, if they care.  */\n+      cfun->is_thunk = true;\n       first_function_block_is_cold = false;\n       /* Make sure unwind info is emitted for the thunk if needed.  */\n       final_start_function (emit_barrier (), asm_out_file, 1);\n@@ -14625,36 +14628,68 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED, HOST_WIDE_INT)\n   if (pic_offset_table_rtx\n       && !ix86_use_pseudo_pic_reg ())\n     SET_REGNO (pic_offset_table_rtx, REAL_PIC_OFFSET_TABLE_REGNUM);\n-#if TARGET_MACHO\n-  /* Mach-O doesn't support labels at the end of objects, so if\n-     it looks like we might want one, insert a NOP.  */\n-  {\n-    rtx_insn *insn = get_last_insn ();\n-    rtx_insn *deleted_debug_label = NULL;\n-    while (insn\n-\t   && NOTE_P (insn)\n-\t   && NOTE_KIND (insn) != NOTE_INSN_DELETED_LABEL)\n-      {\n-\t/* Don't insert a nop for NOTE_INSN_DELETED_DEBUG_LABEL\n-\t   notes only, instead set their CODE_LABEL_NUMBER to -1,\n-\t   otherwise there would be code generation differences\n-\t   in between -g and -g0.  */\n-\tif (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL)\n-\t  deleted_debug_label = insn;\n+\n+  if (TARGET_MACHO)\n+    {\n+      rtx_insn *insn = get_last_insn ();\n+      rtx_insn *deleted_debug_label = NULL;\n+\n+      /* Mach-O doesn't support labels at the end of objects, so if\n+         it looks like we might want one, take special action.\n+        First, collect any sequence of deleted debug labels.  */\n+      while (insn\n+\t     && NOTE_P (insn)\n+\t     && NOTE_KIND (insn) != NOTE_INSN_DELETED_LABEL)\n+\t{\n+\t  /* Don't insert a nop for NOTE_INSN_DELETED_DEBUG_LABEL\n+\t     notes only, instead set their CODE_LABEL_NUMBER to -1,\n+\t     otherwise there would be code generation differences\n+\t     in between -g and -g0.  */\n+\t  if (NOTE_P (insn) && NOTE_KIND (insn)\n+\t      == NOTE_INSN_DELETED_DEBUG_LABEL)\n+\t    deleted_debug_label = insn;\n+\t  insn = PREV_INSN (insn);\n+\t}\n+\n+      /* If we have:\n+\t label:\n+\t    barrier\n+\t  then this needs to be detected, so skip past the barrier.  */\n+\n+      if (insn && BARRIER_P (insn))\n \tinsn = PREV_INSN (insn);\n-      }\n-    if (insn\n-\t&& (LABEL_P (insn)\n-\t    || (NOTE_P (insn)\n-\t\t&& NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL)))\n-      fputs (\"\\tnop\\n\", file);\n-    else if (deleted_debug_label)\n-      for (insn = deleted_debug_label; insn; insn = NEXT_INSN (insn))\n-\tif (NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL)\n-\t  CODE_LABEL_NUMBER (insn) = -1;\n-  }\n-#endif\n \n+      /* Up to now we've only seen notes or barriers.  */\n+      if (insn)\n+\t{\n+\t  if (LABEL_P (insn)\n+\t      || (NOTE_P (insn)\n+\t\t  && NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))\n+\t    /* Trailing label.  */\n+\t    fputs (\"\\tnop\\n\", file);\n+\t  else if (cfun && ! cfun->is_thunk)\n+\t    {\n+\t      /* See if we have a completely empty function body, skipping\n+\t         the special case of the picbase thunk emitted as asm.  */\n+\t      while (insn && ! INSN_P (insn))\n+\t\tinsn = PREV_INSN (insn);\n+\t      /* If we don't find any insns, we've got an empty function body;\n+\t\t I.e. completely empty - without a return or branch.  This is\n+\t\t taken as the case where a function body has been removed\n+\t\t because it contains an inline __builtin_unreachable().  GCC\n+\t\t declares that reaching __builtin_unreachable() means UB so\n+\t\t we're not obliged to do anything special; however, we want\n+\t\t non-zero-sized function bodies.  To meet this, and help the\n+\t\t user out, let's trap the case.  */\n+\t      if (insn == NULL)\n+\t\tfputs (\"\\tud2\\n\", file);\n+\t    }\n+\t}\n+      else if (deleted_debug_label)\n+\tfor (insn = deleted_debug_label; insn; insn = NEXT_INSN (insn))\n+\t  if (NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL)\n+\t    CODE_LABEL_NUMBER (insn) = -1;\n+    }\n }\n \n /* Return a scratch register to use in the split stack prologue.  The"}, {"sha": "6c28e6aaf6543a03b5db0a91e35b452d1eb47b98", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -30234,11 +30234,15 @@ rs6000_output_function_epilogue (FILE *file,\n {\n #if TARGET_MACHO\n   macho_branch_islands ();\n-  /* Mach-O doesn't support labels at the end of objects, so if\n-     it looks like we might want one, insert a NOP.  */\n+\n   {\n     rtx_insn *insn = get_last_insn ();\n     rtx_insn *deleted_debug_label = NULL;\n+\n+    /* Mach-O doesn't support labels at the end of objects, so if\n+       it looks like we might want one, take special action.\n+\n+       First, collect any sequence of deleted debug labels.  */\n     while (insn\n \t   && NOTE_P (insn)\n \t   && NOTE_KIND (insn) != NOTE_INSN_DELETED_LABEL)\n@@ -30251,11 +30255,40 @@ rs6000_output_function_epilogue (FILE *file,\n \t  deleted_debug_label = insn;\n \tinsn = PREV_INSN (insn);\n       }\n-    if (insn\n-\t&& (LABEL_P (insn)\n+\n+    /* Second, if we have:\n+       label:\n+\t barrier\n+       then this needs to be detected, so skip past the barrier.  */\n+\n+    if (insn && BARRIER_P (insn))\n+      insn = PREV_INSN (insn);\n+\n+    /* Up to now we've only seen notes or barriers.  */\n+    if (insn)\n+      {\n+\tif (LABEL_P (insn)\n \t    || (NOTE_P (insn)\n-\t\t&& NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL)))\n-      fputs (\"\\tnop\\n\", file);\n+\t\t&& NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))\n+\t  /* Trailing label: <barrier>.  */\n+\t  fputs (\"\\tnop\\n\", file);\n+\telse\n+\t  {\n+\t    /* Lastly, see if we have a completely empty function body.  */\n+\t    while (insn && ! INSN_P (insn))\n+\t      insn = PREV_INSN (insn);\n+\t    /* If we don't find any insns, we've got an empty function body;\n+\t       I.e. completely empty - without a return or branch.  This is\n+\t       taken as the case where a function body has been removed\n+\t       because it contains an inline __builtin_unreachable().  GCC\n+\t       states that reaching __builtin_unreachable() means UB so we're\n+\t       not obliged to do anything special; however, we want\n+\t       non-zero-sized function bodies.  To meet this, and help the\n+\t       user out, let's trap the case.  */\n+\t    if (insn == NULL)\n+\t      fputs (\"\\ttrap\\n\", file);\n+\t  }\n+      }\n     else if (deleted_debug_label)\n       for (insn = deleted_debug_label; insn; insn = NEXT_INSN (insn))\n \tif (NOTE_KIND (insn) == NOTE_INSN_DELETED_DEBUG_LABEL)"}, {"sha": "d7eacc3543e12647f1890108b2accd4086bd1586", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -1,3 +1,9 @@\n+2016-11-27  Iain Sandoe  <iain@codesourcery.com>\n+\n+\tPR target/57438\n+\t* gcc.dg/pr57438-1.c: New Test.\n+\t* gcc.dg/pr57438-2.c: New Test.\n+\n 2016-11-27  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \t    Iain Sandoe  <iain@codesourcery.com>\n "}, {"sha": "9bfd8b9d9111153f5b3147b7d4dda57f7d4e86e5", "filename": "gcc/testsuite/gcc.dg/pr57438-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-1.c?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-additional-options \"-mdynamic-no-pic\" { target powerpc*-*-darwin* } }\n+\n+/* This is testing that a completely empty function body results in the\n+   insertion of a ud2/trap instruction to prevent a zero-sized FDE, and/or\n+   the function label apparently pointing to following code.  */\n+\n+__attribute__((noinline))\n+void foo (void)\n+{\n+  __builtin_unreachable();\n+}\n+\n+/* { dg-final { scan-assembler \"ud2\" { target  { i?86-*-darwin*  x86_64-*-darwin* } } } } */\n+/* { dg-final { scan-assembler \"trap\" { target { powerpc*-*-darwin* } } } } */"}, {"sha": "f3ff1dc1ed208e02df0ee23ea351abffbe765687", "filename": "gcc/testsuite/gcc.dg/pr57438-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03f82a6a634ddfa5828843b647c896968aee3702/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr57438-2.c?ref=03f82a6a634ddfa5828843b647c896968aee3702", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target *-*-darwin* } } */\n+/* { dg-options \"--param case-values-threshold=3 -O2\" } */\n+/* { dg-additional-options \"-funwind-tables\" { target powerpc*-*-darwin* } }\n+\n+/* This is testing that a trailing local label is followed by a\n+   nop where required.  */\n+   \n+int foo (int x)\n+{\n+  switch (x)\n+    {\n+      case 0:\n+        return 10;\n+      case 3:\n+        return -1;\n+      case 5:\n+        return 29;\n+      default:\n+        __builtin_unreachable();\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"nop\\\\nLFE.*\" { target  { *-*-darwin* } } } } */"}]}