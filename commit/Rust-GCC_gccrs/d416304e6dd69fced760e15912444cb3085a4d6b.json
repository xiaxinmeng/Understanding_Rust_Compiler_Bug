{"sha": "d416304e6dd69fced760e15912444cb3085a4d6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQxNjMwNGU2ZGQ2OWZjZWQ3NjBlMTU5MTI0NDRjYjMwODVhNGQ2Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-05-28T18:03:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-05-28T18:03:56Z"}, "message": "tree-ssa-threadupdate.c: (create_edge_and_update_destination_phis): Update profile.\n\n\n\t* tree-ssa-threadupdate.c: (create_edge_and_update_destination_phis):\n\tUpdate profile.\n\t* value-prof.c (tree_divmod_fixed_value_transform): Be more verbose in\n\tdebug output.\n\t(tree_mod_subtract): Fix profile updating code.\n\t(tree_divmod_values_to_profile): Do not produce useless value profilers\n\tfor divisions.\n\n\t* tree-prof.exp: Fix comment.\n\t* value-prof-1.c: New.\n\t* value-prof-2.c: New.\n\t* value-prof-3.c: New.\n\t* value-prof-4.c: New.\n\nFrom-SVN: r100298", "tree": {"sha": "dd229dc2bdb52fc7314fe74408a642d2f50015b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd229dc2bdb52fc7314fe74408a642d2f50015b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d416304e6dd69fced760e15912444cb3085a4d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d416304e6dd69fced760e15912444cb3085a4d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d416304e6dd69fced760e15912444cb3085a4d6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d416304e6dd69fced760e15912444cb3085a4d6b/comments", "author": null, "committer": null, "parents": [{"sha": "eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaef357b0fc6b96846d872afeb0afedd0f8fe24b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaef357b0fc6b96846d872afeb0afedd0f8fe24b"}], "stats": {"total": 170, "additions": 151, "deletions": 19}, "files": [{"sha": "50e3e65c45a0e8ba08e1e3447deeb3cf5a7b46d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -1,3 +1,13 @@\n+2005-05-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-threadupdate.c: (create_edge_and_update_destination_phis):\n+\tUpdate profile.\n+\t* value-prof.c (tree_divmod_fixed_value_transform): Be more verbose in\n+\tdebug output.\n+\t(tree_mod_subtract): Fix profile updating code.\n+\t(tree_divmod_values_to_profile): Do not produce useless value profilers\n+\tfor divisions.\n+\n 2005-05-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-dom.c (vrp_element_p): Define."}, {"sha": "0416c70aed4b6e70c36ae0a93511b506ac8dc247", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -1,3 +1,11 @@\n+2005-05-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-prof.exp: Fix comment.\n+\t* value-prof-1.c: New.\n+\t* value-prof-2.c: New.\n+\t* value-prof-3.c: New.\n+\t* value-prof-4.c: New.\n+\n 2005-05-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/21614"}, {"sha": "9559a80e187b2aeb430f1677f82eb45035ba5d3d", "filename": "gcc/testsuite/gcc.dg/tree-prof/tree-prof.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftree-prof.exp?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -15,7 +15,7 @@\n # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n \n # Test the functionality of programs compiled with profile-directed block\n-# ordering using -fprofile-generate followed by -fprofile-use\n+# ordering using -fprofile-generate followed by -fbranch-use.\n \n load_lib target-supports.exp\n "}, {"sha": "db3bc950f5a6ea401d46900996dba4ac42d5b258", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-1.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+int a[1000];\n+int b = 256;\n+int c = 257;\n+main ()\n+{\n+  int i;\n+  int n;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      if (i % 17)\n+\tn = c;\n+      else n = b;\n+      a[i] /= n;\n+    }\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Div.mod by constant n=257 transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n != 257\\\\)\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "c11f7ea20e42742c27f138088b469e29302ff1c3", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-2.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+unsigned int a[1000];\n+unsigned int b = 256;\n+unsigned int c = 1024;\n+unsigned int d = 17;\n+main ()\n+{\n+  int i;\n+  unsigned int n;\n+  for (i = 0; i < 1000; i++)\n+    {\n+\t    a[i]=100*i;\n+    }\n+  for (i = 0; i < 1000; i++)\n+    {\n+      if (i % 2)\n+\tn = b;\n+      else if (i % 3)\n+\tn = c;\n+      else\n+\tn = d;\n+      a[i] %= n;\n+    }\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Mod power of 2 transformation on insn\" \"tree_profile\"} } */\n+/* This is part of code checking that n is power of 2, so we are sure that the transformation\n+   didn't get optimized out.  */\n+/* { dg-final-use { scan-tree-dump \"n \\\\+ \\\\-1\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "91ebd376177fcb511700271892c4ee8e785a97ee", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+unsigned int a[1000];\n+unsigned int b = 257;\n+unsigned int c = 1023;\n+unsigned int d = 19;\n+main ()\n+{\n+  int i;\n+  unsigned int n;\n+  for (i = 0; i < 1000; i++)\n+    {\n+\t    a[i]=18;\n+    }\n+  for (i = 0; i < 1000; i++)\n+    {\n+      if (i % 2)\n+\tn = b;\n+      else if (i % 3)\n+\tn = c;\n+      else\n+\tn = d;\n+      a[i] %= n;\n+    }\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n+/* This is part of code checking that n is greater than the divisor so we are sure that it\n+   didn't get optimized out.  */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n \\\\>\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "4fff1123beb6a437da532aac0fc8220d32347e89", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-4.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-4.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+unsigned int a[1000];\n+unsigned int b = 999;\n+unsigned int c = 1002;\n+unsigned int d = 1003;\n+main ()\n+{\n+  int i;\n+  unsigned int n;\n+  for (i = 0; i < 1000; i++)\n+    {\n+\t    a[i]=1000+i;\n+    }\n+  for (i = 0; i < 1000; i++)\n+    {\n+      if (i % 2)\n+\tn = b;\n+      else if (i % 3)\n+\tn = c;\n+      else\n+\tn = d;\n+      a[i] %= n;\n+    }\n+  return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Mod subtract transformation on insn\" \"tree_profile\"} } */\n+/* This is part of code checking that n is greater than the divisor so we are sure that it\n+   didn't get optimized out.  */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(n \\\\>\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "303463850d0c8bfc56bad1e14df7a26403cd3dae", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -299,6 +299,9 @@ create_edge_and_update_destination_phis (struct redirection_data *rd)\n   edge e = make_edge (rd->dup_block, rd->outgoing_edge->dest, EDGE_FALLTHRU);\n   tree phi;\n \n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = rd->dup_block->count;\n+\n   /* If there are any PHI nodes at the destination of the outgoing edge\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument"}, {"sha": "e6b45a519e5965a8ad95d9e982d04a6a338c81cf", "filename": "gcc/value-prof.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d416304e6dd69fced760e15912444cb3085a4d6b/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=d416304e6dd69fced760e15912444cb3085a4d6b", "patch": "@@ -1221,12 +1221,6 @@ tree_divmod_fixed_value_transform (tree stmt)\n   if (simple_cst_equal (op2, value) != 1 || 2 * count < all)\n     return false;\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Div/mod by constant transformation on insn \");\n-      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n-    }\n-\n   /* Compute probability of taking the optimal path.  */\n   prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n \n@@ -1235,6 +1229,16 @@ tree_divmod_fixed_value_transform (tree stmt)\n \t\t\t\t val >> (HOST_BITS_PER_WIDE_INT - 1) >> 1);\n   result = tree_divmod_fixed_value (stmt, op, op1, op2, tree_val, prob, count, all);\n \n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Div/mod by constant \");\n+      print_generic_expr (dump_file, value, TDF_SLIM);\n+      fprintf (dump_file, \"=\");\n+      print_generic_expr (dump_file, tree_val, TDF_SLIM);\n+      fprintf (dump_file, \" transformation on insn \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+    }\n+\n   TREE_OPERAND (modify, 1) = result;\n \n   return true;\n@@ -1489,11 +1493,11 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   e12->flags &= ~EDGE_FALLTHRU;\n   e12->flags |= EDGE_FALSE_VALUE;\n   e12->probability = REG_BR_PROB_BASE - prob1;\n-  e12->count = count1;\n+  e12->count = all - count1;\n \n   e14 = make_edge (bb, bb4, EDGE_TRUE_VALUE);\n   e14->probability = prob1;\n-  e14->count = all - count1;\n+  e14->count = count1;\n \n   if (ncounts)  /* Assumed to be 0 or 1.  */\n     {\n@@ -1653,16 +1657,6 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n \n       if (is_gimple_reg (divisor))\n \t{\n-\t  /* Check for a special case where the divisor is power(s) of 2.\n-\t     This is more aggressive than the RTL version, under the\n-\t     assumption that later phases will reduce / or % by power of 2\n-\t     to something clever most of the time.  Signed or unsigned.  */\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.tree.value = divisor;\n-\t  hist->hvalue.tree.stmt = stmt;\n-\t  hist->type = HIST_TYPE_POW2;\n-\t  VEC_quick_push (histogram_value, *values, hist);\n-\n \t  /* Check for the case where the divisor is the same value most\n \t     of the time.  */\n \t  hist = ggc_alloc (sizeof (*hist));\n@@ -1677,6 +1671,13 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n       if (TREE_CODE (rhs) == TRUNC_MOD_EXPR\n \t  && TYPE_UNSIGNED (type))\n \t{\n+          /* Check for a special case where the divisor is power of 2.  */\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->hvalue.tree.value = divisor;\n+\t  hist->hvalue.tree.stmt = stmt;\n+\t  hist->type = HIST_TYPE_POW2;\n+\t  VEC_quick_push (histogram_value, *values, hist);\n+\n \t  hist = ggc_alloc (sizeof (*hist));\n \t  hist->hvalue.tree.stmt = stmt;\n \t  hist->hvalue.tree.value"}]}