{"sha": "aea8fc973762254dfd518d202975bc043aba4ba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhOGZjOTczNzYyMjU0ZGZkNTE4ZDIwMjk3NWJjMDQzYWJhNGJhOQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-06-30T08:50:14Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-06-30T08:50:14Z"}, "message": "rx-modes.def: New file.\n\n        * config/rx/rx-modes.def: New file.\n        * config/rx/rx.h (FIRST_PSEUDO_REGISTER): Increase to 17.\n        (CC_REGNUM): Define.\n        (FIXED_REGISTERS, CALL_USED_REGISTERS, REGISTER_NAMES): Add cc\n        register.\n        (CC_NO_CARRY, NOTICE_UPDATE_CC): Delete.\n        (SELECT_CC_MODE): Define.\n        * config/rx/rx.md (CC_REG): Define.  Update all patterns to use\n        (reg:CC CC_REG) instead of (cc0).\n        (attr \"cc\"): Delete.\n        (cbranchsi4): Do not split compare and branch here. Instead move\n        it to...\n        (cbranchsi4_<code>): ... here.  New patterns.\n        (cmpsi): Call rx-compare_redundant to find out if it is necessary\n        to emit the compare instruction.\n        * config/rx/rx.c (rx_gen-cond_branch_template): Remove tests of\n        cc_status flags.\n        (rx_get_stack_layout): Iterate up to before CC_REGNUM not\n        FIRST_PSEUDO_REGNUM.\n        (rx_expand_prologue, rx_expand_epilogue): Likewise.\n        (rx_notice_update_cc): Delete.\n        (rx_cc_modes_compatible): New function.\n        (flags_needed_for_conditional): New function.\n        (flags_from_mode): New function.\n        (rx_compare_redundant): New function - scans backwards through\n        insn list to find out if condition flags are already set\n        correctly.\n        (TARGET_CC_MODES_COMPATIBLE): Define.\n        * config/rx/rx-protos.h (rx_compare_redundant): Prototype.\n\n        * config/rx/rx.h (BRANCH_COST): Define.\n        (REGISTER_MOVE_COST): Define.\n        * config/rx/predicates (rx_source_operand): Allow all constant\n        types.\n        * config/rx/rx.md (addsi3): Add alternative for swapped operands.\n        (tstsi4): New pattern.\n        * config/rx/rx.c (rx_memory_move_cost): Define.\n        (TARGET_MEMORY_MOVE_COST): Define.\n\nFrom-SVN: r161592", "tree": {"sha": "01f9bb4c0964cfdc72ea8fd3a7fc97fe6aa30df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01f9bb4c0964cfdc72ea8fd3a7fc97fe6aa30df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea8fc973762254dfd518d202975bc043aba4ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea8fc973762254dfd518d202975bc043aba4ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea8fc973762254dfd518d202975bc043aba4ba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea8fc973762254dfd518d202975bc043aba4ba9/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6662d794044f9124db635ba8acaa82c9483a3b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6662d794044f9124db635ba8acaa82c9483a3b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6662d794044f9124db635ba8acaa82c9483a3b33"}], "stats": {"total": 914, "additions": 601, "deletions": 313}, "files": [{"sha": "bd7f730d6c2eb880e18fb8e8abdf4f520ddab031", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -1,3 +1,44 @@\n+2010-06-30  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rx/rx-modes.def: New file.\n+\t* config/rx/rx.h (FIRST_PSEUDO_REGISTER): Increase to 17.\n+\t(CC_REGNUM): Define.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REGISTER_NAMES): Add cc\n+\tregister.\n+\t(CC_NO_CARRY, NOTICE_UPDATE_CC): Delete.\n+\t(SELECT_CC_MODE): Define.\n+\t* config/rx/rx.md (CC_REG): Define.  Update all patterns to use\n+\t(reg:CC CC_REG) instead of (cc0).\n+\t(attr \"cc\"): Delete.\n+\t(cbranchsi4): Do not split compare and branch here. Instead move\n+\tit to...\n+\t(cbranchsi4_<code>): ... here.  New patterns.\n+\t(cmpsi): Call rx-compare_redundant to find out if it is necessary\n+\tto emit the compare instruction.\n+\t* config/rx/rx.c (rx_gen-cond_branch_template): Remove tests of\n+\tcc_status flags.\n+\t(rx_get_stack_layout): Iterate up to before CC_REGNUM not\n+\tFIRST_PSEUDO_REGNUM.\n+\t(rx_expand_prologue, rx_expand_epilogue): Likewise.\n+\t(rx_notice_update_cc): Delete.\n+\t(rx_cc_modes_compatible): New function.\n+\t(flags_needed_for_conditional): New function.\n+\t(flags_from_mode): New function.\n+\t(rx_compare_redundant): New function - scans backwards through\n+\tinsn list to find out if condition flags are already set\n+\tcorrectly.\n+\t(TARGET_CC_MODES_COMPATIBLE): Define.\n+\t* config/rx/rx-protos.h (rx_compare_redundant): Prototype.\n+\n+\t* config/rx/rx.h (BRANCH_COST): Define.\n+\t(REGISTER_MOVE_COST): Define.\n+\t* config/rx/predicates (rx_source_operand): Allow all constant\n+\ttypes.\n+\t* config/rx/rx.md (addsi3): Add alternative for swapped operands.\n+\t(tstsi4): New pattern.\n+\t* config/rx/rx.c (rx_memory_move_cost): Define.\n+\t(TARGET_MEMORY_MOVE_COST): Define.\n+\n 2010-06-30  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* tree.h (block_may_fallthru): Declare here."}, {"sha": "94e5f5630c231f3c02a7ebe98b9dac913d888169", "filename": "gcc/config/rx/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -50,9 +50,9 @@\n ;; and a restricted subset of memory addresses are allowed.\n \n (define_predicate \"rx_source_operand\"\n-  (match_code \"const_int,reg,mem\")\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,reg,mem\")\n   {\n-    if (CONST_INT_P (op))\n+    if (CONSTANT_P (op))\n       return rx_is_legitimate_constant (op);\n \n     if (! MEM_P (op))"}, {"sha": "5936b672b6bc4471365f9ba8bc8d3f4b39ea64c2", "filename": "gcc/config/rx/rx-modes.def", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-modes.def?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -0,0 +1,26 @@\n+/* Definitions of target machine for GNU compiler, for ARM.\n+   Copyright (C) 2002, 2004, 2007 Free Software Foundation, Inc.\n+   Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n+   and Martin Simmons (@harleqn.co.uk).\n+   More major hacks by Richard Earnshaw (rearnsha@arm.com)\n+   Minor hacks by Nick Clifton (nickc@cygnus.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+CC_MODE (CC_ZS);\n+CC_MODE (CC_ZSO);\n+CC_MODE (CC_ZSC);"}, {"sha": "166290de5e72d7b95264e5bf70f286a05df5a3c6", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -31,6 +31,7 @@ extern int\t\trx_initial_elimination_offset (int, int);\n extern void\t\trx_set_optimization_options (void);\n \n #ifdef RTX_CODE\n+extern bool\t\trx_compare_redundant (rtx);\n extern void             rx_emit_stack_popm (rtx *, bool);\n extern void             rx_emit_stack_pushm (rtx *);\n extern void\t\trx_expand_epilogue (bool);"}, {"sha": "2219efe8559de8af6a15c8ffd9aa090d9176a48e", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 226, "deletions": 59, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -707,12 +707,6 @@ rx_gen_cond_branch_template (rtx condition, bool reversed)\n {\n   enum rtx_code code = GET_CODE (condition);\n \n-  if ((cc_status.flags & CC_NO_OVERFLOW) && ! rx_float_compare_mode)\n-    gcc_assert (code != GT && code != GE && code != LE && code != LT);\n-\n-  if ((cc_status.flags & CC_NO_CARRY) || rx_float_compare_mode)\n-    gcc_assert (code != GEU && code != GTU && code != LEU && code != LTU);\n-\n   if (reversed)\n     {\n       if (rx_float_compare_mode)\n@@ -1063,7 +1057,7 @@ rx_get_stack_layout (unsigned int * lowest,\n       return;\n     }\n \n-  for (save_mask = high = low = 0, reg = 1; reg < FIRST_PSEUDO_REGISTER; reg++)\n+  for (save_mask = high = low = 0, reg = 1; reg < CC_REGNUM; reg++)\n     {\n       if (df_regs_ever_live_p (reg)\n \t  && (! call_used_regs[reg]\n@@ -1241,7 +1235,7 @@ rx_expand_prologue (void)\n   if (mask)\n     {\n       /* Push registers in reverse order.  */\n-      for (reg = FIRST_PSEUDO_REGISTER; reg --;)\n+      for (reg = CC_REGNUM; reg --;)\n \tif (mask & (1 << reg))\n \t  {\n \t    insn = emit_insn (gen_stack_push (gen_rtx_REG (SImode, reg)));\n@@ -1270,7 +1264,7 @@ rx_expand_prologue (void)\n \t{\n \t  acc_low = acc_high = 0;\n \n-\t  for (reg = 1; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\t  for (reg = 1; reg < CC_REGNUM; reg ++)\n \t    if (mask & (1 << reg))\n \t      {\n \t\tif (acc_low == 0)\n@@ -1543,7 +1537,8 @@ rx_expand_epilogue (bool is_sibcall)\n \t  if (register_mask)\n \t    {\n \t      acc_low = acc_high = 0;\n-\t      for (reg = 1; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\n+\t      for (reg = 1; reg < CC_REGNUM; reg ++)\n \t\tif (register_mask & (1 << reg))\n \t\t  {\n \t\t    if (acc_low == 0)\n@@ -1574,7 +1569,7 @@ rx_expand_epilogue (bool is_sibcall)\n \n       if (register_mask)\n \t{\n-\t  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\t  for (reg = 0; reg < CC_REGNUM; reg ++)\n \t    if (register_mask & (1 << reg))\n \t      emit_insn (gen_stack_pop (gen_rtx_REG (SImode, reg)));\n \t}\n@@ -1674,54 +1669,6 @@ rx_initial_elimination_offset (int from, int to)\n   return stack_size;\n }\n \n-/* Update the status of the condition\n-   codes (cc0) based on the given INSN.  */\n-\n-void\n-rx_notice_update_cc (rtx body, rtx insn)\n-{\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Insn does not affect cc0 at all.  */\n-      break;\n-    case CC_CLOBBER:\n-      /* Insn doesn't leave cc0 in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n-    case CC_SET_ZSOC:\n-      /* The insn sets all the condition code bits.  */\n-      CC_STATUS_INIT;\n-      cc_status.value1 = SET_DEST (body);\n-      break;\n-    case CC_SET_ZSO:\n-      /* Insn sets the Z,S and O flags, but not the C flag.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_CARRY;\n-      /* Do not set the value1 field in this case.  The final_scan_insn()\n-\t function naively believes that if cc_status.value1 is set then\n-\t it can eliminate *any* comparison against that value, even if\n-\t the type of comparison cannot be satisfied by the range of flag\n-\t bits being set here.  See gcc.c-torture/execute/20041210-1.c\n-\t for an example of this in action.  */\n-      break;\n-    case CC_SET_ZSC:\n-      /* Insn sets the Z,S and C flags, but not the O flag.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_OVERFLOW;\n-      /* See comment above regarding cc_status.value1.  */\n-      break;\n-    case CC_SET_ZS:\n-      /* Insn sets the Z and S flags, but not the O or C flags.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= (CC_NO_CARRY | CC_NO_OVERFLOW);\n-      /* See comment above regarding cc_status.value1.  */\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Decide if a variable should go into one of the small data sections.  */\n \n static bool\n@@ -2517,6 +2464,220 @@ rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n     }\n }\n \f\n+\n+static enum machine_mode\n+rx_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+{\n+  if (m1 == CCmode)\n+    return m2;\n+  if (m2 == CCmode)\n+    return m1;\n+  if (m1 == m2)\n+    return m1;\n+  if (m1 == CC_ZSmode)\n+    return m1;\n+  if (m2 == CC_ZSmode)\n+    return m2;\n+  return VOIDmode;   \n+}\n+\n+#define CC_FLAG_S (1 << 0)\n+#define CC_FLAG_Z (1 << 1)\n+#define CC_FLAG_O (1 << 2)\n+#define CC_FLAG_C (1 << 3)\n+\n+static unsigned int\n+flags_needed_for_conditional (rtx conditional)\n+{\n+  switch (GET_CODE (conditional))\n+    {\n+    case LE:\n+    case GT:\treturn CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n+\n+    case LEU:\n+    case GTU:\treturn CC_FLAG_Z | CC_FLAG_C;\n+\n+    case LT:\n+    case GE:\treturn CC_FLAG_S | CC_FLAG_O;\n+\n+    case LTU:\n+    case GEU:\treturn CC_FLAG_C;\n+\n+    case EQ:\n+    case NE:\treturn CC_FLAG_Z;\n+\n+    default:\tgcc_unreachable ();\n+    }\n+}\n+\n+static unsigned int\n+flags_from_mode (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case CCmode:     return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;\n+    case CC_ZSmode:  return CC_FLAG_S | CC_FLAG_Z;\n+    case CC_ZSOmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n+    case CC_ZSCmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;\n+    default:         gcc_unreachable ();\n+    }\n+}\n+\n+/* Returns true if a compare insn is redundant because it\n+   would only set flags that are already set correctly.  */\n+\n+bool\n+rx_compare_redundant (rtx cmp)\n+{\n+  unsigned int flags_needed;\n+  unsigned int flags_set;\n+  rtx next;\n+  rtx prev;\n+  rtx source;\n+  rtx dest;\n+  static rtx cc_reg = NULL_RTX;\n+\n+  if (cc_reg == NULL_RTX)\n+    cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n+\n+  /* We can only eliminate compares against 0.  */\n+  if (GET_CODE (XEXP (SET_SRC (PATTERN (cmp)), 1)) != CONST_INT\n+      || INTVAL (XEXP (SET_SRC (PATTERN (cmp)), 1)) != 0)\n+    return false;\n+\n+  /* Locate the branch insn that follows the\n+     compare and which tests the bits in the PSW.  */\n+  next = cmp;\n+  do\n+    {\n+      /* If we have found an insn that sets or clobbers the CC\n+\t register and it was not the IF_THEN_ELSE insn that we\n+\t are looking for, then the comparison is redundant.  */\n+      if (next != cmp && reg_mentioned_p (cc_reg, PATTERN (next)))\n+\treturn true;\n+\n+      next = next_nonnote_insn (next);\n+\n+      /* If we run out of insns without finding the\n+\t user then the comparison is unnecessary.  */\n+      if (next == NULL_RTX)\n+\treturn true;\n+\n+      /* If we have found another comparison\n+\t insn then the first one is redundant.  */\n+      if (INSN_P (next)\n+\t  && GET_CODE (PATTERN (next)) == SET\n+\t  && REG_P (SET_DEST (PATTERN (next)))\n+\t  && REGNO (SET_DEST (PATTERN (next))) == CC_REGNUM)\n+\treturn true;\n+\n+      /* If we have found another arithmetic/logic insn that\n+\t sets the PSW flags then the comparison is redundant.  */\n+      if (INSN_P (next)\n+\t  && GET_CODE (PATTERN (next)) == PARALLEL\n+\t  && GET_CODE (XVECEXP (PATTERN (next), 0, 1)) == SET\n+\t  && REG_P (SET_DEST (XVECEXP (PATTERN (next), 0, 1)))\n+\t  && REGNO (SET_DEST (XVECEXP (PATTERN (next), 0, 1))) == CC_REGNUM)\n+\treturn true;\n+\n+      /* If we have found an unconditional branch then the\n+\t PSW flags might be carried along with the jump, so\n+\t the comparison is necessary.  */\n+      if (INSN_P (next) && JUMP_P (next))\n+\t{\n+\t  if (GET_CODE (PATTERN (next)) != SET)\n+\t    /* If the jump does not involve setting the PC\n+\t       then it is a return of some kind, and we know\n+\t       that the comparison is not used.  */\n+\t    return true;\n+\n+\t  if (GET_CODE (SET_SRC (PATTERN (next))) != IF_THEN_ELSE)\n+\t    return false;\n+\t}\n+    }\n+  while (! INSN_P (next)\n+\t || DEBUG_INSN_P (next)\n+\t || GET_CODE (PATTERN (next)) != SET\n+\t || GET_CODE (SET_SRC (PATTERN (next))) != IF_THEN_ELSE);\n+\n+  flags_needed = flags_needed_for_conditional (XEXP (SET_SRC (PATTERN (next)), 0));\n+\n+  /* Now look to see if there was a previous\n+     instruction which set the PSW bits.  */\n+  source = XEXP (SET_SRC (PATTERN (cmp)), 0);\n+  prev = cmp;\n+  do\n+    {\n+      /* If this insn uses/sets/clobbers the CC register\n+\t and it is not the insn that we are looking for\n+\t below, then we must need the comparison.  */\n+      if (prev != cmp && reg_mentioned_p (cc_reg, PATTERN (prev)))\n+\treturn false;\n+\n+      prev = prev_nonnote_insn (prev);\n+\n+      if (prev == NULL_RTX)\n+\treturn false;\n+\n+      /* If we encounter an insn which changes the contents of\n+\t the register which is the source of the comparison then\n+\t we will definitely need the comparison.  */\n+      if (INSN_P (prev)\n+\t  && GET_CODE (PATTERN (prev)) == SET\n+\t  && rtx_equal_p (SET_DEST (PATTERN (prev)), source))\n+\t{\n+\t  /* Unless this instruction is a simple register move\n+\t     instruction.  In which case we can continue our\n+\t     scan backwards, but now using the *source* of this\n+\t     set instruction.  */\n+\t  if (REG_P (SET_SRC (PATTERN (prev))))\n+\t    source = SET_SRC (PATTERN (prev));\n+\t  /* We can also survive a sign-extension if the test is\n+\t     for EQ/NE.  Note the same does not apply to zero-\n+\t     extension as this can turn a non-zero bit-pattern\n+\t     into zero.  */\n+\t  else if (flags_needed == CC_FLAG_Z\n+\t\t   && GET_CODE (SET_SRC (PATTERN (prev))) == SIGN_EXTEND)\n+\t    source = XEXP (SET_SRC (PATTERN (prev)), 0);\n+\t  else\n+\t    return false;\n+\t}\n+\n+      /* A label means a possible branch into the\n+\t code here, so we have to stop scanning.  */\n+      if (LABEL_P (prev))\n+\treturn false;\n+    }\n+  while (! INSN_P (prev)\n+\t || DEBUG_INSN_P (prev)\n+\t || GET_CODE (PATTERN (prev)) != PARALLEL\n+\t || GET_CODE (XVECEXP (PATTERN (prev), 0, 1)) != SET\n+\t || ! REG_P (SET_DEST (XVECEXP (PATTERN (prev), 0, 1)))\n+\t || REGNO (SET_DEST (XVECEXP (PATTERN (prev), 0, 1))) != CC_REGNUM);\n+\n+  flags_set = flags_from_mode (GET_MODE (SET_DEST (XVECEXP (PATTERN (prev), 0, 1))));\n+\n+  dest = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));\n+  /* The destination of the previous arithmetic/logic instruction\n+     must match the source in the comparison operation.  For registers\n+     we ignore the mode as there may have been a sign-extension involved.  */\n+  if (! rtx_equal_p (source, dest))\n+    {\n+      if (REG_P (source) && REG_P (dest) && REGNO (dest) == REGNO (source))\n+\t;\n+      else\n+\treturn false;\n+    }\n+\n+  return ((flags_set & flags_needed) == flags_needed);\n+}\n+\n+static int\n+rx_memory_move_cost (enum machine_mode mode, enum reg_class regclass, bool in)\n+{\n+  return 2 + memory_move_secondary_cost (mode, regclass, in);\n+}\n+\f\n #undef  TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE\t\trx_function_value\n \n@@ -2610,6 +2771,12 @@ rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n #undef  TARGET_PRINT_OPERAND_ADDRESS\n #define TARGET_PRINT_OPERAND_ADDRESS\t\trx_print_operand_address\n \n+#undef  TARGET_CC_MODES_COMPATIBLE\n+#define TARGET_CC_MODES_COMPATIBLE\t\trx_cc_modes_compatible\n+\n+#undef  TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST\t\t\trx_memory_move_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* #include \"gt-rx.h\" */"}, {"sha": "b3a12690b08a52c7dc350c0519235dce8fbcfbe8", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -207,7 +207,7 @@ enum reg_class\n #define BASE_REG_CLASS  \t\tGR_REGS\n #define INDEX_REG_CLASS\t\t\tGR_REGS\n \n-#define FIRST_PSEUDO_REGISTER \t\t16\n+#define FIRST_PSEUDO_REGISTER \t\t17\n \n #define REGNO_REG_CLASS(REGNO)          ((REGNO) < FIRST_PSEUDO_REGISTER \\\n \t\t\t\t\t ? GR_REGS : NO_REGS)\n@@ -219,6 +219,7 @@ enum reg_class\n #define STATIC_CHAIN_REGNUM \t\t8\n #define TRAMPOLINE_TEMP_REGNUM\t\t9\n #define STRUCT_VAL_REGNUM\t\t15\n+#define CC_REGNUM                       16\n \n /* This is the register which is used to hold the address of the start\n    of the small data area, if that feature is being used.  Note - this\n@@ -245,12 +246,12 @@ enum reg_class\n \n #define FIXED_REGISTERS\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n-  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t\\\n+  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\t\\\n }\n \n #define CALL_USED_REGISTERS\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1\t\\\n+  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1\t\\\n }\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n@@ -351,7 +352,7 @@ typedef unsigned int CUMULATIVE_ARGS;\n #define REGISTER_NAMES\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     \"r0\",  \"r1\",  \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",\t\\\n-    \"r8\",  \"r9\",  \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\" \\\n+      \"r8\",  \"r9\",  \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\", \"cc\"\t\\\n   };\n \n #define ADDITIONAL_REGISTER_NAMES\t\\\n@@ -609,9 +610,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n    they contain are always computed between two same-section symbols.  */\n #define JUMP_TABLES_IN_TEXT_SECTION\t(flag_pic)\n \f\n-#define CC_NO_CARRY\t\t\t0400\n-#define NOTICE_UPDATE_CC(EXP, INSN)\trx_notice_update_cc (EXP, INSN)\n-\n extern int rx_float_compare_mode;\n \f\n /* This is a version of REG_P that also returns TRUE for SUBREGs.  */\n@@ -646,3 +644,16 @@ extern int rx_float_compare_mode;\n \n /* This macro is used to decide when RX FPU instructions can be used.  */\n #define ALLOW_RX_FPU_INSNS\t(TARGET_USE_FPU)\n+\n+#define BRANCH_COST(SPEED,PREDICT)       1\n+#define REGISTER_MOVE_COST(MODE,FROM,TO) 2\n+\n+#define SELECT_CC_MODE(OP,X,Y)\t\t\t\t\t\t\\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CC_ZSmode :\t\t\\\n+    (GET_CODE (X) == PLUS || GET_CODE (X) == MINUS ? CC_ZSCmode :\t\\\n+    (GET_CODE (X) == ABS ? CC_ZSOmode :\t\t\t\t\t\\\n+    (GET_CODE (X) == AND || GET_CODE (X) == NOT || GET_CODE (X) == IOR\t\\\n+     || GET_CODE (X) == XOR || GET_CODE (X) == ROTATE\t\t\t\\\n+     || GET_CODE (X) == ROTATERT || GET_CODE (X) == ASHIFTRT\t\t\\\n+     || GET_CODE (X) == LSHIFTRT || GET_CODE (X) == ASHIFT ? CC_ZSmode : \\\n+     CCmode))))"}, {"sha": "aeba85ffe391ed919d4f2d2df00a8f6874bd0b07", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 287, "deletions": 245, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8fc973762254dfd518d202975bc043aba4ba9/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=aea8fc973762254dfd518d202975bc043aba4ba9", "patch": "@@ -47,6 +47,7 @@\n (define_constants\n   [\n    (SP_REG 0)\n+   (CC_REG \t\t   16)\n \n    (UNSPEC_LOW_REG         0)\n    (UNSPEC_HIGH_REG        1)\n@@ -86,14 +87,6 @@\n   ]\n )\n \n-;; Condition code settings:\n-;;   none     - insn does not affect the condition code bits\n-;;   set_zs   - insn sets z,s to usable values;\n-;;   set_zso  - insn sets z,s,o to usable values;\n-;;   set_zsoc - insn sets z,s,o,c to usable values;\n-;;   clobber  - value of cc0 is unknown\n-(define_attr \"cc\" \"none,set_zs,set_zso,set_zsoc,set_zsc,clobber\" (const_string \"none\"))\n-\n (define_attr \"length\" \"\" (const_int 8))\n \n (include \"predicates.md\")\n@@ -156,95 +149,138 @@\n \n ;; Comparisons\n \n+;; Note - we do not specify the two instructions necessary to perform\n+;; a compare-and-branch in the cbranchsi4 pattern because that would\n+;; allow the comparison to be moved away from the jump before the reload\n+;; pass has completed.  That would be problematical because reload can\n+;; generate ADDSI3 instructions which would corrupt the PSW flags.\n+\n (define_expand \"cbranchsi4\"\n-  [(set (cc0) (compare:CC (match_operand:SI 1 \"register_operand\")\n-\t\t\t  (match_operand:SI 2 \"rx_source_operand\")))\n-   (set (pc)\n-\t(if_then_else (match_operator:SI  0 \"comparison_operator\"\n-\t\t\t\t\t  [(cc0) (const_int 0)])\n+  [(set (pc)\n+\t(if_then_else (match_operator:SI 0 \"comparison_operator\"\n+\t\t\t\t\t [(match_operand:SI 1 \"register_operand\")\n+\t\t\t\t\t  (match_operand:SI 2 \"rx_source_operand\")])\n \t\t      (label_ref (match_operand 3 \"\"))\n-\t\t      (pc)))]\n+\t\t      (pc)))\n+   ]\n   \"\"\n   \"\"\n )\n \n+(define_insn_and_split \"*cbranchsi4_<code>\"\n+  [(set (pc)\n+\t(if_then_else (most_cond:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n+\t\t\t\t    (match_operand:SI  1 \"rx_source_operand\" \"riQ\"))\n+\t\t      (label_ref (match_operand        2 \"\" \"\"))\n+\t\t      (pc)))\n+   ]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  /* We contstruct the split by hand as otherwise the JUMP_LABEL\n+     attribute is not set correctly on the jump insn.  */\n+  emit_insn (gen_cmpsi (operands[0], operands[1]));\n+  \n+  emit_jump_insn (gen_conditional_branch (operands[2],\n+  \t\t gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,\n+\t\t\t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n+  \"\n+)\n+\n (define_expand \"cbranchsf4\"\n-  [(set (cc0) (compare:CC (match_operand:SF 1 \"register_operand\")\n-\t\t\t  (match_operand:SF 2 \"rx_source_operand\")))\n-   (set (pc)\n-\t(if_then_else (match_operator:SI  0 \"comparison_operator\"\n-\t\t\t\t\t  [(cc0) (const_int 0)])\n+  [(set (pc)\n+\t(if_then_else (match_operator:SF 0 \"comparison_operator\"\n+\t\t\t\t\t [(match_operand:SF 1 \"register_operand\")\n+\t\t\t\t\t  (match_operand:SF 2 \"rx_source_operand\")])\n \t\t      (label_ref (match_operand 3 \"\"))\n-\t\t      (pc)))]\n-  \"ALLOW_RX_FPU_INSNS && (cfun == NULL || !cfun->can_throw_non_call_exceptions)\"\n+\t\t      (pc)))\n+   ]\n+  \"ALLOW_RX_FPU_INSNS\"\n   \"\"\n )\n \n-;; The TST instruction is not used as it does not set the Carry flag,\n-;; so for example, the LessThan comparison cannot be tested.\n-;;\n-;; (define_insn \"tstsi\"\n-;;   [(set (cc0)\n-;;         (match_operand:SI 0 \"rx_source_operand\"  \"r,i,Q\")))]\n-;;   \"\"\n-;;   {\n-;;     rx_float_compare_mode = false;\n-;;     return \"tst\\t%Q0\";\n-;;   }\n-;;   [(set_attr \"cc\" \"set_zs\")\n-;;    (set_attr \"timings\" \"11,11,33\")\n-;;    (set_attr \"length\" \"3,7,6\")]\n-;; )\n+(define_insn_and_split \"*cbranchsf4_<code>\"\n+  [(set (pc)\n+\t(if_then_else (most_cond:SF (match_operand:SF  0 \"register_operand\"  \"r\")\n+\t\t\t\t    (match_operand:SF  1 \"rx_source_operand\" \"rFiQ\"))\n+\t\t      (label_ref (match_operand        2 \"\" \"\"))\n+\t\t      (pc)))\n+   ]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  /* We contstruct the split by hand as otherwise the JUMP_LABEL\n+     attribute is not set correctly on the jump insn.  */\n+  emit_insn (gen_cmpsf (operands[0], operands[1]));\n+  \n+  emit_jump_insn (gen_conditional_branch (operands[2],\n+  \t\t gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,\n+ \t\t \t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n+  \"\n+)\n+\n+(define_insn \"tstsi\"\n+  [(set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (and:SI (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n+\t\t\t       (match_operand:SI 1 \"rx_source_operand\" \"r,i,Q\"))\n+\t\t       (const_int 0)))]\n+  \"\"\n+  {\n+    rx_float_compare_mode = false;\n+    return \"tst\\t%Q1, %0\";\n+  }\n+  [(set_attr \"timings\" \"11,11,33\")\n+   (set_attr \"length\"   \"3,7,6\")]\n+)\n \n (define_insn \"cmpsi\"\n-  [(set (cc0) (compare:CC\n-\t       (match_operand:SI 0 \"register_operand\"  \"r,r,r,r,r,r,r\")\n-\t       (match_operand:SI 1 \"rx_source_operand\"\n-\t\t\t\t \"r,Uint04,Int08,Sint16,Sint24,i,Q\")))]\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\"  \"r,r,r,r,r,r,r\")\n+\t\t    (match_operand:SI 1 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")))]\n   \"\"\n   {\n     rx_float_compare_mode = false;\n+    if (rx_compare_redundant (insn))\n+      return \"; Compare Eliminated: cmp %Q1, %0\";\n     return \"cmp\\t%Q1, %0\";\n   }\n-  [(set_attr \"cc\" \"set_zsoc\")\n-   (set_attr \"timings\" \"11,11,11,11,11,11,33\")\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,33\")\n    (set_attr \"length\"  \"2,2,3,4,5,6,5\")]\n )\n \n-;; This pattern is disabled if the function can throw non-call exceptions,\n-;; because it could generate a floating point exception, which would\n-;; introduce an edge into the flow graph between this insn and the\n-;; conditional branch insn to follow, thus breaking the cc0 relationship.\n-;; Run the g++ test g++.dg/eh/080514-1.C to see this happen.\n+;; ??? g++.dg/eh/080514-1.C to see this happen.\n (define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n-\t\t    (match_operand:SF 1 \"rx_source_operand\" \"r,i,Q\")))]\n-  \"ALLOW_RX_FPU_INSNS && (cfun == NULL || !cfun->can_throw_non_call_exceptions)\"\n+  [(set (reg:CC_ZSO CC_REG)\n+\t(compare:CC_ZSO (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n+\t\t\t(match_operand:SF 1 \"rx_source_operand\" \"r,iF,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n   {\n     rx_float_compare_mode = true;\n     return \"fcmp\\t%1, %0\";\n   }\n-  [(set_attr \"cc\" \"set_zso\")\n-   (set_attr \"timings\" \"11,11,33\")\n+  [(set_attr \"timings\" \"11,11,33\")\n    (set_attr \"length\" \"3,7,5\")]\n )\n \n ;; Flow Control Instructions:\n \n (define_expand \"b<code>\"\n   [(set (pc)\n-        (if_then_else (most_cond (cc0) (const_int 0))\n+        (if_then_else (most_cond (reg:CC CC_REG) (const_int 0))\n                       (label_ref (match_operand 0))\n                       (pc)))]\n   \"\"\n   \"\"\n )\n \n-(define_insn \"*conditional_branch\"\n+(define_insn \"conditional_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator           1 \"comparison_operator\"\n-\t\t\t\t\t\t[(cc0) (const_int 0)])\n+\t\t\t\t\t\t[(reg:CC CC_REG) (const_int 0)])\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -253,14 +289,13 @@\n   }\n   [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n                               ;; too hard to compute statically.\n-   (set_attr \"timings\" \"33\")  ;; The timing assumes that the branch is taken.\n-   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+   (set_attr \"timings\" \"33\")] ;; The timing assumes that the branch is taken.\n )\n \n (define_insn \"*reveresed_conditional_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t\t\t      [(reg:CC CC_REG) (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n@@ -269,38 +304,37 @@\n   }\n   [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n                               ;; too hard to compute statically.\n-   (set_attr \"timings\" \"33\")  ;; The timing assumes that the branch is taken.\n-   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+   (set_attr \"timings\" \"33\")] ;; The timing assumes that the branch is taken.\n )\n \n (define_insn \"jump\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"bra\\t%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"timings\" \"33\")\n-   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+   (set_attr \"timings\" \"33\")]\n )\n \n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"\"\n   \"jmp\\t%0\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"timings\" \"33\")\n-   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+   (set_attr \"timings\" \"33\")]\n )\n \n (define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI     0 \"register_operand\" \"r\"))\n+  [(set (pc)\n+\t(match_operand:SI          0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand  1 \"\" \"\")))]\n   \"\"\n   { return flag_pic ? (TARGET_AS100_SYNTAX ? \"\\n?:\\tbra\\t%0\"\n \t\t\t\t\t   : \"\\n1:\\tbra\\t%0\")\n \t                                   : \"jmp\\t%0\";\n   }\n-  [(set_attr \"cc\" \"clobber\") ;; FIXME: This clobber is wrong.\n-   (set_attr \"timings\" \"33\")\n+  [(set_attr \"timings\" \"33\")\n    (set_attr \"length\" \"2\")]\n )\n \n@@ -324,11 +358,10 @@\n )\n \n (define_insn \"pop_and_return\"\n-  [(match_parallel                    1 \"rx_rtsd_vector\"\n+  [(match_parallel 1 \"rx_rtsd_vector\"\n \t\t   [(set:SI (reg:SI SP_REG)\n \t\t\t    (plus:SI (reg:SI SP_REG)\n-\t\t\t\t     (match_operand:SI\n-\t\t\t\t      0 \"const_int_operand\" \"n\")))])]\n+\t\t\t\t     (match_operand:SI 0 \"const_int_operand\" \"n\")))])]\n   \"reload_completed\"\n   {\n     rx_emit_stack_popm (operands, false);\n@@ -385,13 +418,13 @@\n \n (define_insn \"call_internal\"\n   [(call (mem:QI (match_operand:SI 0 \"rx_call_operand\" \"r,Symbol\"))\n-\t (match_operand:SI         1 \"general_operand\" \"g,g\"))]\n+\t (match_operand:SI         1 \"general_operand\" \"g,g\"))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n   jsr\\t%0\n   bsr\\t%A0\"\n   [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"clobber\")\n    (set_attr \"timings\" \"33\")]\n )\n \n@@ -413,13 +446,13 @@\n (define_insn \"call_value_internal\"\n   [(set (match_operand                  0 \"register_operand\" \"=r,r\")\n \t(call (mem:QI (match_operand:SI 1 \"rx_call_operand\"   \"r,Symbol\"))\n-\t      (match_operand:SI         2 \"general_operand\"   \"g,g\")))]\n+\t      (match_operand:SI         2 \"general_operand\"   \"g,g\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"@\n   jsr\\t%1\n   bsr\\t%A1\"\n   [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"clobber\")\n    (set_attr \"timings\" \"33\")]\n )\n \n@@ -564,11 +597,10 @@\n )\n \n (define_insn \"stack_pushm\"\n-  [(match_parallel                     1 \"rx_store_multiple_vector\"\n+  [(match_parallel 1 \"rx_store_multiple_vector\"\n \t\t   [(set:SI (reg:SI SP_REG)\n \t\t\t    (minus:SI (reg:SI SP_REG)\n-\t\t\t\t      (match_operand:SI\n-\t\t\t\t       0 \"const_int_operand\" \"n\")))])]\n+\t\t\t\t      (match_operand:SI 0 \"const_int_operand\" \"n\")))])]\n   \"reload_completed\"\n   {\n     rx_emit_stack_pushm (operands);\n@@ -591,11 +623,10 @@\n )\n \n (define_insn \"stack_popm\"\n-  [(match_parallel                     1 \"rx_load_multiple_vector\"\n+  [(match_parallel 1 \"rx_load_multiple_vector\"\n \t\t   [(set:SI (reg:SI SP_REG)\n \t\t\t    (plus:SI (reg:SI SP_REG)\n-\t\t\t\t     (match_operand:SI\n-\t\t\t\t      0 \"const_int_operand\" \"n\")))])]\n+\t\t\t\t     (match_operand:SI 0 \"const_int_operand\" \"n\")))])]\n   \"reload_completed\"\n   {\n     rx_emit_stack_popm (operands, true);\n@@ -605,29 +636,29 @@\n    (set_attr \"timings\" \"45\")] ;; The timing is a guesstimate average timing.\n )\n \n+;; FIXME: Add memory destination options ?\n (define_insn \"cstoresi4\"\n-  [(set (match_operand:SI  0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n-\t(match_operator:SI\n-\t 1 \"comparison_operator\"\n-\t [(match_operand:SI\n-\t   2 \"register_operand\"  \"r,r,r,r,r,r,r\")\n-\t  (match_operand:SI\n-\t   3 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")]))]\n+  [(set (match_operand:SI   0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n+\t(match_operator:SI  1 \"comparison_operator\"\n+\t [(match_operand:SI 2 \"register_operand\"  \"r,r,r,r,r,r,r\")\n+\t  (match_operand:SI 3 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")]))\n+   (clobber (reg:CC CC_REG))] ;; Because the cc flags are set based on comparing ops 2 & 3 not the value in op 0.\n   \"\"\n   {\n     rx_float_compare_mode = false;\n     return \"cmp\\t%Q3, %Q2\\n\\tsc%B1.L\\t%0\";\n   }\n-  [(set_attr \"cc\" \"clobber\") ;; Because cc0 is set based on comparing ops 2 & 3 not the value in op 0.\n-   (set_attr \"timings\" \"22,22,22,22,22,22,44\")\n+  [(set_attr \"timings\" \"22,22,22,22,22,22,44\")\n    (set_attr \"length\"  \"5,5,6,7,8,9,8\")]\n )\n \n (define_expand \"movsicc\"\n-  [(set (match_operand:SI                   0 \"register_operand\")\n-        (if_then_else:SI (match_operand:SI 1 \"comparison_operator\")\n-\t\t\t (match_operand:SI  2 \"nonmemory_operand\")\n-\t\t\t (match_operand:SI  3 \"immediate_operand\")))]\n+  [(parallel\n+    [(set (match_operand:SI                  0 \"register_operand\")\n+\t  (if_then_else:SI (match_operand:SI 1 \"comparison_operator\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")\n+\t\t\t   (match_operand:SI 3 \"immediate_operand\")))\n+     (clobber (reg:CC CC_REG))])] ;; See cstoresi4\n   \"\"\n   {\n     if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)\n@@ -638,22 +669,18 @@\n )\n \n (define_insn \"*movsieq\"\n-  [(set (match_operand:SI     0 \"register_operand\" \"=r,r,r\")\n-\t(if_then_else:SI (eq (match_operand:SI\n-\t\t\t      3 \"register_operand\"  \"r,r,r\")\n-\t\t\t     (match_operand:SI\n-\t\t\t      4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n-\t\t\t (match_operand:SI\n-\t\t\t  1 \"nonmemory_operand\"     \"0,i,r\")\n-\t\t\t (match_operand:SI\n-\t\t\t  2 \"immediate_operand\"     \"i,i,i\")))]\n+  [(set (match_operand:SI                      0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:SI (eq (match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n+\t\t\t     (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n+\t\t\t (match_operand:SI     1 \"nonmemory_operand\" \"0,i,r\")\n+\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))\n+   (clobber (reg:CC CC_REG))] ;; See cstoresi4\n   \"\"\n   \"@\n   cmp\\t%Q4, %Q3\\n\\tstnz\\t%2, %0\n   cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstz\\t%1, %0\n   cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstnz\\t%2, %0\"\n-  [(set_attr \"cc\"      \"clobber\") ;; See cstoresi4\n-   (set_attr \"length\"  \"13,19,15\")\n+  [(set_attr \"length\"  \"13,19,15\")\n    (set_attr \"timings\" \"22,33,33\")]\n )\n \n@@ -662,39 +689,39 @@\n \t(if_then_else:SI (ne (match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n \t\t\t     (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n \t\t\t (match_operand:SI     1 \"nonmemory_operand\" \"0,i,r\")\n-\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))]\n+\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))\n+   (clobber (reg:CC CC_REG))] ;; See cstoresi4\n   \"\"\n   \"@\n   cmp\\t%Q4, %Q3\\n\\tstz\\t%2, %0\n   cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstnz\\t%1, %0\n   cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstz\\t%2, %0\"\n-  [(set_attr \"cc\"      \"clobber\") ;; See cstoresi4\n-   (set_attr \"length\"  \"13,19,15\")\n+  [(set_attr \"length\"  \"13,19,15\")\n    (set_attr \"timings\" \"22,33,33\")]\n )\n \n ;; Arithmetic Instructions\n \n (define_insn \"abssi2\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n-        (abs:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+        (abs:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))\n+   (set (reg:CC_ZSO CC_REG)\n+\t(compare:CC_ZSO (abs:SI (match_dup 1))\n+\t\t\t(const_int 0)))]\n   \"\"\n   \"@\n   abs\\t%0\n   abs\\t%1, %0\"\n-  [(set_attr \"cc\" \"set_zso\")\n-   (set_attr \"length\" \"2,3\")]\n+  [(set_attr \"length\" \"2,3\")]\n )\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"\n-\t\t\t  \"=r,r,r,r,r,r,r,r,r,r,r,r,r\")\n-\t(plus:SI (match_operand:SI\n-\t\t  1 \"register_operand\"\n-\t\t  \"%0,0,0,0,0,0,0,r,r,r,r,r,0\")\n-\t\t (match_operand:SI\n-\t\t  2 \"rx_source_operand\"\n-\t\t  \"r,Uint04,NEGint4,Sint08,Sint16,Sint24,i,r,Sint08,Sint16,Sint24,i,Q\")))]\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,r,r,r,r,r,r,r,r,r,r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,0,0,0,0,r,r,r,r,r,r,0\")\n+\t\t (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,NEGint4,Sint08,Sint16,Sint24,i,0,r,Sint08,Sint16,Sint24,i,Q\")))\n+   (set (reg:CC_ZSC CC_REG) ;; See subsi3\n+\t(compare:CC_ZSC (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"\"\n   \"@\n   add\\t%2, %0\n@@ -704,35 +731,38 @@\n   add\\t%2, %0\n   add\\t%2, %0\n   add\\t%2, %0\n+  add\\t%1, %0\n   add\\t%2, %1, %0\n   add\\t%2, %1, %0\n   add\\t%2, %1, %0\n   add\\t%2, %1, %0\n   add\\t%2, %1, %0\n   add\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zsc\") ;; See subsi3\n-   (set_attr \"timings\" \"11,11,11,11,11,11,11,11,11,11,11,11,33\")\n-   (set_attr \"length\" \"2,2,2,3,4,5,6,3,3,4,5,6,5\")]\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,11,11,11,11,11,11,11,33\")\n+   (set_attr \"length\"   \"2,2,2,3,4,5,6,2,3,3,4,5,6,5\")]\n )\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI          0 \"register_operand\" \"=r,r,r,r,r,r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n \t\t (match_operand:DI 2 \"rx_source_operand\"\n-\t\t\t\t   \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+\t\t\t\t   \"r,Sint08,Sint16,Sint24,i,Q\")))\n+   (set (reg:CC_ZSC CC_REG) ;; See subsi3\n+\t(compare:CC_ZSC (plus:DI (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"\"\n   \"add\\t%L2, %L0\\n\\tadc\\t%H2, %H0\"\n-  [(set_attr \"cc\" \"set_zsc\") ;; See subsi3\n-   (set_attr \"timings\" \"22,22,22,22,22,44\")\n+  [(set_attr \"timings\" \"22,22,22,22,22,44\")\n    (set_attr \"length\" \"5,7,9,11,13,11\")]\n )\n \n (define_insn \"andsi3\"\n   [(set (match_operand:SI         0 \"register_operand\"  \"=r,r,r,r,r,r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,0,0,0,r,r,0\")\n-\t\t(match_operand:SI\n-\t\t 2 \"rx_source_operand\"\n-\t\t \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))]\n+\t\t(match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (and:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   and\\t%2, %0\n@@ -744,8 +774,7 @@\n   and\\t%1, %0\n   and\\t%2, %1, %0\n   and\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"11,11,11,11,11,11,11,33,33\")\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,11,33,33\")\n    (set_attr \"length\" \"2,2,3,4,5,6,2,5,5\")]\n )\n \n@@ -770,25 +799,23 @@\n (define_insn \"divsi3\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r\")\n \t(div:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0,0,0,0\")\n-\t\t(match_operand:SI\n-\t\t 2 \"rx_source_operand\" \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+\t\t(match_operand:SI 2 \"rx_source_operand\" \"r,Sint08,Sint16,Sint24,i,Q\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"div\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"timings\" \"1111\") ;; Strictly speaking the timing should be\n+  [(set_attr \"timings\" \"1111\") ;; Strictly speaking the timing should be\n                                ;; 2222, but that is a worst case sceanario.\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n \n (define_insn \"udivsi3\"\n   [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,r,r,r,r\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\"   \"0,0,0,0,0,0\")\n-\t\t (match_operand:SI\n-\t\t  2 \"rx_source_operand\"  \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+\t\t (match_operand:SI 2 \"rx_source_operand\"  \"r,Sint08,Sint16,Sint24,i,Q\")))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"divu\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"timings\" \"1010\") ;; Strictly speaking the timing should be\n+  [(set_attr \"timings\" \"1010\") ;; Strictly speaking the timing should be\n                                ;; 2020, but that is a worst case sceanario.\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n@@ -816,12 +843,9 @@\n ;; mulsidi3 pattern.  Immediate mode addressing is not supported\n ;; because gcc cannot handle the expression: (zero_extend (const_int)).\n (define_insn \"umulsidi3\"\n-  [(set (match_operand:DI                          0 \"register_operand\"\n-\t\t\t\t\t\t   \"=r,r\")\n-        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\"\n-\t\t\t\t\t\t   \"%0,0\"))\n-                 (zero_extend:DI (match_operand:SI 2 \"rx_compare_operand\"\n-\t\t\t\t\t\t   \"r,Q\"))))]\n+  [(set (match_operand:DI                          0 \"register_operand\"\t \"=r,r\")\n+        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\"  \"%0,0\"))\n+                 (zero_extend:DI (match_operand:SI 2 \"rx_compare_operand\" \"r,Q\"))))]\n   \"! TARGET_BIG_ENDIAN_DATA\"\n   \"emulu\\t%Q2, %0\"\n   [(set_attr \"length\" \"3,6\")\n@@ -872,33 +896,39 @@\n \n (define_insn \"negsi2\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n-        (neg:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+        (neg:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))\n+   (set (reg:CC CC_REG)\n+\t(compare:CC (neg:SI (match_dup 1))\n+\t\t    (const_int 0)))]\n   ;; The NEG instruction does not comply with -fwrapv semantics.\n   ;; See gcc.c-torture/execute/pr22493-1.c for an example of this.\n   \"! flag_wrapv\"\n   \"@\n   neg\\t%0\n   neg\\t%1, %0\"\n-  [(set_attr \"length\" \"2,3\")\n-   (set_attr \"cc\" \"set_zsoc\")]\n+  [(set_attr \"length\" \"2,3\")]\n )\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+\t(not:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (not:SI (match_dup 1))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   not\\t%0\n   not\\t%1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"2,3\")]\n+  [(set_attr \"length\" \"2,3\")]\n )\n \n (define_insn \"iorsi3\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r,r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,r,r,0\")\n-\t        (match_operand:SI 2 \"rx_source_operand\"\n-\t\t\t\t  \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))]\n+\t        (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (ior:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   or\\t%2, %0\n@@ -910,109 +940,124 @@\n   or\\t%1, %0\n   or\\t%2, %1, %0\n   or\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"11,11,11,11,11,11,11,11,33\")\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,11,11,33\")\n    (set_attr \"length\"  \"2,2,3,4,5,6,2,3,5\")]\n )\n \n (define_insn \"rotlsi3\"\n   [(set (match_operand:SI            0 \"register_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n-\t\t   (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))]\n+\t\t   (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (rotate:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"rotl\\t%2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"3\")]\n+  [(set_attr \"length\" \"3\")]\n )\n \n (define_insn \"rotrsi3\"\n   [(set (match_operand:SI              0 \"register_operand\" \"=r\")\n \t(rotatert:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n-\t\t     (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))]\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (rotatert:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"rotr\\t%2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"3\")]\n+  [(set_attr \"length\" \"3\")]\n )\n \n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI              0 \"register_operand\" \"=r,r,r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n-\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (ashiftrt:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   shar\\t%2, %0\n   shar\\t%2, %0\n   shar\\t%2, %1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"3,2,3\")]\n+  [(set_attr \"length\" \"3,2,3\")]\n )\n \n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI              0 \"register_operand\" \"=r,r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n-\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (lshiftrt:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   shlr\\t%2, %0\n   shlr\\t%2, %0\n   shlr\\t%2, %1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"3,2,3\")]\n+  [(set_attr \"length\" \"3,2,3\")]\n )\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI            0 \"register_operand\" \"=r,r,r\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n-\t           (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+\t           (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (ashift:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"@\n   shll\\t%2, %0\n   shll\\t%2, %0\n   shll\\t%2, %1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"length\" \"3,2,3\")]\n+  [(set_attr \"length\" \"3,2,3\")]\n )\n \n (define_insn \"subsi3\"\n   [(set (match_operand:SI           0 \"register_operand\" \"=r,r,r,r,r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0,r,0\")\n-\t\t  (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,n,r,Q\")))]\n+\t\t  (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,n,r,Q\")))\n+   (set (reg:CC_ZSC CC_REG)\n+\t;; Note - we do not acknowledge that the SUB instruction sets the Overflow\n+\t;; flag because its interpretation is different from comparing the result\n+\t;; against zero.  Compile and run gcc.c-torture/execute/cmpsi-1.c to see this.\n+\t(compare:CC_ZSC (minus:SI (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"\"\n   \"@\n   sub\\t%2, %0\n   sub\\t%2, %0\n   add\\t%N2, %0\n   sub\\t%2, %1, %0\n   sub\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zsc\") ;; Note - we do not acknowledge that the SUB\n-   ;; instruction sets the Overflow flag because its interpretation is\n-   ;; different from comparing the result against zero.  Compile and run\n-   ;; gcc.c-torture/execute/cmpsi-1.c to see this.\n-   (set_attr \"timings\" \"11,11,11,11,33\")\n+  [(set_attr \"timings\" \"11,11,11,11,33\")\n    (set_attr \"length\" \"2,2,6,3,5\")]\n )\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI           0 \"register_operand\" \"=r,r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\"  \"0,0\")\n-\t\t  (match_operand:DI 2 \"rx_source_operand\" \"r,Q\")))]\n+\t\t  (match_operand:DI 2 \"rx_source_operand\" \"r,Q\")))\n+   (set (reg:CC_ZSC CC_REG) ;; See subsi3\n+\t(compare:CC_ZSC (minus:DI (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"\"\n   \"sub\\t%L2, %L0\\n\\tsbb\\t%H2, %H0\"\n-  [(set_attr \"cc\" \"set_zsc\") ;; See subsi3\n-   (set_attr \"timings\" \"22,44\")\n+  [(set_attr \"timings\" \"22,44\")\n    (set_attr \"length\" \"5,11\")]\n )\n \n (define_insn \"xorsi3\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n \t        (match_operand:SI 2 \"rx_source_operand\"\n-\t\t\t\t  \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+\t\t\t\t  \"r,Sint08,Sint16,Sint24,i,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (xor:SI (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"\"\n   \"xor\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"11,11,11,11,11,33\")\n+  [(set_attr \"timings\" \"11,11,11,11,11,33\")\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n \f\n@@ -1021,64 +1066,76 @@\n (define_insn \"addsf3\"\n   [(set (match_operand:SF          0 \"register_operand\"  \"=r,r,r\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\"  \"%0,0,0\")\n-\t\t (match_operand:SF 2 \"rx_source_operand\"  \"r,F,Q\")))]\n+\t\t (match_operand:SF 2 \"rx_source_operand\"  \"r,F,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (plus:SF (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"fadd\\t%2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"44,44,66\")\n+  [(set_attr \"timings\" \"44,44,66\")\n    (set_attr \"length\" \"3,7,5\")]\n )\n \n (define_insn \"divsf3\"\n   [(set (match_operand:SF         0 \"register_operand\" \"=r,r,r\")\n \t(div:SF (match_operand:SF 1 \"register_operand\"  \"0,0,0\")\n-\t\t(match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))]\n+\t\t(match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (div:SF (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"fdiv\\t%2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"1616,1616,1818\")\n+  [(set_attr \"timings\" \"1616,1616,1818\")\n    (set_attr \"length\" \"3,7,5\")]\n )\n \n (define_insn \"mulsf3\"\n   [(set (match_operand:SF          0 \"register_operand\" \"=r,r,r\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0,0,0\")\n-\t\t(match_operand:SF  2 \"rx_source_operand\" \"r,F,Q\")))]\n+\t\t(match_operand:SF  2 \"rx_source_operand\" \"r,F,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (mult:SF (match_dup 1) (match_dup 2))\n+\t\t\t(const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"fmul\\t%2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"33,33,55\")\n+  [(set_attr \"timings\" \"33,33,55\")\n    (set_attr \"length\"  \"3,7,5\")]\n )\n \n (define_insn \"subsf3\"\n   [(set (match_operand:SF           0 \"register_operand\" \"=r,r,r\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\"  \"0,0,0\")\n-\t\t  (match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))]\n+\t\t  (match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (minus:SF (match_dup 1) (match_dup 2))\n+\t\t       (const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"fsub\\t%Q2, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"44,44,66\")\n+  [(set_attr \"timings\" \"44,44,66\")\n    (set_attr \"length\" \"3,7,5\")]\n )\n \n (define_insn \"fix_truncsfsi2\"\n   [(set (match_operand:SI         0 \"register_operand\"  \"=r,r\")\n-\t(fix:SI (match_operand:SF 1 \"rx_compare_operand\" \"r,Q\")))]\n+\t(fix:SI (match_operand:SF 1 \"rx_compare_operand\" \"r,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (fix:SI (match_dup 1))\n+\t\t       (const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"ftoi\\t%Q1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"22,44\")\n+  [(set_attr \"timings\" \"22,44\")\n    (set_attr \"length\" \"3,5\")]\n )\n \n (define_insn \"floatsisf2\"\n   [(set (match_operand:SF           0 \"register_operand\"  \"=r,r\")\n-\t(float:SF (match_operand:SI 1 \"rx_compare_operand\" \"r,Q\")))]\n+\t(float:SF (match_operand:SI 1 \"rx_compare_operand\" \"r,Q\")))\n+   (set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS (float:SF (match_dup 1))\n+\t\t\t(const_int 0)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"itof\\t%Q1, %0\"\n-  [(set_attr \"cc\" \"set_zs\")\n-   (set_attr \"timings\" \"22,44\")\n+  [(set_attr \"timings\" \"22,44\")\n    (set_attr \"length\" \"3,6\")]\n )\n \f\n@@ -1090,8 +1147,8 @@\n ;; of three instructions at a time.\n \n (define_insn \"bitset\"\n-  [(set:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t   (ior:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+  [(set:SI (match_operand:SI                    0 \"register_operand\" \"=r\")\n+\t   (ior:SI (match_operand:SI            1 \"register_operand\" \"0\")\n \t\t   (ashift:SI (const_int 1)\n \t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"ri\"))))]\n   \"\"\n@@ -1100,8 +1157,8 @@\n )\n \n (define_insn \"bitset_in_memory\"\n-  [(set:QI (match_operand:QI 0 \"memory_operand\" \"=m\")\n-\t   (ior:QI (match_operand:QI 1 \"memory_operand\" \"0\")\n+  [(set:QI (match_operand:QI                    0 \"memory_operand\" \"=m\")\n+\t   (ior:QI (match_operand:QI            1 \"memory_operand\" \"0\")\n \t\t   (ashift:QI (const_int 1)\n \t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"ri\"))))]\n   \"\"\n@@ -1275,14 +1332,10 @@\n )\n \n (define_expand \"insv\"\n-  [(set:SI (zero_extract:SI (match_operand:SI\n-\t\t\t     0 \"nonimmediate_operand\") ;; Destination\n-\t\t            (match_operand\n-\t\t\t     1 \"immediate_operand\")    ;; # of bits to set\n-\t\t\t    (match_operand\n-\t\t\t     2 \"immediate_operand\"))   ;; Starting bit\n-\t   (match_operand\n-\t    3 \"immediate_operand\"))]  ;; Bits to insert\n+  [(set:SI (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\") ;; Destination\n+\t\t            (match_operand    1 \"immediate_operand\")    ;; # of bits to set\n+\t\t\t    (match_operand    2 \"immediate_operand\"))   ;; Starting bit\n+\t   (match_operand\t              3 \"immediate_operand\"))]  ;; Bits to insert\n   \"\"\n   {\n     if (rx_expand_insv (operands))\n@@ -1337,8 +1390,7 @@\n    (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVSTR)\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 3))\n-  ]\n+   (clobber (reg:SI 3))]\n   \"\"\n   \"smovu\"\n   [(set_attr \"length\" \"2\")\n@@ -1352,11 +1404,11 @@\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (clobber (reg:SI 3))\n-  ]\n+   (clobber (reg:CC CC_REG))\n+   ]\n   \"\"\n   \"mov\\t%1, r1\\n\\tmov\\t#0, r2\\n\\tsuntil.b\\n\\tmov\\tr1, %0\\n\\tsub\\t#1, %0\"\n   [(set_attr \"length\" \"10\")\n-   (set_attr \"cc\" \"clobber\")\n    (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n )\n \n@@ -1439,17 +1491,12 @@\n )\n \n (define_expand \"cmpstrnsi\"\n-  [(set (match_operand:SI\n-\t 0 \"register_operand\") ;; Result\n-\t(unspec_volatile:SI [(match_operand:BLK\n-\t\t\t      1 \"memory_operand\") ;; String1\n-\t\t\t     (match_operand:BLK\n-\t\t\t      2 \"memory_operand\")] ;; String2\n+  [(set (match_operand:SI                       0 \"register_operand\")   ;; Result\n+\t(unspec_volatile:SI [(match_operand:BLK 1 \"memory_operand\")     ;; String1\n+\t\t\t     (match_operand:BLK 2 \"memory_operand\")]    ;; String2\n \t\t\t    UNSPEC_CMPSTRN))\n-   (use (match_operand:SI\n-\t 3 \"register_operand\")) ;; Max Length\n-   (match_operand:SI\n-    4 \"immediate_operand\")] ;; Known Align\n+   (use (match_operand:SI                       3 \"register_operand\"))  ;; Max Length\n+   (match_operand:SI                            4 \"immediate_operand\")] ;; Known Align\n   \"\"\n   {\n     rtx str1 = gen_rtx_REG (SImode, 1);\n@@ -1466,15 +1513,11 @@\n )\n \n (define_expand \"cmpstrsi\"\n-  [(set (match_operand:SI\n-\t 0 \"register_operand\") ;; Result\n-\t(unspec_volatile:SI [(match_operand:BLK\n-\t\t\t      1 \"memory_operand\")  ;; String1\n-\t\t\t     (match_operand:BLK\n-\t\t\t      2 \"memory_operand\")] ;; String2\n+  [(set (match_operand:SI                       0 \"register_operand\")   ;; Result\n+\t(unspec_volatile:SI [(match_operand:BLK 1 \"memory_operand\")     ;; String1\n+\t\t\t     (match_operand:BLK 2 \"memory_operand\")]    ;; String2\n \t\t\t    UNSPEC_CMPSTRN))\n-   (match_operand:SI\n-    3 \"immediate_operand\")] ;; Known Align\n+   (match_operand:SI                            3 \"immediate_operand\")] ;; Known Align\n   \"\"\n   {\n     rtx str1 = gen_rtx_REG (SImode, 1);\n@@ -1498,7 +1541,8 @@\n    (use (match_operand:BLK   2 \"memory_operand\" \"m\"))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 3))]\n+   (clobber (reg:SI 3))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"scmpu\t\t; Perform the string comparison\n    mov     #-1, %0      ; Set up -1 result (which cannot be created\n@@ -1639,11 +1683,11 @@\n (define_insn \"lrintsf2\"\n   [(set (match_operand:SI             0 \"register_operand\"  \"=r,r\")\n \t(unspec:SI [(match_operand:SF 1 \"rx_compare_operand\" \"r,Q\")]\n-\t\t   UNSPEC_BUILTIN_ROUND))]\n+\t\t   UNSPEC_BUILTIN_ROUND))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"round\\t%1, %0\"\n-  [(set_attr \"cc\" \"clobber\")\n-   (set_attr \"timings\" \"22,44\")   \n+  [(set_attr \"timings\" \"22,44\")   \n    (set_attr \"length\" \"3,5\")]\n )\n \n@@ -1663,22 +1707,20 @@\n (define_insn \"clrpsw\"\n   [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n \t      UNSPEC_BUILTIN_CLRPSW)\n-   (clobber (cc0))]\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"clrpsw\\t%F0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")]\n+  [(set_attr \"length\" \"2\")]\n )\n \n ;; Set Processor Status Word\n (define_insn \"setpsw\"\n   [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n \t      UNSPEC_BUILTIN_SETPSW)\n-   (clobber (cc0))]\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n   \"setpsw\\t%F0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"clobber\")]\n+  [(set_attr \"length\" \"2\")]\n )\n \n ;; Move from control register"}]}