{"sha": "c0111dc43591647ef6d619a1fc222a8e9a06e058", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxMTFkYzQzNTkxNjQ3ZWY2ZDYxOWExZmMyMjJhOGU5YTA2ZTA1OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2018-07-31T17:36:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2018-07-31T17:36:26Z"}, "message": "AArch64 - use CSDB based sequences if speculation tracking is enabled\n\nIn this final patch, now that we can track speculation through conditional\nbranches, we can use this information to use a less expensive CSDB based\nspeculation barrier.\n\n\t* config/aarch64/iterators.md (ALLI_TI): New iterator.\n\t* config/aarch64/aarch64.md (despeculate_copy<ALLI_TI:mode>): New\n\texpand.\n\t(despeculate_copy<ALLI:mode>_insn): New insn.\n\t(despeculate_copyti_insn): New insn.\n\t(despeculate_simple<ALLI:mode>): New insn\n\t(despeculate_simpleti): New insn.\n\t* config/aarch64/aarch64.c (aarch64_speculation_safe_value): New\n\tfunction.\n\t(TARGET_SPECULATION_SAFE_VALUE): Redefine to\n\taarch64_speculation_safe_value.\n\t(aarch64_print_operand): Handle const0_rtx in modifier 'H'.\n\nFrom-SVN: r263174", "tree": {"sha": "77960405952ad4760701c6a46513979c60c7c8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77960405952ad4760701c6a46513979c60c7c8d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0111dc43591647ef6d619a1fc222a8e9a06e058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0111dc43591647ef6d619a1fc222a8e9a06e058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0111dc43591647ef6d619a1fc222a8e9a06e058", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0111dc43591647ef6d619a1fc222a8e9a06e058/comments", "author": null, "committer": null, "parents": [{"sha": "3751345de3763609848d77cffcc91db13e365216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3751345de3763609848d77cffcc91db13e365216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3751345de3763609848d77cffcc91db13e365216"}], "stats": {"total": 163, "additions": 163, "deletions": 0}, "files": [{"sha": "48a2002cfd746212a1fdf4fba0f59d0127628f7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0111dc43591647ef6d619a1fc222a8e9a06e058", "patch": "@@ -1,3 +1,18 @@\n+2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/aarch64/iterators.md (ALLI_TI): New iterator.\n+\t* config/aarch64/aarch64.md (despeculate_copy<ALLI_TI:mode>): New\n+\texpand.\n+\t(despeculate_copy<ALLI:mode>_insn): New insn.\n+\t(despeculate_copyti_insn): New insn.\n+\t(despeculate_simple<ALLI:mode>): New insn\n+\t(despeculate_simpleti): New insn.\n+\t* config/aarch64/aarch64.c (aarch64_speculation_safe_value): New\n+\tfunction.\n+\t(TARGET_SPECULATION_SAFE_VALUE): Redefine to\n+\taarch64_speculation_safe_value.\n+\t(aarch64_print_operand): Handle const0_rtx in modifier 'H'.\n+\n 2018-07-31  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/aarch64/aarch64-speculation.cc: New file."}, {"sha": "f743f577357451cb69cfca6d44e5e5ac14ea2529", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c0111dc43591647ef6d619a1fc222a8e9a06e058", "patch": "@@ -6785,6 +6785,12 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n       break;\n \n     case 'H':\n+      if (x == const0_rtx)\n+\t{\n+\t  asm_fprintf (f, \"xzr\");\n+\t  break;\n+\t}\n+\n       if (!REG_P (x) || !GP_REGNUM_P (REGNO (x) + 1))\n \t{\n \t  output_operand_lossage (\"invalid operand for '%%%c'\", code);\n@@ -17778,6 +17784,45 @@ aarch64_select_early_remat_modes (sbitmap modes)\n     }\n }\n \n+/* Override the default target speculation_safe_value.  */\n+static rtx\n+aarch64_speculation_safe_value (machine_mode mode,\n+\t\t\t\trtx result, rtx val, rtx failval)\n+{\n+  /* Maybe we should warn if falling back to hard barriers.  They are\n+     likely to be noticably more expensive than the alternative below.  */\n+  if (!aarch64_track_speculation)\n+    return default_speculation_safe_value (mode, result, val, failval);\n+\n+  if (!REG_P (val))\n+    val = copy_to_mode_reg (mode, val);\n+\n+  if (!aarch64_reg_or_zero (failval, mode))\n+    failval = copy_to_mode_reg (mode, failval);\n+\n+  switch (mode)\n+    {\n+    case E_QImode:\n+      emit_insn (gen_despeculate_copyqi (result, val, failval));\n+      break;\n+    case E_HImode:\n+      emit_insn (gen_despeculate_copyhi (result, val, failval));\n+      break;\n+    case E_SImode:\n+      emit_insn (gen_despeculate_copysi (result, val, failval));\n+      break;\n+    case E_DImode:\n+      emit_insn (gen_despeculate_copydi (result, val, failval));\n+      break;\n+    case E_TImode:\n+      emit_insn (gen_despeculate_copyti (result, val, failval));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return result;\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P\n@@ -18250,6 +18295,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_SELECT_EARLY_REMAT_MODES\n #define TARGET_SELECT_EARLY_REMAT_MODES aarch64_select_early_remat_modes\n \n+#undef TARGET_SPECULATION_SAFE_VALUE\n+#define TARGET_SPECULATION_SAFE_VALUE aarch64_speculation_safe_value\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}, {"sha": "9f3cadecad0f488b13bd4578f93e61abbe0db167", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=c0111dc43591647ef6d619a1fc222a8e9a06e058", "patch": "@@ -6590,6 +6590,103 @@\n    (set_attr \"speculation_barrier\" \"true\")]\n )\n \n+;; Support for __builtin_speculation_safe_value when we have speculation\n+;; tracking enabled.  Use the speculation tracker to decide whether to\n+;; copy operand 1 to the target, or to copy the fail value (operand 2).\n+(define_expand \"despeculate_copy<ALLI_TI:mode>\"\n+  [(set (match_operand:ALLI_TI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:ALLI_TI\n+\t [(match_operand:ALLI_TI 1 \"register_operand\" \"r\")\n+\t  (match_operand:ALLI_TI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+\t  (use (reg:DI SPECULATION_TRACKER_REGNUM))\n+\t  (clobber (reg:CC CC_REGNUM))] UNSPECV_SPECULATION_BARRIER))]\n+  \"\"\n+  \"\n+  {\n+    if (operands[2] == const0_rtx)\n+      {\n+\trtx tracker;\n+\tif (<MODE>mode == TImode)\n+\t  tracker = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+\telse\n+\t  tracker = gen_rtx_REG (<MODE>mode, SPECULATION_TRACKER_REGNUM);\n+\n+\temit_insn (gen_despeculate_simple<mode> (operands[0], operands[1],\n+\t\t\t\t\t\t tracker));\n+\tDONE;\n+      }\n+  }\n+  \"\n+)\n+\n+;; Patterns to match despeculate_copy<mode>.  Note that \"hint 0x14\" is the\n+;; encoding for CSDB, but will work in older versions of the assembler.\n+(define_insn \"*despeculate_copy<ALLI:mode>_insn\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:ALLI\n+\t [(match_operand:ALLI 1 \"register_operand\" \"r\")\n+\t  (match_operand:ALLI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+\t  (use (reg:DI SPECULATION_TRACKER_REGNUM))\n+\t  (clobber (reg:CC CC_REGNUM))] UNSPECV_SPECULATION_BARRIER))]\n+  \"\"\n+  {\n+    operands[3] = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+    output_asm_insn (\"cmp\\\\t%3, #0\\;csel\\\\t%<w>0, %<w>1, %<w>2, ne\\;hint\\t0x14 // csdb\",\n+\t\t     operands);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"type\" \"block\")\n+   (set_attr \"speculation_barrier\" \"true\")]\n+)\n+\n+;; Pattern to match despeculate_copyti\n+(define_insn \"*despeculate_copyti_insn\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:TI\n+\t [(match_operand:TI 1 \"register_operand\" \"r\")\n+\t  (match_operand:TI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+\t  (use (reg:DI SPECULATION_TRACKER_REGNUM))\n+\t  (clobber (reg:CC CC_REGNUM))] UNSPECV_SPECULATION_BARRIER))]\n+  \"\"\n+  {\n+    operands[3] = gen_rtx_REG (DImode, SPECULATION_TRACKER_REGNUM);\n+    output_asm_insn\n+      (\"cmp\\\\t%3, #0\\;csel\\\\t%0, %1, %2, ne\\;csel\\\\t%H0, %H1, %H2, ne\\;hint\\t0x14 // csdb\",\n+       operands);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"block\")\n+   (set_attr \"speculation_barrier\" \"true\")]\n+)\n+\n+(define_insn \"despeculate_simple<ALLI:mode>\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:ALLI\n+\t [(match_operand:ALLI 1 \"register_operand\" \"r\")\n+\t  (use (match_operand:ALLI 2 \"register_operand\" \"\"))]\n+\t UNSPECV_SPECULATION_BARRIER))]\n+  \"\"\n+  \"and\\\\t%<w>0, %<w>1, %<w>2\\;hint\\t0x14 // csdb\"\n+  [(set_attr \"type\" \"block\")\n+   (set_attr \"length\" \"8\")\n+   (set_attr \"speculation_barrier\" \"true\")]\n+)\n+\n+(define_insn \"despeculate_simpleti\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:TI\n+\t [(match_operand:TI 1 \"register_operand\" \"r\")\n+\t  (use (match_operand:DI 2 \"register_operand\" \"\"))]\n+\t UNSPECV_SPECULATION_BARRIER))]\n+  \"\"\n+  \"and\\\\t%0, %1, %2\\;and\\\\t%H0, %H1, %2\\;hint\\t0x14 // csdb\"\n+  [(set_attr \"type\" \"block\")\n+   (set_attr \"length\" \"12\")\n+   (set_attr \"speculation_barrier\" \"true\")]\n+)\n+\n ;; AdvSIMD Stuff\n (include \"aarch64-simd.md\")\n "}, {"sha": "450edea8ca090f78e054eedc94b59abdebb68b55", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0111dc43591647ef6d619a1fc222a8e9a06e058/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=c0111dc43591647ef6d619a1fc222a8e9a06e058", "patch": "@@ -35,6 +35,9 @@\n ;; Iterator for all integer modes (up to 64-bit)\n (define_mode_iterator ALLI [QI HI SI DI])\n \n+;; Iterator for all integer modes (up to 128-bit)\n+(define_mode_iterator ALLI_TI [QI HI SI DI TI])\n+\n ;; Iterator for all integer modes that can be extended (up to 64-bit)\n (define_mode_iterator ALLX [QI HI SI])\n "}]}