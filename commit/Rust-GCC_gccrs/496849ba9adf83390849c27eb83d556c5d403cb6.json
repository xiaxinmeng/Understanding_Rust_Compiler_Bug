{"sha": "496849ba9adf83390849c27eb83d556c5d403cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2ODQ5YmE5YWRmODMzOTA4NDljMjdlYjgzZDU1NmM1ZDQwM2NiNg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-08-24T17:40:54Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-24T17:40:54Z"}, "message": "jcf-parse.c (yyparse): Set magic to 0, don't issue error for a file smaller than 4 bytes.\n\n2001-08-23  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* jcf-parse.c (yyparse): Set magic to 0, don't issue error for a\n\tfile smaller than 4 bytes.\n\t* parse.y (check_inner_circular_reference): New function.\n\t(check_circular_reference): Likewise.\n\t(array_initializer:): Accept {,}.\n\t(java_check_circular_reference): Rewritten using\n\tcheck_circular_reference and check_inner_circular_reference.\n\t(java_complete_expand_method): Unconditionally save and restore\n\tthe unpurged exception list.\n\t(build_dot_class_method_invocation): Unmangle signature parameter.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-08/msg01417.html)\n\nFrom-SVN: r45156", "tree": {"sha": "d9bf3f14985d225ac1ec275d43787ee9713b21b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9bf3f14985d225ac1ec275d43787ee9713b21b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/496849ba9adf83390849c27eb83d556c5d403cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496849ba9adf83390849c27eb83d556c5d403cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496849ba9adf83390849c27eb83d556c5d403cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496849ba9adf83390849c27eb83d556c5d403cb6/comments", "author": null, "committer": null, "parents": [{"sha": "f2c333a19db8f4a917ad0a64ef4bd818a8865d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2c333a19db8f4a917ad0a64ef4bd818a8865d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2c333a19db8f4a917ad0a64ef4bd818a8865d89"}], "stats": {"total": 148, "additions": 113, "deletions": 35}, "files": [{"sha": "831a380d2380a828302d2fddbb441557d837de14", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=496849ba9adf83390849c27eb83d556c5d403cb6", "patch": "@@ -1,3 +1,16 @@\n+2001-08-23  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* jcf-parse.c (yyparse): Set magic to 0, don't issue error for a\n+\tfile smaller than 4 bytes.  \n+\t* parse.y (check_inner_circular_reference): New function.\n+\t(check_circular_reference): Likewise.\n+\t(array_initializer:): Accept {,}.\n+\t(java_check_circular_reference): Rewritten using\n+\tcheck_circular_reference and check_inner_circular_reference.\n+\t(java_complete_expand_method): Unconditionally save and restore\n+\tthe unpurged exception list.\n+\t(build_dot_class_method_invocation): Unmangle signature parameter.\n+\n 2001-08-21  Tom Tromey  <tromey@redhat.com>\n \n \t* decl.c (init_decl_processing): Add `throws' field to method"}, {"sha": "b52f1c11fb1533710d1bdc74e350f4f10ed8ab4c", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=496849ba9adf83390849c27eb83d556c5d403cb6", "patch": "@@ -1088,7 +1088,7 @@ yyparse ()\n   for (node = current_file_list; node; node = TREE_CHAIN (node))\n     {\n       unsigned char magic_string[4];\n-      uint32 magic;\n+      uint32 magic = 0;\n       tree name = TREE_VALUE (node);\n \n       /* Skip already parsed files */\n@@ -1110,11 +1110,11 @@ yyparse ()\n       input_filename = IDENTIFIER_POINTER (name);\n \n       /* Figure what kind of file we're dealing with */\n-      if (fread (magic_string, 1, 4, finput) != 4)\n-\tfatal_io_error (\"Premature end of input file %s\", \n-\t\t\tIDENTIFIER_POINTER (name));\n-      fseek (finput, 0L, SEEK_SET);\n-      magic = GET_u4 (magic_string);\n+      if (fread (magic_string, 1, 4, finput) == 4)\n+\t{\n+\t  fseek (finput, 0L, SEEK_SET);\n+\t  magic = GET_u4 (magic_string);\n+\t}\n       if (magic == 0xcafebabe)\n \t{\n \t  CLASS_FILE_P (node) = 1;"}, {"sha": "b6054d418f7da7c8106d33f691bcf2cf75d36407", "filename": "gcc/java/parse.y", "status": "modified", "additions": 94, "deletions": 29, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496849ba9adf83390849c27eb83d556c5d403cb6/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=496849ba9adf83390849c27eb83d556c5d403cb6", "patch": "@@ -141,6 +141,8 @@ static tree patch_invoke PARAMS ((tree, tree, tree));\n static int maybe_use_access_method PARAMS ((int, tree *, tree *));\n static tree lookup_method_invoke PARAMS ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PARAMS ((int, tree, tree, tree));\n+static tree check_inner_circular_reference PARAMS ((tree, tree));\n+static tree check_circular_reference PARAMS ((tree));\n static tree obtain_incomplete_type PARAMS ((tree));\n static tree java_complete_lhs PARAMS ((tree));\n static tree java_complete_tree PARAMS ((tree));\n@@ -1346,6 +1348,8 @@ abstract_method_declaration:\n array_initializer:\n \tOCB_TK CCB_TK\n \t\t{ $$ = build_new_array_init ($1.location, NULL_TREE); }\n+|\tOCB_TK C_TK CCB_TK\n+\t\t{ $$ = build_new_array_init ($1.location, NULL_TREE); }\n |\tOCB_TK variable_initializers CCB_TK\n \t\t{ $$ = build_new_array_init ($1.location, $2); }\n |\tOCB_TK variable_initializers C_TK CCB_TK\n@@ -5219,37 +5223,96 @@ register_incomplete_type (kind, wfl, decl, ptr)\n   return ptr;\n }\n \n+/* This checks for circular references with innerclasses. We start\n+   from SOURCE and should never reach TARGET. Extended/implemented\n+   types in SOURCE have their enclosing context checked not to reach\n+   TARGET. When the last enclosing context of SOURCE is reached, its\n+   extended/implemented types are also checked not to reach TARGET.\n+   In case of error, WFL of the offending type is returned; NULL_TREE\n+   otherwise.  */\n+\n+static tree\n+check_inner_circular_reference (source, target)\n+     tree source;\n+     tree target;\n+{\n+  tree basetype_vec = TYPE_BINFO_BASETYPES (source);\n+  tree ctx, cl;\n+  int i;\n+\n+  if (!basetype_vec)\n+    return NULL_TREE;\n+  \n+  for (i = 0; i < TREE_VEC_LENGTH (basetype_vec); i++)\n+    {\n+      tree su = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n+\n+      if (inherits_from_p (su, target))\n+\treturn lookup_cl (TYPE_NAME (su));\n+      \n+      for (ctx = DECL_CONTEXT (TYPE_NAME (su)); ctx; ctx = DECL_CONTEXT (ctx))\n+\t{\n+\t  /* An enclosing context shouldn't be TARGET */\n+\t  if (ctx == TYPE_NAME (target))\n+\t    return lookup_cl (TYPE_NAME (su));\n+\n+\t  /* When we reach the enclosing last context, start a check\n+\t     on it, with the same target */\n+\t  if (! DECL_CONTEXT (ctx) &&\n+\t      (cl = check_inner_circular_reference (TREE_TYPE (ctx), target)))\n+\t    return cl;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Explore TYPE's `extends' clause member(s) and return the WFL of the\n+   offending type if a circularity is detected. NULL_TREE is returned\n+   otherwise. TYPE can be an interface or a class.   */\n+\n+static tree\n+check_circular_reference (type)\n+     tree type;\n+{\n+  tree basetype_vec = TYPE_BINFO_BASETYPES (type);\n+  int i;\n+\n+  if (!basetype_vec)\n+    return NULL_TREE;\n+\n+  if (! CLASS_INTERFACE (TYPE_NAME (type)))\n+    {\n+      if (inherits_from_p (CLASSTYPE_SUPER (type), type))\n+\treturn lookup_cl (TYPE_NAME (type));\n+      return NULL_TREE;\n+    }\n+    \n+  for (i = 0; i < TREE_VEC_LENGTH (basetype_vec); i++)\n+    {\n+      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n+      if (vec_elt && BINFO_TYPE (vec_elt) != object_type_node\n+\t  && interface_of_p (type, BINFO_TYPE (vec_elt)))\n+\treturn lookup_cl (TYPE_NAME (BINFO_TYPE (vec_elt)));\n+    }\n+  return NULL_TREE;\n+}\n+\n void\n java_check_circular_reference ()\n {\n   tree current;\n   for (current = ctxp->class_list; current; current = TREE_CHAIN (current))\n     {\n       tree type = TREE_TYPE (current);\n-      if (CLASS_INTERFACE (current))\n-\t{\n-\t  /* Check all interfaces this class extends */\n-\t  tree basetype_vec = TYPE_BINFO_BASETYPES (type);\n-\t  int n, i;\n+      tree cl;\n \n-\t  if (!basetype_vec)\n-\t    return;\n-\t  n = TREE_VEC_LENGTH (basetype_vec);\n-\t  for (i = 0; i < n; i++)\n-\t    {\n-\t      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n-\t      if (vec_elt && BINFO_TYPE (vec_elt) != object_type_node \n-\t\t  && interface_of_p (type, BINFO_TYPE (vec_elt)))\n-\t\tparse_error_context (lookup_cl (current),\n-\t\t\t\t     \"Cyclic interface inheritance\");\n-\t    }\n-\t}\n-      else\n-\tif (inherits_from_p (CLASSTYPE_SUPER (type), type))\n-\t  parse_error_context (lookup_cl (current), \n-\t\t\t       \"Cyclic class inheritance%s\",\n-\t\t\t       (cyclic_inheritance_report ?\n-\t\t\t\tcyclic_inheritance_report : \"\"));\n+      cl = check_circular_reference (type);\n+      if (! cl)\n+\tcl = check_inner_circular_reference (type, type);\n+      if (cl)\n+\tparse_error_context (cl, \"Cyclic class inheritance%s\",\n+\t\t\t     (cyclic_inheritance_report ?\n+\t\t\t      cyclic_inheritance_report : \"\"));\n     }\n }\n \n@@ -7918,10 +7981,9 @@ java_complete_expand_method (mdecl)\n   current_this = (!METHOD_STATIC (mdecl) ? \n \t\t  BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)) : NULL_TREE);\n \n-  /* Purge the `throws' list of unchecked exceptions. If we're doing\n-     xref, save a copy of the list and re-install it later. */\n-  if (flag_emit_xref)\n-    exception_copy = copy_list (DECL_FUNCTION_THROWS (mdecl));\n+  /* Purge the `throws' list of unchecked exceptions (we save a copy\n+     of the list and re-install it later.) */\n+  exception_copy = copy_list (DECL_FUNCTION_THROWS (mdecl));\n   purge_unchecked_exceptions (mdecl);\n   \n   /* Install exceptions thrown with `throws' */\n@@ -7985,8 +8047,7 @@ java_complete_expand_method (mdecl)\n     abort ();\n \n   /* Restore the copy of the list of exceptions if emitting xrefs. */\n-  if (flag_emit_xref)\n-    DECL_FUNCTION_THROWS (mdecl) = exception_copy;\n+  DECL_FUNCTION_THROWS (mdecl) = exception_copy;\n }\n \n /* For with each class for which there's code to generate. */\n@@ -8657,6 +8718,10 @@ build_dot_class_method_invocation (type)\n   else\n     sig_id = DECL_NAME (TYPE_NAME (type));\n \n+  /* Ensure that the proper name separator is used */\n+  sig_id = unmangle_classname (IDENTIFIER_POINTER (sig_id),\n+\t\t\t       IDENTIFIER_LENGTH (sig_id));\n+\n   s = build_string (IDENTIFIER_LENGTH (sig_id), \n \t\t    IDENTIFIER_POINTER (sig_id));\n   return build_method_invocation (build_wfl_node (classdollar_identifier_node),"}]}