{"sha": "8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0MmIzMGM3YzFhNjUwMGY1NmJkZjkzYmE5NmM1NGRhMzcwYmE4Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T13:57:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T13:57:28Z"}, "message": "[multiple changes]\n\n2014-07-16  Vadim Godunko  <godunko@adacore.com>\n\n\t* a-coinho-shared.adb (Adjust): Create\n\tcopy of internal shared object and element when source container\n\tis locked.\n\t(Copy): Likewise.\n\t(Query_Element): Likewise.\n\t(Update_Element): Likewise.\n\t(Constant_Reference): Likewise. Raise Constraint_Error on attempt\n\tto get reference for empty holder.\n\t(Reference): Likewise.\n\n2014-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Find_Hook_Context): New subprogram, extracted\n\tfrom Process_Transient_Oject.\n\t* exp_ch4.ads: Ditto.\n\t* exp_ch9.adb (Build_Class_Wide_Master): Insert the _master\n\tdeclaration as an action on the topmost enclosing expression,\n\tnot on a possibly conditional subexpreession.\n\nFrom-SVN: r212645", "tree": {"sha": "28cb986e265381c95622992e637affa7b3e12cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28cb986e265381c95622992e637affa7b3e12cb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/comments", "author": null, "committer": null, "parents": [{"sha": "d6f824bf7f4d82ab9b96b31d56b88fa1f2b1f166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6f824bf7f4d82ab9b96b31d56b88fa1f2b1f166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6f824bf7f4d82ab9b96b31d56b88fa1f2b1f166"}], "stats": {"total": 551, "additions": 328, "deletions": 223}, "files": [{"sha": "f2dfb3e456af937b7dc8ed1b9c43fbf44a8c9159", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "patch": "@@ -1,3 +1,24 @@\n+2014-07-16  Vadim Godunko  <godunko@adacore.com>\n+\n+\t* a-coinho-shared.adb (Adjust): Create\n+\tcopy of internal shared object and element when source container\n+\tis locked.\n+\t(Copy): Likewise.\n+\t(Query_Element): Likewise.\n+\t(Update_Element): Likewise.\n+\t(Constant_Reference): Likewise. Raise Constraint_Error on attempt\n+\tto get reference for empty holder.\n+\t(Reference): Likewise.\n+\n+2014-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Find_Hook_Context): New subprogram, extracted\n+\tfrom Process_Transient_Oject.\n+\t* exp_ch4.ads: Ditto.\n+\t* exp_ch9.adb (Build_Class_Wide_Master): Insert the _master\n+\tdeclaration as an action on the topmost enclosing expression,\n+\tnot on a possibly conditional subexpreession.\n+\n 2014-07-16  Vadim Godunko  <godunko@adacore.com>\n \n \t* a-coinho.adb, a-coinho-shared.adb, a-coinho.ads, a-coinho-shared.ads:"}, {"sha": "be45c90fd5abafed2ae2ebf445ed943a7f01e0d6", "filename": "gcc/ada/a-coinho-shared.adb", "status": "modified", "additions": 106, "deletions": 19, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fa-coinho-shared.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fa-coinho-shared.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinho-shared.adb?ref=8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "patch": "@@ -57,7 +57,20 @@ package body Ada.Containers.Indefinite_Holders is\n    overriding procedure Adjust (Container : in out Holder) is\n    begin\n       if Container.Reference /= null then\n-         Reference (Container.Reference);\n+         if Container.Busy = 0 then\n+            --  Container is not locked, reuse existing internal shared object.\n+\n+            Reference (Container.Reference);\n+         else\n+            --  Otherwise, create copy of both internal shared object and\n+            --  element.\n+\n+            Container.Reference :=\n+               new Shared_Holder'\n+                 (Counter => <>,\n+                  Element =>\n+                     new Element_Type'(Container.Reference.Element.all));\n+         end if;\n       end if;\n \n       Container.Busy := 0;\n@@ -113,16 +126,34 @@ package body Ada.Containers.Indefinite_Holders is\n    ------------------------\n \n    function Constant_Reference\n-     (Container : aliased Holder) return Constant_Reference_Type\n-   is\n-      Ref : constant Constant_Reference_Type :=\n-              (Element => Container.Reference.Element.all'Access,\n-               Control => (Controlled with Container'Unrestricted_Access));\n-      B   : Natural renames Ref.Control.Container.Busy;\n+     (Container : aliased Holder) return Constant_Reference_Type is\n    begin\n-      Reference (Ref.Control.Container.Reference);\n-      B := B + 1;\n-      return Ref;\n+      if Container.Reference = null then\n+         raise Constraint_Error with \"container is empty\";\n+\n+      elsif Container.Busy = 0\n+        and then not System.Atomic_Counters.Is_One\n+                       (Container.Reference.Counter)\n+      then\n+         --  Container is not locked and internal shared object is used by\n+         --  other container, create copy of both internal shared object and\n+         --  element.\n+\n+         Container'Unrestricted_Access.Reference :=\n+            new Shared_Holder'\n+              (Counter => <>,\n+               Element => new Element_Type'(Container.Reference.Element.all));\n+      end if;\n+\n+      declare\n+         Ref : constant Constant_Reference_Type :=\n+                 (Element => Container.Reference.Element.all'Access,\n+                  Control => (Controlled with Container'Unrestricted_Access));\n+      begin\n+         Reference (Ref.Control.Container.Reference);\n+         Ref.Control.Container.Busy := Ref.Control.Container.Busy + 1;\n+         return Ref;\n+      end;\n    end Constant_Reference;\n \n    ----------\n@@ -133,10 +164,21 @@ package body Ada.Containers.Indefinite_Holders is\n    begin\n       if Source.Reference = null then\n          return (Controlled with null, 0);\n-      else\n+      elsif Source.Busy = 0 then\n+         --  Container is not locked, reuse internal shared object.\n+\n          Reference (Source.Reference);\n \n          return (Controlled with Source.Reference, 0);\n+      else\n+         --  Otherwise, create copy of both internal shared object and elemet.\n+\n+         return\n+           (Controlled with\n+               new Shared_Holder'\n+                 (Counter => <>,\n+                  Element => new Element_Type'(Source.Reference.Element.all)),\n+               0);\n       end if;\n    end Copy;\n \n@@ -224,6 +266,19 @@ package body Ada.Containers.Indefinite_Holders is\n    begin\n       if Container.Reference = null then\n          raise Constraint_Error with \"container is empty\";\n+\n+      elsif Container.Busy = 0\n+        and then not System.Atomic_Counters.Is_One\n+                       (Container.Reference.Counter)\n+      then\n+         --  Container is not locked and internal shared object is used by\n+         --  other container, create copy of both internal shared object and\n+         --  element.\n+\n+         Container'Unrestricted_Access.Reference :=\n+            new Shared_Holder'\n+              (Counter => <>,\n+               Element => new Element_Type'(Container.Reference.Element.all));\n       end if;\n \n       B := B + 1;\n@@ -284,15 +339,34 @@ package body Ada.Containers.Indefinite_Holders is\n    end Reference;\n \n    function Reference\n-     (Container : aliased in out Holder) return Reference_Type\n-   is\n-      Ref : constant Reference_Type :=\n-              (Element => Container.Reference.Element.all'Access,\n-               Control => (Controlled with Container'Unrestricted_Access));\n+     (Container : aliased in out Holder) return Reference_Type is\n    begin\n-      Reference (Ref.Control.Container.Reference);\n-      Container.Busy := Container.Busy + 1;\n-      return Ref;\n+      if Container.Reference = null then\n+         raise Constraint_Error with \"container is empty\";\n+\n+      elsif Container.Busy = 0\n+        and then not System.Atomic_Counters.Is_One\n+                       (Container.Reference.Counter)\n+      then\n+         --  Container is not locked and internal shared object is used by\n+         --  other container, create copy of both internal shared object and\n+         --  element.\n+\n+         Container.Reference :=\n+            new Shared_Holder'\n+              (Counter => <>,\n+               Element => new Element_Type'(Container.Reference.Element.all));\n+      end if;\n+\n+      declare\n+         Ref : constant Reference_Type :=\n+                 (Element => Container.Reference.Element.all'Access,\n+                  Control => (Controlled with Container'Unrestricted_Access));\n+      begin\n+         Reference (Ref.Control.Container.Reference);\n+         Ref.Control.Container.Busy := Ref.Control.Container.Busy + 1;\n+         return Ref;\n+      end;\n    end Reference;\n \n    ---------------------\n@@ -387,6 +461,19 @@ package body Ada.Containers.Indefinite_Holders is\n    begin\n       if Container.Reference = null then\n          raise Constraint_Error with \"container is empty\";\n+\n+      elsif Container.Busy = 0\n+        and then not System.Atomic_Counters.Is_One\n+                       (Container.Reference.Counter)\n+      then\n+         --  Container is not locked and internal shared object is used by\n+         --  other container, create copy of both internal shared object and\n+         --  element.\n+\n+         Container'Unrestricted_Access.Reference :=\n+            new Shared_Holder'\n+              (Counter => <>,\n+               Element => new Element_Type'(Container.Reference.Element.all));\n       end if;\n \n       B := B + 1;"}, {"sha": "7b97e25ccbe269539bd82de6b119996827425c9b", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 191, "deletions": 201, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "patch": "@@ -11390,6 +11390,145 @@ package body Exp_Ch4 is\n       Adjust_Result_Type (N, Typ);\n    end Expand_Short_Circuit_Operator;\n \n+   -----------------------\n+   -- Find_Hook_Context --\n+   -----------------------\n+\n+   function Find_Hook_Context (N : Node_Id) return Node_Id is\n+      Par : Node_Id;\n+      Top : Node_Id;\n+\n+      Wrapped_Node : Node_Id;\n+      --  Note: if we are in a transient scope, we want to reuse it as\n+      --  the context for actions insertion, if possible. But if N is itself\n+      --  part of the stored actions for the current transient scope,\n+      --  then we need to insert at the appropriate (inner) location in\n+      --  the not as an action on Node_To_Be_Wrapped.\n+\n+      In_Cond_Expr : constant Boolean := Within_Case_Or_If_Expression (N);\n+\n+   begin\n+      --  When the node is inside a case/if expression, the lifetime of any\n+      --  temporary controlled object is extended. Find a suitable insertion\n+      --  node by locating the topmost case or if expressions.\n+\n+      if In_Cond_Expr then\n+         Par := N;\n+         Top := N;\n+         while Present (Par) loop\n+            if Nkind_In (Original_Node (Par), N_Case_Expression,\n+                                              N_If_Expression)\n+            then\n+               Top := Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         --  The topmost case or if expression is now recovered, but it may\n+         --  still not be the correct place to add generated code. Climb to\n+         --  find a parent that is part of a declarative or statement list,\n+         --  and is not a list of actuals in a call.\n+\n+         Par := Top;\n+         while Present (Par) loop\n+            if Is_List_Member (Par)\n+              and then not Nkind_In (Par, N_Component_Association,\n+                                          N_Discriminant_Association,\n+                                          N_Parameter_Association,\n+                                          N_Pragma_Argument_Association)\n+              and then not Nkind_In\n+                             (Parent (Par), N_Function_Call,\n+                                            N_Procedure_Call_Statement,\n+                                            N_Entry_Call_Statement)\n+\n+            then\n+               return Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return Par;\n+\n+      else\n+         Par := N;\n+         while Present (Par) loop\n+\n+            --  Keep climbing past various operators\n+\n+            if Nkind (Parent (Par)) in N_Op\n+              or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n+            then\n+               Par := Parent (Par);\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         Top := Par;\n+\n+         --  The node may be located in a pragma in which case return the\n+         --  pragma itself:\n+\n+         --    pragma Precondition (... and then Ctrl_Func_Call ...);\n+\n+         --  Similar case occurs when the node is related to an object\n+         --  declaration or assignment:\n+\n+         --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n+\n+         --  Another case to consider is when the node is part of a return\n+         --  statement:\n+\n+         --    return ... and then Ctrl_Func_Call ...;\n+\n+         --  Another case is when the node acts as a formal in a procedure\n+         --  call statement:\n+\n+         --    Proc (... and then Ctrl_Func_Call ...);\n+\n+         if Scope_Is_Transient then\n+            Wrapped_Node := Node_To_Be_Wrapped;\n+         else\n+            Wrapped_Node := Empty;\n+         end if;\n+\n+         while Present (Par) loop\n+            if Par = Wrapped_Node\n+              or else Nkind_In (Par, N_Assignment_Statement,\n+                                     N_Object_Declaration,\n+                                     N_Pragma,\n+                                     N_Procedure_Call_Statement,\n+                                     N_Simple_Return_Statement)\n+            then\n+               return Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         --  Return the topmost short circuit operator\n+\n+         return Top;\n+      end if;\n+   end Find_Hook_Context;\n+\n    -------------------------------------\n    -- Fixup_Universal_Fixed_Operation --\n    -------------------------------------\n@@ -12548,8 +12687,19 @@ package body Exp_Ch4 is\n      (Decl     : Node_Id;\n       Rel_Node : Node_Id)\n    is\n-      Hook_Context         : Node_Id;\n-      --  Node on which to insert the hook pointer (as an action)\n+      Loc       : constant Source_Ptr := Sloc (Decl);\n+      Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n+      Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n+      Desig_Typ : Entity_Id;\n+      Expr      : Node_Id;\n+      Fin_Stmts : List_Id;\n+      Ptr_Id    : Entity_Id;\n+      Temp_Id   : Entity_Id;\n+      Temp_Ins  : Node_Id;\n+\n+      Hook_Context         : constant Node_Id := Find_Hook_Context (Rel_Node);\n+      --  Node on which to insert the hook pointer (as an action): the\n+      --  innermost enclosing non-transient scope.\n \n       Finalization_Context : Node_Id;\n       --  Node after which to insert finalization actions\n@@ -12558,215 +12708,55 @@ package body Exp_Ch4 is\n       --  If False, call to finalizer includes a test of whether the\n       --  hook pointer is null.\n \n-      procedure Find_Enclosing_Contexts (N : Node_Id);\n-      --  Find the logical context where N appears, and initialize\n-      --  Hook_Context and Finalization_Context accordingly. Also\n-      --  sets Finalize_Always.\n-\n-      -----------------------------\n-      -- Find_Enclosing_Contexts --\n-      -----------------------------\n-\n-      procedure Find_Enclosing_Contexts (N : Node_Id) is\n-         Par : Node_Id;\n-         Top : Node_Id;\n-\n-         Wrapped_Node : Node_Id;\n-         --  Note: if we are in a transient scope, we want to reuse it as\n-         --  the context for actions insertion, if possible. But if N is itself\n-         --  part of the stored actions for the current transient scope,\n-         --  then we need to insert at the appropriate (inner) location in\n-         --  the not as an action on Node_To_Be_Wrapped.\n-\n-         In_Cond_Expr : constant Boolean := Within_Case_Or_If_Expression (N);\n-\n-      begin\n-         --  When the node is inside a case/if expression, the lifetime of any\n-         --  temporary controlled object is extended. Find a suitable insertion\n-         --  node by locating the topmost case or if expressions.\n-\n-         if In_Cond_Expr then\n-            Par := N;\n-            Top := N;\n-            while Present (Par) loop\n-               if Nkind_In (Original_Node (Par), N_Case_Expression,\n-                                                 N_If_Expression)\n-               then\n-                  Top := Par;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            --  The topmost case or if expression is now recovered, but it may\n-            --  still not be the correct place to add generated code. Climb to\n-            --  find a parent that is part of a declarative or statement list,\n-            --  and is not a list of actuals in a call.\n-\n-            Par := Top;\n-            while Present (Par) loop\n-               if Is_List_Member (Par)\n-                 and then not Nkind_In (Par, N_Component_Association,\n-                                             N_Discriminant_Association,\n-                                             N_Parameter_Association,\n-                                             N_Pragma_Argument_Association)\n-                 and then not Nkind_In\n-                                (Parent (Par), N_Function_Call,\n-                                               N_Procedure_Call_Statement,\n-                                               N_Entry_Call_Statement)\n-\n-               then\n-                  Hook_Context := Par;\n-                  goto Hook_Context_Found;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            Hook_Context := Par;\n-            goto Hook_Context_Found;\n-\n-         else\n-            Par := N;\n-            while Present (Par) loop\n-\n-               --  Keep climbing past various operators\n-\n-               if Nkind (Parent (Par)) in N_Op\n-                 or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n-               then\n-                  Par := Parent (Par);\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            Top := Par;\n-\n-            --  The node may be located in a pragma in which case return the\n-            --  pragma itself:\n-\n-            --    pragma Precondition (... and then Ctrl_Func_Call ...);\n-\n-            --  Similar case occurs when the node is related to an object\n-            --  declaration or assignment:\n-\n-            --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n-\n-            --  Another case to consider is when the node is part of a return\n-            --  statement:\n-\n-            --    return ... and then Ctrl_Func_Call ...;\n-\n-            --  Another case is when the node acts as a formal in a procedure\n-            --  call statement:\n-\n-            --    Proc (... and then Ctrl_Func_Call ...);\n-\n-            if Scope_Is_Transient then\n-               Wrapped_Node := Node_To_Be_Wrapped;\n-            else\n-               Wrapped_Node := Empty;\n-            end if;\n-\n-            while Present (Par) loop\n-               if Par = Wrapped_Node\n-                 or else Nkind_In (Par, N_Assignment_Statement,\n-                                        N_Object_Declaration,\n-                                        N_Pragma,\n-                                        N_Procedure_Call_Statement,\n-                                        N_Simple_Return_Statement)\n-               then\n-                  Hook_Context := Par;\n-                  goto Hook_Context_Found;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            --  Return the topmost short circuit operator\n-\n-            Hook_Context := Top;\n-         end if;\n-\n-      <<Hook_Context_Found>>\n-\n-         --  Special case for Boolean EWAs: capture expression in a temporary,\n-         --  whose declaration will serve as the context around which to insert\n-         --  finalization code. The finalization thus remains local to the\n-         --  specific condition being evaluated.\n+      In_Cond_Expr : constant Boolean :=\n+                       Within_Case_Or_If_Expression (Rel_Node);\n \n-         if Is_Boolean_Type (Etype (N)) then\n-\n-            --  In this case, the finalization context is chosen so that\n-            --  we know at finalization point that the hook pointer is\n-            --  never null, so no need for a test, we can call the finalizer\n-            --  unconditionally, except in the case where the object is\n-            --  created in a specific branch of a conditional expression.\n+   begin\n+      --  Step 0: determine where to attach finalization actions in the tree\n \n-            Finalize_Always :=\n-               not (In_Cond_Expr\n-                     or else\n-                       Nkind_In (Original_Node (N), N_Case_Expression,\n-                                                    N_If_Expression));\n+      --  Special case for Boolean EWAs: capture expression in a temporary,\n+      --  whose declaration will serve as the context around which to insert\n+      --  finalization code. The finalization thus remains local to the\n+      --  specific condition being evaluated.\n \n-            declare\n-               Loc  : constant Source_Ptr := Sloc (N);\n-               Temp : constant Entity_Id := Make_Temporary (Loc, 'E', N);\n-\n-            begin\n-               Append_To (Actions (N),\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Constant_Present    => True,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Etype (N), Loc),\n-                   Expression          => Expression (N)));\n-               Finalization_Context := Last (Actions (N));\n+      if Is_Boolean_Type (Etype (Rel_Node)) then\n \n-               Analyze (Last (Actions (N)));\n+         --  In this case, the finalization context is chosen so that\n+         --  we know at finalization point that the hook pointer is\n+         --  never null, so no need for a test, we can call the finalizer\n+         --  unconditionally, except in the case where the object is\n+         --  created in a specific branch of a conditional expression.\n \n-               Set_Expression (N, New_Occurrence_Of (Temp, Loc));\n-               Analyze (Expression (N));\n-            end;\n+         Finalize_Always :=\n+            not (In_Cond_Expr\n+                  or else\n+                    Nkind_In (Original_Node (Rel_Node), N_Case_Expression,\n+                                                        N_If_Expression));\n \n-         else\n-            Finalize_Always := False;\n-            Finalization_Context := Hook_Context;\n-         end if;\n-      end Find_Enclosing_Contexts;\n+         declare\n+            Loc  : constant Source_Ptr := Sloc (Rel_Node);\n+            Temp : constant Entity_Id := Make_Temporary (Loc, 'E', Rel_Node);\n \n-      --  Local variables\n+         begin\n+            Append_To (Actions (Rel_Node),\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Etype (Rel_Node), Loc),\n+                Expression          => Expression (Rel_Node)));\n+            Finalization_Context := Last (Actions (Rel_Node));\n \n-      Loc       : constant Source_Ptr := Sloc (Decl);\n-      Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n-      Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n-      Desig_Typ : Entity_Id;\n-      Expr      : Node_Id;\n-      Fin_Stmts : List_Id;\n-      Ptr_Id    : Entity_Id;\n-      Temp_Id   : Entity_Id;\n-      Temp_Ins  : Node_Id;\n+            Analyze (Last (Actions (Rel_Node)));\n \n-   --  Start of processing for Process_Transient_Object\n+            Set_Expression (Rel_Node, New_Occurrence_Of (Temp, Loc));\n+            Analyze (Expression (Rel_Node));\n+         end;\n \n-   begin\n-      Find_Enclosing_Contexts (Rel_Node);\n+      else\n+         Finalize_Always := False;\n+         Finalization_Context := Hook_Context;\n+      end if;\n \n       --  Step 1: Create the access type which provides a reference to the\n       --  transient controlled object."}, {"sha": "c7686f746ed42f3c2f3f8be4f2dec46ee0631000", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,4 +103,11 @@ package Exp_Ch4 is\n    --  have special circuitry in Expand_N_Type_Conversion to promote both of\n    --  the operands to type Integer.\n \n+   function Find_Hook_Context (N : Node_Id) return Node_Id;\n+   --  Determine a suitable node on which to attach actions related to N\n+   --  that need to be elaborated unconditionally (i.e. in general the topmost\n+   --  expression of which N is a subexpression, which may or may not be\n+   --  evaluated, for example if N is the right operand of a short circuit\n+   --  operator).\n+\n end Exp_Ch4;"}, {"sha": "c8f2943d18ba8e547161388dc9812398019dc490", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8942b30c7c1a6500f56bdf93ba96c54da370ba8c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "patch": "@@ -29,6 +29,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n@@ -1151,7 +1152,6 @@ package body Exp_Ch9 is\n       then\n          declare\n             Master_Decl : Node_Id;\n-\n          begin\n             Set_Has_Master_Entity (Master_Scope);\n \n@@ -1169,7 +1169,7 @@ package body Exp_Ch9 is\n                   Make_Explicit_Dereference (Loc,\n                     New_Occurrence_Of (RTE (RE_Current_Master), Loc)));\n \n-            Insert_Action (Related_Node, Master_Decl);\n+            Insert_Action (Find_Hook_Context (Related_Node), Master_Decl);\n             Analyze (Master_Decl);\n \n             --  Mark the containing scope as a task master. Masters associated"}]}