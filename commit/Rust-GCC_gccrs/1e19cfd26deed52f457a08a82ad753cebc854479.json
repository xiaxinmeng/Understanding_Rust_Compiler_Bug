{"sha": "1e19cfd26deed52f457a08a82ad753cebc854479", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxOWNmZDI2ZGVlZDUyZjQ1N2EwOGE4MmFkNzUzY2ViYzg1NDQ3OQ==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-06-06T15:09:20Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-06-06T15:09:20Z"}, "message": "natFilePosix.cc (getCanonicalPath): Rewritten.\n\n\n\t* java/io/natFilePosix.cc (getCanonicalPath): Rewritten.\n\t* configure.ac: Remove realpath check and add checks for\n\tlstat and readlink.\n\t* configure: Rebuilt.\n\t* include/config.h.in: Likewise.\n\t* java/io/File.java: Javadoc fix.\n\nFrom-SVN: r114434", "tree": {"sha": "1bf59618bf924a1b5a39b4a3404428ec2cebfef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf59618bf924a1b5a39b4a3404428ec2cebfef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e19cfd26deed52f457a08a82ad753cebc854479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e19cfd26deed52f457a08a82ad753cebc854479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e19cfd26deed52f457a08a82ad753cebc854479", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e19cfd26deed52f457a08a82ad753cebc854479/comments", "author": null, "committer": null, "parents": [{"sha": "406af897d0e3ea07a1baf80b60c2077d25e5420a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406af897d0e3ea07a1baf80b60c2077d25e5420a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406af897d0e3ea07a1baf80b60c2077d25e5420a"}], "stats": {"total": 241, "additions": 163, "deletions": 78}, "files": [{"sha": "76031d52572ee525471477302e686fbf1f457805", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -1,3 +1,12 @@\n+2006-06-06  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/io/natFilePosix.cc (getCanonicalPath): Rewritten.\n+\t* configure.ac: Remove realpath check and add checks for\n+\tlstat and readlink.\n+\t* configure: Rebuilt.\n+\t* include/config.h.in: Likewise.\n+\t* java/io/File.java: Javadoc fix.\n+\n 2006-06-05  Andreas Schwab  <schwab@suse.de>\n \n \tPR libgcj/27860"}, {"sha": "7b3f0f164f5c0b768ba19a9aa4f5edbcd786dde5", "filename": "libjava/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -10396,7 +10396,7 @@ else\n \n for ac_func in strerror ioctl select fstat open fsync sleep opendir \\\n                    gmtime_r localtime_r readdir_r getpwuid_r getcwd \\\n-\t\t   access stat mkdir rename rmdir unlink realpath utime chmod \\\n+\t\t   access stat lstat mkdir rename rmdir unlink utime chmod readlink \\\n \t\t   nl_langinfo setlocale \\\n \t\t   inet_pton uname inet_ntoa \\\n \t\t   fork execvp pipe sigaction ftruncate mmap"}, {"sha": "a02e25f3ab1dbf593ea0afe5aab237a5c1791447", "filename": "libjava/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -897,7 +897,7 @@ if test \"x${with_newlib}\" = \"xyes\"; then\n else\n    AC_CHECK_FUNCS([strerror ioctl select fstat open fsync sleep opendir \\\n                    gmtime_r localtime_r readdir_r getpwuid_r getcwd \\\n-\t\t   access stat mkdir rename rmdir unlink realpath utime chmod \\\n+\t\t   access stat lstat mkdir rename rmdir unlink utime chmod readlink \\\n \t\t   nl_langinfo setlocale \\\n \t\t   inet_pton uname inet_ntoa \\\n \t\t   fork execvp pipe sigaction ftruncate mmap])"}, {"sha": "2ef617103b150108146046e17647d15df53a8ae7", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -169,6 +169,9 @@\n /* Define to 1 if you have the `localtime_r' function. */\n #undef HAVE_LOCALTIME_R\n \n+/* Define to 1 if you have the `lstat' function. */\n+#undef HAVE_LSTAT\n+\n /* Define to 1 if you have the `memcpy' function. */\n #undef HAVE_MEMCPY\n \n@@ -226,8 +229,8 @@\n /* Define to 1 if you have the `readdir_r' function. */\n #undef HAVE_READDIR_R\n \n-/* Define to 1 if you have the `realpath' function. */\n-#undef HAVE_REALPATH\n+/* Define to 1 if you have the `readlink' function. */\n+#undef HAVE_READLINK\n \n /* Define to 1 if you have the `rename' function. */\n #undef HAVE_RENAME"}, {"sha": "55b7b08b9318e058d1fddc1b78f32aa83cc8a170", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -508,9 +508,9 @@ public File getAbsoluteFile()\n   /**\n    * This method returns a canonical representation of the pathname of\n    * this file.  The actual form of the canonical representation is\n-   * different.  On the GNU system, the canonical form differs from the\n-   * absolute form in that all relative file references to \".\" and \"..\"\n-   * are resolved and removed.\n+   * system-dependent.  On the GNU system, conversion to canonical\n+   * form involves the removal of redundant separators, references to\n+   * \".\" and \"..\", and symbolic links.\n    * <p>\n    * Note that this method, unlike the other methods which return path\n    * names, can throw an IOException.  This is because native method "}, {"sha": "356fc2e553363e8b2093e7b77a23b1ddd3f084f1", "filename": "libjava/java/io/natFilePosix.cc", "status": "modified", "additions": 144, "deletions": 71, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fjava%2Fio%2FnatFilePosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e19cfd26deed52f457a08a82ad753cebc854479/libjava%2Fjava%2Fio%2FnatFilePosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFilePosix.cc?ref=1e19cfd26deed52f457a08a82ad753cebc854479", "patch": "@@ -101,94 +101,167 @@ java::io::File::attr (jint query)\n #endif\n }\n \n+// These two methods are used to maintain dynamically allocated\n+// buffers for getCanonicalPath without the overhead of calling\n+// realloc every time a buffer is modified.  Buffers are sized\n+// at the smallest multiple of CHUNKSIZ that is greater than or\n+// equal to the desired length.  The default CHUNKSIZ is 256,\n+// longer than most paths, so in most cases a getCanonicalPath\n+// will require only one malloc per buffer.\n+\n+#define CHUNKLOG 8\n+#define CHUNKSIZ (1 << CHUNKLOG)\n+\n+static int\n+nextChunkSize (int size)\n+{\n+  return ((size >> CHUNKLOG) + ((size & (CHUNKSIZ - 1)) ? 1 : 0)) << CHUNKLOG;\n+}\n+\n+static char *\n+maybeGrowBuf (char *buf, int *size, int required)\n+{\n+  if (required > *size)\n+    {\n+      *size = nextChunkSize (required);\n+      buf = (char *) _Jv_Realloc (buf, *size);\n+    }\n+  return buf;\n+}\n+\n+// Return a canonical representation of the pathname of this file.  On\n+// the GNU system this involves the removal of redundant separators,\n+// references to \".\" and \"..\", and symbolic links.\n+//\n+// The conversion proceeds on a component-by-component basis: symbolic\n+// links and references to \"..\"  are resolved as and when they occur.\n+// This means that if \"/foo/bar\" is a symbolic link to \"/baz\" then the\n+// canonical form of \"/foo/bar/..\" is \"/\" and not \"/foo\".\n+//\n+// In order to mimic the behaviour of proprietary JVMs, non-existant\n+// path components are allowed (a departure from the normal GNU system\n+// convention).  This means that if \"/foo/bar\" is a symbolic link to\n+// \"/baz\", the canonical form of \"/non-existant-directory/../foo/bar\"\n+// is \"/baz\".\n+\n jstring\n java::io::File::getCanonicalPath (void)\n {\n-  // We use `+2' here because we might need to use `.' for our special\n-  // case.\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (path) + 2);\n-  char buf2[MAXPATHLEN];\n-  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  jstring path = getAbsolutePath ();\n \n-  // Special case: treat \"\" the same as \".\".\n-  if (total == 0)\n-    buf[total++] = '.';\n+  int len = JvGetStringUTFLength (path);\n+  int srcl = nextChunkSize (len + 1);\n+  char *src = (char *) _Jv_Malloc (srcl);\n+  JvGetStringUTFRegion (path, 0, path->length(), src);\n+  src[len] = '\\0';\n+  int srci = 1;\n \n-  buf[total] = '\\0';\n+  int dstl = nextChunkSize (2);  \n+  char *dst = (char *) _Jv_Malloc (dstl);\n+  dst[0] = '/';\n+  int dsti = 1;\n+\n+  bool fschecks = true;\n \n-#ifdef HAVE_REALPATH\n-  if (realpath (buf, buf2) == NULL)\n+  while (src[srci] != '\\0')\n     {\n-      // If realpath failed, we have to come up with a canonical path\n-      // anyway.  We do this with purely textual manipulation.\n-      // FIXME: this isn't perfect.  You can construct a case where\n-      // we get a different answer from the JDK:\n-      // mkdir -p /tmp/a/b/c\n-      // ln -s /tmp/a/b /tmp/a/z\n-      // ... getCanonicalPath(\"/tmp/a/z/c/nosuchfile\")\n-      // We will give /tmp/a/z/c/nosuchfile, while the JDK will\n-      // give /tmp/a/b/c/nosuchfile.\n-      int out_idx;\n-      if (buf[0] != '/')\n+      // Skip slashes.\n+      while (src[srci] == '/')\n+\tsrci++;\n+      int tmpi = srci;\n+      // Find next slash.\n+      while (src[srci] != '/' && src[srci] != '\\0')\n+\tsrci++;\n+      if (srci == tmpi)\n+\t// We hit the end.\n+\tbreak;\n+      len = srci - tmpi;\n+\n+      // Handle \".\" and \"..\".\n+      if (len == 1 && src[tmpi] == '.')\n+\tcontinue;\n+      if (len == 2 && src[tmpi] == '.' && src[tmpi + 1] == '.')\n \t{\n-\t  // Not absolute, so start with current directory.\n-\t  if (getcwd (buf2, sizeof (buf2)) == NULL)\n-\t    throw new IOException ();\n-\t  out_idx = strlen (buf2);\n+\t  while (dsti > 1 && dst[dsti - 1] != '/')\n+\t    dsti--;\n+\t  if (dsti != 1)\n+\t    dsti--;\n+\t  // Reenable filesystem checking if disabled, as we might\n+\t  // have reversed over whatever caused the problem before.\n+\t  // At least one proprietary JVM has inconsistencies because\n+\t  // it does not do this.\n+\t  fschecks = true;\n+\t  continue;\n \t}\n-      else\n-\t{\n-\t  buf2[0] = '/';\n-\t  out_idx = 1;\n-\t} \n-      int in_idx = 0;\n-      while (buf[in_idx] != '\\0')\n+\n+      // Handle real path components.\n+      dst = maybeGrowBuf (dst, &dstl, dsti + (dsti > 1 ? 1 : 0) + len + 1);\n+      int dsti_save = dsti;\n+      if (dsti > 1)\n+\tdst[dsti++] = '/';\n+      strncpy (&dst[dsti], &src[tmpi], len);\n+      dsti += len;\n+      if (fschecks == false)\n+\tcontinue;\n+\n+#if defined (HAVE_LSTAT) && defined (HAVE_READLINK)\n+      struct stat sb;\n+      dst[dsti] = '\\0';\n+      if (::lstat (dst, &sb) == 0)\n \t{\n-\t  // Skip '/'s.\n-\t  while (buf[in_idx] == '/')\n-\t    ++in_idx;\n-\t  int elt_start = in_idx;\n-\t  // Find next '/' or end of path.\n-\t  while (buf[in_idx] != '\\0' && buf[in_idx] != '/')\n-\t    ++in_idx;\n-\t  if (in_idx == elt_start)\n-\t    {\n-\t      // An empty component means we've reached the end.\n-\t      break;\n-\t    }\n-\t  int len = in_idx - elt_start;\n-\t  if (len == 1 && buf[in_idx] == '.')\n-\t    continue;\n-\t  if (len == 2 && buf[in_idx] == '.' && buf[in_idx + 1] == '.')\n-\t    {\n-\t      // Found \"..\" component, lop off last part from existing\n-\t      // buffer.\n-\t      --out_idx;\n-\t      while (out_idx > 0 && buf2[out_idx] != '/')\n-\t\t--out_idx;\n-\t      // Can't go up past \"/\".\n-\t      if (out_idx == 0)\n-\t\t++out_idx;\n-\t    }\n-\t  else\n+\t  if (S_ISLNK (sb.st_mode))\n \t    {\n-\t      // Append a real path component to the output.\n-\t      if (out_idx > 1)\n-\t\tbuf2[out_idx++] = '/';\n-\t      strncpy (&buf2[out_idx], &buf[elt_start], len);\n-\t      out_idx += len;\n+\t      int tmpl = CHUNKSIZ;\n+\t      char *tmp = (char *) _Jv_Malloc (tmpl);\n+\n+\t      while (1)\n+\t\t{\n+\t\t  tmpi = ::readlink (dst, tmp, tmpl);\n+\t\t  if (tmpi < 1)\n+\t\t    {\n+\t\t      _Jv_Free (src);\n+\t\t      _Jv_Free (dst);\n+\t\t      _Jv_Free (tmp);\n+\t\t      throw new IOException (\n+\t\t\tJvNewStringLatin1 (\"readlink failed\"));\n+\t\t    }\n+\t\t  if (tmpi < tmpl)\n+\t\t    break;\n+\t\t  tmpl += CHUNKSIZ;\n+\t\t  tmp = (char *) _Jv_Realloc (tmp, tmpl);\n+\t\t}\n+\n+\t      // Prepend the link's path to src.\n+\t      tmp = maybeGrowBuf (tmp, &tmpl, tmpi + strlen (&src[srci]) + 1);\n+\t      strcpy(&tmp[tmpi], &src[srci]);\n+\t      _Jv_Free (src);\n+\t      src = tmp;\n+\t      srcl = tmpl;\n+\t      srci = 0;\n+\n+\t      // Either replace or append dst depending on whether the\n+\t      // link is relative or absolute.\n+\t      dsti = src[0] == '/' ? 1 : dsti_save;\n \t    }\n \t}\n-\n-      buf2[out_idx] = '\\0';\n+      else\n+\t{\n+\t  // Something doesn't exist, or we don't have permission to\n+\t  // read it, or a previous path component is a directory, or\n+\t  // a symlink is looped.  Whatever, we can't check the\n+\t  // filesystem any more.\n+\t  fschecks = false;\n+\t}\n+#endif // HAVE_LSTAT && HAVE_READLINK\n     }\n+  dst[dsti] = '\\0';\n \n   // FIXME: what encoding to assume for file names?  This affects many\n   // calls.\n-  return JvNewStringUTF (buf2);\n-#else\n-  return JvNewStringUTF (buf);\n-#endif\n+  path = JvNewStringUTF (dst);\n+  _Jv_Free (src);\n+  _Jv_Free (dst);\n+  return path;\n }\n \n jboolean"}]}