{"sha": "efe7d0213ad67301f5422af882b13c64ebc62b50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlN2QwMjEzYWQ2NzMwMWY1NDIyYWY4ODJiMTNjNjRlYmM2MmI1MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T18:39:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-12T18:39:59Z"}, "message": "(TPU makefile.in): Reorganize and reformat code.\n\nMake generated .opt files have more consistent format (all comma\nseparated, excess whitespace eliminated);\n(additional_compiler): New routine.\n(process_makefile): Use it to handle cc1plus via cp/Make-lang.in.\n\nFrom-SVN: r9655", "tree": {"sha": "36d2894195758c6e7cb221f6f594639a50f37f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d2894195758c6e7cb221f6f594639a50f37f90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efe7d0213ad67301f5422af882b13c64ebc62b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe7d0213ad67301f5422af882b13c64ebc62b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe7d0213ad67301f5422af882b13c64ebc62b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe7d0213ad67301f5422af882b13c64ebc62b50/comments", "author": null, "committer": null, "parents": [{"sha": "a3c1ce7bb9c09be0ba87e33d8868ee95112dca3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3c1ce7bb9c09be0ba87e33d8868ee95112dca3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3c1ce7bb9c09be0ba87e33d8868ee95112dca3b"}], "stats": {"total": 458, "additions": 257, "deletions": 201}, "files": [{"sha": "4ff93779e0cc69c5f6987439aef753ad32bfd589", "filename": "gcc/vmsconfig.com", "status": "modified", "additions": 257, "deletions": 201, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe7d0213ad67301f5422af882b13c64ebc62b50/gcc%2Fvmsconfig.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe7d0213ad67301f5422af882b13c64ebc62b50/gcc%2Fvmsconfig.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsconfig.com?ref=efe7d0213ad67301f5422af882b13c64ebc62b50", "patch": "@@ -120,216 +120,272 @@ $if f$search(\"[.cp]Makefile.in\").eqs.\"\" .and. f$search(\"[.cp]$M$akefile.in\").nes\n $!\n $!\n $echo \"Now processing Makefile.in to generate linker option files.\"\n-$edit/tpu/nojournal/nosection/nodisplay/command=sys$input\n-   PROCEDURE generate_option_file (TAG_NAME, outfile)\n-        position (beginning_of (newbuffer));\n-        recursive_fetch_tag (TAG_NAME);\n-!\n-! Now fix up a few things in the output buffer\n-!\n-\tpat_replace (\"bytecode \",\" \");\n-\tpat_replace (\".o \",\",\");\n-\tpat_replace (\".o\",\"\");  !appear at end of lines.\n-!\n-! Remove trailing commas, if present.\n-!\n-\tposition (beginning_of (newbuffer));\n-\tLOOP\n-\t  range1 := search_quietly(\",\" & ((SPAN(\" \") & LINE_END) | LINE_END),\n-\t\t\t\t   FORWARD, EXACT);\n-\t  exitif range1 = 0;\n-\t  position (beginning_of (range1));\n-\t  erase(range1);\n-\t  split_line;\t\t\n-\t  ENDLOOP;\n-! get rid of leading spaces on lines.\n-        position (beginning_of (current_buffer)) ;\n-\tLOOP\n-          range1 := search_quietly ( LINE_BEGIN & \" \", FORWARD, EXACT) ;\n-\t  EXITIF range1 = 0;\n-\t  position (end_of (range1));\n-\t  erase_character(1);\n-\tENDLOOP;       \n-!\n-! Now write the output file.\n-!\n-\tSET(OUTPUT_FILE, newbuffer, outfile);\n-      write_file (newbuffer);\n-      erase (newbuffer);\n-   ENDPROCEDURE;\n+$edit/TPU/noJournal/noSection/noDisplay/Command=sys$input: Makefile.in\n+!!\n+VARIABLE makefile_buf, opt_file_buf, complist_buf, extra_compilers; ! Globals.\n \n-!\n-! Looks up a tag, copies it to newbuffer, and then translates any $(...)\n-! definitions that appear.  The translation is put at the current point.\n-!\n-   PROCEDURE recursive_fetch_tag (TAG_N);\n-   fetch_tag (TAG_N);\n-!\n-! substitute any  makefile symbols $(...)\n-!\n-        position (beginning_of (current_buffer)) ;\n-\tLOOP\n-\t  range1 := search_quietly (\"$(\" &  \n+!!\n+PROCEDURE process_makefile( )\n+  !\n+  ! Intepret Makefile.in and subsidiary Make-lang.in templates.\n+  !\n+  LOCAL range1, cmark, makefilename;\n+\n+  makefilename\t  := GET_INFO (COMMAND_LINE, 'FILE_NAME'); ! \"Makefile.in\"\n+  makefile_buf\t  := CREATE_BUFFER (\"makefile\", makefilename);\n+  opt_file_buf\t  := CREATE_BUFFER (\"opt_file\");\n+  complist_buf\t  := CREATE_BUFFER (\"complist\");\n+  extra_compilers := CREATE_ARRAY;\n+  !\n+  SET (NO_WRITE, makefile_buf, ON);\t! Used as workspace; don't save it.\n+  SET (OUTPUT_FILE, complist_buf, \"compilers.list\");\n+  !\n+  ! Collect a list of supported compilers (``COMPILERS=xxx'' macro).\n+  !\n+  identify_compilers ();\n+  !\n+  ! Plus other known compilers described by Make-lang.in makefile fragments.\n+  ! Add new entries as needed; args are (target name, subdirectory name).\n+  !\n+  additional_compiler (\"cc1plus\", \"cp\");\n+  !\n+  WRITE_FILE (complist_buf);\t\t! Now save \"compilers.list\".\n+  !\n+  ! Add to this list, as required.  The file \"Makefile.in\" is searched for\n+  ! a tag that looks like \"LINE_BEGIN + 'tag + (optional space) + \"=\"\".\n+  ! The contents are assumed to be a list of object files, and from this\n+  ! list a VMS linker options file is generated.\n+  !\n+  generate_option_file (\"OBJS\",      \"=\", \"independent.opt\");\n+  generate_option_file (\"LIB2FUNCS\", \"=\", \"libgcc2.list\");\n+  generate_option_file (\"BC_ALL\",    \"=\", \"bc_all.opt\");\n+  generate_option_file (\"BI_OBJ\",    \"=\", \"bi_all.opt\");\n+  !\n+  ! Now change OBJS in the Makefile, so each language specific options file\n+  ! does not pick up all of the language independent files.\n+  !\n+  POSITION (BEGINNING_OF (makefile_buf));\n+  COPY_TEXT (\"OBJS=\");\t! New copy with empty value, seen before real OBJS.\n+  SPLIT_LINE;\n+  !\n+  ! Lastly, process each compiler-specific object dependency list.\n+  !\n+  POSITION (BEGINNING_OF (complist_buf));\n+  LOOP\n+    cmark := MARK (NONE);\n+    EXITIF (cmark = END_OF (complist_buf));\n+    ! The current line contains the name of a compiler target, such as \"cc1\".\n+    MESSAGE (CURRENT_LINE);\t! Give some interactive feedback.\n+    generate_option_file (CURRENT_LINE, \":\", CURRENT_LINE + \"-objs.opt\");\n+    POSITION (cmark);\n+    MOVE_VERTICAL (1);\t\t! Go to the next line.\n+  ENDLOOP;\n+ENDPROCEDURE; !process_makefile\n+!!\n+\n+PROCEDURE identify_compilers( )\n+  !\n+  ! Retrieve the list of supported compilers from Makefile.in, and put them\n+  ! into file \"compilers.list\", one per line, for subsequent access from DCL.\n+  !\n+  LOCAL range1;\n+\n+  ! Strip most comments from the makefile, to speed up subsequent processing.\n+  POSITION (BEGINNING_OF (makefile_buf));\n+  pat_replace (LINE_BEGIN & \"#\" & REMAIN & LINE_END, );\n+!#  ! Convert directory references to VMS syntax (actually, just strip it).\n+!#  pat_replace (\" $(srcdir)/\", \" \");\n+  ! Look up the ``COMPILERS=cc1 xyzzy'' Makefile macro and put\n+  ! its ``cc1 xyzzy'' value into the compilers buffer.\n+  POSITION (BEGINNING_OF (complist_buf));\n+!#--at some point we may want to add this--\n+!#  recursive_fetch_tag (\"CCCP\", \"=\");\t  ! Include the preprocessor.\n+!#  POSITION (END_OF (complist_buf));\n+  recursive_fetch_tag (\"COMPILERS\", \"=\");\n+  ! Convert all spaces into newlines, then remove any blank lines.\n+  pat_replace (SPAN(\" \"), LINE_END);\n+  pat_replace (LINE_BEGIN & LINE_END, );\n+ENDPROCEDURE; !identify_compilers\n+!!\n+\n+PROCEDURE additional_compiler( cname, subdir )\n+  !\n+  ! Load Make-lang.in for compiler CNAME from SUBDIR and append it to the\n+  ! end of Makefile.in's buffer.  Add CNAME to the \"compilers.list\" buffer.\n+  !\n+  ON_ERROR\n+    ! Don't abort if user removes the supporting subdirectory for a\n+    ! language she's not interested in.\n+    [TPU$_OPENIN]:\n+      MESSAGE (\"Cannot load \" + subdir + \"/Make-lang.in for \"\n+\t       + '\"' + cname + '\"' + \"; skipping it.\");\n+      RETURN;\n+  ENDON_ERROR;\n+\n+  POSITION (END_OF (makefile_buf));\n+  SPLIT_LINE;\t! Separate with a blank line.\n+  READ_FILE (\"[.\" + subdir + \"]Make-lang.in\");\t! Load Makefile fragment.\n+  ! Make sure that $(xxx_OTH_SRCS) expands to empty string by renaming $(it)\n+  pat_replace (\"_OTH_SRCS)\", \"_OTH_SRCS_dummy_)\");\n+  ! Convert subdirectory references into VMS syntax.\n+  pat_replace (\"$(srcdir)/\" + subdir + \"/\", \"[.\" + subdir + \"]\");\n+  ! Add this name to compilers.list.\n+  POSITION (END_OF (complist_buf));\n+  COPY_TEXT (cname);\n+  ! Make array entry indexed by compiler's file name; its value is arbitrary.\n+  extra_compilers{cname} := subdir;\n+ENDPROCEDURE; !additional_compiler\n+!!\n+\n+PROCEDURE generate_option_file( tag_name, punct, outfile_name )\n+  !\n+  ! Produce a file listing the names of particular object files, for use\n+  ! as input to the linker and also for use in finding source names by\n+  ! make-cc1.com.  Generally, any name suffix will be suppressed.\n+  !\n+  LOCAL range1, range2;\n+\n+  POSITION (BEGINNING_OF (opt_file_buf));\n+  recursive_fetch_tag (tag_name, punct);\n+  ! First fix up for subdirectory/Make-lang.in.\n+  IF (pat_replace (\"stamp-objlist\" & (SPAN(\" \")|LINE_END), \" \") > 0) THEN\n+    recursive_fetch_tag (\"stamp-objlist\", \":\");\n+  ENDIF;\n+  ! Now fix up a few things in the output buffer.\n+  pat_replace ((\"bytecode\"|\"Makefile\") & (SPAN(\" \")|LINE_END), \" \");\n+!#  FILL (CURRENT_BUFFER, \" \", 1, 80, 0);\t! Condense things a bit.\n+  pat_replace (\".\" & (\"o\"|\"c\"|\"h\"|\"y\") & ((SPAN(\" \")&LINE_END)|LINE_END), LINE_END);\n+  pat_replace (\".\" & (\"o\"|\"c\"|\"h\"|\"y\") & SPAN(\" \"), \",\");\n+!#  ! Remove trailing commas, if present.  {Above patterns preclude any such.}\n+!#  pat_replace (\",\" & ((SPAN(\" \")&LINE_END)|LINE_END), LINE_END);\n+  ! Get rid of spaces and blank lines.\n+  pat_replace (SPAN(\" \"), LINE_END);\n+  pat_replace (LINE_BEGIN & LINE_END, );\n+  ! Second fix up for subdirectory/Make-lang.in;\n+  ! avoid \"sticky defaults\" when linker processes the resulting options file.\n+  IF (extra_compilers{outfile_name - \"-objs.opt\"} <> TPU$K_UNSPECIFIED) THEN\n+    POSITION (BEGINNING_OF (opt_file_buf));\n+    range1 := CREATE_RANGE (MARK (NONE), END_OF (CURRENT_BUFFER), NONE);\n+    LOOP\n+      range2 := SEARCH_QUIETLY (LINE_BEGIN | \",\", FORWARD, EXACT, range1);\n+      EXITIF (range2 = 0);\n+      POSITION (BEGINNING_OF (range2));\n+      IF (CURRENT_CHARACTER = \",\") THEN  MOVE_HORIZONTAL (1); ENDIF;\n+      ! If it's not already \"[.subdir]name\", explicitly make it \"[]name\".\n+      IF (CURRENT_CHARACTER <> \"[\") THEN  COPY_TEXT (\"[]\"); ENDIF;\n+      MOVE_HORIZONTAL (1);\n+      MODIFY_RANGE (range1, MARK (NONE), END_OF (range1));\n+    ENDLOOP;\n+  ENDIF;\n+  ! Now write the output file.\n+  SET (OUTPUT_FILE, opt_file_buf, outfile_name);\n+  WRITE_FILE (opt_file_buf);\n+  ERASE (opt_file_buf);\t\t! Clear buffer out for next opt_file pass.\n+ENDPROCEDURE; !generate_option_file\n+!!\n+\n+PROCEDURE recursive_fetch_tag( tag_n, punct )\n+  !\n+  ! Look up TAG_N, copy it to OPT_FILE_BUF, and then translate any $(...)\n+  ! definitions that appear.  The translation is put at the current point.\n+  !\n+  LOCAL mark1, mark2, range1, tag_range, tag_string;\n+\n+  fetch_tag (tag_n, punct);\n+  ! Substitute any makefile symbols $(...).\n+  POSITION (BEGINNING_OF (CURRENT_BUFFER));\n+  LOOP\n+    range1 := SEARCH_QUIETLY (\"$(\" &\n       SPAN(\"abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ#~0123456789\")\n-\t\t\t\t    & \")\", FORWARD, EXACT) ;\n-\t  EXITIF range1 = 0;\n-\t  position (beginning_of (range1));\n-\t  move_horizontal(2);\n-\t  mark_1 := MARK (NONE);\n-\t  position (end_of (range1));\n-\t  move_horizontal(-1);\n-\t  mark_2 := MARK (NONE);\n-\t  tag_range := CREATE_RANGE(MARK_1, MARK_2, NONE);\n-\t  position (end_of (range1));\n-\t  tag_string := STR (tag_range);\n-\t  erase (range1);\n-\t  fetch_tag (LINE_BEGIN & tag_string & ((SPAN(\" \") & \"=\") | \"=\"));\n-          position (beginning_of (current_buffer)) ;\n-\tENDLOOP;       \n-   ENDPROCEDURE;\n+\t\t\t\t   & \")\", FORWARD, EXACT);\n+    EXITIF (range1 = 0);\n+    POSITION (BEGINNING_OF (range1));\n+    MOVE_HORIZONTAL (2);\t! Past opening \"$(\".\n+    mark1 := MARK (NONE);\n+    POSITION (END_OF (range1));\n+    MOVE_HORIZONTAL (-1);\t! In front of closing \")\".\n+    mark2 := MARK (NONE);\n+    tag_range := CREATE_RANGE (mark1, mark2, NONE);\n+    POSITION (END_OF (range1));\n+    tag_string := STR (tag_range);\n+    ERASE (range1);\n+    fetch_tag (tag_string, \"=\");\n+    POSITION (BEGINNING_OF (CURRENT_BUFFER));\n+  ENDLOOP;\n+ENDPROCEDURE; !recursive_fetch_tag\n+!!\n \n-!\n-! Looks up the translation of a tag, and inserts it at the current location\n-! in the buffer\n-!\n-   PROCEDURE fetch_tag (TAG_N);\n-      LOCAL mark1, mark2, mark3, range2;\n-      mark3 := MARK(NONE) ;\n-      position (beginning_of (mainbuffer)) ;\n-      range2 := search_quietly (TAG_N, FORWARD, EXACT) ;\n-      IF (range2 = 0) then \n-\tposition (mark3);\n-\treturn;\n-\tendif;\n-      position (end_of (range2)) ;\n-      MOVE_HORIZONTAL(1);\n-      mark1 := MARK(NONE) ;\n-      position (beginning_of (range2)) ;\n-      MOVE_VERTICAL(1);\n-      MOVE_HORIZONTAL(-2);\n-      LOOP\n-\tEXITIF CURRENT_CHARACTER <> \"\\\" ;\n-\tERASE_CHARACTER(1);\n-\tMOVE_HORIZONTAL(1);\n-\tMOVE_VERTICAL(1);\n-\tMOVE_HORIZONTAL(-2);\n-\tENDLOOP;\n-      MOVE_HORIZONTAL(1);\n-      mark2 := MARK(NONE) ;\n-      range2 := CREATE_RANGE(mark1, mark2, NONE) ;\n-      position (mark3);\n-      if (length(range2) = 0) then return; endif;\n-      copy_text(range2);\n-   ENDPROCEDURE;\n+PROCEDURE fetch_tag( tag_n, punct )\n+  !\n+  ! Looks up the translation of a tag, and inserts it at the current location\n+  ! in the buffer.\n+  !\n+  LOCAL mark0, mark1, mark2, range2;\n \n-   PROCEDURE pat_replace (\n-      oldstring, !\n-      newstring)  !\n-      LOCAL range2;\n-      position (beginning_of (current_buffer)) ;\n-      LOOP\n-         range2 := search_quietly (oldstring, FORWARD, EXACT) ;\n-         EXITIF range2 = 0 ;\n-         position (beginning_of (range2)) ;\n-         erase (range2) ;\n-         copy_text (newstring) ;\n-         ENDLOOP ;\n-   ENDPROCEDURE ;\n+  mark0 := MARK (NONE);     ! Remember where we started; restore before return.\n+  POSITION (BEGINNING_OF (makefile_buf));\n+  ! The tag definition always starts in the first column, and might have\n+  ! optional space(es) before \"=\" or \":\" punctutation.\n+  range2 := SEARCH_QUIETLY (LINE_BEGIN & tag_n & ((SPAN(\" \") & punct) | punct),\n+\t\t\t    FORWARD, EXACT);\n+  IF (range2 = 0) THEN\n+    POSITION (mark0);\n+    RETURN;\n+  ENDIF;\n+  POSITION (END_OF (range2));\n+  MOVE_HORIZONTAL (1);\t\t! Move beyond \"TAG=\".\n+  mark1 := MARK (NONE);\n+  POSITION (BEGINNING_OF (range2));\n+  LOOP\n+    MOVE_VERTICAL (1);\n+    MOVE_HORIZONTAL (-2);\n+    EXITIF (CURRENT_CHARACTER <> \"\\\");\n+    ERASE_CHARACTER (1);\n+    MOVE_HORIZONTAL (1);\n+  ENDLOOP;\n+  MOVE_HORIZONTAL (1);\n+  mark2 := MARK (NONE);\n+  range2 := CREATE_RANGE (mark1, mark2, NONE);\n+  POSITION (mark0);\n+  IF (LENGTH (range2) <> 0) THEN\n+    COPY_TEXT (range2);\n+  ENDIF;\n+ENDPROCEDURE; !fetch_tag\n+!!\n \n-!                !\n-! ...fix this... !\n-!                !\n- procedure temporary_cplusplus_hack()\n-  position(end_of(compiler_list));\n-  copy_text(\"cc1plus\");\n-  position(end_of(mainbuffer));\n-  copy_text(\"cc1plus: [.cp]call,[.cp]decl,[.cp]errfn,[.cp]expr,[.cp]pt,[.cp]sig\\\");  split_line;\n-  copy_text(\" [.cp]typeck2,[.cp]class,[.cp]decl2,[.cp]error,[.cp]gc,[.cp]lex\\\");  split_line;\n-  copy_text(\" [.cp]parse,[.cp]ptree,[.cp]spew,[.cp]typeck,[.cp]cvt,[.cp]edsel\\\");  split_line;\n-  copy_text(\" [.cp]except,[.cp]init,[.cp]method,[.cp]search,[.cp]tree,[.cp]xref\\\");  split_line;\n-  copy_text(\" []c-common\\\");  split_line;\n-  copy_text(\" bc-emit,bc-optab\\\");  split_line;\n-  copy_text(\" obstack\");  split_line;\n- endprocedure;\n+PROCEDURE pat_replace( oldstring, newstring )\n+  !\n+  ! Replace all occurences of a pattern.\n+  !\n+  LOCAL range1, range2, kill_it, count;\n \n+  count := 0;\n+  kill_it := (GET_INFO (newstring, 'TYPE') = UNSPECIFIED);\t! Omitted arg.\n+  range1 := CREATE_RANGE (BEGINNING_OF (CURRENT_BUFFER),\n+\t\t\t  END_OF (CURRENT_BUFFER), NONE);\n+  LOOP\n+    range2 := SEARCH_QUIETLY (oldstring, FORWARD, EXACT, range1);\n+    EXITIF (range2 = 0);\n+    count := count + 1;\n+    POSITION (BEGINNING_OF (range2));\n+    ERASE (range2);\n+    IF (newstring = LINE_END) THEN\n+      SPLIT_LINE;\n+    ELSE IF (NOT kill_it) THEN\n+      COPY_TEXT (newstring);\n+    ENDIF; ENDIF;\n+    MODIFY_RANGE (range1, MARK (NONE), END_OF (range1));\n+  ENDLOOP;\n+  RETURN count;\n+ENDPROCEDURE; !pat_replace\n+!!\n \n !\n-! this is the start of the main procedure\n-   filename := GET_INFO (COMMAND_LINE, 'file_name') ;\n-   mainbuffer := CREATE_BUFFER (\"Makefile.in\", \"Makefile.in\") ;\n-   newbuffer := CREATE_BUFFER(\"outfile\");\n-   compiler_list := CREATE_BUFFER(\"compilers\");\n+! This is the main routine.\n !\n-! Add to this list, as required.  The file \"Makefile.in\" is searched for a\n-! tag that looks like \"LINE_BEGIN + 'tag + (optional space) + \"=\"\".  The\n-! contents are assumed to be a list of object files, and from this list a\n-! VMS linker options file is generated.\n-!\n-   position (beginning_of (compiler_list));\n-   recursive_fetch_tag(LINE_BEGIN & \"COMPILERS\" & ((SPAN(\" \") & \"=\") | \"=\"));\n-   position (beginning_of (compiler_list));\n-   LOOP ! kill leading spaces.\n-\texitif current_character <> \" \";\n-\terase_character(1);\n-\tENDLOOP;\n-   position (beginning_of (compiler_list));\n-      LOOP ! remove any double spaces.\n-         range1 := search_quietly (\"  \", FORWARD, EXACT) ; EXITIF range1 = 0 ;\n-         position (beginning_of (range1)) ;\n-         erase_character(1);\n-         ENDLOOP ;\n-   position (end_of (compiler_list));\n-   move_horizontal(-1);\n-   LOOP ! kill trailing spaces.\n-\texitif current_character <> \" \";\n-\terase_character(1);\n-\tmove_horizontal(-1);\n-\tENDLOOP;\n-   position (beginning_of (compiler_list));\n-      LOOP\n-         range1 := search_quietly (\" \", FORWARD, EXACT) ;\n-         EXITIF range1 = 0 ;\n-         position (beginning_of (range1)) ;\n-         erase (range1) ;\n-\t split_line;\n-         ENDLOOP ;\n-!                         !\n-! This needs to be fixed. !\n-!                         !\n-\ttemporary_cplusplus_hack();\n-!\n-! We now have a list of supported compilers.  Now write it, and use it.\n-!\n-\tSET(OUTPUT_FILE, compiler_list, \"compilers.list\");\n-      write_file (compiler_list);\n-   generate_option_file(LINE_BEGIN & \"OBJS\" & ((SPAN(\" \") & \"=\") | \"=\"),\n-\t\t\t\"independent.opt\");\n-   generate_option_file(LINE_BEGIN & \"LIB2FUNCS\" & ((SPAN(\" \") & \"=\") | \"=\"),\n-\t\t\t\"libgcc2.list\");\n-   generate_option_file(LINE_BEGIN & \"BC_ALL\" & ((SPAN(\" \") & \"=\") | \"=\"),\n-\t\t\t\"bc_all.opt\");\n-   generate_option_file(LINE_BEGIN & \"BI_OBJ\" & ((SPAN(\" \") & \"=\") | \"=\"),\n-\t\t\t\"bi_all.opt\");\n-!\n-! Now change OBJS in the Makefile, so each language specific options file \n-! does not pick up all of the language independent files.\n-!\n-   position (beginning_of (mainbuffer));\n-   range1 := search_quietly (LINE_BEGIN & \"OBJS\" & ((SPAN(\" \") & \"=\") | \"=\"),\n-\t\t\t     FORWARD, EXACT) ;\n-   position (end_of (range1));\n-   split_line;\n-   position (beginning_of (compiler_list));\n-   LOOP\n-     cmark := mark(NONE);\n-     exitif cmark = end_of(compiler_list);\n-     message(current_line);\n-     generate_option_file(LINE_BEGIN & current_line & ((SPAN(\" \") & \":\") | \":\"),\n-\t\t\t  current_line+\"-objs.opt\");\n-     position (cmark);\n-     move_vertical(1);\n-   ENDLOOP ;\n-   quit ;\n+process_makefile ();\n+QUIT;\t! All done; don't write any modified buffers.\n+!!\n $ echo \"\"\n $!\n $! Remove excessive versions of the option files..."}]}