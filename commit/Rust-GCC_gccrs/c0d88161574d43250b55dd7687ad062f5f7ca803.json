{"sha": "c0d88161574d43250b55dd7687ad062f5f7ca803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBkODgxNjE1NzRkNDMyNTBiNTVkZDc2ODdhZDA2MmY1ZjdjYTgwMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "cow@compsoc.man.ac.uk", "date": "2002-02-10T09:00:41Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-02-10T09:00:41Z"}, "message": "stl_algo.h (__median, [...]): Doxygenate.\n\n2002-02-10  Jonathan Wakely  <cow@compsoc.man.ac.uk>\n\n\t* include/bits/stl_algo.h (__median, for_each, find, find_if,\n\tadjacent_find, count, count_if, search, search_n, swap_ranges,\n\ttransform, replace, replace_if, replace_copy, replace_copy_if,\n\tgenerate, generate_n, remove_copy, remove_copy_if, remove, remove_if,\n\tunique, unique_copy, reverse, reverse_copy):  Doxygenate.\n\nFrom-SVN: r49652", "tree": {"sha": "94acb6477d4f42001171aaa593c1642bde1e03b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94acb6477d4f42001171aaa593c1642bde1e03b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0d88161574d43250b55dd7687ad062f5f7ca803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d88161574d43250b55dd7687ad062f5f7ca803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d88161574d43250b55dd7687ad062f5f7ca803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d88161574d43250b55dd7687ad062f5f7ca803/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3439e039a25f54b3594a436c37d0356729891fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3439e039a25f54b3594a436c37d0356729891fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3439e039a25f54b3594a436c37d0356729891fa4"}], "stats": {"total": 831, "additions": 642, "deletions": 189}, "files": [{"sha": "da2f0f79705a748712c6b1c711c6b626d77e3357", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d88161574d43250b55dd7687ad062f5f7ca803/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d88161574d43250b55dd7687ad062f5f7ca803/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c0d88161574d43250b55dd7687ad062f5f7ca803", "patch": "@@ -1,3 +1,11 @@\n+2002-02-10  Jonathan Wakely  <cow@compsoc.man.ac.uk>\n+\n+\t* include/bits/stl_algo.h (__median, for_each, find, find_if,\n+\tadjacent_find, count, count_if, search, search_n, swap_ranges,\n+\ttransform, replace, replace_if, replace_copy, replace_copy_if,\n+\tgenerate, generate_n, remove_copy, remove_copy_if, remove, remove_if,\n+\tunique, unique_copy, reverse, reverse_copy):  Doxygenate.\n+\n 2002-02-08   Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/locale_facets.h"}, {"sha": "501bcf6dc0fa9223b3b6ca92cd9dc3f43e8b94f8", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 634, "deletions": 189, "changes": 823, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0d88161574d43250b55dd7687ad062f5f7ca803/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0d88161574d43250b55dd7687ad062f5f7ca803/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=c0d88161574d43250b55dd7687ad062f5f7ca803", "patch": "@@ -1,4 +1,4 @@\n-// Algorithm implimentation -*- C++ -*-\n+// Algorithm implementation -*- C++ -*-\n \n // Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n@@ -69,8 +69,18 @@\n namespace std\n {\n \n-  // __median (an extension, not present in the C++ standard).\n-\n+  /**\n+   *  @brief Find the median of three values.\n+   *  @param  a  A value.\n+   *  @param  b  A value.\n+   *  @param  c  A value.\n+   *  @return One of @p a, @p b or @p c.\n+   *\n+   *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @c l<=m<=n\n+   *  then the value returned will be @c m.\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+  */\n   template<typename _Tp>\n   inline const _Tp&\n     __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)\n@@ -92,6 +102,19 @@ namespace std\n \treturn __b;\n     }\n \n+  /**\n+   *  @brief Find the median of three values using a predicate for comparison.\n+   *  @param  a     A value.\n+   *  @param  b     A value.\n+   *  @param  c     A value.\n+   *  @param  comp  A binary predicate.\n+   *  @return One of @p a, @p b or @p c.\n+   *\n+   *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @p comp(l,m)\n+   *  and @p comp(m,n) are both true then the value returned will be @c m.\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+  */\n   template<typename _Tp, typename _Compare>\n     inline const _Tp&\n     __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)\n@@ -113,7 +136,18 @@ namespace std\n \treturn __b;\n     }\n \n-  // for_each.  Apply a function to every element of a range.\n+  /**\n+   *  @brief Apply a function to every element of a sequence.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  f      A unary function object.\n+   *  @return   @p f.\n+   *\n+   *  Applies the function object @p f to each element in the range\n+   *  @p [first,last).\n+   *  @p f must not modify its argument.\n+   *  If @p f has a return value it is ignored.\n+  */\n   template<typename _InputIter, typename _Function>\n     _Function\n     for_each(_InputIter __first, _InputIter __last, _Function __f)\n@@ -125,8 +159,11 @@ namespace std\n       return __f;\n     }\n \n-  // find and find_if.\n-\n+  /**\n+   *  @maint\n+   *  This is an overload used by find() for the Input Iterator case.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _Tp>\n     inline _InputIter\n     find(_InputIter __first, _InputIter __last,\n@@ -138,6 +175,11 @@ namespace std\n       return __first;\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an overload used by find_if() for the Input Iterator case.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _Predicate>\n     inline _InputIter\n     find_if(_InputIter __first, _InputIter __last,\n@@ -149,6 +191,11 @@ namespace std\n       return __first;\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an overload used by find() for the RAI case.\n+   *  @endmaint\n+  */\n   template<typename _RandomAccessIter, typename _Tp>\n     _RandomAccessIter\n     find(_RandomAccessIter __first, _RandomAccessIter __last,\n@@ -188,6 +235,11 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an overload used by find_if() for the RAI case.\n+   *  @endmaint\n+  */\n   template<typename _RandomAccessIter, typename _Predicate>\n     _RandomAccessIter\n     find_if(_RandomAccessIter __first, _RandomAccessIter __last,\n@@ -227,6 +279,14 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief Find the first occurrence of a value in a sequence.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  val    The value to find.\n+   *  @return   The first iterator @c i in the range @p [first,last)\n+   *  such that @c *i == @p val, or @p last if no such iterator exists.\n+  */\n   template<typename _InputIter, typename _Tp>\n     inline _InputIter\n     find(_InputIter __first, _InputIter __last,\n@@ -239,6 +299,14 @@ namespace std\n       return find(__first, __last, __val, __iterator_category(__first));\n     }\n \n+  /**\n+   *  @brief Find the first element in a sequence for which a predicate is true.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  pred   A predicate.\n+   *  @return   The first iterator @c i in the range @p [first,last)\n+   *  such that @p pred(*i) is true, or @p last if no such iterator exists.\n+  */\n   template<typename _InputIter, typename _Predicate>\n     inline _InputIter\n     find_if(_InputIter __first, _InputIter __last,\n@@ -251,8 +319,14 @@ namespace std\n       return find_if(__first, __last, __pred, __iterator_category(__first));\n     }\n \n-  // adjacent_find.\n-\n+  /**\n+   *  @brief Find two adjacent values in a sequence that are equal.\n+   *  @param  first  A forward iterator.\n+   *  @param  last   A forward iterator.\n+   *  @return   The first iterator @c i such that @c i and @c i+1 are both\n+   *  valid iterators in @p [first,last) and such that @c *i == @c *(i+1),\n+   *  or @p last if no such iterator exists.\n+  */\n   template<typename _ForwardIter>\n     _ForwardIter\n     adjacent_find(_ForwardIter __first, _ForwardIter __last)\n@@ -272,6 +346,16 @@ namespace std\n       return __last;\n     }\n \n+  /**\n+   *  @brief Find two adjacent values in a sequence using a predicate.\n+   *  @param  first         A forward iterator.\n+   *  @param  last          A forward iterator.\n+   *  @param  binary_pred   A binary predicate.\n+   *  @return   The first iterator @c i such that @c i and @c i+1 are both\n+   *  valid iterators in @p [first,last) and such that\n+   *  @p binary_pred(*i,*(i+1)) is true, or @p last if no such iterator\n+   *  exists.\n+  */\n   template<typename _ForwardIter, typename _BinaryPredicate>\n     _ForwardIter\n     adjacent_find(_ForwardIter __first, _ForwardIter __last,\n@@ -293,8 +377,14 @@ namespace std\n       return __last;\n     }\n \n-  // count and count_if.\n-\n+  /**\n+   *  @brief Count the number of copies of a value in a sequence.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  value  The value to be counted.\n+   *  @return   The number of iterators @c i in the range @p [first,last)\n+   *  for which @c *i == @p value\n+  */\n   template<typename _InputIter, typename _Tp>\n     typename iterator_traits<_InputIter>::difference_type\n     count(_InputIter __first, _InputIter __last, const _Tp& __value)\n@@ -311,6 +401,14 @@ namespace std\n       return __n;\n     }\n \n+  /**\n+   *  @brief Count the elements of a sequence for which a predicate is true.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  pred   A predicate.\n+   *  @return   The number of iterators @c i in the range @p [first,last)\n+   *  for which @p pred(*i) is true.\n+  */\n   template<typename _InputIter, typename _Predicate>\n     typename iterator_traits<_InputIter>::difference_type\n     count_if(_InputIter __first, _InputIter __last, _Predicate __pred)\n@@ -327,12 +425,33 @@ namespace std\n     }\n \n \n-  // search.\n-\n+  /**\n+   *  @brief Search a sequence for a matching sub-sequence.\n+   *  @param  first1  A forward iterator.\n+   *  @param  last1   A forward iterator.\n+   *  @param  first2  A forward iterator.\n+   *  @param  last2   A forward iterator.\n+   *  @return   The first iterator @c i in the range\n+   *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)\n+   *  for each @c N in the range @p [0,last2-first2), or @p last1 if no\n+   *  such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for a sub-sequence that compares\n+   *  equal value-by-value with the sequence given by @p [first2,last2) and\n+   *  returns an iterator to the first element of the sub-sequence, or\n+   *  @p last1 if the sub-sequence is not found.\n+   *\n+   *  Because the sub-sequence must lie completely within the range\n+   *  @p [first1,last1) it must start at a position less than\n+   *  @p last1-(last2-first2) where @p last2-first2 is the length of the\n+   *  sub-sequence.\n+   *  This means that the returned iterator @c i will be in the range\n+   *  @p [first1,last1-(last2-first2))\n+  */\n   template<typename _ForwardIter1, typename _ForwardIter2>\n     _ForwardIter1\n     search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n-\t   _ForwardIter2 __first2, _ForwardIter2 __last2) \n+\t   _ForwardIter2 __first2, _ForwardIter2 __last2)\n     {\n       // concept requirements\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>)\n@@ -365,7 +484,7 @@ namespace std\n \t  return __last1;\n \n \t__p = __p1;\n-\t__current = __first1; \n+\t__current = __first1;\n \tif (++__current == __last1)\n \t  return __last1;\n \n@@ -381,11 +500,31 @@ namespace std\n       return __first1;\n     }\n \n+  /**\n+   *  @brief Search a sequence for a matching sub-sequence using a predicate.\n+   *  @param  first1     A forward iterator.\n+   *  @param  last1      A forward iterator.\n+   *  @param  first2     A forward iterator.\n+   *  @param  last2      A forward iterator.\n+   *  @param  predicate  A binary predicate.\n+   *  @return   The first iterator @c i in the range\n+   *  @p [first1,last1-(last2-first2)) such that\n+   *  @p predicate(*(i+N),*(first2+N)) is true for each @c N in the range\n+   *  @p [0,last2-first2), or @p last1 if no such iterator exists.\n+   *\n+   *  Searches the range @p [first1,last1) for a sub-sequence that compares\n+   *  equal value-by-value with the sequence given by @p [first2,last2),\n+   *  using @p predicate to determine equality, and returns an iterator\n+   *  to the first element of the sub-sequence, or @p last1 if no such\n+   *  iterator exists.\n+   *\n+   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)\n+  */\n   template<typename _ForwardIter1, typename _ForwardIter2, typename _BinaryPred>\n     _ForwardIter1\n     search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n \t   _ForwardIter2 __first2, _ForwardIter2 __last2,\n-\t   _BinaryPred  __predicate) \n+\t   _BinaryPred  __predicate)\n     {\n       // concept requirements\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>)\n@@ -404,7 +543,7 @@ namespace std\n       if (__tmp == __last2) {\n \twhile (__first1 != __last1 && !__predicate(*__first1, *__first2))\n \t  ++__first1;\n-\treturn __first1;    \n+\treturn __first1;\n       }\n \n       // General case.\n@@ -427,7 +566,7 @@ namespace std\n \t  return __last1;\n \n \t__p = __p1;\n-\t__current = __first1; \n+\t__current = __first1;\n \tif (++__current == __last1) return __last1;\n \n \twhile (__predicate(*__current, *__p)) {\n@@ -442,8 +581,19 @@ namespace std\n       return __first1;\n     }\n \n-  // search_n.  Search for __count consecutive copies of __val.\n-\n+  /**\n+   *  @brief Search a sequence for a number of consecutive values.\n+   *  @param  first  A forward iterator.\n+   *  @param  last   A forward iterator.\n+   *  @param  count  The number of consecutive values.\n+   *  @param  val    The value to find.\n+   *  @return   The first iterator @c i in the range @p [first,last-count)\n+   *  such that @c *(i+N) == @p val for each @c N in the range @p [0,count),\n+   *  or @p last if no such iterator exists.\n+   *\n+   *  Searches the range @p [first,last) for @p count consecutive elements\n+   *  equal to @p val.\n+  */\n   template<typename _ForwardIter, typename _Integer, typename _Tp>\n     _ForwardIter\n     search_n(_ForwardIter __first, _ForwardIter __last,\n@@ -476,6 +626,21 @@ namespace std\n       }\n     }\n \n+  /**\n+   *  @brief Search a sequence for a number of consecutive values using a\n+   *         predicate.\n+   *  @param  first        A forward iterator.\n+   *  @param  last         A forward iterator.\n+   *  @param  count        The number of consecutive values.\n+   *  @param  val          The value to find.\n+   *  @param  binary_pred  A binary predicate.\n+   *  @return   The first iterator @c i in the range @p [first,last-count)\n+   *  such that @p binary_pred(*(i+N),val) is true for each @c N in the\n+   *  range @p [0,count), or @p last if no such iterator exists.\n+   *\n+   *  Searches the range @p [first,last) for @p count consecutive elements\n+   *  for which the predicate returns true.\n+  */\n   template<typename _ForwardIter, typename _Integer, typename _Tp,\n            typename _BinaryPred>\n     _ForwardIter\n@@ -517,10 +682,19 @@ namespace std\n \t}\n \treturn __last;\n       }\n-    } \n-\n-  // swap_ranges\n+    }\n \n+  /**\n+   *  @brief Swap the elements of two sequences.\n+   *  @param  first1  A forward iterator.\n+   *  @param  last1   A forward iterator.\n+   *  @param  first2  A forward iterator.\n+   *  @return   An iterator equal to @p first2+(last1-first1).\n+   *\n+   *  Swaps each element in the range @p [first1,last1) with the\n+   *  corresponding element in the range @p [first2,(last1-first1)).\n+   *  The ranges must not overlap.\n+  */\n   template<typename _ForwardIter1, typename _ForwardIter2>\n     _ForwardIter2\n     swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,\n@@ -541,8 +715,21 @@ namespace std\n       return __first2;\n     }\n \n-  // transform\n-\n+  /**\n+   *  @brief Perform an operation on a sequence.\n+   *  @param  first     An input iterator.\n+   *  @param  last      An input iterator.\n+   *  @param  result    An output iterator.\n+   *  @param  unary_op  A unary operator.\n+   *  @return   An output iterator equal to @p result+(last-first).\n+   *\n+   *  Applies the operator to each element in the input range and assigns\n+   *  the results to successive elements of the output sequence.\n+   *  Evaluates @p *(result+N)=unary_op(*(first+N)) for each @c N in the\n+   *  range @p [0,last-first).\n+   *\n+   *  @p unary_op must not alter its argument.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _UnaryOperation>\n     _OutputIter\n     transform(_InputIter __first, _InputIter __last,\n@@ -561,6 +748,23 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Perform an operation on corresponding elements of two sequences.\n+   *  @param  first1     An input iterator.\n+   *  @param  last1      An input iterator.\n+   *  @param  first2     An input iterator.\n+   *  @param  result     An output iterator.\n+   *  @param  binary_op  A binary operator.\n+   *  @return   An output iterator equal to @p result+(last-first).\n+   *\n+   *  Applies the operator to the corresponding elements in the two\n+   *  input ranges and assigns the results to successive elements of the\n+   *  output sequence.\n+   *  Evaluates @p *(result+N)=binary_op(*(first1+N),*(first2+N)) for each\n+   *  @c N in the range @p [0,last1-first1).\n+   *\n+   *  @p binary_op must not alter either of its arguments.\n+  */\n   template<typename _InputIter1, typename _InputIter2, typename _OutputIter,\n \t   typename _BinaryOperation>\n     _OutputIter\n@@ -582,8 +786,18 @@ namespace std\n       return __result;\n     }\n \n-  // replace, replace_if, replace_copy, replace_copy_if\n-\n+  /**\n+   *  @brief Replace each occurrence of one value in a sequence with another\n+   *         value.\n+   *  @param  first      A forward iterator.\n+   *  @param  last       A forward iterator.\n+   *  @param  old_value  The value to be replaced.\n+   *  @param  new_value  The replacement value.\n+   *  @return   replace() returns no value.\n+   *\n+   *  For each iterator @c i in the range @p [first,last) if @c *i ==\n+   *  @p old_value then the assignment @c *i = @p new_value is performed.\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     void\n     replace(_ForwardIter __first, _ForwardIter __last,\n@@ -601,6 +815,18 @@ namespace std\n \t  *__first = __new_value;\n     }\n \n+  /**\n+   *  @brief Replace each value in a sequence for which a predicate returns\n+   *         true with another value.\n+   *  @param  first      A forward iterator.\n+   *  @param  last       A forward iterator.\n+   *  @param  pred       A predicate.\n+   *  @param  new_value  The replacement value.\n+   *  @return   replace_if() returns no value.\n+   *\n+   *  For each iterator @c i in the range @p [first,last) if @p pred(*i)\n+   *  is true then the assignment @c *i = @p new_value is performed.\n+  */\n   template<typename _ForwardIter, typename _Predicate, typename _Tp>\n     void\n     replace_if(_ForwardIter __first, _ForwardIter __last,\n@@ -618,6 +844,20 @@ namespace std\n \t  *__first = __new_value;\n     }\n \n+  /**\n+   *  @brief Copy a sequence, replacing each element of one value with another\n+   *         value.\n+   *  @param  first      An input iterator.\n+   *  @param  last       An input iterator.\n+   *  @param  result     An output iterator.\n+   *  @param  old_value  The value to be replaced.\n+   *  @param  new_value  The replacement value.\n+   *  @return   The end of the output sequence, @p result+(last-first).\n+   *\n+   *  Copies each element in the input range @p [first,last) to the\n+   *  output range @p [result,result+(last-first)) replacing elements\n+   *  equal to @p old_value with @p new_value.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _Tp>\n     _OutputIter\n     replace_copy(_InputIter __first, _InputIter __last,\n@@ -636,6 +876,20 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Copy a sequence, replacing each value for which a predicate\n+   *         returns true with another value.\n+   *  @param  first      An input iterator.\n+   *  @param  last       An input iterator.\n+   *  @param  result     An output iterator.\n+   *  @param  pred       A predicate.\n+   *  @param  new_value  The replacement value.\n+   *  @return   The end of the output sequence, @p result+(last-first).\n+   *\n+   *  Copies each element in the range @p [first,last) to the range\n+   *  @p [result,result+(last-first)) replacing elements for which\n+   *  @p pred returns true with @p new_value.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _Predicate,\n            typename _Tp>\n     _OutputIter\n@@ -655,8 +909,17 @@ namespace std\n       return __result;\n     }\n \n-  // generate and generate_n\n-\n+  /**\n+   *  @brief Assign the result of a function object to each value in a\n+   *         sequence.\n+   *  @param  first  A forward iterator.\n+   *  @param  last   A forward iterator.\n+   *  @param  gen    A function object taking no arguments.\n+   *  @return   generate() returns no value.\n+   *\n+   *  Performs the assignment @c *i = @p gen() for each @c i in the range\n+   *  @p [first,last).\n+  */\n   template<typename _ForwardIter, typename _Generator>\n     void\n     generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen)\n@@ -670,6 +933,17 @@ namespace std\n \t*__first = __gen();\n     }\n \n+  /**\n+   *  @brief Assign the result of a function object to each value in a\n+   *         sequence.\n+   *  @param  first  A forward iterator.\n+   *  @param  n      The length of the sequence.\n+   *  @param  gen    A function object taking no arguments.\n+   *  @return   The end of the sequence, @p first+n\n+   *\n+   *  Performs the assignment @c *i = @p gen() for each @c i in the range\n+   *  @p [first,first+n).\n+  */\n   template<typename _OutputIter, typename _Size, typename _Generator>\n     _OutputIter\n     generate_n(_OutputIter __first, _Size __n, _Generator __gen)\n@@ -685,8 +959,19 @@ namespace std\n       return __first;\n     }\n \n-  // remove, remove_if, remove_copy, remove_copy_if\n-\n+  /**\n+   *  @brief Copy a sequence, removing elements of a given value.\n+   *  @param  first   An input iterator.\n+   *  @param  last    An input iterator.\n+   *  @param  result  An output iterator.\n+   *  @param  value   The value to be removed.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  Copies each element in the range @p [first,last) not equal to @p value\n+   *  to the range beginning at @p result.\n+   *  remove_copy() is stable, so the relative order of elements that are\n+   *  copied is unchanged.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _Tp>\n     _OutputIter\n     remove_copy(_InputIter __first, _InputIter __last,\n@@ -707,6 +992,20 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Copy a sequence, removing elements for which a predicate is true.\n+   *  @param  first   An input iterator.\n+   *  @param  last    An input iterator.\n+   *  @param  result  An output iterator.\n+   *  @param  pred    A predicate.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  Copies each element in the range @p [first,last) for which\n+   *  @p pred returns true to the range beginning at @p result.\n+   *\n+   *  remove_copy_if() is stable, so the relative order of elements that are\n+   *  copied is unchanged.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _Predicate>\n     _OutputIter\n     remove_copy_if(_InputIter __first, _InputIter __last,\n@@ -727,6 +1026,22 @@ namespace std\n       return __result;\n     }\n \n+  /**\n+   *  @brief Remove elements from a sequence.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *  @param  value  The value to be removed.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  All elements equal to @p value are removed from the range\n+   *  @p [first,last).\n+   *\n+   *  remove() is stable, so the relative order of elements that are\n+   *  not removed is unchanged.\n+   *\n+   *  Elements between the end of the resulting sequence and @p last\n+   *  are still present, but their value is unspecified.\n+  */\n   template<typename _ForwardIter, typename _Tp>\n     _ForwardIter\n     remove(_ForwardIter __first, _ForwardIter __last,\n@@ -741,10 +1056,26 @@ namespace std\n \n       __first = find(__first, __last, __value);\n       _ForwardIter __i = __first;\n-      return __first == __last ? __first \n+      return __first == __last ? __first\n \t\t\t       : remove_copy(++__i, __last, __first, __value);\n     }\n \n+  /**\n+   *  @brief Remove elements from a sequence using a predicate.\n+   *  @param  first  A forward iterator.\n+   *  @param  last   A forward iterator.\n+   *  @param  pred   A predicate.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  All elements for which @p pred returns true are removed from the range\n+   *  @p [first,last).\n+   *\n+   *  remove_if() is stable, so the relative order of elements that are\n+   *  not removed is unchanged.\n+   *\n+   *  Elements between the end of the resulting sequence and @p last\n+   *  are still present, but their value is unspecified.\n+  */\n   template<typename _ForwardIter, typename _Predicate>\n     _ForwardIter\n     remove_if(_ForwardIter __first, _ForwardIter __last,\n@@ -757,14 +1088,20 @@ namespace std\n \n       __first = find_if(__first, __last, __pred);\n       _ForwardIter __i = __first;\n-      return __first == __last ? __first \n+      return __first == __last ? __first\n \t\t\t       : remove_copy_if(++__i, __last, __first, __pred);\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter)\n+   *  overloaded for output iterators.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _OutputIter>\n     _OutputIter\n     __unique_copy(_InputIter __first, _InputIter __last,\n-\t\t  _OutputIter __result, \n+\t\t  _OutputIter __result,\n \t\t  output_iterator_tag)\n     {\n       // concept requirements -- taken care of in dispatching function\n@@ -778,6 +1115,12 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified unique_copy(_InputIter, _InputIter, _OutputIter)\n+   *  overloaded for forward iterators.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _ForwardIter>\n     _ForwardIter\n     __unique_copy(_InputIter __first, _InputIter __last,\n@@ -792,6 +1135,17 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @brief Copy a sequence, removing consecutive duplicate values.\n+   *  @param  first   An input iterator.\n+   *  @param  last    An input iterator.\n+   *  @param  result  An output iterator.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  Copies each element in the range @p [first,last) to the range\n+   *  beginning at @p result, except that only the first element is copied\n+   *  from groups of consecutive elements that compare equal.\n+  */\n   template<typename _InputIter, typename _OutputIter>\n     inline _OutputIter\n     unique_copy(_InputIter __first, _InputIter __last,\n@@ -803,13 +1157,20 @@ namespace std\n \t    typename iterator_traits<_InputIter>::value_type>)\n       __glibcpp_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_InputIter>::value_type>)\n-    \n+\n       typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;\n \n       if (__first == __last) return __result;\n       return __unique_copy(__first, __last, __result, _IterType());\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified\n+   *  unique_copy(_InputIter, _InputIter, _OutputIter, _BinaryPredicate)\n+   *  overloaded for output iterators.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>\n     _OutputIter\n     __unique_copy(_InputIter __first, _InputIter __last,\n@@ -821,7 +1182,7 @@ namespace std\n       __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t  typename iterator_traits<_InputIter>::value_type,\n \t  typename iterator_traits<_InputIter>::value_type>)\n-    \n+\n       typename iterator_traits<_InputIter>::value_type __value = *__first;\n       *__result = __value;\n       while (++__first != __last)\n@@ -832,24 +1193,46 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified\n+   *  unique_copy(_InputIter, _InputIter, _OutputIter, _BinaryPredicate)\n+   *  overloaded for forward iterators.\n+   *  @endmaint\n+  */\n   template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>\n     _ForwardIter\n     __unique_copy(_InputIter __first, _InputIter __last,\n-\t\t  _ForwardIter __result, \n+\t\t  _ForwardIter __result,\n \t\t  _BinaryPredicate __binary_pred,\n \t\t  forward_iterator_tag)\n     {\n       // concept requirements -- iterators already checked\n       __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_ForwardIter>::value_type,\n \t    typename iterator_traits<_InputIter>::value_type>)\n-    \n+\n       *__result = *__first;\n       while (++__first != __last)\n \tif (!__binary_pred(*__result, *__first)) *++__result = *__first;\n       return ++__result;\n     }\n \n+  /**\n+   *  @brief Copy a sequence, removing consecutive values using a predicate.\n+   *  @param  first        An input iterator.\n+   *  @param  last         An input iterator.\n+   *  @param  result       An output iterator.\n+   *  @param  binary_pred  A binary predicate.\n+   *  @return   An iterator designating the end of the resulting sequence.\n+   *\n+   *  Copies each element in the range @p [first,last) to the range\n+   *  beginning at @p result, except that only the first element is copied\n+   *  from groups of consecutive elements for which @p binary_pred returns\n+   *  true.\n+   *  unique_copy() is stable, so the relative order of elements that are\n+   *  copied is unchanged.\n+  */\n   template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>\n     inline _OutputIter\n     unique_copy(_InputIter __first, _InputIter __last,\n@@ -860,14 +1243,27 @@ namespace std\n       __glibcpp_function_requires(_InputIteratorConcept<_InputIter>)\n       __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n \t    typename iterator_traits<_InputIter>::value_type>)\n-    \n+\n       typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;\n \n       if (__first == __last) return __result;\n-      return __unique_copy(__first, __last, \n+      return __unique_copy(__first, __last,\n __result, __binary_pred, _IterType());\n     }\n \n+  /**\n+   *  @brief Remove consecutive duplicate values from a sequence.\n+   *  @param  first  A forward iterator.\n+   *  @param  last   A forward iterator.\n+   *  @return  An iterator designating the end of the resulting sequence.\n+   *\n+   *  Removes all but the first element from each group of consecutive\n+   *  values that compare equal.\n+   *  unique() is stable, so the relative order of elements that are\n+   *  not removed is unchanged.\n+   *  Elements between the end of the resulting sequence and @p last\n+   *  are still present, but their value is unspecified.\n+  */\n   template<typename _ForwardIter>\n     _ForwardIter\n     unique(_ForwardIter __first, _ForwardIter __last)\n@@ -881,6 +1277,20 @@ __result, __binary_pred, _IterType());\n \t  return unique_copy(__first, __last, __first);\n     }\n \n+  /**\n+   *  @brief Remove consecutive values from a sequence using a predicate.\n+   *  @param  first        A forward iterator.\n+   *  @param  last         A forward iterator.\n+   *  @param  binary_pred  A binary predicate.\n+   *  @return  An iterator designating the end of the resulting sequence.\n+   *\n+   *  Removes all but the first element from each group of consecutive\n+   *  values for which @p binary_pred returns true.\n+   *  unique() is stable, so the relative order of elements that are\n+   *  not removed is unchanged.\n+   *  Elements between the end of the resulting sequence and @p last\n+   *  are still present, but their value is unspecified.\n+  */\n   template<typename _ForwardIter, typename _BinaryPredicate>\n     _ForwardIter\n     unique(_ForwardIter __first, _ForwardIter __last,\n@@ -896,9 +1306,15 @@ __result, __binary_pred, _IterType());\n       return unique_copy(__first, __last, __first, __binary_pred);\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified reverse(_BidirectionalIter, _BidirectionalIter)\n+   *  overloaded for bidirectional iterators.\n+   *  @endmaint\n+  */\n   template<typename _BidirectionalIter>\n     void\n-    __reverse(_BidirectionalIter __first, _BidirectionalIter __last, \n+    __reverse(_BidirectionalIter __first, _BidirectionalIter __last,\n \t\t\t  bidirectional_iterator_tag)\n     {\n \t  while (true)\n@@ -908,6 +1324,12 @@ __result, __binary_pred, _IterType());\n \t\t  iter_swap(__first++, __last);\n     }\n \n+  /**\n+   *  @maint\n+   *  This is an uglified reverse(_BidirectionalIter, _BidirectionalIter)\n+   *  overloaded for bidirectional iterators.\n+   *  @endmaint\n+  */\n   template<typename _RandomAccessIter>\n     void\n     __reverse(_RandomAccessIter __first, _RandomAccessIter __last,\n@@ -917,6 +1339,17 @@ __result, __binary_pred, _IterType());\n \t    iter_swap(__first++, --__last);\n     }\n \n+  /**\n+   *  @brief Reverse a sequence.\n+   *  @param  first  A bidirectional iterator.\n+   *  @param  last   A bidirectional iterator.\n+   *  @return   reverse() returns no value.\n+   *\n+   *  Reverses the order of the elements in the range @p [first,last),\n+   *  so that the first element becomes the last etc.\n+   *  For every @c i such that @p 0<=i<=(last-first)/2), @p reverse()\n+   *  swaps @p *(first+i) and @p *(last-(i+1))\n+  */\n   template<typename _BidirectionalIter>\n     inline void\n     reverse(_BidirectionalIter __first, _BidirectionalIter __last)\n@@ -927,6 +1360,21 @@ __result, __binary_pred, _IterType());\n \t  __reverse(__first, __last, __iterator_category(__first));\n     }\n \n+  /**\n+   *  @brief Copy a sequence, reversing its elements.\n+   *  @param  first   A bidirectional iterator.\n+   *  @param  last    A bidirectional iterator.\n+   *  @param  result  An output iterator.\n+   *  @return  An iterator designating the end of the resulting sequence.\n+   *\n+   *  Copies the elements in the range @p [first,last) to the range\n+   *  @p [result,result+(last-first)) such that the order of the\n+   *  elements is reversed.\n+   *  For every @c i such that @p 0<=i<=(last-first), @p reverse_copy()\n+   *  performs the assignment @p *(result+(last-first)-i) = *(first+i).\n+   *  The ranges @p [first,last) and @p [result,result+(last-first))\n+   *  must not overlap.\n+  */\n   template<typename _BidirectionalIter, typename _OutputIter>\n     _OutputIter\n     reverse_copy(_BidirectionalIter __first, _BidirectionalIter __last,\n@@ -968,16 +1416,16 @@ __result, __binary_pred, _IterType());\n     {\n       if ((__first == __middle) || (__last  == __middle))\n \treturn;\n-    \n+\n       _ForwardIter __first2 = __middle;\n       do {\n \tswap(*__first++, *__first2++);\n \tif (__first == __middle)\n \t  __middle = __first2;\n       } while (__first2 != __last);\n-    \n+\n       __first2 = __middle;\n-    \n+\n       while (__first2 != __last) {\n \tswap(*__first++, *__first2++);\n \tif (__first == __middle)\n@@ -986,7 +1434,7 @@ __result, __binary_pred, _IterType());\n \t  __first2 = __middle;\n       }\n     }\n-    \n+\n   template<typename _BidirectionalIter>\n     void\n     __rotate(_BidirectionalIter __first,\n@@ -997,24 +1445,24 @@ __result, __binary_pred, _IterType());\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n \t    _BidirectionalIter>)\n-    \n+\n       if ((__first == __middle) || (__last  == __middle))\n \treturn;\n-    \n+\n       __reverse(__first,  __middle, bidirectional_iterator_tag());\n       __reverse(__middle, __last,   bidirectional_iterator_tag());\n-    \n+\n       while (__first != __middle && __middle != __last)\n \tswap (*__first++, *--__last);\n-    \n+\n       if (__first == __middle) {\n \t__reverse(__middle, __last,   bidirectional_iterator_tag());\n       }\n       else {\n \t__reverse(__first,  __middle, bidirectional_iterator_tag());\n       }\n     }\n-    \n+\n   template<typename _RandomAccessIter>\n     void\n     __rotate(_RandomAccessIter __first,\n@@ -1025,64 +1473,64 @@ __result, __binary_pred, _IterType());\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n-    \n+\n       if ((__first == __middle) || (__last  == __middle))\n \treturn;\n-    \n+\n       typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       _Distance __n = __last   - __first;\n       _Distance __k = __middle - __first;\n       _Distance __l = __n - __k;\n-    \n+\n       if (__k == __l) {\n \tswap_ranges(__first, __middle, __middle);\n \treturn;\n       }\n-    \n+\n       _Distance __d = __gcd(__n, __k);\n-    \n+\n       for (_Distance __i = 0; __i < __d; __i++) {\n \t_ValueType __tmp = *__first;\n \t_RandomAccessIter __p = __first;\n-    \n+\n \tif (__k < __l) {\n \t  for (_Distance __j = 0; __j < __l/__d; __j++) {\n \t    if (__p > __first + __l) {\n \t      *__p = *(__p - __l);\n \t      __p -= __l;\n \t    }\n-    \n+\n \t    *__p = *(__p + __k);\n \t    __p += __k;\n \t  }\n \t}\n-    \n+\n \telse {\n \t  for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {\n \t    if (__p < __last - __k) {\n \t      *__p = *(__p + __k);\n \t      __p += __k;\n \t    }\n-    \n+\n \t    *__p = * (__p - __l);\n \t    __p -= __l;\n \t  }\n \t}\n-    \n+\n \t*__p = __tmp;\n \t++__first;\n       }\n     }\n-    \n+\n   template<typename _ForwardIter>\n     inline void\n     rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last)\n     {\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>)\n-    \n+\n       typedef typename iterator_traits<_ForwardIter>::iterator_category _IterType;\n       __rotate(__first, __middle, __last, _IterType());\n     }\n@@ -1228,13 +1676,13 @@ __result, __binary_pred, _IterType());\n       return __begin;\n     }\n \n-  template<typename _ForwardIter, typename _Pointer, typename _Predicate, \n+  template<typename _ForwardIter, typename _Pointer, typename _Predicate,\n \t   typename _Distance>\n     _ForwardIter\n     __stable_partition_adaptive(_ForwardIter __first, _ForwardIter __last,\n \t\t\t\t_Predicate __pred, _Distance __len,\n \t\t\t\t_Pointer __buffer,\n-\t\t\t\t_Distance __buffer_size) \n+\t\t\t\t_Distance __buffer_size)\n     {\n       if (__len <= __buffer_size) {\n \t_ForwardIter __result1 = __first;\n@@ -1270,14 +1718,14 @@ __result, __binary_pred, _IterType());\n \n   template<typename _ForwardIter, typename _Predicate>\n     _ForwardIter\n-    stable_partition(_ForwardIter __first, _ForwardIter __last, \n+    stable_partition(_ForwardIter __first, _ForwardIter __last,\n \t\t     _Predicate __pred)\n     {\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_ForwardIter>::value_type>)\n-    \n+\n       if (__first == __last)\n \treturn __first;\n       else\n@@ -1291,15 +1739,15 @@ __result, __binary_pred, _IterType());\n \t\t\t\t\t     _DistanceType(__buf.requested_size()),\n \t\t\t\t\t     __buf.begin(), __buf.size());\n \telse\n-\t  return __inplace_stable_partition(__first, __last, __pred, \n+\t  return __inplace_stable_partition(__first, __last, __pred,\n \t\t\t\t\t    _DistanceType(__buf.requested_size()));\n       }\n     }\n \n   template<typename _RandomAccessIter, typename _Tp>\n     _RandomAccessIter\n-    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last, \n-\t\t\t  _Tp __pivot) \n+    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,\n+\t\t\t  _Tp __pivot)\n     {\n       while (true) {\n \twhile (*__first < __pivot)\n@@ -1312,12 +1760,12 @@ __result, __binary_pred, _IterType());\n \titer_swap(__first, __last);\n \t++__first;\n       }\n-    }    \n+    }\n \n   template<typename _RandomAccessIter, typename _Tp, typename _Compare>\n     _RandomAccessIter\n-    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last, \n-\t\t\t  _Tp __pivot, _Compare __comp) \n+    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,\n+\t\t\t  _Tp __pivot, _Compare __comp)\n     {\n       while (true) {\n \twhile (__comp(*__first, __pivot))\n@@ -1334,7 +1782,7 @@ __result, __binary_pred, _IterType());\n \n   const int __stl_threshold = 16;\n \n-  // sort() and its auxiliary functions. \n+  // sort() and its auxiliary functions.\n \n   template<typename _RandomAccessIter, typename _Tp>\n     void\n@@ -1349,13 +1797,13 @@ __result, __binary_pred, _IterType());\n       }\n       *__last = __val;\n     }\n-    \n+\n   template<typename _RandomAccessIter, typename _Tp, typename _Compare>\n     void\n     __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, _Compare __comp)\n     {\n       _RandomAccessIter __next = __last;\n-      --__next;  \n+      --__next;\n       while (__comp(__val, *__next)) {\n \t*__last = *__next;\n \t__last = __next;\n@@ -1368,7 +1816,7 @@ __result, __binary_pred, _IterType());\n     void\n     __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)\n     {\n-      if (__first == __last) return; \n+      if (__first == __last) return;\n \n       for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)\n       {\n@@ -1406,7 +1854,7 @@ __result, __binary_pred, _IterType());\n     __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       for (_RandomAccessIter __i = __first; __i != __last; ++__i)\n \t__unguarded_linear_insert(__i, _ValueType(*__i));\n     }\n@@ -1417,7 +1865,7 @@ __result, __binary_pred, _IterType());\n \t\t\t       _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-      \n+\n       for (_RandomAccessIter __i = __first; __i != __last; ++__i)\n \t__unguarded_linear_insert(__i, _ValueType(*__i), __comp);\n     }\n@@ -1462,7 +1910,7 @@ __result, __binary_pred, _IterType());\n \t\t     _Size __depth_limit)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       while (__last - __first > __stl_threshold) {\n \tif (__depth_limit == 0) {\n \t  partial_sort(__first, __last, __last);\n@@ -1485,7 +1933,7 @@ __result, __binary_pred, _IterType());\n \t\t     _Size __depth_limit, _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       while (__last - __first > __stl_threshold) {\n \tif (__depth_limit == 0) {\n \t  partial_sort(__first, __last, __last, __comp);\n@@ -1508,29 +1956,29 @@ __result, __binary_pred, _IterType());\n     sort(_RandomAccessIter __first, _RandomAccessIter __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>)\n-    \n+\n       if (__first != __last) {\n \t__introsort_loop(__first, __last, __lg(__last - __first) * 2);\n \t__final_insertion_sort(__first, __last);\n       }\n     }\n-    \n+\n   template<typename _RandomAccessIter, typename _Compare>\n     inline void\n     sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _ValueType>)\n-    \n+\n       if (__first != __last) {\n \t__introsort_loop(__first, __last, __lg(__last - __first) * 2, __comp);\n \t__final_insertion_sort(__first, __last, __comp);\n@@ -1576,7 +2024,7 @@ __result, __binary_pred, _IterType());\n   template<typename _RandomAccessIter1, typename _RandomAccessIter2,\n \t   typename _Distance>\n     void\n-    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last, \n+    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,\n \t\t      _RandomAccessIter2 __result, _Distance __step_size)\n     {\n       _Distance __two_step = 2 * __step_size;\n@@ -1596,7 +2044,7 @@ __result, __binary_pred, _IterType());\n   template<typename _RandomAccessIter1, typename _RandomAccessIter2,\n \t   typename _Distance, typename _Compare>\n     void\n-    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last, \n+    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,\n \t\t      _RandomAccessIter2 __result, _Distance __step_size,\n \t\t      _Compare __comp)\n     {\n@@ -1618,7 +2066,7 @@ __result, __binary_pred, _IterType());\n     }\n \n   const int __stl_chunk_size = 7;\n-\t  \n+\n   template<typename _RandomAccessIter, typename _Distance>\n     void\n     __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,\n@@ -1700,7 +2148,7 @@ __result, __binary_pred, _IterType());\n \t__merge_sort_with_buffer(__first, __middle, __buffer);\n \t__merge_sort_with_buffer(__middle, __last, __buffer);\n       }\n-      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), \n+      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),\n                        _Distance(__last - __middle), __buffer, __buffer_size);\n     }\n \n@@ -1714,16 +2162,16 @@ __result, __binary_pred, _IterType());\n       _Distance __len = (__last - __first + 1) / 2;\n       _RandomAccessIter __middle = __first + __len;\n       if (__len > __buffer_size) {\n-\t__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, \n+\t__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,\n                                __comp);\n-\t__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, \n+\t__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,\n                                __comp);\n       }\n       else {\n \t__merge_sort_with_buffer(__first, __middle, __buffer, __comp);\n \t__merge_sort_with_buffer(__middle, __last, __buffer, __comp);\n       }\n-      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), \n+      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),\n                        _Distance(__last - __middle), __buffer, __buffer_size,\n                        __comp);\n     }\n@@ -1734,36 +2182,36 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;\n-    \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>)\n-    \n+\n       _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);\n       if (buf.begin() == 0)\n \t__inplace_stable_sort(__first, __last);\n-      else \n+      else\n \t__stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()));\n     }\n-    \n+\n   template<typename _RandomAccessIter, typename _Compare>\n     inline void\n     stable_sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;\n-    \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t\t\t\t  _ValueType, _ValueType>)\n-    \n+\n       _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);\n       if (buf.begin() == 0)\n \t__inplace_stable_sort(__first, __last, __comp);\n-      else \n+      else\n \t__stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()),\n \t\t\t       __comp);\n     }\n@@ -1775,19 +2223,19 @@ __result, __binary_pred, _IterType());\n \t\t _RandomAccessIter __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>)\n-    \n+\n       make_heap(__first, __middle);\n       for (_RandomAccessIter __i = __middle; __i < __last; ++__i)\n-\tif (*__i < *__first) \n+\tif (*__i < *__first)\n \t  __pop_heap(__first, __middle, __i, _ValueType(*__i));\n       sort_heap(__first, __middle);\n     }\n-    \n+\n   template<typename _RandomAccessIter, typename _Compare>\n     void\n     partial_sort(_RandomAccessIter __first,\n@@ -1796,13 +2244,13 @@ __result, __binary_pred, _IterType());\n \t\t _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-    \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t\t\t\t  _ValueType, _ValueType>)\n-    \n+\n       make_heap(__first, __middle, __comp);\n       for (_RandomAccessIter __i = __middle; __i < __last; ++__i)\n \tif (__comp(*__i, *__first))\n@@ -1819,13 +2267,13 @@ __result, __binary_pred, _IterType());\n       typedef typename iterator_traits<_InputIter>::value_type _InputValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_InputIteratorConcept<_InputIter>)\n       __glibcpp_function_requires(_ConvertibleConcept<_InputValueType, _OutputValueType>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_OutputValueType>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_InputValueType>)\n-    \n+\n       if (__result_first == __result_last) return __result_last;\n       _RandomAccessIter __result_real_last = __result_first;\n       while(__first != __last && __result_real_last != __result_last) {\n@@ -1835,7 +2283,7 @@ __result, __binary_pred, _IterType());\n       }\n       make_heap(__result_first, __result_real_last);\n       while (__first != __last) {\n-\tif (*__first < *__result_first) \n+\tif (*__first < *__result_first)\n \t  __adjust_heap(__result_first, _DistanceType(0),\n \t\t\t_DistanceType(__result_real_last - __result_first),\n \t\t\t_InputValueType(*__first));\n@@ -1855,14 +2303,14 @@ __result, __binary_pred, _IterType());\n       typedef typename iterator_traits<_InputIter>::value_type _InputValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;\n       typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;\n-\t\n+\n       // concept requirements\n       __glibcpp_function_requires(_InputIteratorConcept<_InputIter>)\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<_RandomAccessIter>)\n       __glibcpp_function_requires(_ConvertibleConcept<_InputValueType, _OutputValueType>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t  _OutputValueType, _OutputValueType>)\n-    \n+\n       if (__result_first == __result_last) return __result_last;\n       _RandomAccessIter __result_real_last = __result_first;\n       while(__first != __last && __result_real_last != __result_last) {\n@@ -1890,11 +2338,11 @@ __result, __binary_pred, _IterType());\n \t\t_RandomAccessIter __last)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<_RandomAccessIter>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>)\n-    \n+\n       while (__last - __first > 3) {\n \t_RandomAccessIter __cut =\n \t  __unguarded_partition(__first, __last,\n@@ -1903,7 +2351,7 @@ __result, __binary_pred, _IterType());\n \t\t\t\t\t\t    *(__last - 1))));\n \tif (__cut <= __nth)\n \t  __first = __cut;\n-\telse \n+\telse\n \t  __last = __cut;\n       }\n       __insertion_sort(__first, __last);\n@@ -1917,23 +2365,23 @@ __result, __binary_pred, _IterType());\n \t\t\t    _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;\n-\t\n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<_RandomAccessIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t  _ValueType, _ValueType>)\n-    \n+\n       while (__last - __first > 3) {\n \t_RandomAccessIter __cut =\n \t  __unguarded_partition(__first, __last,\n \t\t\t\t_ValueType(__median(*__first,\n-\t\t\t\t\t\t    *(__first + (__last - __first)/2), \n+\t\t\t\t\t\t    *(__first + (__last - __first)/2),\n \t\t\t\t\t\t    *(__last - 1),\n \t\t\t\t\t\t    __comp)),\n \t\t\t\t__comp);\n \tif (__cut <= __nth)\n \t  __first = __cut;\n-\telse \n+\telse\n \t  __last = __cut;\n       }\n       __insertion_sort(__first, __last, __comp);\n@@ -1948,7 +2396,7 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-    \n+\n       // concept requirements\n       // Note that these are slightly stricter than those of the 4-argument\n       // version, defined next.  The difference is in the strictness of the\n@@ -1957,11 +2405,11 @@ __result, __binary_pred, _IterType());\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_Tp>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -1984,15 +2432,15 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _Tp>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -2014,17 +2462,17 @@ __result, __binary_pred, _IterType());\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       // See comments on lower_bound.\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_Tp>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -2039,23 +2487,23 @@ __result, __binary_pred, _IterType());\n       }\n       return __first;\n     }\n-    \n+\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     _ForwardIter\n     upper_bound(_ForwardIter __first, _ForwardIter __last,\n \t\tconst _Tp& __val, _Compare __comp)\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _ValueType>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -2070,24 +2518,24 @@ __result, __binary_pred, _IterType());\n       }\n       return __first;\n     }\n-    \n+\n   template<typename _ForwardIter, typename _Tp>\n     pair<_ForwardIter, _ForwardIter>\n     equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       // See comments on lower_bound.\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_Tp>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle, __left, __right;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -2108,24 +2556,24 @@ __result, __binary_pred, _IterType());\n       }\n       return pair<_ForwardIter, _ForwardIter>(__first, __first);\n     }\n-    \n+\n   template<typename _ForwardIter, typename _Tp, typename _Compare>\n     pair<_ForwardIter, _ForwardIter>\n     equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,\n \t\t_Compare __comp)\n     {\n       typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n       typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _Tp>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _ValueType>)\n-    \n+\n       _DistanceType __len = distance(__first, __last);\n       _DistanceType __half;\n       _ForwardIter __middle, __left, __right;\n-    \n+\n       while (__len > 0) {\n \t__half = __len >> 1;\n \t__middle = __first;\n@@ -2145,7 +2593,7 @@ __result, __binary_pred, _IterType());\n \t}\n       }\n       return pair<_ForwardIter, _ForwardIter>(__first, __first);\n-    } \n+    }\n \n   template<typename _ForwardIter, typename _Tp>\n     bool\n@@ -2245,7 +2693,7 @@ __result, __binary_pred, _IterType());\n       return copy(__first2, __last2, copy(__first1, __last1, __result));\n     }\n \n-  // inplace_merge and its auxiliary functions. \n+  // inplace_merge and its auxiliary functions.\n \n   template<typename _BidirectionalIter, typename _Distance>\n     void\n@@ -2288,10 +2736,10 @@ __result, __binary_pred, _IterType());\n \n   template<typename _BidirectionalIter, typename _Distance, typename _Compare>\n     void\n-    __merge_without_buffer(_BidirectionalIter __first, \n-                           _BidirectionalIter __middle, \n-\t\t\t   _BidirectionalIter __last, \n-\t\t\t   _Distance __len1, _Distance __len2, \n+    __merge_without_buffer(_BidirectionalIter __first,\n+                           _BidirectionalIter __middle,\n+\t\t\t   _BidirectionalIter __last,\n+\t\t\t   _Distance __len1, _Distance __len2,\n \t\t\t   _Compare __comp)\n     {\n       if (__len1 == 0 || __len2 == 0)\n@@ -2415,10 +2863,10 @@ __result, __binary_pred, _IterType());\n \n   template<typename _BidirectionalIter, typename _Distance, typename _Pointer>\n     void\n-    __merge_adaptive(_BidirectionalIter __first, \n-                     _BidirectionalIter __middle, \n-\t\t     _BidirectionalIter __last, \n-\t\t     _Distance __len1, _Distance __len2, \n+    __merge_adaptive(_BidirectionalIter __first,\n+                     _BidirectionalIter __middle,\n+\t\t     _BidirectionalIter __last,\n+\t\t     _Distance __len1, _Distance __len2,\n \t\t     _Pointer __buffer, _Distance __buffer_size)\n     {\n \t  if (__len1 <= __len2 && __len1 <= __buffer_size) {\n@@ -2438,7 +2886,7 @@ __result, __binary_pred, _IterType());\n \t\t  __len11 = __len1 / 2;\n \t\t  advance(__first_cut, __len11);\n \t\t  __second_cut = lower_bound(__middle, __last, *__first_cut);\n-\t\t  __len22 = distance(__middle, __second_cut); \n+\t\t  __len22 = distance(__middle, __second_cut);\n \t    }\n \t    else {\n \t\t  __len22 = __len2 / 2;\n@@ -2460,11 +2908,11 @@ __result, __binary_pred, _IterType());\n   template<typename _BidirectionalIter, typename _Distance, typename _Pointer,\n \t   typename _Compare>\n     void\n-    __merge_adaptive(_BidirectionalIter __first, \n-                     _BidirectionalIter __middle, \n-\t\t     _BidirectionalIter __last, \n-\t\t     _Distance __len1, _Distance __len2, \n-\t\t     _Pointer __buffer, _Distance __buffer_size, \n+    __merge_adaptive(_BidirectionalIter __first,\n+                     _BidirectionalIter __middle,\n+\t\t     _BidirectionalIter __last,\n+\t\t     _Distance __len1, _Distance __len2,\n+\t\t     _Pointer __buffer, _Distance __buffer_size,\n \t\t     _Compare __comp)\n     {\n \t  if (__len1 <= __len2 && __len1 <= __buffer_size) {\n@@ -2485,7 +2933,7 @@ __result, __binary_pred, _IterType());\n \t\t  __len11 = __len1 / 2;\n \t\t  advance(__first_cut, __len11);\n \t\t  __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);\n-\t\t  __len22 = distance(__middle, __second_cut);   \n+\t\t  __len22 = distance(__middle, __second_cut);\n \t    }\n \t    else {\n \t\t  __len22 = __len2 / 2;\n@@ -2514,18 +2962,18 @@ __result, __binary_pred, _IterType());\n           _ValueType;\n       typedef typename iterator_traits<_BidirectionalIter>::difference_type\n           _DistanceType;\n-    \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n \t    _BidirectionalIter>)\n       __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>)\n-    \n+\n       if (__first == __middle || __middle == __last)\n \treturn;\n-    \n+\n       _DistanceType __len1 = distance(__first, __middle);\n       _DistanceType __len2 = distance(__middle, __last);\n-    \n+\n       _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);\n       if (__buf.begin() == 0)\n \t__merge_without_buffer(__first, __middle, __last, __len1, __len2);\n@@ -2545,19 +2993,19 @@ __result, __binary_pred, _IterType());\n           _ValueType;\n       typedef typename iterator_traits<_BidirectionalIter>::difference_type\n           _DistanceType;\n-      \n+\n       // concept requirements\n       __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n \t    _BidirectionalIter>)\n       __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n \t    _ValueType, _ValueType>)\n-    \n+\n       if (__first == __middle || __middle == __last)\n \treturn;\n-    \n+\n       _DistanceType __len1 = distance(__first, __middle);\n       _DistanceType __len2 = distance(__middle, __last);\n-    \n+\n       _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);\n       if (__buf.begin() == 0)\n \t__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);\n@@ -2589,7 +3037,7 @@ __result, __binary_pred, _IterType());\n       while (__first1 != __last1 && __first2 != __last2)\n \tif (*__first2 < *__first1)\n \t  return false;\n-\telse if(*__first1 < *__first2) \n+\telse if(*__first1 < *__first2)\n \t  ++__first1;\n \telse\n \t  ++__first1, ++__first2;\n@@ -2615,7 +3063,7 @@ __result, __binary_pred, _IterType());\n       while (__first1 != __last1 && __first2 != __last2)\n \tif (__comp(*__first2, *__first1))\n \t  return false;\n-\telse if(__comp(*__first1, *__first2)) \n+\telse if(__comp(*__first1, *__first2))\n \t  ++__first1;\n \telse\n \t  ++__first1, ++__first2;\n@@ -2714,10 +3162,10 @@ __result, __binary_pred, _IterType());\n       __glibcpp_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIter1>::value_type>)\n \n-      while (__first1 != __last1 && __first2 != __last2) \n-\tif (*__first1 < *__first2) \n+      while (__first1 != __last1 && __first2 != __last2)\n+\tif (*__first1 < *__first2)\n \t  ++__first1;\n-\telse if (*__first2 < *__first1) \n+\telse if (*__first2 < *__first1)\n \t  ++__first2;\n \telse {\n \t  *__result = *__first1;\n@@ -2793,11 +3241,11 @@ __result, __binary_pred, _IterType());\n       return copy(__first1, __last1, __result);\n     }\n \n-  template<typename _InputIter1, typename _InputIter2, typename _OutputIter, \n+  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,\n \t   typename _Compare>\n     _OutputIter\n     set_difference(_InputIter1 __first1, _InputIter1 __last1,\n-\t\t   _InputIter2 __first2, _InputIter2 __last2, \n+\t\t   _InputIter2 __first2, _InputIter2 __last2,\n \t\t   _OutputIter __result, _Compare __comp)\n     {\n       // concept requirements\n@@ -2828,7 +3276,7 @@ __result, __binary_pred, _IterType());\n     }\n \n   template<typename _InputIter1, typename _InputIter2, typename _OutputIter>\n-    _OutputIter \n+    _OutputIter\n     set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n \t\t\t     _InputIter2 __first2, _InputIter2 __last2,\n \t\t\t     _OutputIter __result)\n@@ -2864,7 +3312,7 @@ __result, __binary_pred, _IterType());\n \n   template<typename _InputIter1, typename _InputIter2, typename _OutputIter,\n \t   typename _Compare>\n-    _OutputIter \n+    _OutputIter\n     set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n \t\t\t     _InputIter2 __first2, _InputIter2 __last2,\n \t\t\t     _OutputIter __result,\n@@ -2914,7 +3362,7 @@ __result, __binary_pred, _IterType());\n \n       if (__first == __last) return __first;\n       _ForwardIter __result = __first;\n-      while (++__first != __last) \n+      while (++__first != __last)\n \tif (*__result < *__first)\n \t  __result = __first;\n       return __result;\n@@ -2933,7 +3381,7 @@ __result, __binary_pred, _IterType());\n \n       if (__first == __last) return __first;\n       _ForwardIter __result = __first;\n-      while (++__first != __last) \n+      while (++__first != __last)\n \tif (__comp(*__result, *__first)) __result = __first;\n       return __result;\n     }\n@@ -2949,7 +3397,7 @@ __result, __binary_pred, _IterType());\n \n       if (__first == __last) return __first;\n       _ForwardIter __result = __first;\n-      while (++__first != __last) \n+      while (++__first != __last)\n \tif (*__first < *__result)\n \t  __result = __first;\n       return __result;\n@@ -2968,13 +3416,13 @@ __result, __binary_pred, _IterType());\n \n       if (__first == __last) return __first;\n       _ForwardIter __result = __first;\n-      while (++__first != __last) \n+      while (++__first != __last)\n \tif (__comp(*__first, *__result))\n \t  __result = __first;\n       return __result;\n     }\n \n-  // next_permutation and prev_permutation, with and without an explicitly \n+  // next_permutation and prev_permutation, with and without an explicitly\n   // supplied comparison function.\n \n   template<typename _BidirectionalIter>\n@@ -3139,7 +3587,7 @@ __result, __binary_pred, _IterType());\n \t    typename iterator_traits<_InputIter>::value_type,\n \t    typename iterator_traits<_ForwardIter>::value_type>)\n \n-      for ( ; __first1 != __last1; ++__first1) \n+      for ( ; __first1 != __last1; ++__first1)\n \tfor (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)\n \t  if (*__first1 == *__iter)\n \t    return __first1;\n@@ -3162,7 +3610,7 @@ __result, __binary_pred, _IterType());\n \t    typename iterator_traits<_InputIter>::value_type,\n \t    typename iterator_traits<_ForwardIter>::value_type>)\n \n-      for ( ; __first1 != __last1; ++__first1) \n+      for ( ; __first1 != __last1; ++__first1)\n \tfor (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)\n \t  if (__comp(*__first1, *__iter))\n \t    return __first1;\n@@ -3175,7 +3623,7 @@ __result, __binary_pred, _IterType());\n   // the *last* possible match.  Note that find_end for bidirectional iterators\n   // is much faster than for forward iterators.\n \n-  // find_end for forward iterators. \n+  // find_end for forward iterators.\n   template<typename _ForwardIter1, typename _ForwardIter2>\n     _ForwardIter1\n     __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n@@ -3259,7 +3707,7 @@ __result, __binary_pred, _IterType());\n     _BidirectionalIter1\n     __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n \t       _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,\n-\t       bidirectional_iterator_tag, bidirectional_iterator_tag, \n+\t       bidirectional_iterator_tag, bidirectional_iterator_tag,\n \t       _BinaryPredicate __comp)\n     {\n       // concept requirements\n@@ -3287,8 +3735,8 @@ __result, __binary_pred, _IterType());\n   // Dispatching functions for find_end.\n \n   template<typename _ForwardIter1, typename _ForwardIter2>\n-    inline _ForwardIter1 \n-    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1, \n+    inline _ForwardIter1\n+    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n \t     _ForwardIter2 __first2, _ForwardIter2 __last2)\n     {\n       // concept requirements\n@@ -3303,10 +3751,10 @@ __result, __binary_pred, _IterType());\n \t\t\t__iterator_category(__first2));\n     }\n \n-  template<typename _ForwardIter1, typename _ForwardIter2, \n+  template<typename _ForwardIter1, typename _ForwardIter2,\n \t   typename _BinaryPredicate>\n-    inline _ForwardIter1 \n-    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1, \n+    inline _ForwardIter1\n+    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n \t     _ForwardIter2 __first2, _ForwardIter2 __last2,\n \t     _BinaryPredicate __comp)\n     {\n@@ -3327,6 +3775,3 @@ __result, __binary_pred, _IterType());\n \n #endif /* __GLIBCPP_INTERNAL_ALGO_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}]}