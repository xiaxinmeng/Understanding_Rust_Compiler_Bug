{"sha": "9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhNWZmMGYyNTk4NTQ2OGQ4NDUzNjBhZWUxZDExY2IzYTBmMDljOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-19T15:45:53Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-19T15:45:53Z"}, "message": "vec.h: Propagate location information properly.\n\n.:\t* vec.h: Propagate location information properly.\n\t(VEC_T_iterate): Add result pointer parameter.\n\t(VEC_T_space): New.\n\t(VEC_T_reserve): Use it.\ncp:\n\t* class.c (add_method): Delay adding the slot until the end.\n\t(determine_primary_base): Adjust VEC_iterate invokation.\n\t(resort_type_method_vec, finish_struct_methods, warn_hidden,\n\twalk_subobject_offsets, end_of_class, warn_about_ambiguous_bases,\n\tbuild_vtbl_initializer): Likewise.\n\t* init.c (sort_mem_initializers, build_delete, push_base_cleanups,\n\tbuild_vbase_delete): Likewise.\n\t* method.c (do_build_copy_constructor): Likewise.\n\t* name-lookup.c (new_class_binding, print_binding_level,\n\tpoplevel_class, store_class_bindings, push_to_top_level,\n\tpop_from_top_level): Likewise.\n\t* pt.c (check_explicit_specialization): Likewise.\n\t* search.c (lookup_conversion_operator, lookup_fnfields_1,\n\tget_pure_virtuals, add_conversions, dfs_check_overlap,\n\tbinfo_for_vbase): Likewise.\n\nFrom-SVN: r84924", "tree": {"sha": "46c29242b882c33b8a12977fcf57e4b3cd23ce78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c29242b882c33b8a12977fcf57e4b3cd23ce78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/comments", "author": null, "committer": null, "parents": [{"sha": "6df91b0004725e310b8dc7fa463745a703c1c059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df91b0004725e310b8dc7fa463745a703c1c059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df91b0004725e310b8dc7fa463745a703c1c059"}], "stats": {"total": 415, "additions": 259, "deletions": 156}, "files": [{"sha": "7217195f06967a07853c8e4a44cc3a971a9e802a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -1,3 +1,10 @@\n+2004-07-19  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.h: Propagate location information properly.\n+\t(VEC_T_iterate): Add result pointer parameter.\n+\t(VEC_T_space): New.\n+\t(VEC_T_reserve): Use it.\n+\n 2004-07-19  Daniel Jacobowitz  <dan@debian.org>\n \n \t* Makefile.in (c-format.o): Depend on c-format.h."}, {"sha": "dfd8d26229a32199c5357cbe4fa0d333bff0cb06", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -1,3 +1,21 @@\n+2004-07-19  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (add_method): Delay adding the slot until the end.\n+\t(determine_primary_base): Adjust VEC_iterate invokation.\n+\t(resort_type_method_vec, finish_struct_methods, warn_hidden,\n+\twalk_subobject_offsets, end_of_class, warn_about_ambiguous_bases,\n+\tbuild_vtbl_initializer): Likewise.\n+\t* init.c (sort_mem_initializers, build_delete, push_base_cleanups,\n+\tbuild_vbase_delete): Likewise.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t* name-lookup.c (new_class_binding, print_binding_level,\n+\tpoplevel_class, store_class_bindings, push_to_top_level,\n+\tpop_from_top_level): Likewise.\n+\t* pt.c (check_explicit_specialization): Likewise.\n+\t* search.c (lookup_conversion_operator, lookup_fnfields_1,\n+\tget_pure_virtuals, add_conversions, dfs_check_overlap,\n+\tbinfo_for_vbase): Likewise.\n+\n 2004-07-19  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/12170"}, {"sha": "69f6d9e6e6fd504ce9e6c954934131203710b23f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -801,12 +801,13 @@ void\n add_method (tree type, tree method)\n {\n   int using;\n-  size_t len;\n-  size_t slot;\n+  unsigned slot;\n   tree overload;\n   int template_conv_p;\n   VEC(tree) *method_vec;\n   bool complete_p;\n+  bool insert_p = false;\n+  tree current_fns;\n \n   if (method == error_mark_node)\n     return;\n@@ -830,8 +831,6 @@ add_method (tree type, tree method)\n       CLASSTYPE_METHOD_VEC (type) = method_vec;\n     }\n \n-  len = VEC_length (tree, method_vec);\n-\n   /* Constructors and destructors go in special slots.  */\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n     slot = CLASSTYPE_CONSTRUCTOR_SLOT;\n@@ -848,13 +847,13 @@ add_method (tree type, tree method)\n     }\n   else\n     {\n-      bool insert_p = true;\n       bool conv_p = DECL_CONV_FN_P (method);\n       tree m;\n \n+      insert_p = true;\n       /* See if we already have an entry with this name.  */\n       for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t   (m = VEC_iterate (tree, method_vec, slot));\n+\t   VEC_iterate (tree, method_vec, slot, m);\n \t   ++slot)\n \t{\n \t  m = OVL_CURRENT (m);\n@@ -877,25 +876,9 @@ add_method (tree type, tree method)\n \t      && DECL_NAME (m) > DECL_NAME (method))\n \t    break;\n \t}\n-\n-\t/* If we need a new slot, make room.  */\n-\tif (insert_p)\n-\t  {\n-\t    /* We expect to add few methods in the COMPLETE_P case, so\n-\t       just make room for one more method.  */\n-\t    if (complete_p)\n-\t      VEC_reserve (tree, method_vec, 1);\n-\t    if (slot == len)\n-\t      VEC_safe_push (tree, method_vec, NULL_TREE);\n-\t    else\n-\t      VEC_safe_insert (tree, method_vec, slot, NULL_TREE);\n-\t    len++;\n-\t    /* Inserting a new slot may have caused the vector to be\n-\t       reallocated.  */\n-\t    CLASSTYPE_METHOD_VEC (type) = method_vec;\n-\t  }\n     }\n-      \n+  current_fns = insert_p ? NULL_TREE : VEC_index (tree, method_vec, slot);\n+  \n   if (processing_template_decl)\n     /* TYPE is a template class.  Don't issue any errors now; wait\n        until instantiation time to complain.  */\n@@ -905,9 +888,7 @@ add_method (tree type, tree method)\n       tree fns;\n \n       /* Check to see if we've already got this method.  */\n-      for (fns = VEC_index (tree, method_vec, slot);\n-\t   fns;\n-\t   fns = OVL_NEXT (fns))\n+      for (fns = current_fns; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  tree parms1;\n@@ -975,14 +956,25 @@ add_method (tree type, tree method)\n     }\n \n   /* Add the new binding.  */ \n-  overload = build_overload (method, VEC_index (tree, method_vec, slot));\n-  if (!DECL_CONSTRUCTOR_P (method)\n-      && !DECL_DESTRUCTOR_P (method)\n-      && !complete_p)\n+  overload = build_overload (method, current_fns);\n+  \n+  if (slot >= CLASSTYPE_FIRST_CONVERSION_SLOT && !complete_p)\n     push_class_level_binding (DECL_NAME (method), overload);\n \n-  /* Actually insert the new method.  */\n-  VEC_replace (tree, method_vec, slot, overload);\n+  if (insert_p)\n+    {\n+      /* We only expect to add few methods in the COMPLETE_P case, so\n+\t just make room for one more method in that case.  */\n+      if (VEC_reserve (tree, method_vec, complete_p ? 1 : -1))\n+\tCLASSTYPE_METHOD_VEC (type) = method_vec;\n+      if (slot == VEC_length (tree, method_vec))\n+\tVEC_quick_push (tree, method_vec, overload);\n+      else\n+\tVEC_quick_insert (tree, method_vec, slot, overload);\n+    }\n+  else\n+    /* Replace the current slot. */\n+    VEC_replace (tree, method_vec, slot, overload);\n }\n \n /* Subroutines of finish_struct.  */\n@@ -1275,8 +1267,9 @@ static void\n determine_primary_base (tree t)\n {\n   unsigned i, n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n-  tree type_binfo;\n+  tree type_binfo = TYPE_BINFO (t);\n   tree vbase_binfo;\n+  VEC(tree) *vbases;\n \n   /* If there are no baseclasses, there is certainly no primary base.  */\n   if (n_baseclasses == 0)\n@@ -1324,8 +1317,8 @@ determine_primary_base (tree t)\n \n   /* Find the indirect primary bases - those virtual bases which are primary\n      bases of something else in this hierarchy.  */\n-  for (i = 0; (vbase_binfo = VEC_iterate\n-\t       (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n+       VEC_iterate (tree, vbases, i, vbase_binfo); i++)\n     {\n       unsigned j;\n \n@@ -1335,11 +1328,12 @@ determine_primary_base (tree t)\n       for (j = 0; j != n_baseclasses; ++j) \n \t{\n \t  unsigned k;\n+\t  VEC (tree) *base_vbases;\n \t  tree base_vbase_binfo;\n \t  tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), j));\n \t  \n-\t  for (k = 0; (base_vbase_binfo = VEC_iterate\n-\t\t       (tree, CLASSTYPE_VBASECLASSES (basetype), k)); k++)\n+\t  for (base_vbases = CLASSTYPE_VBASECLASSES (basetype), k = 0;\n+\t       VEC_iterate (tree, base_vbases, k, base_vbase_binfo); k++)\n \t    {\n \t      if (BINFO_PRIMARY_P (base_vbase_binfo)\n \t\t  && same_type_p (BINFO_TYPE (base_vbase_binfo),\n@@ -1677,7 +1671,7 @@ resort_type_method_vec (void* obj,\n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       (fn = VEC_iterate (tree, method_vec, slot));\n+       VEC_iterate (tree, method_vec, slot, fn);\n        ++slot)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n       break;\n@@ -1738,8 +1732,8 @@ finish_struct_methods (tree t)\n \n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n-  for (slot = 2;\n-       (fn_fields = VEC_iterate (tree, method_vec, slot));\n+  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+       VEC_iterate (tree, method_vec, slot, fn_fields);\n        ++slot)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn_fields)))\n       break;\n@@ -2369,7 +2363,7 @@ warn_hidden (tree t)\n \n   /* We go through each separately named virtual function.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-       (fns = VEC_iterate (tree, method_vec, i));\n+       VEC_iterate (tree, method_vec, i, fns);\n        ++i)\n     {\n       tree fn;\n@@ -3229,15 +3223,16 @@ walk_subobject_offsets (tree type,\n       if (abi_version_at_least (2) && CLASSTYPE_VBASECLASSES (type))\n \t{\n \t  unsigned ix;\n+\t  VEC (tree) *vbases;\n \n \t  /* Iterate through the virtual base classes of TYPE.  In G++\n \t     3.2, we included virtual bases in the direct base class\n \t     loop above, which results in incorrect results; the\n \t     correct offsets for virtual bases are only known when\n \t     working with the most derived type.  */\n \t  if (vbases_p)\n-\t    for (ix = 0; (binfo = VEC_iterate\n-\t\t\t  (tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n+\t    for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;\n+\t\t VEC_iterate (tree, vbases, ix, binfo); ix++)\n \t      {\n \t\tr = walk_subobject_offsets (binfo,\n \t\t\t\t\t    f,\n@@ -4402,7 +4397,9 @@ static tree\n end_of_class (tree t, int include_virtuals_p)\n {\n   tree result = size_zero_node;\n+  VEC (tree) *vbases;\n   tree binfo;\n+  tree base_binfo;\n   tree offset;\n   int i;\n \n@@ -4422,10 +4419,10 @@ end_of_class (tree t, int include_virtuals_p)\n \n   /* G++ 3.2 did not check indirect virtual bases.  */\n   if (abi_version_at_least (2) && include_virtuals_p)\n-    for (i = 0; (binfo = VEC_iterate\n-\t\t (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n+    for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n+\t VEC_iterate (tree, vbases, i, base_binfo); i++)\n       {\n-\toffset = end_of_base (binfo);\n+\toffset = end_of_base (base_binfo);\n \tif (INT_CST_LT_UNSIGNED (result, offset))\n \t  result = offset;\n       }\n@@ -4447,11 +4444,13 @@ static void\n warn_about_ambiguous_bases (tree t)\n {\n   int i;\n+  VEC (tree) *vbases;\n   tree basetype;\n   tree binfo;\n \n   /* Check direct bases.  */\n-  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n+  for (i = 0;\n+       i < BINFO_N_BASE_BINFOS (TYPE_BINFO (t)); ++i)\n     {\n       basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), i));\n \n@@ -4462,8 +4461,8 @@ warn_about_ambiguous_bases (tree t)\n \n   /* Check for ambiguous virtual bases.  */\n   if (extra_warnings)\n-    for (i = 0; (binfo = VEC_iterate\n-\t\t (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n+    for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n+\t VEC_iterate (tree, vbases, i, binfo); i++)\n       {\n \tbasetype = BINFO_TYPE (binfo);\n \t\n@@ -7237,7 +7236,8 @@ build_vtbl_initializer (tree binfo,\n   vtbl_init_data vid;\n   unsigned ix;\n   tree vbinfo;\n-\n+  VEC (tree) *vbases;\n+  \n   /* Initialize VID.  */\n   memset (&vid, 0, sizeof (vid));\n   vid.binfo = binfo;\n@@ -7262,8 +7262,8 @@ build_vtbl_initializer (tree binfo,\n   \n   /* Clear BINFO_VTABLE_PATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n-  for (ix = 0; (vbinfo = VEC_iterate\n-\t\t(tree, CLASSTYPE_VBASECLASSES (t), ix)); ix++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n+       VEC_iterate (tree, vbases, ix, vbinfo); ix++)\n     BINFO_VTABLE_PATH_MARKED (vbinfo) = 0;\n \n   /* If the target requires padding between data entries, add that now.  */"}, {"sha": "988bfba1cd09d1dec75aa01d97badc4816006e1e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -460,6 +460,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n   tree base;\n   tree sorted_inits;\n   tree next_subobject;\n+  VEC (tree) *vbases;\n   int i;\n   int uses_unions_p;\n \n@@ -470,8 +471,8 @@ sort_mem_initializers (tree t, tree mem_inits)\n   sorted_inits = NULL_TREE;\n   \n   /* Process the virtual bases.  */\n-  for (i = 0; (base = VEC_iterate\n-\t       (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n+       VEC_iterate (tree, vbases, i, base); i++)\n     sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n   \n   /* Process the direct bases.  */\n@@ -2857,10 +2858,11 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n void\n push_base_cleanups (void)\n {\n-  tree binfos;\n+  tree binfos, base_binfo;\n   int i, n_baseclasses;\n   tree member;\n   tree expr;\n+  VEC (tree) *vbases;\n \n   /* Run destructors for all virtual baseclasses.  */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n@@ -2872,16 +2874,15 @@ push_base_cleanups (void)\n \n       /* The CLASSTYPE_VBASECLASSES vector is in initialization\n \t order, which is also the right order for pushing cleanups.  */\n-      for (i = 0; (binfos = VEC_iterate\n-\t\t   (tree, CLASSTYPE_VBASECLASSES (current_class_type), i));\n-\t   i++)\n+      for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n+\t   VEC_iterate (tree, vbases, i, base_binfo); i++)\n \t{\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (binfos)))\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t    {\n \t      expr = build_special_member_call (current_class_ref, \n \t\t\t\t\t\tbase_dtor_identifier,\n \t\t\t\t\t\tNULL_TREE,\n-\t\t\t\t\t\tbinfos,\n+\t\t\t\t\t\tbase_binfo,\n \t\t\t\t\t\t(LOOKUP_NORMAL \n \t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n \t      expr = build (COND_EXPR, void_type_node, cond,\n@@ -2938,13 +2939,14 @@ build_vbase_delete (tree type, tree decl)\n   unsigned ix;\n   tree binfo;\n   tree result;\n+  VEC (tree) *vbases;\n   tree addr = build_unary_op (ADDR_EXPR, decl, 0);\n \n   my_friendly_assert (addr != error_mark_node, 222);\n \n   result = convert_to_void (integer_zero_node, NULL);\n-  for (ix = 0; (binfo = VEC_iterate\n-\t\t(tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;\n+       VEC_iterate (tree, vbases, ix, binfo); ix++)\n     {\n       tree base_addr = convert_force\n \t(build_pointer_type (BINFO_TYPE (binfo)), addr, 0);"}, {"sha": "802d4c023fe68a4abbce52eb3d8405793ebf35a7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -521,15 +521,15 @@ do_build_copy_constructor (tree fndecl)\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n       tree binfo;\n+      VEC (tree) *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n \t to their type so that we get their copy constructor and not\n \t another constructor that takes current_class_type.  We must\n \t deal with the binfo's directly as a direct base might be\n \t inaccessible due to ambiguity.  */\n-      for (i = 0; (binfo = VEC_iterate\n-\t\t   (tree, CLASSTYPE_VBASECLASSES (current_class_type), i));\n-\t   i++)\n+      for (vbases = CLASSTYPE_VBASECLASSES (current_class_type), i = 0;\n+\t   VEC_iterate (tree, vbases, i, binfo); i++)\n \t{\n \t  member_init_list \n \t    = tree_cons (binfo,"}, {"sha": "6cbebb3abbace971fff3053f0c5c03255a90c90c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -387,7 +387,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n \t  size_t i;\n \t  \n \t  for (i = 0;\n-\t       (cb = VEC_iterate (cp_class_binding, scope->class_shadowed, i));\n+\t       VEC_iterate (cp_class_binding, scope->class_shadowed, i, cb);\n \t       i++)\n \t    {\n \t      cxx_binding **b;\n@@ -1656,9 +1656,7 @@ print_binding_level (struct cp_binding_level* lvl)\n       cp_class_binding *b;\n       fprintf (stderr, \" class-shadowed:\");\n       for (i = 0; \n-\t   (b = VEC_iterate(cp_class_binding, \n-\t\t\t    lvl->class_shadowed,\n-\t\t\t    i));\n+\t   VEC_iterate(cp_class_binding, lvl->class_shadowed, i, b);\n \t   ++i) \n \tfprintf (stderr, \" %s \", IDENTIFIER_POINTER (b->identifier));\n       fprintf (stderr, \"\\n\");\n@@ -2617,7 +2615,7 @@ poplevel_class (void)\n   if (level->class_shadowed)\n     {\n       for (i = 0;\n-\t   (cb = VEC_iterate (cp_class_binding, level->class_shadowed, i));\n+\t   VEC_iterate (cp_class_binding, level->class_shadowed, i, cb);\n \t   ++i)\n \tIDENTIFIER_BINDING (cb->identifier) = cb->base.previous;\n       ggc_free (level->class_shadowed);\n@@ -4924,9 +4922,7 @@ store_class_bindings (VEC(cp_class_binding) *names,\n   cp_class_binding *cb;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  for (i = 0; \n-       (cb = VEC_iterate(cp_class_binding, names, i));\n-       ++i)\n+  for (i = 0; VEC_iterate(cp_class_binding, names, i, cb); ++i)\n     store_binding (cb->identifier, old_bindings);\n   timevar_pop (TV_NAME_LOOKUP);\n }\n@@ -4982,9 +4978,7 @@ push_to_top_level (void)\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n \n-  for (i = 0;\n-       (sb = VEC_iterate (cxx_saved_binding, s->old_bindings, i));\n-       ++i)\n+  for (i = 0; VEC_iterate (cxx_saved_binding, s->old_bindings, i, sb); ++i)\n     IDENTIFIER_MARKED (sb->identifier) = 0;\n \n   s->prev = scope_chain;\n@@ -5015,9 +5009,7 @@ pop_from_top_level (void)\n   current_lang_base = 0;\n \n   scope_chain = s->prev;\n-  for (i = 0; \n-       (saved = VEC_iterate (cxx_saved_binding, s->old_bindings, i));\n-       ++i)\n+  for (i = 0; VEC_iterate (cxx_saved_binding, s->old_bindings, i, saved); ++i)\n     {\n       tree id = saved->identifier;\n "}, {"sha": "4c059c11805791595ae7a6e13b3be4eef115109f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -1838,7 +1838,7 @@ check_explicit_specialization (tree declarator,\n \t      methods = CLASSTYPE_METHOD_VEC (ctype);\n \t      if (methods)\n \t\tfor (idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t\t     (ovl = VEC_iterate (tree, methods, idx));\n+\t\t     VEC_iterate (tree, methods, idx, ovl);\n \t\t     ++idx)\n \t\t  {\n \t\t    if (!DECL_CONV_FN_P (OVL_CURRENT (ovl)))"}, {"sha": "e172aa38553a2d8628f34c4d16edbc1e7420b90b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -1319,8 +1319,7 @@ lookup_conversion_operator (tree class_type, tree type)\n \n   for (pass = 0; pass < 2; ++pass)\n     for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t (fn = VEC_iterate (tree, methods, i));\n-\t ++i)\n+\t VEC_iterate (tree, methods, i, fn); ++i)\n       {\n \t/* All the conversion operators come near the beginning of the\n \t   class.  Therefore, if FN is not a conversion operator, there\n@@ -1410,7 +1409,7 @@ lookup_fnfields_1 (tree type, tree name)\n \n   /* Skip the conversion operators.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-       (fn = VEC_iterate (tree, method_vec, i));\n+       VEC_iterate (tree, method_vec, i, fn);\n        ++i)\n     if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n       break;\n@@ -1442,9 +1441,7 @@ lookup_fnfields_1 (tree type, tree name)\n \t}\n     }\n   else\n-    for (; \n-\t (fn = VEC_iterate (tree, method_vec, i));\n-\t ++i)\n+    for (; VEC_iterate (tree, method_vec, i, fn); ++i)\n       {\n #ifdef GATHER_STATISTICS\n \tn_outer_fields_searched++;\n@@ -1887,6 +1884,7 @@ get_pure_virtuals (tree type)\n {\n   unsigned ix;\n   tree binfo;\n+  VEC (tree) *vbases;\n \n   /* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there\n      is going to be overridden.  */\n@@ -1903,8 +1901,8 @@ get_pure_virtuals (tree type)\n   /* Put the pure virtuals in dfs order.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n \n-  for (ix = 0; (binfo = VEC_iterate\n-\t\t(tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;\n+       VEC_iterate (tree, vbases, ix, binfo); ix++)\n     {\n       tree virtuals;\n       \n@@ -2078,12 +2076,12 @@ add_conversions (tree binfo, void *data)\n     return NULL_TREE;\n \n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-       (tmp = VEC_iterate (tree, method_vec, i));\n+       VEC_iterate (tree, method_vec, i, tmp);\n        ++i)\n     {\n       tree name;\n \n-      if (!tmp || ! DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n+      if (!DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n \tbreak;\n \n       name = DECL_NAME (OVL_CURRENT (tmp));\n@@ -2153,6 +2151,7 @@ dfs_check_overlap (tree empty_binfo, void *data)\n {\n   struct overlap_info *oi = (struct overlap_info *) data;\n   tree binfo;\n+  \n   for (binfo = TYPE_BINFO (oi->compare_type); \n        ; \n        binfo = BINFO_BASE_BINFO (binfo, 0))\n@@ -2308,9 +2307,10 @@ binfo_for_vbase (tree base, tree t)\n {\n   unsigned ix;\n   tree binfo;\n+  VEC (tree) *vbases;\n   \n-  for (ix = 0; (binfo = VEC_iterate\n-\t\t(tree, CLASSTYPE_VBASECLASSES (t), ix)); ix++)\n+  for (vbases = CLASSTYPE_VBASECLASSES (t), ix = 0;\n+       VEC_iterate (tree, vbases, ix, binfo); ix++)\n     if (BINFO_TYPE (binfo) == base)\n       return binfo;\n   return NULL;"}, {"sha": "bea438a82b84ce5169b8de9a36c5a234d8390224", "filename": "gcc/vec.h", "status": "modified", "additions": 147, "deletions": 63, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ba5ff0f25985468d845360aee1d11cb3a0f09c8/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=9ba5ff0f25985468d845360aee1d11cb3a0f09c8", "patch": "@@ -39,6 +39,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    objects pointed to must be long lived, but when dealing with a\n    vector of objects, the source objects need not be.\n \n+   There are both 'index' and 'iterate' accessors.  The iterator\n+   returns a boolean iteration condition and updates the iteration\n+   variable passed by reference.  Because the iterator will be\n+   inlined, the address-of can be optimized away.\n+\n    The vectors are implemented using the trailing array idiom, thus\n    they are not resizeable without changing the address of the vector\n    object itself.  This means you cannot have variables or fields of\n@@ -70,6 +75,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    element ordering 'ordered_remove', and one which does not\n    'unordered_remove'.  The latter function copies the end element\n    into the removed slot, rather than invoke a memmove operation.\n+\n+   If you need to directly manipulate a vector, then the 'address'\n+   accessor will return the address of the start of the vector.  Also\n+   the 'space' predicate will tell you whether there is spare capacity\n+   in the vector.  You will not normally need to use these two functions.\n    \n    Vector types are defined using a DEF_VEC_x(TYPEDEF) macro, and\n    variables of vector type are declared using a VEC(TYPEDEF)\n@@ -89,7 +99,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    if (VEC_length(tree,s->v)) { we have some contents }\n    VEC_safe_push(tree,s->v,decl); // append some decl onto the end\n-   for (ix = 0; (t = VEC_iterate(tree,s->v,ix)); ix++)\n+   for (ix = 0; VEC_iterate(tree,s->v,ix,t); ix++)\n      { do something with t }\n \n */\n@@ -105,40 +115,46 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Return the number of active elements in V.  V can be NULL, in which\n    case zero is returned.  */\n-#define VEC_length(TDEF,V)\t\t(VEC_OP(TDEF,length)(V))\n+\n+#define VEC_length(TDEF,V)\t(VEC_OP(TDEF,length)(V))\n \n /* Get the final element of the vector.\n    T VEC_T_last(VEC(T) *v); // Pointer\n    T *VEC_T_last(VEC(T) *v); // Object\n \n    Return the final element.  If V is empty,  abort.  */\n-#define VEC_last(TDEF,V)\t\t(VEC_OP(TDEF,last)(V))\n+\n+#define VEC_last(TDEF,V)\t(VEC_OP(TDEF,last)(V VEC_CHECK_INFO))\n \n /* Index into vector\n    T VEC_T_index(VEC(T) *v, size_t ix); // Pointer\n    T *VEC_T_index(VEC(T) *v, size_t ix); // Object\n \n    Return the IX'th element.  If IX is outside the domain of V,\n    abort.  */\n-#define VEC_index(TDEF,V,I)\t\t(VEC_OP(TDEF,index)(V,I))\n+\n+#define VEC_index(TDEF,V,I)\t(VEC_OP(TDEF,index)(V,I VEC_CHECK_INFO))\n \n /* Iterate over vector\n-   T VEC_T_index(VEC(T) *v, size_t ix); // Pointer\n-   T *VEC_T_index(VEC(T) *v, size_t ix); // Object\n+   int VEC_T_index(VEC(T) *v, size_t ix, T &ptr); // Pointer\n+   int VEC_T_index(VEC(T) *v, size_t ix, T *&ptr); // Object\n \n-   Return the IX'th element or NULL. Use this to iterate over the\n-   elements of a vector as follows,\n+   Return iteration condition and update PTR to point to the IX'th\n+   element.  At the end of iteration, sets PTR to NULL.  Use this to\n+   iterate over the elements of a vector as follows,\n \n-     for (ix = 0; (ptr = VEC_iterate(T,v,ix)); ix++)\n+     for (ix = 0; VEC_iterate(T,v,ix,ptr); ix++)\n        continue;  */\n-#define VEC_iterate(TDEF,V,I)\t\t(VEC_OP(TDEF,iterate)(V,I))\n+\n+#define VEC_iterate(TDEF,V,I,P)\t(VEC_OP(TDEF,iterate)(V,I,&(P)))\n \n /* Allocate new vector.\n    VEC(T) *VEC_T_alloc(int reserve);\n \n    Allocate a new vector with space for RESERVE objects.  If RESERVE\n    is <= 0, a default number of slots are created.  */\n-#define VEC_alloc(TDEF,A)\t\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n+\n+#define VEC_alloc(TDEF,A)\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n \n /* Use these to determine the required size and initialization of a\n    vector embedded within another structure (as the final member).\n@@ -147,8 +163,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    void VEC_T_embedded_init(VEC(T) *v, int reserve);\n    \n    These allow the caller to perform the memory allocation.  */\n-#define VEC_embedded_size(TDEF,A) (VEC_OP(TDEF,embedded_size)(A))\n-#define VEC_embedded_init(TDEF,O,A) (VEC_OP(TDEF,embedded_init)(O,A))\n+\n+#define VEC_embedded_size(TDEF,A)\t(VEC_OP(TDEF,embedded_size)(A))\n+#define VEC_embedded_init(TDEF,O,A)\t(VEC_OP(TDEF,embedded_init)(O,A))\n+\n+/* Determine if a vector has additional capacity.\n+   \n+   int VEC_T_space (VEC(T) *v,int reserve)\n+\n+   If V has space for RESERVE additional entries, return non-zero.  If\n+   RESERVE is < 0, ensure there is at least one space slot.  You\n+   usually only need to use this if you are doing your own vector\n+   reallocation, for instance on an embedded vector.  This returns\n+   non-zero in exactly the same circumstances that VEC_T_reserve\n+   will.  */\n+\n+#define VEC_space(TDEF,V,R)\t(VEC_OP(TDEF,space)(V,R))\n \n /* Reserve space.\n    int VEC_T_reserve(VEC(T) *&v, int reserve);\n@@ -160,6 +190,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    perform the usual exponential headroom increase.  Note this can\n    cause V to be reallocated.  Returns non-zero iff reallocation\n    actually occurred.  */\n+\n #define VEC_reserve(TDEF,V,R)\t(VEC_OP(TDEF,reserve)(&(V),R MEM_STAT_INFO))\n \n /* Push object with no reallocation\n@@ -170,7 +201,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    filled in. For object vectors, the new value can be NULL, in which\n    case NO initialization is performed.  Aborts if there is\n    insufficient space in the vector. */\n-#define VEC_quick_push(TDEF,V,O)\t(VEC_OP(TDEF,quick_push)(V,O))\n+\n+#define VEC_quick_push(TDEF,V,O)\t\\\n+\t(VEC_OP(TDEF,quick_push)(V,O VEC_CHECK_INFO))\n \n /* Push object with reallocation\n    T *VEC_T_safe_push (VEC(T) *&v, T obj); // Pointer\n@@ -179,21 +212,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Push a new element onto the end, returns a pointer to the slot\n    filled in. For object vectors, the new value can be NULL, in which\n    case NO initialization is performed.  Reallocates V, if needed.  */\n-#define VEC_safe_push(TDEF,V,O)\t\t(VEC_OP(TDEF,safe_push)(&(V),O MEM_STAT_INFO))\n+\n+#define VEC_safe_push(TDEF,V,O)\t\t\\\n+\t(VEC_OP(TDEF,safe_push)(&(V),O VEC_CHECK_INFO MEM_STAT_INFO))\n \n /* Pop element off end\n    T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n    void VEC_T_pop (VEC(T) *v);\t\t// Object\n \n    Pop the last element off the end. Returns the element popped, for\n    pointer vectors.  */\n-#define VEC_pop(TDEF,V)\t\t\t(VEC_OP(TDEF,pop)(V))\n+\n+#define VEC_pop(TDEF,V)\t\t\t(VEC_OP(TDEF,pop)(V VEC_CHECK_INFO))\n \n /* Truncate to specific length\n    void VEC_T_truncate (VEC(T) *v, size_t len);\n    \n    Set the length as specified.  This is an O(1) operation.  */\n-#define VEC_truncate(TDEF,V,I)\t\t(VEC_OP(TDEF,truncate)(V,I))\n+\n+#define VEC_truncate(TDEF,V,I)\t\t\\\n+\t(VEC_OP(TDEF,truncate)(V,I VEC_CHECK_INFO))\n \n /* Replace element\n    T VEC_T_replace (VEC(T) *v, size_t ix, T val); // Pointer\n@@ -204,7 +242,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    pointer to the new value.  For object vectors the new value can be\n    NULL, in which case no overwriting of the slot is actually\n    performed.  */\n-#define VEC_replace(TDEF,V,I,O)\t\t(VEC_OP(TDEF,replace)(V,I,O))\n+\n+#define VEC_replace(TDEF,V,I,O)\t\t\\\n+\t(VEC_OP(TDEF,replace)(V,I,O VEC_CHECK_INFO))\n \n /* Insert object with no reallocation\n    T *VEC_T_quick_insert (VEC(T) *v, size_t ix, T val); // Pointer\n@@ -214,7 +254,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n    place. Aborts if there is insufficient space.  */\n-#define VEC_quick_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,quick_insert)(V,I,O))\n+\n+#define VEC_quick_insert(TDEF,V,I,O)\t\\\n+\t(VEC_OP(TDEF,quick_insert)(V,I,O VEC_CHECK_INFO))\n \n /* Insert object with reallocation\n    T *VEC_T_safe_insert (VEC(T) *&v, size_t ix, T val); // Pointer\n@@ -224,7 +266,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    to the slot created.  For vectors of object, the new value can be\n    NULL, in which case no initialization of the inserted slot takes\n    place. Reallocate V, if necessary.  */\n-#define VEC_safe_insert(TDEF,V,I,O)\t(VEC_OP(TDEF,safe_insert)(&(V),I,O MEM_STAT_INFO))\n+\n+#define VEC_safe_insert(TDEF,V,I,O)\t\\\n+\t(VEC_OP(TDEF,safe_insert)(&(V),I,O VEC_CHECK_INFO MEM_STAT_INFO))\n      \n /* Remove element retaining order\n    T VEC_T_ordered_remove (VEC(T) *v, size_t ix); // Pointer\n@@ -233,7 +277,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Remove an element from the IXth position of V. Ordering of\n    remaining elements is preserverd.  For pointer vectors returns the\n    removed object.  This is an O(N) operation due to a memmove.  */\n-#define VEC_ordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,ordered_remove)(V,I))\n+\n+#define VEC_ordered_remove(TDEF,V,I)\t\\\n+\t(VEC_OP(TDEF,ordered_remove)(V,I VEC_CHECK_INFO))\n \n /* Remove element destroying order\n    T VEC_T_unordered_remove (VEC(T) *v, size_t ix); // Pointer\n@@ -242,13 +288,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    Remove an element from the IXth position of V. Ordering of\n    remaining elements is destroyed.  For pointer vectors returns the\n    removed object.  This is an O(1) operation.  */\n-#define VEC_unordered_remove(TDEF,V,I)\t(VEC_OP(TDEF,unordered_remove)(V,I))\n+\n+#define VEC_unordered_remove(TDEF,V,I)\t\\\n+\t(VEC_OP(TDEF,unordered_remove)(V,I VEC_CHECK_INFO))\n \n /* Get the address of the array of elements\n    T *VEC_T_address (VEC(T) v)\n \n    If you need to directly manipulate the array (for instance, you\n    want to feed it to qsort), use this accessor.  */\n+\n #define VEC_address(TDEF,V)\t\t(VEC_OP(TDEF,address)(V))\n \n #if !IN_GENGTYPE\n@@ -257,15 +306,20 @@ extern void *vec_p_reserve (void *, int MEM_STAT_DECL);\n extern void *vec_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n \n #if ENABLE_CHECKING\n-extern void vec_assert_fail (const char *, const char *,\n-\t\t\t    const char *, unsigned int, const char *)\n-     ATTRIBUTE_NORETURN;\n-#define VEC_ASSERT_FAIL(OP,VEC) \\\n-  vec_assert_fail (OP,#VEC,__FILE__,__LINE__,__FUNCTION__)\n+#define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n+#define VEC_CHECK_DECL ,const char *file_,unsigned line_,const char *function_\n+#define VEC_CHECK_PASS ,file_,line_,function_\n      \n #define VEC_ASSERT(EXPR,OP,TDEF) \\\n   (void)((EXPR) ? 0 : (VEC_ASSERT_FAIL(OP,VEC(TDEF)), 0))\n+\n+extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n+     ATTRIBUTE_NORETURN;\n+#define VEC_ASSERT_FAIL(OP,VEC) vec_assert_fail (OP,#VEC VEC_CHECK_PASS)\n #else\n+#define VEC_CHECK_INFO\n+#define VEC_CHECK_DECL\n+#define VEC_CHECK_PASS\n #define VEC_ASSERT(EXPR,OP,TYPE) (void)(EXPR)\n #endif\n \n@@ -303,25 +357,34 @@ static inline size_t VEC_OP (TDEF,length)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,last)\t\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_)\t\t\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,index)\t\t\t\t\t  \\\n-     (const VEC (TDEF) *vec_, size_t ix_)\t\t\t\t  \\\n+     (const VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF VEC_OP (TDEF,iterate)\t\t  \t     \t  \\\n-     (const VEC (TDEF) *vec_, size_t ix_)\t\t\t\t  \\\n+static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n+     (const VEC (TDEF) *vec_, size_t ix_, TDEF *ptr)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ && ix_ < vec_->num ? vec_->vec[ix_] : NULL;\t\t  \\\n+  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      *ptr = vec_->vec[ix_];\t\t\t\t\t\t  \\\n+      return 1;\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  else\t\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      *ptr = 0;\t\t\t\t\t\t\t\t  \\\n+      return 0;\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)\t\t\t\t  \\\n@@ -343,11 +406,17 @@ static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (TDEF,space)\t       \t\t\t\t  \\\n+     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? ((vec_)->alloc - (vec_)->num\t\t\t\t  \\\n+\t\t < (size_t)(alloc_ < 0 ? 1 : alloc_)) : alloc_ != 0;\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (TDEF,reserve)\t       \t\t\t\t  \\\n      (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !*vec_ || ((*vec_)->alloc - (*vec_)->num\t\t\t  \\\n-\t\t\t  < (size_t)(alloc_ < 0 ? 1 : alloc_));\t\t  \\\n+  int extend = VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n \t\t  \t\t\t\t\t\t\t  \\\n   if (extend)\t  \t\t\t\t\t\t\t  \\\n     *vec_ = vec_p_reserve (*vec_, alloc_ PASS_MEM_STAT);\t\t  \\\n@@ -356,7 +425,7 @@ static inline int VEC_OP (TDEF,reserve)\t       \t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, TDEF obj_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, TDEF obj_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n@@ -368,15 +437,15 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, TDEF obj_ MEM_STAT_DECL)\t\t\t  \\\n+     (VEC (TDEF) **vec_, TDEF obj_ VEC_CHECK_DECL MEM_STAT_DECL)       \t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n+  return VEC_OP (TDEF,quick_push) (*vec_, obj_ VEC_CHECK_PASS);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_)\t\t\t       \t\t\t\t  \\\n+     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t    \t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF obj_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -387,15 +456,15 @@ static inline TDEF VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t size_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", TDEF);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n     vec_->num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n-     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF old_obj_;\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -407,7 +476,7 @@ static inline TDEF VEC_OP (TDEF,replace)\t\t  \t     \t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, TDEF obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -421,15 +490,15 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t     \t  \t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, size_t ix_, TDEF obj_ MEM_STAT_DECL)\t\t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, TDEF obj_ VEC_CHECK_DECL MEM_STAT_DECL) \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n+  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_ VEC_CHECK_PASS);\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n   TDEF obj_;\t\t\t\t\t\t\t\t  \\\n@@ -443,7 +512,7 @@ static inline TDEF VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n   TDEF obj_;\t\t\t\t\t\t\t\t  \\\n@@ -480,25 +549,34 @@ static inline size_t VEC_OP (TDEF,length)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,last)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ && vec_->num, \"last\", TDEF);\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return &vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,index)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ && ix_ < vec_->num, \"index\", TDEF);\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n   return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-static inline TDEF *VEC_OP (TDEF,iterate)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, TDEF **ptr)\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ && ix_ < vec_->num ? &vec_->vec[ix_] : NULL;\t\t  \\\n+  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      *ptr = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n+      return 1;\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  else\t\t\t\t\t\t\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      *ptr = 0;\t\t\t\t\t\t\t\t  \\\n+      return 0;\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n@@ -522,11 +600,17 @@ static inline void VEC_OP (TDEF,embedded_init)\t\t\t\t  \\\n   vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline int VEC_OP (TDEF,space)\t       \t\t\t\t  \\\n+     (VEC (TDEF) *vec_, int alloc_)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  return vec_ ? ((vec_)->alloc - (vec_)->num\t\t\t\t  \\\n+\t\t < (size_t)(alloc_ < 0 ? 1 : alloc_)) : alloc_ != 0;\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline int VEC_OP (TDEF,reserve)\t   \t    \t\t\t  \\\n      (VEC (TDEF) **vec_, int alloc_ MEM_STAT_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !*vec_ || ((*vec_)->alloc - (*vec_)->num\t\t\t  \\\n-\t\t\t  < (size_t)(alloc_ < 0 ? 1 : alloc_));\t\t  \\\n+  int extend = VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (extend)\t\t\t\t\t\t\t\t  \\\n     *vec_ = vec_o_reserve (*vec_, alloc_,\t\t\t\t  \\\n@@ -537,7 +621,7 @@ static inline int VEC_OP (TDEF,reserve)\t   \t    \t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, const TDEF *obj_)\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, const TDEF *obj_ VEC_CHECK_DECL)\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n   \t\t\t\t\t\t\t\t\t  \\\n@@ -550,30 +634,30 @@ static inline TDEF *VEC_OP (TDEF,quick_push)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_push)\t\t\t\t  \\\n-     (VEC (TDEF) **vec_, const TDEF *obj_ MEM_STAT_DECL)\t\t  \\\n+     (VEC (TDEF) **vec_, const TDEF *obj_ VEC_CHECK_DECL MEM_STAT_DECL)   \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_push) (*vec_, obj_);\t\t\t  \\\n+  return VEC_OP (TDEF,quick_push) (*vec_, obj_ VEC_CHECK_PASS);\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,pop)\t\t\t\t\t  \\\n-     (VEC (TDEF) *vec_)\t\t\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_ VEC_CHECK_DECL)\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_->num, \"pop\", TDEF);\t\t\t\t\t  \\\n   --vec_->num;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,truncate)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t size_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t size_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (vec_ ? vec_->num >= size_ : !size_, \"truncate\", TDEF);\t  \\\n   if (vec_)\t\t\t\t\t\t\t\t  \\\n     vec_->num = size_;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -586,7 +670,7 @@ static inline TDEF *VEC_OP (TDEF,replace)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_)\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_, const TDEF *obj_ VEC_CHECK_DECL)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -601,15 +685,15 @@ static inline TDEF *VEC_OP (TDEF,quick_insert)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline TDEF *VEC_OP (TDEF,safe_insert)\t\t     \t  \t  \\\n-     (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_ MEM_STAT_DECL)\t  \\\n+     (VEC (TDEF) **vec_, size_t ix_, const TDEF *obj_ VEC_CHECK_DECL MEM_STAT_DECL)  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_OP (TDEF,reserve) (vec_, -1 PASS_MEM_STAT);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_);\t\t\t  \\\n+  return VEC_OP (TDEF,quick_insert) (*vec_, ix_, obj_ VEC_CHECK_PASS);\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   TDEF *slot_;\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n@@ -619,7 +703,7 @@ static inline void VEC_OP (TDEF,ordered_remove)\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (TDEF,unordered_remove)\t\t\t  \\\n-     (VEC (TDEF) *vec_, size_t ix_)\t\t\t\t\t  \\\n+     (VEC (TDEF) *vec_, size_t ix_ VEC_CHECK_DECL)\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n   VEC_ASSERT (ix_ < vec_->num, \"remove\", TDEF);\t\t\t\t  \\\n   vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\"}]}