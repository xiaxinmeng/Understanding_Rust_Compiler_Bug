{"sha": "67999712dc5f65814320813b1d810b35d80162bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5OTk3MTJkYzVmNjU4MTQzMjA4MTNiMWQ4MTBiMzVkODAxNjJiZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-04-07T23:42:42Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-04-07T23:42:42Z"}, "message": "Revert last patch for more testing.\n\nFrom-SVN: r97810", "tree": {"sha": "8ee6fe99780430464919151228e5f968476578fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ee6fe99780430464919151228e5f968476578fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67999712dc5f65814320813b1d810b35d80162bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67999712dc5f65814320813b1d810b35d80162bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67999712dc5f65814320813b1d810b35d80162bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67999712dc5f65814320813b1d810b35d80162bd/comments", "author": null, "committer": null, "parents": [{"sha": "0ceeebd3067f70af56922c88343375d10e0d429f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ceeebd3067f70af56922c88343375d10e0d429f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ceeebd3067f70af56922c88343375d10e0d429f"}], "stats": {"total": 174, "additions": 2, "deletions": 172}, "files": [{"sha": "5a2dfa26b1dbe2618aa362b56d637acea318f069", "filename": "ChangeLog", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67999712dc5f65814320813b1d810b35d80162bd/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67999712dc5f65814320813b1d810b35d80162bd/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=67999712dc5f65814320813b1d810b35d80162bd", "patch": "@@ -1,7 +1,3 @@\n-2005-04-07  Mike Stump  <mrs@apple.com>\n-\n-\t* libtool.m4: Update AC_LIBTOOL_SYS_MAX_CMD_LEN bits from upstream.\n-\n 2005-04-04  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "298bfeca76ae154e67d1920061e190c0ba9e191f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67999712dc5f65814320813b1d810b35d80162bd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67999712dc5f65814320813b1d810b35d80162bd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=67999712dc5f65814320813b1d810b35d80162bd", "patch": "@@ -1,7 +1,3 @@\n-2005-04-07  Mike Stump  <mrs@apple.com>\n-\n-\t* configure: Regenerate.\n-\n 2005-04-06  Andrew Haley  <aph@redhat.com>\n \n \t* testsuite/libjava.lang/bytearray.java: New file."}, {"sha": "ae6e39f2aecb4ce61267e1f78fc2b09d256a55e2", "filename": "libjava/configure", "status": "modified", "additions": 2, "deletions": 83, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67999712dc5f65814320813b1d810b35d80162bd/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67999712dc5f65814320813b1d810b35d80162bd/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=67999712dc5f65814320813b1d810b35d80162bd", "patch": "@@ -4435,87 +4435,6 @@ deplibs_check_method=$lt_cv_deplibs_check_method\n \n # Autoconf 2.13's AC_OBJEXT and AC_EXEEXT macros only works for C compilers!\n \n-# find the maximum length of command line arguments\n-echo \"$as_me:$LINENO: checking the maximum length of command line arguments\" >&5\n-echo $ECHO_N \"checking the maximum length of command line arguments... $ECHO_C\" >&6\n-if test \"${lt_cv_sys_max_cmd_len+set}\" = set; then\n-  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n-else\n-    i=0\n-  teststring=\"ABCD\"\n-\n-  case $build_os in\n-  msdosdjgpp*)\n-    # On DJGPP, this test can blow up pretty badly due to problems in libc\n-    # (any single argument exceeding 2000 bytes causes a buffer overrun\n-    # during glob expansion).  Even if it were fixed, the result of this\n-    # check would be larger than it should be.\n-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n-    ;;\n-\n-  cygwin* | mingw*)\n-    # On Win9x/ME, this test blows up -- it succeeds, but takes\n-    # about 5 minutes as the teststring grows exponentially.\n-    # Worse, since 9x/ME are not pre-emptively multitasking,\n-    # you end up with a \"frozen\" computer, even though with patience\n-    # the test eventually succeeds (with a max line length of 256k).\n-    # Instead, let's just punt: use the minimum linelength reported by\n-    # all of the supported platforms: 8192 (on NT/2K/XP).\n-    lt_cv_sys_max_cmd_len=8192;\n-    ;;\n-\n-  amigaos*)\n-    # On AmigaOS with pdksh, this test takes hours, literally.\n-    # So we just punt and use a minimum line length of 8192.\n-    lt_cv_sys_max_cmd_len=8192;\n-    ;;\n-\n-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n-    # This has been around since 386BSD, at least.  Likely further.\n-    if test -x /sbin/sysctl; then\n-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n-    elif test -x /usr/sbin/sysctl; then\n-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n-    else\n-      lt_cv_sys_max_cmd_len=65536 # usable default for *BSD\n-    fi\n-    # And add a safety zone\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n-    ;;\n-  *)\n-    # If test is not a shell built-in, we'll probably end up computing a\n-    # maximum length that is only half of the actual maximum length, but\n-    # we can't tell.\n-    SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n-    while (test \"X\"`$SHELL $0 --fallback-echo \"X$teststring\" 2>/dev/null` \\\n-\t       = \"XX$teststring\") >/dev/null 2>&1 &&\n-\t    new_result=`expr \"X$teststring\" : \".*\" 2>&1` &&\n-\t    lt_cv_sys_max_cmd_len=$new_result &&\n-\t    test $i != 17 # 1/2 MB should be enough\n-    do\n-      i=`expr $i + 1`\n-      teststring=$teststring$teststring\n-    done\n-    teststring=\n-    # Add a significant safety factor because C++ compilers can tack on massive\n-    # amounts of additional arguments before passing them to the linker.\n-    # It appears as though 1/2 is a usable value.\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n-    ;;\n-  esac\n-\n-fi\n-\n-if test -n $lt_cv_sys_max_cmd_len ; then\n-  echo \"$as_me:$LINENO: result: $lt_cv_sys_max_cmd_len\" >&5\n-echo \"${ECHO_T}$lt_cv_sys_max_cmd_len\" >&6\n-else\n-  echo \"$as_me:$LINENO: result: none\" >&5\n-echo \"${ECHO_T}none\" >&6\n-fi\n-\n-\n # Only perform the check for file, if the check method requires it\n case $deplibs_check_method in\n file_magic*)\n@@ -4849,7 +4768,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 4852 \"configure\"' > conftest.$ac_ext\n+  echo '#line 4771 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -5893,7 +5812,7 @@ if test \"${enable_sjlj_exceptions+set}\" = set; then\n   :\n else\n   cat > conftest.$ac_ext << EOF\n-#line 5896 \"configure\"\n+#line 5815 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()"}, {"sha": "60121579faf990e3a0720139bba043f9547a60e6", "filename": "libtool.m4", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67999712dc5f65814320813b1d810b35d80162bd/libtool.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67999712dc5f65814320813b1d810b35d80162bd/libtool.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libtool.m4?ref=67999712dc5f65814320813b1d810b35d80162bd", "patch": "@@ -103,8 +103,6 @@ AC_REQUIRE([AC_OBJEXT])dnl\n AC_REQUIRE([AC_EXEEXT])dnl\n dnl\n \n-AC_LIBTOOL_SYS_MAX_CMD_LEN\n-\n # Only perform the check for file, if the check method requires it\n case $deplibs_check_method in\n file_magic*)\n@@ -281,85 +279,6 @@ ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n esac\n ])\n \n-\n-# AC_LIBTOOL_SYS_MAX_CMD_LEN\n-# --------------------------\n-AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN],\n-[# find the maximum length of command line arguments\n-AC_MSG_CHECKING([the maximum length of command line arguments])\n-AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n-  i=0\n-  teststring=\"ABCD\"\n-\n-  case $build_os in\n-  msdosdjgpp*)\n-    # On DJGPP, this test can blow up pretty badly due to problems in libc\n-    # (any single argument exceeding 2000 bytes causes a buffer overrun\n-    # during glob expansion).  Even if it were fixed, the result of this\n-    # check would be larger than it should be.\n-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n-    ;;\n-\n-  cygwin* | mingw*)\n-    # On Win9x/ME, this test blows up -- it succeeds, but takes\n-    # about 5 minutes as the teststring grows exponentially.\n-    # Worse, since 9x/ME are not pre-emptively multitasking,\n-    # you end up with a \"frozen\" computer, even though with patience\n-    # the test eventually succeeds (with a max line length of 256k).\n-    # Instead, let's just punt: use the minimum linelength reported by\n-    # all of the supported platforms: 8192 (on NT/2K/XP).\n-    lt_cv_sys_max_cmd_len=8192;\n-    ;;\n-\n-  amigaos*)\n-    # On AmigaOS with pdksh, this test takes hours, literally.\n-    # So we just punt and use a minimum line length of 8192.\n-    lt_cv_sys_max_cmd_len=8192;\n-    ;;\n-\n-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n-    # This has been around since 386BSD, at least.  Likely further.\n-    if test -x /sbin/sysctl; then\n-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n-    elif test -x /usr/sbin/sysctl; then\n-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n-    else\n-      lt_cv_sys_max_cmd_len=65536 # usable default for *BSD\n-    fi\n-    # And add a safety zone\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n-    ;;\n-  *)\n-    # If test is not a shell built-in, we'll probably end up computing a\n-    # maximum length that is only half of the actual maximum length, but\n-    # we can't tell.\n-    SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n-    while (test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring\" 2>/dev/null` \\\n-\t       = \"XX$teststring\") >/dev/null 2>&1 &&\n-\t    new_result=`expr \"X$teststring\" : \".*\" 2>&1` &&\n-\t    lt_cv_sys_max_cmd_len=$new_result &&\n-\t    test $i != 17 # 1/2 MB should be enough\n-    do\n-      i=`expr $i + 1`\n-      teststring=$teststring$teststring\n-    done\n-    teststring=\n-    # Add a significant safety factor because C++ compilers can tack on massive\n-    # amounts of additional arguments before passing them to the linker.\n-    # It appears as though 1/2 is a usable value.\n-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n-    ;;\n-  esac\n-])\n-if test -n $lt_cv_sys_max_cmd_len ; then\n-  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\n-else\n-  AC_MSG_RESULT(none)\n-fi\n-])# AC_LIBTOOL_SYS_MAX_CMD_LEN\n-\n-\n # AC_LIBTOOL_DLOPEN - enable checks for dlopen support\n AC_DEFUN([AC_LIBTOOL_DLOPEN], [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])])\n "}]}