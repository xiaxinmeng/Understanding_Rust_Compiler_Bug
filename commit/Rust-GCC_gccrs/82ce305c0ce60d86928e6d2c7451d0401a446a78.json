{"sha": "82ce305c0ce60d86928e6d2c7451d0401a446a78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjZTMwNWMwY2U2MGQ4NjkyOGU2ZDJjNzQ1MWQwNDAxYTQ0NmE3OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-03-17T20:08:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-03-17T20:08:01Z"}, "message": "re PR rtl-optimization/37273 (IRA does not re-materializes addresses (loads from the TOC))\n\n\n\tPR rtl-optimization/37273\n\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n\thandle them like argument loads from stack slots.  Do not double\n\tcount memory for memory constants and argument loads from stack slots.\n\nFrom-SVN: r171111", "tree": {"sha": "7e9474f74a35ea5586f2698171cdcd9058633f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e9474f74a35ea5586f2698171cdcd9058633f03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82ce305c0ce60d86928e6d2c7451d0401a446a78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ce305c0ce60d86928e6d2c7451d0401a446a78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ce305c0ce60d86928e6d2c7451d0401a446a78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ce305c0ce60d86928e6d2c7451d0401a446a78/comments", "author": null, "committer": null, "parents": [{"sha": "3ade8456a1d97911730cd904a6c1b5e64993ee55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ade8456a1d97911730cd904a6c1b5e64993ee55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ade8456a1d97911730cd904a6c1b5e64993ee55"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "5182971d685cb19d2ae09a36e03e008dde8285a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ce305c0ce60d86928e6d2c7451d0401a446a78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ce305c0ce60d86928e6d2c7451d0401a446a78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82ce305c0ce60d86928e6d2c7451d0401a446a78", "patch": "@@ -1,3 +1,10 @@\n+2011-03-16  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/37273\n+\t* ira-costs.c (scan_one_insn): Detect constants living in memory and\n+\thandle them like argument loads from stack slots.  Do not double\n+\tcount memory for memory constants and argument loads from stack slots.\n+\n 2011-03-17  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR debug/48160"}, {"sha": "6db5bf29b529d1f3713309d79fa9b6d24adf15fa", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ce305c0ce60d86928e6d2c7451d0401a446a78/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ce305c0ce60d86928e6d2c7451d0401a446a78/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=82ce305c0ce60d86928e6d2c7451d0401a446a78", "patch": "@@ -1,5 +1,5 @@\n /* IRA hard register and memory cost calculation for allocnos or pseudos.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n \n@@ -1009,6 +1009,7 @@ scan_one_insn (rtx insn)\n   enum rtx_code pat_code;\n   rtx set, note;\n   int i, k;\n+  bool counted_mem;\n \n   if (!NONDEBUG_INSN_P (insn))\n     return insn;\n@@ -1018,15 +1019,23 @@ scan_one_insn (rtx insn)\n       || pat_code == ADDR_VEC || pat_code == ADDR_DIFF_VEC)\n     return insn;\n \n+  counted_mem = false;\n   set = single_set (insn);\n   extract_insn (insn);\n \n   /* If this insn loads a parameter from its stack slot, then it\n      represents a savings, rather than a cost, if the parameter is\n-     stored in memory.  Record this fact.  */\n+     stored in memory.  Record this fact. \n+\n+     Similarly if we're loading other constants from memory (constant\n+     pool, TOC references, small data areas, etc) and this is the only\n+     assignment to the destination pseudo.  */\n   if (set != 0 && REG_P (SET_DEST (set)) && MEM_P (SET_SRC (set))\n       && (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL_RTX\n-      && MEM_P (XEXP (note, 0)))\n+      && ((MEM_P (XEXP (note, 0)))\n+\t  || (CONSTANT_P (XEXP (note, 0))\n+\t      && LEGITIMATE_CONSTANT_P (XEXP (note, 0))\n+\t      && REG_N_SETS (REGNO (SET_DEST (set))) == 1)))\n     {\n       enum reg_class cl = GENERAL_REGS;\n       rtx reg = SET_DEST (set);\n@@ -1038,6 +1047,7 @@ scan_one_insn (rtx insn)\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n \t\t\t   0, MEM, SCRATCH, frequency * 2);\n+      counted_mem = true;\n     }\n \n   record_operand_costs (insn, pref);\n@@ -1052,7 +1062,10 @@ scan_one_insn (rtx insn)\n \tstruct costs *p = COSTS (costs, COST_INDEX (regno));\n \tstruct costs *q = op_costs[i];\n \n-\tp->mem_cost += q->mem_cost;\n+\t/* If the already accounted for the memory \"cost\" above, don't\n+\t   do so again.  */\n+\tif (!counted_mem)\n+\t  p->mem_cost += q->mem_cost;\n \tfor (k = 0; k < cost_classes_num; k++)\n \t  p->cost[k] += q->cost[k];\n       }"}]}