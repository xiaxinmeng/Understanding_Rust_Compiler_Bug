{"sha": "c5f597633467c2fc0fa80afa19c99f049fac8466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVmNTk3NjMzNDY3YzJmYzBmYTgwYWZhMTljOTlmMDQ5ZmFjODQ2Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-09-14T08:07:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-09-14T08:07:30Z"}, "message": "re PR target/81325 (-fcompare-debug failure on ppc64le)\n\n\tPR target/81325\n\t* cfgbuild.c (find_bb_boundaries): Ignore debug insns in decisions\n\tif and where to split a bb, except for splitting before debug insn\n\tsequences followed by non-label real insn.  Delete debug insns\n\tin between basic blocks.\n\n\t* g++.dg/cpp0x/pr81325.C: New test.\n\nFrom-SVN: r252752", "tree": {"sha": "57b1b301e9ef2951cfbfd3cb199bc29fee9fd255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57b1b301e9ef2951cfbfd3cb199bc29fee9fd255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5f597633467c2fc0fa80afa19c99f049fac8466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f597633467c2fc0fa80afa19c99f049fac8466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5f597633467c2fc0fa80afa19c99f049fac8466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f597633467c2fc0fa80afa19c99f049fac8466/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95a866badb5c78bf48476a92f5909cdf5f7fc088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a866badb5c78bf48476a92f5909cdf5f7fc088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a866badb5c78bf48476a92f5909cdf5f7fc088"}], "stats": {"total": 148, "additions": 136, "deletions": 12}, "files": [{"sha": "9617de3f5bd327f48084c48fa4c4746263e0d3c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5f597633467c2fc0fa80afa19c99f049fac8466", "patch": "@@ -1,5 +1,11 @@\n 2017-09-14  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/81325\n+\t* cfgbuild.c (find_bb_boundaries): Ignore debug insns in decisions\n+\tif and where to split a bb, except for splitting before debug insn\n+\tsequences followed by non-label real insn.  Delete debug insns\n+\tin between basic blocks.\n+\n \t* combine.c (make_compound_operation_int): Formatting fixes.\n \n \t* config/alpha/elf.h (LINK_EH_SPEC): Add -static-pie support."}, {"sha": "62956b2a6a2a0603a50a68db153d3b18592cada8", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=c5f597633467c2fc0fa80afa19c99f049fac8466", "patch": "@@ -442,9 +442,10 @@ find_bb_boundaries (basic_block bb)\n   rtx_insn *end = BB_END (bb), *x;\n   rtx_jump_table_data *table;\n   rtx_insn *flow_transfer_insn = NULL;\n+  rtx_insn *debug_insn = NULL;\n   edge fallthru = NULL;\n \n-  if (insn == BB_END (bb))\n+  if (insn == end)\n     return;\n \n   if (LABEL_P (insn))\n@@ -455,22 +456,43 @@ find_bb_boundaries (basic_block bb)\n     {\n       enum rtx_code code = GET_CODE (insn);\n \n+      if (code == DEBUG_INSN)\n+\t{\n+\t  if (flow_transfer_insn && !debug_insn)\n+\t    debug_insn = insn;\n+\t}\n       /* In case we've previously seen an insn that effects a control\n \t flow transfer, split the block.  */\n-      if ((flow_transfer_insn || code == CODE_LABEL)\n-\t  && inside_basic_block_p (insn))\n+      else if ((flow_transfer_insn || code == CODE_LABEL)\n+\t       && inside_basic_block_p (insn))\n \t{\n-\t  fallthru = split_block (bb, PREV_INSN (insn));\n+\t  rtx_insn *prev = PREV_INSN (insn);\n+\n+\t  /* If the first non-debug inside_basic_block_p insn after a control\n+\t     flow transfer is not a label, split the block before the debug\n+\t     insn instead of before the non-debug insn, so that the debug\n+\t     insns are not lost.  */\n+\t  if (debug_insn && code != CODE_LABEL && code != BARRIER)\n+\t    prev = PREV_INSN (debug_insn);\n+\t  fallthru = split_block (bb, prev);\n \t  if (flow_transfer_insn)\n \t    {\n \t      BB_END (bb) = flow_transfer_insn;\n \n+\t      rtx_insn *next;\n \t      /* Clean up the bb field for the insns between the blocks.  */\n \t      for (x = NEXT_INSN (flow_transfer_insn);\n \t\t   x != BB_HEAD (fallthru->dest);\n-\t\t   x = NEXT_INSN (x))\n-\t\tif (!BARRIER_P (x))\n-\t\t  set_block_for_insn (x, NULL);\n+\t\t   x = next)\n+\t\t{\n+\t\t  next = NEXT_INSN (x);\n+\t\t  /* Debug insns should not be in between basic blocks,\n+\t\t     drop them on the floor.  */\n+\t\t  if (DEBUG_INSN_P (x))\n+\t\t    delete_insn (x);\n+\t\t  else if (!BARRIER_P (x))\n+\t\t    set_block_for_insn (x, NULL);\n+\t\t}\n \t    }\n \n \t  bb = fallthru->dest;\n@@ -480,6 +502,7 @@ find_bb_boundaries (basic_block bb)\n \t  bb->frequency = 0;\n \t  bb->count = profile_count::uninitialized ();\n \t  flow_transfer_insn = NULL;\n+\t  debug_insn = NULL;\n \t  if (code == CODE_LABEL && LABEL_ALT_ENTRY_P (insn))\n \t    make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, 0);\n \t}\n@@ -502,17 +525,23 @@ find_bb_boundaries (basic_block bb)\n   /* In case expander replaced normal insn by sequence terminating by\n      return and barrier, or possibly other sequence not behaving like\n      ordinary jump, we need to take care and move basic block boundary.  */\n-  if (flow_transfer_insn)\n+  if (flow_transfer_insn && flow_transfer_insn != end)\n     {\n       BB_END (bb) = flow_transfer_insn;\n \n       /* Clean up the bb field for the insns that do not belong to BB.  */\n-      x = flow_transfer_insn;\n-      while (x != end)\n+      rtx_insn *next;\n+      for (x = NEXT_INSN (flow_transfer_insn); ; x = next)\n \t{\n-\t  x = NEXT_INSN (x);\n-\t  if (!BARRIER_P (x))\n+\t  next = NEXT_INSN (x);\n+\t  /* Debug insns should not be in between basic blocks,\n+\t     drop them on the floor.  */\n+\t  if (DEBUG_INSN_P (x))\n+\t    delete_insn (x);\n+\t  else if (!BARRIER_P (x))\n \t    set_block_for_insn (x, NULL);\n+\t  if (x == end)\n+\t    break;\n \t}\n     }\n "}, {"sha": "25e2bf6ceb7c1511f62132ba6d27d1617b77da4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5f597633467c2fc0fa80afa19c99f049fac8466", "patch": "@@ -1,3 +1,8 @@\n+2017-09-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/81325\n+\t* g++.dg/cpp0x/pr81325.C: New test.\n+\n 2017-09-13  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/82173"}, {"sha": "11f0900caa21f75205b669bca8b83178306eeeff", "filename": "gcc/testsuite/g++.dg/cpp0x/pr81325.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr81325.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5f597633467c2fc0fa80afa19c99f049fac8466/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr81325.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr81325.C?ref=c5f597633467c2fc0fa80afa19c99f049fac8466", "patch": "@@ -0,0 +1,84 @@\n+// PR target/81325\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fcompare-debug\" }\n+\n+struct A { A(const char *, const int & = 0); };\n+template <typename> struct B;\n+template <typename> struct C {\n+  int _M_i;\n+  void m_fn1() { __atomic_fetch_add(&_M_i, 0, __ATOMIC_RELAXED); }\n+};\n+struct D {\n+  int *Data;\n+  long Length = 0;\n+  D(int) : Data() {}\n+};\n+template <> struct B<int> : C<int> {};\n+struct F {\n+  B<int> RefCount;\n+  void m_fn2() { RefCount.m_fn1(); }\n+};\n+struct G {\n+  F *Obj;\n+  G(const G &p1) : Obj(p1.Obj) {\n+    if (Obj) {\n+      F *a = 0;\n+      a->m_fn2();\n+    }\n+  }\n+};\n+struct H {\n+  int CPlusPlus : 1;\n+};\n+struct I {\n+  enum {} KindId;\n+};\n+template <typename ResultT, typename ArgT> struct J {\n+  void operator()();\n+  ResultT operator()(ArgT) {}\n+};\n+struct K {\n+  int AllowBind;\n+  I SupportedKind;\n+  I RestrictKind;\n+  G Implementation;\n+};\n+struct L {\n+  L(int) : Implementation(Implementation) {}\n+  K Implementation;\n+};\n+struct M {\n+  int Param1;\n+};\n+struct N {\n+  N(int, L &p2) : Param2(p2) {}\n+  L Param2;\n+};\n+struct O {\n+  L m_fn3();\n+};\n+L ignoringImpCasts(L);\n+J<O, L> b;\n+L hasName(const A &);\n+M hasOverloadedOperatorName(D);\n+J<O, int> c;\n+struct P {\n+  void m_fn4(L, int);\n+};\n+struct Q {\n+  void m_fn5(P *);\n+};\n+H d;\n+void Q::m_fn5(P *p1) {\n+  if (!d.CPlusPlus) {\n+    c();\n+    L e = 0, f = ignoringImpCasts(e);\n+    b(ignoringImpCasts(f)).m_fn3();\n+  }\n+  hasOverloadedOperatorName(0);\n+  hasName(\"\");\n+  L g = 0;\n+  N(0, g);\n+  L h(0);\n+  p1->m_fn4(h, 0);\n+}"}]}