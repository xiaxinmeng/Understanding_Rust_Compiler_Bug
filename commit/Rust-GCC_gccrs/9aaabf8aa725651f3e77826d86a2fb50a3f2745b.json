{"sha": "9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFhYWJmOGFhNzI1NjUxZjNlNzc4MjZkODZhMmZiNTBhM2YyNzQ1Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-07-03T02:35:05Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-07-03T02:35:05Z"}, "message": "c-decl.c (struct c_binding): Remove contour field; add depth, invisible, nested fields.\n\n\t* c-decl.c (struct c_binding): Remove contour field; add\n\tdepth, invisible, nested fields.\n\t(B_IN_SCOPE, B_IN_CURRENT_SCOPE, B_IN_FILE_SCOPE)\n\t(B_IN_EXTERNAL_SCOPE): New convenience macros.\n\t(bind): Add invisible and nested arguments. Initialize\n\tnew fields of struct c_binding; adjust loop scanning for\n\tinsertion point.\n\t(free_binding_and_advance): Clear structure with memset.\n\t(pop_scope): Adjust to match.  Set DECL_CONTEXT on everything\n\tin file scope, even if it's in external scope too.\n\t(pushdecl): Adjust to match.  Create invisible file-scope\n\tdeclarations for block-scope forward declarations of static functions.\n\t(pushtag, warn_if_shadowing, pushdecl_top_level, implicitly_declare)\n\t(undeclared_variable, lookup_label, declare_label, define_label)\n\t(lookup_tag, lookup_name, lookup_name_in_scope, builtin_function)\n\t(c_make_fname_decl, store_parm_decls_newstyle, identifier_global_value)\n\t(store_parm_decls_oldstyle): Adjust to match.\n\t(diagnose_mismatched_decls): Correct handling of linkage clashes.\n\t(merge_decls): No need to copy C_DECL_IN_EXTERNAL_SCOPE.\n\n\t* c-tree.h (C_DECL_IN_EXTERNAL_SCOPE): Delete.\n\t(C_DECL_DECLARED_BUILTIN, C_DECL_REGISTER): Slide down one.\n\nFrom-SVN: r84046", "tree": {"sha": "5f3741dfcf03c7efdb7ed86105d521508a573a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f3741dfcf03c7efdb7ed86105d521508a573a4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/comments", "author": null, "committer": null, "parents": [{"sha": "ece95d900ed3c5224e591f3eb98234945aa3b942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece95d900ed3c5224e591f3eb98234945aa3b942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece95d900ed3c5224e591f3eb98234945aa3b942"}], "stats": {"total": 281, "additions": 188, "deletions": 93}, "files": [{"sha": "7d66641a6e8ccdd21c55f12fcb02fefec3b37a46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "patch": "@@ -1,3 +1,28 @@\n+2004-07-02  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (struct c_binding): Remove contour field; add\n+\tdepth, invisible, nested fields.\n+\t(B_IN_SCOPE, B_IN_CURRENT_SCOPE, B_IN_FILE_SCOPE)\n+\t(B_IN_EXTERNAL_SCOPE): New convenience macros.\n+\t(bind): Add invisible and nested arguments. Initialize\n+\tnew fields of struct c_binding; adjust loop scanning for\n+\tinsertion point.\n+\t(free_binding_and_advance): Clear structure with memset.\n+\t(pop_scope): Adjust to match.  Set DECL_CONTEXT on everything\n+\tin file scope, even if it's in external scope too.\n+\t(pushdecl): Adjust to match.  Create invisible file-scope\n+\tdeclarations for block-scope forward declarations of static functions.\n+\t(pushtag, warn_if_shadowing, pushdecl_top_level, implicitly_declare)\n+\t(undeclared_variable, lookup_label, declare_label, define_label)\n+\t(lookup_tag, lookup_name, lookup_name_in_scope, builtin_function)\n+\t(c_make_fname_decl, store_parm_decls_newstyle, identifier_global_value)\n+\t(store_parm_decls_oldstyle): Adjust to match.\n+\t(diagnose_mismatched_decls): Correct handling of linkage clashes.\n+\t(merge_decls): No need to copy C_DECL_IN_EXTERNAL_SCOPE.\n+\n+\t* c-tree.h (C_DECL_IN_EXTERNAL_SCOPE): Delete.\n+\t(C_DECL_DECLARED_BUILTIN, C_DECL_REGISTER): Slide down one.\n+\n 2004-07-02  Richard Henderson  <rth@redhat.com>\n \n \t* c-decl.c (grokdeclarator): Don't frob current_function_decl\n@@ -118,7 +143,7 @@\n \t* c-typeck.c (lvalue_p): Don't handle it.\n \t* expr.c (safe_from_p): Likewise.\n \t(expand_expr_real_1): Likewise.\n-\t* fold-const.c (non_lvalue, operand_equal_p, fold): Likewise.\t\n+\t* fold-const.c (non_lvalue, operand_equal_p, fold): Likewise.\n \t(fold_checksum_tree, tree_expr_nonnegative_p): Likewise.\n \t* gengtype.c (adjust_field_tree_exp): Likewise.\n \t* stmt.c (warn_if_unused_value): Likewise.\n@@ -246,7 +271,7 @@\n \t* builtins.c (expand_builtin_prefetch, expand_builtin_profile_func,\n \texpand_builtin): Likewise.\n \t* calls.c (expand_call, emit_library_call_value_1, store_one_arg):\n-\tLikewise. \n+\tLikewise.\n \t* combine.c (can_combine_p, combinable_i3pat, try_combine,\n \tfind_split_point, combine_simplify_rtx, simplify_set, make_extraction,\n \trtx_equal_for_field_assignment_p, gen_lowpart_for_combine,\n@@ -278,12 +303,12 @@\n \temit_move_insn_1, expand_assignment, store_expr,\n \tstore_constructor_field, store_constructor, store_field,\n \tforce_operand, safe_from_p, expand_expr_real_1, expand_increment):\n-\tLikewise. \n+\tLikewise.\n \t* final.c (cleanup_subreg_operands, alter_subreg,\n \tget_mem_expr_from_op): Likewise.\n \t* flow.c (notice_stack_pointer_modification_1,\n \tinit_propagate_block_info, insn_dead_p, mark_set_1, mark_used_regs):\n-\tLikewise. \n+\tLikewise.\n \t* function.c (mark_temp_addr_taken, preserve_temp_slots,\n \tpreserve_rtl_expr_result, put_var_into_stack, fixup_var_refs_1,\n \toptimize_bit_field, flush_addressof, purge_addressof_1,\n@@ -393,7 +418,7 @@\n \timport_export_class.\n \t* target-def.h (TARGET_CXX): Initialise the new field.\n \t(TARGET_CXX_IMPORT_EXPORT_CLASS): Provide a default value for\n-\tthe new field.  \n+\tthe new field.\n \t* doc/tm.texi: Document the new target hook.\n \n 2004-07-01  Paolo Bonzini  <bonzini@gnu.org>"}, {"sha": "b6abc3ccc940f3d0848430372b859b305f0c3f50", "filename": "gcc/c-decl.c", "status": "modified", "additions": 156, "deletions": 82, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "patch": "@@ -155,25 +155,39 @@ bool c_override_global_bindings_to_false;\n    chained together by the ->prev field, which (as the name implies)\n    runs in reverse order.  All the decls in a given namespace bound to\n    a given identifier are chained by the ->shadowed field, which runs\n-   from inner to outer scopes.  Finally, the ->contour field points\n-   back to the relevant scope structure; this is mainly used to make\n-   decls in the externals scope invisible (see below).\n+   from inner to outer scopes.\n \n    The ->decl field usually points to a DECL node, but there are two\n    exceptions.  In the namespace of type tags, the bound entity is a\n    RECORD_TYPE, UNION_TYPE, or ENUMERAL_TYPE node.  If an undeclared\n    identifier is encountered, it is bound to error_mark_node to\n    suppress further errors about that identifier in the current\n-   function.  */\n+   function.\n+\n+   The depth field is copied from the scope structure that holds this\n+   decl.  It is used to preserve the proper ordering of the ->shadowed\n+   field (see bind()) and also for a handful of special-case checks.\n+   Finally, the invisible bit is true for a decl which should be\n+   ignored for purposes of normal name lookup, and the nested bit is\n+   true for a decl that's been bound a second time in an inner scope;\n+   in all such cases, the binding in the outer scope will have its\n+   invisible bit true.  */\n \n struct c_binding GTY((chain_next (\"%h.prev\")))\n {\n   tree decl;\t\t\t/* the decl bound */\n   tree id;\t\t\t/* the identifier it's bound to */\n   struct c_binding *prev;\t/* the previous decl in this scope */\n   struct c_binding *shadowed;\t/* the innermost decl shadowed by this one */\n-  struct c_scope *contour;\t/* the scope in which this decl is bound */\n+  unsigned int depth : 28;      /* depth of this scope */\n+  BOOL_BITFIELD invisible : 1;  /* normal lookup should ignore this binding */\n+  BOOL_BITFIELD nested : 1;     /* do not set DECL_CONTEXT when popping */\n+  /* two free bits */\n };\n+#define B_IN_SCOPE(b1, b2) ((b1)->depth == (b2)->depth)\n+#define B_IN_CURRENT_SCOPE(b) ((b)->depth == current_scope->depth)\n+#define B_IN_FILE_SCOPE(b) ((b)->depth == 1 /*file_scope->depth*/)\n+#define B_IN_EXTERNAL_SCOPE(b) ((b)->depth == 0 /*external_scope->depth*/)\n \n #define I_SYMBOL_BINDING(node) \\\n   (((struct lang_identifier *)IDENTIFIER_NODE_CHECK(node))->symbol_binding)\n@@ -403,7 +417,7 @@ c_print_identifier (FILE *file, tree node, int indent)\n    which may be any of several kinds of DECL or TYPE or error_mark_node,\n    in the scope SCOPE.  */\n static void\n-bind (tree name, tree decl, struct c_scope *scope)\n+bind (tree name, tree decl, struct c_scope *scope, bool invisible, bool nested)\n {\n   struct c_binding *b, **here;\n \n@@ -418,7 +432,9 @@ bind (tree name, tree decl, struct c_scope *scope)\n   b->shadowed = 0;\n   b->decl = decl;\n   b->id = name;\n-  b->contour = scope;\n+  b->depth = scope->depth;\n+  b->invisible = invisible;\n+  b->nested = nested;\n \n   b->prev = scope->bindings;\n   scope->bindings = b;\n@@ -446,7 +462,7 @@ bind (tree name, tree decl, struct c_scope *scope)\n   /* Locate the appropriate place in the chain of shadowed decls\n      to insert this binding.  Normally, scope == current_scope and\n      this does nothing.  */\n-  while (*here && (*here)->contour->depth > scope->depth)\n+  while (*here && (*here)->depth > scope->depth)\n     here = &(*here)->shadowed;\n \n   b->shadowed = *here;\n@@ -462,10 +478,7 @@ free_binding_and_advance (struct c_binding *b)\n {\n   struct c_binding *prev = b->prev;\n \n-  b->id = 0;\n-  b->decl = 0;\n-  b->contour = 0;\n-  b->shadowed = 0;\n+  memset (b, 0, sizeof (struct c_binding));\n   b->prev = binding_freelist;\n   binding_freelist = b;\n \n@@ -742,13 +755,15 @@ pop_scope (void)\n \tcommon_symbol:\n \t  /* All of these go in BLOCK_VARS, but only if this is the\n \t     binding in the home scope.  */\n-\t  if (!C_DECL_IN_EXTERNAL_SCOPE (p) || scope == external_scope)\n+\t  if (!b->nested)\n \t    {\n \t      TREE_CHAIN (p) = BLOCK_VARS (block);\n \t      BLOCK_VARS (block) = p;\n \t    }\n-\t  /* If this is the file scope, must set DECL_CONTEXT on these.  */\n-\t  if (!C_DECL_IN_EXTERNAL_SCOPE (p) && scope == file_scope)\n+\t  /* If this is the file scope, must set DECL_CONTEXT on\n+\t     these.  Do so even for externals, so that\n+\t     same_translation_unit_p works.  */\n+\t  if (scope == file_scope)\n \t    DECL_CONTEXT (p) = context;\n \n \t  /* Fall through.  */\n@@ -819,7 +834,8 @@ push_file_scope (void)\n   start_fname_decls ();\n \n   for (decl = visible_builtins; decl; decl = TREE_CHAIN (decl))\n-    bind (DECL_NAME (decl), decl, file_scope);\n+    bind (DECL_NAME (decl), decl, file_scope,\n+\t  /*invisible=*/false, /*nested=*/true);\n }\n \n void\n@@ -872,7 +888,7 @@ pushtag (tree name, tree type)\n   /* Record the identifier as the type's name if it has none.  */\n   if (name && !TYPE_NAME (type))\n     TYPE_NAME (type) = name;\n-  bind (name, type, current_scope);\n+  bind (name, type, current_scope, /*invisible=*/false, /*nested=*/false);\n \n   /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the\n      tagged type we just added to the current scope.  This fake\n@@ -1211,33 +1227,47 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n-      /* Mismatched non-static and static is considered poor style.\n-         We only diagnose static then non-static if -Wtraditional,\n-\t because it is the most convenient way to get some effects\n-\t (see e.g.  what unwind-dw2-fde-glibc.c does to the definition\n-\t of _Unwind_Find_FDE in unwind-dw2-fde.c).  Revisit?  */\n+      /* A non-static declaration (even an \"extern\") followed by a\n+\t static declaration is undefined behavior per C99 6.2.2p3-5,7.\n+\t The same is true for a static forward declaration at block\n+\t scope followed by a non-static declaration/definition at file\n+\t scope.  Static followed by non-static at the same scope is\n+\t not undefined behavior, and is the most convenient way to get\n+\t some effects (see e.g.  what unwind-dw2-fde-glibc.c does to\n+\t the definition of _Unwind_Find_FDE in unwind-dw2-fde.c), but\n+\t we do diagnose it if -Wtraditional. */\n       if (TREE_PUBLIC (olddecl) && !TREE_PUBLIC (newdecl))\n \t{\n-\t  /* A static function declaration for a predeclared function\n-\t     that isn't actually built in, silently overrides the\n-\t     default.  Objective C uses these.  See also above.\n-\t     FIXME: Make Objective C use normal builtins.  */\n-\t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && DECL_IS_BUILTIN (olddecl))\n-\t    return false;\n-\t  else\n+\t  /* Two exceptions to the rule.  If olddecl is an extern\n+\t     inline, or a predeclared function that isn't actually\n+\t     built in, newdecl silently overrides olddecl.  The latter\n+\t     occur only in Objective C; see also above.  (FIXME: Make\n+\t     Objective C use normal builtins.)  */\n+\t  if (!DECL_IS_BUILTIN (olddecl)\n+\t      && !(DECL_EXTERNAL (olddecl)\n+\t\t   && DECL_DECLARED_INLINE_P (olddecl)))\n \t    {\n-\t      warning (\"%Jstatic declaration of '%D' follows \"\n-\t\t       \"non-static declaration\", newdecl, newdecl);\n-\t      warned = true;\n+\t      error (\"%Jstatic declaration of '%D' follows \"\n+\t\t     \"non-static declaration\", newdecl, newdecl);\n+\t      locate_old_decl (olddecl, error);\n \t    }\n+\t  return false;\n \t}\n-      else if (TREE_PUBLIC (newdecl) && !TREE_PUBLIC (olddecl)\n-\t       && warn_traditional)\n+      else if (TREE_PUBLIC (newdecl) && !TREE_PUBLIC (olddecl))\n \t{\n-\t  warning (\"%Jnon-static declaration of '%D' follows \"\n-\t\t   \"static declaration\", newdecl, newdecl);\n-\t  warned = true;\n+\t  if (DECL_CONTEXT (olddecl))\n+\t    {\n+\t      error (\"%Jnon-static declaration of '%D' follows \"\n+\t\t     \"static declaration\", newdecl, newdecl);\n+\t      locate_old_decl (olddecl, error);\n+\t      return false;\n+\t    }\n+\t  else if (warn_traditional)\n+\t    {\n+\t      warning (\"%Jnon-static declaration of '%D' follows \"\n+\t\t       \"static declaration\", newdecl, newdecl);\n+\t      warned = true;\n+\t    }\n \t}\n     }\n   else if (TREE_CODE (newdecl) == VAR_DECL)\n@@ -1265,13 +1295,27 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  return false;\n \t}\n \n-      /* Objects declared at file scope: if at least one is 'extern',\n-\t it's fine (6.2.2p4); otherwise the linkage must agree (6.2.2p7).  */\n-      if (DECL_FILE_SCOPE_P (newdecl))\n+      /* Objects declared at file scope: if the first declaration had\n+\t external linkage (even if it was an external reference) the\n+\t second must have external linkage as well, or the behavior is\n+\t undefined.  If the first declaration had internal linkage, then\n+\t the second must too, or else be an external reference (in which\n+\t case the composite declaration still has internal linkage).\n+\t As for function declarations, we warn about the static-then-\n+\t extern case only for -Wtraditional.  See generally 6.2.2p3-5,7.  */\n+      if (DECL_FILE_SCOPE_P (newdecl)\n+\t  && TREE_PUBLIC (newdecl) != TREE_PUBLIC (olddecl))\n \t{\n-\t  if (!DECL_EXTERNAL (newdecl)\n-\t      && !DECL_EXTERNAL (olddecl)\n-\t      && TREE_PUBLIC (newdecl) != TREE_PUBLIC (olddecl))\n+\t  if (DECL_EXTERNAL (newdecl))\n+\t    {\n+\t      if (warn_traditional)\n+\t\t{\n+\t\t  warning (\"%Jnon-static declaration of '%D' follows \"\n+\t\t\t   \"static declaration\", newdecl, newdecl);\n+\t\t  warned = true;\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n \t      if (TREE_PUBLIC (newdecl))\n \t\terror (\"%Jnon-static declaration of '%D' follows \"\n@@ -1286,7 +1330,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t}\n       /* Two objects with the same name declared at the same block\n \t scope must both be external references (6.7p3).  */\n-      else if (DECL_CONTEXT (newdecl) == DECL_CONTEXT (olddecl)\n+      else if (!DECL_FILE_SCOPE_P (newdecl)\n+\t       && DECL_CONTEXT (newdecl) == DECL_CONTEXT (olddecl)\n \t       && (!DECL_EXTERNAL (newdecl) || !DECL_EXTERNAL (olddecl)))\n \t{\n \t  if (DECL_EXTERNAL (newdecl))\n@@ -1618,9 +1663,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t}\n     }\n \n-  /* This bit must not get wiped out.  */\n-  C_DECL_IN_EXTERNAL_SCOPE (newdecl) |= C_DECL_IN_EXTERNAL_SCOPE (olddecl);\n-\n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID.  */\n   {\n@@ -1682,10 +1724,9 @@ warn_if_shadowing (tree new)\n       || (TREE_CODE (new) == PARM_DECL && current_scope->outer->parm_flag))\n     return;\n \n-  /* Is anything being shadowed?  Do not be confused by a second binding\n-     to the same decl in the externals scope.  */\n+  /* Is anything being shadowed?  Invisible decls do not count.  */\n   for (b = I_SYMBOL_BINDING (DECL_NAME (new)); b; b = b->shadowed)\n-    if (b->decl && b->decl != new && b->contour != external_scope)\n+    if (b->decl && b->decl != new && !b->invisible)\n       {\n \ttree old = b->decl;\n \n@@ -1786,6 +1827,7 @@ pushdecl (tree x)\n   tree name = DECL_NAME (x);\n   struct c_scope *scope = current_scope;\n   struct c_binding *b;\n+  bool nested = false;\n \n   /* Functions need the lang_decl data.  */\n   if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_LANG_SPECIFIC (x))\n@@ -1802,7 +1844,7 @@ pushdecl (tree x)\n   /* Anonymous decls are just inserted in the scope.  */\n   if (!name)\n     {\n-      bind (name, x, scope);\n+      bind (name, x, scope, /*invisible=*/false, /*nested=*/false);\n       return x;\n     }\n \n@@ -1814,7 +1856,7 @@ pushdecl (tree x)\n      diagnostics).  In particular, we should not consider possible\n      duplicates in the external scope, or shadowing.  */\n   b = I_SYMBOL_BINDING (name);\n-  if (b && b->contour == scope)\n+  if (b && B_IN_SCOPE (b, scope))\n     {\n       if (duplicate_decls (x, b->decl))\n \treturn b->decl;\n@@ -1839,10 +1881,9 @@ pushdecl (tree x)\n       if (warn_nested_externs\n \t  && scope != file_scope\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n-\twarning (\"nested extern declaration of `%s'\",\n-\t\t IDENTIFIER_POINTER (name));\n+\twarning (\"nested extern declaration of '%D'\", x);\n \n-      while (b && b->contour != external_scope)\n+      while (b && !B_IN_EXTERNAL_SCOPE (b))\n \tb = b->shadowed;\n \n       /* The point of the same_translation_unit_p check here is,\n@@ -1855,23 +1896,47 @@ pushdecl (tree x)\n \t      || same_translation_unit_p (x, b->decl))\n \t  && duplicate_decls (x, b->decl))\n \t{\n-\t  bind (name, b->decl, scope);\n+\t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true);\n \t  return b->decl;\n \t}\n       else if (DECL_EXTERNAL (x) || TREE_PUBLIC (x))\n \t{\n-\t  C_DECL_IN_EXTERNAL_SCOPE (x) = 1;\n-\t  bind (name, x, external_scope);\n+\t  bind (name, x, external_scope, /*invisible=*/true, /*nested=*/false);\n+\t  nested = true;\n \t}\n     }\n+  /* Similarly, a declaration of a function with static linkage at\n+     block scope must be checked against any existing declaration\n+     of that function at file scope.  */\n+  else if (TREE_CODE (x) == FUNCTION_DECL && scope != file_scope\n+\t   && !TREE_PUBLIC (x) && !DECL_INITIAL (x))\n+    {\n+      if (warn_nested_externs && !DECL_IN_SYSTEM_HEADER (x))\n+\twarning (\"nested static declaration of '%D'\", x);\n+\n+      while (b && !B_IN_FILE_SCOPE (b))\n+\tb = b->shadowed;\n+\n+      if (b && same_translation_unit_p (x, b->decl)\n+\t  && duplicate_decls (x, b->decl))\n+\t{\n+\t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true);\n+\t  return b->decl;\n+\t}\n+      else\n+\t{\n+\t  bind (name, x, file_scope, /*invisible=*/true, /*nested=*/false);\n+\t  nested = true;\n+\t}\n+    }      \n \n   warn_if_shadowing (x);\n \n  skip_external_and_shadow_checks:\n   if (TREE_CODE (x) == TYPE_DECL)\n     clone_underlying_type (x);\n \n-  bind (name, x, scope);\n+  bind (name, x, scope, /*invisible=*/false, nested);\n \n   /* If x's type is incomplete because it's based on a\n      structure or union which has not yet been fully declared,\n@@ -1911,6 +1976,7 @@ tree\n pushdecl_top_level (tree x)\n {\n   tree name;\n+  bool nested = false;\n \n   if (TREE_CODE (x) != VAR_DECL)\n     abort ();\n@@ -1922,11 +1988,11 @@ pushdecl_top_level (tree x)\n \n   if (DECL_EXTERNAL (x) || TREE_PUBLIC (x))\n     {\n-      C_DECL_IN_EXTERNAL_SCOPE (x) = 1;\n-      bind (name, x, external_scope);\n+      bind (name, x, external_scope, /*invisible=*/true, /*nested=*/false);\n+      nested = true;\n     }\n   if (file_scope)\n-    bind (name, x, file_scope);\n+    bind (name, x, file_scope, /*invisible=*/false, nested);\n \n   return x;\n }\n@@ -1965,7 +2031,8 @@ implicitly_declare (tree functionid)\n \t file scope.  */\n       if (!DECL_BUILT_IN (decl) && DECL_IS_BUILTIN (decl))\n \t{\n-\t  bind (functionid, decl, file_scope);\n+\t  bind (functionid, decl, file_scope,\n+\t\t/*invisible=*/false, /*nested=*/true);\n \t  return decl;\n \t}\n       else\n@@ -1979,7 +2046,8 @@ implicitly_declare (tree functionid)\n \t      implicit_decl_warning (functionid, decl);\n \t      C_DECL_IMPLICIT (decl) = 1;\n \t    }\n-\t  bind (functionid, decl, current_scope);\n+\t  bind (functionid, decl, current_scope,\n+\t\t/*invisible=*/false, /*nested=*/true);\n \t  return decl;\n \t}\n     }\n@@ -2039,7 +2107,7 @@ undeclared_variable (tree id)\n          will be nonnull but current_function_scope will be null.  */\n       scope = current_function_scope ? current_function_scope : current_scope;\n     }\n-  bind (id, error_mark_node, scope);\n+  bind (id, error_mark_node, scope, /*invisible=*/false, /*nested=*/false);\n }\n \f\n /* Subroutine of lookup_label, declare_label, define_label: construct a\n@@ -2093,7 +2161,8 @@ lookup_label (tree name)\n   label = make_label (name, input_location);\n \n   /* Ordinary labels go in the current function scope.  */\n-  bind (name, label, current_function_scope);\n+  bind (name, label, current_function_scope,\n+\t/*invisible=*/false, /*nested=*/false);\n   return label;\n }\n \n@@ -2109,7 +2178,7 @@ declare_label (tree name)\n \n   /* Check to make sure that the label hasn't already been declared\n      at this scope */\n-  if (b && b->contour == current_scope)\n+  if (b && B_IN_CURRENT_SCOPE (b))\n     {\n       error (\"duplicate label declaration `%s'\", IDENTIFIER_POINTER (name));\n       locate_old_decl (b->decl, error);\n@@ -2122,7 +2191,8 @@ declare_label (tree name)\n   C_DECLARED_LABEL_FLAG (label) = 1;\n \n   /* Declared labels go in the current scope.  */\n-  bind (name, label, current_scope);\n+  bind (name, label, current_scope,\n+\t/*invisible=*/false, /*nested=*/false);\n   return label;\n }\n \n@@ -2162,7 +2232,8 @@ define_label (location_t location, tree name)\n       label = make_label (name, location);\n \n       /* Ordinary labels go in the current function scope.  */\n-      bind (name, label, current_function_scope);\n+      bind (name, label, current_function_scope,\n+\t    /*invisible=*/false, /*nested=*/false);\n     }\n \n   if (warn_traditional && !in_system_header && lookup_name (name))\n@@ -2199,8 +2270,8 @@ lookup_tag (enum tree_code code, tree name, int thislevel_only)\n \t a tag in the file scope.  (Primarily relevant to Objective-C\n \t and its builtin structure tags, which get pushed before the\n \t file scope is created.)  */\n-      if (b->contour == current_scope\n-\t  || (current_scope == file_scope && b->contour == external_scope))\n+      if (B_IN_CURRENT_SCOPE (b)\n+\t  || (current_scope == file_scope && B_IN_EXTERNAL_SCOPE (b)))\n \tthislevel = 1;\n     }\n \n@@ -2248,7 +2319,7 @@ tree\n lookup_name (tree name)\n {\n   struct c_binding *b = I_SYMBOL_BINDING (name);\n-  if (b && (b->contour != external_scope || TREE_CODE (b->decl) == TYPE_DECL))\n+  if (b && !b->invisible)\n     return b->decl;\n   return 0;\n }\n@@ -2261,7 +2332,7 @@ lookup_name_in_scope (tree name, struct c_scope *scope)\n   struct c_binding *b;\n \n   for (b = I_SYMBOL_BINDING (name); b; b = b->shadowed)\n-    if (b->contour == scope)\n+    if (B_IN_SCOPE (b, scope))\n       return b->decl;\n   return 0;\n }\n@@ -2358,7 +2429,8 @@ c_make_fname_decl (tree id, int type_dep)\n   if (current_function_decl)\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n-      bind (id, decl, current_function_scope);\n+      bind (id, decl, current_function_scope,\n+\t    /*invisible=*/false, /*nested=*/false);\n     }\n \n   finish_decl (decl, init, NULL_TREE);\n@@ -2394,8 +2466,7 @@ builtin_function (const char *name, tree type, int function_code,\n   if (I_SYMBOL_BINDING (id))\n     abort ();\n \n-  C_DECL_IN_EXTERNAL_SCOPE (decl) = 1;\n-  bind (id, decl, external_scope);\n+  bind (id, decl, external_scope, /*invisible=*/true, /*nested=*/false);\n \n   /* Builtins in the implementation namespace are made visible without\n      needing to be explicitly declared.  See push_file_scope.  */\n@@ -5807,7 +5878,8 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n-\tbind (DECL_NAME (decl), decl, current_scope);\n+\tbind (DECL_NAME (decl), decl, current_scope,\n+\t      /*invisible=*/false, /*nested=*/false);\n       else\n \terror (\"%Jparameter name omitted\", decl);\n     }\n@@ -5820,13 +5892,15 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n-\tbind (DECL_NAME (decl), decl, current_scope);\n+\tbind (DECL_NAME (decl), decl, current_scope,\n+\t      /*invisible=*/false, /*nested=*/false);\n     }\n \n   /* And all the tag declarations.  */\n   for (decl = tags; decl; decl = TREE_CHAIN (decl))\n     if (TREE_PURPOSE (decl))\n-      bind (TREE_PURPOSE (decl), TREE_VALUE (decl), current_scope);\n+      bind (TREE_PURPOSE (decl), TREE_VALUE (decl), current_scope,\n+\t    /*invisible=*/false, /*nested=*/false);\n }\n \n /* Subroutine of store_parm_decls which handles old-style function\n@@ -5862,7 +5936,7 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n \t}\n \n       b = I_SYMBOL_BINDING (TREE_VALUE (parm));\n-      if (b && b->contour == current_scope)\n+      if (b && B_IN_CURRENT_SCOPE (b))\n \t{\n \t  decl = b->decl;\n \t  /* If we got something other than a PARM_DECL it is an error.  */\n@@ -6454,7 +6528,7 @@ identifier_global_value\t(tree t)\n   struct c_binding *b;\n \n   for (b = I_SYMBOL_BINDING (t); b; b = b->shadowed)\n-    if (b->contour == file_scope || b->contour == external_scope)\n+    if (B_IN_FILE_SCOPE (b) || B_IN_EXTERNAL_SCOPE (b))\n       return b->decl;\n \n   return 0;"}, {"sha": "10c96d4d1b7052fdbc963707b7121d141757b84f", "filename": "gcc/c-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9aaabf8aa725651f3e77826d86a2fb50a3f2745b/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=9aaabf8aa725651f3e77826d86a2fb50a3f2745b", "patch": "@@ -94,18 +94,14 @@ struct lang_type GTY(())\n /* For a FUNCTION_DECL, nonzero if it was an implicit declaration.  */\n #define C_DECL_IMPLICIT(EXP) DECL_LANG_FLAG_2 (EXP)\n \n-/* For any decl, nonzero if it is bound in the externals scope and\n-   pop_scope mustn't chain it into any higher block.  */\n-#define C_DECL_IN_EXTERNAL_SCOPE(EXP) DECL_LANG_FLAG_3 (EXP)\n-\n /* For FUNCTION_DECLs, evaluates true if the decl is built-in but has\n    been declared.  */\n-#define C_DECL_DECLARED_BUILTIN(EXP) DECL_LANG_FLAG_4 (EXP)\n+#define C_DECL_DECLARED_BUILTIN(EXP) DECL_LANG_FLAG_3 (EXP)\n \n /* Record whether a decl was declared register.  This is strictly a\n    front-end flag, whereas DECL_REGISTER is used for code generation;\n    they may differ for structures with volatile fields.  */\n-#define C_DECL_REGISTER(EXP) DECL_LANG_FLAG_5 (EXP)\n+#define C_DECL_REGISTER(EXP) DECL_LANG_FLAG_4 (EXP)\n \n /* Nonzero for a decl which either doesn't exist or isn't a prototype.\n    N.B. Could be simplified if all built-in decls had complete prototypes"}]}