{"sha": "862900112e016aa821f4bd659c3e53ac91853f32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyOTAwMTEyZTAxNmFhODIxZjRiZDY1OWMzZTUzYWM5MTg1M2YzMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-04-04T20:53:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-04-04T20:53:39Z"}, "message": "Makefile.in (tree-ssa-copy.o): Add $(CFGLOOP_H) dependency.\n\n2009-04-04  Richard Guenther  <rguenther@suse.de>\n\n\t* Makefile.in (tree-ssa-copy.o): Add $(CFGLOOP_H) dependency.\n\t* tree-ssa-copy.c (init_copy_prop): Do not propagate through\n\tsingle-argument PHIs if we are in loop-closed SSA form.\n\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Pass extra guards\n\tfor the pre-condition.\n\t(slpeel_tree_peel_loop_to_edge): Likewise.\n\t(vect_build_loop_niters): Take an optional sequence to append stmts.\n\t(vect_generate_tmps_on_preheader): Likewise.\n\t(vect_do_peeling_for_loop_bound): Take extra guards for the\n\tpre-condition.\n\t(vect_do_peeling_for_alignment): Adjust.  Unconditionally apply\n\tthe cost model check.\n\t(vect_loop_versioning): Take stmt and stmt list to put pre-condition\n\tguards if we are going to peel.  Do not apply versioning in that\n\tcase.\n\t* tree-vectorizer.h (vect_loop_versioning): Adjust declaration.\n\t(vect_do_peeling_for_loop_bound): Likewise.\n\t* tree-vect-loop.c (vect_transform_loop): If we are peeling for\n\tloop bound only record extra pre-conditions, do not apply loop\n\tversioning.\n\nFrom-SVN: r145551", "tree": {"sha": "26dd248daf0fd14b57c7421d9111153fca35cc05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26dd248daf0fd14b57c7421d9111153fca35cc05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862900112e016aa821f4bd659c3e53ac91853f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862900112e016aa821f4bd659c3e53ac91853f32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862900112e016aa821f4bd659c3e53ac91853f32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862900112e016aa821f4bd659c3e53ac91853f32/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4d674fc530e3a274c86887967eb820a664787da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d674fc530e3a274c86887967eb820a664787da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d674fc530e3a274c86887967eb820a664787da"}], "stats": {"total": 238, "additions": 162, "deletions": 76}, "files": [{"sha": "b0990589bc48ebdc3e7d057016f1ab776f06f8fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -1,3 +1,26 @@\n+2009-04-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Makefile.in (tree-ssa-copy.o): Add $(CFGLOOP_H) dependency.\n+\t* tree-ssa-copy.c (init_copy_prop): Do not propagate through\n+\tsingle-argument PHIs if we are in loop-closed SSA form.\n+\t* tree-vect-loop-manip.c (slpeel_add_loop_guard): Pass extra guards\n+\tfor the pre-condition.\n+\t(slpeel_tree_peel_loop_to_edge): Likewise.\n+\t(vect_build_loop_niters): Take an optional sequence to append stmts.\n+\t(vect_generate_tmps_on_preheader): Likewise.\n+\t(vect_do_peeling_for_loop_bound): Take extra guards for the\n+\tpre-condition.\n+\t(vect_do_peeling_for_alignment): Adjust.  Unconditionally apply\n+\tthe cost model check.\n+\t(vect_loop_versioning): Take stmt and stmt list to put pre-condition\n+\tguards if we are going to peel.  Do not apply versioning in that\n+\tcase.\n+\t* tree-vectorizer.h (vect_loop_versioning): Adjust declaration.\n+\t(vect_do_peeling_for_loop_bound): Likewise.\n+\t* tree-vect-loop.c (vect_transform_loop): If we are peeling for\n+\tloop bound only record extra pre-conditions, do not apply loop\n+\tversioning.\n+\n 2009-04-04  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-operands.c (pop_stmt_changes): Remove automatic"}, {"sha": "2a0a1775579601ae55325ad00e3ed4ebe9cff52e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -2124,7 +2124,8 @@ tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   $(BASIC_BLOCK_H) tree-pass.h langhooks.h tree-ssa-propagate.h $(FLAGS_H)\n+   $(BASIC_BLOCK_H) tree-pass.h langhooks.h tree-ssa-propagate.h $(FLAGS_H) \\\n+   $(CFGLOOP_H)\n tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "f582ed0f99659c4f7fd34521684b7a767194c710", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n+#include \"cfgloop.h\"\n \n /* This file implements the copy propagation pass and provides a\n    handful of interfaces for performing const/copy propagation and\n@@ -885,7 +886,13 @@ init_copy_prop (void)\n           tree def;\n \n \t  def = gimple_phi_result (phi);\n-\t  if (!is_gimple_reg (def))\n+\t  if (!is_gimple_reg (def)\n+\t      /* In loop-closed SSA form do not copy-propagate through\n+\t         PHI nodes.  Technically this is only needed for loop\n+\t\t exit PHIs, but this is difficult to query.  */\n+\t      || (current_loops\n+\t\t  && gimple_phi_num_args (phi) == 1\n+\t\t  && loops_state_satisfies_p (LOOP_CLOSED_SSA)))\n             prop_set_simulate_again (phi, false);\n \t  else\n             prop_set_simulate_again (phi, true);"}, {"sha": "0edcccb686a83c9dbf467b2e0577502bfeb062f8", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 106, "deletions": 61, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -792,11 +792,12 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, edge e)\n /* Given the condition statement COND, put it as the last statement\n    of GUARD_BB; EXIT_BB is the basic block to skip the loop;\n    Assumes that this is the single exit of the guarded loop.  \n-   Returns the skip edge.  */\n+   Returns the skip edge, inserts new stmts on the COND_EXPR_STMT_LIST.  */\n \n static edge\n-slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n-\t\t       basic_block dom_bb)\n+slpeel_add_loop_guard (basic_block guard_bb, tree cond,\n+\t\t       gimple_seq cond_expr_stmt_list,\n+\t\t       basic_block exit_bb, basic_block dom_bb)\n {\n   gimple_stmt_iterator gsi;\n   edge new_e, enter_e;\n@@ -809,11 +810,13 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n   gsi = gsi_last_bb (guard_bb);\n \n   cond = force_gimple_operand (cond, &gimplify_stmt_list, true, NULL_TREE);\n+  if (gimplify_stmt_list)\n+    gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n   cond_stmt = gimple_build_cond (NE_EXPR,\n \t\t\t\t cond, build_int_cst (TREE_TYPE (cond), 0),\n \t\t\t\t NULL_TREE, NULL_TREE);\n-  if (gimplify_stmt_list)\n-    gsi_insert_seq_after (&gsi, gimplify_stmt_list, GSI_NEW_STMT);\n+  if (cond_expr_stmt_list)\n+    gsi_insert_seq_after (&gsi, cond_expr_stmt_list, GSI_NEW_STMT);\n \n   gsi = gsi_last_bb (guard_bb);\n   gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n@@ -1011,6 +1014,10 @@ set_prologue_iterations (basic_block bb_before_first_loop,\n    The second guard is:\n      if (FIRST_NITERS == NITERS) then skip the second loop.\n \n+   If the optional COND_EXPR and COND_EXPR_STMT_LIST arguments are given\n+   then the generated condition is combined with COND_EXPR and the\n+   statements in COND_EXPR_STMT_LIST are emitted together with it.\n+\n    FORNOW only simple loops are supported (see slpeel_can_duplicate_loop_p).\n    FORNOW the resulting code will not be in loop-closed-ssa form.\n */\n@@ -1019,7 +1026,8 @@ static struct loop*\n slpeel_tree_peel_loop_to_edge (struct loop *loop, \n \t\t\t       edge e, tree first_niters, \n \t\t\t       tree niters, bool update_first_loop_count,\n-\t\t\t       unsigned int th, bool check_profitability)\n+\t\t\t       unsigned int th, bool check_profitability,\n+\t\t\t       tree cond_expr, gimple_seq cond_expr_stmt_list)\n {\n   struct loop *new_loop = NULL, *first_loop, *second_loop;\n   edge skip_e;\n@@ -1149,7 +1157,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n          profitable than the vector one. This occurs when\n \t this function is invoked for epilogue generation\n \t and the cost model check needs to be done at run\n-\t time.\n+\t time.  This check is combined with any pre-existing\n+\t check in COND_EXPR to avoid versioning.\n \n          Resulting CFG after prologue peeling would be:\n \n@@ -1193,6 +1202,14 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n \t  pre_condition = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t       cost_pre_condition, pre_condition);\n \t}\n+      if (cond_expr)\n+\t{\n+\t  pre_condition =\n+\t    fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t pre_condition,\n+\t\t\t fold_build1 (TRUTH_NOT_EXPR, boolean_type_node,\n+\t\t\t\t      cond_expr));\n+\t}\n     }\n \n   /* Prologue peeling.  */  \n@@ -1208,6 +1225,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n     }\n \n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n+\t\t\t\t  cond_expr_stmt_list,\n                                   bb_before_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard1 (skip_e, first_loop,\n \t\t\t\t      first_loop == new_loop,\n@@ -1245,7 +1263,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n \n   pre_condition = \n \tfold_build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n-  skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n+  skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition, NULL,\n                                   bb_after_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,\n                                      second_loop == new_loop, &new_exit_bb);\n@@ -1303,10 +1321,11 @@ find_loop_location (struct loop *loop)\n \n \n /* This function builds ni_name = number of iterations loop executes\n-   on the loop preheader.  */\n+   on the loop preheader.  If SEQ is given the stmt is instead emitted\n+   there.  */\n \n static tree\n-vect_build_loop_niters (loop_vec_info loop_vinfo)\n+vect_build_loop_niters (loop_vec_info loop_vinfo, gimple_seq seq)\n {\n   tree ni_name, var;\n   gimple_seq stmts = NULL;\n@@ -1321,8 +1340,13 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n   pe = loop_preheader_edge (loop);\n   if (stmts)\n     {\n-      basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n+      if (seq)\n+\tgimple_seq_add_seq (&seq, stmts);\n+      else\n+\t{\n+\t  basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n     }\n \n   return ni_name;\n@@ -1335,13 +1359,15 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n  ratio = ni_name / vf\n  ratio_mult_vf_name = ratio * vf\n \n- and places them at the loop preheader edge.  */\n+ and places them at the loop preheader edge or in COND_EXPR_STMT_LIST\n+ if that is non-NULL.  */\n \n static void \n vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo, \n \t\t\t\t tree *ni_name_ptr,\n \t\t\t\t tree *ratio_mult_vf_name_ptr, \n-\t\t\t\t tree *ratio_name_ptr)\n+\t\t\t\t tree *ratio_name_ptr,\n+\t\t\t\t gimple_seq cond_expr_stmt_list)\n {\n \n   edge pe;\n@@ -1361,7 +1387,7 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   /* Generate temporary variable that contains \n      number of iterations loop executes.  */\n \n-  ni_name = vect_build_loop_niters (loop_vinfo);\n+  ni_name = vect_build_loop_niters (loop_vinfo, cond_expr_stmt_list);\n   log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n \n   /* Create: ratio = ni >> log2(vf) */\n@@ -1374,9 +1400,14 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n \n       stmts = NULL;\n       ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n-      pe = loop_preheader_edge (loop);\n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n+      if (cond_expr_stmt_list)\n+\tgimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n+      else\n+\t{\n+\t  pe = loop_preheader_edge (loop);\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n     }\n        \n   /* Create: ratio_mult_vf = ratio << log2 (vf).  */\n@@ -1391,9 +1422,14 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n       stmts = NULL;\n       ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n \t\t\t\t\t\t true, var);\n-      pe = loop_preheader_edge (loop);\n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-      gcc_assert (!new_bb);\n+      if (cond_expr_stmt_list)\n+\tgimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n+      else\n+\t{\n+\t  pe = loop_preheader_edge (loop);\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n     }\n \n   *ni_name_ptr = ni_name;\n@@ -1664,10 +1700,14 @@ conservative_cost_threshold (loop_vec_info loop_vinfo,\n    NITERS % VECTORIZATION_FACTOR times.\n    \n    The original loop will later be made to iterate \n-   NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).  */\n+   NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).\n+\n+   COND_EXPR and COND_EXPR_STMT_LIST are combined with a new generated\n+   test.  */\n \n void \n-vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n+vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n+\t\t\t\ttree cond_expr, gimple_seq cond_expr_stmt_list)\n {\n   tree ni_name, ratio_mult_vf_name;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -1690,15 +1730,17 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n      ratio = ni_name / vf\n      ratio_mult_vf_name = ratio * vf  */\n   vect_generate_tmps_on_preheader (loop_vinfo, &ni_name,\n-\t\t\t\t   &ratio_mult_vf_name, ratio);\n+\t\t\t\t   &ratio_mult_vf_name, ratio,\n+\t\t\t\t   cond_expr_stmt_list);\n \n   loop_num  = loop->num; \n \n   /* If cost model check not done during versioning and \n      peeling for alignment.  */\n   if (!VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n       && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo))\n-      && !LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+      && !LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+      && !cond_expr)\n     {\n       check_profitability = true;\n \n@@ -1711,7 +1753,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n \n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n                                             ratio_mult_vf_name, ni_name, false,\n-                                            th, check_profitability);\n+                                            th, check_profitability,\n+\t\t\t\t\t    cond_expr, cond_expr_stmt_list);\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n #ifdef ENABLE_CHECKING\n@@ -1926,7 +1969,6 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n   tree niters_of_prolog_loop, ni_name;\n   tree n_iters;\n   struct loop *new_loop;\n-  bool check_profitability = false;\n   unsigned int th = 0;\n   int min_profitable_iters;\n \n@@ -1935,28 +1977,20 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo)\n \n   initialize_original_copy_tables ();\n \n-  ni_name = vect_build_loop_niters (loop_vinfo);\n+  ni_name = vect_build_loop_niters (loop_vinfo, NULL);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo, ni_name);\n   \n \n-  /* If cost model check not done during versioning.  */\n-  if (!VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n-      && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    {\n-      check_profitability = true;\n-\n-      /* Get profitability threshold for vectorized loop.  */\n-      min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n-\n-      th = conservative_cost_threshold (loop_vinfo, \n-\t\t\t\t\tmin_profitable_iters);\n-    }\n+  /* Get profitability threshold for vectorized loop.  */\n+  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n+  th = conservative_cost_threshold (loop_vinfo,\n+\t\t\t\t    min_profitable_iters);\n \n   /* Peel the prolog loop and iterate it niters_of_prolog_loop.  */\n   new_loop =\n     slpeel_tree_peel_loop_to_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t   niters_of_prolog_loop, ni_name, true,\n-\t\t\t\t   th, check_profitability);\n+\t\t\t\t   th, true, NULL_TREE, NULL);\n \n   gcc_assert (new_loop);\n #ifdef ENABLE_CHECKING\n@@ -2273,15 +2307,18 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n   \n    The test generated to check which version of loop is executed\n    is modified to also check for profitability as indicated by the \n-   cost model initially.  */\n+   cost model initially.\n+\n+   The versioning precondition(s) are placed in *COND_EXPR and\n+   *COND_EXPR_STMT_LIST.  If DO_VERSIONING is true versioning is\n+   also performed, otherwise only the conditions are generated.  */\n \n void\n-vect_loop_versioning (loop_vec_info loop_vinfo)\n+vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n+\t\t      tree *cond_expr, gimple_seq *cond_expr_stmt_list)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *nloop;\n-  tree cond_expr = NULL_TREE;\n-  gimple_seq cond_expr_stmt_list = NULL;\n   basic_block condition_bb;\n   gimple_stmt_iterator gsi, cond_exp_gsi;\n   basic_block merge_bb;\n@@ -2301,29 +2338,34 @@ vect_loop_versioning (loop_vec_info loop_vinfo)\n   th = conservative_cost_threshold (loop_vinfo,\n \t\t\t\t    min_profitable_iters);\n \n-  cond_expr =\n+  *cond_expr =\n     fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters, \n  \t         build_int_cst (TREE_TYPE (scalar_loop_iters), th));\n \n-  cond_expr = force_gimple_operand (cond_expr, &cond_expr_stmt_list,\n-\t\t\t\t    false, NULL_TREE);\n+  *cond_expr = force_gimple_operand (*cond_expr, cond_expr_stmt_list,\n+\t\t\t\t     false, NULL_TREE);\n \n   if (VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n-      vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,\n-\t\t\t\t\t &cond_expr_stmt_list);\n+      vect_create_cond_for_align_checks (loop_vinfo, cond_expr,\n+\t\t\t\t\t cond_expr_stmt_list);\n \n   if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr, \n-\t\t\t\t       &cond_expr_stmt_list);\n-\n-  cond_expr =\n-    fold_build2 (NE_EXPR, boolean_type_node, cond_expr, integer_zero_node);\n-  cond_expr =\n-    force_gimple_operand (cond_expr, &gimplify_stmt_list, true, NULL_TREE);\n-  gimple_seq_add_seq (&cond_expr_stmt_list, gimplify_stmt_list);\n+    vect_create_cond_for_alias_checks (loop_vinfo, cond_expr,\n+\t\t\t\t       cond_expr_stmt_list);\n+\n+  *cond_expr =\n+    fold_build2 (NE_EXPR, boolean_type_node, *cond_expr, integer_zero_node);\n+  *cond_expr =\n+    force_gimple_operand (*cond_expr, &gimplify_stmt_list, true, NULL_TREE);\n+  gimple_seq_add_seq (cond_expr_stmt_list, gimplify_stmt_list);\n+\n+  /* If we only needed the extra conditions and a new loop copy\n+     bail out here.  */\n+  if (!do_versioning)\n+    return;\n \n   initialize_original_copy_tables ();\n-  nloop = loop_version (loop, cond_expr, &condition_bb,\n+  nloop = loop_version (loop, *cond_expr, &condition_bb,\n \t\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n   free_original_copy_tables();\n \n@@ -2354,10 +2396,13 @@ vect_loop_versioning (loop_vec_info loop_vinfo)\n   /* End loop-exit-fixes after versioning.  */\n \n   update_ssa (TODO_update_ssa);\n-  if (cond_expr_stmt_list)\n+  if (*cond_expr_stmt_list)\n     {\n       cond_exp_gsi = gsi_last_bb (condition_bb);\n-      gsi_insert_seq_before (&cond_exp_gsi, cond_expr_stmt_list, GSI_SAME_STMT);\n+      gsi_insert_seq_before (&cond_exp_gsi, *cond_expr_stmt_list,\n+\t\t\t     GSI_SAME_STMT);\n+      *cond_expr_stmt_list = NULL;\n     }\n+  *cond_expr = NULL_TREE;\n }\n "}, {"sha": "9ae4403f38caadaf80a5af76ca7ee53b8e8f9137", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -3388,23 +3388,33 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool strided_store;\n   bool slp_scheduled = false;\n   unsigned int nunits;\n+  tree cond_expr = NULL_TREE;\n+  gimple_seq cond_expr_stmt_list = NULL;\n+  bool do_peeling_for_loop_bound;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n \n+  /* Peel the loop if there are data refs with unknown alignment.\n+     Only one data ref with unknown store is allowed.  */\n+\n+  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+    vect_do_peeling_for_alignment (loop_vinfo);\n+\n+  do_peeling_for_loop_bound\n+    = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+       || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0));\n+\n   if (VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n       || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    vect_loop_versioning (loop_vinfo);\n+    vect_loop_versioning (loop_vinfo,\n+\t\t\t  !do_peeling_for_loop_bound,\n+\t\t\t  &cond_expr, &cond_expr_stmt_list);\n \n   /* CHECKME: we wouldn't need this if we called update_ssa once\n      for all loops.  */\n   bitmap_zero (vect_memsyms_to_rename);\n-\n-  /* Peel the loop if there are data refs with unknown alignment.\n-     Only one data ref with unknown store is allowed.  */\n-\n-  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n-    vect_do_peeling_for_alignment (loop_vinfo);\n   \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n      compile time constant), or it is a constant that doesn't divide by the\n@@ -3414,10 +3424,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n \n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-          && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0))\n-    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio);\n+  if (do_peeling_for_loop_bound)\n+    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio,\n+\t\t\t\t    cond_expr, cond_expr_stmt_list);\n   else\n     ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);"}, {"sha": "1f3247d1a7550a4ed1c77dc00b71a87bd349abb7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862900112e016aa821f4bd659c3e53ac91853f32/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=862900112e016aa821f4bd659c3e53ac91853f32", "patch": "@@ -706,8 +706,9 @@ extern bitmap vect_memsyms_to_rename;\n    in tree-vect-loop-manip.c.  */\n extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n-extern void vect_loop_versioning (loop_vec_info);\n-extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *);\n+extern void vect_loop_versioning (loop_vec_info, bool, tree *, gimple_seq *);\n+extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n+\t\t\t\t\t    tree, gimple_seq);\n extern void vect_do_peeling_for_alignment (loop_vec_info);\n extern LOC find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);"}]}