{"sha": "78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhlM2U2YWNhMzY4NTVlMTcyNmE5ZDQxYjdkYmQ3YzdmNDE5ZGM0Yg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-02-15T03:57:39Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-02-15T03:57:39Z"}, "message": "libstdc++.exp (dg-test): Lift, temporarily, out of dejagnu/dg.exp.\n\n        * testsuite/lib/libstdc++.exp(dg-test): Lift, temporarily, out of\n        dejagnu/dg.exp.  Adapt to log options used to run testcases.\n\nFrom-SVN: r39704", "tree": {"sha": "519498a490a526c6723aeb1239c5c845afe2ff04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/519498a490a526c6723aeb1239c5c845afe2ff04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b/comments", "author": null, "committer": null, "parents": [{"sha": "4238a754e7532ffe41d20c4de0f5dbd5e62aa2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4238a754e7532ffe41d20c4de0f5dbd5e62aa2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4238a754e7532ffe41d20c4de0f5dbd5e62aa2f4"}], "stats": {"total": 314, "additions": 314, "deletions": 0}, "files": [{"sha": "1f861154f84aeab605d66085895328b075e6193a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "patch": "@@ -1,3 +1,13 @@\n+2001-02-15  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* testsuite/lib/libstdc++.exp: Lift, temporarily, out of\n+        dejagnu/dg.exp.  Adapt to log options used to run testcases.\n+\n+2001-02-13  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n+\n+\t* testsuite/lib/libstdc++.exp(dg-test): Lift temporarily from\n+\tdejagnu/dg.exp.\n+\n 2001-02-13  Dirk Mueller <dmuell@gmx.net>\n             Phil Edwards  <pme@sources.redhat.com>\n "}, {"sha": "d1b8bef14651a39eaac0618acd5a31954619ddda", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=78e3e6aca36855e1726a9d41b7dbd7c7f419dc4b", "patch": "@@ -302,3 +302,307 @@ proc libstdc++-process-options { testfile } {\n \t}\n     }\n }\n+\n+###\n+### The following is an abominal hack, non-recomandable software practice.\n+### This is supposed to be a very-very short term solution.\n+### Please, do not add any piece of code without my approval.\n+### -- Gaby\n+###\n+\n+# dg-test -- runs a new style DejaGnu test\n+#\n+# Syntax: dg-test [-keep-output] prog tool_flags default_extra_tool_flags\n+#\n+# PROG is the full path name of the file to pass to the tool (eg: compiler).\n+# TOOL_FLAGS is a set of options to always pass.\n+# DEFAULT_EXTRA_TOOL_FLAGS are additional options if the testcase has none.\n+\n+#proc dg-test { prog tool_flags default_extra_tool_flags } {\n+proc dg-test { args } {\n+    global dg-do-what-default dg-interpreter-batch-mode dg-linenum-format\n+    global errorCode errorInfo\n+    global tool\n+    global srcdir\t\t;# eg: /calvin/dje/devo/gcc/./testsuite/\n+    global host_triplet target_triplet\n+\n+    set keep 0\n+    set i 0\n+\n+    if { [string index [lindex $args 0] 0] == \"-\" } {\n+\tfor { set i 0 } { $i < [llength $args] } { incr i } {\n+\t    if { [lindex $args $i] == \"--\" } {\n+\t\tincr i\n+\t\tbreak\n+\t    } elseif { [lindex $args $i] == \"-keep-output\" } {\n+\t\tset keep 1\n+\t    } elseif { [string index [lindex $args $i] 0] == \"-\" } {\n+\t\tclone_output \"ERROR: dg-test: illegal argument: [lindex $args $i]\"\n+\t\treturn\n+\t    } else {\n+\t\tbreak\n+\t    }\n+\t}\n+    }\n+\n+    if { $i + 3 != [llength $args] } {\n+\tclone_output \"ERROR: dg-test: missing arguments in call\"\n+\treturn\n+    }\n+    set prog [lindex $args $i]\n+    set tool_flags [lindex $args [expr $i + 1]]\n+    set default_extra_tool_flags [lindex $args [expr $i + 2]]\n+\n+    set text \"\\[- A-Za-z0-9\\.\\;\\\"\\_\\:\\'\\`\\(\\)\\!\\#\\=\\+\\?\\&\\*]*\"\n+\n+    set name [dg-trim-dirname $srcdir $prog]\n+    # If we couldn't rip $srcdir out of `prog' then just do the best we can.\n+    # The point is to reduce the unnecessary noise in the logs.  Don't strip\n+    # out too much because different testcases with the same name can confuse\n+    # `test-tool'.\n+    if [string match \"/*\" $name] {\n+\tset name \"[file tail [file dirname $prog]]/[file tail $prog]\"\n+    }\n+\n+    # Process any embedded dg options in the testcase.\n+\n+    # Use \"\" for the second element of dg-do-what so we can tell if it's been\n+    # explicitly set to \"S\".\n+    set dg-do-what [list ${dg-do-what-default} \"\" P]\n+    set dg-excess-errors-flag 0\n+    set dg-messages \"\"\n+    set dg-extra-tool-flags $default_extra_tool_flags\n+    set dg-final-code \"\"\n+\n+    # `dg-output-text' is a list of two elements: pass/fail and text.\n+    # Leave second element off for now (indicates \"don't perform test\")\n+    set dg-output-text \"P\"\n+\n+    # Define our own \"special function\" `unknown' so we catch spelling errors.\n+    # But first rename the existing one so we can restore it afterwards.\n+    catch {rename dg-save-unknown \"\"}\n+    rename unknown dg-save-unknown\n+    proc unknown { args } {\n+\treturn -code error \"unknown dg option: $args\"\n+    }\n+\n+    set tmp [dg-get-options $prog]\n+    foreach op $tmp {\n+\tverbose \"Processing option: $op\" 3\n+\tset status [catch \"$op\" errmsg]\n+\tif { $status != 0 } {\n+\t    if { 0 && [info exists errorInfo] } {\n+\t\t# This also prints a backtrace which will just confuse\n+\t\t# testcase writers, so it's disabled.\n+\t\tperror \"$name: $errorInfo\\n\"\n+\t    } else {\n+\t\tperror \"$name: $errmsg for \\\"$op\\\"\\n\"\n+\t    }\n+\t    # ??? The call to unresolved here is necessary to clear `errcnt'.\n+\t    # What we really need is a proc like perror that doesn't set errcnt.\n+\t    # It should also set exit_status to 1.\n+\t    unresolved \"$name: $errmsg for \\\"$op\\\"\"\n+\t    return\n+\t}\n+    }\n+\n+    # Restore normal error handling.\n+    rename unknown \"\"\n+    rename dg-save-unknown unknown\n+\n+    # If we're not supposed to try this test on this target, we're done.\n+    if { [lindex ${dg-do-what} 1] == \"N\" } {\n+\tunsupported \"$name\"\n+\tverbose \"$name not supported on this target, skipping it\" 3\n+\treturn\n+    }\n+\n+    # Run the tool and analyze the results.\n+    # The result of ${tool}-dg-test is in a bit of flux.\n+    # Currently it is the name of the output file (or \"\" if none).\n+    # If we need more than this it will grow into a list of things.\n+    # No intention is made (at this point) to preserve upward compatibility\n+    # (though at some point we'll have to).\n+\n+    set results [${tool}-dg-test $prog [lindex ${dg-do-what} 0] \"$tool_flags ${dg-extra-tool-flags}\"];\n+\n+    set comp_output [lindex $results 0];\n+    set output_file [lindex $results 1];\n+\n+    #send_user \"\\nold_dejagnu.exp: comp_output1 = :$comp_output:\\n\\n\"\n+    #send_user \"\\nold_dejagnu.exp: message = :$message:\\n\\n\"\n+    #send_user \"\\nold_dejagnu.exp: message length = [llength $message]\\n\\n\"\n+\n+    foreach i ${dg-messages} {\n+\tverbose \"Scanning for message: $i\" 4\n+\n+\t# Remove all error messages for the line [lindex $i 0]\n+\t# in the source file.  If we find any, success!\n+\tset line [lindex $i 0]\n+\tset pattern [lindex $i 2]\n+\tset comment [lindex $i 3]\n+\t#send_user \"Before:\\n$comp_output\\n\"\n+\tif [regsub -all \"(^|\\n)(\\[^\\n\\]+$line\\[^\\n\\]*($pattern)\\[^\\n\\]*\\n?)+\" $comp_output \"\\n\" comp_output] {\n+            set comp_output [string trimleft $comp_output]\n+\t    set ok pass\n+\t    set uhoh fail\n+\t} else {\n+\t    set ok fail\n+\t    set uhoh pass\n+\t}\n+\t#send_user \"After:\\n$comp_output\\n\"\n+\n+\t# $line will either be a formatted line number or a number all by\n+\t# itself.  Delete the formatting.\n+\tscan $line ${dg-linenum-format} line\n+\tswitch [lindex $i 1] {\n+\t    \"ERROR\" {\n+\t\t$ok \"$name $comment (test for errors, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"XERROR\" {\n+\t\tx$ok \"$name $comment (test for errors, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"WARNING\" {\n+\t\t$ok \"$name $comment (test for warnings, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"XWARNING\" {\n+\t\tx$ok \"$name $comment (test for warnings, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"BOGUS\" {\n+\t\t$uhoh \"$name $comment (test for bogus messages, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"XBOGUS\" {\n+\t\tx$uhoh \"$name $comment (test for bogus messages, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"BUILD\" {\n+\t\t$uhoh \"$name $comment (test for build failure, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"XBUILD\" {\n+\t\tx$uhoh \"$name $comment (test for build failure, line $line), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t    \"EXEC\" { }\n+\t    \"XEXEC\" { }\n+\t}\n+\t#send_user \"\\nold_dejagnu.exp: comp_output2= :$comp_output:\\n\\n\"\n+    }\n+    #send_user \"\\nold_dejagnu.exp: comp_output3 = :$comp_output:\\n\\n\"\n+\n+    # Remove messages from the tool that we can ignore.\n+    #send_user \"comp_output: $comp_output\\n\"\n+    set comp_output [prune_warnings $comp_output]\n+\n+    if { [info proc ${tool}-dg-prune] != \"\" } {\n+\tset comp_output [${tool}-dg-prune $target_triplet $comp_output]\n+\tswitch -glob $comp_output {\n+\t    \"::untested::*\" {\n+\t\tregsub \"::untested::\" $comp_output \"\" message\n+\t\tuntested \"$name: $message\"\n+\t\treturn\n+\t    }\n+\t    \"::unresolved::*\" {\n+\t\tregsub \"::unresolved::\" $comp_output \"\" message\n+\t\tunresolved \"$name: $message\"\n+\t\treturn\n+\t    }\n+\t    \"::unsupported::*\" {\n+\t\tregsub \"::unsupported::\" $comp_output \"\" message\n+\t\tunsupported \"$name: $message\"\n+\t\treturn\n+\t    }\n+\t}\n+    }\n+\n+    # See if someone forgot to delete the extra lines.\n+    regsub -all \"\\n+\" $comp_output \"\\n\" comp_output\n+    regsub \"^\\n+\" $comp_output \"\" comp_output\n+    #send_user \"comp_output: $comp_output\\n\"\n+\n+    # Don't do this if we're testing an interpreter.\n+    # FIXME: why?\n+    if { ${dg-interpreter-batch-mode} == 0 } {\n+\t# Catch excess errors (new bugs or incomplete testcases).\n+\tif ${dg-excess-errors-flag} {\n+\t    setup_xfail \"*-*-*\"\n+\t}\n+\tif ![string match \"\" $comp_output] {\n+\t    fail \"$name (test for excess errors), $tool_flags ${dg-extra-tool-flags}\"\n+\t    send_log \"Excess errors:\\n$comp_output\\n\"\n+\t} else {\n+\t    pass \"$name (test for excess errors), $tool_flags ${dg-extra-tool-flags}\"\n+\t}\n+    }\n+\n+    # Run the executable image if asked to do so.\n+    # FIXME: This is the only place where we assume a standard meaning to\n+    # the `keyword' argument of dg-do.  This could be cleaned up.\n+    if { [lindex ${dg-do-what} 0] == \"run\" } {\n+\tif ![file exists $output_file] {\n+\t    warning \"$name compilation failed to produce executable\"\n+\t} else {\n+\t    set status -1\n+\t    set result [${tool}_load $output_file]\n+\t    set status [lindex $result 0];\n+\t    set output [lindex $result 1];\n+\t    #send_user \"After exec, status: $status\\n\"\n+\t    if { [lindex ${dg-do-what} 2] == \"F\" } {\n+\t\tsetup_xfail \"*-*-*\"\n+\t    }\n+\t    if { \"$status\" == \"pass\" } {\n+\t\tpass \"$name (execution test), $tool_flags ${dg-extra-tool-flags}\"\n+\t\tverbose \"Exec succeeded.\" 3\n+\t\tif { [llength ${dg-output-text}] > 1 } {\n+\t\t    #send_user \"${dg-output-text}\\n\"\n+\t\t    if { [lindex ${dg-output-text} 0] == \"F\" } {\n+\t\t\tsetup_xfail \"*-*-*\"\n+\t\t    }\n+\t\t    set texttmp [lindex ${dg-output-text} 1]\n+\t\t    if { ![regexp $texttmp ${output}] } {\n+\t\t\tfail \"$name output pattern test, is ${output}, should match $texttmp\"\n+\t\t\tverbose \"Failed test for output pattern $texttmp\" 3\n+\t\t    } else {\n+\t\t\tpass \"$name output pattern test, $texttmp\"\n+\t\t\tverbose \"Passed test for output pattern $texttmp\" 3\n+\t\t    }\n+\t\t    unset texttmp\n+\t\t}\n+\t    } elseif { \"$status\" == \"fail\" } {\n+\t\t# It would be nice to get some info out of errorCode.\n+\t\tif [info exists errorCode] {\n+\t\t    verbose \"Exec failed, errorCode: $errorCode\" 3\n+\t\t} else {\n+\t\t    verbose \"Exec failed, errorCode not defined!\" 3\n+\t\t}\n+\t\tfail \"$name (execution test), $tool_flags ${dg-extra-tool-flags}\"\n+\t    } else {\n+\t\t$status \"$name (execution test), $tool_flags ${dg-extra-tool-flags}\"\n+\t    }\n+\t}\n+    }\n+\n+    # Are there any further tests to perform?\n+    # Note that if the program has special run-time requirements, running\n+    # of the program can be delayed until here.  Ditto for other situations.\n+    # It would be a bit cumbersome though.\n+\n+    if ![string match ${dg-final-code} \"\"] {\n+\tregsub -all \"\\\\\\\\(\\[{}\\])\" ${dg-final-code} \"\\\\1\" dg-final-code\n+\t# Note that the use of `args' here makes this a varargs proc.\n+\tproc dg-final-proc { args } ${dg-final-code}\n+\tverbose \"Running dg-final tests.\" 3\n+\tverbose \"dg-final-proc:\\n[info body dg-final-proc]\" 4\n+\tif [catch \"dg-final-proc $prog\" errmsg] {\n+\t    perror \"$name: error executing dg-final: $errmsg\"\n+\t    # ??? The call to unresolved here is necessary to clear `errcnt'.\n+\t    # What we really need is a proc like perror that doesn't set errcnt.\n+\t    # It should also set exit_status to 1.\n+\t    unresolved \"$name: error executing dg-final: $errmsg\"\n+\t}\n+    }\n+\n+    # Do some final clean up.\n+    # When testing an interpreter, we don't compile something and leave an\n+    # output file.\n+    if { ! ${keep} && ${dg-interpreter-batch-mode} == 0 } {\n+\tcatch \"exec rm -f $output_file\"\n+    }\n+}"}]}