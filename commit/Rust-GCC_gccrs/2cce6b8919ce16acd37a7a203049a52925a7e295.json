{"sha": "2cce6b8919ce16acd37a7a203049a52925a7e295", "node_id": "C_kwDOANBUbNoAKDJjY2U2Yjg5MTljZTE2YWNkMzdhN2EyMDMwNDlhNTI5MjVhN2UyOTU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-22T13:07:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-22T13:07:05Z"}, "message": "Merge #873\n\n873: Method resolution should respect deref lang-items r=philberty a=philberty\n\nMethod resolution in rust must respect the autoderef cycle by calling into the deref lang items as required. This\r\nallows for method resolution behind boxing for example. See below for an example gimple dump of two levels\r\nof deref operator overloads. The commit message ee794effe3b55d2aa8acc108fb36bd8d05672dfa holds much\r\nmore detail on the changes in this patch.\r\n\r\n```\r\nvoid main ()\r\n{\r\n  const struct  bar;\r\n  const struct  foo;\r\n  const i32 foobar;\r\n  try\r\n    {\r\n      bar.0 = 123;\r\n      foo.0 = &bar;\r\n      RUSTTMP.3 = <Foo as Deref>::deref<&Bar> (&foo);\r\n      RUSTTMP.5 = <&T as Deref>::deref<Bar> (RUSTTMP.3);\r\n      foobar = Bar::foobar (*RUSTTMP.5);\r\n    }\r\n  finally\r\n    {\r\n      bar = {CLOBBER};\r\n      foo = {CLOBBER};\r\n    }\r\n}\r\n```\r\n\r\nFixes #884 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "0ac934a218d9f65af25065aa4abe94976533cb4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ac934a218d9f65af25065aa4abe94976533cb4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cce6b8919ce16acd37a7a203049a52925a7e295", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh7AF5CRBK7hj4Ov3rIwAATXgIAFXKQXbsmQ3w8+5b2HyfK8+s\n37Xbde/XCam8m6ytBJ1EBQyClasSI8l2vyH2sMw3TMuIe+SQUWoQ3nvBq7PJTLci\nlgbVjq5vglROdiz3+U/kb7RlFsPyFsAhcQyMpAJc0uMelotE5QqDYepZmJnttMFL\n3xc8oEpRNKa5YXygV6X/pY2D2cw+u1HFeqzHAgls+sQvCsSjfMz/RGzSfq3rZXYM\npJYfm4jY5qsIEuFrDd7oiWxT415wZ5Mis4My+zFPZOYIafwF7qMZrgIyZoMYNqUE\nV2RJ9bzl85tQAriz09Za/jzeKtwjnjKSkQdmtXsQ1cZPl4T0XV2qa8LyijsfzhI=\n=bX9M\n-----END PGP SIGNATURE-----\n", "payload": "tree 0ac934a218d9f65af25065aa4abe94976533cb4a\nparent 6c9e57efa5474cfe5d0440e1022ee3c4a8400199\nparent ee794effe3b55d2aa8acc108fb36bd8d05672dfa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642856825 +0000\ncommitter GitHub <noreply@github.com> 1642856825 +0000\n\nMerge #873\n\n873: Method resolution should respect deref lang-items r=philberty a=philberty\n\nMethod resolution in rust must respect the autoderef cycle by calling into the deref lang items as required. This\r\nallows for method resolution behind boxing for example. See below for an example gimple dump of two levels\r\nof deref operator overloads. The commit message ee794effe3b55d2aa8acc108fb36bd8d05672dfa holds much\r\nmore detail on the changes in this patch.\r\n\r\n```\r\nvoid main ()\r\n{\r\n  const struct  bar;\r\n  const struct  foo;\r\n  const i32 foobar;\r\n  try\r\n    {\r\n      bar.0 = 123;\r\n      foo.0 = &bar;\r\n      RUSTTMP.3 = <Foo as Deref>::deref<&Bar> (&foo);\r\n      RUSTTMP.5 = <&T as Deref>::deref<Bar> (RUSTTMP.3);\r\n      foobar = Bar::foobar (*RUSTTMP.5);\r\n    }\r\n  finally\r\n    {\r\n      bar = {CLOBBER};\r\n      foo = {CLOBBER};\r\n    }\r\n}\r\n```\r\n\r\nFixes #884 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cce6b8919ce16acd37a7a203049a52925a7e295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cce6b8919ce16acd37a7a203049a52925a7e295", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cce6b8919ce16acd37a7a203049a52925a7e295/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c9e57efa5474cfe5d0440e1022ee3c4a8400199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c9e57efa5474cfe5d0440e1022ee3c4a8400199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c9e57efa5474cfe5d0440e1022ee3c4a8400199"}, {"sha": "ee794effe3b55d2aa8acc108fb36bd8d05672dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee794effe3b55d2aa8acc108fb36bd8d05672dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee794effe3b55d2aa8acc108fb36bd8d05672dfa"}], "stats": {"total": 1692, "additions": 1002, "deletions": 690}, "files": [{"sha": "f7f248968d6649dbef783ae009f53935a4280137", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -89,6 +89,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-struct.o \\\n     rust/rust-hir-address-taken.o \\\n     rust/rust-hir-type-check-pattern.o \\\n+    rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\"}, {"sha": "902bedce6c43ba7f8640b18233fc0592098e2a26", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -60,6 +60,17 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n \n   bool verify_array_capacities (tree ltype, tree rtype, Location ltype_locus,\n \t\t\t\tLocation rtype_locus);\n+\n+  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t      const Analysis::NodeMapping &mappings,\n+\t\t      Location expr_locus, bool is_qualified_path);\n+\n+  tree resolve_adjustements (std::vector<Resolver::Adjustment> &adjustments,\n+\t\t\t     tree expression, Location locus);\n+\n+  tree resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t tree expression, Location locus);\n };\n \n } // namespace Compile"}, {"sha": "c58d29d0b6ff24797a8a1fc8250aa06c3486394f", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 91, "deletions": 158, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-bounds.h\"\n-#include \"rust-hir-dot-operator.h\"\n #include \"rust-compile-pattern.h\"\n #include \"rust-constexpr.h\"\n \n@@ -574,25 +573,9 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n     expr.get_mappings ().get_hirid (), &adjustments);\n   rust_assert (ok);\n \n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self = ctx->get_backend ()->address_expression (\n-\t    self, expr.get_receiver ()->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  tree expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self = ctx->get_backend ()->indirect_expression (\n-\t    expected_type, self, true, /* known_valid*/\n-\t    expr.get_receiver ()->get_locus ());\n-\t  break;\n-\t}\n-    }\n+  // apply adjustments for the fn call\n+  self = resolve_adjustements (*adjustments, self,\n+\t\t\t       expr.get_receiver ()->get_locus ());\n \n   std::vector<tree> args;\n   args.push_back (self); // adjusted self\n@@ -737,11 +720,10 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   if (resolved_item != nullptr)\n     {\n       if (!fntype->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n-\t\t\t\t\t\t true);\n+\treturn CompileInherentImplItem::Compile (resolved_item, ctx, true);\n \n-      return CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n-\t\t\t\t\t       true, fntype);\n+      return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t\t\t\t\t       fntype);\n     }\n \n   // it might be resolved to a trait item\n@@ -785,24 +767,20 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n     }\n   else\n     {\n-      std::vector<Resolver::Adjustment> adjustments;\n-      Resolver::PathProbeCandidate *candidate\n-\t= Resolver::MethodResolution::Select (candidates, root, adjustments);\n-\n       // FIXME this will be a case to return error_mark_node, there is\n       // an error scenario where a Trait Foo has a method Bar, but this\n       // receiver does not implement this trait or has an incompatible\n       // implementation and we should just return error_mark_node\n-      rust_assert (candidate != nullptr);\n-      rust_assert (candidate->is_impl_candidate ());\n \n-      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+      rust_assert (candidates.size () == 1);\n+      auto &candidate = candidates.at (0);\n+      rust_assert (candidate.is_impl_candidate ());\n+\n+      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n       if (!fntype->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (receiver, impl_item, ctx,\n-\t\t\t\t\t\t true);\n+\treturn CompileInherentImplItem::Compile (impl_item, ctx, true);\n \n-      return CompileInherentImplItem::Compile (receiver, impl_item, ctx, true,\n-\t\t\t\t\t       fntype);\n+      return CompileInherentImplItem::Compile (impl_item, ctx, true, fntype);\n     }\n }\n \n@@ -868,29 +846,8 @@ CompileExpr::resolve_operator_overload (\n     expr.get_mappings ().get_hirid (), &adjustments);\n   rust_assert (ok);\n \n-  // FIXME refactor this out\n-  tree self = lhs;\n-  for (auto &adjustment : *adjustments)\n-    {\n-      switch (adjustment.get_type ())\n-\t{\n-\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n-\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  self\n-\t    = ctx->get_backend ()->address_expression (self,\n-\t\t\t\t\t\t       lhs_expr->get_locus ());\n-\t  break;\n-\n-\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  tree expected_type\n-\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\t  self\n-\t    = ctx->get_backend ()->indirect_expression (expected_type, self,\n-\t\t\t\t\t\t\ttrue, /* known_valid*/\n-\t\t\t\t\t\t\tlhs_expr->get_locus ());\n-\t  break;\n-\t}\n-    }\n+  // apply adjustments for the fn call\n+  tree self = resolve_adjustements (*adjustments, lhs, lhs_expr->get_locus ());\n \n   std::vector<tree> args;\n   args.push_back (self); // adjusted self\n@@ -1221,106 +1178,82 @@ CompileExpr::array_copied_expr (Location expr_locus,\n \t\t\t\t\t\t\t    expr_locus);\n }\n \n-// tree\n-// CompileExpr::array_copied_expr (Location expr_locus, tree array_type,\n-// \t\t\t\tHIR::ArrayElemsCopied &elems)\n-// {\n-//   // create tmp for the result\n-//   fncontext fnctx = ctx->peek_fn ();\n-//   Location start_location = expr_locus;\n-//   Location end_location = expr_locus;\n-//   tree fndecl = fnctx.fndecl;\n-//   tree enclosing_scope = ctx->peek_enclosing_scope ();\n-\n-//   bool is_address_taken = false;\n-//   tree result_var_stmt = nullptr;\n-//   Bvariable *result\n-//     = ctx->get_backend ()->temporary_variable (fnctx.fndecl,\n-//     enclosing_scope,\n-// \t\t\t\t\t       array_type, NULL,\n-// \t\t\t\t\t       is_address_taken, expr_locus,\n-// \t\t\t\t\t       &result_var_stmt);\n-//   ctx->add_statement (result_var_stmt);\n-\n-//   // get the compiled value\n-//   tree translated_expr = CompileExpr::Compile (elems.get_elem_to_copy (),\n-//   ctx);\n-\n-//   // lets assign each index in the array\n-//   TyTy::BaseType *capacity_tyty = nullptr;\n-//   HirId capacity_ty_id\n-//     = elems.get_num_copies_expr ()->get_mappings ().get_hirid ();\n-//   bool ok = ctx->get_tyctx ()->lookup_type (capacity_ty_id,\n-//   &capacity_tyty); rust_assert (ok); tree capacity_type =\n-//   TyTyResolveCompile::compile (ctx, capacity_tyty); tree capacity_expr =\n-//   CompileExpr::Compile (elems.get_num_copies_expr (), ctx);\n-\n-//   // create a loop for this with assignments to array_index exprs\n-//   tree index_type = capacity_type;\n-//   Bvariable *idx\n-//     = ctx->get_backend ()->temporary_variable (fnctx.fndecl,\n-//     enclosing_scope,\n-// \t\t\t\t\t       index_type, NULL,\n-// \t\t\t\t\t       is_address_taken, expr_locus,\n-// \t\t\t\t\t       &result_var_stmt);\n-//   ctx->add_statement (result_var_stmt);\n-\n-//   // set index to zero\n-//   tree index_lvalue = error_mark_node;\n-//   tree zero = build_int_cst (index_type, 0);\n-//   tree index_assignment\n-//     = ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n-//     index_lvalue,\n-// \t\t\t\t\t\t zero, expr_locus);\n-//   ctx->add_statement (index_assignment);\n-\n-//   // BEGIN loop block\n-//   tree loop_body = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-// \t\t\t\t\t       start_location, end_location);\n-//   ctx->push_block (loop_body);\n-\n-//   // loop predicate\n-//   tree loop_predicate\n-//     = fold_build2_loc (expr_locus.gcc_location (), GE_EXPR,\n-//     boolean_type_node,\n-// \t\t       ctx->get_backend ()->var_expression (idx, expr_locus),\n-// \t\t       capacity_expr);\n-//   tree exit_expr = fold_build1_loc (expr_locus.gcc_location (), EXIT_EXPR,\n-// \t\t\t\t    void_type_node, loop_predicate);\n-//   tree break_stmt\n-//     = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n-//   ctx->add_statement (break_stmt);\n-\n-//   // increment index\n-//   tree increment\n-//     = fold_build2_loc (expr_locus.gcc_location (), POSTINCREMENT_EXPR,\n-// \t\t       index_type,\n-// \t\t       ctx->get_backend ()->var_expression (idx, expr_locus),\n-// \t\t       build_int_cst (index_type, 1));\n-\n-//   // create index_assess\n-//   tree index_access = ctx->get_backend ()->array_index_expression (\n-//     ctx->get_backend ()->var_expression (result, expr_locus), increment,\n-//     expr_locus);\n-\n-//   // create assignment to index_access\n-//   tree array_assignment\n-//     = ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n-//     index_access,\n-// \t\t\t\t\t\t translated_expr, expr_locus);\n-//   ctx->add_statement (array_assignment);\n-\n-//   // END loop block\n-//   ctx->pop_block ();\n-\n-//   tree loop_expr = ctx->get_backend ()->loop_expression (loop_body,\n-//   expr_locus); tree loop_stmt\n-//     = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n-//   ctx->add_statement (loop_stmt);\n-\n-//   // result is the tmp\n-//   return ctx->get_backend ()->var_expression (result, expr_locus);\n-// }\n+tree\n+HIRCompileBase::resolve_adjustements (\n+  std::vector<Resolver::Adjustment> &adjustments, tree expression,\n+  Location locus)\n+{\n+  tree e = expression;\n+  for (auto &adjustment : adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::ERROR:\n+\t  return error_mark_node;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  e = ctx->get_backend ()->address_expression (e, locus);\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  e = resolve_deref_adjustment (adjustment, e, locus);\n+\t  break;\n+\t}\n+    }\n+\n+  return e;\n+}\n+\n+tree\n+HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n+\t\t\t\t\t  tree expression, Location locus)\n+{\n+  rust_assert (adjustment.is_deref_adjustment ());\n+\n+  tree expected_type\n+    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+  if (!adjustment.has_operator_overload ())\n+    {\n+      return ctx->get_backend ()->indirect_expression (expected_type,\n+\t\t\t\t\t\t       expression,\n+\t\t\t\t\t\t       true, /* known_valid*/\n+\t\t\t\t\t\t       locus);\n+    }\n+\n+  TyTy::FnType *lookup = adjustment.get_deref_operator_fn ();\n+  HIR::ImplItem *resolved_item = adjustment.get_deref_hir_item ();\n+\n+  tree fn_address = error_mark_node;\n+  if (!lookup->has_subsititions_defined ())\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t\t\t\t\t\t   nullptr, true, locus);\n+  else\n+    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t\t\t\t\t\t   lookup, true, locus);\n+\n+  // does it need a reference to call\n+  tree adjusted_argument = expression;\n+  bool needs_borrow = adjustment.get_deref_adjustment_type ()\n+\t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n+  if (needs_borrow)\n+    {\n+      adjusted_argument\n+\t= ctx->get_backend ()->address_expression (expression, locus);\n+    }\n+\n+  // make the call\n+  auto fncontext = ctx->peek_fn ();\n+  tree deref_call\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n+\t\t\t\t\t    {adjusted_argument}, nullptr,\n+\t\t\t\t\t    locus);\n+\n+  // do the indirect expression\n+  return ctx->get_backend ()->indirect_expression (expected_type, deref_call,\n+\t\t\t\t\t\t   true, /* known_valid*/\n+\t\t\t\t\t\t   locus);\n+}\n \n } // namespace Compile\n } // namespace Rust"}, {"sha": "82b7c6dbffa6fb2fc6875ba3f4eebd2d39524049", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -34,14 +34,12 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static tree Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n-\t\t       Context *ctx, bool compile_fns,\n+  static tree Compile (HIR::ImplItem *item, Context *ctx, bool compile_fns,\n \t\t       TyTy::BaseType *concrete = nullptr,\n \t\t       bool is_query_mode = false,\n \t\t       Location ref_locus = Location ())\n   {\n-    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n-\t\t\t\t      ref_locus);\n+    CompileInherentImplItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n     if (is_query_mode\n@@ -307,15 +305,13 @@ class CompileInherentImplItem : public HIRCompileBase\n   }\n \n private:\n-  CompileInherentImplItem (const TyTy::BaseType *self, Context *ctx,\n-\t\t\t   bool compile_fns, TyTy::BaseType *concrete,\n-\t\t\t   Location ref_locus)\n-    : HIRCompileBase (ctx), self (self), compile_fns (compile_fns),\n-      concrete (concrete), reference (ctx->get_backend ()->error_expression ()),\n+  CompileInherentImplItem (Context *ctx, bool compile_fns,\n+\t\t\t   TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete),\n+      reference (ctx->get_backend ()->error_expression ()),\n       ref_locus (ref_locus)\n   {}\n \n-  const TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n   tree reference;"}, {"sha": "b3c5ba8eb165ba81e5de306787fbc25e3c1e65a5", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -395,8 +395,7 @@ class CompileItem : public HIRCompileBase\n       }\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (self_lookup, impl_item.get (), ctx,\n-\t\t\t\t\tcompile_fns);\n+      CompileInherentImplItem::Compile (impl_item.get (), ctx, compile_fns);\n   }\n \n   void visit (HIR::ExternBlock &extern_block) override"}, {"sha": "5c727d6df2d9e66cc74ecd6e06ce80eb20bb71c0", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -152,10 +152,10 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   // let the query system figure it out\n   return query_compile (ref, lookup, final_segment, mappings, expr_locus,\n \t\t\tis_qualified_path);\n-} // namespace Compile\n+}\n \n tree\n-ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n+HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t\t\t       const HIR::PathIdentSegment &final_segment,\n \t\t\t       const Analysis::NodeMapping &mappings,\n \t\t\t       Location expr_locus, bool is_qualified_path)\n@@ -194,13 +194,11 @@ ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t  rust_assert (ok);\n \n \t  if (!lookup->has_subsititions_defined ())\n-\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t     true, nullptr, true,\n-\t\t\t\t\t\t     expr_locus);\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t\t\t\t\t\t     nullptr, true, expr_locus);\n \t  else\n-\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t     true, lookup, true,\n-\t\t\t\t\t\t     expr_locus);\n+\t    return CompileInherentImplItem::Compile (resolved_item, ctx, true,\n+\t\t\t\t\t\t     lookup, true, expr_locus);\n \t}\n       else\n \t{\n@@ -278,12 +276,12 @@ ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      rust_assert (ok);\n \n \t      if (!lookup->has_subsititions_defined ())\n-\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t\t true, nullptr, true,\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, true,\n+\t\t\t\t\t\t\t nullptr, true,\n \t\t\t\t\t\t\t expr_locus);\n \t      else\n-\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t\t true, lookup, true,\n+\t\treturn CompileInherentImplItem::Compile (impl_item, ctx, true,\n+\t\t\t\t\t\t\t lookup, true,\n \t\t\t\t\t\t\t expr_locus);\n \n \t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());"}, {"sha": "97a79e27d49e016dc0332cf268108e68b7b85106", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -57,11 +57,6 @@ class ResolvePathRef : public HIRCompileBase\n \t\tconst Analysis::NodeMapping &mappings, Location locus,\n \t\tbool is_qualified_path);\n \n-  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n-\t\t      const HIR::PathIdentSegment &final_segment,\n-\t\t      const Analysis::NodeMapping &mappings,\n-\t\t      Location expr_locus, bool is_qualified_path);\n-\n   tree resolved;\n };\n "}, {"sha": "51affe04c4ce0fe3a8a6160749a89680dd57ef10", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -49,6 +49,7 @@ class CompileVarDecl : public HIRCompileBase\n \n     address_taken_context->lookup_addess_taken (\n       stmt.get_mappings ().get_hirid (), &address_taken);\n+\n     translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n     stmt.get_pattern ()->accept_vis (*this);\n   }"}, {"sha": "b17c4384bb62bbc6833b6fe4ad7505965bef304d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -528,9 +528,8 @@ HIRCompileBase::compute_address_for_trait_item (\n \t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n \t}\n \n-      return CompileInherentImplItem::Compile (root, associated_function, ctx,\n-\t\t\t\t\t       true, lookup_fntype, true,\n-\t\t\t\t\t       locus);\n+      return CompileInherentImplItem::Compile (associated_function, ctx, true,\n+\t\t\t\t\t       lookup_fntype, true, locus);\n     }\n \n   // we can only compile trait-items with a body"}, {"sha": "44f09061bba75b36dbde3dbb978ebe96199429cf", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -0,0 +1,242 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-autoderef.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-dot-operator.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+static bool\n+resolve_operator_overload_fn (\n+  Analysis::RustLangItem::ItemType lang_item_type, const TyTy::BaseType *ty,\n+  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  Adjustment::AdjustmentType *requires_ref_adjustment);\n+\n+bool\n+Adjuster::needs_address (const std::vector<Adjustment> &adjustments)\n+{\n+  for (auto &adjustment : adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Adjustment::AdjustmentType::IMM_REF:\n+\tcase Adjustment::AdjustmentType::MUT_REF:\n+\tcase Adjustment::AdjustmentType::DEREF_REF:\n+\t  return true;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+TyTy::BaseType *\n+Adjuster::adjust_type (const std::vector<Adjustment> &adjustments)\n+{\n+  if (adjustments.size () == 0)\n+    return base->clone ();\n+\n+  return adjustments.back ().get_expected ()->clone ();\n+}\n+\n+Adjustment\n+Adjuster::try_deref_type (const TyTy::BaseType *ty)\n+{\n+  // probe for the lang-item\n+  TyTy::BaseType *resolved_base = ty->clone ();\n+\n+  HIR::ImplItem *impl_item = nullptr;\n+  TyTy::FnType *fn = nullptr;\n+  Adjustment::AdjustmentType requires_ref_adjustment\n+    = Adjustment::AdjustmentType::ERROR;\n+  bool operator_overloaded\n+    = resolve_operator_overload_fn (Analysis::RustLangItem::ItemType::DEREF, ty,\n+\t\t\t\t    &fn, &impl_item, &requires_ref_adjustment);\n+  if (operator_overloaded)\n+    {\n+      resolved_base = fn->get_return_type ()->clone ();\n+    }\n+\n+  bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF;\n+  if (!is_valid_type)\n+    return Adjustment::get_error ();\n+\n+  TyTy::ReferenceType *ref_base\n+    = static_cast<TyTy::ReferenceType *> (resolved_base);\n+\n+  auto infered = ref_base->get_base ()->clone ();\n+\n+  return Adjustment::get_op_overload_deref_adjustment (infered, fn, impl_item,\n+\t\t\t\t\t\t       requires_ref_adjustment);\n+}\n+\n+static bool\n+resolve_operator_overload_fn (\n+  Analysis::RustLangItem::ItemType lang_item_type, const TyTy::BaseType *ty,\n+  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  Adjustment::AdjustmentType *requires_ref_adjustment)\n+{\n+  auto context = TypeCheckContext::get ();\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  // look up lang item for arithmetic type\n+  std::string associated_item_name\n+    = Analysis::RustLangItem::ToString (lang_item_type);\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  if (!lang_item_defined)\n+    return false;\n+\n+  auto segment = HIR::PathIdentSegment (associated_item_name);\n+  auto candidate\n+    = MethodResolver::Probe (ty, HIR::PathIdentSegment (associated_item_name),\n+\t\t\t     true);\n+\n+  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  if (!have_implementation_for_lang_item)\n+    return false;\n+\n+  // Get the adjusted self\n+  Adjuster adj (ty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // is this the case we are recursive\n+  // handle the case where we are within the impl block for this\n+  // lang_item otherwise we end up with a recursive operator overload\n+  // such as the i32 operator overload trait\n+  TypeCheckContextItem &fn_context = context->peek_context ();\n+  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+    {\n+      auto &impl_item = fn_context.get_impl_item ();\n+      HIR::ImplBlock *parent = impl_item.first;\n+      HIR::Function *fn = impl_item.second;\n+\n+      if (parent->has_trait_ref ()\n+\t  && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t{\n+\t  TraitReference *trait_reference\n+\t    = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t  if (!trait_reference->is_error ())\n+\t    {\n+\t      TyTy::BaseType *lookup = nullptr;\n+\t      bool ok = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t      rust_assert (ok);\n+\t      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t      rust_assert (fntype->is_method ());\n+\n+\t      bool is_lang_item_impl\n+\t\t= trait_reference->get_mappings ().get_defid ()\n+\t\t  == respective_lang_item_id;\n+\t      bool self_is_lang_item_self\n+\t\t= fntype->get_self_type ()->is_equal (*adjusted_self);\n+\t      bool recursive_operator_overload\n+\t\t= is_lang_item_impl && self_is_lang_item_self;\n+\n+\t      if (recursive_operator_overload)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+\n+  // rust only support impl item deref operator overloading ie you must have an\n+  // impl block for it\n+  rust_assert (candidate.candidate.type\n+\t       == PathProbeCandidate::CandidateType::IMPL_FUNC);\n+  *impl_item = candidate.candidate.item.impl.impl_item;\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  if (fn->needs_substitution ())\n+    {\n+      if (ty->get_kind () == TyTy::TypeKind::ADT)\n+\t{\n+\t  const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (ty);\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rust_assert (candidate.adjustments.size () < 2);\n+\n+\t  // lets infer the params for this we could probably fix this up by\n+\t  // actually just performing a substitution of a single param but this\n+\t  // seems more generic i think.\n+\t  //\n+\t  // this is the case where we had say Foo<&Bar>> and we have derefed to\n+\t  // the &Bar and we are trying to match a method self of Bar which\n+\t  // requires another deref which is matched to the deref trait impl of\n+\t  // &&T so this requires another reference and deref call\n+\n+\t  lookup = fn->infer_substitions (Location ());\n+\t  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  fn = static_cast<TyTy::FnType *> (lookup);\n+\t  fn->get_self_type ()->unify (adjusted_self);\n+\t  lookup = fn;\n+\t}\n+    }\n+\n+  if (candidate.adjustments.size () > 0)\n+    *requires_ref_adjustment = candidate.adjustments.at (0).get_type ();\n+\n+  *resolved_fn = static_cast<TyTy::FnType *> (lookup);\n+\n+  return true;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "762b3e8673bbb90927dcb10f0f3c5b539ecf55d0", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -29,15 +29,26 @@ class Adjustment\n public:\n   enum AdjustmentType\n   {\n+    ERROR,\n+\n     IMM_REF,\n     MUT_REF,\n     DEREF_REF\n   };\n \n+  // ctor for all adjustments except derefs\n   Adjustment (AdjustmentType type, const TyTy::BaseType *expected)\n-    : type (type), expected (expected)\n+    : Adjustment (type, expected, nullptr, nullptr, AdjustmentType::ERROR)\n   {}\n \n+  static Adjustment get_op_overload_deref_adjustment (\n+    const TyTy::BaseType *expected, TyTy::FnType *fn, HIR::ImplItem *deref_item,\n+    Adjustment::AdjustmentType requires_ref_adjustment)\n+  {\n+    return Adjustment (Adjustment::DEREF_REF, expected, fn, deref_item,\n+\t\t       requires_ref_adjustment);\n+  }\n+\n   AdjustmentType get_type () const { return type; }\n \n   const TyTy::BaseType *get_expected () const { return expected; }\n@@ -52,6 +63,8 @@ class Adjustment\n   {\n     switch (type)\n       {\n+      case AdjustmentType::ERROR:\n+\treturn \"ERROR\";\n       case AdjustmentType::IMM_REF:\n \treturn \"IMM_REF\";\n       case AdjustmentType::MUT_REF:\n@@ -63,66 +76,53 @@ class Adjustment\n     return \"\";\n   }\n \n+  static Adjustment get_error () { return Adjustment{ERROR, nullptr}; }\n+\n+  bool is_error () const { return type == ERROR; }\n+\n+  bool is_deref_adjustment () const { return type == DEREF_REF; }\n+\n+  bool has_operator_overload () const { return deref_operator_fn != nullptr; }\n+\n+  TyTy::FnType *get_deref_operator_fn () const { return deref_operator_fn; }\n+\n+  AdjustmentType get_deref_adjustment_type () const\n+  {\n+    return requires_ref_adjustment;\n+  }\n+\n+  HIR::ImplItem *get_deref_hir_item () const { return deref_item; }\n+\n private:\n+  Adjustment (AdjustmentType type, const TyTy::BaseType *expected,\n+\t      TyTy::FnType *deref_operator_fn, HIR::ImplItem *deref_item,\n+\t      Adjustment::AdjustmentType requires_ref_adjustment)\n+    : type (type), expected (expected), deref_operator_fn (deref_operator_fn),\n+      deref_item (deref_item), requires_ref_adjustment (requires_ref_adjustment)\n+  {}\n+\n   AdjustmentType type;\n   const TyTy::BaseType *expected;\n+\n+  // - only used for deref operator_overloads\n+  //\n+  // the fn that we are calling\n+  TyTy::FnType *deref_operator_fn;\n+  HIR::ImplItem *deref_item;\n+  // operator overloads can requre a reference\n+  Adjustment::AdjustmentType requires_ref_adjustment;\n };\n \n class Adjuster\n {\n public:\n   Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n \n-  static bool needs_address (const std::vector<Adjustment> &adjustments)\n-  {\n-    for (auto &adjustment : adjustments)\n-      {\n-\tswitch (adjustment.get_type ())\n-\t  {\n-\t  case Adjustment::AdjustmentType::IMM_REF:\n-\t  case Adjustment::AdjustmentType::MUT_REF:\n-\t    return true;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-      }\n+  TyTy::BaseType *adjust_type (const std::vector<Adjustment> &adjustments);\n \n-    return false;\n-  }\n+  static bool needs_address (const std::vector<Adjustment> &adjustments);\n \n-  TyTy::BaseType *adjust_type (const std::vector<Adjustment> &adjustments)\n-  {\n-    TyTy::BaseType *ty = base->clone ();\n-    for (auto &adjustment : adjustments)\n-      {\n-\tswitch (adjustment.get_type ())\n-\t  {\n-\t  case Adjustment::AdjustmentType::IMM_REF:\n-\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n-\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n-\t\t\t\t\t  Mutability::Imm);\n-\t    break;\n-\n-\t  case Adjustment::AdjustmentType::MUT_REF:\n-\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n-\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n-\t\t\t\t\t  Mutability::Mut);\n-\t    break;\n-\n-\t  case Adjustment::AdjustmentType::DEREF_REF:\n-\t    // FIXME this really needs to support deref lang-item operator\n-\t    // overloads\n-\t    rust_assert (ty->get_kind () == TyTy::TypeKind::REF);\n-\t    const TyTy::ReferenceType *rr\n-\t      = static_cast<const TyTy::ReferenceType *> (ty);\n-\t    ty = rr->get_base ();\n-\n-\t    break;\n-\t  }\n-      }\n-    return ty;\n-  }\n+  static Adjustment try_deref_type (const TyTy::BaseType *ty);\n \n private:\n   const TyTy::BaseType *base;"}, {"sha": "660590277ac7ef793a65af9681a3aaabc9f635a0", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "modified", "additions": 249, "deletions": 100, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -20,161 +20,310 @@\n #define RUST_HIR_DOT_OPERATOR\n \n #include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-// lookup if method exists for current type\n-// if exists: done\n-// if not: check again for auto-ref and auto-mut-ref\n-// deref and start again with 1.*/\n+struct MethodCandidate\n+{\n+  PathProbeCandidate candidate;\n+  std::vector<Adjustment> adjustments;\n+\n+  static MethodCandidate get_error ()\n+  {\n+    return {PathProbeCandidate::get_error (), {}};\n+  }\n \n-// https://doc.rust-lang.org/nightly/nomicon/dot-operator.html\n+  bool is_error () const { return candidate.is_error (); }\n+};\n \n-class MethodResolution\n+class MethodResolver : public TypeCheckBase\n {\n+protected:\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n public:\n-  static PathProbeCandidate *\n-  Select (std::vector<PathProbeCandidate> &candidates,\n-\t  const TyTy::BaseType *receiver, std::vector<Adjustment> &adjustments)\n+  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n+\t\t\t\tbool autoderef_flag = false)\n   {\n     const TyTy::BaseType *r = receiver;\n+    std::vector<Adjustment> adjustments;\n     while (true)\n       {\n-\tPathProbeCandidate *c = nullptr;\n+\tPathProbeCandidate c = PathProbeCandidate::get_error ();\n+\tconst std::vector<TyTy::TypeBoundPredicate> &specified_bounds\n+\t  = r->get_specified_bounds ();\n \n \t// 1. try raw\n-\tc = Try (candidates, r);\n-\tif (c != nullptr)\n-\t  return c;\n+\tMethodResolver raw (*r, segment_name, specified_bounds);\n+\tc = raw.select ();\n+\tif (!c.is_error ())\n+\t  return MethodCandidate{c, adjustments};\n \n \t// 2. try ref\n \tTyTy::ReferenceType *r1\n \t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t\t     Mutability::Imm);\n-\tc = Try (candidates, r1);\n-\tif (c != nullptr)\n+\tMethodResolver imm_ref (*r1, segment_name, specified_bounds);\n+\tc = imm_ref.select ();\n+\tif (!c.is_error ())\n \t  {\n \t    adjustments.push_back (\n \t      Adjustment (Adjustment::AdjustmentType::IMM_REF, r1));\n-\t    return c;\n+\t    return MethodCandidate{c, adjustments};\n \t  }\n \n \t// 3. try mut ref\n \tTyTy::ReferenceType *r2\n \t  = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n \t\t\t\t     Mutability::Mut);\n-\tc = Try (candidates, r2);\n-\tif (c != nullptr)\n+\tMethodResolver mut_ref (*r2, segment_name, specified_bounds);\n+\tc = mut_ref.select ();\n+\tif (!c.is_error ())\n \t  {\n \t    adjustments.push_back (\n \t      Adjustment (Adjustment::AdjustmentType::MUT_REF, r2));\n-\t    return c;\n+\t    return MethodCandidate{c, adjustments};\n \t  }\n \n \t// 4. deref to to 1, if cannot deref then quit\n-\tbool can_deref = r->get_kind () == TyTy::TypeKind::REF;\n-\tif (!can_deref)\n-\t  return nullptr;\n-\n-\t// FIXME this needs to use deref trait and fall back to unsized to\n-\t// remove array syntax\n-\n-\tconst TyTy::ReferenceType *rr\n-\t  = static_cast<const TyTy::ReferenceType *> (r);\n-\tr = rr->get_base ();\n-\tadjustments.push_back (\n-\t  Adjustment (Adjustment::AdjustmentType::DEREF_REF, r));\n+\tif (autoderef_flag)\n+\t  {\n+\t    return MethodCandidate::get_error ();\n+\t  }\n+\telse\n+\t  {\n+\t    Adjustment deref = Adjuster::try_deref_type (r);\n+\t    if (deref.is_error ())\n+\t      return MethodCandidate::get_error ();\n+\n+\t    r = deref.get_expected ();\n+\t    adjustments.push_back (deref);\n+\t  }\n       }\n-    return nullptr;\n+    return MethodCandidate::get_error ();\n   }\n \n-private:\n-  static PathProbeCandidate *Try (std::vector<PathProbeCandidate> &candidates,\n-\t\t\t\t  const TyTy::BaseType *receiver)\n+protected:\n+  PathProbeCandidate select ()\n   {\n-    TypeCheckContext *context = TypeCheckContext::get ();\n+    struct impl_item_candidate\n+    {\n+      HIR::Function *item;\n+      HIR::ImplBlock *impl_block;\n+      TyTy::FnType *ty;\n+    };\n+\n+    // assemble inherent impl items\n+    std::vector<impl_item_candidate> inherent_impl_fns;\n+    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n+\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n+      bool is_trait_impl = impl->has_trait_ref ();\n+      if (is_trait_impl)\n+\treturn true;\n+\n+      bool is_fn\n+\t= item->get_impl_item_type () == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_fn)\n+\treturn true;\n+\n+      HIR::Function *func = static_cast<HIR::Function *> (item);\n+      if (!func->is_method ())\n+\treturn true;\n+\n+      bool name_matches\n+\t= func->get_function_name ().compare (segment_name.as_string ()) == 0;\n+      if (!name_matches)\n+\treturn true;\n+\n+      TyTy::BaseType *ty = nullptr;\n+      if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\treturn true;\n+      if (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn true;\n+\n+      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+      inherent_impl_fns.push_back ({func, impl, fnty});\n+\n+      return true;\n+    });\n+\n+    struct trait_item_candidate\n+    {\n+      const HIR::TraitItemFunc *item;\n+      const HIR::Trait *trait;\n+      TyTy::FnType *ty;\n+      const TraitReference *reference;\n+      const TraitItemReference *item_ref;\n+    };\n+\n+    std::vector<trait_item_candidate> trait_fns;\n+    mappings->iterate_impl_blocks ([&] (HirId id,\n+\t\t\t\t\tHIR::ImplBlock *impl) mutable -> bool {\n+      bool is_trait_impl = impl->has_trait_ref ();\n+      if (!is_trait_impl)\n+\treturn true;\n+\n+      // look for impl implementation else lookup the associated trait item\n+      for (auto &impl_item : impl->get_impl_items ())\n+\t{\n+\t  bool is_fn = impl_item->get_impl_item_type ()\n+\t\t       == HIR::ImplItem::ImplItemType::FUNCTION;\n+\t  if (!is_fn)\n+\t    continue;\n+\n+\t  HIR::Function *func = static_cast<HIR::Function *> (impl_item.get ());\n+\t  if (!func->is_method ())\n+\t    continue;\n+\n+\t  bool name_matches\n+\t    = func->get_function_name ().compare (segment_name.as_string ())\n+\t      == 0;\n+\t  if (!name_matches)\n+\t    continue;\n \n-    // probe impls\n-    for (auto &c : candidates)\n+\t  TyTy::BaseType *ty = nullptr;\n+\t  if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\t    continue;\n+\t  if (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t    continue;\n+\n+\t  rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+\t  inherent_impl_fns.push_back ({func, impl, fnty});\n+\t  return true;\n+\t}\n+\n+      TraitReference *trait_ref\n+\t= TraitResolver::Resolve (*impl->get_trait_ref ().get ());\n+      rust_assert (!trait_ref->is_error ());\n+\n+      auto item_ref\n+\t= trait_ref->lookup_trait_item (segment_name.as_string (),\n+\t\t\t\t\tTraitItemReference::TraitItemType::FN);\n+      if (item_ref->is_error ())\n+\treturn true;\n+\n+      const HIR::Trait *trait = trait_ref->get_hir_trait_ref ();\n+      HIR::TraitItem *item = item_ref->get_hir_trait_item ();\n+      rust_assert (item->get_item_kind ()\n+\t\t   == HIR::TraitItem::TraitItemKind::FUNC);\n+      HIR::TraitItemFunc *func = static_cast<HIR::TraitItemFunc *> (item);\n+\n+      TyTy::BaseType *ty = item_ref->get_tyty ();\n+      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+      trait_item_candidate candidate{func, trait, fnty, trait_ref, item_ref};\n+      trait_fns.push_back (candidate);\n+\n+      return true;\n+    });\n+\n+    // lookup specified bounds for an associated item\n+    struct precdicate_candidate\n+    {\n+      TyTy::TypeBoundPredicateItem lookup;\n+      TyTy::FnType *fntype;\n+    };\n+\n+    std::vector<precdicate_candidate> predicate_items;\n+    for (auto &bound : specified_bounds)\n       {\n-\tbool is_func = c.type == PathProbeCandidate::CandidateType::IMPL_FUNC;\n-\tHIR::ImplBlock *block = c.item.impl.parent;\n-\tif (is_func && !block->has_trait_ref ())\n+\tTyTy::TypeBoundPredicateItem lookup\n+\t  = bound.lookup_associated_item (segment_name.as_string ());\n+\tif (lookup.is_error ())\n+\t  continue;\n+\n+\tbool is_fn = lookup.get_raw_item ()->get_trait_item_type ()\n+\t\t     == TraitItemReference::TraitItemType::FN;\n+\tif (!is_fn)\n+\t  continue;\n+\n+\tTyTy::BaseType *ty = lookup.get_raw_item ()->get_tyty ();\n+\trust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+\tTyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+\tprecdicate_candidate candidate{lookup, fnty};\n+\tpredicate_items.push_back (candidate);\n+      }\n+\n+    for (auto impl_item : inherent_impl_fns)\n+      {\n+\tTyTy::FnType *fn = impl_item.ty;\n+\trust_assert (fn->is_method ());\n+\n+\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\tif (fn_self->can_eq (&receiver, false))\n \t  {\n-\t    HIR::Function *func\n-\t      = static_cast<HIR::Function *> (c.item.impl.impl_item);\n-\n-\t    TyTy::BaseType *lookup = nullptr;\n-\t    bool ok = context->lookup_type (func->get_mappings ().get_hirid (),\n-\t\t\t\t\t    &lookup);\n-\t    rust_assert (ok);\n-\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-\t    if (fn->is_method ())\n-\t      {\n-\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (fn_self->can_eq (receiver, false, true))\n-\t\t  {\n-\t\t    return &c;\n-\t\t  }\n-\t      }\n+\t    PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n+\t\t\t\t\t\t    impl_item.impl_block};\n+\t    return PathProbeCandidate (\n+\t      PathProbeCandidate::CandidateType::IMPL_FUNC, fn,\n+\t      impl_item.item->get_locus (), c);\n \t  }\n       }\n \n-    // probe trait impls\n-    for (auto &c : candidates)\n+    for (auto trait_item : trait_fns)\n       {\n-\tbool is_func = c.type == PathProbeCandidate::CandidateType::IMPL_FUNC;\n-\tHIR::ImplBlock *block = c.item.impl.parent;\n-\tif (is_func && block->has_trait_ref ())\n+\tTyTy::FnType *fn = trait_item.ty;\n+\trust_assert (fn->is_method ());\n+\n+\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\tif (fn_self->can_eq (&receiver, false))\n \t  {\n-\t    HIR::Function *func\n-\t      = static_cast<HIR::Function *> (c.item.impl.impl_item);\n-\n-\t    TyTy::BaseType *lookup = nullptr;\n-\t    bool ok = context->lookup_type (func->get_mappings ().get_hirid (),\n-\t\t\t\t\t    &lookup);\n-\t    rust_assert (ok);\n-\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-\t    if (fn->is_method ())\n-\t      {\n-\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (fn_self->can_eq (receiver, false, true))\n-\t\t  {\n-\t\t    return &c;\n-\t\t  }\n-\t      }\n+\t    PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n+\t\t\t\t\t\t     trait_item.item_ref,\n+\t\t\t\t\t\t     nullptr};\n+\t    return PathProbeCandidate (\n+\t      PathProbeCandidate::CandidateType::TRAIT_FUNC, fn,\n+\t      trait_item.item->get_locus (), c);\n \t  }\n       }\n \n-    // probe trait bounds\n-    for (auto &c : candidates)\n+    for (auto predicate : predicate_items)\n       {\n-\tbool is_func = c.type == PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\tif (is_func)\n+\tTyTy::FnType *fn = predicate.fntype;\n+\trust_assert (fn->is_method ());\n+\n+\tTyTy::BaseType *fn_self = fn->get_self_type ();\n+\tif (fn_self->can_eq (&receiver, false))\n \t  {\n-\t    const TraitItemReference *item_ref = c.item.trait.item_ref;\n-\t    TyTy::BaseType *lookup = item_ref->get_tyty ();\n-\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-\t    if (fn->is_method ())\n-\t      {\n-\t\tTyTy::BaseType *fn_self = fn->get_self_type ();\n-\t\tif (fn_self->can_eq (receiver, false, true))\n-\t\t  {\n-\t\t    return &c;\n-\t\t  }\n-\t      }\n+\t    const TraitReference *trait_ref\n+\t      = predicate.lookup.get_parent ()->get ();\n+\t    const TraitItemReference *trait_item\n+\t      = predicate.lookup.get_raw_item ();\n+\n+\t    TyTy::BaseType *subst = predicate.lookup.get_tyty_for_receiver (\n+\t      receiver.get_root (),\n+\t      predicate.lookup.get_parent ()->get_generic_args ());\n+\n+\t    PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n+\t\t\t\t\t\t     nullptr};\n+\t    return PathProbeCandidate (\n+\t      PathProbeCandidate::CandidateType::TRAIT_FUNC, subst,\n+\t      trait_item->get_locus (), c);\n \t  }\n       }\n \n-    return nullptr;\n+    return PathProbeCandidate::get_error ();\n   }\n+\n+  MethodResolver (const TyTy::BaseType &receiver,\n+\t\t  const HIR::PathIdentSegment &segment_name,\n+\t\t  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+    : receiver (receiver), segment_name (segment_name),\n+      specified_bounds (specified_bounds)\n+  {}\n+\n+  const TyTy::BaseType &receiver;\n+  const HIR::PathIdentSegment &segment_name;\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds;\n };\n \n } // namespace Resolver"}, {"sha": "2738f9583d3df9663114eaddb0b21c9d7fc01465", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -122,7 +122,7 @@ class OverlappingImplItemPass : public TypeCheckBase\n \t    if (query == candidate)\n \t      continue;\n \n-\t    if (query->can_eq (candidate, false, false))\n+\t    if (query->can_eq (candidate, false))\n \t      possible_collision (it->second, iy->second);\n \t  }\n       }"}, {"sha": "ae88787efb2c70ef2701415a066b024a99d89084", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -32,6 +32,8 @@ struct PathProbeCandidate\n {\n   enum CandidateType\n   {\n+    ERROR,\n+\n     ENUM_VARIANT,\n \n     IMPL_CONST,\n@@ -108,6 +110,19 @@ struct PathProbeCandidate\n     return type == TRAIT_ITEM_CONST || type == TRAIT_TYPE_ALIAS\n \t   || type == TRAIT_FUNC;\n   }\n+\n+  bool is_full_trait_item_candidate () const\n+  {\n+    return is_trait_candidate () && item.trait.impl == nullptr;\n+  }\n+\n+  static PathProbeCandidate get_error ()\n+  {\n+    return PathProbeCandidate (ERROR, nullptr, Location (),\n+\t\t\t       ImplItemCandidate{nullptr, nullptr});\n+  }\n+\n+  bool is_error () const { return type == ERROR; }\n };\n \n class PathProbeType : public TypeCheckBase\n@@ -268,7 +283,7 @@ class PathProbeType : public TypeCheckBase\n     bool ok = context->lookup_type (impl_ty_id, &impl_block_ty);\n     rust_assert (ok);\n \n-    if (!receiver->can_eq (impl_block_ty, false, false))\n+    if (!receiver->can_eq (impl_block_ty, false))\n       return;\n \n     // lets visit the impl_item\n@@ -462,6 +477,7 @@ class ReportMultipleCandidateError : private TypeCheckBase\n       {\n \tswitch (c.type)\n \t  {\n+\t  case PathProbeCandidate::CandidateType::ERROR:\n \t  case PathProbeCandidate::CandidateType::ENUM_VARIANT:\n \t    gcc_unreachable ();\n \t    break;"}, {"sha": "3573c99b775bee1a38440a59d0397548b3405b98", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -234,6 +234,8 @@ class TraitReference\n \t   + \"]\";\n   }\n \n+  const HIR::Trait *get_hir_trait_ref () const { return hir_trait_ref; }\n+\n   const Analysis::NodeMapping &get_mappings () const\n   {\n     return hir_trait_ref->get_mappings ();\n@@ -258,6 +260,24 @@ class TraitReference\n     return false;\n   }\n \n+  bool lookup_trait_item_by_type (const std::string &ident,\n+\t\t\t\t  TraitItemReference::TraitItemType type,\n+\t\t\t\t  TraitItemReference **ref)\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n \t\t\t      const TraitItemReference **ref) const\n   {\n@@ -278,7 +298,7 @@ class TraitReference\n     return false;\n   }\n \n-  const TraitItemReference &\n+  const TraitItemReference *\n   lookup_trait_item (const std::string &ident,\n \t\t     TraitItemReference::TraitItemType type) const\n   {\n@@ -288,9 +308,9 @@ class TraitReference\n \t  continue;\n \n \tif (ident.compare (item.get_identifier ()) == 0)\n-\t  return item;\n+\t  return &item;\n       }\n-    return TraitItemReference::error_node ();\n+    return &TraitItemReference::error_node ();\n   }\n \n   size_t size () const { return item_refs.size (); }"}, {"sha": "fd89953d592cdb7a8d38eb9fb463fc0d751895d3", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 43, "deletions": 109, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -251,53 +251,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n     context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n \n-    // in order to probe of the correct type paths we need the root type, which\n-    // strips any references\n-    const TyTy::BaseType *root = receiver_tyty->get_root ();\n-\n-    // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n-    // method resolution is complex in rust once we start handling generics and\n-    // traits. For now we only support looking up the valid name in impl blocks\n-    // which is simple. There will need to be adjustments to ensure we can turn\n-    // the receiver into borrowed references etc\n-\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-\n-    bool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n-    bool probe_bounds = true;\n-    bool probe_impls = !receiver_is_generic;\n-    bool ignore_mandatory_trait_items = !receiver_is_generic;\n-\n-    auto probe_type = probe_impls ? receiver_tyty : root;\n-    auto candidates\n-      = PathProbeType::Probe (probe_type,\n-\t\t\t      expr.get_method_name ().get_segment (),\n-\t\t\t      probe_impls, probe_bounds,\n-\t\t\t      ignore_mandatory_trait_items);\n-    if (candidates.empty ())\n-      {\n-\tif (probe_impls)\n-\t  {\n-\t    candidates\n-\t      = PathProbeType::Probe (root,\n-\t\t\t\t      expr.get_method_name ().get_segment (),\n-\t\t\t\t      probe_impls, probe_bounds,\n-\t\t\t\t      ignore_mandatory_trait_items);\n-\t  }\n-\n-\tif (candidates.empty ())\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"failed to resolve the PathExprSegment to any item\");\n-\t    return;\n-\t  }\n-      }\n-\n-    std::vector<Adjustment> adjustments;\n-    PathProbeCandidate *resolved_candidate\n-      = MethodResolution::Select (candidates, receiver_tyty, adjustments);\n-    if (resolved_candidate == nullptr)\n+    auto candidate\n+      = MethodResolver::Probe (receiver_tyty,\n+\t\t\t       expr.get_method_name ().get_segment ());\n+    if (candidate.is_error ())\n       {\n \trust_error_at (\n \t  expr.get_method_name ().get_locus (),\n@@ -308,28 +265,29 @@ class TypeCheckExpr : public TypeCheckBase\n \n     // Get the adjusted self\n     Adjuster adj (receiver_tyty);\n-    TyTy::BaseType *adjusted_self = adj.adjust_type (adjustments);\n+    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n \n     // mark the required tree addressable\n-    if (Adjuster::needs_address (adjustments))\n+    if (Adjuster::needs_address (candidate.adjustments))\n       AddressTakenResolver::SetAddressTaken (*expr.get_receiver ().get ());\n \n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (adjustments));\n+\t\t\t\t\tstd::move (candidate.adjustments));\n \n-    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    PathProbeCandidate &resolved_candidate = candidate.candidate;\n+    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n     NodeId resolved_node_id\n-      = resolved_candidate->is_impl_candidate ()\n-\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+      = resolved_candidate.is_impl_candidate ()\n+\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n \t      .get_nodeid ()\n-\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n \t      .get_nodeid ();\n \n     if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate->locus);\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated impl item is not a method\");\n \treturn;\n       }\n@@ -339,11 +297,13 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!fn->is_method ())\n       {\n \tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate->locus);\n+\tr.add_range (resolved_candidate.locus);\n \trust_error_at (r, \"associated function is not a method\");\n \treturn;\n       }\n \n+    auto root = receiver_tyty->get_root ();\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n     if (root->get_kind () == TyTy::TypeKind::ADT)\n       {\n \tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n@@ -369,7 +329,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    // always be at the end of the list\n \n \t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->can_eq (adt, false));\n \t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n \t    const TyTy::ADTType *self_adt\n \t      = static_cast<const TyTy::ADTType *> (s);\n@@ -419,6 +379,8 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n+    // ADT expected but got PARAM\n+\n     TyTy::BaseType *function_ret_tyty\n       = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,\n \t\t\t\t\t   context);\n@@ -1320,10 +1282,6 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n \t\t\t     TyTy::BaseType *rhs)\n   {\n-    // in order to probe of the correct type paths we need the root type, which\n-    // strips any references\n-    const TyTy::BaseType *root = lhs->get_root ();\n-\n     // look up lang item for arithmetic type\n     std::string associated_item_name\n       = Analysis::RustLangItem::ToString (lang_item_type);\n@@ -1335,48 +1293,18 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!lang_item_defined)\n       return false;\n \n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-    bool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n-    bool probe_bounds = true;\n-    bool probe_impls = !receiver_is_generic;\n-    bool ignore_mandatory_trait_items = !receiver_is_generic;\n-\n-    auto probe_type = probe_impls ? lhs : root;\n-    auto candidates\n-      = PathProbeType::Probe (probe_type,\n-\t\t\t      HIR::PathIdentSegment (associated_item_name),\n-\t\t\t      probe_impls, probe_bounds,\n-\t\t\t      ignore_mandatory_trait_items);\n-    if (candidates.empty ())\n-      {\n-\tif (probe_impls)\n-\t  {\n-\t    candidates = PathProbeType::Probe (\n-\t      root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n-\t      probe_bounds, ignore_mandatory_trait_items);\n-\t  }\n+    auto segment = HIR::PathIdentSegment (associated_item_name);\n+    auto candidate\n+      = MethodResolver::Probe (lhs,\n+\t\t\t       HIR::PathIdentSegment (associated_item_name));\n \n-\tif (candidates.empty ())\n-\t  return false;\n-      }\n-\n-    // autoderef to find the relevant method\n-    std::vector<Adjustment> adjustments;\n-    PathProbeCandidate *resolved_candidate\n-      = MethodResolution::Select (candidates, lhs, adjustments);\n-    if (resolved_candidate == nullptr)\n-      return false;\n-\n-    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    bool have_implementation_for_lang_item = !candidate.is_error ();\n     if (!have_implementation_for_lang_item)\n       return false;\n \n-    // mark the required tree addressable\n+    // Get the adjusted self\n     Adjuster adj (lhs);\n-    TyTy::BaseType *receiver_adjusted_self_ty = adj.adjust_type (adjustments);\n-    if (Adjuster::needs_address (adjustments))\n-      AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n+    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n \n     // is this the case we are recursive\n     // handle the case where we are within the impl block for this lang_item\n@@ -1410,8 +1338,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t  = trait_reference->get_mappings ().get_defid ()\n \t\t    == respective_lang_item_id;\n \t\tbool self_is_lang_item_self\n-\t\t  = fntype->get_self_type ()->is_equal (\n-\t\t    *receiver_adjusted_self_ty);\n+\t\t  = fntype->get_self_type ()->is_equal (*adjusted_self);\n \t\tbool recursive_operator_overload\n \t\t  = is_lang_item_impl && self_is_lang_item_self;\n \n@@ -1421,26 +1348,33 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    // now its just like a method-call-expr\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+    // mark the required tree addressable\n+    if (Adjuster::needs_address (candidate.adjustments))\n+      AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n \n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (adjustments));\n+\t\t\t\t\tstd::move (candidate.adjustments));\n \n-    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    PathProbeCandidate &resolved_candidate = candidate.candidate;\n+    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n     NodeId resolved_node_id\n-      = resolved_candidate->is_impl_candidate ()\n-\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+      = resolved_candidate.is_impl_candidate ()\n+\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n \t      .get_nodeid ()\n-\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n \t      .get_nodeid ();\n \n     rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::BaseType *lookup = lookup_tyty;\n     TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n     rust_assert (fn->is_method ());\n \n+    auto root = lhs->get_root ();\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n     if (root->get_kind () == TyTy::TypeKind::ADT)\n       {\n \tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n@@ -1466,7 +1400,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    // always be at the end of the list\n \n \t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->can_eq (adt, false));\n \t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n \t    const TyTy::ADTType *self_adt\n \t      = static_cast<const TyTy::ADTType *> (s);\n@@ -1508,7 +1442,7 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n     rust_assert (type->num_params () > 0);\n     auto fnparam = type->param_at (0);\n-    fnparam.second->unify (receiver_adjusted_self_ty); // typecheck the self\n+    fnparam.second->unify (adjusted_self); // typecheck the self\n     if (rhs == nullptr)\n       {\n \trust_assert (type->num_params () == 1);"}, {"sha": "94d8534fd0631cf7bcce41911e1ce5acc183427a", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -370,7 +370,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static const TraitItemReference &\n+  static const TraitItemReference *\n   Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n \t   TraitReference &trait_reference,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n@@ -383,11 +383,14 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::ConstantItem &constant) override\n   {\n-    resolved_trait_item = trait_reference.lookup_trait_item (\n-      constant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n+    // resolved_trait_item = trait_reference.lookup_trait_item (\n+    //   constant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n+    trait_reference.lookup_trait_item_by_type (\n+      constant.get_identifier (), TraitItemReference::TraitItemType::CONST,\n+      &resolved_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n@@ -401,14 +404,14 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     TyTy::BaseType *lookup;\n     if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n       return;\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       return;\n \n     // check the types are compatible\n-    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true, false))\n+    if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n       {\n \tRichLocation r (constant.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n+\tr.add_range (resolved_trait_item->get_locus ());\n \n \trust_error_at (\n \t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n@@ -419,11 +422,14 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::TypeAlias &type) override\n   {\n-    resolved_trait_item = trait_reference.lookup_trait_item (\n-      type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n+    // resolved_trait_item = trait_reference.lookup_trait_item (\n+    //   type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE);\n+    trait_reference.lookup_trait_item_by_type (\n+      type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE,\n+      &resolved_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n@@ -437,14 +443,14 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     TyTy::BaseType *lookup;\n     if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n       return;\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       return;\n \n     // check the types are compatible\n-    if (!resolved_trait_item.get_tyty ()->can_eq (lookup, true, false))\n+    if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n       {\n \tRichLocation r (type.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n+\tr.add_range (resolved_trait_item->get_locus ());\n \n \trust_error_at (\n \t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n@@ -456,19 +462,22 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     // generic substitutions to the type itself\n     TyTy::ProjectionType *projection = new TyTy::ProjectionType (\n       type.get_mappings ().get_hirid (), lookup, &trait_reference,\n-      resolved_trait_item.get_mappings ().get_defid (), substitutions);\n+      resolved_trait_item->get_mappings ().get_defid (), substitutions);\n \n     context->insert_type (type.get_mappings (), projection);\n-    resolved_trait_item.associated_type_set (projection);\n+    resolved_trait_item->associated_type_set (projection);\n   }\n \n   void visit (HIR::Function &function) override\n   {\n-    resolved_trait_item = trait_reference.lookup_trait_item (\n-      function.get_function_name (), TraitItemReference::TraitItemType::FN);\n+    // resolved_trait_item = trait_reference.lookup_trait_item (\n+    //   function.get_function_name (), TraitItemReference::TraitItemType::FN);\n+    trait_reference.lookup_trait_item_by_type (\n+      function.get_function_name (), TraitItemReference::TraitItemType::FN,\n+      &resolved_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n@@ -482,16 +491,16 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     TyTy::BaseType *lookup;\n     if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n       return;\n-    if (resolved_trait_item.is_error ())\n+    if (resolved_trait_item->is_error ())\n       return;\n \n     rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-    rust_assert (resolved_trait_item.get_tyty ()->get_kind ()\n+    rust_assert (resolved_trait_item->get_tyty ()->get_kind ()\n \t\t == TyTy::TypeKind::FNDEF);\n \n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n     TyTy::FnType *trait_item_fntype\n-      = static_cast<TyTy::FnType *> (resolved_trait_item.get_tyty ());\n+      = static_cast<TyTy::FnType *> (resolved_trait_item->get_tyty ());\n \n     // sets substitute self into the trait_item_ref->tyty\n     TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n@@ -515,10 +524,10 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       = trait_item_fntype->handle_substitions (implicit_self_substs);\n \n     // check the types are compatible\n-    if (!trait_item_fntype->can_eq (fntype, true, false))\n+    if (!trait_item_fntype->can_eq (fntype, true))\n       {\n \tRichLocation r (function.get_locus ());\n-\tr.add_range (resolved_trait_item.get_locus ());\n+\tr.add_range (resolved_trait_item->get_locus ());\n \n \trust_error_at (\n \t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n@@ -533,7 +542,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     TraitReference &trait_reference,\n     std::vector<TyTy::SubstitutionParamMapping> substitutions)\n     : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n-      resolved_trait_item (TraitItemReference::error_node ()),\n+      resolved_trait_item (&TraitItemReference::error_node ()),\n       substitutions (substitutions)\n   {\n     rust_assert (is_trait_impl_block ());\n@@ -542,7 +551,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   bool is_trait_impl_block () const { return !trait_reference.is_error (); }\n \n   TraitReference &trait_reference;\n-  TraitItemReference &resolved_trait_item;\n+  TraitItemReference *resolved_trait_item;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n "}, {"sha": "6692bb6321c405d75ce74f00e74c473cb9d2e034", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -113,15 +113,14 @@ class TypeCheckItem : public TypeCheckBase\n \n     bool is_trait_impl_block = !trait_reference->is_error ();\n \n-    std::vector<std::reference_wrapper<const TraitItemReference>>\n-      trait_item_refs;\n+    std::vector<const TraitItemReference *> trait_item_refs;\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n \tif (!is_trait_impl_block)\n \t  TypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n \telse\n \t  {\n-\t    auto &trait_item_ref\n+\t    auto trait_item_ref\n \t      = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n \t\t\t\t\t\t     impl_item.get (), self,\n \t\t\t\t\t\t     *trait_reference,\n@@ -141,12 +140,11 @@ class TypeCheckItem : public TypeCheckBase\n \tfor (auto &trait_item_ref : trait_reference->get_trait_items ())\n \t  {\n \t    bool found = false;\n-\t    for (const TraitItemReference &implemented_trait_item :\n-\t\t trait_item_refs)\n+\t    for (auto implemented_trait_item : trait_item_refs)\n \t      {\n \t\tstd::string trait_item_name = trait_item_ref.get_identifier ();\n \t\tstd::string impl_item_name\n-\t\t  = implemented_trait_item.get_identifier ();\n+\t\t  = implemented_trait_item->get_identifier ();\n \t\tfound = trait_item_name.compare (impl_item_name) == 0;\n \t\tif (found)\n \t\t  break;"}, {"sha": "b751bcdb3169af7918df20be8ca6efe38d898679", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -251,7 +251,7 @@ class TypeCheckContext\n \n     for (auto &item : it->second)\n       {\n-\tif (item.first->can_eq (self, false, false))\n+\tif (item.first->can_eq (self, false))\n \t  {\n \t    *mapping = item.second;\n \t    return true;"}, {"sha": "478a31235c650f2c351680442314b7cc85926f69", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -40,7 +40,7 @@ TypeBoundsProbe::scan ()\n       if (!ok)\n \treturn true;\n \n-      if (!receiver->can_eq (impl_type, false, false))\n+      if (!receiver->can_eq (impl_type, false))\n \treturn true;\n \n       possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});"}, {"sha": "5620b62b7bda9b21b5a61d22e5cc7cbb2b4df184", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 63, "deletions": 82, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -418,18 +418,17 @@ class BaseCmp : public TyConstVisitor\n   }\n \n protected:\n-  BaseCmp (const BaseType *base, bool emit_errors, bool autoderef_mode)\n+  BaseCmp (const BaseType *base, bool emit_errors)\n     : mappings (Analysis::Mappings::get ()),\n       context (Resolver::TypeCheckContext::get ()), ok (false),\n-      emit_error_flag (emit_errors), autoderef_mode_flag (autoderef_mode)\n+      emit_error_flag (emit_errors)\n   {}\n \n   Analysis::Mappings *mappings;\n   Resolver::TypeCheckContext *context;\n \n   bool ok;\n   bool emit_error_flag;\n-  bool autoderef_mode_flag;\n \n private:\n   /* Returns a pointer to the ty that created this rule. */\n@@ -441,8 +440,8 @@ class InferCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  InferCmp (const InferType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  InferCmp (const InferType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const BoolType &type) override\n@@ -690,8 +689,8 @@ class FnCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnCmp (const FnType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  FnCmp (const FnType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -712,7 +711,7 @@ class FnCmp : public BaseCmp\n \tauto a = base->param_at (i).second;\n \tauto b = type.param_at (i).second;\n \n-\tif (!a->can_eq (b, emit_error_flag, autoderef_mode_flag))\n+\tif (!a->can_eq (b, emit_error_flag))\n \t  {\n \t    emit_error_flag = false;\n \t    BaseCmp::visit (type);\n@@ -721,8 +720,7 @@ class FnCmp : public BaseCmp\n       }\n \n     if (!base->get_return_type ()->can_eq (type.get_return_type (),\n-\t\t\t\t\t   emit_error_flag,\n-\t\t\t\t\t   autoderef_mode_flag))\n+\t\t\t\t\t   emit_error_flag))\n       {\n \temit_error_flag = false;\n \tBaseCmp::visit (type);\n@@ -742,8 +740,8 @@ class FnptrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FnptrCmp (const FnPtr *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  FnptrCmp (const FnPtr *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -767,8 +765,7 @@ class FnptrCmp : public BaseCmp\n \n     auto this_ret_type = base->get_return_type ();\n     auto other_ret_type = type.get_return_type ();\n-    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag,\n-\t\t\t\tautoderef_mode_flag))\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -778,8 +775,7 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i);\n-\tif (!this_param->can_eq (other_param, emit_error_flag,\n-\t\t\t\t autoderef_mode_flag))\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -799,8 +795,7 @@ class FnptrCmp : public BaseCmp\n \n     auto this_ret_type = base->get_return_type ();\n     auto other_ret_type = type.get_return_type ();\n-    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag,\n-\t\t\t\tautoderef_mode_flag))\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -810,8 +805,7 @@ class FnptrCmp : public BaseCmp\n       {\n \tauto this_param = base->param_at (i);\n \tauto other_param = type.param_at (i).second;\n-\tif (!this_param->can_eq (other_param, emit_error_flag,\n-\t\t\t\t autoderef_mode_flag))\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -831,8 +825,8 @@ class ClosureCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ClosureCmp (const ClosureType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ClosureCmp (const ClosureType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n private:\n@@ -845,17 +839,16 @@ class ArrayCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ArrayCmp (const ArrayType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ArrayCmp (const ArrayType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const ArrayType &type) override\n   {\n     // check base type\n     const BaseType *base_element = base->get_element_type ();\n     const BaseType *other_element = type.get_element_type ();\n-    if (!base_element->can_eq (other_element, emit_error_flag,\n-\t\t\t       autoderef_mode_flag))\n+    if (!base_element->can_eq (other_element, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -876,8 +869,8 @@ class BoolCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  BoolCmp (const BoolType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  BoolCmp (const BoolType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const BoolType &type) override { ok = true; }\n@@ -899,8 +892,8 @@ class IntCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  IntCmp (const IntType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  IntCmp (const IntType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -925,8 +918,8 @@ class UintCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  UintCmp (const UintType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  UintCmp (const UintType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -951,8 +944,8 @@ class FloatCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  FloatCmp (const FloatType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  FloatCmp (const FloatType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -977,8 +970,8 @@ class ADTCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ADTCmp (const ADTType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ADTCmp (const ADTType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const ADTType &type) override\n@@ -1020,8 +1013,7 @@ class ADTCmp : public BaseCmp\n \t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n \t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n \n-\t    if (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n-\t\t\t\t\tautoderef_mode_flag))\n+\t    if (!this_field_ty->can_eq (other_field_ty, emit_error_flag))\n \t      {\n \t\tBaseCmp::visit (type);\n \t\treturn;\n@@ -1032,8 +1024,6 @@ class ADTCmp : public BaseCmp\n     ok = true;\n   }\n \n-  void visit (const ParamType &type) override { ok = true; }\n-\n private:\n   const BaseType *get_base () const override { return base; }\n   const ADTType *base;\n@@ -1044,8 +1034,8 @@ class TupleCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  TupleCmp (const TupleType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  TupleCmp (const TupleType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const TupleType &type) override\n@@ -1061,7 +1051,7 @@ class TupleCmp : public BaseCmp\n \tBaseType *bo = base->get_field (i);\n \tBaseType *fo = type.get_field (i);\n \n-\tif (!bo->can_eq (fo, emit_error_flag, autoderef_mode_flag))\n+\tif (!bo->can_eq (fo, emit_error_flag))\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -1083,8 +1073,8 @@ class USizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  USizeCmp (const USizeType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  USizeCmp (const USizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1106,8 +1096,8 @@ class ISizeCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ISizeCmp (const ISizeType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ISizeCmp (const ISizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1129,8 +1119,8 @@ class CharCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  CharCmp (const CharType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  CharCmp (const CharType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const InferType &type) override\n@@ -1152,27 +1142,23 @@ class ReferenceCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ReferenceCmp (const ReferenceType *base, bool emit_errors,\n-\t\tbool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ReferenceCmp (const ReferenceType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const ReferenceType &type) override\n   {\n     auto base_type = base->get_base ();\n     auto other_base_type = type.get_base ();\n \n-    // rust is permissive about mutablity here you can always go from mutable to\n-    // immutable but not the otherway round\n-    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n-    if (!mutability_ok)\n+    bool mutability_match = base->is_mutable () == type.is_mutable ();\n+    if (!mutability_match)\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    if (!base_type->can_eq (other_base_type, emit_error_flag,\n-\t\t\t    autoderef_mode_flag))\n+    if (!base_type->can_eq (other_base_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -1191,8 +1177,8 @@ class PointerCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  PointerCmp (const PointerType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  PointerCmp (const PointerType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const ReferenceType &type) override\n@@ -1209,8 +1195,7 @@ class PointerCmp : public BaseCmp\n \treturn;\n       }\n \n-    if (!base_type->can_eq (other_base_type, emit_error_flag,\n-\t\t\t    autoderef_mode_flag))\n+    if (!base_type->can_eq (other_base_type, emit_error_flag))\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -1229,8 +1214,8 @@ class ParamCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  ParamCmp (const ParamType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  ParamCmp (const ParamType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   // param types are a placeholder we shouldn't have cases where we unify\n@@ -1252,7 +1237,7 @@ class ParamCmp : public BaseCmp\n     bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n     rust_assert (ok);\n \n-    return lookup->can_eq (other, emit_error_flag, autoderef_mode_flag);\n+    return lookup->can_eq (other, emit_error_flag);\n   }\n \n   // imagine the case where we have:\n@@ -1263,16 +1248,14 @@ class ParamCmp : public BaseCmp\n   // generic arguments\n   void visit (const ParamType &) override { ok = true; }\n \n-  void visit (const TupleType &) override { ok = true; }\n-\n-  void visit (const ADTType &) override { ok = true; }\n-\n   void visit (const InferType &) override { ok = true; }\n \n   void visit (const FnType &) override { ok = true; }\n \n   void visit (const FnPtr &) override { ok = true; }\n \n+  void visit (const ADTType &) override { ok = true; }\n+\n   void visit (const ArrayType &) override { ok = true; }\n \n   void visit (const BoolType &) override { ok = true; }\n@@ -1289,9 +1272,9 @@ class ParamCmp : public BaseCmp\n \n   void visit (const CharType &) override { ok = true; }\n \n-  void visit (const ReferenceType &) override { ok = !autoderef_mode_flag; }\n+  void visit (const ReferenceType &) override { ok = true; }\n \n-  void visit (const PointerType &) override { ok = !autoderef_mode_flag; }\n+  void visit (const PointerType &) override { ok = true; }\n \n   void visit (const StrType &) override { ok = true; }\n \n@@ -1315,8 +1298,8 @@ class StrCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  StrCmp (const StrType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  StrCmp (const StrType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const StrType &type) override { ok = true; }\n@@ -1333,8 +1316,8 @@ class NeverCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  NeverCmp (const NeverType *base, bool emit_errors, bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  NeverCmp (const NeverType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const NeverType &type) override { ok = true; }\n@@ -1351,9 +1334,8 @@ class PlaceholderCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  PlaceholderCmp (const PlaceholderType *base, bool emit_errors,\n-\t\t  bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  PlaceholderCmp (const PlaceholderType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   bool can_eq (const BaseType *other) override\n@@ -1362,7 +1344,7 @@ class PlaceholderCmp : public BaseCmp\n       return BaseCmp::can_eq (other);\n \n     BaseType *lookup = base->resolve ();\n-    return lookup->can_eq (other, emit_error_flag, autoderef_mode_flag);\n+    return lookup->can_eq (other, emit_error_flag);\n   }\n \n   void visit (const TupleType &) override { ok = true; }\n@@ -1417,9 +1399,8 @@ class DynamicCmp : public BaseCmp\n   using Rust::TyTy::BaseCmp::visit;\n \n public:\n-  DynamicCmp (const DynamicObjectType *base, bool emit_errors,\n-\t      bool autoderef_mode)\n-    : BaseCmp (base, emit_errors, autoderef_mode), base (base)\n+  DynamicCmp (const DynamicObjectType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n   {}\n \n   void visit (const DynamicObjectType &type) override"}, {"sha": "349813b70769b00d29c0adc9bd4c74b2324a8f99", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -25,9 +25,6 @@\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n \n-extern ::Backend *\n-rust_get_backend ();\n-\n namespace Rust {\n namespace TyTy {\n "}, {"sha": "b5427b71a545d815d46310c346cd92eec7c094ea", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 52, "deletions": 71, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -91,8 +91,12 @@ BaseType::bounds_compatible (const BaseType &other, Location locus,\n \t}\n \n       if (emit_error)\n-\trust_error_at (r, \"bounds not satisfied for %s %<%s%> is not satisfied\",\n-\t\t       other.get_name ().c_str (), missing_preds.c_str ());\n+\t{\n+\t  rust_error_at (r,\n+\t\t\t \"bounds not satisfied for %s %<%s%> is not satisfied\",\n+\t\t\t other.get_name ().c_str (), missing_preds.c_str ());\n+\t  // rust_assert (!emit_error);\n+\t}\n     }\n \n   return unsatisfied_bounds.size () == 0;\n@@ -201,10 +205,9 @@ InferType::unify (BaseType *other)\n }\n \n bool\n-InferType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+InferType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  InferCmp r (this, emit_errors, autoderef_mode);\n+  InferCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -279,8 +282,7 @@ ErrorType::unify (BaseType *other)\n }\n \n bool\n-ErrorType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n {\n   return get_kind () == other->get_kind ();\n }\n@@ -685,10 +687,9 @@ ADTType::cast (BaseType *other)\n }\n \n bool\n-ADTType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t bool autoderef_mode) const\n+ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ADTCmp r (this, emit_errors, autoderef_mode);\n+  ADTCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -888,10 +889,9 @@ TupleType::cast (BaseType *other)\n }\n \n bool\n-TupleType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  TupleCmp r (this, emit_errors, autoderef_mode);\n+  TupleCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -993,10 +993,9 @@ FnType::cast (BaseType *other)\n }\n \n bool\n-FnType::can_eq (const BaseType *other, bool emit_errors,\n-\t\tbool autoderef_mode) const\n+FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  FnCmp r (this, emit_errors, autoderef_mode);\n+  FnCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1211,10 +1210,9 @@ FnPtr::cast (BaseType *other)\n }\n \n bool\n-FnPtr::can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const\n+FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  FnptrCmp r (this, emit_errors, autoderef_mode);\n+  FnptrCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1278,10 +1276,9 @@ ClosureType::unify (BaseType *other)\n }\n \n bool\n-ClosureType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t     bool autoderef_mode) const\n+ClosureType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ClosureCmp r (this, emit_errors, autoderef_mode);\n+  ClosureCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1360,10 +1357,9 @@ ArrayType::cast (BaseType *other)\n }\n \n bool\n-ArrayType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ArrayCmp r (this, emit_errors, autoderef_mode);\n+  ArrayCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1434,10 +1430,9 @@ BoolType::cast (BaseType *other)\n }\n \n bool\n-BoolType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t  bool autoderef_mode) const\n+BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  BoolCmp r (this, emit_errors, autoderef_mode);\n+  BoolCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1501,10 +1496,9 @@ IntType::cast (BaseType *other)\n }\n \n bool\n-IntType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t bool autoderef_mode) const\n+IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  IntCmp r (this, emit_errors, autoderef_mode);\n+  IntCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1579,10 +1573,9 @@ UintType::cast (BaseType *other)\n }\n \n bool\n-UintType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t  bool autoderef_mode) const\n+UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  UintCmp r (this, emit_errors, autoderef_mode);\n+  UintCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1651,10 +1644,9 @@ FloatType::cast (BaseType *other)\n }\n \n bool\n-FloatType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  FloatCmp r (this, emit_errors, autoderef_mode);\n+  FloatCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1715,10 +1707,9 @@ USizeType::cast (BaseType *other)\n }\n \n bool\n-USizeType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  USizeCmp r (this, emit_errors, autoderef_mode);\n+  USizeCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1768,10 +1759,9 @@ ISizeType::cast (BaseType *other)\n }\n \n bool\n-ISizeType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ISizeCmp r (this, emit_errors, autoderef_mode);\n+  ISizeCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1821,10 +1811,9 @@ CharType::cast (BaseType *other)\n }\n \n bool\n-CharType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t  bool autoderef_mode) const\n+CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  CharCmp r (this, emit_errors, autoderef_mode);\n+  CharCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1875,10 +1864,9 @@ ReferenceType::cast (BaseType *other)\n }\n \n bool\n-ReferenceType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t       bool autoderef_mode) const\n+ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ReferenceCmp r (this, emit_errors, autoderef_mode);\n+  ReferenceCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -1962,10 +1950,9 @@ PointerType::cast (BaseType *other)\n }\n \n bool\n-PointerType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t     bool autoderef_mode) const\n+PointerType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  PointerCmp r (this, emit_errors, autoderef_mode);\n+  PointerCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -2072,10 +2059,9 @@ ParamType::cast (BaseType *other)\n }\n \n bool\n-ParamType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  ParamCmp r (this, emit_errors, autoderef_mode);\n+  ParamCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -2130,7 +2116,7 @@ ParamType::is_equal (const BaseType &other) const\n     return false;\n \n   if (can_resolve ())\n-    return resolve ()->can_eq (other2.resolve (), false, false);\n+    return resolve ()->can_eq (other2.resolve (), false);\n \n   return get_symbol ().compare (other2.get_symbol ()) == 0;\n }\n@@ -2194,10 +2180,9 @@ StrType::cast (BaseType *other)\n }\n \n bool\n-StrType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t bool autoderef_mode) const\n+StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  StrCmp r (this, emit_errors, autoderef_mode);\n+  StrCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -2247,10 +2232,9 @@ NeverType::cast (BaseType *other)\n }\n \n bool\n-NeverType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t   bool autoderef_mode) const\n+NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  NeverCmp r (this, emit_errors, autoderef_mode);\n+  NeverCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -2303,10 +2287,9 @@ PlaceholderType::cast (BaseType *other)\n }\n \n bool\n-PlaceholderType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t\t bool autoderef_mode) const\n+PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  PlaceholderCmp r (this, emit_errors, autoderef_mode);\n+  PlaceholderCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n \n@@ -2404,10 +2387,9 @@ ProjectionType::cast (BaseType *other)\n }\n \n bool\n-ProjectionType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t\tbool autoderef_mode) const\n+ProjectionType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  return base->can_eq (other, emit_errors, autoderef_mode);\n+  return base->can_eq (other, emit_errors);\n }\n \n BaseType *\n@@ -2511,10 +2493,9 @@ DynamicObjectType::unify (BaseType *other)\n }\n \n bool\n-DynamicObjectType::can_eq (const BaseType *other, bool emit_errors,\n-\t\t\t   bool autoderef_mode) const\n+DynamicObjectType::can_eq (const BaseType *other, bool emit_errors) const\n {\n-  DynamicCmp r (this, emit_errors, autoderef_mode);\n+  DynamicCmp r (this, emit_errors);\n   return r.can_eq (other);\n }\n "}, {"sha": "873f5d8d484877cf2ab1153eb4b85049c1ad0066", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -314,8 +314,7 @@ class BaseType : public TypeBoundsMappings\n   //\n   // It can also be used to optional emit errors for trait item compatibility\n   // checks\n-  virtual bool can_eq (const BaseType *other, bool emit_errors,\n-\t\t       bool autoderef_mode) const = 0;\n+  virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n \n   // this is the base coercion interface for types\n   virtual BaseType *coerce (BaseType *other) = 0;\n@@ -460,8 +459,7 @@ class InferType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n@@ -499,8 +497,7 @@ class ErrorType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -536,8 +533,7 @@ class ParamType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -626,8 +622,7 @@ class TupleType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1252,8 +1247,7 @@ class ADTType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1387,8 +1381,7 @@ class FnType : public BaseType, public SubstitutionRef\n   std::string get_identifier () const { return identifier; }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1507,8 +1500,7 @@ class FnPtr : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1578,8 +1570,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1642,8 +1633,7 @@ class ArrayType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1684,8 +1674,7 @@ class BoolType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1722,8 +1711,7 @@ class IntType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1767,8 +1755,7 @@ class UintType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1810,8 +1797,7 @@ class FloatType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1845,8 +1831,7 @@ class USizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1873,8 +1858,7 @@ class ISizeType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1901,8 +1885,7 @@ class CharType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1936,8 +1919,7 @@ class ReferenceType : public BaseType\n   }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -1987,8 +1969,7 @@ class PointerType : public BaseType\n   }\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -2033,8 +2014,7 @@ class StrType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -2071,8 +2051,7 @@ class NeverType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -2106,8 +2085,7 @@ class PlaceholderType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -2175,8 +2153,7 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n \n@@ -2233,8 +2210,7 @@ class DynamicObjectType : public BaseType\n   std::string as_string () const override;\n \n   BaseType *unify (BaseType *other) override;\n-  bool can_eq (const BaseType *other, bool emit_errors,\n-\t       bool autoderef_mode) const override final;\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n   BaseType *coerce (BaseType *other) override;\n   BaseType *cast (BaseType *other) override;\n   bool is_equal (const BaseType &other) const override;"}, {"sha": "f532b4488c6d0c1b223f0380edc94eff93f309c9", "filename": "gcc/testsuite/rust/execute/torture/method2.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cce6b8919ce16acd37a7a203049a52925a7e295/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmethod2.rs?ref=2cce6b8919ce16acd37a7a203049a52925a7e295", "patch": "@@ -0,0 +1,76 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"foo_deref\\nimm_deref\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+impl<T> Deref for &T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"imm_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+impl<T> Deref for &mut T {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unsafe {\n+            let a = \"mut_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        *self\n+    }\n+}\n+\n+struct Bar(i32);\n+impl Bar {\n+    fn foobar(self) -> i32 {\n+        self.0\n+    }\n+}\n+\n+struct Foo<T>(T);\n+impl<T> Deref for Foo<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            let a = \"foo_deref\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+\n+        &self.0\n+    }\n+}\n+\n+pub fn main() -> i32 {\n+    let bar = Bar(123);\n+    let foo: Foo<&Bar> = Foo(&bar);\n+    let foobar: i32 = foo.foobar();\n+\n+    foobar - 123\n+}"}]}