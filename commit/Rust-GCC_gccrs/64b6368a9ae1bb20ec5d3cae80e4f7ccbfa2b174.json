{"sha": "64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiNjM2OGE5YWUxYmIyMGVjNWQzY2FlODBlNGY3Y2NiZmEyYjE3NA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-01T05:35:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-01T05:35:03Z"}, "message": "Makefile.in (convert.o, typeck.o): Depend on output.h\n\n        * Makefile.in (convert.o, typeck.o): Depend on output.h\n        * convert.c: Include output.h.\n        * typeck.c: Include output.h.\n        (initializer_constant_valid_p): Delete fucntion.\n        * ch-tree.h (initializer_constant_valid_p): Delete prototype.\n\nFrom-SVN: r30311", "tree": {"sha": "ee9457fc83605716affa67d7bbb80e32c098fbe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee9457fc83605716affa67d7bbb80e32c098fbe7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/comments", "author": null, "committer": null, "parents": [{"sha": "7b6cbff4caee3e4cc7e5d180f8b34a64c4e7bff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6cbff4caee3e4cc7e5d180f8b34a64c4e7bff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6cbff4caee3e4cc7e5d180f8b34a64c4e7bff4"}], "stats": {"total": 147, "additions": 13, "deletions": 134}, "files": [{"sha": "5044fe1ad1cce6607df95c69dbe551b180ddfc36", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "patch": "@@ -1,3 +1,11 @@\n+Sun Oct 31 22:33:33 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Makefile.in (convert.o, typeck.o): Depend on output.h\n+\t* convert.c: Include output.h.\n+\t* typeck.c: Include output.h.\n+\t(initializer_constant_valid_p): Delete fucntion.\n+\t* ch-tree.h (initializer_constant_valid_p): Delete prototype.\n+\n 1999-10-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* ch-tree.h (remember_end_note): Remove prototype."}, {"sha": "57c1ebbf44481c945e8f0087be23bf4ed90a4d43", "filename": "gcc/ch/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMakefile.in?ref=64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "patch": "@@ -265,7 +265,8 @@ actions.o : actions.c $(CONFIG_H) $(CHILL_TREE_H) actions.h $(RTL_H)\t\\\n \t$(srcdir)/../expr.h ../insn-codes.h $(srcdir)/../system.h\t\\\n \t$(srcdir)/../toplev.h\n convert.o : convert.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../tree.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n+\t$(srcdir)/../tree.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+\t$(srcdir)/../convert.h\n decl.o : decl.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../flags.h lex.h \\\n \t$(srcdir)/../system.h $(srcdir)/../toplev.h\n except.o : except.c $(CONFIG_H) $(srcdir)/../tree.h $(RTL_H) $(CHILL_TREE_H) \\\n@@ -299,7 +300,7 @@ tree.o : tree.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../system.h \\\n \t$(srcdir)/../toplev.h\n typeck.o : typeck.c $(CONFIG_H) $(CHILL_TREE_H) ../insn-codes.h \\\n \t$(srcdir)/../expr.h ../insn-codes.h $(srcdir)/../flags.h lex.h \\\n-\t$(srcdir)/../system.h $(srcdir)/../toplev.h\n+\t$(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../output.h\n ch-version.o : ch-version.c\n ch-version.c : Makefile\n \techo 'const char * const gnuchill_version = \"$(GNUCHILL_VERSION)\";' > $@"}, {"sha": "956dcb281a58d3dd0f8c74a320a822bd5b144fef", "filename": "gcc/ch/ch-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Fch-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Fch-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.h?ref=64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "patch": "@@ -1101,7 +1101,6 @@ extern ch_class chill_resulting_class           PROTO((ch_class, ch_class));\n extern tree chill_resulting_mode                PROTO((tree, tree));\n extern int  chill_similar\t                PROTO((tree, tree, struct mode_chain*));\n extern int  discrete_type_p\t\t\tPROTO((tree));\n-extern tree initializer_constant_valid_p        PROTO((tree, tree));\n extern tree convert_to_discrete                 PROTO((tree));\n extern tree smash_dummy_type                    PROTO((tree));\n extern tree string_assignment_condition         PROTO((tree, tree));"}, {"sha": "137a2d579f89b6ba29b1168a0166c0555b23b7d7", "filename": "gcc/ch/convert.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconvert.c?ref=64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"convert.h\"\n #include \"lex.h\"\n #include \"toplev.h\"\n+#include \"output.h\"\n \n extern tree bit_one_node, bit_zero_node;\n extern tree string_one_type_node;"}, {"sha": "8628c95280289196702b5227b1973a97f7ff88eb", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 1, "deletions": 131, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=64b6368a9ae1bb20ec5d3cae80e4f7ccbfa2b174", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"lex.h\"\n #include \"toplev.h\"\n+#include \"output.h\"\n \n /* forward declarations */\n static int chill_l_equivalent PROTO((tree, tree, struct mode_chain*));\n@@ -3668,137 +3669,6 @@ mark_addressable (exp)\n     }\n }\n \f\n-/* Return nonzero if VALUE is a valid constant-valued expression\n-   for use in initializing a static variable; one that can be an\n-   element of a \"constant\" initializer.\n-\n-   Return null_pointer_node if the value is absolute;\n-   if it is relocatable, return the variable that determines the relocation.\n-   We assume that VALUE has been folded as much as possible;\n-   therefore, we do not need to check for such things as\n-   arithmetic-combinations of integers.  */\n-\n-tree\n-initializer_constant_valid_p (value, endtype)\n-     tree value;\n-     tree endtype;\n-{\n-  switch (TREE_CODE (value))\n-    {\n-    case CONSTRUCTOR:\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n-\t  && TREE_CONSTANT (value))\n-\treturn\n-\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n-\t\t\t\t\tendtype);\n-\t\n-      return TREE_STATIC (value) ? null_pointer_node : 0;\n-\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case STRING_CST:\n-    case COMPLEX_CST:\n-      return null_pointer_node;\n-\n-    case ADDR_EXPR:\n-      return TREE_OPERAND (value, 0);\n-\n-    case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      /* Allow conversions between pointer types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between real types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow length-preserving conversions between integer types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n-\n-      /* Allow conversions between other integer types only if\n-\t explicit value.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n-\t{\n-\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t     endtype);\n-\t  if (inner == null_pointer_node)\n-\t    return null_pointer_node;\n-\t  return 0;\n-\t}\n-\n-      /* Allow (int) &foo provided int is as wide as a pointer.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-\n-      /* Likewise conversions from int to pointers.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (value))\n-\t      <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-\n-      /* Allow conversions to union types if the value inside is okay.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t     endtype);\n-      return 0;\n-\n-    case PLUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* If either term is absolute, use the other terms relocation.  */\n-\tif (valid0 == null_pointer_node)\n-\t  return valid1;\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\treturn 0;\n-      }\n-\n-    case MINUS_EXPR:\n-      if (TREE_CODE (endtype) == INTEGER_TYPE\n-\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n-\treturn 0;\n-      {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t    endtype);\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t    endtype);\n-\t/* Win if second argument is absolute.  */\n-\tif (valid1 == null_pointer_node)\n-\t  return valid0;\n-\t/* Win if both arguments have the same relocation.\n-\t   Then the value is absolute.  */\n-\tif (valid0 == valid1)\n-\t  return null_pointer_node;\n-\treturn 0;\n-      }\n-    default:\n-      return 0;\n-    }\n-}\n-\f\n /* Return an integer type with BITS bits of precision,\n    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n "}]}