{"sha": "7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q0ZWQ5ZDM4YzdhNjM2NDA4YTI2MmY3MGFhNjlkMmEzNGUyMTY5ZA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-11T04:15:39Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-11T04:15:39Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "915c10b77703d0ef8d074775ddea95eb0f728cab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/915c10b77703d0ef8d074775ddea95eb0f728cab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd1d805ff5921480d9badd7d215e1b1deb33aca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfd1d805ff5921480d9badd7d215e1b1deb33aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfd1d805ff5921480d9badd7d215e1b1deb33aca"}, {"sha": "0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c7d0135663b6f0d94e0ffd931366ba2b32f8b2c"}], "stats": {"total": 1677, "additions": 1216, "deletions": 461}, "files": [{"sha": "b34525e8bb0d34e9cc2a34c1b9c8937c355b3f32", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -1152,11 +1152,14 @@ class Lifetime : public TypeParamBound\n \n   Location locus;\n \n+  NodeId node_id;\n+\n public:\n   // Constructor\n   Lifetime (LifetimeType type, std::string name = std::string (),\n \t    Location locus = Location ())\n-    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Creates an \"error\" lifetime.\n@@ -1172,6 +1175,14 @@ class Lifetime : public TypeParamBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  LifetimeType get_lifetime_type () { return lifetime_type; }\n+\n+  Location get_locus () { return locus; }\n+\n+  std::string get_lifetime_name () const { return lifetime_name; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "5366fac85808a6dc1122407d89a3678c5507768e", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -3163,14 +3163,16 @@ class BreakExpr : public ExprWithoutBlock\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_break_expr ()\n   {\n-    rust_assert (break_expr != nullptr);\n+    rust_assert (has_break_expr ());\n     return break_expr;\n   }\n \n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n   void set_outer_attrs (std::vector<Attribute> new_attrs) override { outer_attrs = std::move (new_attrs); }\n+  \n+  Lifetime &get_label () { return label; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3751,11 +3753,14 @@ class LoopLabel /*: public Node*/\n   Lifetime label; // or type LIFETIME_OR_LABEL\n   Location locus;\n \n+  NodeId node_id;\n+\n public:\n   std::string as_string () const;\n \n   LoopLabel (Lifetime loop_label, Location locus = Location ())\n-    : label (std::move (loop_label)), locus (locus)\n+    : label (std::move (loop_label)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Returns whether the LoopLabel is in an error state.\n@@ -3765,6 +3770,10 @@ class LoopLabel /*: public Node*/\n   static LoopLabel error () { return LoopLabel (Lifetime::error ()); }\n \n   Location get_locus () const { return locus; }\n+\n+  Lifetime &get_lifetime () { return label; }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Base loop expression AST node - aka LoopExpr\n@@ -3823,6 +3832,8 @@ class BaseLoopExpr : public ExprWithBlock\n public:\n   bool has_loop_label () const { return !loop_label.is_error (); }\n \n+  LoopLabel &get_loop_label () { return loop_label; }\n+\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const final override { return get_locus (); }\n "}, {"sha": "288b91789fd7f5c0335852c24f79fec8521ea6b0", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -162,6 +162,21 @@ class Context\n     return true;\n   }\n \n+  void insert_label_decl (HirId id, ::Blabel *label)\n+  {\n+    compiled_labels[id] = label;\n+  }\n+\n+  bool lookup_label_decl (HirId id, ::Blabel **label)\n+  {\n+    auto it = compiled_labels.find (id);\n+    if (it == compiled_labels.end ())\n+      return false;\n+\n+    *label = it->second;\n+    return true;\n+  }\n+\n   void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n@@ -193,6 +208,17 @@ class Context\n     return false;\n   }\n \n+  void push_loop_context (Bvariable *var) { loop_value_stack.push_back (var); }\n+\n+  Bvariable *peek_loop_context () { return loop_value_stack.back (); }\n+\n+  Bvariable *pop_loop_context ()\n+  {\n+    auto back = loop_value_stack.back ();\n+    loop_value_stack.pop_back ();\n+    return back;\n+  }\n+\n private:\n   ::Backend *backend;\n   Resolver::Resolver *resolver;\n@@ -205,8 +231,10 @@ class Context\n   std::map<HirId, ::Btype *> compiled_type_map;\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n   std::map<HirId, ::Bexpression *> compiled_consts;\n+  std::map<HirId, ::Blabel *> compiled_labels;\n   std::vector< ::std::vector<Bstatement *> > statements;\n   std::vector< ::Bblock *> scope_stack;\n+  std::vector< ::Bvariable *> loop_value_stack;\n \n   // To GCC middle-end\n   std::vector< ::Btype *> type_decls;"}, {"sha": "7b25c5e2630fee6103767741afb857c2c7e553a9", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 202, "deletions": 29, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -84,14 +84,18 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::ReturnExpr &expr)\n   {\n-    Bexpression *compiled_expr\n-      = CompileExpr::Compile (expr.return_expr.get (), ctx);\n-    rust_assert (compiled_expr != nullptr);\n-\n     auto fncontext = ctx->peek_fn ();\n \n     std::vector<Bexpression *> retstmts;\n-    retstmts.push_back (compiled_expr);\n+    if (expr.has_return_expr ())\n+      {\n+\tBexpression *compiled_expr\n+\t  = CompileExpr::Compile (expr.return_expr.get (), ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\n+\tretstmts.push_back (compiled_expr);\n+      }\n+\n     auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n \t\t\t\t\t\t    expr.get_locus ());\n     ctx->add_statement (s);\n@@ -417,7 +421,6 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    // this can be a return expression\n     TyTy::TyBase *if_type = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n \t\t\t\t\t &if_type))\n@@ -427,27 +430,67 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    fncontext fnctx = ctx->peek_fn ();\n-    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-    Btype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n-\n-    bool is_address_taken = false;\n-    Bstatement *ret_var_stmt = nullptr;\n-    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n-      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-      expr.get_locus (), &ret_var_stmt);\n-    ctx->add_statement (ret_var_stmt);\n+    Bvariable *tmp = NULL;\n+    bool needs_temp = if_type->get_kind () != TyTy::TypeKind::UNIT;\n+    if (needs_temp)\n+      {\n+\tfncontext fnctx = ctx->peek_fn ();\n+\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+\tbool is_address_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\ttmp = ctx->get_backend ()->temporary_variable (\n+\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\t  expr.get_locus (), &ret_var_stmt);\n+\tctx->add_statement (ret_var_stmt);\n+      }\n \n     auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n     ctx->add_statement (stmt);\n \n-    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    if (tmp != NULL)\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+      }\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n+    TyTy::TyBase *if_type = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &if_type))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup type of IfExprConseqElse\");\n+\treturn;\n+      }\n+\n+    Bvariable *tmp = NULL;\n+    bool needs_temp = if_type->get_kind () != TyTy::TypeKind::UNIT;\n+    if (needs_temp)\n+      {\n+\tfncontext fnctx = ctx->peek_fn ();\n+\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+\tbool is_address_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\ttmp = ctx->get_backend ()->temporary_variable (\n+\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\t  expr.get_locus (), &ret_var_stmt);\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n     ctx->add_statement (stmt);\n+\n+    if (tmp != NULL)\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+      }\n   }\n \n   void visit (HIR::BlockExpr &expr)\n@@ -460,22 +503,31 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    fncontext fnctx = ctx->peek_fn ();\n-    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-    Btype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n-\n-    bool is_address_taken = false;\n-    Bstatement *ret_var_stmt = nullptr;\n-    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n-      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n-      expr.get_locus (), &ret_var_stmt);\n-    ctx->add_statement (ret_var_stmt);\n+    Bvariable *tmp = NULL;\n+    bool needs_temp = block_tyty->get_kind () != TyTy::TypeKind::UNIT;\n+    if (needs_temp)\n+      {\n+\tfncontext fnctx = ctx->peek_fn ();\n+\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+\tbool is_address_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\ttmp = ctx->get_backend ()->temporary_variable (\n+\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\t  expr.get_locus (), &ret_var_stmt);\n+\tctx->add_statement (ret_var_stmt);\n+      }\n \n     auto code_block = CompileBlock::compile (&expr, ctx, tmp);\n     auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (block_stmt);\n \n-    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    if (tmp != NULL)\n+      {\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+      }\n   }\n \n   void visit (HIR::StructExprStructFields &struct_expr)\n@@ -532,6 +584,127 @@ class CompileExpr : public HIRCompileBase\n     translated = ResolvePathRef::Compile (&expr, ctx);\n   }\n \n+  void visit (HIR::LoopExpr &expr)\n+  {\n+    TyTy::TyBase *block_tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &block_tyty))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+\treturn;\n+      }\n+\n+    fncontext fnctx = ctx->peek_fn ();\n+    Bvariable *tmp = NULL;\n+    bool needs_temp = block_tyty->get_kind () != TyTy::TypeKind::UNIT;\n+    if (needs_temp)\n+      {\n+\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+\tbool is_address_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\ttmp = ctx->get_backend ()->temporary_variable (\n+\t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\t  expr.get_locus (), &ret_var_stmt);\n+\tctx->add_statement (ret_var_stmt);\n+\tctx->push_loop_context (tmp);\n+      }\n+\n+    if (expr.has_loop_label ())\n+      {\n+\tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n+\tBlabel *label\n+\t  = ctx->get_backend ()->label (fnctx.fndecl,\n+\t\t\t\t\tloop_label.get_lifetime ().get_name (),\n+\t\t\t\t\tloop_label.get_locus ());\n+\tBstatement *label_decl\n+\t  = ctx->get_backend ()->label_definition_statement (label);\n+\tctx->add_statement (label_decl);\n+\tctx->insert_label_decl (\n+\t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n+      }\n+\n+    Bblock *code_block\n+      = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n+    Bexpression *loop_expr\n+      = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n+    Bstatement *loop_stmt\n+      = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n+    ctx->add_statement (loop_stmt);\n+\n+    if (tmp != NULL)\n+      {\n+\tctx->pop_loop_context ();\n+\ttranslated\n+\t  = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+      }\n+  }\n+\n+  void visit (HIR::BreakExpr &expr)\n+  {\n+    if (expr.has_break_expr ())\n+      {\n+\tfncontext fnctx = ctx->peek_fn ();\n+\tBexpression *compiled_expr\n+\t  = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+\n+\tBvariable *loop_result_holder = ctx->peek_loop_context ();\n+\tBexpression *result_reference = ctx->get_backend ()->var_expression (\n+\t  loop_result_holder, expr.get_expr ()->get_locus_slow ());\n+\n+\tBstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\t  fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\tctx->add_statement (assignment);\n+      }\n+\n+    if (expr.has_label ())\n+      {\n+\tNodeId resolved_node_id = UNKNOWN_NODEID;\n+\tif (!ctx->get_resolver ()->lookup_resolved_label (\n+\t      expr.get_label ().get_mappings ().get_nodeid (),\n+\t      &resolved_node_id))\n+\t  {\n+\t    rust_error_at (\n+\t      expr.get_label ().get_locus (),\n+\t      \"failed to resolve compiled label for label %s\",\n+\t      expr.get_label ().get_mappings ().as_string ().c_str ());\n+\t    return;\n+\t  }\n+\n+\tHirId ref = UNKNOWN_HIRID;\n+\tif (!ctx->get_mappings ()->lookup_node_to_hir (\n+\t      expr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+\t  {\n+\t    rust_fatal_error (expr.get_locus (),\n+\t\t\t      \"reverse lookup label failure\");\n+\t    return;\n+\t  }\n+\n+\tBlabel *label = nullptr;\n+\tif (!ctx->lookup_label_decl (ref, &label))\n+\t  {\n+\t    rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t   \"failed to lookup compiled label\");\n+\t    return;\n+\t  }\n+\n+\tBstatement *goto_label\n+\t  = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n+\tctx->add_statement (goto_label);\n+      }\n+    else\n+      {\n+\tfncontext fnctx = ctx->peek_fn ();\n+\tBexpression *exit_expr = ctx->get_backend ()->exit_expression (\n+\t  ctx->get_backend ()->boolean_constant_expression (true),\n+\t  expr.get_locus ());\n+\tBstatement *break_stmt\n+\t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n+\tctx->add_statement (break_stmt);\n+      }\n+  }\n+\n private:\n   CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n "}, {"sha": "dd87d4528da079899dddb25a0a6ddb78384df06e", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -53,33 +53,9 @@ CompileCrate::go ()\n void\n CompileExpr::visit (HIR::CallExpr &expr)\n {\n-  // this can be a function call or it can be a constructor for a tuple struct\n-  Bexpression *fn = ResolvePathRef::Compile (expr.get_fnexpr (), ctx);\n-  if (fn != nullptr)\n+  Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n+  if (type != nullptr)\n     {\n-      std::vector<Bexpression *> args;\n-      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n-\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\targs.push_back (compiled_expr);\n-\treturn true;\n-      });\n-\n-      auto fncontext = ctx->peek_fn ();\n-      translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n-    }\n-  else\n-    {\n-      Btype *type = ResolvePathType::Compile (expr.get_fnexpr (), ctx);\n-      if (type == nullptr)\n-\t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"failed to lookup type associated with call\");\n-\t  return;\n-\t}\n-\n       // this assumes all fields are in order from type resolution and if a base\n       // struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n@@ -93,6 +69,24 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t= ctx->get_backend ()->constructor_expression (type, vals,\n \t\t\t\t\t\t       expr.get_locus ());\n     }\n+  else\n+    {\n+      // must be a call to a function\n+      Bexpression *fn = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+\n+      std::vector<Bexpression *> args;\n+      expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+\tBexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+\trust_assert (compiled_expr != nullptr);\n+\targs.push_back (compiled_expr);\n+\treturn true;\n+      });\n+\n+      auto fncontext = ctx->peek_fn ();\n+      translated\n+\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t\tnullptr, expr.get_locus ());\n+    }\n }\n \n void\n@@ -242,23 +236,28 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       // the previous passes will ensure this is a valid return\n       // dead code elimination should remove any bad trailing expressions\n       Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n-      rust_assert (compiled_expr != nullptr);\n-\n-      if (result == nullptr)\n-\t{\n-\t  Bstatement *final_stmt\n-\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n-\t\t\t\t\t\t\t compiled_expr);\n-\t  ctx->add_statement (final_stmt);\n-\t}\n-      else\n+      if (compiled_expr != nullptr)\n \t{\n-\t  Bexpression *result_reference = ctx->get_backend ()->var_expression (\n-\t    result, expr.get_final_expr ()->get_locus_slow ());\n-\n-\t  Bstatement *assignment = ctx->get_backend ()->assignment_statement (\n-\t    fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n-\t  ctx->add_statement (assignment);\n+\t  if (result == nullptr)\n+\t    {\n+\t      Bstatement *final_stmt\n+\t\t= ctx->get_backend ()->expression_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t     compiled_expr);\n+\t      ctx->add_statement (final_stmt);\n+\t    }\n+\t  else\n+\t    {\n+\t      Bexpression *result_reference\n+\t\t= ctx->get_backend ()->var_expression (\n+\t\t  result, expr.get_final_expr ()->get_locus_slow ());\n+\n+\t      Bstatement *assignment\n+\t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t     result_reference,\n+\t\t\t\t\t\t\t     compiled_expr,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+\t      ctx->add_statement (assignment);\n+\t    }\n \t}\n     }\n "}, {"sha": "beeff8758f1d8f9d249e7688464d1e1468e06520", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -243,6 +243,47 @@ class ASTLoweringBase : public AST::ASTVisitor\n   ASTLoweringBase () : mappings (Analysis::Mappings::get ()) {}\n \n   Analysis::Mappings *mappings;\n+\n+  HIR::Lifetime lower_lifetime (AST::Lifetime &lifetime)\n+  {\n+    HIR::Lifetime::LifetimeType type = HIR::Lifetime::LifetimeType::NAMED;\n+    switch (lifetime.get_lifetime_type ())\n+      {\n+      case AST::Lifetime::LifetimeType::NAMED:\n+\ttype = HIR::Lifetime::LifetimeType::NAMED;\n+\tbreak;\n+      case AST::Lifetime::LifetimeType::STATIC:\n+\ttype = HIR::Lifetime::LifetimeType::STATIC;\n+\tbreak;\n+      case AST::Lifetime::LifetimeType::WILDCARD:\n+\ttype = HIR::Lifetime::LifetimeType::WILDCARD;\n+\tbreak;\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, lifetime.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    mappings->insert_node_to_hir (mapping.get_crate_num (),\n+\t\t\t\t  mapping.get_nodeid (), mapping.get_hirid ());\n+\n+    return HIR::Lifetime (mapping, type, lifetime.get_lifetime_name (),\n+\t\t\t  lifetime.get_locus ());\n+  }\n+\n+  HIR::LoopLabel lower_loop_label (AST::LoopLabel &loop_label)\n+  {\n+    HIR::Lifetime life = lower_lifetime (loop_label.get_lifetime ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, loop_label.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    mappings->insert_node_to_hir (mapping.get_crate_num (),\n+\t\t\t\t  mapping.get_nodeid (), mapping.get_hirid ());\n+\n+    return HIR::LoopLabel (mapping, std::move (life), loop_label.get_locus ());\n+  }\n };\n \n } // namespace HIR"}, {"sha": "c945042e96f2d79fe02a9e941aade3c8d07981a9", "filename": "gcc/rust/hir/rust-ast-lower-block.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -134,6 +134,27 @@ class ASTLoweringExprWithBlock : public ASTLoweringBase\n     translated = ASTLoweringBlock::translate (&expr, &terminated);\n   }\n \n+  void visit (AST::LoopExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    HIR::BlockExpr *loop_block\n+      = ASTLoweringBlock::translate (expr.get_loop_block ().get (),\n+\t\t\t\t     &terminated);\n+\n+    HIR::LoopLabel loop_label = lower_loop_label (expr.get_loop_label ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::LoopExpr (mapping,\n+\t\t\t   std::unique_ptr<HIR::BlockExpr> (loop_block),\n+\t\t\t   expr.get_locus (), std::move (loop_label),\n+\t\t\t   std::move (outer_attribs));\n+  }\n+\n private:\n   ASTLoweringExprWithBlock ()\n     : ASTLoweringBase (), translated (nullptr), terminated (false)"}, {"sha": "e10448fea6a853450900de06d59e152abcac7a89", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -74,8 +74,6 @@ class ASTLowerPathInExpression : public ASTLoweringBase\n     return compiler.translated;\n   }\n \n-  ~ASTLowerPathInExpression () {}\n-\n   void visit (AST::PathInExpression &expr)\n   {\n     std::vector<HIR::PathExprSegment> path_segments;\n@@ -697,9 +695,35 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t\t  std::move (outer_attribs), expr.get_locus ());\n   }\n \n+  void visit (AST::LoopExpr &expr)\n+  {\n+    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::BreakExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+    HIR::Expr *break_expr\n+      = expr.has_break_expr ()\n+\t  ? ASTLoweringExpr::translate (expr.get_break_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::BreakExpr (mapping, expr.get_locus (),\n+\t\t\t\t     std ::move (break_label),\n+\t\t\t\t     std::unique_ptr<HIR::Expr> (break_expr),\n+\t\t\t\t     std::move (outer_attribs));\n+  }\n+\n private:\n   ASTLoweringExpr ()\n-    : translated (nullptr), translated_array_elems (nullptr), terminated (false)\n+    : ASTLoweringBase (), translated (nullptr),\n+      translated_array_elems (nullptr), terminated (false)\n   {}\n \n   HIR::Expr *translated;"}, {"sha": "e92e0590a4626ffed93a2c1340641de444bf9b7a", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -2712,8 +2712,7 @@ class ContinueExpr : public ExprWithoutBlock\n   bool has_label () const { return !label.is_error (); }\n \n   // Constructor for a ContinueExpr with a label.\n-  ContinueExpr (Analysis::NodeMapping mappings, Location locus,\n-\t\tLifetime label = Lifetime::error (),\n+  ContinueExpr (Analysis::NodeMapping mappings, Location locus, Lifetime label,\n \t\tstd::vector<Attribute> outer_attribs\n \t\t= std::vector<Attribute> ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n@@ -2765,7 +2764,7 @@ class BreakExpr : public ExprWithoutBlock\n \n   // Constructor for a break expression\n   BreakExpr (Analysis::NodeMapping mappings, Location locus,\n-\t     Lifetime break_label = Lifetime::error (),\n+\t     Lifetime break_label,\n \t     std::unique_ptr<Expr> expr_in_break = nullptr,\n \t     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs)),\n@@ -2803,6 +2802,10 @@ class BreakExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Lifetime &get_label () { return label; }\n+\n+  std::unique_ptr<Expr> &get_expr () { return break_expr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -3266,20 +3269,23 @@ class LoopLabel /*: public Node*/\n \n   Location locus;\n \n+  Analysis::NodeMapping mappings;\n+\n public:\n   std::string as_string () const;\n \n-  LoopLabel (Lifetime loop_label, Location locus = Location ())\n-    : label (std::move (loop_label)), locus (locus)\n+  LoopLabel (Analysis::NodeMapping mapping, Lifetime loop_label, Location locus)\n+    : label (std::move (loop_label)), locus (locus), mappings (mapping)\n   {}\n \n   // Returns whether the LoopLabel is in an error state.\n   bool is_error () const { return label.is_error (); }\n \n-  // Creates an error state LoopLabel.\n-  static LoopLabel error () { return LoopLabel (Lifetime::error ()); }\n-\n   Location get_locus () const { return locus; }\n+\n+  Analysis::NodeMapping &get_mappings () { return mappings; }\n+\n+  Lifetime &get_lifetime () { return label; }\n };\n \n // Base loop expression HIR node - aka LoopExpr\n@@ -3299,7 +3305,7 @@ class BaseLoopExpr : public ExprWithBlock\n   // Constructor for BaseLoopExpr\n   BaseLoopExpr (Analysis::NodeMapping mappings,\n \t\tstd::unique_ptr<BlockExpr> loop_block, Location locus,\n-\t\tLoopLabel loop_label = LoopLabel::error (),\n+\t\tLoopLabel loop_label,\n \t\tstd::vector<Attribute> outer_attribs\n \t\t= std::vector<Attribute> ())\n     : ExprWithBlock (std::move (mappings), std::move (outer_attribs)),\n@@ -3334,6 +3340,10 @@ class BaseLoopExpr : public ExprWithBlock\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n+\n+  std::unique_ptr<HIR::BlockExpr> &get_loop_block () { return loop_block; };\n+\n+  LoopLabel &get_loop_label () { return loop_label; }\n };\n \n // 'Loop' expression (i.e. the infinite loop) HIR node\n@@ -3345,7 +3355,7 @@ class LoopExpr : public BaseLoopExpr\n   // Constructor for LoopExpr\n   LoopExpr (Analysis::NodeMapping mappings,\n \t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n-\t    LoopLabel loop_label = LoopLabel::error (),\n+\t    LoopLabel loop_label,\n \t    std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs))\n@@ -3378,7 +3388,7 @@ class WhileLoopExpr : public BaseLoopExpr\n   WhileLoopExpr (Analysis::NodeMapping mappings,\n \t\t std::unique_ptr<Expr> loop_condition,\n \t\t std::unique_ptr<BlockExpr> loop_block, Location locus,\n-\t\t LoopLabel loop_label = LoopLabel::error (),\n+\t\t LoopLabel loop_label,\n \t\t std::vector<Attribute> outer_attribs\n \t\t = std::vector<Attribute> ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n@@ -3440,7 +3450,7 @@ class WhileLetLoopExpr : public BaseLoopExpr\n \t\t    std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t\t    std::unique_ptr<Expr> condition,\n \t\t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n-\t\t    LoopLabel loop_label = LoopLabel::error (),\n+\t\t    LoopLabel loop_label,\n \t\t    std::vector<Attribute> outer_attribs\n \t\t    = std::vector<Attribute> ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_block), locus,\n@@ -3513,7 +3523,7 @@ class ForLoopExpr : public BaseLoopExpr\n \t       std::unique_ptr<Pattern> loop_pattern,\n \t       std::unique_ptr<Expr> iterator_expr,\n \t       std::unique_ptr<BlockExpr> loop_body, Location locus,\n-\t       LoopLabel loop_label = LoopLabel::error (),\n+\t       LoopLabel loop_label,\n \t       std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n     : BaseLoopExpr (std::move (mappings), std::move (loop_body), locus,\n \t\t    std::move (loop_label), std::move (outer_attribs)),"}, {"sha": "c0d6d0f14642295e86cebb481b8f30e16e9a46a9", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -324,7 +324,8 @@ struct SelfParam\n   // Type-based self parameter (not ref, no lifetime)\n   SelfParam (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n \t     bool is_mut, Location locus)\n-    : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n+    : has_ref (false), is_mut (is_mut),\n+      lifetime (Lifetime (mappings, Lifetime::LifetimeType::NAMED, \"\", locus)),\n       type (std::move (type)), locus (locus), mappings (mappings)\n   {}\n "}, {"sha": "746e3e2070ae5136b76bb763e94286dbd24616c5", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -531,7 +531,7 @@ class ReferenceType : public TypeNoBounds\n   // Constructor\n   ReferenceType (Analysis::NodeMapping mappings, bool is_mut,\n \t\t std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus,\n-\t\t Lifetime lifetime = Lifetime::error ())\n+\t\t Lifetime lifetime)\n     : TypeNoBounds (mappings), lifetime (std::move (lifetime)),\n       has_mut (is_mut), type (std::move (type_no_bounds)), locus (locus)\n   {}"}, {"sha": "1567215ea17e4dded1c34fde2fdd76d1c6baf4af", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -1060,16 +1060,16 @@ class Lifetime : public TypeParamBound\n \n   Location locus;\n \n+  Analysis::NodeMapping mappings;\n+\n public:\n   // Constructor\n-  Lifetime (LifetimeType type, std::string name = std::string (),\n-\t    Location locus = Location ())\n-    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+  Lifetime (Analysis::NodeMapping mapping, LifetimeType type, std::string name,\n+\t    Location locus)\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus),\n+      mappings (mapping)\n   {}\n \n-  // Creates an \"error\" lifetime.\n-  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n-\n   // Returns true if the lifetime is in an error state.\n   bool is_error () const\n   {\n@@ -1080,6 +1080,14 @@ class Lifetime : public TypeParamBound\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::string get_name () const { return lifetime_name; }\n+\n+  LifetimeType get_lifetime_type () const { return lifetime_type; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1133,12 +1141,6 @@ class LifetimeParam : public GenericParam\n   // Returns whether the lifetime param has an outer attribute.\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n-  // Creates an error state lifetime param.\n-  static LifetimeParam create_error ()\n-  {\n-    return LifetimeParam (Lifetime::error ());\n-  }\n-\n   // Returns whether the lifetime param is in an error state.\n   bool is_error () const { return lifetime.is_error (); }\n "}, {"sha": "437a7b5f5afe7d94cb3e77cd696b6aaf969a4dbf", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 96, "deletions": 31, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -386,6 +386,8 @@ Parser<ManagedTokenSource>::left_binding_power (const_TokenPtr token)\n       return LBP_MOD_ASSIG;\n     case AMP_EQ:\n       return LBP_AMP_ASSIG;\n+    case PIPE_EQ:\n+      return LBP_PIPE_ASSIG;\n     case CARET_EQ:\n       return LBP_CARET_ASSIG;\n     case LEFT_SHIFT_EQ:\n@@ -7396,8 +7398,10 @@ Parser<ManagedTokenSource>::parse_return_expr (\n     }\n \n   // parse expression to return, if it exists\n-  std::unique_ptr<AST::Expr> returned_expr = parse_expr ();\n-  // FIXME: ensure this doesn't ruin the middle of any expressions or anything\n+  ParseRestrictions restrictions;\n+  restrictions.expr_can_be_null = true;\n+  std::unique_ptr<AST::Expr> returned_expr\n+    = parse_expr (std::vector<AST::Attribute> (), restrictions);\n \n   return std::unique_ptr<AST::ReturnExpr> (\n     new AST::ReturnExpr (std::move (returned_expr), std::move (outer_attrs),\n@@ -7433,7 +7437,10 @@ Parser<ManagedTokenSource>::parse_break_expr (\n     }\n \n   // parse break return expression if it exists\n-  std::unique_ptr<AST::Expr> return_expr = parse_expr ();\n+  ParseRestrictions restrictions;\n+  restrictions.expr_can_be_null = true;\n+  std::unique_ptr<AST::Expr> return_expr\n+    = parse_expr (std::vector<AST::Attribute> (), restrictions);\n \n   return std::unique_ptr<AST::BreakExpr> (\n     new AST::BreakExpr (std::move (label), std::move (return_expr),\n@@ -7502,10 +7509,23 @@ Parser<ManagedTokenSource>::parse_loop_label ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfExpr>\n Parser<ManagedTokenSource>::parse_if_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n {\n-  Location locus = lexer.peek_token ()->get_locus ();\n-  skip_token (IF);\n+  // TODO: make having outer attributes an error?\n+  Location locus = Linemap::unknown_location ();\n+  if (!pratt_parse)\n+    {\n+      locus = lexer.peek_token ()->get_locus ();\n+      if (!skip_token (IF))\n+\t{\n+\t  skip_after_end_block ();\n+\t  return nullptr;\n+\t}\n+    }\n+  else\n+    {\n+      locus = lexer.peek_token ()->get_locus () - 1;\n+    }\n \n   // detect accidental if let\n   if (lexer.peek_token ()->get_id () == LET)\n@@ -7639,10 +7659,23 @@ Parser<ManagedTokenSource>::parse_if_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfLetExpr>\n Parser<ManagedTokenSource>::parse_if_let_expr (\n-  std::vector<AST::Attribute> outer_attrs)\n+  std::vector<AST::Attribute> outer_attrs, bool pratt_parse)\n {\n-  Location locus = lexer.peek_token ()->get_locus ();\n-  skip_token (IF);\n+  // TODO: make having outer attributes an error?\n+  Location locus = Linemap::unknown_location ();\n+  if (!pratt_parse)\n+    {\n+      locus = lexer.peek_token ()->get_locus ();\n+      if (!skip_token (IF))\n+\t{\n+\t  skip_after_end_block ();\n+\t  return nullptr;\n+\t}\n+    }\n+  else\n+    {\n+      locus = lexer.peek_token ()->get_locus () - 1;\n+    }\n \n   // detect accidental if expr parsed as if let expr\n   if (lexer.peek_token ()->get_id () != LET)\n@@ -7802,14 +7835,30 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LoopExpr>\n Parser<ManagedTokenSource>::parse_loop_expr (\n-  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label)\n+  std::vector<AST::Attribute> outer_attrs, AST::LoopLabel label,\n+  bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n-  if (label.is_error ())\n-    locus = lexer.peek_token ()->get_locus ();\n+  if (!pratt_parse)\n+    {\n+      if (label.is_error ())\n+\tlocus = lexer.peek_token ()->get_locus ();\n+      else\n+\tlocus = label.get_locus ();\n+\n+      if (!skip_token (LOOP))\n+\t{\n+\t  skip_after_end_block ();\n+\t  return nullptr;\n+\t}\n+    }\n   else\n-    locus = label.get_locus ();\n-  skip_token (LOOP);\n+    {\n+      if (label.is_error ())\n+\tlocus = lexer.peek_token ()->get_locus () - 1;\n+      else\n+\tlocus = label.get_locus ();\n+    }\n \n   // parse loop body, which is required\n   std::unique_ptr<AST::BlockExpr> loop_body = parse_block_expr ();\n@@ -12390,16 +12439,32 @@ Parser<ManagedTokenSource>::null_denotation (\n     case LEFT_CURLY:\n       // ok - this is an expression with block for once.\n       return parse_block_expr (std::move (outer_attrs), true);\n+    case IF:\n+      // if or if let, so more lookahead to find out\n+      if (lexer.peek_token (1)->get_id () == LET)\n+\t{\n+\t  // if let expr\n+\t  return parse_if_let_expr (std::move (outer_attrs), true);\n+\t}\n+      else\n+\t{\n+\t  // if expr\n+\t  return parse_if_expr (std::move (outer_attrs), true);\n+\t}\n+    case LOOP:\n+      return parse_loop_expr (std::move (outer_attrs), AST::LoopLabel::error (),\n+\t\t\t      true);\n     case MATCH_TOK:\n       // also an expression with block\n       return parse_match_expr (std::move (outer_attrs), true);\n     case LEFT_SQUARE:\n       // array definition expr (not indexing)\n       return parse_array_expr (std::move (outer_attrs), true);\n     default:\n-      rust_error_at (tok->get_locus (),\n-\t\t     \"found unexpected token %qs in null denotation\",\n-\t\t     tok->get_token_description ());\n+      if (!restrictions.expr_can_be_null)\n+\trust_error_at (tok->get_locus (),\n+\t\t       \"found unexpected token %qs in null denotation\",\n+\t\t       tok->get_token_description ());\n       return nullptr;\n     }\n }\n@@ -14415,7 +14480,7 @@ Parser<ManagedTokenSource>::done_end ()\n // Dumps lexer output to stderr.\n template <typename ManagedTokenSource>\n void\n-Parser<ManagedTokenSource>::debug_dump_lex_output ()\n+Parser<ManagedTokenSource>::debug_dump_lex_output (std::ostream &out)\n {\n   /* TODO: a better implementation of \"lexer dump\" (as in dump what was actually\n    * tokenised) would actually be to \"write\" a token to a file every time\n@@ -14426,6 +14491,9 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n \n   while (true)\n     {\n+      if (tok->get_id () == Rust::END_OF_FILE)\n+\tbreak;\n+\n       bool has_text = tok->get_id () == Rust::IDENTIFIER\n \t\t      || tok->get_id () == Rust::INT_LITERAL\n \t\t      || tok->get_id () == Rust::FLOAT_LITERAL\n@@ -14436,16 +14504,13 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n \n       Location loc = tok->get_locus ();\n \n-      fprintf (stderr, \"<id=%s%s, %s\\n\", tok->token_id_to_str (),\n-\t       has_text ? (std::string (\", text=\") + tok->get_str ()\n-\t\t\t   + std::string (\", typehint=\")\n-\t\t\t   + std::string (tok->get_type_hint_str ()))\n-\t\t\t    .c_str ()\n-\t\t\t: \"\",\n-\t       lexer.get_line_map ()->to_string (loc).c_str ());\n-\n-      if (tok->get_id () == Rust::END_OF_FILE)\n-\tbreak;\n+      out << \"<id=\";\n+      out << tok->token_id_to_str ();\n+      out << has_text ? (std::string (\", text=\") + tok->get_str ()\n+\t\t\t + std::string (\", typehint=\")\n+\t\t\t + std::string (tok->get_type_hint_str ()))\n+\t\t      : \"\";\n+      out << lexer.get_line_map ()->to_string (loc);\n \n       lexer.skip_token ();\n       tok = lexer.peek_token ();\n@@ -14455,9 +14520,9 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n // Parses crate and dumps AST to stderr, recursively.\n template <typename ManagedTokenSource>\n void\n-Parser<ManagedTokenSource>::debug_dump_ast_output (AST::Crate &crate)\n+Parser<ManagedTokenSource>::debug_dump_ast_output (AST::Crate &crate,\n+\t\t\t\t\t\t   std::ostream &out)\n {\n-  // print crate \"as string\", which then calls each item as string, etc.\n-  fprintf (stderr, \"%s\", crate.as_string ().c_str ());\n+  out << crate.as_string ();\n }\n } // namespace Rust"}, {"sha": "e691c9e24f3f6e07614a5ef43bbff75088b1604b", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -82,6 +82,7 @@ struct ParseRestrictions\n   /* Whether the expression was entered from a unary expression - prevents stuff\n    * like struct exprs being parsed from a dereference. */\n   bool entered_from_unary = false;\n+  bool expr_can_be_null = false;\n };\n \n // Parser implementation for gccrs.\n@@ -166,22 +167,30 @@ template <typename ManagedTokenSource> class Parser\n   parse_generic_params_in_angles ();\n   std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::GenericParam> >\n+  parse_generic_params (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::LifetimeParam> >\n+  parse_lifetime_params (EndTokenPred is_end_token);\n   std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n   template <typename EndTokenPred>\n-  std::vector<AST::LifetimeParam> parse_lifetime_params_objs (EndTokenPred is_end_token);\n+  std::vector<AST::LifetimeParam>\n+  parse_lifetime_params_objs (EndTokenPred is_end_token);\n   template <typename ParseFunction, typename EndTokenPred>\n-  auto parse_non_ptr_sequence (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg = \"failed to parse generic param in generic params\") -> std::vector<decltype(parsing_function ())>;\n+  auto parse_non_ptr_sequence (\n+    ParseFunction parsing_function, EndTokenPred is_end_token,\n+    std::string error_msg = \"failed to parse generic param in generic params\")\n+    -> std::vector<decltype (parsing_function ())>;\n   AST::LifetimeParam parse_lifetime_param ();\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::TypeParam> >\n+  parse_type_params (EndTokenPred is_end_token);\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n   template <typename EndTokenPred>\n-  std::vector<AST::FunctionParam> parse_function_params (EndTokenPred is_end_token);\n+  std::vector<AST::FunctionParam>\n+  parse_function_params (EndTokenPred is_end_token);\n   AST::FunctionParam parse_function_param ();\n   std::unique_ptr<AST::Type> parse_function_return_type ();\n   AST::WhereClause parse_where_clause ();\n@@ -192,7 +201,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_type_bound_where_clause_item ();\n   std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::TypeParamBound> >\n+  parse_type_param_bounds (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds ();\n   std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n   std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n@@ -215,7 +225,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::EnumItem> >\n+  parse_enum_items (EndTokenPred is_end_token);\n   std::unique_ptr<AST::EnumItem> parse_enum_item ();\n   std::unique_ptr<AST::Union>\n   parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n@@ -247,8 +258,9 @@ template <typename ManagedTokenSource> class Parser\n   parse_extern_block (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n-  AST::NamedFunctionParam parse_named_function_param (\n-    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> ());\n+  AST::NamedFunctionParam\n+  parse_named_function_param (std::vector<AST::Attribute> outer_attrs\n+\t\t\t      = std::vector<AST::Attribute> ());\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n@@ -272,9 +284,11 @@ template <typename ManagedTokenSource> class Parser\n \t\t   = std::vector<AST::Attribute> (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_arithmetic_or_logical_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs, AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n-\t\t\t  ParseRestrictions restrictions = ParseRestrictions ());\n+  parse_arithmetic_or_logical_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n+    AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n@@ -368,10 +382,11 @@ template <typename ManagedTokenSource> class Parser\n   parse_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t    std::vector<AST::Attribute> outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_compound_assignment_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs, AST::CompoundAssignmentExpr::ExprType expr_type,\n-\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_compound_assignment_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n+    AST::CompoundAssignmentExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_plus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t std::vector<AST::Attribute> outer_attrs,\n@@ -480,14 +495,15 @@ template <typename ManagedTokenSource> class Parser\n \t\t    bool pratt_parse = false);\n   std::unique_ptr<AST::IfExpr>\n   parse_if_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t = std::vector<AST::Attribute> ());\n+\t\t = std::vector<AST::Attribute> (),\n+\t\t bool pratt_parse = false);\n   std::unique_ptr<AST::IfLetExpr>\n   parse_if_let_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t     = std::vector<AST::Attribute> ());\n-  std::unique_ptr<AST::LoopExpr>\n-  parse_loop_expr (std::vector<AST::Attribute> outer_attrs\n-\t\t   = std::vector<AST::Attribute> (),\n-\t\t   AST::LoopLabel label = AST::LoopLabel::error ());\n+\t\t     = std::vector<AST::Attribute> (),\n+\t\t     bool pratt_parse = false);\n+  std::unique_ptr<AST::LoopExpr> parse_loop_expr (\n+    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> (),\n+    AST::LoopLabel label = AST::LoopLabel::error (), bool pratt_parse = false);\n   std::unique_ptr<AST::WhileLoopExpr>\n   parse_while_loop_expr (std::vector<AST::Attribute> outer_attrs\n \t\t\t = std::vector<AST::Attribute> (),\n@@ -561,7 +577,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n   std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n-  AST::MaybeNamedParam parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n+  AST::MaybeNamedParam\n+  parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n \n   // Statement-related\n   std::unique_ptr<AST::Stmt> parse_stmt ();\n@@ -591,7 +608,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n   std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n-  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::StructPatternField>\n+  parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n \n   int left_binding_power (const_TokenPtr token);\n \n@@ -607,8 +625,8 @@ template <typename ManagedTokenSource> class Parser\n   AST::Crate parse_crate ();\n \n   // Dumps all lexer output.\n-  void debug_dump_lex_output ();\n-  void debug_dump_ast_output (AST::Crate &crate);\n+  void debug_dump_lex_output (std::ostream &out);\n+  void debug_dump_ast_output (AST::Crate &crate, std::ostream &out);\n \n private:\n   // The token source (usually lexer) associated with the parser."}, {"sha": "9cfa04d59a075de3983eb3aa5bb7227281efff45", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -241,6 +241,62 @@ class ResolveExpr : public ResolverBase\n     ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n   }\n \n+  void visit (AST::LoopExpr &expr)\n+  {\n+    if (expr.has_loop_label ())\n+      {\n+\tauto label = expr.get_loop_label ();\n+\tif (label.get_lifetime ().get_lifetime_type ()\n+\t    != AST::Lifetime::LifetimeType::NAMED)\n+\t  {\n+\t    rust_error_at (label.get_locus (),\n+\t\t\t   \"Labels must be a named lifetime value\");\n+\t    return;\n+\t  }\n+\n+\tauto label_name = label.get_lifetime ().get_lifetime_name ();\n+\tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+\tresolver->get_label_scope ().insert (\n+\t  label_name, label_lifetime_node_id, label.get_locus (), false,\n+\t  [&] (std::string, NodeId, Location locus) -> void {\n+\t    rust_error_at (label.get_locus (),\n+\t\t\t   \"label redefined multiple times\");\n+\t    rust_error_at (locus, \"was defined here\");\n+\t  });\n+\tresolver->insert_new_definition (label_lifetime_node_id,\n+\t\t\t\t\t Definition{label_lifetime_node_id,\n+\t\t\t\t\t\t    label.get_node_id ()});\n+      }\n+    ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::BreakExpr &expr)\n+  {\n+    if (expr.has_label ())\n+      {\n+\tauto label = expr.get_label ();\n+\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t  {\n+\t    rust_error_at (label.get_locus (),\n+\t\t\t   \"Labels must be a named lifetime value\");\n+\t    return;\n+\t  }\n+\n+\tNodeId resolved_node = UNKNOWN_NODEID;\n+\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n+\t\t\t\t\t\t  &resolved_node))\n+\t  {\n+\t    rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t   \"failed to resolve label\");\n+\t    return;\n+\t  }\n+\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+      }\n+\n+    if (expr.has_break_expr ())\n+      ResolveExpr::go (expr.get_break_expr ().get (), expr.get_node_id ());\n+  }\n+\n private:\n   ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n };"}, {"sha": "f5dc579b30706ecc0de6d73904b3303e894046bd", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -88,8 +88,10 @@ class ResolveItem : public ResolverBase\n     NodeId scope_node_id = function.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n     resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n     resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n     // we make a new scope so the names of parameters are resolved and shadowed\n     // correctly\n@@ -111,6 +113,7 @@ class ResolveItem : public ResolverBase\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n   }\n \n   void visit (AST::InherentImpl &impl_block)"}, {"sha": "748f9727ace37379f8511ec2ebf838a77abc07e4", "filename": "gcc/rust/resolve/rust-ast-resolve-unused.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -43,6 +43,7 @@ class ScanUnused\n     auto resolver = Resolver::get ();\n     resolver->iterate_name_ribs ([&] (Rib *r) -> void { ScanRib (r); });\n     resolver->iterate_type_ribs ([&] (Rib *r) -> void { ScanRib (r); });\n+    resolver->iterate_label_ribs ([&] (Rib *r) -> void { ScanRib (r); });\n   }\n };\n "}, {"sha": "4f7382a7e52d634f6ce87086372ad084ed4fa03a", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -49,7 +49,8 @@ namespace Resolver {\n Resolver::Resolver ()\n   : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n     name_scope (Scope (mappings->get_current_crate ())),\n-    type_scope (Scope (mappings->get_current_crate ()))\n+    type_scope (Scope (mappings->get_current_crate ())),\n+    label_scope (Scope (mappings->get_current_crate ()))\n {\n   generate_builtins ();\n }\n@@ -81,6 +82,13 @@ Resolver::push_new_type_rib (Rib *r)\n   type_ribs[r->get_node_id ()] = r;\n }\n \n+void\n+Resolver::push_new_label_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  label_ribs[r->get_node_id ()] = r;\n+}\n+\n bool\n Resolver::find_name_rib (NodeId id, Rib **rib)\n {\n@@ -238,6 +246,27 @@ Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n   return true;\n }\n \n+void\n+Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  rust_assert (it == resolved_labels.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  if (it == resolved_labels.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n // NameResolution\n \n NameResolution *\n@@ -275,6 +304,9 @@ NameResolution::go (AST::Crate &crate)\n   // setup parent scoping for new types\n   resolver->get_type_scope ().push (mappings->get_next_node_id ());\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  // setup label scope\n+  resolver->get_label_scope ().push (mappings->get_next_node_id ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n   // first gather the top-level namespace names then we drill down\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n@@ -293,8 +325,10 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   NodeId scope_node_id = expr.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n   resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n   expr.iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n     ResolveStmt::go (s, s->get_node_id ());\n@@ -306,6 +340,7 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n }\n \n // rust-ast-resolve-struct-expr-field.h"}, {"sha": "9c01d47debade8193957bb287c1cc89b39c9b051", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -250,9 +250,11 @@ class Resolver\n \n   void push_new_name_rib (Rib *r);\n   void push_new_type_rib (Rib *r);\n+  void push_new_label_rib (Rib *r);\n \n   bool find_name_rib (NodeId id, Rib **rib);\n   bool find_type_rib (NodeId id, Rib **rib);\n+  bool find_label_rib (NodeId id, Rib **rib);\n \n   void insert_new_definition (NodeId id, Definition def);\n   bool lookup_definition (NodeId id, Definition *def);\n@@ -263,9 +265,13 @@ class Resolver\n   void insert_resolved_type (NodeId refId, NodeId defId);\n   bool lookup_resolved_type (NodeId refId, NodeId *defId);\n \n+  void insert_resolved_label (NodeId refId, NodeId defId);\n+  bool lookup_resolved_label (NodeId refId, NodeId *defId);\n+\n   // proxy for scoping\n   Scope &get_name_scope () { return name_scope; }\n   Scope &get_type_scope () { return type_scope; }\n+  Scope &get_label_scope () { return label_scope; }\n \n   NodeId get_global_type_node_id () { return global_type_node_id; }\n \n@@ -320,6 +326,12 @@ class Resolver\n       }\n   }\n \n+  void iterate_label_ribs (std::function<void (Rib *)> cb)\n+  {\n+    for (auto it = label_ribs.begin (); it != label_ribs.end (); it++)\n+      cb (it->second);\n+  }\n+\n private:\n   Resolver ();\n \n@@ -332,13 +344,15 @@ class Resolver\n \n   Scope name_scope;\n   Scope type_scope;\n+  Scope label_scope;\n \n   NodeId global_type_node_id;\n   NodeId unit_ty_node_id;\n \n   // map a AST Node to a Rib\n   std::map<NodeId, Rib *> name_ribs;\n   std::map<NodeId, Rib *> type_ribs;\n+  std::map<NodeId, Rib *> label_ribs;\n \n   // map any Node to its Definition\n   // ie any name or type usage\n@@ -354,6 +368,7 @@ class Resolver\n   // we need two namespaces one for names and ones for types\n   std::map<NodeId, NodeId> resolved_names;\n   std::map<NodeId, NodeId> resolved_types;\n+  std::map<NodeId, NodeId> resolved_labels;\n \n   // map of resolved names mutability flag\n   std::map<NodeId, bool> decl_mutability;"}, {"sha": "50e8728fd48bae873d0d9ed2cf3714dd61ca3aba", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -425,6 +425,12 @@ class Backend\n \t\t\t\t    Location)\n     = 0;\n \n+  // infinite loop expressions\n+  virtual Bexpression *loop_expression (Bblock *body, Location);\n+\n+  // exit expressions\n+  virtual Bexpression *exit_expression (Bexpression *condition, Location);\n+\n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n   // VALUE matches any of the list in CASES[i], which will all be"}, {"sha": "82ebb988a0ff569ee2c77b9e62da2e2a88863c6d", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -326,6 +326,10 @@ class Gcc_backend : public Backend\n \t\t\t\t\t   Bstatement *except_stmt,\n \t\t\t\t\t   Bstatement *finally_stmt, Location);\n \n+  Bexpression *loop_expression (Bblock *body, Location);\n+\n+  Bexpression *exit_expression (Bexpression *condition, Location);\n+\n   // Blocks.\n \n   Bblock *block (Bfunction *, Bblock *, const std::vector<Bvariable *> &,\n@@ -2201,6 +2205,25 @@ Gcc_backend::if_statement (Bfunction *, Bexpression *condition,\n   return this->make_statement (ret);\n }\n \n+// Loops\n+\n+Bexpression *\n+Gcc_backend::loop_expression (Bblock *body, Location locus)\n+{\n+  tree loop_expr_tree = fold_build1_loc (locus.gcc_location (), LOOP_EXPR,\n+\t\t\t\t\t void_type_node, body->get_tree ());\n+  return this->make_expression (loop_expr_tree);\n+}\n+\n+Bexpression *\n+Gcc_backend::exit_expression (Bexpression *condition, Location locus)\n+{\n+  tree cond_tree = condition->get_tree ();\n+  tree exit_expr_tree = fold_build1_loc (locus.gcc_location (), EXIT_EXPR,\n+\t\t\t\t\t void_type_node, cond_tree);\n+  return this->make_expression (exit_expr_tree);\n+}\n+\n // Switch.\n \n Bstatement *"}, {"sha": "b8742fba58f1f9f96f242f178e8ca80b767dce70", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 146, "deletions": 66, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -21,6 +21,8 @@\n #include \"rust-diagnostics.h\"\n #include \"diagnostic.h\"\n #include \"input.h\"\n+#include <fstream>\n+#include <sstream>\n \n #include \"target.h\"\n #include \"tm.h\"\n@@ -46,6 +48,13 @@ rust_get_backend ();\n \n namespace Rust {\n \n+const char *kLexDumpFile = \"gccrs.lex.dump\";\n+const char *kASTDumpFile = \"gccrs.ast.dump\";\n+const char *kASTExpandedDumpFile = \"gccrs.ast-expanded.dump\";\n+const char *kHIRDumpFile = \"gccrs.hir.dump\";\n+const char *kHIRTypeResolutionDumpFile = \"gccrs.type-resolution.dump\";\n+const char *kTargetOptionsDumpFile = \"gccrs.target-options.dump\";\n+\n // Implicitly enable a target_feature (and recursively enable dependencies).\n void\n Session::implicitly_enable_feature (std::string feature_name)\n@@ -309,9 +318,7 @@ Session::init ()\n  * itself. */\n void\n Session::init_options ()\n-{\n-  options.dump_option = CompileOptions::NO_DUMP;\n-}\n+{}\n \n // Handle option selection.\n bool\n@@ -357,62 +364,51 @@ Session::handle_option (\n bool\n Session::enable_dump (std::string arg)\n {\n-  /* FIXME: change dumping algorithm when new non-inhibiting dump system is\n-   * created */\n-  if (arg == \"all\")\n+  if (arg.empty ())\n     {\n       rust_error_at (\n \tLocation (),\n-\t\"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n+\t\"dump option was not given a name. choose %<lex%>, %<parse%>, \"\n \t\"%<register_plugins%>, %<injection%>, %<expansion%>, %<resolution%>,\"\n-\t\" %<target_options%>, or %<hir%>\");\n+\t\" %<target_options%>, %<hir%>, or %<all%>\");\n       return false;\n     }\n+\n+  if (arg == \"all\")\n+    {\n+      options.enable_all_dump_options ();\n+    }\n   else if (arg == \"lex\")\n     {\n-      options.dump_option = CompileOptions::LEXER_DUMP;\n+      options.enable_dump_option (CompileOptions::LEXER_DUMP);\n     }\n   else if (arg == \"parse\")\n     {\n-      options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+      options.enable_dump_option (CompileOptions::PARSER_AST_DUMP);\n     }\n   else if (arg == \"register_plugins\")\n     {\n-      options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+      options.enable_dump_option (CompileOptions::REGISTER_PLUGINS_DUMP);\n     }\n   else if (arg == \"injection\")\n     {\n-      options.dump_option = CompileOptions::INJECTION_DUMP;\n+      options.enable_dump_option (CompileOptions::INJECTION_DUMP);\n     }\n   else if (arg == \"expansion\")\n     {\n-      options.dump_option = CompileOptions::EXPANSION_DUMP;\n+      options.enable_dump_option (CompileOptions::EXPANSION_DUMP);\n     }\n   else if (arg == \"resolution\")\n     {\n-      options.dump_option = CompileOptions::RESOLUTION_DUMP;\n+      options.enable_dump_option (CompileOptions::RESOLUTION_DUMP);\n     }\n   else if (arg == \"target_options\")\n     {\n-      // special case - dump all target options, and then quit compilation\n-      // nope, option handling called before init, so have to make this an\n-      // actual compile option\n-      // options.target_data.dump_target_options();\n-      // return false;\n-      options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n+      options.enable_dump_option (CompileOptions::TARGET_OPTION_DUMP);\n     }\n   else if (arg == \"hir\")\n     {\n-      options.dump_option = CompileOptions::HIR_DUMP;\n-    }\n-  else if (arg == \"\")\n-    {\n-      rust_error_at (\n-\tLocation (),\n-\t\"dump option was not given a name. choose \"\n-\t\"%<lex%>, %<parse%>, %<register_plugins%>, %<injection%>, \"\n-\t\"%<expansion%>, %<resolution%>, %<target_options%>, or %<hir%>\");\n-      return false;\n+      options.enable_dump_option (CompileOptions::HIR_DUMP);\n     }\n   else\n     {\n@@ -465,24 +461,22 @@ Session::parse_file (const char *filename)\n   auto mappings = Analysis::Mappings::get ();\n   mappings->insert_ast_crate (&parsed_crate);\n \n-  // give a chance to give some debug\n-  switch (options.dump_option)\n+  if (options.dump_option_enabled (CompileOptions::LEXER_DUMP))\n+    {\n+      dump_lex (parser);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::PARSER_AST_DUMP))\n+    {\n+      dump_ast (parser, parsed_crate);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::TARGET_OPTION_DUMP))\n     {\n-    case CompileOptions::LEXER_DUMP:\n-      parser.debug_dump_lex_output ();\n-      // TODO: rewrite lexer dump or something so that it allows for the crate\n-      // to already be parsed\n-      break;\n-    case CompileOptions::PARSER_AST_DUMP:\n-      parser.debug_dump_ast_output (parsed_crate);\n-      break;\n-    case CompileOptions::TARGET_OPTION_DUMP:\n       options.target_data.dump_target_options ();\n-      return;\n-    default:\n-      break;\n     }\n \n+  if (saw_errors ())\n+    return;\n+\n   /* basic pipeline:\n    *  - lex\n    *  - parse\n@@ -502,36 +496,33 @@ Session::parse_file (const char *filename)\n   // register plugins pipeline stage\n   register_plugins (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::REGISTER_PLUGINS_DUMP))\n     {\n       // TODO: what do I dump here?\n     }\n \n   // injection pipeline stage\n   injection (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::INJECTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::INJECTION_DUMP))\n     {\n       // TODO: what do I dump here? injected crate names?\n     }\n \n   // expansion pipeline stage\n   expansion (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::EXPANSION_DUMP))\n     {\n       // dump AST with expanded stuff\n       fprintf (stderr, \"BEGIN POST-EXPANSION AST DUMP\\n\");\n-      parser.debug_dump_ast_output (parsed_crate);\n+      dump_ast_expanded (parser, parsed_crate);\n       fprintf (stderr, \"END POST-EXPANSION AST DUMP\\n\");\n     }\n \n   // resolution pipeline stage\n   Resolver::NameResolution::Resolve (parsed_crate);\n-  if (options.dump_option == CompileOptions::RESOLUTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::RESOLUTION_DUMP))\n     {\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n     }\n@@ -541,22 +532,19 @@ Session::parse_file (const char *filename)\n \n   // lower AST to HIR\n   HIR::Crate hir = HIR::ASTLowering::Resolve (parsed_crate);\n-  if (options.dump_option == CompileOptions::HIR_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::HIR_DUMP))\n     {\n-      fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n-      return;\n+      dump_hir (hir);\n     }\n \n   if (saw_errors ())\n     return;\n \n   // type resolve\n   Resolver::TypeResolution::Resolve (hir);\n-  if (options.dump_option == CompileOptions::TYPE_RESOLUTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::TYPE_RESOLUTION_DUMP))\n     {\n-      auto buf = Resolver::TypeResolverDump::go (hir);\n-      fprintf (stderr, \"%s\\n\", buf.c_str ());\n-      return;\n+      dump_type_resolution (hir);\n     }\n \n   // scan unused has to be done after type resolution since methods are resolved\n@@ -798,23 +786,115 @@ Session::expansion (AST::Crate &crate)\n   fprintf (stderr, \"finished expansion\\n\");\n }\n \n+void\n+Session::dump_lex (Parser<Lexer> &parser) const\n+{\n+  std::ofstream out;\n+  out.open (kLexDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kLexDumpFile);\n+      return;\n+    }\n+\n+  // TODO: rewrite lexer dump or something so that it allows for the crate\n+  // to already be parsed\n+  parser.debug_dump_lex_output (out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTExpandedDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTExpandedDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_hir (HIR::Crate &hir) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRDumpFile);\n+      return;\n+    }\n+\n+  out << hir.as_string ();\n+  out.close ();\n+}\n+\n+void\n+Session::dump_type_resolution (HIR::Crate &hir) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRTypeResolutionDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRTypeResolutionDumpFile);\n+      return;\n+    }\n+\n+  Resolver::TypeResolverDump::go (hir, out);\n+  out.close ();\n+}\n+\n void\n TargetOptions::dump_target_options () const\n {\n-  fprintf (stderr,\n-\t   \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+  std::ofstream out;\n+  out.open (kTargetOptionsDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kTargetOptionsDumpFile);\n+      return;\n+    }\n+\n+  if (features.empty ())\n+    {\n+      out << \"No target options available!\\n\";\n+    }\n+\n   for (const auto &pairs : features)\n     {\n       for (const auto &value : pairs.second)\n-\tfprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (), value.c_str ());\n+\tout << pairs.first + \": \\\"\" + value + \"\\\"\\n\";\n \n       if (pairs.second.empty ())\n-\tfprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n+\tout << pairs.first + \"\\n\";\n     }\n-  if (features.empty ())\n-    fprintf (stderr, \"No target options available!\\n\");\n \n-  fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+  out.close ();\n }\n \n void"}, {"sha": "b7e081bb8249e82f820e68ff0c8195b2bee45f0d", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -116,8 +116,8 @@ struct TargetOptions\n   // Dump all target options to stderr.\n   void dump_target_options () const;\n \n-  /* Creates derived values and implicit enables after all target info is added\n-   * (e.g. \"unix\"). */\n+  /* Creates derived values and implicit enables after all target info is\n+   * added (e.g. \"unix\"). */\n   void init_derived_values ();\n \n   /* Enables all requirements for the feature given, and will enable feature\n@@ -162,13 +162,8 @@ struct TargetOptions\n // Defines compiler options (e.g. dump, etc.).\n struct CompileOptions\n {\n-  // TODO: use bitfield for smaller memory requirements?\n-\n-  /* FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n-   * not inhibit compilation */\n-  enum DumpOptions\n+  enum DumpOption\n   {\n-    NO_DUMP,\n     LEXER_DUMP,\n     PARSER_AST_DUMP,\n     REGISTER_PLUGINS_DUMP,\n@@ -178,8 +173,9 @@ struct CompileOptions\n     TARGET_OPTION_DUMP,\n     HIR_DUMP,\n     TYPE_RESOLUTION_DUMP,\n+  };\n \n-  } dump_option;\n+  std::set<DumpOption> dump_options;\n \n   /* configuration options - actually useful for conditional compilation and\n    * whatever data related to target arch, features, os, family, env, endian,\n@@ -188,6 +184,26 @@ struct CompileOptions\n   bool enable_test = false;\n   bool debug_assertions = false;\n   bool proc_macro = false;\n+\n+  bool dump_option_enabled (DumpOption option) const\n+  {\n+    return dump_options.find (option) != dump_options.end ();\n+  }\n+\n+  void enable_dump_option (DumpOption option) { dump_options.insert (option); }\n+\n+  void enable_all_dump_options ()\n+  {\n+    enable_dump_option (DumpOption::LEXER_DUMP);\n+    enable_dump_option (DumpOption::PARSER_AST_DUMP);\n+    enable_dump_option (DumpOption::REGISTER_PLUGINS_DUMP);\n+    enable_dump_option (DumpOption::INJECTION_DUMP);\n+    enable_dump_option (DumpOption::EXPANSION_DUMP);\n+    enable_dump_option (DumpOption::RESOLUTION_DUMP);\n+    enable_dump_option (DumpOption::TARGET_OPTION_DUMP);\n+    enable_dump_option (DumpOption::HIR_DUMP);\n+    enable_dump_option (DumpOption::TYPE_RESOLUTION_DUMP);\n+  }\n };\n \n /* Defines a compiler session. This is for a single compiler invocation, so\n@@ -219,6 +235,12 @@ struct Session\n   void parse_file (const char *filename);\n   bool enable_dump (std::string arg);\n \n+  void dump_lex (Parser<Lexer> &parser) const;\n+  void dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_hir (HIR::Crate &crate) const;\n+  void dump_type_resolution (HIR::Crate &crate) const;\n+\n   void debug_dump_load_crates (Parser<Lexer> &parser);\n \n   void implicitly_enable_feature (std::string feature_name);"}, {"sha": "87aeae627584180caebc1f9a87fff9c4e29ce477", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 123, "deletions": 146, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -32,14 +32,15 @@ namespace Resolver {\n class TypeCheckExpr : public TypeCheckBase\n {\n public:\n-  static TyTy::TyBase *Resolve (HIR::Expr *expr, bool is_final_expr = false)\n+  static TyTy::TyBase *Resolve (HIR::Expr *expr, bool inside_loop)\n   {\n-    TypeCheckExpr resolver (is_final_expr);\n+    TypeCheckExpr resolver (inside_loop);\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n       {\n-\trust_error_at (expr->get_locus_slow (), \"failed to resolve expression\");\n+\trust_error_at (expr->get_locus_slow (),\n+\t\t       \"failed to type resolve expression\");\n \treturn new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n       }\n \n@@ -52,7 +53,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::TupleIndexExpr &expr)\n   {\n-    auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n+    auto resolved\n+      = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get (), inside_loop);\n     if (resolved == nullptr)\n       {\n \trust_error_at (expr.get_tuple_expr ()->get_locus_slow (),\n@@ -128,18 +130,24 @@ class TypeCheckExpr : public TypeCheckBase\n     std::vector<HirId> fields;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n-\tauto field_ty = TypeCheckExpr::Resolve (elem.get ());\n+\tauto field_ty = TypeCheckExpr::Resolve (elem.get (), false);\n \tfields.push_back (field_ty->get_ref ());\n       }\n     infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (), fields);\n   }\n \n   void visit (HIR::ReturnExpr &expr)\n   {\n+    if (!expr.has_return_expr ())\n+      {\n+\tinfered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+\treturn;\n+      }\n+\n     auto fn_return_tyty = context->peek_return_type ();\n     rust_assert (fn_return_tyty != nullptr);\n \n-    auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n+    auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr (), false);\n     if (expr_ty == nullptr)\n       {\n \trust_error_at (expr.get_locus (),\n@@ -155,58 +163,12 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::CallExpr &expr)\n   {\n-    auto fn = expr.get_fnexpr ();\n-    auto fn_node_id = fn->get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n-      {\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-    else if (!resolver->lookup_resolved_type (fn_node_id, &ref_node_id))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure for node %u\",\n-\t\t       ref_node_id);\n-\treturn;\n-      }\n-\n-    // check if this has a type\n-    TyTy::TyBase *lookup;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"failed to lookup type for CallExpr: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n+    TyTy::TyBase *function_tyty\n+      = TypeCheckExpr::Resolve (expr.get_fnexpr (), false);\n+    if (function_tyty == nullptr)\n+      return;\n \n-    infered = TyTy::TypeCheckCallExpr::go (lookup, expr, context);\n+    infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, context);\n     if (infered == nullptr)\n       {\n \trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n@@ -218,7 +180,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::MethodCallExpr &expr)\n   {\n-    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+    auto receiver_tyty\n+      = TypeCheckExpr::Resolve (expr.get_receiver ().get (), false);\n     if (receiver_tyty == nullptr)\n       {\n \trust_error_at (expr.get_receiver ()->get_locus_slow (),\n@@ -277,11 +240,13 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::AssignmentExpr &expr)\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n \n-    infered = lhs->combine (rhs);\n-    if (infered == nullptr)\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+\n+    auto result = lhs->combine (rhs);\n+    if (result == nullptr)\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failure in TypeInference AssignmentExpr\");\n@@ -320,11 +285,10 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    // FIXME free the old one\n     context->insert_type (\n       Analysis::NodeMapping (expr.get_lhs ()->get_mappings ().get_crate_num (),\n \t\t\t     ref_node_id, ref, UNKNOWN_LOCAL_DEFID),\n-      infered->clone ());\n+      result->clone ());\n   }\n \n   void visit (HIR::IdentifierExpr &expr)\n@@ -485,8 +449,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr)\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n     bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n     bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n@@ -506,8 +470,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ComparisonExpr &expr)\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n     auto result = lhs->combine (rhs);\n     if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n@@ -521,8 +485,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::LazyBooleanExpr &expr)\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n     // we expect the lhs and rhs must be bools at this point\n     TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n@@ -542,7 +506,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::NegationExpr &expr)\n   {\n-    auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n+    auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr (), false);\n \n     // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n     switch (expr.get_negation_type ())\n@@ -591,79 +555,31 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::IfExpr &expr)\n   {\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    auto blk_expr = TypeCheckExpr::Resolve (expr.get_if_block ());\n-\n-    if (is_final_expr\n-\t&& context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n-      {\n-\tauto expected_ty = context->peek_return_type ();\n-\tinfered = expected_ty->combine (blk_expr);\n-\treturn;\n-      }\n+    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n+    TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n \n     infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    // check and resolve all types in the conditional var\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n+    auto if_blk_resolved\n+      = TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n+    auto else_blk_resolved\n+      = TypeCheckExpr::Resolve (expr.get_else_block (), inside_loop);\n \n-    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n-    auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n-\n-    TyTy::TyBase *if_block_tyty = nullptr;\n-    if (expr.get_if_block ()->has_expr ())\n-      if_block_tyty\n-\t= TypeCheckExpr::Resolve (expr.get_if_block ()->expr.get ());\n-    else\n-      if_block_tyty = if_blk_resolved;\n-\n-    TyTy::TyBase *else_block_tyty = nullptr;\n-    if (expr.get_else_block ()->has_expr ())\n-      else_block_tyty\n-\t= TypeCheckExpr::Resolve (expr.get_else_block ()->expr.get ());\n-    else\n-      else_block_tyty = else_blk_resolved;\n-\n-    if (context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n-      {\n-\t// this must combine to what the type is expected\n-\t// this might be a parameter or the last expr in an if + else in a\n-\t// BlockExpr then it must resolve to fn return type else its a unit-type\n-\tauto expected_ty\n-\t  = is_final_expr\n-\t      ? context->peek_return_type ()\n-\t      : new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n-\n-\tauto if_blk_combined = expected_ty->combine (if_block_tyty);\n-\tauto else_blk_combined = expected_ty->combine (else_block_tyty);\n-\n-\tinfered = if_blk_combined->combine (else_blk_combined);\n-\treturn;\n-      }\n-\n-    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+    infered = if_blk_resolved->combine (else_blk_resolved);\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    TypeCheckExpr::Resolve (expr.get_if_condition ());\n-    auto if_blk = TypeCheckExpr::Resolve (expr.get_if_block ());\n-    auto elif_blk = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n-\n-    if (is_final_expr\n-\t&& context->peek_return_type ()->get_kind () != TyTy::TypeKind::UNIT)\n-      {\n-\tauto expected_ty = context->peek_return_type ();\n-\n-\tinfered = expected_ty->combine (if_blk);\n-\tinfered = infered->combine (elif_blk);\n-\treturn;\n-      }\n+    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n+    auto if_blk = TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n+    auto else_blk\n+      = TypeCheckExpr::Resolve (expr.get_conseq_if_expr (), inside_loop);\n \n-    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+    infered = if_blk->combine (else_blk);\n   }\n \n   void visit (HIR::BlockExpr &expr);\n@@ -679,8 +595,8 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    auto resolved_index_expr\n-      = size_ty->combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n+    auto resolved_index_expr = size_ty->combine (\n+      TypeCheckExpr::Resolve (expr.get_index_expr (), false));\n     if (resolved_index_expr == nullptr)\n       {\n \trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n@@ -727,7 +643,7 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     std::vector<TyTy::TyBase *> types;\n     elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n-      types.push_back (TypeCheckExpr::Resolve (e));\n+      types.push_back (TypeCheckExpr::Resolve (e, false));\n       return true;\n     });\n \n@@ -743,7 +659,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ArrayElemsCopied &elems)\n   {\n-    infered_array_elems = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n+    infered_array_elems\n+      = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n   }\n \n   void visit (HIR::StructExprStructFields &struct_expr)\n@@ -753,13 +670,17 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::GroupedExpr &expr)\n   {\n-    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n+    printf (\"inside grouped expr: \\n%s\\n inside it is: \\n%s\\n\",\n+\t    expr.as_string ().c_str (),\n+\t    expr.get_expr_in_parens ()->as_string ().c_str ());\n+\n+    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get (), false);\n   }\n \n   void visit (HIR::FieldAccessExpr &expr)\n   {\n     auto struct_base\n-      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n+      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get (), false);\n \n     bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n     if (!is_valid_type)\n@@ -788,16 +709,33 @@ class TypeCheckExpr : public TypeCheckBase\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n \n     // then lookup the reference_node_id\n-    NodeId ref_node_id;\n-    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n       {\n-\tif (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n \t  {\n \t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"Failed to lookup reference for node: %s\",\n-\t\t\t   expr.as_string ().c_str ());\n+\t\t\t   \"unknown reference for resolved name\");\n \t    return;\n \t  }\n+\tref_node_id = def.parent;\n+      }\n+    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n       }\n \n     // node back to HIR\n@@ -813,13 +751,52 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"failed to resolve PathInExpression type\");\n+\treturn;\n+      }\n+  }\n+\n+  void visit (HIR::LoopExpr &expr)\n+  {\n+    context->push_new_loop_context (expr.get_mappings ().get_hirid ());\n+    TypeCheckExpr::Resolve (expr.get_loop_block ().get (), true);\n+    TyTy::TyBase *loop_context_type = context->pop_loop_context ();\n+\n+    bool loop_context_type_infered\n+      = (loop_context_type->get_kind () != TyTy::TypeKind::INFER)\n+\t|| ((loop_context_type->get_kind () == TyTy::TypeKind::INFER)\n+\t    && (((TyTy::InferType *) loop_context_type)->get_infer_kind ()\n+\t\t!= TyTy::InferType::GENERAL));\n+\n+    infered = loop_context_type_infered\n+\t\t? loop_context_type\n+\t\t: new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n+  }\n+\n+  void visit (HIR::BreakExpr &expr)\n+  {\n+    if (!inside_loop)\n+      {\n+\trust_error_at (expr.get_locus (), \"cannot `break` outside of a loop\");\n+\treturn;\n       }\n+\n+    if (expr.has_break_expr ())\n+      {\n+\tTyTy::TyBase *break_expr_tyty\n+\t  = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n+\n+\tTyTy::TyBase *loop_context = context->peek_loop_context ();\n+\tTyTy::TyBase *combined = loop_context->combine (break_expr_tyty);\n+\tcontext->swap_head_loop_context (combined);\n+      }\n+\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n private:\n-  TypeCheckExpr (bool is_final_expr)\n+  TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n-      is_final_expr (is_final_expr)\n+      inside_loop (inside_loop)\n   {}\n \n   bool\n@@ -871,7 +848,7 @@ class TypeCheckExpr : public TypeCheckBase\n   TyTy::TyBase *infered;\n   TyTy::TyBase *infered_array_elems;\n \n-  bool is_final_expr;\n+  bool inside_loop;\n };\n \n } // namespace Resolver"}, {"sha": "3e835b727f7bc969e69b1736e679d0cbf6e69a36", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -40,7 +40,8 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n   void visit (HIR::ConstantItem &constant)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+    TyTy::TyBase *expr_type\n+      = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->combine (expr_type));\n   }\n@@ -170,23 +171,12 @@ class TypeCheckImplItem : public TypeCheckBase\n     auto expected_ret_tyty = resolve_fn_type->return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n-    TypeCheckExpr::Resolve (function.function_body.get ());\n-    if (function.function_body->has_expr ())\n-      {\n-\tauto resolved\n-\t  = TypeCheckExpr::Resolve (function.function_body->expr.get ());\n+    auto result = TypeCheckExpr::Resolve (function.function_body.get (), false);\n+    auto ret_resolved = expected_ret_tyty->combine (result);\n+    if (ret_resolved == nullptr)\n+      return;\n \n-\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n-\tif (ret_resolved == nullptr)\n-\t  {\n-\t    rust_error_at (function.function_body->expr->get_locus_slow (),\n-\t\t\t   \"failed to resolve final expression\");\n-\t    return;\n-\t  }\n-\n-\tcontext->peek_return_type ()->append_reference (\n-\t  ret_resolved->get_ref ());\n-      }\n+    context->peek_return_type ()->append_reference (ret_resolved->get_ref ());\n \n     context->pop_return_type ();\n   }\n@@ -213,23 +203,13 @@ class TypeCheckImplItem : public TypeCheckBase\n     auto expected_ret_tyty = resolve_fn_type->return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n-    TypeCheckExpr::Resolve (method.get_function_body ().get ());\n-    if (method.get_function_body ()->has_expr ())\n-      {\n-\tauto resolved\n-\t  = TypeCheckExpr::Resolve (method.get_function_body ()->expr.get ());\n+    auto result\n+      = TypeCheckExpr::Resolve (method.get_function_body ().get (), false);\n+    auto ret_resolved = expected_ret_tyty->combine (result);\n+    if (ret_resolved == nullptr)\n+      return;\n \n-\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n-\tif (ret_resolved == nullptr)\n-\t  {\n-\t    rust_error_at (method.get_function_body ()->expr->get_locus_slow (),\n-\t\t\t   \"failed to resolve final expression\");\n-\t    return;\n-\t  }\n-\n-\tcontext->peek_return_type ()->append_reference (\n-\t  ret_resolved->get_ref ());\n-      }\n+    context->peek_return_type ()->append_reference (ret_resolved->get_ref ());\n \n     context->pop_return_type ();\n   }"}, {"sha": "f54956c608066dc4f2a4a2473cbdfe5cb96816a5", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -75,23 +75,12 @@ class TypeCheckItem : public TypeCheckBase\n     auto expected_ret_tyty = resolve_fn_type->return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n-    TypeCheckExpr::Resolve (function.function_body.get ());\n-    if (function.function_body->has_expr ())\n-      {\n-\tauto resolved\n-\t  = TypeCheckExpr::Resolve (function.function_body->expr.get ());\n-\n-\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n-\tif (ret_resolved == nullptr)\n-\t  {\n-\t    rust_error_at (function.function_body->expr->get_locus_slow (),\n-\t\t\t   \"failed to resolve final expression\");\n-\t    return;\n-\t  }\n-\n-\tcontext->peek_return_type ()->append_reference (\n-\t  ret_resolved->get_ref ());\n-      }\n+    auto result = TypeCheckExpr::Resolve (function.function_body.get (), false);\n+    auto ret_resolved = expected_ret_tyty->combine (result);\n+    if (ret_resolved == nullptr)\n+      return;\n+\n+    context->peek_return_type ()->append_reference (ret_resolved->get_ref ());\n \n     context->pop_return_type ();\n   }"}, {"sha": "195e48341b883ead9435d8c01cd37b40feb202d9", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -30,21 +30,21 @@ namespace Resolver {\n class TypeCheckStmt : public TypeCheckBase\n {\n public:\n-  static TyTy::TyBase *Resolve (HIR::Stmt *stmt, bool is_final_stmt)\n+  static TyTy::TyBase *Resolve (HIR::Stmt *stmt, bool inside_loop)\n   {\n-    TypeCheckStmt resolver (is_final_stmt);\n+    TypeCheckStmt resolver (inside_loop);\n     stmt->accept_vis (resolver);\n     return resolver.infered;\n   }\n \n   void visit (HIR::ExprStmtWithBlock &stmt)\n   {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr (), is_final_stmt);\n+    infered = TypeCheckExpr::Resolve (stmt.get_expr (), inside_loop);\n   }\n \n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr (), is_final_stmt);\n+    infered = TypeCheckExpr::Resolve (stmt.get_expr (), inside_loop);\n   }\n \n   void visit (HIR::LetStmt &stmt)\n@@ -55,7 +55,7 @@ class TypeCheckStmt : public TypeCheckBase\n     if (stmt.has_init_expr ())\n       {\n \tinit_expr_ty\n-\t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+\t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), inside_loop);\n \tif (init_expr_ty == nullptr)\n \t  return;\n \n@@ -106,13 +106,13 @@ class TypeCheckStmt : public TypeCheckBase\n   }\n \n private:\n-  TypeCheckStmt (bool is_final_stmt)\n-    : TypeCheckBase (), infered (nullptr), is_final_stmt (is_final_stmt)\n+  TypeCheckStmt (bool inside_loop)\n+    : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n   {}\n \n   TyTy::TyBase *infered;\n-  bool is_final_stmt;\n-}; // namespace Resolver\n+  bool inside_loop;\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "6d4c876ade341b1bc10bab34488297f4f924a9bb", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -86,15 +86,16 @@ class TypeCheckTopLevel : public TypeCheckBase\n   void visit (HIR::StaticItem &var)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (var.get_type ());\n-    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n+    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (var.get_expr (), false);\n \n     context->insert_type (var.get_mappings (), type->combine (expr_type));\n   }\n \n   void visit (HIR::ConstantItem &constant)\n   {\n     TyTy::TyBase *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::TyBase *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n+    TyTy::TyBase *expr_type\n+      = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->combine (expr_type));\n   }"}, {"sha": "00a92b06cbb4704a4207485d68dc1222905244c3", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -109,10 +109,11 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n \n   expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n     bool is_final_stmt = expr.is_final_stmt (s);\n-    bool is_final_expr = is_final_stmt && !expr.has_expr ();\n+    bool is_final_expr\n+      = is_final_stmt && (!expr.has_expr () || !expr.tail_expr_reachable ());\n \n-    auto infered = TypeCheckStmt::Resolve (s, is_final_expr);\n-    if (infered == nullptr)\n+    auto resolved = TypeCheckStmt::Resolve (s, inside_loop);\n+    if (resolved == nullptr)\n       {\n \trust_error_at (s->get_locus_slow (), \"failure to resolve type\");\n \treturn false;\n@@ -121,7 +122,12 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     if (is_final_expr)\n       {\n \tdelete block_tyty;\n-\tblock_tyty = infered;\n+\tblock_tyty = resolved;\n+      }\n+    else if (resolved->get_kind () != TyTy::TypeKind::UNIT)\n+      {\n+\trust_error_at (s->get_locus_slow (), \"expected () got %s\",\n+\t\t       infered->as_string ().c_str ());\n       }\n \n     return true;\n@@ -131,7 +137,8 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     {\n       delete block_tyty;\n \n-      block_tyty = TypeCheckExpr::Resolve (expr.get_final_expr ().get (), true);\n+      block_tyty\n+\t= TypeCheckExpr::Resolve (expr.get_final_expr ().get (), inside_loop);\n     }\n \n   infered = block_tyty->clone ();\n@@ -154,7 +161,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   if (struct_expr.has_struct_base ())\n     {\n       TyTy::TyBase *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n+\t\t\t\t  false);\n       resolved = struct_path_resolved->combine (base_resolved);\n       if (resolved == nullptr)\n \t{\n@@ -320,7 +328,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n     }\n \n   size_t field_index;\n-  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value (), false);\n   TyTy::StructFieldType *field_type\n     = struct_path_resolved->get_field (field.field_name, &field_index);\n   if (field_type == nullptr)\n@@ -349,7 +357,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n     }\n \n   size_t field_index;\n-  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value ());\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (field.get_value (), false);\n   TyTy::StructFieldType *field_type\n     = struct_path_resolved->get_field (field_name, &field_index);\n   if (field_type == nullptr)\n@@ -389,7 +397,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n   // existing code to figure out the type\n   HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n \t\t\t    field.get_locus ());\n-  TyTy::TyBase *value = TypeCheckExpr::Resolve (&expr);\n+  TyTy::TyBase *value = TypeCheckExpr::Resolve (&expr, false);\n \n   resolved_field = field_type->get_field_type ()->combine (value);\n   if (resolved_field != nullptr)"}, {"sha": "531d24189f3357a99ef3eb75746bb7435ce57451", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -56,13 +56,36 @@ class TypeCheckContext\n       }\n   }\n \n+  void push_new_loop_context (HirId id)\n+  {\n+    TyTy::TyBase *infer_var\n+      = new TyTy::InferType (id, TyTy::InferType::InferTypeKind::GENERAL);\n+    loop_type_stack.push_back (infer_var);\n+  }\n+\n+  TyTy::TyBase *peek_loop_context () { return loop_type_stack.back (); }\n+\n+  TyTy::TyBase *pop_loop_context ()\n+  {\n+    auto back = peek_loop_context ();\n+    loop_type_stack.pop_back ();\n+    return back;\n+  }\n+\n+  void swap_head_loop_context (TyTy::TyBase *val)\n+  {\n+    loop_type_stack.pop_back ();\n+    loop_type_stack.push_back (val);\n+  }\n+\n private:\n   TypeCheckContext ();\n \n   std::map<NodeId, HirId> node_id_refs;\n   std::map<HirId, TyTy::TyBase *> resolved;\n   std::vector<std::unique_ptr<TyTy::TyBase> > builtins;\n   std::vector<TyTy::TyBase *> return_type_stack;\n+  std::vector<TyTy::TyBase *> loop_type_stack;\n };\n \n class TypeResolution"}, {"sha": "17774a7fab5460c7fe51c396640d9a97b000d54f", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -28,13 +28,13 @@ namespace Resolver {\n class TypeResolverDump : public TypeCheckBase\n {\n public:\n-  static std::string go (HIR::Crate &crate)\n+  static void go (HIR::Crate &crate, std::ofstream &out)\n   {\n     TypeResolverDump dumper;\n     for (auto &item : crate.items)\n       item->accept_vis (dumper);\n \n-    return dumper.dump;\n+    out << dumper.dump;\n   }\n \n   void visit (HIR::InherentImpl &impl_block) override"}, {"sha": "e12d5ffcc32f1596199248e892f09229bed80f69", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -501,7 +501,7 @@ TypeCheckCallExpr::visit (ADTType &type)\n     StructFieldType *field = type.get_field (i);\n     TyBase *field_tyty = field->get_field_type ();\n \n-    TyBase *arg = Resolver::TypeCheckExpr::Resolve (p);\n+    TyBase *arg = Resolver::TypeCheckExpr::Resolve (p, false);\n     if (arg == nullptr)\n       {\n \trust_error_at (p->get_locus_slow (), \"failed to resolve argument type\");\n@@ -542,7 +542,7 @@ TypeCheckCallExpr::visit (FnType &type)\n   size_t i = 0;\n   call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto fnparam = type.param_at (i);\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n     if (argument_expr_tyty == nullptr)\n       {\n \trust_error_at (param->get_locus_slow (),\n@@ -593,7 +593,7 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n   size_t i = 1;\n   call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto fnparam = type.param_at (i);\n-    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param, false);\n     if (argument_expr_tyty == nullptr)\n       {\n \trust_error_at (param->get_locus_slow (),"}, {"sha": "4a1d4f7c75e439d104b619a665accaeaf855dec9", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -460,6 +460,12 @@ Mappings::walk_local_defids_for_crate (CrateNum crateNum,\n     }\n }\n \n+void\n+Mappings::insert_node_to_hir (CrateNum crate, NodeId id, HirId ref)\n+{\n+  nodeIdToHirMappings[crate][id] = ref;\n+}\n+\n bool\n Mappings::lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref)\n {"}, {"sha": "b7dbd456ea2828dcd5a16e605f25250d95638f0c", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -136,6 +136,7 @@ class Mappings\n   void walk_local_defids_for_crate (CrateNum crateNum,\n \t\t\t\t    std::function<bool (HIR::Item *)> cb);\n \n+  void insert_node_to_hir (CrateNum crate, NodeId id, HirId ref);\n   bool lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref);\n \n   void insert_location (CrateNum crate, HirId id, Location locus);"}, {"sha": "a66ca7bcb01a62843f2b3d9c85f5a47525d854c4", "filename": "gcc/testsuite/rust.test/compilable/block_expr2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr2.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,14 @@\n+fn test() -> i32 {\n+    123\n+}\n+\n+fn main() {\n+    let a = { test() };\n+    let b = {\n+        if a > 10 {\n+            a - 1\n+        } else {\n+            a + 1\n+        }\n+    };\n+}"}, {"sha": "a8b2f278f030a8cf4c66df8c3307ffdcfabba302", "filename": "gcc/testsuite/rust.test/compilable/block_expr3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr3.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    let x = 111;\n+\n+    let a = {\n+        if x == 10 {\n+            123\n+        } else if x < 10 {\n+            456\n+        } else {\n+            789\n+        }\n+    };\n+}"}, {"sha": "e583008380928548ad6fdc64a0a1c204ccdbb878", "filename": "gcc/testsuite/rust.test/compilable/block_expr_parser_bug.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr_parser_bug.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr_parser_bug.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr_parser_bug.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let a = 123;\n+    let b = if a > 10 { a - 1 } else { a + 1 };\n+}"}, {"sha": "1ff0d24cf8e67b3fadd3d083e9c668e3312cffc7", "filename": "gcc/testsuite/rust.test/compilable/compound_assignment_expr1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fcompound_assignment_expr1.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -16,8 +16,7 @@ fn main() {\n     d /= 4;\n     e %= 5;\n     f &= 6;\n-    // https://github.com/Rust-GCC/gccrs/issues/173\n-    // g |= 7;\n+    g |= 7;\n     h ^= 8;\n     i <<= 9;\n     j >>= 10;"}, {"sha": "32f4728d71c412652ba3cff6d68bbf23d855fcf5", "filename": "gcc/testsuite/rust.test/compilable/function_reference3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ffunction_reference3.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,18 @@\n+struct Foo {\n+    a: fn(i32) -> i32,\n+    b: i32,\n+}\n+\n+fn test(a: i32) -> i32 {\n+    a + 1\n+}\n+\n+fn main() {\n+    let a = test(1);\n+\n+    let b: fn(i32) -> i32 = test;\n+    let c = b(1);\n+\n+    let d = Foo { a: test, b: c };\n+    let e = (d.a)(d.b);\n+}"}, {"sha": "eda6d176ea7d12345fbb327c61dfe5275ed7b3c7", "filename": "gcc/testsuite/rust.test/compilable/if_elif_else_expr1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fif_elif_else_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fif_elif_else_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fif_elif_else_expr1.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,13 @@\n+fn test(x: i32) -> i32 {\n+    if x == 10 {\n+        123\n+    } else if x < 10 {\n+        456\n+    } else {\n+        789\n+    }\n+}\n+\n+fn main() {\n+    let a = test(1);\n+}"}, {"sha": "a8ee2f59bb85facfbf0f9f4254c10c3971957f62", "filename": "gcc/testsuite/rust.test/compilable/loop1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop1.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    loop {\n+        let c = a + b;\n+        a = b;\n+        b = c;\n+    }\n+}"}, {"sha": "3de3ea819472fd710926f040b2c4dbb31786db72", "filename": "gcc/testsuite/rust.test/compilable/loop2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop2.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    // first number in Fibonacci sequence over 10:\n+    loop {\n+        if b > 10 {\n+            break;\n+        }\n+        let c = a + b;\n+        a = b;\n+        b = c;\n+    }\n+}"}, {"sha": "76fadfb4337d250f81834576c2bbda330fa5f1e4", "filename": "gcc/testsuite/rust.test/compilable/loop3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop3.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    // first number in Fibonacci sequence over 10:\n+    loop {\n+        if b > 10 {\n+            return;\n+        }\n+        let c = a + b;\n+        a = b;\n+        b = c;\n+    }\n+}"}, {"sha": "f7b59357aeb110152feaa2d42ca6deb937402248", "filename": "gcc/testsuite/rust.test/compilable/loop4.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop4.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    'outer: loop {\n+        'inner: loop {\n+            break 'outer;\n+        }\n+    }\n+}"}, {"sha": "4004cd30b7b8ea349b145b46c3c55a1ce77b15b0", "filename": "gcc/testsuite/rust.test/compilable/loop5.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Floop5.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    let mut a = 1;\n+    let mut b = 1;\n+\n+    // first number in Fibonacci sequence over 10:\n+    let _fib = loop {\n+        if b > 10 {\n+            break b;\n+        }\n+        let c = a + b;\n+        a = b;\n+        b = c;\n+    };\n+}"}, {"sha": "401a5751d73ca485d2aa9673b4bd8124d2a6c2f4", "filename": "gcc/testsuite/rust.test/fail_compilation/break1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbreak1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d4ed9d38c7a636408a262f70aa69d2a34e2169d/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbreak1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fbreak1.rs?ref=7d4ed9d38c7a636408a262f70aa69d2a34e2169d", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a;\n+    a = 1;\n+    break a;\n+}"}]}