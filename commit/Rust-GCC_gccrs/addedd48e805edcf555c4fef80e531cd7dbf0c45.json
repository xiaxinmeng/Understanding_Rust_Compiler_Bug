{"sha": "addedd48e805edcf555c4fef80e531cd7dbf0c45", "node_id": "C_kwDOANBUbNoAKGFkZGVkZDQ4ZTgwNWVkY2Y1NTVjNGZlZjgwZTUzMWNkN2RiZjBjNDU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-09T11:36:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-09T12:48:36Z"}, "message": "[c++][NFC] Rename Attached to Keyed\n\nWith modules, certain decls are 'scoped' with another decl.  I chose\nthe name 'attached', but that has become something specific in the\nmodules context, so is no longer a good name.  The alternative name I\nconsidered was 'keyed', but we already had the concept of a key\nvirtual function (from the ABI), which is why I went with 'attached'.\nHowever, I think 'keyed' is the less worse name.  I think there's less\nchance of confusion.\n\n\tgcc/cp/\n\t* cp-tree.h (DECL_MODULE_KEYED_DECLS_P): Renamed from\n\tDECL_MODULE_ATTACHMENTS_P.\n\t(struct lane_decl_base): Rename module_attached_p to\n\tmodule_keyed_decls_p.\n\t(maybe_key_decl): Renamed from maybe_attach_decl.\n\t* lambda.cc (record_lambda_scope): Adjust.\n\t* lex.cc (cxx_dup_lang_specific_decl): Adjust.\n\t* module.cc (keyed_map_t, keyed_table): Renamed from attached_map_t,\n\tattached_table.\n\t(enum merge_kind): Rename MK_attached to MK_keyed.\n\t(trees_out::lang_decl_bools): Adjust.\n\t(trees_in::lang_decl_bools): Adjust.\n\t(trees_in::decl_value): Adjust.\n\t(trees_out::get_merge_kind): Adjust.\n\t(trees_out::key_mergeable): Adjust.\n\t(trees_in::key_mergeable): Adjust.\n\t(maybe_key_decl): Rename from maybe_attach_decl.\n\t(direct_import): Adjust.\n\t(fini_modules): Adjust.", "tree": {"sha": "6b13364ebdf0ca03946aa41469fd7be7033037b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b13364ebdf0ca03946aa41469fd7be7033037b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/addedd48e805edcf555c4fef80e531cd7dbf0c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/addedd48e805edcf555c4fef80e531cd7dbf0c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/addedd48e805edcf555c4fef80e531cd7dbf0c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/addedd48e805edcf555c4fef80e531cd7dbf0c45/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49e8f813bb5bd08850309166fbfba8a7346cd8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e8f813bb5bd08850309166fbfba8a7346cd8c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e8f813bb5bd08850309166fbfba8a7346cd8c9"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "10ecab760822a15f41c351159e3f3fa2477441b8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=addedd48e805edcf555c4fef80e531cd7dbf0c45", "patch": "@@ -1734,9 +1734,9 @@ check_constraint_info (tree t)\n   (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (NODE))->u.base.module_entity_p)\n \n /* DECL that has attached decls for ODR-relatedness.  */\n-#define DECL_MODULE_ATTACHMENTS_P(NODE)\t\t\t\\\n+#define DECL_MODULE_KEYED_DECLS_P(NODE)\t\t\t\\\n   (DECL_LANG_SPECIFIC (TREE_CHECK2(NODE,FUNCTION_DECL,VAR_DECL))\\\n-   ->u.base.module_attached_p)\n+   ->u.base.module_keyed_decls_p)\n \n /* Whether this is an exported DECL.  Held on any decl that can appear\n    at namespace scope (function, var, type, template, const or\n@@ -2836,8 +2836,8 @@ struct GTY(()) lang_decl_base {\n   unsigned module_import_p : 1;     \t   /* from an import */\n   unsigned module_entity_p : 1;\t\t   /* is in the entitity ary &\n \t\t\t\t\t      hash.  */\n-  /* VAR_DECL or FUNCTION_DECL has attached decls.     */\n-  unsigned module_attached_p : 1;\n+  /* VAR_DECL or FUNCTION_DECL has keyed decls.     */\n+  unsigned module_keyed_decls_p : 1;\n \n   /* 12 spare bits.  */\n };\n@@ -7196,7 +7196,7 @@ extern unsigned get_importing_module (tree, bool = false) ATTRIBUTE_PURE;\n /* Where current instance of the decl got declared/defined/instantiated.  */\n extern void set_instantiating_module (tree);\n extern void set_defining_module (tree);\n-extern void maybe_attach_decl (tree ctx, tree decl);\n+extern void maybe_key_decl (tree ctx, tree decl);\n \n extern void mangle_module (int m, bool include_partition);\n extern void mangle_module_fini ();"}, {"sha": "0a9f0f8f3108cfd23097913836658276585dbbc6", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=addedd48e805edcf555c4fef80e531cd7dbf0c45", "patch": "@@ -1431,7 +1431,7 @@ record_lambda_scope (tree lambda)\n     {\n       tree closure = LAMBDA_EXPR_CLOSURE (lambda);\n       gcc_checking_assert (closure);\n-      maybe_attach_decl (lambda_scope, TYPE_NAME (closure));\n+      maybe_key_decl (lambda_scope, TYPE_NAME (closure));\n     }\n }\n "}, {"sha": "784debcd705402dda68c471554409ba3a8b9a67b", "filename": "gcc/cp/lex.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.cc?ref=addedd48e805edcf555c4fef80e531cd7dbf0c45", "patch": "@@ -1008,8 +1008,8 @@ cxx_dup_lang_specific_decl (tree node)\n      (module_purview_p still does).  */\n   ld->u.base.module_entity_p = false;\n   ld->u.base.module_import_p = false;\n-  ld->u.base.module_attached_p = false;\n-  \n+  ld->u.base.module_keyed_decls_p = false;\n+\n   if (GATHER_STATISTICS)\n     {\n       tree_node_counts[(int)lang_decl] += 1;"}, {"sha": "6126316a6a0faaf3bb124eeb374b9bdbe3abee7c", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/addedd48e805edcf555c4fef80e531cd7dbf0c45/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=addedd48e805edcf555c4fef80e531cd7dbf0c45", "patch": "@@ -2697,11 +2697,11 @@ pending_map_t *pending_table;\n    completed.  */\n vec<tree, va_heap, vl_embed> *post_load_decls;\n \n-/* Some entities are attached to another entitity for ODR purposes.\n+/* Some entities are keyed to another entitity for ODR purposes.\n    For example, at namespace scope, 'inline auto var = []{};', that\n-   lambda is attached to 'var', and follows its ODRness.  */\n-typedef hash_map<tree, auto_vec<tree>> attached_map_t;\n-static attached_map_t *attached_table;\n+   lambda is keyed to 'var', and follows its ODRness.  */\n+typedef hash_map<tree, auto_vec<tree>> keyed_map_t;\n+static keyed_map_t *keyed_table;\n \n /********************************************************************/\n /* Tree streaming.   The tree streaming is very specific to the tree\n@@ -2766,7 +2766,7 @@ enum merge_kind\n   MK_partial,\n \n   MK_enum,\t/* Found by CTX, & 1stMemberNAME.  */\n-  MK_attached,  /* Found by attachee & index.  */\n+  MK_keyed,     /* Found by key & index.  */\n \n   MK_friend_spec,  /* Like named, but has a tmpl & args too.  */\n   MK_local_friend, /* Found by CTX, index.  */\n@@ -5533,7 +5533,7 @@ trees_out::lang_decl_bools (tree t)\n      that's the GM purview, so not what the importer will mean  */\n   WB (lang->u.base.module_purview_p && !header_module_p ());\n   if (VAR_OR_FUNCTION_DECL_P (t))\n-    WB (lang->u.base.module_attached_p);\n+    WB (lang->u.base.module_keyed_decls_p);\n   switch (lang->u.base.selector)\n     {\n     default:\n@@ -5603,7 +5603,7 @@ trees_in::lang_decl_bools (tree t)\n   RB (lang->u.base.dependent_init_p);\n   RB (lang->u.base.module_purview_p);\n   if (VAR_OR_FUNCTION_DECL_P (t))\n-    RB (lang->u.base.module_attached_p);\n+    RB (lang->u.base.module_keyed_decls_p);\n   switch (lang->u.base.selector)\n     {\n     default:\n@@ -7701,11 +7701,11 @@ trees_out::decl_value (tree decl, depset *dep)\n \n   if (VAR_OR_FUNCTION_DECL_P (inner)\n       && DECL_LANG_SPECIFIC (inner)\n-      && DECL_MODULE_ATTACHMENTS_P (inner)\n+      && DECL_MODULE_KEYED_DECLS_P (inner)\n       && !is_key_order ())\n     {\n-      /* Stream the attached entities.  */\n-      auto *attach_vec = attached_table->get (inner);\n+      /* Stream the keyed entities.  */\n+      auto *attach_vec = keyed_table->get (inner);\n       unsigned num = attach_vec->length ();\n       if (streaming_p ())\n \tu (num);\n@@ -7998,12 +7998,12 @@ trees_in::decl_value ()\n \n   if (VAR_OR_FUNCTION_DECL_P (inner)\n       && DECL_LANG_SPECIFIC (inner)\n-      && DECL_MODULE_ATTACHMENTS_P (inner))\n+      && DECL_MODULE_KEYED_DECLS_P (inner))\n     {\n       /* Read and maybe install the attached entities.  */\n       bool existed;\n-      auto &set = attached_table->get_or_insert (STRIP_TEMPLATE (existing),\n-\t\t\t\t\t\t &existed);\n+      auto &set = keyed_table->get_or_insert (STRIP_TEMPLATE (existing),\n+\t\t\t\t\t      &existed);\n       unsigned num = u ();\n       if (is_new == existed)\n \tset_overrun ();\n@@ -10200,9 +10200,9 @@ trees_out::get_merge_kind (tree decl, depset *dep)\n \t\t  = LAMBDA_EXPR_EXTRA_SCOPE (CLASSTYPE_LAMBDA_EXPR\n \t\t\t\t\t     (TREE_TYPE (decl))))\n \t\tif (TREE_CODE (scope) == VAR_DECL\n-\t\t    && DECL_MODULE_ATTACHMENTS_P (scope))\n+\t\t    && DECL_MODULE_KEYED_DECLS_P (scope))\n \t\t  {\n-\t\t    mk = MK_attached;\n+\t\t    mk = MK_keyed;\n \t\t    break;\n \t\t  }\n \n@@ -10492,21 +10492,21 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t  }\n \t  break;\n \n-\tcase MK_attached:\n+\tcase MK_keyed:\n \t  {\n \t    gcc_checking_assert (LAMBDA_TYPE_P (TREE_TYPE (inner)));\n \t    tree scope = LAMBDA_EXPR_EXTRA_SCOPE (CLASSTYPE_LAMBDA_EXPR\n \t\t\t\t\t\t  (TREE_TYPE (inner)));\n \t    gcc_checking_assert (TREE_CODE (scope) == VAR_DECL);\n-\t    auto *root = attached_table->get (scope);\n+\t    auto *root = keyed_table->get (scope);\n \t    unsigned ix = root->length ();\n \t    /* If we don't find it, we'll write a really big number\n \t       that the reader will ignore.  */\n \t    while (ix--)\n \t      if ((*root)[ix] == inner)\n \t\tbreak;\n \n-\t    /* Use the attached-to decl as the 'name'.  */\n+\t    /* Use the keyed-to decl as the 'name'.  */\n \t    name = scope;\n \t    key.index = ix;\n \t  }\n@@ -10773,12 +10773,12 @@ trees_in::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t    gcc_unreachable ();\n \n \t  case NAMESPACE_DECL:\n-\t    if (mk == MK_attached)\n+\t    if (mk == MK_keyed)\n \t      {\n \t\tif (DECL_LANG_SPECIFIC (name)\n \t\t    && VAR_OR_FUNCTION_DECL_P (name)\n-\t\t    && DECL_MODULE_ATTACHMENTS_P (name))\n-\t\t  if (auto *set = attached_table->get (name))\n+\t\t    && DECL_MODULE_KEYED_DECLS_P (name))\n+\t\t  if (auto *set = keyed_table->get (name))\n \t\t    if (key.index < set->length ())\n \t\t      {\n \t\t\texisting = (*set)[key.index];\n@@ -18566,10 +18566,10 @@ set_originating_module (tree decl, bool friend_p ATTRIBUTE_UNUSED)\n   DECL_MODULE_EXPORT_P (decl) = true;\n }\n \n-/* DECL is attached to ROOT for odr purposes.  */\n+/* DECL is keyed to CTX for odr purposes.  */\n \n void\n-maybe_attach_decl (tree ctx, tree decl)\n+maybe_key_decl (tree ctx, tree decl)\n {\n   if (!modules_p ())\n     return;\n@@ -18581,14 +18581,14 @@ maybe_attach_decl (tree ctx, tree decl)\n \n   gcc_checking_assert (DECL_NAMESPACE_SCOPE_P (ctx));\n \n- if (!attached_table)\n-    attached_table = new attached_map_t (EXPERIMENT (1, 400));\n+ if (!keyed_table)\n+    keyed_table = new keyed_map_t (EXPERIMENT (1, 400));\n \n- auto &vec = attached_table->get_or_insert (ctx);\n+ auto &vec = keyed_table->get_or_insert (ctx);\n  if (!vec.length ())\n    {\n      retrofit_lang_decl (ctx);\n-     DECL_MODULE_ATTACHMENTS_P (ctx) = true;\n+     DECL_MODULE_KEYED_DECLS_P (ctx) = true;\n    }\n  vec.safe_push (decl);\n }\n@@ -18898,8 +18898,8 @@ direct_import (module_state *import, cpp_reader *reader)\n \n   if (import->loadedness < ML_LANGUAGE)\n     {\n-      if (!attached_table)\n-\tattached_table = new attached_map_t (EXPERIMENT (1, 400));\n+      if (!keyed_table)\n+\tkeyed_table = new keyed_map_t (EXPERIMENT (1, 400));\n       import->read_language (true);\n     }\n \n@@ -20004,9 +20004,9 @@ fini_modules ()\n   delete pending_table;\n   pending_table = NULL;\n \n-  /* Or any attachments -- Let it go!  */\n-  delete attached_table;\n-  attached_table = NULL;\n+  /* Or any keys -- Let it go!  */\n+  delete keyed_table;\n+  keyed_table = NULL;\n \n   /* Allow a GC, we've possibly made much data unreachable.  */\n   ggc_collect ();"}]}