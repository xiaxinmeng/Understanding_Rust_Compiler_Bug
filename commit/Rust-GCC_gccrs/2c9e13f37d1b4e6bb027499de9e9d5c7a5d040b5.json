{"sha": "2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5ZTEzZjM3ZDFiNGU2YmIwMjc0OTlkZTllOWQ1YzdhNWQwNDBiNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-08-23T22:29:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-08-23T22:29:14Z"}, "message": "predict.c (probability_reliable_p): New predicate.\n\n\t* predict.c (probability_reliable_p): New predicate.\n\t(edge_probability_reliable_p, br_prob_note_reliable_p): Likewise.\n\t(predict_loops): Do not predict loop exit with less than 2%\n\tprobability.\n\t* basic-block.h (edge_probability_reliable_p,\n\tbr_prob_note_reliable_p): Declare.\n\t* ia64.h (ia64_print_operand): Do not disable on-chip branch\n\tprediction when static predictor is not reliable.\n\t* rs6000.c (output_cbranch): Likewise.\n\nFrom-SVN: r116358", "tree": {"sha": "f848a4c4747fe1d9158aa3bfedbaa571b97b8c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f848a4c4747fe1d9158aa3bfedbaa571b97b8c80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/comments", "author": null, "committer": null, "parents": [{"sha": "a4d0390b4488cc159cb7389b778cc92a504f6796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d0390b4488cc159cb7389b778cc92a504f6796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d0390b4488cc159cb7389b778cc92a504f6796"}], "stats": {"total": 95, "additions": 84, "deletions": 11}, "files": [{"sha": "d62c53b96232c21d832a1279ef67d23178a6877a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "patch": "@@ -1,3 +1,15 @@\n+2006-08-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (probability_reliable_p): New predicate.\n+\t(edge_probability_reliable_p, br_prob_note_reliable_p): Likewise.\n+\t(predict_loops): Do not predict loop exit with less than 2%\n+\tprobability.\n+\t* basic-block.h (edge_probability_reliable_p,\n+\tbr_prob_note_reliable_p): Declare.\n+\t* ia64.h (ia64_print_operand): Do not disable on-chip branch\n+\tprediction when static predictor is not reliable.\n+\t* rs6000.c (output_cbranch): Likewise.\n+\n 2006-08-23  Stuart Hastings  <stuart@apple.com>\n \n \tPR 28825"}, {"sha": "bc9f6650c9ad61d99b125a6ae93f1ab50c6d8afc", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "patch": "@@ -880,6 +880,8 @@ extern void rtl_predict_edge (edge, enum br_predictor, int);\n extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n extern void guess_outgoing_edge_probabilities (basic_block);\n extern void remove_predictions_associated_with_edge (edge);\n+extern bool edge_probability_reliable_p (edge);\n+extern bool br_prob_note_reliable_p (rtx);\n \n /* In flow.c */\n extern void init_flow (void);"}, {"sha": "d38a19a1501bd14b57008a1b0b33e7920ed08ec5", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "patch": "@@ -4656,11 +4656,13 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \t    int pred_val = INTVAL (XEXP (x, 0));\n \n \t    /* Guess top and bottom 10% statically predicted.  */\n-\t    if (pred_val < REG_BR_PROB_BASE / 50)\n+\t    if (pred_val < REG_BR_PROB_BASE / 50\n+\t\t&& br_prob_note_reliable_p (x))\n \t      which = \".spnt\";\n \t    else if (pred_val < REG_BR_PROB_BASE / 2)\n \t      which = \".dpnt\";\n-\t    else if (pred_val < REG_BR_PROB_BASE / 100 * 98)\n+\t    else if (pred_val < REG_BR_PROB_BASE / 100 * 98\n+\t\t     || !br_prob_note_reliable_p (x))\n \t      which = \".dptk\";\n \t    else\n \t      which = \".sptk\";"}, {"sha": "9bae3f8b24d4b0c7947bfe836a2f5de00388128d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "patch": "@@ -11498,7 +11498,8 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n \t mispredicted taken branch is more expensive than a\n \t mispredicted not-taken branch.  */\n       if (rs6000_always_hint\n-\t  || abs (prob) > REG_BR_PROB_BASE / 100 * 48)\n+\t  || (abs (prob) > REG_BR_PROB_BASE / 100 * 48\n+\t      && br_prob_note_reliable_p (note)))\n \t{\n \t  if (abs (prob) > REG_BR_PROB_BASE / 20\n \t      && ((prob > 0) ^ need_longbranch))"}, {"sha": "3c2775cd69a67476f2ea5ac55026e4e055ac69d0", "filename": "gcc/predict.c", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=2c9e13f37d1b4e6bb027499de9e9d5c7a5d040b5", "patch": "@@ -178,6 +178,45 @@ tree_predicted_by_p (basic_block bb, enum br_predictor predictor)\n   return false;\n }\n \n+/* Return true when the probability of edge is reliable.\n+  \n+   The profile guessing code is good at predicting branch outcome (ie.\n+   taken/not taken), that is predicted right slightly over 75% of time.\n+   It is however notorously poor on predicting the probability itself.\n+   In general the profile appear a lot flatter (with probabilities closer\n+   to 50%) than the reality so it is bad idea to use it to drive optimization\n+   such as those disabling dynamic branch prediction for well predictable\n+   branches.\n+\n+   There are two exceptions - edges leading to noreturn edges and edges\n+   predicted by number of iterations heuristics are predicted well.  This macro\n+   should be able to distinguish those, but at the moment it simply check for\n+   noreturn heuristic that is only one giving probability over 99% or bellow\n+   1%.  In future we might want to propagate reliablity information across the\n+   CFG if we find this information useful on multiple places.   */\n+static bool\n+probability_reliable_p (int prob)\n+{\n+  return (profile_status == PROFILE_READ\n+\t  || (profile_status == PROFILE_GUESSED\n+\t      && (prob <= HITRATE (1) || prob >= HITRATE (99))));\n+}\n+\n+/* Same predicate as above, working on edges.  */\n+bool\n+edge_probability_reliable_p (edge e)\n+{\n+  return probability_reliable_p (e->probability);\n+}\n+\n+/* Same predicate as edge_probability_reliable_p, working on notes.  */\n+bool\n+br_prob_note_reliable_p (rtx note)\n+{\n+  gcc_assert (REG_NOTE_KIND (note) == REG_BR_PROB);\n+  return probability_reliable_p (INTVAL (XEXP (note, 0)));\n+}\n+\n static void\n predict_insn (rtx insn, enum br_predictor predictor, int probability)\n {\n@@ -706,14 +745,31 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t  /* Loop exit heuristics - predict an edge exiting the loop if the\n \t     conditional has no loop header successors as not taken.  */\n \t  if (!header_found)\n-\t    FOR_EACH_EDGE (e, ei, bb->succs)\n-\t      if (e->dest->index < NUM_FIXED_BLOCKS\n-\t\t  || !flow_bb_inside_loop_p (loop, e->dest))\n-\t\tpredict_edge\n-\t\t  (e, PRED_LOOP_EXIT,\n-\t\t   (REG_BR_PROB_BASE\n-\t\t    - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n-\t\t   / n_exits);\n+\t    {\n+\t      /* For loop with many exits we don't want to predict all exits\n+\t         with the pretty large probability, because if all exits are\n+\t\t considered in row, the loop would be predicted to iterate\n+\t\t almost never.  The code to divide probability by number of\n+\t\t exits is very rough.  It should compute the number of exits\n+\t\t taken in each patch through function (not the overall number\n+\t\t of exits that might be a lot higher for loops with wide switch\n+\t\t statements in them) and compute n-th square root.\n+\n+\t\t We limit the minimal probability by 2% to avoid\n+\t\t EDGE_PROBABILITY_RELIABLE from trusting the branch prediction\n+\t\t as this was causing regression in perl benchmark containing such\n+\t\t a wide loop.  */\n+\t        \n+\t      int probability = ((REG_BR_PROB_BASE\n+\t\t                  - predictor_info [(int) PRED_LOOP_EXIT].hitrate)\n+\t\t\t\t / n_exits);\n+\t      if (probability < HITRATE (2))\n+\t\tprobability = HITRATE (2);\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (e->dest->index < NUM_FIXED_BLOCKS\n+\t\t    || !flow_bb_inside_loop_p (loop, e->dest))\n+\t\t  predict_edge (e, PRED_LOOP_EXIT, probability);\n+\t    }\n \t}\n       \n       /* Free basic blocks from get_loop_body.  */"}]}