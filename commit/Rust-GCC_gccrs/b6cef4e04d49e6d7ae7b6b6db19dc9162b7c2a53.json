{"sha": "b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZjZWY0ZTA0ZDQ5ZTZkN2FlN2I2YjZkYjE5ZGM5MTYyYjdjMmE1Mw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-06-14T12:21:36Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-06-14T12:21:36Z"}, "message": "tree-vectorizer.h (vect_get_stmt_cost): Move from tree-vect-stmts.c.\n\n2012-06-14  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* tree-vectorizer.h (vect_get_stmt_cost): Move from tree-vect-stmts.c.\n\t(cost_for_stmt): Remove decl.\n\t(vect_get_single_scalar_iteration_cost): Correct typo in name.\n\t* tree-vect-loop.c (vect_get_cost): Remove.\n\t(vect_get_single_scalar_iteration_cost): Correct typo in name; use\n\tvect_get_stmt_cost rather than vect_get_cost.\n\t(vect_get_known_peeling_cost): Use vect_get_stmt_cost rather than\n\tvect_get_cost.\n\t(vect_estimate_min_profitable_iters): Correct typo in call to\n\tvect_get_single_scalar_iteration_cost; use vect_get_stmt_cost rather\n\tthan vect_get_cost.\n\t(vect_model_reduction_cost): Use vect_get_stmt_cost rather than\n\tvect_get_cost.\n\t(vect_model_induction_cost): Likewise.\n\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost): Correct\n\ttypo in call to vect_get_single_scalar_iteration_cost.\n\t* tree-vect-stmts.c (vect_get_stmt_cost): Move to tree-vectorizer.h.\n\t(cost_for_stmt): Remove unnecessary function.\n\t* Makefile.in (TREE_VECTORIZER_H): Update dependencies.\n\nFrom-SVN: r188611", "tree": {"sha": "a0aed9af70716fc07eefe673995535d93b3c99a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0aed9af70716fc07eefe673995535d93b3c99a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/comments", "author": null, "committer": null, "parents": [{"sha": "df3781485406ededf60d901bbcbbcbeeaf0529b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df3781485406ededf60d901bbcbbcbeeaf0529b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df3781485406ededf60d901bbcbbcbeeaf0529b9"}], "stats": {"total": 141, "additions": 60, "deletions": 81}, "files": [{"sha": "be5790c713a3d33b6f5ba4ad381c4e6664c2e765", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -1,3 +1,25 @@\n+2012-06-14  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* tree-vectorizer.h (vect_get_stmt_cost): Move from tree-vect-stmts.c.\n+\t(cost_for_stmt): Remove decl.\n+\t(vect_get_single_scalar_iteration_cost): Correct typo in name.\n+\t* tree-vect-loop.c (vect_get_cost): Remove.\n+\t(vect_get_single_scalar_iteration_cost): Correct typo in name; use\n+\tvect_get_stmt_cost rather than vect_get_cost.\n+\t(vect_get_known_peeling_cost): Use vect_get_stmt_cost rather than\n+\tvect_get_cost.\n+\t(vect_estimate_min_profitable_iters): Correct typo in call to\n+\tvect_get_single_scalar_iteration_cost; use vect_get_stmt_cost rather\n+\tthan vect_get_cost.\n+\t(vect_model_reduction_cost): Use vect_get_stmt_cost rather than\n+\tvect_get_cost.\n+\t(vect_model_induction_cost): Likewise.\n+\t* tree-vect-data-refs.c (vect_peeling_hash_get_lowest_cost): Correct\n+\ttypo in call to vect_get_single_scalar_iteration_cost.\n+\t* tree-vect-stmts.c (vect_get_stmt_cost): Move to tree-vectorizer.h.\n+\t(cost_for_stmt): Remove unnecessary function.\n+\t* Makefile.in (TREE_VECTORIZER_H): Update dependencies.\n+\n 2012-06-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.opt (mfp=2, mfp=3, mfpe, mfpe=2, mfpe=3): Delete options."}, {"sha": "a404a5f3e416d6e579485eac295dd2dd7a289cae", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -965,7 +965,7 @@ GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n TREE_STREAMER_H = tree-streamer.h $(TREE_H) $(LTO_STREAMER_H) \\\n \t\t  $(STREAMER_HOOKS_H)\n STREAMER_HOOKS_H = streamer-hooks.h $(TREE_H)\n-TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n+TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H) $(TARGET_H)\n IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H) alloc-pool.h\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h"}, {"sha": "ed967f236ade66588bc8435404a58fedd2fe3afc", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -1320,7 +1320,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n     }\n \n   outside_cost += vect_get_known_peeling_cost (loop_vinfo, elem->npeel, &dummy,\n-                         vect_get_single_scalar_iteraion_cost (loop_vinfo));\n+                         vect_get_single_scalar_iteration_cost (loop_vinfo));\n \n   if (inside_cost < min->inside_cost\n       || (inside_cost == min->inside_cost && outside_cost < min->outside_cost))"}, {"sha": "55046e48b5aa9b56d4948d7441f73ec5a333c00c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -1201,19 +1201,6 @@ vect_analyze_loop_form (struct loop *loop)\n }\n \n \n-/* Get cost by calling cost target builtin.  */\n-\n-static inline int\n-vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n-{\n-  tree dummy_type = NULL;\n-  int dummy = 0;\n-\n-  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n-                                                       dummy_type, dummy);\n-}\n-\n- \n /* Function vect_analyze_loop_operations.\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n@@ -2385,7 +2372,7 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple phi,\n \n /* Calculate the cost of one scalar iteration of the loop.  */\n int\n-vect_get_single_scalar_iteraion_cost (loop_vec_info loop_vinfo)\n+vect_get_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n@@ -2434,12 +2421,12 @@ vect_get_single_scalar_iteraion_cost (loop_vec_info loop_vinfo)\n           if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n             {\n               if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n-               stmt_cost = vect_get_cost (scalar_load);\n+               stmt_cost = vect_get_stmt_cost (scalar_load);\n              else\n-               stmt_cost = vect_get_cost (scalar_store);\n+               stmt_cost = vect_get_stmt_cost (scalar_store);\n             }\n           else\n-            stmt_cost = vect_get_cost (scalar_stmt);\n+            stmt_cost = vect_get_stmt_cost (scalar_stmt);\n \n           scalar_single_iter_cost += stmt_cost * factor;\n         }\n@@ -2466,7 +2453,7 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n \n       /* If peeled iterations are known but number of scalar loop\n          iterations are unknown, count a taken branch per peeled loop.  */\n-      peel_guard_costs =  2 * vect_get_cost (cond_branch_taken);\n+      peel_guard_costs =  2 * vect_get_stmt_cost (cond_branch_taken);\n     }\n   else\n     {\n@@ -2547,7 +2534,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vec_outside_cost += vect_get_cost (cond_branch_taken); \n+    vec_outside_cost += vect_get_stmt_cost (cond_branch_taken); \n \n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n      iteration for now.\n@@ -2618,7 +2605,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-  scalar_single_iter_cost = vect_get_single_scalar_iteraion_cost (loop_vinfo);\n+  scalar_single_iter_cost = vect_get_single_scalar_iteration_cost (loop_vinfo);\n \n   /* Add additional cost for the peeled instructions in prologue and epilogue\n      loop.\n@@ -2648,8 +2635,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n          branch per peeled loop. Even if scalar loop iterations are known,\n          vector iterations are not known since peeled prologue iterations are\n          not known. Hence guards remain the same.  */\n-      peel_guard_costs +=  2 * (vect_get_cost (cond_branch_taken)\n-                                + vect_get_cost (cond_branch_not_taken));\n+      peel_guard_costs +=  2 * (vect_get_stmt_cost (cond_branch_taken)\n+                                + vect_get_stmt_cost (cond_branch_not_taken));\n       vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n                            + (peel_iters_epilogue * scalar_single_iter_cost)\n                            + peel_guard_costs;\n@@ -2722,16 +2709,16 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       /* Cost model check occurs at versioning.  */\n       if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n           || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-\tscalar_outside_cost += vect_get_cost (cond_branch_not_taken);\n+\tscalar_outside_cost += vect_get_stmt_cost (cond_branch_not_taken);\n       else\n \t{\n \t  /* Cost model check occurs at prologue generation.  */\n \t  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n-\t    scalar_outside_cost += 2 * vect_get_cost (cond_branch_taken)\n-                                   + vect_get_cost (cond_branch_not_taken); \n+\t    scalar_outside_cost += 2 * vect_get_stmt_cost (cond_branch_taken)\n+\t      + vect_get_stmt_cost (cond_branch_not_taken); \n \t  /* Cost model check occurs at epilogue generation.  */\n \t  else\n-\t    scalar_outside_cost += 2 * vect_get_cost (cond_branch_taken); \n+\t    scalar_outside_cost += 2 * vect_get_stmt_cost (cond_branch_taken); \n \t}\n     }\n \n@@ -2842,7 +2829,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n   /* Cost of reduction op inside loop.  */\n   STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n-    += ncopies * vect_get_cost (vector_stmt);\n+    += ncopies * vect_get_stmt_cost (vector_stmt);\n \n   stmt = STMT_VINFO_STMT (stmt_info);\n \n@@ -2885,7 +2872,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   code = gimple_assign_rhs_code (orig_stmt);\n \n   /* Add in cost for initial definition.  */\n-  outer_cost += vect_get_cost (scalar_to_vec);\n+  outer_cost += vect_get_stmt_cost (scalar_to_vec);\n \n   /* Determine cost of epilogue code.\n \n@@ -2895,8 +2882,8 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   if (!nested_in_vect_loop_p (loop, orig_stmt))\n     {\n       if (reduc_code != ERROR_MARK)\n-\touter_cost += vect_get_cost (vector_stmt) \n-                      + vect_get_cost (vec_to_scalar); \n+\touter_cost += vect_get_stmt_cost (vector_stmt) \n+                      + vect_get_stmt_cost (vec_to_scalar); \n       else\n \t{\n \t  int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n@@ -2914,13 +2901,13 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t    /* Final reduction via vector shifts and the reduction operator. Also\n \t       requires scalar extract.  */\n \t    outer_cost += ((exact_log2(nelements) * 2) \n-              * vect_get_cost (vector_stmt) \n-  \t      + vect_get_cost (vec_to_scalar));\n+              * vect_get_stmt_cost (vector_stmt) \n+  \t      + vect_get_stmt_cost (vec_to_scalar));\n \t  else\n \t    /* Use extracts and reduction op for final reduction.  For N elements,\n                we have N extracts and N-1 reduction ops.  */\n \t    outer_cost += ((nelements + nelements - 1) \n-              * vect_get_cost (vector_stmt));\n+              * vect_get_stmt_cost (vector_stmt));\n \t}\n     }\n \n@@ -2944,10 +2931,10 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n {\n   /* loop cost for vec_loop.  */\n   STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) \n-    = ncopies * vect_get_cost (vector_stmt);\n+    = ncopies * vect_get_stmt_cost (vector_stmt);\n   /* prologue cost for vec_init and vec_step.  */\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info)  \n-    = 2 * vect_get_cost (scalar_to_vec);\n+    = 2 * vect_get_stmt_cost (scalar_to_vec);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \""}, {"sha": "9fa57e1985c042b840f847807950305c451d8022", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -727,48 +727,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n }\n \n \n-/* Get cost by calling cost target builtin.  */\n-\n-static inline\n-int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n-{\n-  tree dummy_type = NULL;\n-  int dummy = 0;\n-\n-  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n-                                                       dummy_type, dummy);\n-}\n-\n-\n-/* Get cost for STMT.  */\n-\n-int\n-cost_for_stmt (gimple stmt)\n-{\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n-  switch (STMT_VINFO_TYPE (stmt_info))\n-  {\n-  case load_vec_info_type:\n-    return vect_get_stmt_cost (scalar_load);\n-  case store_vec_info_type:\n-    return vect_get_stmt_cost (scalar_store);\n-  case op_vec_info_type:\n-  case condition_vec_info_type:\n-  case assignment_vec_info_type:\n-  case reduc_vec_info_type:\n-  case induc_vec_info_type:\n-  case type_promotion_vec_info_type:\n-  case type_demotion_vec_info_type:\n-  case type_conversion_vec_info_type:\n-  case call_vec_info_type:\n-    return vect_get_stmt_cost (scalar_stmt);\n-  case undef_vec_info_type:\n-  default:\n-    gcc_unreachable ();\n-  }\n-}\n-\n /* Function vect_model_simple_cost.\n \n    Models cost for simple operations, i.e. those that only emit ncopies of a"}, {"sha": "4c5ea36017d1e407e64c30acdcb7a6827051728a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b6cef4e04d49e6d7ae7b6b6db19dc9162b7c2a53", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_VECTORIZER_H\n \n #include \"tree-data-ref.h\"\n+#include \"target.h\"\n \n typedef source_location LOC;\n #define UNKNOWN_LOC UNKNOWN_LOCATION\n@@ -769,6 +770,18 @@ vect_pow2 (int x)\n   return res;\n }\n \n+/* Get cost by calling cost target builtin.  */\n+\n+static inline\n+int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n+{\n+  tree dummy_type = NULL;\n+  int dummy = 0;\n+\n+  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n+                                                       dummy_type, dummy);\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n@@ -843,7 +856,6 @@ extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree);\n extern void vect_finish_stmt_generation (gimple, gimple,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-extern int cost_for_stmt (gimple);\n extern tree vect_get_vec_def_for_operand (tree, gimple, tree *);\n extern tree vect_init_vector (gimple, tree, tree,\n                               gimple_stmt_iterator *);\n@@ -919,7 +931,7 @@ extern int vect_estimate_min_profitable_iters (loop_vec_info);\n extern tree get_initial_def_for_reduction (gimple, tree, tree *);\n extern int vect_min_worthwhile_factor (enum tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int);\n-extern int vect_get_single_scalar_iteraion_cost (loop_vec_info);\n+extern int vect_get_single_scalar_iteration_cost (loop_vec_info);\n \n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);"}]}