{"sha": "2dd1f944547eb6560c3e15a4b705ae1ac236df75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRkMWY5NDQ1NDdlYjY1NjBjM2UxNWE0YjcwNWFlMWFjMjM2ZGY3NQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-01-29T14:23:48Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-01-29T16:47:18Z"}, "message": "tree-optimization/98866 - Compile time hog in VRP\n\nDon't track [1, +INF] for pointer types, treat them as invariant for caching\npurposes as they cannot be further refined without evaluating to UNDEFINED.\n\n\tPR tree-optimization/98866\n\t* gimple-range-gori.h (gori_compute:set_range_invariant): New.\n\t* gimple-range-gori.cc (gori_map::set_range_invariant): New.\n\t(gori_map::m_maybe_invariant): Rename from all_outgoing.\n\t(gori_map::gori_map): Rename all_outgoing to m_maybe_invariant.\n\t(gori_map::is_export_p): Ditto.\n\t(gori_map::calculate_gori): Ditto.\n\t(gori_compute::set_range_invariant): New.\n\t* gimple-range.cc (gimple_ranger::range_of_stmt): Set range\n\tinvariant for pointers evaluating to [1, +INF].", "tree": {"sha": "852fd940fa1a98600560ca77e528c5c500d8bce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/852fd940fa1a98600560ca77e528c5c500d8bce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dd1f944547eb6560c3e15a4b705ae1ac236df75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd1f944547eb6560c3e15a4b705ae1ac236df75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dd1f944547eb6560c3e15a4b705ae1ac236df75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd1f944547eb6560c3e15a4b705ae1ac236df75/comments", "author": null, "committer": null, "parents": [{"sha": "a7f52181a6a16bb6d216ff41d9c6a9da95c19b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f52181a6a16bb6d216ff41d9c6a9da95c19b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f52181a6a16bb6d216ff41d9c6a9da95c19b5c"}], "stats": {"total": 34, "additions": 29, "deletions": 5}, "files": [{"sha": "7f7f3dc0d697948a0575e469391c61443e90421b", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=2dd1f944547eb6560c3e15a4b705ae1ac236df75", "patch": "@@ -232,13 +232,14 @@ class gori_map : public range_def_chain\n   bool is_export_p (tree name, basic_block bb = NULL);\n   bool def_chain_in_export_p (tree name, basic_block bb);\n   bitmap exports (basic_block bb);\n+  void set_range_invariant (tree name);\n \n   void dump (FILE *f);\n   void dump (FILE *f, basic_block bb);\n private:\n   bitmap_obstack m_bitmaps;\n   vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n-  bitmap all_outgoing;\t\t// All outgoing ranges combined. \n+  bitmap m_maybe_variant;\t// Names which might have outgoing ranges.\n   void maybe_add_gori (tree name, basic_block bb);\n   void calculate_gori (basic_block bb);\n };\n@@ -251,7 +252,7 @@ gori_map::gori_map ()\n   m_outgoing.create (0);\n   m_outgoing.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   bitmap_obstack_initialize (&m_bitmaps);\n-  all_outgoing = BITMAP_ALLOC (&m_bitmaps);\n+  m_maybe_variant = BITMAP_ALLOC (&m_bitmaps);\n }\n \n // Free any memory the GORI map allocated.\n@@ -280,10 +281,18 @@ gori_map::is_export_p (tree name, basic_block bb)\n {\n   // If no BB is specified, test if it is exported anywhere in the IL.\n   if (!bb)\n-    return bitmap_bit_p (all_outgoing, SSA_NAME_VERSION (name));\n+    return bitmap_bit_p (m_maybe_variant, SSA_NAME_VERSION (name));\n   return bitmap_bit_p (exports (bb), SSA_NAME_VERSION (name));\n }\n \n+// Clear the m_maybe_variant bit so ranges will not be tracked for NAME.\n+\n+void\n+gori_map::set_range_invariant (tree name)\n+{\n+  bitmap_clear_bit (m_maybe_variant, SSA_NAME_VERSION (name));\n+}\n+\n // Return true if any element in the def chain of NAME is in the\n // export list for BB.\n \n@@ -348,7 +357,7 @@ gori_map::calculate_gori (basic_block bb)\n       maybe_add_gori (name, gimple_bb (stmt));\n     }\n   // Add this bitmap to the aggregate list of all outgoing names.\n-  bitmap_ior_into (all_outgoing, m_outgoing[bb->index]);\n+  bitmap_ior_into (m_maybe_variant, m_outgoing[bb->index]);\n }\n \n // Dump the table information for BB to file F.\n@@ -447,7 +456,7 @@ gori_compute::gori_compute ()\n   m_gori_map = new gori_map;\n   unsigned x, lim = last_basic_block_for_fn (cfun);\n   // Calculate outgoing range info upfront.  This will fully populate the\n-  // all_outgoing bitmap which will help eliminate processing of names\n+  // m_maybe_variant bitmap which will help eliminate processing of names\n   // which never have their ranges adjusted.\n   for (x = 0; x < lim ; x++)\n     {\n@@ -996,6 +1005,14 @@ gori_compute::has_edge_range_p (tree name, edge e)\n \t  || m_gori_map->def_chain_in_export_p (name, e->src));\n }\n \n+// Clear the m_maybe_variant bit so ranges will not be tracked for NAME.\n+\n+void\n+gori_compute::set_range_invariant (tree name)\n+{\n+  m_gori_map->set_range_invariant (name);\n+}\n+\n // Dump what is known to GORI computes to listing file F.\n \n void"}, {"sha": "48c746d1f377bedeb008a41144ee0de445792854", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=2dd1f944547eb6560c3e15a4b705ae1ac236df75", "patch": "@@ -72,6 +72,7 @@ class gori_compute\n   ~gori_compute ();\n   bool outgoing_edge_range_p (irange &r, edge e, tree name);\n   bool has_edge_range_p (tree name, edge e = NULL);\n+  void set_range_invariant (tree name);\n   void dump (FILE *f);\n protected:\n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);"}, {"sha": "6158a754dd663148e73a8612a49c5bcc8588fa0a", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dd1f944547eb6560c3e15a4b705ae1ac236df75/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=2dd1f944547eb6560c3e15a4b705ae1ac236df75", "patch": "@@ -1072,6 +1072,12 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n   // can sometimes get different results.  See PR 97741.\n   r.intersect (tmp);\n   m_cache.set_global_range (name, r);\n+\n+  // Pointers which resolve to non-zero at the defintion point do not need\n+  // tracking in the cache as they will never change.  See PR 98866.\n+  if (POINTER_TYPE_P (TREE_TYPE (name)) && r.nonzero_p ())\n+    m_cache.set_range_invariant (name);\n+\n   return true;\n }\n "}]}