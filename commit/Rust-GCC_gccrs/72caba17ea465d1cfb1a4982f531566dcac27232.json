{"sha": "72caba17ea465d1cfb1a4982f531566dcac27232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJjYWJhMTdlYTQ2NWQxY2ZiMWE0OTgyZjUzMTU2NmRjYWMyNzIzMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-05-29T16:02:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-05-29T16:02:09Z"}, "message": "re PR fortran/16939 (Pointers not passed as subroutine arguments)\n\n2005-05-29 Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/16939\n\tPR fortran/17192\n\tPR fortran/17193\n\tPR fortran/17202\n\tPR fortran/18689\n\tPR fortran/18890\n\tPR fortran/21297\n\t* fortran/trans-array.c (gfc_conv_resolve_dependencies): Add string\n\tlength to temp_ss for character pointer array assignments.\n\t* fortran/trans-expr.c (gfc_conv_variable): Correct errors in\n\tdereferencing of characters and character pointers.\n\t* fortran/trans-expr.c (gfc_conv_function_call): Provide string\n\tlength as return argument for various kinds of handling of return.\n\tReturn a char[]* temporary for character pointer functions and\n\tdereference the temporary upon return.\n\nFrom-SVN: r100324", "tree": {"sha": "181048e11241d6f20cce0dd0367d8cf43e8fa30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/181048e11241d6f20cce0dd0367d8cf43e8fa30b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72caba17ea465d1cfb1a4982f531566dcac27232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72caba17ea465d1cfb1a4982f531566dcac27232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72caba17ea465d1cfb1a4982f531566dcac27232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72caba17ea465d1cfb1a4982f531566dcac27232/comments", "author": null, "committer": null, "parents": [{"sha": "0ac2a27ad751182f295a6baab384ca22c11e53b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac2a27ad751182f295a6baab384ca22c11e53b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac2a27ad751182f295a6baab384ca22c11e53b2"}], "stats": {"total": 147, "additions": 108, "deletions": 39}, "files": [{"sha": "047f8bcd7f1c36ce2fa360c3a812fa3c0dc3fbc0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72caba17ea465d1cfb1a4982f531566dcac27232/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72caba17ea465d1cfb1a4982f531566dcac27232/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=72caba17ea465d1cfb1a4982f531566dcac27232", "patch": "@@ -2342,7 +2342,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n       loop->temp_ss->type = GFC_SS_TEMP;\n       loop->temp_ss->data.temp.type =\n \tgfc_get_element_type (TREE_TYPE (dest->data.info.descriptor));\n-      loop->temp_ss->string_length = NULL_TREE;\n+      loop->temp_ss->string_length = dest->string_length;\n       loop->temp_ss->data.temp.dimen = loop->dimen;\n       loop->temp_ss->next = gfc_ss_terminator;\n       gfc_add_ss_to_loop (loop, loop->temp_ss);\n@@ -3617,6 +3617,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->type = GFC_SS_TEMP;\n       loop.temp_ss->next = gfc_ss_terminator;\n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n+\n       /* ... which can hold our string, if present.  */\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length = loop.temp_ss->string_length"}, {"sha": "c04efd276e6f6628375f3ff0a2dcc7ce58351d99", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 106, "deletions": 38, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72caba17ea465d1cfb1a4982f531566dcac27232/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72caba17ea465d1cfb1a4982f531566dcac27232/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=72caba17ea465d1cfb1a4982f531566dcac27232", "patch": "@@ -354,30 +354,43 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t      se->expr = gfc_build_addr_expr (NULL, se->expr);\n \t    }\n \t  return;\n-\t}\n-\n-      /* Dereference scalar dummy variables.  */\n-      if (sym->attr.dummy\n-\t  && sym->ts.type != BT_CHARACTER\n-\t  && !sym->attr.dimension)\n-\tse->expr = gfc_build_indirect_ref (se->expr);\n-\n-      /* Dereference scalar hidden result.  */\n-      if (gfc_option.flag_f2c \n-\t  && (sym->attr.function || sym->attr.result)\n-\t  && sym->ts.type == BT_COMPLEX\n-\t  && !sym->attr.dimension)\n-\tse->expr = gfc_build_indirect_ref (se->expr);\n-\n-      /* Dereference pointer variables.  */\n-      if ((sym->attr.pointer || sym->attr.allocatable)\n-\t  && (sym->attr.dummy\n-\t      || sym->attr.result\n-\t      || sym->attr.function\n-\t      || !sym->attr.dimension)\n-          && sym->ts.type != BT_CHARACTER)\n-\tse->expr = gfc_build_indirect_ref (se->expr);\n-\n+\t}\r\n+\n+\r\n+      /* Dereference the expression, where needed. Since characters\r\n+\t are entirely different from other types, they are treated \r\n+\t separately.  */\r\n+      if (sym->ts.type == BT_CHARACTER)\r\n+\t{\r\n+          /* Dereference character pointer dummy arguments\r\n+\t     or results.  */\n+\t  if ((sym->attr.pointer || sym->attr.allocatable)\r\n+\t      && ((sym->attr.dummy)\r\n+\t\t  || (sym->attr.function\r\n+\t\t  || sym->attr.result)))\r\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n+\t}\r\n+      else\r\n+\t{\r\n+          /* Dereference non-charcter scalar dummy arguments.  */\n+\t  if ((sym->attr.dummy) && (!sym->attr.dimension))\r\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n+\r\n+          /* Dereference scalar hidden result.  */\n+\t  if ((gfc_option.flag_f2c && sym->ts.type == BT_COMPLEX)\r\n+\t      && (sym->attr.function || sym->attr.result)\r\n+\t      && (!sym->attr.dimension))\r\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n+\r\n+          /* Dereference non-character pointer variables. \r\n+\t     These must be dummys or results or scalars.  */\n+\t  if ((sym->attr.pointer || sym->attr.allocatable)\r\n+\t      && ((sym->attr.dummy) \r\n+\t\t  || (sym->attr.function || sym->attr.result)\r\n+\t\t  || (!sym->attr.dimension)))\r\n+\t    se->expr = gfc_build_indirect_ref (se->expr);\r\n+\t}\r\n+\r\n       ref = expr->ref;\n     }\n \n@@ -1083,6 +1096,15 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   var = NULL_TREE;\n   len = NULL_TREE;\n \n+  /* Obtain the string length now because it is needed often below.  */\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      gcc_assert (sym->ts.cl && sym->ts.cl->length\n+\t\t  && sym->ts.cl->length->expr_type == EXPR_CONSTANT);\n+      len = gfc_conv_mpz_to_tree\n+\t      (sym->ts.cl->length->value.integer, sym->ts.cl->length->ts.kind);\n+    }\n+\n   if (se->ss != NULL)\n     {\n       if (!sym->attr.elemental)\n@@ -1097,6 +1119,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n               /* Access the previously obtained result.  */\n               gfc_conv_tmp_array_ref (se);\n               gfc_advance_se_ss_chain (se);\n+\n+\t      /* Bundle in the string length.  */\n+\t      se->string_length=len;\n               return;\n             }\n \t}\n@@ -1108,14 +1133,26 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   byref = gfc_return_by_reference (sym);\n   if (byref)\n     {\n-      if (se->direct_byref)\n-\targlist = gfc_chainon_list (arglist, se->expr);\n+      if (se->direct_byref) \n+\t{\n+\t  arglist = gfc_chainon_list (arglist, se->expr);\n+\r\n+\t  /* Add string length to argument list.  */\r\n+\t  if (sym->ts.type == BT_CHARACTER)\n+\t    {\n+\t      sym->ts.cl->backend_decl = len;\n+\t      arglist = gfc_chainon_list (arglist, \n+\t\t\t\tconvert (gfc_charlen_type_node, len));\n+\t    }\n+\t}\n       else if (sym->result->attr.dimension)\n \t{\n-\t  gcc_assert (se->loop && se->ss);\n+\t  gcc_assert (se->loop && se->ss);\r\n+\n \t  /* Set the type of the array.  */\n \t  tmp = gfc_typenode_for_spec (&sym->ts);\n-\t  info->dimen = se->loop->dimen;\n+\t  info->dimen = se->loop->dimen;\r\n+\n \t  /* Allocate a temporary to store the result.  */\n \t  gfc_trans_allocate_temp_array (se->loop, info, tmp);\n \n@@ -1124,22 +1161,46 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t    gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n \t  gfc_add_modify_expr (&se->pre, tmp,\n \t\t\t       convert (TREE_TYPE (tmp), integer_zero_node));\n+\r\n \t  /* Pass the temporary as the first argument.  */\n \t  tmp = info->descriptor;\n \t  tmp = gfc_build_addr_expr (NULL, tmp);\n \t  arglist = gfc_chainon_list (arglist, tmp);\n+\n+\t  /* Add string length to argument list.  */\n+\t  if (sym->ts.type == BT_CHARACTER)\n+\t    {\n+\t      sym->ts.cl->backend_decl = len;\n+\t      arglist = gfc_chainon_list (arglist, \n+\t\t\t      convert (gfc_charlen_type_node, len));\n+\t    }\n+\n \t}\n       else if (sym->ts.type == BT_CHARACTER)\n \t{\n-\t  gcc_assert (sym->ts.cl && sym->ts.cl->length\n-\t\t  && sym->ts.cl->length->expr_type == EXPR_CONSTANT);\n-\t  len = gfc_conv_mpz_to_tree\n-\t    (sym->ts.cl->length->value.integer, sym->ts.cl->length->ts.kind);\n+\r\n+\t  /* Pass the string length.  */\r\n \t  sym->ts.cl->backend_decl = len;\n \t  type = gfc_get_character_type (sym->ts.kind, sym->ts.cl);\n \t  type = build_pointer_type (type);\n \n-\t  var = gfc_conv_string_tmp (se, type, len);\n+\t  /* Return an address to a char[4]* temporary for character pointers.  */\n+\t  if (sym->attr.pointer || sym->attr.allocatable)\n+\t    {\n+\t      /* Build char[4] * pstr.  */\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\r\n+\t\t\t\t convert (gfc_charlen_type_node, integer_one_node));\r\n+\t      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\r\n+\t      tmp = build_array_type (gfc_character1_type_node, tmp);\r\n+\t      var = gfc_create_var (build_pointer_type (tmp), \"pstr\");\n+\n+\t      /* Provide an address expression for the function arguments.  */\r\n+\t      var = gfc_build_addr_expr (NULL, var);\r\n+\t    }\n+\t  else\n+\t    {\n+\t      var = gfc_conv_string_tmp (se, type, len);\r\n+\t    }\n \t  arglist = gfc_chainon_list (arglist, var);\n \t  arglist = gfc_chainon_list (arglist, \n \t\t\t\t      convert (gfc_charlen_type_node, len));\n@@ -1205,8 +1266,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  && arg->expr->expr_type != EXPR_NULL)\n                 {\n                   /* Scalar pointer dummy args require an extra level of\n-                     indirection. The null pointer already contains\n-\t\t     this level of indirection.  */\n+\t\t  indirection. The null pointer already contains\n+\t\t  this level of indirection.  */\n                   parmse.expr = gfc_build_addr_expr (NULL, parmse.expr);\n                 }\n             }\n@@ -1299,10 +1360,17 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  gfc_trans_runtime_check (tmp, gfc_strconst_fault, &se->pre);\n \t\t}\n \t      se->expr = info->descriptor;\n+\t      /* Bundle in the string length.  */\n+\t      se->string_length = len;\n \t    }\n \t  else if (sym->ts.type == BT_CHARACTER)\n-\t    {\n-\t      se->expr = var;\n+\t    {\r\n+\t      /* Dereference for character pointer results.  */\n+\t      if (sym->attr.pointer || sym->attr.allocatable)\n+\t\tse->expr = gfc_build_indirect_ref (var);\r\n+\t      else\r\n+\t        se->expr = var;\n+\n \t      se->string_length = len;\n \t    }\n \t  else\n@@ -2229,7 +2297,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     }\n   else\n     gfc_conv_expr (&lse, expr1);\n-\n+\r\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n   gfc_add_expr_to_block (&body, tmp);\n "}]}