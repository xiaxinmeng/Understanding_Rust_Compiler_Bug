{"sha": "c132886e7c0605edb5f66c0614c98b61840efc24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzMjg4NmU3YzA2MDVlZGI1ZjY2YzA2MTRjOThiNjE4NDBlZmMyNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-11-21T04:05:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-11-21T04:05:08Z"}, "message": "ssa.c, [...]: Remove files.\n\n        * ssa.c, ssa-dce.c, ssa-ccp.c: Remove files.\n        * Makefile.in (OBJS-common, GTFILES): Don't reference them.\n        (gtype-desc.o, toplev.o, flow.o): Remove ssa.h.\n        (ssa.o, ssa-dce.o, ssa-ccp.o): Remove.\n        * flow.c: Don't include ssa.h.\n        (set_phi_alternative_reg): Remove.\n        (calculate_global_regs_live): Don't call it.\n        (mark_used_regs): Don't handle PHI.\n        * gengtype.c (open_base_files): Don't reference ssa.h.\n        * rtl.def (PHI): Remove.\n        * timevar.def (TV_TO_SSA, TV_SSA_CCP, TV_SSA_DCE, TV_FROM_SSA): Kill.\n        * common.opt: Remove -fssa, -fssa-ccp, -fssa-dce.\n        * opts.c (common_handle_option): Likewise.\n        * toplev.c (f_options): Likewise.\n        (DFI_ssa, DFI_ssa_ccp, DFI_ssa_dce, DFI_ussa): Remove.\n        (dump_file): Update to match.\n        (flag_ssa, flag_ssa_ccp, flag_ssa_dce): Remove.\n        (rest_of_handle_ssa): Remove.\n        (rest_of_compilation): Don't call it.\n        * toplev.h (flag_ssa, flag_ssa_dce, flag_ssa_ccp): Remove.\n        * doc/invoke.texi: Remove -fssa, -fssa-ccp, -fssa-dce.\n        * doc/passes.texi (SSA optimizations): Remove.\n\n        * gcc.dg/20020201-2.c: Remove.\n        * gcc.dg/20020201-4.c: Remove.\n        * gcc.dg/20020304-1.c: Remove.\n\nFrom-SVN: r73789", "tree": {"sha": "56dd457ad8f3460dc3a6f8b53c7c66038e438501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56dd457ad8f3460dc3a6f8b53c7c66038e438501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c132886e7c0605edb5f66c0614c98b61840efc24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c132886e7c0605edb5f66c0614c98b61840efc24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c132886e7c0605edb5f66c0614c98b61840efc24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c132886e7c0605edb5f66c0614c98b61840efc24/comments", "author": null, "committer": null, "parents": [{"sha": "bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a"}], "stats": {"total": 4592, "additions": 44, "deletions": 4548}, "files": [{"sha": "b6b6b09057933e9a2ed784b23987608e988b32d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -1,3 +1,28 @@\n+2003-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* ssa.c, ssa-dce.c, ssa-ccp.c: Remove files.\n+\t* Makefile.in (OBJS-common, GTFILES): Don't reference them.\n+\t(gtype-desc.o, toplev.o, flow.o): Remove ssa.h.\n+\t(ssa.o, ssa-dce.o, ssa-ccp.o): Remove.\n+\t* flow.c: Don't include ssa.h.\n+\t(set_phi_alternative_reg): Remove.\n+\t(calculate_global_regs_live): Don't call it.\n+\t(mark_used_regs): Don't handle PHI.\n+\t* gengtype.c (open_base_files): Don't reference ssa.h.\n+\t* rtl.def (PHI): Remove.\n+\t* timevar.def (TV_TO_SSA, TV_SSA_CCP, TV_SSA_DCE, TV_FROM_SSA): Kill.\n+\t* common.opt: Remove -fssa, -fssa-ccp, -fssa-dce.\n+\t* opts.c (common_handle_option): Likewise.\n+\t* toplev.c (f_options): Likewise.\n+\t(DFI_ssa, DFI_ssa_ccp, DFI_ssa_dce, DFI_ussa): Remove.\n+\t(dump_file): Update to match.\n+\t(flag_ssa, flag_ssa_ccp, flag_ssa_dce): Remove.\n+\t(rest_of_handle_ssa): Remove.\n+\t(rest_of_compilation): Don't call it.\n+\t* toplev.h (flag_ssa, flag_ssa_dce, flag_ssa_ccp): Remove.\n+\t* doc/invoke.texi: Remove -fssa, -fssa-ccp, -fssa-dce.\n+\t* doc/passes.texi (SSA optimizations): Remove.\n+\n 2003-11-20  Bob Wilson  <bob.wilson@acm.org>\n \n \t* configure.in: Add xtensa-*-* targets to test for dwarf2 debug_line."}, {"sha": "a2406f49a9e1ddcf1f7bcbf37ff617e00e85cd37", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -865,15 +865,15 @@ OBJS-common = \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o optabs.o options.o opts.o params.o postreload.o predict.o\t   \\\n- print-rtl.o print-tree.o value-prof.o \t\t\t\t\t\t\t\t   \\\n+ print-rtl.o print-tree.o value-prof.o\t\t\t\t\t   \\\n  profile.o ra.o ra-build.o ra-colorize.o ra-debug.o ra-rewrite.o\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n- sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n- stor-layout.o stringpool.o targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n- unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o\t\t   \\\n- alloc-pool.o et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o\n+ sibcall.o simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o \t   \\\n+ targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n+ varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n+ et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n@@ -1467,7 +1467,7 @@ version.o: version.c version.h\n gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h \\\n \t$(HASHTAB_H) $(TREE_H) $(RTL_H) function.h insn-config.h $(EXPR_H) $(OPTABS_H) \\\n \tlibfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-\tssa.h cselib.h insn-addr.h\n+\tcselib.h insn-addr.h\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n@@ -1533,7 +1533,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n    debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n    graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n-   ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n+   $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h cfglayout.h real.h cfgloop.h \\\n    hosthooks.h $(LANGHOOKS_DEF_H) cgraph.h $(COVERAGE_H)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n@@ -1669,14 +1669,6 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) coretype\n lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(TM_P_H) df.h function.h\n-ssa.o : ssa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) varray.h \\\n-   $(EXPR_H) hard-reg-set.h flags.h function.h real.h insn-config.h $(RECOG_H) \\\n-   $(BASIC_BLOCK_H) output.h ssa.h\n-ssa-dce.o : ssa-dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) hard-reg-set.h \\\n-   $(BASIC_BLOCK_H) ssa.h insn-config.h $(RECOG_H) output.h\n-ssa-ccp.o : ssa-ccp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) hard-reg-set.h \\\n-    $(BASIC_BLOCK_H) ssa.h insn-config.h $(RECOG_H) output.h \\\n-    errors.h $(GGC_H) df.h function.h\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) df.h $(FIBHEAP_H)\n@@ -1702,7 +1694,7 @@ unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-co\n alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) ssa.h $(GGC_H) $(TM_P_H)\n+   $(RECOG_H) function.h except.h $(EXPR_H) $(GGC_H) $(TM_P_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h\n@@ -2068,7 +2060,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n   $(srcdir)/bitmap.h $(srcdir)/coverage.c $(srcdir)/function.h  $(srcdir)/rtl.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h \\\n-  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/ssa.h $(srcdir)/insn-addr.h \\\n+  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\"}, {"sha": "fdb7a849ed4db947a21b81dde5025700fa83ad71", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -628,18 +628,6 @@ fsingle-precision-constant\n Common\n Convert floating point constants to single precision constants\n \n-fssa\n-Common\n-Enable static single assignment optimizations\n-\n-fssa-ccp\n-Common\n-Enable SSA conditional constant propagation\n-\n-fssa-dce\n-Common\n-Enable aggressive SSA dead code elimination\n-\n fstack-check\n Common\n Insert stack checking code into the program"}, {"sha": "b1b2e8c2cecb2f1a92e0f125ca9de84b2688ac84", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -291,7 +291,7 @@ in the following sections.\n -fsched-stalled-insns=@var{n} -sched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n -fsched2-use-traces  -fsignaling-nans @gol\n--fsingle-precision-constant  -fssa  -fssa-ccp  -fssa-dce @gol\n+-fsingle-precision-constant  @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n@@ -4674,23 +4674,6 @@ You will not be able to use @code{gprof} on all systems if you\n specify this option and you may have problems with debugging if\n you specify both this option and @option{-g}.\n \n-@item -fssa\n-@opindex fssa\n-Perform optimizations in static single assignment form.  Each function's\n-flow graph is translated into SSA form, optimizations are performed, and\n-the flow graph is translated back from SSA form.  Users should not\n-specify this option, since it is not yet ready for production use.\n-\n-@item -fssa-ccp\n-@opindex fssa-ccp\n-Perform Sparse Conditional Constant Propagation in SSA form.  Requires\n-@option{-fssa}.  Like @option{-fssa}, this is an experimental feature.\n-\n-@item -fssa-dce\n-@opindex fssa-dce\n-Perform aggressive dead-code elimination in SSA form.  Requires @option{-fssa}.\n-Like @option{-fssa}, this is an experimental feature.\n-\n @item -fbranch-target-load-optimize\n @opindex fbranch-target-load-optimize\n Perform branch target register load optimization before prologue / epilogue\n@@ -4704,9 +4687,6 @@ a separate optimization pass.\n Perform branch target register load optimization after prologue / epilogue\n threading.\n \n-\n-\n-\n @item --param @var{name}=@var{value}\n @opindex param\n In some places, GCC uses various constants to control the amount of"}, {"sha": "6bbc61c2822da73bedd9e3e7106cdf43951538ef", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -237,57 +237,6 @@ the second conditional test.  The source code for this pass is in\n @file{jump.c}.  This optimization is only performed if\n @option{-fthread-jumps} is enabled.\n \n-@cindex SSA optimizations\n-@cindex Single Static Assignment optimizations\n-@opindex fssa\n-@item\n-Static Single Assignment (SSA) based optimization passes.  The\n-SSA conversion passes (to/from) are turned on by the @option{-fssa}\n-option (it is also done automatically if you enable an SSA optimization pass).\n-These passes utilize a form called Static Single Assignment.  In SSA form,\n-each variable (pseudo register) is only set once, giving you def-use\n-and use-def chains for free, and enabling a lot more optimization\n-passes to be run in linear time.\n-Conversion to and from SSA form is handled by functions in\n-@file{ssa.c}.\n-\n-@opindex de\n-The option @option{-de} causes a debugging dump of the RTL code after\n-this pass.  This dump file's name is made by appending @samp{.ssa} to\n-the input file name.\n-@itemize @bullet\n-@cindex SSA Conditional Constant Propagation\n-@cindex Conditional Constant Propagation, SSA based\n-@cindex conditional constant propagation\n-@opindex fssa-ccp\n-@item\n-SSA Conditional Constant Propagation.  Turned on by the @option{-fssa-ccp}\n-option.  This pass performs conditional constant propagation to simplify\n-instructions including conditional branches.  This pass is more aggressive\n-than the constant propagation done by the CSE and GCSE passes, but operates\n-in linear time.\n-\n-@opindex dW\n-The option @option{-dW} causes a debugging dump of the RTL code after\n-this pass.  This dump file's name is made by appending @samp{.ssaccp} to\n-the input file name.\n-\n-@cindex SSA DCE\n-@cindex DCE, SSA based\n-@cindex dead code elimination\n-@opindex fssa-dce\n-@item\n-SSA Aggressive Dead Code Elimination.  Turned on by the @option{-fssa-dce}\n-option.  This pass performs elimination of code considered unnecessary because\n-it has no externally visible effects on the program.  It operates in\n-linear time.\n-\n-@opindex dX\n-The option @option{-dX} causes a debugging dump of the RTL code after\n-this pass.  This dump file's name is made by appending @samp{.ssadce} to\n-the input file name.\n-@end itemize\n-\n @cindex common subexpression elimination\n @cindex constant propagation\n @item"}, {"sha": "7ad7a803ef94203b7e7ff0fc113796506bb97d72", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -136,7 +136,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"expr.h\"\n-#include \"ssa.h\"\n #include \"timevar.h\"\n \n #include \"obstack.h\"\n@@ -293,7 +292,6 @@ static void notice_stack_pointer_modification_1 (rtx, rtx, void *);\n static void notice_stack_pointer_modification (rtx);\n static void mark_reg (rtx, void *);\n static void mark_regs_live_at_end (regset);\n-static int set_phi_alternative_reg (rtx, int, int, void *);\n static void calculate_global_regs_live (sbitmap, sbitmap, int);\n static void propagate_block_delete_insn (rtx);\n static rtx propagate_block_delete_libcall (rtx, rtx);\n@@ -1033,20 +1031,6 @@ mark_regs_live_at_end (regset set)\n   diddle_return_value (mark_reg, set);\n }\n \n-/* Callback function for for_each_successor_phi.  DATA is a regset.\n-   Sets the SRC_REGNO, the regno of the phi alternative for phi node\n-   INSN, in the regset.  */\n-\n-static int\n-set_phi_alternative_reg (rtx insn ATTRIBUTE_UNUSED,\n-\t\t\t int dest_regno ATTRIBUTE_UNUSED, int src_regno,\n-\t\t\t void *data)\n-{\n-  regset live = (regset) data;\n-  SET_REGNO_REG_SET (live, src_regno);\n-  return 0;\n-}\n-\n /* Propagate global life info around the graph of basic blocks.  Begin\n    considering blocks with their corresponding bit set in BLOCKS_IN.\n    If BLOCKS_IN is null, consider it the universal set.\n@@ -1208,14 +1192,6 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t    SET_REGNO_REG_SET (new_live_at_end, PIC_OFFSET_TABLE_REGNUM);\n \t}\n \n-      /* Regs used in phi nodes are not included in\n-\t global_live_at_start, since they are live only along a\n-\t particular edge.  Set those regs that are live because of a\n-\t phi node alternative corresponding to this particular block.  */\n-      if (in_ssa_form)\n-\tfor_each_successor_phi (bb, &set_phi_alternative_reg,\n-\t\t\t\tnew_live_at_end);\n-\n       if (bb == ENTRY_BLOCK_PTR)\n \t{\n \t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n@@ -3908,14 +3884,6 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n       x = COND_EXEC_CODE (x);\n       goto retry;\n \n-    case PHI:\n-      /* We _do_not_ want to scan operands of phi nodes.  Operands of\n-\t a phi function are evaluated only when control reaches this\n-\t block along a particular edge.  Therefore, regs that appear\n-\t as arguments to phi should not be added to the global live at\n-\t start.  */\n-      return;\n-\n     default:\n       break;\n     }"}, {"sha": "e5579a46837b5fa704dc815940ba5f6731590e7d", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -1087,7 +1087,7 @@ open_base_files (void)\n       \"config.h\", \"system.h\", \"coretypes.h\", \"tm.h\", \"varray.h\",\n       \"hashtab.h\", \"splay-tree.h\", \"bitmap.h\", \"tree.h\", \"rtl.h\",\n       \"function.h\", \"insn-config.h\", \"expr.h\", \"hard-reg-set.h\",\n-      \"basic-block.h\", \"cselib.h\", \"insn-addr.h\", \"ssa.h\", \"optabs.h\",\n+      \"basic-block.h\", \"cselib.h\", \"insn-addr.h\", \"optabs.h\",\n       \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       NULL\n     };"}, {"sha": "cbfbd64607f514ab04aa03821fc97f70e777834d", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -1299,18 +1299,6 @@ common_handle_option (size_t scode, const char *arg,\n       flag_single_precision_constant = value;\n       break;\n \n-    case OPT_fssa:\n-      flag_ssa = value;\n-      break;\n-\n-    case OPT_fssa_ccp:\n-      flag_ssa_ccp = value;\n-      break;\n-\n-    case OPT_fssa_dce:\n-      flag_ssa_dce = value;\n-      break;\n-\n     case OPT_fstack_check:\n       flag_stack_check = value;\n       break;"}, {"sha": "6371cf0fcbe2632333f24744ea705234f1dc3558", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -1208,20 +1208,6 @@ DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n /* Unsigned saturating truncate.  */\n DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n \n-/* The SSA phi operator. \n-\n-   The argument is a vector of 2N rtxes.  Element 2N+1 is a CONST_INT\n-   containing the block number of the predecessor through which control\n-   has passed when the register at element 2N is used.\n-\n-   Note that PHI may only appear at the beginning of a basic block.\n-\n-   ??? There may be multiple PHI insns, but they are all evaluated\n-   in parallel.  This probably ought to be changed to use a real\n-   PARALLEL, as that would be less confusing and more in the spirit\n-   of canonical RTL.  It is, however, easier to manipulate this way.  */\n-DEF_RTL_EXPR(PHI, \"phi\", \"E\", 'x')\n-\n \n /*\n Local variables:"}, {"sha": "7ff305a9d3d24ed6926b4027c5944f601e77bc9c", "filename": "gcc/ssa-ccp.c", "status": "removed", "additions": 0, "deletions": 1206, "changes": 1206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,1206 +0,0 @@\n-/* Conditional constant propagation pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-   Original framework by Daniel Berlin <dan@cgsoftware.com>\n-   Fleshed out and major cleanups by Jeff Law <law@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-/* Conditional constant propagation.\n-\n-   References:\n-\n-     Constant propagation with conditional branches,\n-     Wegman and Zadeck, ACM TOPLAS 13(2):181-210.\n-\n-     Building an Optimizing Compiler,\n-     Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.\n-\n-     Advanced Compiler Design and Implementation,\n-     Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6\n-\n-   The overall structure is as follows:\n-\n-\t1. Run a simple SSA based DCE pass to remove any dead code.\n-\t2. Run CCP to compute what registers are known constants\n-\t   and what edges are not executable.  Remove unexecutable\n-\t   edges from the CFG and simplify PHI nodes.\n-\t3. Replace registers with constants where possible.\n-\t4. Remove unreachable blocks computed in step #2.\n-\t5. Another simple SSA DCE pass to remove dead code exposed\n-\t   by CCP.\n-\n-   When we exit, we are still in SSA form.\n-\n-\n-   Potential further enhancements:\n-\n-    1. Handle SUBREGs, STRICT_LOW_PART, etc in destinations more\n-       gracefully.\n-\n-    2. Handle insns with multiple outputs more gracefully.\n-\n-    3. Handle CONST_DOUBLE and symbolic constants.\n-\n-    4. Fold expressions after performing constant substitutions.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"ssa.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"output.h\"\n-#include \"errors.h\"\n-#include \"ggc.h\"\n-#include \"df.h\"\n-#include \"function.h\"\n-\f\n-/* Possible lattice values.  */\n-\n-typedef enum\n-{\n-  UNDEFINED,\n-  CONSTANT,\n-  VARYING\n-} latticevalue;\n-\n-/* Main structure for CCP.\n-\n-   Contains the lattice value and, if it's a constant, the constant\n-   value.  */\n-typedef struct\n-{\n-  latticevalue lattice_val;\n-  rtx const_value;\n-} value;\n-\n-/* Array of values indexed by register number.  */\n-static value *values;\n-\n-/* A bitmap to keep track of executable blocks in the CFG.  */\n-static sbitmap executable_blocks;\n-\n-/* A bitmap for all executable edges in the CFG.  */\n-static sbitmap executable_edges;\n-\n-/* Array of edges on the work list.  */\n-static edge *edge_info;\n-\n-/* We need an edge list to be able to get indexes easily.  */\n-static struct edge_list *edges;\n-\n-/* For building/following use-def and def-use chains.  */\n-static struct df *df_analyzer;\n-\n-/* Current edge we are operating on, from the worklist */\n-static edge flow_edges;\n-\n-/* Bitmap of SSA edges which will need reexamination as their definition\n-   has changed.  */\n-static sbitmap ssa_edges;\n-\n-/* Simple macros to simplify code */\n-#define SSA_NAME(x) REGNO (SET_DEST (x))\n-#define EIE(x,y) EDGE_INDEX (edges, x, y)\n-\n-static void visit_phi_node (rtx, basic_block);\n-static void visit_expression (rtx, basic_block);\n-static void defs_to_undefined (rtx);\n-static void defs_to_varying (rtx);\n-static void examine_flow_edges (void);\n-static int mark_references (rtx *, void *);\n-static void follow_def_use_chains (void);\n-static void optimize_unexecutable_edges (struct edge_list *, sbitmap);\n-static void ssa_ccp_substitute_constants (void);\n-static void ssa_ccp_df_delete_unreachable_insns (void);\n-static void ssa_fast_dce (struct df *);\n-\n-/* Loop through the PHI_NODE's parameters for BLOCK and compare their\n-   lattice values to determine PHI_NODE's lattice value.  */\n-static void\n-visit_phi_node (rtx phi_node, basic_block block)\n-{\n-  unsigned int i;\n-  rtx phi_node_expr = NULL;\n-  unsigned int phi_node_name = SSA_NAME (PATTERN (phi_node));\n-  latticevalue phi_node_lattice_val = UNDEFINED;\n-  rtx pat = PATTERN (phi_node);\n-  rtvec phi_vec = XVEC (SET_SRC (pat), 0);\n-  unsigned int num_elem = GET_NUM_ELEM (phi_vec);\n-\n-  for (i = 0; i < num_elem; i += 2)\n-    {\n-      if (TEST_BIT (executable_edges,\n-\t\t    EIE (BASIC_BLOCK (INTVAL (RTVEC_ELT (phi_vec, i + 1))),\n-\t\t\t block)))\n-\t{\n-\t  unsigned int current_parm\n-\t    = REGNO (RTVEC_ELT (phi_vec, i));\n-\n-\t  latticevalue current_parm_lattice_val\n-\t    = values[current_parm].lattice_val;\n-\n-\t  /* If any node is VARYING, then new value of PHI_NODE\n-\t     is VARYING.  */\n-\t  if (current_parm_lattice_val == VARYING)\n-\t    {\n-\t      phi_node_lattice_val = VARYING;\n-\t      phi_node_expr = NULL;\n-\t      break;\n-\t    }\n-\n-\t  /* If we have more than one distinct constant, then the new\n-\t     value of PHI_NODE is VARYING.  */\n-\t  if (current_parm_lattice_val == CONSTANT\n-\t      && phi_node_lattice_val == CONSTANT\n-\t      && values[current_parm].const_value != phi_node_expr)\n-\t    {\n-\t      phi_node_lattice_val = VARYING;\n-\t      phi_node_expr = NULL;\n-\t      break;\n-\t    }\n-\n-\t  /* If the current value of PHI_NODE is UNDEFINED and one\n-\t     node in PHI_NODE is CONSTANT, then the new value of the\n-\t     PHI is that CONSTANT.  Note this can turn into VARYING\n-\t     if we find another distinct constant later.  */\n-\t  if (phi_node_lattice_val == UNDEFINED\n-\t      && phi_node_expr == NULL\n-\t      && current_parm_lattice_val == CONSTANT)\n-\t    {\n-\t      phi_node_expr = values[current_parm].const_value;\n-\t      phi_node_lattice_val = CONSTANT;\n-\t      continue;\n-\t    }\n-\t}\n-    }\n-\n-  /* If the value of PHI_NODE changed, then we will need to\n-     re-execute uses of the output of PHI_NODE.  */\n-  if (phi_node_lattice_val != values[phi_node_name].lattice_val)\n-    {\n-      values[phi_node_name].lattice_val = phi_node_lattice_val;\n-      values[phi_node_name].const_value = phi_node_expr;\n-      SET_BIT (ssa_edges, phi_node_name);\n-    }\n-}\n-\n-/* Sets all defs in an insn to UNDEFINED.  */\n-static void\n-defs_to_undefined (rtx insn)\n-{\n-  struct df_link *currdef;\n-  for (currdef = DF_INSN_DEFS (df_analyzer, insn); currdef;\n-       currdef = currdef->next)\n-    {\n-      if (values[DF_REF_REGNO (currdef->ref)].lattice_val != UNDEFINED)\n-\tSET_BIT (ssa_edges, DF_REF_REGNO (currdef->ref));\n-      values[DF_REF_REGNO (currdef->ref)].lattice_val = UNDEFINED;\n-    }\n-}\n-\n-/* Sets all defs in an insn to VARYING.  */\n-static void\n-defs_to_varying (rtx insn)\n-{\n-  struct df_link *currdef;\n-  for (currdef = DF_INSN_DEFS (df_analyzer, insn); currdef;\n-       currdef = currdef->next)\n-    {\n-      if (values[DF_REF_REGNO (currdef->ref)].lattice_val != VARYING)\n-\tSET_BIT (ssa_edges, DF_REF_REGNO (currdef->ref));\n-      values[DF_REF_REGNO (currdef->ref)].lattice_val = VARYING;\n-    }\n-}\n-\n-/* Go through the expression, call the appropriate evaluation routines\n-   to attempt cprop */\n-static void\n-visit_expression (rtx insn, basic_block block)\n-{\n-  rtx src, dest, set;\n-\n-\n-  /* Ugh.  CALL_INSNs may end a basic block and have multiple edges\n-     leading out from them.\n-\n-     Mark all the outgoing edges as executable, then fall into the\n-     normal processing below.  */\n-  if (GET_CODE (insn) == CALL_INSN && block->end == insn)\n-    {\n-      edge curredge;\n-\n-      for (curredge = block->succ; curredge;\n-\t   curredge = curredge->succ_next)\n-\t{\n-\t  int index = EIE (curredge->src, curredge->dest);\n-\n-\t  if (TEST_BIT (executable_edges, index))\n-\t    continue;\n-\n-\t  SET_BIT (executable_edges, index);\n-\t  edge_info[index] = flow_edges;\n-\t  flow_edges = curredge;\n-\t}\n-    }\n-\n-  set = single_set (insn);\n-  if (! set)\n-    {\n-      defs_to_varying (insn);\n-      return;\n-    }\n-\n-  src = SET_SRC (set);\n-  dest = SET_DEST (set);\n-\n-  /* We may want to refine this some day.  */\n-  if (GET_CODE (dest) != REG && dest != pc_rtx)\n-    {\n-      defs_to_varying (insn);\n-      return;\n-    }\n-\n-  /* Hard registers are not put in SSA form and thus we must consider\n-     them varying.  All the more reason to avoid hard registers in\n-     RTL until as late as possible in the compilation.  */\n-  if (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER)\n-    {\n-      defs_to_varying (insn);\n-      return;\n-    }\n-\n-  /* If this is assigning DEST to a constant, record that fact.  */\n-  if (GET_CODE (src) == CONST_INT && GET_CODE (insn) == INSN)\n-    {\n-      unsigned int resultreg = REGNO (dest);\n-\n-      values[resultreg].lattice_val = CONSTANT;\n-      values[resultreg].const_value = SET_SRC (PATTERN (insn));\n-      SET_BIT (ssa_edges, resultreg);\n-    }\n-\n-  /* If this is a copy operation, then we can copy the lattice values.  */\n-  else if (GET_CODE (src) == REG && GET_CODE (dest) == REG)\n-    {\n-      unsigned int old_value = REGNO (src);\n-      latticevalue old_lattice_value = values[old_value].lattice_val;\n-      unsigned int new_value = REGNO (dest);\n-\n-      /* Unless the lattice value is going to change, don't bother\n-         adding the \"new value\" into the worklist.  */\n-      if (values[new_value].lattice_val != old_lattice_value\n-\t  || values[new_value].const_value != values[old_value].const_value)\n-\tSET_BIT (ssa_edges, new_value);\n-\n-      /* Copy the old lattice node info into the new value lattice node.  */\n-      values[new_value].lattice_val = old_lattice_value;\n-      values[new_value].const_value = values[old_value].const_value;\n-    }\n-\n-  /* Handle jumps.  */\n-  else if (GET_CODE (insn) == JUMP_INSN)\n-    {\n-      rtx x = pc_set (insn);\n-      if (GET_CODE (src) != IF_THEN_ELSE)\n-\t{\n-\t  edge curredge;\n-\n-\t  /* This is a computed jump, table jump, or an unconditional\n-\t     jump.  For all these cases we want to mark all successor\n-\t     blocks as executable if they have not already been\n-\t     marked.\n-\n-\t     One day we may try do better with switch tables and\n-\t     other computed jumps.  */\n-\t  for (curredge = block->succ; curredge;\n-\t       curredge = curredge->succ_next)\n-\t    {\n-\t      int index = EIE (curredge->src, curredge->dest);\n-\n-\t      if (TEST_BIT (executable_edges, index))\n-\t\tcontinue;\n-\n-\t      SET_BIT (executable_edges, index);\n-\t      edge_info[index] = flow_edges;\n-\t      flow_edges = curredge;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  edge curredge;\n-\t  enum rtx_code comparison_code;\n-\t  rtx comparison_src0;\n-\t  rtx comparison_src1;\n-\n-\t  comparison_code = GET_CODE (XEXP (src, 0));\n-\t  comparison_src0 = XEXP (XEXP (src, 0), 0);\n-\t  comparison_src1 = XEXP (XEXP (src, 0), 1);\n-\n-\t  /* If either operand is undefined, then there is nothing to\n-\t     do right now.  If/when operands are later defined we will\n-\t     revaluate the condition and take the appropriate action.  */\n-\t  if ((GET_CODE (comparison_src0) == REG\n-\t       && values[REGNO (comparison_src0)].lattice_val == UNDEFINED)\n-\t      || (GET_CODE (comparison_src1) == REG\n-\t          && values[REGNO (comparison_src1)].lattice_val == UNDEFINED))\n-\t    return;\n-\n-\t  /* If either operand is varying, then we must consider all\n-\t     paths as executable.  */\n-\t  if ((GET_CODE (comparison_src0) == REG\n-\t       && values[REGNO (comparison_src0)].lattice_val == VARYING)\n-\t      || (GET_CODE (comparison_src1) == REG\n-\t          && values[REGNO (comparison_src1)].lattice_val == VARYING))\n-\t    {\n-\t      for (curredge = block->succ; curredge;\n-\t           curredge = curredge->succ_next)\n-\t        {\n-\t          int index = EIE (curredge->src, curredge->dest);\n-\n-\t          if (TEST_BIT (executable_edges, index))\n-\t\t    continue;\n-\n-\t          SET_BIT (executable_edges, index);\n-\t          edge_info[index] = flow_edges;\n-\t          flow_edges = curredge;\n-\t        }\n-\t      return;\n-\t    }\n-\n-\t  /* Try to simplify the comparison.  */\n-\t  if (GET_CODE (comparison_src0) == REG\n-\t      && values[REGNO (comparison_src0)].lattice_val == CONSTANT)\n-\t    comparison_src0 = values[REGNO (comparison_src0)].const_value;\n-\n-\t  if (GET_CODE (comparison_src1) == REG\n-\t      && values[REGNO (comparison_src1)].lattice_val == CONSTANT)\n-\t    comparison_src1 = values[REGNO (comparison_src1)].const_value;\n-\n-\t  x = simplify_ternary_operation (IF_THEN_ELSE,\n-\t\t\t\t\t  VOIDmode,\n-\t\t\t\t\t  GET_MODE (XEXP (src, 0)),\n-\t\t\t\t\t  gen_rtx (comparison_code,\n-\t\t\t\t\t\t   GET_MODE (XEXP (src, 0)),\n-\t\t\t\t\t\t   comparison_src0,\n-\t\t\t\t\t\t   comparison_src1),\n-\t\t\t\t\t  XEXP (src, 1),\n-\t\t\t\t\t  XEXP (src, 2));\n-\n-\t  /* Walk through all the outgoing edges from this block and see\n-\t     which (if any) we should mark as executable.  */\n-\t  for (curredge = block->succ; curredge;\n-\t       curredge = curredge->succ_next)\n-\t    {\n-\t      int index = EIE (curredge->src, curredge->dest);\n-\n-\t      if (TEST_BIT (executable_edges, index))\n-\t\tcontinue;\n-\n-\t      /* If we were unable to simplify the expression at this\n-\t\t point, it's highly unlikely we'll be able to simplify\n-\t\t it later.  So consider all edges as executable if the\n-\t\t expression did not simplify.\n-\n-\t\t If the expression simplified to (pc), then we know we\n-\t\t will take the fall-thru edge, so mark it.  Similarly,\n-\t\t if the expression simplified to (label_ref ...), then\n-\t\t we know the branch will be taken and we mark that\n-\t\t edge as taken.  */\n-\t      if (!x\n-\t\t  || (x == pc_rtx\n-\t\t      && (curredge->flags & EDGE_FALLTHRU))\n-\t\t  || (GET_CODE (x) == LABEL_REF\n-\t\t      && ! (curredge->flags & EDGE_FALLTHRU)))\n-\t\t{\n-\t\t  SET_BIT (executable_edges, index);\n-\t\t  edge_info[index] = flow_edges;\n-\t\t  flow_edges = curredge;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  else if (!PHI_NODE_P (insn))\n-    {\n-      rtx simplified = NULL;\n-\n-      /* We've got some kind of INSN.  If it's simple, try to evaluate\n-\t it and record the results.\n-\n-\t We already know this insn is a single_set and that it sets\n-\t a pseudo register.   So we just need to extract the source\n-\t arguments, simplify them to constants if possible, then\n-\t simplify the expression as a whole if possible.  */\n-      switch (GET_RTX_CLASS (GET_CODE (src)))\n-\t{\n-\t  case '<':\n-\t    {\n-\t      rtx src0 = XEXP (src, 0);\n-\t      rtx src1 = XEXP (src, 1);\n-\t      enum machine_mode mode;\n-\n-\t      /* If either is undefined, then the result is undefined.  */\n-\t      if ((GET_CODE (src0) == REG\n-\t\t   && values[REGNO (src0)].lattice_val == UNDEFINED)\n-\t\t  || (GET_CODE (src1) == REG\n-\t\t      && values[REGNO (src1)].lattice_val == UNDEFINED))\n-\t\t{\n-\t\t  defs_to_undefined (insn);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Determine the mode for the operation before we simplify\n-\t\t our arguments to constants.  */\n-\t      mode = GET_MODE (src0);\n-\t      if (mode == VOIDmode)\n-\t\tmode = GET_MODE (src1);\n-\n-\t      /* Simplify source operands to whatever known values they\n-\t\t may have.  */\n-\t      if (GET_CODE (src0) == REG\n-\t\t  && values[REGNO (src0)].lattice_val == CONSTANT)\n-\t\tsrc0 = values[REGNO (src0)].const_value;\n-\n-\t      if (GET_CODE (src1) == REG\n-\t\t  && values[REGNO (src1)].lattice_val == CONSTANT)\n-\t\tsrc1 = values[REGNO (src1)].const_value;\n-\n-\t      /* See if the simplifier can determine if this operation\n-\t\t computes a constant value.  */\n-\t      simplified = simplify_relational_operation (GET_CODE (src),\n-\t\t\t\t\t\t\t  mode, src0, src1);\n-\t      break;\n-\n-\t    }\n-\n-\t  case '1':\n-\t    {\n-\t      rtx src0 = XEXP (src, 0);\n-\t      enum machine_mode mode0 = GET_MODE (src0);\n-\n-\t      /* If the operand is undefined, then the result is undefined.  */\n-\t      if (GET_CODE (src0) == REG\n-\t\t   && values[REGNO (src0)].lattice_val == UNDEFINED)\n-\t\t{\n-\t\t  defs_to_undefined (insn);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Simplify source operands to whatever known values they\n-\t\t may have.  */\n-\t      if (GET_CODE (src0) == REG\n-\t\t  && values[REGNO (src0)].lattice_val == CONSTANT)\n-\t\tsrc0 = values[REGNO (src0)].const_value;\n-\n-\t      /* See if the simplifier can determine if this operation\n-\t\t computes a constant value.  */\n-\t      simplified = simplify_unary_operation (GET_CODE (src),\n-\t\t\t\t\t\t     GET_MODE (src),\n-\t\t\t\t\t\t     src0,\n-\t\t\t\t\t\t     mode0);\n-\t      break;\n-\t    }\n-\n-\t  case '2':\n-\t  case 'c':\n-\t    {\n-\t      rtx src0 = XEXP (src, 0);\n-\t      rtx src1 = XEXP (src, 1);\n-\n-\t      /* If either is undefined, then the result is undefined.  */\n-\t      if ((GET_CODE (src0) == REG\n-\t\t   && values[REGNO (src0)].lattice_val == UNDEFINED)\n-\t\t  || (GET_CODE (src1) == REG\n-\t\t      && values[REGNO (src1)].lattice_val == UNDEFINED))\n-\t\t{\n-\t\t  defs_to_undefined (insn);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Simplify source operands to whatever known values they\n-\t\t may have.  */\n-\t      if (GET_CODE (src0) == REG\n-\t\t  && values[REGNO (src0)].lattice_val == CONSTANT)\n-\t\tsrc0 = values[REGNO (src0)].const_value;\n-\n-\t      if (GET_CODE (src1) == REG\n-\t\t  && values[REGNO (src1)].lattice_val == CONSTANT)\n-\t\tsrc1 = values[REGNO (src1)].const_value;\n-\n-\t      /* See if the simplifier can determine if this operation\n-\t\t computes a constant value.  */\n-\t      simplified = simplify_binary_operation (GET_CODE (src),\n-\t\t\t\t\t\t      GET_MODE (src),\n-\t\t\t\t\t\t      src0, src1);\n-\t      break;\n-\t    }\n-\n-\t  case '3':\n-\t  case 'b':\n-\t    {\n-\t      rtx src0 = XEXP (src, 0);\n-\t      rtx src1 = XEXP (src, 1);\n-\t      rtx src2 = XEXP (src, 2);\n-\n-\t      /* If either is undefined, then the result is undefined.  */\n-\t      if ((GET_CODE (src0) == REG\n-\t\t   && values[REGNO (src0)].lattice_val == UNDEFINED)\n-\t\t  || (GET_CODE (src1) == REG\n-\t\t      && values[REGNO (src1)].lattice_val == UNDEFINED)\n-\t\t  || (GET_CODE (src2) == REG\n-\t\t      && values[REGNO (src2)].lattice_val == UNDEFINED))\n-\t\t{\n-\t\t  defs_to_undefined (insn);\n-\t\t  break;\n-\t\t}\n-\n-\t      /* Simplify source operands to whatever known values they\n-\t\t may have.  */\n-\t      if (GET_CODE (src0) == REG\n-\t\t  && values[REGNO (src0)].lattice_val == CONSTANT)\n-\t\tsrc0 = values[REGNO (src0)].const_value;\n-\n-\t      if (GET_CODE (src1) == REG\n-\t\t  && values[REGNO (src1)].lattice_val == CONSTANT)\n-\t\tsrc1 = values[REGNO (src1)].const_value;\n-\n-\t      if (GET_CODE (src2) == REG\n-\t\t  && values[REGNO (src2)].lattice_val == CONSTANT)\n-\t\tsrc2 = values[REGNO (src2)].const_value;\n-\n-\t      /* See if the simplifier can determine if this operation\n-\t\t computes a constant value.  */\n-\t      simplified = simplify_ternary_operation (GET_CODE (src),\n-\t\t\t\t\t\t       GET_MODE (src),\n-\t\t\t\t\t\t       GET_MODE (src),\n-\t\t\t\t\t\t       src0, src1, src2);\n-\t      break;\n-\t    }\n-\n-\t  default:\n-\t    defs_to_varying (insn);\n-\t}\n-\n-      if (simplified && GET_CODE (simplified) == CONST_INT)\n-\t{\n-\t  if (values[REGNO (dest)].lattice_val != CONSTANT\n-\t      || values[REGNO (dest)].const_value != simplified)\n-\t    SET_BIT (ssa_edges, REGNO (dest));\n-\n-\t  values[REGNO (dest)].lattice_val = CONSTANT;\n-\t  values[REGNO (dest)].const_value = simplified;\n-\t}\n-      else\n-\tdefs_to_varying (insn);\n-    }\n-}\n-\n-/* Iterate over the FLOW_EDGES work list.  Simulate the target block\n-   for each edge.  */\n-static void\n-examine_flow_edges (void)\n-{\n-  while (flow_edges != NULL)\n-    {\n-      basic_block succ_block;\n-      rtx curr_phi_node;\n-\n-      /* Pull the next block to simulate off the worklist.  */\n-      succ_block = flow_edges->dest;\n-      flow_edges = edge_info[EIE (flow_edges->src, flow_edges->dest)];\n-\n-      /* There is nothing to do for the exit block.  */\n-      if (succ_block == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      /* Always simulate PHI nodes, even if we have simulated this block\n-\t before.  Note that all PHI nodes are consecutive within a block.  */\n-      for (curr_phi_node = first_insn_after_basic_block_note (succ_block);\n-\t   PHI_NODE_P (curr_phi_node);\n-\t   curr_phi_node = NEXT_INSN (curr_phi_node))\n-\tvisit_phi_node (curr_phi_node, succ_block);\n-\n-      /* If this is the first time we've simulated this block, then we\n-\t must simulate each of its insns.  */\n-      if (!TEST_BIT (executable_blocks, succ_block->index))\n-\t{\n-\t  rtx currinsn;\n-\t  edge succ_edge = succ_block->succ;\n-\n-\t  /* Note that we have simulated this block.  */\n-\t  SET_BIT (executable_blocks, succ_block->index);\n-\n-\t  /* Simulate each insn within the block.  */\n-\t  currinsn = succ_block->head;\n-\t  while (currinsn != succ_block->end)\n-\t    {\n-\t      if (INSN_P (currinsn))\n-\t\tvisit_expression (currinsn, succ_block);\n-\n-\t      currinsn = NEXT_INSN (currinsn);\n-\t    }\n-\n-\t  /* Don't forget the last insn in the block.  */\n-\t  if (INSN_P (currinsn))\n-\t    visit_expression (currinsn, succ_block);\n-\n-\t  /* If we haven't looked at the next block, and it has a\n-\t     single successor, add it onto the worklist.  This is because\n-\t     if we only have one successor, we know it gets executed,\n-\t     so we don't have to wait for cprop to tell us.  */\n-\t  if (succ_edge != NULL\n-\t      && succ_edge->succ_next == NULL\n-\t      && !TEST_BIT (executable_edges,\n-\t\t\t    EIE (succ_edge->src, succ_edge->dest)))\n-\t    {\n-\t      SET_BIT (executable_edges,\n-\t\t       EIE (succ_edge->src, succ_edge->dest));\n-\t      edge_info[EIE (succ_edge->src, succ_edge->dest)] = flow_edges;\n-\t      flow_edges = succ_edge;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Follow the def-use chains for each definition on the worklist and\n-   simulate the uses of the definition.  */\n-\n-static void\n-follow_def_use_chains (void)\n-{\n-  /* Iterate over all the entries on the SSA_EDGES worklist.  */\n-  while (sbitmap_first_set_bit (ssa_edges) >= 0)\n-    {\n-      int member;\n-      struct df_link *curruse;\n-\n-      /* Pick an entry off the worklist (it does not matter which\n-\t entry we pick).  */\n-      member = sbitmap_first_set_bit (ssa_edges);\n-      RESET_BIT (ssa_edges, member);\n-\n-      /* Iterate through all the uses of this entry.  */\n-      for (curruse = df_analyzer->regs[member].uses; curruse;\n-\t   curruse = curruse->next)\n-\t{\n-\t  rtx useinsn;\n-\n-\t  useinsn = DF_REF_INSN (curruse->ref);\n-\t  if (PHI_NODE_P (useinsn))\n-\t    {\n-\t      if (TEST_BIT (executable_blocks, BLOCK_NUM (useinsn)))\n-\t\tvisit_phi_node (useinsn, BLOCK_FOR_INSN (useinsn));\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TEST_BIT (executable_blocks, BLOCK_NUM (useinsn)))\n-\t\tvisit_expression (useinsn, BLOCK_FOR_INSN (useinsn));\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Examine each edge to see if we were able to prove any were\n-   not executable.\n-\n-   If an edge is not executable, then we can remove its alternative\n-   in PHI nodes as the destination of the edge, we can simplify the\n-   conditional branch at the source of the edge, and we can remove\n-   the edge from the CFG.  Note we do not delete unreachable blocks\n-   yet as the DF analyzer can not deal with that yet.  */\n-static void\n-optimize_unexecutable_edges (struct edge_list *edges,\n-\t\t\t     sbitmap executable_edges)\n-{\n-  int i;\n-  basic_block bb;\n-\n-  for (i = 0; i < NUM_EDGES (edges); i++)\n-    {\n-      if (!TEST_BIT (executable_edges, i))\n-\t{\n-\t  edge edge = INDEX_EDGE (edges, i);\n-\n-\t  if (edge->flags & EDGE_ABNORMAL)\n-\t    continue;\n-\n-\t  /* We found an edge that is not executable.  First simplify\n-\t     the PHI nodes in the target block.  */\n-\t  if (edge->dest != EXIT_BLOCK_PTR)\n-\t    {\n-\t      rtx insn = first_insn_after_basic_block_note (edge->dest);\n-\n-\t      while (PHI_NODE_P (insn))\n-\t\t{\n-\t\t  remove_phi_alternative (PATTERN (insn), edge->src);\n-\t\t  if (rtl_dump_file)\n-\t\t    fprintf (rtl_dump_file,\n-\t\t\t     \"Removing alternative for bb %d of phi %d\\n\",\n-\t\t\t     edge->src->index, SSA_NAME (PATTERN (insn)));\n-\t\t  insn = NEXT_INSN (insn);\n-\t\t}\n-\t    }\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n-\t\t     \"Removing unexecutable edge from %d to %d\\n\",\n-\t\t     edge->src->index, edge->dest->index);\n-\t  /* Since the edge was not executable, remove it from the CFG.  */\n-\t  remove_edge (edge);\n-\t}\n-    }\n-\n-  /* We have removed all the unexecutable edges from the CFG.  Fix up\n-     the conditional jumps at the end of any affected block.\n-\n-     We have three cases to deal with:\n-\n-       a. Both outgoing edges are not executable.  This happens if the\n-\t  source block is not reachable.  We will deal with this by\n-\t  deleting all the insns in the block later.\n-\n-       b. The fall-thru edge is not executable.  In this case we\n-\t  change the conditional jump into an unconditional jump and\n-\t  add a BARRIER after the unconditional jump.  Note that since\n-\t  we are working on generic RTL we can change the jump in-place\n-\t  instead of dealing with the headache of reemitting the jump.\n-\n-       c. The branch taken edge is not executable.  In this case\n-\t  we turn the jump into (set (pc) (pc)) which is a nop-jump\n-          and we will remove the unrecognizable insn later.\n-\n-     In cases B & C we are removing uses of registers, so make sure\n-     to note those changes for the DF analyzer.  */\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx insn = bb->end;\n-      edge edge = bb->succ;\n-\n-      /* If we have no predecessors, then this block is unreachable and\n-\t will be cleaned up when we remove unreachable blocks.  */\n-      if (bb->pred == NULL || GET_CODE (insn) != JUMP_INSN)\n-\tcontinue;\n-\n-      /* If this block ends in a conditional jump, but only has one\n-\t successor, then the jump needs adjustment.  */\n-      if (condjump_p (insn) && ! simplejump_p (insn)\n-\t  && bb->succ && bb->succ->succ_next == NULL)\n-\t{\n-\t  /* If the fallthru edge is the executable edge, then turn\n-\t     this jump into a nop jump, otherwise make it an unconditional\n-\t     jump to its target.  */\n-\t  if (edge->flags & EDGE_FALLTHRU)\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t    }\n-\t  else\n-\t    {\n-\t      SET_SRC (PATTERN (insn)) = gen_rtx_LABEL_REF (Pmode,\n-\t\t\t\t\t\t\t    JUMP_LABEL (insn));\n-\t      emit_barrier_after (insn);\n-\t      INSN_CODE (insn) = -1;\n-\t    }\n-\n-\t  /* Inform the DF analyzer that this insn changed.  */\n-\t  df_insn_modify (df_analyzer, BLOCK_FOR_INSN (insn), insn);\n-\t}\n-    }\n-}\n-\n-/* Perform substitution of known values for pseudo registers.\n-\n-   ??? Note we do not do simplifications or constant folding here, it\n-   is unlikely that any significant simplifications can be done here\n-   anyway.  Consider that if the simplification would result in an\n-   expression that produces a constant value that the value would\n-   have been discovered and recorded already.\n-\n-   We perform two transformations.  First, we initialize pseudos to their\n-   known constant values at their definition point.  Second, we try to\n-   replace uses with the known constant value.  */\n-\n-static void\n-ssa_ccp_substitute_constants (void)\n-{\n-  unsigned int i;\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < VARRAY_SIZE (ssa_definition); i++)\n-    {\n-      if (values[i].lattice_val == CONSTANT)\n-\t{\n-\t  rtx def = VARRAY_RTX (ssa_definition, i);\n-\t  rtx set = single_set (def);\n-\t  struct df_link *curruse;\n-\n-\t  if (! set)\n-\t    continue;\n-\n-\t  /* Do not try to simplify PHI nodes down to a constant load.\n-\t     That will be done later as we translate out of SSA.  Also,\n-\t     doing that here could violate the rule that all PHI nodes\n-\t     are consecutive at the start of the basic block.\n-\n-\t     Don't do anything to nodes that were already sets to\n-\t     constants.\t */\n-\t  if (! PHI_NODE_P (def)\n-\t      && ! ((GET_CODE (def) == INSN\n-\t\t     && GET_CODE (SET_SRC (set)) == CONST_INT)))\n-\t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file,\n-\t\t\t \"Register %d is now set to a constant\\n\",\n-\t\t\t SSA_NAME (PATTERN (def)));\n-\t      SET_SRC (set) = values[i].const_value;\n-\t      INSN_CODE (def) = -1;\n-\t      df_insn_modify (df_analyzer, BLOCK_FOR_INSN (def), def);\n-\t    }\n-\n-\t  /* Iterate through all the uses of this entry and try replacements\n-\t     there too.  Note it is not particularly profitable to try\n-\t     and fold/simplify expressions here as most of the common\n-\t     cases were handled above.  */\n-\t  for (curruse = df_analyzer->regs[i].uses;\n-\t       curruse;\n-\t       curruse = curruse->next)\n-\t    {\n-\t      rtx useinsn;\n-\n-\t      useinsn = DF_REF_INSN (curruse->ref);\n-\n-\t      if (!INSN_DELETED_P (useinsn)\n-\t\t  && ! (GET_CODE (useinsn) == NOTE\n-\t\t\t&& NOTE_LINE_NUMBER (useinsn) == NOTE_INSN_DELETED)\n-\t\t  && (GET_CODE (useinsn) == INSN\n-\t\t      || GET_CODE (useinsn) == JUMP_INSN))\n-\t\t{\n-\n-\t\t  if (validate_replace_src (regno_reg_rtx [i],\n-\t\t\t\t\tvalues[i].const_value,\n-\t\t\t\t\t    useinsn))\n-\t\t    {\n-\t\t      if (rtl_dump_file)\n-\t\t\tfprintf (rtl_dump_file,\n-\t\t\t\t \"Register %d in insn %d replaced with constant\\n\",\n-\t\t\t\t i, INSN_UID (useinsn));\n-\t\t      INSN_CODE (useinsn) = -1;\n-\t\t      df_insn_modify (df_analyzer,\n-\t\t\t\t      BLOCK_FOR_INSN (useinsn),\n-\t\t\t\t      useinsn);\n-\t\t    }\n-\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Now find all unreachable basic blocks.  All the insns in those\n-   blocks are unreachable, so delete them and mark any necessary\n-   updates for the DF analyzer.  */\n-\n-static void\n-ssa_ccp_df_delete_unreachable_insns (void)\n-{\n-  basic_block b;\n-\n-  /* Use the CFG to find all the reachable blocks.  */\n-  find_unreachable_blocks ();\n-\n-  /* Now we know what blocks are not reachable.  Mark all the insns\n-     in those blocks as deleted for the DF analyzer.   We'll let the\n-     normal flow code actually remove the unreachable blocks.  */\n-  FOR_EACH_BB_REVERSE (b)\n-    {\n-      if (!(b->flags & BB_REACHABLE))\n-\t{\n-\t  rtx start = b->head;\n-\t  rtx end = b->end;\n-\t  rtx tmp;\n-\n-\t  /* Include any jump table following the basic block.  */\n-\t  end = b->end;\n-\t  if (tablejump_p (end, NULL, &tmp))\n-\t    end = tmp;\n-\n-\t  while (1)\n-\t    {\n-\t      rtx next = NEXT_INSN (start);\n-\n-\t      if (GET_CODE (start) == INSN\n-\t\t  || GET_CODE (start) == CALL_INSN\n-\t\t  || GET_CODE (start) == JUMP_INSN)\n-\t\tdf_insn_delete (df_analyzer, BLOCK_FOR_INSN (start), start);\n-\n-\t      if (start == end)\n-\t\tbreak;\n-\t      start = next;\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/* Main entry point for SSA Conditional Constant Propagation.\n-\n-   Long term it should accept as input the specific flow graph to\n-   operate on so that it can be called for sub-graphs.  */\n-\n-void\n-ssa_const_prop (void)\n-{\n-  unsigned int i;\n-  edge curredge;\n-\n-  /* We need alias analysis (for what?) */\n-  init_alias_analysis ();\n-\n-  df_analyzer = df_init ();\n-  df_analyse (df_analyzer, 0,\n-\t      DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);\n-\n-  /* Perform a quick and dirty dead code elimination pass.  This is not\n-     as aggressive as it could be, but it's good enough to clean up a\n-     lot of unwanted junk and it is fast.  */\n-  ssa_fast_dce (df_analyzer);\n-\n-  /* Build an edge list from the CFG.  */\n-  edges = create_edge_list ();\n-\n-  /* Initialize the values array with everything as undefined.  */\n-  values = xmalloc (VARRAY_SIZE (ssa_definition) * sizeof (value));\n-  for (i = 0; i < VARRAY_SIZE (ssa_definition); i++)\n-    {\n-      if (i < FIRST_PSEUDO_REGISTER)\n-\tvalues[i].lattice_val = VARYING;\n-      else\n-\tvalues[i].lattice_val = UNDEFINED;\n-      values[i].const_value = NULL;\n-    }\n-\n-  ssa_edges = sbitmap_alloc (VARRAY_SIZE (ssa_definition));\n-  sbitmap_zero (ssa_edges);\n-\n-  executable_blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (executable_blocks);\n-\n-  executable_edges = sbitmap_alloc (NUM_EDGES (edges));\n-  sbitmap_zero (executable_edges);\n-\n-  edge_info = xmalloc (NUM_EDGES (edges) * sizeof (edge));\n-  flow_edges = ENTRY_BLOCK_PTR->succ;\n-\n-  /* Add the successors of the entry block to the edge worklist.  That\n-     is enough of a seed to get SSA-CCP started.  */\n-  for (curredge = ENTRY_BLOCK_PTR->succ; curredge;\n-       curredge = curredge->succ_next)\n-    {\n-      int index = EIE (curredge->src, curredge->dest);\n-      SET_BIT (executable_edges, index);\n-      edge_info[index] = curredge->succ_next;\n-    }\n-\n-  /* Iterate until until the worklists are empty.  */\n-  do\n-    {\n-      examine_flow_edges ();\n-      follow_def_use_chains ();\n-    }\n-  while (flow_edges != NULL);\n-\n-  /* Now perform substitutions based on the known constant values.  */\n-  ssa_ccp_substitute_constants ();\n-\n-  /* Remove unexecutable edges from the CFG and make appropriate\n-     adjustments to PHI nodes.  */\n-  optimize_unexecutable_edges (edges, executable_edges);\n-\n-  /* Now remove all unreachable insns and update the DF information.\n-     as appropriate.  */\n-  ssa_ccp_df_delete_unreachable_insns ();\n-\n-#if 0\n-  /* The DF analyzer expects the number of blocks to remain constant,\n-     so we can't remove unreachable blocks.\n-\n-     Code the DF analyzer calls expects there to be no unreachable\n-     blocks in the CFG.  So we can't leave unreachable blocks in the\n-     CFG.\n-\n-     So, there is no way to do an incremental update of the DF data\n-     at this point.  */\n-  df_analyse (df_analyzer, 0,\n-\t      DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);\n-#endif\n-\n-  /* Clean up any dead code exposed by SSA-CCP, do this after updating\n-     the dataflow information!  */\n-  ssa_fast_dce (df_analyzer);\n-\n-  free (values);\n-  values = NULL;\n-\n-  free (edge_info);\n-  edge_info = NULL;\n-\n-  sbitmap_free (executable_blocks);\n-  executable_blocks = NULL;\n-\n-  sbitmap_free (ssa_edges);\n-  ssa_edges = NULL;\n-\n-  free_edge_list (edges);\n-  edges = NULL;\n-\n-  sbitmap_free (executable_edges);\n-  executable_edges = NULL;\n-\n-  df_finish (df_analyzer);\n-  end_alias_analysis ();\n-}\n-\n-static int\n-mark_references (rtx *current_rtx, void *data)\n-{\n-  rtx x = *current_rtx;\n-  sbitmap worklist = (sbitmap) data;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-\n-  if (GET_CODE (x) == SET)\n-    {\n-      rtx dest = SET_DEST (x);\n-\n-      if (GET_CODE (dest) == STRICT_LOW_PART\n-\t  || GET_CODE (dest) == SUBREG\n-\t  || GET_CODE (dest) == SIGN_EXTRACT\n-\t  || GET_CODE (dest) == ZERO_EXTRACT)\n-\t{\n-\t  rtx reg;\n-\n-\t  reg = dest;\n-\n-\t  while (GET_CODE (reg) == STRICT_LOW_PART\n-\t\t || GET_CODE (reg) == SUBREG\n-\t\t || GET_CODE (reg) == SIGN_EXTRACT\n-\t\t || GET_CODE (reg) == ZERO_EXTRACT)\n-\t    reg = XEXP (reg, 0);\n-\n-\t  if (GET_CODE (reg) == REG)\n-\t    SET_BIT (worklist, REGNO (reg));\n-\t}\n-\n-      if (GET_CODE (dest) == REG)\n-\t{\n-\t  for_each_rtx (&SET_SRC (x), mark_references, data);\n-\t  return -1;\n-\t}\n-\n-      return 0;\n-    }\n-  else if (GET_CODE (x) == REG)\n-    {\n-      SET_BIT (worklist, REGNO (x));\n-      return -1;\n-    }\n-  else if (GET_CODE (x) == CLOBBER)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-static void\n-ssa_fast_dce (struct df *df)\n-{\n-  sbitmap worklist = sbitmap_alloc (VARRAY_SIZE (ssa_definition));\n-  sbitmap_ones (worklist);\n-\n-  /* Iterate on the worklist until there's no definitions left to\n-     examine.  */\n-  while (sbitmap_first_set_bit (worklist) >= 0)\n-    {\n-      struct df_link *curruse;\n-      int reg, found_use;\n-\n-      /* Remove an item from the worklist.  */\n-      reg = sbitmap_first_set_bit (worklist);\n-      RESET_BIT (worklist, reg);\n-\n-      /* We never consider deleting assignments to hard regs or things\n-\t which do not have SSA definitions, or things we have already\n-\t deleted, or things with unusual side effects.  */\n-      if (reg < FIRST_PSEUDO_REGISTER\n-\t  || ! VARRAY_RTX (ssa_definition, reg)\n-\t  || INSN_DELETED_P (VARRAY_RTX (ssa_definition, reg))\n-\t  || (GET_CODE (VARRAY_RTX (ssa_definition, reg)) == NOTE\n-\t      && (NOTE_LINE_NUMBER (VARRAY_RTX (ssa_definition, reg))\n-\t\t  == NOTE_INSN_DELETED))\n-\t  || side_effects_p (PATTERN (VARRAY_RTX (ssa_definition, reg))))\n-\tcontinue;\n-\n-      /* Iterate over the uses of this register.  If we can not find\n-\t any uses that have not been deleted, then the definition of\n-\t this register is dead.  */\n-      found_use = 0;\n-      for (curruse = df->regs[reg].uses; curruse; curruse = curruse->next)\n-\t{\n-\t  if (curruse->ref\n-\t      && DF_REF_INSN (curruse->ref)\n-\t      && ! INSN_DELETED_P (DF_REF_INSN (curruse->ref))\n-\t      && ! (GET_CODE (DF_REF_INSN (curruse->ref)) == NOTE\n-\t\t    && (NOTE_LINE_NUMBER (DF_REF_INSN (curruse->ref))\n-\t\t\t== NOTE_INSN_DELETED))\n-\t      && DF_REF_INSN (curruse->ref) != VARRAY_RTX (ssa_definition, reg))\n-\t    {\n-\t      found_use = 1;\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* If we did not find a use of this register, then the definition\n-\t of this register is dead.  */\n-\n-      if (! found_use)\n-\t{\n-\t  rtx def = VARRAY_RTX (ssa_definition, reg);\n-\n-\t  /* Add all registers referenced by INSN to the work\n-\t     list.  */\n-\t  for_each_rtx (&PATTERN (def), mark_references, worklist);\n-\n-\t  /* Inform the analyzer that this insn is going to be\n-\t     deleted.  */\n-\t  df_insn_delete (df, BLOCK_FOR_INSN (def), def);\n-\n-\t  VARRAY_RTX (ssa_definition, reg) = NULL;\n-\t}\n-    }\n-\n-  sbitmap_free (worklist);\n-\n-  /* Update the use-def chains in the df_analyzer as needed.  */\n-  df_analyse (df_analyzer, 0,\n-\t      DF_RD_CHAIN | DF_RU_CHAIN | DF_REG_INFO | DF_HARD_REGS);\n-}"}, {"sha": "c308c7793b6ed680b62609c20bb7ef72c290eede", "filename": "gcc/ssa-dce.c", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,713 +0,0 @@\n-/* Dead-code elimination pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-   Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-/* Dead-code elimination is the removal of instructions which have no\n-   impact on the program's output.  \"Dead instructions\" have no impact\n-   on the program's output, while \"necessary instructions\" may have\n-   impact on the output.\n-\n-   The algorithm consists of three phases:\n-   1) marking as necessary all instructions known to be necessary,\n-      e.g., writing a value to memory,\n-   2) propagating necessary instructions, e.g., the instructions\n-      giving values to operands in necessary instructions, and\n-   3) removing dead instructions (except replacing dead conditionals\n-      with unconditional jumps).\n-\n-   Side Effects:\n-   The last step can require adding labels, deleting insns, and\n-   modifying basic block structures.  Some conditional jumps may be\n-   converted to unconditional jumps so the control-flow graph may be\n-   out-of-date.\n-\n-   Edges from some infinite loops to the exit block can be added to\n-   the control-flow graph, but will be removed after this pass is\n-   complete.\n-\n-   It Does Not Perform:\n-   We decided to not simultaneously perform jump optimization and dead\n-   loop removal during dead-code elimination.  Thus, all jump\n-   instructions originally present remain after dead-code elimination\n-   but 1) unnecessary conditional jump instructions are changed to\n-   unconditional jump instructions and 2) all unconditional jump\n-   instructions remain.\n-\n-   Assumptions:\n-   1) SSA has been performed.\n-   2) The basic block and control-flow graph structures are accurate.\n-   3) The flow graph permits constructing an edge_list.\n-   4) note rtxes should be saved.\n-\n-   Unfinished:\n-   When replacing unnecessary conditional jumps with unconditional\n-   jumps, the control-flow graph is not updated.  It should be.\n-\n-   References:\n-   Building an Optimizing Compiler\n-   Robert Morgan\n-   Butterworth-Heinemann, 1998\n-   Section 8.9\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"ssa.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"output.h\"\n-\n-\f\n-/* A map from blocks to the edges on which they are control dependent.  */\n-typedef struct {\n-  /* A dynamically allocated array.  The Nth element corresponds to\n-     the block with index N + 2.  The Ith bit in the bitmap is set if\n-     that block is dependent on the Ith edge.  */\n-  bitmap *data;\n-  /* The number of elements in the array.  */\n-  int length;\n-} control_dependent_block_to_edge_map_s, *control_dependent_block_to_edge_map;\n-\n-/* Local function prototypes.  */\n-static control_dependent_block_to_edge_map control_dependent_block_to_edge_map_create\n-  (size_t num_basic_blocks);\n-static void set_control_dependent_block_to_edge_map_bit\n-  (control_dependent_block_to_edge_map c, basic_block bb, int edge_index);\n-static void control_dependent_block_to_edge_map_free\n-  (control_dependent_block_to_edge_map c);\n-static void find_all_control_dependences\n-  (struct edge_list *el, dominance_info pdom,\n-   control_dependent_block_to_edge_map cdbte);\n-static void find_control_dependence\n-  (struct edge_list *el, int edge_index, dominance_info pdom,\n-   control_dependent_block_to_edge_map cdbte);\n-static basic_block find_pdom (dominance_info pdom, basic_block block);\n-static int inherently_necessary_register_1 (rtx *current_rtx, void *data);\n-static int inherently_necessary_register (rtx current_rtx);\n-static int find_inherently_necessary (rtx current_rtx);\n-static int propagate_necessity_through_operand (rtx *current_rtx, void *data);\n-static void note_inherently_necessary_set (rtx, rtx, void *);\n-\f\n-/* Unnecessary insns are indicated using insns' in_struct bit.  */\n-\n-/* Indicate INSN is dead-code; returns nothing.  */\n-#define KILL_INSN(INSN)\t\tINSN_DEAD_CODE_P(INSN) = 1\n-/* Indicate INSN is necessary, i.e., not dead-code; returns nothing.  */\n-#define RESURRECT_INSN(INSN)\tINSN_DEAD_CODE_P(INSN) = 0\n-/* Return nonzero if INSN is unnecessary.  */\n-#define UNNECESSARY_P(INSN)\tINSN_DEAD_CODE_P(INSN)\n-static void mark_all_insn_unnecessary (void);\n-/* Execute CODE with free variable INSN for all unnecessary insns in\n-   an unspecified order, producing no output.  */\n-#define EXECUTE_IF_UNNECESSARY(INSN, CODE)\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  rtx INSN;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  for (INSN = get_insns (); INSN != NULL_RTX; INSN = NEXT_INSN (INSN))\t\\\n-    if (INSN_P (insn) && INSN_DEAD_CODE_P (INSN))\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        CODE;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Find the label beginning block BB.  */\n-static rtx find_block_label (basic_block bb);\n-/* Remove INSN, updating its basic block structure.  */\n-static void delete_insn_bb (rtx insn);\n-\f\n-/* Recording which blocks are control dependent on which edges.  We\n-   expect each block to be control dependent on very few edges so we\n-   use a bitmap for each block recording its edges.  An array holds\n-   the bitmap.  Its position 0 entry holds the bitmap for block\n-   INVALID_BLOCK+1 so that all blocks, including the entry and exit\n-   blocks can participate in the data structure.  */\n-\n-/* Create a control_dependent_block_to_edge_map, given the number\n-   NUM_BASIC_BLOCKS of non-entry, non-exit basic blocks, e.g.,\n-   n_basic_blocks.  This memory must be released using\n-   control_dependent_block_to_edge_map_free ().  */\n-\n-static control_dependent_block_to_edge_map\n-control_dependent_block_to_edge_map_create (size_t num_basic_blocks)\n-{\n-  int i;\n-  control_dependent_block_to_edge_map c\n-    = xmalloc (sizeof (control_dependent_block_to_edge_map_s));\n-  c->length = num_basic_blocks - (INVALID_BLOCK+1);\n-  c->data = xmalloc ((size_t) c->length*sizeof (bitmap));\n-  for (i = 0; i < c->length; ++i)\n-    c->data[i] = BITMAP_XMALLOC ();\n-\n-  return c;\n-}\n-\n-/* Indicate block BB is control dependent on an edge with index\n-   EDGE_INDEX in the mapping C of blocks to edges on which they are\n-   control-dependent.  */\n-\n-static void\n-set_control_dependent_block_to_edge_map_bit (control_dependent_block_to_edge_map c,\n-\t\t\t\t\t     basic_block bb, int edge_index)\n-{\n-  if (bb->index - (INVALID_BLOCK+1) >= c->length)\n-    abort ();\n-\n-  bitmap_set_bit (c->data[bb->index - (INVALID_BLOCK+1)],\n-\t\t  edge_index);\n-}\n-\n-/* Execute CODE for each edge (given number EDGE_NUMBER within the\n-   CODE) for which the block containing INSN is control dependent,\n-   returning no output.  CDBTE is the mapping of blocks to edges on\n-   which they are control-dependent.  */\n-\n-#define EXECUTE_IF_CONTROL_DEPENDENT(CDBTE, INSN, EDGE_NUMBER, CODE) \\\n-\tEXECUTE_IF_SET_IN_BITMAP \\\n-\t  (CDBTE->data[BLOCK_NUM (INSN) - (INVALID_BLOCK+1)], 0, \\\n-\t  EDGE_NUMBER, CODE)\n-\n-/* Destroy a control_dependent_block_to_edge_map C.  */\n-\n-static void\n-control_dependent_block_to_edge_map_free (control_dependent_block_to_edge_map c)\n-{\n-  int i;\n-  for (i = 0; i < c->length; ++i)\n-    BITMAP_XFREE (c->data[i]);\n-  free (c);\n-}\n-\n-/* Record all blocks' control dependences on all edges in the edge\n-   list EL, ala Morgan, Section 3.6.  The mapping PDOM of blocks to\n-   their postdominators are used, and results are stored in CDBTE,\n-   which should be empty.  */\n-\n-static void\n-find_all_control_dependences (struct edge_list *el, dominance_info pdom,\n-\t\t\t      control_dependent_block_to_edge_map cdbte)\n-{\n-  int i;\n-\n-  for (i = 0; i < NUM_EDGES (el); ++i)\n-    find_control_dependence (el, i, pdom, cdbte);\n-}\n-\n-/* Determine all blocks' control dependences on the given edge with\n-   edge_list EL index EDGE_INDEX, ala Morgan, Section 3.6.  The\n-   mapping PDOM of blocks to their postdominators are used, and\n-   results are stored in CDBTE, which is assumed to be initialized\n-   with zeros in each (block b', edge) position.  */\n-\n-static void\n-find_control_dependence (struct edge_list *el, int edge_index,\n-\t\t\t dominance_info pdom,\n-\t\t\t control_dependent_block_to_edge_map cdbte)\n-{\n-  basic_block current_block;\n-  basic_block ending_block;\n-\n-  if (INDEX_EDGE_PRED_BB (el, edge_index) == EXIT_BLOCK_PTR)\n-    abort ();\n-  ending_block =\n-    (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR)\n-    ? ENTRY_BLOCK_PTR->next_bb\n-    : find_pdom (pdom, INDEX_EDGE_PRED_BB (el, edge_index));\n-\n-  for (current_block = INDEX_EDGE_SUCC_BB (el, edge_index);\n-       current_block != ending_block && current_block != EXIT_BLOCK_PTR;\n-       current_block = find_pdom (pdom, current_block))\n-    {\n-      set_control_dependent_block_to_edge_map_bit (cdbte,\n-\t\t\t\t\t\t   current_block,\n-\t\t\t\t\t\t   edge_index);\n-    }\n-}\n-\f\n-/* Find the immediate postdominator PDOM of the specified basic block\n-   BLOCK.  This function is necessary because some blocks have\n-   negative numbers.  */\n-\n-static basic_block\n-find_pdom (dominance_info pdom, basic_block block)\n-{\n-  if (!block)\n-    abort ();\n-  if (block->index == INVALID_BLOCK)\n-    abort ();\n-\n-  if (block == ENTRY_BLOCK_PTR)\n-    return ENTRY_BLOCK_PTR->next_bb;\n-  else if (block == EXIT_BLOCK_PTR)\n-    return EXIT_BLOCK_PTR;\n-  else\n-    {\n-      basic_block bb = get_immediate_dominator (pdom, block);\n-      if (!bb)\n-\treturn EXIT_BLOCK_PTR;\n-      return bb;\n-    }\n-}\n-\n-/* Determine if the given CURRENT_RTX uses a hard register not\n-   converted to SSA.  Returns nonzero only if it uses such a hard\n-   register.  DATA is not used.\n-\n-   The program counter (PC) is not considered inherently necessary\n-   since code should be position-independent and thus not depend on\n-   particular PC values.  */\n-\n-static int\n-inherently_necessary_register_1 (rtx *current_rtx,\n-\t\t\t\t void *data ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *current_rtx;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-  switch (GET_CODE (x))\n-    {\n-    case CLOBBER:\n-      /* Do not traverse the rest of the clobber.  */\n-      return -1;\n-      break;\n-    case PC:\n-      return 0;\n-      break;\n-    case REG:\n-      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)) || x == pc_rtx)\n-\treturn 0;\n-      else\n-\treturn !0;\n-      break;\n-    default:\n-      return 0;\n-      break;\n-    }\n-}\n-\n-/* Return nonzero if the insn CURRENT_RTX is inherently necessary.  */\n-\n-static int\n-inherently_necessary_register (rtx current_rtx)\n-{\n-  return for_each_rtx (&current_rtx,\n-\t\t       &inherently_necessary_register_1, NULL);\n-}\n-\n-\n-/* Called via note_stores for each store in an insn.  Note whether\n-   or not a particular store is inherently necessary.  Store a\n-   nonzero value in inherently_necessary_p if such a store is found.  */\n-\n-static void\n-note_inherently_necessary_set (rtx dest, rtx set ATTRIBUTE_UNUSED, void *data)\n-{\n-  int *inherently_necessary_set_p = (int *) data;\n-\n-  while (GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == STRICT_LOW_PART\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT)\n-    dest = XEXP (dest, 0);\n-\n-  if (GET_CODE (dest) == MEM\n-      || GET_CODE (dest) == UNSPEC\n-      || GET_CODE (dest) == UNSPEC_VOLATILE)\n-    *inherently_necessary_set_p = 1;\n-}\n-\n-/* Mark X as inherently necessary if appropriate.  For example,\n-   function calls and storing values into memory are inherently\n-   necessary.  This function is to be used with for_each_rtx ().\n-   Return nonzero iff inherently necessary.  */\n-\n-static int\n-find_inherently_necessary (rtx x)\n-{\n-  if (x == NULL_RTX)\n-    return 0;\n-  else if (inherently_necessary_register (x))\n-    return !0;\n-  else\n-    switch (GET_CODE (x))\n-      {\n-      case CALL_INSN:\n-      case BARRIER:\n-      case PREFETCH:\n-\treturn !0;\n-      case CODE_LABEL:\n-      case NOTE:\n-\treturn 0;\n-      case JUMP_INSN:\n-\treturn JUMP_TABLE_DATA_P (x) || computed_jump_p (x) != 0;\n-      case INSN:\n-\t{\n-\t  int inherently_necessary_set = 0;\n-\t  note_stores (PATTERN (x),\n-\t\t       note_inherently_necessary_set,\n-\t\t       &inherently_necessary_set);\n-\n-\t  /* If we found an inherently necessary set or an asm\n-\t     instruction, then we consider this insn inherently\n-\t     necessary.  */\n-\t  return (inherently_necessary_set\n-\t\t  || GET_CODE (PATTERN (x)) == ASM_INPUT\n-\t\t  || asm_noperands (PATTERN (x)) >= 0);\n-\t}\n-      default:\n-\t/* Found an impossible insn type.  */\n-\tabort ();\n-\tbreak;\n-      }\n-}\n-\n-/* Propagate necessity through REG and SUBREG operands of CURRENT_RTX.\n-   This function is called with for_each_rtx () on necessary\n-   instructions.  The DATA must be a varray of unprocessed\n-   instructions.  */\n-\n-static int\n-propagate_necessity_through_operand (rtx *current_rtx, void *data)\n-{\n-  rtx x = *current_rtx;\n-  varray_type *unprocessed_instructions = (varray_type *) data;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-  switch ( GET_CODE (x))\n-    {\n-    case REG:\n-      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)))\n-\t{\n-\t  rtx insn = VARRAY_RTX (ssa_definition, REGNO (x));\n-\t  if (insn != NULL_RTX && UNNECESSARY_P (insn))\n-\t    {\n-\t      RESURRECT_INSN (insn);\n-\t      VARRAY_PUSH_RTX (*unprocessed_instructions, insn);\n-\t    }\n-\t}\n-      return 0;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Indicate all insns initially assumed to be unnecessary.  */\n-\n-static void\n-mark_all_insn_unnecessary (void)\n-{\n-  rtx insn;\n-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn)) {\n-    if (INSN_P (insn))\n-      KILL_INSN (insn);\n-  }\n-\n-}\n-\n-/* Find the label beginning block BB, adding one if necessary.  */\n-\n-static rtx\n-find_block_label (basic_block bb)\n-{\n-  rtx insn = bb->head;\n-  if (LABEL_P (insn))\n-    return insn;\n-  else\n-    {\n-      rtx new_label = emit_label_before (gen_label_rtx (), insn);\n-      if (insn == bb->head)\n-\tbb->head = new_label;\n-      return new_label;\n-    }\n-}\n-\n-/* Remove INSN, updating its basic block structure.  */\n-\n-static void\n-delete_insn_bb (rtx insn)\n-{\n-  if (!insn)\n-    abort ();\n-\n-  /* Do not actually delete anything that is not an INSN.\n-\n-     We can get here because we only consider INSNs as\n-     potentially necessary.  We leave it to later passes\n-     to remove unnecessary notes, unused labels, etc.  */\n-  if (! INSN_P (insn))\n-    return;\n-\n-  delete_insn (insn);\n-}\n-\f\n-/* Perform the dead-code elimination.  */\n-\n-void\n-ssa_eliminate_dead_code (void)\n-{\n-  rtx insn;\n-  basic_block bb;\n-  /* Necessary instructions with operands to explore.  */\n-  varray_type unprocessed_instructions;\n-  /* Map element (b,e) is nonzero if the block is control dependent on\n-     edge.  \"cdbte\" abbreviates control dependent block to edge.  */\n-  control_dependent_block_to_edge_map cdbte;\n- /* Element I is the immediate postdominator of block I.  */\n-  dominance_info pdom;\n-  struct edge_list *el;\n-\n-  /* Initialize the data structures.  */\n-  mark_all_insn_unnecessary ();\n-  VARRAY_RTX_INIT (unprocessed_instructions, 64,\n-\t\t   \"unprocessed instructions\");\n-  cdbte = control_dependent_block_to_edge_map_create (last_basic_block);\n-\n-  /* Prepare for use of BLOCK_NUM ().  */\n-  connect_infinite_loops_to_exit ();\n-\n-  /* Compute control dependence.  */\n-  pdom = calculate_dominance_info (CDI_POST_DOMINATORS);\n-  el = create_edge_list ();\n-  find_all_control_dependences (el, pdom, cdbte);\n-\n-  /* Find inherently necessary instructions.  */\n-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n-    if (find_inherently_necessary (insn) && INSN_P (insn))\n-      {\n-\tRESURRECT_INSN (insn);\n-\tVARRAY_PUSH_RTX (unprocessed_instructions, insn);\n-      }\n-\n-  /* Propagate necessity using the operands of necessary instructions.  */\n-  while (VARRAY_ACTIVE_SIZE (unprocessed_instructions) > 0)\n-    {\n-      rtx current_instruction;\n-      int edge_number;\n-\n-      current_instruction = VARRAY_TOP_RTX (unprocessed_instructions);\n-      VARRAY_POP (unprocessed_instructions);\n-\n-      /* Make corresponding control dependent edges necessary.  */\n-      /* Assume the only JUMP_INSN is the block's last insn.  It appears\n-\t that the last instruction of the program need not be a\n-\t JUMP_INSN.  */\n-\n-      if (INSN_P (current_instruction)\n-\t  && !JUMP_TABLE_DATA_P (current_instruction))\n-\t{\n-\t  /* Notes and labels contain no interesting operands.  */\n-\t  EXECUTE_IF_CONTROL_DEPENDENT\n-\t    (cdbte, current_instruction, edge_number,\n-\t    {\n-\t      rtx jump_insn = (INDEX_EDGE_PRED_BB (el, edge_number))->end;\n-\t      if (GET_CODE (jump_insn) == JUMP_INSN\n-\t\t  && UNNECESSARY_P (jump_insn))\n-\t\t{\n-\t\t  RESURRECT_INSN (jump_insn);\n-\t\t  VARRAY_PUSH_RTX (unprocessed_instructions, jump_insn);\n-\t\t}\n-\t    });\n-\n-\t  /* Propagate through the operands.  */\n-\t  for_each_rtx (&current_instruction,\n-\t\t\t&propagate_necessity_through_operand,\n-\t\t\t&unprocessed_instructions);\n-\n-\t  /* PHI nodes are somewhat special in that each PHI alternative\n-\t     has data and control dependencies.  The data dependencies\n-\t     are handled via propagate_necessity_through_operand.  We\n-\t     handle the control dependency here.\n-\n-\t     We consider the control dependent edges leading to the\n-\t     predecessor block associated with each PHI alternative\n-\t     as necessary.  */\n-\t  if (PHI_NODE_P (current_instruction))\n-\t    {\n-\t      rtvec phi_vec = XVEC (SET_SRC (PATTERN (current_instruction)), 0);\n-\t      int num_elem = GET_NUM_ELEM (phi_vec);\n-\t      int v;\n-\n-\t      for (v = num_elem - 2; v >= 0; v -= 2)\n-\t\t{\n-\t\t  basic_block bb;\n-\n-\t\t  bb = BASIC_BLOCK (INTVAL (RTVEC_ELT (phi_vec, v + 1)));\n-\t\t  EXECUTE_IF_CONTROL_DEPENDENT\n-\t\t    (cdbte, bb->end, edge_number,\n-\t\t    {\n-\t\t      rtx jump_insn;\n-\n-\t\t      jump_insn = (INDEX_EDGE_PRED_BB (el, edge_number))->end;\n-\t\t      if (((GET_CODE (jump_insn) == JUMP_INSN))\n-\t\t\t  && UNNECESSARY_P (jump_insn))\n-\t\t\t{\n-\t\t\t  RESURRECT_INSN (jump_insn);\n-\t\t\t  VARRAY_PUSH_RTX (unprocessed_instructions, jump_insn);\n-\t\t\t}\n-\t\t    });\n-\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Remove the unnecessary instructions.  */\n-  EXECUTE_IF_UNNECESSARY (insn,\n-  {\n-    if (any_condjump_p (insn))\n-      {\n-\tbasic_block bb = BLOCK_FOR_INSN (insn);\n-\tbasic_block pdom_bb = find_pdom (pdom, bb);\n-\trtx lbl;\n-\tedge e;\n-\n-\t/* Egad.  The immediate post dominator is the exit block.  We\n-\t   would like to optimize this conditional jump to jump directly\n-\t   to the exit block.  That can be difficult as we may not have\n-\t   a suitable CODE_LABEL that allows us to fall unmolested into\n-\t   the exit block.\n-\n-\t   So, we just delete the conditional branch by turning it into\n-\t   a deleted note.   That is safe, but just not as optimal as\n-\t   it could be.  */\n-\tif (pdom_bb == EXIT_BLOCK_PTR)\n-\t  {\n-\t    /* Since we're going to just delete the branch, we need\n-\t       look at all the edges and remove all those which are not\n-\t       a fallthru edge.  */\n-\t    e = bb->succ;\n-\t    while (e)\n-\t      {\n-\t\tedge temp = e;\n-\n-\t\te = e->succ_next;\n-\t\tif ((temp->flags & EDGE_FALLTHRU) == 0)\n-\t\t  {\n-\t\t    /* We've found a non-fallthru edge, find any PHI nodes\n-\t\t       at the target and clean them up.  */\n-\t\t    if (temp->dest != EXIT_BLOCK_PTR)\n-\t\t      {\n-\t\t        rtx insn\n-\t\t\t  = first_insn_after_basic_block_note (temp->dest);\n-\n-\t\t        while (PHI_NODE_P (insn))\n-\t\t\t  {\n-\t\t\t    remove_phi_alternative (PATTERN (insn), temp->src);\n-\t\t\t    insn = NEXT_INSN (insn);\n-\t\t\t  }\n-\t\t      }\n-\n-\t\t    remove_edge (temp);\n-\t\t  }\n-\t      }\n-\n-\t    /* Now \"delete\" the conditional jump.  */\n-\t    PUT_CODE (insn, NOTE);\n-\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t    continue;\n-\t  }\n-\n-\t/* We've found a conditional branch that is unnecessary.\n-\n-\t   First, remove all outgoing edges from this block, updating\n-\t   PHI nodes as appropriate.  */\n-\te = bb->succ;\n-\twhile (e)\n-\t  {\n-\t    edge temp = e;\n-\n-\t    e = e->succ_next;\n-\n-\t    if (temp->flags & EDGE_ABNORMAL)\n-\t      continue;\n-\n-\t    /* We found an edge that is not executable.  First simplify\n-\t       the PHI nodes in the target block.  */\n-\t    if (temp->dest != EXIT_BLOCK_PTR)\n-\t      {\n-\t\trtx insn = first_insn_after_basic_block_note (temp->dest);\n-\n-\t\twhile (PHI_NODE_P (insn))\n-\t\t  {\n-\t\t    remove_phi_alternative (PATTERN (insn), temp->src);\n-\t\t    insn = NEXT_INSN (insn);\n-\t\t  }\n-\t      }\n-\n-\t    remove_edge (temp);\n-\t  }\n-\n-\t/* Create an edge from this block to the post dominator.\n-\t   What about the PHI nodes at the target?  */\n-\tmake_edge (bb, pdom_bb, 0);\n-\n-\t/* Third, transform this insn into an unconditional\n-\t   jump to the label for the immediate postdominator.  */\n-\tlbl = find_block_label (pdom_bb);\n-\tSET_SRC (PATTERN (insn)) = gen_rtx_LABEL_REF (VOIDmode, lbl);\n-\tINSN_CODE (insn) = -1;\n-\tJUMP_LABEL (insn) = lbl;\n-\tLABEL_NUSES (lbl)++;\n-\n-\t/* A barrier must follow any unconditional jump.  Barriers\n-\t   are not in basic blocks so this must occur after\n-\t   deleting the conditional jump.  */\n-\temit_barrier_after (insn);\n-      }\n-    else if (!JUMP_P (insn))\n-      delete_insn_bb (insn);\n-  });\n-\n-  /* Remove fake edges from the CFG.  */\n-  remove_fake_edges ();\n-\n-  /* Find any blocks with no successors and ensure they are followed\n-     by a BARRIER.  delete_insn has the nasty habit of deleting barriers\n-     when deleting insns.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      if (bb->succ == NULL)\n-\t{\n-\t  rtx next = NEXT_INSN (bb->end);\n-\n-\t  if (!next || GET_CODE (next) != BARRIER)\n-\t    emit_barrier_after (bb->end);\n-\t}\n-    }\n-  /* Release allocated memory.  */\n-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn)) {\n-    if (INSN_P (insn))\n-      RESURRECT_INSN (insn);\n-  }\n-\n-  if (VARRAY_ACTIVE_SIZE (unprocessed_instructions) != 0)\n-    abort ();\n-  control_dependent_block_to_edge_map_free (cdbte);\n-  free (pdom);\n-  free_edge_list (el);\n-}"}, {"sha": "c12cdbe7afb493f81113180856a948a5f0d6c636", "filename": "gcc/ssa.c", "status": "removed", "additions": 0, "deletions": 2214, "changes": 2214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,2214 +0,0 @@\n-/* Static Single Assignment conversion routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-/* References:\n-\n-   Building an Optimizing Compiler\n-   Robert Morgan\n-   Butterworth-Heinemann, 1998\n-\n-   Static Single Assignment Construction\n-   Preston Briggs, Tim Harvey, Taylor Simpson\n-   Technical Report, Rice University, 1995\n-   ftp://ftp.cs.rice.edu/public/preston/optimizer/SSA.ps.gz.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"varray.h\"\n-#include \"partition.h\"\n-#include \"sbitmap.h\"\n-#include \"hashtab.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"basic-block.h\"\n-#include \"output.h\"\n-#include \"ssa.h\"\n-\n-/* TODO:\n-\n-   Handle subregs better, maybe.  For now, if a reg that's set in a\n-   subreg expression is duplicated going into SSA form, an extra copy\n-   is inserted first that copies the entire reg into the duplicate, so\n-   that the other bits are preserved.  This isn't strictly SSA, since\n-   at least part of the reg is assigned in more than one place (though\n-   they are adjacent).\n-\n-   ??? What to do about strict_low_part.  Probably I'll have to split\n-   them out of their current instructions first thing.\n-\n-   Actually the best solution may be to have a kind of \"mid-level rtl\"\n-   in which the RTL encodes exactly what we want, without exposing a\n-   lot of niggling processor details.  At some later point we lower\n-   the representation, calling back into optabs to finish any necessary\n-   expansion.  */\n-\n-/* All pseudo-registers and select hard registers are converted to SSA\n-   form.  When converting out of SSA, these select hard registers are\n-   guaranteed to be mapped to their original register number.  Each\n-   machine's .h file should define CONVERT_HARD_REGISTER_TO_SSA_P\n-   indicating which hard registers should be converted.\n-\n-   When converting out of SSA, temporaries for all registers are\n-   partitioned.  The partition is checked to ensure that all uses of\n-   the same hard register in the same machine mode are in the same\n-   class.  */\n-\n-/* If conservative_reg_partition is nonzero, use a conservative\n-   register partitioning algorithm (which leaves more regs after\n-   emerging from SSA) instead of the coalescing one.  This is being\n-   left in for a limited time only, as a debugging tool until the\n-   coalescing algorithm is validated.  */\n-\n-static int conservative_reg_partition;\n-\n-/* This flag is set when the CFG is in SSA form.  */\n-int in_ssa_form = 0;\n-\n-/* Element I is the single instruction that sets register I.  */\n-varray_type ssa_definition;\n-\n-/* Element I-PSEUDO is the normal register that originated the ssa\n-   register in question.  */\n-varray_type ssa_rename_from;\n-\n-/* Element I is the normal register that originated the ssa\n-   register in question.\n-\n-   A hash table stores the (register, rtl) pairs.  These are each\n-   xmalloc'ed and deleted when the hash table is destroyed.  */\n-htab_t ssa_rename_from_ht;\n-\n-/* The running target ssa register for a given pseudo register.\n-   (Pseudo registers appear in only one mode.)  */\n-static rtx *ssa_rename_to_pseudo;\n-/* Similar, but for hard registers.  A hard register can appear in\n-   many modes, so we store an equivalent pseudo for each of the\n-   modes.  */\n-static rtx ssa_rename_to_hard[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n-\n-/* ssa_rename_from maps pseudo registers to the original corresponding\n-   RTL.  It is implemented as using a hash table.  */\n-\n-typedef struct {\n-  unsigned int reg;\n-  rtx original;\n-} ssa_rename_from_pair;\n-\n-struct ssa_rename_from_hash_table_data {\n-  sbitmap canonical_elements;\n-  partition reg_partition;\n-};\n-\n-static rtx gen_sequence (void);\n-static void ssa_rename_from_initialize (void);\n-static rtx ssa_rename_from_lookup (int reg);\n-static unsigned int original_register (unsigned int regno);\n-static void ssa_rename_from_insert (unsigned int reg, rtx r);\n-static void ssa_rename_from_free (void);\n-typedef int (*srf_trav) (int regno, rtx r, sbitmap canonical_elements,\n-\t\t\t partition reg_partition);\n-static void ssa_rename_from_traverse (htab_trav callback_function,\n-\t\t\t\t      sbitmap canonical_elements, partition reg_partition);\n-/*static Avoid warning message.  */ void ssa_rename_from_print (void);\n-static int ssa_rename_from_print_1 (void **slot, void *data);\n-static hashval_t ssa_rename_from_hash_function (const void * srfp);\n-static int ssa_rename_from_equal (const void *srfp1, const void *srfp2);\n-static void ssa_rename_from_delete (void *srfp);\n-\n-static rtx ssa_rename_to_lookup (rtx reg);\n-static void ssa_rename_to_insert (rtx reg, rtx r);\n-\n-/* The number of registers that were live on entry to the SSA routines.  */\n-static unsigned int ssa_max_reg_num;\n-\n-/* Local function prototypes.  */\n-\n-struct rename_context;\n-\n-static inline rtx * phi_alternative (rtx, int);\n-static void compute_dominance_frontiers_1 (sbitmap *frontiers,\n-\t\t\t\t\t   dominance_info idom, int bb,\n-\t\t\t\t\t   sbitmap done);\n-static void find_evaluations_1 (rtx dest, rtx set, void *data);\n-static void find_evaluations (sbitmap *evals, int nregs);\n-static void compute_iterated_dominance_frontiers (sbitmap *idfs,\n-\t\t\t\t\t\t  sbitmap *frontiers,\n-\t\t\t\t\t\t  sbitmap *evals, int nregs);\n-static void insert_phi_node (int regno, int b);\n-static void insert_phi_nodes (sbitmap *idfs, sbitmap *evals, int nregs);\n-static void create_delayed_rename (struct rename_context *, rtx *);\n-static void apply_delayed_renames (struct rename_context *);\n-static int rename_insn_1 (rtx *ptr, void *data);\n-static void rename_block (int b, dominance_info dom);\n-static void rename_registers (int nregs, dominance_info idom);\n-\n-static inline int ephi_add_node (rtx reg, rtx *nodes, int *n_nodes);\n-static int * ephi_forward (int t, sbitmap visited, sbitmap *succ, int *tstack);\n-static void ephi_backward (int t, sbitmap visited, sbitmap *pred, rtx *nodes);\n-static void ephi_create (int t, sbitmap visited, sbitmap *pred,\n-\t\t\t sbitmap *succ, rtx *nodes);\n-static void eliminate_phi (edge e, partition reg_partition);\n-static int make_regs_equivalent_over_bad_edges (int bb,\n-\t\t\t\t\t\tpartition reg_partition);\n-\n-/* These are used only in the conservative register partitioning\n-   algorithms.  */\n-static int make_equivalent_phi_alternatives_equivalent\n-  (int bb, partition reg_partition);\n-static partition compute_conservative_reg_partition (void);\n-static int record_canonical_element_1 (void **srfp, void *data);\n-static int check_hard_regs_in_partition (partition reg_partition);\n-\n-/* These are used in the register coalescing algorithm.  */\n-static int coalesce_if_unconflicting (partition p, conflict_graph conflicts,\n-\t\t\t\t      int reg1, int reg2);\n-static int coalesce_regs_in_copies (basic_block bb, partition p,\n-\t\t\t\t    conflict_graph conflicts);\n-static int coalesce_reg_in_phi (rtx, int dest_regno, int src_regno,\n-\t\t\t\tvoid *data);\n-static int coalesce_regs_in_successor_phi_nodes (basic_block bb,\n-\t\t\t\t\t\t partition p,\n-\t\t\t\t\t\t conflict_graph conflicts);\n-static partition compute_coalesced_reg_partition (void);\n-static int mark_reg_in_phi (rtx *ptr, void *data);\n-static void mark_phi_and_copy_regs (regset phi_set);\n-\n-static int rename_equivalent_regs_in_insn (rtx *ptr, void *data);\n-static void rename_equivalent_regs (partition reg_partition);\n-\n-/* Deal with hard registers.  */\n-static int conflicting_hard_regs_p (int reg1, int reg2);\n-\n-/* ssa_rename_to maps registers and machine modes to SSA pseudo registers.  */\n-\n-/* Find the register associated with REG in the indicated mode.  */\n-\n-static rtx\n-ssa_rename_to_lookup (rtx reg)\n-{\n-  if (!HARD_REGISTER_P (reg))\n-    return ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER];\n-  else\n-    return ssa_rename_to_hard[REGNO (reg)][GET_MODE (reg)];\n-}\n-\n-/* Store a new value mapping REG to R in ssa_rename_to.  */\n-\n-static void\n-ssa_rename_to_insert (rtx reg, rtx r)\n-{\n-  if (!HARD_REGISTER_P (reg))\n-    ssa_rename_to_pseudo[REGNO (reg) - FIRST_PSEUDO_REGISTER] = r;\n-  else\n-    ssa_rename_to_hard[REGNO (reg)][GET_MODE (reg)] = r;\n-}\n-\n-/* Prepare ssa_rename_from for use.  */\n-\n-static void\n-ssa_rename_from_initialize (void)\n-{\n-  /* We use an arbitrary initial hash table size of 64.  */\n-  ssa_rename_from_ht = htab_create (64,\n-\t\t\t\t    &ssa_rename_from_hash_function,\n-\t\t\t\t    &ssa_rename_from_equal,\n-\t\t\t\t    &ssa_rename_from_delete);\n-}\n-\n-/* Find the REG entry in ssa_rename_from.  Return NULL_RTX if no entry is\n-   found.  */\n-\n-static rtx\n-ssa_rename_from_lookup (int reg)\n-{\n-  ssa_rename_from_pair srfp;\n-  ssa_rename_from_pair *answer;\n-  srfp.reg = reg;\n-  srfp.original = NULL_RTX;\n-  answer = htab_find_with_hash (ssa_rename_from_ht, (void *) &srfp, reg);\n-  return (answer == 0 ? NULL_RTX : answer->original);\n-}\n-\n-/* Find the number of the original register specified by REGNO.  If\n-   the register is a pseudo, return the original register's number.\n-   Otherwise, return this register number REGNO.  */\n-\n-static unsigned int\n-original_register (unsigned int regno)\n-{\n-  rtx original_rtx = ssa_rename_from_lookup (regno);\n-  return original_rtx != NULL_RTX ? REGNO (original_rtx) : regno;\n-}\n-\n-/* Add mapping from R to REG to ssa_rename_from even if already present.  */\n-\n-static void\n-ssa_rename_from_insert (unsigned int reg, rtx r)\n-{\n-  void **slot;\n-  ssa_rename_from_pair *srfp = xmalloc (sizeof (ssa_rename_from_pair));\n-  srfp->reg = reg;\n-  srfp->original = r;\n-  slot = htab_find_slot_with_hash (ssa_rename_from_ht, (const void *) srfp,\n-\t\t\t\t   reg, INSERT);\n-  if (*slot != 0)\n-    free ((void *) *slot);\n-  *slot = srfp;\n-}\n-\n-/* Apply the CALLBACK_FUNCTION to each element in ssa_rename_from.\n-   CANONICAL_ELEMENTS and REG_PARTITION pass data needed by the only\n-   current use of this function.  */\n-\n-static void\n-ssa_rename_from_traverse (htab_trav callback_function,\n-\t\t\t  sbitmap canonical_elements, partition reg_partition)\n-{\n-  struct ssa_rename_from_hash_table_data srfhd;\n-  srfhd.canonical_elements = canonical_elements;\n-  srfhd.reg_partition = reg_partition;\n-  htab_traverse (ssa_rename_from_ht, callback_function, (void *) &srfhd);\n-}\n-\n-/* Destroy ssa_rename_from.  */\n-\n-static void\n-ssa_rename_from_free (void)\n-{\n-  htab_delete (ssa_rename_from_ht);\n-}\n-\n-/* Print the contents of ssa_rename_from.  */\n-\n-/* static  Avoid erroneous error message.  */\n-void\n-ssa_rename_from_print (void)\n-{\n-  printf (\"ssa_rename_from's hash table contents:\\n\");\n-  htab_traverse (ssa_rename_from_ht, &ssa_rename_from_print_1, NULL);\n-}\n-\n-/* Print the contents of the hash table entry SLOT, passing the unused\n-   attribute DATA.  Used as a callback function with htab_traverse ().  */\n-\n-static int\n-ssa_rename_from_print_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n-{\n-  ssa_rename_from_pair * p = *slot;\n-  printf (\"ssa_rename_from maps pseudo %i to original %i.\\n\",\n-\t  p->reg, REGNO (p->original));\n-  return 1;\n-}\n-\n-/* Given a hash entry SRFP, yield a hash value.  */\n-\n-static hashval_t\n-ssa_rename_from_hash_function (const void *srfp)\n-{\n-  return ((const ssa_rename_from_pair *) srfp)->reg;\n-}\n-\n-/* Test whether two hash table entries SRFP1 and SRFP2 are equal.  */\n-\n-static int\n-ssa_rename_from_equal (const void *srfp1, const void *srfp2)\n-{\n-  return ssa_rename_from_hash_function (srfp1) ==\n-    ssa_rename_from_hash_function (srfp2);\n-}\n-\n-/* Delete the hash table entry SRFP.  */\n-\n-static void\n-ssa_rename_from_delete (void *srfp)\n-{\n-  free (srfp);\n-}\n-\n-/* Given the SET of a PHI node, return the address of the alternative\n-   for predecessor block C.  */\n-\n-static inline rtx *\n-phi_alternative (rtx set, int c)\n-{\n-  rtvec phi_vec = XVEC (SET_SRC (set), 0);\n-  int v;\n-\n-  for (v = GET_NUM_ELEM (phi_vec) - 2; v >= 0; v -= 2)\n-    if (INTVAL (RTVEC_ELT (phi_vec, v + 1)) == c)\n-      return &RTVEC_ELT (phi_vec, v);\n-\n-  return NULL;\n-}\n-\n-/* Given the SET of a phi node, remove the alternative for predecessor\n-   block C.  Return nonzero on success, or zero if no alternative is\n-   found for C.  */\n-\n-int\n-remove_phi_alternative (rtx set, basic_block block)\n-{\n-  rtvec phi_vec = XVEC (SET_SRC (set), 0);\n-  int num_elem = GET_NUM_ELEM (phi_vec);\n-  int v, c;\n-\n-  c = block->index;\n-  for (v = num_elem - 2; v >= 0; v -= 2)\n-    if (INTVAL (RTVEC_ELT (phi_vec, v + 1)) == c)\n-      {\n-\tif (v < num_elem - 2)\n-\t  {\n-\t    RTVEC_ELT (phi_vec, v) = RTVEC_ELT (phi_vec, num_elem - 2);\n-\t    RTVEC_ELT (phi_vec, v + 1) = RTVEC_ELT (phi_vec, num_elem - 1);\n-\t  }\n-\tPUT_NUM_ELEM (phi_vec, num_elem - 2);\n-\treturn 1;\n-      }\n-\n-  return 0;\n-}\n-\n-/* For all registers, find all blocks in which they are set.\n-\n-   This is the transform of what would be local kill information that\n-   we ought to be getting from flow.  */\n-\n-static sbitmap *fe_evals;\n-static int fe_current_bb;\n-\n-static void\n-find_evaluations_1 (rtx dest, rtx set ATTRIBUTE_UNUSED,\n-\t\t    void *data ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (dest) == REG\n-      && CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))\n-    SET_BIT (fe_evals[REGNO (dest)], fe_current_bb);\n-}\n-\n-static void\n-find_evaluations (sbitmap *evals, int nregs)\n-{\n-  basic_block bb;\n-\n-  sbitmap_vector_zero (evals, nregs);\n-  fe_evals = evals;\n-\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      rtx p, last;\n-\n-      fe_current_bb = bb->index;\n-      p = bb->head;\n-      last = bb->end;\n-      while (1)\n-\t{\n-\t  if (INSN_P (p))\n-\t    note_stores (PATTERN (p), find_evaluations_1, NULL);\n-\n-\t  if (p == last)\n-\t    break;\n-\t  p = NEXT_INSN (p);\n-\t}\n-    }\n-}\n-\n-/* Computing the Dominance Frontier:\n-\n-   As described in Morgan, section 3.5, this may be done simply by\n-   walking the dominator tree bottom-up, computing the frontier for\n-   the children before the parent.  When considering a block B,\n-   there are two cases:\n-\n-   (1) A flow graph edge leaving B that does not lead to a child\n-   of B in the dominator tree must be a block that is either equal\n-   to B or not dominated by B.  Such blocks belong in the frontier\n-   of B.\n-\n-   (2) Consider a block X in the frontier of one of the children C\n-   of B.  If X is not equal to B and is not dominated by B, it\n-   is in the frontier of B.\n-*/\n-\n-static void\n-compute_dominance_frontiers_1 (sbitmap *frontiers, dominance_info idom,\n-\t\t\t       int bb, sbitmap done)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  edge e;\n-  basic_block c;\n-\n-  SET_BIT (done, bb);\n-  sbitmap_zero (frontiers[bb]);\n-\n-  /* Do the frontier of the children first.  Not all children in the\n-     dominator tree (blocks dominated by this one) are children in the\n-     CFG, so check all blocks.  */\n-  FOR_EACH_BB (c)\n-    if (get_immediate_dominator (idom, c)->index == bb\n-\t&& ! TEST_BIT (done, c->index))\n-      compute_dominance_frontiers_1 (frontiers, idom, c->index, done);\n-\n-  /* Find blocks conforming to rule (1) above.  */\n-  for (e = b->succ; e; e = e->succ_next)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-      if (get_immediate_dominator (idom, e->dest)->index != bb)\n-\tSET_BIT (frontiers[bb], e->dest->index);\n-    }\n-\n-  /* Find blocks conforming to rule (2).  */\n-  FOR_EACH_BB (c)\n-    if (get_immediate_dominator (idom, c)->index == bb)\n-      {\n-\tint x;\n-\tEXECUTE_IF_SET_IN_SBITMAP (frontiers[c->index], 0, x,\n-\t  {\n-\t    if (get_immediate_dominator (idom, BASIC_BLOCK (x))->index != bb)\n-\t      SET_BIT (frontiers[bb], x);\n-\t  });\n-      }\n-}\n-\n-void\n-compute_dominance_frontiers (sbitmap *frontiers, dominance_info idom)\n-{\n-  sbitmap done = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (done);\n-\n-  compute_dominance_frontiers_1 (frontiers, idom, 0, done);\n-\n-  sbitmap_free (done);\n-}\n-\n-/* Computing the Iterated Dominance Frontier:\n-\n-   This is the set of merge points for a given register.\n-\n-   This is not particularly intuitive.  See section 7.1 of Morgan, in\n-   particular figures 7.3 and 7.4 and the immediately surrounding text.\n-*/\n-\n-static void\n-compute_iterated_dominance_frontiers (sbitmap *idfs, sbitmap *frontiers,\n-\t\t\t\t      sbitmap *evals, int nregs)\n-{\n-  sbitmap worklist;\n-  int reg, passes = 0;\n-\n-  worklist = sbitmap_alloc (last_basic_block);\n-\n-  for (reg = 0; reg < nregs; ++reg)\n-    {\n-      sbitmap idf = idfs[reg];\n-      int b, changed;\n-\n-      /* Start the iterative process by considering those blocks that\n-\t evaluate REG.  We'll add their dominance frontiers to the\n-\t IDF, and then consider the blocks we just added.  */\n-      sbitmap_copy (worklist, evals[reg]);\n-\n-      /* Morgan's algorithm is incorrect here.  Blocks that evaluate\n-\t REG aren't necessarily in REG's IDF.  Start with an empty IDF.  */\n-      sbitmap_zero (idf);\n-\n-      /* Iterate until the worklist is empty.  */\n-      do\n-\t{\n-\t  changed = 0;\n-\t  passes++;\n-\t  EXECUTE_IF_SET_IN_SBITMAP (worklist, 0, b,\n-\t    {\n-\t      RESET_BIT (worklist, b);\n-\t      /* For each block on the worklist, add to the IDF all\n-\t\t blocks on its dominance frontier that aren't already\n-\t\t on the IDF.  Every block that's added is also added\n-\t\t to the worklist.  */\n-\t      sbitmap_union_of_diff (worklist, worklist, frontiers[b], idf);\n-\t      sbitmap_a_or_b (idf, idf, frontiers[b]);\n-\t      changed = 1;\n-\t    });\n-\t}\n-      while (changed);\n-    }\n-\n-  sbitmap_free (worklist);\n-\n-  if (rtl_dump_file)\n-    {\n-      fprintf (rtl_dump_file,\n-\t       \"Iterated dominance frontier: %d passes on %d regs.\\n\",\n-\t       passes, nregs);\n-    }\n-}\n-\n-/* Insert the phi nodes.  */\n-\n-static void\n-insert_phi_node (int regno, int bb)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  edge e;\n-  int npred, i;\n-  rtvec vec;\n-  rtx phi, reg;\n-  rtx insn;\n-  int end_p;\n-\n-  /* Find out how many predecessors there are.  */\n-  for (e = b->pred, npred = 0; e; e = e->pred_next)\n-    if (e->src != ENTRY_BLOCK_PTR)\n-      npred++;\n-\n-  /* If this block has no \"interesting\" preds, then there is nothing to\n-     do.  Consider a block that only has the entry block as a pred.  */\n-  if (npred == 0)\n-    return;\n-\n-  /* This is the register to which the phi function will be assigned.  */\n-  reg = regno_reg_rtx[regno];\n-\n-  /* Construct the arguments to the PHI node.  The use of pc_rtx is just\n-     a placeholder; we'll insert the proper value in rename_registers.  */\n-  vec = rtvec_alloc (npred * 2);\n-  for (e = b->pred, i = 0; e ; e = e->pred_next, i += 2)\n-    if (e->src != ENTRY_BLOCK_PTR)\n-      {\n-\tRTVEC_ELT (vec, i + 0) = pc_rtx;\n-\tRTVEC_ELT (vec, i + 1) = GEN_INT (e->src->index);\n-      }\n-\n-  phi = gen_rtx_PHI (VOIDmode, vec);\n-  phi = gen_rtx_SET (VOIDmode, reg, phi);\n-\n-  insn = first_insn_after_basic_block_note (b);\n-  end_p = PREV_INSN (insn) == b->end;\n-  emit_insn_before (phi, insn);\n-  if (end_p)\n-    b->end = PREV_INSN (insn);\n-}\n-\n-static void\n-insert_phi_nodes (sbitmap *idfs, sbitmap *evals ATTRIBUTE_UNUSED, int nregs)\n-{\n-  int reg;\n-\n-  for (reg = 0; reg < nregs; ++reg)\n-    if (CONVERT_REGISTER_TO_SSA_P (reg))\n-    {\n-      int b;\n-      EXECUTE_IF_SET_IN_SBITMAP (idfs[reg], 0, b,\n-\t{\n-\t  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, reg))\n-\t    insert_phi_node (reg, b);\n-\t});\n-    }\n-}\n-\n-/* Rename the registers to conform to SSA.\n-\n-   This is essentially the algorithm presented in Figure 7.8 of Morgan,\n-   with a few changes to reduce pattern search time in favor of a bit\n-   more memory usage.  */\n-\n-/* One of these is created for each set.  It will live in a list local\n-   to its basic block for the duration of that block's processing.  */\n-struct rename_set_data\n-{\n-  struct rename_set_data *next;\n-  /* This is the SET_DEST of the (first) SET that sets the REG.  */\n-  rtx *reg_loc;\n-  /* This is what used to be at *REG_LOC.  */\n-  rtx old_reg;\n-  /* This is the REG that will replace OLD_REG.  It's set only\n-     when the rename data is moved onto the DONE_RENAMES queue.  */\n-  rtx new_reg;\n-  /* This is what to restore ssa_rename_to_lookup (old_reg) to.  It is\n-     usually the previous contents of ssa_rename_to_lookup (old_reg).  */\n-  rtx prev_reg;\n-  /* This is the insn that contains all the SETs of the REG.  */\n-  rtx set_insn;\n-};\n-\n-/* This struct is used to pass information to callback functions while\n-   renaming registers.  */\n-struct rename_context\n-{\n-  struct rename_set_data *new_renames;\n-  struct rename_set_data *done_renames;\n-  rtx current_insn;\n-};\n-\n-/* Queue the rename of *REG_LOC.  */\n-static void\n-create_delayed_rename (struct rename_context *c, rtx *reg_loc)\n-{\n-  struct rename_set_data *r;\n-  r = xmalloc (sizeof(*r));\n-\n-  if (GET_CODE (*reg_loc) != REG\n-      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*reg_loc)))\n-    abort ();\n-\n-  r->reg_loc = reg_loc;\n-  r->old_reg = *reg_loc;\n-  r->prev_reg = ssa_rename_to_lookup(r->old_reg);\n-  r->set_insn = c->current_insn;\n-  r->next = c->new_renames;\n-  c->new_renames = r;\n-}\n-\n-/* This is part of a rather ugly hack to allow the pre-ssa regno to be\n-   reused.  If, during processing, a register has not yet been touched,\n-   ssa_rename_to[regno][machno] will be NULL.  Now, in the course of pushing\n-   and popping values from ssa_rename_to, when we would ordinarily\n-   pop NULL back in, we pop RENAME_NO_RTX.  We treat this exactly the\n-   same as NULL, except that it signals that the original regno has\n-   already been reused.  */\n-#define RENAME_NO_RTX  pc_rtx\n-\n-/* Move all the entries from NEW_RENAMES onto DONE_RENAMES by\n-   applying all the renames on NEW_RENAMES.  */\n-\n-static void\n-apply_delayed_renames (struct rename_context *c)\n-{\n-  struct rename_set_data *r;\n-  struct rename_set_data *last_r = NULL;\n-\n-  for (r = c->new_renames; r != NULL; r = r->next)\n-    {\n-      int new_regno;\n-\n-      /* Failure here means that someone has a PARALLEL that sets\n-\t a register twice (bad!).  */\n-      if (ssa_rename_to_lookup (r->old_reg) != r->prev_reg)\n-\tabort ();\n-      /* Failure here means we have changed REG_LOC before applying\n-\t the rename.  */\n-      /* For the first set we come across, reuse the original regno.  */\n-      if (r->prev_reg == NULL_RTX && !HARD_REGISTER_P (r->old_reg))\n-\t{\n-\t  r->new_reg = r->old_reg;\n-\t  /* We want to restore RENAME_NO_RTX rather than NULL_RTX.  */\n-\t  r->prev_reg = RENAME_NO_RTX;\n-\t}\n-      else\n-\tr->new_reg = gen_reg_rtx (GET_MODE (r->old_reg));\n-      new_regno = REGNO (r->new_reg);\n-      ssa_rename_to_insert (r->old_reg, r->new_reg);\n-\n-      if (new_regno >= (int) ssa_definition->num_elements)\n-\t{\n-\t  int new_limit = new_regno * 5 / 4;\n-\t  VARRAY_GROW (ssa_definition, new_limit);\n-\t}\n-\n-      VARRAY_RTX (ssa_definition, new_regno) = r->set_insn;\n-      ssa_rename_from_insert (new_regno, r->old_reg);\n-      last_r = r;\n-    }\n-  if (last_r != NULL)\n-    {\n-      last_r->next = c->done_renames;\n-      c->done_renames = c->new_renames;\n-      c->new_renames = NULL;\n-    }\n-}\n-\n-/* Part one of the first step of rename_block, called through for_each_rtx.\n-   Mark pseudos that are set for later update.  Transform uses of pseudos.  */\n-\n-static int\n-rename_insn_1 (rtx *ptr, void *data)\n-{\n-  rtx x = *ptr;\n-  struct rename_context *context = data;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SET:\n-      {\n-\trtx *destp = &SET_DEST (x);\n-\trtx dest = SET_DEST (x);\n-\n-\t/* An assignment to a paradoxical SUBREG does not read from\n-\t   the destination operand, and thus does not need to be\n-\t   wrapped into a SEQUENCE when translating into SSA form.\n-\t   We merely strip off the SUBREG and proceed normally for\n-\t   this case.  */\n-\tif (GET_CODE (dest) == SUBREG\n-\t    && (GET_MODE_SIZE (GET_MODE (dest))\n-\t\t> GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))\n-\t    && GET_CODE (SUBREG_REG (dest)) == REG\n-\t    && CONVERT_REGISTER_TO_SSA_P (REGNO (SUBREG_REG (dest))))\n-\t  {\n-\t    destp = &XEXP (dest, 0);\n-\t    dest = XEXP (dest, 0);\n-\t  }\n-\n-\t/* Some SETs also use the REG specified in their LHS.\n-\t   These can be detected by the presence of\n-\t   STRICT_LOW_PART, SUBREG, SIGN_EXTRACT, and ZERO_EXTRACT\n-\t   in the LHS.  Handle these by changing\n-\t   (set (subreg (reg foo)) ...)\n-\t   into\n-\t   (sequence [(set (reg foo_1) (reg foo))\n-\t              (set (subreg (reg foo_1)) ...)])\n-\n-\t   FIXME: Much of the time this is too much.  For some constructs\n-\t   we know that the output register is strictly an output\n-\t   (paradoxical SUBREGs and some libcalls for example).\n-\n-\t   For those cases we are better off not making the false\n-\t   dependency.  */\n-\tif (GET_CODE (dest) == STRICT_LOW_PART\n-\t    || GET_CODE (dest) == SUBREG\n-\t    || GET_CODE (dest) == SIGN_EXTRACT\n-\t    || GET_CODE (dest) == ZERO_EXTRACT)\n-\t  {\n-\t    rtx i, reg;\n-\t    reg = dest;\n-\n-\t    while (GET_CODE (reg) == STRICT_LOW_PART\n-\t\t   || GET_CODE (reg) == SUBREG\n-\t\t   || GET_CODE (reg) == SIGN_EXTRACT\n-\t\t   || GET_CODE (reg) == ZERO_EXTRACT)\n-\t\treg = XEXP (reg, 0);\n-\n-\t    if (GET_CODE (reg) == REG\n-\t\t&& CONVERT_REGISTER_TO_SSA_P (REGNO (reg)))\n-\t      {\n-\t\t/* Generate (set reg reg), and do renaming on it so\n-\t\t   that it becomes (set reg_1 reg_0), and we will\n-\t\t   replace reg with reg_1 in the SUBREG.  */\n-\n-\t\tstruct rename_set_data *saved_new_renames;\n-\t\tsaved_new_renames = context->new_renames;\n-\t\tcontext->new_renames = NULL;\n-\t\ti = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));\n-\t\tfor_each_rtx (&i, rename_insn_1, data);\n-\t\tapply_delayed_renames (context);\n-\t\tcontext->new_renames = saved_new_renames;\n-\t      }\n-\t  }\n-\telse if (GET_CODE (dest) == REG\n-\t\t && CONVERT_REGISTER_TO_SSA_P (REGNO (dest)))\n-\t  {\n-\t    /* We found a genuine set of an interesting register.  Tag\n-\t       it so that we can create a new name for it after we finish\n-\t       processing this insn.  */\n-\n-\t    create_delayed_rename (context, destp);\n-\n-\t    /* Since we do not wish to (directly) traverse the\n-\t       SET_DEST, recurse through for_each_rtx for the SET_SRC\n-\t       and return.  */\n-\t    if (GET_CODE (x) == SET)\n-\t      for_each_rtx (&SET_SRC (x), rename_insn_1, data);\n-\t    return -1;\n-\t  }\n-\n-\t/* Otherwise, this was not an interesting destination.  Continue\n-\t   on, marking uses as normal.  */\n-\treturn 0;\n-      }\n-\n-    case REG:\n-      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x))\n-\t  && REGNO (x) < ssa_max_reg_num)\n-\t{\n-\t  rtx new_reg = ssa_rename_to_lookup (x);\n-\n-\t  if (new_reg != RENAME_NO_RTX && new_reg != NULL_RTX)\n-\t    {\n-\t      if (GET_MODE (x) != GET_MODE (new_reg))\n-\t\tabort ();\n-\t      *ptr = new_reg;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Undefined value used, rename it to a new pseudo register so\n-\t\t that it cannot conflict with an existing register.  */\n-\t      *ptr = gen_reg_rtx (GET_MODE (x));\n-\t    }\n-\t}\n-      return -1;\n-\n-    case CLOBBER:\n-      /* There is considerable debate on how CLOBBERs ought to be\n-\t handled in SSA.  For now, we're keeping the CLOBBERs, which\n-\t means that we don't really have SSA form.  There are a couple\n-\t of proposals for how to fix this problem, but neither is\n-\t implemented yet.  */\n-      {\n-\trtx dest = XCEXP (x, 0, CLOBBER);\n-\tif (REG_P (dest))\n-\t  {\n-\t    if (CONVERT_REGISTER_TO_SSA_P (REGNO (dest))\n-\t\t&& REGNO (dest) < ssa_max_reg_num)\n-\t      {\n-\t\trtx new_reg = ssa_rename_to_lookup (dest);\n-\t\tif (new_reg != NULL_RTX && new_reg != RENAME_NO_RTX)\n-\t\t    XCEXP (x, 0, CLOBBER) = new_reg;\n-\t      }\n-\t    /* Stop traversing.  */\n-\t    return -1;\n-\t  }\n-\telse\n-\t  /* Continue traversing.  */\n-\t  return 0;\n-      }\n-\n-    case PHI:\n-      /* Never muck with the phi.  We do that elsewhere, special-like.  */\n-      return -1;\n-\n-    default:\n-      /* Anything else, continue traversing.  */\n-      return 0;\n-    }\n-}\n-\n-static rtx\n-gen_sequence (void)\n-{\n-  rtx first_insn = get_insns ();\n-  rtx result;\n-  rtx tem;\n-  int i;\n-  int len;\n-\n-  /* Count the insns in the chain.  */\n-  len = 0;\n-  for (tem = first_insn; tem; tem = NEXT_INSN (tem))\n-    len++;\n-\n-  result = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (len));\n-\n-  for (i = 0, tem = first_insn; tem; tem = NEXT_INSN (tem), i++)\n-    XVECEXP (result, 0, i) = tem;\n-\n-  return result;\n-}\n-\n-static void\n-rename_block (int bb, dominance_info idom)\n-{\n-  basic_block b = BASIC_BLOCK (bb);\n-  edge e;\n-  rtx insn, next, last;\n-  struct rename_set_data *set_data = NULL;\n-  basic_block c;\n-\n-  /* Step One: Walk the basic block, adding new names for sets and\n-     replacing uses.  */\n-\n-  next = b->head;\n-  last = b->end;\n-  do\n-    {\n-      insn = next;\n-      if (INSN_P (insn))\n-\t{\n-\t  struct rename_context context;\n-\t  context.done_renames = set_data;\n-\t  context.new_renames = NULL;\n-\t  context.current_insn = insn;\n-\n-\t  start_sequence ();\n-\t  for_each_rtx (&PATTERN (insn), rename_insn_1, &context);\n-\t  for_each_rtx (&REG_NOTES (insn), rename_insn_1, &context);\n-\n-\t  /* Sometimes, we end up with a sequence of insns that\n-\t     SSA needs to treat as a single insn.  Wrap these in a\n-\t     SEQUENCE.  (Any notes now get attached to the SEQUENCE,\n-\t     not to the old version inner insn.)  */\n-\t  if (get_insns () != NULL_RTX)\n-\t    {\n-\t      rtx seq;\n-\t      int i;\n-\n-\t      emit (PATTERN (insn));\n-\t      seq = gen_sequence ();\n-\t      /* We really want a SEQUENCE of SETs, not a SEQUENCE\n-\t\t of INSNs.  */\n-\t      for (i = 0; i < XVECLEN (seq, 0); i++)\n-\t\tXVECEXP (seq, 0, i) = PATTERN (XVECEXP (seq, 0, i));\n-\t      PATTERN (insn) = seq;\n-\t    }\n-\t  end_sequence ();\n-\n-\t  apply_delayed_renames (&context);\n-\t  set_data = context.done_renames;\n-\t}\n-\n-      next = NEXT_INSN (insn);\n-    }\n-  while (insn != last);\n-\n-  /* Step Two: Update the phi nodes of this block's successors.  */\n-\n-  for (e = b->succ; e; e = e->succ_next)\n-    {\n-      if (e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      insn = first_insn_after_basic_block_note (e->dest);\n-\n-      while (PHI_NODE_P (insn))\n-\t{\n-\t  rtx phi = PATTERN (insn);\n-\t  rtx reg;\n-\n-\t  /* Find out which of our outgoing registers this node is\n-\t     intended to replace.  Note that if this is not the first PHI\n-\t     node to have been created for this register, we have to\n-\t     jump through rename links to figure out which register\n-\t     we're talking about.  This can easily be recognized by\n-\t     noting that the regno is new to this pass.  */\n-\t  reg = SET_DEST (phi);\n-\t  if (REGNO (reg) >= ssa_max_reg_num)\n-\t    reg = ssa_rename_from_lookup (REGNO (reg));\n-\t  if (reg == NULL_RTX)\n-\t    abort ();\n-\t  reg = ssa_rename_to_lookup (reg);\n-\n-\t  /* It is possible for the variable to be uninitialized on\n-\t     edges in.  Reduce the arity of the PHI so that we don't\n-\t     consider those edges.  */\n-\t  if (reg == NULL || reg == RENAME_NO_RTX)\n-\t    {\n-\t      if (! remove_phi_alternative (phi, b))\n-\t\tabort ();\n-\t    }\n-\t  else\n-\t    {\n-\t      /* When we created the PHI nodes, we did not know what mode\n-\t\t the register should be.  Now that we've found an original,\n-\t\t we can fill that in.  */\n-\t      if (GET_MODE (SET_DEST (phi)) == VOIDmode)\n-\t\tPUT_MODE (SET_DEST (phi), GET_MODE (reg));\n-\t      else if (GET_MODE (SET_DEST (phi)) != GET_MODE (reg))\n-\t\tabort ();\n-\n-\t      *phi_alternative (phi, bb) = reg;\n-\t    }\n-\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  /* Step Three: Do the same to the children of this block in\n-     dominator order.  */\n-\n-  FOR_EACH_BB (c)\n-    if (get_immediate_dominator (idom, c)->index == bb)\n-      rename_block (c->index, idom);\n-\n-  /* Step Four: Update the sets to refer to their new register,\n-     and restore ssa_rename_to to its previous state.  */\n-\n-  while (set_data)\n-    {\n-      struct rename_set_data *next;\n-      rtx old_reg = *set_data->reg_loc;\n-\n-      if (*set_data->reg_loc != set_data->old_reg)\n-\tabort ();\n-      *set_data->reg_loc = set_data->new_reg;\n-\n-      ssa_rename_to_insert (old_reg, set_data->prev_reg);\n-\n-      next = set_data->next;\n-      free (set_data);\n-      set_data = next;\n-    }\n-}\n-\n-static void\n-rename_registers (int nregs, dominance_info idom)\n-{\n-  VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n-  ssa_rename_from_initialize ();\n-\n-  ssa_rename_to_pseudo = alloca (nregs * sizeof(rtx));\n-  memset (ssa_rename_to_pseudo, 0, nregs * sizeof(rtx));\n-  memset (ssa_rename_to_hard, 0,\n-\t  FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n-\n-  rename_block (0, idom);\n-\n-  /* ??? Update basic_block_live_at_start, and other flow info\n-     as needed.  */\n-\n-  ssa_rename_to_pseudo = NULL;\n-}\n-\n-/* The main entry point for moving to SSA.  */\n-\n-void\n-convert_to_ssa (void)\n-{\n-  /* Element I is the set of blocks that set register I.  */\n-  sbitmap *evals;\n-\n-  /* Dominator bitmaps.  */\n-  sbitmap *dfs;\n-  sbitmap *idfs;\n-\n-  /* Element I is the immediate dominator of block I.  */\n-  dominance_info idom;\n-\n-  int nregs;\n-\n-  basic_block bb;\n-\n-  /* Don't do it twice.  */\n-  if (in_ssa_form)\n-    abort ();\n-\n-  /* Need global_live_at_{start,end} up to date.  Do not remove any\n-     dead code.  We'll let the SSA optimizers do that.  */\n-  life_analysis (get_insns (), NULL, 0);\n-\n-  idom = calculate_dominance_info (CDI_DOMINATORS);\n-\n-  if (rtl_dump_file)\n-    {\n-      fputs (\";; Immediate Dominators:\\n\", rtl_dump_file);\n-      FOR_EACH_BB (bb)\n-\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", bb->index,\n-\t\t get_immediate_dominator (idom, bb)->index);\n-      fflush (rtl_dump_file);\n-    }\n-\n-  /* Compute dominance frontiers.  */\n-\n-  dfs = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  compute_dominance_frontiers (dfs, idom);\n-\n-  if (rtl_dump_file)\n-    {\n-      dump_sbitmap_vector (rtl_dump_file, \";; Dominance Frontiers:\",\n-\t\t\t   \"; Basic Block\", dfs, last_basic_block);\n-      fflush (rtl_dump_file);\n-    }\n-\n-  /* Compute register evaluations.  */\n-\n-  ssa_max_reg_num = max_reg_num ();\n-  nregs = ssa_max_reg_num;\n-  evals = sbitmap_vector_alloc (nregs, last_basic_block);\n-  find_evaluations (evals, nregs);\n-\n-  /* Compute the iterated dominance frontier for each register.  */\n-\n-  idfs = sbitmap_vector_alloc (nregs, last_basic_block);\n-  compute_iterated_dominance_frontiers (idfs, dfs, evals, nregs);\n-\n-  if (rtl_dump_file)\n-    {\n-      dump_sbitmap_vector (rtl_dump_file, \";; Iterated Dominance Frontiers:\",\n-\t\t\t   \"; Register\", idfs, nregs);\n-      fflush (rtl_dump_file);\n-    }\n-\n-  /* Insert the phi nodes.  */\n-\n-  insert_phi_nodes (idfs, evals, nregs);\n-\n-  /* Rename the registers to satisfy SSA.  */\n-\n-  rename_registers (nregs, idom);\n-\n-  /* All done!  Clean up and go home.  */\n-\n-  sbitmap_vector_free (dfs);\n-  sbitmap_vector_free (evals);\n-  sbitmap_vector_free (idfs);\n-  in_ssa_form = 1;\n-\n-  reg_scan (get_insns (), max_reg_num (), 1);\n-  free_dominance_info (idom);\n-}\n-\n-/* REG is the representative temporary of its partition.  Add it to the\n-   set of nodes to be processed, if it hasn't been already.  Return the\n-   index of this register in the node set.  */\n-\n-static inline int\n-ephi_add_node (rtx reg, rtx *nodes, int *n_nodes)\n-{\n-  int i;\n-  for (i = *n_nodes - 1; i >= 0; --i)\n-    if (REGNO (reg) == REGNO (nodes[i]))\n-      return i;\n-\n-  nodes[i = (*n_nodes)++] = reg;\n-  return i;\n-}\n-\n-/* Part one of the topological sort.  This is a forward (downward) search\n-   through the graph collecting a stack of nodes to process.  Assuming no\n-   cycles, the nodes at top of the stack when we are finished will have\n-   no other dependencies.  */\n-\n-static int *\n-ephi_forward (int t, sbitmap visited, sbitmap *succ, int *tstack)\n-{\n-  int s;\n-\n-  SET_BIT (visited, t);\n-\n-  EXECUTE_IF_SET_IN_SBITMAP (succ[t], 0, s,\n-    {\n-      if (! TEST_BIT (visited, s))\n-\ttstack = ephi_forward (s, visited, succ, tstack);\n-    });\n-\n-  *tstack++ = t;\n-  return tstack;\n-}\n-\n-/* Part two of the topological sort.  The is a backward search through\n-   a cycle in the graph, copying the data forward as we go.  */\n-\n-static void\n-ephi_backward (int t, sbitmap visited, sbitmap *pred, rtx *nodes)\n-{\n-  int p;\n-\n-  SET_BIT (visited, t);\n-\n-  EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n-    {\n-      if (! TEST_BIT (visited, p))\n-\t{\n-\t  ephi_backward (p, visited, pred, nodes);\n-\t  emit_move_insn (nodes[p], nodes[t]);\n-\t}\n-    });\n-}\n-\n-/* Part two of the topological sort.  Create the copy for a register\n-   and any cycle of which it is a member.  */\n-\n-static void\n-ephi_create (int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes)\n-{\n-  rtx reg_u = NULL_RTX;\n-  int unvisited_predecessors = 0;\n-  int p;\n-\n-  /* Iterate through the predecessor list looking for unvisited nodes.\n-     If there are any, we have a cycle, and must deal with that.  At\n-     the same time, look for a visited predecessor.  If there is one,\n-     we won't need to create a temporary.  */\n-\n-  EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n-    {\n-      if (! TEST_BIT (visited, p))\n-\tunvisited_predecessors = 1;\n-      else if (!reg_u)\n-\treg_u = nodes[p];\n-    });\n-\n-  if (unvisited_predecessors)\n-    {\n-      /* We found a cycle.  Copy out one element of the ring (if necessary),\n-\t then traverse the ring copying as we go.  */\n-\n-      if (!reg_u)\n-\t{\n-\t  reg_u = gen_reg_rtx (GET_MODE (nodes[t]));\n-\t  emit_move_insn (reg_u, nodes[t]);\n-\t}\n-\n-      EXECUTE_IF_SET_IN_SBITMAP (pred[t], 0, p,\n-\t{\n-\t  if (! TEST_BIT (visited, p))\n-\t    {\n-\t      ephi_backward (p, visited, pred, nodes);\n-\t      emit_move_insn (nodes[p], reg_u);\n-\t    }\n-\t});\n-    }\n-  else\n-    {\n-      /* No cycle.  Just copy the value from a successor.  */\n-\n-      int s;\n-      EXECUTE_IF_SET_IN_SBITMAP (succ[t], 0, s,\n-\t{\n-\t  SET_BIT (visited, t);\n-\t  emit_move_insn (nodes[t], nodes[s]);\n-\t  return;\n-\t});\n-    }\n-}\n-\n-/* Convert the edge to normal form.  */\n-\n-static void\n-eliminate_phi (edge e, partition reg_partition)\n-{\n-  int n_nodes;\n-  sbitmap *pred, *succ;\n-  sbitmap visited;\n-  rtx *nodes;\n-  int *stack, *tstack;\n-  rtx insn;\n-  int i;\n-\n-  /* Collect an upper bound on the number of registers needing processing.  */\n-\n-  insn = first_insn_after_basic_block_note (e->dest);\n-\n-  n_nodes = 0;\n-  while (PHI_NODE_P (insn))\n-    {\n-      insn = next_nonnote_insn (insn);\n-      n_nodes += 2;\n-    }\n-\n-  if (n_nodes == 0)\n-    return;\n-\n-  /* Build the auxiliary graph R(B).\n-\n-     The nodes of the graph are the members of the register partition\n-     present in Phi(B).  There is an edge from FIND(T0)->FIND(T1) for\n-     each T0 = PHI(...,T1,...), where T1 is for the edge from block C.  */\n-\n-  nodes = alloca (n_nodes * sizeof(rtx));\n-  pred = sbitmap_vector_alloc (n_nodes, n_nodes);\n-  succ = sbitmap_vector_alloc (n_nodes, n_nodes);\n-  sbitmap_vector_zero (pred, n_nodes);\n-  sbitmap_vector_zero (succ, n_nodes);\n-\n-  insn = first_insn_after_basic_block_note (e->dest);\n-\n-  n_nodes = 0;\n-  for (; PHI_NODE_P (insn); insn = next_nonnote_insn (insn))\n-    {\n-      rtx* preg = phi_alternative (PATTERN (insn), e->src->index);\n-      rtx tgt = SET_DEST (PATTERN (insn));\n-      rtx reg;\n-\n-      /* There may be no phi alternative corresponding to this edge.\n-\t This indicates that the phi variable is undefined along this\n-\t edge.  */\n-      if (preg == NULL)\n-\tcontinue;\n-      reg = *preg;\n-\n-      if (GET_CODE (reg) != REG || GET_CODE (tgt) != REG)\n-\tabort ();\n-\n-      reg = regno_reg_rtx[partition_find (reg_partition, REGNO (reg))];\n-      tgt = regno_reg_rtx[partition_find (reg_partition, REGNO (tgt))];\n-      /* If the two registers are already in the same partition,\n-\t nothing will need to be done.  */\n-      if (reg != tgt)\n-\t{\n-\t  int ireg, itgt;\n-\n-\t  ireg = ephi_add_node (reg, nodes, &n_nodes);\n-\t  itgt = ephi_add_node (tgt, nodes, &n_nodes);\n-\n-\t  SET_BIT (pred[ireg], itgt);\n-\t  SET_BIT (succ[itgt], ireg);\n-\t}\n-    }\n-\n-  if (n_nodes == 0)\n-    goto out;\n-\n-  /* Begin a topological sort of the graph.  */\n-\n-  visited = sbitmap_alloc (n_nodes);\n-  sbitmap_zero (visited);\n-\n-  tstack = stack = alloca (n_nodes * sizeof (int));\n-\n-  for (i = 0; i < n_nodes; ++i)\n-    if (! TEST_BIT (visited, i))\n-      tstack = ephi_forward (i, visited, succ, tstack);\n-\n-  sbitmap_zero (visited);\n-\n-  /* As we find a solution to the tsort, collect the implementation\n-     insns in a sequence.  */\n-  start_sequence ();\n-\n-  while (tstack != stack)\n-    {\n-      i = *--tstack;\n-      if (! TEST_BIT (visited, i))\n-\tephi_create (i, visited, pred, succ, nodes);\n-    }\n-\n-  insn = get_insns ();\n-  end_sequence ();\n-  insert_insn_on_edge (insn, e);\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Emitting copy on edge (%d,%d)\\n\",\n-\t     e->src->index, e->dest->index);\n-\n-  sbitmap_free (visited);\n-out:\n-  sbitmap_vector_free (pred);\n-  sbitmap_vector_free (succ);\n-}\n-\n-/* For basic block B, consider all phi insns which provide an\n-   alternative corresponding to an incoming abnormal critical edge.\n-   Place the phi alternative corresponding to that abnormal critical\n-   edge in the same register class as the destination of the set.\n-\n-   From Morgan, p. 178:\n-\n-     For each abnormal critical edge (C, B),\n-     if T0 = phi (T1, ..., Ti, ..., Tm) is a phi node in B,\n-     and C is the ith predecessor of B,\n-     then T0 and Ti must be equivalent.\n-\n-   Return nonzero iff any such cases were found for which the two\n-   regs were not already in the same class.  */\n-\n-static int\n-make_regs_equivalent_over_bad_edges (int bb, partition reg_partition)\n-{\n-  int changed = 0;\n-  basic_block b = BASIC_BLOCK (bb);\n-  rtx phi;\n-\n-  /* Advance to the first phi node.  */\n-  phi = first_insn_after_basic_block_note (b);\n-\n-  /* Scan all the phi nodes.  */\n-  for (;\n-       PHI_NODE_P (phi);\n-       phi = next_nonnote_insn (phi))\n-    {\n-      edge e;\n-      int tgt_regno;\n-      rtx set = PATTERN (phi);\n-      rtx tgt = SET_DEST (set);\n-\n-      /* The set target is expected to be an SSA register.  */\n-      if (GET_CODE (tgt) != REG\n-\t  || !CONVERT_REGISTER_TO_SSA_P (REGNO (tgt)))\n-\tabort ();\n-      tgt_regno = REGNO (tgt);\n-\n-      /* Scan incoming abnormal critical edges.  */\n-      for (e = b->pred; e; e = e->pred_next)\n-\tif ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n-\t  {\n-\t    rtx *alt = phi_alternative (set, e->src->index);\n-\t    int alt_regno;\n-\n-\t    /* If there is no alternative corresponding to this edge,\n-\t       the value is undefined along the edge, so just go on.  */\n-\t    if (alt == 0)\n-\t      continue;\n-\n-\t    /* The phi alternative is expected to be an SSA register.  */\n-\t    if (GET_CODE (*alt) != REG\n-\t\t|| !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt)))\n-\t      abort ();\n-\t    alt_regno = REGNO (*alt);\n-\n-\t    /* If the set destination and the phi alternative aren't\n-\t       already in the same class...  */\n-\t    if (partition_find (reg_partition, tgt_regno)\n-\t\t!= partition_find (reg_partition, alt_regno))\n-\t      {\n-\t\t/* ... make them such.  */\n-\t\tif (conflicting_hard_regs_p (tgt_regno, alt_regno))\n-\t\t  /* It is illegal to unify a hard register with a\n-\t\t     different register.  */\n-\t\t  abort ();\n-\n-\t\tpartition_union (reg_partition,\n-\t\t\t\t tgt_regno, alt_regno);\n-\t\t++changed;\n-\t      }\n-\t  }\n-    }\n-\n-  return changed;\n-}\n-\n-/* Consider phi insns in basic block BB pairwise.  If the set target\n-   of both insns are equivalent pseudos, make the corresponding phi\n-   alternatives in each phi corresponding equivalent.\n-\n-   Return nonzero if any new register classes were unioned.  */\n-\n-static int\n-make_equivalent_phi_alternatives_equivalent (int bb, partition reg_partition)\n-{\n-  int changed = 0;\n-  basic_block b = BASIC_BLOCK (bb);\n-  rtx phi;\n-\n-  /* Advance to the first phi node.  */\n-  phi = first_insn_after_basic_block_note (b);\n-\n-  /* Scan all the phi nodes.  */\n-  for (;\n-       PHI_NODE_P (phi);\n-       phi = next_nonnote_insn (phi))\n-    {\n-      rtx set = PATTERN (phi);\n-      /* The regno of the destination of the set.  */\n-      int tgt_regno = REGNO (SET_DEST (PATTERN (phi)));\n-\n-      rtx phi2 = next_nonnote_insn (phi);\n-\n-      /* Scan all phi nodes following this one.  */\n-      for (;\n-\t   PHI_NODE_P (phi2);\n-\t   phi2 = next_nonnote_insn (phi2))\n-\t{\n-\t  rtx set2 = PATTERN (phi2);\n-\t  /* The regno of the destination of the set.  */\n-\t  int tgt2_regno = REGNO (SET_DEST (set2));\n-\n-\t  /* Are the set destinations equivalent regs?  */\n-\t  if (partition_find (reg_partition, tgt_regno) ==\n-\t      partition_find (reg_partition, tgt2_regno))\n-\t    {\n-\t      edge e;\n-\t      /* Scan over edges.  */\n-\t      for (e = b->pred; e; e = e->pred_next)\n-\t\t{\n-\t\t  int pred_block = e->src->index;\n-\t\t  /* Identify the phi alternatives from both phi\n-\t\t     nodes corresponding to this edge.  */\n-\t\t  rtx *alt = phi_alternative (set, pred_block);\n-\t\t  rtx *alt2 = phi_alternative (set2, pred_block);\n-\n-\t\t  /* If one of the phi nodes doesn't have a\n-\t\t     corresponding alternative, just skip it.  */\n-\t\t  if (alt == 0 || alt2 == 0)\n-\t\t    continue;\n-\n-\t\t  /* Both alternatives should be SSA registers.  */\n-\t\t  if (GET_CODE (*alt) != REG\n-\t\t      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt)))\n-\t\t    abort ();\n-\t\t  if (GET_CODE (*alt2) != REG\n-\t\t      || !CONVERT_REGISTER_TO_SSA_P (REGNO (*alt2)))\n-\t\t    abort ();\n-\n-\t\t  /* If the alternatives aren't already in the same\n-\t\t     class ...  */\n-\t\t  if (partition_find (reg_partition, REGNO (*alt))\n-\t\t      != partition_find (reg_partition, REGNO (*alt2)))\n-\t\t    {\n-\t\t      /* ... make them so.  */\n-\t\t      if (conflicting_hard_regs_p (REGNO (*alt), REGNO (*alt2)))\n-\t\t\t/* It is illegal to unify a hard register with\n-\t\t\t   a different register.  */\n-\t\t\tabort ();\n-\n-\t\t      partition_union (reg_partition,\n-\t\t\t\t       REGNO (*alt), REGNO (*alt2));\n-\t\t      ++changed;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  return changed;\n-}\n-\n-/* Compute a conservative partition of outstanding pseudo registers.\n-   See Morgan 7.3.1.  */\n-\n-static partition\n-compute_conservative_reg_partition (void)\n-{\n-  basic_block bb;\n-  int changed = 0;\n-\n-  /* We don't actually work with hard registers, but it's easier to\n-     carry them around anyway rather than constantly doing register\n-     number arithmetic.  */\n-  partition p =\n-    partition_new (ssa_definition->num_elements);\n-\n-  /* The first priority is to make sure registers that might have to\n-     be copied on abnormal critical edges are placed in the same\n-     partition.  This saves us from having to split abnormal critical\n-     edges.  */\n-  FOR_EACH_BB_REVERSE (bb)\n-    changed += make_regs_equivalent_over_bad_edges (bb->index, p);\n-\n-  /* Now we have to insure that corresponding arguments of phi nodes\n-     assigning to corresponding regs are equivalent.  Iterate until\n-     nothing changes.  */\n-  while (changed > 0)\n-    {\n-      changed = 0;\n-      FOR_EACH_BB_REVERSE (bb)\n-\tchanged += make_equivalent_phi_alternatives_equivalent (bb->index, p);\n-    }\n-\n-  return p;\n-}\n-\n-/* The following functions compute a register partition that attempts\n-   to eliminate as many reg copies and phi node copies as possible by\n-   coalescing registers.   This is the strategy:\n-\n-    1. As in the conservative case, the top priority is to coalesce\n-       registers that otherwise would cause copies to be placed on\n-       abnormal critical edges (which isn't possible).\n-\n-    2. Figure out which regs are involved (in the LHS or RHS) of\n-       copies and phi nodes.  Compute conflicts among these regs.\n-\n-    3. Walk around the instruction stream, placing two regs in the\n-       same class of the partition if one appears on the LHS and the\n-       other on the RHS of a copy or phi node and the two regs don't\n-       conflict.  The conflict information of course needs to be\n-       updated.\n-\n-    4. If anything has changed, there may be new opportunities to\n-       coalesce regs, so go back to 2.\n-*/\n-\n-/* If REG1 and REG2 don't conflict in CONFLICTS, place them in the\n-   same class of partition P, if they aren't already.  Update\n-   CONFLICTS appropriately.\n-\n-   Returns one if REG1 and REG2 were placed in the same class but were\n-   not previously; zero otherwise.\n-\n-   See Morgan figure 11.15.  */\n-\n-static int\n-coalesce_if_unconflicting (partition p, conflict_graph conflicts,\n-\t\t\t   int reg1, int reg2)\n-{\n-  int reg;\n-\n-  /* Work only on SSA registers.  */\n-  if (!CONVERT_REGISTER_TO_SSA_P (reg1) || !CONVERT_REGISTER_TO_SSA_P (reg2))\n-    return 0;\n-\n-  /* Find the canonical regs for the classes containing REG1 and\n-     REG2.  */\n-  reg1 = partition_find (p, reg1);\n-  reg2 = partition_find (p, reg2);\n-\n-  /* If they're already in the same class, there's nothing to do.  */\n-  if (reg1 == reg2)\n-    return 0;\n-\n-  /* If the regs conflict, our hands are tied.  */\n-  if (conflicting_hard_regs_p (reg1, reg2) ||\n-      conflict_graph_conflict_p (conflicts, reg1, reg2))\n-    return 0;\n-\n-  /* We're good to go.  Put the regs in the same partition.  */\n-  partition_union (p, reg1, reg2);\n-\n-  /* Find the new canonical reg for the merged class.  */\n-  reg = partition_find (p, reg1);\n-\n-  /* Merge conflicts from the two previous classes.  */\n-  conflict_graph_merge_regs (conflicts, reg, reg1);\n-  conflict_graph_merge_regs (conflicts, reg, reg2);\n-\n-  return 1;\n-}\n-\n-/* For each register copy insn in basic block BB, place the LHS and\n-   RHS regs in the same class in partition P if they do not conflict\n-   according to CONFLICTS.\n-\n-   Returns the number of changes that were made to P.\n-\n-   See Morgan figure 11.14.  */\n-\n-static int\n-coalesce_regs_in_copies (basic_block bb, partition p, conflict_graph conflicts)\n-{\n-  int changed = 0;\n-  rtx insn;\n-  rtx end = bb->end;\n-\n-  /* Scan the instruction stream of the block.  */\n-  for (insn = bb->head; insn != end; insn = NEXT_INSN (insn))\n-    {\n-      rtx pattern;\n-      rtx src;\n-      rtx dest;\n-\n-      /* If this isn't a set insn, go to the next insn.  */\n-      if (GET_CODE (insn) != INSN)\n-\tcontinue;\n-      pattern = PATTERN (insn);\n-      if (GET_CODE (pattern) != SET)\n-\tcontinue;\n-\n-      src = SET_SRC (pattern);\n-      dest = SET_DEST (pattern);\n-\n-      /* We're only looking for copies.  */\n-      if (GET_CODE (src) != REG || GET_CODE (dest) != REG)\n-\tcontinue;\n-\n-      /* Coalesce only if the reg modes are the same.  As long as\n-\t each reg's rtx is unique, it can have only one mode, so two\n-\t pseudos of different modes can't be coalesced into one.\n-\n-         FIXME: We can probably get around this by inserting SUBREGs\n-         where appropriate, but for now we don't bother.  */\n-      if (GET_MODE (src) != GET_MODE (dest))\n-\tcontinue;\n-\n-      /* Found a copy; see if we can use the same reg for both the\n-\t source and destination (and thus eliminate the copy,\n-\t ultimately).  */\n-      changed += coalesce_if_unconflicting (p, conflicts,\n-\t\t\t\t\t    REGNO (src), REGNO (dest));\n-    }\n-\n-  return changed;\n-}\n-\n-struct phi_coalesce_context\n-{\n-  partition p;\n-  conflict_graph conflicts;\n-  int changed;\n-};\n-\n-/* Callback function for for_each_successor_phi.  If the set\n-   destination and the phi alternative regs do not conflict, place\n-   them in the same partition class.  DATA is a pointer to a\n-   phi_coalesce_context struct.  */\n-\n-static int\n-coalesce_reg_in_phi (rtx insn ATTRIBUTE_UNUSED, int dest_regno,\n-\t\t     int src_regno, void *data)\n-{\n-  struct phi_coalesce_context *context =\n-    (struct phi_coalesce_context *) data;\n-\n-  /* Attempt to use the same reg, if they don't conflict.  */\n-  context->changed\n-    += coalesce_if_unconflicting (context->p, context->conflicts,\n-\t\t\t\t  dest_regno, src_regno);\n-  return 0;\n-}\n-\n-/* For each alternative in a phi function corresponding to basic block\n-   BB (in phi nodes in successor block to BB), place the reg in the\n-   phi alternative and the reg to which the phi value is set into the\n-   same class in partition P, if allowed by CONFLICTS.\n-\n-   Return the number of changes that were made to P.\n-\n-   See Morgan figure 11.14.  */\n-\n-static int\n-coalesce_regs_in_successor_phi_nodes (basic_block bb, partition p,\n-\t\t\t\t      conflict_graph conflicts)\n-{\n-  struct phi_coalesce_context context;\n-  context.p = p;\n-  context.conflicts = conflicts;\n-  context.changed = 0;\n-\n-  for_each_successor_phi (bb, &coalesce_reg_in_phi, &context);\n-\n-  return context.changed;\n-}\n-\n-/* Compute and return a partition of pseudos.  Where possible,\n-   non-conflicting pseudos are placed in the same class.\n-\n-   The caller is responsible for deallocating the returned partition.  */\n-\n-static partition\n-compute_coalesced_reg_partition (void)\n-{\n-  basic_block bb;\n-  int changed = 0;\n-  regset_head phi_set_head;\n-  regset phi_set = &phi_set_head;\n-\n-  partition p =\n-    partition_new (ssa_definition->num_elements);\n-\n-  /* The first priority is to make sure registers that might have to\n-     be copied on abnormal critical edges are placed in the same\n-     partition.  This saves us from having to split abnormal critical\n-     edges (which can't be done).  */\n-  FOR_EACH_BB_REVERSE (bb)\n-    make_regs_equivalent_over_bad_edges (bb->index, p);\n-\n-  INIT_REG_SET (phi_set);\n-\n-  do\n-    {\n-      conflict_graph conflicts;\n-\n-      changed = 0;\n-\n-      /* Build the set of registers involved in phi nodes, either as\n-\t arguments to the phi function or as the target of a set.  */\n-      CLEAR_REG_SET (phi_set);\n-      mark_phi_and_copy_regs (phi_set);\n-\n-      /* Compute conflicts.  */\n-      conflicts = conflict_graph_compute (phi_set, p);\n-\n-      /* FIXME: Better would be to process most frequently executed\n-\t blocks first, so that most frequently executed copies would\n-\t be more likely to be removed by register coalescing.  But any\n-\t order will generate correct, if non-optimal, results.  */\n-      FOR_EACH_BB_REVERSE (bb)\n-\t{\n-\t  changed += coalesce_regs_in_copies (bb, p, conflicts);\n-\t  changed +=\n-\t    coalesce_regs_in_successor_phi_nodes (bb, p, conflicts);\n-\t}\n-\n-      conflict_graph_delete (conflicts);\n-    }\n-  while (changed > 0);\n-\n-  FREE_REG_SET (phi_set);\n-\n-  return p;\n-}\n-\n-/* Mark the regs in a phi node.  PTR is a phi expression or one of its\n-   components (a REG or a CONST_INT).  DATA is a reg set in which to\n-   set all regs.  Called from for_each_rtx.  */\n-\n-static int\n-mark_reg_in_phi (rtx *ptr, void *data)\n-{\n-  rtx expr = *ptr;\n-  regset set = (regset) data;\n-\n-  switch (GET_CODE (expr))\n-    {\n-    case REG:\n-      SET_REGNO_REG_SET (set, REGNO (expr));\n-      /* Fall through.  */\n-    case CONST_INT:\n-    case PHI:\n-      return 0;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Mark in PHI_SET all pseudos that are used in a phi node -- either\n-   set from a phi expression, or used as an argument in one.  Also\n-   mark regs that are the source or target of a reg copy.  Uses\n-   ssa_definition.  */\n-\n-static void\n-mark_phi_and_copy_regs (regset phi_set)\n-{\n-  unsigned int reg;\n-\n-  /* Scan the definitions of all regs.  */\n-  for (reg = 0; reg < VARRAY_SIZE (ssa_definition); ++reg)\n-    if (CONVERT_REGISTER_TO_SSA_P (reg))\n-      {\n-\trtx insn = VARRAY_RTX (ssa_definition, reg);\n-\trtx pattern;\n-\trtx src;\n-\n-\tif (insn == NULL\n-\t    || (GET_CODE (insn) == NOTE\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED))\n-\t  continue;\n-\tpattern = PATTERN (insn);\n-\t/* Sometimes we get PARALLEL insns.  These aren't phi nodes or\n-\t   copies.  */\n-\tif (GET_CODE (pattern) != SET)\n-\t  continue;\n-\tsrc = SET_SRC (pattern);\n-\n-\tif (GET_CODE (src) == REG)\n-\t  {\n-\t    /* It's a reg copy.  */\n-\t    SET_REGNO_REG_SET (phi_set, reg);\n-\t    SET_REGNO_REG_SET (phi_set, REGNO (src));\n-\t  }\n-\telse if (GET_CODE (src) == PHI)\n-\t  {\n-\t    /* It's a phi node.  Mark the reg being set.  */\n-\t    SET_REGNO_REG_SET (phi_set, reg);\n-\t    /* Mark the regs used in the phi function.  */\n-\t    for_each_rtx (&src, mark_reg_in_phi, phi_set);\n-\t  }\n-\t/* ... else nothing to do.  */\n-      }\n-}\n-\n-/* Rename regs in insn PTR that are equivalent.  DATA is the register\n-   partition which specifies equivalences.  */\n-\n-static int\n-rename_equivalent_regs_in_insn (rtx *ptr, void* data)\n-{\n-  rtx x = *ptr;\n-  partition reg_partition = (partition) data;\n-\n-  if (x == NULL_RTX)\n-    return 0;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)))\n-\t{\n-\t  unsigned int regno = REGNO (x);\n-\t  unsigned int new_regno = partition_find (reg_partition, regno);\n-\t  rtx canonical_element_rtx = ssa_rename_from_lookup (new_regno);\n-\n-\t  if (canonical_element_rtx != NULL_RTX &&\n-\t      HARD_REGISTER_P (canonical_element_rtx))\n-\t    {\n-\t      if (REGNO (canonical_element_rtx) != regno)\n-\t\t*ptr = canonical_element_rtx;\n-\t    }\n-\t  else if (regno != new_regno)\n-\t    {\n-\t      rtx new_reg = regno_reg_rtx[new_regno];\n-\t      if (GET_MODE (x) != GET_MODE (new_reg))\n-\t\tabort ();\n-\t      *ptr = new_reg;\n-\t    }\n-\t}\n-      return -1;\n-\n-    case PHI:\n-      /* No need to rename the phi nodes.  We'll check equivalence\n-\t when inserting copies.  */\n-      return -1;\n-\n-    default:\n-      /* Anything else, continue traversing.  */\n-      return 0;\n-    }\n-}\n-\n-/* Record the register's canonical element stored in SRFP in the\n-   canonical_elements sbitmap packaged in DATA.  This function is used\n-   as a callback function for traversing ssa_rename_from.  */\n-\n-static int\n-record_canonical_element_1 (void **srfp, void *data)\n-{\n-  unsigned int reg = ((ssa_rename_from_pair *) *srfp)->reg;\n-  sbitmap canonical_elements =\n-    ((struct ssa_rename_from_hash_table_data *) data)->canonical_elements;\n-  partition reg_partition =\n-    ((struct ssa_rename_from_hash_table_data *) data)->reg_partition;\n-\n-  SET_BIT (canonical_elements, partition_find (reg_partition, reg));\n-  return 1;\n-}\n-\n-/* For each class in the REG_PARTITION corresponding to a particular\n-   hard register and machine mode, check that there are no other\n-   classes with the same hard register and machine mode.  Returns\n-   nonzero if this is the case, i.e., the partition is acceptable.  */\n-\n-static int\n-check_hard_regs_in_partition (partition reg_partition)\n-{\n-  /* CANONICAL_ELEMENTS has a nonzero bit if a class with the given register\n-     number and machine mode has already been seen.  This is a\n-     problem with the partition.  */\n-  sbitmap canonical_elements;\n-  int element_index;\n-  int already_seen[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n-  int reg;\n-  int mach_mode;\n-\n-  /* Collect a list of canonical elements.  */\n-  canonical_elements = sbitmap_alloc (max_reg_num ());\n-  sbitmap_zero (canonical_elements);\n-  ssa_rename_from_traverse (&record_canonical_element_1,\n-\t\t\t    canonical_elements, reg_partition);\n-\n-  /* We have not seen any hard register uses.  */\n-  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; ++reg)\n-    for (mach_mode = 0; mach_mode < NUM_MACHINE_MODES; ++mach_mode)\n-      already_seen[reg][mach_mode] = 0;\n-\n-  /* Check for classes with the same hard register and machine mode.  */\n-  EXECUTE_IF_SET_IN_SBITMAP (canonical_elements, 0, element_index,\n-  {\n-    rtx hard_reg_rtx = ssa_rename_from_lookup (element_index);\n-    if (hard_reg_rtx != NULL_RTX &&\n-\tHARD_REGISTER_P (hard_reg_rtx) &&\n-\talready_seen[REGNO (hard_reg_rtx)][GET_MODE (hard_reg_rtx)] != 0)\n-\t  /* Two distinct partition classes should be mapped to the same\n-\t     hard register.  */\n-\t  return 0;\n-  });\n-\n-  sbitmap_free (canonical_elements);\n-\n-  return 1;\n-}\n-\n-/* Rename regs that are equivalent in REG_PARTITION.  Also collapse\n-   any SEQUENCE insns.  */\n-\n-static void\n-rename_equivalent_regs (partition reg_partition)\n-{\n-  basic_block b;\n-\n-  FOR_EACH_BB_REVERSE (b)\n-    {\n-      rtx next = b->head;\n-      rtx last = b->end;\n-      rtx insn;\n-\n-      do\n-\t{\n-\t  insn = next;\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      for_each_rtx (&PATTERN (insn),\n-\t\t\t    rename_equivalent_regs_in_insn,\n-\t\t\t    reg_partition);\n-\t      for_each_rtx (&REG_NOTES (insn),\n-\t\t\t    rename_equivalent_regs_in_insn,\n-\t\t\t    reg_partition);\n-\n-\t      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t\t{\n-\t\t  rtx s = PATTERN (insn);\n-\t\t  int slen = XVECLEN (s, 0);\n-\t\t  int i;\n-\n-\t\t  if (slen <= 1)\n-\t\t    abort ();\n-\n-\t\t  PATTERN (insn) = XVECEXP (s, 0, slen-1);\n-\t\t  for (i = 0; i < slen - 1; i++)\n-\t\t    emit_insn_before (XVECEXP (s, 0, i), insn);\n-\t\t}\n-\t    }\n-\n-\t  next = NEXT_INSN (insn);\n-\t}\n-      while (insn != last);\n-    }\n-}\n-\n-/* The main entry point for moving from SSA.  */\n-\n-void\n-convert_from_ssa (void)\n-{\n-  basic_block b, bb;\n-  partition reg_partition;\n-  rtx insns = get_insns ();\n-\n-  /* Need global_live_at_{start,end} up to date.  There should not be\n-     any significant dead code at this point, except perhaps dead\n-     stores.  So do not take the time to perform dead code elimination.\n-\n-     Register coalescing needs death notes, so generate them.  */\n-  life_analysis (insns, NULL, PROP_DEATH_NOTES);\n-\n-  /* Figure out which regs in copies and phi nodes don't conflict and\n-     therefore can be coalesced.  */\n-  if (conservative_reg_partition)\n-    reg_partition = compute_conservative_reg_partition ();\n-  else\n-    reg_partition = compute_coalesced_reg_partition ();\n-\n-  if (!check_hard_regs_in_partition (reg_partition))\n-    /* Two separate partitions should correspond to the same hard\n-       register but do not.  */\n-    abort ();\n-\n-  rename_equivalent_regs (reg_partition);\n-\n-  /* Eliminate the PHI nodes.  */\n-  FOR_EACH_BB_REVERSE (b)\n-    {\n-      edge e;\n-\n-      for (e = b->pred; e; e = e->pred_next)\n-\tif (e->src != ENTRY_BLOCK_PTR)\n-\t  eliminate_phi (e, reg_partition);\n-    }\n-\n-  partition_delete (reg_partition);\n-\n-  /* Actually delete the PHI nodes.  */\n-  FOR_EACH_BB_REVERSE (bb)\n-    {\n-      rtx insn = bb->head;\n-\n-      while (1)\n-\t{\n-\t  /* If this is a PHI node delete it.  */\n-\t  if (PHI_NODE_P (insn))\n-\t    {\n-\t      if (insn == bb->end)\n-\t\tbb->end = PREV_INSN (insn);\n-\t      insn = delete_insn (insn);\n-\t    }\n-\t  /* Since all the phi nodes come at the beginning of the\n-\t     block, if we find an ordinary insn, we can stop looking\n-\t     for more phi nodes.  */\n-\t  else if (INSN_P (insn))\n-\t    break;\n-\t  /* If we've reached the end of the block, stop.  */\n-\t  else if (insn == bb->end)\n-\t    break;\n-\t  else\n-\t    insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  /* Commit all the copy nodes needed to convert out of SSA form.  */\n-  commit_edge_insertions ();\n-\n-  in_ssa_form = 0;\n-\n-  count_or_remove_death_notes (NULL, 1);\n-\n-  /* Deallocate the data structures.  */\n-  ssa_definition = 0;\n-  ssa_rename_from_free ();\n-}\n-\n-/* Scan phi nodes in successors to BB.  For each such phi node that\n-   has a phi alternative value corresponding to BB, invoke FN.  FN\n-   is passed the entire phi node insn, the regno of the set\n-   destination, the regno of the phi argument corresponding to BB,\n-   and DATA.\n-\n-   If FN ever returns nonzero, stops immediately and returns this\n-   value.  Otherwise, returns zero.  */\n-\n-int\n-for_each_successor_phi (basic_block bb, successor_phi_fn fn, void *data)\n-{\n-  edge e;\n-\n-  if (bb == EXIT_BLOCK_PTR)\n-    return 0;\n-\n-  /* Scan outgoing edges.  */\n-  for (e = bb->succ; e != NULL; e = e->succ_next)\n-    {\n-      rtx insn;\n-\n-      basic_block successor = e->dest;\n-      if (successor == ENTRY_BLOCK_PTR\n-\t  || successor == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      /* Advance to the first non-label insn of the successor block.  */\n-      insn = first_insn_after_basic_block_note (successor);\n-\n-      if (insn == NULL)\n-\tcontinue;\n-\n-      /* Scan phi nodes in the successor.  */\n-      for ( ; PHI_NODE_P (insn); insn = NEXT_INSN (insn))\n-\t{\n-\t  int result;\n-\t  rtx phi_set = PATTERN (insn);\n-\t  rtx *alternative = phi_alternative (phi_set, bb->index);\n-\t  rtx phi_src;\n-\n-\t  /* This phi function may not have an alternative\n-\t     corresponding to the incoming edge, indicating the\n-\t     assigned variable is not defined along the edge.  */\n-\t  if (alternative == NULL)\n-\t    continue;\n-\t  phi_src = *alternative;\n-\n-\t  /* Invoke the callback.  */\n-\t  result = (*fn) (insn, REGNO (SET_DEST (phi_set)),\n-\t\t\t  REGNO (phi_src), data);\n-\n-\t  /* Terminate if requested.  */\n-\t  if (result != 0)\n-\t    return result;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Assuming the ssa_rename_from mapping has been established, yields\n-   nonzero if 1) only one SSA register of REG1 and REG2 comes from a\n-   hard register or 2) both SSA registers REG1 and REG2 come from\n-   different hard registers.  */\n-\n-static int\n-conflicting_hard_regs_p (int reg1, int reg2)\n-{\n-  int orig_reg1 = original_register (reg1);\n-  int orig_reg2 = original_register (reg2);\n-  if (HARD_REGISTER_NUM_P (orig_reg1) && HARD_REGISTER_NUM_P (orig_reg2)\n-      && orig_reg1 != orig_reg2)\n-    return 1;\n-  if (HARD_REGISTER_NUM_P (orig_reg1) && !HARD_REGISTER_NUM_P (orig_reg2))\n-    return 1;\n-  if (!HARD_REGISTER_NUM_P (orig_reg1) && HARD_REGISTER_NUM_P (orig_reg2))\n-    return 1;\n-\n-  return 0;\n-}"}, {"sha": "ab3cdf1a7894726e7c60a3937797be49d47152d7", "filename": "gcc/ssa.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,70 +0,0 @@\n-/* Static Single Assignment (SSA) definitions for GCC\n-   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n-   Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-\n-/* Main SSA routines.  */\n-extern void convert_to_ssa (void);\n-extern void convert_from_ssa (void);\n-typedef int (*successor_phi_fn) (rtx, int, int, void *);\n-extern int for_each_successor_phi (basic_block bb, successor_phi_fn,\n-\t\t\t\t   void *);\n-void compute_dominance_frontiers (sbitmap *frontiers, dominance_info idom);\n-extern int remove_phi_alternative (rtx, basic_block);\n-\n-\n-/* Optimizations.  */\n-/* In ssa-dce.c */\n-extern void ssa_eliminate_dead_code (void);\n-\n-/* In ssa-ccp.c */\n-extern void ssa_const_prop (void);\n-\n-\n-/* SSA definitions and uses.  */\n-/* This flag is set when the CFG is in SSA form.  */\n-extern int in_ssa_form;\n-\n-/* Element I is the single instruction that sets register I.  */\n-extern GTY(()) varray_type ssa_definition;\n-\n-/* Element I is an INSN_LIST of instructions that use register I.  */\n-extern varray_type ssa_uses;\n-\n-\n-/* Specify which hard registers should be converted.  */\n-\n-/* All pseudo-registers (having register number >=\n-   FIRST_PSEUDO_REGISTER) and hard registers satisfying\n-   CONVERT_HARD_REGISTER_TO_SSA_P are converted to SSA form.  */\n-\n-/* Given a hard register number REG_NO, return nonzero if and only if\n-   the register should be converted to SSA.  */\n-\n-#ifndef CONVERT_HARD_REGISTER_TO_SSA_P\n-#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) (0) /* default of no hard registers */\n-#endif /* CONVERT_HARD_REGISTER_TO_SSA_P  */\n-\n-/* Given a register number REG_NO, return nonzero if and only if the\n-   register should be converted to SSA.  */\n-\n-#define CONVERT_REGISTER_TO_SSA_P(REG_NO)\t\\\n-\t((!HARD_REGISTER_NUM_P (REG_NO)) || \\\n-\t (CONVERT_HARD_REGISTER_TO_SSA_P (REG_NO)))"}, {"sha": "d14e5ae1b98f4d23e796783537935741ad455b72", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -1,3 +1,9 @@\n+2003-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/20020201-2.c: Remove.\n+\t* gcc.dg/20020201-4.c: Remove.\n+\t* gcc.dg/20020304-1.c: Remove.\n+\n 2003-11-19  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* gcc.dg/cpp/trad/xwin1.c: New test case."}, {"sha": "2a13c8d83caa32ab6483406974ad32be3a9a3413", "filename": "gcc/testsuite/gcc.dg/20020201-2.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-2.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,30 +0,0 @@\n-/* This testcase caused ICE because gcc was not able to add instructions\n-   on edge from ENTRY block successor to itself.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fssa\" } */\n-\n-struct A { int a1; int a2; };\n-struct B { long int b[32]; };\n-\n-extern int bar (struct B *, struct A *);\n-\n-int\n-foo (struct B x)\n-{\n-  struct A a, b;\n-  struct B c;\n-  int d;\n-\n-  while (1)\n-    {\n-      a.a1 = 0;\n-      a.a2 = 0;\n-      b = a;\n-      c = x;\n-      d = bar (&c, &b);\n-      if (d >= 0)\n-        return d;\n-    }\n-\n-  return 0;\n-}"}, {"sha": "3c83fe76047d8a68cf04b1f7fc0f1e8db7b5842c", "filename": "gcc/testsuite/gcc.dg/20020201-4.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020201-4.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,16 +0,0 @@\n-/* This testcase failed because recog_for_combine used to pass a different\n-   pattern than contained in insn to recog.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fssa -fssa-ccp\" } */\n-/* { dg-options \"-O2 -march=i686 -fssa -fssa-ccp\" { target i?86-*-* } } */\n-\n-extern int bar (char *);\n-\n-int\n-foo (void)\n-{\n-  char b[512];\n-\n-  bar (b);\n-  return __builtin_strlen (b);\n-}"}, {"sha": "f6d6b4e49a7453d3ce9ad50f2c6fd8742a0e3850", "filename": "gcc/testsuite/gcc.dg/20020304-1.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020304-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6946d1bf8c727ca3781e3a955a781f3ae6f31a/gcc%2Ftestsuite%2Fgcc.dg%2F20020304-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020304-1.c?ref=bd6946d1bf8c727ca3781e3a955a781f3ae6f31a", "patch": "@@ -1,37 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O -fssa -fssa-ccp\" } */\n-\n-double a[10][35], b[10][8];\n-int c, c, d, e, f, g, h;\n-\n-int foo ()\n-{\n-  int i, j, k, l;\n-\n-  if (c > 10)\n-    c = 10;\n-\n-  for (j = 0; j < c; j++)\n-    {\n-      k = 0;\n-      for (l = 0; l < h; l++)\n-\t{\n-\t  if (d != 5)\n-\t    return -1;\n-\t  k = l * g;\n-\t  a[j][k] = (double) e; k++;\n-\t  a[j][k] = (double) f; k++;\n-\t}\n-      for (i = 0;i < 35; i++)\n-        {\n-\t  if (a[j][i] >= 0.9)\n-\t    a[j][i] = 0.9;\n-\t  if (a[j][i] <= 0.1)\n-\t    a[j][i] = 0.1;\n-        }\n-      k = 0;\n-      b[j][k] = (double) e; k++;\n-      b[j][k] = (double) f; k++;\n-    }\n-  return 0;\n-}"}, {"sha": "6fab782c0527e324dbf8a73a06e12c874369f19e", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -92,10 +92,6 @@ DEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")\n DEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\n DEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\n DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n-DEFTIMEVAR (TV_TO_SSA                , \"convert to SSA\")\n-DEFTIMEVAR (TV_SSA_CCP               , \"SSA CCP\")\n-DEFTIMEVAR (TV_SSA_DCE               , \"SSA aggressive DCE\")\n-DEFTIMEVAR (TV_FROM_SSA              , \"convert from SSA\")\n DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")\n "}, {"sha": "bd1f37dd41fd0a0a0a66318c95addbcff7bd90d6", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 95, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -63,7 +63,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"regs.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n-#include \"ssa.h\"\n #include \"params.h\"\n #include \"reload.h\"\n #include \"dwarf2asm.h\"\n@@ -125,7 +124,6 @@ static void print_switch_values (FILE *, int, int, const char *,\n \n /* Rest of compilation helper functions.  */\n static bool rest_of_handle_inlining (tree);\n-static rtx rest_of_handle_ssa (tree, rtx);\n static void rest_of_handle_cse (tree, rtx);\n static void rest_of_handle_cse2 (tree, rtx);\n static void rest_of_handle_gcse (tree, rtx);\n@@ -254,10 +252,6 @@ enum dump_file_index\n   DFI_sibling,\n   DFI_eh,\n   DFI_jump,\n-  DFI_ssa,\n-  DFI_ssa_ccp,\n-  DFI_ssa_dce,\n-  DFI_ussa,\n   DFI_null,\n   DFI_cse,\n   DFI_addressof,\n@@ -298,8 +292,8 @@ enum dump_file_index\n \n    Remaining -d letters:\n \n-\t\"            m   q         \"\n-\t\"         JK   O Q       Y \"\n+\t\"   e        m   q         \"\n+\t\"         JK   O Q     WXY \"\n */\n \n static struct dump_file_info dump_file[DFI_MAX] =\n@@ -309,10 +303,6 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"sibling\",  'i', 0, 0, 0 },\n   { \"eh\",\t'h', 0, 0, 0 },\n   { \"jump\",\t'j', 0, 0, 0 },\n-  { \"ssa\",\t'e', 1, 0, 0 },\n-  { \"ssaccp\",\t'W', 1, 0, 0 },\n-  { \"ssadce\",\t'X', 1, 0, 0 },\n-  { \"ussa\",\t'e', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"null\",\t'u', 0, 0, 0 },\n   { \"cse\",\t's', 0, 0, 0 },\n   { \"addressof\", 'F', 0, 0, 0 },\n@@ -904,15 +894,6 @@ int flag_gnu_linker = 1;\n /* Nonzero means put zero initialized data in the bss section.  */\n int flag_zero_initialized_in_bss = 1;\n \n-/* Enable SSA.  */\n-int flag_ssa = 0;\n-\n-/* Enable ssa conditional constant propagation.  */\n-int flag_ssa_ccp = 0;\n-\n-/* Enable ssa aggressive dead code elimination.  */\n-int flag_ssa_dce = 0;\n-\n /* Tag all structures with __attribute__(packed).  */\n int flag_pack_struct = 0;\n \n@@ -1149,9 +1130,6 @@ static const lang_independent_options f_options[] =\n   {\"dump-unnumbered\", &flag_dump_unnumbered, 1 },\n   {\"instrument-functions\", &flag_instrument_function_entry_exit, 1 },\n   {\"zero-initialized-in-bss\", &flag_zero_initialized_in_bss, 1 },\n-  {\"ssa\", &flag_ssa, 1 },\n-  {\"ssa-ccp\", &flag_ssa_ccp, 1 },\n-  {\"ssa-dce\", &flag_ssa_dce, 1 },\n   {\"leading-underscore\", &flag_leading_underscore, 1 },\n   {\"ident\", &flag_no_ident, 0 },\n   { \"peephole2\", &flag_peephole2, 1 },\n@@ -2750,71 +2728,6 @@ rest_of_handle_inlining (tree decl)\n   return (bool) DECL_EXTERNAL (decl);\n }\n \n-/* Rest of compilation helper to convert the rtl to SSA form.  */\n-static rtx\n-rest_of_handle_ssa (tree decl, rtx insns)\n-{\n-  timevar_push (TV_TO_SSA);\n-  open_dump_file (DFI_ssa, decl);\n-\n-  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-  convert_to_ssa ();\n-\n-  close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n-  timevar_pop (TV_TO_SSA);\n-\n-  /* Perform sparse conditional constant propagation, if requested.  */\n-  if (flag_ssa_ccp)\n-    {\n-      timevar_push (TV_SSA_CCP);\n-      open_dump_file (DFI_ssa_ccp, decl);\n-\n-      ssa_const_prop ();\n-\n-      close_dump_file (DFI_ssa_ccp, print_rtl_with_bb, get_insns ());\n-      timevar_pop (TV_SSA_CCP);\n-    }\n-\n-  /* It would be useful to cleanup the CFG at this point, but block\n-     merging and possibly other transformations might leave a PHI\n-     node in the middle of a basic block, which is a strict no-no.  */\n-\n-  /* The SSA implementation uses basic block numbers in its phi\n-     nodes.  Thus, changing the control-flow graph or the basic\n-     blocks, e.g., calling find_basic_blocks () or cleanup_cfg (),\n-     may cause problems.  */\n-\n-  if (flag_ssa_dce)\n-    {\n-      /* Remove dead code.  */\n-\n-      timevar_push (TV_SSA_DCE);\n-      open_dump_file (DFI_ssa_dce, decl);\n-\n-      insns = get_insns ();\n-      ssa_eliminate_dead_code ();\n-\n-      close_dump_file (DFI_ssa_dce, print_rtl_with_bb, insns);\n-      timevar_pop (TV_SSA_DCE);\n-    }\n-\n-  /* Convert from SSA form.  */\n-\n-  timevar_push (TV_FROM_SSA);\n-  open_dump_file (DFI_ussa, decl);\n-\n-  convert_from_ssa ();\n-  /* New registers have been created.  Rescan their usage.  */\n-  reg_scan (insns, max_reg_num (), 1);\n-\n-  close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n-  timevar_pop (TV_FROM_SSA);\n-\n-  ggc_collect ();\n-\n-  return insns;\n-}\n-\n /* Try to identify useless null pointer tests and delete them.  */\n static void\n rest_of_handle_null_pointer (tree decl, rtx insns)\n@@ -3325,12 +3238,6 @@ rest_of_compilation (tree decl)\n   if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n     goto exit_rest_of_compilation;\n \n-  /* Long term, this should probably move before the jump optimizer too,\n-     but I didn't want to disturb the rtl_dump_and_exit and related\n-     stuff at this time.  */\n-  if (optimize > 0 && flag_ssa)\n-    insns = rest_of_handle_ssa (decl, insns);\n-\n   timevar_push (TV_JUMP);\n \n   if (optimize)"}, {"sha": "31611c3a2206d4a3ec87d828865d73f5899a8417", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c132886e7c0605edb5f66c0614c98b61840efc24/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=c132886e7c0605edb5f66c0614c98b61840efc24", "patch": "@@ -118,9 +118,6 @@ extern int flag_unroll_loops;\n extern int flag_unroll_all_loops;\n extern int flag_unswitch_loops;\n extern int flag_cprop_registers;\n-extern int flag_ssa;\n-extern int flag_ssa_ccp;\n-extern int flag_ssa_dce;\n extern int time_report;\n extern int flag_new_regalloc;\n "}]}