{"sha": "c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwNGYzZjg4ZGI1NGIzZTNlM2VhOWI2YTc2OWQxZTYzOGY5YjY4YQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-06T03:24:58Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-06T03:24:58Z"}, "message": "loop.c (debug_biv, debug_giv): New.\n\n\t* loop.c (debug_biv, debug_giv): New.\n\t(loop_biv_dump): Break out from ...\n\t(record_biv): ... here.\n\t(loop_giv_dump): Break out from ...\n\t(record_giv): ... here.\n\t(loop_bivs_check): Use print_simple_rtl.\n\t* unroll.c (loop_iterations): Use print_simple_rtl.\n\nFrom-SVN: r38744", "tree": {"sha": "6f3180fe6b3f02a2833ff9102c2852e4e0e3c3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f3180fe6b3f02a2833ff9102c2852e4e0e3c3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/comments", "author": null, "committer": null, "parents": [{"sha": "d358ecd01f0516f53e3147b818590c61b25db912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d358ecd01f0516f53e3147b818590c61b25db912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d358ecd01f0516f53e3147b818590c61b25db912"}], "stats": {"total": 229, "additions": 131, "deletions": 98}, "files": [{"sha": "8b075d3deb70bb970b3b985d466598cc194043d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "patch": "@@ -1,3 +1,13 @@\n+2001-01-06  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.c (debug_biv, debug_giv): New.\n+\t(loop_biv_dump): Break out from ...\n+\t(record_biv): ... here.\n+\t(loop_giv_dump): Break out from ...\n+\t(record_giv): ... here.\n+\t(loop_bivs_check): Use print_simple_rtl.\n+\t* unroll.c (loop_iterations): Use print_simple_rtl.\n+\n 2000-01-05  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa.md (return, return_internal): Modify patterns to prevent regrename"}, {"sha": "347f3c9d8a3dd1f4aa74762fd0d297618817c13e", "filename": "gcc/loop.c", "status": "modified", "additions": 118, "deletions": 95, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "patch": "@@ -201,6 +201,8 @@ static void record_biv PARAMS ((struct loop *, struct induction *,\n \t\t\t\tint, int));\n static void check_final_value PARAMS ((const struct loop *,\n \t\t\t\t       struct induction *));\n+static void loop_biv_dump PARAMS((const struct induction *, FILE *, int));\n+static void loop_giv_dump PARAMS((const struct induction *, FILE *, int));\n static void record_giv PARAMS ((const struct loop *, struct induction *,\n \t\t\t\trtx, rtx, rtx, rtx, rtx, rtx, int,\n \t\t\t\tenum g_types, int, int, rtx *));\n@@ -248,6 +250,8 @@ static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n+void debug_biv PARAMS ((const struct induction *));\n+void debug_giv PARAMS ((const struct induction *));\n void debug_loop PARAMS ((const struct loop *));\n void debug_loops PARAMS ((const struct loops *));\n \n@@ -3662,7 +3666,7 @@ loop_bivs_find (loop)\n \t  || ! bl->incremented)\n \t{\n \t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Reg %d: biv discarded, %s\\n\",\n+\t    fprintf (loop_dump_stream, \"Biv %d: discarded, %s\\n\",\n \t\t     bl->regno,\n \t\t     (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t\t      ? \"not induction variable\"\n@@ -3677,7 +3681,7 @@ loop_bivs_find (loop)\n \t  backbl = &bl->next;\n \n \t  if (loop_dump_stream)\n-\t    fprintf (loop_dump_stream, \"Reg %d: biv verified\\n\", bl->regno);\n+\t    fprintf (loop_dump_stream, \"Biv %d: verified\\n\", bl->regno);\n \t}\n     }\n }\n@@ -3770,7 +3774,7 @@ loop_bivs_check (loop)\n \n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Biv %d initialized at insn %d: initial value \",\n+\t\t \"Biv %d: initialized at insn %d: initial value \",\n \t\t bl->regno, INSN_UID (bl->init_insn));\n \n       if ((GET_MODE (src) == GET_MODE (regno_reg_rtx[bl->regno])\n@@ -3783,17 +3787,8 @@ loop_bivs_check (loop)\n \n \t  if (loop_dump_stream)\n \t    {\n-\t      if (GET_CODE (src) == CONST_INT)\n-\t\t{\n-\t\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, \n-\t\t\t   INTVAL (src));\n-\t\t  fputc ('\\n', loop_dump_stream);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  print_rtl (loop_dump_stream, src);\n-\t\t  fprintf (loop_dump_stream, \"\\n\");\n-\t\t}\n+\t      print_simple_rtl (loop_dump_stream, src);\n+\t      fputc ('\\n', loop_dump_stream);\n \t    }\n \t}\n       /* If we can't make it a giv,\n@@ -4160,7 +4155,7 @@ loop_givs_rescan (loop, bl, reg_map, end_insert_before)\n \t{\n \t  fprintf (loop_dump_stream, \"giv at %d reduced to \",\n \t\t   INSN_UID (v->insn));\n-\t  print_rtl (loop_dump_stream, v->new_reg);\n+\t  print_simple_rtl (loop_dump_stream, v->new_reg);\n \t  fprintf (loop_dump_stream, \"\\n\");\n \t}\n     }\n@@ -4947,23 +4942,7 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n     bl->incremented = 1;\n \n   if (loop_dump_stream)\n-    {\n-      fprintf (loop_dump_stream,\n-\t       \"Insn %d: possible biv, reg %d,\",\n-\t       INSN_UID (insn), REGNO (dest_reg));\n-      if (GET_CODE (inc_val) == CONST_INT)\n-\t{\n-\t  fprintf (loop_dump_stream, \" const =\");\n-\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (inc_val));\n-\t  fputc ('\\n', loop_dump_stream);\n-\t}\n-      else\n-\t{\n-\t  fprintf (loop_dump_stream, \" const = \");\n-\t  print_rtl (loop_dump_stream, inc_val);\n-\t  fprintf (loop_dump_stream, \"\\n\");\n-\t}\n-    }\n+    loop_biv_dump (v, loop_dump_stream, 0);\n }\n \f\n /* Fill in the data about one giv.\n@@ -5177,69 +5156,7 @@ record_giv (loop, v, insn, src_reg, dest_reg, mult_val, add_val, ext_val,\n   }\n \n   if (loop_dump_stream)\n-    {\n-      if (type == DEST_REG)\n- \tfprintf (loop_dump_stream, \"Insn %d: giv reg %d\",\n-\t\t INSN_UID (insn), REGNO (dest_reg));\n-      else\n- \tfprintf (loop_dump_stream, \"Insn %d: dest address\",\n- \t\t INSN_UID (insn));\n-\n-      fprintf (loop_dump_stream, \" src reg %d benefit %d\",\n-\t       REGNO (src_reg), v->benefit);\n-      fprintf (loop_dump_stream, \" lifetime %d\",\n-\t       v->lifetime);\n-\n-      if (v->replaceable)\n- \tfprintf (loop_dump_stream, \" replaceable\");\n-\n-      if (v->no_const_addval)\n-\tfprintf (loop_dump_stream, \" ncav\");\n-\n-      if (v->ext_dependant)\n-\t{\n-\t  switch (GET_CODE (v->ext_dependant))\n-\t    {\n-\t    case SIGN_EXTEND:\n-\t      fprintf (loop_dump_stream, \" ext se\");\n-\t      break;\n-\t    case ZERO_EXTEND:\n-\t      fprintf (loop_dump_stream, \" ext ze\");\n-\t      break;\n-\t    case TRUNCATE:\n-\t      fprintf (loop_dump_stream, \" ext tr\");\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n-\n-      if (GET_CODE (mult_val) == CONST_INT)\n-\t{\n-\t  fprintf (loop_dump_stream, \" mult \");\n-\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (mult_val));\n-\t}\n-      else\n-\t{\n-\t  fprintf (loop_dump_stream, \" mult \");\n-\t  print_rtl (loop_dump_stream, mult_val);\n-\t}\n-\n-      if (GET_CODE (add_val) == CONST_INT)\n-\t{\n-\t  fprintf (loop_dump_stream, \" add \");\n-\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, INTVAL (add_val));\n-\t}\n-      else\n-\t{\n-\t  fprintf (loop_dump_stream, \" add \");\n-\t  print_rtl (loop_dump_stream, add_val);\n-\t}\n-    }\n-\n-  if (loop_dump_stream)\n-    fprintf (loop_dump_stream, \"\\n\");\n-\n+    loop_giv_dump (v, loop_dump_stream, 0);\n }\n \n /* All this does is determine whether a giv can be made replaceable because\n@@ -9481,6 +9398,112 @@ replace_label (x, data)\n   return 0;\n }\n \f\n+static void\n+loop_biv_dump (v, file, verbose)\n+     const struct induction *v;\n+     FILE *file;\n+     int verbose;\n+{\n+  if (! v || ! file)\n+    return;\n+\n+  fprintf (file,\n+\t   \"Biv %d: insn %d\",\n+\t   REGNO (v->dest_reg), INSN_UID (v->insn));\n+  fprintf (file, \" const \");\n+  print_simple_rtl (file, v->add_val);\n+\n+  if (verbose && v->final_value)\n+    {\n+      fputc ('\\n', file);  \n+      fprintf (file, \" final \");\n+      print_simple_rtl (file, v->final_value);\n+    }\n+\n+  fputc ('\\n', file);\n+}\n+\n+\n+static void\n+loop_giv_dump (v, file, verbose)\n+     const struct induction *v;\n+     FILE *file;\n+     int verbose;\n+{\n+  if (! v || ! file)\n+    return;\n+\n+  if (v->giv_type == DEST_REG)\n+    fprintf (file, \"Giv %d: insn %d\",\n+\t     REGNO (v->dest_reg),  INSN_UID (v->insn)); \n+  else\n+    fprintf (file, \"Dest address: insn %d\",\n+\t     INSN_UID (v->insn));\n+  \n+  fprintf (file, \" src reg %d benefit %d\",\n+\t   REGNO (v->src_reg), v->benefit);\n+  fprintf (file, \" lifetime %d\",\n+\t   v->lifetime);\n+  \n+  if (v->replaceable)\n+    fprintf (file, \" replaceable\");\n+  \n+  if (v->no_const_addval)\n+    fprintf (file, \" ncav\");\n+  \n+  if (v->ext_dependant)\n+    {\n+      switch (GET_CODE (v->ext_dependant))\n+\t{\n+\tcase SIGN_EXTEND:\n+\t  fprintf (file, \" ext se\");\n+\t  break;\n+\tcase ZERO_EXTEND:\n+\t  fprintf (file, \" ext ze\");\n+\t  break;\n+\tcase TRUNCATE:\n+\t  fprintf (file, \" ext tr\");\n+\t      break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  fputc ('\\n', file);  \n+  fprintf (file, \" mult \");\n+  print_simple_rtl (file, v->mult_val);\n+\n+  fputc ('\\n', file);  \n+  fprintf (file, \" add  \");\n+  print_simple_rtl (file, v->add_val);\n+\n+  if (verbose && v->final_value)\n+    {\n+      fputc ('\\n', file);  \n+      fprintf (file, \" final \");\n+      print_simple_rtl (file, v->final_value);\n+    }\n+\n+  fputc ('\\n', file);  \n+}\n+\n+\n+void\n+debug_biv (v)\n+     const struct induction *v;\n+{\n+  loop_biv_dump (v, stderr, 1);\n+}\n+\n+\n+void\n+debug_giv (v)\n+     const struct induction *v;\n+{\n+  loop_giv_dump (v, stderr, 1);\n+}\n+\n+\n #define LOOP_BLOCK_NUM_1(INSN) \\\n ((INSN) ? (BLOCK_FOR_INSN (INSN) ? BLOCK_NUM (INSN) : - 1) : -1)\n "}, {"sha": "0b4a89bfd284bdc9a47bb46546f7e71dafe422e1", "filename": "gcc/unroll.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c804f3f88db54b3e3e3ea9b6a769d1e638f9b68a", "patch": "@@ -3852,7 +3852,7 @@ loop_iterations (loop)\n \t    {\n \t      fprintf (loop_dump_stream,\n \t\t       \"Loop iterations: Increment value not constant \");\n-\t      print_rtl (loop_dump_stream, increment);\n+\t      print_simple_rtl (loop_dump_stream, increment);\n \t      fprintf (loop_dump_stream, \".\\n\");\n \t    }\n \t  return 0;\n@@ -3866,7 +3866,7 @@ loop_iterations (loop)\n \t{\n \t  fprintf (loop_dump_stream,\n \t\t   \"Loop iterations: Initial value not constant \");\n-\t  print_rtl (loop_dump_stream, initial_value);\n+\t  print_simple_rtl (loop_dump_stream, initial_value);\n \t  fprintf (loop_dump_stream, \".\\n\");\n \t}\n       return 0;\n@@ -3883,7 +3883,7 @@ loop_iterations (loop)\n \t{\n \t  fprintf (loop_dump_stream,\n \t\t   \"Loop iterations: Final value not constant \");\n-\t  print_rtl (loop_dump_stream, final_value);\n+\t  print_simple_rtl (loop_dump_stream, final_value);\n \t  fprintf (loop_dump_stream, \".\\n\");\n \t}\n       return 0;"}]}