{"sha": "d98ad4101fa724d2d7f7364405f31fd3e8090371", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk4YWQ0MTAxZmE3MjRkMmQ3ZjczNjQ0MDVmMzFmZDNlODA5MDM3MQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2005-11-02T23:16:31Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-11-02T23:16:31Z"}, "message": "re PR target/24615 (internal compiler error: in print_shift_count_operand, at config/s390/s390.c:4025)\n\nChangeLog:\n\n\tPR target/24615\n\t* config/s390/s390-protos.h (s390_decompose_shift_count): Declare.\n\t* config/s390/s390.c (s390_decompose_shift_count): New function.\n\t(s390_extra_constraint_str) ['Y']: Use s390_decompose_shift_count.\n\t(print_shift_count_operand): Use s390_decompose_shift_count.\n\t* config/s390/predicates.md (\"setmem_operand\", \"shift_count_operand\"):\n\tUse s390_decompose_shift_count.  Do not accept any non-base hard regs.\n\ntestsuite/ChangeLog:\n\n\tPR target/24615\n\t* gcc.dg/pr24615.c: New test.\n\nFrom-SVN: r106405", "tree": {"sha": "292c78d7d1f4715de0268e2e75d7ed0d2e075510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292c78d7d1f4715de0268e2e75d7ed0d2e075510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d98ad4101fa724d2d7f7364405f31fd3e8090371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d98ad4101fa724d2d7f7364405f31fd3e8090371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d98ad4101fa724d2d7f7364405f31fd3e8090371", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d98ad4101fa724d2d7f7364405f31fd3e8090371/comments", "author": null, "committer": null, "parents": [{"sha": "f55b94653531277c15fbda2a69b5fa61dccbd589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f55b94653531277c15fbda2a69b5fa61dccbd589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f55b94653531277c15fbda2a69b5fa61dccbd589"}], "stats": {"total": 212, "additions": 127, "deletions": 85}, "files": [{"sha": "59654738319b49b67e790b4e66c3aee09cc7e086", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -1,3 +1,13 @@\n+2005-11-02  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR target/24615\n+\t* config/s390/s390-protos.h (s390_decompose_shift_count): Declare.\n+\t* config/s390/s390.c (s390_decompose_shift_count): New function.\n+\t(s390_extra_constraint_str) ['Y']: Use s390_decompose_shift_count.\n+\t(print_shift_count_operand): Use s390_decompose_shift_count.\n+\t* config/s390/predicates.md (\"setmem_operand\", \"shift_count_operand\"):\n+\tUse s390_decompose_shift_count.  Do not accept any non-base hard regs.\n+\n 2005-11-02  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \tPR target/24600"}, {"sha": "a921d1f344688727e2e1f31bbc1b5c6d674748d1", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -80,35 +80,17 @@\n (define_predicate \"setmem_operand\"\n   (match_code \"reg, subreg, plus, const_int\")\n {\n-  HOST_WIDE_INT offset = 0;\n+  HOST_WIDE_INT offset;\n+  rtx base;\n \n-  /* The padding byte operand of the mvcle instruction is always truncated\n-     to the 8 least significant bits.  */\n-  if (GET_CODE (op) == AND && GET_CODE (XEXP (op, 1)) == CONST_INT\n-      && (INTVAL (XEXP (op, 1)) & 255) == 255)\n-    op = XEXP (op, 0);\n-\n-  /* We can have an integer constant, an address register,\n-     or a sum of the two.  Note that reload already checks\n-     that any register present is an address register, so\n-     we just check for any register here.  */\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      offset = INTVAL (op);\n-      op = NULL_RTX;\n-    }\n-  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    {\n-      offset = INTVAL (XEXP (op, 1));\n-      op = XEXP (op, 0);\n-    }\n-  while (op && GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (op && GET_CODE (op) != REG)\n+  /* Extract base register and offset.  Use 8 significant bits.  */\n+  if (!s390_decompose_shift_count (op, &base, &offset, 8))\n     return false;\n \n-  if (op && REGNO (op) < FIRST_PSEUDO_REGISTER\n-      && !GENERAL_REGNO_P (REGNO (op)))\n+  /* Don't allow any non-base hard registers.  Doing so without\n+     confusing reload and/or regrename would be tricky, and doesn't\n+     buy us much anyway.  */\n+  if (base && REGNO (base) < FIRST_PSEUDO_REGISTER && !ADDR_REG_P (base))\n     return false;\n \n   /* Unfortunately we have to reject constants that are invalid\n@@ -124,35 +106,17 @@\n (define_predicate \"shift_count_operand\"\n   (match_code \"reg, subreg, plus, const_int, and\")\n {\n-  HOST_WIDE_INT offset = 0;\n+  HOST_WIDE_INT offset;\n+  rtx base;\n \n-  /* Shift count operands are always truncated to the 6 least significant bits.\n-     So we can accept pointless ANDs here.  */\n-  if (GET_CODE (op) == AND && GET_CODE (XEXP (op, 1)) == CONST_INT\n-      && (INTVAL (XEXP (op, 1)) & 63) == 63)\n-    op = XEXP (op, 0);\n-\n-  /* We can have an integer constant, an address register,\n-     or a sum of the two.  Note that reload already checks\n-     that any register present is an address register, so\n-     we just check for any register here.  */\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      offset = INTVAL (op);\n-      op = NULL_RTX;\n-    }\n-  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    {\n-      offset = INTVAL (XEXP (op, 1));\n-      op = XEXP (op, 0);\n-    }\n-  while (op && GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (op && GET_CODE (op) != REG)\n+  /* Extract base register and offset.  Use 6 significant bits.  */\n+  if (!s390_decompose_shift_count (op, &base, &offset, 6))\n     return false;\n \n-  if (op && REGNO (op) < FIRST_PSEUDO_REGISTER\n-      && !GENERAL_REGNO_P (REGNO (op)))\n+  /* Don't allow any non-base hard registers.  Doing so without\n+     confusing reload and/or regrename would be tricky, and doesn't\n+     buy us much anyway.  */\n+  if (base && REGNO (base) < FIRST_PSEUDO_REGISTER && !ADDR_REG_P (base))\n     return false;\n \n   /* Unfortunately we have to reject constants that are invalid"}, {"sha": "42eecdbfcf64fcc89911fcd7b1f12ea53a556032", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -97,6 +97,7 @@ extern rtx s390_load_got (void);\n extern rtx s390_get_thread_pointer (void);\n extern void s390_emit_tpf_eh_return (rtx);\n extern bool s390_legitimate_address_without_index_p (rtx);\n+extern bool s390_decompose_shift_count (rtx, rtx *, HOST_WIDE_INT *, int);\n extern int s390_branch_condition_mask (rtx);\n \n #endif /* RTX_CODE */"}, {"sha": "03e5a0ee83baf8d2ac8009f478496c0a3cf39cdc", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -1721,6 +1721,58 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n   return true;\n }\n \n+/* Decompose a RTL expression OP for a shift count into its components,\n+   and return the base register in BASE and the offset in OFFSET.\n+\n+   If BITS is non-zero, the expression is used in a context where only\n+   that number to low-order bits is significant.  We then allow OP to\n+   contain and outer AND that does not affect significant bits.  If BITS\n+   is zero, we allow OP to contain any outer AND with a constant.\n+\n+   Return true if OP is a valid shift count, false if not.  */\n+\n+bool\n+s390_decompose_shift_count (rtx op, rtx *base, HOST_WIDE_INT *offset, int bits)\n+{\n+  HOST_WIDE_INT off = 0;\n+\n+  /* Drop outer ANDs.  */\n+  if (GET_CODE (op) == AND && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+    {\n+      HOST_WIDE_INT mask = ((HOST_WIDE_INT)1 << bits) - 1;\n+      if ((INTVAL (XEXP (op, 1)) & mask) != mask)\n+\treturn false;\n+\n+      op = XEXP (op, 0);\n+    }\n+\n+  /* We can have an integer constant, an address register,\n+     or a sum of the two.  */\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      off = INTVAL (op);\n+      op = NULL_RTX;\n+    }\n+  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+    {\n+      off = INTVAL (XEXP (op, 1));\n+      op = XEXP (op, 0);\n+    }\n+  while (op && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (op && GET_CODE (op) != REG)\n+    return false;\n+\n+  if (offset)\n+    *offset = off;\n+  if (base)\n+    *base = op;\n+\n+   return true;\n+}\n+\n+\n /* Return true if CODE is a valid address without index.  */\n \n bool\n@@ -1851,7 +1903,11 @@ s390_extra_constraint_str (rtx op, int c, const char * str)\n       break;\n \n     case 'Y':\n-      return shift_count_operand (op, VOIDmode);\n+      /* Simply check for the basic form of a shift count.  Reload will\n+\t take care of making sure we have a proper base register.  */\n+      if (!s390_decompose_shift_count (op, NULL, NULL, 0))\n+\treturn 0;\n+      break;\n \n     default:\n       return 0;\n@@ -3978,46 +4034,25 @@ s390_delegitimize_address (rtx orig_x)\n static void\n print_shift_count_operand (FILE *file, rtx op)\n {\n-  HOST_WIDE_INT offset = 0;\n-\n-  /* Shift count operands are always truncated to the 6 least significant bits and\n-     the setmem padding byte to the least 8 significant bits.  Hence we can drop\n-     pointless ANDs.  */\n-  if (GET_CODE (op) == AND && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    {\n-      if ((INTVAL (XEXP (op, 1)) & 63) != 63)\n-\tgcc_unreachable ();\n-\n-      op = XEXP (op, 0);\n-    }\n+  HOST_WIDE_INT offset;\n+  rtx base;\n \n-  /* We can have an integer constant, an address register,\n-     or a sum of the two.  */\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      offset = INTVAL (op);\n-      op = NULL_RTX;\n-    }\n-  if (op && GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n-    {\n-      offset = INTVAL (XEXP (op, 1));\n-      op = XEXP (op, 0);\n-    }\n-  while (op && GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+  /* Extract base register and offset.  */\n+  if (!s390_decompose_shift_count (op, &base, &offset, 0))\n+    gcc_unreachable ();\n \n   /* Sanity check.  */\n-  if (op)\n+  if (base)\n     {\n-      gcc_assert (GET_CODE (op) == REG);\n-      gcc_assert (REGNO (op) < FIRST_PSEUDO_REGISTER);\n-      gcc_assert (REGNO_REG_CLASS (REGNO (op)) == ADDR_REGS);\n+      gcc_assert (GET_CODE (base) == REG);\n+      gcc_assert (REGNO (base) < FIRST_PSEUDO_REGISTER);\n+      gcc_assert (REGNO_REG_CLASS (REGNO (base)) == ADDR_REGS);\n     }\n \n   /* Offsets are constricted to twelve bits.  */\n   fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset & ((1 << 12) - 1));\n-  if (op)\n-    fprintf (file, \"(%s)\", reg_names[REGNO (op)]);\n+  if (base)\n+    fprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n }\n \n /* See 'get_some_local_dynamic_name'.  */"}, {"sha": "5fee48f1bc1cdbc4f557d16a9829880027cb2488", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -1,3 +1,8 @@\n+2005-11-02  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR target/24615\n+\t* gcc.dg/pr24615.c: New test.\n+\n 2005-11-02  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \tPR target/24600"}, {"sha": "9699d8e6ded1d8d5eda3062e52492279833f0803", "filename": "gcc/testsuite/gcc.dg/pr24615.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24615.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d98ad4101fa724d2d7f7364405f31fd3e8090371/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24615.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24615.c?ref=d98ad4101fa724d2d7f7364405f31fd3e8090371", "patch": "@@ -0,0 +1,27 @@\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fPIC\" } */\n+\n+void *memset (void *, int, __SIZE_TYPE__);\n+void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+char *alloc (int);\n+\n+char *\n+test (int type, int size, char *data, int len)\n+{\n+  char *block = alloc (size);\n+  char *bp = block;\n+\n+  *bp++ = type;\n+  switch (type)\n+    {\n+    case 0:\n+    case 1:\n+      memset (bp, type == 0 ? 0x00 : 0xff, size);\n+      memcpy (bp, data, len);\n+    }\n+\n+  return block;\n+}\n+"}]}