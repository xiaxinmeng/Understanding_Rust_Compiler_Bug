{"sha": "643400b8c99f0a1343018d9f65dbba95c2bab842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQzNDAwYjhjOTlmMGExMzQzMDE4ZDlmNjVkYmJhOTVjMmJhYjg0Mg==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-11-15T00:12:45Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-11-15T00:12:45Z"}, "message": "re PR tree-optimization/51005 (-ftree-tail-merge slows down compilation of 20001226-1.c)\n\n2011-11-15  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/51005\n\t* tree-ssa-tail-merge.c (delete_basic_block_same_succ): Rename to\n\tmark_basic_block_deleted.\n\t(update_worklist): Inline purge_bbs.\n\t(purge_bbs, unlink_virtual_phi, update_vuses, vop_at_entry)\n\t(delete_block_update_dominator_info): Remove.\n\t(replace_block_by): Remove update_vops parameter.  Partially evaluate\n\tfor update_vops == false.\n\t(apply_clusters): Remove update_vops parameter.  Remove update_vops\n\targument in replace_block_by call.\n\t(update_debug_stmts): Remove MAY_HAVE_DEBUG_STMTS test.\n\t(tail_merge_optimize): Remove update_vops argument to apply_clusters.\n\tRemove call to purge_bbs.  Add calls to calculate_dominance_info and\n\tfree_dominance_info.  Add MAY_HAVE_DEBUG_STMTS\tbefore calling\n\tupdate_debug_stmts.  Mark vop var for renaming, if necessary.\n\nFrom-SVN: r181372", "tree": {"sha": "e1ed07e337a3f84a46a42c64c3b313599074a2a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1ed07e337a3f84a46a42c64c3b313599074a2a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/643400b8c99f0a1343018d9f65dbba95c2bab842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643400b8c99f0a1343018d9f65dbba95c2bab842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643400b8c99f0a1343018d9f65dbba95c2bab842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643400b8c99f0a1343018d9f65dbba95c2bab842/comments", "author": null, "committer": null, "parents": [{"sha": "894a84b5ed98b1fcf565f462f364db0e3d769831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894a84b5ed98b1fcf565f462f364db0e3d769831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894a84b5ed98b1fcf565f462f364db0e3d769831"}], "stats": {"total": 370, "additions": 52, "deletions": 318}, "files": [{"sha": "a8292ffe510b655d1af2ebccc4c7614e3bed008d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643400b8c99f0a1343018d9f65dbba95c2bab842/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643400b8c99f0a1343018d9f65dbba95c2bab842/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=643400b8c99f0a1343018d9f65dbba95c2bab842", "patch": "@@ -1,3 +1,21 @@\n+2011-11-15  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/51005\n+\t* tree-ssa-tail-merge.c (delete_basic_block_same_succ): Rename to\n+\tmark_basic_block_deleted.\n+\t(update_worklist): Inline purge_bbs.\n+\t(purge_bbs, unlink_virtual_phi, update_vuses, vop_at_entry)\n+\t(delete_block_update_dominator_info): Remove.\n+\t(replace_block_by): Remove update_vops parameter.  Partially evaluate\n+\tfor update_vops == false.\n+\t(apply_clusters): Remove update_vops parameter.  Remove update_vops\n+\targument in replace_block_by call.\n+\t(update_debug_stmts): Remove MAY_HAVE_DEBUG_STMTS test.\n+\t(tail_merge_optimize): Remove update_vops argument to apply_clusters.\n+\tRemove call to purge_bbs.  Add calls to calculate_dominance_info and\n+\tfree_dominance_info.  Add MAY_HAVE_DEBUG_STMTS\tbefore calling\n+\tupdate_debug_stmts.  Mark vop var for renaming, if necessary.\n+\n 2011-11-15  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR rtl-optimization/51051"}, {"sha": "39a3aabb84219e013f45b0c42301641684350a6c", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 34, "deletions": 318, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643400b8c99f0a1343018d9f65dbba95c2bab842/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643400b8c99f0a1343018d9f65dbba95c2bab842/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=643400b8c99f0a1343018d9f65dbba95c2bab842", "patch": "@@ -742,7 +742,7 @@ delete_worklist (void)\n /* Mark BB as deleted, and mark its predecessors.  */\n \n static void\n-delete_basic_block_same_succ (basic_block bb)\n+mark_basic_block_deleted (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -809,15 +809,6 @@ release_last_vdef (basic_block bb)\n   \n }\n \n-/* Delete all deleted_bbs.  */\n-\n-static void\n-purge_bbs (void)\n-{\n-  bitmap_and_compl_into (deleted_bb_preds, deleted_bbs);\n-  bitmap_clear (deleted_bbs);\n-}\n-\n /* For deleted_bb_preds, find bbs with same successors.  */\n \n static void\n@@ -828,6 +819,9 @@ update_worklist (void)\n   basic_block bb;\n   same_succ same;\n \n+  bitmap_and_compl_into (deleted_bb_preds, deleted_bbs);\n+  bitmap_clear (deleted_bbs);\n+\n   bitmap_clear_bit (deleted_bb_preds, ENTRY_BLOCK);\n   same_succ_flush_bbs (deleted_bb_preds);\n \n@@ -1353,125 +1347,6 @@ find_clusters (void)\n     }\n }\n \n-/* Replace uses of the result of PHI with NAME.  */\n-\n-static void\n-unlink_virtual_phi (gimple phi, tree name)\n-{\n-  use_operand_p use_p;\n-  imm_use_iterator iter;\n-  gimple use_stmt;\n-  tree vdef = gimple_phi_result (phi);\n-\n-  if (!vdef\n-      || TREE_CODE (vdef) != SSA_NAME)\n-    return;\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, iter, vdef)\n-    {\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\tSET_USE (use_p, name);\n-    }\n-\n-  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (vdef))\n-    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name) = 1;\n-}\n-\n-/* Create or update a vop phi in BB2.  Use VUSE1 arguments for all the\n-   REDIRECTED_EDGES, or if VUSE1 is NULL_TREE, use BB_VOP_AT_EXIT.  If a new\n-   phis is created, use the phi instead of VUSE2 in BB2.  */\n-\n-static void\n-update_vuses (bool vuse1_phi_args, tree vuse1, tree vuse2, basic_block bb2,\n-              VEC (edge,heap) *redirected_edges)\n-{\n-  gimple stmt, phi = NULL;\n-  tree lhs = NULL_TREE, arg, var;\n-  unsigned int i;\n-  gimple def_stmt2 = NULL;\n-  imm_use_iterator iter;\n-  use_operand_p use_p;\n-  edge_iterator ei;\n-  edge e;\n-\n-  if (vuse2 != NULL_TREE)\n-    {\n-      var = SSA_NAME_VAR (vuse2);\n-      def_stmt2 =  SSA_NAME_DEF_STMT (vuse2);\n-    }\n-  else\n-    var = SSA_NAME_VAR (vuse1);\n-\n-  if (def_stmt2 && gimple_bb (def_stmt2) == bb2)\n-    /* Update existing phi.  */\n-    phi = def_stmt2;\n-  else\n-    {\n-      /* No need to create a phi with 2 equal arguments.  */\n-      if (vuse1 == vuse2)\n-\treturn;\n-\n-      /* Create a phi.  */\n-      lhs = make_ssa_name (var, NULL);\n-      VN_INFO_GET (lhs);\n-      phi = create_phi_node (lhs, bb2);\n-      SSA_NAME_DEF_STMT (lhs) = phi;\n-\n-      /* Set default argument vuse2 for all preds.  */\n-      arg = vuse2 == NULL_TREE ? gimple_phi_result (phi): vuse2;\n-      FOR_EACH_EDGE (e, ei, bb2->preds)\n-\tadd_phi_arg (phi, arg, e, UNKNOWN_LOCATION);\n-    }\n-\n-  /* Update phi.  */\n-  for (i = 0; i < EDGE_COUNT (redirected_edges); ++i)\n-    {\n-      e = VEC_index (edge, redirected_edges, i);\n-      if (vuse1_phi_args)\n-\targ = BB_VOP_AT_EXIT (e->src);\n-      else\n-\targ = vuse1 == NULL_TREE ? gimple_phi_result (phi): vuse1;\n-\n-      add_phi_arg (phi, arg, e, UNKNOWN_LOCATION);\n-    }\n-\n-  /* Return if we updated an existing phi.  */\n-  if (def_stmt2 && gimple_bb (def_stmt2) == bb2)\n-    return;\n-\n-  /* Replace relevant uses with the newly created phi.  */\n-  FOR_EACH_IMM_USE_STMT (stmt, iter, vuse2 == NULL_TREE ? vuse1 : vuse2)\n-    {\n-      if (stmt == phi)\n-\tcontinue;\n-\n-      if (gimple_code (stmt) != GIMPLE_PHI\n-\t  && !dominated_by_p (CDI_DOMINATORS, gimple_bb (stmt), bb2))\n-\t  continue;\n-\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t{\n-\t  if (gimple_code (stmt) == GIMPLE_PHI)\n-\t    {\n-\t      unsigned int pred_index = PHI_ARG_INDEX_FROM_USE (use_p);\n-\t      basic_block pred = EDGE_PRED (gimple_bb (stmt), pred_index)->src;\n-\t      if (!dominated_by_p (CDI_DOMINATORS, pred, bb2))\n-\t\tcontinue;\n-\n-\t      if (pred == bb2 && EDGE_COUNT (gimple_bb (stmt)->preds) == 1)\n-\t\t{\n-\t\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\t\t  unlink_virtual_phi (stmt, lhs);\n-\t\t  remove_phi_node (&gsi, true);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  SET_USE (use_p, lhs);\n-\t  update_stmt (stmt);\n-\t}\n-    }\n-}\n-\n /* Returns the vop phi of BB, if any.  */\n \n static gimple\n@@ -1489,215 +1364,54 @@ vop_phi (basic_block bb)\n   return NULL;\n }\n \n-/* Returns the vop state at the entry of BB, if found in BB or a successor\n-   bb.  */\n-\n-static tree\n-vop_at_entry (basic_block bb)\n-{\n-  gimple bb_phi, succ_phi;\n-  gimple_stmt_iterator gsi;\n-  gimple stmt;\n-  tree vuse, vdef;\n-  basic_block succ;\n-\n-  bb_phi = vop_phi (bb);\n-  if (bb_phi != NULL)\n-    return gimple_phi_result (bb_phi);\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      stmt = gsi_stmt (gsi);\n-      vuse = gimple_vuse (stmt);\n-      vdef = gimple_vdef (stmt);\n-      if (vuse != NULL_TREE)\n-\treturn vuse;\n-      if (vdef != NULL_TREE)\n-\treturn NULL_TREE;\n-    }\n-\n-  if (EDGE_COUNT (bb->succs) == 0)\n-    return NULL_TREE;\n-\n-  succ = EDGE_SUCC (bb, 0)->dest;\n-  succ_phi = vop_phi (succ);\n-  return (succ_phi != NULL\n-\t  ? PHI_ARG_DEF_FROM_EDGE (succ_phi, find_edge (bb, succ))\n-\t  : NULL_TREE);\n-}\n-\n-/* Given that all incoming edges of BB1 have been redirected to BB2, delete BB1\n-   and recompute dominator info.  */\n-\n-static void\n-delete_block_update_dominator_info (basic_block bb1, basic_block bb2)\n-{\n-  VEC (basic_block,heap) *fix_dom_bb;\n-  unsigned int i;\n-  basic_block bb, dom;\n-  edge e;\n-  edge_iterator ei;\n-\n-  /* Consider the following cfg, where A is the direct dominator of I:\n-\n-                A\n-               / \\\n-              B   \\\n-             / \\   \\\n-                C   D\n-               /|   |\\\n-                E   F\n-                |\\ /|\n-                | x |\n-                |/ \\|\n-                G   H\n-                 \\ /\n-                  I\n-\n-     Say E and F are duplicates, and F is removed.  The cfg then looks like\n-     this:\n-\n-                A\n-               / \\\n-              B   \\\n-             / \\   \\\n-                C   D\n-               / \\ / \\\n-                  E\n-                 / \\\n-                G   H\n-                 \\ /\n-                  I\n-\n-     E is now the new direct dominator of I.\n-\n-     In order to calculate the new dominator info, we take the nearest common\n-     dominator (A) of bb1 (F) and bb2 (E), and get the set of bbs immediately\n-     dominated by it.  Some of this set may now be directly dominated by bb2.\n-\n-     Ideally we would have a means to determine which bbs in the set are now\n-     dominated by bb2, and call set_immediate_dominator for those bbs, but we\n-     don't, so instead we let iterate_fix_dominators figure it out.  */\n-\n-  /* Add bbs immediately dominated by the most common dominator.  */\n-  dom = nearest_common_dominator (CDI_DOMINATORS, bb1, bb2);\n-  fix_dom_bb = get_dominated_by (CDI_DOMINATORS, dom);\n-\n-  if (get_immediate_dominator (CDI_DOMINATORS, bb1) == dom)\n-    for (i = 0; VEC_iterate (basic_block, fix_dom_bb, i, bb); ++i)\n-      {\n-\tif (bb != bb1)\n-\t  continue;\n-\tVEC_unordered_remove (basic_block, fix_dom_bb, i);\n-\tbreak;\n-      }\n-\n-  /* Add bb2, but not twice.  */\n-  if (get_immediate_dominator (CDI_DOMINATORS, bb2) != dom)\n-    VEC_safe_push (basic_block, heap, fix_dom_bb, bb2);\n-  /* Add succs of bb2, but not twice.  */\n-  FOR_EACH_EDGE (e, ei, bb2->succs)\n-    if (get_immediate_dominator (CDI_DOMINATORS, e->dest) != dom)\n-      VEC_safe_push (basic_block, heap, fix_dom_bb, e->dest);\n-\n-  delete_basic_block (bb1);\n-  iterate_fix_dominators (CDI_DOMINATORS, fix_dom_bb, false);\n-#if defined (ENABLE_CHECKING)\n-  verify_dominators (CDI_DOMINATORS);\n-#endif\n-  VEC_free (basic_block, heap, fix_dom_bb);\n-}\n-\n-/* Redirect all edges from BB1 to BB2, marks BB1 for removal, and if\n-   UPDATE_VOPS, inserts vop phis.  */\n+/* Redirect all edges from BB1 to BB2, removes BB1 and marks it as removed.  */\n \n static void\n-replace_block_by (basic_block bb1, basic_block bb2, bool update_vops)\n+replace_block_by (basic_block bb1, basic_block bb2)\n {\n   edge pred_edge;\n   unsigned int i;\n-  tree phi_vuse1 = NULL_TREE, phi_vuse2 = NULL_TREE, arg;\n-  VEC (edge,heap) *redirected_edges = NULL;\n-  edge e;\n-  edge_iterator ei;\n-  bool vuse1_phi_args = false;\n-\n-  phi_vuse2 = vop_at_entry (bb2);\n-  if (phi_vuse2 != NULL_TREE && TREE_CODE (phi_vuse2) != SSA_NAME)\n-    phi_vuse2 = NULL_TREE;\n+  gimple bb2_phi;\n \n-  if (update_vops)\n-    {\n-      /* Find the vops at entry of bb1 and bb2.  */\n-      phi_vuse1 = vop_at_entry (bb1);\n-\n-      /* If both are not found, it means there's no need to update.  Uses old\n-\t dominator info.  */\n-      if (phi_vuse1 == NULL_TREE && phi_vuse2 == NULL_TREE)\n-\tupdate_vops = false;\n-      else if (phi_vuse1 == NULL_TREE)\n-\tupdate_vops = dominated_by_p (CDI_DOMINATORS, bb1, bb2);\n-      else if (phi_vuse2 == NULL_TREE)\n-\tupdate_vops = dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n-    }\n-\n-  if (phi_vuse1 && gimple_bb (SSA_NAME_DEF_STMT (phi_vuse1)) == bb1)\n-    {\n-      /* If the vop at entry of bb1 is a phi, save the phi alternatives in\n-\t BB_VOP_AT_EXIT, before we lose that information by redirecting the\n-\t edges.  */\n-      FOR_EACH_EDGE (e, ei, bb1->preds)\n-\t{\n-\t  arg = PHI_ARG_DEF_FROM_EDGE (SSA_NAME_DEF_STMT (phi_vuse1), e);\n-\t  BB_VOP_AT_EXIT (e->src) = arg;\n-\t}\n-      vuse1_phi_args = true;\n-    }\n+  bb2_phi = vop_phi (bb2);\n \n-  /* Mark the basic block for later deletion.  */\n-  delete_basic_block_same_succ (bb1);\n-\n-  if (update_vops)\n-    redirected_edges = VEC_alloc (edge, heap, 10);\n+  /* Mark the basic block as deleted.  */\n+  mark_basic_block_deleted (bb1);\n \n   /* Redirect the incoming edges of bb1 to bb2.  */\n   for (i = EDGE_COUNT (bb1->preds); i > 0 ; --i)\n     {\n       pred_edge = EDGE_PRED (bb1, i - 1);\n       pred_edge = redirect_edge_and_branch (pred_edge, bb2);\n       gcc_assert (pred_edge != NULL);\n-      if (update_vops)\n-\tVEC_safe_push (edge, heap, redirected_edges, pred_edge);\n-      else if (phi_vuse2 && gimple_bb (SSA_NAME_DEF_STMT (phi_vuse2)) == bb2)\n-\tadd_phi_arg (SSA_NAME_DEF_STMT (phi_vuse2), SSA_NAME_VAR (phi_vuse2),\n-\t\t     pred_edge, UNKNOWN_LOCATION);\n+\n+      if (bb2_phi == NULL)\n+\tcontinue;\n+\n+      /* The phi might have run out of capacity when the redirect added an\n+\t argument, which means it could have been replaced.  Refresh it.  */\n+      bb2_phi = vop_phi (bb2);\n+\n+      add_phi_arg (bb2_phi, SSA_NAME_VAR (gimple_phi_result (bb2_phi)),\n+\t\t   pred_edge, UNKNOWN_LOCATION);\n     }\n \n   /* Do updates that use bb1, before deleting bb1.  */\n-  if (!update_vops)\n-    release_last_vdef (bb1);\n+  release_last_vdef (bb1);\n   same_succ_flush_bb (bb1);\n \n-  delete_block_update_dominator_info (bb1, bb2);\n-\n-  /* Update the vops.  Uses new dominator info.  */\n-  if (update_vops)\n-    {\n-      update_vuses (vuse1_phi_args, phi_vuse1, phi_vuse2, bb2,\n-\t\t    redirected_edges);\n-      VEC_free (edge, heap, redirected_edges);\n-    }\n+  delete_basic_block (bb1);\n }\n \n /* Bbs for which update_debug_stmt need to be called.  */\n \n static bitmap update_bbs;\n \n /* For each cluster in all_clusters, merge all cluster->bbs.  Returns\n-   number of bbs removed.  Insert vop phis if UPDATE_VOPS.  */\n+   number of bbs removed.  */\n \n static int\n-apply_clusters (bool update_vops)\n+apply_clusters (void)\n {\n   basic_block bb1, bb2;\n   bb_cluster c;\n@@ -1720,7 +1434,7 @@ apply_clusters (bool update_vops)\n \t  bb1 = BASIC_BLOCK (j);\n \t  bitmap_clear_bit (update_bbs, bb1->index);\n \n-\t  replace_block_by (bb1, bb2, update_vops);\n+\t  replace_block_by (bb1, bb2);\n \t  nr_bbs_removed++;\n \t}\n     }\n@@ -1772,9 +1486,6 @@ update_debug_stmts (void)\n   bitmap_iterator bi;\n   unsigned int i;\n \n-  if (!MAY_HAVE_DEBUG_STMTS)\n-    return;\n-\n   EXECUTE_IF_SET_IN_BITMAP (update_bbs, 0, i, bi)\n     {\n       gimple stmt;\n@@ -1800,7 +1511,6 @@ tail_merge_optimize (unsigned int todo)\n   int nr_bbs_removed;\n   bool loop_entered = false;\n   int iteration_nr = 0;\n-  bool update_vops = !symbol_marked_for_renaming (gimple_vop (cfun));\n   int max_iterations = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_ITERATIONS);\n \n   if (!flag_tree_tail_merge || max_iterations == 0)\n@@ -1831,16 +1541,17 @@ tail_merge_optimize (unsigned int todo)\n       if (VEC_empty (bb_cluster, all_clusters))\n \tbreak;\n \n-      nr_bbs_removed = apply_clusters (update_vops);\n+      nr_bbs_removed = apply_clusters ();\n       nr_bbs_removed_total += nr_bbs_removed;\n       if (nr_bbs_removed == 0)\n \tbreak;\n \n-      purge_bbs ();\n+      free_dominance_info (CDI_DOMINATORS);\n \n       if (iteration_nr == max_iterations)\n \tbreak;\n \n+      calculate_dominance_info (CDI_DOMINATORS);\n       update_worklist ();\n     }\n \n@@ -1850,7 +1561,11 @@ tail_merge_optimize (unsigned int todo)\n \n   if (nr_bbs_removed_total > 0)\n     {\n-      update_debug_stmts ();\n+      if (MAY_HAVE_DEBUG_STMTS)\n+\t{\n+\t  calculate_dominance_info (CDI_DOMINATORS);\n+\t  update_debug_stmts ();\n+\t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1860,6 +1575,7 @@ tail_merge_optimize (unsigned int todo)\n \n       todo |= (TODO_verify_ssa | TODO_verify_stmts | TODO_verify_flow\n \t       | TODO_dump_func);\n+      mark_sym_for_renaming (gimple_vop (cfun));\n     }\n \n   delete_worklist ();"}]}