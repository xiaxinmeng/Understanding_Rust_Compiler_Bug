{"sha": "523e82a7a3204343688a56345ed5e99df777aea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIzZTgyYTdhMzIwNDM0MzY4OGE1NjM0NWVkNWU5OWRmNzc3YWVhNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-09-20T20:11:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-09-20T20:11:35Z"}, "message": "langhooks.h (struct lang_hooks_for_types): Remove hash_types field.\n\n\t* langhooks.h (struct lang_hooks_for_types): Remove hash_types field.\n\t* langhooks-def.h (LANG_HOOKS_HASH_TYPES): Delete.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Remove LANG_HOOKS_HASH_TYPES.\n\t* system.h (LANG_HOOKS_HASH_TYPES): Poison.\n\t* tree.c (type_hash_canon): Do not test lang_hooks.types.hash_types.\n\t(build_nonstandard_integer_type): Likewise.\n\t(build_range_type_1): New function, built from...\n\t(build_range_type): ...this.  Call build_range_type_1.\n\t(build_nonshared_range_type): New function.\n\t(build_array_type_1): New function, built from...\n\t(build_array_type: ...this.  Call build_array_type_1.\n\t(build_nonshared_array_type): New function.\n\t* tree.h (build_nonshared_range_type): Declare.\n\t(build_nonshared_array_type): Likewise.\nada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace calls to\n\tbuild_array_type with calls to build_nonshared_array_type.\n\t(substitute_in_type): Likewise.\n\t* gcc-interface/misc.c (LANG_HOOKS_HASH_TYPES): Delete.\n\t(LANG_HOOKS_TYPE_HASH_EQ): Define.\n\t(gnat_post_options): Add 'static' keyword.\n\t(gnat_type_hash_eq): New static function.\n\t* gcc-interface/utils.c (fntype_same_flags_p): New function.\n\t(create_subprog_type): Call it.\n\t(create_index_type): Call build_nonshared_range_type and tidy up.\n\t(create_range_type): Likewise.\n\t* gcc-interface/gigi.h (fntype_same_flags_p): Declare.\n\nFrom-SVN: r164452", "tree": {"sha": "4291df90e4876f78bbfe40aed9ee9925facd6467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4291df90e4876f78bbfe40aed9ee9925facd6467"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/523e82a7a3204343688a56345ed5e99df777aea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523e82a7a3204343688a56345ed5e99df777aea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523e82a7a3204343688a56345ed5e99df777aea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523e82a7a3204343688a56345ed5e99df777aea5/comments", "author": null, "committer": null, "parents": [{"sha": "8d03ad011afc65df43816e253af7728a738cb3f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d03ad011afc65df43816e253af7728a738cb3f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d03ad011afc65df43816e253af7728a738cb3f8"}], "stats": {"total": 219, "additions": 146, "deletions": 73}, "files": [{"sha": "faf3d0b69dab9f820f25ffeb5fea1fd449d6c8e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -1,3 +1,20 @@\n+2010-09-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* langhooks.h (struct lang_hooks_for_types): Remove hash_types field.\n+\t* langhooks-def.h (LANG_HOOKS_HASH_TYPES): Delete.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Remove LANG_HOOKS_HASH_TYPES.\n+\t* system.h (LANG_HOOKS_HASH_TYPES): Poison.\n+\t* tree.c (type_hash_canon): Do not test lang_hooks.types.hash_types.\n+\t(build_nonstandard_integer_type): Likewise.\n+\t(build_range_type_1): New function, built from...\n+\t(build_range_type): ...this.  Call build_range_type_1.\n+\t(build_nonshared_range_type): New function.\n+\t(build_array_type_1): New function, built from...\n+\t(build_array_type: ...this.  Call build_array_type_1.\n+\t(build_nonshared_array_type): New function.\n+\t* tree.h (build_nonshared_range_type): Declare.\n+\t(build_nonshared_array_type): Likewise.\n+\n 2010-09-20  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/arm/arm.h (CLASS_LIKELY_SPILLED_P): Remove."}, {"sha": "15100f651009ccd2431bbb82221b8dff8bf84064", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -1,3 +1,18 @@\n+2010-09-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace calls to\n+\tbuild_array_type with calls to build_nonshared_array_type.\n+\t(substitute_in_type): Likewise.\n+\t* gcc-interface/misc.c (LANG_HOOKS_HASH_TYPES): Delete.\n+\t(LANG_HOOKS_TYPE_HASH_EQ): Define.\n+\t(gnat_post_options): Add 'static' keyword.\n+\t(gnat_type_hash_eq): New static function.\n+\t* gcc-interface/utils.c (fntype_same_flags_p): New function.\n+\t(create_subprog_type): Call it.\n+\t(create_index_type): Call build_nonshared_range_type and tidy up.\n+\t(create_range_type): Likewise.\n+\t* gcc-interface/gigi.h (fntype_same_flags_p): Declare.\n+\n 2010-09-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (gnat_pushdecl): Do not do anything special"}, {"sha": "06698755b5e1faf8b5e7c64dc0cf6d50af09d1c3", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -2070,7 +2070,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Now build the array type.  */\n \tfor (index = ndim - 1; index >= 0; index--)\n \t  {\n-\t    tem = build_array_type (tem, gnu_index_types[index]);\n+\t    tem = build_nonshared_array_type (tem, gnu_index_types[index]);\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n \t    if (array_type_has_nonaliased_component (tem, gnat_entity))\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n@@ -2403,7 +2403,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Now build the array type.  */\n \t  for (index = ndim - 1; index >= 0; index --)\n \t    {\n-\t      gnu_type = build_array_type (gnu_type, gnu_index_types[index]);\n+\t      gnu_type = build_nonshared_array_type (gnu_type,\n+\t\t\t\t\t\t     gnu_index_types[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n \t      if (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n@@ -2649,8 +2650,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       gnat_entity);\n \n \tgnu_type\n-\t  = build_array_type (gnat_to_gnu_type (Component_Type (gnat_entity)),\n-\t\t\t      gnu_index_type);\n+\t  = build_nonshared_array_type (gnat_to_gnu_type\n+\t\t\t\t\t(Component_Type (gnat_entity)),\n+\t\t\t\t\tgnu_index_type);\n \tif (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t  TYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \trelate_alias_sets (gnu_type, gnu_string_type, ALIAS_SET_COPY);\n@@ -8610,7 +8612,7 @@ substitute_in_type (tree t, tree f, tree r)\n \tif (component == TREE_TYPE (t) && domain == TYPE_DOMAIN (t))\n \t  return t;\n \n-\tnt = build_array_type (component, domain);\n+\tnt = build_nonshared_array_type (component, domain);\n \tTYPE_ALIGN (nt) = TYPE_ALIGN (t);\n \tTYPE_USER_ALIGN (nt) = TYPE_USER_ALIGN (t);\n \tSET_TYPE_MODE (nt, TYPE_MODE (t));"}, {"sha": "dd30b246bb973382566af38cd26677dc38fad75d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -447,6 +447,9 @@ extern tree gnat_signed_type (tree type_node);\n    transparently converted to each other.  */\n extern int gnat_types_compatible_p (tree t1, tree t2);\n \n+/* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n+extern bool fntype_same_flags_p (const_tree, tree, bool, bool, bool);\n+\n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable"}, {"sha": "1167f0361e0f7a44e3fbc7ff1657c5f945daf921", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -72,6 +72,7 @@ static void gnat_print_decl\t\t(FILE *, tree, int);\n static void gnat_print_type\t\t(FILE *, tree, int);\n static const char *gnat_printable_name\t(tree, int);\n static const char *gnat_dwarf_name\t(tree, int);\n+static bool gnat_type_hash_eq\t\t(const_tree, const_tree);\n static tree gnat_return_tree\t\t(tree);\n static void gnat_parse_file\t\t(int);\n static void internal_error_function\t(diagnostic_context *,\n@@ -98,8 +99,8 @@ static tree gnat_eh_personality\t\t(void);\n #define LANG_HOOKS_POST_OPTIONS\t\tgnat_post_options\n #undef  LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n-#undef  LANG_HOOKS_HASH_TYPES\n-#define LANG_HOOKS_HASH_TYPES\t\tfalse\n+#undef  LANG_HOOKS_TYPE_HASH_EQ\n+#define LANG_HOOKS_TYPE_HASH_EQ\t\tgnat_type_hash_eq\n #undef  LANG_HOOKS_GETDECLS\n #define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n #undef  LANG_HOOKS_PUSHDECL\n@@ -304,7 +305,7 @@ gnat_init_options (unsigned int decoded_options_count,\n \n /* Post-switch processing.  */\n \n-bool\n+static bool\n gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n {\n   /* Excess precision other than \"fast\" requires front-end\n@@ -595,6 +596,20 @@ gnat_dwarf_name (tree decl, int verbosity ATTRIBUTE_UNUSED)\n   return (const char *) IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n \n+/* Return true if types T1 and T2 are identical for type hashing purposes.\n+   Called only after doing all language independent checks.  At present,\n+   this function is only called when both types are FUNCTION_TYPE.  */\n+\n+static bool\n+gnat_type_hash_eq (const_tree t1, const_tree t2)\n+{\n+  gcc_assert (TREE_CODE (t1) == FUNCTION_TYPE);\n+  return fntype_same_flags_p (t1, TYPE_CI_CO_LIST (t2),\n+\t\t\t      TYPE_RETURN_UNCONSTRAINED_P (t2),\n+\t\t\t      TYPE_RETURN_BY_DIRECT_REF_P (t2),\n+\t\t\t      TREE_ADDRESSABLE (t2));\n+}\n+\n /* Do nothing (return the tree node passed).  */\n \n static tree"}, {"sha": "3fab92b0c1e43e2e9f5f353d2016b388d6c956c6", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -1106,10 +1106,8 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n \n   /* TYPE may have been shared since GCC hashes types.  If it has a different\n      CICO_LIST, make a copy.  Likewise for the various flags.  */\n-  if (TYPE_CI_CO_LIST (type) != cico_list\n-      || TYPE_RETURN_UNCONSTRAINED_P (type) != return_unconstrained_p\n-      || TYPE_RETURN_BY_DIRECT_REF_P (type) != return_by_direct_ref_p\n-      || TREE_ADDRESSABLE (type) != return_by_invisi_ref_p)\n+  if (!fntype_same_flags_p (type, cico_list, return_unconstrained_p,\n+\t\t\t    return_by_direct_ref_p, return_by_invisi_ref_p))\n     {\n       type = copy_type (type);\n       TYPE_CI_CO_LIST (type) = cico_list;\n@@ -1165,17 +1163,9 @@ tree\n create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n {\n   /* First build a type for the desired range.  */\n-  tree type = build_range_type (sizetype, min, max);\n-\n-  /* If this type has the TYPE_INDEX_TYPE we want, return it.  */\n-  if (TYPE_INDEX_TYPE (type) == index)\n-    return type;\n-\n-  /* Otherwise, if TYPE_INDEX_TYPE is set, make a copy.  Note that we have\n-     no way of sharing these types, but that's only a small hole.  */\n-  if (TYPE_INDEX_TYPE (type))\n-    type = copy_type (type);\n+  tree type = build_nonshared_range_type (sizetype, min, max);\n \n+  /* Then set the index type.  */\n   SET_TYPE_INDEX_TYPE (type, index);\n   create_type_decl (NULL_TREE, type, NULL, true, false, gnat_node);\n \n@@ -1194,26 +1184,12 @@ create_range_type (tree type, tree min, tree max)\n     type = sizetype;\n \n   /* First build a type with the base range.  */\n-  range_type\n-    = build_range_type (type, TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type));\n-\n-  min = convert (type, min);\n-  max = convert (type, max);\n-\n-  /* If this type has the TYPE_RM_{MIN,MAX}_VALUE we want, return it.  */\n-  if (TYPE_RM_MIN_VALUE (range_type)\n-      && TYPE_RM_MAX_VALUE (range_type)\n-      && operand_equal_p (TYPE_RM_MIN_VALUE (range_type), min, 0)\n-      && operand_equal_p (TYPE_RM_MAX_VALUE (range_type), max, 0))\n-    return range_type;\n-\n-  /* Otherwise, if TYPE_RM_{MIN,MAX}_VALUE is set, make a copy.  */\n-  if (TYPE_RM_MIN_VALUE (range_type) || TYPE_RM_MAX_VALUE (range_type))\n-    range_type = copy_type (range_type);\n+  range_type = build_nonshared_range_type (type, TYPE_MIN_VALUE (type),\n+\t\t\t\t\t\t TYPE_MAX_VALUE (type));\n \n   /* Then set the actual range.  */\n-  SET_TYPE_RM_MIN_VALUE (range_type, min);\n-  SET_TYPE_RM_MAX_VALUE (range_type, max);\n+  SET_TYPE_RM_MIN_VALUE (range_type, convert (type, min));\n+  SET_TYPE_RM_MAX_VALUE (range_type, convert (type, max));\n \n   return range_type;\n }\n@@ -2121,6 +2097,18 @@ gnat_types_compatible_p (tree t1, tree t2)\n \n   return 0;\n }\n+\n+/* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n+\n+bool\n+fntype_same_flags_p (const_tree t, tree cico_list, bool return_unconstrained_p,\n+\t\t     bool return_by_direct_ref_p, bool return_by_invisi_ref_p)\n+{\n+  return TYPE_CI_CO_LIST (t) == cico_list\n+\t && TYPE_RETURN_UNCONSTRAINED_P (t) == return_unconstrained_p\n+\t && TYPE_RETURN_BY_DIRECT_REF_P (t) == return_by_direct_ref_p\n+\t && TREE_ADDRESSABLE (t) == return_by_invisi_ref_p;\n+}\n \f\n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or"}, {"sha": "a4dda6b7bed885109ebbf926c03546f601ee72d7", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -178,7 +178,6 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tNULL\n #define LANG_HOOKS_GET_SUBRANGE_BOUNDS\tNULL\n #define LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE reconstruct_complex_type\n-#define LANG_HOOKS_HASH_TYPES\t\ttrue\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n   LANG_HOOKS_MAKE_TYPE, \\\n@@ -195,8 +194,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_TYPE_HASH_EQ, \\\n   LANG_HOOKS_GET_ARRAY_DESCR_INFO, \\\n   LANG_HOOKS_GET_SUBRANGE_BOUNDS, \\\n-  LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE, \\\n-  LANG_HOOKS_HASH_TYPES \\\n+  LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE \\\n }\n \n /* Declaration hooks.  */"}, {"sha": "eb8b8fcfbd4257565ddfc4df44c2c4ff83919a64", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -138,11 +138,6 @@ struct lang_hooks_for_types\n      return values from functions.  The argument TYPE is the top of the\n      chain, and BOTTOM is the new type which we will point to.  */\n   tree (*reconstruct_complex_type) (tree, tree);\n-\n-  /* Nonzero if types that are identical are to be hashed so that only\n-     one copy is kept.  If a language requires unique types for each\n-     user-specified type, such as Ada, this should be set to TRUE.  */\n-  bool hash_types;\n };\n \n /* Language hooks related to decls and the symbol table.  */"}, {"sha": "178eec01b493711e698e17465b55bb07482571c1", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -781,7 +781,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tLANG_HOOKS_MAYBE_BUILD_CLEANUP LANG_HOOKS_UPDATE_DECL_AFTER_SAVING \\\n \tLANG_HOOKS_POPLEVEL LANG_HOOKS_TRUTHVALUE_CONVERSION \\\n \tTARGET_PROMOTE_FUNCTION_ARGS TARGET_PROMOTE_FUNCTION_RETURN \\\n-\tLANG_HOOKS_MISSING_ARGUMENT\n+\tLANG_HOOKS_MISSING_ARGUMENT LANG_HOOKS_HASH_TYPES\n \n /* Miscellaneous macros that are no longer used.  */\n  #pragma GCC poison USE_MAPPED_LOCATION"}, {"sha": "84234162033dccf0e1772c932e9c6b822911142c", "filename": "gcc/tree.c", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -6123,9 +6123,6 @@ type_hash_canon (unsigned int hashcode, tree type)\n      being passed.  */\n   gcc_assert (TYPE_MAIN_VARIANT (type) == type);\n \n-  if (!lang_hooks.types.hash_types)\n-    return type;\n-\n   /* See if the type is in the hash table already.  If so, return it.\n      Otherwise, add the type.  */\n   t1 = type_hash_lookup (hashcode, type);\n@@ -7093,21 +7090,20 @@ build_nonstandard_integer_type (unsigned HOST_WIDE_INT precision,\n   ret = itype;\n   if (host_integerp (TYPE_MAX_VALUE (itype), 1))\n     ret = type_hash_canon (tree_low_cst (TYPE_MAX_VALUE (itype), 1), itype);\n-  if (precision <= MAX_INT_CACHED_PREC && lang_hooks.types.hash_types)\n+  if (precision <= MAX_INT_CACHED_PREC)\n     nonstandard_integer_type_cache[precision + unsignedp] = ret;\n \n   return ret;\n }\n \n-/* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n-   ENUMERAL_TYPE or BOOLEAN_TYPE), with low bound LOWVAL and\n-   high bound HIGHVAL.  */\n+/* Create a range of some discrete type TYPE (an INTEGER_TYPE, ENUMERAL_TYPE\n+   or BOOLEAN_TYPE) with low bound LOWVAL and high bound HIGHVAL.  If SHARED\n+   is true, reuse such a type that has already been constructed.  */\n \n-tree\n-build_range_type (tree type, tree lowval, tree highval)\n+static tree\n+build_range_type_1 (tree type, tree lowval, tree highval, bool shared)\n {\n   tree itype = make_node (INTEGER_TYPE);\n-  hashval_t hash;\n \n   TREE_TYPE (itype) = type;\n \n@@ -7131,10 +7127,32 @@ build_range_type (tree type, tree lowval, tree highval)\n       SET_TYPE_STRUCTURAL_EQUALITY (itype);\n       return itype;\n     }\n-  hash = iterative_hash_expr (TYPE_MIN_VALUE (itype), 0);\n-  hash = iterative_hash_expr (TYPE_MAX_VALUE (itype), hash);\n-  hash = iterative_hash_hashval_t (TYPE_HASH (type), hash);\n-  return type_hash_canon (hash, itype);\n+\n+  if (shared)\n+    {\n+      hashval_t hash = iterative_hash_expr (TYPE_MIN_VALUE (itype), 0);\n+      hash = iterative_hash_expr (TYPE_MAX_VALUE (itype), hash);\n+      hash = iterative_hash_hashval_t (TYPE_HASH (type), hash);\n+      itype = type_hash_canon (hash, itype);\n+    }\n+\n+  return itype;\n+}\n+\n+/* Wrapper around build_range_type_1 with SHARED set to true.  */\n+\n+tree\n+build_range_type (tree type, tree lowval, tree highval)\n+{\n+  return build_range_type_1 (type, lowval, highval, true);\n+}\n+\n+/* Wrapper around build_range_type_1 with SHARED set to false.  */\n+\n+tree\n+build_nonshared_range_type (tree type, tree lowval, tree highval)\n+{\n+  return build_range_type_1 (type, lowval, highval, false);\n }\n \n /* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.\n@@ -7205,13 +7223,12 @@ subrange_type_for_debug_p (const_tree type, tree *lowval, tree *highval)\n \n /* Construct, lay out and return the type of arrays of elements with ELT_TYPE\n    and number of elements specified by the range of values of INDEX_TYPE.\n-   If such a type has already been constructed, reuse it.  */\n+   If SHARED is true, reuse such a type that has already been constructed.  */\n \n-tree\n-build_array_type (tree elt_type, tree index_type)\n+static tree\n+build_array_type_1 (tree elt_type, tree index_type, bool shared)\n {\n   tree t;\n-  hashval_t hashcode = 0;\n \n   if (TREE_CODE (elt_type) == FUNCTION_TYPE)\n     {\n@@ -7231,10 +7248,13 @@ build_array_type (tree elt_type, tree index_type)\n   if (TYPE_STRUCTURAL_EQUALITY_P (t))\n     return t;\n \n-  hashcode = iterative_hash_object (TYPE_HASH (elt_type), hashcode);\n-  if (index_type)\n-    hashcode = iterative_hash_object (TYPE_HASH (index_type), hashcode);\n-  t = type_hash_canon (hashcode, t);\n+  if (shared)\n+    {\n+      hashval_t hashcode = iterative_hash_object (TYPE_HASH (elt_type), 0);\n+      if (index_type)\n+\thashcode = iterative_hash_object (TYPE_HASH (index_type), hashcode);\n+      t = type_hash_canon (hashcode, t);\n+    }\n \n   if (TYPE_CANONICAL (t) == t)\n     {\n@@ -7244,13 +7264,31 @@ build_array_type (tree elt_type, tree index_type)\n       else if (TYPE_CANONICAL (elt_type) != elt_type\n \t       || (index_type && TYPE_CANONICAL (index_type) != index_type))\n \tTYPE_CANONICAL (t)\n-\t  = build_array_type (TYPE_CANONICAL (elt_type),\n-\t\t\t      index_type ? TYPE_CANONICAL (index_type) : NULL);\n+\t  = build_array_type_1 (TYPE_CANONICAL (elt_type),\n+\t\t\t\tindex_type\n+\t\t\t\t? TYPE_CANONICAL (index_type) : NULL_TREE,\n+\t\t\t\tshared);\n     }\n \n   return t;\n }\n \n+/* Wrapper around build_array_type_1 with SHARED set to true.  */\n+\n+tree\n+build_array_type (tree elt_type, tree index_type)\n+{\n+  return build_array_type_1 (elt_type, index_type, true);\n+}\n+\n+/* Wrapper around build_array_type_1 with SHARED set to false.  */\n+\n+tree\n+build_nonshared_array_type (tree elt_type, tree index_type)\n+{\n+  return build_array_type_1 (elt_type, index_type, false);\n+}\n+\n /* Recursively examines the array elements of TYPE, until a non-array\n    element type is found.  */\n "}, {"sha": "e7d0c53f88e5cc3b0e13dd4f4e6d6d1de10bd4fc", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523e82a7a3204343688a56345ed5e99df777aea5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=523e82a7a3204343688a56345ed5e99df777aea5", "patch": "@@ -4102,6 +4102,7 @@ extern tree build_opaque_vector_type (tree innertype, int nunits);\n extern tree build_type_no_quals (tree);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree);\n+extern tree build_nonshared_array_type (tree, tree);\n extern tree build_function_type (tree, tree);\n extern tree build_function_type_list (tree, ...);\n extern tree build_function_type_skip_args (tree, bitmap);\n@@ -5127,6 +5128,7 @@ extern void build_common_tree_nodes_2 (int);\n extern void build_common_builtin_nodes (void);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n+extern tree build_nonshared_range_type (tree, tree, tree);\n extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);\n extern HOST_WIDE_INT int_cst_value (const_tree);\n extern HOST_WIDEST_INT widest_int_cst_value (const_tree);"}]}