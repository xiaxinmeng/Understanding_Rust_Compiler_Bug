{"sha": "94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlNmU0YzRmM2Q3NTMzYWIxZGU3YjcwOWUzYjMzMDVkM2Q4ZTUyZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-05-14T17:20:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-05-14T17:20:47Z"}, "message": "cp-tree.h (struct lang_type): Added non_zero_init.\n\n* cp-tree.h (struct lang_type): Added non_zero_init.\n(CLASS_NON_ZERO_INIT_P): New macro.\n(zero_init_p, force_store_init_value, build_forced_zero_init): Declare.\n* class.c (check_field_decls): Test non_zero_init.\n* cvt.c (convert_to_pointer_force): Use cp_convert_to_pointer for\nzero-to-NULL conversions.\n* decl.c (obscure_complex_init): Don't reset DECL_INITIAL of a\ntype that needs zero-initialization without zeros.\n(check_initializer_decl): Compute zero-initializer for types\nthat require a non-trivial one.\n* init.c (build_forced_zero_init): New function.\n(build_default_init): Use it.\n* tree.c (zero_init_p): New function.\n* typeck2.c (force_store_init_value): New function.\n(process_init_constructor): Create non-trivial zero-initializers\nfor array members and class fields.\n\nFrom-SVN: r53461", "tree": {"sha": "8e6a21c939257492f2f1761473f122f6de4c33dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e6a21c939257492f2f1761473f122f6de4c33dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/comments", "author": null, "committer": null, "parents": [{"sha": "e5f5feea65f904d95c6f7aded34f8d2f447141e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f5feea65f904d95c6f7aded34f8d2f447141e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f5feea65f904d95c6f7aded34f8d2f447141e9"}], "stats": {"total": 181, "additions": 143, "deletions": 38}, "files": [{"sha": "b5dcccdd596b762317dc4d04d9dc5808631fba13", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1,3 +1,22 @@\n+2002-05-14  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* cp-tree.h (struct lang_type): Added non_zero_init.\n+\t(CLASS_NON_ZERO_INIT_P): New macro.\n+\t(zero_init_p, force_store_init_value, build_forced_zero_init): Declare.\n+\t* class.c (check_field_decls): Test non_zero_init.\n+\t* cvt.c (convert_to_pointer_force): Use cp_convert_to_pointer for\n+\tzero-to-NULL conversions.\n+\t* decl.c (obscure_complex_init): Don't reset DECL_INITIAL of a\n+\ttype that needs zero-initialization without zeros.\n+\t(check_initializer_decl): Compute zero-initializer for types\n+\tthat require a non-trivial one.\n+\t* init.c (build_forced_zero_init): New function.\n+\t(build_default_init): Use it.\n+\t* tree.c (zero_init_p): New function.\n+\t* typeck2.c (force_store_init_value): New function.\n+\t(process_init_constructor): Create non-trivial zero-initializers\n+\tfor array members and class fields.\n+\n 2002-05-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* lang-specs.h: Remove redundant -lang-c++."}, {"sha": "64b528a5a67e3eaeed357c0fd7aa4dbbd33e134d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -3405,6 +3405,9 @@ check_field_decls (t, access_decls, empty_p,\n            to be allowed in POD structs.  */\n \tCLASSTYPE_NON_POD_P (t) = 1;\n \n+      if (! zero_init_p (type))\n+\tCLASSTYPE_NON_ZERO_INIT_P (t) = 1;\n+\n       /* If any field is const, the structure type is pseudo-const.  */\n       if (CP_TYPE_CONST_P (type))\n \t{"}, {"sha": "a1d4ddb88bd143817d73d45403203f2faa9e0d0f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1240,14 +1240,16 @@ struct lang_type\n   unsigned is_partial_instantiation : 1;\n   unsigned java_interface : 1;\n \n+  unsigned non_zero_init : 1;\n+\n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n      so, make sure to copy it in instantiate_class_template!  */\n \n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 8;\n+  unsigned dummy : 7;\n \n   int vsize;\n \n@@ -1501,9 +1503,14 @@ struct lang_type\n #define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC (NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n-/*  Nonzero means that this class type is a non-POD class.  */\n+/* Nonzero means that this class type is a non-POD class.  */\n #define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_pod_class)\n \n+/* Nonzero means that this class contains pod types whose default\n+   initialization is not a zero initialization (namely, pointers to\n+   data members).  */\n+#define CLASSTYPE_NON_ZERO_INIT_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_zero_init)\n+\n /* Nonzero if this class is \"nearly empty\", i.e., contains only a\n    virtual function table pointer.  */\n #define CLASSTYPE_NEARLY_EMPTY_P(NODE) \\\n@@ -3912,6 +3919,7 @@ extern tree build_init\t\t\t\tPARAMS ((tree, tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n extern tree get_aggr_from_typedef\t\tPARAMS ((tree, int));\n extern tree get_type_value\t\t\tPARAMS ((tree));\n+extern tree build_forced_zero_init\t\tPARAMS ((tree));\n extern tree build_member_call\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n@@ -4230,6 +4238,7 @@ extern tree cxx_unsave_expr_now\t\tPARAMS ((tree));\n extern tree cxx_maybe_build_cleanup\t\tPARAMS ((tree));\n extern void init_tree\t\t\t        PARAMS ((void));\n extern int pod_type_p\t\t\t\tPARAMS ((tree));\n+extern int zero_init_p\t\t\t\tPARAMS ((tree));\n extern tree canonical_type_variant              PARAMS ((tree));\n extern void unshare_base_binfos\t\t\tPARAMS ((tree));\n extern int member_p\t\t\t\tPARAMS ((tree));\n@@ -4376,6 +4385,7 @@ extern int abstract_virtuals_error\t\tPARAMS ((tree, tree));\n #define my_friendly_assert(EXP, N) (void) \\\n  (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n \n+extern tree force_store_init_value\t\tPARAMS ((tree, tree));\n extern tree store_init_value\t\t\tPARAMS ((tree, tree));\n extern tree digest_init\t\t\t\tPARAMS ((tree, tree, tree *));\n extern tree build_scoped_ref\t\t\tPARAMS ((tree, tree, tree *));"}, {"sha": "0c43fc3609c9f422387e3dabe3d4de730d29e5e1", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1,6 +1,6 @@\n /* Language-level data type conversion for GNU C++.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -288,13 +288,6 @@ convert_to_pointer_force (type, expr)\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form = TREE_CODE (intype);\n   \n-  if (integer_zerop (expr))\n-    {\n-      expr = build_int_2 (0, 0);\n-      TREE_TYPE (expr) = type;\n-      return expr;\n-    }\n-\n   if (form == POINTER_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);"}, {"sha": "6c5b97999c71c1dc01b6fca8e1362eb9ff9f03a6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -7592,7 +7592,13 @@ obscure_complex_init (decl, init)\n \t\t\t\t NULL_TREE);\n   else\n #endif\n-    DECL_INITIAL (decl) = error_mark_node;\n+    {\n+      if (zero_init_p (TREE_TYPE (decl)))\n+\tDECL_INITIAL (decl) = error_mark_node;\n+      /* Otherwise, force_store_init_value will have already stored a\n+\t zero-init initializer in DECL_INITIAL, that should be\n+\t retained.  */\n+    }\n \n   return init;\n }\n@@ -7838,8 +7844,16 @@ check_initializer (decl, init)\n       if (init)\n \tinit = obscure_complex_init (decl, init);\n     }\n+  else if (!DECL_EXTERNAL (decl) && !zero_init_p (type))\n+    {\n+      force_store_init_value (decl, build_forced_zero_init (type));\n+\n+      if (init)\n+\tgoto process_init;\n+    }\n   else if (init)\n     {\n+    process_init:\n       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n \t  if (TREE_CODE (type) == ARRAY_TYPE)"}, {"sha": "9827307126791567181076724e07aaa683ddd0ac", "filename": "gcc/cp/init.c", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1,6 +1,6 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -156,6 +156,44 @@ initialize_vtbl_ptrs (addr)\n \t    dfs_marked_real_bases_queue_p, type);\n }\n \n+/* Types containing pointers to data members cannot be\n+   zero-initialized with zeros, because the NULL value for such\n+   pointers is -1.\n+\n+   TYPE is a type that requires such zero initialization.  The\n+   returned value is the initializer.  */\n+\n+tree\n+build_forced_zero_init (type)\n+     tree type;\n+{\n+  tree init = NULL;\n+\n+  if (AGGREGATE_TYPE_P (type) && !TYPE_PTRMEMFUNC_P (type))\n+    {\n+      /* This is a default initialization of an aggregate, but not one of\n+\t non-POD class type.  We cleverly notice that the initialization\n+\t rules in such a case are the same as for initialization with an\n+\t empty brace-initialization list.  */\n+      init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n+    }\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+    /*   --if T is a reference type, no initialization is performed.  */\n+    return NULL_TREE;\n+  else\n+    {\n+      init = integer_zero_node;\n+      \n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+        /* We must make enumeral types the right type. */\n+        init = fold (build1 (NOP_EXPR, type, init));\n+    }\n+\n+  init = digest_init (type, init, 0);\n+\n+  return init;\n+}\n+\n /* [dcl.init]:\n \n   To default-initialize an object of type T means:\n@@ -182,28 +220,8 @@ build_default_init (type)\n        anything with a CONSTRUCTOR for arrays here, as that would imply\n        copy-initialization.  */\n     return NULL_TREE;\n-  else if (AGGREGATE_TYPE_P (type) && !TYPE_PTRMEMFUNC_P (type))\n-    {\n-      /* This is a default initialization of an aggregate, but not one of\n-\t non-POD class type.  We cleverly notice that the initialization\n-\t rules in such a case are the same as for initialization with an\n-\t empty brace-initialization list.  */\n-      init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n-    }\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-    /*   --if T is a reference type, no initialization is performed.  */\n-    return NULL_TREE;\n-  else\n-    {\n-      init = integer_zero_node;\n-      \n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n-        /* We must make enumeral types the right type. */\n-        init = fold (build1 (NOP_EXPR, type, init));\n-    }\n \n-  init = digest_init (type, init, 0);\n-  return init;\n+  return build_forced_zero_init (type);\n }\n \n /* Subroutine of emit_base_init.  */"}, {"sha": "9a52cc0b53148da25d02023ac4498b612fbcc1dc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1,6 +1,6 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1901,6 +1901,27 @@ pod_type_p (t)\n   return 1;\n }\n \n+/* Returns 1 iff zero initialization of type T means actually storing\n+   zeros in it.  */\n+\n+int\n+zero_init_p (t)\n+     tree t;\n+{\n+  t = strip_array_types (t);\n+\n+  /* NULL pointers to data members are initialized with -1.  */\n+  if (TYPE_PTRMEM_P (t))\n+    return 0;\n+\n+  /* Classes that contain types that can't be zero-initialized, cannot\n+     be zero-initialized themselves.  */\n+  if (CLASS_TYPE_P (t) && CLASSTYPE_NON_ZERO_INIT_P (t))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Table of valid C++ attributes.  */\n const struct attribute_spec cxx_attribute_table[] =\n {"}, {"sha": "b83750326c3cf5983656c52ae19bc6f31ac3ad7b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=94e6e4c4f3d7533ab1de7b709e3b3305d3d8e52d", "patch": "@@ -1,7 +1,7 @@\n /* Report error messages, build initializers, and perform\n    some front-end optimizations for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -420,6 +420,28 @@ store_init_value (decl, init)\n   DECL_INITIAL (decl) = value;\n   return NULL_TREE;\n }\n+\n+/* Same as store_init_value, but used for known-to-be-valid static\n+   initializers.  Used to introduce a static initializer even in data\n+   structures that may require dynamic initialization.  */\n+\n+tree\n+force_store_init_value (decl, init)\n+     tree decl, init;\n+{\n+  tree type = TREE_TYPE (decl);\n+  int needs_constructing = TYPE_NEEDS_CONSTRUCTING (type);\n+\n+  TYPE_NEEDS_CONSTRUCTING (type) = 0;\n+\n+  init = store_init_value (decl, init);\n+  if (init)\n+    abort ();\n+\n+  TYPE_NEEDS_CONSTRUCTING (type) = needs_constructing;\n+\n+  return init;\n+}  \n \f\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n@@ -732,6 +754,8 @@ process_init_constructor (type, init, elts)\n \t\tnext1 = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n \t      next1 = digest_init (TREE_TYPE (type), next1, 0);\n \t    }\n+\t  else if (! zero_init_p (TREE_TYPE (type)))\n+\t    next1 = build_forced_zero_init (TREE_TYPE (type));\n \t  else\n \t    /* The default zero-initialization is fine for us; don't\n \t       add anything to the CONSTRUCTOR.  */\n@@ -848,9 +872,12 @@ process_init_constructor (type, init, elts)\n \t          && (!init || TREE_HAS_CONSTRUCTOR (init)))\n \t\twarning (\"missing initializer for member `%D'\", field);\n \n-\t      /* The default zero-initialization is fine for us; don't\n-\t\t add anything to the CONSTRUCTOR.  */\n-\t      continue;\n+\t      if (! zero_init_p (TREE_TYPE (field)))\n+\t\tnext1 = build_forced_zero_init (TREE_TYPE (field));\n+\t      else\n+\t\t/* The default zero-initialization is fine for us; don't\n+\t\t   add anything to the CONSTRUCTOR.  */\n+\t\tcontinue;\n \t    }\n \n \t  if (next1 == error_mark_node)"}]}