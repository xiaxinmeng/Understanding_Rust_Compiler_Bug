{"sha": "01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyNzVlMWU1YThkNDVmMzUxMjFmNGNlNzM0NWRkNjJlNTVjZjYwZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-05-30T12:05:30Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-05-30T12:05:30Z"}, "message": "re PR libgomp/80822 (libgomp incorrect affinity when OMP_PLACES=threads)\n\n\tPR libgomp/80822\n\t* config/linux/affinity.c (gomp_affinity_init_level_1): New function.\n\t(gomp_affinity_init_level): Use it.  Always analyze the core and thread\n\tsibling lists, depending on level just pick up what CPUs to put\n\ttogether into a place vs. whether add multiple ordered places.\n\nFrom-SVN: r248683", "tree": {"sha": "6e6e460487e536f7cc1a6782355c11a9cc9266ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e6e460487e536f7cc1a6782355c11a9cc9266ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01275e1e5a8d45f35121f4ce7345dd62e55cf60e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba7629e2dd50baaa34acb9430c2087073685c0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7629e2dd50baaa34acb9430c2087073685c0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba7629e2dd50baaa34acb9430c2087073685c0fa"}], "stats": {"total": 181, "additions": 98, "deletions": 83}, "files": [{"sha": "a51228b4504c2102fca00cf3b1a0ec22e67adf87", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01275e1e5a8d45f35121f4ce7345dd62e55cf60e/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01275e1e5a8d45f35121f4ce7345dd62e55cf60e/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "patch": "@@ -1,3 +1,11 @@\n+2017-05-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/80822\n+\t* config/linux/affinity.c (gomp_affinity_init_level_1): New function.\n+\t(gomp_affinity_init_level): Use it.  Always analyze the core and thread\n+\tsibling lists, depending on level just pick up what CPUs to put\n+\ttogether into a place vs. whether add multiple ordered places.\n+\n 2017-05-24  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* openacc.h (acc_async_wait, acc_async_wait_all): New prototypes."}, {"sha": "cbc96870f4fc87aa30d7bd2098191d5a8c041d2d", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 90, "deletions": 83, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01275e1e5a8d45f35121f4ce7345dd62e55cf60e/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01275e1e5a8d45f35121f4ce7345dd62e55cf60e/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=01275e1e5a8d45f35121f4ce7345dd62e55cf60e", "patch": "@@ -222,10 +222,87 @@ gomp_affinity_finalize_place_list (bool quiet)\n   return true;\n }\n \n+static void\n+gomp_affinity_init_level_1 (int level, int this_level, unsigned long count,\n+\t\t\t    cpu_set_t *copy, char *name, bool quiet)\n+{\n+  size_t prefix_len = sizeof (\"/sys/devices/system/cpu/cpu\") - 1;\n+  FILE *f;\n+  char *line = NULL;\n+  size_t linelen = 0;\n+  unsigned long i, max = 8 * gomp_cpuset_size;\n+\n+  for (i = 0; i < max && gomp_places_list_len < count; i++)\n+    if (CPU_ISSET_S (i, gomp_cpuset_size, copy))\n+      {\n+\tsprintf (name + prefix_len, \"%lu/topology/%s_siblings_list\",\n+\t\t i, this_level == 3 ? \"core\" : \"thread\");\n+\tf = fopen (name, \"r\");\n+\tif (f == NULL)\n+\t  {\n+\t    CPU_CLR_S (i, gomp_cpuset_size, copy);\n+\t    continue;\n+\t  }\n+\tif (getline (&line, &linelen, f) > 0)\n+\t  {\n+\t    char *p = line;\n+\t    void *pl = gomp_places_list[gomp_places_list_len];\n+\t    if (level == this_level)\n+\t      gomp_affinity_init_place (pl);\n+\t    while (*p && *p != '\\n')\n+\t      {\n+\t\tunsigned long first, last;\n+\t\terrno = 0;\n+\t\tfirst = strtoul (p, &p, 10);\n+\t\tif (errno)\n+\t\t  break;\n+\t\tlast = first;\n+\t\tif (*p == '-')\n+\t\t  {\n+\t\t    errno = 0;\n+\t\t    last = strtoul (p + 1, &p, 10);\n+\t\t    if (errno || last < first)\n+\t\t      break;\n+\t\t  }\n+\t\tfor (; first <= last; first++)\n+\t\t  if (!CPU_ISSET_S (first, gomp_cpuset_size, copy))\n+\t\t    continue;\n+\t\t  else if (this_level == 3 && level < this_level)\n+\t\t    gomp_affinity_init_level_1 (level, 2, count, copy,\n+\t\t\t\t\t\tname, quiet);\n+\t\t  else\n+\t\t    {\n+\t\t      if (level == 1)\n+\t\t\t{\n+\t\t\t  pl = gomp_places_list[gomp_places_list_len];\n+\t\t\t  gomp_affinity_init_place (pl);\n+\t\t\t}\n+\t\t      if (gomp_affinity_add_cpus (pl, first, 1, 0, true))\n+\t\t\t{\n+\t\t\t  CPU_CLR_S (first, gomp_cpuset_size, copy);\n+\t\t\t  if (level == 1)\n+\t\t\t    gomp_places_list_len++;\n+\t\t\t}\n+\t\t    }\n+\t\tif (*p == ',')\n+\t\t  ++p;\n+\t      }\n+\t    if (level == this_level\n+\t\t&& !CPU_ISSET_S (i, gomp_cpuset_size, copy))\n+\t      gomp_places_list_len++;\n+\t    CPU_CLR_S (i, gomp_cpuset_size, copy);\n+\t  }\n+\tfclose (f);\n+      }\n+  free (line);\n+}\n+\n bool\n gomp_affinity_init_level (int level, unsigned long count, bool quiet)\n {\n-  unsigned long i, max = 8 * gomp_cpuset_size;\n+  char name[sizeof (\"/sys/devices/system/cpu/cpu/topology/\"\n+\t\t    \"thread_siblings_list\") + 3 * sizeof (unsigned long)];\n+  cpu_set_t *copy;\n \n   if (gomp_cpusetp)\n     {\n@@ -238,90 +315,20 @@ gomp_affinity_init_level (int level, unsigned long count, bool quiet)\n   gomp_places_list_len = 0;\n   if (gomp_places_list == NULL)\n     return false;\n-  /* SMT (threads).  */\n-  if (level == 1)\n-    {\n-      for (i = 0; i < max && gomp_places_list_len < count; i++)\n-\tif (CPU_ISSET_S (i, gomp_cpuset_size, gomp_cpusetp))\n-\t  {\n-\t    gomp_affinity_init_place (gomp_places_list[gomp_places_list_len]);\n-\t    gomp_affinity_add_cpus (gomp_places_list[gomp_places_list_len],\n-\t\t\t\t    i, 1, 0, true);\n-\t    ++gomp_places_list_len;\n-\t  }\n-      return true;\n-    }\n-  else\n+\n+  copy = gomp_alloca (gomp_cpuset_size);\n+  strcpy (name, \"/sys/devices/system/cpu/cpu\");\n+  memcpy (copy, gomp_cpusetp, gomp_cpuset_size);\n+  gomp_affinity_init_level_1 (level, 3, count, copy, name, quiet);\n+  if (gomp_places_list_len == 0)\n     {\n-      char name[sizeof (\"/sys/devices/system/cpu/cpu/topology/\"\n-\t\t\t\"thread_siblings_list\") + 3 * sizeof (unsigned long)];\n-      size_t prefix_len = sizeof (\"/sys/devices/system/cpu/cpu\") - 1;\n-      cpu_set_t *copy = gomp_alloca (gomp_cpuset_size);\n-      FILE *f;\n-      char *line = NULL;\n-      size_t linelen = 0;\n-\n-      memcpy (name, \"/sys/devices/system/cpu/cpu\", prefix_len);\n-      memcpy (copy, gomp_cpusetp, gomp_cpuset_size);\n-      for (i = 0; i < max && gomp_places_list_len < count; i++)\n-\tif (CPU_ISSET_S (i, gomp_cpuset_size, copy))\n-\t  {\n-\t    sprintf (name + prefix_len, \"%lu/topology/%s_siblings_list\",\n-\t\t     i, level == 2 ? \"thread\" : \"core\");\n-\t    f = fopen (name, \"r\");\n-\t    if (f != NULL)\n-\t      {\n-\t\tif (getline (&line, &linelen, f) > 0)\n-\t\t  {\n-\t\t    char *p = line;\n-\t\t    bool seen_i = false;\n-\t\t    void *pl = gomp_places_list[gomp_places_list_len];\n-\t\t    gomp_affinity_init_place (pl);\n-\t\t    while (*p && *p != '\\n')\n-\t\t      {\n-\t\t\tunsigned long first, last;\n-\t\t\terrno = 0;\n-\t\t\tfirst = strtoul (p, &p, 10);\n-\t\t\tif (errno)\n-\t\t\t  break;\n-\t\t\tlast = first;\n-\t\t\tif (*p == '-')\n-\t\t\t  {\n-\t\t\t    errno = 0;\n-\t\t\t    last = strtoul (p + 1, &p, 10);\n-\t\t\t    if (errno || last < first)\n-\t\t\t      break;\n-\t\t\t  }\n-\t\t\tfor (; first <= last; first++)\n-\t\t\t  if (CPU_ISSET_S (first, gomp_cpuset_size, copy)\n-\t\t\t      && gomp_affinity_add_cpus (pl, first, 1, 0,\n-\t\t\t\t\t\t\t true))\n-\t\t\t    {\n-\t\t\t      CPU_CLR_S (first, gomp_cpuset_size, copy);\n-\t\t\t      if (first == i)\n-\t\t\t\tseen_i = true;\n-\t\t\t    }\n-\t\t\tif (*p == ',')\n-\t\t\t  ++p;\n-\t\t      }\n-\t\t    if (seen_i)\n-\t\t      gomp_places_list_len++;\n-\t\t  }\n-\t\tfclose (f);\n-\t      }\n-\t  }\n-      if (gomp_places_list_len == 0)\n-\t{\n-\t  if (!quiet)\n-\t    gomp_error (\"Error reading %s topology\",\n-\t\t\tlevel == 2 ? \"core\" : \"socket\");\n-\t  free (gomp_places_list);\n-\t  gomp_places_list = NULL;\n-\t  return false;\n-\t}\n-      return true;\n+      if (!quiet)\n+\tgomp_error (\"Error reading core/socket topology\");\n+      free (gomp_places_list);\n+      gomp_places_list = NULL;\n+      return false;\n     }\n-  return false;\n+  return true;\n }\n \n void"}]}