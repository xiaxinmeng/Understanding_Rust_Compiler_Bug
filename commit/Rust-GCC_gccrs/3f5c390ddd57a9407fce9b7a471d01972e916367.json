{"sha": "3f5c390ddd57a9407fce9b7a471d01972e916367", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1YzM5MGRkZDU3YTk0MDdmY2U5YjdhNDcxZDAxOTcyZTkxNjM2Nw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-06T13:08:06Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-06T13:08:06Z"}, "message": "tree.c (drop_tree_overflow): New function.\n\n2013-11-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree.c (drop_tree_overflow): New function.\n\t* tree.h (drop_tree_overflow): Declare.\n\t* gimplify.c (gimplify_expr): Drop TREE_OVERFLOW.\n\t* tree-vrp.c (range_int_cst_singleton_p): Use\n\tis_overflow_infinity instead of testing TREE_OVERFLOW.\n\t(extract_range_from_assert): Likewise.\n\t(zero_nonzero_bits_from_vr): Likewise.\n\t(extract_range_basic): Likewise.\n\t(register_new_assert_for): Use drop_tree_overflow.\n\t(vrp_visit_phi_node): Likewise.\n\nFrom-SVN: r204454", "tree": {"sha": "053822df465eb3c1f6c53f1d007303a4f3ddaef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/053822df465eb3c1f6c53f1d007303a4f3ddaef0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f5c390ddd57a9407fce9b7a471d01972e916367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5c390ddd57a9407fce9b7a471d01972e916367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f5c390ddd57a9407fce9b7a471d01972e916367", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f5c390ddd57a9407fce9b7a471d01972e916367/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9789a9127686e1d8d9e99a22bfaea4d2587d2bfd"}], "stats": {"total": 74, "additions": 53, "deletions": 21}, "files": [{"sha": "c211db0dd8ef2a7cfdc725c7016e40cce9542100", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f5c390ddd57a9407fce9b7a471d01972e916367", "patch": "@@ -1,3 +1,16 @@\n+2013-11-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree.c (drop_tree_overflow): New function.\n+\t* tree.h (drop_tree_overflow): Declare.\n+\t* gimplify.c (gimplify_expr): Drop TREE_OVERFLOW.\n+\t* tree-vrp.c (range_int_cst_singleton_p): Use\n+\tis_overflow_infinity instead of testing TREE_OVERFLOW.\n+\t(extract_range_from_assert): Likewise.\n+\t(zero_nonzero_bits_from_vr): Likewise.\n+\t(extract_range_basic): Likewise.\n+\t(register_new_assert_for): Use drop_tree_overflow.\n+\t(vrp_visit_phi_node): Likewise.\n+\n 2013-11-06  Dodji Seketeli  <dodji@redhat.com>\n \n \tpreprocessor/58580"}, {"sha": "721e8fb6002ce39ca66867b08a519f4b30cc3372", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3f5c390ddd57a9407fce9b7a471d01972e916367", "patch": "@@ -7897,6 +7897,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase STRING_CST:\n \tcase COMPLEX_CST:\n \tcase VECTOR_CST:\n+\t  /* Drop the overflow flag on constants, we do not want\n+\t     that in the GIMPLE IL.  */\n+\t  if (TREE_OVERFLOW_P (*expr_p))\n+\t    *expr_p = drop_tree_overflow (*expr_p);\n \t  ret = GS_ALL_DONE;\n \t  break;\n "}, {"sha": "9b26f17eb548c0cc44920ca1b1de1b40decafc91", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3f5c390ddd57a9407fce9b7a471d01972e916367", "patch": "@@ -892,8 +892,8 @@ static inline bool\n range_int_cst_singleton_p (value_range_t *vr)\n {\n   return (range_int_cst_p (vr)\n-\t  && !TREE_OVERFLOW (vr->min)\n-\t  && !TREE_OVERFLOW (vr->max)\n+\t  && !is_overflow_infinity (vr->min)\n+\t  && !is_overflow_infinity (vr->max)\n \t  && tree_int_cst_equal (vr->min, vr->max));\n }\n \n@@ -1741,7 +1741,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t all should be optimized away above us.  */\n       if ((cond_code == LT_EXPR\n \t   && compare_values (max, min) == 0)\n-\t  || (CONSTANT_CLASS_P (max) && TREE_OVERFLOW (max)))\n+\t  || is_overflow_infinity (max))\n \tset_value_range_to_varying (vr_p);\n       else\n \t{\n@@ -1781,7 +1781,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t all should be optimized away above us.  */\n       if ((cond_code == GT_EXPR\n \t   && compare_values (min, max) == 0)\n-\t  || (CONSTANT_CLASS_P (min) && TREE_OVERFLOW (min)))\n+\t  || is_overflow_infinity (min))\n \tset_value_range_to_varying (vr_p);\n       else\n \t{\n@@ -1998,8 +1998,8 @@ zero_nonzero_bits_from_vr (value_range_t *vr,\n   *may_be_nonzero = double_int_minus_one;\n   *must_be_nonzero = double_int_zero;\n   if (!range_int_cst_p (vr)\n-      || TREE_OVERFLOW (vr->min)\n-      || TREE_OVERFLOW (vr->max))\n+      || is_overflow_infinity (vr->min)\n+      || is_overflow_infinity (vr->max))\n     return false;\n \n   if (range_int_cst_singleton_p (vr))\n@@ -3623,13 +3623,13 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t\t    && integer_nonzerop (vr0->min))\n \t\t   || (vr0->type == VR_ANTI_RANGE\n \t\t       && integer_zerop (vr0->min)))\n-\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\t  && !is_overflow_infinity (vr0->min))\n \t\tmini = 1;\n \t      /* If some high bits are known to be zero,\n \t\t we can decrease the maximum.  */\n \t      if (vr0->type == VR_RANGE\n \t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\t  && !is_overflow_infinity (vr0->max))\n \t\tmaxi = tree_floor_log2 (vr0->max) + 1;\n \t    }\n \t  goto bitop_builtin;\n@@ -3664,15 +3664,15 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t\t result maximum.  */\n \t      if (vr0->type == VR_RANGE\n \t\t  && TREE_CODE (vr0->min) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\t  && !is_overflow_infinity (vr0->min))\n \t\t{\n \t\t  maxi = prec - 1 - tree_floor_log2 (vr0->min);\n \t\t  if (maxi != prec)\n \t\t    mini = 0;\n \t\t}\n \t      else if (vr0->type == VR_ANTI_RANGE\n \t\t       && integer_zerop (vr0->min)\n-\t\t       && !TREE_OVERFLOW (vr0->min))\n+\t\t       && !is_overflow_infinity (vr0->min))\n \t\t{\n \t\t  maxi = prec - 1;\n \t\t  mini = 0;\n@@ -3683,7 +3683,7 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t\t result minimum.  */\n \t      if (vr0->type == VR_RANGE\n \t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\t  && !is_overflow_infinity (vr0->max))\n \t\t{\n \t\t  mini = prec - 1 - tree_floor_log2 (vr0->max);\n \t\t  if (mini == prec)\n@@ -3726,7 +3726,7 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t\t    && integer_nonzerop (vr0->min))\n \t\t   || (vr0->type == VR_ANTI_RANGE\n \t\t       && integer_zerop (vr0->min)))\n-\t\t  && !TREE_OVERFLOW (vr0->min))\n+\t\t  && !is_overflow_infinity (vr0->min))\n \t\t{\n \t\t  mini = 0;\n \t\t  maxi = prec - 1;\n@@ -3735,7 +3735,7 @@ extract_range_basic (value_range_t *vr, gimple stmt)\n \t\t we can decrease the result maximum.  */\n \t      if (vr0->type == VR_RANGE\n \t\t  && TREE_CODE (vr0->max) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (vr0->max))\n+\t\t  && !is_overflow_infinity (vr0->max))\n \t\t{\n \t\t  maxi = tree_floor_log2 (vr0->max);\n \t\t  /* For vr0 [0, 0] give up.  */\n@@ -4619,10 +4619,8 @@ register_new_assert_for (tree name, tree expr,\n   /* Never build an assert comparing against an integer constant with\n      TREE_OVERFLOW set.  This confuses our undefined overflow warning\n      machinery.  */\n-  if (TREE_CODE (val) == INTEGER_CST\n-      && TREE_OVERFLOW (val))\n-    val = build_int_cst_wide (TREE_TYPE (val),\n-\t\t\t      TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val));\n+  if (TREE_OVERFLOW_P (val))\n+    val = drop_tree_overflow (val);\n \n   /* The new assertion A will be inserted at BB or E.  We need to\n      determine if the new location is dominated by a previously\n@@ -8320,10 +8318,7 @@ vrp_visit_phi_node (gimple phi)\n \t  else\n \t    {\n \t      if (is_overflow_infinity (arg))\n-\t\t{\n-\t\t  arg = copy_node (arg);\n-\t\t  TREE_OVERFLOW (arg) = 0;\n-\t\t}\n+\t\targ = drop_tree_overflow (arg);\n \n \t      vr_arg.type = VR_RANGE;\n \t      vr_arg.min = arg;"}, {"sha": "98896f82e810e6b48e709c144022ffc1bdb72e95", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3f5c390ddd57a9407fce9b7a471d01972e916367", "patch": "@@ -12542,4 +12542,23 @@ get_tree_code_name (enum tree_code code)\n   return tree_code_name[code];\n }\n \n+/* Drops the TREE_OVERFLOW flag from T.  */\n+\n+tree\n+drop_tree_overflow (tree t)\n+{\n+  gcc_checking_assert (TREE_OVERFLOW (t));\n+\n+  /* For tree codes with a sharing machinery re-build the result.  */\n+  if (TREE_CODE (t) == INTEGER_CST)\n+    return build_int_cst_wide (TREE_TYPE (t),\n+\t\t\t       TREE_INT_CST_LOW (t), TREE_INT_CST_HIGH (t));\n+\n+  /* Otherwise, as all tcc_constants are possibly shared, copy the node\n+     and drop the flag.  */\n+  t = copy_node (t);\n+  TREE_OVERFLOW (t) = 0;\n+  return t;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "5f9d0ea14cc9973d0eee3e835b344bebfc62f2de", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f5c390ddd57a9407fce9b7a471d01972e916367/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3f5c390ddd57a9407fce9b7a471d01972e916367", "patch": "@@ -4800,6 +4800,7 @@ extern tree get_base_address (tree t);\n extern void mark_addressable (tree);\n \n /* In tree.c.  */\n+extern tree drop_tree_overflow (tree);\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);"}]}