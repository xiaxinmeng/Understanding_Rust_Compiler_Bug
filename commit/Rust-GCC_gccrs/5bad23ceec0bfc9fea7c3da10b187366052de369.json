{"sha": "5bad23ceec0bfc9fea7c3da10b187366052de369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJhZDIzY2VlYzBiZmM5ZmVhN2MzZGExMGIxODczNjYwNTJkZTM2OQ==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2020-09-11T13:24:59Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-11T13:24:59Z"}, "message": "libstdc++: Use FUTEX_CLOCK_REALTIME for futex wait\n\nThe futex system call supports waiting for an absolute time if\nFUTEX_WAIT_BITSET is used rather than FUTEX_WAIT.  Doing so provides two\nbenefits:\n\n1. The call to gettimeofday is not required in order to calculate a\n   relative timeout.\n\n2. If someone changes the system clock during the wait then the futex\n   timeout will correctly expire earlier or later.  Currently that only\n   happens if the clock is changed prior to the call to gettimeofday.\n\nAccording to futex(2), support for FUTEX_CLOCK_REALTIME was added in the\nv2.6.28 Linux kernel and FUTEX_WAIT_BITSET was added in v2.6.25.  To\nensure that the code still works correctly with earlier kernel versions,\nan ENOSYS error from futex[1] results in the\nfutex_clock_realtime_unavailable flag being set.  This flag is used to\navoid the unnecessary unsupported futex call in the future and to fall\nback to the previous gettimeofday and relative time implementation.\n\nglibc applied an equivalent switch in pthread_cond_timedwait to use\nFUTEX_CLOCK_REALTIME and FUTEX_WAIT_BITSET rather than FUTEX_WAIT for\nglibc-2.10 back in 2009.  See\nglibc:cbd8aeb836c8061c23a5e00419e0fb25a34abee7\n\nThe futex_clock_realtime_unavailable flag is accessed using\nstd::memory_order_relaxed to stop it becoming a bottleneck.  If the\nfirst two calls to _M_futex_wait_until happen to happen simultaneously\nthen the only consequence is that both will try to use\nFUTEX_CLOCK_REALTIME, both risk discovering that it doesn't work and, if\nso, both set the flag.\n\n[1] This is how glibc's nptl-init.c determines whether these flags are\n    supported.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++11/futex.cc: Add new constants for required futex\n\tflags.  Add futex_clock_realtime_unavailable flag to store\n\tresult of trying to use FUTEX_CLOCK_REALTIME.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until): Try to\n\tuse FUTEX_WAIT_BITSET with FUTEX_CLOCK_REALTIME and only\n\tfall back to using gettimeofday and FUTEX_WAIT if that's not\n\tsupported.", "tree": {"sha": "66830168b76011e89065e48eb73d478020815350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66830168b76011e89065e48eb73d478020815350"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bad23ceec0bfc9fea7c3da10b187366052de369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bad23ceec0bfc9fea7c3da10b187366052de369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bad23ceec0bfc9fea7c3da10b187366052de369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bad23ceec0bfc9fea7c3da10b187366052de369/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f639343dc8c4fa65342a8c1fd43384999cf9f9d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f639343dc8c4fa65342a8c1fd43384999cf9f9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f639343dc8c4fa65342a8c1fd43384999cf9f9d0"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "25b3e05d0d0793dc381f60c8ff7be311f1ef9e5a", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bad23ceec0bfc9fea7c3da10b187366052de369/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bad23ceec0bfc9fea7c3da10b187366052de369/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=5bad23ceec0bfc9fea7c3da10b187366052de369", "patch": "@@ -35,8 +35,16 @@\n \n // Constants for the wait/wake futex syscall operations\n const unsigned futex_wait_op = 0;\n+const unsigned futex_wait_bitset_op = 9;\n+const unsigned futex_clock_realtime_flag = 256;\n+const unsigned futex_bitset_match_any = ~0;\n const unsigned futex_wake_op = 1;\n \n+namespace\n+{\n+  std::atomic<bool> futex_clock_realtime_unavailable;\n+}\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -58,6 +66,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     else\n       {\n+\tif (!futex_clock_realtime_unavailable.load(std::memory_order_relaxed))\n+\t  {\n+\t    struct timespec rt;\n+\t    rt.tv_sec = __s.count();\n+\t    rt.tv_nsec = __ns.count();\n+\t    if (syscall (SYS_futex, __addr,\n+\t\t\t futex_wait_bitset_op | futex_clock_realtime_flag,\n+\t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)\n+\t      {\n+\t\t__glibcxx_assert(errno == EINTR || errno == EAGAIN\n+\t\t\t\t|| errno == ETIMEDOUT || errno == ENOSYS);\n+\t\tif (errno == ETIMEDOUT)\n+\t\t  return false;\n+\t\tif (errno == ENOSYS)\n+\t\t  {\n+\t\t    futex_clock_realtime_unavailable.store(true,\n+\t\t\t\t\t\t    std::memory_order_relaxed);\n+\t\t    // Fall through to legacy implementation if the system\n+\t\t    // call is unavailable.\n+\t\t  }\n+\t\telse\n+\t\t  return true;\n+\t      }\n+\t    else\n+\t      return true;\n+\t  }\n+\n+\t// We only get to here if futex_clock_realtime_unavailable was\n+\t// true or has just been set to true.\n \tstruct timeval tv;\n \tgettimeofday (&tv, NULL);\n \t// Convert the absolute timeout value to a relative timeout"}]}