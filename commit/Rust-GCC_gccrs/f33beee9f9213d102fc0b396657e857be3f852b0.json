{"sha": "f33beee9f9213d102fc0b396657e857be3f852b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMzYmVlZTlmOTIxM2QxMDJmYzBiMzk2NjU3ZTg1N2JlM2Y4NTJiMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-04-27T08:41:00Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-27T08:41:00Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2010-04-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * resolve.c (resolve_allocate_expr): Allow array coarrays.\n        * trans-types.h (gfc_get_array_type_bounds): Update prototype.\n        * trans-types.c (gfc_get_array_type_bounds,\n        gfc_get_array_descriptor_base): Add corank argument.\n        * trans-array.c (gfc_array_init_size): Handle corank.\n        (gfc_trans_create_temp_array, gfc_array_allocate,\n        gfc_conv_expr_descriptor): Add corank argument to call.\n        * trans-stmt.c (gfc_trans_pointer_assign_need_temp): Ditto.\n\n2010-04-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_7.f90: Modified and removed obsolete\n        tests.\n        * gfortran.dg/coarray_12.f90: New.\n\nFrom-SVN: r158768", "tree": {"sha": "42b0fbad69c17856b9cdcd2534809988ef7ec0a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b0fbad69c17856b9cdcd2534809988ef7ec0a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f33beee9f9213d102fc0b396657e857be3f852b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33beee9f9213d102fc0b396657e857be3f852b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f33beee9f9213d102fc0b396657e857be3f852b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33beee9f9213d102fc0b396657e857be3f852b0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d89488ec13d521f894e1d3d3aad05d01940226bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89488ec13d521f894e1d3d3aad05d01940226bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89488ec13d521f894e1d3d3aad05d01940226bb"}], "stats": {"total": 248, "additions": 185, "deletions": 63}, "files": [{"sha": "9db6b609653e4d48f9be179453a423e33d604e57", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -1,3 +1,15 @@\n+2010-04-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* resolve.c (resolve_allocate_expr): Allow array coarrays.\n+\t* trans-types.h (gfc_get_array_type_bounds): Update prototype.\n+\t* trans-types.c (gfc_get_array_type_bounds,\n+\tgfc_get_array_descriptor_base): Add corank argument.\n+\t* trans-array.c (gfc_array_init_size): Handle corank.\n+\t(gfc_trans_create_temp_array, gfc_array_allocate,\n+\tgfc_conv_expr_descriptor): Add corank argument to call.\n+\t* trans-stmt.c (gfc_trans_pointer_assign_need_temp): Ditto.\n+\n 2010-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/30073"}, {"sha": "135eda4d53b0ef66c7d68ea4478a9e5ecbf5cce1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -6561,9 +6561,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       goto failure;\n     }\n \n-  if (codimension)\n+  if (codimension && ar->as->rank == 0)\n     {\n-      gfc_error (\"Sorry, allocatable coarrays are no yet supported coarray \"\n+      gfc_error (\"Sorry, allocatable scalar coarrays are not yet supported \"\n \t\t \"at %L\", &e->where);\n       goto failure;\n     }"}, {"sha": "e20406c94514b4c974024a7f3b20bf18c6b589fc", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -725,7 +725,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n   /* Initialize the descriptor.  */\n   type =\n-    gfc_get_array_type_bounds (eltype, info->dimen, loop->from, loop->to, 1,\n+    gfc_get_array_type_bounds (eltype, info->dimen, 0, loop->from, loop->to, 1,\n \t\t\t       GFC_ARRAY_UNKNOWN, true);\n   desc = gfc_create_var (type, \"atmp\");\n   GFC_DECL_PACKED_ARRAY (desc) = 1;\n@@ -3819,7 +3819,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n /*GCC ARRAYS*/\n \n static tree\n-gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n+gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper,\n \t\t     stmtblock_t * pblock)\n {\n@@ -3917,6 +3917,43 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       stride = gfc_evaluate_now (stride, pblock);\n     }\n \n+  for (n = rank; n < rank + corank; n++)\n+    {\n+      ubound = upper[n];\n+\n+      /* Set lower bound.  */\n+      gfc_init_se (&se, NULL);\n+      if (lower == NULL || lower[n] == NULL)\n+\t{\n+\t  gcc_assert (n == rank + corank - 1);\n+\t  se.expr = gfc_index_one_node;\n+\t}\n+      else\n+\t{\n+          if (ubound || n == rank + corank - 1)\n+            {\n+\t      gfc_conv_expr_type (&se, lower[n], gfc_array_index_type);\n+\t      gfc_add_block_to_block (pblock, &se.pre);\n+            }\n+          else\n+            {\n+              se.expr = gfc_index_one_node;\n+              ubound = lower[n];\n+            }\n+\t}\n+      gfc_conv_descriptor_lbound_set (pblock, descriptor, gfc_rank_cst[n],\n+\t\t\t\t      se.expr);\n+\n+      if (n < rank + corank - 1)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gcc_assert (ubound);\n+\t  gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  gfc_conv_descriptor_ubound_set (pblock, descriptor, gfc_rank_cst[n], se.expr);\n+\t}\n+    }\n+\n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n@@ -3965,7 +4002,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL;\n-  bool allocatable_array;\n+  bool allocatable_array, coarray;\n \n   ref = expr->ref;\n \n@@ -3981,29 +4018,40 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   if (ref == NULL || ref->type != REF_ARRAY)\n     return false;\n \n-  /* Return if this is a scalar coarray.  */\n-  if (!prev_ref && !expr->symtree->n.sym->attr.dimension)\n+  if (!prev_ref)\n     {\n-      gcc_assert (expr->symtree->n.sym->attr.codimension);\n-      return false;\n+      allocatable_array = expr->symtree->n.sym->attr.allocatable;\n+      coarray = expr->symtree->n.sym->attr.codimension;\n     }\n-  else if (prev_ref && !prev_ref->u.c.component->attr.dimension)\n+  else\n     {\n-      gcc_assert (prev_ref->u.c.component->attr.codimension);\n-      return false;\n+      allocatable_array = prev_ref->u.c.component->attr.allocatable;\n+      coarray = prev_ref->u.c.component->attr.codimension;\n     }\n \n-  if (!prev_ref)\n-    allocatable_array = expr->symtree->n.sym->attr.allocatable;\n-  else\n-    allocatable_array = prev_ref->u.c.component->attr.allocatable;\n+  /* Return if this is a scalar coarray.  */\n+  if ((!prev_ref && !expr->symtree->n.sym->attr.dimension)\n+      || (prev_ref && !prev_ref->u.c.component->attr.dimension))\n+    {\n+      gcc_assert (coarray);\n+      return false;\n+    }\n \n   /* Figure out the size of the array.  */\n   switch (ref->u.ar.type)\n     {\n     case AR_ELEMENT:\n-      lower = NULL;\n-      upper = ref->u.ar.start;\n+      if (!coarray)\n+\t{\n+\t  lower = NULL;\n+\t  upper = ref->u.ar.start;\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+\n+    case AR_SECTION:\n+      lower = ref->u.ar.start;\n+      upper = ref->u.ar.end;\n       break;\n \n     case AR_FULL:\n@@ -4013,18 +4061,14 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n       upper = ref->u.ar.as->upper;\n       break;\n \n-    case AR_SECTION:\n-      lower = ref->u.ar.start;\n-      upper = ref->u.ar.end;\n-      break;\n-\n     default:\n       gcc_unreachable ();\n       break;\n     }\n \n-  size = gfc_array_init_size (se->expr, ref->u.ar.as->rank, &offset,\n-\t\t\t      lower, upper, &se->pre);\n+  size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n+\t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n+\t\t\t      &se->pre);\n \n   /* Allocate memory to store the data.  */\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n@@ -5299,7 +5343,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  /* Otherwise make a new one.  */\n \t  parmtype = gfc_get_element_type (TREE_TYPE (desc));\n-\t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n+\t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, 0,\n \t\t\t\t\t\tloop.from, loop.to, 0,\n \t\t\t\t\t\tGFC_ARRAY_UNKNOWN, false);\n \t  parm = gfc_create_var (parmtype, \"parm\");"}, {"sha": "edffb9bfd8f5e7564cce52906746113292947f71", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -2822,7 +2822,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       /* Make a new descriptor.  */\n       parmtype = gfc_get_element_type (TREE_TYPE (desc));\n-      parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n+      parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, 0,\n                                             loop.from, loop.to, 1,\n \t\t\t\t\t    GFC_ARRAY_UNKNOWN, true);\n "}, {"sha": "9d5378492cd8f7ddce5b359eca8210c8c1103336", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -1222,8 +1222,8 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n \n   if (as->type == AS_ASSUMED_SHAPE)\n     akind = GFC_ARRAY_ASSUMED_SHAPE;\n-  return gfc_get_array_type_bounds (type, as->rank, lbound, ubound, 0, akind,\n-\t\t\t\t    restricted);\n+  return gfc_get_array_type_bounds (type, as->rank, as->corank, lbound,\n+\t\t\t\t    ubound, 0, akind, restricted);\n }\n \f\n /* Returns the struct descriptor_dimension type.  */\n@@ -1538,20 +1538,21 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n /* Return or create the base type for an array descriptor.  */\n \n static tree\n-gfc_get_array_descriptor_base (int dimen, bool restricted)\n+gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n {\n   tree fat_type, fieldlist, decl, arraytype;\n-  char name[16 + GFC_RANK_DIGITS + 1];\n+  char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n   int idx = 2 * (dimen - 1) + restricted;\n \n-  gcc_assert (dimen >= 1 && dimen <= GFC_MAX_DIMENSIONS);\n+  gcc_assert (dimen >= 1 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n   if (gfc_array_descriptor_base[idx])\n     return gfc_array_descriptor_base[idx];\n \n   /* Build the type node.  */\n   fat_type = make_node (RECORD_TYPE);\n \n-  sprintf (name, \"array_descriptor\" GFC_RANK_PRINTF_FORMAT, dimen);\n+  sprintf (name, \"array_descriptor\" GFC_RANK_PRINTF_FORMAT \"_\"\n+\t   GFC_RANK_PRINTF_FORMAT, dimen, codimen);\n   TYPE_NAME (fat_type) = get_identifier (name);\n \n   /* Add the data member as the first element of the descriptor.  */\n@@ -1583,7 +1584,7 @@ gfc_get_array_descriptor_base (int dimen, bool restricted)\n     build_array_type (gfc_get_desc_dim_type (),\n \t\t      build_range_type (gfc_array_index_type,\n \t\t\t\t\tgfc_index_zero_node,\n-\t\t\t\t\tgfc_rank_cst[dimen - 1]));\n+\t\t\t\t\tgfc_rank_cst[codimen + dimen - 1]));\n \n   decl = build_decl (input_location,\n \t\t     FIELD_DECL, get_identifier (\"dim\"), arraytype);\n@@ -1604,20 +1605,20 @@ gfc_get_array_descriptor_base (int dimen, bool restricted)\n /* Build an array (descriptor) type with given bounds.  */\n \n tree\n-gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n+gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n \t\t\t   tree * ubound, int packed,\n \t\t\t   enum gfc_array_kind akind, bool restricted)\n {\n-  char name[8 + GFC_RANK_DIGITS + GFC_MAX_SYMBOL_LEN];\n+  char name[8 + 2*GFC_RANK_DIGITS + 1 + GFC_MAX_SYMBOL_LEN];\n   tree fat_type, base_type, arraytype, lower, upper, stride, tmp, rtype;\n   const char *type_name;\n   int n;\n \n-  base_type = gfc_get_array_descriptor_base (dimen, restricted);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, restricted);\n   fat_type = build_distinct_type_copy (base_type);\n   /* Make sure that nontarget and target array type have the same canonical\n      type (and same stub decl for debug info).  */\n-  base_type = gfc_get_array_descriptor_base (dimen, false);\n+  base_type = gfc_get_array_descriptor_base (dimen, codimen, false);\n   TYPE_CANONICAL (fat_type) = base_type;\n   TYPE_STUB_DECL (fat_type) = TYPE_STUB_DECL (base_type);\n \n@@ -1628,7 +1629,8 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n     type_name = IDENTIFIER_POINTER (tmp);\n   else\n     type_name = \"unknown\";\n-  sprintf (name, \"array\" GFC_RANK_PRINTF_FORMAT \"_%.*s\", dimen,\n+  sprintf (name, \"array\" GFC_RANK_PRINTF_FORMAT \"_\"\n+\t   GFC_RANK_PRINTF_FORMAT \"_%.*s\", dimen, codimen,\n \t   GFC_MAX_SYMBOL_LEN, type_name);\n   TYPE_NAME (fat_type) = get_identifier (name);\n "}, {"sha": "0b962114b96335714658e73095ceff23d56d2c19", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -72,7 +72,7 @@ tree gfc_type_for_mode (enum machine_mode, int);\n tree gfc_build_uint_type (int);\n \n tree gfc_get_element_type (tree);\n-tree gfc_get_array_type_bounds (tree, int, tree *, tree *, int,\n+tree gfc_get_array_type_bounds (tree, int, int, tree *, tree *, int,\n \t\t\t\tenum gfc_array_kind, bool);\n tree gfc_get_nodesc_array_type (tree, gfc_array_spec *, gfc_packed, bool);\n "}, {"sha": "7bc52d16325a7bacbc53904fd2c1b814c6a4b747", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -1,3 +1,9 @@\n+2010-04-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_7.f90: Modified and removed obsolete tests.\n+\t* gfortran.dg/coarray_12.f90: New.\n+\n 2010-04-27  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \tPR c/32207"}, {"sha": "776c819954dcbc0caa30dd9927dd83bb098d4b75", "filename": "gcc/testsuite/gfortran.dg/coarray_12.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_12.f90?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -fdump-tree-original\" }\n+!\n+! Coarray support -- allocatable array coarrays\n+! PR fortran/18918\n+!\n+integer,allocatable :: a(:)[:,:]\n+nn = 5\n+mm = 7\n+allocate(a(nn)[mm,*])\n+end\n+\n+subroutine testAlloc3\n+  implicit none\n+  integer, allocatable :: ab(:,:,:)[:,:]\n+  integer, allocatable, dimension(:),codimension[:] :: b(:,:,:)[:,:]\n+  integer, allocatable, dimension(:,:),codimension[:,:,:] :: c\n+  integer, allocatable, dimension(:,:),codimension[:,:,:] :: d[:,:]\n+  integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: e(:,:)\n+  integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: f(:,:)[:,:]\n+\n+  allocate(ab(1,2,3)[4,*])\n+  allocate(b(1,2,3)[4,*])\n+  allocate(c(1,2)[3,4,*])\n+  allocate(d(1,2)[3,*])\n+  allocate(e(1,2)[3,4,*])\n+  allocate(f(1,2)[3,*])\n+end subroutine testAlloc3\n+\n+subroutine testAlloc4()\n+  implicit none\n+  integer, allocatable :: xxx(:)[:,:,:,:]\n+  integer :: mmm\n+  mmm=88\n+  allocate(xxx(1)[7,-5:8,mmm:2,*])\n+end subroutine testAlloc4\n+\n+subroutine testAlloc5()\n+  implicit none\n+  integer, allocatable :: yyy(:)[:,:,:,:]\n+  integer :: ooo, ppp\n+  ooo=88\n+  ppp=42\n+  allocate(yyy(1)[7,-5:ppp,1,ooo:*])\n+end subroutine testAlloc5\n+\n+\n+! { dg-final { scan-tree-dump-times \"a.dim.0..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"a.dim.0..ubound = .* nn;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"a.dim.1..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"a.dim.1..ubound = .* mm;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"a.dim.2..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"a.dim.2..ubound\"          0 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"xxx.dim.0..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.0..ubound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.1..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.1..ubound = 7;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.2..lbound = -5;\"    1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.2..ubound = 8;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.3..lbound = .*mmm;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.3..ubound = 2;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.4..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"xxx.dim.4..ubound\"          0 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"yyy.dim.0..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.0..ubound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.1..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.1..ubound = 7;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.2..lbound = -5;\"    1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.2..ubound = .*ppp;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.3..lbound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.3..ubound = 1;\"     1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.4..lbound = .*ooo;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"yyy.dim.4..ubound\"          0 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "29af0d1919538808b3044627d3d6886d51670507", "filename": "gcc/testsuite/gfortran.dg/coarray_7.f90", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33beee9f9213d102fc0b396657e857be3f852b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90?ref=f33beee9f9213d102fc0b396657e857be3f852b0", "patch": "@@ -91,7 +91,6 @@ subroutine alloc()\n allocate(b(1)) ! { dg-error \"Coarray specification\" }\n allocate(a[3]%a(5)) ! { dg-error \"Coindexed allocatable\" }\n allocate(c[*]) ! { dg-error \"Sorry\" }\n-allocate(b(3)[5:*]) ! { dg-error \"Sorry\" }\n allocate(a%a(5)) ! OK\n end subroutine alloc\n \n@@ -148,34 +147,16 @@ end subroutine test4\n \n subroutine allocateTest()\n   implicit none\n-  real, allocatable,dimension(:,:), codimension[:,:] :: a,b,c\n+  real, allocatable, codimension[:,:] :: a,b,c\n   integer :: n, q\n   n = 1\n   q = 1\n-  allocate(a(n,n)[q,*]) ! { dg-error \"Sorry\" }\n-  allocate(b(n,n)[q,*]) ! { dg-error \"Sorry\" }\n-  allocate(c(n,n)[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(a[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(b[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(c[q,*]) ! { dg-error \"Sorry\" }\n end subroutine allocateTest\n \n \n-subroutine testAlloc3\n-implicit none\n-integer, allocatable :: a(:,:,:)[:,:]\n-integer, allocatable, dimension(:),codimension[:] :: b(:,:,:)[:,:]\n-integer, allocatable, dimension(:,:),codimension[:,:,:] :: c\n-integer, allocatable, dimension(:,:),codimension[:,:,:] :: d[:,:]\n-integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: e(:,:)\n-integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: f(:,:)[:,:]\n-\n-allocate(a(1,2,3)[4,*]) ! { dg-error \"Sorry\" }\n-allocate(b(1,2,3)[4,*]) ! { dg-error \"Sorry\" }\n-allocate(c(1,2)[3,4,*]) ! { dg-error \"Sorry\" }\n-allocate(d(1,2)[3,*])   ! { dg-error \"Sorry\" }\n-allocate(e(1,2)[3,4,*]) ! { dg-error \"Sorry\" }\n-allocate(f(1,2)[3,*]) ! { dg-error \"Sorry\" }\n-end subroutine testAlloc3\n-\n-\n subroutine testAlloc4()\n   implicit none\n   type co_double_3"}]}