{"sha": "43905ff30b187d8d1d1dee50e722f47fd8a93144", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5MDVmZjMwYjE4N2Q4ZDFkMWRlZTUwZTcyMmY0N2ZkOGE5MzE0NA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-04-30T07:23:42Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-04-30T07:23:42Z"}, "message": "Engine.java, [...]: New files from classpath.\n\n2003-04-30  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/security/Engine.java,\n\tgnu/java/security/OID.java,\n\tgnu/java/security/der/BitString.java,\n\tgnu/java/security/der/DER.java,\n\tgnu/java/security/der/DERReader.java,\n\tgnu/java/security/der/DERValue.java,\n\tgnu/java/security/der/DERWriter.java,\n\tgnu/java/security/provider/DSAKeyFactory.java,\n\tgnu/java/security/provider/X509CertificateFactory.java,\n\tgnu/java/security/x509/X500DistinguishedName.java,\n\tgnu/java/security/x509/X509CRL.java,\n\tgnu/java/security/x509/X509CRLEntry.java,\n\tgnu/java/security/x509/X509Certificate.java,\n\tjava/security/cert/CRLSelector.java,\n\tjava/security/cert/CertPathBuilder.java,\n\tjava/security/cert/CertPathBuilderResult.java,\n\tjava/security/cert/CertPathBuilderSpi.java,\n\tjava/security/cert/CertPathParameters.java,\n\tjava/security/cert/CertPathValidator.java,\n\tjava/security/cert/CertPathValidatorResult.java,\n\tjava/security/cert/CertPathValidatorSpi.java,\n\tjava/security/cert/CertSelector.java,\n\tjava/security/cert/CertStore.java,\n\tjava/security/cert/CertStoreParameters.java,\n\tjava/security/cert/CertStoreSpi.java,\n\tjava/security/cert/CollectionCertStoreParameters.java,\n\tjava/security/cert/LDAPCertStoreParameters.java,\n\tjava/security/cert/PKIXBuilderParameters.java,\n\tjava/security/cert/PKIXCertPathBuilderResult.java,\n\tjava/security/cert/PKIXCertPathChecker.java,\n\tjava/security/cert/PKIXCertPathValidatorResult.java,\n\tjava/security/cert/PKIXParameters.java,\n\tjava/security/cert/PolicyNode.java,\n\tjava/security/cert/PolicyQualifierInfo.java,\n\tjava/security/cert/TrustAnchor.java,\n\tjavax/security/auth/x500/X500Principal.java:\n\tNew files from classpath.\n\t* gnu/java/io/ASN1ParsingException.java,\n\tgnu/java/io/Base64InputStream.java,\n\tgnu/java/security/der/DEREncodingException.java,\n\tgnu/java/security/provider/DSAParameters.java,\n\tgnu/java/security/provider/DSASignature.java,\n\tgnu/java/security/provider/Gnu.java,\n\tgnu/java/security/provider/GnuDSAPrivateKey.java,\n\tgnu/java/security/provider/GnuDSAPublicKey.java,\n\tjava/security/AlgorithmParameterGenerator.java,\n\tjava/security/AlgorithmParameters.java,\n\tjava/security/KeyFactory.java,\n\tjava/security/KeyPairGenerator.java,\n\tjava/security/KeyStore.java,\n\tjava/security/MessageDigest.java,\n\tjava/security/SecureClassLoader.java,\n\tjava/security/SecureRandom.java,\n\tjava/security/Security.java,\n\tjava/security/Signature.java,\n\tjava/security/cert/Certificate.java,\n\tjava/security/cert/CertificateFactory.java,\n\tjava/security/cert/CertificateFactorySpi.java,\n\tjava/security/cert/X509CRL.java,\n\tjava/security/cert/X509Certificate.java,\n\tjava/security/spec/DSAPublicKeySpec.java:\n\tNew versions from classpath.\n\t* gnu/java/security/provider/DERReader.java,\n\tgnu/java/security/provider/DERWriter.java,\n\tjava/security/Engine.java: Removed.\n\t* Makefile.am\n\t(java_source_files, javax_source_files): Added new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r66283", "tree": {"sha": "89373f6e7f4c07ae0c9c6eeebf05fcb7bbcdfa36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89373f6e7f4c07ae0c9c6eeebf05fcb7bbcdfa36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43905ff30b187d8d1d1dee50e722f47fd8a93144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43905ff30b187d8d1d1dee50e722f47fd8a93144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43905ff30b187d8d1d1dee50e722f47fd8a93144", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43905ff30b187d8d1d1dee50e722f47fd8a93144/comments", "author": null, "committer": null, "parents": [{"sha": "505b0fd661e21182856cfcf73ed6f39c707ac28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/505b0fd661e21182856cfcf73ed6f39c707ac28b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/505b0fd661e21182856cfcf73ed6f39c707ac28b"}], "stats": {"total": 9677, "additions": 9039, "deletions": 638}, "files": [{"sha": "1ef6a516c01b5fd8a6cd7baf03a17d51e42f9796", "filename": "libjava/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,3 +1,74 @@\n+2003-04-30  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/security/Engine.java,\n+\tgnu/java/security/OID.java,\n+\tgnu/java/security/der/BitString.java,\n+\tgnu/java/security/der/DER.java,\n+\tgnu/java/security/der/DERReader.java,\n+\tgnu/java/security/der/DERValue.java,\n+\tgnu/java/security/der/DERWriter.java,\n+\tgnu/java/security/provider/DSAKeyFactory.java,\n+\tgnu/java/security/provider/X509CertificateFactory.java,\n+\tgnu/java/security/x509/X500DistinguishedName.java,\n+\tgnu/java/security/x509/X509CRL.java,\n+\tgnu/java/security/x509/X509CRLEntry.java,\n+\tgnu/java/security/x509/X509Certificate.java,\n+\tjava/security/cert/CRLSelector.java,\n+\tjava/security/cert/CertPathBuilder.java,\n+\tjava/security/cert/CertPathBuilderResult.java,\n+\tjava/security/cert/CertPathBuilderSpi.java,\n+\tjava/security/cert/CertPathParameters.java,\n+\tjava/security/cert/CertPathValidator.java,\n+\tjava/security/cert/CertPathValidatorResult.java,\n+\tjava/security/cert/CertPathValidatorSpi.java,\n+\tjava/security/cert/CertSelector.java,\n+\tjava/security/cert/CertStore.java,\n+\tjava/security/cert/CertStoreParameters.java,\n+\tjava/security/cert/CertStoreSpi.java,\n+\tjava/security/cert/CollectionCertStoreParameters.java,\n+\tjava/security/cert/LDAPCertStoreParameters.java,\n+\tjava/security/cert/PKIXBuilderParameters.java,\n+\tjava/security/cert/PKIXCertPathBuilderResult.java,\n+\tjava/security/cert/PKIXCertPathChecker.java,\n+\tjava/security/cert/PKIXCertPathValidatorResult.java,\n+\tjava/security/cert/PKIXParameters.java,\n+\tjava/security/cert/PolicyNode.java,\n+\tjava/security/cert/PolicyQualifierInfo.java,\n+\tjava/security/cert/TrustAnchor.java,\n+\tjavax/security/auth/x500/X500Principal.java:\n+\tNew files from classpath.\n+\t* gnu/java/io/ASN1ParsingException.java,\n+\tgnu/java/io/Base64InputStream.java,\n+\tgnu/java/security/der/DEREncodingException.java,\n+\tgnu/java/security/provider/DSAParameters.java,\n+\tgnu/java/security/provider/DSASignature.java,\n+\tgnu/java/security/provider/Gnu.java,\n+\tgnu/java/security/provider/GnuDSAPrivateKey.java,\n+\tgnu/java/security/provider/GnuDSAPublicKey.java,\n+\tjava/security/AlgorithmParameterGenerator.java,\n+\tjava/security/AlgorithmParameters.java,\n+\tjava/security/KeyFactory.java,\n+\tjava/security/KeyPairGenerator.java,\n+\tjava/security/KeyStore.java,\n+\tjava/security/MessageDigest.java,\n+\tjava/security/SecureClassLoader.java,\n+\tjava/security/SecureRandom.java,\n+\tjava/security/Security.java,\n+\tjava/security/Signature.java,\n+\tjava/security/cert/Certificate.java,\n+\tjava/security/cert/CertificateFactory.java,\n+\tjava/security/cert/CertificateFactorySpi.java,\n+\tjava/security/cert/X509CRL.java,\n+\tjava/security/cert/X509Certificate.java,\n+\tjava/security/spec/DSAPublicKeySpec.java:\n+\tNew versions from classpath.\n+\t* gnu/java/security/provider/DERReader.java,\n+\tgnu/java/security/provider/DERWriter.java,\n+\tjava/security/Engine.java: Removed.\n+\t* Makefile.am\n+\t(java_source_files, javax_source_files): Added new files.\n+\t* Makefile.in: Regenerated.\n+\n 2003-04-29  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/JTable.java"}, {"sha": "9d0b8a527dbd2319349631e0ea6c2c2abe5af3a4", "filename": "libjava/Makefile.am", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1645,6 +1645,7 @@ javax/naming/OperationNotSupportedException.java \\\n javax/print/attribute/Attribute.java \\\n javax/print/attribute/AttributeSet.java \\\n javax/print/attribute/PrintRequestAttributeSet.java \\\n+javax/security/auth/x500/X500Principal.java \\\n javax/sql/ConnectionEvent.java \\\n javax/sql/ConnectionEventListener.java \\\n javax/sql/ConnectionPoolDataSource.java \\\n@@ -1946,6 +1947,8 @@ gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/java/io/ASN1ParsingException.java \\\n+gnu/java/io/Base64InputStream.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -2118,10 +2121,16 @@ gnu/java/nio/charset/UTF_16Decoder.java \\\n gnu/java/nio/charset/UTF_16Encoder.java \\\n gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n+gnu/java/security/Engine.java \\\n+gnu/java/security/OID.java \\\n+gnu/java/security/der/BitString.java \\\n+gnu/java/security/der/DER.java \\\n gnu/java/security/der/DEREncodingException.java \\\n-gnu/java/security/provider/DERReader.java \\\n-gnu/java/security/provider/DERWriter.java \\\n+gnu/java/security/der/DERReader.java \\\n+gnu/java/security/der/DERValue.java \\\n+gnu/java/security/der/DERWriter.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n+gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\\n gnu/java/security/provider/DSAParameterGenerator.java \\\n gnu/java/security/provider/DSAParameters.java \\\n@@ -2132,7 +2141,12 @@ gnu/java/security/provider/GnuDSAPublicKey.java \\\n gnu/java/security/provider/MD5.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/security/provider/X509CertificateFactory.java \\\n gnu/java/security/util/Prime.java \\\n+gnu/java/security/x509/X500DistinguishedName.java \\\n+gnu/java/security/x509/X509Certificate.java \\\n+gnu/java/security/x509/X509CRLEntry.java \\\n+gnu/java/security/x509/X509CRL.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n@@ -2294,7 +2308,6 @@ java/security/DummySignature.java \\\n java/security/DigestInputStream.java \\\n java/security/DomainCombiner.java \\\n java/security/DummyMessageDigest.java \\\n-java/security/Engine.java \\\n java/security/GeneralSecurityException.java \\\n java/security/Guard.java \\\n java/security/GuardedObject.java \\\n@@ -2353,6 +2366,7 @@ java/security/acl/NotOwnerException.java \\\n java/security/acl/Permission.java \\\n java/security/cert/CRL.java \\\n java/security/cert/CRLException.java \\\n+java/security/cert/CRLSelector.java \\\n java/security/cert/Certificate.java \\\n java/security/cert/CertificateEncodingException.java \\\n java/security/cert/CertificateException.java \\\n@@ -2362,9 +2376,30 @@ java/security/cert/CertificateFactorySpi.java \\\n java/security/cert/CertificateNotYetValidException.java \\\n java/security/cert/CertificateParsingException.java \\\n java/security/cert/CertPath.java \\\n+java/security/cert/CertPathBuilder.java \\\n java/security/cert/CertPathBuilderException.java \\\n+java/security/cert/CertPathBuilderResult.java \\\n+java/security/cert/CertPathBuilderSpi.java \\\n+java/security/cert/CertPathParameters.java \\\n+java/security/cert/CertPathValidator.java \\\n java/security/cert/CertPathValidatorException.java \\\n+java/security/cert/CertPathValidatorResult.java \\\n+java/security/cert/CertPathValidatorSpi.java \\\n+java/security/cert/CertSelector.java \\\n+java/security/cert/CertStore.java \\\n java/security/cert/CertStoreException.java \\\n+java/security/cert/CertStoreParameters.java \\\n+java/security/cert/CertStoreSpi.java \\\n+java/security/cert/CollectionCertStoreParameters.java \\\n+java/security/cert/LDAPCertStoreParameters.java \\\n+java/security/cert/PKIXBuilderParameters.java \\\n+java/security/cert/PKIXCertPathBuilderResult.java \\\n+java/security/cert/PKIXCertPathChecker.java \\\n+java/security/cert/PKIXCertPathValidatorResult.java \\\n+java/security/cert/PKIXParameters.java \\\n+java/security/cert/PolicyNode.java \\\n+java/security/cert/PolicyQualifierInfo.java \\\n+java/security/cert/TrustAnchor.java \\\n java/security/cert/X509CRL.java \\\n java/security/cert/X509CRLEntry.java \\\n java/security/cert/X509Certificate.java \\"}, {"sha": "70b904a279346d29f00c267fde40bd83d3985579", "filename": "libjava/Makefile.in", "status": "modified", "additions": 77, "deletions": 7, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1416,6 +1416,7 @@ javax/naming/OperationNotSupportedException.java \\\n javax/print/attribute/Attribute.java \\\n javax/print/attribute/AttributeSet.java \\\n javax/print/attribute/PrintRequestAttributeSet.java \\\n+javax/security/auth/x500/X500Principal.java \\\n javax/sql/ConnectionEvent.java \\\n javax/sql/ConnectionEventListener.java \\\n javax/sql/ConnectionPoolDataSource.java \\\n@@ -1708,6 +1709,8 @@ gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/java/io/ASN1ParsingException.java \\\n+gnu/java/io/Base64InputStream.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n@@ -1880,10 +1883,16 @@ gnu/java/nio/charset/UTF_16Decoder.java \\\n gnu/java/nio/charset/UTF_16Encoder.java \\\n gnu/java/nio/charset/UTF_16LE.java \\\n gnu/java/nio/charset/UTF_8.java \\\n+gnu/java/security/Engine.java \\\n+gnu/java/security/OID.java \\\n+gnu/java/security/der/BitString.java \\\n+gnu/java/security/der/DER.java \\\n gnu/java/security/der/DEREncodingException.java \\\n-gnu/java/security/provider/DERReader.java \\\n-gnu/java/security/provider/DERWriter.java \\\n+gnu/java/security/der/DERReader.java \\\n+gnu/java/security/der/DERValue.java \\\n+gnu/java/security/der/DERWriter.java \\\n gnu/java/security/provider/DefaultPolicy.java \\\n+gnu/java/security/provider/DSAKeyFactory.java \\\n gnu/java/security/provider/DSAKeyPairGenerator.java \\\n gnu/java/security/provider/DSAParameterGenerator.java \\\n gnu/java/security/provider/DSAParameters.java \\\n@@ -1894,7 +1903,12 @@ gnu/java/security/provider/GnuDSAPublicKey.java \\\n gnu/java/security/provider/MD5.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+gnu/java/security/provider/X509CertificateFactory.java \\\n gnu/java/security/util/Prime.java \\\n+gnu/java/security/x509/X500DistinguishedName.java \\\n+gnu/java/security/x509/X509Certificate.java \\\n+gnu/java/security/x509/X509CRLEntry.java \\\n+gnu/java/security/x509/X509CRL.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n@@ -2056,7 +2070,6 @@ java/security/DummySignature.java \\\n java/security/DigestInputStream.java \\\n java/security/DomainCombiner.java \\\n java/security/DummyMessageDigest.java \\\n-java/security/Engine.java \\\n java/security/GeneralSecurityException.java \\\n java/security/Guard.java \\\n java/security/GuardedObject.java \\\n@@ -2115,6 +2128,7 @@ java/security/acl/NotOwnerException.java \\\n java/security/acl/Permission.java \\\n java/security/cert/CRL.java \\\n java/security/cert/CRLException.java \\\n+java/security/cert/CRLSelector.java \\\n java/security/cert/Certificate.java \\\n java/security/cert/CertificateEncodingException.java \\\n java/security/cert/CertificateException.java \\\n@@ -2124,9 +2138,30 @@ java/security/cert/CertificateFactorySpi.java \\\n java/security/cert/CertificateNotYetValidException.java \\\n java/security/cert/CertificateParsingException.java \\\n java/security/cert/CertPath.java \\\n+java/security/cert/CertPathBuilder.java \\\n java/security/cert/CertPathBuilderException.java \\\n+java/security/cert/CertPathBuilderResult.java \\\n+java/security/cert/CertPathBuilderSpi.java \\\n+java/security/cert/CertPathParameters.java \\\n+java/security/cert/CertPathValidator.java \\\n java/security/cert/CertPathValidatorException.java \\\n+java/security/cert/CertPathValidatorResult.java \\\n+java/security/cert/CertPathValidatorSpi.java \\\n+java/security/cert/CertSelector.java \\\n+java/security/cert/CertStore.java \\\n java/security/cert/CertStoreException.java \\\n+java/security/cert/CertStoreParameters.java \\\n+java/security/cert/CertStoreSpi.java \\\n+java/security/cert/CollectionCertStoreParameters.java \\\n+java/security/cert/LDAPCertStoreParameters.java \\\n+java/security/cert/PKIXBuilderParameters.java \\\n+java/security/cert/PKIXCertPathBuilderResult.java \\\n+java/security/cert/PKIXCertPathChecker.java \\\n+java/security/cert/PKIXCertPathValidatorResult.java \\\n+java/security/cert/PKIXParameters.java \\\n+java/security/cert/PolicyNode.java \\\n+java/security/cert/PolicyQualifierInfo.java \\\n+java/security/cert/TrustAnchor.java \\\n java/security/cert/X509CRL.java \\\n java/security/cert/X509CRLEntry.java \\\n java/security/cert/X509Certificate.java \\\n@@ -2636,7 +2671,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2783,6 +2818,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/beans/editors/NativeShortEditor.P \\\n .deps/gnu/java/beans/editors/StringEditor.P \\\n .deps/gnu/java/beans/info/ComponentBeanInfo.P \\\n+.deps/gnu/java/io/ASN1ParsingException.P \\\n+.deps/gnu/java/io/Base64InputStream.P \\\n .deps/gnu/java/io/ClassLoaderObjectInputStream.P \\\n .deps/gnu/java/io/NullOutputStream.P \\\n .deps/gnu/java/io/ObjectIdentityWrapper.P \\\n@@ -2983,9 +3020,14 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/rmi/server/UnicastRemoteStub.P \\\n .deps/gnu/java/rmi/server/UnicastServer.P \\\n .deps/gnu/java/rmi/server/UnicastServerRef.P \\\n+.deps/gnu/java/security/Engine.P .deps/gnu/java/security/OID.P \\\n+.deps/gnu/java/security/der/BitString.P \\\n+.deps/gnu/java/security/der/DER.P \\\n .deps/gnu/java/security/der/DEREncodingException.P \\\n-.deps/gnu/java/security/provider/DERReader.P \\\n-.deps/gnu/java/security/provider/DERWriter.P \\\n+.deps/gnu/java/security/der/DERReader.P \\\n+.deps/gnu/java/security/der/DERValue.P \\\n+.deps/gnu/java/security/der/DERWriter.P \\\n+.deps/gnu/java/security/provider/DSAKeyFactory.P \\\n .deps/gnu/java/security/provider/DSAKeyPairGenerator.P \\\n .deps/gnu/java/security/provider/DSAParameterGenerator.P \\\n .deps/gnu/java/security/provider/DSAParameters.P \\\n@@ -2997,7 +3039,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/security/provider/MD5.P \\\n .deps/gnu/java/security/provider/SHA.P \\\n .deps/gnu/java/security/provider/SHA1PRNG.P \\\n+.deps/gnu/java/security/provider/X509CertificateFactory.P \\\n .deps/gnu/java/security/util/Prime.P \\\n+.deps/gnu/java/security/x509/X500DistinguishedName.P \\\n+.deps/gnu/java/security/x509/X509CRL.P \\\n+.deps/gnu/java/security/x509/X509CRLEntry.P \\\n+.deps/gnu/java/security/x509/X509Certificate.P \\\n .deps/gnu/java/text/BaseBreakIterator.P \\\n .deps/gnu/java/text/CharacterBreakIterator.P \\\n .deps/gnu/java/text/LineBreakIterator.P \\\n@@ -3576,7 +3623,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/DomainCombiner.P \\\n .deps/java/security/DummyKeyPairGenerator.P \\\n .deps/java/security/DummyMessageDigest.P \\\n-.deps/java/security/DummySignature.P .deps/java/security/Engine.P \\\n+.deps/java/security/DummySignature.P \\\n .deps/java/security/GeneralSecurityException.P \\\n .deps/java/security/Guard.P .deps/java/security/GuardedObject.P \\\n .deps/java/security/Identity.P .deps/java/security/IdentityScope.P \\\n@@ -3619,10 +3666,22 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/acl/NotOwnerException.P \\\n .deps/java/security/acl/Owner.P .deps/java/security/acl/Permission.P \\\n .deps/java/security/cert/CRL.P .deps/java/security/cert/CRLException.P \\\n+.deps/java/security/cert/CRLSelector.P \\\n .deps/java/security/cert/CertPath.P \\\n+.deps/java/security/cert/CertPathBuilder.P \\\n .deps/java/security/cert/CertPathBuilderException.P \\\n+.deps/java/security/cert/CertPathBuilderResult.P \\\n+.deps/java/security/cert/CertPathBuilderSpi.P \\\n+.deps/java/security/cert/CertPathParameters.P \\\n+.deps/java/security/cert/CertPathValidator.P \\\n .deps/java/security/cert/CertPathValidatorException.P \\\n+.deps/java/security/cert/CertPathValidatorResult.P \\\n+.deps/java/security/cert/CertPathValidatorSpi.P \\\n+.deps/java/security/cert/CertSelector.P \\\n+.deps/java/security/cert/CertStore.P \\\n .deps/java/security/cert/CertStoreException.P \\\n+.deps/java/security/cert/CertStoreParameters.P \\\n+.deps/java/security/cert/CertStoreSpi.P \\\n .deps/java/security/cert/Certificate.P \\\n .deps/java/security/cert/CertificateEncodingException.P \\\n .deps/java/security/cert/CertificateException.P \\\n@@ -3631,6 +3690,16 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/cert/CertificateFactorySpi.P \\\n .deps/java/security/cert/CertificateNotYetValidException.P \\\n .deps/java/security/cert/CertificateParsingException.P \\\n+.deps/java/security/cert/CollectionCertStoreParameters.P \\\n+.deps/java/security/cert/LDAPCertStoreParameters.P \\\n+.deps/java/security/cert/PKIXBuilderParameters.P \\\n+.deps/java/security/cert/PKIXCertPathBuilderResult.P \\\n+.deps/java/security/cert/PKIXCertPathChecker.P \\\n+.deps/java/security/cert/PKIXCertPathValidatorResult.P \\\n+.deps/java/security/cert/PKIXParameters.P \\\n+.deps/java/security/cert/PolicyNode.P \\\n+.deps/java/security/cert/PolicyQualifierInfo.P \\\n+.deps/java/security/cert/TrustAnchor.P \\\n .deps/java/security/cert/X509CRL.P \\\n .deps/java/security/cert/X509CRLEntry.P \\\n .deps/java/security/cert/X509Certificate.P \\\n@@ -3868,6 +3937,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/rmi/CORBA/Util.P .deps/javax/rmi/CORBA/UtilDelegate.P \\\n .deps/javax/rmi/CORBA/ValueHandler.P .deps/javax/rmi/ORB.P \\\n .deps/javax/rmi/PortableRemoteObject.P \\\n+.deps/javax/security/auth/x500/X500Principal.P \\\n .deps/javax/sql/ConnectionEvent.P \\\n .deps/javax/sql/ConnectionEventListener.P \\\n .deps/javax/sql/ConnectionPoolDataSource.P .deps/javax/sql/DataSource.P \\"}, {"sha": "3a5dade8192ebb010f4cc81632719c98eee70afa", "filename": "libjava/gnu/java/io/ASN1ParsingException.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fio%2FASN1ParsingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fio%2FASN1ParsingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FASN1ParsingException.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,56 @@\n+/* ASN1ParsingException.java -- ASN.1 parsing exception.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.io;\n+\n+/**\n+ * Signals a malformed ASN.1 sequence.\n+ */\n+public class ASN1ParsingException extends java.io.IOException\n+{\n+\n+\tpublic ASN1ParsingException()\n+\t{\n+\t\tsuper();\n+\t}\n+\n+\tpublic ASN1ParsingException(String msg)\n+\t{\n+\t\tsuper(msg);\n+\t}\n+}"}, {"sha": "0879e94596217ca2ef25f6b5fb351eb4042ae835", "filename": "libjava/gnu/java/io/Base64InputStream.java", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fio%2FBase64InputStream.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,191 @@\n+/* Base64InputStream.java -- base-64 input stream.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.io;\n+\n+import java.io.FilterInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.EOFException;\n+\n+/**\n+ * A filter input stream that decodes data encoded in the Base-64\n+ * encoding scheme.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class Base64InputStream extends FilterInputStream\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Base-64 digits. */\n+  private static final String BASE_64 = \n+    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n+\n+  /** Base-64 padding character. */\n+  private static final char BASE_64_PAD = '=';\n+\n+  /** Decoding state. */\n+  private int state;\n+\n+  /** Intermediate decoded value. */\n+  private int temp;\n+\n+  /** EOF flag. */\n+  private boolean eof;\n+\n+  private final byte[] one = new byte[1];\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new Base-64 input stream. The input bytes must be the\n+   * ASCII characters A-Z, a-z, 0-9, + and /, with optional whitespace,\n+   * and will be decoded into a byte stream.\n+   *\n+   * @param in The source of Base-64 input.\n+   */\n+  public Base64InputStream(InputStream in)\n+  {\n+    super(in);\n+    state = 0;\n+    temp = 0;\n+    eof = false;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public int available()\n+  {\n+    return 0;\n+  }\n+\n+  public int read() throws IOException\n+  {\n+    if (read(one) == 1)\n+      return one[0];\n+    return -1;\n+  }\n+\n+  public int read(byte[] buf, int off, int len) throws IOException\n+  {\n+    if (eof)\n+      return -1;\n+    int count = 0;\n+    while (count < len)\n+      {\n+        int i;\n+        while (Character.isWhitespace((char) (i = in.read())));\n+        int pos = BASE_64.indexOf((char) i);\n+        if (pos >= 0)\n+          {\n+            switch (state)\n+              {\n+                case 0:\n+                  temp = pos << 2;\n+                  state = 1;\n+                  break;\n+                case 1:\n+                  buf[count++] = (byte) (temp | (pos >>> 4));\n+                  temp = (pos & 0x0F) << 4;\n+                  state = 2;\n+                  break;\n+                case 2:\n+                  buf[count++] = (byte) (temp | (pos >>> 2));\n+                  temp = (pos & 0x03) << 6;\n+                  state = 3;\n+                  break;\n+                case 3:\n+                  buf[count++] = (byte) (temp | pos);\n+                  state = 0;\n+                  break;\n+              }\n+          }\n+        else if (i == BASE_64_PAD)\n+          {\n+            switch (state)\n+              {\n+                case 0:\n+                case 1:\n+                  throw new IOException(\"malformed Base-64 input\");\n+                case 2:\n+                  while (Character.isWhitespace((char) (i = in.read())));\n+                  if (i != BASE_64_PAD)\n+                    throw new IOException(\"malformed Base-64 input\");\n+                case 3:\n+                  while (Character.isWhitespace((char) (i = in.read())));\n+              }\n+            eof = true;\n+            break;\n+          }\n+        else  // First non-Base-64 character, consider it end-of-stream.\n+          {\n+            if (state != 0)\n+              throw new IOException(\"malformed Base-64 input\");\n+            eof = true;\n+            break;\n+          }\n+      }\n+      return count;\n+  }\n+\n+  public boolean markSupported()\n+  {\n+    return false;\n+  }\n+\n+  public void mark(int markLimit) { }\n+\n+  public void reset() throws IOException\n+  {\n+    throw new IOException(\"reset not supported\");\n+  }\n+\n+  public long skip(long n) throws IOException\n+  {\n+    long skipped;\n+    for (skipped = 0; skipped < n; skipped++)\n+      if (read() == -1)\n+        break;\n+    return skipped;\n+  }\n+}"}, {"sha": "9f6568cddaeff5791222f9879d2516ae9a3086bd", "filename": "libjava/gnu/java/security/Engine.java", "status": "renamed", "additions": 92, "deletions": 7, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2FEngine.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2FEngine.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2FEngine.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -35,7 +35,13 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-package java.security;\n+package gnu.java.security;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n \n /**\n  * Generic implementation of the getInstance methods in the various\n@@ -51,7 +57,7 @@\n  * @see Provider\n  * @author Casey Marshall \n  */\n-final class Engine\n+public final class Engine\n {\n \n   // Constants.\n@@ -63,6 +69,9 @@\n   /** Maximum number of aliases to try. */\n   private static final int MAX_ALIASES = 5;\n \n+  /** Argument list for no-argument constructors. */\n+  private static final Object[] NO_ARGS = new Object[0];\n+\n   // Constructor.\n   // ------------------------------------------------------------------------\n \n@@ -85,13 +94,44 @@ private Engine() { }\n    *         service, but callers should check that this is so.\n    * @throws NoSuchAlgorithmException If the implementation cannot be\n    *         found or cannot be instantiated.\n+   * @throws InvocationTargetException If the SPI class's constructor\n+   *         throws an exception.\n    * @throws IllegalArgumentException If any of the three arguments are null.\n    */\n-  static Object\n-  getInstance(String service, String algorithm, Provider provider)\n-  throws NoSuchAlgorithmException\n+  public static Object getInstance(String service, String algorithm,\n+                                   Provider provider)\n+    throws InvocationTargetException, NoSuchAlgorithmException\n+  {\n+    return getInstance(service, algorithm, provider, NO_ARGS);\n+  }\n+\n+  /**\n+   * Get the implementation for <i>algorithm</i> for service\n+   * <i>service</i> from <i>provider</i>, passing <i>initArgs</i> to the\n+   * SPI class's constructor (which cannot be null; pass a zero-length\n+   * array if the SPI takes no arguments). The service is e.g.\n+   * \"Signature\", and the algorithm \"DSA\".\n+   *\n+   * @param service   The service name.\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The provider to get the implementation from.\n+   * @param initArgs  The arguments to pass to the SPI class's\n+   *        constructor (cannot be null).\n+   * @return The engine class for the specified algorithm; the object\n+   *         returned is typically a subclass of the SPI class for that\n+   *         service, but callers should check that this is so.\n+   * @throws NoSuchAlgorithmException If the implementation cannot be\n+   *         found or cannot be instantiated.\n+   * @throws InvocationTargetException If the SPI class's constructor\n+   *         throws an exception.\n+   * @throws IllegalArgumentException If any of the four arguments are null.\n+   */\n+  public static Object getInstance(String service, String algorithm,\n+                                   Provider provider, Object[] initArgs)\n+    throws InvocationTargetException, NoSuchAlgorithmException\n   {\n-    if (service == null || algorithm == null || provider == null)\n+    if (service == null || algorithm == null\n+        || provider == null || initArgs == null)\n       throw new IllegalArgumentException();\n \n     // If there is no property \"service.algorithm\"\n@@ -117,14 +157,17 @@ private Engine() { }\n     // Find and instantiate the implementation.\n     Class clazz = null;\n     ClassLoader loader = provider.getClass().getClassLoader();\n+    Constructor constructor = null;\n     String error = algorithm;\n+\n     try\n       {\n         if (loader != null)\n           clazz = loader.loadClass(provider.getProperty(service+\".\"+algorithm));\n         else\n           clazz = Class.forName(provider.getProperty(service+\".\"+algorithm));\n-        return clazz.newInstance();\n+        constructor = getCompatibleConstructor(clazz, initArgs);\n+        return constructor.newInstance(initArgs);\n       }\n     catch (ClassNotFoundException cnfe)\n       {\n@@ -146,7 +189,49 @@ private Engine() { }\n       {\n         error = \"security exception: \" + se.getMessage();\n       }\n+    catch (NoSuchMethodException nsme)\n+      {\n+        error = \"no appropriate constructor found\";\n+      }\n \n     throw new NoSuchAlgorithmException(error);\n   }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Find a constructor in the given class that can take the specified\n+   * argument list, allowing any of which to be null.\n+   *\n+   * @param clazz    The class from which to get the constructor.\n+   * @param initArgs The argument list to be passed to the constructor.\n+   * @return The constructor.\n+   * @throws NoSuchMethodException If no constructor of the given class\n+   *         can take the specified argument array.\n+   */\n+  private static Constructor getCompatibleConstructor(Class clazz,\n+                                                      Object[] initArgs)\n+    throws NoSuchMethodException\n+  {\n+    Constructor[] c = clazz.getConstructors();\n+    outer:for (int i = 0; i < c.length; i++)\n+      {\n+        Class[] argTypes = c[i].getParameterTypes();\n+        if (argTypes.length != initArgs.length)\n+          continue;\n+        for (int j = 0; j < argTypes.length; j++)\n+          {\n+            if (initArgs[j] != null &&\n+                !argTypes[j].isAssignableFrom(initArgs[j].getClass()))\n+              continue outer;\n+          }\n+        // If we reach this point, we know this constructor (c[i]) has\n+        // the same number of parameters as the target parameter list,\n+        // and all our parameters are either (1) null, or (2) assignable\n+        // to the target parameter type.\n+        return c[i];\n+      }\n+    throw new NoSuchMethodException();\n+  }\n }", "previous_filename": "libjava/java/security/Engine.java"}, {"sha": "c27ec9253abe9f5f74b59f6acc1fcaebe30ddac4", "filename": "libjava/gnu/java/security/OID.java", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2FOID.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2FOID.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2FOID.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,511 @@\n+/* OID.java -- numeric representation of an object identifier\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.util.StringTokenizer;\n+\n+import gnu.java.security.der.DEREncodingException;\n+\n+/**\n+ * This immutable class represents an object identifier, or OID.\n+ *\n+ * <p>OIDs are represented as a series of hierarcical tokens, each of\n+ * which is usually represented as a single, unsigned integer. The\n+ * hierarchy works so that later tokens are considered within the group\n+ * of earlier tokens. Thus, the OID for the Serpent block cipher,\n+ * 1.3.6.1.4.1.11591.13.2, is maintained by the GNU project, whose OID\n+ * is 1.3.6.1.4.1.11591 (which is, in turn, part of bigger, more general\n+ * bodies; the topmost, 1, stands for the OIDs assigned by the\n+ * International Standards Organization, ISO).\n+ *\n+ * <p>OIDs can be represented in a variety of ways, including the\n+ * dotted-decimal form we use here.\n+ *\n+ * <p>OIDs may be relative, in which case the first two elements of the\n+ * OID are omitted.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class OID implements Cloneable, Comparable, java.io.Serializable\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * The numeric ID structure.\n+   */\n+  private int[] components;\n+\n+  /**\n+   * The string representation of this OID, in dotted-decimal format.\n+   */\n+  private transient String strRep;\n+\n+  /**\n+   * The DER encoding of this OID.\n+   */\n+  private transient byte[] der;\n+\n+  /**\n+   * Whether or not this OID is relative.\n+   */\n+  private boolean relative;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new OID from the given byte array. The argument (which can\n+   * neither be null nor zero-length) is copied to prevent subsequent\n+   * modification.\n+   *\n+   * @param components The numeric IDs.\n+   * @throws IllegalArgumentException If <i>components</i> is null or empty.\n+   */\n+  public OID(int[] components)\n+  {\n+    this(components, false);\n+  }\n+\n+  /**\n+   * Create a new OID from the given byte array. The argument (which can\n+   * neither be null nor zero-length) is copied to prevent subsequent\n+   * modification.\n+   *\n+   * @param components The numeric IDs.\n+   * @param relative The relative flag.\n+   * @throws IllegalArgumentException If <i>components</i> is null or empty.\n+   */\n+  public OID(int[] components, boolean relative)\n+  {\n+    if (components == null || components.length == 0)\n+      throw new IllegalArgumentException();\n+    this.components = (int[]) components.clone();\n+    this.relative = relative;\n+  }\n+\n+  /**\n+   * Create a new OID from the given dotted-decimal representation.\n+   *\n+   * @param strRep The string representation of the OID.\n+   * @throws IllegalArgumentException If the string does not contain at\n+   * least one integer.\n+   * @throws NumberFormatException If the string does not contain only\n+   * numbers and periods ('.').\n+   */\n+  public OID(String strRep)\n+  {\n+    this(strRep, false);\n+  }\n+\n+  /**\n+   * Create a new OID from the given dotted-decimal representation.\n+   *\n+   * @param strRep The string representation of the OID.\n+   * @param relative The relative flag.\n+   * @throws IllegalArgumentException If the string does not contain at\n+   * least one integer.\n+   * @throws NumberFormatException If the string does not contain only\n+   * numbers and periods ('.').\n+   */\n+  public OID(String strRep, boolean relative)\n+  {\n+    this.relative = relative;\n+    this.strRep = strRep;\n+    components = fromString(strRep);\n+  }\n+\n+  /**\n+   * Construct a new OID from the DER bytes in an input stream. This method\n+   * does not read the tag or the length field from the input stream, so\n+   * the caller must supply the number of octets in this OID's encoded\n+   * form.\n+   *\n+   * @param derIn The DER input stream.\n+   * @param len   The number of bytes in the encoded form.\n+   * @throws IOException If an error occurs reading the OID.\n+   */\n+  public OID(InputStream derIn, int len) throws IOException\n+  {\n+    this(derIn, len, false);\n+  }\n+\n+  /**\n+   * Construct a new OID from the DER bytes in an input stream. This method\n+   * does not read the tag or the length field from the input stream, so\n+   * the caller must supply the number of octets in this OID's encoded\n+   * form.\n+   *\n+   * @param derIn The DER input stream.\n+   * @param len   The number of bytes in the encoded form.\n+   * @param relative The relative flag.\n+   * @throws IOException If an error occurs reading the OID.\n+   */\n+  public OID(InputStream derIn, int len, boolean relative) throws IOException\n+  {\n+    der = new byte[len];\n+    derIn.read(der);\n+    this.relative = relative;\n+    try\n+      {\n+        components = fromDER(der, relative);\n+      }\n+    catch (ArrayIndexOutOfBoundsException aioobe)\n+      {\n+        aioobe.printStackTrace();\n+        throw aioobe;\n+      }\n+  }\n+\n+  /**\n+   * Construct a new OID from the given DER bytes.\n+   *\n+   * @param encoded The DER encoded OID.\n+   * @throws IOException If an error occurs reading the OID.\n+   */\n+  public OID(byte[] encoded) throws IOException\n+  {\n+    this(encoded, false);\n+  }\n+\n+  /**\n+   * Construct a new OID from the given DER bytes.\n+   *\n+   * @param root The root OID.\n+   * @param encoded The encoded relative OID.\n+   * @param relative The relative flag.\n+   */\n+  public OID(byte[] encoded, boolean relative) throws IOException\n+  {\n+    der = (byte[]) encoded.clone();\n+    this.relative = relative;\n+    try\n+      {\n+        components = fromDER(der, relative);\n+      }\n+    catch (ArrayIndexOutOfBoundsException aioobe)\n+      {\n+        aioobe.printStackTrace();\n+        throw aioobe;\n+      }\n+  }\n+\n+  /**\n+   * Our private constructor.\n+   */\n+  private OID()\n+  {\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the numeric IDs of this OID. The value returned is copied to\n+   * prevent modification.\n+   *\n+   * @return The IDs in a new integer array.\n+   */\n+  public int[] getIDs()\n+  {\n+    return (int[]) components.clone();\n+  }\n+\n+  /**\n+   * Get the DER encoding of this OID, minus the tag and length fields.\n+   *\n+   * @return The DER bytes.\n+   */\n+  public byte[] getDER()\n+  {\n+    if (der == null)\n+      {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        int i = 0;\n+        if (!relative)\n+          {\n+            int b = components[i++] * 40 + (components.length > 1\n+              ? components[i++] : 0);\n+            encodeSubID(bout, b);\n+          }\n+        for ( ; i < components.length; i++)\n+          encodeSubID(bout, components[i]);\n+        der = bout.toByteArray();\n+      }\n+    return (byte[]) der.clone();\n+  }\n+\n+  /**\n+   * Get the parent OID of this OID. That is, if this OID is \"1.2.3.4\",\n+   * then the parent OID will be \"1.2.3\". If this OID is a top-level\n+   * OID, this method returns null.\n+   *\n+   * @return The parent OID, or null.\n+   */\n+  public OID getParent()\n+  {\n+    if (components.length == 1)\n+      return null;\n+    int[] parent = new int[components.length - 1];\n+    System.arraycopy(components, 0, parent, 0, parent.length);\n+    return new OID(parent);\n+  }\n+\n+  public OID getChild(int id)\n+  {\n+    int[] child = new int[components.length + 1];\n+    System.arraycopy(components, 0, child, 0, components.length);\n+    child[child.length - 1] = id;\n+    return new OID(child);\n+  }\n+\n+  /**\n+   * Get the root OID of this OID. That is, the first two components.\n+   *\n+   * @return The root OID.\n+   */\n+  public OID getRoot()\n+  {\n+    if (components.length <= 2)\n+      return this;\n+    int[] root = new int[2];\n+    root[0] = components[0];\n+    root[1] = components[1];\n+    return new OID(root);\n+  }\n+\n+  public boolean isRelative()\n+  {\n+    return relative;\n+  }\n+\n+  /**\n+   * Returns a copy of this OID.\n+   *\n+   * @return The copy.\n+   */\n+  public Object clone()\n+  {\n+    OID oid = new OID();\n+    oid.components = this.components;\n+    oid.strRep = this.strRep;\n+    return oid;\n+  }\n+\n+  /* Nice idea, but possibly too expensive for whatever benefit it\n+   * provides.\n+   \n+  public String getShortName()\n+  {\n+    return OIDTable.getShortName(this);\n+  }\n+\n+  public String getLongName()\n+  {\n+    return OIDTable.getLongName(this);\n+  }\n+\n+  */\n+\n+  /**\n+   * Returns the value of this OID in dotted-decimal format.\n+   *\n+   * @return The string representation.\n+   */\n+  public String toString()\n+  {\n+    if (strRep != null)\n+      return strRep;\n+    else\n+      {\n+        StringBuffer buf = new StringBuffer();\n+        for (int i = 0; i < components.length; i++)\n+          {\n+            buf.append((long) components[i] & 0xFFFFFFFFL);\n+            if (i < components.length - 1)\n+              buf.append('.');\n+          }\n+        return (strRep = buf.toString());\n+      }\n+  }\n+\n+  /**\n+   * Computes a hash code for this OID.\n+   *\n+   * @return The hash code.\n+   */\n+  public int hashCode()\n+  {\n+    int ret = 0;\n+    for (int i = 0; i < components.length; i++)\n+      ret += components[i] << (i & 31);\n+    return ret;\n+  }\n+\n+  /**\n+   * Tests whether or not this OID equals another.\n+   *\n+   * @return Whether or not this OID equals the other.\n+   */\n+  public boolean equals(Object o)\n+  {\n+    if (this == o)\n+      return true;\n+    return java.util.Arrays.equals(components, ((OID) o).components);\n+  }\n+\n+  /**\n+   * Compares this OID to another. The comparison is essentially\n+   * lexicographic, where the two OIDs are compared until their\n+   * first difference, then that difference is returned. If one OID is\n+   * shorter, but all elements equal between the two for the shorter\n+   * length, then the shorter OID is lesser than the longer.\n+   *\n+   * @param o The object to compare.\n+   * @return An integer less than, equal to, or greater than zero if\n+   *         this object is less than, equal to, or greater than the\n+   *         argument.\n+   * @throws ClassCastException If <i>o</i> is not an OID.\n+   */\n+  public int compareTo(Object o)\n+  {\n+    if (o == this)\n+      return 0;\n+    int[] components2 = ((OID) o).components;\n+    int len = Math.min(components.length, components2.length);\n+    for (int i = 0; i < len; i++)\n+      {\n+        if (components[i] != components2[i])\n+          return (components[i] < components2[i]) ? -1 : 1;\n+      }\n+    if (components.length == components2.length)\n+      return 0;\n+    return (components.length < components2.length) ? -1 : 1;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private static int[] fromDER(byte[] der, boolean relative)\n+    throws DEREncodingException\n+  {\n+    // cannot be longer than this.\n+    int[] components = new int[der.length + 1];\n+    int count = 0;\n+    int i = 0;\n+    if (!relative && i < der.length)\n+      {\n+        // Non-relative OIDs have the first two arcs coded as:\n+        //\n+        //   i = first_arc * 40 + second_arc;\n+        //\n+        int j = (der[i] & 0xFF);\n+        components[count++] = j / 40;\n+        components[count++] = j % 40;\n+        i++;\n+      }\n+    while (i < der.length)\n+      {\n+        int j = 0;\n+        do\n+          {\n+            j = der[i++] & 0xFF;\n+            components[count] <<= 7;\n+            components[count]  |= j & 0x7F;\n+            if (i >= der.length && (j & 0x80) != 0)\n+              throw new DEREncodingException(\"malformed OID\");\n+          }\n+        while ((j & 0x80) != 0);\n+        count++;\n+      }\n+    if (count == components.length)\n+      return components;\n+    int[] ret = new int[count];\n+    System.arraycopy(components, 0, ret, 0, count);\n+    return ret;\n+  }\n+\n+  private static int[] fromString(String strRep) throws NumberFormatException\n+  {\n+    if (strRep.startsWith(\"OID.\") || strRep.startsWith(\"oid.\"))\n+      strRep = strRep.substring(4);\n+    StringTokenizer tok = new StringTokenizer(strRep, \".\");\n+    if (tok.countTokens() == 0)\n+      throw new IllegalArgumentException();\n+    int[] components = new int[tok.countTokens()];\n+    int i = 0;\n+    while (tok.hasMoreTokens())\n+      {\n+        components[i++] = Integer.parseInt(tok.nextToken());\n+      }\n+    return components;\n+  }\n+\n+  private static void encodeSubID(ByteArrayOutputStream out, int id)\n+  {\n+    if (id < 128)\n+      {\n+        out.write(id);\n+      }\n+    else if (id < 16384)\n+      {\n+        out.write((id >>> 7) | 0x80);\n+        out.write(id & 0x7F);\n+      }\n+    else if (id < 2097152)\n+      {\n+        out.write((id >>> 14) | 0x80);\n+        out.write(((id >>> 7) | 0x80) & 0xFF);\n+        out.write(id & 0x7F);\n+      }\n+    else if (id < 268435456)\n+      {\n+        out.write( (id >>> 21) | 0x80);\n+        out.write(((id >>> 14) | 0x80) & 0xFF);\n+        out.write(((id >>>  7) | 0x80) & 0xFF);\n+        out.write(id & 0x7F);\n+      }\n+  }\n+}"}, {"sha": "c4c2d9ab158713335c4b68fc6fa2971f49832b24", "filename": "libjava/gnu/java/security/der/BitString.java", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FBitString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FBitString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FBitString.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,317 @@\n+/* BitString.java -- Java representation of the BIT STRING type.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.der;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+\n+/**\n+ * Immutable representation of a bit string, which is equivalent to a\n+ * byte array except some number of the rightmost bits are ignored. For\n+ * example, this could be the bit string:\n+ *\n+ * <pre>   00010101 11101101 11010xxx</pre>\n+ *\n+ * <p>Where the \"xxx\" represents three bits that should be ignored, and\n+ * can have any value.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class BitString implements Cloneable, Comparable, java.io.Serializable\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The bits themselves. */\n+  private final byte[] bytes;\n+\n+  /**\n+   * The exportable byte array. This array has the ignored bits\n+   * removed.\n+   */\n+  private transient byte[] externBytes;\n+\n+  /** The number of bits ignored at the end of the byte array. */\n+  private final int ignoredBits;\n+\n+  /** This bit string as a boolean array. */\n+  private transient boolean[] boolVal;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new bit string, shifting the given byte array if needed.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @param ignoredBits The number of bits to ignore.\n+   * @param doShift Pass true in this parameter if the byte array has\n+   * not yet been shifted left by <i>ignoredBits</i>.\n+   * @throws IllegalArgumentException If <i>ignoredBits</i> is negative\n+   * or greater than 7.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes, int ignoredBits, boolean doShift)\n+  {\n+    this(bytes, 0, bytes.length, ignoredBits, doShift);\n+  }\n+\n+  /**\n+   * Create a new bit string, shifting the given byte array if needed.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @param offset The offset where the meaningful bytes begin.\n+   * @param length The number of meaningful bytes.\n+   * @param ignoredBits The number of bits to ignore.\n+   * @param doShift Pass true in this parameter if the byte array has\n+   * not yet been shifted left by <i>ignoredBits</i>.\n+   * @throws IllegalArgumentException If <i>ignoredBits</i> is negative\n+   * or greater than 7.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes, int offset, int length,\n+                   int ignoredBits, boolean doShift)\n+  {\n+    if (ignoredBits < 0 || ignoredBits > 7)\n+      throw new IllegalArgumentException();\n+    if (bytes == null)\n+      throw new NullPointerException();\n+    if (doShift && ignoredBits > 0)\n+      {\n+        this.externBytes = new byte[length];\n+        System.arraycopy(bytes, offset, externBytes, 0, length);\n+        this.bytes = new BigInteger(externBytes).shiftLeft(ignoredBits)\n+                       .toByteArray();\n+      }\n+    else\n+      {\n+        this.bytes = new byte[length];\n+        System.arraycopy(bytes, offset, this.bytes, 0, length);\n+      }\n+    this.ignoredBits = ignoredBits;\n+  }\n+\n+  /**\n+   * Create a new bit string.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @param offset The offset where the meaningful bytes begin.\n+   * @param length The number of meaningful bytes.\n+   * @param ignoredBits The number of bits to ignore.\n+   * @throws IllegalArgumentException If <i>ignoredBits</i> is negative\n+   * or greater than 7.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes, int offset, int length, int ignoredBits)\n+  {\n+    this(bytes, offset, length, ignoredBits, false);\n+  }\n+\n+  /**\n+   * Create a new bit string.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @param ignoredBits The number of bits to ignore.\n+   * @throws IllegalArgumentException If <i>ignoredBits</i> is negative\n+   * or greater than 7.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes, int ignoredBits)\n+  {\n+    this(bytes, 0, bytes.length, ignoredBits, false);\n+  }\n+\n+  /**\n+   * Create a new bit string.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @param offset The offset where the meaningful bytes begin.\n+   * @param length The number of meaningful bytes.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes, int offset, int length)\n+  {\n+    this(bytes, offset, length, 0, false);\n+  }\n+\n+  /**\n+   * Create a new bit string.\n+   *\n+   * @param bytes The byte array holding the bit string.\n+   * @throws NullPointerException If <i>bytes</i> is null.\n+   */\n+  public BitString(byte[] bytes)\n+  {\n+    this(bytes, 0, bytes.length, 0, false);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return this bit string as a byte array, with the ignored bits\n+   * trimmed off. The byte array is cloned every time this method is\n+   * called to prevent modification.\n+   *\n+   * @return The trimmed byte array.\n+   */\n+  public byte[] toByteArray()\n+  {\n+    if (ignoredBits == 0)\n+      return (byte[]) bytes.clone();\n+    if (externBytes == null)\n+      externBytes = new BigInteger(bytes).shiftRight(ignoredBits).toByteArray();\n+    return (byte[]) externBytes.clone();\n+  }\n+\n+  /**\n+   * Returns this bit string as a byte array, with the ignored bits\n+   * present. The byte array is cloned every time this method is\n+   * called to prevent modification.\n+   *\n+   * @return The byte array.\n+   */\n+  public byte[] getShiftedByteArray()\n+  {\n+    return (byte[]) bytes.clone();\n+  }\n+\n+  /**\n+   * Returns the number of ignored bits.\n+   *\n+   * @return The number of ignored bits.\n+   */\n+  public int getIgnoredBits()\n+  {\n+    return ignoredBits;\n+  }\n+\n+  /**\n+   * Returns the size, in bits, of this bit string.\n+   *\n+   * @return The size of this bit string.\n+   */\n+  public int size()\n+  {\n+    return (bytes.length << 3) - ignoredBits;\n+  }\n+\n+  /**\n+   * Return this bit string as a boolean array. The value returned is of\n+   * size {@link #size()}, and each <code>true</code> value\n+   * corresponding to each \"1\" in this bit string. The boolean array is\n+   * cloned before it is returned.\n+   *\n+   * @return The boolean array.\n+   */\n+  public boolean[] toBooleanArray()\n+  {\n+    if (boolVal == null)\n+      {\n+        boolVal = new boolean[size()];\n+        for (int i = 0, j = 7, k = 0; i < boolVal.length; i++)\n+          {\n+            boolVal[i] = (bytes[k] & 1 << j--) != 0;\n+            if (j < 0)\n+              {\n+                j = 7;\n+                k++;\n+              }\n+          }\n+      }\n+    return (boolean[]) boolVal.clone();\n+  }\n+\n+  public Object clone()\n+  {\n+    try\n+      {\n+        return super.clone();\n+      }\n+    catch (CloneNotSupportedException cce)\n+      {\n+        throw new InternalError(cce.getMessage());\n+      }\n+  }\n+\n+  public int compareTo(Object o)\n+  {\n+    BitString that = (BitString) o;\n+    if (this.equals(that))\n+      return 0;\n+    if (this.bytes.length != that.bytes.length)\n+      return (this.bytes.length < that.bytes.length) ? -1 : 1;\n+    if (this.ignoredBits != that.ignoredBits)\n+      return (this.ignoredBits < that.ignoredBits) ? -1 : 1;\n+    for (int i = 0; i < this.bytes.length; i++)\n+      if (this.bytes[i] != that.bytes[i])\n+        return (this.bytes[i] < that.bytes[i]) ? -1 : 1;\n+    return 0; // not reached.\n+  }\n+\n+  public boolean equals(Object o)\n+  {\n+    if (this == o)\n+      return true;\n+    BitString that = (BitString) o;\n+    // True for cloned instances.\n+    if (this.bytes == that.bytes && this.ignoredBits == that.ignoredBits)\n+      return true;\n+    if (this.ignoredBits == that.ignoredBits)\n+      return Arrays.equals(this.bytes, that.bytes);\n+    return false;\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer();\n+    for (int i = 0, j = 7, k = 0; i < size(); i++)\n+      {\n+        sb.append((bytes[k] & 1 << j) != 0 ? \"1\" : \"0\");\n+        j--;\n+        if (j < 0)\n+          {\n+            j = 7;\n+            k++;\n+          }\n+      }\n+    return sb.toString();\n+  }\n+}"}, {"sha": "94353665c30972c4e28e16ea34f46af07ed27cdf", "filename": "libjava/gnu/java/security/der/DER.java", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDER.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDER.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDER.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,90 @@\n+/* DER.java -- Basic constants in DER sequences.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.der;\n+\n+/**\n+ * The set of tags for DER types.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public interface DER\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  public static final int UNIVERSAL   = 0x00;\n+  public static final int APPLICATION = 0x40;\n+  public static final int CONTEXT     = 0x80;\n+  public static final int PRIVATE     = 0xC0;\n+\n+  public static final int CONSTRUCTED = 0x20;\n+\n+  public static final int ANY               = 0x00;\n+  public static final int BOOLEAN           = 0x01;\n+  public static final int INTEGER           = 0x02;\n+  public static final int BIT_STRING        = 0x03;\n+  public static final int OCTET_STRING      = 0x04;\n+  public static final int NULL              = 0x05;\n+  public static final int OBJECT_IDENTIFIER = 0x06;\n+  public static final int REAL              = 0x09;\n+  public static final int ENUMERATED        = 0x0a;\n+  public static final int RELATIVE_OID      = 0x0d;\n+\n+  public static final int SEQUENCE = 0x10;\n+  public static final int SET      = 0x11;\n+\n+  public static final Object CONSTRUCTED_VALUE = new Object();\n+\n+  public static final int NUMERIC_STRING   = 0x12;\n+  public static final int PRINTABLE_STRING = 0x13;\n+  public static final int T61_STRING       = 0x14;\n+  public static final int VIDEOTEX_STRING  = 0x15;\n+  public static final int IA5_STRING       = 0x16;\n+  public static final int GRAPHIC_STRING   = 0x19;\n+  public static final int ISO646_STRING    = 0x1A;\n+  public static final int GENERAL_STRING   = 0x1B;\n+\n+  public static final int UTF8_STRING      = 0x0C;\n+  public static final int UNIVERSAL_STRING = 0x1C;\n+  public static final int BMP_STRING       = 0x1E;\n+\n+  public static final int UTC_TIME         = 0x17;\n+  public static final int GENERALIZED_TIME = 0x18;\n+}"}, {"sha": "385fbaccc20078f7a1687efebff2980d2b6c8352", "filename": "libjava/gnu/java/security/der/DEREncodingException.java", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDEREncodingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDEREncodingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDEREncodingException.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* DEREncodingException.java --- DER Encoding Exception\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,9 +38,10 @@\n \n package gnu.java.security.der;\n \n-public class DEREncodingException extends Exception\n-{\n+import java.io.IOException;\n \n+public class DEREncodingException extends IOException\n+{\n   public DEREncodingException()\n   {\n     super ();"}, {"sha": "3020b8b2d1aeb0fb706aea5ad3453e0976890cfd", "filename": "libjava/gnu/java/security/der/DERReader.java", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERReader.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,382 @@\n+/* DERReader.java -- parses ASN.1 DER sequences\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.der;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import gnu.java.security.OID;\n+\n+/**\n+ * This class decodes DER sequences into Java objects. The methods of\n+ * this class do not have knowledge of higher-levels of structure in the\n+ * DER stream -- such as ASN.1 constructions -- and it is therefore up\n+ * to the calling application to determine if the data are structured\n+ * properly by inspecting the {@link DERValue} that is returned.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class DERReader implements DER\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  protected InputStream in;\n+\n+  protected final ByteArrayOutputStream encBuf;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new DER reader from a byte array.\n+   *\n+   * @param in The encoded bytes.\n+   */\n+  public DERReader(byte[] in)\n+  {\n+    this(new ByteArrayInputStream(in));\n+  }\n+\n+  /**\n+   * Create a new DER readed from an input stream.\n+   *\n+   * @param in The encoded bytes.\n+   */\n+  public DERReader(InputStream in)\n+  {\n+    if (!in.markSupported())\n+      this.in = new BufferedInputStream(in, 16384);\n+    else\n+      this.in = in;\n+    encBuf = new ByteArrayOutputStream(2048);\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Convenience method for reading a single primitive value from the\n+   * given byte array.\n+   *\n+   * @param encoded The encoded bytes.\n+   * @throws IOException If the bytes do not represent an encoded\n+   * object.\n+   */\n+  public static DERValue read(byte[] encoded) throws IOException\n+  {\n+    return new DERReader(encoded).read();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Decode a single value from the input stream, returning it in a new\n+   * {@link DERValue}. By \"single value\" we mean any single type in its\n+   * entirety -- including constructed types such as SEQUENCE and all\n+   * the values they contain. Usually it is sufficient to call this\n+   * method once to parse and return the top-level structure, then to\n+   * inspect the returned value for the proper contents.\n+   *\n+   * @return The parsed DER structure.\n+   * @throws IOException If an error occurs reading from the input\n+   * stream.\n+   * @throws DEREncodingException If the input does not represent a\n+   * valid DER stream.\n+   */\n+  public DERValue read() throws IOException\n+  {\n+    int tag = in.read();\n+    if (tag == -1)\n+      throw new EOFException();\n+    encBuf.write(tag);\n+    int len = readLength();\n+    DERValue value = null;\n+    if ((tag & CONSTRUCTED) == CONSTRUCTED)\n+      {\n+        in.mark(2048);\n+        byte[] encoded = new byte[len];\n+        in.read(encoded);\n+        encBuf.write(encoded);\n+        value = new DERValue(tag, len, CONSTRUCTED_VALUE, encBuf.toByteArray());\n+        in.reset();\n+        encBuf.reset();\n+        return value;\n+      }\n+    switch (tag & 0xC0)\n+      {\n+        case UNIVERSAL:\n+          value = new DERValue(tag, len, readUniversal(tag, len),\n+            encBuf.toByteArray());\n+          encBuf.reset();\n+          break;\n+        case CONTEXT:\n+          byte[] encoded = new byte[len];\n+          in.read(encoded);\n+          encBuf.write(encoded);\n+          value = new DERValue(tag, len, encoded, encBuf.toByteArray());\n+          encBuf.reset();\n+          break;\n+        case APPLICATION:\n+          // This should not be reached, since (I think) APPLICATION is\n+          // always constructed.\n+          throw new DEREncodingException(\"non-constructed APPLICATION data\");\n+        default:\n+          throw new DEREncodingException(\"PRIVATE class not supported\");\n+      }\n+    return value;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private Object readUniversal(int tag, int len) throws IOException\n+  {\n+    byte[] value = new byte[len];\n+    in.read(value);\n+    encBuf.write(value);\n+    switch (tag & 0x1F)\n+      {\n+        case BOOLEAN:\n+          if (value.length != 1)\n+            throw new DEREncodingException();\n+          return Boolean.valueOf(value[0] != 0);\n+        case NULL:\n+          if (len != 0)\n+            throw new DEREncodingException();\n+          return null;\n+        case INTEGER:\n+        case ENUMERATED:\n+          return new BigInteger(value);\n+        case BIT_STRING:\n+          byte[] bits = new byte[len - 1];\n+          System.arraycopy(value, 1, bits, 0, bits.length);\n+          return new BitString(bits, value[0] & 0xFF);\n+        case OCTET_STRING:\n+          return value;\n+        case NUMERIC_STRING:\n+        case PRINTABLE_STRING:\n+        case T61_STRING:\n+        case VIDEOTEX_STRING:\n+        case IA5_STRING:\n+        case GRAPHIC_STRING:\n+        case ISO646_STRING:\n+        case GENERAL_STRING:\n+        case UNIVERSAL_STRING:\n+        case BMP_STRING:\n+        case UTF8_STRING:\n+          return makeString(tag, value);\n+        case UTC_TIME:\n+        case GENERALIZED_TIME:\n+          return makeTime(tag, value);\n+        case OBJECT_IDENTIFIER:\n+          return new OID(value);\n+        case RELATIVE_OID:\n+          return new OID(value, true);\n+        default:\n+          throw new DEREncodingException(\"unknown tag \" + tag);\n+      }\n+  }\n+\n+  private int readLength() throws IOException\n+  {\n+    int i = in.read();\n+    if (i == -1)\n+      throw new EOFException();\n+    encBuf.write(i);\n+    if ((i & ~0x7F) == 0)\n+      {\n+        return i;\n+      }\n+    else if (i < 0xFF)\n+      {\n+        byte[] octets = new byte[i & 0x7F];\n+        in.read(octets);\n+        encBuf.write(octets);\n+        return new BigInteger(1, octets).intValue();\n+      }\n+    throw new DEREncodingException();\n+  }\n+\n+  private String makeString(int tag, byte[] value)\n+    throws IOException\n+  {\n+    Charset charset = null;\n+    switch (tag & 0x1F)\n+      {\n+        case NUMERIC_STRING:\n+        case PRINTABLE_STRING:\n+        case T61_STRING:\n+        case VIDEOTEX_STRING:\n+        case IA5_STRING:\n+        case GRAPHIC_STRING:\n+        case ISO646_STRING:\n+        case GENERAL_STRING:\n+          charset = Charset.forName(\"ISO-8859-1\");\n+          break;\n+        case UNIVERSAL_STRING:\n+          // XXX The docs say UniversalString is encoded in four bytes\n+          // per character, but Java has no support (yet) for UTF-32.\n+          //return new String(buf, \"UTF-32\");\n+        case BMP_STRING:\n+          charset = Charset.forName(\"UTF-16BE\");\n+          break;\n+        case UTF8_STRING:\n+          charset = Charset.forName(\"UTF-8\");\n+          break;\n+        default:\n+          throw new DEREncodingException(\"unknown string tag\");\n+      }\n+    if (charset == null)\n+      throw new DEREncodingException(\"no decoder\");\n+    CharsetDecoder decoder = charset.newDecoder();\n+    CharBuffer result = decoder.decode(ByteBuffer.wrap(value));\n+    char[] buf = new char[result.remaining()];\n+    result.get(buf);\n+    return new String(buf);\n+  }\n+\n+  private Date makeTime(int tag, byte[] value) throws IOException\n+  {\n+    Calendar calendar = Calendar.getInstance();\n+    String str = makeString(PRINTABLE_STRING, value);\n+\n+    // Classpath's SimpleDateFormat does not work for parsing these\n+    // types of times, so we do this by hand.\n+    String date = str;\n+    String tz = \"\";\n+    if (str.indexOf(\"+\") > 0)\n+      {\n+        date = str.substring(0, str.indexOf(\"+\"));\n+        tz = str.substring(str.indexOf(\"+\"));\n+      }\n+    else if (str.indexOf(\"-\") > 0)\n+      {\n+        date = str.substring(0, str.indexOf(\"-\"));\n+        tz = str.substring(str.indexOf(\"-\"));\n+      }\n+    else if (str.endsWith(\"Z\"))\n+      {\n+        date = str.substring(0, str.length()-2);\n+        tz = \"Z\";\n+      }\n+    if (!tz.equals(\"Z\") && tz.length() > 0)\n+      calendar.setTimeZone(TimeZone.getTimeZone(tz));\n+    else\n+      calendar.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    if ((tag & 0x1F) == UTC_TIME)\n+      {\n+        if (date.length() < 10)  // must be at least 10 chars long\n+          throw new DEREncodingException(\"cannot parse date\");\n+        // UTCTime is of the form \"yyMMddHHmm[ss](Z|(+|-)hhmm)\"\n+        try\n+          {\n+            int year = Integer.parseInt(str.substring(0, 2));\n+            if (year < 50)\n+              year += 2000;\n+            else\n+              year += 1900;\n+            calendar.set(year,\n+              Integer.parseInt(str.substring( 2,  4))-1,  // month\n+              Integer.parseInt(str.substring( 4,  6)),    // day\n+              Integer.parseInt(str.substring( 6,  8)),    // hour\n+              Integer.parseInt(str.substring( 8, 10)));   // minute\n+            if (date.length() == 12);\n+              calendar.set(calendar.SECOND,\n+                Integer.parseInt(str.substring(10, 12)));\n+          }\n+        catch (NumberFormatException nfe)\n+          {\n+            throw new DEREncodingException(\"cannot parse date\");\n+          }\n+      }\n+    else\n+      {\n+        if (date.length() < 10)  // must be at least 10 chars long\n+          throw new DEREncodingException(\"cannot parse date\");\n+        // GeneralTime is of the form \"yyyyMMddHH[mm[ss[(.|,)SSSS]]]\"\n+        // followed by \"Z\" or \"(+|-)hh[mm]\"\n+        try\n+          {\n+            calendar.set(\n+              Integer.parseInt(date.substring(0, 4)),      // year\n+              Integer.parseInt(date.substring(4, 6))-1,    // month\n+              Integer.parseInt(date.substring(6, 8)),      // day\n+              Integer.parseInt(date.substring(8, 10)), 0); // hour, min\n+            switch (date.length())\n+              {\n+                case 19:\n+                case 18:\n+                case 17:\n+                case 16:\n+                  calendar.set(calendar.MILLISECOND,\n+                    Integer.parseInt(date.substring(15)));\n+                case 14:\n+                  calendar.set(calendar.SECOND,\n+                    Integer.parseInt(date.substring(12, 14)));\n+                case 12:\n+                  calendar.set(calendar.MINUTE,\n+                    Integer.parseInt(date.substring(10, 12)));\n+              }\n+          }\n+        catch (NumberFormatException nfe)\n+          {\n+            throw new DEREncodingException(\"cannot parse date\");\n+          }\n+      }\n+    return calendar.getTime();\n+  }\n+}"}, {"sha": "dd8afc4ea1e6dd43c37d451d339ff2884d6dd6f0", "filename": "libjava/gnu/java/security/der/DERValue.java", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERValue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERValue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERValue.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,168 @@\n+/* DERValue.java -- a value read or written to a DER encoding.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.der;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+public class DERValue implements DER\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  private final int tagClass;\n+\n+  private final boolean constructed;\n+\n+  private final int tag;\n+\n+  private int length;\n+\n+  private final Object value;\n+\n+  private byte[] encoded;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  public DERValue(int tag, int length, Object value, byte[] encoded)\n+  {\n+    tagClass = tag & 0xC0;\n+    this.tag = tag & 0x1F;\n+    constructed = (tag & CONSTRUCTED) == CONSTRUCTED;\n+    this.length = length;\n+    this.value = value;\n+    if (encoded != null)\n+      this.encoded = (byte[]) encoded.clone();\n+  }\n+\n+  public DERValue(int tag, Object value)\n+  {\n+    this(tag, 0, value, null);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public int getExternalTag()\n+  {\n+    return tagClass | tag | (constructed ? 0x20 : 0x00);\n+  }\n+\n+  public int getTag()\n+  {\n+    return tag;\n+  }\n+\n+  public int getTagClass()\n+  {\n+    return tagClass;\n+  }\n+\n+  public boolean isConstructed()\n+  {\n+    return constructed;\n+  }\n+\n+  public int getLength()\n+  {\n+    if (encoded == null)\n+      {\n+        try\n+          {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            length = DERWriter.write(out, this);\n+            encoded = out.toByteArray();\n+          }\n+        catch (IOException ioe)\n+          {\n+            encoded = new byte[0];\n+          }\n+      }\n+    return length;\n+  }\n+\n+  public Object getValue()\n+  {\n+    return value;\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      {\n+        try\n+          {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            length = DERWriter.write(out, this);\n+            encoded = out.toByteArray();\n+          }\n+        catch (IOException ioe)\n+          {\n+            encoded = new byte[0];\n+          }\n+      }\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public int getEncodedLength()\n+  {\n+    if (encoded == null)\n+      {\n+        try\n+          {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            length = DERWriter.write(out, this);\n+            encoded = out.toByteArray();\n+          }\n+        catch (IOException ioe)\n+          {\n+            encoded = new byte[0];\n+          }\n+      }\n+    return encoded.length;\n+  }\n+\n+  public String toString()\n+  {\n+    return \"DERValue [ tag=\" + tag + \", class=\" + tagClass + \", constructed=\"\n+      + constructed + \", value=\" + value + \" ]\";\n+  }\n+}"}, {"sha": "ec3e3df339d204f924ea7277fd0641abdaf1bdfb", "filename": "libjava/gnu/java/security/der/DERWriter.java", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fder%2FDERWriter.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,324 @@\n+/* DERWriter.java -- write Java types in DER format.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.der;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import java.math.BigInteger;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+\n+import java.text.SimpleDateFormat;\n+\n+import java.util.BitSet;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import gnu.java.security.OID;\n+\n+/**\n+ * Methods that allow various Java types to be written as a DER\n+ * (Distinguished Encoding Rules) stream to the specified output stream.\n+ * DER is used to encode ASN.1 constructions, but this class provides no\n+ * methods for interacting with ASN.1. Rather, callers should construct\n+ * their output objects properly for whatever ASN.1 construct is being\n+ * output.\n+ *\n+ * <p>This class only defines static methods; there are no instance\n+ * variables needed.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class DERWriter implements DER\n+{\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /** This class only has static methods. */\n+  private DERWriter()\n+  {\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  public static int write(OutputStream out, DERValue object) \n+    throws IOException\n+  {\n+    out.write(object.getExternalTag());\n+    Object value = object.getValue();\n+    if (value == null)\n+      {\n+        writeLength(out, 0);\n+        return 0;\n+      }\n+    if (value instanceof Boolean)\n+      return writeBoolean(out, (Boolean) value);\n+    else if (value instanceof BigInteger)\n+      return writeInteger(out, (BigInteger) value);\n+    else if (value instanceof Date)\n+      return writeDate(out, object.getExternalTag(), (Date) value);\n+    else if (value instanceof String)\n+      return writeString(out, object.getExternalTag(), (String) value);\n+    else if (value instanceof List)\n+      return writeSequence(out, (List) value);\n+    else if (value instanceof Set)\n+      return writeSet(out, (Set) value);\n+    else if (value instanceof BitString)\n+      return writeBitString(out, (BitString) value);\n+    else if (value instanceof OID)\n+      return writeOID(out, (OID) value);\n+    else if (value instanceof byte[])\n+      {\n+        writeLength(out, ((byte[]) value).length);\n+        out.write((byte[]) value);\n+        return ((byte[]) value).length;\n+      }\n+    else if (value instanceof DERValue)\n+      {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        write(bout, (DERValue) value);\n+        byte[] buf = bout.toByteArray();\n+        writeLength(out, buf.length);\n+        out.write(buf);\n+        return buf.length;\n+      }\n+    else\n+      throw new DEREncodingException(\"cannot encode \" + value.getClass().getName());\n+  }\n+\n+  public static int definiteEncodingSize(int length)\n+  {\n+    if (length < 128)\n+      return 1;\n+    else if (length < 256)\n+      return 2;\n+    else if (length < 65536)\n+      return 3;\n+    else if (length < 16777216)\n+      return 4;\n+    else\n+      return 5;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Write a BOOLEAN type to the given output stream.\n+   *\n+   * @param out The sink output stream.\n+   * @param b   The boolean value to write.\n+   */\n+  private static int writeBoolean(OutputStream out, Boolean b)\n+    throws IOException\n+  {\n+    writeLength(out, 1);\n+    if (b.booleanValue())\n+      out.write(0xFF);\n+    else\n+      out.write(0);\n+    return 1;\n+  }\n+\n+  /**\n+   * Write an INTEGER type to the given output stream.\n+   *\n+   * @param out The sink output stream.\n+   * @param integer The integer to write.\n+   */\n+  private static int writeInteger(OutputStream out, BigInteger integer)\n+    throws IOException\n+  {\n+    byte[] bytes = integer.toByteArray();\n+    writeLength(out, bytes.length);\n+    out.write(bytes);\n+    return bytes.length;\n+  }\n+\n+  private static int writeSequence(OutputStream out, List sequence)\n+    throws IOException\n+  {\n+    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+    for (Iterator i = sequence.iterator(); i.hasNext(); )\n+      {\n+        write(bout, (DERValue) i.next());\n+      }\n+    byte[] buf = bout.toByteArray();\n+    writeLength(out, buf.length);\n+    out.write(buf);\n+    return buf.length;\n+  }\n+\n+  private static int writeSet(OutputStream out, Set set)\n+    throws IOException\n+  {\n+    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+    for (Iterator i = set.iterator(); i.hasNext(); )\n+      {\n+        write(bout, (DERValue) i.next());\n+      }\n+    byte[] buf = bout.toByteArray();\n+    writeLength(out, buf.length);\n+    out.write(buf);\n+    return buf.length;\n+  }\n+\n+  private static int writeOID(OutputStream out, OID oid)\n+    throws IOException\n+  {\n+    byte[] der = oid.getDER();\n+    writeLength(out, der.length);\n+    out.write(der);\n+    return der.length;\n+  }\n+\n+  private static int writeBitString(OutputStream out, BitString bs)\n+    throws IOException\n+  {\n+    byte[] buf = bs.getShiftedByteArray();\n+    out.write(buf.length + 1);\n+    out.write(bs.getIgnoredBits());\n+    out.write(buf);\n+    return buf.length;\n+  }\n+\n+  private static int writeString(OutputStream out, int tag, String str)\n+    throws IOException\n+  {\n+    Charset charset = null;\n+    byte[] b = null;\n+    switch (tag & 0x1F)\n+      {\n+        case NUMERIC_STRING:\n+        case PRINTABLE_STRING:\n+        case T61_STRING:\n+        case VIDEOTEX_STRING:\n+        case IA5_STRING:\n+        case GRAPHIC_STRING:\n+        case ISO646_STRING:\n+        case GENERAL_STRING:\n+          charset = Charset.forName(\"ISO-8859-1\");\n+          break;\n+        case UNIVERSAL_STRING:\n+        case BMP_STRING:\n+          charset = Charset.forName(\"UTF-16BE\");\n+          break;\n+        case UTF8_STRING:\n+        default:\n+          charset = Charset.forName(\"UTF-8\");\n+          break;\n+      }\n+    if (charset == null)\n+      throw new DEREncodingException(\"no charset\");\n+    CharsetEncoder encoder = charset.newEncoder();\n+    ByteBuffer result = encoder.encode(CharBuffer.wrap(str));\n+    if (result.hasArray())\n+      {\n+        b = result.array();\n+      }\n+    else\n+      {\n+        b = new byte[result.remaining()];\n+        result.get(b);\n+      }\n+    writeLength(out, b.length);\n+    out.write(b);\n+    return b.length;\n+  }\n+\n+  private static int writeDate(OutputStream out, int tag, Date date)\n+    throws IOException\n+  {\n+    SimpleDateFormat sdf = null;\n+    if ((tag & 0x1F) == UTC_TIME)\n+      sdf = new SimpleDateFormat(\"yyMMddHHmmss'Z'\");\n+    else\n+      sdf = new SimpleDateFormat(\"yyyyMMddHHmmss'.'SSS'Z'\");\n+    sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    byte[] b = sdf.format(date).getBytes(\"ISO-8859-1\");\n+    writeLength(out, b.length);\n+    out.write(b);\n+    return b.length;\n+  }\n+\n+  // Package method.\n+  // ------------------------------------------------------------------------\n+\n+  static void writeLength(OutputStream out, int len) throws IOException\n+  {\n+    if (len < 128)\n+      out.write(len);\n+    else if (len < 256)\n+      {\n+        out.write(0x81);\n+        out.write(len);\n+      }\n+    else if (len < 65536)\n+      {\n+        out.write(0x82);\n+        out.write(len >> 8);\n+        out.write(len);\n+      }\n+    else if (len < 16777216)\n+      {\n+        out.write(0x83);\n+        out.write(len >> 16);\n+        out.write(len >>  8);\n+        out.write(len);\n+      }\n+    else\n+      {\n+        out.write(0x84);\n+        out.write(len >> 24);\n+        out.write(len >> 16);\n+        out.write(len >>  8);\n+        out.write(len);\n+      }\n+  }\n+}"}, {"sha": "0f6e492a5f5302d65bccf738dd33aded53a5973b", "filename": "libjava/gnu/java/security/provider/DERReader.java", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/505b0fd661e21182856cfcf73ed6f39c707ac28b/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/505b0fd661e21182856cfcf73ed6f39c707ac28b/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERReader.java?ref=505b0fd661e21182856cfcf73ed6f39c707ac28b", "patch": "@@ -1,152 +0,0 @@\n-/* DERReader.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.security.provider;\n-\n-import java.math.BigInteger;\n-import gnu.java.security.der.DEREncodingException;\n-\n-public class DERReader\n-{\n-  byte source[];\n-  int pos;\n-\n-  static final int UNIVERSAL = 1;\n-  static final int APPLICATION = 2;\n-  static final int CONTEXT_SPECIFIC = 3;\n-  static final int PRIVATE = 4;\n-\n-\n-  public DERReader()\n-  {\n-    source = null;\n-    pos = 0;\n-  }\n-\n-  public DERReader( byte source[] )\n-  {\n-    init( source );\n-  }\n-\n-  public void init( String source )\n-  {\n-    init( source.getBytes() );\n-  }\n-\n-  public void init( byte source[] )\n-  {\n-    this.source = source;\n-    pos = 0;\n-  }\n-\n-  public BigInteger getBigInteger() throws DEREncodingException\n-  {\n-    return new BigInteger( getPrimitive() );\n-  }\n-\n-  //Reads Primitive, definite-length method\n-  private byte[] getPrimitive() throws DEREncodingException\n-  {\n-    int tmp = pos;\n-\t\n-    //Read Identifier\n-    byte identifier = source[tmp++];\n-    if( (0x20 & identifier) != 0)\n-      throw new DEREncodingException();\n-    int type = translateLeadIdentifierByte(identifier);\n-    //System.out.println(\"Type: \" + type);\n-\n-    //get tag\n-    int tag = (0x1f & identifier);\n-    //if( tag == 0x1f)\n-    //\ttag = getIdentifier(tmp);\n-    //System.out.println(\"Tag: \" + tag);\n-\n-    //get length\n-    byte len = source[tmp]; //may be length of length parameter\n-    long length =  0x7f & len;\n-    int i;\n-    if( (0x80 & len) != 0 ) {\n-      //System.out.println(\"Extra Long Length\");\n-      len &= 0x7f;\n-      //System.out.println(\"Length of Length: \" + len);\n-      //get length here\n-      length = 0;\n-      for( i = 0; i < len; i++ ) {\n-\ttmp++;\n-\tlength <<= 8;\n-\tlength += (source[tmp] < 0 ) ? \n-\t  (256 + source[tmp]) : \n-\t  source[tmp];\n-\t//System.out.println(\"Length of Length: \" + length);\n-      }\n-      tmp++;\n-    } else\n-      tmp++;\n-\n-    /*System.out.println(\"Position: \" + tmp);\n-      System.out.println(\"Length: \" + length);\n-      for( i = 0; i < 10; i++)\n-      System.out.print(source[tmp + i] + \" \");\n-      System.out.println();*/\n-\n-    byte tmpb[] = new byte[ (int)length ];\n-    System.arraycopy( source, tmp, tmpb, 0, (int)length);\n-    pos = (int)(tmp + length);\n-    return tmpb;\t\n-  }\n-\n-  private int translateLeadIdentifierByte(byte b)\n-  {\n-    if( (0x3f & b ) == b)\n-      return UNIVERSAL;\n-    else if( (0x7f & b ) == b)\n-      return APPLICATION;\n-    else if( (0xbf & b ) == b)\n-      return CONTEXT_SPECIFIC;\n-    else \n-      return PRIVATE;\n-  }\n-\n-  private int getIdentifier(int tpos)\n-  {\n-    while( (0x80 & source[tpos]) != 0)\n-      tpos++;\n-    return tpos;\n-  }\n-}"}, {"sha": "4add1191e06a7a3265e2ca3ec7dbfbdb8968e8a7", "filename": "libjava/gnu/java/security/provider/DERWriter.java", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/505b0fd661e21182856cfcf73ed6f39c707ac28b/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/505b0fd661e21182856cfcf73ed6f39c707ac28b/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDERWriter.java?ref=505b0fd661e21182856cfcf73ed6f39c707ac28b", "patch": "@@ -1,142 +0,0 @@\n-/* DERWriter.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.security.provider;\n-\n-import java.math.BigInteger;\n-\n-public class DERWriter\n-{\n-  static final int UNIVERSAL = 1;\n-  static final int APPLICATION = 2;\n-  static final int CONTEXT_SPECIFIC = 3;\n-  static final int PRIVATE = 4;\n-\n-  public DERWriter()\n-  {}\n-\n-  public byte[] writeBigInteger( BigInteger i)\n-  {\n-    return writePrimitive( 0x02, UNIVERSAL, (int)Math.ceil((double)i.bitLength() / 8), i.toByteArray() );\n-  }\n-\n-  private byte[] writePrimitive( int identifier, int identifierencoding,\n-\t\t\t\t int length, byte contents[])\n-  {\n-    return joinarrays( generateIdentifier( identifier, identifierencoding ), generateLength( length ), contents);\n-  }\n-\n-  public byte[] joinarrays( byte a[], byte b[])\n-  {\n-    byte d[] = new byte[ a.length + b.length];\n-    System.arraycopy( a, 0, d, 0, a.length);\n-    System.arraycopy( b, 0, d, a.length, b.length);\n-    return d;\n-  }\n-\n-  public byte[] joinarrays( byte a[], byte b[], byte c[])\n-  {\n-    byte d[] = new byte[ a.length + b.length + c.length];\n-    System.arraycopy( a, 0, d, 0, a.length);\n-    System.arraycopy( b, 0, d, a.length, b.length);\n-    System.arraycopy( c, 0, d, a.length + b.length, c.length);\n-    return d;\n-  }\n-\n-  private byte[] generateIdentifier(int identifier, \n-\t\t\t\t    int identifierencoding)\n-  {\n-    byte b[];\n-    if( identifier > 31 ) {\n-      int count = (int)(Math.log( identifier ) / Math.log( 256 ));\n-      b = new byte[ count + 1 ];\n-      b[0] = (byte)(translateLeadIdentifierByte(identifierencoding) \n-\t\t    | 0x1f);\n-      int i;\n-      for( i = 1; i < (count + 1); i++) {\n-\tb[i] = (byte)(0x7f & ( identifier >> (7 * (count - i)) ));\n-\tb[i] |= 0x80;\n-      }\n-      b[i - 1] ^= 0x80;\n-      //System.out.println(\"Identifier1: \" + b[0]);\n-      return b;\n-    } else {\n-      b = new byte[1];\n-      b[0] = (byte)((translateLeadIdentifierByte(identifierencoding)\n-\t\t     | (byte)( identifier & 0x1f )) & 0xdf);\n-      //System.out.println(\"Identifier2: \" + b[0]);\n-      return b;\n-    }\n-  }\n-\n-  private byte translateLeadIdentifierByte(int b)\n-  {\n-    if( b == UNIVERSAL)\n-      return (byte)0x3f;\n-    else if( b == APPLICATION)\n-      return (byte)0x7f;\n-    else if( b == CONTEXT_SPECIFIC)\n-      return (byte)0xbf;\n-    else \n-      return (byte)0xC0;\n-  }\n-\n-  private byte[] generateLength( int length )\n-  {\n-    byte b[];\n-    if( length > 127 ) {\n-      int count = (int)Math.ceil(Math.log( length ) / Math.log( 256 ));\n-      //System.out.println(\"Length byte count: \" + count);\n-      b = new byte[ count + 1 ];\n-      b[0] = (byte)((count & 0x7f) | 0x80);\n-      for( int i = 1; i < (count + 1); i++) {\n-\tb[i] = (byte)( length >>> (8 * ( count - i) ));\n-\t//System.out.println(\"Length1 byte1: \" + (length >>> (8 * ( count - i) )));\n-\t//System.out.println(\"Length1 byte2: \" + b[i]);\n-      }\n-\n-      //System.out.println(\"Length1: \" + length);\n-      return b;\n-    } else {\n-      b = new byte[1];\n-      b[0] = (byte)( length & 0x7f );\n-      //System.out.println(\"Length2: \" + length);\n-      return b;\n-    }\n-  }\n-}"}, {"sha": "3414f423c4850b96f325009fcd4bf464ceeab0fd", "filename": "libjava/gnu/java/security/provider/DSAKeyFactory.java", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAKeyFactory.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,134 @@\n+/* DSAKeyFactory.java -- DSA key factory.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.interfaces.DSAPrivateKey;\n+import java.security.interfaces.DSAPublicKey;\n+import java.security.spec.DSAPrivateKeySpec;\n+import java.security.spec.DSAPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+\n+/**\n+ * DSA key factory.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class DSAKeyFactory extends KeyFactorySpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  public DSAKeyFactory()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    if (!(keySpec instanceof DSAPrivateKeySpec))\n+      throw new InvalidKeySpecException();\n+    return new GnuDSAPrivateKey(\n+      ((DSAPrivateKeySpec) keySpec).getX(),\n+      ((DSAPrivateKeySpec) keySpec).getP(),\n+      ((DSAPrivateKeySpec) keySpec).getQ(),\n+      ((DSAPrivateKeySpec) keySpec).getG());\n+  }\n+\n+  protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    if (!(keySpec instanceof DSAPublicKeySpec))\n+      throw new InvalidKeySpecException();\n+    return new GnuDSAPublicKey(\n+      ((DSAPublicKeySpec) keySpec).getY(),\n+      ((DSAPublicKeySpec) keySpec).getP(),\n+      ((DSAPublicKeySpec) keySpec).getQ(),\n+      ((DSAPublicKeySpec) keySpec).getG());\n+  }\n+\n+  protected KeySpec engineGetKeySpec(Key key, Class keySpec)\n+    throws InvalidKeySpecException\n+  {\n+    if ((key instanceof DSAPublicKey) &&\n+         keySpec.isAssignableFrom(DSAPublicKeySpec.class))\n+      {\n+        return new DSAPublicKeySpec(((DSAPublicKey) key).getY(),\n+          ((DSAPublicKey) key).getParams().getP(),\n+          ((DSAPublicKey) key).getParams().getQ(),\n+          ((DSAPublicKey) key).getParams().getG());\n+      }\n+    if ((key instanceof DSAPrivateKey) &&\n+         keySpec.isAssignableFrom(DSAPrivateKeySpec.class))\n+      {\n+        return new DSAPrivateKeySpec(((DSAPrivateKey) key).getX(),\n+          ((DSAPrivateKey) key).getParams().getP(),\n+          ((DSAPrivateKey) key).getParams().getQ(),\n+          ((DSAPrivateKey) key).getParams().getG());\n+      }\n+    throw new InvalidKeySpecException();\n+  }\n+\n+  protected Key engineTranslateKey(Key key) throws InvalidKeyException\n+  {\n+    if ((key instanceof GnuDSAPublicKey) || (key instanceof GnuDSAPrivateKey))\n+      return key;\n+    if (key instanceof DSAPublicKey)\n+      return new GnuDSAPublicKey(((DSAPublicKey) key).getY(),\n+        ((DSAPublicKey) key).getParams().getP(),\n+        ((DSAPublicKey) key).getParams().getQ(),\n+        ((DSAPublicKey) key).getParams().getG());\n+    if (key instanceof DSAPrivateKey)\n+      return new GnuDSAPrivateKey(((DSAPrivateKey) key).getX(),\n+        ((DSAPrivateKey) key).getParams().getP(),\n+        ((DSAPrivateKey) key).getParams().getQ(),\n+        ((DSAPrivateKey) key).getParams().getG());\n+    throw new InvalidKeyException();\n+  } \n+}"}, {"sha": "31c0d5e8e8e25cd774b089274d6199e2d64bba58", "filename": "libjava/gnu/java/security/provider/DSAParameters.java", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSAParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* DSAParameters.java --- DSA Parameters Implementation\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,15 +38,28 @@\n \n package gnu.java.security.provider;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+\n import java.math.BigInteger;\n+\n import java.security.AlgorithmParametersSpi;\n import java.security.InvalidAlgorithmParameterException;\n import java.security.spec.AlgorithmParameterSpec;\n import java.security.spec.DSAParameterSpec;\n import java.security.spec.InvalidParameterSpecException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Random;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.der.DER;\n import gnu.java.security.der.DEREncodingException;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n \n import gnu.java.security.util.Prime;\n \n@@ -76,7 +89,7 @@ public void engineInit(AlgorithmParameterSpec paramSpec)\n \t\tDSAParameterSpec dsaParamSpec = (DSAParameterSpec)paramSpec;\n \t\tp = dsaParamSpec.getP();\n \t\tq = dsaParamSpec.getQ();\n-\t\tq = dsaParamSpec.getG();\n+\t\tg = dsaParamSpec.getG();\n \t}\n \telse\n \t\tthrow new InvalidParameterSpecException(\"Only accepts DSAParameterSpec\");\n@@ -85,16 +98,20 @@ public void engineInit(AlgorithmParameterSpec paramSpec)\n public void engineInit(byte[] params)\n                             throws IOException\n {\n-\tDERReader reader = new DERReader( params );\n-\ttry {\n-\n-\t\tp = reader.getBigInteger();\n-\t\tq = reader.getBigInteger();\n-\t\tg = reader.getBigInteger();\n-\n-\t} catch ( DEREncodingException DERee) {\n-\t\tthrow new IOException(\"Invalid Format: Only accepts ASN.1\");\n-\t}\n+\tDERReader in = new DERReader(params);\n+\tDERValue val = in.read();\n+\tif (val.getValue() != DER.CONSTRUCTED_VALUE)\n+\t\tthrow new ASN1ParsingException(\"badly formed parameters\");\n+\ttry\n+\t\t{\n+\t\t\tp = (BigInteger) in.read().getValue();\n+\t\t\tq = (BigInteger) in.read().getValue();\n+\t\t\tg = (BigInteger) in.read().getValue();\n+\t\t}\n+\tcatch (Exception x)\n+\t\t{\n+\t\t\tthrow new ASN1ParsingException(\"badly formed parameters\");\n+\t\t}\n }\n \n public void engineInit(byte[] params, String format)\n@@ -117,10 +134,13 @@ public AlgorithmParameterSpec engineGetParameterSpec(Class paramSpec)\n public byte[] engineGetEncoded()\n                                     throws IOException\n {\n-\tDERWriter writer = new DERWriter();\n-\treturn writer.joinarrays( writer.writeBigInteger(p), \n-\t\t\t\twriter.writeBigInteger(q), \n-\t\t\t\twriter.writeBigInteger(g) );\n+\tByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\tArrayList seq = new ArrayList(3);\n+\tseq.add(new DERValue(DER.INTEGER, p));\n+\tseq.add(new DERValue(DER.INTEGER, q));\n+\tseq.add(new DERValue(DER.INTEGER, g));\n+\tDERWriter.write(bout, new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, seq));\n+\treturn bout.toByteArray();\n }\n \n \n@@ -135,7 +155,7 @@ public byte[] engineGetEncoded(String format)\n public String engineToString()\n {\n \tString lineSeparator = System.getProperty(\"line.seperator\");\n-\treturn (\"q: \" + q + lineSeparator + \"p: \" + p + lineSeparator + \"g:\" + g);\n+\treturn (\"q: \" + q + \" p: \" + p + \" g: \" + g);\n }\n \n }"}, {"sha": "7da1c7dab3640a91fef142b64d78cefaa7eeebab", "filename": "libjava/gnu/java/security/provider/DSASignature.java", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* DSASignature.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,7 +37,12 @@\n \n package gnu.java.security.provider;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n import java.math.BigInteger;\n+\n import java.security.InvalidAlgorithmParameterException;\n import java.security.InvalidKeyException;\n import java.security.InvalidParameterException;\n@@ -52,8 +57,17 @@\n import java.security.interfaces.DSAPrivateKey;\n import java.security.interfaces.DSAPublicKey;\n import java.security.spec.AlgorithmParameterSpec;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Random;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.der.DER;\n import gnu.java.security.der.DEREncodingException;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n \n public class DSASignature extends SignatureSpi\n {\n@@ -157,9 +171,14 @@ public byte[] engineSign()\n       BigInteger s = sha.add( x.multiply( r ) );\n       s = s.multiply( k.modInverse(q) ).mod( q );\n \n-      DERWriter writer = new DERWriter();\n-      return writer.joinarrays( writer.writeBigInteger( r ),  writer.writeBigInteger( s ) );\n-\n+      ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+      ArrayList seq = new ArrayList(2);\n+      seq.set(0, new DERValue(DER.INTEGER, r));\n+      seq.set(1, new DERValue(DER.INTEGER, s));\n+      DERWriter.write(bout, new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, seq));\n+      return bout.toByteArray();\n+    } catch (IOException ioe) {\n+      throw new SignatureException();\n     } catch ( ArithmeticException ae ) {\n       throw new SignatureException();\n     }\n@@ -180,9 +199,12 @@ public boolean engineVerify(byte[] sigBytes)\n   {\n     //Decode sigBytes from ASN.1 DER encoding\n     try {\n-      DERReader reader = new DERReader( sigBytes );\n-      BigInteger r = reader.getBigInteger();\n-      BigInteger s = reader.getBigInteger();\n+      DERReader in = new DERReader(sigBytes);\n+      DERValue val = in.read();\n+      if (!val.isConstructed())\n+        throw new SignatureException(\"badly formed signature\");\n+      BigInteger r = (BigInteger) in.read().getValue();\n+      BigInteger s = (BigInteger) in.read().getValue();\n \n       BigInteger g = publicKey.getParams().getG();\n       BigInteger p = publicKey.getParams().getP();\n@@ -206,8 +228,8 @@ public boolean engineVerify(byte[] sigBytes)\n \treturn true;\n       else\n \treturn false;\n-    } catch ( DEREncodingException deree ) {\n-      throw new SignatureException();\n+    } catch (IOException ioe) {\n+      throw new SignatureException(\"badly formed signature\");\n     }\n   }\n "}, {"sha": "70a7d1df15ec8cf204be91ed3a621a3d0b5fd8c9", "filename": "libjava/gnu/java/security/provider/Gnu.java", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnu.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* Gnu.java --- Gnu provider main class\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -43,15 +43,15 @@ public final class Gnu extends Provider\n {\n   public Gnu()\n   {\n-    super( \"GNU\", 1.0, \"GNU provider v1.0 implementing SHA-1, MD5, DSA\");\n+    super(\"GNU\", 1.0, \"GNU provider v1.0 implementing SHA-1, MD5, DSA, X.509 Certificates\");\n \n     // Note that all implementation class names are referenced by using\n     // Class.getName(). That way when we staticly link the Gnu provider\n     // we automatically get all the implementation classes.\n \n     // Signature\n     put(\"Signature.SHA1withDSA\",\n-\tgnu.java.security.provider.DSASignature.class.getName());\n+        gnu.java.security.provider.DSASignature.class.getName());\n \n     put(\"Alg.Alias.Signature.DSS\", \"SHA1withDSA\");\n     put(\"Alg.Alias.Signature.DSA\", \"SHA1withDSA\");\n@@ -68,12 +68,20 @@ public Gnu()\n \n     // Key Pair Generator\n     put(\"KeyPairGenerator.DSA\",\n-\tgnu.java.security.provider.DSAKeyPairGenerator.class.getName());\n+        gnu.java.security.provider.DSAKeyPairGenerator.class.getName());\n \n     put(\"Alg.Alias.KeyPairGenerator.OID.1.2.840.10040.4.1\", \"DSA\");\n     put(\"Alg.Alias.KeyPairGenerator.1.2.840.10040.4.1\", \"DSA\");\n     put(\"Alg.Alias.KeyPairGenerator.1.3.14.3.2.12\", \"DSA\");\n \n+    // Key Factory\n+    put(\"KeyFactory.DSA\",\n+        gnu.java.security.provider.DSAKeyFactory.class.getName());\n+\n+    put(\"Alg.Alias.KeyFactory.OID.1.2.840.10040.4.1\", \"DSA\");\n+    put(\"Alg.Alias.KeyFactory.1.2.840.10040.4.1\", \"DSA\");\n+    put(\"Alg.Alias.KeyFactory.1.3.14.3.2.12\", \"DSA\");\n+\n     // Message Digests\n     put(\"MessageDigest.SHA\", gnu.java.security.provider.SHA.class.getName());\n     put(\"MessageDigest.MD5\", gnu.java.security.provider.MD5.class.getName());\n@@ -84,15 +92,20 @@ public Gnu()\n \n     // Algorithm Parameters\n     put(\"AlgorithmParameters.DSA\",\n-\tgnu.java.security.provider.DSAParameters.class.getName());\n+        gnu.java.security.provider.DSAParameters.class.getName());\n \n     // Algorithm Parameter Generator\n     put(\"AlgorithmParameterGenerator.DSA\",\n-     gnu.java.security.provider.DSAParameterGenerator.class.getName());\n+        gnu.java.security.provider.DSAParameterGenerator.class.getName());\n \n     // SecureRandom\n     put(\"SecureRandom.SHA1PRNG\",\n-\tgnu.java.security.provider.SHA1PRNG.class.getName());\n+        gnu.java.security.provider.SHA1PRNG.class.getName());\n+\n+    // CertificateFactory\n+    put(\"CertificateFactory.X.509\",\n+        gnu.java.security.provider.X509CertificateFactory.class.getName());\n \n+    put(\"Alg.Alias.CertificateFactory.X509\", \"X.509\");\n   }\n }"}, {"sha": "4eceb0074da43aa54c4a22c4dd62fc00312f6e6e", "filename": "libjava/gnu/java/security/provider/GnuDSAPrivateKey.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPrivateKey.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -82,4 +82,10 @@ public BigInteger getX()\n   {\n     return x;\n   }\n+\n+  public String toString()\n+  {\n+    return \"GnuDSAPrivateKey: x=\" + x.toString(16) + \" p=\" + p.toString(16)\n+      + \" q=\" + q.toString(16) + \" g=\" + g.toString(16);\n+  }\n }"}, {"sha": "91d6b561c7fceb30d60c6f3507f593905fad454d", "filename": "libjava/gnu/java/security/provider/GnuDSAPublicKey.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FGnuDSAPublicKey.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* GnuDSAPublicKey.java --- Gnu DSA Public Key\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -82,4 +82,10 @@ public BigInteger getY()\n   {\n     return y;\n   }\n+\n+  public String toString()\n+  {\n+    return \"GnuDSAPublicKey: y=\" + y.toString(16) + \" p=\" + p.toString(16)\n+      + \" q=\" + q.toString(16) + \" g=\" + g.toString(16);\n+  }\n }"}, {"sha": "62d3d38af626daeb9b806d612ec5a1aaea1f7e16", "filename": "libjava/gnu/java/security/provider/X509CertificateFactory.java", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FX509CertificateFactory.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,269 @@\n+/* X509CertificateFactory.java -- generates X.509 certificates.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.provider;\n+\n+import java.io.BufferedInputStream;\n+import java.io.EOFException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactorySpi;\n+import java.security.cert.CRL;\n+import java.security.cert.CRLException;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+import gnu.java.io.Base64InputStream;\n+import gnu.java.security.x509.X509Certificate;\n+import gnu.java.security.x509.X509CRL;\n+\n+public class X509CertificateFactory extends CertificateFactorySpi\n+{\n+\n+  // Constants.\n+  // ------------------------------------------------------------------------\n+\n+  public static final String BEGIN_CERTIFICATE = \"-----BEGIN CERTIFICATE-----\";\n+  public static final String END_CERTIFICATE = \"-----END CERTIFICATE-----\";\n+  public static final String BEGIN_X509_CRL = \"-----BEGIN X509 CRL-----\";\n+  public static final String END_X509_CRL = \"-----END X509 CRL-----\";\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  public X509CertificateFactory()\n+  {\n+    super();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public Certificate engineGenerateCertificate(InputStream inStream)\n+    throws CertificateException\n+  {\n+    try\n+      {\n+        return generateCert(inStream);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new CertificateException(ioe.toString());\n+      }\n+  }\n+\n+  public Collection engineGenerateCertificates(InputStream inStream)\n+    throws CertificateException\n+  {\n+    LinkedList certs = new LinkedList();\n+    while (true)\n+      {\n+        try\n+          {\n+            certs.add(generateCert(inStream));\n+          }\n+        catch (EOFException eof)\n+          {\n+            break;\n+          }\n+        catch (IOException ioe)\n+          {\n+            throw new CertificateException(ioe.toString());\n+          }\n+      }\n+    return certs;\n+  }\n+\n+  public CRL engineGenerateCRL(InputStream inStream) throws CRLException\n+  {\n+    try\n+      {\n+        return generateCRL(inStream);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new CRLException(ioe.toString());\n+      }\n+  }\n+\n+  public Collection engineGenerateCRLs(InputStream inStream)\n+    throws CRLException\n+  {\n+    LinkedList crls = new LinkedList();\n+    while (true)\n+      {\n+        try\n+          {\n+            crls.add(generateCRL(inStream));\n+          }\n+        catch (EOFException eof)\n+          {\n+            break;\n+          }\n+        catch (IOException ioe)\n+          {\n+            throw new CRLException(ioe.toString());\n+          }\n+      }\n+    return crls;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private X509Certificate generateCert(InputStream inStream)\n+    throws IOException, CertificateException\n+  {\n+    if (!inStream.markSupported())\n+      inStream = new BufferedInputStream(inStream, 8192);\n+    inStream.mark(20);\n+    int i = inStream.read();\n+    if (i == -1)\n+      throw new EOFException();\n+\n+    // If the input is in binary DER format, the first byte MUST be\n+    // 0x30, which stands for the ASN.1 [UNIVERSAL 16], which is the\n+    // UNIVERSAL SEQUENCE, with the CONSTRUCTED bit (0x20) set.\n+    //\n+    // So if we do not see 0x30 here we will assume it is in Base-64.\n+    if (i != 0x30)\n+      {\n+        inStream.reset();\n+        StringBuffer line = new StringBuffer(80);\n+        do\n+          {\n+            line.setLength(0);\n+            do\n+              {\n+                i = inStream.read();\n+                if (i == -1)\n+                  throw new EOFException();\n+                if (i != '\\n' && i != '\\r')\n+                  line.append((char) i);\n+              }\n+            while (i != '\\n' && i != '\\r');\n+          }\n+        while (!line.toString().equals(BEGIN_CERTIFICATE));\n+        X509Certificate ret = new X509Certificate(\n+           new BufferedInputStream(new Base64InputStream(inStream), 8192));\n+        line.setLength(0);\n+        line.append('-'); // Base64InputStream will eat this.\n+        do\n+          {\n+            i = inStream.read();\n+            if (i == -1)\n+              throw new EOFException();\n+            if (i != '\\n' && i != '\\r')\n+              line.append((char) i);\n+          }\n+        while (i != '\\n' && i != '\\r');\n+        // XXX ???\n+        if (!line.toString().equals(END_CERTIFICATE))\n+          throw new CertificateException(\"no end-of-certificate marker\");\n+        return ret;\n+      }\n+    else\n+      {\n+        inStream.reset();\n+        return new X509Certificate(inStream);\n+      }\n+  }\n+\n+  private X509CRL generateCRL(InputStream inStream)\n+    throws IOException, CRLException\n+  {\n+    if (!inStream.markSupported())\n+      inStream = new BufferedInputStream(inStream, 8192);\n+    inStream.mark(20);\n+    int i = inStream.read();\n+    if (i == -1)\n+      throw new EOFException();\n+\n+    // If the input is in binary DER format, the first byte MUST be\n+    // 0x30, which stands for the ASN.1 [UNIVERSAL 16], which is the\n+    // UNIVERSAL SEQUENCE, with the CONSTRUCTED bit (0x20) set.\n+    //\n+    // So if we do not see 0x30 here we will assume it is in Base-64.\n+    if (i != 0x30)\n+      {\n+        inStream.reset();\n+        StringBuffer line = new StringBuffer(80);\n+        do\n+          {\n+            line.setLength(0);\n+            do\n+              {\n+                i = inStream.read();\n+                if (i == -1)\n+                  throw new EOFException();\n+                if (i != '\\n' && i != '\\r')\n+                  line.append((char) i);\n+              }\n+            while (i != '\\n' && i != '\\r');\n+          }\n+        while (!line.toString().startsWith(BEGIN_X509_CRL));\n+        X509CRL ret = new X509CRL(\n+           new BufferedInputStream(new Base64InputStream(inStream), 8192));\n+        line.setLength(0);\n+        line.append('-'); // Base64InputStream will eat this.\n+        do\n+          {\n+            i = inStream.read();\n+            if (i == -1)\n+              throw new EOFException();\n+            if (i != '\\n' && i != '\\r')\n+              line.append((char) i);\n+          }\n+        while (i != '\\n' && i != '\\r');\n+        // XXX ???\n+        if (!line.toString().startsWith(END_X509_CRL))\n+          throw new CRLException(\"no end-of-CRL marker\");\n+        return ret;\n+      }\n+    else\n+      {\n+        inStream.reset();\n+        return new X509CRL(inStream);\n+      }\n+  }\n+\n+}"}, {"sha": "5284385267a9f96c8f3aaa27a3cad6c1d38b5a88", "filename": "libjava/gnu/java/security/x509/X500DistinguishedName.java", "status": "added", "additions": 824, "deletions": 0, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX500DistinguishedName.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,824 @@\n+/* X500DistinguishedName.java -- X.500 name.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.StreamTokenizer;\n+import java.io.StringReader;\n+\n+import java.security.Principal;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+/**\n+ * A X.500 distinguished name. Distinguished names are sequences of\n+ * ATTRIB=VALUE pairs, where ATTRIB is one of the following:\n+ *\n+ * <table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">\n+ * <tr>\n+ * <th bgcolor=\"#CCCCFF\" align=\"left\">Name</th>\n+ * <th bgcolor=\"#CCCCFF\" align=\"left\">X.500 AttributeType</th>\n+ * <th bgcolor=\"#CCCCFF\" align=\"left\">ObjectIdentifier</th>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">CN</td>\n+ * <td align=\"left\">commonName</td>\n+ * <td align=\"left\">2.5.4.3</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">C</td>\n+ * <td align=\"left\">countryName</td>\n+ * <td align=\"left\">2.5.4.6</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">L</td>\n+ * <td align=\"left\">localityName</td>\n+ * <td align=\"left\">2.5.4.7</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">ST</td>\n+ * <td align=\"left\">stateOrProvinceName</td>\n+ * <td align=\"left\">2.5.4.8</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">STREET</td>\n+ * <td align=\"left\">streetAddress</td>\n+ * <td align=\"left\">2.5.4.9</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">O</td>\n+ * <td align=\"left\">organizationName</td>\n+ * <td align=\"left\">2.5.4.10</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">OU</td>\n+ * <td align=\"left\">organizationUnitName</td>\n+ * <td align=\"left\">2.5.4.11</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">DC</td>\n+ * <td align=\"left\">domainComponent</td>\n+ * <td align=\"left\">0.9.2342.19200300.100.1.25</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">UID</td>\n+ * <td align=\"left\">userid</td>\n+ * <td align=\"left\"0.9.2342.19200300.100.1.1></td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">DNQ or DNQUALIFIER(*)</td>\n+ * <td align=\"left\">domainNameQualifier</td>\n+ * <td align=\"left\">2.5.4.46</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">SURNAME(*)</td>\n+ * <td align=\"left\">name</td>\n+ * <td align=\"left\">2.5.4.41</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">GIVENNAME(*)</td>\n+ * <td align=\"left\">givenName</td>\n+ * <td align=\"left\">2.5.4.42</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">INITIALS(*)</td>\n+ * <td align=\"left\">initials</td>\n+ * <td align=\"left\">2.5.4.43</td>\n+ * </tr>\n+ * <tr>\n+ * <td align=\"left\">EMAILADDRESS(*)</td>\n+ * <td align=\"left\">emailAddress</td>\n+ * <td align=\"left\">2.5.4.44</td>\n+ * </tr>\n+ * </table>\n+ *\n+ * <p><i>(*) = attributes not specified in RFC1779 or RFC2253, but\n+ * recognized anyway.</i>\n+ *\n+ * <p>Distinguished names of this form are used in the lightweight\n+ * directory access protocol (LDAP) and in the issuer and subject fields\n+ * of X.509 certificates.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ * @see javax.security.auth.x500.X500Principal\n+ * @status DER decoding/encoding works, RFC1779 and RFC2253 need to be\n+ *         made more robust.\n+ */\n+public class X500DistinguishedName\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  public static final OID CN         = new OID(\"2.5.4.3\");\n+  public static final OID C          = new OID(\"2.5.4.6\");\n+  public static final OID L          = new OID(\"2.5.4.7\");\n+  public static final OID ST         = new OID(\"2.5.4.8\");\n+  public static final OID STREET     = new OID(\"2.5.4.9\");\n+  public static final OID O          = new OID(\"2.5.4.10\");\n+  public static final OID OU         = new OID(\"2.5.4.11\");\n+  public static final OID T          = new OID(\"2.5.4.12\");\n+  public static final OID DNQ        = new OID(\"2.5.4.46\");\n+  public static final OID NAME       = new OID(\"2.5.4.41\");\n+  public static final OID GIVENNAME  = new OID(\"2.5.4.42\");\n+  public static final OID INITIALS   = new OID(\"2.5.4.43\");\n+  public static final OID GENERATION = new OID(\"2.5.4.44\");\n+  public static final OID EMAIL      = new OID(\"1.2.840.113549.1.9.1\");\n+  public static final OID DC         = new OID(\"0.9.2342.19200300.100.1.25\");\n+  public static final OID UID        = new OID(\"0.9.2342.19200300.100.1.1\");\n+\n+  private String commonName;\n+  private String country;\n+  private String locality;\n+  private String orgUnit;\n+  private String organization;\n+  private String street;\n+  private String state;\n+  private String title;\n+  private String dnQualifier;\n+  private String surname;\n+  private String givenName;\n+  private String initials;\n+  private String generation;\n+  private String email;\n+  private String domainComponent;\n+  private String userid;\n+\n+  private String nameRFC1779;\n+  private String nameRFC2253;\n+  private String nameCanonical;\n+\n+  private transient byte[] encoded;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new X500DistinguishedName from the RFC1779 or RFC2253\n+   * encoded form.\n+   *\n+   * @param name The encoded name.\n+   * @throws IllegalArgumentException If the name cannot be parsed.\n+   */\n+  public X500DistinguishedName(String name)\n+  {\n+    if (name == null)\n+      throw new NullPointerException();\n+    try\n+      {\n+        parseDN(name, true);\n+      }\n+    catch (Exception e)\n+      {\n+        parseDN(name, false);\n+      }\n+  }\n+\n+  /**\n+   * Create a new X500DistinguishedName from the DER encoded bytes.\n+   *\n+   * @param encoded The encoded form.\n+   * @throws IOException If the bytes are not a valid DER construct.\n+   */\n+  public X500DistinguishedName(byte[] encoded) throws IOException\n+  {\n+    this(new ByteArrayInputStream(encoded));\n+  }\n+\n+  /**\n+   * Create a new X500DistinguishedName from the DER encoded bytes.\n+   *\n+   * @param encoded The encoded form.\n+   * @throws IOException If the bytes are not a valid DER construct.\n+   */\n+  public X500DistinguishedName(InputStream encoded) throws IOException\n+  {\n+    parseDER(encoded);\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean equals(Object o)\n+  {\n+    return \n+      (commonName != null &&\n+       commonName.equals(((X500DistinguishedName) o).commonName)) &&\n+      (country != null &&\n+       country.equals(((X500DistinguishedName) o).country)) &&\n+      (locality != null &&\n+       locality.equals(((X500DistinguishedName) o).locality)) &&\n+      (orgUnit != null &&\n+       orgUnit.equals(((X500DistinguishedName) o).orgUnit)) &&\n+      (organization != null &&\n+       organization.equals(((X500DistinguishedName) o).organization)) &&\n+      (street != null &&\n+       street.equals(((X500DistinguishedName) o).street)) &&\n+      (state != null &&\n+       state.equals(((X500DistinguishedName) o).state)) &&\n+      (domainComponent != null &&\n+       domainComponent.equals(((X500DistinguishedName) o).domainComponent)) &&\n+      (title != null &&\n+       title.equals(((X500DistinguishedName) o).title)) &&\n+      (dnQualifier != null &&\n+       dnQualifier.equals(((X500DistinguishedName) o).dnQualifier)) &&\n+      (surname != null &&\n+       surname.equals(((X500DistinguishedName) o).surname)) &&\n+      (givenName != null &&\n+       givenName.equals(((X500DistinguishedName) o).givenName)) &&\n+      (initials != null &&\n+       initials.equals(((X500DistinguishedName) o).initials)) &&\n+      (generation != null &&\n+       generation.equals(((X500DistinguishedName) o).generation)) &&\n+      (email != null &&\n+       email.equals(((X500DistinguishedName) o).email)) &&\n+      (userid != null &&\n+       userid.equals(((X500DistinguishedName) o).userid));\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    if (encoded == null)\n+      encoded = encodeDER();\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  private static String quote(String str)\n+  {\n+    if (str.indexOf(\" \")  > 0 || str.indexOf(\"\\f\") > 0 ||\n+        str.indexOf(\"\\n\") > 0 || str.indexOf(\"\\r\") > 0 ||\n+        str.indexOf(\"\\t\") > 0)\n+      str = '\"' + str + '\"';\n+    // XXX needs regex\n+    //return str.replaceAll(\"([,+\\\"\\\\<>;])\", \"\\\\\\1\");\n+    return str;\n+  }\n+\n+  public String toRFC1779()\n+  {\n+    if (nameRFC1779 != null)\n+      return nameRFC1779;\n+    StringBuffer buf = new StringBuffer();\n+    if (commonName != null)\n+      buf.append(\"CN=\").append(quote(commonName)).append(\", \");\n+    if (country != null)\n+      buf.append(\"C=\").append(quote(country)).append(\", \");\n+    if (locality != null)\n+      buf.append(\"L=\").append(quote(locality)).append(\", \");\n+    if (orgUnit != null)\n+      buf.append(\"OU=\").append(quote(orgUnit)).append(\", \");\n+    if (organization != null)\n+      buf.append(\"O=\").append(quote(organization)).append(\", \");\n+    if (street != null)\n+      buf.append(\"STREET=\").append(quote(street)).append(\", \");\n+    if (state != null)\n+      buf.append(\"ST=\").append(quote(state)).append(\", \");\n+    if (title != null)\n+      buf.append(T).append(\"=\").append(quote(title)).append(\", \");\n+    if (dnQualifier != null)\n+      buf.append(DNQ).append(\"=\").append(quote(dnQualifier)).append(\", \");\n+    if (surname != null)\n+      buf.append(NAME).append(\"=\").append(quote(surname)).append(\", \");\n+    if (givenName != null)\n+      buf.append(GIVENNAME).append(\"=\").append(quote(givenName)).append(\", \");\n+    if (initials != null)\n+      buf.append(INITIALS).append(\"=\").append(quote(initials)).append(\", \");\n+    if (generation != null)\n+      buf.append(GENERATION).append(\"=\").append(quote(generation)).append(\", \");\n+    if (email != null)\n+      buf.append(EMAIL).append(\"=\").append(quote(email)).append(\", \");\n+    if (domainComponent != null)\n+      buf.append(DC).append(\"=\").append(quote(domainComponent)).append(\", \");\n+    if (userid != null)\n+      buf.append(UID).append(\"=\").append(quote(userid)).append(\", \");\n+    // XXX escapes\n+    return (nameRFC1779 = buf.substring(0, buf.length()-2));\n+  }\n+\n+  public String toRFC2253()\n+  {\n+    if (nameRFC2253 != null)\n+      return nameRFC2253;\n+    StringBuffer buf = new StringBuffer();\n+    if (commonName != null)\n+      buf.append(\"CN=\").append(quote(commonName)).append(\",\");\n+    if (country != null)\n+      buf.append(\"C=\").append(quote(country)).append(\",\");\n+    if (locality != null)\n+      buf.append(\"L=\").append(quote(locality)).append(\",\");\n+    if (orgUnit != null)\n+      buf.append(\"OU=\").append(quote(orgUnit)).append(\",\");\n+    if (organization != null)\n+      buf.append(\"O=\").append(quote(organization)).append(\",\");\n+    if (street != null)\n+      buf.append(\"STREET=\").append(quote(street)).append(\",\");\n+    if (state != null)\n+      buf.append(\"ST=\").append(quote(state)).append(\",\");\n+    if (title != null)\n+      buf.append(T).append(\"=\").append(quote(title)).append(\",\");\n+    if (dnQualifier != null)\n+      buf.append(DNQ).append(\"=\").append(quote(dnQualifier)).append(\",\");\n+    if (surname != null)\n+      buf.append(NAME).append(\"=\").append(quote(surname)).append(\",\");\n+    if (givenName != null)\n+      buf.append(GIVENNAME).append(\"=\").append(quote(givenName)).append(\",\");\n+    if (initials != null)\n+      buf.append(INITIALS).append(\"=\").append(quote(initials)).append(\",\");\n+    if (generation != null)\n+      buf.append(GENERATION).append(\"=\").append(quote(generation)).append(\",\");\n+    if (email != null)\n+      buf.append(EMAIL).append(\"=\").append(quote(email)).append(\",\");\n+    if (domainComponent != null)\n+      buf.append(DC).append(\"=\").append(quote(domainComponent)).append(\",\");\n+    if (userid != null)\n+      buf.append(UID).append(\"=\").append(quote(userid)).append(\",\");\n+    // XXX escapes.\n+    return (nameRFC2253 = buf.substring(0, buf.length()-1));\n+  }\n+\n+  public String toCanonical()\n+  {\n+    if (nameCanonical != null)\n+      return nameCanonical;\n+    nameCanonical = toRFC2253();\n+    return nameCanonical; // XXX canonicalize\n+  }\n+\n+  public String getCommonName()\n+  {\n+    return commonName;\n+  }\n+\n+  public String getCountry()\n+  {\n+    return country;\n+  }\n+\n+  public String getLocality()\n+  {\n+    return locality;\n+  }\n+\n+  public String getOrganizationalUnit()\n+  {\n+    return orgUnit;\n+  }\n+\n+  public String getOrganization()\n+  {\n+    return organization;\n+  }\n+\n+  public String getStreet()\n+  {\n+    return street;\n+  }\n+\n+  public String getState()\n+  {\n+    return state;\n+  }\n+\n+  public String getTitle()\n+  {\n+    return title;\n+  }\n+\n+  public String getDNQualifier()\n+  {\n+    return dnQualifier;\n+  }\n+\n+  public String getSurname()\n+  {\n+    return surname;\n+  }\n+\n+  public String getGivenName()\n+  {\n+    return givenName;\n+  }\n+\n+  public String getInitials()\n+  {\n+    return initials;\n+  }\n+\n+  public String getGeneration()\n+  {\n+    return generation;\n+  }\n+\n+  public String getEmail()\n+  {\n+    return email;\n+  }\n+\n+  public String getDomain()\n+  {\n+    return domainComponent;\n+  }\n+\n+  public String getUserID()\n+  {\n+    return userid;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private static String unquote(String str)\n+  {\n+    if (str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\"))\n+      str = str.substring(1, str.length()-1);\n+    // XXX needs regex\n+    //return str.replaceAll(\"\\\\([,+\\\"\\\\<>;])\", \"\\1\");\n+    return str;\n+  }\n+\n+  private void parseDN(String name, boolean rfc2253)\n+  {\n+    if (name.length() == 0)\n+      throw new IllegalArgumentException(\"zero-length distinguished name\");\n+    StreamTokenizer parse = new StreamTokenizer(new StringReader(name));\n+    parse.resetSyntax();\n+    parse.wordChars('\\000', '~');\n+    parse.ordinaryChar('#');\n+    parse.ordinaryChar(',');\n+    parse.ordinaryChar('=');\n+    parse.ordinaryChar('<');\n+    parse.ordinaryChar('>');\n+    parse.ordinaryChar(';');\n+    parse.ordinaryChar('\\\\');\n+    parse.quoteChar('\"');\n+    String attrib = null;\n+    String value = null;\n+    int token, lastToken = ',';\n+    while (true)\n+      {\n+        try\n+          {\n+            token = parse.nextToken();\n+          }\n+        catch (IOException ioe)\n+          {\n+            throw new IllegalArgumentException();\n+          }\n+        switch (token)\n+          {\n+            case StreamTokenizer.TT_WORD:\n+              if (lastToken == ',' || lastToken == '+' ||\n+                  (!rfc2253 && lastToken == ';'))\n+                attrib = parse.sval.trim();\n+              else if (lastToken == '=')\n+                value = unquote(parse.sval.trim());\n+              else\n+                throw new IllegalArgumentException();\n+              break;\n+            case '\"':\n+              if (lastToken == '=')\n+                value = parse.sval;\n+              else\n+                throw new IllegalArgumentException();\n+              break;\n+            case ';':\n+              if (rfc2253)\n+                throw new IllegalArgumentException();\n+            case ',':\n+            case '+':\n+              if (attrib == null || value == null)\n+                throw new IllegalArgumentException(\"extraneous separator\");\n+              try\n+                {\n+                  setAttribute(new OID(attrib), value);\n+                }\n+              catch (Exception x)\n+                {\n+                  setAttribute(attrib, value);\n+                }\n+              attrib = null;\n+              value = null;\n+              break;\n+            case '=':\n+              break;\n+            case StreamTokenizer.TT_EOF:\n+              return;\n+            default:\n+              throw new IllegalArgumentException(\"unknown token \" + (char)token\n+                + \" (\" + token + \")\");\n+          }\n+        lastToken = token;\n+      }\n+  }\n+\n+  private void parseDER(InputStream in) throws IOException\n+  {\n+    DERReader der = new DERReader(in);\n+    DERValue name = der.read();\n+    if (!name.isConstructed())\n+      throw new ASN1ParsingException(\"badly formed Name\");\n+    int len = 0;\n+    while (len < name.getLength())\n+      {\n+        DERValue rdn = der.read();\n+        if (rdn.getValue() != DER.CONSTRUCTED_VALUE)\n+          throw new ASN1ParsingException(\"badly formed RDNSequence\");\n+        int len2 = 0;\n+        while (len2 < rdn.getLength())\n+          {\n+            DERValue atav = der.read();\n+            if (atav.getValue() != DER.CONSTRUCTED_VALUE)\n+              throw new ASN1ParsingException(\n+                \"badly formed AttributeTypeAndValue\");\n+            OID atype = (OID) der.read().getValue();\n+            String aval = (String) der.read().getValue();\n+            setAttribute(atype, aval);\n+            len2 += 1 + atav.getLength()\n+                 + DERWriter.definiteEncodingSize(atav.getLength());\n+          }\n+        len += len2 + 1 + DERWriter.definiteEncodingSize(name.getLength());\n+      }\n+  }\n+\n+  private byte[] encodeDER()\n+  {\n+    try\n+      {\n+        LinkedList name = new LinkedList();\n+        if (commonName != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, CN));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, commonName));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (country != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, C));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, country));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (locality != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, L));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, locality));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (orgUnit != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, OU));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, orgUnit));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (organization != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, O));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, organization));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (street != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, STREET));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, street));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (state != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, ST));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, state));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (title != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, T));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, title));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (dnQualifier != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, DNQ));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, dnQualifier));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (surname != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, NAME));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, surname));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (givenName != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, GIVENNAME));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, givenName));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (initials != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, INITIALS));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, initials));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (generation != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, GENERATION));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, generation));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (email != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, EMAIL));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, email));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (domainComponent != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, DC));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, domainComponent));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        if (userid != null)\n+          {\n+            HashSet rdn = new HashSet();\n+            LinkedList atav = new LinkedList();\n+            atav.add(new DERValue(DER.OBJECT_IDENTIFIER, UID));\n+            atav.add(new DERValue(DER.PRINTABLE_STRING, userid));\n+            rdn.add(new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, atav));\n+            name.add(new DERValue(DER.CONSTRUCTED | DER.SET, rdn));\n+          }\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        DERWriter.write(out, new DERValue(DER.CONSTRUCTED|DER.SEQUENCE, name));\n+        return out.toByteArray();\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new Error(ioe);\n+      }\n+  }\n+\n+  private void setAttribute(String atype, String aval)\n+  {\n+    if (atype.equals(\"CN\"))\n+      commonName = aval;\n+    else if (atype.equals(\"C\"))\n+      country = aval;\n+    else if (atype.equals(\"L\"))\n+      locality = aval;\n+    else if (atype.equals(\"ST\"))\n+      state = aval;\n+    else if (atype.equals(\"STREET\"))\n+      street = aval;\n+    else if (atype.equals(\"O\"))\n+      organization = aval;\n+    else if (atype.equals(\"OU\"))\n+      orgUnit = aval;\n+    else if (atype.equals(\"T\"))\n+      title = aval;\n+    else if (atype.equals(\"DNQ\") || atype.equals(\"DNQUALIFIER\"))\n+      dnQualifier = aval;\n+    else if (atype.equals(\"SURNAME\"))\n+      surname = aval;\n+    else if (atype.equals(\"GIVENNAME\"))\n+      givenName = aval;\n+    else if (atype.equals(\"INITIALS\"))\n+      initials = aval;\n+    else if (atype.equals(\"GENERATION\"))\n+      generation = aval;\n+    else if (atype.equals(\"EMAILADDRESS\"))\n+      email = aval;\n+    else if (atype.equals(\"DC\"))\n+      domainComponent = aval;\n+    else if (atype.equals(\"UID\"))\n+      userid = aval;\n+    else\n+      throw new IllegalArgumentException(\"unknown attribute \" + atype);\n+  }\n+\n+  private void setAttribute(OID atype, String aval)\n+  {\n+    if (atype.equals(CN))\n+      commonName = aval;\n+    else if (atype.equals(C))\n+      country = aval;\n+    else if (atype.equals(L))\n+      locality = aval;\n+    else if (atype.equals(ST))\n+      state = aval;\n+    else if (atype.equals(STREET))\n+      street = aval;\n+    else if (atype.equals(O))\n+      organization = aval;\n+    else if (atype.equals(OU))\n+      orgUnit = aval;\n+    else if (atype.equals(T))\n+      title = aval;\n+    else if (atype.equals(DNQ))\n+      dnQualifier = aval;\n+    else if (atype.equals(NAME))\n+      surname = aval;\n+    else if (atype.equals(GIVENNAME))\n+      givenName = aval;\n+    else if (atype.equals(INITIALS))\n+      initials = aval;\n+    else if (atype.equals(GENERATION))\n+      generation = aval;\n+    else if (atype.equals(EMAIL))\n+      email = aval;\n+    else if (atype.equals(DC))\n+      domainComponent = aval;\n+    else if (atype.equals(UID))\n+      userid = aval;\n+    else\n+      throw new IllegalArgumentException(\"unknown attribute \" + atype);\n+  }\n+}"}, {"sha": "6205c0f89558a5067af8ebdd7319048549d4ffc1", "filename": "libjava/gnu/java/security/x509/X509CRL.java", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRL.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,404 @@\n+/* X509CRL.java -- X.509 certificate revocation list.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PublicKey;\n+import java.security.Principal;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CRLException;\n+import java.security.cert.X509CRLEntry;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+/**\n+ * X.509 certificate revocation lists.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class X509CRL extends java.security.cert.X509CRL\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final OID ID_DSA = new OID(\"1.2.840.10040.4.1\");\n+  private static final OID ID_DSA_WITH_SHA1 = new OID(\"1.2.840.10040.4.3\");\n+  private static final OID ID_RSA = new OID(\"1.2.840.113549.1.1.1\");\n+  private static final OID ID_RSA_WITH_MD2 = new OID(\"1.2.840.113549.1.1.2\");\n+  private static final OID ID_RSA_WITH_MD5 = new OID(\"1.2.840.113549.1.1.4\");\n+  private static final OID ID_RSA_WITH_SHA1 = new OID(\"1.2.840.113549.1.1.5\");\n+\n+  private byte[] encoded;\n+\n+  private byte[] tbsCRLBytes;\n+  private int version;\n+  private OID algId;\n+  private byte[] algParams;\n+  private Date thisUpdate;\n+  private Date nextUpdate;\n+  private X500Principal issuerDN;\n+  private HashMap revokedCerts;\n+  private HashMap extensions;\n+  private HashSet critOids;\n+  private HashSet nonCritOids;\n+  \n+  private OID sigAlg;\n+  private byte[] sigAlgParams;\n+  private byte[] rawSig;\n+  private byte[] signature;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new X.509 CRL.\n+   *\n+   * @param encoded The DER encoded CRL.\n+   * @throws CRLException If the input bytes are incorrect.\n+   * @throws IOException  If the input bytes cannot be read.\n+   */\n+  public X509CRL(InputStream encoded) throws CRLException, IOException\n+  {\n+    super();\n+    revokedCerts = new HashMap();\n+    extensions = new HashMap();\n+    critOids = new HashSet();\n+    nonCritOids = new HashSet();\n+    try\n+      {\n+        parse(encoded);\n+      }\n+    catch (IOException ioe)\n+      {\n+        ioe.printStackTrace();\n+        throw ioe;\n+      }\n+    catch (Exception x)\n+      {\n+        x.printStackTrace();\n+        throw new CRLException(x.toString());\n+      }\n+  }\n+\n+  // X509CRL methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean equals(Object o)\n+  {\n+    return ((X509CRL) o).revokedCerts.equals(revokedCerts);\n+  }\n+\n+  public int hashCode()\n+  {\n+    return revokedCerts.hashCode();\n+  }\n+\n+  public byte[] getEncoded() throws CRLException\n+  {\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public void verify(PublicKey key)\n+    throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException\n+  {\n+    Signature sig = Signature.getInstance(sigAlg.toString());\n+    doVerify(sig, key);\n+  }\n+\n+  public void verify(PublicKey key, String provider)\n+    throws CRLException, NoSuchAlgorithmException, InvalidKeyException,\n+           NoSuchProviderException, SignatureException\n+  {\n+    Signature sig = Signature.getInstance(sigAlg.toString(), provider);\n+    doVerify(sig, key);\n+  }\n+\n+  public int getVersion()\n+  {\n+    return version;\n+  }\n+\n+  public Principal getIssuerDN()\n+  {\n+    return issuerDN;\n+  }\n+\n+  public X500Principal getIssuerX500Principal()\n+  {\n+    return issuerDN;\n+  }\n+\n+  public Date getThisUpdate()\n+  {\n+    return (Date) thisUpdate.clone();\n+  }\n+\n+  public Date getNextUpdate()\n+  {\n+    if (nextUpdate != null)\n+      return (Date) nextUpdate.clone();\n+    return null;\n+  }\n+\n+  public X509CRLEntry getRevokedCertificate(BigInteger serialNo)\n+  {\n+    return (X509CRLEntry) revokedCerts.get(serialNo);\n+  }\n+\n+  public Set getRevokedCertificates()\n+  {\n+    return Collections.unmodifiableSet(new HashSet(revokedCerts.values()));\n+  }\n+\n+  public byte[] getTBSCertList() throws CRLException\n+  {\n+    return (byte[]) tbsCRLBytes.clone();\n+  }\n+\n+  public byte[] getSignature()\n+  {\n+    return (byte[]) rawSig.clone();\n+  }\n+\n+  public String getSigAlgName()\n+  {\n+    if (sigAlg.equals(ID_DSA_WITH_SHA1))\n+      return \"SHA1withDSA\";\n+    if (sigAlg.equals(ID_RSA_WITH_MD2))\n+      return \"MD2withRSA\";\n+    if (sigAlg.equals(ID_RSA_WITH_MD5))\n+      return \"MD5withRSA\";\n+    if (sigAlg.equals(ID_RSA_WITH_SHA1))\n+      return \"SHA1withRSA\";\n+    return \"unknown\";\n+  }\n+\n+  public String getSigAlgOID()\n+  {\n+    return sigAlg.toString();\n+  }\n+\n+  public byte[] getSigAlgParams()\n+  {\n+    if (sigAlgParams != null)\n+      return (byte[]) sigAlgParams.clone();\n+    return null;\n+  }\n+\n+  // X509Extension methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean hasUnsupportedCriticalExtension()\n+  {\n+    return false; // XXX\n+  }\n+\n+  public Set getCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(critOids);\n+  }\n+\n+  public Set getNonCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(nonCritOids);\n+  }\n+\n+  public byte[] getExtensionValue(String oid)\n+  {\n+    byte[] ext = (byte[]) extensions.get(oid);\n+    if (ext != null)\n+      return (byte[]) ext.clone();\n+    return null;\n+  }\n+\n+  // CRL methods.\n+  // ------------------------------------------------------------------------\n+\n+  public String toString()\n+  {\n+    return gnu.java.security.x509.X509CRL.class.getName();\n+  }\n+\n+  public boolean isRevoked(Certificate cert)\n+  {\n+    if (!(cert instanceof java.security.cert.X509Certificate))\n+      throw new IllegalArgumentException(\"not a X.509 certificate\");\n+    BigInteger certSerial =\n+      ((java.security.cert.X509Certificate) cert).getSerialNumber();\n+    X509CRLEntry ent = (X509CRLEntry) revokedCerts.get(certSerial);\n+    if (ent == null)\n+      return false;\n+    return ent.getRevocationDate().compareTo(new Date()) < 0;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private void doVerify(Signature sig, PublicKey key)\n+    throws CRLException, InvalidKeyException, SignatureException\n+  {\n+    sig.initVerify(key);\n+    sig.update(tbsCRLBytes);\n+    if (!sig.verify(signature))\n+      throw new CRLException(\"signature not verified\");\n+  }\n+\n+  private void parse(InputStream in) throws Exception\n+  {\n+    DERReader der = new DERReader(in);\n+    DERValue val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed CertificateList\");\n+    encoded = val.getEncoded();\n+\n+    val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed TBSCertList\");\n+    tbsCRLBytes = val.getEncoded();\n+\n+    val = der.read();\n+    if (val.getValue() instanceof BigInteger)\n+      {\n+        version = ((BigInteger) val.getValue()).intValue() + 1;\n+        val = der.read();\n+      }\n+    else\n+      version = 1;\n+\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+    DERValue algIdVal = der.read();\n+    algId = (OID) algIdVal.getValue();\n+    if (val.getLength() > algIdVal.getEncodedLength())\n+      {\n+        val = der.read();\n+        algParams = val.getEncoded();\n+        if (val.isConstructed())\n+          in.skip(val.getLength());\n+      }\n+\n+    issuerDN = new X500Principal(in);\n+\n+    thisUpdate = (Date) der.read().getValue();\n+\n+    val = der.read();\n+    if (val.getValue() instanceof Date)\n+      {\n+        nextUpdate = (Date) val.getValue();\n+        val = der.read();\n+      }\n+    if (val.getTag() != 0)\n+      {\n+        int len = 0;\n+        while (len < val.getLength())\n+          {\n+            X509CRLEntry entry =\n+               new gnu.java.security.x509.X509CRLEntry(version, in);\n+            revokedCerts.put(entry.getSerialNumber(), entry);\n+            len += entry.getEncoded().length;\n+          }\n+      }\n+    if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 0)\n+      {\n+        val = der.read();\n+        int len = 0;\n+        while (len < val.getLength())\n+          {\n+            DERValue ext = der.read();\n+            OID extId = (OID) der.read().getValue();\n+            DERValue val2 = der.read();\n+            Boolean crit = Boolean.valueOf(false);\n+            if (val2.getValue() instanceof Boolean)\n+              {\n+                crit = (Boolean) val2.getValue();\n+                val2 = der.read();\n+              }\n+            byte[] extVal = (byte[]) val2.getValue();\n+            extensions.put(extId.toString(), extVal);\n+            if (crit.booleanValue())\n+              critOids.add(extId.toString());\n+            else\n+              nonCritOids.add(extId.toString());\n+            len += ext.getEncodedLength();\n+          }\n+      }\n+\n+    val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+    DERValue sigAlgVal = der.read();\n+    sigAlg = (OID) sigAlgVal.getValue();\n+    if (val.getLength() > sigAlgVal.getEncodedLength())\n+      {\n+        val = der.read();\n+        sigAlgParams = (byte[]) val.getEncoded();\n+        if (val.isConstructed())\n+          in.skip(val.getLength());\n+      }\n+    val = der.read();\n+    rawSig = val.getEncoded();\n+    signature = ((BitString) val.getValue()).toByteArray();\n+  }\n+}"}, {"sha": "4057c60a22afd6c0753c5883eeddf1768d9cd36e", "filename": "libjava/gnu/java/security/x509/X509CRLEntry.java", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509CRLEntry.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,236 @@\n+/* X509CRLEntry.java -- entry in a X.509 CRL.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import java.math.BigInteger;\n+\n+import java.security.cert.CRLException;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+/**\n+ * A single entry in a X.509 certificate revocation list.\n+ *\n+ * @see X509CRL\n+ * @author Casey Marshall\n+ */\n+class X509CRLEntry extends java.security.cert.X509CRLEntry\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The DER encoded form of this CRL entry. */\n+  private byte[] encoded;\n+\n+  /** The revoked certificate's serial number. */\n+  private BigInteger serialNo;\n+\n+  /** The date the certificate was revoked. */\n+  private Date revocationDate;\n+\n+  /** The encoded extensions. */\n+  private HashMap extensions;\n+\n+  /** The set of critical extension OIDs. */\n+  private HashSet critOids;\n+\n+  /** the set of non-critical extension OIDs. */\n+  private HashSet nonCritOids;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new X.509 certificate revocation list entry from the given\n+   * input stream and CRL version number.\n+   *\n+   * @param version The CRL version.\n+   * @param encoded The stream of DER bytes.\n+   * @throws CRLException If the ASN.1 structure is invalid.\n+   * @throws IOException  If the bytes cannot be read.\n+   */\n+  X509CRLEntry(int version, InputStream encoded)\n+    throws CRLException, IOException\n+  {\n+    super();\n+    extensions = new HashMap();\n+    critOids = new HashSet();\n+    nonCritOids = new HashSet();\n+    try\n+      {\n+        parse(version, encoded);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw ioe;\n+      }\n+    catch (Exception x)\n+      {\n+        throw new CRLException(x.toString());\n+      }\n+  }\n+\n+  // X509CRLEntry methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean equals(Object o)\n+  {\n+    return ((X509CRLEntry) o).serialNo.equals(serialNo) &&\n+           ((X509CRLEntry) o).revocationDate.equals(revocationDate);\n+  }\n+\n+  public int hashCode()\n+  {\n+    return serialNo.hashCode();\n+  }\n+\n+  public byte[] getEncoded() throws CRLException\n+  {\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public BigInteger getSerialNumber()\n+  {\n+    return serialNo;\n+  }\n+\n+  public Date getRevocationDate()\n+  {\n+    return (Date) revocationDate.clone();\n+  }\n+\n+  public boolean hasExtensions()\n+  {\n+    return ! extensions.isEmpty();\n+  }\n+\n+  public String toString()\n+  {\n+    return \"X509CRLEntry serial=\" + serialNo + \" revocation date=\"\n+      + revocationDate + \" critExt=\" + critOids + \" ext=\" + nonCritOids;\n+  }\n+\n+  // X509Extension methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean hasUnsupportedCriticalExtension()\n+  {\n+    return false; // XXX\n+  }\n+\n+  public Set getCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(critOids);\n+  }\n+\n+  public Set getNonCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(nonCritOids);\n+  }\n+\n+  public byte[] getExtensionValue(String oid)\n+  {\n+    byte[] ext = (byte[]) extensions.get(oid);\n+    if (ext != null)\n+      return (byte[]) ext.clone();\n+    return null;\n+  }\n+\n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  private void parse(int version, InputStream in) throws Exception\n+  {\n+    DERReader der = new DERReader(in);\n+    DERValue entry = der.read();\n+    if (!entry.isConstructed())\n+      throw new ASN1ParsingException(\"malformed revokedCertificate\");\n+    encoded = entry.getEncoded();\n+    int len = 0;\n+    DERValue val = der.read();\n+    serialNo = (BigInteger) val.getValue();\n+    len += DERWriter.definiteEncodingSize(val.getLength())\n+         + val.getLength() + 1;\n+    val = der.read();\n+    revocationDate = (Date) val.getValue();\n+    len += DERWriter.definiteEncodingSize(val.getLength())\n+         + val.getLength() + 1;\n+\n+    if (len < entry.getLength())\n+      {\n+        if (version < 2)\n+          throw new ASN1ParsingException(\"extra data in CRL entry\");\n+        while (len < entry.getLength())\n+          {\n+            val = der.read();\n+            if (!val.isConstructed())\n+              throw new ASN1ParsingException(\"malformed Extension\");\n+            OID extOid = (OID) der.read().getValue();\n+            Boolean critical = Boolean.valueOf(false);\n+            DERValue val2 = der.read();\n+            if (val2.getValue() instanceof Boolean)\n+              {\n+                critical = (Boolean) val2.getValue();\n+                val2 = der.read();\n+              }\n+            byte[] ext = (byte[]) val2.getValue();\n+            extensions.put(extOid.toString(), ext);\n+            if (critical.booleanValue())\n+              critOids.add(extOid.toString());\n+            else\n+              nonCritOids.add(extOid.toString());\n+            len += val.getEncodedLength();\n+          }\n+      }\n+  }\n+}"}, {"sha": "bb66f2e67b6719af65e2dcc7cff51c5fa7bc6394", "filename": "libjava/gnu/java/security/x509/X509Certificate.java", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fx509%2FX509Certificate.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,693 @@\n+/* X509Certificate.java -- X.509 certificate.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.security.x509;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import java.math.BigInteger;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+import java.security.Signature;\n+import java.security.SignatureException;\n+\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.CertificateParsingException;\n+\n+import java.security.spec.DSAParameterSpec;\n+import java.security.spec.DSAPublicKeySpec;\n+import java.security.spec.RSAPublicKeySpec;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.BitString;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+/**\n+ * An implementation of X.509 certificates.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class X509Certificate extends java.security.cert.X509Certificate\n+  implements Serializable\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  private static final OID ID_DSA = new OID(\"1.2.840.10040.4.1\");\n+  private static final OID ID_DSA_WITH_SHA1 = new OID(\"1.2.840.10040.4.3\");\n+  private static final OID ID_RSA = new OID(\"1.2.840.113549.1.1.1\");\n+  private static final OID ID_RSA_WITH_MD2 = new OID(\"1.2.840.113549.1.1.2\");\n+  private static final OID ID_RSA_WITH_MD5 = new OID(\"1.2.840.113549.1.1.4\");\n+  private static final OID ID_RSA_WITH_SHA1 = new OID(\"1.2.840.113549.1.1.5\");\n+\n+  private static final OID ID_EXTENSION = new OID(\"2.5.29\");\n+  private static final OID ID_KEY_USAGE = ID_EXTENSION.getChild(15);\n+  private static final OID ID_BASIC_CONSTRAINTS = ID_EXTENSION.getChild(19);\n+  private static final OID ID_EXT_KEY_USAGE = ID_EXTENSION.getChild(37);\n+\n+  private static final int OTHER_NAME     = 0;\n+  private static final int RFC882_NAME    = 1;\n+  private static final int DNS_NAME       = 2;\n+  private static final int X400_ADDRESS   = 3;\n+  private static final int DIRECTORY_NAME = 4;\n+  private static final int EDI_PARTY_NAME = 5;\n+  private static final int URI            = 6;\n+  private static final int IP_ADDRESS     = 7;\n+  private static final int REGISTERED_ID  = 8;\n+\n+  // This object SHOULD be serialized with an instance of\n+  // java.security.cert.Certificate.CertificateRep, thus all fields are\n+  // transient.\n+\n+  // The encoded certificate.\n+  private transient byte[] encoded;\n+\n+  // TBSCertificate part.\n+  private transient byte[] tbsCertBytes;\n+  private transient int version;\n+  private transient BigInteger serialNo;\n+  private transient OID algId;\n+  private transient byte[] algVal;\n+  private transient X500Principal issuer;\n+  private transient Date notBefore;\n+  private transient Date notAfter;\n+  private transient X500Principal subject;\n+  private transient PublicKey subjectKey;\n+  private transient BitString issuerUniqueId;\n+  private transient BitString subjectUniqueId;\n+  private transient HashMap extensions;\n+  private transient HashSet critOids;\n+  private transient HashSet nonCritOids;\n+  \n+  private transient BitString keyUsage;\n+  private transient int basicConstraints = -1;\n+\n+  // Signature.\n+  private transient OID sigAlgId;\n+  private transient byte[] sigAlgVal;\n+  private transient byte[] signature;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new X.509 certificate from the encoded data. The input\n+   * data are expected to be the ASN.1 DER encoding of the certificate.\n+   *\n+   * @param encoded The encoded certificate data.\n+   * @throws IOException If the certificate cannot be read, possibly\n+   * from a formatting error.\n+   * @throws CertificateException If the data read is not an X.509\n+   * certificate.\n+   */\n+  public X509Certificate(InputStream encoded)\n+    throws CertificateException, IOException\n+  {\n+    super();\n+    extensions = new HashMap();\n+    critOids = new HashSet();\n+    nonCritOids = new HashSet();\n+    try\n+      {\n+        parse(encoded);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw ioe;\n+      }\n+    catch (Exception e)\n+      {\n+        throw new CertificateException(e.toString());\n+      }\n+  }\n+\n+  // X509Certificate methods.\n+  // ------------------------------------------------------------------------\n+\n+  public void checkValidity()\n+    throws CertificateExpiredException, CertificateNotYetValidException\n+  {\n+    checkValidity(new Date());\n+  }\n+\n+  public void checkValidity(Date date)\n+    throws CertificateExpiredException, CertificateNotYetValidException\n+  {\n+    if (date.compareTo(notBefore) < 0)\n+      throw new CertificateNotYetValidException();\n+    if (date.compareTo(notAfter) > 0)\n+      throw new CertificateExpiredException();\n+  }\n+\n+  public int getVersion()\n+  {\n+    return version;\n+  }\n+\n+  public BigInteger getSerialNumber()\n+  {\n+    return serialNo;\n+  }\n+\n+  public Principal getIssuerDN()\n+  {\n+    return getIssuerX500Principal();\n+  }\n+\n+  public X500Principal getIssuerX500Principal()\n+  {\n+    return issuer;\n+  }\n+\n+  public Principal getSubjectDN()\n+  {\n+    return getSubjectX500Principal();\n+  }\n+\n+  public X500Principal getSubjectX500Principal()\n+  {\n+    return subject;\n+  }\n+\n+  public Date getNotBefore()\n+  {\n+    return (Date) notBefore.clone();\n+  }\n+\n+  public Date getNotAfter()\n+  {\n+    return (Date) notAfter.clone();\n+  }\n+\n+  public byte[] getTBSCertificate() throws CertificateEncodingException\n+  {\n+    return (byte[]) tbsCertBytes.clone();\n+  }\n+\n+  public byte[] getSignature()\n+  {\n+    return (byte[]) signature.clone();\n+  }\n+\n+  public String getSigAlgName()\n+  {\n+    if (sigAlgId.equals(ID_DSA_WITH_SHA1))\n+      return \"SHA1withDSA\";\n+    if (sigAlgId.equals(ID_RSA_WITH_MD2 ))\n+      return \"MD2withRSA\";\n+    if (sigAlgId.equals(ID_RSA_WITH_MD5 ))\n+      return \"MD5withRSA\";\n+    if (sigAlgId.equals(ID_RSA_WITH_SHA1 ))\n+      return \"SHA1withRSA\";\n+    return \"unknown\";\n+    // return sigAlgId.getShortName();\n+  }\n+\n+  public String getSigAlgOID()\n+  {\n+    return sigAlgId.toString();\n+  }\n+\n+  public byte[] getSigAlgParams()\n+  {\n+    return (byte[]) sigAlgVal.clone();\n+  }\n+\n+  public boolean[] getIssuerUniqueID()\n+  {\n+    if (issuerUniqueId != null)\n+      return issuerUniqueId.toBooleanArray();\n+    return null;\n+  }\n+\n+  public boolean[] getSubjectUniqueID()\n+  {\n+    if (subjectUniqueId != null)\n+      return subjectUniqueId.toBooleanArray();\n+    return null;\n+  }\n+\n+  public boolean[] getKeyUsage()\n+  {\n+    if (keyUsage != null)\n+      return keyUsage.toBooleanArray();\n+    return null;\n+  }\n+\n+  public List getExtendedKeyUsage() throws CertificateParsingException\n+  {\n+    byte[] ext = (byte[]) extensions.get(\"2.5.29.37\");\n+    if (ext == null)\n+      return null;\n+    LinkedList usages = new LinkedList();\n+    try\n+      {\n+        DERReader der = new DERReader(new ByteArrayInputStream(ext));\n+        DERValue seq = der.read();\n+        if (!seq.isConstructed())\n+          throw new CertificateParsingException();\n+        int len = 0;\n+        while (len < seq.getLength())\n+          {\n+            DERValue oid = der.read();\n+            if (!(oid.getValue() instanceof OID))\n+              throw new CertificateParsingException();\n+            usages.add(oid.getValue().toString());\n+            len += DERWriter.definiteEncodingSize(oid.getLength())\n+                 + oid.getLength() + 1;\n+          }\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new CertificateParsingException();\n+      }\n+    return usages;\n+  }\n+\n+  public int getBasicConstraints()\n+  {\n+    return basicConstraints;\n+  }\n+\n+  public Collection getSubjectAlternativeNames()\n+    throws CertificateParsingException\n+  {\n+    byte[] ext = getExtensionValue(\"2.5.29.17\");\n+    if (ext == null)\n+      return null;\n+    return getAltNames(ext);\n+  }\n+\n+  public Collection getIssuerAlternativeNames()\n+    throws CertificateParsingException\n+  {\n+    byte[] ext = getExtensionValue(\"2.5.29.18\");\n+    if (ext == null)\n+      return null;\n+    return getAltNames(ext);\n+  }\n+\n+\f// X509Extension methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean hasUnsupportedCriticalExtension()\n+  {\n+    for (Iterator it = critOids.iterator(); it.hasNext(); )\n+      {\n+        String oid = (String) it.next();\n+        if (!oid.equals(\"2.5.29.15\") && !oid.equals(\"2.5.29.17\") &&\n+            !oid.equals(\"2.5.29.18\") && !oid.equals(\"2.5.29.19\") &&\n+            !oid.equals(\"2.5.29.37\"))\n+          return true;\n+      }\n+    return false;\n+  }\n+\n+  public Set getCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(critOids);\n+  }\n+\n+  public Set getNonCriticalExtensionOIDs()\n+  {\n+    return Collections.unmodifiableSet(nonCritOids);\n+  }\n+\n+  public byte[] getExtensionValue(String oid)\n+  {\n+    byte[] ext = (byte[]) extensions.get(oid);\n+    if (ext != null)\n+      return (byte[]) ext.clone();\n+    return null;\n+  }\n+\n+  // Certificate methods.\n+  // ------------------------------------------------------------------------\n+\n+  public byte[] getEncoded() throws CertificateEncodingException\n+  {\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  public void verify(PublicKey key)\n+    throws CertificateException, NoSuchAlgorithmException, \n+           InvalidKeyException, NoSuchProviderException, SignatureException\n+  {\n+    Signature sig = Signature.getInstance(sigAlgId.toString());\n+    doVerify(sig, key);\n+  }\n+\n+  public void verify(PublicKey key, String provider)\n+    throws CertificateException, NoSuchAlgorithmException,\n+           InvalidKeyException, NoSuchProviderException, SignatureException\n+  {\n+    Signature sig = Signature.getInstance(sigAlgId.toString(), provider);\n+    doVerify(sig, key);\n+  }\n+\n+  public String toString()\n+  {\n+    // XXX say more than this.\n+    return gnu.java.security.x509.X509Certificate.class.getName();\n+  }\n+\n+  public PublicKey getPublicKey()\n+  {\n+    return subjectKey;\n+  }\n+\n+  public Object writeReplace() throws java.io.ObjectStreamException\n+  {\n+    return super.writeReplace();\n+  }\n+  \n+  // Own methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Verify this certificate's signature.\n+   */\n+  private void doVerify(Signature sig, PublicKey key)\n+    throws CertificateException, InvalidKeyException, SignatureException\n+  {\n+    sig.initVerify(key);\n+    sig.update(tbsCertBytes);\n+    if (!sig.verify(signature))\n+      throw new CertificateException(\"signature not validated\");\n+  }\n+\n+  /**\n+   * Read a GeneralNames structure.\n+   */\n+  private List getAltNames(byte[] encoded)\n+    throws CertificateParsingException\n+  {\n+    LinkedList names = new LinkedList();\n+    try\n+      {\n+        ByteArrayInputStream in = new ByteArrayInputStream(encoded);\n+        DERReader der = new DERReader(in);\n+        DERValue seq = der.read();\n+        if (!seq.isConstructed())\n+          throw new CertificateParsingException();\n+        int len = 0;\n+        while (len < seq.getLength())\n+          {\n+            DERValue name = der.read();\n+            ArrayList pair = new ArrayList(2);\n+            Object nameVal = null;\n+            switch (name.getTag())\n+              {\n+                case RFC882_NAME:\n+                case DNS_NAME:\n+                case URI:\n+                  nameVal = new String((byte[]) name.getValue());\n+                  break;\n+                case IP_ADDRESS:\n+                  nameVal = java.net.InetAddress.getByAddress(\n+                    (byte[]) name.getValue()).getHostAddress();\n+                  break;\n+                case REGISTERED_ID:\n+                  nameVal = new OID((byte[]) name.getValue());\n+                  break;\n+                case OTHER_NAME:\n+                case X400_ADDRESS:\n+                case DIRECTORY_NAME:\n+                case EDI_PARTY_NAME:\n+                  nameVal = name.getEncoded();\n+                  break;\n+                default:\n+                  throw new CertificateParsingException();\n+              }\n+            pair.add(new Integer(name.getTag()));\n+            pair.add(nameVal);\n+            names.add(pair);\n+            if (name.isConstructed())\n+              in.skip(name.getLength());\n+            len += name.getEncodedLength();\n+          }\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new CertificateParsingException(ioe.toString());\n+      }\n+    return Collections.unmodifiableList(names);\n+  }\n+\n+  /**\n+   * Parse a DER stream into an X.509 certificate.\n+   *\n+   * @param encoded The encoded bytes.\n+   */\n+  private void parse(InputStream encoded) throws Exception\n+  {\n+    DERReader der = new DERReader(encoded);\n+\n+    // Certificate ::= SEQUENCE {\n+    DERValue cert = der.read();\n+    this.encoded = cert.getEncoded();\n+    if (!cert.isConstructed())\n+      throw new ASN1ParsingException(\"malformed Certificate\");\n+\n+    // TBSCertificate ::= SEQUENCE {\n+    DERValue tbsCert = der.read();\n+    if (tbsCert.getValue() != DER.CONSTRUCTED_VALUE)\n+      throw new ASN1ParsingException(\"malformed TBSCertificate\");\n+    tbsCertBytes = tbsCert.getEncoded();\n+\n+    DERValue val = der.read();\n+    if (val.getTagClass() == DER.CONTEXT && val.getTag() == 0)\n+      {\n+        // Version ::= INTEGER [0] { v1(0), v2(1), v3(2) }\n+        version = ((BigInteger) der.read().getValue()).intValue() + 1;\n+        val = der.read();\n+      }\n+    else\n+      {\n+        version = 1;\n+      }\n+    // SerialNumber ::= INTEGER\n+    serialNo = (BigInteger) val.getValue();\n+\n+    // AlgorithmIdentifier ::= SEQUENCE {\n+    val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+    int certAlgLen = val.getLength();\n+    val = der.read();\n+    algId = (OID) val.getValue();\n+    if (certAlgLen > val.getEncodedLength())\n+      {\n+        val = der.read();\n+        if (val == null)\n+          algVal = null;\n+        else\n+          algVal = val.getEncoded();\n+        if (val.isConstructed())\n+          encoded.skip(val.getLength());\n+      }\n+\n+    issuer = new X500Principal(encoded);\n+\n+    if (!der.read().isConstructed())\n+      throw new ASN1ParsingException(\"malformed Validity\");\n+    notBefore = (Date) der.read().getValue();\n+    notAfter  = (Date) der.read().getValue();\n+\n+    subject = new X500Principal(encoded);\n+\n+    if (!der.read().isConstructed())\n+      throw new ASN1ParsingException(\"malformed SubjectPublicKeyInfo\");\n+   \n+    val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+    int keyAlgLen = val.getLength();\n+    val = der.read();\n+    OID keyID = (OID) val.getValue();\n+    byte[] keyParams = null;\n+    if (keyAlgLen > val.getEncodedLength())\n+      {\n+        val = der.read();\n+        keyParams = val.getEncoded();\n+        if (algVal == null)\n+          algVal = keyParams;\n+        if (val.isConstructed())\n+          encoded.skip(val.getLength());\n+      }\n+    val = der.read();\n+    byte[] keyVal = ((BitString) val.getValue()).toByteArray();\n+\n+    if (keyID.equals(ID_DSA))\n+      {\n+        AlgorithmParameters params = AlgorithmParameters.getInstance(\"DSA\");\n+        params.init(keyParams, \"ASN.1\");\n+        KeyFactory keyFac = KeyFactory.getInstance(\"DSA\");\n+        DSAParameterSpec spec = (DSAParameterSpec)\n+          params.getParameterSpec(DSAParameterSpec.class);\n+        subjectKey = keyFac.generatePublic(new DSAPublicKeySpec(\n+          (BigInteger) new DERReader(keyVal).read().getValue(),\n+          spec.getP(), spec.getQ(), spec.getG()));\n+      }\n+    else if (keyID.equals(ID_RSA))\n+      {\n+        KeyFactory keyFac = KeyFactory.getInstance(\"RSA\");\n+        DERReader rsaKey = new DERReader(keyVal);\n+        if (!rsaKey.read().isConstructed())\n+          throw new ASN1ParsingException(\"malformed RSAPublicKey\");\n+        subjectKey = keyFac.generatePublic(new RSAPublicKeySpec(\n+          (BigInteger) rsaKey.read().getValue(),\n+          (BigInteger) rsaKey.read().getValue()));\n+      }\n+    else\n+      throw new ASN1ParsingException(\"unknown key algorithm \" + keyID);\n+\n+    if (version > 1)\n+      val = der.read();\n+    if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 1)\n+      {\n+        byte[] b = (byte[]) val.getValue();\n+        issuerUniqueId = new BitString(b, 1, b.length-1, b[0] & 0xFF);\n+        val = der.read();\n+      }\n+    if (version >= 2 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 2)\n+      {\n+        byte[] b = (byte[]) val.getValue();\n+        subjectUniqueId = new BitString(b, 1, b.length-1, b[0] & 0xFF);\n+        val = der.read();\n+      }\n+    if (version >= 3 && val.getTagClass() != DER.UNIVERSAL && val.getTag() == 3)\n+      {\n+        val = der.read();\n+        int len = 0;\n+        while (len < val.getLength())\n+          {\n+            DERValue ext = der.read();\n+            OID extId = (OID) der.read().getValue();\n+            DERValue val2 = der.read();\n+            Boolean crit = Boolean.valueOf(false);\n+            if (val2.getValue() instanceof Boolean)\n+              {\n+                crit = (Boolean) val2.getValue();\n+                val2 = der.read();\n+              }\n+            byte[] extVal = (byte[]) val2.getValue();\n+            extensions.put(extId.toString(), extVal);\n+            if (crit.booleanValue())\n+              critOids.add(extId.toString());\n+            else\n+              nonCritOids.add(extId.toString());\n+            if (extId.equals(ID_KEY_USAGE))\n+              {\n+                keyUsage = (BitString) DERReader.read(extVal).getValue();\n+              }\n+            else if (extId.equals(ID_BASIC_CONSTRAINTS))\n+              {\n+                DERReader bc = new DERReader(extVal);\n+                DERValue constraints = bc.read();\n+                if (!constraints.isConstructed())\n+                  throw new ASN1ParsingException(\"malformed BasicConstraints\");\n+                if (constraints.getLength() > 0)\n+                  {\n+                    boolean ca = false;\n+                    int constr = -1;\n+                    val2 = bc.read();\n+                    if (val2.getValue() instanceof Boolean)\n+                      {\n+                        ca = ((Boolean) val2.getValue()).booleanValue();\n+                        if (constraints.getLength() > val2.getEncodedLength())\n+                          val2 = bc.read();\n+                      }\n+                    if (val2.getValue() instanceof BigInteger)\n+                      constr = ((BigInteger) val2.getValue()).intValue();\n+                    basicConstraints = constr;\n+                  }\n+              }\n+            len += ext.getEncodedLength();\n+          }\n+      }\n+\n+    val = der.read();\n+    if (!val.isConstructed())\n+      throw new ASN1ParsingException(\"malformed AlgorithmIdentifier\");\n+    int sigAlgLen = val.getLength();\n+    val = der.read();\n+    sigAlgId = (OID) val.getValue();\n+    if (sigAlgLen > val.getEncodedLength())\n+      {\n+        val = der.read();\n+        if (val.getValue() == null)\n+          sigAlgVal = keyParams;\n+        else\n+          sigAlgVal = (byte[]) val.getEncoded();\n+        if (val.isConstructed())\n+          encoded.skip(val.getLength());\n+      }\n+    signature = ((BitString) der.read().getValue()).toByteArray();\n+  }\n+}"}, {"sha": "26a7790d37a18eb6d4228d20d4de4ec4aac4aeb4", "filename": "libjava/java/security/AlgorithmParameterGenerator.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAlgorithmParameterGenerator.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -39,6 +39,8 @@\n \n import java.security.spec.AlgorithmParameterSpec;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>The <code>AlgorithmParameterGenerator</code> class is used to generate a\n  * set of parameters to be used with a certain algorithm. Parameter generators\n@@ -201,7 +203,11 @@ public static AlgorithmParameterGenerator getInstance(String algorithm,\n \t  (AlgorithmParameterGeneratorSpi) Engine.getInstance(\n \t    ALGORITHM_PARAMETER_GENERATOR, algorithm, provider),\n \t  provider, algorithm);\n-        }\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n     catch (ClassCastException cce)\n       {\n \tthrow new NoSuchAlgorithmException(algorithm);"}, {"sha": "07d76bb7bab0b1a57b573f07b62076279194b57c", "filename": "libjava/java/security/AlgorithmParameters.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAlgorithmParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -41,6 +41,8 @@\n import java.security.spec.AlgorithmParameterSpec;\n import java.io.IOException;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>This class is used as an opaque representation of cryptographic\n  * parameters.</p>\n@@ -204,6 +206,10 @@ public static AlgorithmParameters getInstance(String algorithm,\n \t  Engine.getInstance(ALGORITHM_PARAMETERS, algorithm, provider),\n \t  provider, algorithm);\n       }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n     catch (ClassCastException cce)\n       {\n \tthrow new NoSuchAlgorithmException(algorithm);"}, {"sha": "223d0d84af3ad24c089a1a0f4093b8b13ada63dd", "filename": "libjava/java/security/KeyFactory.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyFactory.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -41,6 +41,8 @@\n import java.security.spec.InvalidKeySpecException;\n import java.security.NoSuchAlgorithmException;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>Key factories are used to convert keys (opaque cryptographic keys of type\n  * {@link Key}) into key specifications (transparent representations of the\n@@ -192,6 +194,10 @@ public static KeyFactory getInstance(String algorithm, Provider provider)\n \t  Engine.getInstance(KEY_FACTORY, algorithm, provider),\n           provider, algorithm);\n       }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n     catch (ClassCastException cce)\n       {\n \tthrow new NoSuchAlgorithmException(algorithm);"}, {"sha": "b9b07852aa426bb454a152b79a457a36f5f4bb29", "filename": "libjava/java/security/KeyPairGenerator.java", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -39,6 +39,8 @@\n \n import java.security.spec.AlgorithmParameterSpec;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>The <code>KeyPairGenerator</code> class is used to generate pairs of\n  * public and private keys. Key pair generators are constructed using the\n@@ -231,7 +233,16 @@ public static KeyPairGenerator getInstance(String algorithm,\n     if (provider == null)\n       throw new IllegalArgumentException(\"Illegal provider\");\n \n-    Object o = Engine.getInstance(KEY_PAIR_GENERATOR, algorithm, provider);\n+    Object o = null;\n+    try\n+      {\n+        o = Engine.getInstance(KEY_PAIR_GENERATOR, algorithm, provider);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n+\n     KeyPairGenerator result = null;\n     if (o instanceof KeyPairGeneratorSpi)\n       {"}, {"sha": "5f0c159d7d255eda81f54fb8b513183347b65d44", "filename": "libjava/java/security/KeyStore.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyStore.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FKeyStore.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyStore.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -43,6 +43,8 @@\n import java.util.Date;\n import java.util.Enumeration;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * Keystore represents an in-memory collection of keys and \n  * certificates. There are two types of entries:\n@@ -194,6 +196,10 @@ public static KeyStore getInstance(String type, Provider provider)\n       {\n         throw new KeyStoreException(type);\n       }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new KeyStoreException(type);\n+      }\n     catch (ClassCastException cce)\n       {\n         throw new KeyStoreException(type);"}, {"sha": "47b082a19f401a03e28dab2a408678412729ecb4", "filename": "libjava/java/security/MessageDigest.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FMessageDigest.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -37,6 +37,8 @@\n \n package java.security;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>This <code>MessageDigest</code> class provides applications the\n  * functionality of a message digest algorithm, such as <i>MD5</i> or <i>SHA</i>.\n@@ -197,7 +199,15 @@ public static MessageDigest getInstance(String algorithm, Provider provider)\n       throw new IllegalArgumentException(\"Illegal provider\");\n \n     MessageDigest result = null;\n-    Object o = Engine.getInstance(MESSAGE_DIGEST, algorithm, provider);\n+    Object o = null;\n+    try\n+      {\n+        o = Engine.getInstance(MESSAGE_DIGEST, algorithm, provider);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n      \n     if (o instanceof MessageDigestSpi)\n       {"}, {"sha": "5f7ac211bf07a23cb2323e1ace03d87a6fc6a64e", "filename": "libjava/java/security/SecureClassLoader.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -93,7 +93,7 @@ protected final Class defineClass(String name, byte[] b, int off, int len,\n \n   /**\n      Returns a PermissionCollection for the specified CodeSource.\n-     The default implmentation invokes \n+     The default implementation invokes \n      java.security.Policy.getPermissions.\n \n      This method is called by defineClass that takes a CodeSource"}, {"sha": "022d014cf1c19941af91e50054b83206691ca483", "filename": "libjava/java/security/SecureRandom.java", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecureRandom.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecureRandom.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecureRandom.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,4 +1,4 @@\n-/* SecureRandom.java --- Secure Random class implmentation\n+/* SecureRandom.java --- Secure Random class implementation\n    Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -41,6 +41,8 @@\n import java.util.Random;\n import java.util.Enumeration;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * An interface to a cryptographically secure pseudo-random number\n  * generator (PRNG). Random (or at least unguessable) numbers are used\n@@ -162,7 +164,7 @@ protected SecureRandom(SecureRandomSpi secureRandomSpi, Provider provider)\n    * the first provider that implements it.\n    *\n    * @param algorithm The algorithm name.\n-   * @return A new SecureRandom implmenting the given algorithm.\n+   * @return A new SecureRandom implementing the given algorithm.\n    * @throws NoSuchAlgorithmException If no installed provider implements\n    *         the given algorithm.\n    */\n@@ -191,7 +193,7 @@ public static SecureRandom getInstance(String algorithm) throws\n    *\n    * @param algorithm The algorithm name.\n    * @param provider  The provider name.\n-   * @return A new SecureRandom implmenting the chosen algorithm.\n+   * @return A new SecureRandom implementing the chosen algorithm.\n    * @throws NoSuchAlgorithmException If the named provider does not implement\n    *         the algorithm, or if the implementation cannot be\n    *         instantiated.\n@@ -234,6 +236,10 @@ public static SecureRandom getInstance(String algorithm, Provider provider)\n           Engine.getInstance(SECURE_RANDOM, algorithm, provider),\n           provider);\n       }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+\tthrow new NoSuchAlgorithmException(algorithm);\n+      }\n     catch (ClassCastException cce)\n       {\n         throw new NoSuchAlgorithmException(algorithm);"}, {"sha": "0f1827ea02c0b02da3e0727d6ae3ecb84abe5cfa", "filename": "libjava/java/security/Security.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecurity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSecurity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecurity.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,4 +1,4 @@\n-/* Security.java --- Java base security class implmentation\n+/* Security.java --- Java base security class implementation\n    Copyright (C) 1999, 2001, 2002, 2003, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath."}, {"sha": "1e99a7bb3e0552aba0800e111b39ec011f82ff72", "filename": "libjava/java/security/Signature.java", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2FSignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSignature.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -41,6 +41,8 @@\n import java.security.cert.X509Certificate;\n import java.security.spec.AlgorithmParameterSpec;\n \n+import gnu.java.security.Engine;\n+\n /**\n  * <p>This <code>Signature</code> class is used to provide applications the\n  * functionality of a digital signature algorithm. Digital signatures are used\n@@ -237,7 +239,15 @@ public static Signature getInstance(String algorithm, Provider provider)\n       throw new IllegalArgumentException(\"Illegal provider\");\n \n     Signature result = null;\n-    Object o = Engine.getInstance(SIGNATURE, algorithm, provider);\n+    Object o = null;\n+    try\n+      {\n+        o = Engine.getInstance(SIGNATURE, algorithm, provider);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n \n     if (o instanceof SignatureSpi)\n       {"}, {"sha": "7bfce306b9cf4ec1594044f4d57c14e731db7b82", "filename": "libjava/java/security/cert/CRLSelector.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLSelector.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,69 @@\n+/* CRLSelector.java -- matches CRLs against criteria.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * A generic interface to classes that match certificate revocation\n+ * lists (CRLs) to some given criteria. Implementations of this\n+ * interface are useful for finding {@link CRL} objects in a {@link\n+ * CertStore}.\n+ *\n+ * @see CertStore\n+ * @see CertSelector\n+ * @see X509CRLSelector\n+ */\n+public interface CRLSelector extends Cloneable\n+{\n+\n+  /**\n+   * Returns a clone of this instance.\n+   *\n+   * @return The clone.\n+   */\n+  Object clone();\n+\n+  /**\n+   * Match a given certificate revocation list to this selector's\n+   * criteria, returning true if it matches, false otherwise.\n+   *\n+   * @param crl The certificate revocation list to test.\n+   * @return The boolean result of this test.\n+   */\n+  boolean match(CRL crl);\n+}"}, {"sha": "af935369074c964e9bed72a32b82917e14056cd1", "filename": "libjava/java/security/cert/CertPathBuilder.java", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilder.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,237 @@\n+/* CertPathBuilder.java -- bulids CertPath objects from Certificates.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * This class builds certificate paths (also called certificate chains),\n+ * which can be used to establish trust for a particular certificate by\n+ * building a path from a trusted certificate (a trust anchor) to the\n+ * untrusted certificate.\n+ *\n+ * @see CertPath\n+ */\n+public class CertPathBuilder\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Service name for CertPathBuilder. */\n+  private static final String CERT_PATH_BUILDER = \"CertPathBuilder\";\n+\n+  /** The underlying implementation. */\n+  private CertPathBuilderSpi cpbSpi;\n+\n+  /** The provider of this implementation. */\n+  private Provider provider;\n+\n+  /** The name of this implementation. */\n+  private String algorithm;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CertPathBuilder.\n+   *\n+   * @param cpbSpi    The underlying implementation.\n+   * @param provider  The provider of the implementation.\n+   * @param algorithm This implementation's name.\n+   */\n+  protected CertPathBuilder(CertPathBuilderSpi cpbSpi, Provider provider,\n+                            String algorithm)\n+  {\n+    this.cpbSpi = cpbSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the default cert path builder type.\n+   *\n+   * <p>This value can be set at run-time by the security property\n+   * <code>\"certpathbuilder.type\"</code>. If this property is not set,\n+   * then the value returned is <code>\"PKIX\"</code>.\n+   *\n+   * @return The default CertPathBuilder algorithm.\n+   */\n+  public static final String getDefaultType()\n+  {\n+    String type = Security.getProperty(\"certpathbuilder.type\");\n+    if (type == null)\n+      type = \"PKIX\";\n+    return type;\n+  }\n+\n+  /**\n+   * Get an instance of a named CertPathBuilder, from the first provider\n+   * that implements it.\n+   *\n+   * @param algorithm The name of the CertPathBuilder to create.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If no installed provider\n+   *   implements the named algorithm.\n+   */\n+  public static CertPathBuilder getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] p = Security.getProviders();\n+\n+    for (int i = 0; i < p.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, p[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignored)\n+          {\n+          }\n+      }\n+\n+    throw new NoSuchAlgorithmException(algorithm);\n+  }\n+\n+  /**\n+   * Get an instance of a named CertPathBuilder from the named\n+   * provider.\n+   *\n+   * @param algorithm The name of the CertPathBuilder to create.\n+   * @param provider  The name of the provider from which to get the\n+   *   implementation.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If no installed provider\n+   *   implements the named algorithm.\n+   * @throws NoSuchProviderException If the named provider does not\n+   *   exist.\n+   */\n+  public static CertPathBuilder getInstance(String algorithm, String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      throw new NoSuchProviderException(provider);\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Get an instance of a named CertPathBuilder from the specified\n+   * provider.\n+   *\n+   * @param algorithm The name of the CertPathBuilder to create.\n+   * @param provider  The provider from which to get the implementation.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If no installed provider\n+   *   implements the named algorithm.\n+   * @throws IllegalArgumentException If <i>provider</i> in\n+   *   <tt>null</tt>.\n+   */\n+  public static CertPathBuilder getInstance(String algorithm, Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"null provider\");\n+    try\n+      {\n+        return new CertPathBuilder((CertPathBuilderSpi)\n+          Engine.getInstance(CERT_PATH_BUILDER, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the name of this CertPathBuilder algorithm.\n+   *\n+   * @return The algorithm name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Return the provider of this instance's implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Builds a certificate path. The {@link CertPathParameters} parameter\n+   * passed to this method is implementation-specific, but in general\n+   * should contain some number of certificates and some number of\n+   * trusted certificates (or \"trust anchors\").\n+   *\n+   * @param params The parameters.\n+   * @retrun The certificate path result.\n+   * @throws CertPathBuilderException If the certificate path cannot be\n+   *   built.\n+   * @throws InvalidAlgorithmParameterException If the implementation\n+   *   rejects the specified parameters.\n+   */\n+  public final CertPathBuilderResult build(CertPathParameters params)\n+    throws CertPathBuilderException, InvalidAlgorithmParameterException\n+  {\n+    return cpbSpi.engineBuild(params);\n+  }\n+}"}, {"sha": "e5b2c6dbc0e26fc65c9aac7477355634502d0f27", "filename": "libjava/java/security/cert/CertPathBuilderResult.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderResult.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderResult.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderResult.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,63 @@\n+/* CertPathBuilderResult -- results from building cert paths.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * A standard interface for the result of building a certificate path.\n+ * All implementations of this class must provide a way to get the\n+ * certificate path, but may also define additional methods for\n+ * returning other result data generated by the certificate path\n+ * builder.\n+ */\n+public interface CertPathBuilderResult extends Cloneable {\n+\n+\t/**\n+   * Creates a copy of this builder result.\n+   *\n+   * @return The copy.\n+   */\n+\tObject clone();\n+\n+  /**\n+   * Get the certificate path that was built.\n+   *\n+   * @retrn The certificate path.\n+   */\n+\tCertPath getCertPath();\n+}"}, {"sha": "9220f5a4e3f61ff520de01c8dd508aef6c511d76", "filename": "libjava/java/security/cert/CertPathBuilderSpi.java", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathBuilderSpi.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,74 @@\n+/* CertPathBuilderSpi -- CertPathBuilder service provider interface.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.cert;\n+\n+/**\n+ * The {@link CertPathBuilder} <i>Service Provider Interface</i>\n+ * (<b>SPI</b>).\n+ *\n+ * @see CertPathBuilder\n+ */\n+public abstract class CertPathBuilderSpi {\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CertPathBuilderSpi.\n+   */\n+  public CertPathBuilderSpi() {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a certificate path from the specified parameters.\n+   *\n+   * @param params The parameters to use.\n+   * @return The certificate path result.\n+   * @throws CertPathBuilderException If the certificate path cannot be\n+   *   built.\n+   * @throws java.security.InvalidAlgorithmParameterException If the\n+   *   implementation rejects the specified parameters.\n+   */\n+  public abstract CertPathBuilderResult engineBuild(CertPathParameters params)\n+  throws CertPathBuilderException,\n+         java.security.InvalidAlgorithmParameterException;\n+}"}, {"sha": "5cc678bdc0511bbca37af35addd2270c3be8f5ca", "filename": "libjava/java/security/cert/CertPathParameters.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,58 @@\n+/* CertPathParameters.java -- parameters for CertPathBuilder.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.security.cert;\n+\n+/**\n+ * Parameters for generating and validating certificate paths. This\n+ * class does not define any methods (except a required cloneable\n+ * interface) and is provided only to provide type safety for\n+ * implementations. Concrete implementations implement this interface\n+ * in accord with thier own needs.\n+ *\n+ * @see CertPathBuilder\n+ * @see CertPathValidator\n+ */\n+public interface CertPathParameters extends Cloneable {\n+\n+   /**\n+    * Makes a copy of this CertPathParameters instance.\n+    *\n+    * @return The copy.\n+    */\n+   Object clone();\n+}"}, {"sha": "4c1262d379bebc19d8c763c6bb76d3f8a3beefd7", "filename": "libjava/java/security/cert/CertPathValidator.java", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidator.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,248 @@\n+/* CertPathValidator -- validates certificate paths.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.AccessController;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivilegedAction;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * Generic interface to classes that validate certificate paths.\n+ *\n+ * <p>Using this class is similar to all the provider-based security\n+ * classes; the method of interest, {@link\n+ * #validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)},\n+ * which takes provider-specific implementations of {@link\n+ * CertPathParameters}, and return provider-specific implementations of\n+ * {@link CertPathValidatorResult}.\n+ *\n+ * @since JDK 1.4\n+ * @see CertPath\n+ */\n+public class CertPathValidator {\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Service name for CertPathValidator. */\n+  private static final String CERT_PATH_VALIDATOR = \"CertPathValidator\";\n+\n+  /** The underlying implementation. */\n+  private final CertPathValidatorSpi validatorSpi;\n+\n+  /** The provider of this implementation. */\n+  private final Provider provider;\n+\n+  /** The algorithm's name. */\n+  private final String algorithm;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CertPathValidator.\n+   *\n+   * @param validatorSpi The underlying implementation.\n+   * @param provider     The provider of the implementation.\n+   * @param algorithm    The algorithm name.\n+   */\n+  protected CertPathValidator(CertPathValidatorSpi validatorSpi,\n+                              Provider provider, String algorithm)\n+  {\n+    this.validatorSpi = validatorSpi;\n+    this.provider = provider;\n+    this.algorithm = algorithm;\n+  }\n+\n+  // Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the default validator type.\n+   *\n+   * <p>This value may be set at run-time via the security property\n+   * \"certpathvalidator.type\", or the value \"PKIX\" if this property is\n+   * not set.\n+   *\n+   * @return The default validator type.\n+   */\n+  public static synchronized String getDefaultType() {\n+    String type = (String) AccessController.doPrivileged(\n+      new PrivilegedAction()\n+        {\n+          public Object run()\n+          {\n+            return Security.getProperty(\"certpathvalidator.type\");\n+          }\n+        }\n+    );\n+    if (type == null)\n+      type = \"PKIX\";\n+    return type;\n+  }\n+\n+  /**\n+   * Get an instance of the given validator from the first provider that\n+   * implements it.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If no installed provider\n+   * implements the requested algorithm.\n+   */\n+  public static CertPathValidator getInstance(String algorithm)\n+    throws NoSuchAlgorithmException\n+  {\n+    Provider[] p = Security.getProviders();\n+    for (int i = 0; i < p.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(algorithm, p[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignored)\n+          {\n+          }\n+      }\n+    throw new NoSuchAlgorithmException(algorithm);\n+  }\n+\n+  /**\n+   * Get an instance of the given validator from the named provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The name of the provider from which to get the\n+   * implementation.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If the named provider does not\n+   * implement the algorithm.\n+   * @throws NoSuchProviderException If no provider named\n+   * <i>provider</i> is installed.\n+   */\n+  public static CertPathValidator getInstance(String algorithm,\n+                                              String provider)\n+    throws NoSuchAlgorithmException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      throw new NoSuchProviderException(provider);\n+\n+    return getInstance(algorithm, p);\n+  }\n+\n+  /**\n+   * Get an instance of the given validator from the given provider.\n+   *\n+   * @param algorithm The name of the algorithm to get.\n+   * @param provider  The provider from which to get the implementation.\n+   * @return The new instance.\n+   * @throws NoSuchAlgorithmException If the provider does not implement\n+   * the algorithm.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static CertPathValidator getInstance(String algorithm,\n+                                              Provider provider)\n+    throws NoSuchAlgorithmException\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"null provider\");\n+\n+    try\n+      {\n+        return new CertPathValidator((CertPathValidatorSpi)\n+          Engine.getInstance(CERT_PATH_VALIDATOR, algorithm, provider),\n+          provider, algorithm);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(algorithm);\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the name of this validator.\n+   *\n+   * @return This validator's name.\n+   */\n+  public final String getAlgorithm()\n+  {\n+    return algorithm;\n+  }\n+\n+  /**\n+   * Return the provider of this implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Attempt to validate a certificate path.\n+   *\n+   * @param certPath The path to validate.\n+   * @param params   The algorithm-specific parameters.\n+   * @return The result of this validation attempt.\n+   * @throws CertPathValidatorException If the certificate path cannot\n+   * be validated.\n+   * @throws InvalidAlgorithmParameterException If this implementation\n+   * rejects the specified parameters.\n+   */\n+  public final CertPathValidatorResult validate(CertPath certPath,\n+                                                CertPathParameters params)\n+    throws CertPathValidatorException, InvalidAlgorithmParameterException\n+  {\n+    return validatorSpi.engineValidate(certPath, params);\n+  }\n+}"}, {"sha": "0732efc8b26aa995bff125681a9c1c44484666d4", "filename": "libjava/java/security/cert/CertPathValidatorResult.java", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorResult.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorResult.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorResult.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,63 @@\n+/* CertPathValidatorResult -- result of validating certificate paths\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * Interface to the result of calling {@link\n+ * CertPathValidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)}.\n+ *\n+ * <p>This interface defines no methods other than the required\n+ * {@link java.lang.Cloneable} interface, and is intended to group and\n+ * provide type safety for validator results. Providers that implement\n+ * a certificate path validator must also provide an implementation of\n+ * this interface, possibly defining additional methods.\n+ *\n+ * @since JDK 1.4\n+ * @see CertPathValidator\n+ */\n+public interface CertPathValidatorResult extends Cloneable\n+{\n+\n+  /**\n+   * Returns a copy of this validator result.\n+   *\n+   * @return The copy.\n+   */\n+  Object clone();\n+}"}, {"sha": "cdbde55508aaadaa8f001e460473254c7c93e53c", "filename": "libjava/java/security/cert/CertPathValidatorSpi.java", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertPathValidatorSpi.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,79 @@\n+/* CertPathValidatorSpi -- cert path validator service provider interface\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * The <i>service provider interface</i> (<b>SPI</b>) for the {@link\n+ * CertPathValidator} class. Providers implementing certificate path\n+ * validators must subclass this class and implement its abstract\n+ * methods.\n+ */\n+public abstract class CertPathValidatorSpi\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Default constructor.\n+   */\n+  public CertPathValidatorSpi()\n+  {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Attempt to validate a certificate path.\n+   *\n+   * @param certPath The path to validate.\n+   * @param params   The algorithm-specific parameters.\n+   * @return The result of this validation attempt.\n+   * @throws CertPathValidatorException If the certificate path cannot\n+   * be validated.\n+   * @throws InvalidAlgorithmParameterException If this implementation\n+   * rejects the specified parameters.\n+   */\n+  public abstract CertPathValidatorResult\n+  engineValidate(CertPath certPath, CertPathParameters params)\n+  throws CertPathValidatorException,\n+         java.security.InvalidAlgorithmParameterException;\n+}"}, {"sha": "5001c62da267d46f0e1e0acec24353549be6034e", "filename": "libjava/java/security/cert/CertSelector.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertSelector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertSelector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertSelector.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,58 @@\n+/* CertSelector.java -- certificate selector interface.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+public interface CertSelector extends Cloneable\n+{\n+\n+  /**\n+   * Returns a copy of this CertSelector.\n+   *\n+   * @return The copy.\n+   */\n+  Object clone();\n+\n+  /**\n+   * Match a certificate according to this selector's criteria.\n+   *\n+   * @param cert The certificate to match.\n+   * @return true if the certificate matches thin criteria.\n+   */\n+  boolean match(Certificate cert);\n+}"}, {"sha": "44143c5ad6c9f9673caa72a70b18f0256132eaf7", "filename": "libjava/java/security/cert/CertStore.java", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStore.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStore.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStore.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,295 @@\n+/* CertStore -- stores and retrieves certificates.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.PrivilegedAction;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+import java.util.Collection;\n+\n+import gnu.java.security.Engine;\n+\n+/**\n+ * A CertStore is a read-only repository for certificates and\n+ * certificate revocation lists.\n+ *\n+ * @since JDK 1.4\n+ */\n+public class CertStore\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** Service name for CertStore. */\n+  private static final String CERT_STORE = \"CertStore\";\n+\n+  /** The underlying implementation. */\n+  private CertStoreSpi storeSpi;\n+\n+  /** This implementation's provider. */\n+  private Provider provider;\n+\n+  /** The name of this key store type. */\n+  private String type;\n+\n+  /** The parameters used to initialize this instance, if any. */\n+  private CertStoreParameters params;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new CertStore.\n+   *\n+   * @param storeSpi The underlying implementation.\n+   * @param provider The provider of this implementation.\n+   * @param type     The type of CertStore this class represents.\n+   * @param params   The parameters used to initialize this instance, if any.\n+   */\n+  protected CertStore(CertStoreSpi storeSpi, Provider provider, String type,\n+                      CertStoreParameters params)\n+  {\n+    this.storeSpi = storeSpi;\n+    this.provider = provider;\n+    this.type = type;\n+    this.params = params;\n+  }\n+\n+\f// Class methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the default certificate store type.\n+   *\n+   * <p>This value can be set at run-time via the security property\n+   * \"certstore.type\"; if not specified than the default type will be\n+   * \"LDAP\".\n+   *\n+   * @return The default CertStore type.\n+   */\n+  public static final synchronized String getDefaultType()\n+  {\n+    String type = null;\n+    type = (String) java.security.AccessController.doPrivileged(\n+      new PrivilegedAction() {\n+        public Object run() {\n+          return Security.getProperty(\"certstore.type\");\n+        }\n+      }\n+    );\n+    if (type == null)\n+      type = \"LDAP\";\n+    return type;\n+  }\n+\n+  /**\n+   * Get an instance of the given certificate store from the first\n+   * installed provider.\n+   *\n+   * @param type     The type of CertStore to create.\n+   * @param params   The parameters to initialize this cert store with.\n+   * @return The new instance.\n+   * @throws InvalidAlgorithmParameterException If the instance rejects\n+   *         the specified parameters.\n+   * @throws NoSuchAlgorithmException If no installed provider\n+   *         implements the specified CertStore.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static CertStore getInstance(String type, CertStoreParameters params)\n+    throws InvalidAlgorithmParameterException, NoSuchAlgorithmException\n+  {\n+    Provider[] p = Security.getProviders();\n+    for (int i = 0; i < p.length; i++)\n+      {\n+        try\n+          {\n+            return getInstance(type, params, p[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignored)\n+          {\n+          }\n+      }\n+\n+    throw new NoSuchAlgorithmException(type);\n+  }\n+\n+  /**\n+   * Get an instance of the given certificate store from the named\n+   * provider.\n+   *\n+   * @param type     The type of CertStore to create.\n+   * @param params   The parameters to initialize this cert store with.\n+   * @param provider The name of the provider from which to get the\n+   *        implementation.\n+   * @return The new instance.\n+   * @throws InvalidAlgorithmParameterException If the instance rejects\n+   *         the specified parameters.\n+   * @throws NoSuchAlgorithmException If the specified provider does not\n+   *         implement the specified CertStore.\n+   * @throws NoSuchProviderException If no provider named\n+   *         <i>provider</i> is installed.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static CertStore getInstance(String type, CertStoreParameters params,\n+                                      String provider)\n+    throws InvalidAlgorithmParameterException, NoSuchAlgorithmException,\n+           NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if (p == null)\n+      throw new NoSuchProviderException(provider);\n+    return getInstance(type, params, p);\n+  }\n+\n+  /**\n+   * Get an instance of the given certificate store from the given\n+   * provider.\n+   *\n+   * @param type     The type of CertStore to create.\n+   * @param params   The parameters to initialize this cert store with.\n+   * @param provider The provider from which to get the implementation.\n+   * @return The new instance.\n+   * @throws InvalidAlgorithmParameterException If the instance rejects\n+   *         the specified parameters.\n+   * @throws NoSuchAlgorithmException If the specified provider does not\n+   *         implement the specified CertStore.\n+   * @throws IllegalArgumentException If <i>provider</i> is null.\n+   */\n+  public static CertStore getInstance(String type, CertStoreParameters params,\n+                                      Provider provider)\n+    throws InvalidAlgorithmParameterException, NoSuchAlgorithmException\n+  {\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"null provider\");\n+\n+    try\n+      {\n+        return new CertStore((CertStoreSpi) Engine.getInstance(CERT_STORE,\n+          type, provider, new Object[] { params }), provider, type, params);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new NoSuchAlgorithmException(type);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+        Throwable cause = ite.getCause();\n+        if (cause != null &&\n+           (cause instanceof InvalidAlgorithmParameterException))\n+          throw (InvalidAlgorithmParameterException) cause;\n+        else\n+          throw new NoSuchAlgorithmException(type);\n+      }\n+  }\n+\n+\f// Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the type of certificate store this instance represents.\n+   *\n+   * @return The CertStore type.\n+   */\n+  public final String getType()\n+  {\n+    return type;\n+  }\n+\n+  /**\n+   * Return the provider of this implementation.\n+   *\n+   * @return The provider.\n+   */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+   * Get the parameters this instance was created with, if any. The\n+   * parameters will be cloned before they are returned.\n+   *\n+   * @return The parameters, or null.\n+   */\n+  public final CertStoreParameters getCertStoreParameters()\n+  {\n+    return params != null ? (CertStoreParameters) params.clone() : null;\n+  }\n+\n+  /**\n+   * Get a collection of certificates from this CertStore, optionally\n+   * filtered by the specified CertSelector. The Collection returned may\n+   * be empty, but will never be null.\n+   *\n+   * <p>Implementations may not allow a null argument, even if no\n+   * filtering is desired.\n+   *\n+   * @param selector The certificate selector.\n+   * @return The collection of certificates.\n+   * @throws CertStoreException If the certificates cannot be retrieved.\n+   */\n+  public final Collection getCertificates(CertSelector selector)\n+    throws CertStoreException\n+  {\n+    return storeSpi.engineGetCertificates(selector);\n+  }\n+\n+  /**\n+   * Get a collection of certificate revocation lists from this CertStore,\n+   * optionally filtered by the specified CRLSelector. The Collection\n+   * returned may be empty, but will never be null.\n+   *\n+   * <p>Implementations may not allow a null argument, even if no\n+   * filtering is desired.\n+   *\n+   * @param selector The certificate selector.\n+   * @return The collection of certificate revocation lists.\n+   * @throws CertStoreException If the CRLs cannot be retrieved.\n+   */\n+  public final Collection getCRLs(CRLSelector selector)\n+    throws CertStoreException\n+  {\n+    return storeSpi.engineGetCRLs(selector);\n+  }\n+}"}, {"sha": "1f4b40d2b368817552e154516463e28ceef8168c", "filename": "libjava/java/security/cert/CertStoreParameters.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,60 @@\n+/* CertStoreParameters -- interface to CertStore parameters.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * Parameters used when creating instances of {@link CertStore}. This\n+ * class does not define any methods (except a required cloneable\n+ * interface) and is provided only to provide type safety for\n+ * implementations. Concrete implementations implement this interface\n+ * in accord with thier own needs.\n+ *\n+ * @see LDAPCertStoreParameters\n+ * @see CollectionCertStoreParameters\n+ */\n+public interface CertStoreParameters extends Cloneable\n+{\n+\n+  /**\n+   * Create a copy of these parameters.\n+   *\n+   * @return The copy.\n+   */\n+  Object clone();\n+}"}, {"sha": "352062329a41aa0ae3a643c819fb711bfecf1798", "filename": "libjava/java/security/cert/CertStoreSpi.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertStoreSpi.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,102 @@\n+/* CertStoreSpi -- certificate store service provider interface.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.util.Collection;\n+\n+/**\n+ * The <i>service provider interface</i> (<b>SPI</b>) for the {@link\n+ * CertStore} class.\n+ *\n+ * <p>Providers wishing to implement a CertStore must subclass this\n+ * class, implementing all the abstract methods. Providers may also\n+ * implement the {@link CertStoreParameters} interface, if they require\n+ * parameters.\n+ *\n+ * @since JDK 1.4\n+ * @see CertStore\n+ * @see CollectionCertStoreParameters\n+ * @see LDAPCertStoreParameters\n+ */\n+public abstract class CertStoreSpi\n+{\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CertStoreSpi.\n+   *\n+   * @param params The parameters to initialize this instance with, or\n+   *        null if no parameters are required.\n+   * @throws InvalidAlgorithmParameterException If the specified\n+   *         parameters are inappropriate for this class.\n+   */\n+  public CertStoreSpi(CertStoreParameters params)\n+    throws java.security.InvalidAlgorithmParameterException\n+  {\n+    super();\n+  }\n+\n+  // Abstract methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Get the certificates from this store, filtering them through the\n+   * specified CertSelector.\n+   *\n+   * @param selector The CertSelector to filter certificates.\n+   * @return A (non-null) collection of certificates.\n+   * @throws CertStoreException If the certificates cannot be retrieved.\n+   */\n+  public abstract Collection engineGetCertificates(CertSelector selector)\n+  throws CertStoreException;\n+\n+  /**\n+   * Get the certificate revocation list from this store, filtering them\n+   * through the specified CRLSelector.\n+   *\n+   * @param selector The CRLSelector to filter certificate revocation\n+   *        lists.\n+   * @return A (non-null) collection of certificate revocation list.\n+   * @throws CertStoreException If the CRLs cannot be retrieved.\n+   */\n+  public abstract Collection engineGetCRLs(CRLSelector selector)\n+  throws CertStoreException;\n+}"}, {"sha": "bcb206d0c7afd76e52794274776bda676d83bfcd", "filename": "libjava/java/security/cert/Certificate.java", "status": "modified", "additions": 101, "deletions": 44, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* Certificate.java --- Certificate class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,41 +37,46 @@\n \n \n package java.security.cert;\n+\n import java.security.PublicKey;\n import java.security.NoSuchAlgorithmException;\n import java.security.InvalidKeyException;\n import java.security.NoSuchProviderException;\n import java.security.SignatureException;\n import java.io.ObjectInputStream;\n import java.io.ByteArrayInputStream;\n+import java.io.InvalidObjectException;\n import java.io.ObjectStreamException;\n \n /**\n-   The Certificate class is an abstract class used to manage \n-   identity certificates. An identity certificate is a\n-   combination of a principal and a public key which is \n-   certified by another principal. This is the puprose of \n-   Certificate Authorities (CA).\n-   \n-   This class is used to manage different types of certificates\n-   but have important common puposes. Different types of \n-   certificates like X.509 and OpenPGP share general certificate\n-   functions (like encoding and verifying) and information like\n-   public keys.\n-   \n-   X.509, OpenPGP, and SDSI can be implemented by subclassing this\n-   class even though they differ in storage methods and information\n-   stored.\n-   \n-   @since JDK 1.2\n-   \n-   @author Mark Benvenuto\n-*/\n+ * The Certificate class is an abstract class used to manage \n+ * identity certificates. An identity certificate is a\n+ * combination of a principal and a public key which is \n+ * certified by another principal. This is the puprose of \n+ * Certificate Authorities (CA).\n+ * \n+ * <p>This class is used to manage different types of certificates\n+ * but have important common puposes. Different types of \n+ * certificates like X.509 and OpenPGP share general certificate\n+ * functions (like encoding and verifying) and information like\n+ * public keys.\n+ * \n+ * <p>X.509, OpenPGP, and SDSI can be implemented by subclassing this\n+ * class even though they differ in storage methods and information\n+ * stored.\n+ *\n+ * @see CertificateFactory\n+ * @see X509Certificate\n+ * @since JDK 1.2\n+ * @author Mark Benvenuto\n+ * @author Casey Marshall\n+ */\n public abstract class Certificate\n {\n   static final long serialVersionUID = -6751606818319535583L;\n \t\n   private String type;\n+\n   /**\n      Constructs a new certificate of the specified type. An example\n      is \"X.509\".\n@@ -203,47 +208,99 @@ public abstract void verify(PublicKey key,\n   */\n   public abstract PublicKey getPublicKey();\n \n+  // Protected methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns a replacement for this certificate to be serialized. This\n+   * method returns the equivalent to the following for this class:\n+   *\n+   * <blockquote>\n+   * <pre>new CertificateRep(getType(), getEncoded());</pre>\n+   * </blockquote>\n+   *\n+   * <p>This thusly replaces the certificate with its name and its\n+   * encoded form, which can be deserialized later with the {@link\n+   * CertificateFactory} implementation for this certificate's type.\n+   *\n+   * @return The replacement object to be serialized.\n+   * @throws ObjectStreamException If the replacement could not be\n+   * created.\n+   */\n+  public Object writeReplace() throws ObjectStreamException\n+  {\n+    try\n+      {\n+        return new CertificateRep(getType(), getEncoded());\n+      }\n+    catch (CertificateEncodingException cee)\n+      {\n+        throw new InvalidObjectException(cee.toString());\n+      }\n+  }\n+\n+  // Inner class.\n+  // ------------------------------------------------------------------------\n \n-  /* INNER CLASS */\n   /**\n      Certificate.CertificateRep is an inner class used to provide an alternate\n      storage mechanism for serialized Certificates.\n   */\n   protected static class CertificateRep implements java.io.Serializable\n   {\n+\n+    /** From JDK1.4. */\n+    private static final long serialVersionUID = -8563758940495660020L;\n+  \n+    /** The certificate type, e.g. \"X.509\". */\n     private String type;\n+\n+    /** The encoded certificate data. */\n     private byte[] data;\n \n     /**\n-       Create an alternate Certificate class to store a serialized Certificate\n-\n-       @param type the name of certificate type\n-       @param data the certificate data\n-    */\n-    protected CertificateRep(String type,\n-\t\t\t     byte[] data)\n+     * Create an alternative representation of this certificate. The\n+     * <code>(type, data)</code> pair is typically the certificate's\n+     * type as returned by {@link Certificate#getType()} (i.e. the\n+     * canonical name of the certificate type) and the encoded form as\n+     * returned by {@link Certificate#getEncoded()}.\n+     *\n+     * <p>For example, X.509 certificates would create an instance of\n+     * this class with the parameters \"X.509\" and the ASN.1\n+     * representation of the certificate, encoded as DER bytes.\n+     *\n+     * @param type The certificate type.\n+     * @param data The encoded certificate data.\n+     */\n+    protected CertificateRep(String type, byte[] data)\n     {\n       this.type = type;\n       this.data = data;\n     }\n \n     /**\n-       Return the stored Certificate\n-\n-       @return the stored certificate\n-\n-       @throws ObjectStreamException if certificate cannot be resolved\n-    */\n-    protected Object readResolve()\n-      throws ObjectStreamException\n+     * Deserialize this certificate replacement into the appropriate\n+     * certificate object. That is, this method attempts to create a\n+     * {@link CertificateFactory} for this certificate's type, then\n+     * attempts to parse the encoded data with that factory, returning\n+     * the resulting certificate.\n+     *\n+     * @return The deserialized certificate.\n+     * @throws ObjectStreamException If there is no appropriate\n+     * certificate factory for the given type, or if the encoded form\n+     * cannot be parsed.\n+     */\n+    protected Object readResolve() throws ObjectStreamException\n     {\n-      try {\n-\treturn new ObjectInputStream( new ByteArrayInputStream( data ) ).readObject();\n-      } catch ( Exception e ) {\n-\te.printStackTrace();\n-\tthrow new RuntimeException ( e.toString() );\n-      }\n+      try\n+        {\n+          CertificateFactory fact = CertificateFactory.getInstance(type);\n+          return fact.generateCertificate(new ByteArrayInputStream(data));\n+        }\n+      catch (Exception e)\n+        {\n+          throw new InvalidObjectException(e.toString());\n+        }\n     }\n   }\n-\n }"}, {"sha": "e60695491580e478da7bf1fe49698d4086a7543c", "filename": "libjava/java/security/cert/CertificateFactory.java", "status": "modified", "additions": 233, "deletions": 149, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* CertificateFactory.java -- Certificate Factory Class\n-   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,239 +37,323 @@\n \n \n package java.security.cert;\n+\n+import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n import java.security.Provider;\n import java.security.Security;\n+\n import java.io.InputStream;\n+\n import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import gnu.java.security.Engine;\n \n /**\n-   This class implments the CertificateFactory class interface\n-   used to generate certificates and certificate revocation\n-   list (CRL) objects from their encodings.\n-   \n-   A certifcate factory for X.509 returns certificates of the \n-   java.security.cert.X509Certificate class, and CRLs of the \n-   java.security.cert.X509CRL class. \n-   \n-   @author Mark Benvenuto\n-   @since JDK 1.2\n-   @status still missing full 1.4 support\n-*/\n+ * This class implements the CertificateFactory class interface used to\n+ * generate certificates, certificate revocation lists (CRLs), and certificate\n+ * paths objects from their encoded forms.\n+ *\n+ * @author Mark Benvenuto\n+ * @author Casey Marshall\n+ * @since JDK 1.2\n+ * @status Fully compatible with JDK 1.4.\n+ */\n public class CertificateFactory\n {\n \n+  /** The service name for certificate factories. */\n+  private static final String CERTIFICATE_FACTORY = \"CertificateFactory\";\n+\n   private CertificateFactorySpi certFacSpi;\n   private Provider provider;\n   private String type;\n \n   /**\n-     Creates an instance of CertificateFactory\n-\n-     @param certFacSpi A CertificateFactory engine to use\n-     @param provider A provider to use\n-     @param type The type of Certificate\n-  */\n-  protected CertificateFactory(CertificateFactorySpi certFacSpi, Provider provider, String type)\n+   * Creates an instance of CertificateFactory.\n+   *\n+   * @param certFacSpi The underlying CertificateFactory engine.\n+   * @param provider   The provider of this implementation.\n+   * @param type       The type of Certificate this factory creates.\n+   */\n+  protected CertificateFactory(CertificateFactorySpi certFacSpi,\n+                               Provider provider, String type)\n   {\n     this.certFacSpi = certFacSpi;\n     this.provider = provider;\n     this.type = type;\n   }\n \n+\f// Class methods.\n+  // ------------------------------------------------------------------------\n \n   /** \n-      Gets an instance of the CertificateFactory class representing\n-      the specified certificate factory. If the type is not \n-      found then, it throws CertificateException.\n-\n-      @param type the type of certificate to choose\n-\n-      @return a CertificateFactory repesenting the desired type\n-\n-      @throws CertificateException if the type of certificate is not implemented by providers\n-  */\n-  public static final CertificateFactory getInstance(String type) throws CertificateException\n+   * Gets an instance of the CertificateFactory class representing\n+   * the specified certificate factory. If the type is not \n+   * found then, it throws CertificateException.\n+   *\n+   * @param type     The type of certificate factory to create.\n+   * @return a CertificateFactory repesenting the desired type\n+   * @throws CertificateException If the type of certificate is not\n+   *    implemented by any installed provider.\n+   */\n+  public static final CertificateFactory getInstance(String type)\n+    throws CertificateException\n   {\n-    Provider[] p = Security.getProviders ();\n+    Provider[] p = Security.getProviders();\n \n     for (int i = 0; i < p.length; i++)\n       {\n-\tString classname = p[i].getProperty (\"CertificateFactory.\" + type);\n-\tif (classname != null)\n-\t  return getInstance (classname, type, p[i]);\n+        try\n+          {\n+            return getInstance(type, p[i]);\n+          }\n+        catch (CertificateException ignored)\n+          {\n+          }\n       }\n \n     throw new CertificateException(type);\n   }\n \n-\n-\n   /** \n-      Gets an instance of the CertificateFactory class representing\n-      the specified certificate factory from the specified provider. \n-      If the type is not found then, it throws CertificateException. \n-      If the provider is not found, then it throws \n-      NoSuchProviderException.\n-\n-      @param type the type of certificate to choose\n-\n-      @return a CertificateFactory repesenting the desired type\n-\n-      @throws CertificateException if the type of certificate is not implemented by providers\n-      @throws NoSuchProviderException if the provider is not found\n-  */\n-  public static final CertificateFactory getInstance(String type, String provider) \n+   * Gets an instance of the CertificateFactory class representing\n+   * the specified certificate factory from the specified provider. \n+   * If the type is not found then, it throws {@link CertificateException}. \n+   * If the provider is not found, then it throws \n+   * {@link java.security.NoSuchProviderException}.\n+   *\n+   * @param type     The type of certificate factory to create.\n+   * @param provider The name of the provider from which to get the\n+   *        implementation.\n+   * @return A CertificateFactory for the desired type.\n+   * @throws CertificateException If the type of certificate is not\n+   *         implemented by the named provider.\n+   * @throws NoSuchProviderException If the named provider is not installed.\n+   */\n+  public static final CertificateFactory getInstance(String type,\n+                                                     String provider) \n     throws CertificateException, NoSuchProviderException\n   {\n     Provider p = Security.getProvider(provider);\n     if( p == null)\n       throw new NoSuchProviderException();\n \n-    return getInstance (p.getProperty (\"CertificateFactory.\" + type),\n-\t\t\ttype, p);\n+    return getInstance(type, p);\n   }\n \n-  private static CertificateFactory getInstance (String classname,\n-\t\t\t\t\t\t String type,\n-\t\t\t\t\t\t Provider provider)\n+  /**\n+   * Get a certificate factory for the given certificate type from the\n+   * given provider.\n+   *\n+   * @param type     The type of certificate factory to create.\n+   * @param provider The provider from which to get the implementation.\n+   * @return A CertificateFactory for the desired type.\n+   * @throws CertificateException If the type of certificate is not\n+   *         implemented by the provider.\n+   * @throws IllegalArgumentException If the provider is null.\n+   */\n+  public static final CertificateFactory getInstance(String type,\n+                                                     Provider provider)\n     throws CertificateException\n   {\n-    try {\n-      return new CertificateFactory( (CertificateFactorySpi)Class.forName( classname ).newInstance(), provider, type );\n-    } catch( ClassNotFoundException cnfe) {\n-      throw new CertificateException(\"Class not found\");\n-    } catch( InstantiationException ie) {\n-      throw new CertificateException(\"Class instantiation failed\");\n-    } catch( IllegalAccessException iae) {\n-      throw new CertificateException(\"Illegal Access\");\n-    }\n+    if (provider == null)\n+      throw new IllegalArgumentException(\"null provider\");\n+\n+    try\n+      {\n+        return new CertificateFactory((CertificateFactorySpi)\n+          Engine.getInstance(CERTIFICATE_FACTORY, type, provider),\n+          provider, type);\n+      }\n+    catch (ClassCastException cce)\n+      {\n+        throw new CertificateException(type);\n+      }\n+    catch (java.lang.reflect.InvocationTargetException ite)\n+      {\n+        throw new CertificateException(type);\n+      }\n+    catch (NoSuchAlgorithmException nsae)\n+      {\n+        throw new CertificateException(nsae.getMessage());\n+      }\n   }\n \n+\f// Instance methods.\n+  // ------------------------------------------------------------------------\n \n   /**\n-     Gets the provider that the class is from.\n-\n-     @return the provider of this class\n-  */\n+   * Gets the provider of this implementation.\n+   *\n+   * @return The provider of this implementation.\n+   */\n   public final Provider getProvider()\n   {\n     return provider;\n   }\n \n   /**\n-     Returns the type of the certificate supported\n-\n-     @return A string with the type of certificate\n-  */\n+   * Returns the type of the certificate this factory creates.\n+   *\n+   * @return A string with the type of certificate\n+   */\n   public final String getType()\n   {\n     return type;\n   }\n \n   /**\n-     Generates a Certificate based on the encoded data read\n-     from the InputStream.\n-\n-     The input stream must contain only one certificate.\n-\n-     If there exists a specialized certificate class for the\n-     certificate format handled by the certificate factory\n-     then the return Ceritificate should be a typecast of it.\n-     Ex: A X.509 CertificateFactory should return X509Certificate.\n-\n-     For X.509 certificates, the certificate in inStream must be\n-     DER encoded and supplied in binary or printable (Base64) \n-     encoding. If the certificate is in Base64 encoding, it must be \n-     bounded by -----BEGINCERTIFICATE-----, and \n-     -----END CERTIFICATE-----. \n-\n-     @param inStream an input stream containing the certificate data\n-\n-     @return a certificate initialized with InputStream data.\n-\n-     @throws CertificateException Certificate parsing error\n-  */\n+   * Generates a Certificate from the encoded data read\n+   * from an InputStream.\n+   *\n+   * <p>The input stream must contain only one certificate.\n+   *\n+   * <p>If there exists a specialized certificate class for the\n+   * certificate format handled by the certificate factory\n+   * then the return Ceritificate should be a typecast of it.\n+   * Ex: A X.509 CertificateFactory should return X509Certificate.\n+   *\n+   * <p>For X.509 certificates, the certificate in inStream must be\n+   * DER encoded and supplied in binary or printable (Base64) \n+   * encoding. If the certificate is in Base64 encoding, it must be \n+   * bounded by -----BEGINCERTIFICATE-----, and \n+   * -----END CERTIFICATE-----. \n+   *\n+   * @param inStream An input stream containing the certificate data.\n+   * @return A certificate initialized from the decoded InputStream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   *   certificate.\n+   */\n   public final Certificate generateCertificate(InputStream inStream)\n     throws CertificateException\n   {\n-    return certFacSpi.engineGenerateCertificate( inStream );\n+    return certFacSpi.engineGenerateCertificate(inStream);\n   }\n \n   /**\n-     Returns a collection of certificates that were read from the \n-     input stream. It may be empty, have only one, or have \n-     multiple certificates.\n-\n-     For a X.509 certificate factory, the stream may contain a\n-     single DER encoded certificate or a PKCS#7 certificate \n-     chain. This is a PKCS#7 <I>SignedData</I> object with the \n-     most significant field being <I>certificates</I>. If no \n-     CRLs are present, then an empty collection is returned.\n-\t\n-     @param inStream an input stream containing the certificates\n-\n-     @return a collection of certificates initialized with \n-     the InputStream data.\n-\n-     @throws CertificateException Certificate parsing error\n-  */\n+   * Returns a collection of certificates that were read from the \n+   * input stream. It may be empty, have only one, or have \n+   * multiple certificates.\n+   *\n+   * For a X.509 certificate factory, the stream may contain a\n+   * single DER encoded certificate or a PKCS#7 certificate \n+   * chain. This is a PKCS#7 <I>SignedData</I> object with the \n+   * most significant field being <I>certificates</I>. If no \n+   * CRLs are present, then an empty collection is returned.\n+\t *\n+   * @param inStream An input stream containing the certificate data.\n+   * @return A collection of certificates initialized from the decoded\n+   *   InputStream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   *   certificates.\n+   */\n   public final Collection generateCertificates(InputStream inStream)\n     throws CertificateException\n   {\n-    return certFacSpi.engineGenerateCertificates( inStream );\n+    return certFacSpi.engineGenerateCertificates(inStream);\n   }\n \n   /**\n-     Generates a CRL based on the encoded data read\n-     from the InputStream.\n-\n-     The input stream must contain only one CRL.\n-\n-     If there exists a specialized CRL class for the\n-     CRL format handled by the certificate factory\n-     then the return CRL should be a typecast of it.\n-     Ex: A X.509 CertificateFactory should return X509CRL.\n-\n-     @param inStream an input stream containing the CRL data\n-\n-     @return a CRL initialized with InputStream data.\n-\n-     @throws CRLException CRL parsing error\n-  */\n+   * Generates a CRL based on the encoded data read\n+   * from the InputStream.\n+   *\n+   * <p>The input stream must contain only one CRL.\n+   *\n+   * <p>If there exists a specialized CRL class for the\n+   * CRL format handled by the certificate factory\n+   * then the return CRL should be a typecast of it.\n+   * Ex: A X.509 CertificateFactory should return X509CRL.\n+   *\n+   * @param inStream An input stream containing the CRL data.\n+   * @return A CRL initialized from the decoded InputStream data.\n+   * @throws CRLException If an error occurs decoding the CRL.\n+   */\n   public final CRL generateCRL(InputStream inStream)\n     throws CRLException\n   {\n-    return certFacSpi.engineGenerateCRL( inStream );\n+    return certFacSpi.engineGenerateCRL(inStream);\n   }\n \n-\n   /**\n-     Generates CRLs based on the encoded data read\n-     from the InputStream.\n-\n-     For a X.509 certificate factory, the stream may contain a\n-     single DER encoded CRL or a PKCS#7 CRL set. This is a \n-     PKCS#7 <I>SignedData</I> object with the most significant \n-     field being <I>crls</I>. If no CRLs are present, then an\n-     empty collection is returned.\n-\n-     @param inStream an input stream containing the CRLs\n-\n-     @return a collection of CRLs initialized with \n-     the InputStream data.\n-\n-     @throws CRLException CRL parsing error\n-  */\n+   * <p>Generates CRLs based on the encoded data read\n+   * from the InputStream.\n+   *\n+   * <p>For a X.509 certificate factory, the stream may contain a\n+   * single DER encoded CRL or a PKCS#7 CRL set. This is a \n+   * PKCS#7 <I>SignedData</I> object with the most significant \n+   * field being <I>crls</I>. If no CRLs are present, then an\n+   * empty collection is returned.\n+   *\n+   * @param inStream an input stream containing the CRLs.\n+   * @return a collection of CRLs initialized from the decoded\n+   *    InputStream data.\n+   * @throws CRLException If an error occurs decoding the CRLs.\n+   */\n   public final Collection generateCRLs(InputStream inStream)\n     throws CRLException\n   {\n     return certFacSpi.engineGenerateCRLs( inStream );\n   }\n \n+  /**\n+   * Generate a {@link CertPath} and initialize it with data parsed from\n+   * the input stream. The default encoding of this factory is used.\n+   *\n+   * @param inStream The InputStream containing the CertPath data.\n+   * @return A CertPath initialized from the input stream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   * CertPath.\n+   */\n   public final CertPath generateCertPath(InputStream inStream)\n     throws CertificateException\n   {\n-    throw new CertificateException(\"not implemented\");\n+    return certFacSpi.engineGenerateCertPath(inStream);\n+  }\n+\n+  /**\n+   * Generate a {@link CertPath} and initialize it with data parsed from\n+   * the input stream, using the specified encoding.\n+   *\n+   * @param inStream The InputStream containing the CertPath data.\n+   * @param encoding The encoding of the InputStream data.\n+   * @return A CertPath initialized from the input stream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   *   CertPath.\n+   */\n+  public final CertPath generateCertPath(InputStream inStream, String encoding)\n+    throws CertificateException\n+  {\n+    return certFacSpi.engineGenerateCertPath(inStream, encoding);\n+  }\n+\n+  /**\n+   * Generate a {@link CertPath} and initialize it with the certificates\n+   * in the {@link java.util.List} argument.\n+   *\n+   * @param certificates The list of certificates with which to create\n+   *   the CertPath.\n+   * @return A CertPath initialized from the certificates.\n+   * @throws CertificateException If an error occurs generating the\n+   *   CertPath.\n+   */\n+  public final CertPath generateCertPath(List certificates)\n+    throws CertificateException\n+  {\n+    return certFacSpi.engineGenerateCertPath(certificates);\n+  }\n+\n+  /**\n+   * Returns an Iterator of CertPath encodings supported by this\n+   * factory, with the default encoding first. The returned Iterator\n+   * cannot be modified.\n+   *\n+   * @return The Iterator of supported encodings.\n+   */\n+  public final Iterator getCertPathEncodings()\n+  {\n+    return certFacSpi.engineGetCertPathEncodings();\n   }\n } // class CertificateFactory"}, {"sha": "b01eac4abfa410d778e2c811940979c655d0b8cc", "filename": "libjava/java/security/cert/CertificateFactorySpi.java", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* CertificateFactorySpi.java --- Certificate Factory Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,13 +37,17 @@\n \n \n package java.security.cert;\n+\n import java.io.InputStream;\n+\n import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n \n /**\n    CertificateFactorySpi is the abstract class Service Provider\n    Interface (SPI) for the CertificateFactory class. A provider\n-   must implment all the abstract methods if they wish to \n+   must implement all the abstract methods if they wish to \n    supply a certificate factory for a particular certificate\n    type. Ex: X.509\n    \n@@ -53,16 +57,22 @@ certificate revocation lists (CRL) from their encoding.\n    @since JDK 1.2\n    \n    @author Mark Benvenuto\n-*/\n+ */\n public abstract class CertificateFactorySpi\n {\n \n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n   /**\n-     Constructs a new CertificateFactorySpi\n-  */\n+   * Constructs a new CertificateFactorySpi\n+   */\n   public CertificateFactorySpi()\n   {}\n \n+  // Abstract methods.\n+  // ------------------------------------------------------------------------\n+\n   /**\n      Generates a Certificate based on the encoded data read\n      from the InputStream.\n@@ -77,7 +87,7 @@ public CertificateFactorySpi()\n      For X.509 certificates, the certificate in inStream must be\n      DER encoded and supplied in binary or printable (Base64) \n      encoding. If the certificate is in Base64 encoding, it must be \n-     bounded by -----BEGINCERTIFICATE-----, and \n+     bounded by -----BEGIN CERTIFICATE-----, and \n      -----END CERTIFICATE-----. \n \n      @param inStream an input stream containing the certificate data\n@@ -149,5 +159,67 @@ public abstract CRL engineGenerateCRL(InputStream inStream)\n   */\n   public abstract Collection engineGenerateCRLs(InputStream inStream)\n     throws CRLException;\n+\n+  // 1.4 instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Generate a {@link CertPath} and initialize it with data parsed from\n+   * the input stream. The default encoding of this factory is used.\n+   *\n+   * @param inStream The InputStream containing the CertPath data.\n+   * @return A CertPath initialized from the input stream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   * CertPath.\n+   */\n+  public CertPath engineGenerateCertPath(InputStream inStream)\n+    throws CertificateException\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  /**\n+   * Generate a {@link CertPath} and initialize it with data parsed from\n+   * the input stream, using the specified encoding.\n+   *\n+   * @param inStream The InputStream containing the CertPath data.\n+   * @param encoding The encoding of the InputStream data.\n+   * @return A CertPath initialized from the input stream data.\n+   * @throws CertificateException If an error occurs decoding the\n+   *   CertPath.\n+   */\n+  public CertPath engineGenerateCertPath(InputStream inStream, String encoding)\n+    throws CertificateException\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  /**\n+   * Generate a {@link CertPath} and initialize it with the certificates\n+   * in the {@link java.util.List} argument.\n+   *\n+   * @param certificates The list of certificates with which to create\n+   *   the CertPath.\n+   * @return A CertPath initialized from the certificates.\n+   * @throws CertificateException If an error occurs generating the\n+   *   CertPath.\n+   */\n+  public CertPath engineGenerateCertPath(List certificates)\n+    throws CertificateException\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  /**\n+   * Returns an Iterator of CertPath encodings supported by this\n+   * factory, with the default encoding first. The returned Iterator\n+   * cannot be modified.\n+   *\n+   * @return The Iterator of supported encodings.\n+   */\n+  public Iterator engineGetCertPathEncodings()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n }\n "}, {"sha": "e46cee237ebd870e4275279cc5506b223f877d56", "filename": "libjava/java/security/cert/CollectionCertStoreParameters.java", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCollectionCertStoreParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FCollectionCertStoreParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCollectionCertStoreParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,121 @@\n+/* CollectionCertStoreParameters -- collection-based cert store parameters\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * An implementation of {@link CertStoreParameters} with a simple,\n+ * in-memory {@link Collection} of certificates and certificate\n+ * revocation list.\n+ *\n+ * <p>Note that this class is not thread-safe, and its underlying\n+ * collection may be changed at any time.\n+ *\n+ * @see CertStore\n+ */\n+public class CollectionCertStoreParameters implements CertStoreParameters\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The underlying collection. */\n+  private final Collection collection;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new CollectionCertStoreParameters with an empty,\n+   * immutable collection.\n+   */\n+  public CollectionCertStoreParameters()\n+  {\n+    this(Collections.EMPTY_LIST);\n+  }\n+\n+  /**\n+   * Create a new CollectionCertStoreParameters with the specified\n+   * collection. The argument is not copied, and subsequent changes to\n+   * the collection will change this class's collection.\n+   *\n+   * @param collection The collection.\n+   * @throws NullPointerException If <i>collection</i> is null.\n+   */\n+  public CollectionCertStoreParameters(Collection collection)\n+  {\n+    if (collection == null)\n+      throw new NullPointerException();\n+    this.collection = collection;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public Object clone()\n+  {\n+    return new CollectionCertStoreParameters(new ArrayList(collection));\n+  }\n+\n+  /**\n+   * Return the underlying collection. The collection is not copied\n+   * before being returned, so callers may update the collection that is\n+   * returned.\n+   *\n+   * @return The collection.\n+   */\n+  public Collection getCollection()\n+  {\n+    return collection;\n+  }\n+\n+  /**\n+   * Return a string representation of these parameters.\n+   *\n+   * @return The string representation of these parameters.\n+   */\n+  public String toString()\n+  {\n+    return \"CollectionCertStoreParameters: [ collection: \"\n+      + collection + \" ]\";\n+  }\n+}"}, {"sha": "061f7d0c4a3d1b94985934eaf8fdfe81eb68e479", "filename": "libjava/java/security/cert/LDAPCertStoreParameters.java", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FLDAPCertStoreParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FLDAPCertStoreParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FLDAPCertStoreParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,140 @@\n+/* LDAPCertStoreParameters.java -- LDAP CertStore parameters.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * Parameters for CertStores that are retrieved via the <i>lightweight\n+ * directory access protocol</i> (<b>LDAP</b>).\n+ *\n+ * @see CertStore\n+ */\n+public class LDAPCertStoreParameters implements CertStoreParameters\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The default LDAP port. */\n+  private static final int LDAP_PORT = 389;\n+\n+  /** The server name. */\n+  private final String serverName;\n+\n+  /** The LDAP port. */\n+  private final int port;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new LDAPCertStoreParameters object, with a servername of\n+   * \"localhost\" and a port of 389.\n+   */\n+  public LDAPCertStoreParameters()\n+  {\n+    this(\"localhost\", LDAP_PORT);\n+  }\n+\n+  /**\n+   * Create a new LDAPCertStoreParameters object, with a specified\n+   * server name and a port of 389.\n+   *\n+   * @param serverName The LDAP server name.\n+   * @throws NullPointerException If <i>serverName</i> is null.\n+   */\n+  public LDAPCertStoreParameters(String serverName)\n+  {\n+    this(serverName, LDAP_PORT);\n+  }\n+\n+  /**\n+   * Create a new LDAPCertStoreParameters object, with a specified\n+   * server name and port.\n+   *\n+   * @param serverName The LDAP server name.\n+   * @param port       The LDAP port.\n+   * @throws NullPointerException If <i>serverName</i> is null.\n+   */\n+  public LDAPCertStoreParameters(String serverName, int port)\n+  {\n+    if (serverName == null)\n+      throw new NullPointerException();\n+    this.serverName = serverName;\n+    this.port = port;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public Object clone()\n+  {\n+    return new LDAPCertStoreParameters(serverName, port);\n+  }\n+\n+  /**\n+   * Return the server name.\n+   *\n+   * @return The server name.\n+   */\n+  public String getServerName()\n+  {\n+    return serverName;\n+  }\n+\n+  /**\n+   * Return the port.\n+   *\n+   * @return the port.\n+   */\n+  public int getPort()\n+  {\n+    return port;\n+  }\n+\n+  /**\n+   * Return a string representation of these parameters.\n+   *\n+   * @return The string representation of these parameters.\n+   */\n+  public String toString()\n+  {\n+    return \"LDAPCertStoreParameters: [ serverName: \" + serverName\n+      + \"; port: \" + port + \" ]\";\n+  }\n+}"}, {"sha": "bb44a0561986c0532489189ce59a72b38153a08b", "filename": "libjava/java/security/cert/PKIXBuilderParameters.java", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXBuilderParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXBuilderParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXBuilderParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,145 @@\n+/* PKIXBuilderParameters.java -- parameters for PKIX cert path builders\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+\n+import java.util.Set;\n+\n+/**\n+ * Parameters for building certificate paths using the PKIX algorithm.\n+ *\n+ * @see CertPathBuilder\n+ */\n+public class PKIXBuilderParameters extends PKIXParameters\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The maximum path length. */\n+  private int maxPathLength;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new PKIXBuilderParameters object, populating the trusted\n+   * certificates set with all X.509 certificates found in the given key\n+   * store. All certificates found in the key store are assumed to be\n+   * trusted by this constructor.\n+   *\n+   * @param keystore The key store.\n+   * @param targetConstraints The target certificate constraints.\n+   * @throws KeyStoreException If the certificates cannot be retrieved\n+   *         from the key store.\n+   * @throws InvalidAlgorithmParameterException If there are no\n+   *         certificates in the key store.\n+   * @throws NullPointerException If <i>keystore</i> is null.\n+   */\n+  public PKIXBuilderParameters(KeyStore keystore,\n+                               CertSelector targetConstraints)\n+    throws KeyStoreException, InvalidAlgorithmParameterException\n+  {\n+    super(keystore);\n+    setTargetCertConstraints(targetConstraints);\n+    maxPathLength = 5;\n+  }\n+\n+  /**\n+   * Create a new PKIXBuilderParameters object, populating the trusted\n+   * certificates set with the elements of the given set, each of which\n+   * must be a {@link TrustAnchor}.\n+   *\n+   * @param trustAnchors The set of trust anchors.\n+   * @param targetConstraints The target certificate constraints.\n+   * @throws InvalidAlgorithmParameterException If there are no\n+   *         certificates in the set.\n+   * @throws NullPointerException If <i>trustAnchors</i> is null.\n+   * @throws ClassCastException If every element in <i>trustAnchors</i>\n+   *         is not a {@link TrustAnchor}.\n+   */\n+  public PKIXBuilderParameters(Set trustAnchors, CertSelector targetConstraints)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    super(trustAnchors);\n+    setTargetCertConstraints(targetConstraints);\n+    maxPathLength = 5;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the maximum length of certificate paths to build.\n+   *\n+   * <p>If this value is 0 it is taken to mean that the certificate path\n+   * should contain only one certificate. A value of -1 means that the\n+   * certificate path length is unconstrained. The default value is 5.\n+   *\n+   * @return The maximum path length.\n+   */\n+  public int getMaxPathLength()\n+  {\n+    return maxPathLength;\n+  }\n+\n+  /**\n+   * Sets the maximum length of certificate paths to build.\n+   *\n+   * @param maxPathLength The new path length.\n+   * @throws IllegalArgumentException If <i>maxPathLength</i> is less\n+   *         than -1.\n+   */\n+  public void setMaxPathLength(int maxPathLength)\n+  {\n+    if (maxPathLength < -1)\n+      throw new IllegalArgumentException();\n+    this.maxPathLength = maxPathLength;\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer buf = new StringBuffer(super.toString());\n+    buf.insert(buf.length() - 2, \"; Max Path Length=\" + maxPathLength);\n+    return buf.toString();\n+  }\n+}"}, {"sha": "e423f64df4cb05cee84a2279ef27c2cd0c91bedd", "filename": "libjava/java/security/cert/PKIXCertPathBuilderResult.java", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathBuilderResult.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathBuilderResult.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathBuilderResult.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,101 @@\n+/* PKIXCertPathBuilderResult.java -- PKIX cert path bulider result\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+ * The result of calling the {@link\n+ * CertPathBuilder#build(java.security.cert.CertPathParameters)} method\n+ * of PKIX {@link CertPathBuilder}s.\n+ *\n+ * @see CertPathBuilder\n+ * @see CertPathBuilderResult\n+ */\n+public class PKIXCertPathBuilderResult extends PKIXCertPathValidatorResult\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The certificate path. */\n+  private CertPath certPath;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new PKIXCertPathBuilderResult.\n+   *\n+   * @param certPath         The certificate path.\n+   * @param trustAnchor      The trust anchor.\n+   * @param policyTree       The root node of the policy tree.\n+   * @param subjectPublicKey The public key.\n+   * @throws NullPointerException If <i>certPath</i>, <i>trustAnchor</i> or\n+   *         <i>subjectPublicKey</i> is null.\n+   */\n+  public PKIXCertPathBuilderResult(CertPath certPath,\n+                                   TrustAnchor trustAnchor,\n+                                   PolicyNode policyTree,\n+                                   java.security.PublicKey subjectPublicKey)\n+  {\n+    super(trustAnchor, policyTree, subjectPublicKey);\n+    if (certPath == null)\n+      throw new NullPointerException();\n+    this.certPath = certPath;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the certificate path that was built.\n+   *\n+   * @return The certificate path that was built.\n+   */\n+  public CertPath getCertPath()\n+  {\n+    return certPath;\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer buf = new StringBuffer(super.toString());\n+    buf.insert(buf.length() - 2, \"; CertPath=\" + certPath);\n+    return buf.toString();\n+  }\n+}"}, {"sha": "fda4d061ed9f426fbdddd081781695542018ec87", "filename": "libjava/java/security/cert/PKIXCertPathChecker.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathChecker.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathChecker.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathChecker.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,133 @@\n+/* PKIXCertPathChecker.java -- checks X.509 certificate paths.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ * A validator for X.509 certificates when approving certificate chains.\n+ *\n+ * <p>Concrete subclasses can be passed to the {@link\n+ * PKIXParameters#setCertPathCheckers(java.util.List)} and {@link\n+ * PKIXParameters#addCertPathChecker(java.security.cert.PKIXCertPathChecker}\n+ * methods, which are then used to set up PKIX certificate chain\n+ * builders or validators. These classes then call the {@link\n+ * #check(java.security.cert.Certificate,java.util.Collection)} method\n+ * of this class, performing whatever checks on the certificate,\n+ * throwing an exception if any check fails.\n+ *\n+ * <p>Subclasses of this must be able to perform their checks in the\n+ * backward direction -- from the most-trusted certificate to the target\n+ * -- and may optionally support forward checking -- from the target to\n+ * the most-trusted certificate.\n+ *\n+ * @see PKIXParameters\n+ */\n+public abstract class PKIXCertPathChecker implements Cloneable\n+{\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /** Default constructor. */\n+  protected PKIXCertPathChecker()\n+  {\n+    super();\n+  }\n+\n+  // Cloneable interface.\n+  // ------------------------------------------------------------------------\n+\n+  public Object clone()\n+  {\n+    try\n+      {\n+        return super.clone();\n+      }\n+    catch (CloneNotSupportedException cnse)\n+      {\n+        throw new InternalError(cnse.getMessage());\n+      }\n+  }\n+\n+  // Abstract methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Initialize this PKIXCertPathChecker. If subclasses support forward\n+   * checking, a value of true can be passed to this method, and\n+   * certificates can be validated from the target certificate to the\n+   * most-trusted certifcate.\n+   *\n+   * @param forward The direction of this PKIXCertPathChecker.\n+   * @throws CertPathValidatorException If <i>forward</i> is true and\n+   *         this class does not support forward checking.\n+   */\n+  public abstract void init(boolean forward) throws CertPathValidatorException;\n+\n+  /**\n+   * Returns whether or not this class supports forward checking.\n+   *\n+   * @return Whether or not this class supports forward checking.\n+   */\n+  public abstract boolean isForwardCheckingSupported();\n+\n+  /**\n+   * Returns an immutable set of X.509 extension object identifiers (OIDs)\n+   * supported by this PKIXCertPathChecker.\n+   *\n+   * @return An immutable set of Strings of the supported X.509 OIDs, or\n+   *         null if no extensions are supported.\n+   */\n+  public abstract Set getSupportedExtensions();\n+\n+  /**\n+   * Checks a certificate, removing any critical extensions that are\n+   * resolved in this check.\n+   *\n+   * @param cert               The certificate to check.\n+   * @param unresolvedCritExts The (mutable) collection of as-of-yet\n+   *        unresolved critical extensions, as OID strings.\n+   * @throws CertPathValidatorException If this certificate fails this\n+   *         check.\n+   */\n+  public abstract void check(Certificate cert, Collection unresolvedCritExts)\n+  throws CertPathValidatorException;\n+}"}, {"sha": "7b88acf43b65bfaee93279d1d0766037c7459d86", "filename": "libjava/java/security/cert/PKIXCertPathValidatorResult.java", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathValidatorResult.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathValidatorResult.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXCertPathValidatorResult.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,142 @@\n+/* PKIXCertPathValidatorResult.java -- PKIX cert path builder result\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.PublicKey;\n+\n+/**\n+ * Results returned by the {@link\n+ * CertPathValidator#validate(java.security.cert.CertPath,java.security.cert.CertPathParameters)}\n+ * method for PKIX {@link CertPathValidator}s.\n+ *\n+ * @see CertPathValidator\n+ */\n+public class PKIXCertPathValidatorResult implements CertPathValidatorResult\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The trust anchor. */\n+  private final TrustAnchor trustAnchor;\n+\n+  /** The root node of the policy tree. */\n+  private final PolicyNode policyTree;\n+\n+  /** The subject's public key. */\n+  private final PublicKey subjectPublicKey;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Creates a new PKIXCertPathValidatorResult.\n+   *\n+   * @param trustAnchor      The trust anchor.\n+   * @param policyTree       The root node of the policy tree.\n+   * @param subjectPublicKey The public key.\n+   * @throws NullPointerException If either <i>trustAnchor</i> or\n+   *         <i>subjectPublicKey</i> is null.\n+   */\n+  public PKIXCertPathValidatorResult(TrustAnchor trustAnchor,\n+                                     PolicyNode policyTree,\n+                                     PublicKey subjectPublicKey)\n+  {\n+    if (trustAnchor == null || subjectPublicKey == null)\n+      throw new NullPointerException();\n+    this.trustAnchor = trustAnchor;\n+    this.policyTree = policyTree;\n+    this.subjectPublicKey = subjectPublicKey;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the trust anchor.\n+   *\n+   * @return The trust anchor.\n+   */\n+  public TrustAnchor getTrustAnchor()\n+  {\n+    return trustAnchor;\n+  }\n+\n+  /**\n+   * Returns the root node of the policy tree.\n+   *\n+   * @return The root node of the policy tree.\n+   */\n+  public PolicyNode getPolicyTree()\n+  {\n+    return policyTree;\n+  }\n+\n+  /**\n+   * Returns the subject public key.\n+   *\n+   * @return The subject public key.\n+   */\n+  public PublicKey getPublicKey()\n+  {\n+    return subjectPublicKey;\n+  }\n+\n+  /**\n+   * Returns a copy of this object.\n+   *\n+   * @return The copy.\n+   */\n+  public Object clone()\n+  {\n+    return new PKIXCertPathValidatorResult(trustAnchor, policyTree,\n+                                           subjectPublicKey);\n+  }\n+\n+  /**\n+   * Returns a printable string representation of this result.\n+   *\n+   * @return A printable string representation of this result.\n+   */\n+  public String toString()\n+  {\n+    return \"[ Trust Anchor=\" + trustAnchor + \"; Policy Tree=\"\n+      + policyTree + \"; Subject Public Key=\" + subjectPublicKey + \" ]\";\n+  }\n+}"}, {"sha": "faa6fa34886cbd9d55c59ab3bc04e09e93d0b5e2", "filename": "libjava/java/security/cert/PKIXParameters.java", "status": "added", "additions": 546, "deletions": 0, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXParameters.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXParameters.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPKIXParameters.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,546 @@\n+/* PKIXParameters.java -- parameters for the PKIX cert path algorithm\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Parameters for verifying certificate paths using the PKIX\n+ * (Public-Key Infrastructure (X.509)) algorithm.\n+ *\n+ * @see CertPathBulider\n+ */\n+public class PKIXParameters implements CertPathParameters\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The trusted certificates. */\n+  private final Set trustAnchors;\n+\n+  /** The set of initial policy identifiers. */\n+  private final Set initPolicies;\n+\n+  /** The list of certificate stores. */\n+  private final List certStores;\n+\n+  /** The list of path checkers. */\n+  private final List pathCheckers;\n+\n+  /** The revocation enabled flag. */\n+  private boolean revocationEnabled;\n+\n+  /** The explicit policy required flag. */\n+  private boolean exPolicyRequired;\n+\n+  /** The policy mapping inhibited flag. */\n+  private boolean policyMappingInhibited;\n+\n+  /** The any policy inhibited flag. */\n+  private boolean anyPolicyInhibited;\n+\n+  /** The policy qualifiers rejected flag. */\n+  private boolean policyQualRejected;\n+\n+  /** The target validation date. */\n+  private Date date;\n+\n+  /** The signature algorithm provider. */\n+  private String sigProvider;\n+\n+  /** The target constraints. */\n+  private CertSelector targetConstraints;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new PKIXParameters object, populating the trusted\n+   * certificates set with all certificates found in the given key\n+   * store. All certificates found in the key store are assumed to be\n+   * trusted by this constructor.\n+   *\n+   * @param keystore The key store.\n+   * @throws KeyStoreException If the certificates cannot be retrieved\n+   *         from the key store.\n+   * @throws InvalidAlgorithmParameterException If there are no\n+   *         certificates in the key store.\n+   * @throws NullPointerException If <i>keystore</i> is null.\n+   */\n+  public PKIXParameters(KeyStore keystore)\n+    throws KeyStoreException, InvalidAlgorithmParameterException\n+  {\n+    this();\n+    for (Enumeration e = keystore.aliases(); e.hasMoreElements(); )\n+      {\n+        String alias = (String) e.nextElement();\n+        if (!keystore.isCertificateEntry(alias))\n+          continue;\n+        Certificate cert = keystore.getCertificate(alias);\n+        if (cert instanceof X509Certificate)\n+          trustAnchors.add(new TrustAnchor((X509Certificate) cert, null));\n+      }\n+    if (trustAnchors.isEmpty())\n+      throw new InvalidAlgorithmParameterException(\"no certs in the key store\");\n+  }\n+\n+  /**\n+   * Create a new PKIXParameters object, populating the trusted\n+   * certificates set with the elements of the given set, each of which\n+   * must be a {@link TrustAnchor}.\n+   *\n+   * @param trustAnchors The set of trust anchors.\n+   * @throws InvalidAlgorithmParameterException If there are no\n+   *         certificates in the set.\n+   * @throws NullPointerException If <i>trustAnchors</i> is null.\n+   * @throws ClassCastException If every element in <i>trustAnchors</i>\n+   *         is not a {@link TrustAnchor}.\n+   */\n+  public PKIXParameters(Set trustAnchors)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    this();\n+    setTrustAnchors(trustAnchors);\n+  }\n+\n+  /**\n+   * Default constructor.\n+   */\n+  private PKIXParameters()\n+  {\n+    trustAnchors = new HashSet();\n+    initPolicies = new HashSet();\n+    certStores = new LinkedList();\n+    pathCheckers = new LinkedList();\n+    revocationEnabled = true;\n+    exPolicyRequired = false;\n+    policyMappingInhibited = false;\n+    anyPolicyInhibited = false;\n+    policyQualRejected = true;\n+  }\n+\n+  /**\n+   * Copying constructor for cloning.\n+   *\n+   * @param that The instance being cloned.\n+   */\n+  private PKIXParameters(PKIXParameters that)\n+  {\n+    this();\n+    this.trustAnchors.addAll(that.trustAnchors);\n+    this.initPolicies.addAll(that.initPolicies);\n+    this.certStores.addAll(that.certStores);\n+    this.pathCheckers.addAll(that.pathCheckers);\n+    this.revocationEnabled = that.revocationEnabled;\n+    this.exPolicyRequired = that.exPolicyRequired;\n+    this.policyMappingInhibited = that.policyMappingInhibited;\n+    this.anyPolicyInhibited = that.anyPolicyInhibited;\n+    this.policyQualRejected = that.policyQualRejected;\n+    this.date = that.date;\n+    this.sigProvider = that.sigProvider;\n+    this.targetConstraints = that.targetConstraints != null\n+      ? (CertSelector) that.targetConstraints.clone() : null;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns an immutable set of trust anchors. The set returned will\n+   * never be null and will never be empty.\n+   *\n+   * @return A (never null, never empty) immutable set of trust anchors.\n+   */\n+  public Set getTrustAnchors()\n+  {\n+    return Collections.unmodifiableSet(trustAnchors);\n+  }\n+\n+  /**\n+   * Sets the trust anchors of this class, replacing the current trust\n+   * anchors with those in the given set. The supplied set is copied to\n+   * prevent modification.\n+   *\n+   * @param trustAnchors The new set of trust anchors.\n+   * @throws InvalidAlgorithmParameterException If there are no\n+   *         certificates in the set.\n+   * @throws NullPointerException If <i>trustAnchors</i> is null.\n+   * @throws ClassCastException If every element in <i>trustAnchors</i>\n+   *         is not a {@link TrustAnchor}.\n+   */\n+  public void setTrustAnchors(Set trustAnchors)\n+    throws InvalidAlgorithmParameterException\n+  {\n+    if (trustAnchors.isEmpty())\n+      throw new InvalidAlgorithmParameterException(\"no trust anchors\");\n+    this.trustAnchors.clear();\n+    for (Iterator i = trustAnchors.iterator(); i.hasNext(); )\n+      {\n+        this.trustAnchors.add((TrustAnchor) i.next());\n+      }\n+  }\n+\n+  /**\n+   * Returns the set of initial policy identifiers (as OID strings). If\n+   * any policy is accepted, this method returns the empty set.\n+   *\n+   * @return An immutable set of initial policy OID strings, or the\n+   *         empty set if any policy is acceptable.\n+   */\n+  public Set getInitialPolicies()\n+  {\n+    return Collections.unmodifiableSet(initPolicies);\n+  }\n+\n+  /**\n+   * Sets the initial policy identifiers (as OID strings). If the\n+   * argument is null or the empty set, then any policy identifier will\n+   * be accepted.\n+   *\n+   * @param initPolicies The new set of policy strings, or null.\n+   * @throws ClassCastException If any element in <i>initPolicies</i> is\n+   *         not a string.\n+   */\n+  public void setInitialPolicies(Set initPolicies)\n+  {\n+    this.initPolicies.clear();\n+    if (initPolicies == null)\n+      return;\n+    for (Iterator i = initPolicies.iterator(); i.hasNext(); )\n+      {\n+        this.initPolicies.add((String) i.next());\n+      }\n+  }\n+\n+  /**\n+   * Add a {@link CertStore} to the list of cert stores.\n+   *\n+   * @param store The CertStore to add.\n+   */\n+  public void addCertStore(CertStore store)\n+  {\n+    if (store != null)\n+      certStores.add(store);\n+  }\n+\n+  /**\n+   * Returns an immutable list of cert stores. This method never returns\n+   * null.\n+   *\n+   * @return The list of cert stores.\n+   */\n+  public List getCertStores()\n+  {\n+    return Collections.unmodifiableList(certStores);\n+  }\n+\n+  /**\n+   * Set the cert stores. If the argument is null the list of cert\n+   * stores will be empty.\n+   *\n+   * @param certStores The cert stores.\n+   */\n+  public void setCertStores(List certStores)\n+  {\n+    this.certStores.clear();\n+    if (certStores == null)\n+      return;\n+    for (Iterator i = certStores.iterator(); i.hasNext(); )\n+      {\n+        this.certStores.add((CertStore) i.next());\n+      }\n+  }\n+\n+  /**\n+   * Returns the value of the <i>revocation enabled</i> flag. The default\n+   * value for this flag is <code>true</code>.\n+   *\n+   * @return The <i>revocation enabled</i> flag.\n+   */\n+  public boolean isRevocationEnabled()\n+  {\n+    return revocationEnabled;\n+  }\n+\n+  /**\n+   * Sets the value of the <i>revocation enabled</i> flag.\n+   *\n+   * @param value The new value.\n+   */\n+  public void setRevocationEnabled(boolean value)\n+  {\n+    revocationEnabled = value;\n+  }\n+\n+  /**\n+   * Returns the value of the <i>explicit policy required</i> flag. The\n+   * default value of this flag is <code>false</code>.\n+   *\n+   * @return The <i>explicit policy required</i> flag.\n+   */\n+  public boolean isExplicitPolicyRequired()\n+  {\n+    return exPolicyRequired;\n+  }\n+\n+  /**\n+   * Sets the value of the <i>explicit policy required</i> flag.\n+   *\n+   * @param value The new value.\n+   */\n+  public void setExplicitPolicyRequired(boolean value)\n+  {\n+    exPolicyRequired = value;\n+  }\n+\n+  /**\n+   * Returns the value of the <i>policy mapping inhibited</i> flag. The\n+   * default value of this flag is <code>false</code>.\n+   *\n+   * @return The <i>policy mapping inhibited</i> flag.\n+   */\n+  public boolean isPolicyMappingInhibited()\n+  {\n+    return policyMappingInhibited;\n+  }\n+\n+  /**\n+   * Sets the value of the <i>policy mapping inhibited</i> flag.\n+   *\n+   * @param value The new value.\n+   */\n+  public void setPolicyMappingInhibited(boolean value)\n+  {\n+    policyMappingInhibited = value;\n+  }\n+\n+  /**\n+   * Returns the value of the <i>any policy inhibited</i> flag. The\n+   * default value of this flag is <code>false</code>.\n+   *\n+   * @return The <i>any policy inhibited</i> flag.\n+   */\n+  public boolean isAnyPolicyInhibited()\n+  {\n+    return anyPolicyInhibited;\n+  }\n+\n+  /**\n+   * Sets the value of the <i>any policy inhibited</i> flag.\n+   *\n+   * @param value The new value.\n+   */\n+  public void setAnyPolicyInhibited(boolean value)\n+  {\n+    anyPolicyInhibited = value;\n+  }\n+\n+  /**\n+   * Returns the value of the <i>policy qualifiers enabled</i> flag. The\n+   * default value of this flag is <code>true</code>.\n+   *\n+   * @return The <i>policy qualifiers enabled</i> flag.\n+   */\n+  public boolean getPolicyQualifiersRejected()\n+  {\n+    return policyQualRejected;\n+  }\n+\n+  /**\n+   * Sets the value of the <i>policy qualifiers enabled</i> flag.\n+   *\n+   * @param value The new value.\n+   */\n+  public void setPolicyQualifiersRejected(boolean value)\n+  {\n+    policyQualRejected = value;\n+  }\n+\n+  /**\n+   * Returns the date for which the certificate path should be\n+   * validated, or null if the current time should be used. The date\n+   * object is copied to prevent subsequent modification.\n+   *\n+   * @return The date, or null if not set.\n+   */\n+  public Date getDate()\n+  {\n+    return date != null ? (Date) date.clone() : null;\n+  }\n+\n+  /**\n+   * Sets the date for which the certificate path should be validated,\n+   * or null if the current time should be used.\n+   *\n+   * @param date The new date, or null.\n+   */\n+  public void setDate(Date date)\n+  {\n+    if (date != null)\n+      this.date = (Date) date.clone();\n+    else\n+      this.date = null;\n+  }\n+\n+  /**\n+   * Add a certificate path checker.\n+   *\n+   * @param checker The certificate path checker to add.\n+   */\n+  public void addCertPathChecker(PKIXCertPathChecker checker)\n+  {\n+    if (checker != null)\n+      pathCheckers.add(checker);\n+  }\n+\n+  /**\n+   * Returns an immutable list of all certificate path checkers.\n+   *\n+   * @return An immutable list of all certificate path checkers.\n+   */\n+  public List getCertPathCheckers()\n+  {\n+    return Collections.unmodifiableList(pathCheckers);\n+  }\n+\n+  /**\n+   * Sets the certificate path checkers. If the argument is null, the\n+   * list of checkers will merely be cleared.\n+   *\n+   * @param pathCheckers The new list of certificate path checkers.\n+   * @throws ClassCastException If any element of <i>pathCheckers</i> is\n+   *         not a {@link PKIXCertPathChecker}.\n+   */\n+  public void setCertPathCheckers(List pathCheckers)\n+  {\n+    this.pathCheckers.clear();\n+    if (pathCheckers == null)\n+      return;\n+    for (Iterator i = pathCheckers.iterator(); i.hasNext(); )\n+      {\n+        this.pathCheckers.add((PKIXCertPathChecker) i.next());\n+      }\n+  }\n+\n+  /**\n+   * Returns the signature algorithm provider, or null if not set.\n+   *\n+   * @return The signature algorithm provider, or null if not set.\n+   */\n+  public String getSigProvider()\n+  {\n+    return sigProvider;\n+  }\n+\n+  /**\n+   * Sets the signature algorithm provider, or null if there is no\n+   * preferred provider.\n+   *\n+   * @param sigProvider The signature provider name.\n+   */\n+  public void setSigProvider(String sigProvider)\n+  {\n+    this.sigProvider = sigProvider;\n+  }\n+\n+  /**\n+   * Returns the constraints placed on the target certificate, or null\n+   * if there are none. The target constraints are copied to prevent\n+   * subsequent modification.\n+   *\n+   * @return The target constraints, or null.\n+   */\n+  public CertSelector getTargetCertConstraints()\n+  {\n+    return targetConstraints != null\n+      ? (CertSelector) targetConstraints.clone() : null;\n+  }\n+\n+  /**\n+   * Sets the constraints placed on the target certificate.\n+   *\n+   * @param targetConstraints The target constraints.\n+   */\n+  public void setTargetCertConstraints(CertSelector targetConstraints)\n+  {\n+    this.targetConstraints = targetConstraints != null\n+      ? (CertSelector) targetConstraints.clone() : null;\n+  }\n+\n+  /**\n+   * Returns a copy of these parameters.\n+   *\n+   * @return The copy.\n+   */\n+  public Object clone()\n+  {\n+    return new PKIXParameters(this);\n+  }\n+\n+  /**\n+   * Returns a printable representation of these parameters.\n+   *\n+   * @return A printable representation of these parameters.\n+   */\n+  public String toString() {\n+    return \"[ Trust Anchors: \" + trustAnchors + \"; Initial Policy OIDs=\"\n+      + (initPolicies != null ? initPolicies.toString() : \"any\")\n+      + \"; Validity Date=\" + date + \"; Signature Provider=\"\n+      + sigProvider + \"; Default Revocation Enabled=\" + revocationEnabled\n+      + \"; Explicit Policy Required=\" + exPolicyRequired\n+      + \"; Policy Mapping Inhibited=\" + policyMappingInhibited\n+      + \"; Any Policy Inhibited=\" + anyPolicyInhibited\n+      + \"; Policy Qualifiers Rejected=\" + policyQualRejected\n+      + \"; Target Cert Contstraints=\" + targetConstraints\n+      + \"; Certification Path Checkers=\" + pathCheckers\n+      + \"; CertStores=\" + certStores + \" ]\";\n+  }\n+}"}, {"sha": "d39a2e575849b9bd1cb918c07df4387bfd4b6704", "filename": "libjava/java/security/cert/PolicyNode.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyNode.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,102 @@\n+/* PolicyNode.java -- a single node in a policy tree\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+public interface PolicyNode\n+{\n+\n+  /**\n+   * Get the iterator of the child nodes of this node. The returned\n+   * iterator is (naturally) unmodifiable.\n+   *\n+   * @return An iterator over the child nodes.\n+   */\n+  java.util.Iterator getChildren();\n+\n+  /**\n+   * Get the depth of this node within the tree, starting at 0 for the\n+   * root node.\n+   *\n+   * @return The depth of this node.\n+   */\n+  int getDepth();\n+\n+  /**\n+   * Returns a set of policies (string OIDs) that will satisfy this\n+   * node's policy. The root node should always return the singleton set\n+   * with the element \"any-policy\".\n+   *\n+   * @return The set of expected policies.\n+   */\n+  java.util.Set getExpectedPolicies();\n+\n+  /**\n+   * Returns the parent node of this node, or null if this is the root\n+   * node.\n+   *\n+   * @return The parent node, or null.\n+   */\n+  PolicyNode getParent();\n+\n+  /**\n+   * Returns a set of {@link PolicyQualifierInfo} objects that qualify\n+   * the valid policy of this node. The root node should always return\n+   * the empty set.\n+   *\n+   * @return The set of {@link PolicyQualifierInfo} objects.\n+   */\n+  java.util.Set getPolicyQualifiers();\n+\n+  /**\n+   * Get the policy OID this node represents. The root node should return\n+   * the special value \"any-policy\".\n+   *\n+   * @return The policy of this node.\n+   */\n+  String getValidPolicy();\n+\n+  /**\n+   * Return the criticality flag of this policy node. Nodes who return\n+   * true for this method should be considered critical. The root node\n+   * is never critical.\n+   *\n+   * @return The criticality flag.\n+   */\n+  boolean isCritical();\n+}"}, {"sha": "a46b6ba89bebdb639005933ce4bc9d241c805374", "filename": "libjava/java/security/cert/PolicyQualifierInfo.java", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyQualifierInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyQualifierInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FPolicyQualifierInfo.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,172 @@\n+/* PolicyQualifierInfo.java -- policy qualifier info object.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import gnu.java.io.ASN1ParsingException;\n+import gnu.java.security.OID;\n+import gnu.java.security.der.DER;\n+import gnu.java.security.der.DEREncodingException;\n+import gnu.java.security.der.DERReader;\n+import gnu.java.security.der.DERValue;\n+import gnu.java.security.der.DERWriter;\n+\n+/**\n+ * The PolicyQualifierInfo X.509 certificate extension.\n+ * PolicyQualifierInfo objects are represented by the ASN.1 structure:\n+ *\n+ * <pre>\n+ * PolicyQualifierInfo ::= SEQUENCE {\n+ *    policyQualifierId   PolicyQualifierId,\n+ *    qualifier           ANY DEFINED BY policyQualifierId\n+ * }\n+ *\n+ * PolicyQualifierId ::= OBJECT IDENTIFIER\n+ * </pre>\n+ *\n+ * @since JDK 1.4\n+ */\n+public class PolicyQualifierInfo\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The <code>policyQualifierId</code> field. */\n+  private OID oid;\n+\n+  /** The DER encoded form of this object. */\n+  private byte[] encoded;\n+\n+  /** The DER encoded form of the <code>qualifier</code> field. */\n+  private DERValue qualifier;\n+\n+  // Constructor.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new PolicyQualifierInfo object from the DER encoded form\n+   * passed in the byte array. The argument is copied.\n+   *\n+   * <p>The ASN.1 form of PolicyQualifierInfo is:\n+<pre>\n+PolicyQualifierInfo ::= SEQUENCE {\n+   policyQualifierId     PolicyQualifierId,\n+   qualifier             ANY DEFINED BY policyQualifierId\n+}\n+\n+PolicyQualifierId ::= OBJECT IDENTIFIER\n+</pre>\n+   *\n+   * @param encoded The DER encoded form.\n+   * @throws IOException If the structure cannot be parsed from the\n+   *         encoded bytes.\n+   */\n+  public PolicyQualifierInfo(byte[] encoded) throws IOException\n+  {\n+    if (encoded == null)\n+      throw new IOException(\"null bytes\");\n+    this.encoded = (byte[]) encoded.clone();\n+    DERReader in = new DERReader(new ByteArrayInputStream(this.encoded));\n+    DERValue qualInfo = in.read();\n+    if (!qualInfo.isConstructed())\n+      throw new ASN1ParsingException(\"malformed PolicyQualifierInfo\");\n+    DERValue val = in.read();\n+    if (!(val.getValue() instanceof OID))\n+      throw new ASN1ParsingException(\"value read not an OBJECT IDENTIFIER\");\n+    oid = (OID) val.getValue();\n+    if (val.getEncodedLength() < val.getLength())\n+      qualifier = in.read();\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the <code>policyQualifierId</code> field of this structure,\n+   * as a dotted-decimal representation of the object identifier.\n+   *\n+   * @return This structure's OID field.\n+   */\n+  public String getPolicyQualifierId()\n+  {\n+    return oid.toString();\n+  }\n+\n+  /**\n+   * Returns the DER encoded form of this object; the contents of the\n+   * returned byte array are equivalent to those that were passed to the\n+   * constructor. The byte array is cloned every time this method is\n+   * called.\n+   *\n+   * @return The encoded form.\n+   */\n+  public byte[] getEncoded()\n+  {\n+    return (byte[]) encoded.clone();\n+  }\n+\n+  /**\n+   * Get the <code>qualifier</code> field of this object, as a DER\n+   * encoded byte array. The byte array returned is cloned every time\n+   * this method is called.\n+   *\n+   * @return The encoded qualifier.\n+   */\n+  public byte[] getPolicyQualifier()\n+  {\n+    if (qualifier == null)\n+      return new byte[0];\n+    return qualifier.getEncoded();\n+  }\n+\n+  /**\n+   * Returns a printable string representation of this object.\n+   *\n+   * @return The string representation.\n+   */\n+  public String toString()\n+  {\n+    return \"PolicyQualifierInfo { policyQualifierId ::= \" + oid\n+      + \", qualifier ::= \" + qualifier + \" }\";\n+  }\n+}"}, {"sha": "ccd2a9fadb3dd2a764d02314068e12ba73da5c5d", "filename": "libjava/java/security/cert/TrustAnchor.java", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FTrustAnchor.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,188 @@\n+/* TrustAnchor.java -- an ultimately-trusted certificate.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security.cert;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+\n+import java.security.PublicKey;\n+\n+import gnu.java.security.x509.X500DistinguishedName;\n+\n+/**\n+ * An ultimately-trusted certificate to serve as the root of a\n+ * certificate chain.\n+ *\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n+public class TrustAnchor\n+{\n+\n+  // Fields.\n+  // ------------------------------------------------------------------------\n+\n+  /** The certificate authority's distinguished name. */\n+  private final X500DistinguishedName caName;\n+\n+  /** The certficate authority's public key. */\n+  private final PublicKey caKey;\n+\n+  /** The certficate authority's certificate. */\n+  private final X509Certificate trustedCert;\n+\n+  /** The encoded name constraints bytes. */\n+  private final byte[] nameConstraints;\n+\n+  // Constnuctors.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Create a new trust anchor from a certificate and (optional) name\n+   * constraints.\n+   *\n+   * <p>If the <i>nameConstraints</i> argument in non-null, it will be\n+   * copied to prevent modification.\n+   *\n+   * @param trustedCert The trusted certificate.\n+   * @param nameConstraints The encoded nameConstraints.\n+   */\n+  public TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints)\n+  {\n+    if (trustedCert == null)\n+      throw new NullPointerException();\n+    this.trustedCert = trustedCert;\n+    caName = null;\n+    caKey = null;\n+    if (nameConstraints != null)\n+      this.nameConstraints = (byte[]) nameConstraints.clone();\n+    else\n+      this.nameConstraints = null;\n+  }\n+\n+  /**\n+   * Create a new trust anchor from a certificate authority's\n+   * distinguished name, public key, and (optional) name constraints.\n+   *\n+   * <p>If the <i>nameConstraints</i> argument in non-null, it will be\n+   * copied to prevent modification.\n+   *\n+   * @params caName The CA's distinguished name.\n+   * @params caKey The CA's public key.\n+   * @params nameConstraints The encoded nameConstraints.\n+   */\n+  public TrustAnchor(String caName, PublicKey caKey, byte[] nameConstraints)\n+  {\n+    if (caName == null || caKey == null)\n+      throw new NullPointerException();\n+    if (caName.length() == 0)\n+      throw new IllegalArgumentException();\n+    trustedCert = null;\n+    this.caName = new X500DistinguishedName(caName);\n+    this.caKey = caKey;\n+    if (nameConstraints != null)\n+      this.nameConstraints = (byte[]) nameConstraints.clone();\n+    else\n+      this.nameConstraints = null;\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Return the trusted certificate, or null if none was specified.\n+   *\n+   * @return The trusted certificate.\n+   */\n+  public final X509Certificate getTrustedCert()\n+  {\n+    return trustedCert;\n+  }\n+\n+  /**\n+   * Return the certificate authority's distinguished name, or null if\n+   * none was specified.\n+   *\n+   * @return The CA's distinguished name.\n+   */\n+  public final String getCAName()\n+  {\n+    if (caName != null)\n+      return caName.toRFC2253();\n+    return null;\n+  }\n+\n+  /**\n+   * Return the certificate authority's public key, or null if none was\n+   * specified.\n+   *\n+   * @return The CA's public key.\n+   */\n+  public final PublicKey getCAPublicKey()\n+  {\n+    return caKey;\n+  }\n+\n+  /**\n+   * Return the encoded name constraints, or null if none was specified.\n+   *\n+   * <p>The name constraints byte array is copied when this method is\n+   * called to prevent modification.\n+   *\n+   * @return The encoded name constraints.\n+   */\n+  public final byte[] getNameConstraints()\n+  {\n+    if (nameConstraints == null)\n+      return null;\n+    return (byte[]) nameConstraints.clone();\n+  }\n+\n+  /**\n+   * Return a printable representation of this trust anchor.\n+   *\n+   * @return The printable representation.\n+   */\n+  public String toString()\n+  {\n+    if (trustedCert == null)\n+      return \"[ Trusted CA Public Key=\" + caKey + \", Trusted CA Issuer Name=\"\n+        + caName.toRFC2253() + \" ]\";\n+    return \"[ Trusted CA Certificate=\" + trustedCert + \" ]\";\n+  }\n+}"}, {"sha": "6794ccb43adcc6104fd051dddfe9a2c9dea17f82", "filename": "libjava/java/security/cert/X509CRL.java", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -47,6 +47,8 @@\n import java.util.Date;\n import java.util.Set;\n \n+import javax.security.auth.x500.X500Principal;\n+\n /**\n    The X509CRL class is the abstract class used to manage\n    X.509 Certificate Revocation Lists. The CRL is a list of\n@@ -378,4 +380,17 @@ bmpString               BMPString (SIZE (1..MAX)) }\n   */\n   public abstract byte[] getSigAlgParams();\n \n+  // 1.4 instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the X.500 distinguished name of this CRL's issuer.\n+   *\n+   * @return The issuer's X.500 distinguished name.\n+   * @since JDK 1.4\n+   */\n+  public X500Principal getIssuerX500Principal()\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n }"}, {"sha": "cce1e535cc4e2226d2833a29946523eefe508d96", "filename": "libjava/java/security/cert/X509Certificate.java", "status": "modified", "additions": 216, "deletions": 81, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -1,5 +1,5 @@\n /* X509Certificate.java --- X.509 Certificate class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n \n package java.security.cert;\n+\n import java.math.BigInteger;\n import java.security.Principal;\n import java.security.PublicKey;\n@@ -47,90 +48,104 @@\n import java.util.Date;\n \n /**\n-\tX509Certificate is the abstract class for X.509 certificates.\n-\tThis provides a stanard class interface for accessing all \n-\tthe attributes of X.509 certificates.\n-\n-\tIn June 1996, the basic X.509 v3 format was finished by \n-\tISO/IEC and ANSI X.9. The ASN.1 DER format is below:\n-\n-\t   Certificate  ::=  SEQUENCE  {\n-        \ttbsCertificate       TBSCertificate,\n-\t        signatureAlgorithm   AlgorithmIdentifier,\n-        \tsignatureValue       BIT STRING  }\n-\n-\tThese certificates are widely used in various Internet \n-\tprotocols to support authentication. It is used in \n-\tPrivacy Enhanced Mail (PEM), Transport Layer Security (TLS),\n-\tSecure Sockets Layer (SSL), code signing for trusted software\n-\tdistribution, and Secure Electronic Transactions (SET).\n-\n-\tThe certificates are managed and vouched for by \n-\t<I>Certificate Authorities</I> (CAs). CAs are companies or \n-\tgroups that create certificates by placing the data in the \n-\tX.509 certificate format and signing it with their private\n-\tkey. CAs serve as trusted third parties by certifying that\n-\tthe person or group specified in the certificate is who\n-\tthey say they are. \n-\n-\tThe ASN.1 defintion for <I>tbsCertificate</I> is\n-\t\n-   TBSCertificate  ::=  SEQUENCE  {\n-        version         [0]  EXPLICIT Version DEFAULT v1,\n-        serialNumber         CertificateSerialNumber,\n-        signature            AlgorithmIdentifier,\n-        issuer               Name,\n-        validity             Validity,\n-        subject              Name,\n-        subjectPublicKeyInfo SubjectPublicKeyInfo,\n-        issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n-                             -- If present, version shall be v2 or v3\n-        subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n-                             -- If present, version shall be v2 or v3\n-        extensions      [3]  EXPLICIT Extensions OPTIONAL\n-                             -- If present, version shall be v3\n-        }\n-\n-   Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n-\n-   CertificateSerialNumber  ::=  INTEGER\n-\n-   Validity ::= SEQUENCE {\n-        notBefore      Time,\n-        notAfter       Time }\n-\n-   Time ::= CHOICE {\n-        utcTime        UTCTime,\n-        generalTime    GeneralizedTime }\n-\n-   UniqueIdentifier  ::=  BIT STRING\n-\n-   SubjectPublicKeyInfo  ::=  SEQUENCE  {\n-        algorithm            AlgorithmIdentifier,\n-        subjectPublicKey     BIT STRING  }\n-\n-   Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n-\n-   Extension  ::=  SEQUENCE  {\n-        extnID      OBJECT IDENTIFIER,\n-        critical    BOOLEAN DEFAULT FALSE,\n-        extnValue   OCTET STRING  }\n-\n-\n-\tCertificates are created with the CertificateFactory.\n-\tFor more information about X.509 certificates, consult\n-\trfc2459.\n-\n-\t@since JDK 1.2\n-\n-\t@author Mark Benvenuto\n-*/\n+ * X509Certificate is the abstract class for X.509 certificates.\n+ * This provides a stanard class interface for accessing all \n+ * the attributes of X.509 certificates.\n+ *\n+ * <p>In June 1996, the basic X.509 v3 format was finished by \n+ * ISO/IEC and ANSI X.9. The ASN.1 DER format is below:\n+ *\n+ * <blockquote><pre>\n+ * Certificate  ::=  SEQUENCE  {\n+ *   tbsCertificate       TBSCertificate,\n+ *   signatureAlgorithm   AlgorithmIdentifier,\n+ *   signatureValue       BIT STRING  }\n+ * </pre></blockquote>\n+ *\n+ * <p>These certificates are widely used in various Internet \n+ * protocols to support authentication. It is used in \n+ * Privacy Enhanced Mail (PEM), Transport Layer Security (TLS),\n+ * Secure Sockets Layer (SSL), code signing for trusted software\n+ * distribution, and Secure Electronic Transactions (SET).\n+ *\n+ * <p>The certificates are managed and vouched for by \n+ * <I>Certificate Authorities</I> (CAs). CAs are companies or \n+ * groups that create certificates by placing the data in the \n+ * X.509 certificate format and signing it with their private\n+ * key. CAs serve as trusted third parties by certifying that\n+ * the person or group specified in the certificate is who\n+ * they say they are. \n+ *\n+ * <p>The ASN.1 defintion for <I>tbsCertificate</I> is\n+ * \n+ * <blockquote><pre>\n+ * TBSCertificate  ::=  SEQUENCE  {\n+ *   version         [0]  EXPLICIT Version DEFAULT v1,\n+ *   serialNumber         CertificateSerialNumber,\n+ *   signature            AlgorithmIdentifier,\n+ *   issuer               Name,\n+ *   validity             Validity,\n+ *   subject              Name,\n+ *   subjectPublicKeyInfo SubjectPublicKeyInfo,\n+ *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n+ *                        -- If present, version shall be v2 or v3\n+ *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n+ *                        -- If present, version shall be v2 or v3\n+ *   extensions      [3]  EXPLICIT Extensions OPTIONAL\n+ *                        -- If present, version shall be v3\n+ * }\n+ *\n+ * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n+ *\n+ * CertificateSerialNumber  ::=  INTEGER\n+ *\n+ * Validity ::= SEQUENCE {\n+ *   notBefore      Time,\n+ *   notAfter       Time }\n+ *\n+ * Time ::= CHOICE {\n+ *   utcTime        UTCTime,\n+ *   generalTime    GeneralizedTime }\n+ *\n+ * UniqueIdentifier  ::=  BIT STRING\n+ *\n+ * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n+ *   algorithm            AlgorithmIdentifier,\n+ *   subjectPublicKey     BIT STRING  }\n+ *\n+ * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n+ *\n+ * Extension  ::=  SEQUENCE  {\n+ *   extnID      OBJECT IDENTIFIER,\n+ *   critical    BOOLEAN DEFAULT FALSE,\n+ *   extnValue   OCTET STRING  }\n+ * </pre></blockquote>\n+ * \n+ * Certificates are created with the CertificateFactory.\n+ *\n+ * <p>References:\n+ *\n+ * <ol>\n+ * <li>Olivier Dubuisson, Philippe Fouquart (Translator) <i>ASN.1 -\n+ * Communication between heterogeneous systems</i>, (C) September 2000,\n+ * Morgan Kaufmann Publishers, ISBN 0-12-6333361-0. Available on-line at\n+ * <a\n+ * href=\"http://www.oss.com/asn1/dubuisson.html\">http://www.oss.com/asn1/dubuisson.html</a></li>\n+ * <li>R. Housley et al, <i><a href=\"http://www.ietf.org/rfc/rfc3280.txt\">RFC\n+ * 3280: Internet X.509 Public Key Infrastructure Certificate and CRL\n+ * Profile</a></i>.</li>\n+ * </ol>\n+ *\n+ * @since JDK 1.2\n+ * @author Mark Benvenuto\n+ * @author Casey Marshall (rsdio@metastatic.org)\n+ */\n public abstract class X509Certificate extends Certificate implements X509Extension\n {\n \n   /**\n-     Constructs a new certificate of the specified type.\n-  */\n+   * Constructs a new certificate of the specified type.\n+   */\n   protected X509Certificate()\n   {\n     super( \"X.509\" );\n@@ -451,5 +466,125 @@ pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n   */\n   public abstract int getBasicConstraints();\n \n+  // 1.4 instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  /**\n+   * Returns the <code>ExtendedKeyUsage</code> extension of this\n+   * certificate, or null if there is no extension present. The returned\n+   * value is a {@link java.util.List} strings representing the object\n+   * identifiers of the extended key usages. This extension has the OID\n+   * 2.5.29.37.\n+   *\n+   * <p>The ASN.1 definition for this extension is:\n+   *\n+   * <blockquote><pre> \n+   * ExtendedKeyUsage ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId\n+   *\n+   * KeyPurposeId ::= OBJECT IDENTIFIER\n+   * </pre></blockquote>\n+   *\n+   * @return The list of extension OIDs, or null if there are none\n+   * present in this certificate.\n+   * @throws CertificateParsingException If this extension cannot be\n+   * parsed from its encoded form.\n+   */\n+  public java.util.List getExtendedKeyUsage()\n+    throws CertificateParsingException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Returns the alternative names for this certificate's subject (the\n+   * owner), or null if there are none.\n+   *\n+   * <p>This is an X.509 extension with OID 2.5.29.17 and is defined by\n+   * the ASN.1 construction:\n+   *\n+   * <blockquote><pre>\n+   * SubjectAltNames ::= GeneralNames\n+   *\n+   * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName\n+   *\n+   * GeneralName ::= CHOICE {\n+   *   otherName                 [0]   OtherName,\n+   *   rfc822Name                [1]   IA5String,\n+   *   dNSName                   [2]   IA5String,\n+   *   x400Address               [3]   ORAddress,\n+   *   directoryName             [4]   Name,\n+   *   ediPartyName              [5]   EDIPartyName,\n+   *   uniformResourceIdentifier [6]   IA5String,\n+   *   iPAddress                 [7]   OCTET STRING,\n+   *   registeredID              [8]   OBJECT IDENTIFIER\n+   * }\n+   * </pre></blockquote>\n+   *\n+   * <p>The returned collection contains one or more two-element Lists,\n+   * with the first object being an Integer representing the choice\n+   * above (with value 0 through 8) and the second being an (a) String\n+   * if the <code>GeneralName</code> is a rfc822Name, dNSName,\n+   * uniformResourceIdentifier, iPAddress, or registeredID, or (b) a\n+   * byte array of the DER encoded form for any others.\n+   *\n+   * @return The collection of alternative names, or null if there are\n+   * none.\n+   * @throws CertificateParsingException If the encoded extension cannot\n+   * be parsed.\n+   * @since JDK 1.4\n+   */\n+  public java.util.Collection getSubjectAlternativeNames()\n+    throws CertificateParsingException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n \n+  /**\n+   * Returns the alternative names for this certificate's issuer, or\n+   * null if there are none.\n+   *\n+   * <p>This is an X.509 extension with OID 2.5.29.18, and is defined by\n+   * the ASN.1 construction:\n+   *\n+   * <blockquote><pre>\n+   * IssuerAltNames ::= GeneralNames\n+   * </pre></blockquote>\n+   *\n+   * <p>The <code>GeneralNames</code> construct and the form of the\n+   * returned collection are the same as with {@link\n+   * #getSubjectAlternativeNames()}.\n+   *\n+   * @return The collection of alternative names, or null if there are\n+   * none.\n+   * @throws CertificateParsingException If the encoded extension cannot\n+   * be parsed.\n+   * @since JDK 1.4\n+   */\n+  public java.util.Collection getIssuerAlternativeNames()\n+    throws CertificateParsingException\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  /**\n+   * Returns the X.500 distinguished name of this certificate's subject.\n+   *\n+   * @return The subject's X.500 distinguished name.\n+   * @since JDK 1.4\n+   */\n+  public javax.security.auth.x500.X500Principal getSubjectX500Principal()\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+ \n+  /**\n+   * Returns the X.500 distinguished name of this certificate's issuer.\n+   *\n+   * @return The issuer's X.500 distinguished name.\n+   * @since JDK 1.4\n+   */\n+  public javax.security.auth.x500.X500Principal getIssuerX500Principal()\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n }"}, {"sha": "ef73371188a8e35c5f7c4723da08b8f42f312fba", "filename": "libjava/java/security/spec/DSAPublicKeySpec.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fspec%2FDSAPublicKeySpec.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjava%2Fsecurity%2Fspec%2FDSAPublicKeySpec.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fspec%2FDSAPublicKeySpec.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -62,7 +62,7 @@ public class DSAPublicKeySpec extends Object implements KeySpec\n      @param q the sub-prime\n      @param g the base\n   */\n-  public DSAPublicKeySpec(BigInteger x, BigInteger p, BigInteger q, BigInteger g) \n+  public DSAPublicKeySpec(BigInteger y, BigInteger p, BigInteger q, BigInteger g) \n   {\n     this.y = y;\n     this.p = p;"}, {"sha": "fc72e7b268e4cfa04dac2a09a7db5d3759fc4324", "filename": "libjava/javax/security/auth/x500/X500Principal.java", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43905ff30b187d8d1d1dee50e722f47fd8a93144/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fsecurity%2Fauth%2Fx500%2FX500Principal.java?ref=43905ff30b187d8d1d1dee50e722f47fd8a93144", "patch": "@@ -0,0 +1,147 @@\n+/* X500Principal.java -- X.500 principal.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.security.auth.x500;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.NotActiveException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import java.security.Principal;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+\n+import gnu.java.security.x509.X500DistinguishedName;\n+\n+public final class X500Principal implements Principal, Serializable\n+{\n+\n+  // Constants and fields.\n+  // ------------------------------------------------------------------------\n+\n+  public static final String CANONICAL = \"CANONICAL\";\n+\n+  public static final String RFC1779 = \"RFC1779\";\n+\n+  public static final String RFC2253 = \"RFC2253\";\n+\n+  private transient X500DistinguishedName name;\n+\n+  // Constructors.\n+  // ------------------------------------------------------------------------\n+\n+  public X500Principal(String name)\n+  {\n+    if (name == null)\n+      throw new NullPointerException();\n+    this.name = new X500DistinguishedName(name);\n+  }\n+\n+  public X500Principal(byte[] encoded)\n+  {\n+    try\n+      {\n+        name = new X500DistinguishedName(encoded);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new IllegalArgumentException(ioe.toString());\n+      }\n+  }\n+\n+  public X500Principal(InputStream encoded)\n+  {\n+    try\n+      {\n+        name = new X500DistinguishedName(encoded);\n+      }\n+    catch (IOException ioe)\n+      {\n+        throw new IllegalArgumentException(ioe.toString());\n+      }\n+  }\n+\n+  // Instance methods.\n+  // ------------------------------------------------------------------------\n+\n+  public boolean equals(Object o)\n+  {\n+    return ((X500Principal) o).name.equals(name);\n+  }\n+\n+  public byte[] getEncoded()\n+  {\n+    return name.getEncoded();\n+  }\n+\n+  public String getName()\n+  {\n+    return getName(RFC2253);\n+  }\n+\n+  public String getName(String format)\n+  {\n+    if (format.equalsIgnoreCase(RFC2253))\n+      return name.toRFC2253();\n+    else if (format.equalsIgnoreCase(RFC1779))\n+      return name.toRFC1779();\n+    else if (format.equalsIgnoreCase(CANONICAL))\n+      return name.toCanonical();\n+    throw new IllegalArgumentException(\"unsupported format \" + format);\n+  }\n+\n+  // Serialization methods.\n+  // ------------------------------------------------------------------------\n+\n+  private void writeObject(ObjectOutputStream out) throws IOException\n+  {\n+    out.writeObject(name.getEncoded());\n+  }\n+\n+  private void readObject(ObjectInputStream in)\n+    throws IOException, NotActiveException, ClassNotFoundException\n+  {\n+    byte[] buf = (byte[]) in.readObject();\n+    name = new X500DistinguishedName(buf);\n+  }\n+}"}]}