{"sha": "1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMzODRiZjE0MmM4MWJhYWFkN2YwNGM1ZDNmZGFlYmNiYWZjNWIwYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-09-14T20:17:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-09-14T20:17:24Z"}, "message": "builtins.c (expand_builtin_synchronize): Use gimple_build_asm_vec.\n\n\t* builtins.c (expand_builtin_synchronize): Use gimple_build_asm_vec.\n\t* cfgbuild.c (make_edges): Handle asm goto.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t* cfgrtl.c (patch_jump_insn): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_asm): Likewise.\n\t* gimple.c (gimple_build_asm_1): Add and use nlabels parameter.\n\t(gimple_build_asm_vec): Add and use labels parameter.\n\t(gimple_build_asm): Remove.\n\t(walk_gimple_asm): Walk labels too.\n\t* gimple.def (GIMPLE_ASM): Update docs.\n\t* gimple.h: Update decls.\n\t(struct gimple_statement_asm): Change nc to use unsigned char;\n\tadd nl member.\n\t(gimple_asm_nlabels): New.\n\t(gimple_asm_label_op, gimple_asm_set_label_op): New.\n\t* gimplify.c (gimplify_asm_expr): Copy labels from ASM_EXPR\n\tinto gimple_build_asm_vec.\n\t* jump.c (mark_jump_label_asm): New.\n\t(mark_jump_label): Use it.\n\t(redirect_jump_1): Handle asm goto.\n\t(invert_jump_1): Soft fail if X is null.\n\t* recog.c (extract_asm_operands): New.\n\t(asm_noperands): Use it; handle asm labels.\n\t(decode_asm_operands): Use extract_asm_operands.\n\t(asm_operand_ok): Properly handle empty string.\n\t* reg-stack.c (get_asm_operands_in_out): Rename from\n\tget_asm_operand_n_inputs; use extract_asm_operands; return both\n\tinputs and outputs by reference; update all callers.\n\t* rtl.def (ASM_OPERANDS): Add label vector as operand 6.\n\t* rtl.h (ASM_OPERANDS_LABEL_VEC): New.\n\t(ASM_OPERANDS_LABEL_LENGTH, ASM_OPERANDS_LABEL): New.\n\t(ASM_OPERANDS_SOURCE_LOCATION): Renumber.\n\t(extract_asm_operands): Declare.\n\t* stmt.c (expand_asm_operands): Add and use labels parameter.\n\t(check_unique_operand_names): Likewise.\n\t(resolve_asm_operand_names, resolve_operand_name_1): Likewise.\n\t(expand_asm_stmt): Handle asm labels.\n\t* tree-cfg.c (make_gimple_asm_edges): New.\n\t(make_edges): Use it.\n\t(cleanup_dead_labels): Handle asm labels.\n\t(is_ctrl_altering_stmt): Likewise.\n\t(gimple_redirect_edge_and_branch): Likewise.\n\t* tree.def (ASM_EXPR): Add 5th operand.\n\t* tree.h (ASM_LABELS): New.\n\t(resolve_asm_operand_names): Update decl.\n\n\t* c-parser.c (c_parser_asm_statement): Parse asm goto.\n\t(c_parser_asm_goto_operands): New.\n\t* c-tree.h (build_asm_expr): Update decl.\n\t* c-typeck.c (build_asm_expr): Add and use labels parameter.\n\t* doc/extend.texi: Document asm goto.\n\ngcc/ada/\n\t* gcc-interface/trans.c (Pragma_to_gnu): Use build5 for ASM_EXPR.\n\ngcc/cp/\n\t* cp-tree.h (finish_asm_stmt): Update decl.\n\t* parser.c (cp_parser_asm_definition): Parse asm goto.\n\t(cp_parser_asm_label_list): New.\n\t* pt.c (tsubst_copy_asm_operands): Don't recurse on labels.\n\t(tsubst_expr): Handle asm labels.\n\t* semantics.c (finish_asm_stmt): Add and use labels parameter.\n\ngcc/testsuite/\n\t* c-c++-common/asmgoto-1.c, c-c++-common/asmgoto-2.c,\n\tc-c++-common/asmgoto-3.c, gcc.c-torture/compile/asmgoto-1.c,\n\tgcc.dg/tree-ssa/asmgoto-1.c: New files.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r151701", "tree": {"sha": "d43d66a4da24c2d77ee8f88fc747f6a2f149435f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43d66a4da24c2d77ee8f88fc747f6a2f149435f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/comments", "author": null, "committer": null, "parents": [{"sha": "40c88b9403ef1e2b2e93ff70a5fb794916027665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40c88b9403ef1e2b2e93ff70a5fb794916027665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40c88b9403ef1e2b2e93ff70a5fb794916027665"}], "stats": {"total": 1586, "additions": 1157, "deletions": 429}, "files": [{"sha": "304f207a9636faec0c7a4ffa079cd652818c946b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1,3 +1,58 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+            Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtins.c (expand_builtin_synchronize): Use gimple_build_asm_vec.\n+\t* cfgbuild.c (make_edges): Handle asm goto.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t* cfgrtl.c (patch_jump_insn): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_asm): Likewise.\n+\t* gimple.c (gimple_build_asm_1): Add and use nlabels parameter.\n+\t(gimple_build_asm_vec): Add and use labels parameter.\n+\t(gimple_build_asm): Remove.\n+\t(walk_gimple_asm): Walk labels too.\n+\t* gimple.def (GIMPLE_ASM): Update docs.\n+\t* gimple.h: Update decls.\n+\t(struct gimple_statement_asm): Change nc to use unsigned char;\n+\tadd nl member.\n+\t(gimple_asm_nlabels): New.\n+\t(gimple_asm_label_op, gimple_asm_set_label_op): New.\n+\t* gimplify.c (gimplify_asm_expr): Copy labels from ASM_EXPR\n+\tinto gimple_build_asm_vec.\n+\t* jump.c (mark_jump_label_asm): New.\n+\t(mark_jump_label): Use it.\n+\t(redirect_jump_1): Handle asm goto.\n+\t(invert_jump_1): Soft fail if X is null.\n+\t* recog.c (extract_asm_operands): New.\n+\t(asm_noperands): Use it; handle asm labels.\n+\t(decode_asm_operands): Use extract_asm_operands.\n+\t(asm_operand_ok): Properly handle empty string.\n+\t* reg-stack.c (get_asm_operands_in_out): Rename from\n+\tget_asm_operand_n_inputs; use extract_asm_operands; return both\n+\tinputs and outputs by reference; update all callers.\n+\t* rtl.def (ASM_OPERANDS): Add label vector as operand 6.\n+\t* rtl.h (ASM_OPERANDS_LABEL_VEC): New.\n+\t(ASM_OPERANDS_LABEL_LENGTH, ASM_OPERANDS_LABEL): New.\n+\t(ASM_OPERANDS_SOURCE_LOCATION): Renumber.\n+\t(extract_asm_operands): Declare.\n+\t* stmt.c (expand_asm_operands): Add and use labels parameter.\n+\t(check_unique_operand_names): Likewise.\n+\t(resolve_asm_operand_names, resolve_operand_name_1): Likewise.\n+\t(expand_asm_stmt): Handle asm labels.\n+\t* tree-cfg.c (make_gimple_asm_edges): New.\n+\t(make_edges): Use it.\n+\t(cleanup_dead_labels): Handle asm labels.\n+\t(is_ctrl_altering_stmt): Likewise.\n+\t(gimple_redirect_edge_and_branch): Likewise.\n+\t* tree.def (ASM_EXPR): Add 5th operand.\n+\t* tree.h (ASM_LABELS): New.\n+\t(resolve_asm_operand_names): Update decl.\n+\n+\t* c-parser.c (c_parser_asm_statement): Parse asm goto.\n+\t(c_parser_asm_goto_operands): New.\n+\t* c-tree.h (build_asm_expr): Update decl.\n+\t* c-typeck.c (build_asm_expr): Add and use labels parameter.\n+\t* doc/extend.texi: Document asm goto.\n+\n 2009-09-14  Richard Henderson  <rth@redhat.com>\n \n \t* except.h: Update declarations."}, {"sha": "cb38dab12f0856fc1bfa000a5a22918eed7f3fe5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1,3 +1,7 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc-interface/trans.c (Pragma_to_gnu): Use build5 for ASM_EXPR.\n+\n 2009-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_dbug.ads (Packed Array Encoding): Document the new encoding for"}, {"sha": "5bce21a7063953898d50b81274791db79a76f0be", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1026,14 +1026,14 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t  asm_constraint = build_string (strlen (comment), comment);\n \t  free (comment);\n #endif\n-\t  gnu_expr = build4 (ASM_EXPR, void_type_node,\n+\t  gnu_expr = build5 (ASM_EXPR, void_type_node,\n \t\t\t     asm_constraint,\n \t\t\t     NULL_TREE,\n \t\t\t     tree_cons\n \t\t\t     (build_tree_list (NULL_TREE,\n \t\t\t\t\t       build_string (1, \"g\")),\n \t\t\t      gnu_expr, NULL_TREE),\n-\t\t\t     NULL_TREE);\n+\t\t\t     NULL_TREE, NULL_TREE);\n \t  ASM_VOLATILE_P (gnu_expr) = 1;\n \t  set_expr_location_from_node (gnu_expr, gnat_node);\n \t  append_to_statement_list (gnu_expr, &gnu_result);\n@@ -5088,9 +5088,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      TREE_VALUE (tail) = input;\n \t    }\n \n-\t  gnu_result = build4 (ASM_EXPR,  void_type_node,\n+\t  gnu_result = build5 (ASM_EXPR,  void_type_node,\n \t\t\t       gnu_template, gnu_outputs,\n-\t\t\t       gnu_inputs, gnu_clobbers);\n+\t\t\t       gnu_inputs, gnu_clobbers, NULL_TREE);\n \t  ASM_VOLATILE_P (gnu_result) = Is_Asm_Volatile (gnat_node);\n \t}\n       else"}, {"sha": "8ef96070c3ad3c87652c98bfa1a959c725b87290", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -6236,6 +6236,7 @@ static void\n expand_builtin_synchronize (void)\n {\n   gimple x;\n+  VEC (tree, gc) *v_clobbers;\n \n #ifdef HAVE_memory_barrier\n   if (HAVE_memory_barrier)\n@@ -6253,8 +6254,10 @@ expand_builtin_synchronize (void)\n \n   /* If no explicit memory barrier instruction is available, create an\n      empty asm stmt with a memory clobber.  */\n-  x = gimple_build_asm (\"\", 0, 0, 1,\n-\t\t\ttree_cons (NULL, build_string (6, \"memory\"), NULL));\n+  v_clobbers = VEC_alloc (tree, gc, 1);\n+  VEC_quick_push (tree, v_clobbers,\n+\t\t  tree_cons (NULL, build_string (6, \"memory\"), NULL));\n+  x = gimple_build_asm_vec (\"\", NULL, NULL, v_clobbers, NULL);\n   gimple_asm_set_volatile (x, true);\n   expand_asm_stmt (x);\n }"}, {"sha": "d9ea159c4e57649c27a5885aaf8c22af44cc70b1", "filename": "gcc/c-parser.c", "status": "modified", "additions": 124, "deletions": 66, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -903,6 +903,7 @@ static void c_parser_do_statement (c_parser *);\n static void c_parser_for_statement (c_parser *);\n static tree c_parser_asm_statement (c_parser *);\n static tree c_parser_asm_operands (c_parser *, bool);\n+static tree c_parser_asm_goto_operands (c_parser *);\n static tree c_parser_asm_clobbers (c_parser *);\n static struct c_expr c_parser_expr_no_commas (c_parser *, struct c_expr *);\n static struct c_expr c_parser_conditional_expression (c_parser *,\n@@ -4226,22 +4227,29 @@ c_parser_for_statement (c_parser *parser)\n \n    asm-statement:\n      asm type-qualifier[opt] ( asm-argument ) ;\n+     asm type-qualifier[opt] goto ( asm-goto-argument ) ;\n \n    asm-argument:\n      asm-string-literal\n      asm-string-literal : asm-operands[opt]\n      asm-string-literal : asm-operands[opt] : asm-operands[opt]\n-     asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers\n+     asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers[opt]\n+\n+   asm-goto-argument:\n+     asm-string-literal : : asm-operands[opt] : asm-clobbers[opt] \\\n+       : asm-goto-operands\n \n    Qualifiers other than volatile are accepted in the syntax but\n    warned for.  */\n \n static tree\n c_parser_asm_statement (c_parser *parser)\n {\n-  tree quals, str, outputs, inputs, clobbers, ret;\n-  bool simple;\n+  tree quals, str, outputs, inputs, clobbers, labels, ret;\n+  bool simple, is_goto;\n   location_t asm_loc = c_parser_peek_token (parser)->location;\n+  int section, nsections;\n+\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))\n@@ -4261,85 +4269,96 @@ c_parser_asm_statement (c_parser *parser)\n     }\n   else\n     quals = NULL_TREE;\n+\n+  is_goto = false;\n+  if (c_parser_next_token_is_keyword (parser, RID_GOTO))\n+    {\n+      c_parser_consume_token (parser);\n+      is_goto = true;\n+    }\n+\n   /* ??? Follow the C++ parser rather than using the\n      lex_untranslated_string kludge.  */\n   parser->lex_untranslated_string = true;\n+  ret = NULL;\n+\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-    {\n-      parser->lex_untranslated_string = false;\n-      return NULL_TREE;\n-    }\n+    goto error;\n+\n   str = c_parser_asm_string_literal (parser);\n   if (str == NULL_TREE)\n-    {\n-      parser->lex_untranslated_string = false;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-      return NULL_TREE;\n-    }\n-  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-    {\n-      simple = true;\n-      outputs = NULL_TREE;\n-      inputs = NULL_TREE;\n-      clobbers = NULL_TREE;\n-      goto done_asm;\n-    }\n-  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n-    {\n-      parser->lex_untranslated_string = false;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-      return NULL_TREE;\n-    }\n-  simple = false;\n-  /* Parse outputs.  */\n-  if (c_parser_next_token_is (parser, CPP_COLON)\n-      || c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-    outputs = NULL_TREE;\n-  else\n-    outputs = c_parser_asm_operands (parser, false);\n-  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-    {\n-      inputs = NULL_TREE;\n-      clobbers = NULL_TREE;\n-      goto done_asm;\n-    }\n-  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n-    {\n-      parser->lex_untranslated_string = false;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-      return NULL_TREE;\n-    }\n-  /* Parse inputs.  */\n-  if (c_parser_next_token_is (parser, CPP_COLON)\n-      || c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-    inputs = NULL_TREE;\n-  else\n-    inputs = c_parser_asm_operands (parser, true);\n-  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-    {\n-      clobbers = NULL_TREE;\n-      goto done_asm;\n-    }\n-  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n-    {\n-      parser->lex_untranslated_string = false;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-      return NULL_TREE;\n+    goto error_close_paren;\n+\n+  simple = true;\n+  outputs = NULL_TREE;\n+  inputs = NULL_TREE;\n+  clobbers = NULL_TREE;\n+  labels = NULL_TREE;\n+\n+  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN) && !is_goto)\n+    goto done_asm;\n+\n+  /* Parse each colon-delimited section of operands.  */\n+  nsections = 3 + is_goto;\n+  for (section = 0; section < nsections; ++section)\n+    {\n+      if (!c_parser_require (parser, CPP_COLON,\n+\t\t\t     is_goto\n+\t\t\t     ? \"expected %<:%>\"\n+\t\t\t     : \"expected %<:%> or %<)%>\"))\n+\tgoto error_close_paren;\n+\n+      /* Once past any colon, we're no longer a simple asm.  */\n+      simple = false;\n+\n+      if ((!c_parser_next_token_is (parser, CPP_COLON)\n+\t   && !c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\t  || section == 3)\n+\tswitch (section)\n+\t  {\n+\t  case 0:\n+\t    /* For asm goto, we don't allow output operands, but reserve\n+\t       the slot for a future extension that does allow them.  */\n+\t    if (!is_goto)\n+\t      outputs = c_parser_asm_operands (parser, false);\n+\t    break;\n+\t  case 1:\n+\t    inputs = c_parser_asm_operands (parser, true);\n+\t    break;\n+\t  case 2:\n+\t    clobbers = c_parser_asm_clobbers (parser);\n+\t    break;\n+\t  case 3:\n+\t    labels = c_parser_asm_goto_operands (parser);\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\n+      if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN) && !is_goto)\n+\tgoto done_asm;\n     }\n-  /* Parse clobbers.  */\n-  clobbers = c_parser_asm_clobbers (parser);\n+\n  done_asm:\n-  parser->lex_untranslated_string = false;\n   if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-      return NULL_TREE;\n+      goto error;\n     }\n+\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n+\n   ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,\n-\t\t\t\t\t       clobbers, simple));\n+\t\t\t\t\t       clobbers, labels, simple));\n+\n+ error:\n+  parser->lex_untranslated_string = false;\n   return ret;\n+\n+ error_close_paren:\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+  goto error;\n }\n \n /* Parse asm operands, a GNU extension.  If CONVERT_P (for inputs but\n@@ -4441,6 +4460,45 @@ c_parser_asm_clobbers (c_parser *parser)\n   return list;\n }\n \n+/* Parse asm goto labels, a GNU extension.\n+ \n+   asm-goto-operands:\n+     identifier\n+     asm-goto-operands , identifier\n+*/\n+\n+static tree\n+c_parser_asm_goto_operands (c_parser *parser)\n+{\n+  tree list = NULL_TREE;\n+  while (true)\n+    {\n+      tree name, label;\n+\n+      if (c_parser_next_token_is (parser, CPP_NAME))\n+\t{\n+\t  c_token *tok = c_parser_peek_token (parser);\n+\t  name = tok->value;\n+\t  label = lookup_label_for_goto (tok->location, name);\n+\t  c_parser_consume_token (parser);\n+\t  TREE_USED (label) = 1;\n+\t}\n+      else\n+\t{\n+\t  c_parser_error (parser, \"expected identifier\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      name = build_string (IDENTIFIER_LENGTH (name),\n+\t\t\t   IDENTIFIER_POINTER (name));\n+      list = tree_cons (name, label, list);\n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+      else\n+\treturn nreverse (list);\n+    }\n+}\n+\n /* Parse an expression other than a compound expression; that is, an\n    assignment expression (C90 6.3.16, C99 6.5.16).  If AFTER is not\n    NULL then it is an Objective-C message expression which is the"}, {"sha": "c7490e461a3673c8428423666df6bcf8abdd8f14", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -541,7 +541,7 @@ extern tree build_compound_literal (location_t, tree, tree, bool);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n extern tree c_start_case (location_t, location_t, tree);\n extern void c_finish_case (tree);\n-extern tree build_asm_expr (location_t, tree, tree, tree, tree, bool);\n+extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool);\n extern tree build_asm_stmt (tree, tree);\n extern int c_types_compatible_p (tree, tree);\n extern tree c_begin_compound_stmt (bool);"}, {"sha": "411b9ec2aa2f1a00fc9d78c41e27938949604712", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -7920,7 +7920,7 @@ build_asm_stmt (tree cv_qualifier, tree args)\n    are subtly different.  We use a ASM_EXPR node to represent this.  */\n tree\n build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n-\t\ttree clobbers, bool simple)\n+\t\ttree clobbers, tree labels, bool simple)\n {\n   tree tail;\n   tree args;\n@@ -7934,7 +7934,7 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n   noutputs = list_length (outputs);\n   oconstraints = (const char **) alloca (noutputs * sizeof (const char *));\n \n-  string = resolve_asm_operand_names (string, outputs, inputs);\n+  string = resolve_asm_operand_names (string, outputs, inputs, labels);\n \n   /* Remove output conversions that change the type but not the mode.  */\n   for (i = 0, tail = outputs; tail; ++i, tail = TREE_CHAIN (tail))\n@@ -8004,7 +8004,11 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n       TREE_VALUE (tail) = input;\n     }\n \n-  args = build_stmt (loc, ASM_EXPR, string, outputs, inputs, clobbers);\n+  /* ASMs with labels cannot have outputs.  This should have been\n+     enforced by the parser.  */\n+  gcc_assert (outputs == NULL || labels == NULL);\n+\n+  args = build_stmt (loc, ASM_EXPR, string, outputs, inputs, clobbers, labels);\n \n   /* asm statements without outputs, including simple ones, are treated\n      as volatile.  */"}, {"sha": "b5ddadd2ac9402f6012f2566cf238966ae9dc805", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -303,6 +303,15 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t  else if (returnjump_p (insn))\n \t    cached_make_edge (edge_cache, bb, EXIT_BLOCK_PTR, 0);\n \n+\t  /* Recognize asm goto and do the right thing.  */\n+\t  else if ((tmp = extract_asm_operands (PATTERN (insn))) != NULL)\n+\t    {\n+\t      int i, n = ASM_OPERANDS_LABEL_LENGTH (tmp);\n+\t      for (i = 0; i < n; ++i)\n+\t\tmake_label_edge (edge_cache, bb,\n+\t\t\t\t XEXP (ASM_OPERANDS_LABEL (tmp, i), 0), 0);\n+\t    }\n+\n \t  /* Otherwise, we have a plain conditional or unconditional jump.  */\n \t  else\n \t    {"}, {"sha": "bc8ed8b7f32373c59fddcaf304546c86c50d162b", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -848,6 +848,15 @@ fixup_reorder_chain (void)\n \t\t  continue;\n \t\t}\n \t    }\n+\t  else if (extract_asm_operands (PATTERN (bb_end_insn)) != NULL)\n+\t    {\n+\t      /* If the old fallthru is still next, nothing to do.  */\n+\t      if (bb->aux == e_fall->dest\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      /* Otherwise we'll have to use the fallthru fixup below.  */\n+\t    }\n \t  else\n \t    {\n \t      /* Otherwise we have some return, switch or computed"}, {"sha": "4146b146977e7e777fa522be688414a1d495e5a4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -956,6 +956,45 @@ patch_jump_insn (rtx insn, rtx old_label, basic_block new_bb)\n \t  ++LABEL_NUSES (new_label);\n \t}\n     }\n+  else if ((tmp = extract_asm_operands (PATTERN (insn))) != NULL)\n+    {\n+      int i, n = ASM_OPERANDS_LABEL_LENGTH (tmp);\n+      rtx new_label, note;\n+\n+      if (new_bb == EXIT_BLOCK_PTR)\n+\treturn false;\n+      new_label = block_label (new_bb);\n+\n+      for (i = 0; i < n; ++i)\n+\t{\n+\t  rtx old_ref = ASM_OPERANDS_LABEL (tmp, i);\n+\t  gcc_assert (GET_CODE (old_ref) == LABEL_REF);\n+\t  if (XEXP (old_ref, 0) == old_label)\n+\t    {\n+\t      ASM_OPERANDS_LABEL (tmp, i)\n+\t\t= gen_rtx_LABEL_REF (Pmode, new_label);\n+\t      --LABEL_NUSES (old_label);\n+\t      ++LABEL_NUSES (new_label);\n+\t    }\n+\t}\n+\n+      if (JUMP_LABEL (insn) == old_label)\n+\t{\n+\t  JUMP_LABEL (insn) = new_label;\n+\t  note = find_reg_note (insn, REG_LABEL_TARGET, new_label);\n+\t  if (note)\n+\t    remove_note (insn, note);\n+\t}\n+      else\n+\t{\n+\t  note = find_reg_note (insn, REG_LABEL_TARGET, old_label);\n+\t  if (note)\n+\t    remove_note (insn, note);\n+\t  if (JUMP_LABEL (insn) != new_label\n+\t      && !find_reg_note (insn, REG_LABEL_TARGET, new_label))\n+\t    add_reg_note (insn, REG_LABEL_TARGET, new_label);\n+\t}\n+    }\n   else\n     {\n       /* ?? We may play the games with moving the named labels from"}, {"sha": "93b90b5c0ee57eea6ba1e78c13587c319e1a08fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1,3 +1,13 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+            Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (finish_asm_stmt): Update decl.\n+\t* parser.c (cp_parser_asm_definition): Parse asm goto.\n+\t(cp_parser_asm_label_list): New.\n+\t* pt.c (tsubst_copy_asm_operands): Don't recurse on labels.\n+\t(tsubst_expr): Handle asm labels.\n+\t* semantics.c (finish_asm_stmt): Add and use labels parameter.\n+\n 2009-09-14  Richard Henderson  <rth@redhat.com>\n \n \t* except.c (init_exception_processing): Don't call"}, {"sha": "e8db635fda7bb56e5546d07bbed7c07e922b819b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -4820,7 +4820,8 @@ enum {\n extern tree begin_compound_stmt\t\t\t(unsigned int);\n \n extern void finish_compound_stmt\t\t(tree);\n-extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree);\n+extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree,\n+\t\t\t\t\t\t tree);\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n extern tree finish_parenthesized_expr\t\t(tree);"}, {"sha": "55effed939e8d4d69eb83e65039ea02d21a5cd4c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1859,6 +1859,8 @@ static tree cp_parser_asm_operand_list\n   (cp_parser *);\n static tree cp_parser_asm_clobber_list\n   (cp_parser *);\n+static tree cp_parser_asm_label_list\n+  (cp_parser *);\n static tree cp_parser_attributes_opt\n   (cp_parser *);\n static tree cp_parser_attribute_list\n@@ -12531,7 +12533,10 @@ cp_parser_using_directive (cp_parser* parser)\n \t\t\t  : asm-operand-list [opt] ) ;\n      asm volatile [opt] ( string-literal : asm-operand-list [opt]\n \t\t\t  : asm-operand-list [opt]\n-\t\t\t  : asm-operand-list [opt] ) ;  */\n+\t\t\t  : asm-clobber-list [opt] ) ;\n+     asm volatile [opt] goto ( string-literal : : asm-operand-list [opt]\n+\t\t\t       : asm-clobber-list [opt]\n+\t\t\t       : asm-goto-list ) ;  */\n \n static void\n cp_parser_asm_definition (cp_parser* parser)\n@@ -12540,11 +12545,14 @@ cp_parser_asm_definition (cp_parser* parser)\n   tree outputs = NULL_TREE;\n   tree inputs = NULL_TREE;\n   tree clobbers = NULL_TREE;\n+  tree labels = NULL_TREE;\n   tree asm_stmt;\n   bool volatile_p = false;\n   bool extended_p = false;\n   bool invalid_inputs_p = false;\n   bool invalid_outputs_p = false;\n+  bool goto_p = false;\n+  const char *missing = NULL;\n \n   /* Look for the `asm' keyword.  */\n   cp_parser_require_keyword (parser, RID_ASM, \"%<asm%>\");\n@@ -12557,6 +12565,15 @@ cp_parser_asm_definition (cp_parser* parser)\n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n+  if (cp_parser_allow_gnu_extensions_p (parser)\n+      && parser->in_function_body\n+      && cp_lexer_next_token_is_keyword (parser->lexer, RID_GOTO))\n+    {\n+      /* Remember that we saw the `goto' keyword.  */\n+      goto_p = true;\n+      /* Consume the token.  */\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n   /* Look for the opening `('.  */\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return;\n@@ -12581,6 +12598,7 @@ cp_parser_asm_definition (cp_parser* parser)\n     {\n       bool inputs_p = false;\n       bool clobbers_p = false;\n+      bool labels_p = false;\n \n       /* The extended syntax was used.  */\n       extended_p = true;\n@@ -12596,7 +12614,8 @@ cp_parser_asm_definition (cp_parser* parser)\n \t      && cp_lexer_next_token_is_not (parser->lexer,\n \t\t\t\t\t     CPP_SCOPE)\n \t      && cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t     CPP_CLOSE_PAREN))\n+\t\t\t\t\t     CPP_CLOSE_PAREN)\n+\t      && !goto_p)\n \t    outputs = cp_parser_asm_operand_list (parser);\n \n \t    if (outputs == error_mark_node)\n@@ -12617,6 +12636,8 @@ cp_parser_asm_definition (cp_parser* parser)\n \t  /* Parse the output-operands.  */\n \t  if (cp_lexer_next_token_is_not (parser->lexer,\n \t\t\t\t\t  CPP_COLON)\n+\t      && cp_lexer_next_token_is_not (parser->lexer,\n+\t\t\t\t\t     CPP_SCOPE)\n \t      && cp_lexer_next_token_is_not (parser->lexer,\n \t\t\t\t\t     CPP_CLOSE_PAREN))\n \t    inputs = cp_parser_asm_operand_list (parser);\n@@ -12632,16 +12653,41 @@ cp_parser_asm_definition (cp_parser* parser)\n       if (clobbers_p\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n \t{\n+\t  clobbers_p = true;\n \t  /* Consume the `:' or `::'.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the clobbers.  */\n \t  if (cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t  CPP_CLOSE_PAREN))\n+\t\t\t\t\t  CPP_COLON)\n+\t      && cp_lexer_next_token_is_not (parser->lexer,\n+\t\t\t\t\t     CPP_CLOSE_PAREN))\n \t    clobbers = cp_parser_asm_clobber_list (parser);\n \t}\n+      else if (goto_p\n+\t       && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n+\t/* The labels are coming next.  */\n+\tlabels_p = true;\n+\n+      /* Look for labels.  */\n+      if (labels_p\n+\t  || (goto_p && cp_lexer_next_token_is (parser->lexer, CPP_COLON)))\n+\t{\n+\t  labels_p = true;\n+\t  /* Consume the `:' or `::'.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  /* Parse the labels.  */\n+\t  labels = cp_parser_asm_label_list (parser);\n+\t}\n+\n+      if (goto_p && !labels_p)\n+\tmissing = clobbers_p ? \"%<:%>\" : \"%<:%> or %<::%>\";\n     }\n+  else if (goto_p)\n+    missing = \"%<:%> or %<::%>\";\n+\n   /* Look for the closing `)'.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\"))\n+  if (!cp_parser_require (parser, missing ? CPP_COLON : CPP_CLOSE_PAREN,\n+\t\t\t  missing ? missing : \"%<)%>\"))\n     cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t   /*consume_paren=*/true);\n   cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n@@ -12652,7 +12698,7 @@ cp_parser_asm_definition (cp_parser* parser)\n       if (parser->in_function_body)\n \t{\n \t  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,\n-\t\t\t\t      inputs, clobbers);\n+\t\t\t\t      inputs, clobbers, labels);\n \t  /* If the extended syntax was not used, mark the ASM_EXPR.  */\n \t  if (!extended_p)\n \t    {\n@@ -16866,6 +16912,49 @@ cp_parser_asm_clobber_list (cp_parser* parser)\n   return clobbers;\n }\n \n+/* Parse an asm-label-list.\n+\n+   asm-label-list:\n+     identifier\n+     asm-label-list , identifier\n+\n+   Returns a TREE_LIST, indicating the labels in the order that they\n+   appeared.  The TREE_VALUE of each node is a label.  */\n+\n+static tree\n+cp_parser_asm_label_list (cp_parser* parser)\n+{\n+  tree labels = NULL_TREE;\n+\n+  while (true)\n+    {\n+      tree identifier, label, name;\n+\n+      /* Look for the identifier.  */\n+      identifier = cp_parser_identifier (parser);\n+      if (!error_operand_p (identifier))\n+        {\n+\t  label = lookup_label (identifier);\n+\t  if (TREE_CODE (label) == LABEL_DECL)\n+\t    {\n+\t      TREE_USED (label) = 1;\n+\t      check_goto (label);\n+\t      name = build_string (IDENTIFIER_LENGTH (identifier),\n+\t\t\t\t   IDENTIFIER_POINTER (identifier));\n+\t      labels = tree_cons (name, label, labels);\n+\t    }\n+\t}\n+      /* If the next token is not a `,', then the list is\n+\t complete.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\tbreak;\n+      /* Consume the `,' token.  */\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  return nreverse (labels);\n+}\n+\n /* Parse an (optional) series of attributes.\n \n    attributes:"}, {"sha": "9f094a3959ef61a4c4e11042153d48a60bd609d4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -10818,7 +10818,7 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n   if (purpose)\n     purpose = RECUR (purpose);\n   value = TREE_VALUE (t);\n-  if (value)\n+  if (value && TREE_CODE (value) != LABEL_DECL)\n     value = RECUR (value);\n   chain = TREE_CHAIN (t);\n   if (chain && chain != void_type_node)\n@@ -11210,7 +11210,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t RECUR (ASM_STRING (t)),\n \t tsubst_copy_asm_operands (ASM_OUTPUTS (t), args, complain, in_decl),\n \t tsubst_copy_asm_operands (ASM_INPUTS (t), args, complain, in_decl),\n-\t tsubst_copy_asm_operands (ASM_CLOBBERS (t), args, complain, in_decl));\n+\t tsubst_copy_asm_operands (ASM_CLOBBERS (t), args, complain, in_decl),\n+\t tsubst_copy_asm_operands (ASM_LABELS (t), args, complain, in_decl));\n       {\n \ttree asm_expr = tmp;\n \tif (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)"}, {"sha": "6b741b3ebe5e46f5ffd96031f74a1b28232e4db4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1200,12 +1200,13 @@ finish_compound_stmt (tree stmt)\n }\n \n /* Finish an asm-statement, whose components are a STRING, some\n-   OUTPUT_OPERANDS, some INPUT_OPERANDS, and some CLOBBERS.  Also note\n-   whether the asm-statement should be considered volatile.  */\n+   OUTPUT_OPERANDS, some INPUT_OPERANDS, some CLOBBERS and some\n+   LABELS.  Also note whether the asm-statement should be\n+   considered volatile.  */\n \n tree\n finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n-\t\t tree input_operands, tree clobbers)\n+\t\t tree input_operands, tree clobbers, tree labels)\n {\n   tree r;\n   tree t;\n@@ -1223,7 +1224,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n       oconstraints = (const char **) alloca (noutputs * sizeof (char *));\n \n       string = resolve_asm_operand_names (string, output_operands,\n-\t\t\t\t\t  input_operands);\n+\t\t\t\t\t  input_operands, labels);\n \n       for (i = 0, t = output_operands; t; t = TREE_CHAIN (t), ++i)\n \t{\n@@ -1309,7 +1310,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \n   r = build_stmt (input_location, ASM_EXPR, string,\n \t\t  output_operands, input_operands,\n-\t\t  clobbers);\n+\t\t  clobbers, labels);\n   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;\n   r = maybe_cleanup_point_expr_void (r);\n   return add_stmt (r);"}, {"sha": "22d9f6e3cc2249143029ab2e744b7d3eb4ef0f6b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -5251,7 +5251,7 @@ and most Unix assemblers do.\n Speaking of labels, jumps from one @code{asm} to another are not\n supported.  The compiler's optimizers do not know about these jumps, and\n therefore they cannot take account of them when deciding how to\n-optimize.\n+optimize.  @xref{Extended asm with goto}.\n \n @cindex macros containing @code{asm}\n Usually the most convenient way to use these @code{asm} instructions is to\n@@ -5350,6 +5350,94 @@ For reasons similar to those described above, it is not possible to give\n an assembler instruction access to the condition code left by previous\n instructions.\n \n+@anchor{Extended asm with goto}\n+As of GCC version 4.5, @code{asm goto} may be used to have the assembly\n+jump to one or more C labels.  In this form, a fifth section after the\n+clobber list contains a list of all C labels to which the assembly may jump.\n+Each label operand is implicitly self-named.  The @code{asm} is also assumed\n+to fall through to the next statement.\n+\n+This form of @code{asm} is restricted to not have outputs.  This is due\n+to a internal restriction in the compiler that control transfer instructions\n+cannot have outputs.  This restriction on @code{asm goto} may be lifted\n+in some future version of the compiler.  In the mean time, @code{asm goto}\n+may include a memory clobber, and so leave outputs in memory.\n+\n+@smallexample\n+int frob(int x)\n+@{\n+  int y;\n+  asm goto (\"frob %%r5, %1; jc %l[error]; mov (%2), %%r5\"\n+            : : \"r\"(x), \"r\"(&y) : \"r5\", \"memory\" : error);\n+  return y;\n+ error:\n+  return -1;\n+@}\n+@end smallexample\n+\n+In this (inefficient) example, the @code{frob} instruction sets the\n+carry bit to indicate an error.  The @code{jc} instruction detects\n+this and branches to the @code{error} label.  Finally, the output \n+of the @code{frob} instruction (@code{%r5}) is stored into the memory\n+for variable @code{y}, which is later read by the @code{return} statement.\n+\n+@smallexample\n+void doit(void)\n+@{\n+  int i = 0;\n+  asm goto (\"mfsr %%r1, 123; jmp %%r1;\"\n+            \".pushsection doit_table;\"\n+\t    \".long %l0, %l1, %l2, %l3;\"\n+\t    \".popsection\"\n+\t    : : : \"r1\" : label1, label2, label3, label4);\n+  __builtin_unreachable ();\n+\n+ label1:\n+  f1();\n+  return;\n+ label2:\n+  f2();\n+  return;\n+ label3:\n+  i = 1;\n+ label4:\n+  f3(i);\n+@}\n+@end smallexample\n+\n+In this (also inefficient) example, the @code{mfsr} instruction reads\n+an address from some out-of-band machine register, and the following\n+@code{jmp} instruction branches to that address.  The address read by\n+the @code{mfsr} instruction is assumed to have been previously set via\n+some application-specific mechanism to be one of the four values stored\n+in the @code{doit_table} section.  Finally, the @code{asm} is followed\n+by a call to @code{__builtin_unreachable} to indicate that the @code{asm}\n+does not in fact fall through.\n+\n+@smallexample\n+#define TRACE1(NUM)                         \\\n+  do @{                                      \\\n+    asm goto (\"0: nop;\"                     \\\n+              \".pushsection trace_table;\"   \\\n+              \".long 0b, %l0;\"              \\\n+              \".popsection\"                 \\\n+              : : : : trace#NUM);           \\\n+    if (0) @{ trace#NUM: trace(); @}          \\\n+  @} while (0)\n+#define TRACE  TRACE1(__COUNTER__)\n+@end smallexample\n+\n+In this example (which in fact inspired the @code{asm goto} feature)\n+we want on rare occasions to call the @code{trace} function; on other\n+occasions we'd like to keep the overhead to the absolute minimum.\n+The normal code path consists of a single @code{nop} instruction.\n+However, we record the address of this @code{nop} together with the\n+address of a label that calls the @code{trace} function.  This allows\n+the @code{nop} instruction to be patched at runtime to be an \n+unconditional branch to the stored label.  It is assumed that an\n+optimizing compiler will move the labeled block out of line, to\n+optimize the fall through path from the @code{asm}.\n+\n If you are writing a header file that should be includable in ISO C\n programs, write @code{__asm__} instead of @code{asm}.  @xref{Alternate\n Keywords}."}, {"sha": "3d3134beaa60863a9dc8872ebc6c5d23721501e9", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 128, "deletions": 66, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1101,89 +1101,151 @@ dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n static void\n dump_gimple_asm (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n-  unsigned int i;\n+  unsigned int i, n, f, fields;\n \n   if (flags & TDF_RAW)\n-    dump_gimple_fmt (buffer, spc, flags, \"%G <%+STRING <%n%s%n>\", gs,\n-                     gimple_asm_string (gs));\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+STRING <%n%s%n>\", gs,\n+                       gimple_asm_string (gs));\n+\n+      n = gimple_asm_noutputs (gs);\n+      if (n)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"OUTPUT: \");\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      dump_generic_node (buffer, gimple_asm_output_op (gs, i),\n+\t\t\t\t spc, flags, false);\n+\t      if (i < n - 1)\n+\t\tpp_string (buffer, \", \");\n+\t    }\n+\t}\n+\n+      n = gimple_asm_ninputs (gs);\n+      if (n)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"INPUT: \");\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      dump_generic_node (buffer, gimple_asm_input_op (gs, i),\n+\t\t\t\t spc, flags, false);\n+\t      if (i < n - 1)\n+\t\tpp_string (buffer, \", \");\n+\t    }\n+\t}\n+\n+      n = gimple_asm_nclobbers (gs);\n+      if (n)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"CLOBBER: \");\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      dump_generic_node (buffer, gimple_asm_clobber_op (gs, i),\n+\t\t\t\t spc, flags, false);\n+\t      if (i < n - 1)\n+\t\tpp_string (buffer, \", \");\n+\t    }\n+\t}\n+\n+      n = gimple_asm_nlabels (gs);\n+      if (n)\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_string (buffer, \"LABEL: \");\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      dump_generic_node (buffer, gimple_asm_label_op (gs, i),\n+\t\t\t\t spc, flags, false);\n+\t      if (i < n - 1)\n+\t\tpp_string (buffer, \", \");\n+\t    }\n+\t}\n+\n+      newline_and_indent (buffer, spc);\n+      pp_character (buffer, '>');\n+    }\n   else\n     {\n       pp_string (buffer, \"__asm__\");\n       if (gimple_asm_volatile_p (gs))\n \tpp_string (buffer, \" __volatile__\");\n+      if (gimple_asm_nlabels (gs))\n+\tpp_string (buffer, \" goto\");\n       pp_string (buffer, \"(\\\"\");\n       pp_string (buffer, gimple_asm_string (gs));\n       pp_string (buffer, \"\\\"\");\n-    }\n \n-  if (gimple_asm_ninputs (gs)\n-     || gimple_asm_noutputs (gs) \n-     || gimple_asm_nclobbers (gs))\n-    {\n-      if (gimple_asm_noutputs (gs))\n-        {\n-          if (flags & TDF_RAW)\n-            {\n-              newline_and_indent (buffer, spc + 2);\n-              pp_string (buffer, \"OUTPUT: \");\n-            }\n-          else\n-            pp_string (buffer, \" : \");\n-        }\n+      if (gimple_asm_nlabels (gs))\n+\tfields = 4;\n+      else if (gimple_asm_nclobbers (gs))\n+\tfields = 3;\n+      else if (gimple_asm_ninputs (gs))\n+\tfields = 2;\n+      else if (gimple_asm_noutputs (gs))\n+\tfields = 1;\n+      else\n+\tfields = 0;\n \n-      for (i = 0; i < gimple_asm_noutputs (gs); i++)\n-        {\n-          dump_generic_node (buffer, gimple_asm_output_op (gs, i), spc, flags,\n-                             false);\n-          if ( i < gimple_asm_noutputs (gs) -1)\n-            pp_string (buffer, \", \");\n-        }\n+      for (f = 0; f < fields; ++f)\n+\t{\n+\t  pp_string (buffer, \" : \");\n \n-      if (gimple_asm_ninputs (gs))\n-        {\n-          if (flags & TDF_RAW)\n-            {\n-              newline_and_indent (buffer, spc + 2);\n-              pp_string (buffer, \"INPUT: \");\n-            }\n-          else\n-            pp_string (buffer, \" : \");\n-        }\n+\t  switch (f)\n+\t    {\n+\t    case 0:\n+\t      n = gimple_asm_noutputs (gs);\n+\t      for (i = 0; i < n; i++)\n+\t\t{\n+\t\t  dump_generic_node (buffer, gimple_asm_output_op (gs, i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  if (i < n - 1)\n+\t\t    pp_string (buffer, \", \");\n+\t\t}\n+\t      break;\n \n-      for (i = 0; i < gimple_asm_ninputs (gs); i++)\n-        {\n-          dump_generic_node (buffer, gimple_asm_input_op (gs, i), spc, flags,\n-                             false);\n-          if (i < gimple_asm_ninputs (gs) -1)\n-            pp_string (buffer, \" : \");\n-        }\n+\t    case 1:\n+\t      n = gimple_asm_ninputs (gs);\n+\t      for (i = 0; i < n; i++)\n+\t\t{\n+\t\t  dump_generic_node (buffer, gimple_asm_input_op (gs, i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  if (i < n - 1)\n+\t\t    pp_string (buffer, \", \");\n+\t\t}\n+\t      break;\n \n-      if (gimple_asm_nclobbers (gs))\n-        {\n-          if (flags & TDF_RAW)\n-            {\n-              newline_and_indent (buffer, spc + 2);\n-              pp_string (buffer, \"CLOBBER: \");\n-            }\n-          else\n-            pp_string (buffer, \" : \");\n-        }\n+\t    case 2:\n+\t      n = gimple_asm_nclobbers (gs);\n+\t      for (i = 0; i < n; i++)\n+\t\t{\n+\t\t  dump_generic_node (buffer, gimple_asm_clobber_op (gs, i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  if (i < n - 1)\n+\t\t    pp_string (buffer, \", \");\n+\t\t}\n+\t      break;\n \n-      for (i = 0; i < gimple_asm_nclobbers (gs); i++)\n-        {\n-          dump_generic_node (buffer, gimple_asm_clobber_op (gs, i), spc, flags,\n-                             false);\n-          if ( i < gimple_asm_nclobbers (gs) -1)\n-            pp_string (buffer, \", \");\n-        }\n-    }\n-  if (flags & TDF_RAW)\n-    {\n-      newline_and_indent (buffer, spc);\n-      pp_character (buffer, '>');\n+\t    case 3:\n+\t      n = gimple_asm_nlabels (gs);\n+\t      for (i = 0; i < n; i++)\n+\t\t{\n+\t\t  dump_generic_node (buffer, gimple_asm_label_op (gs, i),\n+\t\t\t\t     spc, flags, false);\n+\t\t  if (i < n - 1)\n+\t\t    pp_string (buffer, \", \");\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+\n+      pp_string (buffer, \");\");\n     }\n-  else\n-    pp_string (buffer, \");\");\n }\n \n "}, {"sha": "425463c31ca14c8e0ea2f0e44e7421b677e0c0f7", "filename": "gcc/gimple.c", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -507,17 +507,22 @@ gimple_build_bind (tree vars, gimple_seq body, tree block)\n \n static inline gimple\n gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs, \n-                    unsigned nclobbers)\n+                    unsigned nclobbers, unsigned nlabels)\n {\n   gimple p;\n   int size = strlen (string);\n \n+  /* ASMs with labels cannot have outputs.  This should have been\n+     enforced by the front end.  */\n+  gcc_assert (nlabels == 0 || noutputs == 0);\n+\n   p = gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n-\t\t\t     ninputs + noutputs + nclobbers);\n+\t\t\t     ninputs + noutputs + nclobbers + nlabels);\n \n   p->gimple_asm.ni = ninputs;\n   p->gimple_asm.no = noutputs;\n   p->gimple_asm.nc = nclobbers;\n+  p->gimple_asm.nl = nlabels;\n   p->gimple_asm.string = ggc_alloc_string (string, size);\n \n #ifdef GATHER_STATISTICS\n@@ -535,19 +540,22 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n    NCLOBBERS is the number of clobbered registers.\n    INPUTS is a vector of the input register parameters.\n    OUTPUTS is a vector of the output register parameters.\n-   CLOBBERS is a vector of the clobbered register parameters.  */\n+   CLOBBERS is a vector of the clobbered register parameters.\n+   LABELS is a vector of destination labels.  */\n \n gimple\n gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs, \n-                      VEC(tree,gc)* outputs, VEC(tree,gc)* clobbers)\n+                      VEC(tree,gc)* outputs, VEC(tree,gc)* clobbers,\n+\t\t      VEC(tree,gc)* labels)\n {\n   gimple p;\n   unsigned i;\n \n   p = gimple_build_asm_1 (string,\n                           VEC_length (tree, inputs),\n                           VEC_length (tree, outputs), \n-                          VEC_length (tree, clobbers));\n+                          VEC_length (tree, clobbers),\n+\t\t\t  VEC_length (tree, labels));\n   \n   for (i = 0; i < VEC_length (tree, inputs); i++)\n     gimple_asm_set_input_op (p, i, VEC_index (tree, inputs, i));\n@@ -558,39 +566,8 @@ gimple_build_asm_vec (const char *string, VEC(tree,gc)* inputs,\n   for (i = 0; i < VEC_length (tree, clobbers); i++)\n     gimple_asm_set_clobber_op (p, i, VEC_index (tree, clobbers, i));\n   \n-  return p;\n-}\n-\n-/* Build a GIMPLE_ASM statement.\n-\n-   STRING is the assembly code.\n-   NINPUT is the number of register inputs.\n-   NOUTPUT is the number of register outputs.\n-   NCLOBBERS is the number of clobbered registers.\n-   ... are trees for each input, output and clobbered register.  */\n-\n-gimple\n-gimple_build_asm (const char *string, unsigned ninputs, unsigned noutputs, \n-\t\t  unsigned nclobbers, ...)\n-{\n-  gimple p;\n-  unsigned i;\n-  va_list ap;\n-  \n-  p = gimple_build_asm_1 (string, ninputs, noutputs, nclobbers);\n-  \n-  va_start (ap, nclobbers);\n-\n-  for (i = 0; i < ninputs; i++)\n-    gimple_asm_set_input_op (p, i, va_arg (ap, tree));\n-\n-  for (i = 0; i < noutputs; i++)\n-    gimple_asm_set_output_op (p, i, va_arg (ap, tree));\n-\n-  for (i = 0; i < nclobbers; i++)\n-    gimple_asm_set_clobber_op (p, i, va_arg (ap, tree));\n-\n-  va_end (ap);\n+  for (i = 0; i < VEC_length (tree, labels); i++)\n+    gimple_asm_set_label_op (p, i, VEC_index (tree, labels, i));\n   \n   return p;\n }\n@@ -1230,10 +1207,10 @@ static tree\n walk_gimple_asm (gimple stmt, walk_tree_fn callback_op,\n \t\t struct walk_stmt_info *wi)\n {\n-  tree ret;\n+  tree ret, op;\n   unsigned noutputs;\n   const char **oconstraints;\n-  unsigned i;\n+  unsigned i, n;\n   const char *constraint;\n   bool allows_mem, allows_reg, is_inout;\n \n@@ -1245,7 +1222,7 @@ walk_gimple_asm (gimple stmt, walk_tree_fn callback_op,\n \n   for (i = 0; i < noutputs; i++)\n     {\n-      tree op = gimple_asm_output_op (stmt, i);\n+      op = gimple_asm_output_op (stmt, i);\n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       oconstraints[i] = constraint;\n       parse_output_constraint (&constraint, i, 0, 0, &allows_mem, &allows_reg,\n@@ -1257,18 +1234,19 @@ walk_gimple_asm (gimple stmt, walk_tree_fn callback_op,\n \treturn ret;\n     }\n \n-  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+  n = gimple_asm_ninputs (stmt);\n+  for (i = 0; i < n; i++)\n     {\n-      tree op = gimple_asm_input_op (stmt, i);\n+      op = gimple_asm_input_op (stmt, i);\n       constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (op)));\n       parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n \t\t\t      oconstraints, &allows_mem, &allows_reg);\n       if (wi)\n-\twi->val_only = (allows_reg || !allows_mem);\n-\n-      /* Although input \"m\" is not really a LHS, we need a lvalue.  */\n-      if (wi)\n-\twi->is_lhs = !wi->val_only;\n+\t{\n+\t  wi->val_only = (allows_reg || !allows_mem);\n+          /* Although input \"m\" is not really a LHS, we need a lvalue.  */\n+\t  wi->is_lhs = !wi->val_only;\n+\t}\n       ret = walk_tree (&TREE_VALUE (op), callback_op, wi, NULL);\n       if (ret)\n \treturn ret;\n@@ -1280,6 +1258,15 @@ walk_gimple_asm (gimple stmt, walk_tree_fn callback_op,\n       wi->val_only = true;\n     }\n \n+  n = gimple_asm_nlabels (stmt);\n+  for (i = 0; i < n; i++)\n+    {\n+      op = gimple_asm_label_op (stmt, i);\n+      ret = walk_tree (&TREE_VALUE (op), callback_op, wi, NULL);\n+      if (ret)\n+\treturn ret;\n+    }\n+\n   return NULL_TREE;\n }\n "}, {"sha": "d736dd719cbc8b80107ed1cd9c7688419907942b", "filename": "gcc/gimple.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -106,7 +106,8 @@ DEFGSCODE(GIMPLE_ASSIGN, \"gimple_assign\", GSS_WITH_MEM_OPS)\n    STRING is the string containing the assembly statements.\n    I1 ... IN are the N input operands.\n    O1 ... OM are the M output operands.\n-   C1 ... CP are the P clobber operands.  */\n+   C1 ... CP are the P clobber operands.\n+   L1 ... LQ are the Q label operands.  */\n DEFGSCODE(GIMPLE_ASM, \"gimple_asm\", GSS_ASM)\n \n /* GIMPLE_CALL <FN, LHS, ARG1, ..., ARGN[, CHAIN]> represents function"}, {"sha": "e1e3b655b7dcbb2634b40a2e6402941e5ccb79f6", "filename": "gcc/gimple.h", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -553,10 +553,11 @@ struct GTY(()) gimple_statement_asm\n   const char *string;\n \n   /* [ WORD 10 ]\n-       Number of inputs, outputs and clobbers.  */\n+       Number of inputs, outputs, clobbers, labels.  */\n   unsigned char ni;\n   unsigned char no;\n-  unsigned short nc;\n+  unsigned char nc;\n+  unsigned char nl;\n \n   /* [ WORD 11 ]\n      Operand vector.  NOTE!  This must always be the last field\n@@ -792,9 +793,8 @@ gimple gimple_build_label (tree label);\n gimple gimple_build_goto (tree dest);\n gimple gimple_build_nop (void);\n gimple gimple_build_bind (tree, gimple_seq, tree);\n-gimple gimple_build_asm (const char *, unsigned, unsigned, unsigned, ...);\n gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *,\n-                             VEC(tree,gc) *);\n+                             VEC(tree,gc) *, VEC(tree,gc) *);\n gimple gimple_build_catch (tree, gimple_seq);\n gimple gimple_build_eh_filter (tree, gimple_seq);\n gimple gimple_build_eh_must_not_throw (tree);\n@@ -2614,6 +2614,14 @@ gimple_asm_nclobbers (const_gimple gs)\n   return gs->gimple_asm.nc;\n }\n \n+/* Return the number of label operands for GIMPLE_ASM GS.  */\n+\n+static inline unsigned\n+gimple_asm_nlabels (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASM);\n+  return gs->gimple_asm.nl;\n+}\n \n /* Return input operand INDEX of GIMPLE_ASM GS.  */\n \n@@ -2703,6 +2711,26 @@ gimple_asm_set_clobber_op (gimple gs, unsigned index, tree clobber_op)\n   gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.no, clobber_op);\n }\n \n+/* Return label operand INDEX of GIMPLE_ASM GS.  */\n+\n+static inline tree\n+gimple_asm_label_op (const_gimple gs, unsigned index)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASM);\n+  gcc_assert (index <= gs->gimple_asm.nl);\n+  return gimple_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc);\n+}\n+\n+/* Set LABEL_OP to be label operand INDEX in GIMPLE_ASM GS.  */\n+\n+static inline void\n+gimple_asm_set_label_op (gimple gs, unsigned index, tree label_op)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_ASM);\n+  gcc_assert (index <= gs->gimple_asm.nl);\n+  gcc_assert (TREE_CODE (label_op) == TREE_LIST);\n+  gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc, label_op);\n+}\n \n /* Return the string representing the assembly instruction in\n    GIMPLE_ASM GS.  */"}, {"sha": "c0cab20561357e4ecf59da3b31c71996e784f2f0", "filename": "gcc/gimplify.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -4765,13 +4765,14 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   VEC(tree, gc) *inputs;\n   VEC(tree, gc) *outputs;\n   VEC(tree, gc) *clobbers;\n+  VEC(tree, gc) *labels;\n   tree link_next;\n   \n   expr = *expr_p;\n   noutputs = list_length (ASM_OUTPUTS (expr));\n   oconstraints = (const char **) alloca ((noutputs) * sizeof (const char *));\n \n-  inputs = outputs = clobbers = NULL;\n+  inputs = outputs = clobbers = labels = NULL;\n \n   ret = GS_ALL_DONE;\n   link_next = NULL_TREE;\n@@ -4953,13 +4954,16 @@ gimplify_asm_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n     }\n   \n   for (link = ASM_CLOBBERS (expr); link; ++i, link = TREE_CHAIN (link))\n-      VEC_safe_push (tree, gc, clobbers, link);\n+    VEC_safe_push (tree, gc, clobbers, link);\n+\n+  for (link = ASM_LABELS (expr); link; ++i, link = TREE_CHAIN (link))\n+    VEC_safe_push (tree, gc, labels, link);\n \n   /* Do not add ASMs with errors to the gimple IL stream.  */\n   if (ret != GS_ERROR)\n     {\n       stmt = gimple_build_asm_vec (TREE_STRING_POINTER (ASM_STRING (expr)),\n-\t\t\t\t   inputs, outputs, clobbers);\n+\t\t\t\t   inputs, outputs, clobbers, labels);\n \n       gimple_asm_set_volatile (stmt, ASM_VOLATILE_P (expr));\n       gimple_asm_set_input (stmt, ASM_INPUT_P (expr));"}, {"sha": "a12d040450087d5d2b320d8f030b651d96ab638b", "filename": "gcc/jump.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n static void init_label_info (rtx);\n static void mark_all_labels (rtx);\n static void mark_jump_label_1 (rtx, rtx, bool, bool);\n+static void mark_jump_label_asm (rtx, rtx);\n static void redirect_exp_1 (rtx *, rtx, rtx, rtx);\n static int invert_exp_1 (rtx, rtx);\n static int returnjump_p_1 (rtx *, void *);\n@@ -1006,8 +1007,12 @@ sets_cc0_p (const_rtx x)\n void\n mark_jump_label (rtx x, rtx insn, int in_mem)\n {\n-  mark_jump_label_1 (x, insn, in_mem != 0,\n-\t\t     (insn != NULL && x == PATTERN (insn) && JUMP_P (insn)));\n+  rtx asmop = extract_asm_operands (x);\n+  if (asmop)\n+    mark_jump_label_asm (asmop, insn);\n+  else\n+    mark_jump_label_1 (x, insn, in_mem != 0,\n+\t\t       (insn != NULL && x == PATTERN (insn) && JUMP_P (insn)));\n }\n \n /* Worker function for mark_jump_label.  IN_MEM is TRUE when X occurs\n@@ -1145,6 +1150,22 @@ mark_jump_label_1 (rtx x, rtx insn, bool in_mem, bool is_target)\n     }\n }\n \n+/* Worker function for mark_jump_label.  Handle asm insns specially.\n+   In particular, output operands need not be considered so we can\n+   avoid re-scanning the replicated asm_operand.  Also, the asm_labels\n+   need to be considered targets.  */\n+\n+static void\n+mark_jump_label_asm (rtx asmop, rtx insn)\n+{\n+  int i;\n+\n+  for (i = ASM_OPERANDS_INPUT_LENGTH (asmop) - 1; i >= 0; --i)\n+    mark_jump_label_1 (ASM_OPERANDS_INPUT (asmop, i), insn, false, false);\n+\n+  for (i = ASM_OPERANDS_LABEL_LENGTH (asmop) - 1; i >= 0; --i)\n+    mark_jump_label_1 (ASM_OPERANDS_LABEL (asmop, i), insn, false, true);\n+}\n \f\n /* Delete insn INSN from the chain of insns and update label ref counts\n    and delete insns now unreachable.\n@@ -1386,9 +1407,17 @@ int\n redirect_jump_1 (rtx jump, rtx nlabel)\n {\n   int ochanges = num_validated_changes ();\n-  rtx *loc;\n+  rtx *loc, asmop;\n \n-  if (GET_CODE (PATTERN (jump)) == PARALLEL)\n+  asmop = extract_asm_operands (PATTERN (jump));\n+  if (asmop)\n+    {\n+      if (nlabel == NULL)\n+\treturn 0;\n+      gcc_assert (ASM_OPERANDS_LABEL_LENGTH (asmop) == 1);\n+      loc = &ASM_OPERANDS_LABEL (asmop, 0);\n+    }\n+  else if (GET_CODE (PATTERN (jump)) == PARALLEL)\n     loc = &XVECEXP (PATTERN (jump), 0, 0);\n   else\n     loc = &PATTERN (jump);\n@@ -1514,7 +1543,8 @@ invert_jump_1 (rtx jump, rtx nlabel)\n   int ok;\n \n   ochanges = num_validated_changes ();\n-  gcc_assert (x);\n+  if (x == NULL)\n+    return 0;\n   ok = invert_exp_1 (SET_SRC (x), jump);\n   gcc_assert (ok);\n   "}, {"sha": "6874d6c5c60b28817c9cce17183eba7f6a12deaf", "filename": "gcc/recog.c", "status": "modified", "additions": 125, "deletions": 127, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1373,33 +1373,65 @@ comparison_operator (rtx op, enum machine_mode mode)\n \t  && COMPARISON_P (op));\n }\n \f\n+/* If BODY is an insn body that uses ASM_OPERANDS, return it.  */\n+\n+rtx\n+extract_asm_operands (rtx body)\n+{\n+  rtx tmp;\n+  switch (GET_CODE (body))\n+    {\n+    case ASM_OPERANDS:\n+      return body;\n+\n+    case SET:\n+      /* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */\n+      tmp = SET_SRC (body);\n+      if (GET_CODE (tmp) == ASM_OPERANDS)\n+\treturn tmp;\n+      break;\n+\n+    case PARALLEL:\n+      tmp = XVECEXP (body, 0, 0);\n+      if (GET_CODE (tmp) == ASM_OPERANDS)\n+\treturn tmp;\n+      if (GET_CODE (tmp) == SET)\n+\t{\n+\t  tmp = SET_SRC (tmp);\n+\t  if (GET_CODE (tmp) == ASM_OPERANDS)\n+\t    return tmp;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return NULL;\n+}\n+\n /* If BODY is an insn body that uses ASM_OPERANDS,\n    return the number of operands (both input and output) in the insn.\n    Otherwise return -1.  */\n \n int\n asm_noperands (const_rtx body)\n {\n-  switch (GET_CODE (body))\n+  rtx asm_op = extract_asm_operands (CONST_CAST_RTX (body));\n+  int n_sets = 0;\n+\n+  if (asm_op == NULL)\n+    return -1;\n+\n+  if (GET_CODE (body) == SET)\n+    n_sets = 1;\n+  else if (GET_CODE (body) == PARALLEL)\n     {\n-    case ASM_OPERANDS:\n-      /* No output operands: return number of input operands.  */\n-      return ASM_OPERANDS_INPUT_LENGTH (body);\n-    case SET:\n-      if (GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-\t/* Single output operand: BODY is (set OUTPUT (asm_operands ...)).  */\n-\treturn ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body)) + 1;\n-      else\n-\treturn -1;\n-    case PARALLEL:\n-      if (GET_CODE (XVECEXP (body, 0, 0)) == SET\n-\t  && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n+      int i;\n+      if (GET_CODE (XVECEXP (body, 0, 0)) == SET)\n \t{\n \t  /* Multiple output operands, or 1 output plus some clobbers:\n-\t     body is [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */\n-\t  int i;\n-\t  int n_sets;\n-\n+\t     body is \n+\t     [(set OUTPUT (asm_operands ...))... (clobber (reg ...))...].  */\n \t  /* Count backwards through CLOBBERs to determine number of SETs.  */\n \t  for (i = XVECLEN (body, 0); i > 0; i--)\n \t    {\n@@ -1425,30 +1457,23 @@ asm_noperands (const_rtx body)\n \t      /* If these ASM_OPERANDS rtx's came from different original insns\n \t         then they aren't allowed together.  */\n \t      if (ASM_OPERANDS_INPUT_VEC (SET_SRC (elt))\n-\t\t  != ASM_OPERANDS_INPUT_VEC (SET_SRC (XVECEXP (body, 0, 0))))\n+\t\t  != ASM_OPERANDS_INPUT_VEC (asm_op))\n \t\treturn -1;\n \t    }\n-\t  return (ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)))\n-\t\t  + n_sets);\n \t}\n-      else if (GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+      else\n \t{\n \t  /* 0 outputs, but some clobbers:\n \t     body is [(asm_operands ...) (clobber (reg ...))...].  */\n-\t  int i;\n-\n \t  /* Make sure all the other parallel things really are clobbers.  */\n \t  for (i = XVECLEN (body, 0) - 1; i > 0; i--)\n \t    if (GET_CODE (XVECEXP (body, 0, i)) != CLOBBER)\n \t      return -1;\n-\n-\t  return ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n \t}\n-      else\n-\treturn -1;\n-    default:\n-      return -1;\n     }\n+\n+  return (ASM_OPERANDS_INPUT_LENGTH (asm_op)\n+\t  + ASM_OPERANDS_LABEL_LENGTH (asm_op) + n_sets);\n }\n \n /* Assuming BODY is an insn body that uses ASM_OPERANDS,\n@@ -1466,28 +1491,19 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n \t\t     const char **constraints, enum machine_mode *modes,\n \t\t     location_t *loc)\n {\n-  int i;\n-  int noperands;\n-  rtx asmop = 0;\n+  int noperands, nbase = 0, n, i;\n+  rtx asmop;\n \n-  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+  switch (GET_CODE (body))\n     {\n-      asmop = SET_SRC (body);\n-      /* Single output operand: BODY is (set OUTPUT (asm_operands ....)).  */\n-\n-      noperands = ASM_OPERANDS_INPUT_LENGTH (asmop) + 1;\n+    case ASM_OPERANDS:\n+      /* Zero output asm: BODY is (asm_operands ...).  */\n+      asmop = body;\n+      break;\n \n-      for (i = 1; i < noperands; i++)\n-\t{\n-\t  if (operand_locs)\n-\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i - 1);\n-\t  if (operands)\n-\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i - 1);\n-\t  if (constraints)\n-\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i - 1);\n-\t  if (modes)\n-\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i - 1);\n-\t}\n+    case SET:\n+      /* Single output asm: BODY is (set OUTPUT (asm_operands ...)).  */\n+      asmop = SET_SRC (body);\n \n       /* The output is in the SET.\n \t Its constraint is in the ASM_OPERANDS itself.  */\n@@ -1499,93 +1515,70 @@ decode_asm_operands (rtx body, rtx *operands, rtx **operand_locs,\n \tconstraints[0] = ASM_OPERANDS_OUTPUT_CONSTRAINT (asmop);\n       if (modes)\n \tmodes[0] = GET_MODE (SET_DEST (body));\n-    }\n-  else if (GET_CODE (body) == ASM_OPERANDS)\n-    {\n-      asmop = body;\n-      /* No output operands: BODY is (asm_operands ....).  */\n-\n-      noperands = ASM_OPERANDS_INPUT_LENGTH (asmop);\n-\n-      /* The input operands are found in the 1st element vector.  */\n-      /* Constraints for inputs are in the 2nd element vector.  */\n-      for (i = 0; i < noperands; i++)\n-\t{\n-\t  if (operand_locs)\n-\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (operands)\n-\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (constraints)\n-\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n-\t  if (modes)\n-\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n-\t}\n-    }\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET\n-\t   && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) == ASM_OPERANDS)\n-    {\n-      int nparallel = XVECLEN (body, 0); /* Includes CLOBBERs.  */\n-      int nin;\n-      int nout = 0;\t\t/* Does not include CLOBBERs.  */\n-\n-      asmop = SET_SRC (XVECEXP (body, 0, 0));\n-      nin = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+      nbase = 1;\n+      break;\n \n-      /* At least one output, plus some CLOBBERs.  */\n+    case PARALLEL:\n+      {\n+\tint nparallel = XVECLEN (body, 0); /* Includes CLOBBERs.  */\n \n-      /* The outputs are in the SETs.\n-\t Their constraints are in the ASM_OPERANDS itself.  */\n-      for (i = 0; i < nparallel; i++)\n-\t{\n-\t  if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n-\t    break;\t\t/* Past last SET */\n+\tasmop = XVECEXP (body, 0, 0);\n+\tif (GET_CODE (asmop) == SET)\n+\t  {\n+\t    asmop = SET_SRC (asmop);\n \n-\t  if (operands)\n-\t    operands[i] = SET_DEST (XVECEXP (body, 0, i));\n-\t  if (operand_locs)\n-\t    operand_locs[i] = &SET_DEST (XVECEXP (body, 0, i));\n-\t  if (constraints)\n-\t    constraints[i] = XSTR (SET_SRC (XVECEXP (body, 0, i)), 1);\n-\t  if (modes)\n-\t    modes[i] = GET_MODE (SET_DEST (XVECEXP (body, 0, i)));\n-\t  nout++;\n-\t}\n+\t    /* At least one output, plus some CLOBBERs.  The outputs are in\n+\t       the SETs.  Their constraints are in the ASM_OPERANDS itself.  */\n+\t    for (i = 0; i < nparallel; i++)\n+\t      {\n+\t\tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t\t  break;\t\t/* Past last SET */\n+\t\tif (operands)\n+\t\t  operands[i] = SET_DEST (XVECEXP (body, 0, i));\n+\t\tif (operand_locs)\n+\t\t  operand_locs[i] = &SET_DEST (XVECEXP (body, 0, i));\n+\t\tif (constraints)\n+\t\t  constraints[i] = XSTR (SET_SRC (XVECEXP (body, 0, i)), 1);\n+\t\tif (modes)\n+\t\t  modes[i] = GET_MODE (SET_DEST (XVECEXP (body, 0, i)));\n+\t      }\n+\t    nbase = i;\n+\t  }\n+\tbreak;\n+      }\n \n-      for (i = 0; i < nin; i++)\n-\t{\n-\t  if (operand_locs)\n-\t    operand_locs[i + nout] = &ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (operands)\n-\t    operands[i + nout] = ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (constraints)\n-\t    constraints[i + nout] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n-\t  if (modes)\n-\t    modes[i + nout] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n-\t}\n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    {\n-      /* No outputs, but some CLOBBERs.  */\n-\n-      int nin;\n \n-      asmop = XVECEXP (body, 0, 0);\n-      nin = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+  noperands = (ASM_OPERANDS_INPUT_LENGTH (asmop)\n+\t       + ASM_OPERANDS_LABEL_LENGTH (asmop) + nbase);\n \n-      for (i = 0; i < nin; i++)\n-\t{\n-\t  if (operand_locs)\n-\t    operand_locs[i] = &ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (operands)\n-\t    operands[i] = ASM_OPERANDS_INPUT (asmop, i);\n-\t  if (constraints)\n-\t    constraints[i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n-\t  if (modes)\n-\t    modes[i] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n-\t}\n+  n = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+  for (i = 0; i < n; i++)\n+    {\n+      if (operand_locs)\n+\toperand_locs[nbase + i] = &ASM_OPERANDS_INPUT (asmop, i);\n+      if (operands)\n+\toperands[nbase + i] = ASM_OPERANDS_INPUT (asmop, i);\n+      if (constraints)\n+\tconstraints[nbase + i] = ASM_OPERANDS_INPUT_CONSTRAINT (asmop, i);\n+      if (modes)\n+\tmodes[nbase + i] = ASM_OPERANDS_INPUT_MODE (asmop, i);\n+    }\n+  nbase += n;\n \n+  n = ASM_OPERANDS_LABEL_LENGTH (asmop);\n+  for (i = 0; i < n; i++)\n+    {\n+      if (operand_locs)\n+\toperand_locs[nbase + i] = &ASM_OPERANDS_LABEL (asmop, i);\n+      if (operands)\n+\toperands[nbase + i] = ASM_OPERANDS_LABEL (asmop, i);\n+      if (constraints)\n+\tconstraints[nbase + i] = \"\";\n+      if (modes)\n+\tmodes[nbase + i] = Pmode;\n     }\n \n   if (loc)\n@@ -1605,6 +1598,11 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n   /* Use constrain_operands after reload.  */\n   gcc_assert (!reload_completed);\n \n+  /* Empty constraint string is the same as \"X,...,X\", i.e. X for as\n+     many alternatives as required to match the other operands.  */\n+  if (*constraint == '\\0')\n+    return 1;\n+\n   while (*constraint)\n     {\n       char c = *constraint;"}, {"sha": "7e4ba6cad201b803d38e53314f0abdb62fb84c73", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -254,7 +254,7 @@ static void pop_stack (stack, int);\n static rtx *get_true_reg (rtx *);\n \n static int check_asm_stack_operands (rtx);\n-static int get_asm_operand_n_inputs (rtx);\n+static void get_asm_operands_in_out (rtx, int *, int *);\n static rtx stack_result (tree);\n static void replace_reg (rtx *, int);\n static void remove_regno_note (rtx, enum reg_note, unsigned int);\n@@ -480,8 +480,7 @@ check_asm_stack_operands (rtx insn)\n \n   preprocess_constraints ();\n \n-  n_inputs = get_asm_operand_n_inputs (body);\n-  n_outputs = recog_data.n_operands - n_inputs;\n+  get_asm_operands_in_out (body, &n_outputs, &n_inputs);\n \n   if (alt < 0)\n     {\n@@ -645,24 +644,15 @@ check_asm_stack_operands (rtx insn)\n    N_INPUTS and N_OUTPUTS are pointers to ints into which the results are\n    placed.  */\n \n-static int\n-get_asm_operand_n_inputs (rtx body)\n+static void\n+get_asm_operands_in_out (rtx body, int *pout, int *pin)\n {\n-  switch (GET_CODE (body))\n-    {\n-    case SET:\n-      gcc_assert (GET_CODE (SET_SRC (body)) == ASM_OPERANDS);\n-      return ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n-      \n-    case ASM_OPERANDS:\n-      return ASM_OPERANDS_INPUT_LENGTH (body);\n-      \n-    case PARALLEL:\n-      return get_asm_operand_n_inputs (XVECEXP (body, 0, 0));\n-      \n-    default:\n-      gcc_unreachable ();\n-    }\n+  rtx asmop = extract_asm_operands (body);\n+\n+  *pin = ASM_OPERANDS_INPUT_LENGTH (asmop);\n+  *pout = (recog_data.n_operands\n+\t   - ASM_OPERANDS_INPUT_LENGTH (asmop)\n+\t   - ASM_OPERANDS_LABEL_LENGTH (asmop));\n }\n \n /* If current function returns its result in an fp stack register,\n@@ -2034,8 +2024,7 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \n   preprocess_constraints ();\n \n-  n_inputs = get_asm_operand_n_inputs (body);\n-  n_outputs = recog_data.n_operands - n_inputs;\n+  get_asm_operands_in_out (body, &n_outputs, &n_inputs);\n \n   gcc_assert (alt >= 0);\n "}, {"sha": "2aa76b1f6c8ea22fd421a1064d44c69fdbdbaa0e", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -187,8 +187,9 @@ DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"si\", RTX_EXTRA)\n    5th is a vector of modes and constraints for the input operands.\n      Each element is an ASM_INPUT containing a constraint string\n      and whose mode indicates the mode of the input operand.\n-   6th is the source line number.  */\n-DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEi\", RTX_EXTRA)\n+   6th is a vector of labels that may be branched to by the asm.\n+   7th is the source line number.  */\n+DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEEi\", RTX_EXTRA)\n \n /* A machine-specific operation.\n    1st operand is a vector of operands being used by the operation so that"}, {"sha": "925246f787bcb5337a41c39d0a67c54615ce27df", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1188,7 +1188,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n   XSTR (XCVECEXP (RTX, 4, N, ASM_OPERANDS), 0)\n #define ASM_OPERANDS_INPUT_MODE(RTX, N)  \\\n   GET_MODE (XCVECEXP (RTX, 4, N, ASM_OPERANDS))\n-#define ASM_OPERANDS_SOURCE_LOCATION(RTX) XCUINT (RTX, 5, ASM_OPERANDS)\n+#define ASM_OPERANDS_LABEL_VEC(RTX) XCVEC (RTX, 5, ASM_OPERANDS)\n+#define ASM_OPERANDS_LABEL_LENGTH(RTX) XCVECLEN (RTX, 5, ASM_OPERANDS)\n+#define ASM_OPERANDS_LABEL(RTX, N) XCVECEXP (RTX, 5, N, ASM_OPERANDS)\n+#define ASM_OPERANDS_SOURCE_LOCATION(RTX) XCUINT (RTX, 6, ASM_OPERANDS)\n #define ASM_INPUT_SOURCE_LOCATION(RTX) XCUINT (RTX, 1, ASM_INPUT)\n \n /* 1 if RTX is a mem that is statically allocated in read-only memory.  */\n@@ -1926,6 +1929,7 @@ extern bool resize_reg_info (void);\n extern void free_reg_info (void);\n \n /* recog.c */\n+extern rtx extract_asm_operands (rtx);\n extern int asm_noperands (const_rtx);\n extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n \t\t\t\t\tenum machine_mode *, location_t *);"}, {"sha": "42f22b5868b692154c43c532084eeb3b6dbcc8a8", "filename": "gcc/stmt.c", "status": "modified", "additions": 76, "deletions": 53, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -110,8 +110,8 @@ static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n static void expand_nl_goto_receiver (void);\n static bool check_operand_nalternatives (tree, tree);\n-static bool check_unique_operand_names (tree, tree);\n-static char *resolve_operand_name_1 (char *, tree, tree);\n+static bool check_unique_operand_names (tree, tree, tree);\n+static char *resolve_operand_name_1 (char *, tree, tree, tree);\n static void expand_null_return_1 (void);\n static void expand_value_return (rtx);\n static int estimate_case_costs (case_node_ptr);\n@@ -633,12 +633,13 @@ tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n \n static void\n expand_asm_operands (tree string, tree outputs, tree inputs,\n-\t\t     tree clobbers, int vol, location_t locus)\n+\t\t     tree clobbers, tree labels, int vol, location_t locus)\n {\n-  rtvec argvec, constraintvec;\n+  rtvec argvec, constraintvec, labelvec;\n   rtx body;\n   int ninputs = list_length (inputs);\n   int noutputs = list_length (outputs);\n+  int nlabels = list_length (labels);\n   int ninout;\n   int nclobbers;\n   HARD_REG_SET clobbered_regs;\n@@ -661,7 +662,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   if (! check_operand_nalternatives (outputs, inputs))\n     return;\n \n-  string = resolve_asm_operand_names (string, outputs, inputs);\n+  string = resolve_asm_operand_names (string, outputs, inputs, labels);\n \n   /* Collect constraints.  */\n   i = 0;\n@@ -845,12 +846,13 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \n   argvec = rtvec_alloc (ninputs);\n   constraintvec = rtvec_alloc (ninputs);\n+  labelvec = rtvec_alloc (nlabels);\n \n   body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n \t\t\t\t: GET_MODE (output_rtx[0])),\n \t\t\t       ggc_strdup (TREE_STRING_POINTER (string)),\n \t\t\t       empty_string, 0, argvec, constraintvec,\n-\t\t\t       locus);\n+\t\t\t       labelvec, locus);\n \n   MEM_VOLATILE_P (body) = vol;\n \n@@ -959,25 +961,33 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t= gen_rtx_ASM_INPUT (inout_mode[i], ggc_strdup (buffer));\n     }\n \n+  /* Copy labels to the vector.  */\n+  for (i = 0, tail = labels; i < nlabels; ++i, tail = TREE_CHAIN (tail))\n+    ASM_OPERANDS_LABEL (body, i)\n+      = gen_rtx_LABEL_REF (Pmode, label_rtx (TREE_VALUE (tail)));\n+\n   generating_concat_p = old_generating_concat_p;\n \n   /* Now, for each output, construct an rtx\n      (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER\n \t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n      If there is more than one, put them inside a PARALLEL.  */\n \n-  if (noutputs == 1 && nclobbers == 0)\n+  if (nlabels > 0 && nclobbers == 0)\n     {\n-      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = ggc_strdup (constraints[0]);\n-      emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n+      gcc_assert (noutputs == 0);\n+      emit_jump_insn (body);\n     }\n-\n   else if (noutputs == 0 && nclobbers == 0)\n     {\n       /* No output operands: put in a raw ASM_OPERANDS rtx.  */\n       emit_insn (body);\n     }\n-\n+  else if (noutputs == 1 && nclobbers == 0)\n+    {\n+      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = ggc_strdup (constraints[0]);\n+      emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n+    }\n   else\n     {\n       rtx obody = body;\n@@ -998,7 +1008,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t\t\t   (GET_MODE (output_rtx[i]),\n \t\t\t    ggc_strdup (TREE_STRING_POINTER (string)),\n \t\t\t    ggc_strdup (constraints[i]),\n-\t\t\t    i, argvec, constraintvec, locus));\n+\t\t\t    i, argvec, constraintvec, labelvec, locus));\n \n \t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i))) = vol;\n \t}\n@@ -1062,7 +1072,10 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t    = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n \t}\n \n-      emit_insn (body);\n+      if (nlabels > 0)\n+\temit_jump_insn (body);\n+      else\n+\temit_insn (body);\n     }\n \n   /* For any outputs that needed reloading into registers, spill them\n@@ -1083,7 +1096,7 @@ expand_asm_stmt (gimple stmt)\n   tree *o;\n   size_t i, n;\n   const char *s;\n-  tree str, out, in, cl;\n+  tree str, out, in, cl, labels;\n \n   /* Meh... convert the gimple asm operands into real tree lists.\n      Eventually we should make all routines work on the vectors instead\n@@ -1094,10 +1107,7 @@ expand_asm_stmt (gimple stmt)\n     {\n       t = out = gimple_asm_output_op (stmt, 0);\n       for (i = 1; i < n; i++)\n-\t{\n-\t  TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n-\t  t = gimple_asm_output_op (stmt, i);\n-\t}\n+\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n     }\n \n   in = NULL_TREE;\n@@ -1106,10 +1116,7 @@ expand_asm_stmt (gimple stmt)\n     {\n       t = in = gimple_asm_input_op (stmt, 0);\n       for (i = 1; i < n; i++)\n-\t{\n-\t  TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n-\t  t = gimple_asm_input_op (stmt, i);\n-\t}\n+\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n     }\n \n   cl = NULL_TREE;\n@@ -1118,10 +1125,16 @@ expand_asm_stmt (gimple stmt)\n     {\n       t = cl = gimple_asm_clobber_op (stmt, 0);\n       for (i = 1; i < n; i++)\n-\t{\n-\t  TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n-\t  t = gimple_asm_clobber_op (stmt, i);\n-\t}\n+\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+    }\n+\n+  labels = NULL_TREE;\n+  n = gimple_asm_nlabels (stmt);\n+  if (n > 0)\n+    {\n+      t = labels = gimple_asm_label_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n     }\n \n   s = gimple_asm_string (stmt);\n@@ -1144,8 +1157,8 @@ expand_asm_stmt (gimple stmt)\n \n   /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n      OUTPUTS some trees for where the values were actually stored.  */\n-  expand_asm_operands (str, outputs, in, cl, gimple_asm_volatile_p (stmt),\n-\t\t       input_location);\n+  expand_asm_operands (str, outputs, in, cl, labels,\n+\t\t       gimple_asm_volatile_p (stmt), input_location);\n \n   /* Copy all the intermediate outputs into the specified outputs.  */\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n@@ -1210,7 +1223,7 @@ check_operand_nalternatives (tree outputs, tree inputs)\n    so all we need are pointer comparisons.  */\n \n static bool\n-check_unique_operand_names (tree outputs, tree inputs)\n+check_unique_operand_names (tree outputs, tree inputs, tree labels)\n {\n   tree i, j;\n \n@@ -1239,6 +1252,20 @@ check_unique_operand_names (tree outputs, tree inputs)\n \t  goto failure;\n     }\n \n+  for (i = labels; i ; i = TREE_CHAIN (i))\n+    {\n+      tree i_name = TREE_PURPOSE (i);\n+      if (! i_name)\n+\tcontinue;\n+\n+      for (j = TREE_CHAIN (i); j ; j = TREE_CHAIN (j))\n+\tif (simple_cst_equal (i_name, TREE_PURPOSE (j)))\n+\t  goto failure;\n+      for (j = inputs; j ; j = TREE_CHAIN (j))\n+\tif (simple_cst_equal (i_name, TREE_PURPOSE (TREE_PURPOSE (j))))\n+\t  goto failure;\n+    }\n+\n   return true;\n \n  failure:\n@@ -1252,14 +1279,14 @@ check_unique_operand_names (tree outputs, tree inputs)\n    STRING and in the constraints to those numbers.  */\n \n tree\n-resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n+resolve_asm_operand_names (tree string, tree outputs, tree inputs, tree labels)\n {\n   char *buffer;\n   char *p;\n   const char *c;\n   tree t;\n \n-  check_unique_operand_names (outputs, inputs);\n+  check_unique_operand_names (outputs, inputs, labels);\n \n   /* Substitute [<name>] in input constraint strings.  There should be no\n      named operands in output constraints.  */\n@@ -1270,7 +1297,7 @@ resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n \t{\n \t  p = buffer = xstrdup (c);\n \t  while ((p = strchr (p, '[')) != NULL)\n-\t    p = resolve_operand_name_1 (p, outputs, inputs);\n+\t    p = resolve_operand_name_1 (p, outputs, inputs, NULL);\n \t  TREE_VALUE (TREE_PURPOSE (t))\n \t    = build_string (strlen (buffer), buffer);\n \t  free (buffer);\n@@ -1313,7 +1340,7 @@ resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n \t      continue;\n \t    }\n \n-\t  p = resolve_operand_name_1 (p, outputs, inputs);\n+\t  p = resolve_operand_name_1 (p, outputs, inputs, labels);\n \t}\n \n       string = build_string (strlen (buffer), buffer);\n@@ -1329,53 +1356,49 @@ resolve_asm_operand_names (tree string, tree outputs, tree inputs)\n    balance of the string after substitution.  */\n \n static char *\n-resolve_operand_name_1 (char *p, tree outputs, tree inputs)\n+resolve_operand_name_1 (char *p, tree outputs, tree inputs, tree labels)\n {\n   char *q;\n   int op;\n   tree t;\n-  size_t len;\n \n   /* Collect the operand name.  */\n-  q = strchr (p, ']');\n+  q = strchr (++p, ']');\n   if (!q)\n     {\n       error (\"missing close brace for named operand\");\n       return strchr (p, '\\0');\n     }\n-  len = q - p - 1;\n+  *q = '\\0';\n \n   /* Resolve the name to a number.  */\n   for (op = 0, t = outputs; t ; t = TREE_CHAIN (t), op++)\n     {\n       tree name = TREE_PURPOSE (TREE_PURPOSE (t));\n-      if (name)\n-\t{\n-\t  const char *c = TREE_STRING_POINTER (name);\n-\t  if (strncmp (c, p + 1, len) == 0 && c[len] == '\\0')\n-\t    goto found;\n-\t}\n+      if (name && strcmp (TREE_STRING_POINTER (name), p) == 0)\n+\tgoto found;\n     }\n   for (t = inputs; t ; t = TREE_CHAIN (t), op++)\n     {\n       tree name = TREE_PURPOSE (TREE_PURPOSE (t));\n-      if (name)\n-\t{\n-\t  const char *c = TREE_STRING_POINTER (name);\n-\t  if (strncmp (c, p + 1, len) == 0 && c[len] == '\\0')\n-\t    goto found;\n-\t}\n+      if (name && strcmp (TREE_STRING_POINTER (name), p) == 0)\n+\tgoto found;\n+    }\n+  for (t = labels; t ; t = TREE_CHAIN (t), op++)\n+    {\n+      tree name = TREE_PURPOSE (t);\n+      if (name && strcmp (TREE_STRING_POINTER (name), p) == 0)\n+\tgoto found;\n     }\n \n-  *q = '\\0';\n-  error (\"undefined named operand %qs\", identifier_to_locale (p + 1));\n+  error (\"undefined named operand %qs\", identifier_to_locale (p));\n   op = 0;\n- found:\n \n+ found:\n   /* Replace the name with the number.  Unfortunately, not all libraries\n      get the return value of sprintf correct, so search for the end of the\n      generated string by hand.  */\n-  sprintf (p, \"%d\", op);\n+  sprintf (--p, \"%d\", op);\n   p = strchr (p, '\\0');\n \n   /* Verify the no extra buffer space assumption.  */"}, {"sha": "5649e200a850d81a71c3d24902f6e09f0d55eadc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1,3 +1,9 @@\n+2009-09-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-c++-common/asmgoto-1.c, c-c++-common/asmgoto-2.c,\n+\tc-c++-common/asmgoto-3.c, gcc.c-torture/compile/asmgoto-1.c,\n+\tgcc.dg/tree-ssa/asmgoto-1.c: New files.\n+\n 2009-09-14  Richard Henderson  <rth@redhat.com>\n \n \t* g++.dg/eh/builtin1.C: Update resx pattern match."}, {"sha": "9c729fdd57167f53df52371026a354dff0468c5e", "filename": "gcc/testsuite/c-c++-common/asmgoto-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-1.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void\n+foo (void)\n+{\n+  int i = 0;\n+  asm (\"\" : : : \"memory\");\n+  asm (\"\" : : : );\n+  asm (\"\" : : \"r\" (i));\n+  asm (\"\" : : );\n+  asm (\"\" : \"=r\" (i));\n+  asm (\"\" : );\n+  asm (\"\");\n+}"}, {"sha": "5bf45725d80e47693088aa90339445754ad25b62", "filename": "gcc/testsuite/c-c++-common/asmgoto-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-2.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void\n+foo (void)\n+{\n+  __label__ lab;\n+  int i = 0;\n+  asm goto (\"\" : : : : lab);\n+  asm goto (\"\" : \"=r\" (i) : : : lab);\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : : : : );\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : : : \"memory\");\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : : : );\t\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : : \"r\" (i));\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : : );\t\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : \"=r\" (i));\t/* { dg-error \"expected\" } */\n+  asm goto (\"\" : );\t\t/* { dg-error \"expected\" } */\n+  asm goto (\"\");\t\t/* { dg-error \"expected\" } */\n+  lab:;\n+}"}, {"sha": "5224429a3ce3fe3f5e2b1b842629917fdaf1d513", "filename": "gcc/testsuite/c-c++-common/asmgoto-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasmgoto-3.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wunused\" } */\n+\n+int foo ()\n+{\n+  asm goto (\"\" : : : : label);\n+  return 1;\n+ label:\n+  return 0;\n+}"}, {"sha": "cc34610aba7329ed2e09de0d56e726c49dd70afe", "filename": "gcc/testsuite/gcc.c-torture/compile/asmgoto-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fasmgoto-1.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -0,0 +1,30 @@\n+void fn (void);\n+\n+void\n+foo (void *x, unsigned long y)\n+{\n+  asm goto (\"\": : : : lab);\n+lab:\n+  fn ();\n+}\n+\n+static void\n+bar (unsigned long x)\n+{\n+  foo (0, x);\n+}\n+\n+static void\n+baz (unsigned long x)\n+{\n+  if (x > 8192)\n+    bar (x);\n+  else\n+    ({ __here: (unsigned long) &&__here; });\n+}\n+\n+void\n+test (void)\n+{\n+  baz (16384);\n+}"}, {"sha": "1d08067bba2109294fcc6d17947454ddb8670322", "filename": "gcc/testsuite/gcc.dg/tree-ssa/asmgoto-1.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasmgoto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasmgoto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasmgoto-1.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+extern void XYZZY (void);\n+typedef unsigned long __kernel_size_t;\n+typedef __kernel_size_t size_t;\n+typedef unsigned gfp_t;\n+struct per_cpu_pageset { } __attribute__ ((__aligned__ ((1 << (6)))));\n+struct zone { struct per_cpu_pageset *pageset[64]; }\n+zone_flags_t; typedef struct pglist_data { struct zone node_zones[4]; } pg_data_t;\n+extern struct pglist_data *first_online_pgdat (void);\n+extern struct zone *next_zone (struct zone *zone);\n+extern volatile int per_cpu__x86_cpu_to_node_map[];\n+struct kmem_cache { int size; };\n+extern struct kmem_cache kmalloc_caches[(12 + 2)];\n+struct tracepoint { void **funcs; } __attribute__ ((aligned (32)));\n+extern struct tracepoint __tracepoint_kmalloc_node;\n+void *__kmalloc_node (size_t size, gfp_t flags, int node);\n+\n+static inline int\n+cpu_to_node (int cpu)\n+{\n+  return per_cpu__x86_cpu_to_node_map[cpu];\n+}\n+\n+static inline void\n+trace_kmalloc_node (unsigned long call_site, const void *ptr,\n+\t\t    size_t bytes_req, size_t bytes_alloc, gfp_t gfp_flags,\n+\t\t    int node)\n+{\n+  asm goto (\"\" : : : : trace_label);\n+  if (0)\n+    {\n+\t  void **it_func;\n+    trace_label:\n+\t  asm (\"\" : \"=r\"(it_func) : \"0\"(&__tracepoint_kmalloc_node.funcs));\n+    }\n+};\n+\n+static inline __attribute__ ((always_inline)) int\n+kmalloc_index (size_t size)\n+{\n+  if (size <= 64)\n+    return 6;\n+  return -1;\n+}\n+\n+static inline __attribute__ ((always_inline)) struct kmem_cache *\n+kmalloc_slab (size_t size)\n+{\n+  int index = kmalloc_index (size);\n+  if (index == 0)\n+    return ((void *) 0);\n+  return &kmalloc_caches[index];\n+}\n+\n+static inline __attribute__ ((always_inline)) void *\n+kmalloc_node (size_t size, gfp_t flags, int node)\n+{\n+  void *ret;\n+  if (__builtin_constant_p (size) && size <= (2 * ((1UL) << 12))\n+      && !(flags & ((gfp_t) 0x01u)))\n+    {\n+      struct kmem_cache *s = kmalloc_slab (size);\n+      if (!s)\n+\treturn ((void *) 16);\n+      trace_kmalloc_node (({ __here:(unsigned long) &&__here;}),\n+\t\t\t  ret, size, s->size, flags, node);\n+    }\n+  return __kmalloc_node (size, flags, node);\n+}\n+\n+int\n+process_zones (int cpu)\n+{\n+  struct zone *zone, *dzone;\n+  int node = cpu_to_node (cpu);\n+  for (zone = (first_online_pgdat ())->node_zones;\n+       zone; zone = next_zone (zone))\n+      {\n+\t((zone)->pageset[(cpu)]) =\n+\t  kmalloc_node (sizeof (struct per_cpu_pageset),\n+\t\t\t(((gfp_t) 0x10u) | ((gfp_t) 0x40u) | ((gfp_t) 0x80u)),\n+\t\t\tnode);\n+\tif (!((zone)->pageset[(cpu)]))\n+\t  goto bad;\n+      }\n+  return 0;\n+bad:\n+  XYZZY ();\n+  return -12;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"XYZZY\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f596c75fe275b820a839362a31356576973fa485", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -99,6 +99,7 @@ static void make_edges (void);\n static void make_cond_expr_edges (basic_block);\n static void make_gimple_switch_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n+static void make_gimple_asm_edges (basic_block);\n static unsigned int locus_map_hash (const void *);\n static int locus_map_eq (const void *, const void *);\n static void assign_discriminator (location_t, basic_block);\n@@ -572,6 +573,11 @@ make_edges (void)\n \t      fallthru = true;\n \t      break;\n \n+\t    case GIMPLE_ASM:\n+\t      make_gimple_asm_edges (bb);\n+\t      fallthru = true;\n+\t      break;\n+\n \t    case GIMPLE_OMP_PARALLEL:\n \t    case GIMPLE_OMP_TASK:\n \t    case GIMPLE_OMP_FOR:\n@@ -593,13 +599,11 @@ make_edges (void)\n \t      fallthru = false;\n \t      break;\n \n-\n             case GIMPLE_OMP_ATOMIC_LOAD:\n             case GIMPLE_OMP_ATOMIC_STORE:\n                fallthru = true;\n                break;\n \n-\n \t    case GIMPLE_OMP_RETURN:\n \t      /* In the case of a GIMPLE_OMP_SECTION, the edge will go\n \t\t somewhere other than the next block.  This will be\n@@ -1011,6 +1015,23 @@ make_goto_expr_edges (basic_block bb)\n   make_abnormal_goto_edges (bb, false);\n }\n \n+/* Create edges for an asm statement with labels at block BB.  */\n+\n+static void\n+make_gimple_asm_edges (basic_block bb)\n+{\n+  gimple stmt = last_stmt (bb);\n+  location_t stmt_loc = gimple_location (stmt);\n+  int i, n = gimple_asm_nlabels (stmt);\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));\n+      basic_block label_bb = label_to_block (label);\n+      make_edge (bb, label_bb, 0);\n+      assign_discriminator (stmt_loc, label_bb);\n+    }\n+}\n \n /*---------------------------------------------------------------------------\n \t\t\t       Flowgraph analysis\n@@ -1188,15 +1209,28 @@ cleanup_dead_labels (void)\n \t    break;\n \t  }\n \n+\tcase GIMPLE_ASM:\n+\t  {\n+\t    int i, n = gimple_asm_nlabels (stmt);\n+\n+\t    for (i = 0; i < n; ++i)\n+\t      {\n+\t\ttree cons = gimple_asm_label_op (stmt, i);\n+\t\ttree label = main_block_label (TREE_VALUE (cons));\n+\t\tTREE_VALUE (cons) = label;\n+\t      }\n+\t    break;\n+\t  }\n+\n \t/* We have to handle gotos until they're removed, and we don't\n \t   remove them until after we've created the CFG edges.  */\n \tcase GIMPLE_GOTO:\n           if (!computed_goto_p (stmt))\n \t    {\n \t      tree new_dest = main_block_label (gimple_goto_dest (stmt));\n \t      gimple_goto_set_dest (stmt, new_dest);\n-\t      break;\n \t    }\n+\t  break;\n \n \tdefault:\n \t  break;\n@@ -2821,6 +2855,11 @@ is_ctrl_altering_stmt (gimple t)\n \t fallthru to the next statement as well.  */\n       return true;\n \n+    case GIMPLE_ASM:\n+      if (gimple_asm_nlabels (t) > 0)\n+\treturn true;\n+      break;\n+\n     CASE_GIMPLE_OMP:\n       /* OpenMP directives alter control flow.  */\n       return true;\n@@ -5184,9 +5223,22 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \t\t  CASE_LABEL (elt) = label;\n \t      }\n \t  }\n+      }\n+      break;\n \n-\tbreak;\n+    case GIMPLE_ASM:\n+      {\n+\tint i, n = gimple_asm_nlabels (stmt);\n+\ttree label = gimple_block_label (dest);\n+\n+\tfor (i = 0; i < n; ++i)\n+\t  {\n+\t    tree cons = gimple_asm_label_op (stmt, i);\n+\t    if (label_to_block (TREE_VALUE (cons)) == e->dest)\n+\t      TREE_VALUE (cons) = label;\n+\t  }\n       }\n+      break;\n \n     case GIMPLE_RETURN:\n       gsi_remove (&gsi, true);"}, {"sha": "c1ba96aa9663fc811700b656bd4dbc5eaa95434f", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -875,8 +875,9 @@ DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 3)\n /* Used to represent an inline assembly statement.  ASM_STRING returns a\n    STRING_CST for the instruction (e.g., \"mov x, y\"). ASM_OUTPUTS,\n    ASM_INPUTS, and ASM_CLOBBERS represent the outputs, inputs, and clobbers\n-   for the statement.  */\n-DEFTREECODE (ASM_EXPR, \"asm_expr\", tcc_statement, 4)\n+   for the statement.  ASM_LABELS, if present, indicates various destinations\n+   for the asm; labels cannot be combined with outputs.  */\n+DEFTREECODE (ASM_EXPR, \"asm_expr\", tcc_statement, 5)\n \n /* Variable references for SSA analysis.  New SSA names are created every\n    time a variable is assigned a new value.  The SSA builder uses SSA_NAME"}, {"sha": "70650489dd9ca4aba4e3a75d707a148dac392cec", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1c384bf142c81baaad7f04c5d3fdaebcbafc5b0c", "patch": "@@ -1626,6 +1626,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_EXPR_CHECK (NODE), 1)\n #define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_EXPR_CHECK (NODE), 2)\n #define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_EXPR_CHECK (NODE), 3)\n+#define ASM_LABELS(NODE)\tTREE_OPERAND (ASM_EXPR_CHECK (NODE), 4)\n /* Nonzero if we want to create an ASM_INPUT instead of an\n    ASM_OPERAND with no operands.  */\n #define ASM_INPUT_P(NODE) (ASM_EXPR_CHECK (NODE)->base.static_flag)\n@@ -5087,7 +5088,7 @@ extern bool parse_output_constraint (const char **, int, int, int,\n extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n extern void expand_asm_stmt (gimple);\n-extern tree resolve_asm_operand_names (tree, tree, tree);\n+extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n extern void expand_case (gimple);\n extern void expand_decl (tree);\n #ifdef HARD_CONST"}]}