{"sha": "ebcc44f4ad40870b4cf551647ece950cab07793b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjYzQ0ZjRhZDQwODcwYjRjZjU1MTY0N2VjZTk1MGNhYjA3NzkzYg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-04-13T15:38:12Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-04-13T15:38:12Z"}, "message": "c4x.md (storeqf_int, [...]): Add new patterns with corresponding splitters to handle moves of floating point...\n\n\t* config/c4x/c4x.md (storeqf_int, storeqf_int_clobber, loadqf_int,\n \tloadqf_int_clobber): Add new patterns with corresponding splitters\n \tto handle moves of floating point values into and out of intager\n \tregisters by using memory.\n\t* config/c4x/c4x.c (c4x_check_legit_addr): Disallow PRE_INC for modes\n\tother than QFmode and QImode.\n\t(mixed_subreg_operand): New function.\n\t(c4x_emit_move_sequence): If moving a floating point value into or\n\tout of an integer register, use the new patterns storeqf_int_clobber\n\tor loadqf_int_clobber.\n\t(reg_imm_operand, *_reg_operand): Call reg_operand instead of\n\tregister_operand.\n\t(reg_operand, src_operand): Disallow operand if it satisifes\n\tmixed_subreg_operand.\n\t* config/c4x/c4x.h (mixed_subreg_operand): Add prototype.\n\nFrom-SVN: r26413", "tree": {"sha": "46bc5e9d9ecbefeba698d9d586f3ecb44872eeec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46bc5e9d9ecbefeba698d9d586f3ecb44872eeec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebcc44f4ad40870b4cf551647ece950cab07793b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcc44f4ad40870b4cf551647ece950cab07793b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebcc44f4ad40870b4cf551647ece950cab07793b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcc44f4ad40870b4cf551647ece950cab07793b/comments", "author": null, "committer": null, "parents": [{"sha": "b985a30f322f6e5d744e1b70a6d83e238543d652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b985a30f322f6e5d744e1b70a6d83e238543d652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b985a30f322f6e5d744e1b70a6d83e238543d652"}], "stats": {"total": 208, "additions": 199, "deletions": 9}, "files": [{"sha": "929a5700afdf3cdf5be7d7b35290d54acfb7638b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebcc44f4ad40870b4cf551647ece950cab07793b", "patch": "@@ -1,3 +1,23 @@\n+Wed Apr 14 10:04:27 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md (storeqf_int, storeqf_int_clobber, loadqf_int,\n+ \tloadqf_int_clobber): Add new patterns with corresponding splitters\n+ \tto handle moves of floating point values into and out of intager\n+ \tregisters by using memory.\n+\n+\t* config/c4x/c4x.c (c4x_check_legit_addr): Disallow PRE_INC for modes\n+\tother than QFmode and QImode.\n+\t(mixed_subreg_operand): New function.\n+\t(c4x_emit_move_sequence): If moving a floating point value into or\n+\tout of an integer register, use the new patterns storeqf_int_clobber\n+\tor loadqf_int_clobber.\n+\t(reg_imm_operand, *_reg_operand): Call reg_operand instead of \n+\tregister_operand.\n+\t(reg_operand, src_operand): Disallow operand if it satisifes\n+\tmixed_subreg_operand.\n+\n+\t* config/c4x/c4x.h (mixed_subreg_operand): Add prototype.\n+\n Tue Apr 13 14:49:13 1999  Jan Hubicka <hubicka@freesoft.cz>\n \n \t* i386.c (agi_dependent): Handle push operation more correctly."}, {"sha": "61cf7b70505fe9c35f7bf03822c630e9764f260a", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 82, "deletions": 8, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=ebcc44f4ad40870b4cf551647ece950cab07793b", "patch": "@@ -1099,6 +1099,56 @@ c4x_emit_move_sequence (operands, mode)\n \t\t\t    gen_rtx_LO_SUM (Pmode, dp_reg, XEXP (op0, 0)));\n     }\n \n+  if (GET_CODE (op0) == SUBREG\n+      && mixed_subreg_operand (op0, mode))\n+    {\n+      /* We should only generate these mixed mode patterns\n+\t during RTL generation.  If we need do it later on\n+\t then we'll have to emit patterns that won't clobber CC.  */\n+      if (reload_in_progress || reload_completed)\n+\tabort ();\n+      if (GET_MODE (SUBREG_REG (op0)) == QImode)\n+\top0 = SUBREG_REG (op0);\n+      else if (GET_MODE (SUBREG_REG (op0)) == HImode)\n+\t{\n+\t  op0 = copy_rtx (op0);\n+\t  PUT_MODE (op0, QImode);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (mode == QFmode)\n+\temit_insn (gen_storeqf_int_clobber (op0, op1));\n+      else\n+\tabort ();\n+      return 1;\n+    }\n+\n+  if (GET_CODE (op1) == SUBREG\n+      && mixed_subreg_operand (op1, mode))\n+    {\n+      /* We should only generate these mixed mode patterns\n+\t during RTL generation.  If we need do it later on\n+\t then we'll have to emit patterns that won't clobber CC.  */\n+      if (reload_in_progress || reload_completed)\n+\tabort ();\n+      if (GET_MODE (SUBREG_REG (op1)) == QImode)\n+\top1 = SUBREG_REG (op1);\n+      else if (GET_MODE (SUBREG_REG (op1)) == HImode)\n+\t{\n+\t  op1 = copy_rtx (op1);\n+\t  PUT_MODE (op1, QImode);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (mode == QFmode)\n+\temit_insn (gen_loadqf_int_clobber (op0, op1));\n+      else\n+\tabort ();\n+      return 1;\n+    }\n+\n   /* Adjust operands in case we have modified them.  */\n   operands[0] = op0;\n   operands[1] = op1;\n@@ -1250,10 +1300,11 @@ c4x_check_legit_addr (mode, addr, strict)\n \t being pushed on the stack.  */\n \n     case PRE_DEC:\n+    case PRE_INC:\n     case POST_DEC:\n       if (mode != QImode && mode != QFmode)\n \treturn 0;\n-    case PRE_INC:\n+\n     case POST_INC:\n       base = XEXP (addr, 0);\n       if (! REG_P (base))\n@@ -2653,10 +2704,29 @@ reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  if (GET_CODE (op) == SUBREG\n+      && GET_MODE (op) == QFmode)\n+    return 0;\n   return register_operand (op, mode);\n }\n \n \n+int\n+mixed_subreg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Allow (subreg:HF (reg:HI)) that be generated for a union of an\n+     int and a long double.  */\n+  if (GET_CODE (op) == SUBREG\n+      && (GET_MODE (op) == QFmode)\n+      && (GET_MODE (SUBREG_REG (op)) == QImode\n+\t  || GET_MODE (SUBREG_REG (op)) == HImode))\n+    return 1;\n+  return 0;\n+}\n+\n+\n int\n reg_imm_operand (op, mode)\n      rtx op;\n@@ -2733,7 +2803,7 @@ r0r1_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2748,7 +2818,7 @@ r2r3_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2763,7 +2833,7 @@ ext_low_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2778,7 +2848,7 @@ ext_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2795,7 +2865,7 @@ std_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2810,7 +2880,7 @@ addr_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   return c4x_a_register (op);\n }\n@@ -2823,7 +2893,7 @@ index_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! register_operand (op, mode))\n+  if (! reg_operand (op, mode))\n     return 0;\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -2914,6 +2984,10 @@ src_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  if (GET_CODE (op) == SUBREG\n+      && mixed_subreg_operand (op, mode))\n+    return 0;\n+\n   if (REG_P (op))\n     return reg_operand (op, mode);\n "}, {"sha": "743e8e862fe847222f03cac7e273fdcd727b7600", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=ebcc44f4ad40870b4cf551647ece950cab07793b", "patch": "@@ -2655,6 +2655,8 @@ extern int reg_or_const_operand ();\n \n extern int reg_operand ();\n \n+extern int mixed_subreg_operand ();\n+\n extern int reg_imm_operand ();\n \n extern int r0r1_reg_operand ();"}, {"sha": "97f67a5c4d66636b4916042713353a7fd0da10ea", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebcc44f4ad40870b4cf551647ece950cab07793b/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=ebcc44f4ad40870b4cf551647ece950cab07793b", "patch": "@@ -449,7 +449,9 @@\n ;  8 loadhf_int\n ;  9 storehf_int\n ; 10 RSQRF\n-\n+; 11 loadqf_int\n+; 12 storeqf_int\n+; 22 rptb_init\n \n ;\n ; C4x FUNCTIONAL UNITS\n@@ -2968,6 +2970,98 @@\n     DONE;\n }\")\n \n+; This can generate invalid stack slot displacements\n+(define_split\n+ [(set (match_operand:QI 0 \"reg_operand\" \"=r\")\n+       (unspec [(match_operand:QF 1 \"reg_operand\" \"f\")] 12))]\n+  \"reload_completed\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"operands[2] = assign_stack_temp (QImode, GET_MODE_SIZE (QImode), 0);\n+   operands[3] = copy_rtx (operands[2]);\n+   PUT_MODE (operands[3], QFmode);\")\n+\n+\n+(define_insn \"storeqf_int\"\n+ [(set (match_operand:QI 0 \"reg_operand\" \"=r\")\n+       (unspec [(match_operand:QF 1 \"reg_operand\" \"f\")] 12))]\n+ \"\"\n+ \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+ [(parallel [(set (match_operand:QI 0 \"reg_operand\" \"=r\")\n+                  (unspec [(match_operand:QF 1 \"reg_operand\" \"f\")] 12))\n+             (clobber (reg:CC 21))])]\n+  \"reload_completed\"\n+  [(set (mem:QF (pre_inc:QI (reg:QI 20)))\n+        (match_dup 1))\n+   (parallel [(set (match_dup 0)\n+                   (mem:QI (post_dec:QI (reg:QI 20))))\n+              (clobber (reg:CC 21))])]\n+  \"\")\n+\n+\n+; We need accurate death notes for this...\n+;(define_peephole\n+;  [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+;        (match_operand:QF 1 \"memory_operand\" \"m\"))\n+;   (set (mem:QF (pre_inc:QI (reg:QI 20)))\n+;        (match_dup 0))\n+;   (parallel [(set (match_operand:QI 2 \"reg_operand\" \"r\")\n+;                   (mem:QI (post_dec:QI (reg:QI 20))))\n+;              (clobber (reg:CC 21))])]\n+;  \"\"\n+;  \"ldiu\\\\t%1,%0\")\n+\n+(define_insn \"storeqf_int_clobber\"\n+ [(parallel [(set (match_operand:QI 0 \"reg_operand\" \"=r\")\n+                  (unspec [(match_operand:QF 1 \"reg_operand\" \"f\")] 12))\n+             (clobber (reg:CC 21))])]\n+ \"\"\n+ \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+\n+; This can generate invalid stack slot displacements\n+(define_split\n+ [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+       (unspec [(match_operand:QI 1 \"reg_operand\" \"r\")] 11))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 3))]\n+  \"operands[2] = assign_stack_temp (QImode, GET_MODE_SIZE (QImode), 0);\n+   operands[3] = copy_rtx (operands[2]);\n+   PUT_MODE (operands[3], QFmode);\")\n+\n+\n+(define_insn \"loadqf_int\"\n+ [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+       (unspec [(match_operand:QI 1 \"reg_operand\" \"r\")] 11))]\n+ \"\"\n+ \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split\n+ [(parallel [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+                  (unspec [(match_operand:QI 1 \"reg_operand\" \"r\")] 11))\n+             (clobber (reg:CC 21))])]\n+  \"reload_completed\"\n+  [(set (mem:QI (pre_inc:QI (reg:QI 20)))\n+        (match_dup 1))\n+   (parallel [(set (match_dup 0)\n+                   (mem:QF (post_dec:QI (reg:QI 20))))\n+              (clobber (reg:CC 21))])]\n+  \"\")\n+\n+(define_insn \"loadqf_int_clobber\"\n+ [(parallel [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+                  (unspec [(match_operand:QI 1 \"reg_operand\" \"r\")] 11))\n+             (clobber (reg:CC 21))])]\n+ \"\"\n+ \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n ; We must provide an alternative to store to memory in case we have to\n ; spill a register.\n (define_insn \"movqf_noclobber\""}]}