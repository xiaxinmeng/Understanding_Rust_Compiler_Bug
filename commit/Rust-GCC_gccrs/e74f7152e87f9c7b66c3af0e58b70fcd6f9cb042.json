{"sha": "e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc0ZjcxNTJlODdmOWM3YjY2YzNhZjBlNThiNzBmY2Q2ZjljYjA0Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-12-10T20:13:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-12-10T20:13:14Z"}, "message": "nvptx.c (nvptx_function_arg, [...]): Move earlier.\n\n\t* config/nvptx/nvptx.c (nvptx_function_arg,\n\tnvptx_function_incoming_arg, nvptx_function_arg_advance,\n\tnvptx_strict_argument_naming, nvptx_function_arg_boundary,\n\tnvptx_libcall_value, nvptx_function_value,\n\tnvptx_function_value_regno_p, nvptx_pass_by_reference,\n\tnvptx_return_in_memory, nvptx_promote_function_mode,\n\tnvptx_static_chain): Move earlier.\n\t(write_one_arg): Break out as helper fn for ...\n\t(write_arg): ... this new function.  Adjust all callers.\n\nFrom-SVN: r231543", "tree": {"sha": "8c7dbd1010cffa0b680d87fa6087e4d6e9c0226f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c7dbd1010cffa0b680d87fa6087e4d6e9c0226f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35bd8e8fb68675f42f407cf47b2e8df1cd0110e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35bd8e8fb68675f42f407cf47b2e8df1cd0110e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35bd8e8fb68675f42f407cf47b2e8df1cd0110e2"}], "stats": {"total": 479, "additions": 250, "deletions": 229}, "files": [{"sha": "27ccfc8cf72fea099f1729449a77a3393bae8a40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "patch": "@@ -1,3 +1,15 @@\n+2015-12-10  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.c (nvptx_function_arg,\n+\tnvptx_function_incoming_arg, nvptx_function_arg_advance,\n+\tnvptx_strict_argument_naming, nvptx_function_arg_boundary,\n+\tnvptx_libcall_value, nvptx_function_value,\n+\tnvptx_function_value_regno_p, nvptx_pass_by_reference,\n+\tnvptx_return_in_memory, nvptx_promote_function_mode,\n+\tnvptx_static_chain): Move earlier.\n+\t(write_one_arg): Break out as helper fn for ...\n+\t(write_arg): ... this new function.  Adjust all callers.\n+\n 2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-streamer-out.c (wrap_refs): Only wrap public decls."}, {"sha": "5bd2662574e4d97bd89d45efdc160a3d52ea4058", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 238, "deletions": 229, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=e74f7152e87f9c7b66c3af0e58b70fcd6f9cb042", "patch": "@@ -389,69 +389,270 @@ arg_promotion (machine_mode mode)\n   return mode;\n }\n \n-/* Process function parameter TYPE, either emitting in a prototype\n-   argument, or as a copy a in a function prologue.  ARGNO is the\n-   index of this argument in the PTX function.  FOR_REG is negative,\n-   if we're emitting the PTX prototype.  It is zero if we're copying\n-   to an argument register and it is greater than zero if we're\n-   copying to a specific hard register.  PROTOTYPED is true, if this\n-   is a prototyped function, rather than an old-style C declaration.\n+/* Implement TARGET_FUNCTION_ARG.  */\n \n-   The behaviour here must match the regular GCC function parameter\n-   marshalling machinery.  */\n+static rtx\n+nvptx_function_arg (cumulative_args_t, machine_mode mode,\n+\t\t    const_tree, bool named)\n+{\n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n \n-static int\n-write_one_arg (std::stringstream &s, int for_reg, int argno,\n-\t       tree type, bool prototyped)\n+  if (named)\n+    return gen_reg_rtx (mode);\n+  return NULL_RTX;\n+}\n+\n+/* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n+\n+static rtx\n+nvptx_function_incoming_arg (cumulative_args_t cum_v, machine_mode mode,\n+\t\t\t     const_tree, bool named)\n {\n-  machine_mode mode = TYPE_MODE (type);\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  if (mode == VOIDmode)\n+    return NULL_RTX;\n \n-  if (!PASS_IN_REG_P (mode, type))\n-    mode = Pmode;\n+  if (!named)\n+    return NULL_RTX;\n \n-  machine_mode split = maybe_split_mode (mode);\n-  if (split != VOIDmode)\n+  /* No need to deal with split modes here, the only case that can\n+     happen is complex modes and those are dealt with by\n+     TARGET_SPLIT_COMPLEX_ARG.  */\n+  return gen_rtx_UNSPEC (mode,\n+\t\t\t gen_rtvec (1, GEN_INT (cum->count)),\n+\t\t\t UNSPEC_ARG_REG);\n+}\n+\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n+\n+static void\n+nvptx_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    machine_mode ARG_UNUSED (mode),\n+\t\t\t    const_tree ARG_UNUSED (type),\n+\t\t\t    bool ARG_UNUSED (named))\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  cum->count++;\n+}\n+\n+/* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.\n+\n+   For nvptx, we know how to handle functions declared as stdarg: by\n+   passing an extra pointer to the unnamed arguments.  However, the\n+   Fortran frontend can produce a different situation, where a\n+   function pointer is declared with no arguments, but the actual\n+   function and calls to it take more arguments.  In that case, we\n+   want to ensure the call matches the definition of the function.  */\n+\n+static bool\n+nvptx_strict_argument_naming (cumulative_args_t cum_v)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  return cum->fntype == NULL_TREE || stdarg_p (cum->fntype);\n+}\n+\n+/* Implement TARGET_FUNCTION_ARG_BOUNDARY.  */\n+\n+static unsigned int\n+nvptx_function_arg_boundary (machine_mode mode, const_tree type)\n+{\n+  unsigned int boundary = type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode);\n+\n+  if (boundary > BITS_PER_WORD)\n+    return 2 * BITS_PER_WORD;\n+\n+  if (mode == BLKmode)\n     {\n-      mode = split;\n-      argno = write_one_arg (s, for_reg, argno,\n-\t\t\t     TREE_TYPE (type), prototyped);\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      if (size > 4)\n+        return 2 * BITS_PER_WORD;\n+      if (boundary < BITS_PER_WORD)\n+        {\n+          if (size >= 3)\n+            return BITS_PER_WORD;\n+          if (size >= 2)\n+            return 2 * BITS_PER_UNIT;\n+        }\n     }\n+  return boundary;\n+}\n \n-  if (!prototyped && !AGGREGATE_TYPE_P (type))\n+/* Implement TARGET_LIBCALL_VALUE.  */\n+\n+static rtx\n+nvptx_libcall_value (machine_mode mode, const_rtx)\n+{\n+  if (cfun->machine->start_call == NULL_RTX)\n+    /* Pretend to return in a hard reg for early uses before pseudos can be\n+       generated.  */\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  return gen_reg_rtx (mode);\n+}\n+\n+/* TARGET_FUNCTION_VALUE implementation.  Returns an RTX representing the place\n+   where function FUNC returns or receives a value of data type TYPE.  */\n+\n+static rtx\n+nvptx_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED,\n+\t\t      bool outgoing)\n+{\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  machine_mode orig_mode = TYPE_MODE (type);\n+  machine_mode mode = promote_function_mode (type, orig_mode,\n+\t\t\t\t\t     &unsignedp, NULL_TREE, 1);\n+  if (outgoing)\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  if (cfun->machine->start_call == NULL_RTX)\n+    /* Pretend to return in a hard reg for early uses before pseudos can be\n+       generated.  */\n+    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n+  return gen_reg_rtx (mode);\n+}\n+\n+/* Implement TARGET_FUNCTION_VALUE_REGNO_P.  */\n+\n+static bool\n+nvptx_function_value_regno_p (const unsigned int regno)\n+{\n+  return regno == NVPTX_RETURN_REGNUM;\n+}\n+\n+/* Types with a mode other than those supported by the machine are passed by\n+   reference in memory.  */\n+\n+static bool\n+nvptx_pass_by_reference (cumulative_args_t, machine_mode mode,\n+\t\t\t const_tree type, bool)\n+{\n+  return !PASS_IN_REG_P (mode, type);\n+}\n+\n+/* Implement TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+nvptx_return_in_memory (const_tree type, const_tree)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  if (!RETURN_IN_REG_P (mode))\n+    return true;\n+  return false;\n+}\n+\n+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */\n+\n+static machine_mode\n+nvptx_promote_function_mode (const_tree type, machine_mode mode,\n+\t\t\t     int *punsignedp,\n+\t\t\t     const_tree funtype, int for_return)\n+{\n+  if (type == NULL_TREE)\n+    return mode;\n+  if (for_return)\n+    return promote_mode (type, mode, punsignedp);\n+  /* For K&R-style functions, try to match the language promotion rules to\n+     minimize type mismatches at assembly time.  */\n+  if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n+      && type != NULL_TREE\n+      && !AGGREGATE_TYPE_P (type))\n     {\n       if (mode == SFmode)\n \tmode = DFmode;\n       mode = arg_promotion (mode);\n     }\n \n+  return mode;\n+}\n+\n+/* Implement TARGET_STATIC_CHAIN.  */\n+\n+static rtx\n+nvptx_static_chain (const_tree fndecl, bool incoming_p)\n+{\n+  if (!DECL_STATIC_CHAIN (fndecl))\n+    return NULL;\n+\n+  if (incoming_p)\n+    return gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+  else\n+    return gen_rtx_REG (Pmode, OUTGOING_STATIC_CHAIN_REGNUM);\n+}\n+\n+/* Helper for write_arg.  Emit a single PTX argument of MODE, either\n+   in a prototype, or as copy in a function prologue.  ARGNO is the\n+   index of this argument in the PTX function.  FOR_REG is negative,\n+   if we're emitting the PTX prototype.  It is zero if we're copying\n+   to an argument register and it is greater than zero if we're\n+   copying to a specific hard register.  */\n+\n+static int\n+write_one_arg (std::stringstream &s, int for_reg, int argno, machine_mode mode)\n+{\n+  const char *ptx_type = nvptx_ptx_type_from_mode (mode, false);\n+\n   if (for_reg < 0)\n     {\n       /* Writing PTX prototype.  */\n       s << (argno ? \", \" : \" (\");\n-      s << \".param\" << nvptx_ptx_type_from_mode (mode, false)\n-\t<< \" %in_ar\" << argno;\n+      s << \".param\" << ptx_type << \" %in_ar\" << argno;\n       if (mode == QImode || mode == HImode)\n \ts << \"[1]\";\n     }\n   else\n     {\n-      mode = arg_promotion (mode);\n-      s << \"\\t.reg\" << nvptx_ptx_type_from_mode (mode, false) << \" \";\n+      s << \"\\t.reg\" << ptx_type << \" \";\n       if (for_reg)\n \ts << reg_names[for_reg];\n       else\n \ts << \"%ar\" << argno;\n       s << \";\\n\";\n-      s << \"\\tld.param\" << nvptx_ptx_type_from_mode (mode, false) << \" \";\n+      s << \"\\tld.param\" << ptx_type << \" \";\n       if (for_reg)\n \ts << reg_names[for_reg];\n       else\n \ts << \"%ar\" << argno;\n-      s<< \", [%in_ar\" << argno << \"];\\n\";\n+      s << \", [%in_ar\" << argno << \"];\\n\";\n     }\n   return argno + 1;\n }\n \n+/* Process function parameter TYPE to emit one or more PTX\n+   arguments.  PROTOTYPED is true, if this is a prototyped function,\n+   rather than an old-style C declaration.\n+\n+   The promotion behaviour here must match the regular GCC function\n+   parameter marshalling machinery.  */\n+\n+static int\n+write_arg (std::stringstream &s, int for_reg, int argno,\n+\t   tree type, bool prototyped)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+\n+  if (mode == VOIDmode)\n+    return argno;\n+\n+  if (!PASS_IN_REG_P (mode, type))\n+    mode = Pmode;\n+\n+  machine_mode split = maybe_split_mode (mode);\n+  if (split != VOIDmode)\n+    mode = split;\n+\n+  if (!prototyped && !AGGREGATE_TYPE_P (type))\n+    {\n+      if (mode == SFmode)\n+\tmode = DFmode;\n+      mode = arg_promotion (mode);\n+    }\n+  else if (for_reg >= 0)\n+    mode = arg_promotion (mode);\n+\n+  if (split != VOIDmode)\n+    argno = write_one_arg (s, for_reg, argno, mode);\n+  return write_one_arg (s, for_reg, argno, mode);\n+}\n+\n static bool\n write_return (std::stringstream &s, bool for_proto, tree type,\n \t      machine_mode ret_mode)\n@@ -555,7 +756,7 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n \n   /* Emit argument list.  */\n   if (return_in_mem)\n-    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg (s, -1, argno, ptr_type_node, true);\n \n   /* We get:\n      NULL in TYPE_ARG_TYPES, for old-style functions\n@@ -574,20 +775,19 @@ write_fn_proto (std::stringstream &s, bool is_defn,\n     {\n       tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n \n-      if (type != void_type_node)\n-\targno = write_one_arg (s, -1, argno, type, prototyped);\n+      argno = write_arg (s, -1, argno, type, prototyped);\n     }\n \n   if (stdarg_p (fntype))\n-    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg (s, -1, argno, ptr_type_node, true);\n \n   if (DECL_STATIC_CHAIN (decl))\n-    argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n+    argno = write_arg (s, -1, argno, ptr_type_node, true);\n \n   if (!argno && strcmp (name, \"main\") == 0)\n     {\n-      argno = write_one_arg (s, -1, argno, integer_type_node, true);\n-      argno = write_one_arg (s, -1, argno, ptr_type_node, true);\n+      argno = write_arg (s, -1, argno, integer_type_node, true);\n+      argno = write_arg (s, -1, argno, ptr_type_node, true);\n     }\n \n   if (argno)\n@@ -743,7 +943,7 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n   bool return_in_mem = write_return (s, false, result_type,\n \t\t\t\t     (machine_mode)cfun->machine->ret_reg_mode);\n   if (return_in_mem)\n-    argno = write_one_arg (s, 0, argno, ptr_type_node, true);\n+    argno = write_arg (s, 0, argno, ptr_type_node, true);\n   \n   /* Declare and initialize incoming arguments.  */\n   tree args = TYPE_ARG_TYPES (fntype);\n@@ -758,15 +958,14 @@ nvptx_declare_function_name (FILE *file, const char *name, const_tree decl)\n     {\n       tree type = prototyped ? TREE_VALUE (args) : TREE_TYPE (args);\n \n-      if (type != void_type_node)\n-\targno = write_one_arg (s, 0, argno, type, prototyped);\n+      argno = write_arg (s, 0, argno, type, prototyped);\n     }\n \n   if (stdarg_p (fntype))\n-    argno = write_one_arg (s, ARG_POINTER_REGNUM, argno, ptr_type_node, true);\n+    argno = write_arg (s, ARG_POINTER_REGNUM, argno, ptr_type_node, true);\n \n   if (DECL_STATIC_CHAIN (decl))\n-    argno = write_one_arg (s, STATIC_CHAIN_REGNUM, argno, ptr_type_node, true);\n+    argno = write_arg (s, STATIC_CHAIN_REGNUM, argno, ptr_type_node, true);\n \n   fprintf (file, \"%s\", s.str().c_str());\n \n@@ -1001,196 +1200,6 @@ nvptx_expand_call (rtx retval, rtx address)\n   if (tmp_retval != retval)\n     emit_move_insn (retval, tmp_retval);\n }\n-\n-/* Implement TARGET_FUNCTION_ARG.  */\n-\n-static rtx\n-nvptx_function_arg (cumulative_args_t, machine_mode mode,\n-\t\t    const_tree, bool named)\n-{\n-  if (mode == VOIDmode)\n-    return NULL_RTX;\n-\n-  if (named)\n-    return gen_reg_rtx (mode);\n-  return NULL_RTX;\n-}\n-\n-/* Implement TARGET_FUNCTION_INCOMING_ARG.  */\n-\n-static rtx\n-nvptx_function_incoming_arg (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t     const_tree, bool named)\n-{\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  if (mode == VOIDmode)\n-    return NULL_RTX;\n-\n-  if (!named)\n-    return NULL_RTX;\n-\n-  /* No need to deal with split modes here, the only case that can\n-     happen is complex modes and those are dealt with by\n-     TARGET_SPLIT_COMPLEX_ARG.  */\n-  return gen_rtx_UNSPEC (mode,\n-\t\t\t gen_rtvec (1, GEN_INT (cum->count)),\n-\t\t\t UNSPEC_ARG_REG);\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n-\n-static void\n-nvptx_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t    machine_mode ARG_UNUSED (mode),\n-\t\t\t    const_tree ARG_UNUSED (type),\n-\t\t\t    bool ARG_UNUSED (named))\n-{\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  cum->count++;\n-}\n-\n-/* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.\n-\n-   For nvptx, we know how to handle functions declared as stdarg: by\n-   passing an extra pointer to the unnamed arguments.  However, the\n-   Fortran frontend can produce a different situation, where a\n-   function pointer is declared with no arguments, but the actual\n-   function and calls to it take more arguments.  In that case, we\n-   want to ensure the call matches the definition of the function.  */\n-\n-static bool\n-nvptx_strict_argument_naming (cumulative_args_t cum_v)\n-{\n-  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  return cum->fntype == NULL_TREE || stdarg_p (cum->fntype);\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG_BOUNDARY.  */\n-\n-static unsigned int\n-nvptx_function_arg_boundary (machine_mode mode, const_tree type)\n-{\n-  unsigned int boundary = type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode);\n-\n-  if (boundary > BITS_PER_WORD)\n-    return 2 * BITS_PER_WORD;\n-\n-  if (mode == BLKmode)\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      if (size > 4)\n-        return 2 * BITS_PER_WORD;\n-      if (boundary < BITS_PER_WORD)\n-        {\n-          if (size >= 3)\n-            return BITS_PER_WORD;\n-          if (size >= 2)\n-            return 2 * BITS_PER_UNIT;\n-        }\n-    }\n-  return boundary;\n-}\n-\n-/* TARGET_FUNCTION_VALUE implementation.  Returns an RTX representing the place\n-   where function FUNC returns or receives a value of data type TYPE.  */\n-\n-static rtx\n-nvptx_function_value (const_tree type, const_tree func ATTRIBUTE_UNUSED,\n-\t\t      bool outgoing)\n-{\n-  int unsignedp = TYPE_UNSIGNED (type);\n-  machine_mode orig_mode = TYPE_MODE (type);\n-  machine_mode mode = promote_function_mode (type, orig_mode,\n-\t\t\t\t\t     &unsignedp, NULL_TREE, 1);\n-  if (outgoing)\n-    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n-  if (cfun->machine->start_call == NULL_RTX)\n-    /* Pretend to return in a hard reg for early uses before pseudos can be\n-       generated.  */\n-    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n-  return gen_reg_rtx (mode);\n-}\n-\n-/* Implement TARGET_LIBCALL_VALUE.  */\n-\n-static rtx\n-nvptx_libcall_value (machine_mode mode, const_rtx)\n-{\n-  if (cfun->machine->start_call == NULL_RTX)\n-    /* Pretend to return in a hard reg for early uses before pseudos can be\n-       generated.  */\n-    return gen_rtx_REG (mode, NVPTX_RETURN_REGNUM);\n-  return gen_reg_rtx (mode);\n-}\n-\n-/* Implement TARGET_FUNCTION_VALUE_REGNO_P.  */\n-\n-static bool\n-nvptx_function_value_regno_p (const unsigned int regno)\n-{\n-  return regno == NVPTX_RETURN_REGNUM;\n-}\n-\n-/* Types with a mode other than those supported by the machine are passed by\n-   reference in memory.  */\n-\n-static bool\n-nvptx_pass_by_reference (cumulative_args_t, machine_mode mode,\n-\t\t\t const_tree type, bool)\n-{\n-  return !PASS_IN_REG_P (mode, type);\n-}\n-\n-/* Implement TARGET_RETURN_IN_MEMORY.  */\n-\n-static bool\n-nvptx_return_in_memory (const_tree type, const_tree)\n-{\n-  machine_mode mode = TYPE_MODE (type);\n-  if (!RETURN_IN_REG_P (mode))\n-    return true;\n-  return false;\n-}\n-\n-/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */\n-\n-static machine_mode\n-nvptx_promote_function_mode (const_tree type, machine_mode mode,\n-\t\t\t     int *punsignedp,\n-\t\t\t     const_tree funtype, int for_return)\n-{\n-  if (type == NULL_TREE)\n-    return mode;\n-  if (for_return)\n-    return promote_mode (type, mode, punsignedp);\n-  /* For K&R-style functions, try to match the language promotion rules to\n-     minimize type mismatches at assembly time.  */\n-  if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n-      && type != NULL_TREE\n-      && !AGGREGATE_TYPE_P (type))\n-    {\n-      if (mode == SFmode)\n-\tmode = DFmode;\n-      mode = arg_promotion (mode);\n-    }\n-\n-  return mode;\n-}\n-\n-/* Implement TARGET_STATIC_CHAIN.  */\n-\n-static rtx\n-nvptx_static_chain (const_tree fndecl, bool incoming_p)\n-{\n-  if (!DECL_STATIC_CHAIN (fndecl))\n-    return NULL;\n-\n-  if (incoming_p)\n-    return gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-  else\n-    return gen_rtx_REG (Pmode, OUTGOING_STATIC_CHAIN_REGNUM);\n-}\n-\f\n /* Emit a comparison COMPARE, and return the new test to be used in the\n    jump.  */\n "}]}