{"sha": "357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU3ZDk1NmViZDUxOTgzZDRhMTVkY2Q0ZGU2Y2I0OWRiYTdkYjljYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-01-03T08:41:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-01-03T08:41:21Z"}, "message": "re PR c++/25635 (Bogus cruft in error message for invalid operator declaration)\n\n\tPR c++/25635\n\t* class.c (add_method): Set TYPE_HAS_CONVERSION for classes with a\n\tconversion operator.\n\t* decl.c (grokdeclarator): Do not set TYPE_HAS_CONVERSION here.\n\tPR c++/25638\n\t* class.c (add_method): Never associate more than one destructor\n\twith a single class.\n\tPR c++/25637\n\t* cp-tree.h (do_friend): Adjust prototype.\n\t* decl.c (grokfndecl): Make funcdef_flag a bool, not an int.\n\t(grokdeclarator): Likewise.  Refine check for invalid\n\tdeclarations/definitions of member functions outside of their own\n\tclass.\n\t* friend.c (do_friend): Make funcdef_flag a bool, not an int.\n\tPR c++/25633\n\t* parser.c (cp_parser_mem_initializer_list): Check result of\n\tcp_parser_mem_initializer against error_mark_node, not NULL_TREE.\n\t(cp_parser_mem_initializer): Return error_mark_node for failure.\n\tPR c++/25634\n\t* parser.c (cp_parser_template_parameter_list): Call\n\tbegin_template_parm_list and end_template_parm_list here.\n\t(cp_parser_type_parameter): Not here.\n\t(cp_parser_template_declaration_after_export): Or here.\n\t(cp_parser_elaborated_type_specifier): Call\n\tcp_parser_check_template_parameters.\n\t* tree.c (build_target_expr_with_type): Use force_target_expr.\n\tPR c++/25635\n\t* g++.dg/parse/operator6.C: New test.\n\tPR c++/25637\n\t* g++.dg/parse/error29.C: New test.\n\tPR c++/25638\n\t* g++.dg/parse/dtor6.C: New test.\n\tPR c++/25633\n\t* g++.dg/parse/ctor3.C: New test.\n\tPR c++/25634\n\t* g++.dg/template/class3.C: New test.\n\nFrom-SVN: r109270", "tree": {"sha": "9713a84588cc7b909eb491c5c4a8940742cf7efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9713a84588cc7b909eb491c5c4a8940742cf7efa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/comments", "author": null, "committer": null, "parents": [{"sha": "622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc"}], "stats": {"total": 200, "additions": 145, "deletions": 55}, "files": [{"sha": "4c0381220dfa7f69c33f36c7770eb5b69ef844c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -1,5 +1,37 @@\n 2006-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/25635\n+\t* class.c (add_method): Set TYPE_HAS_CONVERSION for classes with a\n+\tconversion operator.\n+\t* decl.c (grokdeclarator): Do not set TYPE_HAS_CONVERSION here.\n+\n+\tPR c++/25638\n+\t* class.c (add_method): Never associate more than one destructor\n+\twith a single class.\n+\n+\tPR c++/25637\n+\t* cp-tree.h (do_friend): Adjust prototype.\n+\t* decl.c (grokfndecl): Make funcdef_flag a bool, not an int.\n+\t(grokdeclarator): Likewise.  Refine check for invalid\n+\tdeclarations/definitions of member functions outside of their own\n+\tclass.\n+\t* friend.c (do_friend): Make funcdef_flag a bool, not an int.\n+\n+\tPR c++/25633\n+\t* parser.c (cp_parser_mem_initializer_list): Check result of\n+\tcp_parser_mem_initializer against error_mark_node, not NULL_TREE.\n+\t(cp_parser_mem_initializer): Return error_mark_node for failure.\n+\n+\tPR c++/25634\n+\t* parser.c (cp_parser_template_parameter_list): Call\n+\tbegin_template_parm_list and end_template_parm_list here.\n+\t(cp_parser_type_parameter): Not here.\n+\t(cp_parser_template_declaration_after_export): Or here.\n+\t(cp_parser_elaborated_type_specifier): Call\n+\tcp_parser_check_template_parameters.\n+\n+\t* tree.c (build_target_expr_with_type): Use force_target_expr.\n+\n \t* decl2.c (mark_used): Fix typo in comment.\n \n 2006-01-02  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>"}, {"sha": "4509ac23bbb7dc33f4f3c7e3ff86adbfc91cfe8c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -1059,10 +1059,16 @@ add_method (tree type, tree method, tree using_decl)\n \t}\n     }\n \n+  /* A class should never have more than one destructor.  */ \n+  if (current_fns && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n+    return false;\n+\n   /* Add the new binding.  */\n   overload = build_overload (method, current_fns);\n \n-  if (!conv_p && slot >= CLASSTYPE_FIRST_CONVERSION_SLOT && !complete_p)\n+  if (conv_p)\n+    TYPE_HAS_CONVERSION (type) = 1;\n+  else if (slot >= CLASSTYPE_FIRST_CONVERSION_SLOT && !complete_p)\n     push_class_level_binding (DECL_NAME (method), overload);\n \n   if (insert_p)"}, {"sha": "3fbaff86916c48c71788f10dbae231ee377d9bd1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -3935,7 +3935,7 @@ extern tree cplus_expand_constant\t\t(tree);\n extern int is_friend\t\t\t\t(tree, tree);\n extern void make_friend_class\t\t\t(tree, tree, bool);\n extern void add_friend\t\t\t\t(tree, tree, bool);\n-extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, cp_cv_quals, int);\n+extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, cp_cv_quals, bool);\n \n /* in init.c */\n extern tree expand_member_init\t\t\t(tree);"}, {"sha": "020d96f7fd5ddc5eb9665b60f597914aaff7f20c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -5697,7 +5697,7 @@ grokfndecl (tree ctype,\n \t    int publicp,\n \t    int inlinep,\n \t    special_function_kind sfk,\n-\t    int funcdef_flag,\n+\t    bool funcdef_flag,\n \t    int template_count,\n \t    tree in_namespace,\n \t    tree* attrlist)\n@@ -5918,7 +5918,7 @@ grokfndecl (tree ctype,\n \n   decl = check_explicit_specialization (orig_declarator, decl,\n \t\t\t\t\ttemplate_count,\n-\t\t\t\t\t2 * (funcdef_flag != 0) +\n+\t\t\t\t\t2 * funcdef_flag +\n \t\t\t\t\t4 * (friendp != 0));\n   if (decl == error_mark_node)\n     return NULL_TREE;\n@@ -5940,27 +5940,26 @@ grokfndecl (tree ctype,\n \t\t\t\t > template_class_depth (ctype))\n \t\t\t\t? current_template_parms\n \t\t\t\t: NULL_TREE);\n-\n-      if (old_decl && TREE_CODE (old_decl) == TEMPLATE_DECL)\n-\t/* Because grokfndecl is always supposed to return a\n-\t   FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT\n-\t   here.  We depend on our callers to figure out that its\n-\t   really a template that's being returned.  */\n-\told_decl = DECL_TEMPLATE_RESULT (old_decl);\n-\n-      if (old_decl && DECL_STATIC_FUNCTION_P (old_decl)\n-\t  && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\t/* Remove the `this' parm added by grokclassfn.\n-\t   XXX Isn't this done in start_function, too?  */\n-\trevert_static_member_fn (decl);\n-      if (old_decl && DECL_ARTIFICIAL (old_decl))\n-\terror (\"definition of implicitly-declared %qD\", old_decl);\n-\n       if (old_decl)\n \t{\n \t  tree ok;\n \t  tree pushed_scope;\n \n+\t  if (TREE_CODE (old_decl) == TEMPLATE_DECL)\n+\t    /* Because grokfndecl is always supposed to return a\n+\t       FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT\n+\t       here.  We depend on our callers to figure out that its\n+\t       really a template that's being returned.  */\n+\t    old_decl = DECL_TEMPLATE_RESULT (old_decl);\n+\n+\t  if (DECL_STATIC_FUNCTION_P (old_decl)\n+\t      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n+\t    /* Remove the `this' parm added by grokclassfn.\n+\t       XXX Isn't this done in start_function, too?  */\n+\t    revert_static_member_fn (decl);\n+\t  if (DECL_ARTIFICIAL (old_decl))\n+\t    error (\"definition of implicitly-declared %qD\", old_decl);\n+\n \t  /* Since we've smashed OLD_DECL to its\n \t     DECL_TEMPLATE_RESULT, we must do the same to DECL.  */\n \t  if (TREE_CODE (decl) == TEMPLATE_DECL)\n@@ -6627,7 +6626,8 @@ grokdeclarator (const cp_declarator *declarator,\n   tree typedef_decl = NULL_TREE;\n   const char *name = NULL;\n   tree typedef_type = NULL_TREE;\n-  int funcdef_flag = 0;\n+  /* True if this declarator is a function definition.  */\n+  bool funcdef_flag = false;\n   cp_declarator_kind innermost_code = cdk_error;\n   int bitfield = 0;\n #if 0\n@@ -6674,9 +6674,9 @@ grokdeclarator (const cp_declarator *declarator,\n   thread_p = declspecs->specs[(int)ds_thread];\n \n   if (decl_context == FUNCDEF)\n-    funcdef_flag = 1, decl_context = NORMAL;\n+    funcdef_flag = true, decl_context = NORMAL;\n   else if (decl_context == MEMFUNCDEF)\n-    funcdef_flag = -1, decl_context = FIELD;\n+    funcdef_flag = true, decl_context = FIELD;\n   else if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n \n@@ -7349,8 +7349,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t&& (friendp == 0 || dname == current_class_name))\n \t      ctype = current_class_type;\n \n-\t    if (ctype && sfk == sfk_conversion)\n-\t      TYPE_HAS_CONVERSION (ctype) = 1;\n \t    if (ctype && (sfk == sfk_constructor\n \t\t\t  || sfk == sfk_destructor))\n \t      {\n@@ -7604,22 +7602,25 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  tree sname = declarator->u.id.unqualified_name;\n \n+\t  if (current_class_type\n+\t      && (!friendp || funcdef_flag))\n+\t    {\n+\t      error (funcdef_flag\n+\t\t     ? \"cannot define member function %<%T::%s%> within %<%T%>\"\n+\t\t     : \"cannot declare member function %<%T::%s%> within %<%T%>\",\n+\t\t     ctype, name, current_class_type);\n+\t      return error_mark_node;\n+\t    }\n+\n \t  if (TREE_CODE (sname) == IDENTIFIER_NODE\n \t      && NEW_DELETE_OPNAME_P (sname))\n \t    /* Overloaded operator new and operator delete\n \t       are always static functions.  */\n \t    ;\n-\t  else if (current_class_type == NULL_TREE || friendp)\n-\t    type\n-\t      = build_method_type_directly (ctype,\n-\t\t\t\t\t    TREE_TYPE (type),\n-\t\t\t\t\t    TYPE_ARG_TYPES (type));\n \t  else\n-\t    {\n-\t      error (\"cannot declare member function %<%T::%s%> within %<%T%>\",\n-\t\t     ctype, name, current_class_type);\n-\t      return error_mark_node;\n-\t    }\n+\t    type = build_method_type_directly (ctype,\n+\t\t\t\t\t       TREE_TYPE (type),\n+\t\t\t\t\t       TYPE_ARG_TYPES (type));\n \t}\n       else if (declspecs->specs[(int)ds_typedef]\n \t       || COMPLETE_TYPE_P (complete_type (ctype)))\n@@ -8179,7 +8180,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    decl = check_explicit_specialization\n \t\t      (unqualified_id, decl, template_count,\n-\t\t       2 * (funcdef_flag != 0) + 4);\n+\t\t       2 * funcdef_flag + 4);\n \t\t    if (decl == error_mark_node)\n \t\t      return error_mark_node;\n \t\t  }"}, {"sha": "0ae9130b61abb6d249ded687f137707388b1e616", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -408,7 +408,7 @@ tree\n do_friend (tree ctype, tree declarator, tree decl,\n \t   tree attrlist, enum overload_flags flags,\n \t   cp_cv_quals quals,\n-\t   int funcdef_flag)\n+\t   bool funcdef_flag)\n {\n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;"}, {"sha": "bfcf2612acfabe27e38ab3c1dcc670c49b8e8765", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -7808,7 +7808,7 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n       /* Parse the mem-initializer.  */\n       mem_initializer = cp_parser_mem_initializer (parser);\n       /* Add it to the list, unless it was erroneous.  */\n-      if (mem_initializer)\n+      if (mem_initializer != error_mark_node)\n \t{\n \t  TREE_CHAIN (mem_initializer) = mem_initializer_list;\n \t  mem_initializer_list = mem_initializer;\n@@ -7837,7 +7837,8 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n \n    Returns a TREE_LIST.  The TREE_PURPOSE is the TYPE (for a base\n    class) or FIELD_DECL (for a non-static data member) to initialize;\n-   the TREE_VALUE is the expression-list.  */\n+   the TREE_VALUE is the expression-list.  An empty initialization\n+   list is represented by void_list_node.  */\n \n static tree\n cp_parser_mem_initializer (cp_parser* parser)\n@@ -7862,12 +7863,14 @@ cp_parser_mem_initializer (cp_parser* parser)\n     = cp_parser_parenthesized_expression_list (parser, false,\n \t\t\t\t\t       /*cast_p=*/false,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n+  if (expression_list == error_mark_node)\n+    return error_mark_node;\n   if (!expression_list)\n     expression_list = void_type_node;\n \n   in_base_initializer = 0;\n \n-  return member ? build_tree_list (member, expression_list) : NULL_TREE;\n+  return member ? build_tree_list (member, expression_list) : error_mark_node;\n }\n \n /* Parse a mem-initializer-id.\n@@ -8277,6 +8280,7 @@ cp_parser_template_parameter_list (cp_parser* parser)\n {\n   tree parameter_list = NULL_TREE;\n \n+  begin_template_parm_list ();\n   while (true)\n     {\n       tree parameter;\n@@ -8299,7 +8303,7 @@ cp_parser_template_parameter_list (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n-  return parameter_list;\n+  return end_template_parm_list (parameter_list);\n }\n \n /* Parse a template-parameter.\n@@ -8447,10 +8451,7 @@ cp_parser_type_parameter (cp_parser* parser)\n \t/* Look for the `<'.  */\n \tcp_parser_require (parser, CPP_LESS, \"`<'\");\n \t/* Parse the template-parameter-list.  */\n-\tbegin_template_parm_list ();\n-\tparameter_list\n-\t  = cp_parser_template_parameter_list (parser);\n-\tparameter_list = end_template_parm_list (parameter_list);\n+\tparameter_list = cp_parser_template_parameter_list (parser);\n \t/* Look for the `>'.  */\n \tcp_parser_require (parser, CPP_GREATER, \"`>'\");\n \t/* Look for the `class' keyword.  */\n@@ -10112,6 +10113,11 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t    (parser->num_template_parameter_lists\n \t     && (cp_parser_next_token_starts_class_definition_p (parser)\n \t\t || cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)));\n+\t  /* An unqualified name was used to reference this type, so\n+\t     there were no qualifying templates.  */\n+\t  if (!cp_parser_check_template_parameters (parser, \n+\t\t\t\t\t\t    /*num_templates=*/0))\n+\t    return error_mark_node;\n \t  type = xref_tag (tag_type, identifier, ts, template_p);\n \t}\n     }\n@@ -15259,12 +15265,8 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       parameter_list = NULL_TREE;\n     }\n   else\n-    {\n-      /* Parse the template parameters.  */\n-      begin_template_parm_list ();\n-      parameter_list = cp_parser_template_parameter_list (parser);\n-      parameter_list = end_template_parm_list (parameter_list);\n-    }\n+    /* Parse the template parameters.  */\n+    parameter_list = cp_parser_template_parameter_list (parser);\n \n   /* Look for the `>'.  */\n   cp_parser_skip_until_found (parser, CPP_GREATER, \"`>'\");"}, {"sha": "df59f5003def9f60d6bcf9e1893ab4757c4e332d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -325,8 +325,6 @@ build_cplus_new (tree type, tree init)\n tree\n build_target_expr_with_type (tree init, tree type)\n {\n-  tree slot;\n-\n   gcc_assert (!VOID_TYPE_P (type));\n \n   if (TREE_CODE (init) == TARGET_EXPR)\n@@ -342,8 +340,7 @@ build_target_expr_with_type (tree init, tree type)\n        aggregate; there's no additional work to be done.  */\n     return force_rvalue (init);\n \n-  slot = build_local_temp (type);\n-  return build_target_expr (slot, init);\n+  return force_target_expr (type, init);\n }\n \n /* Like the above function, but without the checking.  This function should"}, {"sha": "f96ba05f169699620e9bc2b71aaddefc94beafc8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -1,3 +1,20 @@\n+2006-01-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25635\n+\t* g++.dg/parse/operator6.C: New test.\n+\n+\tPR c++/25637\n+\t* g++.dg/parse/error29.C: New test.\n+\n+\tPR c++/25638\n+\t* g++.dg/parse/dtor6.C: New test.\n+\n+\tPR c++/25633\n+\t* g++.dg/parse/ctor3.C: New test.\n+\n+\tPR c++/25634\n+\t* g++.dg/template/class3.C: New test.\n+\n 2006-01-02  Geoffrey Keating  <geoffk@apple.com>\n \n \t* g++.dg/debug/debug9.C: New."}, {"sha": "193ffae24fef811aabc8a5665f5b443e520e3258", "filename": "gcc/testsuite/g++.dg/parse/ctor3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fctor3.C?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/25633\n+\n+struct A {};\n+\n+struct B : A\n+{\n+  B() : A {} // { dg-error \"expected\" }\n+};"}, {"sha": "3333161c39986feb6f0731f807bb546834210956", "filename": "gcc/testsuite/g++.dg/parse/dtor6.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor6.C?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/25638\n+\n+struct A { ~A(); }; // { dg-error \"candidate\" }  \n+\n+struct B : A\n+{\n+  template<int> friend A::~A(); // { dg-error \"match\" }\n+};"}, {"sha": "b50b275a9e622aba1cc7e4bb4f8228793f32a0c6", "filename": "gcc/testsuite/g++.dg/parse/error29.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror29.C?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/25637\n+\n+struct A { \n+  void foo();\n+  A(); \n+  void operator delete(void *);\n+};\n+struct B { \n+  friend void A::foo() {} // { dg-error \"define\" }\n+  friend void A::operator delete(void*) {} // { dg-error \"define\" }\n+  friend A::A() {} // { dg-error \"define\" }\n+};"}, {"sha": "e58a3a682c3169f1e6a090636c52ee5fff314478", "filename": "gcc/testsuite/g++.dg/parse/operator6.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/25635\n+\n+struct A {};\n+\n+A::operator int(); // { dg-error \"class\" }"}, {"sha": "44a02a60bd5406ffb1035e2bab29942e081f315b", "filename": "gcc/testsuite/g++.dg/template/class3.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fclass3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/357d956ebd51983d4a15dcd4de6cb49dba7db9ca/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fclass3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fclass3.C?ref=357d956ebd51983d4a15dcd4de6cb49dba7db9ca", "patch": "@@ -0,0 +1,2 @@\n+// PR c++/25634\n+template<int> template<int> struct A; // { dg-error \"too many\" }"}]}