{"sha": "7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2MDJjNGRjMjhjMGViMjRmZWM1MGZlMjBhZjc4YzEzMTE0ZThhNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-03-10T06:42:40Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-03-10T06:42:40Z"}, "message": "[IEPM] [PR debug/84620] use constant form for DW_AT_GNU_entry_view\n\nWhen outputting entry views in symbolic mode, we used to use a lbl_id,\nbut that outputs the view as an addr, perhaps even in an indirect one,\nwhich is all excessive and undesirable for a small assembler-computed\nconstant.\n\nIntroduce a new value class for symbolic views, so that we can output\nthe labels as constant data, using as narrow forms as possible, but\nwide enough for any symbolic views output in the compilation.  We\ndon't know exactly where the assembler will reset views, but we count\nthe symbolic views since known reset points and use that as an upper\nbound for view numbers.\n\nIdeally, we'd use uleb128, but then the compiler would have to defer\n.debug_info offset computation to the assembler.  I'm not going there\nfor now, so a symbolic uleb128 assembler constant in an attribute is\nnot something GCC can deal with ATM.\n\nfor  gcc/ChangeLog\n\n\tPR debug/84620\n\t* dwarf2out.h (dw_val_class): Add dw_val_class_symview.\n\t(dw_val_node): Add val_symbolic_view.\n\t* dwarf2out.c (dw_line_info_table): Add symviews_since_reset.\n\t(symview_upper_bound): New.\n\t(new_line_info_table): Initialize symviews_since_reset.\n\t(dwarf2out_source_line): Count symviews_since_reset and set\n\tsymview_upper_bound.\n\t(dw_val_equal_p): Handle symview.\n\t(add_AT_symview): New.\n\t(print_dw_val): Handle symview.\n\t(attr_checksum, attr_checksum_ordered): Likewise.\n\t(same_dw_val_p, size_of_die): Likewise.\n\t(value_format, output_die): Likewise.\n\t(add_high_low_attributes): Use add_AT_symview for entry_view.\n\t(dwarf2out_finish): Reset symview_upper_bound, clear\n\tzero_view_p.\n\nFrom-SVN: r258411", "tree": {"sha": "4de84df5e003b3f53849813f2f9e7085cf81b1fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4de84df5e003b3f53849813f2f9e7085cf81b1fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/comments", "author": null, "committer": null, "parents": [{"sha": "7ed12599fa74fdfd9bd36853b50a6086f89df061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ed12599fa74fdfd9bd36853b50a6086f89df061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ed12599fa74fdfd9bd36853b50a6086f89df061"}], "stats": {"total": 126, "additions": 119, "deletions": 7}, "files": [{"sha": "8b10e33f804b3fae76d6ffe7589e27cae3486170", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "patch": "@@ -1,3 +1,23 @@\n+2018-03-10  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/84620\n+\t* dwarf2out.h (dw_val_class): Add dw_val_class_symview.\n+\t(dw_val_node): Add val_symbolic_view.\n+\t* dwarf2out.c (dw_line_info_table): Add symviews_since_reset.\n+\t(symview_upper_bound): New.\n+\t(new_line_info_table): Initialize symviews_since_reset.\n+\t(dwarf2out_source_line): Count symviews_since_reset and set\n+\tsymview_upper_bound.\n+\t(dw_val_equal_p): Handle symview.\n+\t(add_AT_symview): New.\n+\t(print_dw_val): Handle symview.\n+\t(attr_checksum, attr_checksum_ordered): Likewise.\n+\t(same_dw_val_p, size_of_die): Likewise.\n+\t(value_format, output_die): Likewise.\n+\t(add_high_low_attributes): Use add_AT_symview for entry_view.\n+\t(dwarf2out_finish): Reset symview_upper_bound, clear\n+\tzero_view_p.\n+\n 2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>\n \n \tPR target/83969"}, {"sha": "4e6ee5e8f82e0283476e096b1421759c011068c1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "patch": "@@ -1434,6 +1434,8 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n       return a->v.val_die_ref.die == b->v.val_die_ref.die;\n     case dw_val_class_fde_ref:\n       return a->v.val_fde_index == b->v.val_fde_index;\n+    case dw_val_class_symview:\n+      return strcmp (a->v.val_symbolic_view, b->v.val_symbolic_view) == 0;\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n@@ -2951,6 +2953,11 @@ struct GTY(()) dw_line_info_table {\n      going to ask the assembler to assign.  */\n   var_loc_view view;\n \n+  /* This counts the number of symbolic views emitted in this table\n+     since the latest view reset.  Its max value, over all tables,\n+     sets symview_upper_bound.  */\n+  var_loc_view symviews_since_reset;\n+\n #define FORCE_RESET_NEXT_VIEW(x) ((x) = (var_loc_view)-1)\n #define RESET_NEXT_VIEW(x) ((x) = (var_loc_view)0)\n #define FORCE_RESETTING_VIEW_P(x) ((x) == (var_loc_view)-1)\n@@ -2959,6 +2966,13 @@ struct GTY(()) dw_line_info_table {\n   vec<dw_line_info_entry, va_gc> *entries;\n };\n \n+/* This is an upper bound for view numbers that the assembler may\n+   assign to symbolic views output in this translation.  It is used to\n+   decide how big a field to use to represent view numbers in\n+   symview-classed attributes.  */\n+\n+static var_loc_view symview_upper_bound;\n+\n /* If we're keep track of location views and their reset points, and\n    INSN is a reset point (i.e., it necessarily advances the PC), mark\n    the next view in TABLE as reset.  */\n@@ -3603,6 +3617,7 @@ static addr_table_entry *add_addr_table_entry (void *, enum ate_kind);\n static void remove_addr_table_entry (addr_table_entry *);\n static void add_AT_addr (dw_die_ref, enum dwarf_attribute, rtx, bool);\n static inline rtx AT_addr (dw_attr_node *);\n+static void add_AT_symview (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_lbl_id (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_lineptr (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_macptr (dw_die_ref, enum dwarf_attribute, const char *);\n@@ -5117,6 +5132,21 @@ add_AT_vms_delta (dw_die_ref die, enum dwarf_attribute attr_kind,\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Add a symbolic view identifier attribute value to a DIE.  */\n+\n+static inline void\n+add_AT_symview (dw_die_ref die, enum dwarf_attribute attr_kind,\n+               const char *view_label)\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_symview;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_symbolic_view = xstrdup (view_label);\n+  add_dwarf_attr (die, &attr);\n+}\n+\n /* Add a label identifier attribute value to a DIE.  */\n \n static inline void\n@@ -6460,6 +6490,9 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n       fprintf (outfile, \"delta: @slotcount(%s-%s)\",\n \t       val->v.val_vms_delta.lbl2, val->v.val_vms_delta.lbl1);\n       break;\n+    case dw_val_class_symview:\n+      fprintf (outfile, \"view: %s\", val->v.val_symbolic_view);\n+      break;\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n@@ -6831,6 +6864,7 @@ attr_checksum (dw_attr_node *at, struct md5_ctx *ctx, int *mark)\n \n     case dw_val_class_fde_ref:\n     case dw_val_class_vms_delta:\n+    case dw_val_class_symview:\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n@@ -7127,6 +7161,7 @@ attr_checksum_ordered (enum dwarf_tag tag, dw_attr_node *at,\n       break;\n \n     case dw_val_class_fde_ref:\n+    case dw_val_class_symview:\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n@@ -7627,6 +7662,9 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n     case dw_val_class_die_ref:\n       return same_die_p (v1->v.val_die_ref.die, v2->v.val_die_ref.die, mark);\n \n+    case dw_val_class_symview:\n+      return strcmp (v1->v.val_symbolic_view, v2->v.val_symbolic_view) == 0;\n+\n     case dw_val_class_fde_ref:\n     case dw_val_class_vms_delta:\n     case dw_val_class_lbl_id:\n@@ -9287,6 +9325,16 @@ size_of_die (dw_die_ref die)\n \t      size += csize;\n \t  }\n \t  break;\n+\tcase dw_val_class_symview:\n+\t  if (symview_upper_bound <= 0xff)\n+\t    size += 1;\n+\t  else if (symview_upper_bound <= 0xffff)\n+\t    size += 2;\n+\t  else if (symview_upper_bound <= 0xffffffff)\n+\t    size += 4;\n+\t  else\n+\t    size += 8;\n+\t  break;\n \tcase dw_val_class_const_implicit:\n \tcase dw_val_class_unsigned_const_implicit:\n \tcase dw_val_class_file_implicit:\n@@ -9735,6 +9783,17 @@ value_format (dw_attr_node *a)\n \tdefault:\n \t  return DW_FORM_block1;\n \t}\n+    case dw_val_class_symview:\n+      /* ??? We might use uleb128, but then we'd have to compute\n+\t .debug_info offsets in the assembler.  */\n+      if (symview_upper_bound <= 0xff)\n+\treturn DW_FORM_data1;\n+      else if (symview_upper_bound <= 0xffff)\n+\treturn DW_FORM_data2;\n+      else if (symview_upper_bound <= 0xffffffff)\n+\treturn DW_FORM_data4;\n+      else\n+\treturn DW_FORM_data8;\n     case dw_val_class_vec:\n       switch (constant_size (a->dw_attr_val.v.val_vec.length\n \t\t\t     * a->dw_attr_val.v.val_vec.elt_size))\n@@ -10500,6 +10559,22 @@ output_die (dw_die_ref die)\n \t  }\n \t  break;\n \n+\tcase dw_val_class_symview:\n+\t  {\n+\t    int vsize;\n+\t    if (symview_upper_bound <= 0xff)\n+\t      vsize = 1;\n+\t    else if (symview_upper_bound <= 0xffff)\n+\t      vsize = 2;\n+\t    else if (symview_upper_bound <= 0xffffffff)\n+\t      vsize = 4;\n+\t    else\n+\t      vsize = 8;\n+\t    dw2_asm_output_addr (vsize, a->dw_attr_val.v.val_symbolic_view,\n+\t\t\t\t \"%s\", name);\n+\t  }\n+\t  break;\n+\n \tcase dw_val_class_const_implicit:\n \t  if (flag_debug_asm)\n \t    fprintf (asm_out_file, \"\\t\\t\\t%s %s (\"\n@@ -23815,7 +23890,7 @@ add_high_low_attributes (tree stmt, dw_die_ref die)\n \t\t indirecting them through a table might make things\n \t\t easier, but even that would be more wasteful,\n \t\t space-wise, than what we have now.  */\n-\t      add_AT_lbl_id (die, DW_AT_GNU_entry_view, label);\n+\t      add_AT_symview (die, DW_AT_GNU_entry_view, label);\n \t    }\n \t}\n \n@@ -27412,6 +27487,7 @@ new_line_info_table (void)\n   table->line_num = 1;\n   table->is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n   FORCE_RESET_NEXT_VIEW (table->view);\n+  table->symviews_since_reset = 0;\n \n   return table;\n }\n@@ -27609,11 +27685,16 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t  /* If we're using the assembler to compute view numbers, we\n \t     can't issue a .loc directive for line zero, so we can't\n \t     get a view number at this point.  We might attempt to\n-\t     compute it from the previous view, but since we're\n-\t     omitting the line number entry, we might as well omit the\n-\t     view number as well.  That means pretending it's a view\n-\t     number zero, which might very well turn out to be\n-\t     correct.  */\n+\t     compute it from the previous view, or equate it to a\n+\t     subsequent view (though it might not be there!), but\n+\t     since we're omitting the line number entry, we might as\n+\t     well omit the view number as well.  That means pretending\n+\t     it's a view number zero, which might very well turn out\n+\t     to be correct.  ??? Extend the assembler so that the\n+\t     compiler could emit e.g. \".locview .LVU#\", to output a\n+\t     view without changing line number information.  We'd then\n+\t     have to count it in symviews_since_reset; when it's omitted,\n+\t     it doesn't count.  */\n \t  if (!zero_view_p)\n \t    zero_view_p = BITMAP_GGC_ALLOC ();\n \t  bitmap_set_bit (zero_view_p, table->view);\n@@ -27702,6 +27783,9 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t{\n \t  if (!RESETTING_VIEW_P (table->view))\n \t    {\n+\t      table->symviews_since_reset++;\n+\t      if (table->symviews_since_reset > symview_upper_bound)\n+\t\tsymview_upper_bound = table->symviews_since_reset;\n \t      /* When we're using the assembler to compute view\n \t\t numbers, we output symbolic labels after \"view\" in\n \t\t .loc directives, and the assembler will set them for\n@@ -27720,6 +27804,7 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t    }\n \t  else\n \t    {\n+\t      table->symviews_since_reset = 0;\n \t      if (FORCE_RESETTING_VIEW_P (table->view))\n \t\tfputs (\" view -0\", asm_out_file);\n \t      else\n@@ -31295,6 +31380,11 @@ dwarf2out_finish (const char *)\n       debug_line_str_hash->traverse<enum dwarf_form,\n \t\t\t\t    output_indirect_string> (form);\n     }\n+\n+  /* ??? Move lvugid out of dwarf2out_source_line and reset it too?  */\n+  symview_upper_bound = 0;\n+  if (zero_view_p)\n+    bitmap_clear (zero_view_p);\n }\n \n /* Returns a hash value for X (which really is a variable_value_struct).  */"}, {"sha": "a0ba414014d495067e4551d76881b60fccd43e4e", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b602c4dc28c0eb24fec50fe20af78c13114e8a6/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=7b602c4dc28c0eb24fec50fe20af78c13114e8a6", "patch": "@@ -161,7 +161,8 @@ enum dw_val_class\n   dw_val_class_const_implicit,\n   dw_val_class_unsigned_const_implicit,\n   dw_val_class_file_implicit,\n-  dw_val_class_view_list\n+  dw_val_class_view_list,\n+  dw_val_class_symview\n };\n \n /* Describe a floating point constant value, or a vector constant value.  */\n@@ -233,6 +234,7 @@ struct GTY(()) dw_val_node {\n \t} GTY ((tag (\"dw_val_class_vms_delta\"))) val_vms_delta;\n       dw_discr_value GTY ((tag (\"dw_val_class_discr_value\"))) val_discr_value;\n       dw_discr_list_ref GTY ((tag (\"dw_val_class_discr_list\"))) val_discr_list;\n+      char * GTY ((tag (\"dw_val_class_symview\"))) val_symbolic_view;\n     }\n   GTY ((desc (\"%1.val_class\"))) v;\n };"}]}