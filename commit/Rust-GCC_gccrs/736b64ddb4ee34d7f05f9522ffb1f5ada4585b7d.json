{"sha": "736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM2YjY0ZGRiNGVlMzRkN2YwNWY5NTIyZmZiMWY1YWRhNDU4NWI3ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-02-06T13:57:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-02-06T13:57:15Z"}, "message": "recog.c (split_all_insns): Do not update reg info.\n\n\t* recog.c (split_all_insns): Do not update reg info.\n\t* regrename.c (regrename_optimize): Likewise.\n\t* toplev.c (rest_of_handle_reorder_blocks): Likewise.\n\t* flow.c (struct propagate_block_info): Add insn_num field.\n\t(reg_deaths): New array.\n\t(life_analysis): Free reg_deaths info.\n\t(allocate_reg_life_data): Allocate reg_deaths array.\n\t(propagate_one_insn): Use new array.\n\t(init_propagate_block): Initialize it.\n\t(free_propagate_block_info): Finish compuation of\n\tREG_LIVE_LENGTH\n\t(attempt_auto_inc): Sanity check that REG_INFO is not\n\tcomputed at same time.\n\t(mark_used_regs): Update new array.\n\n\t* reg-stack.c (subst_stack_regs): Unshare clobbers before\n\tsubstitution.\n\nFrom-SVN: r77396", "tree": {"sha": "d2c09d295981dd120be3b0f716e287f0fc34cd6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2c09d295981dd120be3b0f716e287f0fc34cd6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/comments", "author": null, "committer": null, "parents": [{"sha": "2941cc061a7a0cafdfa0aec2be9387c92b590625", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2941cc061a7a0cafdfa0aec2be9387c92b590625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2941cc061a7a0cafdfa0aec2be9387c92b590625"}], "stats": {"total": 113, "additions": 101, "deletions": 12}, "files": [{"sha": "3eaa2a20b46b33c630842203697669f09c817f5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -1,3 +1,23 @@\n+2004-02-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* recog.c (split_all_insns): Do not update reg info.\n+\t* regrename.c (regrename_optimize): Likewise.\n+\t* toplev.c (rest_of_handle_reorder_blocks): Likewise.\n+\t* flow.c (struct propagate_block_info): Add insn_num field.\n+\t(reg_deaths): New array.\n+\t(life_analysis): Free reg_deaths info.\n+\t(allocate_reg_life_data): Allocate reg_deaths array.\n+\t(propagate_one_insn): Use new array.\n+\t(init_propagate_block): Initialize it.\n+\t(free_propagate_block_info): Finish compuation of\n+\tREG_LIVE_LENGTH\n+\t(attempt_auto_inc): Sanity check that REG_INFO is not\n+\tcomputed at same time.\n+\t(mark_used_regs): Update new array.\n+\n+\t* reg-stack.c (subst_stack_regs): Unshare clobbers before\n+\tsubstitution.\n+\n 2004-02-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/s390/s390.md (*extendsiqi2_short_displ): Change to"}, {"sha": "049a587903e9c7042f25d2e6208fb87b03f32198", "filename": "gcc/flow.c", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -264,11 +264,28 @@ struct propagate_block_info\n \n   /* Flags controlling the set of information propagate_block collects.  */\n   int flags;\n+  /* Index of instruction being processed.  */\n+  int insn_num;\n };\n \n /* Number of dead insns removed.  */\n static int ndead;\n \n+/* When PROP_REG_INFO set, array contains pbi->insn_num of instruction\n+   where given register died.  When the register is marked alive, we use the\n+   information to compute amount of instructions life range cross.\n+   (remember, we are walking backward).  This can be computed as current\n+   pbi->insn_num - reg_deaths[regno].\n+   At the end of processing each basic block, the remaining live registers\n+   are inspected and liferanges are increased same way so liverange of global\n+   registers are computed correctly.\n+  \n+   The array is maintained clear for dead registers, so it can be safely reused\n+   for next basic block without expensive memset of the whole array after\n+   reseting pbi->insn_num to 0.  */\n+\n+static int *reg_deaths;\n+\n /* Maximum length of pbi->mem_set_list before we start dropping\n    new elements on the floor.  */\n #define MAX_MEM_SET_LIST_LEN\t100\n@@ -458,6 +475,11 @@ life_analysis (rtx f, FILE *file, int flags)\n       memset (regs_asm_clobbered, 0, sizeof (regs_asm_clobbered));\n     }\n   update_life_info (NULL, UPDATE_LIFE_GLOBAL, flags);\n+  if (reg_deaths)\n+    {\n+      free (reg_deaths);\n+      reg_deaths = NULL;\n+    }\n \n   /* Clean up.  */\n   if (optimize && (flags & PROP_SCAN_DEAD_STORES))\n@@ -734,6 +756,11 @@ update_life_info (sbitmap blocks, enum update_life_extent extent, int prop_flags\n \t\t\t\t     }\n \t\t\t\t });\n     }\n+  if (reg_deaths)\n+    {\n+      free (reg_deaths);\n+      reg_deaths = NULL;\n+    }\n   timevar_pop ((extent == UPDATE_LIFE_LOCAL || blocks)\n \t       ? TV_LIFE_UPDATE : TV_LIFE);\n   if (ndead && rtl_dump_file)\n@@ -1457,6 +1484,9 @@ allocate_reg_life_data (void)\n   int i;\n \n   max_regno = max_reg_num ();\n+  if (reg_deaths)\n+    abort ();\n+  reg_deaths = xcalloc (sizeof (*reg_deaths), max_regno);\n \n   /* Recalculate the register space, in case it has grown.  Old style\n      vector oriented regsets would set regset_{size,bytes} here also.  */\n@@ -1783,6 +1813,9 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n \t    mark_used_regs (pbi, XEXP (XEXP (note, 0), 0), cond, insn);\n \n \t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n+\t  if ((flags & PROP_REG_INFO)\n+\t      && !REGNO_REG_SET_P (pbi->reg_live, STACK_POINTER_REGNUM))\n+\t    reg_deaths[STACK_POINTER_REGNUM] = pbi->insn_num;\n \t  SET_REGNO_REG_SET (pbi->reg_live, STACK_POINTER_REGNUM);\n \n \t  /* Calls may also reference any of the global registers,\n@@ -1793,11 +1826,7 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n \t}\n     }\n \n-  /* On final pass, update counts of how many insns in which each reg\n-     is live.  */\n-  if (flags & PROP_REG_INFO)\n-    EXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i,\n-\t\t\t       { REG_LIVE_LENGTH (i)++; });\n+  pbi->insn_num++;\n \n   return prev;\n }\n@@ -1820,6 +1849,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n   pbi->cond_local_set = cond_local_set;\n   pbi->cc0_live = 0;\n   pbi->flags = flags;\n+  pbi->insn_num = 0;\n \n   if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n     pbi->reg_next_use = xcalloc (max_reg_num (), sizeof (rtx));\n@@ -1976,6 +2006,16 @@ free_propagate_block_info (struct propagate_block_info *pbi)\n   BITMAP_XFREE (pbi->reg_cond_reg);\n #endif\n \n+  if (pbi->flags & PROP_REG_INFO)\n+    {\n+      int num = pbi->insn_num;\n+      int i;\n+\n+      EXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i,\n+\t { REG_LIVE_LENGTH (i) += num - reg_deaths[i];\n+\t   reg_deaths[i] = 0;\n+         });\n+    }\n   if (pbi->reg_next_use)\n     free (pbi->reg_next_use);\n \n@@ -2803,7 +2843,15 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t{\n \t  for (i = regno_first; i <= regno_last; ++i)\n \t    if (!(not_dead & (((unsigned long) 1) << (i - regno_first))))\n-\t      CLEAR_REGNO_REG_SET (pbi->reg_live, i);\n+\t      {\n+\t\tif ((pbi->flags & PROP_REG_INFO)\n+\t\t    && REGNO_REG_SET_P (pbi->reg_live, i))\n+\t\t  {\n+\t\t    REG_LIVE_LENGTH (i) += pbi->insn_num - reg_deaths[i];\n+\t\t    reg_deaths[i] = 0;\n+\t\t  }\n+\t\tCLEAR_REGNO_REG_SET (pbi->reg_live, i);\n+\t      }\n \t}\n     }\n   else if (GET_CODE (reg) == REG)\n@@ -3334,6 +3382,10 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n \t on this insn, which is incorrect.  */\n       SET_REGNO_REG_SET (pbi->reg_live, regno);\n \n+      /* We shall not do the autoinc during final pass.  */\n+      if (flags & PROP_REG_INFO)\n+\tabort ();\n+\n       /* If there are any calls between INSN and INCR, show\n \t that REGNO now crosses them.  */\n       for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n@@ -3365,6 +3417,9 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n       /* If the original source was dead, it's dead now.  */\n       rtx note;\n \n+      /* We shall not do the autoinc during final pass.  */\n+      if (flags & PROP_REG_INFO)\n+\tabort ();\n       while ((note = find_reg_note (incr, REG_DEAD, NULL_RTX)) != NULL_RTX)\n \t{\n \t  remove_note (incr, note);\n@@ -3550,6 +3605,15 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n \t  REG_FREQ (regno_first) += REG_FREQ_FROM_BB (pbi->bb);\n \t  REG_N_REFS (regno_first)++;\n \t}\n+      for (i = regno_first; i <= regno_last; ++i)\n+\tif (! REGNO_REG_SET_P (pbi->reg_live, i))\n+\t  {\n+#ifdef ENABLE_CHECKING\n+\t    if (reg_deaths[i])\n+\t      abort ();\n+#endif\n+\t    reg_deaths[i] = pbi->insn_num;\n+\t  }\n     }\n \n   /* Record and count the insns in which a reg dies.  If it is used in"}, {"sha": "9b5f4d4152c0eeb7dcbbc324e436fc0166ab673e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -2795,7 +2795,7 @@ split_all_insns (int upd_life)\n \n   if (changed && upd_life)\n     update_life_info (blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t      PROP_DEATH_NOTES | PROP_REG_INFO);\n+\t\t      PROP_DEATH_NOTES);\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();"}, {"sha": "90e137df56a9e73c1d00e75db6337d93e76a6882", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -2236,9 +2236,14 @@ subst_stack_regs (rtx insn, stack regstack)\n \tfor (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t  {\n \t    if (stack_regs_mentioned_p (XVECEXP (PATTERN (insn), 0, i)))\n-\t      control_flow_insn_deleted\n-\t\t|= subst_stack_regs_pat (insn, regstack,\n-\t\t\t\t\t XVECEXP (PATTERN (insn), 0, i));\n+\t      {\n+\t        if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == CLOBBER)\n+\t           XVECEXP (PATTERN (insn), 0, i)\n+\t\t     = shallow_copy_rtx (XVECEXP (PATTERN (insn), 0, i));\n+\t\tcontrol_flow_insn_deleted\n+\t\t  |= subst_stack_regs_pat (insn, regstack,\n+\t\t\t\t\t   XVECEXP (PATTERN (insn), 0, i));\n+\t      }\n \t  }\n       else\n \tcontrol_flow_insn_deleted"}, {"sha": "8a83b9687e2d69d0f07af2d591c12ee7e503e227", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -360,7 +360,7 @@ regrename_optimize (void)\n \n   count_or_remove_death_notes (NULL, 1);\n   update_life_info (NULL, UPDATE_LIFE_LOCAL,\n-\t\t    PROP_REG_INFO | PROP_DEATH_NOTES);\n+\t\t    PROP_DEATH_NOTES);\n }\n \n static void"}, {"sha": "369ba5c04f4953009430606f7f15c7415439a97e", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=736b64ddb4ee34d7f05f9522ffb1f5ada4585b7d", "patch": "@@ -2331,7 +2331,7 @@ rest_of_handle_reorder_blocks (tree decl, rtx insns)\n      but should not be terribly bad.  */\n   if (changed && HAVE_conditional_execution)\n     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t      PROP_DEATH_NOTES | PROP_REG_INFO);\n+\t\t      PROP_DEATH_NOTES);\n   close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n }\n "}]}