{"sha": "0615f92345112bf405492e83c49273f4956e6df2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxNWY5MjM0NTExMmJmNDA1NDkyZTgzYzQ5MjczZjQ5NTZlNmRmMg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-04-13T13:48:08Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-04-13T13:48:08Z"}, "message": "re PR fortran/18937 (quadratic behaviour with many label \"spaghetti\" code)\n\nPR fortran/18937\nfortran/\n* resolve.c: Include obstack.h and bitmap.h.  New variable\nlabels_obstack.\n(code_stack): Add tail and reachable_labels fields.\n(reachable_labels): New function.\n(resolve_branch): Rework to use new fields in code_stack.\n(resolve_code): Call reachable_labels.\n(resolve_codes): Allocate and free labels_obstack.\ntestsuite/\n* gfortran.dg/goto_2.f90: New.\n* gfortran.dg/goto_3.f90: New.\n* gfortran.dg/pr17708.f90: Rename to ...\n* gfortran.dg/goto_4.f90: ... this, add comment pointing to\nPR.\n\nFrom-SVN: r123789", "tree": {"sha": "be0d426b6781435930dee66ab8761429aca3b837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0d426b6781435930dee66ab8761429aca3b837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0615f92345112bf405492e83c49273f4956e6df2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0615f92345112bf405492e83c49273f4956e6df2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0615f92345112bf405492e83c49273f4956e6df2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0615f92345112bf405492e83c49273f4956e6df2/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1138d8e5e398c3847ff55cab3a4c3c9cb538814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1138d8e5e398c3847ff55cab3a4c3c9cb538814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1138d8e5e398c3847ff55cab3a4c3c9cb538814"}], "stats": {"total": 238, "additions": 191, "deletions": 47}, "files": [{"sha": "3079268d386ae6071d662c20b6d1f55f95315727", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -1,3 +1,14 @@\n+2007-04-13  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/18937\n+\t* resolve.c: Include obstack.h and bitmap.h.  New variable\n+\tlabels_obstack.\n+\t(code_stack): Add tail and reachable_labels fields.\n+\t(reachable_labels): New function.\n+\t(resolve_branch): Rework to use new fields in code_stack.\n+\t(resolve_code): Call reachable_labels.\n+\t(resolve_codes): Allocate and free labels_obstack.\n+\n 2007-04-12  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/31250"}, {"sha": "7ad4f55d9f8377bb24b1c5d3b087b7fd5f2bdb7e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 89, "deletions": 47, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -24,6 +24,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor,Boston, MA\n #include \"system.h\"\n #include \"flags.h\"\n #include \"gfortran.h\"\n+#include \"obstack.h\"\n+#include \"bitmap.h\"\n #include \"arith.h\"  /* For gfc_compare_expr().  */\n #include \"dependency.h\"\n \n@@ -35,13 +37,17 @@ typedef enum seq_type\n }\n seq_type;\n \n-/* Stack to push the current if we descend into a block during\n-   resolution.  See resolve_branch() and resolve_code().  */\n+/* Stack to keep track of the nesting of blocks as we move through the\n+   code.  See resolve_branch() and resolve_code().  */\n \n typedef struct code_stack\n {\n-  struct gfc_code *head, *current;\n+  struct gfc_code *head, *current, *tail;\n   struct code_stack *prev;\n+\n+  /* This bitmap keeps track of the targets valid for a branch from\n+     inside this block.  */\n+  bitmap reachable_labels;\n }\n code_stack;\n \n@@ -66,6 +72,9 @@ static int specification_expr = 0;\n /* The id of the last entry seen.  */\n static int current_entry_id;\n \n+/* We use bitmaps to determine if a branch target is valid.  */\n+static bitmap_obstack labels_obstack;\n+\n int\n gfc_is_formal_arg (void)\n {\n@@ -4395,33 +4404,63 @@ resolve_transfer (gfc_code *code)\n \n /*********** Toplevel code resolution subroutines ***********/\n \n+/* Find the set of labels that are reachable from this block.  We also\n+   record the last statement in each block so that we don't have to do\n+   a linear search to find the END DO statements of the blocks.  */\n+     \n+static void\n+reachable_labels (gfc_code *block)\n+{\n+  gfc_code *c;\n+\n+  if (!block)\n+    return;\n+\n+  cs_base->reachable_labels = bitmap_obstack_alloc (&labels_obstack);\n+\n+  /* Collect labels in this block.  */\n+  for (c = block; c; c = c->next)\n+    {\n+      if (c->here)\n+\tbitmap_set_bit (cs_base->reachable_labels, c->here->value);\n+\n+      if (!c->next && cs_base->prev)\n+\tcs_base->prev->tail = c;\n+    }\n+\n+  /* Merge with labels from parent block.  */\n+  if (cs_base->prev)\n+    {\n+      gcc_assert (cs_base->prev->reachable_labels);\n+      bitmap_ior_into (cs_base->reachable_labels,\n+\t\t       cs_base->prev->reachable_labels);\n+    }\n+}\n+\n /* Given a branch to a label and a namespace, if the branch is conforming.\n-   The code node described where the branch is located.  */\n+   The code node describes where the branch is located.  */\n \n static void\n resolve_branch (gfc_st_label *label, gfc_code *code)\n {\n-  gfc_code *block, *found;\n   code_stack *stack;\n-  gfc_st_label *lp;\n \n   if (label == NULL)\n     return;\n-  lp = label;\n \n   /* Step one: is this a valid branching target?  */\n \n-  if (lp->defined == ST_LABEL_UNKNOWN)\n+  if (label->defined == ST_LABEL_UNKNOWN)\n     {\n-      gfc_error (\"Label %d referenced at %L is never defined\", lp->value,\n-\t\t &lp->where);\n+      gfc_error (\"Label %d referenced at %L is never defined\", label->value,\n+\t\t &label->where);\n       return;\n     }\n \n-  if (lp->defined != ST_LABEL_TARGET)\n+  if (label->defined != ST_LABEL_TARGET)\n     {\n       gfc_error (\"Statement at %L is not a valid branch target statement \"\n-\t\t \"for the branch statement at %L\", &lp->where, &code->loc);\n+\t\t \"for the branch statement at %L\", &label->where, &code->loc);\n       return;\n     }\n \n@@ -4433,52 +4472,50 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n       return;\n     }\n \n-  /* Step three: Try to find the label in the parse tree. To do this,\n-     we traverse the tree block-by-block: first the block that\n-     contains this GOTO, then the block that it is nested in, etc.  We\n-     can ignore other blocks because branching into another block is\n-     not allowed.  */\n-\n-  found = NULL;\n-\n-  for (stack = cs_base; stack; stack = stack->prev)\n-    {\n-      for (block = stack->head; block; block = block->next)\n-\t{\n-\t  if (block->here == label)\n-\t    {\n-\t      found = block;\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (found)\n-\tbreak;\n-    }\n+  /* Step three:  See if the label is in the same block as the\n+     branching statement.  The hard work has been done by setting up\n+     the bitmap reachable_labels.  */\n \n-  if (found == NULL)\n+  if (!bitmap_bit_p (cs_base->reachable_labels, label->value))\n     {\n       /* The label is not in an enclosing block, so illegal.  This was\n-\t allowed in Fortran 66, so we allow it as extension.  We also \n-\t forego further checks if we run into this.  */\n+\t allowed in Fortran 66, so we allow it as extension.  No\n+\t further checks are necessary in this case.  */\n       gfc_notify_std (GFC_STD_LEGACY, \"Label at %L is not in the same block \"\n-\t\t      \"as the GOTO statement at %L\", &lp->where, &code->loc);\n+\t\t      \"as the GOTO statement at %L\", &label->where,\n+\t\t      &code->loc);\n       return;\n     }\n \n   /* Step four: Make sure that the branching target is legal if\n-     the statement is an END {SELECT,DO,IF}.  */\n+     the statement is an END {SELECT,IF}.  */\n \n-  if (found->op == EXEC_NOP)\n-    {\n-      for (stack = cs_base; stack; stack = stack->prev)\n-\tif (stack->current->next == found)\n-\t  break;\n+  for (stack = cs_base; stack; stack = stack->prev)\n+    if (stack->current->next && stack->current->next->here == label)\n+      break;\n \n-      if (stack == NULL)\n-\tgfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: GOTO at %L jumps to END \"\n-\t\t\t\"of construct at %L\", &code->loc, &found->loc);\n+  if (stack && stack->current->next->op == EXEC_NOP)\n+    {\n+      gfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: GOTO at %L jumps to \"\n+\t\t      \"END of construct at %L\", &code->loc,\n+\t\t      &stack->current->next->loc);\n+      return;  /* We know this is not an END DO.  */\n     }\n+\n+  /* Step five: Make sure that we're not jumping to the end of a DO\n+     loop from within the loop.  */\n+\n+  for (stack = cs_base; stack; stack = stack->prev)\n+    if ((stack->current->op == EXEC_DO\n+\t || stack->current->op == EXEC_DO_WHILE)\n+\t&& stack->tail->here == label && stack->tail->op == EXEC_NOP)\n+      {\n+\tgfc_notify_std (GFC_STD_F95_DEL, \"Obsolete: GOTO at %L jumps \"\n+\t\t\t\"to END of construct at %L\", &code->loc,\n+\t\t\t&stack->tail->loc);\n+\treturn;\n+\n+      }\n }\n \n \n@@ -5004,6 +5041,8 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n   frame.head = code;\n   cs_base = &frame;\n \n+  reachable_labels (code);\n+\n   for (; code; code = code->next)\n     {\n       frame.current = code;\n@@ -7338,7 +7377,10 @@ resolve_codes (gfc_namespace *ns)\n   cs_base = NULL;\n   /* Set to an out of range value.  */\n   current_entry_id = -1;\n+\n+  bitmap_obstack_initialize (&labels_obstack);\n   resolve_code (ns->code, ns);\n+  bitmap_obstack_release (&labels_obstack);\n }\n \n "}, {"sha": "a22295a355fb4c0e8c570e1f681b7b19636fa64f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -1,3 +1,11 @@\n+2007-04-13  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/18937\n+\t* gfortran.dg/goto_2.f90: New.\n+\t* gfortran.dg/goto_3.f90: New.\n+\t* gfortran.dg/pr17708.f90: Rename to ...\n+\t* gfortran.dg/goto_4.f90: ... this, add comment pointing to PR.\n+\n 2007-04-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/31562"}, {"sha": "acff590a9cd724d31dcfa8f5c4d34fb174273bff", "filename": "gcc/testsuite/gfortran.dg/goto_2.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_2.f90?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! Checks for corrects warnings if branching to then end of a\n+! construct at various nesting levels\n+  subroutine check_if(i)\n+    goto 10\n+    if (i > 0) goto 40\n+    if (i < 0) then\n+       goto 40\n+10  end if\n+    if (i == 0) then\n+       i = i+1\n+       goto 20  ! { dg-warning \"jumps to END of construct\" }\n+       goto 40\n+20  end if   ! { dg-warning \"jumps to END of construct\" }\n+    if (i == 1) then\n+       i = i+1\n+       if (i == 2) then\n+          goto 30 ! { dg-warning \"jumps to END of construct\" }\n+       end if\n+       goto 40\n+30  end if    ! { dg-warning \"jumps to END of construct\" }\n+    return\n+40  i = -1\n+  end subroutine check_if\n+  \n+  subroutine check_select(i)\n+    goto 10\n+    select case (i)\n+    case default\n+       goto 999\n+10  end select\n+    select case (i)\n+    case (2)\n+       i = 1\n+       goto 20  ! { dg-warning \"jumps to END of construct\" }\n+       goto 999\n+    case default\n+       goto 999\n+20  end select   ! { dg-warning \"jumps to END of construct\" }\n+    j = i\n+    select case (j)\n+    case default\n+       select case (i)\n+       case (1)\n+          i = 2\n+          goto 30  ! { dg-warning \"jumps to END of construct\" }\n+       end select\n+       goto 999\n+30  end select    ! { dg-warning \"jumps to END of construct\" }\n+    return    \n+999 i = -1\n+  end subroutine check_select\n+\n+  i = 0\n+  call check_if (i)\n+  if (i /= 2) call abort ()\n+  call check_select (i)\n+  if (i /= 2) call abort ()\n+end"}, {"sha": "918443abbd9524c4a8737d535c025972c0983285", "filename": "gcc/testsuite/gfortran.dg/goto_3.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_3.f90?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! Verify that various cases of invalid branches are rejected\n+   dimension a(10)\n+   if (i>0) then\n+      goto 10  ! { dg-error \"not a valid branch target statement\" }\n+10 else        ! { dg-error \"not a valid branch target statement\" }\n+      i = -i\n+   end if\n+\n+   goto 20     ! { dg-error \"not a valid branch target statement\" }\n+   forall (i=1:10)\n+      a(i) = 2*i\n+20 end forall  ! { dg-error \"not a valid branch target statement\" }\n+\n+   goto 30     ! { dg-error \"not a valid branch target statement\" }\n+   goto 40     ! { dg-error \"not a valid branch target statement\" }\n+   where (a>0)\n+      a = 2*a\n+30 elsewhere   ! { dg-error \"not a valid branch target statement\" }\n+      a = a/2\n+40 end where   ! { dg-error \"not a valid branch target statement\" }\n+ end\n+ "}, {"sha": "d48af7240fe0656f34f48920c881dd34fa76322b", "filename": "gcc/testsuite/gfortran.dg/goto_4.f90", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0615f92345112bf405492e83c49273f4956e6df2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoto_4.f90?ref=0615f92345112bf405492e83c49273f4956e6df2", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do run }\n+! PR 17708: Jumping to END DO statements didn't do the right thing\n       program test\n         j = 0\n         do 10 i=1,3", "previous_filename": "gcc/testsuite/gfortran.dg/pr17708.f90"}]}