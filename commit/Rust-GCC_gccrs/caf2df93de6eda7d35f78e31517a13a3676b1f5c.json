{"sha": "caf2df93de6eda7d35f78e31517a13a3676b1f5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmMmRmOTNkZTZlZGE3ZDM1Zjc4ZTMxNTE3YTEzYTM2NzZiMWY1Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-10T04:24:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-10T04:24:21Z"}, "message": "re PR tree-optimization/65355 (vectorizer increase alignment of symbols already placed in anchors)\n\n\n\tPR tree-optimization/65355\n\t* varasm.c (notice_global_symbol): Do not produce RTL.\n\t* symtab.c (symtab_node::can_increase_alignment_p): Check for section\n\tanchor.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Do not\n\tcheck for section anchors.\n\t* gcc.dg/vect/section-anchors-vect-69.c: Update template.\n\nFrom-SVN: r221297", "tree": {"sha": "6649fcc416406122c827c2e5a9961675ab392c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6649fcc416406122c827c2e5a9961675ab392c9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf2df93de6eda7d35f78e31517a13a3676b1f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf2df93de6eda7d35f78e31517a13a3676b1f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf2df93de6eda7d35f78e31517a13a3676b1f5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf2df93de6eda7d35f78e31517a13a3676b1f5c/comments", "author": null, "committer": null, "parents": [{"sha": "57ace19f92d886930470b037f7b3cd8ef4cafae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ace19f92d886930470b037f7b3cd8ef4cafae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ace19f92d886930470b037f7b3cd8ef4cafae4"}], "stats": {"total": 51, "additions": 31, "deletions": 20}, "files": [{"sha": "0cbeaa3b9e32c0cd35706021408fb6c47320031b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -1,3 +1,12 @@\n+2015-03-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/65355\n+\t* varasm.c (notice_global_symbol): Do not produce RTL.\n+\t* symtab.c (symtab_node::can_increase_alignment_p): Check for section\n+\tanchor.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Do not\n+\tcheck for section anchors.\n+\n 2015-03-10  Alan Modra  <amodra@gmail.com>\n \n \tPR target/65286"}, {"sha": "88e168bd193086048b51cd38b8578364c4f8951d", "filename": "gcc/symtab.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -1924,6 +1924,13 @@ symtab_node::can_increase_alignment_p (void)\n   if (TREE_ASM_WRITTEN (target->decl))\n     return false;\n \n+  /* If target is already placed in an anchor, we can not touch its\n+     alignment.  */\n+  if (DECL_RTL_SET_P (target->decl)\n+      && MEM_P (DECL_RTL (target->decl))\n+      && SYMBOL_REF_HAS_BLOCK_INFO_P (XEXP (DECL_RTL (target->decl), 0)))\n+    return false;\n+\n   /* Constant pool entries may be shared.  */\n   if (DECL_IN_CONSTANT_POOL (target->decl))\n     return false;"}, {"sha": "ec7a3bc5ba4bc96fec68e448700ad50278469f55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -1,3 +1,8 @@\n+2015-03-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/65355\n+\t* gcc.dg/vect/section-anchors-vect-69.c: Update template.\n+\n 2015-03-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/65120"}, {"sha": "4916274fb0a19ccd9c086968953da7546ecb83e0", "filename": "gcc/testsuite/gcc.dg/vect/section-anchors-vect-69.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fsection-anchors-vect-69.c?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -115,6 +115,6 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n /* Alignment forced using versioning until the pass that increases alignment\n   is extended to handle structs.  */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 4 \"vect\" { target {vect_int && vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target {vect_int && vector_alignment_reachable } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 4 \"vect\" { target {vect_int && {! vector_alignment_reachable} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b308ac7ac680b365d58c1b0d13f6bd0786d0132b", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -758,12 +758,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t  && TREE_CODE (TREE_OPERAND (base, 0)) == ADDR_EXPR)\n \tbase = TREE_OPERAND (TREE_OPERAND (base, 0), 0);\n \n-      /* Do not change the alignment of global variables here if\n-\t flag_section_anchors is enabled as we already generated\n-\t RTL for other functions.  Most global variables should\n-\t have been aligned during the IPA increase_alignment pass.  */\n-      if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype))\n-\t  || (TREE_STATIC (base) && flag_section_anchors))\n+      if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n \t  if (dump_enabled_p ())\n \t    {"}, {"sha": "752dccf935dfe06a9e1308731de081c5366ec4b7", "filename": "gcc/varasm.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf2df93de6eda7d35f78e31517a13a3676b1f5c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=caf2df93de6eda7d35f78e31517a13a3676b1f5c", "patch": "@@ -1630,35 +1630,30 @@ default_ctor_section_asm_out_constructor (rtx symbol,\n void\n notice_global_symbol (tree decl)\n {\n-  const char **type = &first_global_object_name;\n+  const char **t = &first_global_object_name;\n \n   if (first_global_object_name\n       || !TREE_PUBLIC (decl)\n       || DECL_EXTERNAL (decl)\n       || !DECL_NAME (decl)\n+      || (TREE_CODE (decl) == VAR_DECL && DECL_HARD_REGISTER (decl))\n       || (TREE_CODE (decl) != FUNCTION_DECL\n \t  && (TREE_CODE (decl) != VAR_DECL\n \t      || (DECL_COMMON (decl)\n \t\t  && (DECL_INITIAL (decl) == 0\n-\t\t      || DECL_INITIAL (decl) == error_mark_node))))\n-      || !MEM_P (DECL_RTL (decl)))\n+\t\t      || DECL_INITIAL (decl) == error_mark_node)))))\n     return;\n \n   /* We win when global object is found, but it is useful to know about weak\n      symbol as well so we can produce nicer unique names.  */\n   if (DECL_WEAK (decl) || DECL_ONE_ONLY (decl) || flag_shlib)\n-    type = &weak_global_object_name;\n+    t = &weak_global_object_name;\n \n-  if (!*type)\n+  if (!*t)\n     {\n-      const char *p;\n-      const char *name;\n-      rtx decl_rtl = DECL_RTL (decl);\n-\n-      p = targetm.strip_name_encoding (XSTR (XEXP (decl_rtl, 0), 0));\n-      name = ggc_strdup (p);\n-\n-      *type = name;\n+      tree id = DECL_ASSEMBLER_NAME (decl);\n+      ultimate_transparent_alias_target (&id);\n+      *t = ggc_strdup (targetm.strip_name_encoding (IDENTIFIER_POINTER (id)));\n     }\n }\n "}]}