{"sha": "f0afa4a260ed42561e5359f2b6c104abc216668f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBhZmE0YTI2MGVkNDI1NjFlNTM1OWYyYjZjMTA0YWJjMjE2NjY4Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T22:02:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T22:02:42Z"}, "message": "(deduce_conversion, emit_typecode_conversion): Cast enum array indices to int.\n\n(bc_init_mode_to_code_map, preferred_typecode): Likewise.\n(bc_expand_binary_operation, bc_expand_unary_operation): Likewise.\n(bc_expand_increment): Likewise.\n\nFrom-SVN: r5594", "tree": {"sha": "823016657e147eaa7cf06658cc91f6045ae2f5d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/823016657e147eaa7cf06658cc91f6045ae2f5d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0afa4a260ed42561e5359f2b6c104abc216668f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0afa4a260ed42561e5359f2b6c104abc216668f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0afa4a260ed42561e5359f2b6c104abc216668f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0afa4a260ed42561e5359f2b6c104abc216668f/comments", "author": null, "committer": null, "parents": [{"sha": "eecaa29b353d0a5ae60c8fc47320404d18bc0d25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eecaa29b353d0a5ae60c8fc47320404d18bc0d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eecaa29b353d0a5ae60c8fc47320404d18bc0d25"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "cd1fc8ace39e5a60d32a7bc66721461ee0c75e63", "filename": "gcc/bc-optab.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0afa4a260ed42561e5359f2b6c104abc216668f/gcc%2Fbc-optab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0afa4a260ed42561e5359f2b6c104abc216668f/gcc%2Fbc-optab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-optab.c?ref=f0afa4a260ed42561e5359f2b6c104abc216668f", "patch": "@@ -607,9 +607,10 @@ deduce_conversion (from, to)\n   return result;\n }\n \n-#define DEDUCE_CONVERSION(FROM, TO)\t\t\t\t\t      \\\n-  (conversion_recipe[FROM][TO].opcodes ? 0\t\t\t\t      \\\n-   : (conversion_recipe[FROM][TO] = deduce_conversion (FROM, TO), 0))\n+#define DEDUCE_CONVERSION(FROM, TO)\t\t\t\t\\\n+  (conversion_recipe[(int) FROM][(int) TO].opcodes ? 0\t\t\\\n+   : (conversion_recipe[(int) FROM][(int) TO]\t\t\t\\\n+       = deduce_conversion (FROM, TO), 0))\n \n \n /* Emit a conversion between the given scalar types.  */\n@@ -620,8 +621,8 @@ emit_typecode_conversion (from, to)\n   int i;\n \n   DEDUCE_CONVERSION (from, to);\n-  for (i = 0; i < conversion_recipe[from][to].nopcodes; ++i)\n-    bc_emit_instruction (conversion_recipe[from][to].opcodes[i]);\n+  for (i = 0; i < conversion_recipe[(int) from][(int) to].nopcodes; ++i)\n+    bc_emit_instruction (conversion_recipe[(int) from][(int) to].opcodes[i]);\n }\n \n \n@@ -639,8 +640,8 @@ bc_init_mode_to_code_map ()\n     }\n \n #define DEF_MODEMAP(SYM, CODE, UCODE, CONST, LOAD, STORE) \\\n-  { signed_mode_to_code_map[(enum machine_mode) SYM] = CODE; \\\n-    unsigned_mode_to_code_map[(enum machine_mode) SYM] = UCODE; }\n+  { signed_mode_to_code_map[(int) SYM] = CODE; \\\n+    unsigned_mode_to_code_map[(int) SYM] = UCODE; }\n #include \"modemap.def\"\n #undef DEF_MODEMAP\n \n@@ -656,7 +657,8 @@ preferred_typecode (mode, unsignedp)\n {\n   enum typecode code = (unsignedp\n \t\t\t? unsigned_mode_to_code_map\n-\t\t\t: signed_mode_to_code_map) [MIN (mode, MAX_MACHINE_MODE)];\n+\t\t\t: signed_mode_to_code_map) [MIN ((int) mode,\n+\t\t\t\t\t\t\t (int) MAX_MACHINE_MODE)];\n \n   if (code == LAST_AND_UNUSED_TYPECODE)\n     abort ();\n@@ -709,9 +711,9 @@ bc_expand_binary_operation (optab, resulttype, arg0, arg1)\n     {\n       cost = 0;\n       DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n-      cost += conversion_recipe[arg0code][optab[i].arg0].cost;\n+      cost += conversion_recipe[(int) arg0code][(int) optab[i].arg0].cost;\n       DEDUCE_CONVERSION (arg1code, optab[i].arg1);\n-      cost += conversion_recipe[arg1code][optab[i].arg1].cost;\n+      cost += conversion_recipe[(int) arg1code][(int) optab[i].arg1].cost;\n       if (cost < bestcost)\n \t{\n \t  besti = i;\n@@ -748,7 +750,7 @@ bc_expand_unary_operation (optab, resulttype, arg0)\n   for (i = 0; optab[i].opcode != -1; ++i)\n     {\n       DEDUCE_CONVERSION (arg0code, optab[i].arg0);\n-      cost = conversion_recipe[arg0code][optab[i].arg0].cost;\n+      cost = conversion_recipe[(int) arg0code][(int) optab[i].arg0].cost;\n       if (cost < bestcost)\n \t{\n \t  besti = i;\n@@ -776,7 +778,7 @@ bc_expand_increment (optab, type)\n   int i;\n \n   code = preferred_typecode (TYPE_MODE (type), TREE_UNSIGNED (type));\n-  for (i = 0; optab[i].opcode >= 0; ++i)\n+  for (i = 0; (int) optab[i].opcode >= 0; ++i)\n     if (code == optab[i].arg)\n       {\n \tbc_emit_instruction (optab[i].opcode);"}]}