{"sha": "9a5e1efcaca6305711e7d44b355e98c923f27c6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE1ZTFlZmNhY2E2MzA1NzExZTdkNDRiMzU1ZTk4YzkyM2YyN2M2ZA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-10-28T20:56:28Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-10-28T20:56:28Z"}, "message": "combine: Improve change_zero_ext (fixes PR71847)\n\nThis improves a few things in change_zero_ext.  Firstly, it should use\nthe passed in pattern in recog_for_combine, not the pattern of the insn\n(they are not the same if the whole pattern was replaced).  Secondly,\nit handled zero_ext of a subreg, but with hard registers we do not get\na subreg, instead the mode of the reg is changed.  So this handles that.\nThirdly, after changing a zero_ext to an AND, the resulting RTL may become\nnon-canonical, like (ior (ashift ..) (and ..)); the AND should be first,\nit is commutative.  And lastly, zero_extract as a set_dest wasn't handled\nat all, but now it is.\n\nThis fixes the testcase in PR71847, and improves code generation in some\nother edge cases too.\n\n\n\tPR target/71847\n\t* combine.c (change_zero_ext): Handle zero_ext of hard registers.\n\tSwap commutative operands in new RTL if needed.  Handle zero_ext\n\tin the set_dest.\n\t(recog_for_combine): Pass *pnewpat to change_zero_ext instead of\n\tPATTERN (insn).\n\nFrom-SVN: r241664", "tree": {"sha": "8021e705f33c93434b854873987fa541d49d8007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8021e705f33c93434b854873987fa541d49d8007"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a5e1efcaca6305711e7d44b355e98c923f27c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5e1efcaca6305711e7d44b355e98c923f27c6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5e1efcaca6305711e7d44b355e98c923f27c6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5e1efcaca6305711e7d44b355e98c923f27c6d/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5742b01585d78d5e9c39e8dbc9cfce7796af492", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5742b01585d78d5e9c39e8dbc9cfce7796af492", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5742b01585d78d5e9c39e8dbc9cfce7796af492"}], "stats": {"total": 64, "additions": 60, "deletions": 4}, "files": [{"sha": "32f6435a90085f1bace966d62c3e2f9d2e3e8c05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5e1efcaca6305711e7d44b355e98c923f27c6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5e1efcaca6305711e7d44b355e98c923f27c6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a5e1efcaca6305711e7d44b355e98c923f27c6d", "patch": "@@ -1,3 +1,12 @@\n+2016-10-28  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR target/71847\n+\t* combine.c (change_zero_ext): Handle zero_ext of hard registers.\n+\tSwap commutative operands in new RTL if needed.  Handle zero_ext\n+\tin the set_dest.\n+\t(recog_for_combine): Pass *pnewpat to change_zero_ext instead of\n+\tPATTERN (insn).\n+\n 2016-10-28  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \t    Kugan Vivekanandarajah  <kuganv@linaro.org>\n \t    Jim Wilson  <jim.wilson@linaro.org>"}, {"sha": "60a127f2e53dbfb32ac32c5c0962539fbf880480", "filename": "gcc/combine.c", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5e1efcaca6305711e7d44b355e98c923f27c6d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5e1efcaca6305711e7d44b355e98c923f27c6d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9a5e1efcaca6305711e7d44b355e98c923f27c6d", "patch": "@@ -11106,9 +11106,10 @@ recog_for_combine_1 (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n    Return whether anything was so changed.  */\n \n static bool\n-change_zero_ext (rtx *src)\n+change_zero_ext (rtx pat)\n {\n   bool changed = false;\n+  rtx *src = &SET_SRC (pat);\n \n   subrtx_ptr_iterator::array_type array;\n   FOR_EACH_SUBRTX_PTR (iter, array, src, NONCONST)\n@@ -11140,6 +11141,14 @@ change_zero_ext (rtx *src)\n \t  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));\n \t  x = SUBREG_REG (XEXP (x, 0));\n \t}\n+      else if (GET_CODE (x) == ZERO_EXTEND\n+\t       && SCALAR_INT_MODE_P (mode)\n+\t       && REG_P (XEXP (x, 0))\n+\t       && HARD_REGISTER_P (XEXP (x, 0)))\n+\t{\n+\t  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));\n+\t  x = gen_rtx_REG (mode, REGNO (XEXP (x, 0)));\n+\t}\n       else\n \tcontinue;\n \n@@ -11150,6 +11159,44 @@ change_zero_ext (rtx *src)\n       changed = true;\n     }\n \n+  if (changed)\n+    FOR_EACH_SUBRTX_PTR (iter, array, src, NONCONST)\n+      {\n+\trtx x = **iter;\n+\tif (COMMUTATIVE_ARITH_P (x)\n+\t    && swap_commutative_operands_p (XEXP (x, 0), XEXP (x, 1)))\n+\t  {\n+\t    rtx tem = XEXP (x, 0);\n+\t    SUBST (XEXP (x, 0), XEXP (x, 1));\n+\t    SUBST (XEXP (x, 1), tem);\n+\t  }\n+      }\n+\n+  rtx *dst = &SET_DEST (pat);\n+  if (GET_CODE (*dst) == ZERO_EXTRACT\n+      && REG_P (XEXP (*dst, 0))\n+      && CONST_INT_P (XEXP (*dst, 1))\n+      && CONST_INT_P (XEXP (*dst, 2)))\n+    {\n+      rtx reg = XEXP (*dst, 0);\n+      int width = INTVAL (XEXP (*dst, 1));\n+      int offset = INTVAL (XEXP (*dst, 2));\n+      machine_mode mode = GET_MODE (reg);\n+      int reg_width = GET_MODE_PRECISION (mode);\n+      if (BITS_BIG_ENDIAN)\n+\toffset = reg_width - width - offset;\n+\n+      wide_int mask = wi::shifted_mask (offset, width, true, reg_width);\n+      rtx x = gen_rtx_AND (mode, reg, immed_wide_int_const (mask, mode));\n+      rtx y = simplify_gen_binary (ASHIFT, mode, SET_SRC (pat),\n+\t\t\t\t   GEN_INT (offset));\n+      rtx z = simplify_gen_binary (IOR, mode, x, y);\n+      SUBST (SET_DEST (pat), reg);\n+      SUBST (SET_SRC (pat), z);\n+\n+      changed = true;\n+    }\n+\n   return changed;\n }\n \n@@ -11172,7 +11219,7 @@ change_zero_ext (rtx *src)\n static int\n recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n {\n-  rtx pat = PATTERN (insn);\n+  rtx pat = *pnewpat;\n   int insn_code_number = recog_for_combine_1 (pnewpat, insn, pnotes);\n   if (insn_code_number >= 0 || check_asm_operands (pat))\n     return insn_code_number;\n@@ -11181,15 +11228,15 @@ recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n   bool changed = false;\n \n   if (GET_CODE (pat) == SET)\n-    changed = change_zero_ext (&SET_SRC (pat));\n+    changed = change_zero_ext (pat);\n   else if (GET_CODE (pat) == PARALLEL)\n     {\n       int i;\n       for (i = 0; i < XVECLEN (pat, 0); i++)\n \t{\n \t  rtx set = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (set) == SET)\n-\t    changed |= change_zero_ext (&SET_SRC (set));\n+\t    changed |= change_zero_ext (set);\n \t}\n     }\n "}]}