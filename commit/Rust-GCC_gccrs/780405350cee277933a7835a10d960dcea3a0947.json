{"sha": "780405350cee277933a7835a10d960dcea3a0947", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwNDA1MzUwY2VlMjc3OTMzYTc4MzVhMTBkOTYwZGNlYTNhMDk0Nw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-09-25T19:06:28Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-09-25T19:06:28Z"}, "message": "re PR target/54089 ([SH] Refactor shift patterns)\n\n\tPR target/54089\n\t* config/sh/constraints.md (Jhb): New constraint.\n\t* config/sh/predicates.md (negt_reg_shl31_operand): New predicate.\n\t* config/sh/sh.md (rotrsi3): New expander.\n\t(rotrsi3_1, *rotrsi3_1, *rotlsi3_1): New insns.\n\t(rotlsi3, rotlhi3): Use const_int_operand predicate instead of\n\timmediate_operand and remove CONST_INT_P checks in expansion code.\n\t(*rotcr): Cleanup variable usage.  Handle preceding nott insn.  Add\n\tsplit with swapped operands.\n\t(*rotcr_neg_t, *movt_msb, *negt_msb): New insns and splits.\n\n\tPR target/54089\n\t* gcc.target/sh/pr54089-1.c (test_15, test_16, test_17, test_18,\n\ttest_19, test_20, test_21, test_22, test_23): New functions.\n\t* gcc.target/sh/pr54089-4.c: New.\n\t* gcc.target/sh/pr54089-5.c: New.\n\t* gcc.target/sh/pr54089-6.c: New.\n\t* gcc.target/sh/pr54089-7.c: New.\n\nFrom-SVN: r191743", "tree": {"sha": "ecbd8ddaf619969c907ae05cf2c8c9a8a4ea0ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecbd8ddaf619969c907ae05cf2c8c9a8a4ea0ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/780405350cee277933a7835a10d960dcea3a0947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780405350cee277933a7835a10d960dcea3a0947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780405350cee277933a7835a10d960dcea3a0947", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780405350cee277933a7835a10d960dcea3a0947/comments", "author": null, "committer": null, "parents": [{"sha": "91cad09b08a860dccace9d1e7050e8765b3556e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91cad09b08a860dccace9d1e7050e8765b3556e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91cad09b08a860dccace9d1e7050e8765b3556e9"}], "stats": {"total": 453, "additions": 427, "deletions": 26}, "files": [{"sha": "953b07e908a8b4bb8a2e89c7cc280b9b8797df33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -1,3 +1,16 @@\n+2012-09-25  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* config/sh/constraints.md (Jhb): New constraint.\n+\t* config/sh/predicates.md (negt_reg_shl31_operand): New predicate.\n+\t* config/sh/sh.md (rotrsi3): New expander.\n+\t(rotrsi3_1, *rotrsi3_1, *rotlsi3_1): New insns.\n+\t(rotlsi3, rotlhi3): Use const_int_operand predicate instead of\n+\timmediate_operand and remove CONST_INT_P checks in expansion code.\n+\t(*rotcr): Cleanup variable usage.  Handle preceding nott insn.  Add\n+\tsplit with swapped operands.\n+\t(*rotcr_neg_t, *movt_msb, *negt_msb): New insns and splits.\n+\n 2012-09-25  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR middle-end/53850\n@@ -1066,7 +1079,7 @@\n 2012-09-14  Christian Bruel  <christian.bruel@st.com>\n \n \t* config/sh/predicates.md (t_reg_operand): Check REG_P for SUBREG.\n-\t* config/sh/sh.c (sequence_insn_p: Check INSNP_P for SEQUENCE.\n+\t* config/sh/sh.c (sequence_insn_p): Check INSNP_P for SEQUENCE.\n \n 2012-09-14  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "c2540e8b6683740893b382c01152265be83e27b0", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -33,6 +33,7 @@\n ;;  J16: 0xffffffff00000000 | 0x00000000ffffffff\n ;;  Jmb: 0x000000FF\n ;;  Jmw: 0x0000FFFF\n+;;  Jhb: 0x80000000\n ;;  Kxx: unsigned xx bit\n ;;  M: 1\n ;;  N: 0\n@@ -148,6 +149,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival == 0xFFFF\")))\n \n+(define_constraint \"Jhb\"\n+  \"Highest bit constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xFFFFFFFF) == 0x80000000\")))\n+\n (define_constraint \"K03\"\n   \"An unsigned 3-bit constant, as used in SH2A bclr, bset, etc.\"\n   (and (match_code \"const_int\")"}, {"sha": "93a33bf2544b06cf64d2f6c4cbaed84466d3c2d6", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -1033,3 +1033,41 @@\n (define_predicate \"arith_reg_or_t_reg_operand\"\n   (ior (match_operand 0 \"arith_reg_operand\")\n        (match_operand 0 \"t_reg_operand\")))\n+\n+;; A predicate describing the negated value of the T bit register shifted\n+;; left by 31.\n+(define_predicate \"negt_reg_shl31_operand\"\n+  (match_code \"plus,minus,if_then_else\")\n+{\n+  /* (plus:SI (mult:SI (match_operand:SI 1 \"t_reg_operand\")\n+\t\t       (const_int -2147483648))  ;; 0xffffffff80000000\n+\t      (const_int -2147483648))\n+  */\n+  if (GET_CODE (op) == PLUS && satisfies_constraint_Jhb (XEXP (op, 1))\n+      && GET_CODE (XEXP (op, 0)) == MULT\n+      && t_reg_operand (XEXP (XEXP (op, 0), 0), SImode)\n+      && satisfies_constraint_Jhb (XEXP (XEXP (op, 0), 1)))\n+    return true;\n+\n+  /* (minus:SI (const_int -2147483648)  ;; 0xffffffff80000000\n+\t       (mult:SI (match_operand:SI 1 \"t_reg_operand\")\n+\t\t\t(const_int -2147483648)))\n+  */\n+  if (GET_CODE (op) == MINUS\n+      && satisfies_constraint_Jhb (XEXP (op, 0))\n+      && GET_CODE (XEXP (op, 1)) == MULT\n+      && t_reg_operand (XEXP (XEXP (op, 1), 0), SImode)\n+      && satisfies_constraint_Jhb (XEXP (XEXP (op, 1), 1)))\n+    return true;\n+\n+  /*  (if_then_else:SI (match_operand:SI 1 \"t_reg_operand\")\n+\t\t       (const_int 0)\n+\t\t       (const_int -2147483648))  ;; 0xffffffff80000000\n+  */\n+  if (GET_CODE (op) == IF_THEN_ELSE && t_reg_operand (XEXP (op, 0), SImode)\n+      && satisfies_constraint_Z (XEXP (op, 1))\n+      && satisfies_constraint_Jhb (XEXP (op, 2)))\n+    return true;\n+\n+  return false;\n+})"}, {"sha": "8f0443ad6db3c58f71a3e770920aa3e9e4782d06", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 173, "deletions": 24, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -3817,6 +3817,42 @@ label:\n \t\t\t      GEN_INT (56), GEN_INT (8));\n })\n \n+(define_expand \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(rotatert:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SH1\"\n+{\n+  HOST_WIDE_INT ival = INTVAL (operands[2]);\n+  if (ival == 1)\n+    {\n+      emit_insn (gen_rotrsi3_1 (operands[0], operands[1]));\n+      DONE;\n+    }\n+\n+  FAIL;\n+})\n+\n+(define_insn \"rotrsi3_1\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (set (reg:SI T_REG)\n+\t(and:SI (match_dup 1) (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"rotr\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;; A slimplified version of rotr for combine.\n+(define_insn \"*rotrsi3_1\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"rotr\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"rotlsi3_1\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3827,6 +3863,16 @@ label:\n   \"rotl\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; A simplified version of rotl for combine.\n+(define_insn \"*rotlsi3_1\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"rotl\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"rotlsi3_31\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -3845,9 +3891,9 @@ label:\n   [(set_attr \"type\" \"arith\")])\n \n (define_expand \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t   (match_operand:SI 2 \"const_int_operand\")))]\n   \"TARGET_SH1\"\n {\n   static const char rot_tab[] = {\n@@ -3857,12 +3903,8 @@ label:\n     002, 002, 010, 000, 000, 000, 000, 000,\n   };\n \n-  int count, choice;\n-\n-  if (!CONST_INT_P (operands[2]))\n-    FAIL;\n-  count = INTVAL (operands[2]);\n-  choice = rot_tab[count];\n+  int count = INTVAL (operands[2]);\n+  int choice = rot_tab[count];\n   if (choice & 010 && SH_DYNAMIC_SHIFT_COST <= 1)\n     FAIL;\n   choice &= 7;\n@@ -3908,12 +3950,12 @@ label:\n   [(set_attr \"type\" \"arith\")])\n \n (define_expand \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n-\t(rotate:HI (match_operand:HI 1 \"arith_reg_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"immediate_operand\" \"\")))]\n+  [(set (match_operand:HI 0 \"arith_reg_operand\")\n+\t(rotate:HI (match_operand:HI 1 \"arith_reg_operand\")\n+\t\t   (match_operand:HI 2 \"const_int_operand\")))]\n   \"TARGET_SH1\"\n {\n-  if (!CONST_INT_P (operands[2]) || INTVAL (operands[2]) != 8)\n+  if (INTVAL (operands[2]) != 8)\n     FAIL;\n })\n \n@@ -3950,11 +3992,7 @@ label:\n {\n   if (INTVAL (operands[2]) > 1)\n     {\n-      /* use plus_constant function ?? */\n-      const int shift_count = INTVAL (operands[2]) - 1;\n-      const rtx shift_count_rtx = GEN_INT (shift_count);\n-      rtx shift_res = gen_reg_rtx (SImode);\n-\n+      const rtx shift_count = GEN_INT (INTVAL (operands[2]) - 1);\n       rtx prev_set_t_insn = NULL_RTX;\n       rtx tmp_t_reg = NULL_RTX;\n \n@@ -3963,10 +4001,24 @@ label:\n \t shift insn before that insn, to remove the T_REG dependency.\n \t If the insn that sets the T_REG cannot be found, store the T_REG\n \t in a temporary reg and restore it after the shift.  */\n-      if (sh_lshrsi_clobbers_t_reg_p (shift_count_rtx)\n-\t  && ! sh_dynamicalize_shift_p (shift_count_rtx))\n+      if (sh_lshrsi_clobbers_t_reg_p (shift_count)\n+\t  && ! sh_dynamicalize_shift_p (shift_count))\n \t{\n \t  prev_set_t_insn = prev_nonnote_insn_bb (curr_insn);\n+\n+\t  /* Skip the nott insn, which was probably inserted by the splitter\n+\t     of *rotcr_neg_t.  Don't use one of the recog functions\n+\t     here during insn splitting, since that causes problems in later\n+\t     passes.  */\n+\t  if (prev_set_t_insn != NULL_RTX)\n+\t    {\n+\t      rtx pat = PATTERN (prev_set_t_insn);\n+\t      if (GET_CODE (pat) == SET\n+\t\t  && t_reg_operand (XEXP (pat, 0), SImode)\n+\t\t  && negt_reg_operand (XEXP (pat, 1), SImode))\n+\t      prev_set_t_insn = prev_nonnote_insn_bb (prev_set_t_insn);\n+\t    }\n+\n \t  if (! (prev_set_t_insn != NULL_RTX\n \t\t && reg_set_p (get_t_reg_rtx (), prev_set_t_insn)\n \t\t && ! reg_referenced_p (get_t_reg_rtx (),\n@@ -3978,14 +4030,15 @@ label:\n \t    } \n \t}\n \n-      rtx shift_rtx = gen_lshrsi3 (shift_res, operands[1], shift_count_rtx);\n-      operands[1] = shift_res;\n+      rtx shift_result = gen_reg_rtx (SImode);\n+      rtx shift_insn = gen_lshrsi3 (shift_result, operands[1], shift_count);\n+      operands[1] = shift_result;\n \n       /* Emit the shift insn before the insn that sets T_REG, if possible.  */\n       if (prev_set_t_insn != NULL_RTX)\n-\temit_insn_before (shift_rtx, prev_set_t_insn);\n+\temit_insn_before (shift_insn, prev_set_t_insn);\n       else\n-\temit_insn (shift_rtx);\n+\temit_insn (shift_insn);\n \n       /* Restore T_REG if it has been saved before.  */\n       if (tmp_t_reg != NULL_RTX)\n@@ -4007,6 +4060,20 @@ label:\n   DONE;\n })\n \n+;; If combine tries the same as above but with swapped operands, split\n+;; it so that it will try the pattern above.\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_or_t_reg_operand\")\n+\t\t\t   (const_int 31))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t     (match_operand:SI 3 \"const_int_operand\"))))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (lshiftrt:SI (match_dup 2) (match_dup 3))\n+\t\t\t   (ashift:SI (match_dup 1) (const_int 31))))\n+\t      (clobber (reg:SI T_REG))])])\n+\n ;; rotcr combine bridge pattern which will make combine try out more\n ;; complex patterns.\n (define_insn_and_split \"*rotcr\"\n@@ -4040,6 +4107,41 @@ label:\n   DONE;\n })\n \n+;; rotcr combine patterns for rotating in the negated T_REG value.\n+(define_insn_and_split \"*rotcr_neg_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (match_operand:SI 1 \"negt_reg_shl31_operand\")\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t     (match_operand:SI 3 \"const_int_operand\"))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (lshiftrt:SI (match_dup 2) (match_dup 3))\n+\t\t\t   (ashift:SI (reg:SI T_REG) (const_int 31))))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_nott (get_t_reg_rtx ()));\n+})\n+\n+(define_insn_and_split \"*rotcr_neg_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(match_operand:SI 3 \"negt_reg_shl31_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (lshiftrt:SI (match_dup 1) (match_dup 2))\n+\t\t\t   (ashift:SI (reg:SI T_REG) (const_int 31))))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  emit_insn (gen_nott (get_t_reg_rtx ()));\n+})\n+\n ;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n ;; SImode shift left\n \n@@ -10720,6 +10822,53 @@ label:\n   operands[0] = gen_reg_rtx (SImode);\n })\n \n+;; Store T bit as MSB in a reg.\n+;; T = 0: 0x00000000 -> reg\n+;; T = 1: 0x80000000 -> reg\n+(define_insn_and_split \"*movt_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(mult:SI (match_operand:SI 1 \"t_reg_operand\")\n+\t\t (const_int -2147483648)))  ;; 0xffffffff80000000\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0) (ashift:SI (reg:SI T_REG) (const_int 31)))])\n+\n+;; Store inverted T bit as MSB in a reg.\n+;; T = 0: 0x80000000 -> reg\n+;; T = 1: 0x00000000 -> reg\n+;; On SH2A we can get away without clobbering the T_REG.\n+(define_insn_and_split \"*negt_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand:SI 1 \"negt_reg_shl31_operand\"))]\n+  \"TARGET_SH2A\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  rtx tmp = gen_reg_rtx (SImode);\n+  emit_insn (gen_movrt (tmp, get_t_reg_rtx ()));\n+  emit_insn (gen_rotrsi3 (operands[0], tmp, const1_rtx));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"*negt_msb\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand:SI 1 \"negt_reg_shl31_operand\"))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1 && !TARGET_SH2A\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  rtx tmp = gen_reg_rtx (SImode);\n+  emit_move_insn (tmp, get_t_reg_rtx ());\n+  emit_insn (gen_cmpeqsi_t (tmp, const0_rtx));\n+  emit_insn (gen_rotcr (operands[0], tmp, get_t_reg_rtx ()));\n+  DONE;\n+})\n+\n ;; The *cset_zero patterns convert optimizations such as\n ;;\t\"if (test) x = 0;\" to \"x &= -(test == 0);\"\n ;; back to conditional branch sequences if zero-displacement branches"}, {"sha": "dfbab8205cbc276404e149357a1b27fb1ed66535", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -1,3 +1,13 @@\n+2012-09-25  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* gcc.target/sh/pr54089-1.c (test_15, test_16, test_17, test_18,\n+\ttest_19, test_20, test_21, test_22, test_23): New functions.\n+\t* gcc.target/sh/pr54089-4.c: New.\n+\t* gcc.target/sh/pr54089-5.c: New.\n+\t* gcc.target/sh/pr54089-6.c: New.\n+\t* gcc.target/sh/pr54089-7.c: New.\n+\n 2012-09-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/54625"}, {"sha": "399b0a53e22c8cfb7cd2d777530792dcfc8ac9c1", "filename": "gcc/testsuite/gcc.target/sh/pr54089-1.c", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-1.c?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -2,7 +2,7 @@\n /* { dg-do compile { target \"sh*-*-*\" } } */\n /* { dg-options \"-O1\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n-/* { dg-final { scan-assembler-times \"rotcr\" 15 } } */\n+/* { dg-final { scan-assembler-times \"rotcr\" 24 } } */\n /* { dg-final { scan-assembler-times \"shll\\t\" 1 } } */\n \n typedef char bool;\n@@ -109,3 +109,66 @@ test_14 (unsigned int a, int b)\n   bool r = b < 0;\n   return ((a >> 1) | (r << 31));\n }\n+\n+unsigned int\n+test_15 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 1) | (r << 31));\n+}\n+\n+unsigned int\n+test_16 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 2) | (r << 31));\n+}\n+\n+unsigned int\n+test_17 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 3) | (r << 31));\n+}\n+\n+unsigned int\n+test_18 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 4) | (r << 31));\n+}\n+\n+unsigned int\n+test_19 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 5) | (r << 31));\n+}\n+\n+unsigned int\n+test_20 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 6) | (r << 31));\n+}\n+\n+unsigned int\n+test_21 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 7) | (r << 31));\n+}\n+\n+unsigned int\n+test_22 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 8) | (r << 31));\n+}\n+\n+unsigned int\n+test_23 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a >> 31) | (r << 31));\n+}"}, {"sha": "4617c3a5f1dbd0c0bbc389cd3fae462d17d3a132", "filename": "gcc/testsuite/gcc.target/sh/pr54089-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-4.c?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -0,0 +1,15 @@\n+/* Check that the rotcr instruction is generated when shifting the\n+   negated T bit on non-SH2A.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" \"-m2a*\" } { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotcr\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tst\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 1 } } */\n+\n+int\n+test_00 (int a, int b)\n+{\n+  int r = a != b;\n+  return r << 31;\n+}"}, {"sha": "f781acabf8e3574378d12bf85e6d806c895bc2a0", "filename": "gcc/testsuite/gcc.target/sh/pr54089-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-5.c?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -0,0 +1,14 @@\n+/* Check that the movrt rotr instruction sequence is generated when shifting\n+   the negated T bit on SH2A.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"movrt\" 1 } } */\n+/* { dg-final { scan-assembler-times \"rotr\" 1 } } */\n+\n+int\n+test_00 (int a, int b)\n+{\n+  int r = a != b;\n+  return r << 31;\n+}"}, {"sha": "a12a0e93044cb9fc02ab2467530072d80cc5220b", "filename": "gcc/testsuite/gcc.target/sh/pr54089-6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-6.c?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -0,0 +1,30 @@\n+/* Check that the rotr and rotl instructions are generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotr\" 2 } } */\n+/* { dg-final { scan-assembler-times \"rotl\" 2 } } */\n+\n+int\n+test_00 (int a)\n+{\n+  return (a << 1) | ((a >> 31) & 1);\n+}\n+\n+int\n+test_01 (int a)\n+{\n+  return (a << 1) | ((unsigned int)a >> 31);\n+}\n+\n+int\n+test_02 (int a)\n+{\n+  return ((unsigned int)a >> 1) | (a << 31);\n+}\n+\n+int\n+test_03 (int a)\n+{\n+  return ((a >> 1) & 0x7FFFFFFF) | (a << 31);\n+}"}, {"sha": "40ca8219a2fb307914a748e038a8f7826651fdd6", "filename": "gcc/testsuite/gcc.target/sh/pr54089-7.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780405350cee277933a7835a10d960dcea3a0947/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-7.c?ref=780405350cee277933a7835a10d960dcea3a0947", "patch": "@@ -0,0 +1,63 @@\n+/* Check that the rotcr instruction is generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotcr\" 4 } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+/* { dg-final { scan-assembler-not \"or\\t\" } } */\n+/* { dg-final { scan-assembler-not \"rotr\" } } */\n+/* { dg-final { scan-assembler-not \"and\" } } */\n+\n+typedef char bool;\n+\n+int\n+test_00 (int* a, int* b)\n+{\n+  int i;\n+  unsigned int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (t << 31) | (r >> 1);\n+    }\n+  return r;\n+}\n+\n+int\n+test_01 (int* a, int* b)\n+{\n+  int i;\n+  unsigned int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (t << 31) | (r >> 2);\n+    }\n+  return r;\n+}\n+\n+int\n+test_02 (int* a, int* b)\n+{\n+  int i;\n+  unsigned int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (t << 31) | (r >> 3);\n+    }\n+  return r;\n+}\n+\n+unsigned int\n+test_03 (const bool* a)\n+{\n+  int i;\n+  unsigned int r = 0;\n+  for (i = 0; i < 32; ++i)\n+    {\n+      bool t = a[i];\n+      r = (t << 31) | (r >> 1);\n+    }\n+  return r;\n+}"}]}