{"sha": "6f09f3140c724335069034b6b43d391867d43267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwOWYzMTQwYzcyNDMzNTA2OTAzNGI2YjQzZDM5MTg2N2Q0MzI2Nw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2007-11-08T00:01:38Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2007-11-08T00:01:38Z"}, "message": "re PR tree-optimization/33870 (miscompiles sqlite)\n\n\n\tPR 33870\n\t* tree.h (struct tree_struct_field_tag): Add field in_nested_struct.\n\t(SFT_IN_NESTED_STRUCT): Define.\n\t* tree-dfa.c (dump_subvars_for): Show offset of each\n\tsub-var.\n\t* tree-flow.h (struct fieldoff): Add field in_nested_struct.\n\t* tree-ssa-structalias.c (struct variable_info): Likewise.\n\t(push_fields_onto_fieldstack): If OFFSET is positive,\n\tset in_nested_struct.\n\t(create_variable_info_for): Copy setting of\n\tin_nested_struct from the field offset object.\n\t(set_uids_in_ptset): Set SFT_IN_NESTED_STRUCT from the\n\tvariable info object.\n\t* tree-ssa-operands.c (add_vars_for_offset): If VAR\n\tbelongs to a nested structure, adjust OFFSET by\n\tSFT_OFFSET(VAR).\n\ntestsuite/ChangeLog\n\n\t* gcc.c-torture/execute/pr33870.x: Remove.\n\nFrom-SVN: r129976", "tree": {"sha": "06efa0a928d92fb0ec421d6bddae19cebfe2145b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06efa0a928d92fb0ec421d6bddae19cebfe2145b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f09f3140c724335069034b6b43d391867d43267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f09f3140c724335069034b6b43d391867d43267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f09f3140c724335069034b6b43d391867d43267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f09f3140c724335069034b6b43d391867d43267/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4fd5b87bf37f1a58194897e10fae8132470f84a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fd5b87bf37f1a58194897e10fae8132470f84a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fd5b87bf37f1a58194897e10fae8132470f84a"}], "stats": {"total": 113, "additions": 100, "deletions": 13}, "files": [{"sha": "efc629375ef2c9362a680e13e64521d776b4176c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -1,3 +1,22 @@\n+2007-11-07  Diego Novillo  <dnovillo@google.com>\n+\n+\tPR 33870\n+\t* tree.h (struct tree_struct_field_tag): Add field in_nested_struct.\n+\t(SFT_IN_NESTED_STRUCT): Define.\n+\t* tree-dfa.c (dump_subvars_for): Show offset of each\n+\tsub-var.\n+\t* tree-flow.h (struct fieldoff): Add field in_nested_struct.\n+\t* tree-ssa-structalias.c (struct variable_info): Likewise.\n+\t(push_fields_onto_fieldstack): If OFFSET is positive,\n+\tset in_nested_struct.\n+\t(create_variable_info_for): Copy setting of\n+\tin_nested_struct from the field offset object.\n+\t(set_uids_in_ptset): Set SFT_IN_NESTED_STRUCT from the\n+\tvariable info object.\n+\t* tree-ssa-operands.c (add_vars_for_offset): If VAR\n+\tbelongs to a nested structure, adjust OFFSET by\n+\tSFT_OFFSET(VAR).\n+\n 2007-11-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR rtl-optimization/33737"}, {"sha": "2a863b9463fccec58029b15f86880e6ab1c67047", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -1,3 +1,8 @@\n+2007-11-07  Diego Novillo  <dnovillo@google.com>\n+\n+\tPR 33870\n+\t* gcc.c-torture/execute/pr33870.x: Remove.\n+\n 2007-11-07  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/33045"}, {"sha": "fbf8aae4ab6e400fb490302b698fd6d0728f1ff8", "filename": "gcc/testsuite/gcc.c-torture/execute/pr33870.x", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fd5b87bf37f1a58194897e10fae8132470f84a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fd5b87bf37f1a58194897e10fae8132470f84a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr33870.x?ref=e4fd5b87bf37f1a58194897e10fae8132470f84a", "patch": "@@ -1,9 +0,0 @@\n-# The test breaks because of wrong alias info for -O2 and -Os\n-\n-set torture_eval_before_compile {\n-  if {[string match {*-O[2s]*} \"$option\"]} {\n-     set torture_execute_xfail \"*-*-*\"\n-  }\n-}\n-\n-return 0"}, {"sha": "6ee90d7461705f727e22fa0d36997b98433e4631", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -287,7 +287,7 @@ dump_subvars_for (FILE *file, tree var)\n   for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n     {\n       print_generic_expr (file, subvar, dump_flags);\n-      fprintf (file, \" \");\n+      fprintf (file, \"@\" HOST_WIDE_INT_PRINT_UNSIGNED \" \", SFT_OFFSET (subvar));\n     }\n \n   fprintf (file, \"}\");"}, {"sha": "1b63e95d3bdcf90ca25908a375c1b99e02e44113", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -1159,6 +1159,10 @@ struct fieldoff\n   /* Field.  */\n   tree decl;\n \n+  /* True if this field is inside a structure nested inside the base\n+     containing object.  */\n+  unsigned int in_nested_struct : 1;\n+\n   /* Offset from the base of the base containing object to this field.  */\n   HOST_WIDE_INT offset;  \n "}, {"sha": "87eec7452b7781b8ab102afbd4034a399e16084d", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -1397,8 +1397,48 @@ add_vars_for_offset (tree var, unsigned HOST_WIDE_INT offset,\n   subvar_t sv;\n   unsigned int i;\n \n-  /* Adjust offset by the pointed-to location.  */\n-  offset += SFT_OFFSET (var);\n+  if (SFT_IN_NESTED_STRUCT (var))\n+    {\n+      /* Since VAR is an SFT inside a nested structure, the OFFSET\n+\t computed by get_ref_base_and_extent is the offset from the\n+\t start of the immediately containing structure.  However, to\n+\t find out what other SFTs are affected by this reference, we\n+\t need to know the offsets starting at the root structure in\n+\t the nesting hierarchy.\n+\n+\t For instance, given the following structure:\n+\n+\t \tstruct X {\n+\t\t  int a;\n+\t\t  struct Y {\n+\t\t    int b;\n+\t\t    struct Z {\n+\t\t      int c[3];\n+\t\t    } d;\n+\t\t  } e;\n+\t\t} m;\n+\n+\t and the following address expression:\n+\n+\t\tp_1 = &m.e.d;\n+\n+\t This structure will receive 5 SFTs, namely 2 for fields 'a'\n+\t and 'b' and 3 for the array 'c' in struct Z.  So, the\n+\t reference p_1->c[2] and m.e.d.c[2] access the exact same\n+\t memory location (ie, SFT.5).\n+\n+\t Now, alias analysis computed the points-to set for pointer\n+\t p_1 as  { SFT.3 } because that is the first field that p_1\n+\t actually points to.  When the expression p_1->c[2] is\n+\t analyzed, get_ref_base_and_extent will return an offset of 96\n+\t because we are accessing the third element of the array.  But\n+\t the SFT we are looking for is actually at offset 160,\n+\t counting from the top of struct X.\n+\n+\t Therefore, we adjust OFFSET by the offset of VAR so that we\n+\t can get at all the fields starting at VAR.  */\n+      offset += SFT_OFFSET (var);\n+    }\n \n   /* Add all subvars of var that overlap with the access.\n      Binary search for the first relevant SFT.  */"}, {"sha": "2d3a40a87316f1e1c762007d84873d2ed5ca9796", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -253,6 +253,15 @@ struct variable_info\n      variable.  This is used for C++ placement new.  */\n   unsigned int no_tbaa_pruning : 1;\n \n+  /* True if this variable is inside a structure nested in the\n+     structure for the base variable.  For instance, in \n+     struct X { int a; struct Y { int b; int c; } }, the variables for\n+     fields 'b' and 'c' are inside a nested structure.  We are not\n+     interested in tracking how many levels of nesting, just whether\n+     there is nesting at all.  This is later used to adjust offsets\n+     for pointers pointing into sub-structures.  */\n+  unsigned int in_nested_struct : 1;\n+\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n@@ -4133,6 +4142,12 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\tpair->alias_set = get_alias_set (addressable_type);\n \t      else\n \t\tpair->alias_set = -1;\n+\n+\t      /* If the base offset is positive, this field belongs to\n+\t\t a structure nested inside the base structure.  */\n+\t      if (offset > 0)\n+\t\tpair->in_nested_struct = true;\n+\n \t      count++;\n \t    }\n \t  else\n@@ -4181,6 +4196,12 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      pair->alias_set = get_alias_set (addressable_type);\n \t    else\n \t      pair->alias_set = -1;\n+\n+\t    /* If the base offset is positive, this field belongs to\n+\t       a structure nested inside the base structure.  */\n+\t    if (offset > 0)\n+\t      pair->in_nested_struct = true;\n+\n \t    count++;\n \t  }\n \telse\n@@ -4491,6 +4512,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->offset = fo->offset;\n \t  newvi->size = TREE_INT_CST_LOW (fo->size);\n \t  newvi->fullsize = vi->fullsize;\n+\t  newvi->in_nested_struct = fo->in_nested_struct;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode))\n@@ -4743,6 +4765,7 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t\t      || (!is_derefed && !vi->directly_dereferenced)\n \t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n \t\t    bitmap_set_bit (into, DECL_UID (sft));\n+\t\t  SFT_IN_NESTED_STRUCT (sft) = vi->in_nested_struct;\n \t\t}\n \t    }\n \t  else\n@@ -4946,7 +4969,6 @@ find_what_p_points_to (tree p)\n \t    }\n \n \t  /* Share the final set of variables when possible.  */\n-\n \t  finished_solution = BITMAP_GGC_ALLOC ();\n \t  stats.points_to_sets_created++;\n "}, {"sha": "d82ce850effdde354cb99a15cf350ce1abc355c9", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f09f3140c724335069034b6b43d391867d43267/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6f09f3140c724335069034b6b43d391867d43267", "patch": "@@ -2573,15 +2573,21 @@ struct tree_struct_field_tag GTY(())\n   /* Size of the field.  */\n   unsigned HOST_WIDE_INT size;\n \n+  /* True if this SFT is for a field in a nested structure.  */\n+  unsigned int in_nested_struct : 1;\n+\n   /* Alias set for a DECL_NONADDRESSABLE_P field.  Otherwise -1.  */\n   alias_set_type alias_set;\n };\n+\n #define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n #define SFT_OFFSET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.offset)\n #define SFT_SIZE(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.size)\n #define SFT_NONADDRESSABLE_P(NODE) \\\n   (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set != -1)\n #define SFT_ALIAS_SET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set)\n+#define SFT_IN_NESTED_STRUCT(NODE) \\\n+  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.in_nested_struct)\n \n /* Memory Partition Tags (MPTs) group memory symbols under one\n    common name for the purposes of placing memory PHI nodes.  */"}]}