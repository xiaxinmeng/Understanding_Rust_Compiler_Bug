{"sha": "6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY0ZmQ1MzYyZDE0ZTZjYTc5NGI2MjliZWZkNjBiN2IzYWE1NmE0Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-10-24T03:45:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-10-24T03:45:37Z"}, "message": "PR c++/25950 (DR 391)\n\n        PR c++/25950 (DR 391)\n        * call.c (struct conversion): Remove check_copy_constructor_p.\n        (reference_binding): Always bind a reference directly to a\n        compatible class rvalue.  Pass down LOOKUP_NO_TEMP_BIND during\n        temporary creation.\n        (check_constructor_callable): Remove.\n        (convert_like_real): Don't call it.\n        (initialize_reference): Don't call check_constructor_callable.\n        (standard_conversion): Check LOOKUP_NO_CONVERSION instead of\n        LOOKUP_CONSTRUCTOR_CALLABLE.  Don't require a temporary for base\n        conversions if LOOKUP_NO_TEMP_BIND.\n        (implicit_conversion): Pass through LOOKUP_NO_TEMP_BIND.\n        (build_user_type_conversion_1): Pass through LOOKUP_NO_TEMP_BIND for\n        second conversion.\n        * cp-tree.h (LOOKUP_CONSTRUCTOR_CALLABLE): Remove.\n\nFrom-SVN: r129596", "tree": {"sha": "fbca0e01a3c67e9b7a3d7a0dea6fb8da66a10c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbca0e01a3c67e9b7a3d7a0dea6fb8da66a10c03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d72702e2cbf5f92f41b442c0fec1e42e65730dc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72702e2cbf5f92f41b442c0fec1e42e65730dc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72702e2cbf5f92f41b442c0fec1e42e65730dc4"}], "stats": {"total": 178, "additions": 90, "deletions": 88}, "files": [{"sha": "d75316e67de451569a80fd75c04c7108bfb4ae4c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "patch": "@@ -1,3 +1,21 @@\n+2007-10-23  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/25950 (DR 391)\n+\t* call.c (struct conversion): Remove check_copy_constructor_p.\n+\t(reference_binding): Always bind a reference directly to a \n+\tcompatible class rvalue.  Pass down LOOKUP_NO_TEMP_BIND during \n+\ttemporary creation.\n+\t(check_constructor_callable): Remove.\n+\t(convert_like_real): Don't call it.\n+\t(initialize_reference): Don't call check_constructor_callable.\n+\t(standard_conversion): Check LOOKUP_NO_CONVERSION instead of\n+\tLOOKUP_CONSTRUCTOR_CALLABLE.  Don't require a temporary for base\n+\tconversions if LOOKUP_NO_TEMP_BIND.\n+\t(implicit_conversion): Pass through LOOKUP_NO_TEMP_BIND.\n+\t(build_user_type_conversion_1): Pass through LOOKUP_NO_TEMP_BIND for\n+\tsecond conversion.\n+\t* cp-tree.h (LOOKUP_CONSTRUCTOR_CALLABLE): Remove.\n+\n 2007-10-22  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33372"}, {"sha": "121092de3325697f2a91cc8b197a7b73e51348da", "filename": "gcc/cp/call.c", "status": "modified", "additions": 35, "deletions": 65, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "patch": "@@ -89,10 +89,6 @@ struct conversion {\n      temporary should be created to hold the result of the\n      conversion.  */\n   BOOL_BITFIELD need_temporary_p : 1;\n-  /* If KIND is ck_identity or ck_base_conv, true to indicate that the\n-     copy constructor must be accessible, even though it is not being\n-     used.  */\n-  BOOL_BITFIELD check_copy_constructor_p : 1;\n   /* If KIND is ck_ptr or ck_pmem, true to indicate that a conversion\n      from a pointer-to-derived to pointer-to-base is being performed.  */\n   BOOL_BITFIELD base_p : 1;\n@@ -201,7 +197,6 @@ static conversion *merge_conversion_sequences (conversion *, conversion *);\n static bool magic_varargs_p (tree);\n typedef void (*diagnostic_fn_t) (const char *, ...) ATTRIBUTE_GCC_CXXDIAG(1,2);\n static tree build_temp (tree, tree, int, diagnostic_fn_t *);\n-static void check_constructor_callable (tree, tree);\n \n /* Returns nonzero iff the destructor name specified in NAME matches BASETYPE.\n    NAME can take many forms...  */\n@@ -866,7 +861,13 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n \t   && vector_types_convertible_p (from, to, false))\n     return build_conv (ck_std, to, conv);\n-  else if (!(flags & LOOKUP_CONSTRUCTOR_CALLABLE)\n+  /* A derived-to-base conversion sequence is a user-defined conversion\n+     because it involves a constructor call, even though it has the rank of\n+     a standard conversion, so we don't consider it if we aren't allowing\n+     user-defined conversions.  But if we're binding directly to a\n+     reference, it's only a pointer conversion.  */\n+  else if ((!(flags & LOOKUP_NO_CONVERSION)\n+\t    || (flags & LOOKUP_NO_TEMP_BIND))\n \t   && IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t   && is_properly_derived_from (from, to))\n     {\n@@ -876,8 +877,8 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       /* The derived-to-base conversion indicates the initialization\n \t of a parameter with base type from an object of a derived\n \t type.  A temporary object is created to hold the result of\n-\t the conversion.  */\n-      conv->need_temporary_p = true;\n+\t the conversion unless we're binding directly to a reference.  */\n+      conv->need_temporary_p = !(flags & LOOKUP_NO_TEMP_BIND);\n     }\n   else\n     return NULL;\n@@ -1153,14 +1154,12 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   compatible_p = reference_compatible_p (to, from);\n \n   /* Directly bind reference when target expression's type is compatible with\n-     the reference and expression is an lvalue. In C++0x, the wording in\n-     [8.5.3/5 dcl.init.ref] is changed to also allow direct bindings for const\n-     and rvalue references to rvalues of compatible class type, as part of\n-     DR391. */\n+     the reference and expression is an lvalue. In DR391, the wording in\n+     [8.5.3/5 dcl.init.ref] is changed to also require direct bindings for\n+     const and rvalue references to rvalues of compatible class type. */\n   if (compatible_p\n       && (lvalue_p\n-\t  || ((cxx_dialect != cxx98)\n-\t      && (CP_TYPE_CONST_NON_VOLATILE_P(to) || TYPE_REF_IS_RVALUE (rto))\n+\t  || ((CP_TYPE_CONST_NON_VOLATILE_P(to) || TYPE_REF_IS_RVALUE (rto))\n \t      && CLASS_TYPE_P (from))))\n     {\n       /* [dcl.init.ref]\n@@ -1171,7 +1170,14 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \t    is reference-compatible with \"cv2 T2,\"\n \n \t the reference is bound directly to the initializer expression\n-\t lvalue.  */\n+\t lvalue.\n+\n+\t [...]\n+\t If the initializer expression is an rvalue, with T2 a class type,\n+\t and \"cv1 T1\" is reference-compatible with \"cv2 T2\", the reference\n+\t is bound to the object represented by the rvalue or to a sub-object\n+\t within that object.  */\n+\n       conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n \n@@ -1249,32 +1255,6 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !TYPE_REF_IS_RVALUE (rto))\n     return NULL;\n \n-  /* [dcl.init.ref]\n-\n-     If the initializer expression is an rvalue, with T2 a class type,\n-     and \"cv1 T1\" is reference-compatible with \"cv2 T2\", the reference\n-     is bound in one of the following ways:\n-\n-     -- The reference is bound to the object represented by the rvalue\n-\tor to a sub-object within that object.\n-\n-     -- ...\n-\n-     We use the first alternative.  The implicit conversion sequence\n-     is supposed to be same as we would obtain by generating a\n-     temporary.  Fortunately, if the types are reference compatible,\n-     then this is either an identity conversion or the derived-to-base\n-     conversion, just as for direct binding.  */\n-  if (CLASS_TYPE_P (from) && compatible_p)\n-    {\n-      conv = build_identity_conv (from, expr);\n-      conv = direct_reference_binding (rto, conv);\n-      conv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n-      if (!(flags & LOOKUP_CONSTRUCTOR_CALLABLE))\n-\tconv->u.next->check_copy_constructor_p = true;\n-      return conv;\n-    }\n-\n   /* [dcl.init.ref]\n \n      Otherwise, a temporary of type \"cv1 T1\" is created and\n@@ -1285,6 +1265,11 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   if (related_p && !at_least_as_qualified_p (to, from))\n     return NULL;\n \n+  /* We're generating a temporary now, but don't bind any more in the\n+     conversion (specifically, don't slice the temporary returned by a\n+     conversion operator).  */\n+  flags |= LOOKUP_NO_TEMP_BIND;\n+\n   conv = implicit_conversion (to, from, expr, c_cast_p,\n \t\t\t      flags);\n   if (!conv)\n@@ -1329,9 +1314,10 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       struct z_candidate *cand;\n+      int convflags = ((flags & LOOKUP_NO_TEMP_BIND)\n+\t\t       |LOOKUP_ONLYCONVERTING);\n \n-      cand = build_user_type_conversion_1\n-\t(to, expr, LOOKUP_ONLYCONVERTING);\n+      cand = build_user_type_conversion_1 (to, expr, convflags);\n       if (cand)\n \tconv = cand->second_conv;\n \n@@ -2590,6 +2576,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   conversion *conv = NULL;\n   tree args = NULL_TREE;\n   bool any_viable_p;\n+  int convflags;\n \n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n      BASE_CONV, as specified by [over.best.ics]; these become plain\n@@ -2620,6 +2607,11 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   candidates = 0;\n   flags |= LOOKUP_NO_CONVERSION;\n \n+  /* It's OK to bind a temporary for converting constructor arguments, but\n+     not in converting the return value of a conversion operator.  */\n+  convflags = ((flags & LOOKUP_NO_TEMP_BIND) | LOOKUP_NO_CONVERSION);\n+  flags &= ~LOOKUP_NO_TEMP_BIND;\n+\n   if (ctors)\n     {\n       tree t;\n@@ -2664,7 +2656,6 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n     {\n       tree fns;\n       tree conversion_path = TREE_PURPOSE (conv_fns);\n-      int convflags = LOOKUP_NO_CONVERSION;\n \n       /* If we are called to convert to a reference type, we are trying to\n \t find an lvalue binding, so don't even consider temporaries.  If\n@@ -4270,21 +4261,6 @@ enforce_access (tree basetype_path, tree decl, tree diag_decl)\n   return true;\n }\n \n-/* Check that a callable constructor to initialize a temporary of\n-   TYPE from an EXPR exists.  */\n-\n-static void\n-check_constructor_callable (tree type, tree expr)\n-{\n-  build_special_member_call (NULL_TREE,\n-\t\t\t     complete_ctor_identifier,\n-\t\t\t     build_tree_list (NULL_TREE, expr),\n-\t\t\t     type,\n-\t\t\t     LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING\n-\t\t\t     | LOOKUP_NO_CONVERSION\n-\t\t\t     | LOOKUP_CONSTRUCTOR_CALLABLE);\n-}\n-\n /* Initialize a temporary of type TYPE with EXPR.  The FLAGS are a\n    bitwise or of LOOKUP_* values.  If any errors are warnings are\n    generated, set *DIAGNOSTIC_FN to \"error\" or \"warning\",\n@@ -4442,8 +4418,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t leave it as an lvalue.  */\n       if (inner >= 0)\n \texpr = decl_constant_value (expr);\n-      if (convs->check_copy_constructor_p)\n-\tcheck_constructor_callable (totype, expr);\n       return expr;\n     case ck_ambig:\n       /* Call build_user_type_conversion again for the error.  */\n@@ -4473,8 +4447,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t{\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n-\t  if (convs->check_copy_constructor_p)\n-\t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  /* Build an expression for `*((base*) &expr)'.  */\n \t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n \t  expr = convert_to_base (expr, build_pointer_type (totype),\n@@ -6796,8 +6768,6 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t remember that the conversion was required.  */\n       if (conv->kind == ck_base)\n \t{\n-\t  if (conv->check_copy_constructor_p)\n-\t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  base_conv_type = conv->type;\n \t  conv = conv->u.next;\n \t}"}, {"sha": "c0f3bf0ea7335e99f58905fe23a51835546961f5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "patch": "@@ -3699,13 +3699,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define LOOKUP_PREFER_NAMESPACES (1 << 9)\n /* Accept types or namespaces.  */\n #define LOOKUP_PREFER_BOTH (LOOKUP_PREFER_TYPES | LOOKUP_PREFER_NAMESPACES)\n-/* We are checking that a constructor can be called -- but we do not\n-   actually plan to call it.  */\n-#define LOOKUP_CONSTRUCTOR_CALLABLE (1 << 10)\n /* Return friend declarations and un-declared builtin functions.\n    (Normally, these entities are registered in the symbol table, but\n    not found by lookup.)  */\n-#define LOOKUP_HIDDEN (LOOKUP_CONSTRUCTOR_CALLABLE << 1)\n+#define LOOKUP_HIDDEN (LOOKUP_PREFER_NAMESPACES << 1)\n /* Prefer that the lvalue be treated as an rvalue.  */\n #define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n "}, {"sha": "8c23c546d5d6088057354034daf4ff15a973bdcb", "filename": "gcc/testsuite/g++.dg/init/copy7.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d72702e2cbf5f92f41b442c0fec1e42e65730dc4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d72702e2cbf5f92f41b442c0fec1e42e65730dc4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C?ref=d72702e2cbf5f92f41b442c0fec1e42e65730dc4", "patch": "@@ -1,19 +0,0 @@\n-// { dg-options \"-std=c++98\" }\n-// PR c++/12226\n-\n-class foo {\n-private:\n-  foo(const foo &); // { dg-error \"\" }\n-public:\n-  foo();\n-};\n-const foo &bar = foo(); // { dg-error \"\" }\n-\n-class derived : public foo {\n-private:\n-  derived(const derived&);  // { dg-error \"\" }\n-public:\n-  derived();\n-};\n-\n-const foo& baz = derived(); // { dg-error \"\" }"}, {"sha": "89f941817ce6bf674cf9918d4228783dedfcf74f", "filename": "gcc/testsuite/g++.dg/overload/reftemp1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp1.C?ref=6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/25950\n+\n+struct X {\n+  X();\n+  explicit X(const X&);\n+};\n+\n+void g(const X&);\n+\n+int main()\n+{\n+  g(X());\n+}"}, {"sha": "365d5b13f5065a97a944343aae0e3cf9ee2007dd", "filename": "gcc/testsuite/g++.dg/overload/reftemp2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f4fd5362d14e6ca794b629befd60b7b3aa56a42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Freftemp2.C?ref=6f4fd5362d14e6ca794b629befd60b7b3aa56a42", "patch": "@@ -0,0 +1,23 @@\n+// DR 391 says that we always bind a reference to the base subobject; it is\n+// incorrect to call the A copy constructor to initialize the parameter of\n+// f.\n+\n+int fail;\n+\n+struct A {\n+  A() { }\n+  A(const A&) { fail = 1; }\n+};\n+struct B : public A { };\n+struct X {\n+  operator B() { return B(); }\n+};\n+X x;\n+\n+void f (const A&) { }\n+\n+int main()\n+{\n+  f(x);\n+  return fail;\n+}"}]}