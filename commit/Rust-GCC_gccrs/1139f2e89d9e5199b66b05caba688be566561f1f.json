{"sha": "1139f2e89d9e5199b66b05caba688be566561f1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzOWYyZTg5ZDllNTE5OWI2NmIwNWNhYmE2ODhiZTU2NjU2MWYxZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-16T12:07:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-16T12:07:02Z"}, "message": "decl.c (gnat_to_gnu_entity): Use boolean_type_node in lieu of integer_type_node for boolean operations.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use boolean_type_node in\n\tlieu of integer_type_node for boolean operations.\n\t(choices_to_gnu): Likewise.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Likewise.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(establish_gnat_vms_condition_handler): Likewise.\n\t(Exception_Handler_to_gnu_sjlj): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(build_unary_op_trapv): Likewise.\n\t(build_binary_op_trapv): Likewise.\n\t(emit_range_check): Likewise.\n\t(emit_index_check): Likewise.\n\t(convert_with_check): Likewise.\n\t* gcc-interface/utils.c (convert_vms_descriptor64): Likewise.\n\t(convert_vms_descriptor32): Likewise.\n\t(convert_vms_descriptor): Likewise.\n\t* gcc-interface/utils2.c (nonbinary_modular_operation): Likewise.\n\t(compare_arrays): Use boolean instead of integer constants.\n\t(build_binary_op) <TRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR, TRUTH_AND_EXPR,\n\tTRUTH_OR_EXPR, TRUTH_XOR_EXPR>: New case.  Check that the result type\n\tis a boolean type.\n\t<GE_EXPR, LE_EXPR, GT_EXPR, LT_EXPR>: Remove obsolete assertion.\n\t<EQ_EXPR, NE_EXPR>: Check that the result type is a boolean type.\n\t<PREINC/PREDECREMENT_EXPR, POSTINC/POSTDECREMENT_EXPR>: Delete.\n\t<TRUTH_NOT_EXPR>: Check that the result type is a boolean type.\n\t(build_unary_op): Use boolean_type_node in lieu of integer_type_node\n\tfor boolean operations.\n\t(fill_vms_descriptor): Likewise.  Fix formatting nits.\n\nFrom-SVN: r158411", "tree": {"sha": "e240b2394edcddd159a273da457f7a4e17a8d5c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e240b2394edcddd159a273da457f7a4e17a8d5c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1139f2e89d9e5199b66b05caba688be566561f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1139f2e89d9e5199b66b05caba688be566561f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1139f2e89d9e5199b66b05caba688be566561f1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1139f2e89d9e5199b66b05caba688be566561f1f/comments", "author": null, "committer": null, "parents": [{"sha": "d88bbbb943151cd73871f5ece8bac7f4127f76bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88bbbb943151cd73871f5ece8bac7f4127f76bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88bbbb943151cd73871f5ece8bac7f4127f76bd"}], "stats": {"total": 274, "additions": 159, "deletions": 115}, "files": [{"sha": "4e6367cc43dc18515e4b028652384afc31da2857", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1139f2e89d9e5199b66b05caba688be566561f1f", "patch": "@@ -1,3 +1,34 @@\n+2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use boolean_type_node in\n+\tlieu of integer_type_node for boolean operations.\n+\t(choices_to_gnu): Likewise.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Likewise.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(establish_gnat_vms_condition_handler): Likewise.\n+\t(Exception_Handler_to_gnu_sjlj): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(build_unary_op_trapv): Likewise.\n+\t(build_binary_op_trapv): Likewise.\n+\t(emit_range_check): Likewise.\n+\t(emit_index_check): Likewise.\n+\t(convert_with_check): Likewise.\n+\t* gcc-interface/utils.c (convert_vms_descriptor64): Likewise.\n+\t(convert_vms_descriptor32): Likewise.\n+\t(convert_vms_descriptor): Likewise.\n+\t* gcc-interface/utils2.c (nonbinary_modular_operation): Likewise.\n+\t(compare_arrays): Use boolean instead of integer constants.\n+\t(build_binary_op) <TRUTH_ANDIF_EXPR, TRUTH_ORIF_EXPR, TRUTH_AND_EXPR,\n+\tTRUTH_OR_EXPR, TRUTH_XOR_EXPR>: New case.  Check that the result type\n+\tis a boolean type.\n+\t<GE_EXPR, LE_EXPR, GT_EXPR, LT_EXPR>: Remove obsolete assertion.\n+\t<EQ_EXPR, NE_EXPR>: Check that the result type is a boolean type.\n+\t<PREINC/PREDECREMENT_EXPR, POSTINC/POSTDECREMENT_EXPR>: Delete.\n+\t<TRUTH_NOT_EXPR>: Check that the result type is a boolean type.\n+\t(build_unary_op): Use boolean_type_node in lieu of integer_type_node\n+\tfor boolean operations.\n+\t(fill_vms_descriptor): Likewise.  Fix formatting nits.\n+\n 2010-04-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.def (LOOP_STMT): Change to 4-operand nodes."}, {"sha": "4db6c112ff0a6276af47dd1bbf7176c1088e6a22", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1139f2e89d9e5199b66b05caba688be566561f1f", "patch": "@@ -1916,7 +1916,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Compute the size of this dimension.  */\n \t    gnu_max\n \t      = build3 (COND_EXPR, gnu_index_base_type,\n-\t\t\tbuild2 (GE_EXPR, integer_type_node, gnu_high, gnu_low),\n+\t\t\tbuild2 (GE_EXPR, boolean_type_node, gnu_high, gnu_low),\n \t\t\tgnu_high,\n \t\t\tbuild2 (MINUS_EXPR, gnu_index_base_type,\n \t\t\t\tgnu_low, fold_convert (gnu_index_base_type,\n@@ -2214,7 +2214,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    gnu_high\n \t\t      = build_cond_expr (sizetype,\n \t\t\t\t\t build_binary_op (GE_EXPR,\n-\t\t\t\t\t\t\t  integer_type_node,\n+\t\t\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t\t\t  gnu_orig_max,\n \t\t\t\t\t\t\t  gnu_orig_min),\n \t\t\t\t\t gnu_max, gnu_high);\n@@ -6335,13 +6335,11 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t  low = gnat_to_gnu (Low_Bound (choice));\n \t  high = gnat_to_gnu (High_Bound (choice));\n \n-\t  /* There's no good type to use here, so we might as well use\n-\t     integer_type_node.  */\n \t  this_test\n-\t    = build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t\t       build_binary_op (GE_EXPR, integer_type_node,\n+\t    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t       build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\t\t\toperand, low),\n-\t\t\t       build_binary_op (LE_EXPR, integer_type_node,\n+\t\t\t       build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t\toperand, high));\n \n \t  break;\n@@ -6352,10 +6350,10 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t  high = gnat_to_gnu (High_Bound (gnat_temp));\n \n \t  this_test\n-\t    = build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t\t       build_binary_op (GE_EXPR, integer_type_node,\n+\t    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t       build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\t\t\toperand, low),\n-\t\t\t       build_binary_op (LE_EXPR, integer_type_node,\n+\t\t\t       build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t\toperand, high));\n \t  break;\n \n@@ -6373,10 +6371,10 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t      high = TYPE_MAX_VALUE (type);\n \n \t      this_test\n-\t\t= build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t\t\t   build_binary_op (GE_EXPR, integer_type_node,\n+\t\t= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t\t   build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\t\t\t    operand, low),\n-\t\t\t\t   build_binary_op (LE_EXPR, integer_type_node,\n+\t\t\t\t   build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t\t    operand, high));\n \t      break;\n \t    }\n@@ -6386,7 +6384,7 @@ choices_to_gnu (tree operand, Node_Id choices)\n \tcase N_Character_Literal:\n \tcase N_Integer_Literal:\n \t  single = gnat_to_gnu (choice);\n-\t  this_test = build_binary_op (EQ_EXPR, integer_type_node, operand,\n+\t  this_test = build_binary_op (EQ_EXPR, boolean_type_node, operand,\n \t\t\t\t       single);\n \t  break;\n \n@@ -6398,8 +6396,8 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t  gcc_unreachable ();\n \t}\n \n-      result = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t\t\tresult, this_test);\n+      result = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, result,\n+\t\t\t\tthis_test);\n     }\n \n   return result;"}, {"sha": "b446e070e555a2c7434b684b1449e08d7005a4bd", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 64, "deletions": 55, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1139f2e89d9e5199b66b05caba688be566561f1f", "patch": "@@ -1212,7 +1212,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  gnu_expr = gnat_protect_expr (gnu_expr);\n \t  gnu_expr\n \t    = emit_check\n-\t      (build_binary_op (EQ_EXPR, integer_type_node,\n+\t      (build_binary_op (EQ_EXPR, boolean_type_node,\n \t\t\t\tgnu_expr,\n \t\t\t\tattribute == Attr_Pred\n \t\t\t\t? TYPE_MIN_VALUE (gnu_result_type)\n@@ -1677,7 +1677,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\tgnu_result\n \t\t  = build_cond_expr (comp_type,\n \t\t\t\t     build_binary_op (GE_EXPR,\n-\t\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t\t      boolean_type_node,\n \t\t\t\t\t\t      hb, lb),\n \t\t\t\t     gnu_result,\n \t\t\t\t     convert (comp_type, integer_zero_node));\n@@ -2259,7 +2259,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t  test_code = NE_EXPR;\n \t  gnu_cond_expr\n \t    = build3 (COND_EXPR, void_type_node,\n-\t\t      build_binary_op (LE_EXPR, integer_type_node,\n+\t\t      build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t       gnu_low, gnu_high),\n \t\t      NULL_TREE, alloc_stmt_list ());\n \t  set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n@@ -2280,7 +2280,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n       /* Set either the top or bottom exit condition.  */\n       LOOP_STMT_COND (gnu_loop_stmt)\n-\t= build_binary_op (test_code, integer_type_node, gnu_loop_var,\n+\t= build_binary_op (test_code, boolean_type_node, gnu_loop_var,\n \t\t\t   gnu_last);\n \n       /* Set either the top or bottom update statement and give it the source\n@@ -2359,7 +2359,7 @@ establish_gnat_vms_condition_handler (void)\n       gnat_vms_condition_handler_decl\n \t= create_subprog_decl (get_identifier (\"__gnat_handle_vms_condition\"),\n \t\t\t       NULL_TREE,\n-\t\t\t       build_function_type_list (integer_type_node,\n+\t\t\t       build_function_type_list (boolean_type_node,\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t ptr_void_type_node,\n \t\t\t\t\t\t\t NULL_TREE),\n@@ -3386,7 +3386,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t  else\n \t    this_choice\n \t      = build_binary_op\n-\t\t(EQ_EXPR, integer_type_node,\n+\t\t(EQ_EXPR, boolean_type_node,\n \t\t convert\n \t\t (integer_type_node,\n \t\t  build_component_ref\n@@ -3413,7 +3413,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \n \t  this_choice\n \t    = build_binary_op\n-\t      (EQ_EXPR, integer_type_node, TREE_VALUE (gnu_except_ptr_stack),\n+\t      (EQ_EXPR, boolean_type_node, TREE_VALUE (gnu_except_ptr_stack),\n \t       convert (TREE_TYPE (TREE_VALUE (gnu_except_ptr_stack)),\n \t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr)));\n \n@@ -3430,16 +3430,16 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \n \t      this_choice\n \t\t= build_binary_op\n-\t\t  (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t   build_binary_op (EQ_EXPR, integer_type_node, gnu_comp,\n+\t\t  (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t   build_binary_op (EQ_EXPR, boolean_type_node, gnu_comp,\n \t\t\t\t    build_int_cst (TREE_TYPE (gnu_comp), 'V')),\n \t\t   this_choice);\n \t    }\n \t}\n       else\n \tgcc_unreachable ();\n \n-      gnu_choice = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+      gnu_choice = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n \t\t\t\t    gnu_choice, this_choice);\n     }\n \n@@ -4166,14 +4166,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_expr_type = get_base_type (gnu_index_type);\n \n \t    /* Test whether the minimum slice value is too small.  */\n-\t    gnu_expr_l = build_binary_op (LT_EXPR, integer_type_node,\n+\t    gnu_expr_l = build_binary_op (LT_EXPR, boolean_type_node,\n \t\t\t\t\t  convert (gnu_expr_type,\n \t\t\t\t\t\t   gnu_min_expr),\n \t\t\t\t\t  convert (gnu_expr_type,\n \t\t\t\t\t\t   gnu_base_min_expr));\n \n \t    /* Test whether the maximum slice value is too large.  */\n-\t    gnu_expr_h = build_binary_op (GT_EXPR, integer_type_node,\n+\t    gnu_expr_h = build_binary_op (GT_EXPR, boolean_type_node,\n \t\t\t\t\t  convert (gnu_expr_type,\n \t\t\t\t\t\t   gnu_max_expr),\n \t\t\t\t\t  convert (gnu_expr_type,\n@@ -4182,7 +4182,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    /* Build a slice index check that returns the low bound,\n \t       assuming the slice is not empty.  */\n \t    gnu_expr = emit_check\n-\t      (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+\t      (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n \t\t\t\tgnu_expr_l, gnu_expr_h),\n \t       gnu_min_expr, CE_Index_Check_Failed, gnat_node);\n \n@@ -4621,7 +4621,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result\n \t    = build_cond_expr\n \t      (gnu_type,\n-\t       build_binary_op (GE_EXPR, integer_type_node,\n+\t       build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\tgnu_rhs,\n \t\t\t\tconvert (TREE_TYPE (gnu_rhs),\n \t\t\t\t\t TYPE_SIZE (gnu_type))),\n@@ -6523,7 +6523,7 @@ build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand,\n \n   operand = gnat_protect_expr (operand);\n \n-  return emit_check (build_binary_op (EQ_EXPR, integer_type_node,\n+  return emit_check (build_binary_op (EQ_EXPR, boolean_type_node,\n \t\t\t\t      operand, TYPE_MIN_VALUE (gnu_type)),\n \t\t     build_unary_op (code, gnu_type, operand),\n \t\t     CE_Overflow_Check_Failed, gnat_node);\n@@ -6567,8 +6567,8 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n     }\n \n   rhs_lt_zero = tree_expr_nonnegative_p (rhs)\n-\t\t? integer_zero_node\n-\t\t: build_binary_op (LT_EXPR, integer_type_node, rhs, zero);\n+\t\t? boolean_false_node\n+\t\t: build_binary_op (LT_EXPR, boolean_type_node, rhs, zero);\n \n   /* ??? Should use more efficient check for operand_equal_p (lhs, rhs, 0) */\n \n@@ -6604,10 +6604,10 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t\t\t\t\t      convert (wide_type, rhs));\n \n \t  tree check = build_binary_op\n-\t    (TRUTH_ORIF_EXPR, integer_type_node,\n-\t     build_binary_op (LT_EXPR, integer_type_node, wide_result,\n+\t    (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t     build_binary_op (LT_EXPR, boolean_type_node, wide_result,\n \t\t\t      convert (wide_type, type_min)),\n-\t     build_binary_op (GT_EXPR, integer_type_node, wide_result,\n+\t     build_binary_op (GT_EXPR, boolean_type_node, wide_result,\n \t\t\t      convert (wide_type, type_max)));\n \n \t  tree result = convert (gnu_type, wide_result);\n@@ -6630,9 +6630,9 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t  /* Overflow when (rhs < 0) ^ (wrapped_expr < lhs)), for addition\n \t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction.  */\n \t  tree check = build_binary_op\n-\t    (TRUTH_XOR_EXPR, integer_type_node, rhs_lt_zero,\n+\t    (TRUTH_XOR_EXPR, boolean_type_node, rhs_lt_zero,\n \t     build_binary_op (code == PLUS_EXPR ? LT_EXPR : GT_EXPR,\n-\t\t\t      integer_type_node, wrapped_expr, lhs));\n+\t\t\t      boolean_type_node, wrapped_expr, lhs));\n \n \t  return\n \t    emit_check (check, result, CE_Overflow_Check_Failed, gnat_node);\n@@ -6643,24 +6643,24 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n     {\n     case PLUS_EXPR:\n       /* When rhs >= 0, overflow when lhs > type_max - rhs.  */\n-      check_pos = build_binary_op (GT_EXPR, integer_type_node, lhs,\n+      check_pos = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n \t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_max, rhs)),\n \n       /* When rhs < 0, overflow when lhs < type_min - rhs.  */\n-      check_neg = build_binary_op (LT_EXPR, integer_type_node, lhs,\n+      check_neg = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n \t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_min, rhs));\n       break;\n \n     case MINUS_EXPR:\n       /* When rhs >= 0, overflow when lhs < type_min + rhs.  */\n-      check_pos = build_binary_op (LT_EXPR, integer_type_node, lhs,\n+      check_pos = build_binary_op (LT_EXPR, boolean_type_node, lhs,\n \t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_min, rhs)),\n \n       /* When rhs < 0, overflow when lhs > type_max + rhs.  */\n-      check_neg = build_binary_op (GT_EXPR, integer_type_node, lhs,\n+      check_neg = build_binary_op (GT_EXPR, boolean_type_node, lhs,\n \t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n \t\t\t\t\t\t    type_max, rhs));\n       break;\n@@ -6678,19 +6678,31 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n       tmp1 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_max, rhs);\n       tmp2 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_min, rhs);\n \n-      check_pos = build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t    build_binary_op (NE_EXPR, integer_type_node, zero, rhs),\n-\t\t    build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t      build_binary_op (GT_EXPR, integer_type_node, lhs, tmp1),\n-\t\t      build_binary_op (LT_EXPR, integer_type_node, lhs, tmp2)));\n-\n-      check_neg = fold_build3 (COND_EXPR, integer_type_node,\n-\t\t    build_binary_op (EQ_EXPR, integer_type_node, rhs,\n-\t\t\t\t     build_int_cst (gnu_type, -1)),\n-\t\t    build_binary_op (EQ_EXPR, integer_type_node, lhs, type_min),\n-\t\t    build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t      build_binary_op (GT_EXPR, integer_type_node, lhs, tmp2),\n-\t\t      build_binary_op (LT_EXPR, integer_type_node, lhs, tmp1)));\n+      check_pos\n+\t= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t   build_binary_op (NE_EXPR, boolean_type_node, zero,\n+\t\t\t\t\t    rhs),\n+\t\t\t   build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t\t\t    build_binary_op (GT_EXPR,\n+\t\t\t\t\t\t\t     boolean_type_node,\n+\t\t\t\t\t\t\t     lhs, tmp1),\n+\t\t\t\t\t    build_binary_op (LT_EXPR,\n+\t\t\t\t\t\t\t     boolean_type_node,\n+\t\t\t\t\t\t\t     lhs, tmp2)));\n+\n+      check_neg\n+\t= fold_build3 (COND_EXPR, boolean_type_node,\n+\t\t       build_binary_op (EQ_EXPR, boolean_type_node, rhs,\n+\t\t\t\t\tbuild_int_cst (gnu_type, -1)),\n+\t\t       build_binary_op (EQ_EXPR, boolean_type_node, lhs,\n+\t\t\t\t\ttype_min),\n+\t\t       build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t\t\tbuild_binary_op (GT_EXPR,\n+\t\t\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t\t\t lhs, tmp2),\n+\t\t\t\t\tbuild_binary_op (LT_EXPR,\n+\t\t\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t\t\t lhs, tmp1)));\n       break;\n \n     default:\n@@ -6704,8 +6716,8 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   if (TREE_CONSTANT (gnu_expr))\n     return gnu_expr;\n \n-  check = fold_build3 (COND_EXPR, integer_type_node,\n-\t\t       rhs_lt_zero,  check_neg, check_pos);\n+  check = fold_build3 (COND_EXPR, boolean_type_node, rhs_lt_zero, check_neg,\n+\t\t       check_pos);\n \n   return emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n }\n@@ -6739,19 +6751,18 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type, Node_Id gnat_node)\n   /* Checked expressions must be evaluated only once.  */\n   gnu_expr = gnat_protect_expr (gnu_expr);\n \n-  /* There's no good type to use here, so we might as well use\n-     integer_type_node. Note that the form of the check is\n+  /* Note that the form of the check is\n \t(not (expr >= lo)) or (not (expr <= hi))\n      the reason for this slightly convoluted form is that NaNs\n      are not considered to be in range in the float case.  */\n   return emit_check\n-    (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+    (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n \t\t      invert_truthvalue\n-\t\t      (build_binary_op (GE_EXPR, integer_type_node,\n+\t\t      (build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\t       convert (gnu_compare_type, gnu_expr),\n \t\t\t\t       convert (gnu_compare_type, gnu_low))),\n \t\t      invert_truthvalue\n-\t\t      (build_binary_op (LE_EXPR, integer_type_node,\n+\t\t      (build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\tconvert (gnu_compare_type, gnu_expr),\n \t\t\t\t\tconvert (gnu_compare_type,\n \t\t\t\t\t\t gnu_high)))),\n@@ -6788,15 +6799,13 @@ emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n   gnu_low = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_low, gnu_array_object);\n   gnu_high = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_high, gnu_array_object);\n \n-  /* There's no good type to use here, so we might as well use\n-     integer_type_node.   */\n   return emit_check\n-    (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n-\t\t      build_binary_op (LT_EXPR, integer_type_node,\n+    (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t      build_binary_op (LT_EXPR, boolean_type_node,\n \t\t\t\t       gnu_expr_check,\n \t\t\t\t       convert (TREE_TYPE (gnu_expr_check),\n \t\t\t\t\t\tgnu_low)),\n-\t\t      build_binary_op (GT_EXPR, integer_type_node,\n+\t\t      build_binary_op (GT_EXPR, boolean_type_node,\n \t\t\t\t       gnu_expr_check,\n \t\t\t\t       convert (TREE_TYPE (gnu_expr_check),\n \t\t\t\t\t\tgnu_high))),\n@@ -6909,7 +6918,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t     : 1))\n \tgnu_cond\n \t  = invert_truthvalue\n-\t    (build_binary_op (GE_EXPR, integer_type_node,\n+\t    (build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t      gnu_input, convert (gnu_in_basetype,\n \t\t\t\t\t\t  gnu_out_lb)));\n \n@@ -6920,9 +6929,9 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t\t\t\t TREE_REAL_CST (gnu_in_lb))\n \t     : 1))\n \tgnu_cond\n-\t  = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node, gnu_cond,\n+\t  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_cond,\n \t\t\t     invert_truthvalue\n-\t\t\t     (build_binary_op (LE_EXPR, integer_type_node,\n+\t\t\t     (build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t       gnu_input,\n \t\t\t\t\t       convert (gnu_in_basetype,\n \t\t\t\t\t\t\tgnu_out_ub))));\n@@ -6980,7 +6989,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       gnu_result = gnat_protect_expr (gnu_result);\n       gnu_conv = convert (calc_type, gnu_result);\n       gnu_comp\n-\t= fold_build2 (GE_EXPR, integer_type_node, gnu_result, gnu_zero);\n+\t= fold_build2 (GE_EXPR, boolean_type_node, gnu_result, gnu_zero);\n       gnu_add_pred_half\n \t= fold_build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n       gnu_subtract_pred_half"}, {"sha": "916a432231f585343a428b26a56553210113225b", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1139f2e89d9e5199b66b05caba688be566561f1f", "patch": "@@ -3025,7 +3025,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n \t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n-\t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n+\t  u = build_binary_op (EQ_EXPR, boolean_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  The fields are\n              64bits so they must be repacked. */\n@@ -3063,12 +3063,12 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n \t     or FL_COEFF or FL_BOUNDS not set.  */\n \t  u = build_int_cst (TREE_TYPE (aflags), 192);\n-\t  u = build_binary_op (TRUTH_OR_EXPR, integer_type_node,\n-\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t  u = build_binary_op (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n \t\t\t\t\t\tdimct,\n \t\t\t\t\t\tconvert (TREE_TYPE (dimct),\n \t\t\t\t\t\t\t size_one_node)),\n-\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n \t\t\t\t\t\tbuild2 (BIT_AND_EXPR,\n \t\t\t\t\t\t\tTREE_TYPE (aflags),\n \t\t\t\t\t\t\taflags, u),\n@@ -3173,7 +3173,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n \t  t = build3 (COMPONENT_REF, TREE_TYPE (klass), desc, klass, NULL);\n \t  u = convert (TREE_TYPE (klass), DECL_INITIAL (klass));\n-\t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n+\t  u = build_binary_op (EQ_EXPR, boolean_type_node, t, u);\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  */\n \t  t = TREE_CHAIN (pointer);\n@@ -3196,12 +3196,12 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n \t     or FL_COEFF or FL_BOUNDS not set.  */\n \t  u = build_int_cst (TREE_TYPE (aflags), 192);\n-\t  u = build_binary_op (TRUTH_OR_EXPR, integer_type_node,\n-\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t  u = build_binary_op (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n \t\t\t\t\t\tdimct,\n \t\t\t\t\t\tconvert (TREE_TYPE (dimct),\n \t\t\t\t\t\t\t size_one_node)),\n-\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t\t\t       build_binary_op (NE_EXPR, boolean_type_node,\n \t\t\t\t\t\tbuild2 (BIT_AND_EXPR,\n \t\t\t\t\t\t\tTREE_TYPE (aflags),\n \t\t\t\t\t\t\taflags, u),\n@@ -3263,11 +3263,11 @@ convert_vms_descriptor (tree gnu_type, tree gnu_expr, tree gnu_expr_alt_type,\n   mbo = build3 (COMPONENT_REF, TREE_TYPE (mbo), desc, mbo, NULL_TREE);\n   mbmo = build3 (COMPONENT_REF, TREE_TYPE (mbmo), desc, mbmo, NULL_TREE);\n   is64bit\n-    = build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n-\t\t       build_binary_op (EQ_EXPR, integer_type_node,\n+    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t       build_binary_op (EQ_EXPR, boolean_type_node,\n \t\t\t\t\tconvert (integer_type_node, mbo),\n \t\t\t\t\tinteger_one_node),\n-\t\t       build_binary_op (EQ_EXPR, integer_type_node,\n+\t\t       build_binary_op (EQ_EXPR, boolean_type_node,\n \t\t\t\t\tconvert (integer_type_node, mbmo),\n \t\t\t\t\tinteger_minus_one_node));\n "}, {"sha": "33f3a613f60b9416ec7c09e8576670e5ce9ceec7", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1139f2e89d9e5199b66b05caba688be566561f1f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=1139f2e89d9e5199b66b05caba688be566561f1f", "patch": "@@ -242,11 +242,11 @@ find_common_type (tree t1, tree t2)\n static tree\n compare_arrays (tree result_type, tree a1, tree a2)\n {\n+  tree result = convert (result_type, boolean_true_node);\n+  tree a1_is_null = convert (result_type, boolean_false_node);\n+  tree a2_is_null = convert (result_type, boolean_false_node);\n   tree t1 = TREE_TYPE (a1);\n   tree t2 = TREE_TYPE (a2);\n-  tree result = convert (result_type, integer_one_node);\n-  tree a1_is_null = convert (result_type, integer_zero_node);\n-  tree a2_is_null = convert (result_type, integer_zero_node);\n   bool a1_side_effects_p = TREE_SIDE_EFFECTS (a1);\n   bool a2_side_effects_p = TREE_SIDE_EFFECTS (a2);\n   bool length_zero_p = false;\n@@ -310,7 +310,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \n \t  length_zero_p = true;\n \t  this_a1_is_null = comparison;\n-\t  this_a2_is_null = convert (result_type, integer_one_node);\n+\t  this_a2_is_null = convert (result_type, boolean_true_node);\n \t}\n \n       /* If the length is some other constant value, we know that the\n@@ -339,7 +339,7 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n \t  if (EXPR_P (this_a1_is_null))\n \t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n-\t  this_a2_is_null = convert (result_type, integer_zero_node);\n+\t  this_a2_is_null = convert (result_type, boolean_false_node);\n \t}\n \n       /* Otherwise compare the computed lengths.  */\n@@ -491,7 +491,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n     {\n       result = gnat_protect_expr (result);\n       result = fold_build3 (COND_EXPR, op_type,\n-\t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n+\t\t\t    fold_build2 (LT_EXPR, boolean_type_node, result,\n \t\t\t\t\t convert (op_type, integer_zero_node)),\n \t\t\t    fold_build2 (PLUS_EXPR, op_type, result, modulus),\n \t\t\t    result);\n@@ -502,7 +502,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n     {\n       result = gnat_protect_expr (result);\n       result = fold_build3 (COND_EXPR, op_type,\n-\t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n+\t\t\t    fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t\t result, modulus),\n \t\t\t    fold_build2 (MINUS_EXPR, op_type,\n \t\t\t\t\t result, modulus),\n@@ -716,16 +716,28 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       modulus = NULL_TREE;\n       break;\n \n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (TREE_CODE (get_base_type (result_type)) == BOOLEAN_TYPE);\n+#endif\n+      operation_type = left_base_type;\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (operation_type, right_operand);\n+      break;\n+\n     case GE_EXPR:\n     case LE_EXPR:\n     case GT_EXPR:\n     case LT_EXPR:\n-      gcc_assert (!POINTER_TYPE_P (left_type));\n-\n-      /* ... fall through ... */\n-\n     case EQ_EXPR:\n     case NE_EXPR:\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (TREE_CODE (get_base_type (result_type)) == BOOLEAN_TYPE);\n+#endif\n       /* If either operand is a NULL_EXPR, just return a new one.  */\n       if (TREE_CODE (left_operand) == NULL_EXPR)\n \treturn build2 (op_code, result_type,\n@@ -842,13 +854,6 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       modulus = NULL_TREE;\n       break;\n \n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      /* These operations are not used anymore.  */\n-      gcc_unreachable ();\n-\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n@@ -1001,7 +1006,9 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      gcc_assert (result_type == base_type);\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (TREE_CODE (get_base_type (result_type)) == BOOLEAN_TYPE);\n+#endif\n       result = invert_truthvalue (operand);\n       break;\n \n@@ -1259,7 +1266,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n \t\tresult = fold_build3 (COND_EXPR, operation_type,\n \t\t\t\t      fold_build2 (NE_EXPR,\n-\t\t\t\t\t\t   integer_type_node,\n+\t\t\t\t\t\t   boolean_type_node,\n \t\t\t\t\t\t   operand,\n \t\t\t\t\t\t   convert\n \t\t\t\t\t\t     (operation_type,\n@@ -2088,12 +2095,11 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n tree\n fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n {\n-  tree field;\n   tree parm_decl = get_gnu_tree (gnat_formal);\n-  tree const_list = NULL_TREE;\n   tree record_type = TREE_TYPE (TREE_TYPE (parm_decl));\n-  int do_range_check =\n-      strcmp (\"MBO\",\n+  tree const_list = NULL_TREE, field;\n+  const bool do_range_check\n+    = strcmp (\"MBO\",\n \t      IDENTIFIER_POINTER (DECL_NAME (TYPE_FIELDS (record_type))));\n \n   expr = maybe_unconstrained_array (expr);\n@@ -2105,19 +2111,19 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n \t\t\t      SUBSTITUTE_PLACEHOLDER_IN_EXPR\n \t\t\t      (DECL_INITIAL (field), expr));\n \n-      /* Check to ensure that only 32bit pointers are passed in\n-\t 32bit descriptors */\n-      if (do_range_check &&\n-          strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), \"POINTER\") == 0)\n+      /* Check to ensure that only 32-bit pointers are passed in\n+\t 32-bit descriptors */\n+      if (do_range_check\n+          && strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), \"POINTER\") == 0)\n         {\n-\t  tree pointer64type =\n-\t     build_pointer_type_for_mode (void_type_node, DImode, false);\n+\t  tree pointer64type\n+\t    = build_pointer_type_for_mode (void_type_node, DImode, false);\n \t  tree addr64expr = build_unary_op (ADDR_EXPR, pointer64type, expr);\n-\t  tree malloc64low =\n-\t     build_int_cstu (long_integer_type_node, 0x80000000);\n+\t  tree malloc64low\n+\t    = build_int_cstu (long_integer_type_node, 0x80000000);\n \n \t  add_stmt (build3 (COND_EXPR, void_type_node,\n-\t\t\t    build_binary_op (GE_EXPR, long_integer_type_node,\n+\t\t\t    build_binary_op (GE_EXPR, boolean_type_node,\n \t\t\t\t\t     convert (long_integer_type_node,\n \t\t\t\t\t\t      addr64expr),\n \t\t\t\t\t     malloc64low),"}]}