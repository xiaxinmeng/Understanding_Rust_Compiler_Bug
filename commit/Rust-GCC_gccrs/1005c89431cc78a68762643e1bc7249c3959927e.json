{"sha": "1005c89431cc78a68762643e1bc7249c3959927e", "node_id": "C_kwDOANBUbNoAKDEwMDVjODk0MzFjYzc4YTY4NzYyNjQzZTFiYzcyNDljMzk1OTkyN2U", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-20T14:27:47Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-09-20T14:27:47Z"}, "message": "vect: Fix SLP layout handling of masked loads [PR106794]\n\nPR106794 shows that I'd forgotten about masked loads when\ndoing the SLP layout changes.  These loads can't currently\nbe permuted independently of their mask input, so during\nconstruction they never get a load permutation.\n\n(If we did support permuting masked loads in future, the mask\nwould need to be in the right order for the load, rather than in\nthe order implied by the result of the permutation.  Since masked\nloads can't be partly or fully scalarised in the way that normal\npermuted loads can be, there's probably no benefit to fusing the\npermutation and the load.  Permutation after the fact is probably\ngood enough.)\n\ngcc/\n\tPR tree-optimization/106794\n\tPR tree-optimization/106914\n\t* tree-vect-slp.cc (vect_optimize_slp_pass::internal_node_cost):\n\tOnly consider loads that already have a permutation.\n\t(vect_optimize_slp_pass::start_choosing_layouts): Assert that\n\tloads with permutations are leaf nodes.  Prevent any kind of grouped\n\taccess from changing layout if it doesn't have a load permutation.\n\ngcc/testsuite/\n\t* gcc.dg/vect/pr106914.c: New test.\n\t* g++.dg/vect/pr106794.cc: Likewise.", "tree": {"sha": "f877af71a0131d84dc6134c289ea2020ae71f20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f877af71a0131d84dc6134c289ea2020ae71f20b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1005c89431cc78a68762643e1bc7249c3959927e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1005c89431cc78a68762643e1bc7249c3959927e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1005c89431cc78a68762643e1bc7249c3959927e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1005c89431cc78a68762643e1bc7249c3959927e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a773bf2f08656a39ac75cf6b4871c8cec8b5007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a773bf2f08656a39ac75cf6b4871c8cec8b5007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a773bf2f08656a39ac75cf6b4871c8cec8b5007"}], "stats": {"total": 85, "additions": 77, "deletions": 8}, "files": [{"sha": "f056563c4e1d883122771c63afabc559972aa8a9", "filename": "gcc/testsuite/g++.dg/vect/pr106794.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr106794.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr106794.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr106794.cc?ref=1005c89431cc78a68762643e1bc7249c3959927e", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Ofast\" } */\n+/* { dg-additional-options \"-march=bdver2\" { target x86_64-*-* i?86-*-* } } */\n+\n+template <class T> struct Vector3 {\n+  Vector3();\n+  Vector3(T, T, T);\n+  T length() const;\n+  T x, y, z;\n+};\n+template <class T>\n+Vector3<T>::Vector3(T _x, T _y, T _z) : x(_x), y(_y), z(_z) {}\n+Vector3<float> cross(Vector3<float> a, Vector3<float> b) {\n+  return Vector3<float>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,\n+                        a.x * b.y - a.y * b.x);\n+}\n+template <class T> T Vector3<T>::length() const { return z; }\n+int generateNormals_i;\n+float generateNormals_p2_0, generateNormals_p0_0;\n+struct SphereMesh {\n+  void generateNormals();\n+  float vertices;\n+};\n+void SphereMesh::generateNormals() {\n+  Vector3<float> *faceNormals = new Vector3<float>;\n+  for (int j; j; j++) {\n+    float *p0 = &vertices + 3, *p1 = &vertices + j * 3, *p2 = &vertices + 3,\n+          *p3 = &vertices + generateNormals_i + j * 3;\n+    Vector3<float> v0(p1[0] - generateNormals_p0_0, p1[1] - 1, p1[2] - 2),\n+        v1(0, 1, 2);\n+    if (v0.length())\n+      v1 = Vector3<float>(p3[0] - generateNormals_p2_0, p3[1] - p2[1],\n+                          p3[2] - p2[2]);\n+    else\n+      v1 = Vector3<float>(generateNormals_p0_0 - p3[0], p0[1] - p3[1],\n+                          p0[2] - p3[2]);\n+    Vector3<float> faceNormal = cross(v0, v1);\n+    faceNormals[j] = faceNormal;\n+  }\n+}"}, {"sha": "9d9b3e30081a54901235764453204cabab1efbb8", "filename": "gcc/testsuite/gcc.dg/vect/pr106914.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr106914.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr106914.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr106914.c?ref=1005c89431cc78a68762643e1bc7249c3959927e", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fprofile-generate\" } */\n+/* { dg-additional-options \"-mavx512vl\" { target x86_64-*-* i?86-*-* } } */\n+\n+int *mask_slp_int64_t_8_2_x, *mask_slp_int64_t_8_2_y, *mask_slp_int64_t_8_2_z;\n+\n+void\n+__attribute__mask_slp_int64_t_8_2() {\n+  for (int i; i; i += 8) {\n+    mask_slp_int64_t_8_2_x[i + 6] =\n+        mask_slp_int64_t_8_2_y[i + 6] ? mask_slp_int64_t_8_2_z[i] : 1;\n+    mask_slp_int64_t_8_2_x[i + 7] =\n+        mask_slp_int64_t_8_2_y[i + 7] ? mask_slp_int64_t_8_2_z[i + 7] : 2;\n+  }\n+}"}, {"sha": "229f2663ebcc6161e9294381a9a857308fe4c713", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1005c89431cc78a68762643e1bc7249c3959927e/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=1005c89431cc78a68762643e1bc7249c3959927e", "patch": "@@ -4494,7 +4494,8 @@ vect_optimize_slp_pass::internal_node_cost (slp_tree node, int in_layout_i,\n   stmt_vec_info rep = SLP_TREE_REPRESENTATIVE (node);\n   if (rep\n       && STMT_VINFO_DATA_REF (rep)\n-      && DR_IS_READ (STMT_VINFO_DATA_REF (rep)))\n+      && DR_IS_READ (STMT_VINFO_DATA_REF (rep))\n+      && SLP_TREE_LOAD_PERMUTATION (node).exists ())\n     {\n       auto_load_permutation_t tmp_perm;\n       tmp_perm.safe_splice (SLP_TREE_LOAD_PERMUTATION (node));\n@@ -4569,8 +4570,12 @@ vect_optimize_slp_pass::start_choosing_layouts ()\n       if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \t{\n \t  /* If splitting out a SLP_TREE_LANE_PERMUTATION can make the node\n-\t     unpermuted, record a layout that reverses this permutation.  */\n-\t  gcc_assert (partition.layout == 0);\n+\t     unpermuted, record a layout that reverses this permutation.\n+\n+\t     We would need more work to cope with loads that are internally\n+\t     permuted and also have inputs (such as masks for\n+\t     IFN_MASK_LOADs).  */\n+\t  gcc_assert (partition.layout == 0 && !m_slpg->vertices[node_i].succ);\n \t  if (!STMT_VINFO_GROUPED_ACCESS (dr_stmt))\n \t    continue;\n \t  dr_stmt = DR_GROUP_FIRST_ELEMENT (dr_stmt);\n@@ -4684,12 +4689,21 @@ vect_optimize_slp_pass::start_choosing_layouts ()\n \t  vertex.weight = vect_slp_node_weight (node);\n \n \t  /* We do not handle stores with a permutation, so all\n-\t     incoming permutations must have been materialized.  */\n+\t     incoming permutations must have been materialized.\n+\n+\t     We also don't handle masked grouped loads, which lack a\n+\t     permutation vector.  In this case the memory locations\n+\t     form an implicit second input to the loads, on top of the\n+\t     explicit mask input, and the memory input's layout cannot\n+\t     be changed.\n+\n+\t     On the other hand, we do support permuting gather loads and\n+\t     masked gather loads, where each scalar load is independent\n+\t     of the others.  This can be useful if the address/index input\n+\t     benefits from permutation.  */\n \t  if (STMT_VINFO_DATA_REF (rep)\n-\t      && DR_IS_WRITE (STMT_VINFO_DATA_REF (rep)))\n-\t    /* ???  We're forcing materialization in place\n-\t       of the child here, we'd need special handling\n-\t       in materialization to leave layout -1 here.  */\n+\t      && STMT_VINFO_GROUPED_ACCESS (rep)\n+\t      && !SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \t    partition.layout = 0;\n \n \t  /* We cannot change the layout of an operation that is"}]}