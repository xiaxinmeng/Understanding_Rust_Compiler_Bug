{"sha": "38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiOWM4YzNhOTg5YmU0YjZlZmVjMzRmMWU2MGEzOTQyNWQyN2ZiNg==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2005-05-17T20:07:08Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-05-17T20:07:08Z"}, "message": "Yet more Objective-C++...\n\n        * objc-act.c (objc_finish_try_stmt): Add return value.\n        (objc_build_synchronized): Likewise.\n\n        * objc-act.c (objc_is_gcable_type): Add.\n        (objc_substitute_decl): Add.\n        (objc_build_ivar_assignment): Add.\n        (objc_build_global_assignment): Add.\n        (objc_build_strong_cast_assignment): Add.\n        (objc_is_ivar_reference_p): Add.\n        (objc_is_global_reference_p): Add.\n        (objc_generate_write_barrier): Add.\n        (objc_rewrite_function_call): Add.\n        (objc_gimplify_expr): Add Objective-C++ support.\n        * objc-act.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Likewise.\n        (SIZEOF_OBJC_TYPE_LANG_SPECIFIC): Add.\n        (INIT_TYPE_OBJC_INFO): Add Objective-C++ support.\n        (DUP_TYPE_OBJC_INFO): Likewise.\n        (struct imp_entry): Add field has_cxx_cdtors.\n        (struct imp_entry *imp_list): Add OCTI_UMSG_FAST_DECL,\n        OCTI_METH_LIST_TEMPL, OCTI_METH_PROTO_LIST_TEMPL,\n        OCTI_IVAR_LIST_TEMPL, OCTI_ASSIGN_IVAR_DECL,\n        OCTI_ASSIGN_IVAR_FAST_DECL, OCTI_ASSIGN_GLOBAL_DECL,\n        OCTI_ASSIGN_STRONGCAST_DECL.\n        (umsg_fast_decl): Add.\n        (objc_assign_ivar_decl): Add.\n        (objc_assign_ivar_fast_decl): Add.\n        (objc_assign_global_decl): Add.\n        (objc_assign_strong_cast_decl): Add.\n        (objc_method_list_ptr): Add.\n        (objc_method_proto_list_ptr): Add.\n        (objc_ivar_list_ptr): Add.\n\n        * objc-act.c (should_call_super_dealloc): Add.\n        (OBJC_VERSION): Bump to 6.\n        (objc_is_gcable_type): Add.\n        (objc_substitute_decl): Add.\n        (objc_build_ivar_assignment): Add.\n        (objc_build_global_assignment): Add.\n        (objc_build_strong_cast_assignment): Add.\n        (objc_is_gcable_p): Add.\n        (objc_is_ivar_reference_p): Add.\n        (objc_is_global_reference_p): Add.\n        (generate_shared_structures): Add flags parameter.\n        (objc_generate_cxx_ctor_or_dtor): Add.\n        (objc_generate_cxx_cdtors): Add.\n        (add_class): Add name parameter.\n        (objc_types_share_size_and_alignment): Add.\n        (comp_proto_with_proto): Add strict parameter.\n        (CLS_HAS_CXX_STRUCTORS): Add.\n        (TAG_ASSIGNIVAR): Add.\n        (TAG_ASSIGNGLOBAL): Add.\n        (TAG_ASSIGNSTRONGCAST): Add.\n        (TAG_MSGSEND_FAST): Add.\n        (TAG_ASSIGNIVAR_FAST): Add.\n        (TAG_CXX_CONSTRUCT): Add.\n        (TAG_CXX_DESTRUCT): Add.\n        (OBJC_LOOKUP_CLASS): Add.\n        (OBJC_LOOKUP_NO_SUPER): Add.\n        (objc_finish_file): Add pch support.\n        (objc_finish_implementation): Add Objective-C++ support.\n        (synth_module_prologue): Likewise.\n        (synth_module_prologue): Add fast dispatching.\n        (objc_get_class_reference): Add Objective-C++ support.\n        (objc_generate_write_barrier): Likewise.\n        (next_sjlj_build_enter_and_setjmp): Likewise.\n        (objc_begin_try_stmt): Likewise.\n        (build_next_objc_exception_stuff): Add fast ivar support.\n        (build_private_template): Mark the record as used so debug\n        information is generated.\n        (build_protocol_template): Add Objective-C++ support.\n        (objc_method_parm_type) Likewise.\n        (objc_generate_cxx_ctor_or_dtor): Likewise.\n        (objc_generate_cxx_cdtors): Likewise.\n        (build_protocol_initializer): Likewise.\n        (build_category_template): Likewise.\n        (build_class_template): Likewise.\n        (build_method_list_template): Likewise.\n        (build_category_initializer): Likewise.\n        (build_shared_structure_initializer): Likewise.\n        (objc_finish_message_expr): Likewise.\n        (build_objc_method_call): Add fast dispatch support.\n        (lookup_method_static): Add support to end search at superclasses.\n        (add_method_to_hash_list): Add strict parameter to\n        comp_proto_with_proto.\n        (objc_add_method): Likewise.\n        (objc_add_method): Also set the interface_value.\n        (add_instance_variable): Add Objective-C++ support.\n        (objc_is_public): Likewise.\n        (start_class): Likewise.\n        (continue_class): Likewise.\n        (encode_aggregate_within): Likewise.\n        (start_method_def): Likewise.\n        (objc_start_function): Clear current_function_returns_value\n        and current_function_returns_null.\n        (really_start_method): Add Objective-C++ support.\n        (objc_finish_method_definition): Add warning for missing\n        [super dealloc].\n        (finish_objc): Add Objective-C++ support.\n        (generate_objc_image_info): Likewise.\n        (objc_lookup_ivar): Likewise.\n        * objc-act.h (TYPE_HAS_OBJC_INFO): Likewise.\n        (INIT_TYPE_OBJC_INFO): Likewise.\n        (DUP_TYPE_OBJC_INFO): Likewise.\n\nFrom-SVN: r99857", "tree": {"sha": "5c27e283cf816aa99e92251fc2f107d93a66e0c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c27e283cf816aa99e92251fc2f107d93a66e0c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/comments", "author": null, "committer": null, "parents": [{"sha": "3193108e90e2c61c784027c730a75fa3f88921b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3193108e90e2c61c784027c730a75fa3f88921b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3193108e90e2c61c784027c730a75fa3f88921b0"}], "stats": {"total": 1200, "additions": 963, "deletions": 237}, "files": [{"sha": "10465b82115a566101906738348f9010ffbc562b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "patch": "@@ -1,3 +1,111 @@\n+2005-05-17  Mike Stump  <mrs@apple.com>\n+\n+\tYet more Objective-C++...\n+\n+\t* objc-act.c (objc_finish_try_stmt): Add return value.\n+\t(objc_build_synchronized): Likewise.\n+\n+\t* objc-act.c (objc_is_gcable_type): Add.\n+\t(objc_substitute_decl): Add.\n+\t(objc_build_ivar_assignment): Add.\n+\t(objc_build_global_assignment): Add.\n+\t(objc_build_strong_cast_assignment): Add.\n+\t(objc_is_ivar_reference_p): Add.\n+\t(objc_is_global_reference_p): Add.\n+\t(objc_generate_write_barrier): Add.\n+\t(objc_rewrite_function_call): Add.\n+\t(objc_gimplify_expr): Add Objective-C++ support.\n+\t* objc-act.h (ALLOC_OBJC_TYPE_LANG_SPECIFIC): Likewise.\n+\t(SIZEOF_OBJC_TYPE_LANG_SPECIFIC): Add.\n+\t(INIT_TYPE_OBJC_INFO): Add Objective-C++ support.\n+\t(DUP_TYPE_OBJC_INFO): Likewise.\n+\t(struct imp_entry): Add field has_cxx_cdtors.\n+\t(struct imp_entry *imp_list): Add OCTI_UMSG_FAST_DECL,\n+\tOCTI_METH_LIST_TEMPL, OCTI_METH_PROTO_LIST_TEMPL,\n+\tOCTI_IVAR_LIST_TEMPL, OCTI_ASSIGN_IVAR_DECL,\n+\tOCTI_ASSIGN_IVAR_FAST_DECL, OCTI_ASSIGN_GLOBAL_DECL,\n+\tOCTI_ASSIGN_STRONGCAST_DECL.\n+\t(umsg_fast_decl): Add.\n+\t(objc_assign_ivar_decl): Add.\n+\t(objc_assign_ivar_fast_decl): Add.\n+\t(objc_assign_global_decl): Add.\n+\t(objc_assign_strong_cast_decl): Add.\n+\t(objc_method_list_ptr): Add.\n+\t(objc_method_proto_list_ptr): Add.\n+\t(objc_ivar_list_ptr): Add.\n+\n+\t* objc-act.c (should_call_super_dealloc): Add.\n+\t(OBJC_VERSION): Bump to 6.\n+\t(objc_is_gcable_type): Add.\n+\t(objc_substitute_decl): Add.\n+\t(objc_build_ivar_assignment): Add.\n+\t(objc_build_global_assignment): Add.\n+\t(objc_build_strong_cast_assignment): Add.\n+\t(objc_is_gcable_p): Add.\n+\t(objc_is_ivar_reference_p): Add.\n+\t(objc_is_global_reference_p): Add.\n+\t(generate_shared_structures): Add flags parameter.\n+\t(objc_generate_cxx_ctor_or_dtor): Add.\n+\t(objc_generate_cxx_cdtors): Add.\n+\t(add_class): Add name parameter.\n+\t(objc_types_share_size_and_alignment): Add.\n+\t(comp_proto_with_proto): Add strict parameter.\n+\t(CLS_HAS_CXX_STRUCTORS): Add.\n+\t(TAG_ASSIGNIVAR): Add.\n+\t(TAG_ASSIGNGLOBAL): Add.\n+\t(TAG_ASSIGNSTRONGCAST): Add.\n+\t(TAG_MSGSEND_FAST): Add.\n+\t(TAG_ASSIGNIVAR_FAST): Add.\n+\t(TAG_CXX_CONSTRUCT): Add.\n+\t(TAG_CXX_DESTRUCT): Add.\n+\t(OBJC_LOOKUP_CLASS): Add.\n+\t(OBJC_LOOKUP_NO_SUPER): Add.\n+\t(objc_finish_file): Add pch support.\n+\t(objc_finish_implementation): Add Objective-C++ support.\n+\t(synth_module_prologue): Likewise.\n+\t(synth_module_prologue): Add fast dispatching.\n+\t(objc_get_class_reference): Add Objective-C++ support.\n+\t(objc_generate_write_barrier): Likewise.\n+\t(next_sjlj_build_enter_and_setjmp): Likewise.\n+\t(objc_begin_try_stmt): Likewise.\n+\t(build_next_objc_exception_stuff): Add fast ivar support.\n+\t(build_private_template): Mark the record as used so debug\n+\tinformation is generated.\n+\t(build_protocol_template): Add Objective-C++ support.\n+\t(objc_method_parm_type) Likewise.\n+\t(objc_generate_cxx_ctor_or_dtor): Likewise.\n+\t(objc_generate_cxx_cdtors): Likewise.\n+\t(build_protocol_initializer): Likewise.\n+\t(build_category_template): Likewise.\n+\t(build_class_template): Likewise.\n+\t(build_method_list_template): Likewise.\n+\t(build_category_initializer): Likewise.\n+\t(build_shared_structure_initializer): Likewise.\n+\t(objc_finish_message_expr): Likewise.\n+\t(build_objc_method_call): Add fast dispatch support.\n+\t(lookup_method_static): Add support to end search at superclasses.\n+\t(add_method_to_hash_list): Add strict parameter to\n+\tcomp_proto_with_proto.\n+\t(objc_add_method): Likewise.\n+\t(objc_add_method): Also set the interface_value.\n+\t(add_instance_variable): Add Objective-C++ support.\n+\t(objc_is_public): Likewise.\n+\t(start_class): Likewise.\n+\t(continue_class): Likewise.\n+\t(encode_aggregate_within): Likewise.\n+\t(start_method_def): Likewise.\n+\t(objc_start_function): Clear current_function_returns_value\n+\tand current_function_returns_null.\n+\t(really_start_method): Add Objective-C++ support.\n+\t(objc_finish_method_definition): Add warning for missing\n+\t[super dealloc].\n+\t(finish_objc): Add Objective-C++ support.\n+\t(generate_objc_image_info): Likewise.\n+\t(objc_lookup_ivar): Likewise.\n+\t* objc-act.h (TYPE_HAS_OBJC_INFO): Likewise.\n+\t(INIT_TYPE_OBJC_INFO): Likewise.\n+\t(DUP_TYPE_OBJC_INFO): Likewise.\n+\n 2005-04-23  DJ Delorie  <dj@redhat.com>\n \n \t* objc-act.c: Adjust warning() callers."}, {"sha": "c1ce2e794d60a28410e13376c55b697f59adb268", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 817, "deletions": 223, "changes": 1040, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "patch": "@@ -77,6 +77,8 @@ Boston, MA 02111-1307, USA.  */\n \n #define OBJC_VOID_AT_END\tvoid_list_node\n \n+static unsigned int should_call_super_dealloc = 0;\n+\n /* When building Objective-C++, we are not linking against the C front-end\n    and so need to replicate the C tree-construction functions in some way.  */\n #ifdef OBJCPLUS\n@@ -126,7 +128,7 @@ char *util_firstobj;\n    the module (file) was compiled for, and is recorded in the\n    module descriptor.  */\n \n-#define OBJC_VERSION\t(flag_next_runtime ? 5 : 8)\n+#define OBJC_VERSION\t(flag_next_runtime ? 6 : 8)\n #define PROTOCOL_VERSION 2\n \n /* (Decide if these can ever be validly changed.) */\n@@ -142,15 +144,9 @@ static void finish_objc (void);\n \n /* Code generation.  */\n \n-static void synth_module_prologue (void);\n static tree objc_build_constructor (tree, tree);\n-static void build_module_descriptor (void);\n-static void build_module_initializer_routine (void);\n-static tree init_module_descriptor (tree);\n static tree build_objc_method_call (int, tree, tree, tree, tree);\n-static void generate_strings (void);\n static tree get_proto_encoding (tree);\n-static void build_selector_translation_table (void);\n static tree lookup_interface (tree);\n static tree objc_add_static_instance (tree, tree);\n \n@@ -169,55 +165,33 @@ static tree objc_add_method (tree, tree, int);\n static tree add_instance_variable (tree, int, tree);\n static tree build_ivar_reference (tree);\n static tree is_ivar (tree, tree);\n-static int is_private (tree);\n-static tree get_super_receiver (void);\n \n static void build_objc_exception_stuff (void);\n static void build_next_objc_exception_stuff (void);\n \n-static tree build_ivar_template (void);\n-static tree build_method_template (void);\n-static void build_private_template (tree);\n static void build_class_template (void);\n static void build_selector_template (void);\n static void build_category_template (void);\n-static tree lookup_method_in_hash_lists (tree, int);\n static void build_super_template (void);\n-static tree build_category_initializer (tree, tree, tree, tree, tree, tree);\n static tree build_protocol_initializer (tree, tree, tree, tree, tree);\n-static void synth_forward_declarations (void);\n-static int ivar_list_length (tree);\n static tree get_class_ivars (tree);\n-static void generate_ivar_lists (void);\n-static void generate_dispatch_tables (void);\n-static void generate_shared_structures (void);\n static tree generate_protocol_list (tree);\n static void build_protocol_reference (tree);\n \n-static tree build_keyword_selector (tree);\n-static const char *synth_id_with_class_suffix (const char *, tree);\n+#ifdef OBJCPLUS\n+static void objc_generate_cxx_cdtors (void);\n+#endif\n \n-static void generate_static_references (void);\n-static int check_methods_accessible (tree, tree, int);\n-static void encode_aggregate_within (tree, int, int, int, int);\n-static const char *objc_demangle (const char *);\n+static const char *synth_id_with_class_suffix (const char *, tree);\n \n /* Hash tables to manage the global pool of method prototypes.  */\n \n hash *nst_method_hash_list = 0;\n hash *cls_method_hash_list = 0;\n \n-static size_t hash_func (tree);\n-static void hash_init (void);\n-static void hash_enter (hash *, tree);\n static hash hash_lookup (hash *, tree);\n-static void hash_add_attr (hash, tree);\n static tree lookup_method (tree, tree);\n static tree lookup_method_static (tree, tree, int);\n-static void add_method_to_hash_list (hash *, tree);\n-static tree add_class (tree);\n-static void add_category (tree, tree);\n-static inline tree lookup_category (tree, tree);\n \n enum string_section\n {\n@@ -227,26 +201,17 @@ enum string_section\n };\n \n static tree add_objc_string (tree, enum string_section);\n-static tree get_objc_string_decl (tree, enum string_section);\n static tree build_objc_string_decl (enum string_section);\n-static tree build_selector_reference_decl (void);\n static void build_selector_table_decl (void);\n \n /* Protocol additions.  */\n \n-static tree add_protocol (tree);\n static tree lookup_protocol (tree);\n-static void check_protocol_recursively (tree, tree);\n static tree lookup_and_install_protocols (tree);\n \n /* Type encoding.  */\n \n static void encode_type_qualifiers (tree);\n-static void encode_pointer (tree, int, int);\n-static void encode_array (tree, int, int);\n-static void encode_aggregate (tree, int, int);\n-static void encode_next_bitfield (int);\n-static void encode_gnu_bitfield (int, tree, int);\n static void encode_type (tree, int, int);\n static void encode_field_decl (tree, int, int);\n \n@@ -255,76 +220,28 @@ static void really_start_method (tree, tree);\n #else\n static void really_start_method (tree, struct c_arg_info *);\n #endif\n-static int objc_types_are_equivalent (tree, tree);\n-static int comp_proto_with_proto (tree, tree);\n-static tree get_arg_type_list (tree, int, int);\n+static int comp_proto_with_proto (tree, tree, int);\n static void objc_push_parm (tree);\n #ifdef OBJCPLUS\n static tree objc_get_parm_info (int);\n #else\n static struct c_arg_info *objc_get_parm_info (int);\n #endif\n-static void synth_self_and_ucmd_args (void);\n \n /* Utilities for debugging and error diagnostics.  */\n \n static void warn_with_method (const char *, int, tree);\n-static void error_with_ivar (const char *, tree);\n static char *gen_type_name (tree);\n static char *gen_type_name_0 (tree);\n static char *gen_method_decl (tree);\n static char *gen_declaration (tree);\n-static void dump_interface (FILE *, tree);\n \n /* Everything else.  */\n \n-static tree lookup_method_in_protocol_list (tree, tree, int);\n-static tree lookup_protocol_in_reflist (tree, tree);\n-static tree start_var_decl (tree, const char *);\n-static void finish_var_decl (tree, tree);\n static tree create_field_decl (tree, const char *);\n-static tree setup_string_decl (void);\n-static int check_string_class_template (void);\n-static tree my_build_string (int, const char *);\n-static void build_objc_symtab_template (void);\n-static tree init_def_list (tree);\n-static tree init_objc_symtab (tree);\n-static tree build_metadata_decl (const char *, tree);\n-static void forward_declare_categories (void);\n-static void generate_objc_symtab_decl (void);\n-static tree build_selector (tree);\n-static tree build_typed_selector_reference (tree, tree);\n-static tree build_selector_reference (tree);\n-static tree build_class_reference_decl (void);\n static void add_class_reference (tree);\n static void build_protocol_template (void);\n-static tree build_descriptor_table_initializer (tree, tree);\n-static tree build_method_prototype_list_template (tree, int);\n-static tree build_method_prototype_template (void);\n-static tree objc_method_parm_type (tree);\n-static int objc_encoded_type_size (tree);\n static tree encode_method_prototype (tree);\n-static tree generate_descriptor_table (tree, const char *, int, tree, tree);\n-static void generate_method_descriptors (tree);\n-static void generate_protocol_references (tree);\n-static void generate_protocols (void);\n-static void check_ivars (tree, tree);\n-static tree build_ivar_list_template (tree, int);\n-static tree build_method_list_template (tree, int);\n-static tree build_ivar_list_initializer (tree, tree);\n-static tree generate_ivars_list (tree, const char *, int, tree);\n-static tree build_dispatch_table_initializer (tree, tree);\n-static tree generate_dispatch_table (tree, const char *, int, tree);\n-static tree build_shared_structure_initializer (tree, tree, tree, tree,\n-\t\t\t\t\t\ttree, int, tree, tree, tree);\n-static void generate_category (tree);\n-static tree adjust_type_for_id_default (tree);\n-static tree check_duplicates (hash, int, int);\n-static tree receiver_is_class_object (tree, int, int);\n-static int check_methods (tree, tree, int);\n-static int conforms_to_protocol (tree, tree);\n-static void check_protocol (tree, const char *, const char *);\n-static void check_protocols (tree, const char *, const char *);\n static void generate_classref_translation_entry (tree);\n static void handle_class_ref (tree);\n static void generate_struct_by_value_array (void)\n@@ -378,6 +295,7 @@ static const char *default_constant_string_class_name;\n /* Runtime metadata flags.  */\n #define CLS_FACTORY\t\t\t0x0001L\n #define CLS_META\t\t\t0x0002L\n+#define CLS_HAS_CXX_STRUCTORS\t\t0x2000L\n \n #define OBJC_MODIFIER_STATIC\t\t0x00000001\n #define OBJC_MODIFIER_FINAL\t\t0x00000002\n@@ -405,11 +323,28 @@ static const char *default_constant_string_class_name;\n #define TAG_SETJMP\t\t\t\"_setjmp\"\n #define UTAG_EXCDATA\t\t\t\"_objc_exception_data\"\n \n+#define TAG_ASSIGNIVAR\t\t\t\"objc_assign_ivar\"\n+#define TAG_ASSIGNGLOBAL\t\t\"objc_assign_global\"\n+#define TAG_ASSIGNSTRONGCAST\t\t\"objc_assign_strongCast\"\n+\n+/* Branch entry points.  All that matters here are the addresses;\n+   functions with these names do not really exist in libobjc.  */\n+\n+#define TAG_MSGSEND_FAST\t\t\"objc_msgSend_Fast\"\n+#define TAG_ASSIGNIVAR_FAST\t\t\"objc_assign_ivar_Fast\"\n+\n+#define TAG_CXX_CONSTRUCT\t\t\".cxx_construct\"\n+#define TAG_CXX_DESTRUCT\t\t\".cxx_destruct\"\n+\n /* GNU-specific tags.  */\n \n #define TAG_EXECCLASS\t\t\t\"__objc_exec_class\"\n #define TAG_GNUINIT\t\t\t\"__objc_gnu_init\"\n \n+/* Flags for lookup_method_static().  */\n+#define OBJC_LOOKUP_CLASS\t1\t/* Look for class methods.  */\n+#define OBJC_LOOKUP_NO_SUPER\t2\t/* Do not examine superclasses.  */\n+\n /* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n \n@@ -453,9 +388,6 @@ struct string_descriptor GTY(())\n \n static GTY((param_is (struct string_descriptor))) htab_t string_htab;\n \n-static hashval_t string_hash (const void *);\n-static int string_eq (const void *, const void *);\n-\n FILE *gen_declaration_file;\n \n /* Tells \"encode_pointer/encode_aggregate\" whether we are generating\n@@ -596,8 +528,8 @@ objc_finish_file (void)\n #endif\n \n   /* Finalize Objective-C runtime data.  No need to generate tables\n-     and code if only checking syntax.  */\n-  if (!flag_syntax_only)\n+     and code if only checking syntax, or if generating a PCH file.  */\n+  if (!flag_syntax_only && !pch_file)\n     finish_objc ();\n \n   if (gen_declaration_file)\n@@ -746,6 +678,11 @@ objc_continue_implementation (void)\n void\n objc_finish_implementation (void)\n {\n+#ifdef OBJCPLUS\n+  if (flag_objc_call_cxx_cdtors)\n+    objc_generate_cxx_cdtors ();\n+#endif\n+\n   if (objc_implementation_context)\n     {\n       finish_class (objc_implementation_context);\n@@ -1441,6 +1378,17 @@ synth_module_prologue (void)\n   objc_super_type = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\t\t  get_identifier (TAG_SUPER)));\n \n+  /* Declare pointers to method and ivar lists.  */\n+  objc_method_list_ptr = build_pointer_type\n+\t\t\t (xref_tag (RECORD_TYPE,\n+\t\t\t\t    get_identifier (UTAG_METHOD_LIST)));\n+  objc_method_proto_list_ptr\n+    = build_pointer_type (xref_tag (RECORD_TYPE,\n+\t\t\t\t    get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n+  objc_ivar_list_ptr = build_pointer_type\n+\t\t       (xref_tag (RECORD_TYPE,\n+\t\t\t\t  get_identifier (UTAG_IVAR_LIST)));\n+\n   if (flag_next_runtime)\n     {\n       /* NB: In order to call one of the ..._stret (struct-returning)\n@@ -1470,6 +1418,21 @@ synth_module_prologue (void)\n \t\t\t\t\t\t type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t NULL, NULL_TREE);\n \n+      /* id objc_msgSend_Fast (id, SEL, ...)\n+\t   __attribute__ ((hard_coded_address (OFFS_MSGSEND_FAST))); */\n+#ifdef OFFS_MSGSEND_FAST\n+      umsg_fast_decl = builtin_function (TAG_MSGSEND_FAST,\n+\t\t\t\t\t type, 0, NOT_BUILT_IN,\n+\t\t\t\t\t NULL, NULL_TREE);\n+      DECL_ATTRIBUTES (umsg_fast_decl) \n+\t= tree_cons (get_identifier (\"hard_coded_address\"), \n+\t\t     build_int_cst (NULL_TREE, OFFS_MSGSEND_FAST),\n+\t\t     NULL_TREE);\n+#else\n+      /* No direct dispatch availible.  */\n+      umsg_fast_decl = umsg_decl;\n+#endif\n+\n       /* id objc_msgSendSuper (struct objc_super *, SEL, ...); */\n       /* id objc_msgSendSuper_stret (struct objc_super *, SEL, ...); */\n       type\n@@ -2550,17 +2513,24 @@ tree\n objc_get_class_reference (tree ident)\n {\n   tree orig_ident;\n+  bool local_scope = false;\n \n #ifdef OBJCPLUS\n   if (processing_template_decl)\n     /* Must wait until template instantiation time.  */\n     return build_min_nt (CLASS_REFERENCE_EXPR, ident);\n   if (TREE_CODE (ident) == TYPE_DECL)\n-    ident = DECL_NAME (ident);\n+    {\n+      /* The type must exist in the global namespace.  */\n+      if (DECL_CONTEXT (ident) && DECL_CONTEXT (ident) != global_namespace)\n+\tlocal_scope = true;\n+\n+      ident = DECL_NAME (ident);\n+    }\n #endif\n   orig_ident = ident;\n \n-  if (!(ident = objc_is_class_name (ident)))\n+  if (local_scope || !(ident = objc_is_class_name (ident)))\n     {\n       error (\"%qs is not an Objective-C class name or alias\",\n \t     IDENTIFIER_POINTER (orig_ident));\n@@ -2808,21 +2778,320 @@ objc_is_object_ptr (tree type)\n   return ret;\n }\n \n+static int\n+objc_is_gcable_type (tree type, int or_strong_p)\n+{\n+  tree name; \n+\n+  if (!TYPE_P (type))\n+    return 0;\n+  if (objc_is_id (TYPE_MAIN_VARIANT (type)))\n+    return 1;\n+  if (or_strong_p && lookup_attribute (\"objc_gc\", TYPE_ATTRIBUTES (type)))\n+    return 1;\n+  if (TREE_CODE (type) != POINTER_TYPE && TREE_CODE (type) != INDIRECT_REF)\n+    return 0;\n+  type = TREE_TYPE (type);\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return 0;\n+  name = TYPE_NAME (type);\n+  return (objc_is_class_name (name) != NULL_TREE);\n+}\n+\n static tree\n-lookup_interface (tree ident)\n+objc_substitute_decl (tree expr, tree oldexpr, tree newexpr)\n+{\n+  if (expr == oldexpr)\n+    return newexpr;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+      return build_component_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\t\toldexpr,\n+\t\t\t\t\t\t\tnewexpr),\n+\t\t\t\t  DECL_NAME (TREE_OPERAND (expr, 1)));\n+    case ARRAY_REF:\n+      return build_array_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\t    oldexpr,\n+\t\t\t\t\t\t    newexpr),\n+\t\t\t      TREE_OPERAND (expr, 1));\n+    case INDIRECT_REF:\n+      return build_indirect_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+\t\t\t\t\t\t       oldexpr,\n+\t\t\t\t\t\t       newexpr), \"->\");\n+    default:\n+      return expr;\n+    }\n+}\n+\n+static tree\n+objc_build_ivar_assignment (tree outervar, tree lhs, tree rhs)\n {\n-  tree chain;\n+  tree func_params;\n+  /* The LHS parameter contains the expression 'outervar->memberspec';\n+     we need to transform it into '&((typeof(outervar) *) 0)->memberspec',\n+     where memberspec may be arbitrarily complex (e.g., 'g->f.d[2].g[3]').\n+  */\n+  tree offs\n+    = objc_substitute_decl\n+      (lhs, outervar, convert (TREE_TYPE (outervar), integer_zero_node));\n+  tree func\n+    = (flag_objc_direct_dispatch\n+       ? objc_assign_ivar_fast_decl\n+       : objc_assign_ivar_decl);\n+\n+  offs = convert (integer_type_node, build_unary_op (ADDR_EXPR, offs, 0));\n+  offs = fold (offs);\n+  func_params = tree_cons (NULL_TREE, \n+\tconvert (objc_object_type, rhs),\n+\t    tree_cons (NULL_TREE, convert (objc_object_type, outervar),\n+\t\ttree_cons (NULL_TREE, offs,\n+\t\t    NULL_TREE)));\n+\n+  assemble_external (func);\n+  return build_function_call (func, func_params);\n+}\n+\n+static tree\n+objc_build_global_assignment (tree lhs, tree rhs)\n+{\n+  tree func_params = tree_cons (NULL_TREE,\n+\tconvert (objc_object_type, rhs),\n+\t    tree_cons (NULL_TREE, convert (build_pointer_type (objc_object_type),\n+\t\t      build_unary_op (ADDR_EXPR, lhs, 0)),\n+\t\t    NULL_TREE));\n+\n+  assemble_external (objc_assign_global_decl);\n+  return build_function_call (objc_assign_global_decl, func_params);\n+}\n+\n+static tree\n+objc_build_strong_cast_assignment (tree lhs, tree rhs)\n+{\n+  tree func_params = tree_cons (NULL_TREE,\n+\tconvert (objc_object_type, rhs),\n+\t    tree_cons (NULL_TREE, convert (build_pointer_type (objc_object_type),\n+\t\t      build_unary_op (ADDR_EXPR, lhs, 0)), \n+\t\t    NULL_TREE));\n+\n+  assemble_external (objc_assign_strong_cast_decl);\n+  return build_function_call (objc_assign_strong_cast_decl, func_params);\n+}\n+\n+static int\n+objc_is_gcable_p (tree expr)\n+{\n+  return (TREE_CODE (expr) == COMPONENT_REF\n+\t  ? objc_is_gcable_p (TREE_OPERAND (expr, 1))\n+\t  : TREE_CODE (expr) == ARRAY_REF\n+\t  ? (objc_is_gcable_p (TREE_TYPE (expr))\n+\t     || objc_is_gcable_p (TREE_OPERAND (expr, 0)))\n+\t  : TREE_CODE (expr) == ARRAY_TYPE\n+\t  ? objc_is_gcable_p (TREE_TYPE (expr))\n+\t  : TYPE_P (expr)\n+\t  ? objc_is_gcable_type (expr, 1)\n+\t  : (objc_is_gcable_p (TREE_TYPE (expr))\n+\t     || (DECL_P (expr)\n+\t\t && lookup_attribute (\"objc_gc\", DECL_ATTRIBUTES (expr)))));\n+}\n+\n+static int\n+objc_is_ivar_reference_p (tree expr)\n+{\n+  return (TREE_CODE (expr) == ARRAY_REF\n+\t  ? objc_is_ivar_reference_p (TREE_OPERAND (expr, 0))\n+\t  : TREE_CODE (expr) == COMPONENT_REF\n+\t  ? TREE_CODE (TREE_OPERAND (expr, 1)) == FIELD_DECL\n+\t  : 0);\n+}\n+\n+static int\n+objc_is_global_reference_p (tree expr)\n+{\n+  return (TREE_CODE (expr) == INDIRECT_REF || TREE_CODE (expr) == PLUS_EXPR\n+\t  ? objc_is_global_reference_p (TREE_OPERAND (expr, 0))\n+\t  : DECL_P (expr)\n+\t  ? (!DECL_CONTEXT (expr) || TREE_STATIC (expr))\n+\t  : 0);\n+}\n \n+tree\n+objc_generate_write_barrier (tree lhs, enum tree_code modifycode, tree rhs)\n+{\n+  tree result = NULL_TREE, outer;\n+  int strong_cast_p = 0, outer_gc_p = 0, indirect_p = 0;\n+\n+  /* See if we have any lhs casts, and strip them out.  NB: The lvalue casts\n+     will have been transformed to the form '*(type *)&expr'.  */\n+  if (TREE_CODE (lhs) == INDIRECT_REF)\n+    {\n+      outer = TREE_OPERAND (lhs, 0);\n+\n+      while (!strong_cast_p\n+\t     && (TREE_CODE (outer) == CONVERT_EXPR\n+\t\t || TREE_CODE (outer) == NOP_EXPR\n+\t\t || TREE_CODE (outer) == NON_LVALUE_EXPR))\n+\t{\n+\t  tree lhstype = TREE_TYPE (outer);\n+\n+\t  /* Descend down the cast chain, and record the first objc_gc\n+\t     attribute found.  */\n+\t  if (POINTER_TYPE_P (lhstype))\n+\t    {\n+\t      tree attr\n+\t\t= lookup_attribute (\"objc_gc\",\n+\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (lhstype)));\n+\n+\t      if (attr)\n+\t\tstrong_cast_p = 1;\n+\t    }\n+\n+\t  outer = TREE_OPERAND (outer, 0);\n+\t}\n+    }\n+\n+  /* If we have a __strong cast, it trumps all else.  */\n+  if (strong_cast_p)\n+    {\n+      if (modifycode != NOP_EXPR)\n+        goto invalid_pointer_arithmetic;\n+\n+      if (warn_assign_intercept)\n+\twarning (0, \"strong-cast assignment has been intercepted\");\n+\n+      result = objc_build_strong_cast_assignment (lhs, rhs);\n+\n+      goto exit_point;\n+    }\n+\n+  /* the lhs must be of a suitable type, regardless of its underlying\n+     structure.  */\n+  if (!objc_is_gcable_p (lhs))\n+    goto exit_point;\n+\n+  outer = lhs;\n+\n+  while (outer\n+\t && (TREE_CODE (outer) == COMPONENT_REF\n+\t     || TREE_CODE (outer) == ARRAY_REF))\n+    outer = TREE_OPERAND (outer, 0);\n+\n+  if (TREE_CODE (outer) == INDIRECT_REF)\n+    {\n+      outer = TREE_OPERAND (outer, 0);\n+      indirect_p = 1;\n+    }\n+\n+  outer_gc_p = objc_is_gcable_p (outer);\n+  \n+  /* Handle ivar assignments. */\n+  if (objc_is_ivar_reference_p (lhs))\n+    {\n+      /* if the struct to the left of the ivar is not an Objective-C object (__strong\n+\t doesn't cut it here), the best we can do here is suggest a cast.  */\n+      if (!objc_is_gcable_type (TREE_TYPE (outer), 0))\n+\t{\n+\t  /* We may still be able to use the global write barrier... */\n+\t  if (!indirect_p && objc_is_global_reference_p (outer))\n+\t    goto global_reference;\n+\n+\t suggest_cast:\n+\t  if (modifycode == NOP_EXPR)\n+\t    {\n+\t      if (warn_assign_intercept)\n+\t\twarning (0, \"strong-cast may possibly be needed\");\n+\t    }\n+\n+\t  goto exit_point;\n+\t}\n+\n+      if (modifycode != NOP_EXPR)\n+        goto invalid_pointer_arithmetic;\n+\n+      if (warn_assign_intercept)\n+\twarning (0, \"instance variable assignment has been intercepted\");\n+\n+      result = objc_build_ivar_assignment (outer, lhs, rhs);\n+\n+      goto exit_point;\n+    }\n+\n+  /* Likewise, intercept assignment to global/static variables if their type is\n+     GC-marked.  */    \n+  if (objc_is_global_reference_p (outer))\n+    {\n+      if (indirect_p)\n+\tgoto suggest_cast;\n+\n+     global_reference:\n+      if (modifycode != NOP_EXPR)\n+\t{\n+\t invalid_pointer_arithmetic:\n+\t  if (outer_gc_p)\n+\t    warning (0, \"pointer arithmetic for garbage-collected objects not allowed\");\n+\n+\t  goto exit_point;\n+\t}\n+\n+      if (warn_assign_intercept)\n+\twarning (0, \"global/static variable assignment has been intercepted\");\n+\n+      result = objc_build_global_assignment (lhs, rhs);\n+    }\n+\n+  /* In all other cases, fall back to the normal mechanism.  */\n+ exit_point:\n+  return result;\n+}\n+\n+static GTY ((param_is (union tree_node))) htab_t interface_htab;\n+\n+struct interface_tuple {\n+  tree id;\n+  tree class_name;\n+};\n+\n+static hashval_t\n+hash_interface (const void *p)\n+{\n+  const struct interface_tuple *d = p;\n+  return htab_hash_pointer (d->id);\n+}\n+\n+static int\n+eq_interface (const void *p1, const void *p2)\n+{\n+  const struct interface_tuple *d = p1;\n+  return d->id == p2;\n+}\n+\n+static tree\n+lookup_interface (tree ident)\n+{\n #ifdef OBJCPLUS\n   if (ident && TREE_CODE (ident) == TYPE_DECL)\n     ident = DECL_NAME (ident);\n #endif\n-  for (chain = interface_chain; chain; chain = TREE_CHAIN (chain))\n-    {\n-      if (ident == CLASS_NAME (chain))\n-      return chain;\n-    }\n-  return NULL_TREE;\n+\n+  if (ident == NULL_TREE || TREE_CODE (ident) != IDENTIFIER_NODE)\n+    return NULL_TREE;\n+\n+  {\n+    struct interface_tuple **slot;\n+    tree i = NULL_TREE;\n+\n+    if (interface_htab)\n+      {\n+\tslot = (struct interface_tuple **)\n+\t  htab_find_slot_with_hash (interface_htab, ident,\n+\t\t\t\t    htab_hash_pointer (ident),\n+\t\t\t\t    NO_INSERT);\n+\tif (slot && *slot)\n+\t  i = (*slot)->class_name;\n+      }\n+    return i;\n+  }\n }\n \n /* Implement @defs (<classname>) within struct bodies.  */\n@@ -3016,7 +3285,15 @@ next_sjlj_build_enter_and_setjmp (void)\n   t = build_component_ref (cur_try_context->stack_decl,\n \t\t\t   get_identifier (\"buf\"));\n   t = build_fold_addr_expr (t);\n+#ifdef OBJCPLUS\n+  /* Convert _setjmp argument to type that is expected.  */\n+  if (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl)))\n+    t = convert (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (objc_setjmp_decl))), t);\n+  else\n+    t = convert (ptr_type_node, t);\n+#else\n   t = convert (ptr_type_node, t);\n+#endif\n   t = tree_cons (NULL, t, NULL);\n   sj = build_function_call (objc_setjmp_decl, t);\n \n@@ -3243,6 +3520,9 @@ objc_begin_try_stmt (location_t try_locus, tree body)\n   cur_try_context = c;\n \n   objc_init_exceptions ();\n+\n+  if (flag_objc_sjlj_exceptions)\n+    objc_mark_locals_volatile (NULL);\n }\n \n /* Called just after parsing \"@catch (parm)\".  Open a binding level, \n@@ -3338,7 +3618,7 @@ objc_build_finally_clause (location_t finally_locus, tree body)\n \n /* Called to finalize a @try construct.  */\n \n-void\n+tree\n objc_finish_try_stmt (void)\n {\n   struct objc_try_context *c = cur_try_context;\n@@ -3376,6 +3656,7 @@ objc_finish_try_stmt (void)\n \n   cur_try_context = c->outer;\n   free (c);\n+  return stmt;\n }\n \n tree\n@@ -3407,7 +3688,7 @@ objc_build_throw_stmt (tree throw_expr)\n   return add_stmt (build_function_call (objc_exception_throw_decl, args));\n }\n \n-void\n+tree\n objc_build_synchronized (location_t start_locus, tree mutex, tree body)\n {\n   tree args, call;\n@@ -3427,7 +3708,7 @@ objc_build_synchronized (location_t start_locus, tree mutex, tree body)\n   /* Put the that and the body in a TRY_FINALLY.  */\n   objc_begin_try_stmt (start_locus, body);\n   objc_build_finally_clause (input_location, call);\n-  objc_finish_try_stmt ();\n+  return objc_finish_try_stmt ();\n }\n \n \f\n@@ -3509,6 +3790,44 @@ build_next_objc_exception_stuff (void)\n \t\t\t\t\t\t OBJC_VOID_AT_END)));\n   objc_exception_match_decl\n     = builtin_function (TAG_EXCEPTIONMATCH, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n+\n+  /* id objc_assign_ivar (id, id, unsigned int); */\n+  /* id objc_assign_ivar_Fast (id, id, unsigned int)\n+       __attribute__ ((hard_coded_address (OFFS_ASSIGNIVAR_FAST))); */\n+  temp_type\n+    = build_function_type (objc_object_type,\n+\t\t\t   tree_cons\n+\t\t\t   (NULL_TREE, objc_object_type,\n+\t\t\t    tree_cons (NULL_TREE, objc_object_type,\n+\t\t\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t\t\t  unsigned_type_node,\n+\t\t\t\t\t\t  OBJC_VOID_AT_END))));\n+  objc_assign_ivar_decl\n+    = builtin_function (TAG_ASSIGNIVAR, temp_type, 0, NOT_BUILT_IN,\n+\t\t\tNULL, NULL_TREE);\n+#ifdef OFFS_ASSIGNIVAR_FAST\n+  objc_assign_ivar_fast_decl\n+    = builtin_function (TAG_ASSIGNIVAR_FAST, temp_type, 0,\n+\t\t\tNOT_BUILT_IN, NULL, NULL_TREE);\n+  DECL_ATTRIBUTES (objc_assign_ivar_fast_decl) \n+    = tree_cons (get_identifier (\"hard_coded_address\"), \n+\t\t build_int_cst (NULL_TREE, OFFS_ASSIGNIVAR_FAST),\n+\t\t NULL_TREE);\n+#else\n+  /* Default to slower ivar method.  */\n+  objc_assign_ivar_fast_decl = objc_assign_ivar_decl;\n+#endif\n+\n+  /* id objc_assign_global (id, id *); */\n+  /* id objc_assign_strongCast (id, id *); */\n+  temp_type = build_function_type (objc_object_type,\n+\t\ttree_cons (NULL_TREE, objc_object_type,\n+\t\t    tree_cons (NULL_TREE, build_pointer_type (objc_object_type),\n+\t\t\tOBJC_VOID_AT_END)));\n+  objc_assign_global_decl\n+\t= builtin_function (TAG_ASSIGNGLOBAL, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n+  objc_assign_strong_cast_decl\n+\t= builtin_function (TAG_ASSIGNSTRONGCAST, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n }\n \n static void\n@@ -3556,6 +3875,11 @@ build_private_template (tree class)\n       INIT_TYPE_OBJC_INFO (record);\n       TYPE_OBJC_INTERFACE (record) = class;\n       CLASS_STATIC_TEMPLATE (class) = record;\n+\n+      /* Set the TREE_USED bit for this struct, so that stab generator\n+\t can emit stabs for this struct type.  */\n+      if (flag_debug_only_used_symbols && TYPE_STUB_DECL (record))\n+\tTREE_USED (TYPE_STUB_DECL (record)) = 1;\n     }\n }\n \f\n@@ -3595,19 +3919,13 @@ build_protocol_template (void)\n \t\t\t\t  \"protocol_list\");\n   chainon (field_decl_chain, field_decl);\n \n-  /* struct objc_method_list *instance_methods; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_PROTOTYPE_LIST))),\n+  /* struct _objc__method_prototype_list *instance_methods; */\n+  field_decl = create_field_decl (objc_method_proto_list_ptr,\n \t\t\t\t  \"instance_methods\");\n   chainon (field_decl_chain, field_decl);\n \n-  /* struct objc_method_list *class_methods; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_PROTOTYPE_LIST))),\n+  /* struct _objc__method_prototype_list *class_methods; */\n+  field_decl = create_field_decl (objc_method_proto_list_ptr,\n \t\t\t\t  \"class_methods\");\n   chainon (field_decl_chain, field_decl);\n \n@@ -3708,7 +4026,7 @@ objc_method_parm_type (tree type)\n   type = TREE_VALUE (TREE_TYPE (type));\n   if (TREE_CODE (type) == TYPE_DECL)\n     type = TREE_TYPE (type);\n-  return TYPE_MAIN_VARIANT (type);\n+  return type;\n }\n \n static int\n@@ -3886,6 +4204,136 @@ generate_protocol_references (tree plist)\n     }\n }\n \n+/* Generate either '- .cxx_construct' or '- .cxx_destruct' for the\n+   current class.  */\n+#ifdef OBJCPLUS\n+static void\n+objc_generate_cxx_ctor_or_dtor (bool dtor)\n+{\n+  tree fn, body, compound_stmt, ivar;\n+\n+  /* - (id) .cxx_construct { ... return self; } */\n+  /* - (void) .cxx_construct { ... }            */\n+\n+  objc_set_method_type (MINUS_EXPR);\n+  objc_start_method_definition\n+   (objc_build_method_signature (build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t  dtor\n+\t\t\t\t\t\t  ? void_type_node\n+\t\t\t\t\t\t  : objc_object_type),\n+\t\t\t\t get_identifier (dtor\n+\t\t\t\t\t\t ? TAG_CXX_DESTRUCT\n+\t\t\t\t\t\t : TAG_CXX_CONSTRUCT),\n+\t\t\t\t make_node (TREE_LIST),\n+\t\t\t\t false));\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  ivar = CLASS_IVARS (implementation_template);\n+  /* Destroy ivars in reverse order.  */\n+  if (dtor)\n+    ivar = nreverse (copy_list (ivar));\n+\n+  for (; ivar; ivar = TREE_CHAIN (ivar))\n+    {\n+      if (TREE_CODE (ivar) == FIELD_DECL)\n+\t{\n+\t  tree type = TREE_TYPE (ivar);\n+\n+\t  /* Call the ivar's default constructor or destructor.  Do not\n+\t     call the destructor unless a corresponding constructor call\n+\t     has also been made (or is not needed).  */\n+\t  if (IS_AGGR_TYPE (type)\n+\t      && (dtor\n+\t\t  ? (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+\t\t     && (!TYPE_NEEDS_CONSTRUCTING (type)\n+\t\t\t || TYPE_HAS_DEFAULT_CONSTRUCTOR (type)))\n+\t\t  : (TYPE_NEEDS_CONSTRUCTING (type)\n+\t\t     && TYPE_HAS_DEFAULT_CONSTRUCTOR (type))))\n+\t    finish_expr_stmt\n+\t     (build_special_member_call\n+\t      (build_ivar_reference (DECL_NAME (ivar)),\n+\t       dtor ? complete_dtor_identifier : complete_ctor_identifier,\n+\t       NULL_TREE, type, LOOKUP_NORMAL));\n+\t}\n+    }\n+\n+  /* The constructor returns 'self'.  */\n+  if (!dtor)\n+    finish_return_stmt (self_decl);\n+\n+  finish_compound_stmt (compound_stmt);\n+  finish_function_body (body);\n+  fn = current_function_decl;\n+  finish_function ();\n+  objc_finish_method_definition (fn);\n+}\n+\n+/* The following routine will examine the current @interface for any\n+   non-POD C++ ivars requiring non-trivial construction and/or\n+   destruction, and then synthesize special '- .cxx_construct' and/or\n+   '- .cxx_destruct' methods which will run the appropriate\n+   construction or destruction code.  Note that ivars inherited from\n+   super-classes are _not_ considered.  */\n+static void\n+objc_generate_cxx_cdtors (void)\n+{\n+  bool need_ctor = false, need_dtor = false;\n+  tree ivar;\n+\n+  /* We do not want to do this for categories, since they do not have\n+     their own ivars.  */\n+\n+  if (TREE_CODE (objc_implementation_context) != CLASS_IMPLEMENTATION_TYPE)\n+    return;\n+\n+  /* First, determine if we even need a constructor and/or destructor.  */\n+\n+  for (ivar = CLASS_IVARS (implementation_template); ivar;\n+       ivar = TREE_CHAIN (ivar))\n+    {\n+      if (TREE_CODE (ivar) == FIELD_DECL)\n+\t{\n+\t  tree type = TREE_TYPE (ivar);\n+\n+\t  if (IS_AGGR_TYPE (type))\n+\t    {\n+\t      if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t\t  && TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+\t\t/* NB: If a default constructor is not available, we will not\n+\t\t   be able to initialize this ivar; the add_instance_variable()\n+\t\t   routine will already have warned about this.  */\n+\t\tneed_ctor = true;\n+\n+\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+\t\t  && (!TYPE_NEEDS_CONSTRUCTING (type)\n+\t\t      || TYPE_HAS_DEFAULT_CONSTRUCTOR (type)))\n+\t\t/* NB: If a default constructor is not available, we will not\n+\t\t   call the destructor either, for symmetry.  */\n+\t\tneed_dtor = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* Generate '- .cxx_construct' if needed.  */\n+\n+  if (need_ctor)\n+    objc_generate_cxx_ctor_or_dtor (false);\n+\n+  /* Generate '- .cxx_destruct' if needed.  */\n+\n+  if (need_dtor)\n+    objc_generate_cxx_ctor_or_dtor (true);\n+\n+  /* The 'imp_list' variable points at an imp_entry record for the current\n+     @implementation.  Record the existence of '- .cxx_construct' and/or\n+     '- .cxx_destruct' methods therein; it will be included in the\n+     metadata for the class.  */\n+  if (flag_next_runtime)\n+    imp_list->has_cxx_cdtors = (need_ctor || need_dtor);\n+}\n+#endif\n+\n /* For each protocol which was referenced either from a @protocol()\n    expression, or because a class/category implements it (then a\n    pointer to the protocol is stored in the struct describing the\n@@ -4019,15 +4467,17 @@ build_protocol_initializer (tree type, tree protocol_name,\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, instance_methods, 0);\n+      expr = convert (objc_method_proto_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, instance_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n   if (!class_methods)\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, class_methods, 0);\n+      expr = convert (objc_method_proto_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, class_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -4059,18 +4509,12 @@ build_category_template (void)\n   chainon (field_decl_chain, field_decl);\n \n   /* struct _objc_method_list *instance_methods; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_LIST))),\n+  field_decl = create_field_decl (objc_method_list_ptr,\n \t\t\t\t  \"instance_methods\");\n   chainon (field_decl_chain, field_decl);\n \n   /* struct _objc_method_list *class_methods; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_LIST))),\n+  field_decl = create_field_decl (objc_method_list_ptr,\n \t\t\t\t  \"class_methods\");\n   chainon (field_decl_chain, field_decl);\n \n@@ -4172,18 +4616,12 @@ build_class_template (void)\n   chainon (field_decl_chain, field_decl);\n \n   /* struct _objc_ivar_list *ivars; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_IVAR_LIST))),\n+  field_decl = create_field_decl (objc_ivar_list_ptr,\n \t\t\t\t  \"ivars\");\n   chainon (field_decl_chain, field_decl);\n \n   /* struct _objc_method_list *methods; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_LIST))),\n+  field_decl = create_field_decl (objc_method_list_ptr,\n \t\t\t\t  \"methods\");\n   chainon (field_decl_chain, field_decl);\n \n@@ -4434,10 +4872,7 @@ build_method_list_template (tree list_type, int size)\n   objc_ivar_list_record = start_struct (RECORD_TYPE, NULL_TREE);\n \n   /* struct _objc__method_prototype_list *method_next; */\n-  field_decl = create_field_decl (build_pointer_type\n-\t\t\t\t  (xref_tag (RECORD_TYPE,\n-\t\t\t\t\t     get_identifier\n-\t\t\t\t\t     (UTAG_METHOD_PROTOTYPE_LIST))),\n+  field_decl = create_field_decl (objc_method_proto_list_ptr,\n \t\t\t\t  \"method_next\");\n   field_decl_chain = field_decl;\n \n@@ -4836,14 +5271,16 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, instance_methods, 0);\n+      expr = convert (objc_method_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, instance_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n   if (!class_methods)\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, class_methods, 0);\n+      expr = convert (objc_method_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, class_methods, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -4919,7 +5356,8 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, ivar_list, 0);\n+      expr = convert (objc_ivar_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, ivar_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -4928,7 +5366,8 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0), initlist);\n   else\n     {\n-      expr = build_unary_op (ADDR_EXPR, dispatch_table, 0);\n+      expr = convert (objc_method_list_ptr,\n+\t\t      build_unary_op (ADDR_EXPR, dispatch_table, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n@@ -5023,7 +5462,7 @@ generate_category (tree cat)\n    static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n \n static void\n-generate_shared_structures (void)\n+generate_shared_structures (int cls_flags)\n {\n   tree sc_spec, decl_specs, decl;\n   tree name_expr, super_expr, root_expr;\n@@ -5114,7 +5553,7 @@ generate_shared_structures (void)\n        convert (integer_type_node,\n \t\tTYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE\n \t\t\t\t(implementation_template))),\n-       1 /*CLS_FACTORY*/,\n+       1 /*CLS_FACTORY*/ | cls_flags,\n        UOBJC_INSTANCE_METHODS_decl,\n        UOBJC_INSTANCE_VARIABLES_decl,\n        protocol_decl);\n@@ -5377,6 +5816,20 @@ check_duplicates (hash hsh, int methods, int is_class)\n \t     different types.  */\n \t  attr loop;\n \n+\t  /* But just how different are those types?  If\n+\t     -Wno-strict-selector-match is specified, we shall not\n+\t     complain if the differences are solely among types with\n+\t     identical size and alignment.  */\n+\t  if (!warn_strict_selector_match)\n+\t    {\n+\t      for (loop = hsh->list; loop; loop = loop->next)\n+\t\tif (!comp_proto_with_proto (meth, loop->value, 0))\n+\t\t  goto issue_warning;\n+\n+\t      return meth;\n+\t    }\n+\n+\tissue_warning:\n \t  warning (0, \"multiple %s named %<%c%s%> found\",\n \t\t   methods ? \"methods\" : \"selectors\",\n \t\t   (is_class ? '+' : '-'),\n@@ -5587,6 +6040,10 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t       || (TREE_CODE (receiver) == COMPOUND_EXPR\n \t\t   && !IS_SUPER (rtype)));\n \n+  /* If we are calling [super dealloc], reset our warning flag.  */\n+  if (super && !strcmp (\"dealloc\", IDENTIFIER_POINTER (sel_name)))\n+    should_call_super_dealloc = 0;\n+\n   /* If the receiver is a class object, retrieve the corresponding\n      @interface, if one exists. */\n   class_tree = receiver_is_class_object (receiver, self, super);\n@@ -5615,18 +6072,13 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n   /* If receiver is of type `id' or `Class' (or if the @interface for a\n      class is not visible), we shall be satisfied with the existence of\n      any instance or class method. */\n-  if (!rtype || objc_is_id (rtype))\n+  if (objc_is_id (rtype))\n     {\n-      if (!rtype)\n-\trtype = xref_tag (RECORD_TYPE, class_tree);\n-      else\n-\t{\n-\t  class_tree = (IS_CLASS (rtype) ? objc_class_name : NULL_TREE);\n-\t  rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n-\t\t     ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n-\t\t     : NULL_TREE);\n-\t  rtype = NULL_TREE;\n-\t}\n+      class_tree = (IS_CLASS (rtype) ? objc_class_name : NULL_TREE);\n+      rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n+\t\t ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n+\t\t : NULL_TREE);\n+      rtype = NULL_TREE;\n \n       if (rprotos)\n \t{\n@@ -5651,7 +6103,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t    }\n \t}\n     }\n-  else\n+  else if (rtype)\n     {\n       tree orig_rtype = rtype, saved_rtype;\n \n@@ -5673,7 +6125,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t more intelligent about which methods the receiver will\n \t understand. */\n       if (!rtype || TREE_CODE (rtype) == IDENTIFIER_NODE)\n-\trtype = saved_rtype;\n+\trtype = NULL_TREE;\n       else if (TREE_CODE (rtype) == CLASS_INTERFACE_TYPE\n \t  || TREE_CODE (rtype) == CLASS_IMPLEMENTATION_TYPE)\n \t{\n@@ -5788,7 +6240,9 @@ build_objc_method_call (int super_flag, tree method_prototype,\n {\n   tree sender = (super_flag ? umsg_super_decl :\n \t\t (!flag_next_runtime || flag_nil_receivers\n-\t\t  ? umsg_decl\n+\t\t  ? (flag_objc_direct_dispatch\n+\t\t     ? umsg_fast_decl\n+\t\t     : umsg_decl)\n \t\t  : umsg_nonnil_decl));\n   tree rcv_p = (super_flag ? objc_super_type : objc_object_type);\n \n@@ -6125,11 +6579,23 @@ lookup_method (tree mchain, tree method)\n   return NULL_TREE;\n }\n \n+/* Look up a class (if OBJC_LOOKUP_CLASS is set in FLAGS) or instance method\n+   in INTERFACE, along with any categories and protocols attached thereto.\n+   If method is not found, and the OBJC_LOOKUP_NO_SUPER is _not_ set in FLAGS,\n+   recursively examine the INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is \n+   set, OBJC_LOOKUP_NO_SUPER is cleared, and no suitable class method could\n+   be found in INTERFACE or any of its superclasses, look for an _instance_\n+   method of the same name in the root class as a last resort.\n+\n+   If a suitable method cannot be found, return NULL_TREE.  */\n+   \n static tree\n-lookup_method_static (tree interface, tree ident, int is_class)\n+lookup_method_static (tree interface, tree ident, int flags)\n {\n   tree meth = NULL_TREE, root_inter = NULL_TREE;\n   tree inter = interface;\n+  int is_class = (flags & OBJC_LOOKUP_CLASS);\n+  int no_superclasses = (flags & OBJC_LOOKUP_NO_SUPER);\n \n   while (inter)\n     {\n@@ -6166,6 +6632,10 @@ lookup_method_static (tree interface, tree ident, int is_class)\n \t    return meth;\n \t}\n \n+      /* If we were instructed not to look in superclasses, don't.  */\n+      if (no_superclasses)\n+\treturn NULL_TREE;\n+\n       /* Failing that, climb up the inheritance hierarchy.  */\n       root_inter = inter;\n       inter = lookup_interface (CLASS_SUPER_NAME (inter));\n@@ -6195,9 +6665,9 @@ add_method_to_hash_list (hash *hash_list, tree method)\n     {\n       /* Check types against those; if different, add to a list.  */\n       attr loop;\n-      int already_there = comp_proto_with_proto (method, hsh->key);\n+      int already_there = comp_proto_with_proto (method, hsh->key, 1);\n       for (loop = hsh->list; !already_there && loop; loop = loop->next)\n-\talready_there |= comp_proto_with_proto (method, loop->value);\n+\talready_there |= comp_proto_with_proto (method, loop->value, 1);\n       if (!already_there)\n \thash_add_attr (hsh, method);\n     }\n@@ -6233,7 +6703,7 @@ objc_add_method (tree class, tree method, int is_class)\n \t definition errors).  */\n       if ((TREE_CODE (class) == CLASS_INTERFACE_TYPE\n \t   || TREE_CODE (class) == CATEGORY_INTERFACE_TYPE)\n-\t  && !comp_proto_with_proto (method, mth))\n+\t  && !comp_proto_with_proto (method, mth, 1))\n \terror (\"duplicate declaration of method %<%c%s%>\",\n \t\tis_class ? '+' : '-', \n \t\tIDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n@@ -6263,11 +6733,27 @@ objc_add_method (tree class, tree method, int is_class)\n }\n \n static tree\n-add_class (tree class)\n+add_class (tree class_name, tree name)\n {\n+  struct interface_tuple **slot;\n+\n   /* Put interfaces on list in reverse order.  */\n-  TREE_CHAIN (class) = interface_chain;\n-  interface_chain = class;\n+  TREE_CHAIN (class_name) = interface_chain;\n+  interface_chain = class_name;\n+\n+  if (interface_htab == NULL)\n+    interface_htab = htab_create_ggc (31, hash_interface, eq_interface, NULL);\n+  slot = (struct interface_tuple **)\n+    htab_find_slot_with_hash (interface_htab, name,\n+\t\t\t      htab_hash_pointer (name),\n+\t\t\t      INSERT);\n+  if (!*slot)\n+    {\n+      *slot = (struct interface_tuple *) ggc_alloc_cleared (sizeof (struct interface_tuple));\n+      (*slot)->id = name;\n+    }\n+  (*slot)->class_name = class_name;\n+\n   return interface_chain;\n }\n \n@@ -6323,27 +6809,65 @@ add_instance_variable (tree class, int public, tree field_decl)\n     }\n \n #ifdef OBJCPLUS\n-  /* zlaski 2001-Apr-24: C++ classes with non-trivial constructors and/or destructors\n-     cannot be ivars; ditto for classes with vtables. */\n-  if(IS_AGGR_TYPE (field_type) && (TYPE_NEEDS_CONSTRUCTING (field_type)\n-      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type) || TYPE_POLYMORPHIC_P (field_type)))\n+  /* Check if the ivar being added has a non-POD C++ type.   If so, we will\n+     need to either (1) warn the user about it or (2) generate suitable\n+     constructor/destructor call from '- .cxx_construct' or '- .cxx_destruct'\n+     methods (if '-fobjc-call-cxx-cdtors' was specified).  */\n+  if (IS_AGGR_TYPE (field_type)\n+      && (TYPE_NEEDS_CONSTRUCTING (field_type)\n+\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type)\n+\t  || TYPE_POLYMORPHIC_P (field_type)))\n     {\n       const char *type_name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (field_type));\n-      if(TYPE_POLYMORPHIC_P (field_type)) {\n-        /* vtable pointers are Real Bad(tm), since Obj-C cannot initialize them */\n-        error (\"type %qs has virtual member functions\", type_name);\n-        error (\"illegal aggregate type %qs specified for instance variable %qs\",\n-  \t       type_name, ivar_name);\n-        /* Return class as is without adding this ivar.  */\n-        return class;\n-      }\n-      /* user-defined constructors and destructors are not known to Obj-C and\n-         hence will not be called.  This may or may not be a problem. */\n-      if (TYPE_NEEDS_CONSTRUCTING (field_type))\n-        warning (0, \"type %qs has a user-defined constructor\", type_name);\n-      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type))\n-        warning (0, \"type %qs has a user-defined destructor\", type_name);\n-      warning (0, \"C++ constructors and destructors will not be invoked for Objective-C fields\");\n+\n+      if (flag_objc_call_cxx_cdtors)\n+        {\n+\t  /* Since the ObjC runtime will be calling the constructors and\n+\t     destructors for us, the only thing we can't handle is the lack\n+\t     of a default constructor.  */\n+\t  if (TYPE_NEEDS_CONSTRUCTING (field_type)\n+\t      && !TYPE_HAS_DEFAULT_CONSTRUCTOR (field_type))\n+\t    {\n+\t      warning (0, \"type `%s' has no default constructor to call\",\n+\t\t       type_name);\n+\n+\t      /* If we cannot call a constructor, we should also avoid\n+\t\t calling the destructor, for symmetry.  */\n+\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type))\n+\t\twarning (0, \"destructor for `%s' shall not be run either\",\n+\t\t\t type_name);\n+\t    }\n+        }\n+      else\n+\t{\n+\t  static bool warn_cxx_ivars = false;\n+\n+\t  if (TYPE_POLYMORPHIC_P (field_type))\n+\t    {\n+\t      /* Vtable pointers are Real Bad(tm), since Obj-C cannot\n+\t\t initialize them.  */\n+\t      error (\"type `%s' has virtual member functions\", type_name);\n+\t      error (\"illegal aggregate type `%s' specified \"\n+\t\t     \"for instance variable `%s'\",\n+\t\t     type_name, ivar_name);\n+\t      /* Return class as is without adding this ivar.  */\n+\t      return class;\n+\t    }\n+\n+\t  /* User-defined constructors and destructors are not known to Obj-C\n+\t     and hence will not be called.  This may or may not be a problem. */\n+\t  if (TYPE_NEEDS_CONSTRUCTING (field_type))\n+\t    warning (0, \"type `%s' has a user-defined constructor\", type_name);\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type))\n+\t    warning (0, \"type `%s' has a user-defined destructor\", type_name);\n+\n+\t  if (!warn_cxx_ivars)\n+\t    {\n+\t      warning (0, \"C++ constructors and destructors will not \"\n+\t\t       \"be invoked for Objective-C fields\");\n+\t      warn_cxx_ivars = true;\n+\t    }\n+\t}\n     }\n #endif\n \n@@ -6400,21 +6924,22 @@ int\n objc_is_public (tree expr, tree identifier)\n {\n   tree basetype = TREE_TYPE (expr);\n-  enum tree_code code = TREE_CODE (basetype);\n   tree decl;\n \n-  if (code == RECORD_TYPE)\n+  if (basetype && TREE_CODE (basetype) == RECORD_TYPE)\n     {\n       if (TYPE_HAS_OBJC_INFO (basetype) && TYPE_OBJC_INTERFACE (basetype))\n \t{\n-\t  if (TREE_CODE (TYPE_OBJC_INTERFACE (basetype)) == IDENTIFIER_NODE)\n+\t  tree class = lookup_interface (OBJC_TYPE_NAME (basetype));\n+\n+\t  if (!class)\n \t    {\n \t      error (\"cannot find interface declaration for %qs\",\n \t\t     IDENTIFIER_POINTER (OBJC_TYPE_NAME (basetype)));\n \t      return 0;\n \t    }\n \n-\t  if ((decl = is_ivar (TYPE_FIELDS (basetype), identifier)))\n+\t  if ((decl = is_ivar (get_class_ivars (class), identifier)))\n \t    {\n \t      if (TREE_PUBLIC (decl))\n \t\treturn 1;\n@@ -6455,12 +6980,6 @@ objc_is_public (tree expr, tree identifier)\n \t      return 0;\n \t    }\n \t}\n-\n-      else if (objc_implementation_context && (basetype == objc_object_reference))\n-\t{\n-\t  expr = convert (uprivate_record, expr);\n-\t  warning (0, \"static access to object of type %<id%>\");\n-\t}\n     }\n \n   return 1;\n@@ -6687,14 +7206,23 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n   class = make_node (code);\n   TYPE_LANG_SLOT_1 (class) = make_tree_vec (CLASS_LANG_SLOT_ELTS);\n \n-  /* Check for existence of the super class, if one was specified.  */\n+  /* Check for existence of the super class, if one was specified.  Note\n+     that we must have seen an @interface, not just a @class.  If we\n+     are looking at a @compatibility_alias, traverse it first.  */\n   if ((code == CLASS_INTERFACE_TYPE || code == CLASS_IMPLEMENTATION_TYPE)\n-      && super_name && !objc_is_class_name (super_name))\n+      && super_name)\n     {\n-      error (\"cannot find interface declaration for %qs, superclass of %qs\",\n-\t     IDENTIFIER_POINTER (super_name),\n-\t     IDENTIFIER_POINTER (class_name));\n-      super_name = NULL_TREE;\n+      tree super = objc_is_class_name (super_name);\n+\n+      if (!super || !lookup_interface (super))\n+\t{\n+\t  error (\"cannot find interface declaration for %qs, superclass of %qs\",\n+\t\t IDENTIFIER_POINTER (super ? super : super_name),\n+\t\t IDENTIFIER_POINTER (class_name));\n+\t  super_name = NULL_TREE;\n+\t}\n+      else\n+\tsuper_name = super;\n     }\n \n   CLASS_NAME (class) = class_name;\n@@ -6737,7 +7265,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n         {\n \t  warning (0, \"cannot find interface declaration for %qs\",\n \t\t   IDENTIFIER_POINTER (class_name));\n-\t  add_class (implementation_template = objc_implementation_context);\n+\t  add_class (implementation_template = objc_implementation_context,\n+\t\t     class_name);\n         }\n \n       /* If a super class has been specified in the implementation,\n@@ -6771,7 +7300,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n #endif\t\n         IDENTIFIER_POINTER (class_name));\n       else\n-        add_class (class);\n+        add_class (class, class_name);\n \n       if (protocol_list)\n \tCLASS_PROTOCOL_LIST (class)\n@@ -6828,7 +7357,6 @@ continue_class (tree class)\n       || TREE_CODE (class) == CATEGORY_IMPLEMENTATION_TYPE)\n     {\n       struct imp_entry *imp_entry;\n-      tree ivar_context;\n \n       /* Check consistency of the instance variables.  */\n \n@@ -6843,7 +7371,6 @@ continue_class (tree class)\n \n       build_private_template (implementation_template);\n       uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);\n-      ivar_context = TYPE_FIELDS (uprivate_record);\n       objc_instance_type = build_pointer_type (uprivate_record);\n \n       imp_entry = (struct imp_entry *) ggc_alloc (sizeof (struct imp_entry));\n@@ -6855,6 +7382,7 @@ continue_class (tree class)\n       synth_forward_declarations ();\n       imp_entry->class_decl = UOBJC_CLASS_decl;\n       imp_entry->meta_decl = UOBJC_METACLASS_decl;\n+      imp_entry->has_cxx_cdtors = 0;\n \n       /* Append to front and increment count.  */\n       imp_list = imp_entry;\n@@ -6867,7 +7395,7 @@ continue_class (tree class)\n       pop_lang_context ();\n #endif /* OBJCPLUS */\n \n-      return ivar_context;\n+      return get_class_ivars (implementation_template);\n     }\n \n   else if (TREE_CODE (class) == CLASS_INTERFACE_TYPE)\n@@ -7159,12 +7687,13 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n   tree name;\n   /* NB: aggregates that are pointed to have slightly different encoding\n      rules in that you never encode the names of instance variables.  */\n-  int pointed_to\n-   = (obstack_object_size (&util_obstack) > 0\n-      && *(obstack_next_free (&util_obstack) - 1) == '^');\n+  int ob_size = obstack_object_size (&util_obstack);\n+  char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n+  char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n+  int pointed_to = (c0 == '^' || (c1 == '^' && c0 == 'r'));\n   int inline_contents\n    = ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n-      && (!pointed_to || obstack_object_size (&util_obstack) - curtype == 1));\n+      && (!pointed_to || ob_size - curtype == (c1 == 'r' ? 2 : 1)));\n \n   /* Traverse struct aliases; it is important to get the\n      original struct and its tag name (if any).  */\n@@ -7511,6 +8040,15 @@ start_method_def (tree method)\n #endif\n   int have_ellipsis = 0;\n \n+  /* If we are defining a \"dealloc\" method in a non-root class, we\n+     will need to check if a [super dealloc] is missing, and warn if\n+     it is.  */\n+  if(CLASS_SUPER_NAME (objc_implementation_context)\n+     && !strcmp (\"dealloc\", IDENTIFIER_POINTER (METHOD_SEL_NAME (method))))\n+    should_call_super_dealloc = 1;\n+  else\n+    should_call_super_dealloc = 0;\n+\n   /* Required to implement _msgSuper.  */\n   objc_method_context = method;\n   UOBJC_SUPER_decl = NULL_TREE;\n@@ -7589,11 +8127,23 @@ objc_types_are_equivalent (tree type1, tree type2)\n   return 0;\n }\n \n+/* Return 1 if TYPE1 has the same size and alignment as TYPE2.  */\n+\n+static int\n+objc_types_share_size_and_alignment (tree type1, tree type2)\n+{\n+  return (simple_cst_equal (TYPE_SIZE (type1), TYPE_SIZE (type2))\n+\t  && TYPE_ALIGN (type1) == TYPE_ALIGN (type2));\n+}\n+\n /* Return 1 if PROTO1 is equivalent to PROTO2\n-   for purposes of method overloading.  */\n+   for purposes of method overloading.  Ordinarily, the type signatures\n+   should match up exactly, unless STRICT is zero, in which case we\n+   shall allow differences in which the size and alignment of a type\n+   is the same.  */\n \n static int\n-comp_proto_with_proto (tree proto1, tree proto2)\n+comp_proto_with_proto (tree proto1, tree proto2, int strict)\n {\n   tree type1, type2;\n \n@@ -7606,7 +8156,8 @@ comp_proto_with_proto (tree proto1, tree proto2)\n   type1 = TREE_VALUE (TREE_TYPE (proto1));\n   type2 = TREE_VALUE (TREE_TYPE (proto2));\n \n-  if (!objc_types_are_equivalent (type1, type2))\n+  if (!objc_types_are_equivalent (type1, type2)\n+      && (strict || !objc_types_share_size_and_alignment (type1, type2)))\n     return 0;\n \n   /* Compare argument types.  */\n@@ -7615,7 +8166,10 @@ comp_proto_with_proto (tree proto1, tree proto2)\n        type1 && type2;\n        type1 = TREE_CHAIN (type1), type2 = TREE_CHAIN (type2))\n     {\n-      if (!objc_types_are_equivalent (TREE_VALUE (type1), TREE_VALUE (type2)))\n+      if (!objc_types_are_equivalent (TREE_VALUE (type1), TREE_VALUE (type2))\n+\t  && (strict\n+\t      || !objc_types_share_size_and_alignment (TREE_VALUE (type1),\n+\t\t\t\t\t\t       TREE_VALUE (type2))))\n \treturn 0;\n     }\n \n@@ -7682,6 +8236,9 @@ objc_start_function (tree name, tree type, tree attrs,\n   nstack_vm->scope = 0;\n   nstack_vm->next = label_context_stack_vm;\n   label_context_stack_vm = nstack_vm;\n+  current_function_returns_value = 0;  /* Assume, until we see it does.  */\n+  current_function_returns_null = 0;\n+\n   decl_attributes (&fndecl, attrs, 0);\n   announce_function (fndecl);\n   DECL_INITIAL (fndecl) = error_mark_node;\n@@ -7772,11 +8329,12 @@ really_start_method (tree method,\n       tree proto\n \t= lookup_method_static (implementation_template,\n \t\t\t\tMETHOD_SEL_NAME (method),\n-\t\t\t\tTREE_CODE (method) == CLASS_METHOD_DECL);\n+\t\t\t\t((TREE_CODE (method) == CLASS_METHOD_DECL)\n+\t\t\t\t | OBJC_LOOKUP_NO_SUPER));\n \n       if (proto)\n \t{\n-\t  if (!comp_proto_with_proto (method, proto))\n+\t  if (!comp_proto_with_proto (method, proto, 1))\n \t    {\n \t      char type = (TREE_CODE (method) == INSTANCE_METHOD_DECL ? '-' : '+');\n \n@@ -7948,6 +8506,9 @@ objc_finish_method_definition (tree fndecl)\n   /* Required to implement _msgSuper. This must be done AFTER finish_function,\n      since the optimizer may find \"may be used before set\" errors.  */\n   objc_method_context = NULL_TREE;\n+\n+  if (should_call_super_dealloc)\n+    warning (0, \"method possibly missing a [super dealloc] call\");\n }\n \n #if 0\n@@ -8322,7 +8883,9 @@ finish_objc (void)\n \t  /* all of the following reference the string pool...  */\n \t  generate_ivar_lists ();\n \t  generate_dispatch_tables ();\n-\t  generate_shared_structures ();\n+\t  generate_shared_structures (impent->has_cxx_cdtors\n+\t\t\t\t      ? CLS_HAS_CXX_STRUCTORS\n+\t\t\t\t      : 0);\n \t}\n       else\n \t{\n@@ -8339,7 +8902,7 @@ finish_objc (void)\n   if (protocol_chain)\n     generate_protocols ();\n \n-  if (flag_replace_objc_classes && imp_list)\n+  if ((flag_replace_objc_classes && imp_list) || flag_objc_gc)\n     generate_objc_image_info ();\n \n   /* Arrange for ObjC data structures to be initialized at run time.  */\n@@ -8521,14 +9084,17 @@ static void\n generate_objc_image_info (void)\n {\n   tree decl, initlist;\n+  int flags\n+    = ((flag_replace_objc_classes && imp_list ? 1 : 0)\n+       | (flag_objc_gc ? 2 : 0));\n \n   decl = start_var_decl (build_array_type\n \t\t\t (integer_type_node,\n \t\t\t  build_index_type (build_int_cst (NULL_TREE, 2 - 1))),\n \t\t\t \"_OBJC_IMAGE_INFO\");\n \n   initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, 0));\n-  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 1), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags), initlist);\n   initlist = objc_build_constructor (TREE_TYPE (decl), nreverse (initlist));\n \n   finish_var_decl (decl, initlist);\n@@ -8565,7 +9131,12 @@ objc_lookup_ivar (tree other, tree id)\n   /* In an instance method, a local variable (or parameter) may hide the\n      instance variable.  */\n   if (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL\n-      && other && other != error_mark_node && !DECL_FILE_SCOPE_P (other))\n+      && other && other != error_mark_node\n+#ifdef OBJCPLUS\n+      && CP_DECL_CONTEXT (other) != global_namespace)\n+#else\n+      && !DECL_FILE_SCOPE_P (other))\n+#endif\n     {\n       warning (0, \"local declaration of %qs hides instance variable\",\n \t       IDENTIFIER_POINTER (id));\n@@ -8579,6 +9150,25 @@ objc_lookup_ivar (tree other, tree id)\n   return build_ivar_reference (id);\n }\n \n+/* Possibly rewrite a function CALL into an OBJ_TYPE_REF expression.  This\n+   needs to be done if we are calling a function through a cast.  */\n+\n+tree\n+objc_rewrite_function_call (tree function, tree params)\n+{\n+  if (TREE_CODE (function) == NOP_EXPR\n+      && TREE_CODE (TREE_OPERAND (function, 0)) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (function, 0), 0))\n+\t == FUNCTION_DECL)\n+    {\n+      function = build (OBJ_TYPE_REF, TREE_TYPE (function),\n+\t\t\tTREE_OPERAND (function, 0),\n+\t\t\tTREE_VALUE (params), size_zero_node);\n+    }\n+\n+  return function;\n+}\n+\n /* Look for the special case of OBJC_TYPE_REF with the address of\n    a function in OBJ_TYPE_REF_EXPR (presumably objc_msgSend or one\n    of its cousins).  */\n@@ -8604,7 +9194,11 @@ enum gimplify_status objc_gimplify_expr (tree *expr_p, tree *pre_p,\n \t\t\t  is_gimple_val, fb_rvalue);\n       return MIN (r0, r1);\n     }\n+#ifdef OBJCPLUS\n+  return cp_gimplify_expr (expr_p, pre_p, post_p);\n+#else\n   return c_gimplify_expr (expr_p, pre_p, post_p);\n+#endif\n }\n \n /* Given a CALL expression, find the function being called.  The ObjC"}, {"sha": "47ee83ed5e3837a4efd7f558c7cab95efbc0d220", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b9c8c3a989be4b6efec34f1e60a39425d27fb6/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=38b9c8c3a989be4b6efec34f1e60a39425d27fb6", "patch": "@@ -77,43 +77,45 @@ enum gimplify_status objc_gimplify_expr (tree *, tree *, tree *);\n \n /* ObjC-specific information pertaining to RECORD_TYPEs are stored in\n    the LANG_SPECIFIC structures, which may itself need allocating first.  */\n+\n+/* The following three macros must be overridden (in objcp/objcp-decl.h)\n+   for Objective-C++.  */\n #define TYPE_OBJC_INFO(TYPE) TYPE_LANG_SPECIFIC (TYPE)->objc_info\n+#define SIZEOF_OBJC_TYPE_LANG_SPECIFIC sizeof (struct lang_type)\n+#define ALLOC_OBJC_TYPE_LANG_SPECIFIC(NODE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    TYPE_LANG_SPECIFIC (NODE) = GGC_CNEW (struct lang_type);\t\t\\\n+  } while (0)\n+\n #define TYPE_HAS_OBJC_INFO(TYPE)\t\t\t\t\\\n-\t(TYPE_LANG_SPECIFIC (TYPE)\t\t\t\t\\\n-\t && TYPE_LANG_SPECIFIC (TYPE)->objc_info)\n+\t(TYPE_LANG_SPECIFIC (TYPE) && TYPE_OBJC_INFO (TYPE))\n #define TYPE_OBJC_INTERFACE(TYPE) TREE_VEC_ELT (TYPE_OBJC_INFO (TYPE), 0)\n #define TYPE_OBJC_PROTOCOL_LIST(TYPE) TREE_VEC_ELT (TYPE_OBJC_INFO (TYPE), 1)\n \n+\n #define INIT_TYPE_OBJC_INFO(TYPE)\t\t\t\t\\\n \tdo\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n \t    if (!TYPE_LANG_SPECIFIC (TYPE))\t\t\t\\\n-\t      TYPE_LANG_SPECIFIC (TYPE)\t\t\t\t\\\n-\t\t= ALLOC_OBJC_TYPE_LANG_SPECIFIC;\t\t\t\\\n-\t    if (!TYPE_LANG_SPECIFIC (TYPE)->objc_info)\t\t\\\n-\t      TYPE_LANG_SPECIFIC (TYPE)->objc_info\t\t\\\n+\t      ALLOC_OBJC_TYPE_LANG_SPECIFIC(TYPE);\t\t\\\n+\t    if (!TYPE_OBJC_INFO (TYPE))\t\t\t\t\\\n+\t      TYPE_OBJC_INFO (TYPE)\t\t\t\t\\\n \t\t= make_tree_vec (OBJC_INFO_SLOT_ELTS);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n \twhile (0)\n #define DUP_TYPE_OBJC_INFO(DST, SRC)\t\t\t\t\\\n \tdo\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n-\t    TYPE_LANG_SPECIFIC (DST)\t\t\t\t\\\n-\t      = ALLOC_OBJC_TYPE_LANG_SPECIFIC;\t\t\t\\\n+\t    ALLOC_OBJC_TYPE_LANG_SPECIFIC(DST);\t\t\t\\\n \t    if (TYPE_LANG_SPECIFIC (SRC))\t\t\t\\\n \t      memcpy (TYPE_LANG_SPECIFIC (DST),\t\t\t\\\n \t\t      TYPE_LANG_SPECIFIC (SRC),\t\t\t\\\n \t\t      SIZEOF_OBJC_TYPE_LANG_SPECIFIC);\t\t\\\n-\t    TYPE_LANG_SPECIFIC (DST)->objc_info\t\t\t\\\n+\t    TYPE_OBJC_INFO (DST)\t\t\t\t\\\n \t      = make_tree_vec (OBJC_INFO_SLOT_ELTS);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n \twhile (0)\n \n-/* The following two macros must be overridden (in objcp/objcp-decl.h)\n-   for Objective-C++.  */\n-#define ALLOC_OBJC_TYPE_LANG_SPECIFIC\tGGC_CNEW (struct lang_type)\n-#define SIZEOF_OBJC_TYPE_LANG_SPECIFIC\tsizeof (struct lang_type)\n-\n #define TYPED_OBJECT(TYPE)\t\t\t\t\t\\\n \t(TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\\\n \t && TYPE_HAS_OBJC_INFO (TYPE)\t\t\t\t\\\n@@ -170,6 +172,7 @@ struct imp_entry GTY(())\n   tree imp_template;\n   tree class_decl;\t\t/* _OBJC_CLASS_<my_name>; */\n   tree meta_decl;\t\t/* _OBJC_METACLASS_<my_name>; */\n+  BOOL_BITFIELD has_cxx_cdtors : 1;\n };\n \n extern GTY(()) struct imp_entry *imp_list;\n@@ -191,6 +194,7 @@ enum objc_tree_index\n \n     OCTI_SELF_DECL,\n     OCTI_UMSG_DECL,\n+    OCTI_UMSG_FAST_DECL,\n     OCTI_UMSG_SUPER_DECL,\n     OCTI_UMSG_STRET_DECL,\n     OCTI_UMSG_SUPER_STRET_DECL,\n@@ -241,6 +245,9 @@ enum objc_tree_index\n     OCTI_UUCLS_SUPER_REF,\n     OCTI_METH_TEMPL,\n     OCTI_IVAR_TEMPL,\n+    OCTI_METH_LIST_TEMPL,\n+    OCTI_METH_PROTO_LIST_TEMPL,\n+    OCTI_IVAR_LIST_TEMPL,\n     OCTI_SYMTAB_TEMPL,\n     OCTI_MODULE_TEMPL,\n     OCTI_SUPER_TEMPL,\n@@ -278,6 +285,11 @@ enum objc_tree_index\n     OCTI_CATCH_TYPE,\n     OCTI_EXECCLASS_DECL,\n \n+    OCTI_ASSIGN_IVAR_DECL,\n+    OCTI_ASSIGN_IVAR_FAST_DECL,\n+    OCTI_ASSIGN_GLOBAL_DECL,\n+    OCTI_ASSIGN_STRONGCAST_DECL,\n+\n     OCTI_MAX\n };\n \n@@ -297,6 +309,7 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \n #define self_decl\t\tobjc_global_trees[OCTI_SELF_DECL]\n #define umsg_decl\t\tobjc_global_trees[OCTI_UMSG_DECL]\n+#define umsg_fast_decl\t\tobjc_global_trees[OCTI_UMSG_FAST_DECL]\n #define umsg_super_decl\t\tobjc_global_trees[OCTI_UMSG_SUPER_DECL]\n #define umsg_stret_decl\t\tobjc_global_trees[OCTI_UMSG_STRET_DECL]\n #define umsg_super_stret_decl\tobjc_global_trees[OCTI_UMSG_SUPER_STRET_DECL]\n@@ -408,8 +421,19 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n \n #define execclass_decl\t\tobjc_global_trees[OCTI_EXECCLASS_DECL]\n \n+#define objc_assign_ivar_decl\tobjc_global_trees[OCTI_ASSIGN_IVAR_DECL]\n+#define objc_assign_ivar_fast_decl\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_ASSIGN_IVAR_FAST_DECL]\n+#define objc_assign_global_decl\tobjc_global_trees[OCTI_ASSIGN_GLOBAL_DECL]\n+#define objc_assign_strong_cast_decl\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_ASSIGN_STRONGCAST_DECL]\n+\n #define objc_method_template\tobjc_global_trees[OCTI_METH_TEMPL]\n #define objc_ivar_template\tobjc_global_trees[OCTI_IVAR_TEMPL]\n+#define objc_method_list_ptr\tobjc_global_trees[OCTI_METH_LIST_TEMPL]\n+#define objc_method_proto_list_ptr\t\t\\\n+\t\t\t\tobjc_global_trees[OCTI_METH_PROTO_LIST_TEMPL]\n+#define objc_ivar_list_ptr\tobjc_global_trees[OCTI_IVAR_LIST_TEMPL]\n #define objc_symtab_template\tobjc_global_trees[OCTI_SYMTAB_TEMPL]\n #define objc_module_template\tobjc_global_trees[OCTI_MODULE_TEMPL]\n #define objc_super_template\tobjc_global_trees[OCTI_SUPER_TEMPL]"}]}