{"sha": "675f99c97fb1fa0405b19eba9785075117d50849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1Zjk5Yzk3ZmIxZmEwNDA1YjE5ZWJhOTc4NTA3NTExN2Q1MDg0OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-16T18:55:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-16T18:55:20Z"}, "message": "resource.c (mark_referenced_resources): Change include_delayed_effects parameter to bool.\n\n\t* resource.c (mark_referenced_resources): Change\n\tinclude_delayed_effects parameter to bool.  Change all callers.\n\t(mark_end_of_function_resources): Likewise.\n\t* reorg.c (insn_references_resource_p): Likewise.\n\t(insn_sets_resource_p): Likewise.\n\t* resource.h (mark_referenced_resources): Update declaration.\n\t(mark_end_of_function_resources): Update declaration.\n\nFrom-SVN: r148547", "tree": {"sha": "83e14595650e69007e9dbeb944d1dff4b5977881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e14595650e69007e9dbeb944d1dff4b5977881"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/675f99c97fb1fa0405b19eba9785075117d50849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675f99c97fb1fa0405b19eba9785075117d50849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/675f99c97fb1fa0405b19eba9785075117d50849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675f99c97fb1fa0405b19eba9785075117d50849/comments", "author": null, "committer": null, "parents": [{"sha": "a322799debba41a2225dd52c2731adb5e19fa7ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a322799debba41a2225dd52c2731adb5e19fa7ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a322799debba41a2225dd52c2731adb5e19fa7ad"}], "stats": {"total": 172, "additions": 93, "deletions": 79}, "files": [{"sha": "0939e0e04e0576bd8188cc3f3284e69d33629a5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=675f99c97fb1fa0405b19eba9785075117d50849", "patch": "@@ -1,3 +1,13 @@\n+2009-06-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* resource.c (mark_referenced_resources): Change\n+\tinclude_delayed_effects parameter to bool.  Change all callers.\n+\t(mark_end_of_function_resources): Likewise.\n+\t* reorg.c (insn_references_resource_p): Likewise.\n+\t(insn_sets_resource_p): Likewise.\n+\t* resource.h (mark_referenced_resources): Update declaration.\n+\t(mark_end_of_function_resources): Update declaration.\n+\n 2009-06-16  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/aix.h (LIBSTDCXX_STATIC): Remove -lstdc++."}, {"sha": "74e84eb8116f36cab87e72320bdd137283e90b50", "filename": "gcc/reorg.c", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=675f99c97fb1fa0405b19eba9785075117d50849", "patch": "@@ -173,8 +173,8 @@ static int max_uid;\n \n static int stop_search_p (rtx, int);\n static int resource_conflicts_p (struct resources *, struct resources *);\n-static int insn_references_resource_p (rtx, struct resources *, int);\n-static int insn_sets_resource_p (rtx, struct resources *, int);\n+static int insn_references_resource_p (rtx, struct resources *, bool);\n+static int insn_sets_resource_p (rtx, struct resources *, bool);\n static rtx find_end_label (void);\n static rtx emit_delay_sequence (rtx, rtx, int);\n static rtx add_to_delay_list (rtx, rtx);\n@@ -297,7 +297,7 @@ resource_conflicts_p (struct resources *res1, struct resources *res2)\n \n static int\n insn_references_resource_p (rtx insn, struct resources *res,\n-\t\t\t    int include_delayed_effects)\n+\t\t\t    bool include_delayed_effects)\n {\n   struct resources insn_res;\n \n@@ -313,7 +313,7 @@ insn_references_resource_p (rtx insn, struct resources *res,\n \n static int\n insn_sets_resource_p (rtx insn, struct resources *res,\n-\t\t      int include_delayed_effects)\n+\t\t      bool include_delayed_effects)\n {\n   struct resources insn_sets;\n \n@@ -1246,7 +1246,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n       rtx trial = XEXP (temp, 0);\n \n       mark_set_resources (trial, &cc_set, 0, MARK_SRC_DEST_CALL);\n-      if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, 0))\n+      if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, false))\n \treturn delay_list;\n     }\n \n@@ -1268,9 +1268,9 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n       rtx trial = XVECEXP (seq, 0, i);\n       int flags;\n \n-      if (insn_references_resource_p (trial, sets, 0)\n-\t  || insn_sets_resource_p (trial, needed, 0)\n-\t  || insn_sets_resource_p (trial, sets, 0)\n+      if (insn_references_resource_p (trial, sets, false)\n+\t  || insn_sets_resource_p (trial, needed, false)\n+\t  || insn_sets_resource_p (trial, sets, false)\n #ifdef HAVE_cc0\n \t  /* If TRIAL sets CC0, we can't copy it, so we can't steal this\n \t     delay list.  */\n@@ -1293,7 +1293,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n \n       if (! must_annul\n \t  && ((condition == const_true_rtx\n-\t       || (! insn_sets_resource_p (trial, other_needed, 0)\n+\t       || (! insn_sets_resource_p (trial, other_needed, false)\n \t\t   && ! may_trap_or_fault_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, total_slots_filled, trial, flags)\n \t  : (must_annul || (delay_list == NULL && new_delay_list == NULL))\n@@ -1368,9 +1368,9 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n \n       /* If TRIAL sets CC0, stealing it will move it too far from the use\n \t of CC0.  */\n-      if (insn_references_resource_p (trial, sets, 0)\n-\t  || insn_sets_resource_p (trial, needed, 0)\n-\t  || insn_sets_resource_p (trial, sets, 0)\n+      if (insn_references_resource_p (trial, sets, false)\n+\t  || insn_sets_resource_p (trial, needed, false)\n+\t  || insn_sets_resource_p (trial, sets, false)\n #ifdef HAVE_cc0\n \t  || sets_cc0_p (PATTERN (trial))\n #endif\n@@ -1387,7 +1387,7 @@ steal_delay_list_from_fallthrough (rtx insn, rtx condition, rtx seq,\n \n       if (! must_annul\n \t  && ((condition == const_true_rtx\n-\t       || (! insn_sets_resource_p (trial, other_needed, 0)\n+\t       || (! insn_sets_resource_p (trial, other_needed, false)\n \t\t   && ! may_trap_or_fault_p (PATTERN (trial)))))\n \t  ? eligible_for_delay (insn, *pslots_filled, trial, flags)\n \t  : (must_annul || delay_list == NULL) && (must_annul = 1,\n@@ -1448,7 +1448,8 @@ try_merge_delay_insns (rtx insn, rtx thread)\n   if (! annul_p)\n     for (i = 1 ; i < num_slots; i++)\n       if (XVECEXP (PATTERN (insn), 0, i))\n-\tmark_referenced_resources (XVECEXP (PATTERN (insn), 0, i), &needed, 1);\n+\tmark_referenced_resources (XVECEXP (PATTERN (insn), 0, i), &needed,\n+\t\t\t\t   true);\n \n   for (trial = thread; !stop_search_p (trial, 1); trial = next_trial)\n     {\n@@ -1467,9 +1468,9 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t  /* We can't share an insn that sets cc0.  */\n \t  && ! sets_cc0_p (pat)\n #endif\n-\t  && ! insn_references_resource_p (trial, &set, 1)\n-\t  && ! insn_sets_resource_p (trial, &set, 1)\n-\t  && ! insn_sets_resource_p (trial, &needed, 1)\n+\t  && ! insn_references_resource_p (trial, &set, true)\n+\t  && ! insn_sets_resource_p (trial, &set, true)\n+\t  && ! insn_sets_resource_p (trial, &needed, true)\n \t  && (trial = try_split (pat, trial, 0)) != 0\n \t  /* Update next_trial, in case try_split succeeded.  */\n \t  && (next_trial = next_nonnote_insn (trial))\n@@ -1500,7 +1501,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t}\n \n       mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-      mark_referenced_resources (trial, &needed, 1);\n+      mark_referenced_resources (trial, &needed, true);\n     }\n \n   /* See if we stopped on a filled insn.  If we did, try to see if its\n@@ -1515,15 +1516,15 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \n       /* Account for resources set/needed by the filled insn.  */\n       mark_set_resources (filled_insn, &set, 0, MARK_SRC_DEST_CALL);\n-      mark_referenced_resources (filled_insn, &needed, 1);\n+      mark_referenced_resources (filled_insn, &needed, true);\n \n       for (i = 1; i < XVECLEN (pat, 0); i++)\n \t{\n \t  rtx dtrial = XVECEXP (pat, 0, i);\n \n-\t  if (! insn_references_resource_p (dtrial, &set, 1)\n-\t      && ! insn_sets_resource_p (dtrial, &set, 1)\n-\t      && ! insn_sets_resource_p (dtrial, &needed, 1)\n+\t  if (! insn_references_resource_p (dtrial, &set, true)\n+\t      && ! insn_sets_resource_p (dtrial, &set, true)\n+\t      && ! insn_sets_resource_p (dtrial, &needed, true)\n #ifdef HAVE_cc0\n \t      && ! sets_cc0_p (PATTERN (dtrial))\n #endif\n@@ -1554,7 +1555,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n \t      /* Keep track of the set/referenced resources for the delay\n \t\t slots of any trial insns we encounter.  */\n \t      mark_set_resources (dtrial, &set, 0, MARK_SRC_DEST_CALL);\n-\t      mark_referenced_resources (dtrial, &needed, 1);\n+\t      mark_referenced_resources (dtrial, &needed, true);\n \t    }\n \t}\n     }\n@@ -1690,7 +1691,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n   CLEAR_RESOURCE (&needed);\n   CLEAR_RESOURCE (&set);\n   mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n-  mark_referenced_resources (insn, &needed, 1);\n+  mark_referenced_resources (insn, &needed, true);\n \n   /* If TARGET is a SEQUENCE, get the main insn.  */\n   if (NONJUMP_INSN_P (target) && GET_CODE (PATTERN (target)) == SEQUENCE)\n@@ -1702,8 +1703,8 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n #endif\n       /* The insn requiring the delay may not set anything needed or set by\n \t INSN.  */\n-      || insn_sets_resource_p (target_main, &needed, 1)\n-      || insn_sets_resource_p (target_main, &set, 1))\n+      || insn_sets_resource_p (target_main, &needed, true)\n+      || insn_sets_resource_p (target_main, &set, true))\n     return 0;\n \n   /* Insns we pass may not set either NEEDED or SET, so merge them for\n@@ -1717,14 +1718,15 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \n   while (delay_list)\n     {\n-      if (insn_sets_resource_p (XEXP (delay_list, 0), &needed, 1))\n+      if (insn_sets_resource_p (XEXP (delay_list, 0), &needed, true))\n \treturn 0;\n       delay_list = XEXP (delay_list, 1);\n     }\n \n   if (NONJUMP_INSN_P (target) && GET_CODE (PATTERN (target)) == SEQUENCE)\n     for (i = 1; i < XVECLEN (PATTERN (target), 0); i++)\n-      if (insn_sets_resource_p (XVECEXP (PATTERN (target), 0, i), &needed, 1))\n+      if (insn_sets_resource_p (XVECEXP (PATTERN (target), 0, i), &needed,\n+\t\t\t\ttrue))\n \treturn 0;\n \n   /* Scan backwards until we reach a label or an insn that uses something\n@@ -1783,13 +1785,13 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \t\t we must stop if it sets anything needed or set by INSN.  */\n \t      if ((! INSN_ANNULLED_BRANCH_P (XVECEXP (pat, 0, 0))\n \t\t   || ! INSN_FROM_TARGET_P (candidate))\n-\t\t  && insn_sets_resource_p (candidate, &needed, 1))\n+\t\t  && insn_sets_resource_p (candidate, &needed, true))\n \t\treturn 0;\n \t    }\n \n \t  /* If the insn requiring the delay slot conflicts with INSN, we\n \t     must stop.  */\n-\t  if (insn_sets_resource_p (XVECEXP (pat, 0, 0), &needed, 1))\n+\t  if (insn_sets_resource_p (XVECEXP (pat, 0, 0), &needed, true))\n \t    return 0;\n \t}\n       else\n@@ -1800,7 +1802,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \t    return trial;\n \n \t  /* Can't go any further if TRIAL conflicts with INSN.  */\n-\t  if (insn_sets_resource_p (trial, &needed, 1))\n+\t  if (insn_sets_resource_p (trial, &needed, true))\n \t    return 0;\n \t}\n     }\n@@ -2138,7 +2140,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  CLEAR_RESOURCE (&needed);\n \t  CLEAR_RESOURCE (&set);\n \t  mark_set_resources (insn, &set, 0, MARK_SRC_DEST);\n-\t  mark_referenced_resources (insn, &needed, 0);\n+\t  mark_referenced_resources (insn, &needed, false);\n \n \t  for (trial = prev_nonnote_insn (insn); ! stop_search_p (trial, 1);\n \t       trial = next_trial)\n@@ -2154,9 +2156,9 @@ fill_simple_delay_slots (int non_jumps_p)\n \n \t      /* Check for resource conflict first, to avoid unnecessary\n \t\t splitting.  */\n-\t      if (! insn_references_resource_p (trial, &set, 1)\n-\t\t  && ! insn_sets_resource_p (trial, &set, 1)\n-\t\t  && ! insn_sets_resource_p (trial, &needed, 1)\n+\t      if (! insn_references_resource_p (trial, &set, true)\n+\t\t  && ! insn_sets_resource_p (trial, &set, true)\n+\t\t  && ! insn_sets_resource_p (trial, &needed, true)\n #ifdef HAVE_cc0\n \t\t  /* Can't separate set of cc0 from its use.  */\n \t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n@@ -2184,7 +2186,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t}\n \n \t      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-\t      mark_referenced_resources (trial, &needed, 1);\n+\t      mark_referenced_resources (trial, &needed, true);\n \t    }\n \t}\n \n@@ -2255,13 +2257,13 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  if (CALL_P (insn))\n \t    {\n \t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n-\t      mark_referenced_resources (insn, &needed, 1);\n+\t      mark_referenced_resources (insn, &needed, true);\n \t      maybe_never = 1;\n \t    }\n \t  else\n \t    {\n \t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n-\t      mark_referenced_resources (insn, &needed, 1);\n+\t      mark_referenced_resources (insn, &needed, true);\n \t      if (JUMP_P (insn))\n \t\ttarget = JUMP_LABEL (insn);\n \t    }\n@@ -2296,9 +2298,9 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t/* See if we have a resource problem before we try to\n \t\t   split.  */\n \t\tif (GET_CODE (pat) != SEQUENCE\n-\t\t    && ! insn_references_resource_p (trial, &set, 1)\n-\t\t    && ! insn_sets_resource_p (trial, &set, 1)\n-\t\t    && ! insn_sets_resource_p (trial, &needed, 1)\n+\t\t    && ! insn_references_resource_p (trial, &set, true)\n+\t\t    && ! insn_sets_resource_p (trial, &set, true)\n+\t\t    && ! insn_sets_resource_p (trial, &needed, true)\n #ifdef HAVE_cc0\n \t\t    && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n@@ -2322,7 +2324,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  }\n \n \t\tmark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-\t\tmark_referenced_resources (trial, &needed, 1);\n+\t\tmark_referenced_resources (trial, &needed, true);\n \n \t\t/* Ensure we don't put insns between the setting of cc and the\n \t\t   comparison by moving a setting of cc into an earlier delay\n@@ -2349,9 +2351,9 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      && ! (NONJUMP_INSN_P (next_trial)\n \t\t    && GET_CODE (PATTERN (next_trial)) == SEQUENCE)\n \t      && !JUMP_P (next_trial)\n-\t      && ! insn_references_resource_p (next_trial, &set, 1)\n-\t      && ! insn_sets_resource_p (next_trial, &set, 1)\n-\t      && ! insn_sets_resource_p (next_trial, &needed, 1)\n+\t      && ! insn_references_resource_p (next_trial, &set, true)\n+\t      && ! insn_sets_resource_p (next_trial, &set, true)\n+\t      && ! insn_sets_resource_p (next_trial, &needed, true)\n #ifdef HAVE_cc0\n \t      && ! reg_mentioned_p (cc0_rtx, PATTERN (next_trial))\n #endif\n@@ -2458,9 +2460,9 @@ fill_simple_delay_slots (int non_jumps_p)\n       if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \tcontinue;\n \n-      if (! insn_references_resource_p (trial, &set, 1)\n-\t  && ! insn_sets_resource_p (trial, &needed, 1)\n-\t  && ! insn_sets_resource_p (trial, &set, 1)\n+      if (! insn_references_resource_p (trial, &set, true)\n+\t  && ! insn_sets_resource_p (trial, &needed, true)\n+\t  && ! insn_sets_resource_p (trial, &set, true)\n #ifdef HAVE_cc0\n \t  /* Don't want to mess with cc0 here.  */\n \t  && ! reg_mentioned_p (cc0_rtx, pat)\n@@ -2476,7 +2478,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      crtl->epilogue_delay_list\n \t\t= gen_rtx_INSN_LIST (VOIDmode, trial,\n \t\t\t\t     crtl->epilogue_delay_list);\n-\t      mark_end_of_function_resources (trial, 1);\n+\t      mark_end_of_function_resources (trial, true);\n \t      update_block (trial, trial);\n \t      delete_related_insns (trial);\n \n@@ -2490,7 +2492,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t}\n \n       mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-      mark_referenced_resources (trial, &needed, 1);\n+      mark_referenced_resources (trial, &needed, true);\n     }\n \n   note_delay_statistics (slots_filled, 0);\n@@ -2635,9 +2637,9 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \n       /* If TRIAL conflicts with the insns ahead of it, we lose.  Also,\n \t don't separate or copy insns that set and use CC0.  */\n-      if (! insn_references_resource_p (trial, &set, 1)\n-\t  && ! insn_sets_resource_p (trial, &set, 1)\n-\t  && ! insn_sets_resource_p (trial, &needed, 1)\n+      if (! insn_references_resource_p (trial, &set, true)\n+\t  && ! insn_sets_resource_p (trial, &set, true)\n+\t  && ! insn_sets_resource_p (trial, &needed, true)\n #ifdef HAVE_cc0\n \t  && ! (reg_mentioned_p (cc0_rtx, pat)\n \t\t&& (! own_thread || ! sets_cc0_p (pat)))\n@@ -2678,7 +2680,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t     go into an annulled delay slot.  */\n \t  if (!must_annul\n \t      && (condition == const_true_rtx\n-\t          || (! insn_sets_resource_p (trial, &opposite_needed, 1)\n+\t          || (! insn_sets_resource_p (trial, &opposite_needed, true)\n \t\t      && ! may_trap_or_fault_p (pat))))\n \t    {\n \t      old_trial = trial;\n@@ -2793,10 +2795,11 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t\t may be branching to a location that has a\n \t\t\t redundant insn.  Skip any if so.  */\n \t\t      while (new_thread && ! own_thread\n-\t\t\t     && ! insn_sets_resource_p (new_thread, &set, 1)\n-\t\t\t     && ! insn_sets_resource_p (new_thread, &needed, 1)\n+\t\t\t     && ! insn_sets_resource_p (new_thread, &set, true)\n+\t\t\t     && ! insn_sets_resource_p (new_thread, &needed,\n+\t\t\t\t\t\t\ttrue)\n \t\t\t     && ! insn_references_resource_p (new_thread,\n-\t\t\t\t\t\t\t      &set, 1)\n+\t\t\t\t\t\t\t      &set, true)\n \t\t\t     && (prior_insn\n \t\t\t\t = redundant_insn (new_thread, insn,\n \t\t\t\t\t\t   delay_list)))\n@@ -2818,7 +2821,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       /* This insn can't go into a delay slot.  */\n       lose = 1;\n       mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-      mark_referenced_resources (trial, &needed, 1);\n+      mark_referenced_resources (trial, &needed, true);\n \n       /* Ensure we don't put insns between the setting of cc and the comparison\n \t by moving a setting of cc into an earlier delay slot since these insns"}, {"sha": "846f8ef2b41d710b28c4317157d11c6c69b997c0", "filename": "gcc/resource.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=675f99c97fb1fa0405b19eba9785075117d50849", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for computing resource usage of specific insns.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -203,7 +203,7 @@ next_insn_no_annul (rtx insn)\n \n void\n mark_referenced_resources (rtx x, struct resources *res,\n-\t\t\t   int include_delayed_effects)\n+\t\t\t   bool include_delayed_effects)\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n@@ -226,7 +226,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \n     case SUBREG:\n       if (!REG_P (SUBREG_REG (x)))\n-\tmark_referenced_resources (SUBREG_REG (x), res, 0);\n+\tmark_referenced_resources (SUBREG_REG (x), res, false);\n       else\n \t{\n \t  unsigned int regno = subreg_regno (x);\n@@ -253,7 +253,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n       res->volatil |= MEM_VOLATILE_P (x);\n \n       /* Mark registers used to access memory.  */\n-      mark_referenced_resources (XEXP (x, 0), res, 0);\n+      mark_referenced_resources (XEXP (x, 0), res, false);\n       return;\n \n     case CC0:\n@@ -276,31 +276,31 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t traditional asms unlike their normal usage.  */\n \n       for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n-\tmark_referenced_resources (ASM_OPERANDS_INPUT (x, i), res, 0);\n+\tmark_referenced_resources (ASM_OPERANDS_INPUT (x, i), res, false);\n       return;\n \n     case CALL:\n       /* The first operand will be a (MEM (xxx)) but doesn't really reference\n \t memory.  The second operand may be referenced, though.  */\n-      mark_referenced_resources (XEXP (XEXP (x, 0), 0), res, 0);\n-      mark_referenced_resources (XEXP (x, 1), res, 0);\n+      mark_referenced_resources (XEXP (XEXP (x, 0), 0), res, false);\n+      mark_referenced_resources (XEXP (x, 1), res, false);\n       return;\n \n     case SET:\n       /* Usually, the first operand of SET is set, not referenced.  But\n \t registers used to access memory are referenced.  SET_DEST is\n \t also referenced if it is a ZERO_EXTRACT.  */\n \n-      mark_referenced_resources (SET_SRC (x), res, 0);\n+      mark_referenced_resources (SET_SRC (x), res, false);\n \n       x = SET_DEST (x);\n       if (GET_CODE (x) == ZERO_EXTRACT\n \t  || GET_CODE (x) == STRICT_LOW_PART)\n-\tmark_referenced_resources (x, res, 0);\n+\tmark_referenced_resources (x, res, false);\n       else if (GET_CODE (x) == SUBREG)\n \tx = SUBREG_REG (x);\n       if (MEM_P (x))\n-\tmark_referenced_resources (XEXP (x, 0), res, 0);\n+\tmark_referenced_resources (XEXP (x, 0), res, false);\n       return;\n \n     case CLOBBER:\n@@ -372,7 +372,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t\t    }\n \t\t  if (i >= seq_size)\n \t\t    mark_referenced_resources (XEXP (XEXP (link, 0), 0),\n-\t\t\t\t\t       res, 0);\n+\t\t\t\t\t       res, false);\n \t\t}\n \t  }\n \t}\n@@ -519,7 +519,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t\t  if (jump_count >= 10)\n \t\t    break;\n \n-\t\t  mark_referenced_resources (insn, &needed, 1);\n+\t\t  mark_referenced_resources (insn, &needed, true);\n \n \t\t  /* For an annulled branch, mark_set_resources ignores slots\n \t\t     filled by instructions from the target.  This is correct\n@@ -585,7 +585,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t    }\n \t}\n \n-      mark_referenced_resources (insn, &needed, 1);\n+      mark_referenced_resources (insn, &needed, true);\n       mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \n       COPY_HARD_REG_SET (scratch, set.regs);\n@@ -888,7 +888,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n   else if (return_insn_p (target))\n     {\n       *res = end_of_function_needs;\n-      mark_referenced_resources (target, res, 0);\n+      mark_referenced_resources (target, res, false);\n       return;\n     }\n \n@@ -1101,7 +1101,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n       /* Include JUMP_INSN in the needed registers.  */\n       for (insn = target; insn != stop_insn; insn = next_active_insn (insn))\n \t{\n-\t  mark_referenced_resources (insn, &needed, 1);\n+\t  mark_referenced_resources (insn, &needed, true);\n \n \t  COPY_HARD_REG_SET (scratch, needed.regs);\n \t  AND_COMPL_HARD_REG_SET (scratch, set.regs);\n@@ -1155,7 +1155,7 @@ init_resource_info (rtx epilogue_insn)\n \n   if (crtl->return_rtx != 0)\n     mark_referenced_resources (crtl->return_rtx,\n-\t\t\t       &end_of_function_needs, 1);\n+\t\t\t       &end_of_function_needs, true);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i]\n@@ -1274,7 +1274,7 @@ incr_ticks_for_insn (rtx insn)\n /* Add TRIAL to the set of resources used at the end of the current\n    function.  */\n void\n-mark_end_of_function_resources (rtx trial, int include_delayed_effects)\n+mark_end_of_function_resources (rtx trial, bool include_delayed_effects)\n {\n   mark_referenced_resources (trial, &end_of_function_needs,\n \t\t\t     include_delayed_effects);"}, {"sha": "b13782f1ab01b519de8988012efcf4556e3c18d4", "filename": "gcc/resource.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675f99c97fb1fa0405b19eba9785075117d50849/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=675f99c97fb1fa0405b19eba9785075117d50849", "patch": "@@ -1,5 +1,6 @@\n /* Definitions for computing resource usage of specific insns.\n-   Copyright (C) 1999, 2003, 2004, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2003, 2004, 2006, 2007, 2009\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -48,10 +49,10 @@ enum mark_resource_type\n extern void mark_target_live_regs (rtx, rtx, struct resources *);\n extern void mark_set_resources (rtx, struct resources *, int,\n \t\t\t\tenum mark_resource_type);\n-extern void mark_referenced_resources (rtx, struct resources *, int);\n+extern void mark_referenced_resources (rtx, struct resources *, bool);\n extern void clear_hashed_info_for_insn (rtx);\n extern void incr_ticks_for_insn (rtx);\n-extern void mark_end_of_function_resources (rtx, int);\n+extern void mark_end_of_function_resources (rtx, bool);\n extern void init_resource_info (rtx);\n extern void free_resource_info (void);\n "}]}