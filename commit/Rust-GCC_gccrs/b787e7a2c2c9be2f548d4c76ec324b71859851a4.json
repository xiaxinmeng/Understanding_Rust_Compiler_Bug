{"sha": "b787e7a2c2c9be2f548d4c76ec324b71859851a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4N2U3YTJjMmM5YmUyZjU0OGQ0Yzc2ZWMzMjRiNzE4NTk4NTFhNA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-08-02T11:34:54Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-08-02T11:34:54Z"}, "message": "convert many uses of pointer_map to hash_map\n\ngcc/c-family/\n\n\t* cilk.c: Use hash_map instead of pointer_map.\n\ngcc/c/\n\n\t* c-typeck.c: Use hash_map instead of pointer_map.\n\ngcc/cp/\n\n\t* optimize.c, semantics.c: Use hash_map instead of pointer_map.\n\ngcc/\n\n\t* hash-map.h (default_hashmap_traits::mark_key_deleted):\n\tFix cast.\n\t(hash_map::remove): New method.\n(hash_map::traverse): New method.\n\t* cgraph.h, except.c, except.h, gimple-ssa-strength-reduction.c,\n\tipa-utils.c, lto-cgraph.c, lto-streamer.h, omp-low.c, predict.c,\n\ttree-cfg.c, tree-cfgcleanup.c, tree-eh.c, tree-eh.h, tree-inline.c,\n\ttree-inline.h, tree-nested.c, tree-sra.c, tree-ssa-loop-im.c,\n\ttree-ssa-loop-ivopts.c, tree-ssa-reassoc.c, tree-ssa-structalias.c,\n\ttree-ssa.c, tree-ssa.h, var-tracking.c: Use hash_map instead of\n pointer_map.\n\nFrom-SVN: r213517", "tree": {"sha": "b20f9df1d7e2cb3a642d2fab604f827c7d23712a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b20f9df1d7e2cb3a642d2fab604f827c7d23712a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b787e7a2c2c9be2f548d4c76ec324b71859851a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b787e7a2c2c9be2f548d4c76ec324b71859851a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b787e7a2c2c9be2f548d4c76ec324b71859851a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b787e7a2c2c9be2f548d4c76ec324b71859851a4/comments", "author": null, "committer": null, "parents": [{"sha": "6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2830c3dbe0d4972519ddd44bd1b15b2b274ba2"}], "stats": {"total": 1010, "additions": 452, "deletions": 558}, "files": [{"sha": "7302bc8befcafff2f26eaa75d03c608c7091948f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -1,3 +1,17 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-map.h (default_hashmap_traits::mark_key_deleted):\n+\tFix cast.\n+\t(hash_map::remove): New method.\n+(hash_map::traverse): New method.\n+\t* cgraph.h, except.c, except.h, gimple-ssa-strength-reduction.c,\n+\tipa-utils.c, lto-cgraph.c, lto-streamer.h, omp-low.c, predict.c,\n+\ttree-cfg.c, tree-cfgcleanup.c, tree-eh.c, tree-eh.h, tree-inline.c,\n+\ttree-inline.h, tree-nested.c, tree-sra.c, tree-ssa-loop-im.c,\n+\ttree-ssa-loop-ivopts.c, tree-ssa-reassoc.c, tree-ssa-structalias.c,\n+\ttree-ssa.c, tree-ssa.h, var-tracking.c: Use hash_map instead of\n+ pointer_map.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* hash-set.h: new File."}, {"sha": "ff788591328f5bc391f321ab09f2dbac62cf924a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* cilk.c: Use hash_map instead of pointer_map.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* c-gimplify.c: Use hash_set instead of pointer_set."}, {"sha": "e0d114128abcf6ea360a76cd176e91bc27b133f6", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -64,7 +64,7 @@ struct wrapper_data\n   /* Containing function.  */\n   tree context;\n   /* Disposition of all variables in the inner statement.  */\n-  struct pointer_map_t *decl_map;\n+  hash_map<tree, tree> *decl_map;\n   /* True if this function needs a static chain.  */\n   bool nested;\n   /* Arguments to be passed to wrapper function, currently a list.  */\n@@ -335,12 +335,11 @@ create_cilk_helper_decl (struct wrapper_data *wd)\n \n /* A function used by walk tree to find wrapper parms.  */\n \n-static bool\n-wrapper_parm_cb (const void *key0, void **val0, void *data)\n+bool\n+wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n {\n-  struct wrapper_data *wd = (struct wrapper_data *) data;\n-  tree arg = * (tree *)&key0;\n-  tree val = (tree)*val0;\n+  tree arg = key0;\n+  tree val = *val0;\n   tree parm;\n \n   if (val == error_mark_node || val == arg)\n@@ -387,7 +386,7 @@ build_wrapper_type (struct wrapper_data *wd)\n   wd->parms = NULL_TREE;\n   wd->argtypes = void_list_node;\n \n-  pointer_map_traverse (wd->decl_map, wrapper_parm_cb, wd);\n+  wd->decl_map->traverse<wrapper_data *, wrapper_parm_cb> (wd);\n   gcc_assert (wd->type != CILK_BLOCK_FOR);\n \n   /* Now build a function.\n@@ -452,25 +451,22 @@ copy_decl_for_cilk (tree decl, copy_body_data *id)\n \n /* Copy all local variables.  */\n \n-static bool\n-for_local_cb (const void *k_v, void **vp, void *p)\n+bool\n+for_local_cb (tree const &k, tree *vp, copy_body_data *id)\n {\n-  tree k = *(tree *) &k_v;\n-  tree v = (tree) *vp;\n+  tree v = *vp;\n \n   if (v == error_mark_node)\n-    *vp = copy_decl_no_change (k, (copy_body_data *) p);\n+    *vp = copy_decl_no_change (k, id);\n   return true;\n }\n \n /* Copy all local declarations from a _Cilk_spawned function's body.  */\n \n-static bool\n-wrapper_local_cb (const void *k_v, void **vp, void *data)\n+bool\n+wrapper_local_cb (tree const &key, tree *vp, copy_body_data *id)\n {\n-  copy_body_data *id = (copy_body_data *) data;\n-  tree key = *(tree *) &k_v;\n-  tree val = (tree) *vp;\n+  tree val = *vp;\n \n   if (val == error_mark_node)\n     *vp = copy_decl_for_cilk (key, id);\n@@ -514,8 +510,11 @@ cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n   insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n \n   /* We don't want the private variables any more.  */\n-  pointer_map_traverse (wd->decl_map, nested ? for_local_cb : wrapper_local_cb,\n-\t\t\t&id);\n+  if (nested)\n+    wd->decl_map->traverse<copy_body_data *, for_local_cb> (&id);\n+  else\n+    wd->decl_map->traverse<copy_body_data *, wrapper_local_cb> (&id);\n+\n   walk_tree (stmt_p, copy_tree_body_r, (void *) &id, NULL);\n \n   /* See if this function can throw or calls something that should\n@@ -576,7 +575,7 @@ init_wd (struct wrapper_data *wd, enum cilk_block_type type)\n   wd->type = type;\n   wd->fntype = NULL_TREE;\n   wd->context = current_function_decl;\n-  wd->decl_map = pointer_map_create ();\n+  wd->decl_map = new hash_map<tree, tree>;\n   /* _Cilk_for bodies are always nested.  Others start off as \n      normal functions.  */\n   wd->nested = (type == CILK_BLOCK_FOR);\n@@ -590,7 +589,7 @@ init_wd (struct wrapper_data *wd, enum cilk_block_type type)\n static void\n free_wd (struct wrapper_data *wd)\n {\n-  pointer_map_destroy (wd->decl_map);\n+  delete wd->decl_map;\n   wd->nested = false;\n   wd->arglist = NULL_TREE;\n   wd->argtypes = NULL_TREE;\n@@ -618,12 +617,11 @@ free_wd (struct wrapper_data *wd)\n    (var, ???) -- Pure output argument, handled similarly to above.\n */\n \n-static bool\n-declare_one_free_variable (const void *var0, void **map0,\n-\t\t\t   void *data ATTRIBUTE_UNUSED)\n+bool\n+declare_one_free_variable (tree const &var0, tree *map0, wrapper_data &)\n {\n-  const_tree var = (const_tree) var0;\n-  tree map = (tree)*map0;\n+  const_tree var = var0;\n+  tree map = *map0;\n   tree var_type = TREE_TYPE (var), arg_type;\n   bool by_reference;\n   tree parm;\n@@ -713,7 +711,7 @@ create_cilk_wrapper (tree exp, tree *args_out)\n     }\n   else\n     extract_free_variables (exp, &wd, ADD_READ);\n-  pointer_map_traverse (wd.decl_map, declare_one_free_variable, &wd);\n+  wd.decl_map->traverse<wrapper_data &, declare_one_free_variable> (wd);\n   wd.block = TREE_BLOCK (exp);\n   if (!wd.block)\n     wd.block = DECL_INITIAL (current_function_decl);\n@@ -884,9 +882,7 @@ cilk_install_body_pedigree_operations (tree frame_ptr)\n static void\n add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n {\n-  void **valp;\n-  \n-  valp = pointer_map_contains (wd->decl_map, (void *) var);\n+  tree *valp = wd->decl_map->get (var);\n   if (valp)\n     {\n       tree val = (tree) *valp;\n@@ -907,7 +903,7 @@ add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n       if (how != ADD_WRITE)\n \treturn;\n       /* This variable might have been entered as read but is now written.  */\n-      *valp = (void *) var;\n+      *valp = var;\n       wd->nested = true;\n       return;\n     }\n@@ -971,7 +967,7 @@ add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n \t      break;\n \t    }\n \t}\n-      *pointer_map_insert (wd->decl_map, (void *) var) = val;\n+      wd->decl_map->put (var, val);\n     }\n }\n "}, {"sha": "35d958c18096633d740600199060b1f733d72391", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* c-typeck.c: Use hash_map instead of pointer_map.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* c-decl.c: Use hash_set instead of pointer_set."}, {"sha": "1b664bd0258b5ebd37655095f5a47bcd6c646942", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -11800,15 +11800,15 @@ c_clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n \t\t tree decl, tree placeholder)\n {\n   copy_body_data id;\n-  struct pointer_map_t *decl_map = pointer_map_create ();\n+  hash_map<tree, tree> decl_map;\n \n-  *pointer_map_insert (decl_map, omp_decl1) = placeholder;\n-  *pointer_map_insert (decl_map, omp_decl2) = decl;\n+  decl_map.put (omp_decl1, placeholder);\n+  decl_map.put (omp_decl2, decl);\n   memset (&id, 0, sizeof (id));\n   id.src_fn = DECL_CONTEXT (omp_decl1);\n   id.dst_fn = current_function_decl;\n   id.src_cfun = DECL_STRUCT_FUNCTION (id.src_fn);\n-  id.decl_map = decl_map;\n+  id.decl_map = &decl_map;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -11817,7 +11817,6 @@ c_clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n   id.transform_lang_insert_block = NULL;\n   id.eh_lp_nr = 0;\n   walk_tree (&stmt, copy_tree_body_r, &id, NULL);\n-  pointer_map_destroy (decl_map);\n   return stmt;\n }\n "}, {"sha": "2be6d60de58d91727e375b2f1970ddcf670d82ef", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n \n+#include \"hash-map.h\"\n #include \"is-a.h\"\n #include \"plugin-api.h\"\n #include \"vec.h\"\n@@ -1204,7 +1205,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n    can appear in multiple sets.  */\n struct cgraph_node_set_def\n {\n-  struct pointer_map_t *map;\n+  hash_map<cgraph_node *, size_t> *map;\n   vec<cgraph_node *> nodes;\n };\n \n@@ -1217,7 +1218,7 @@ class varpool_node;\n    can appear in multiple sets.  */\n struct varpool_node_set_def\n {\n-  struct pointer_map_t * map;\n+  hash_map<varpool_node *, size_t> * map;\n   vec<varpool_node *> nodes;\n };\n "}, {"sha": "193a9c2d848d3eda08243c37d45ef33dd4d2eeee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -1,3 +1,7 @@\n+2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* optimize.c, semantics.c: Use hash_map instead of pointer_map.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* class.c, cp-gimplify.c, cp-tree.h, decl.c, decl2.c, error.c,"}, {"sha": "6eeca4d64f942d25b8f6d6802fbd5d2a18ab08fd", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -86,7 +86,7 @@ clone_body (tree clone, tree fn, void *arg_map)\n   id.src_fn = fn;\n   id.dst_fn = clone;\n   id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n-  id.decl_map = (struct pointer_map_t *) arg_map;\n+  id.decl_map = static_cast<hash_map<tree, tree> *> (arg_map);\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -527,7 +527,7 @@ maybe_clone_body (tree fn)\n       tree parm;\n       tree clone_parm;\n       int parmno;\n-      struct pointer_map_t *decl_map;\n+      hash_map<tree, tree> *decl_map;\n       bool alias = false;\n \n       clone = fns[idx];\n@@ -587,7 +587,7 @@ maybe_clone_body (tree fn)\n \t    }\n \n           /* Remap the parameters.  */\n-          decl_map = pointer_map_create ();\n+          decl_map = new hash_map<tree, tree>;\n           for (parmno = 0,\n                 parm = DECL_ARGUMENTS (fn),\n                 clone_parm = DECL_ARGUMENTS (clone);\n@@ -600,7 +600,7 @@ maybe_clone_body (tree fn)\n                 {\n                   tree in_charge;\n                   in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n-                  *pointer_map_insert (decl_map, parm) = in_charge;\n+                  decl_map->put (parm, in_charge);\n                 }\n               else if (DECL_ARTIFICIAL (parm)\n                        && DECL_NAME (parm) == vtt_parm_identifier)\n@@ -611,19 +611,22 @@ maybe_clone_body (tree fn)\n                   if (DECL_HAS_VTT_PARM_P (clone))\n                     {\n                       DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n-                      *pointer_map_insert (decl_map, parm) = clone_parm;\n+                      decl_map->put (parm, clone_parm);\n                       clone_parm = DECL_CHAIN (clone_parm);\n                     }\n                   /* Otherwise, map the VTT parameter to `NULL'.  */\n                   else\n-                    *pointer_map_insert (decl_map, parm)\n-                       = fold_convert (TREE_TYPE (parm), null_pointer_node);\n+\t\t    {\n+\t\t      tree t\n+\t\t\t= fold_convert (TREE_TYPE (parm), null_pointer_node);\n+\t\t      decl_map->put (parm, t);\n+\t\t    }\n                 }\n               /* Map other parameters to their equivalents in the cloned\n                  function.  */\n               else\n                 {\n-                  *pointer_map_insert (decl_map, parm) = clone_parm;\n+                  decl_map->put (parm, clone_parm);\n                   clone_parm = DECL_CHAIN (clone_parm);\n                 }\n             }\n@@ -632,14 +635,14 @@ maybe_clone_body (tree fn)\n             {\n               parm = DECL_RESULT (fn);\n               clone_parm = DECL_RESULT (clone);\n-              *pointer_map_insert (decl_map, parm) = clone_parm;\n+              decl_map->put (parm, clone_parm);\n             }\n \n           /* Clone the body.  */\n           clone_body (clone, fn, decl_map);\n \n           /* Clean up.  */\n-          pointer_map_destroy (decl_map);\n+          delete decl_map;\n         }\n \n       /* The clone can throw iff the original function can throw.  */"}, {"sha": "4868d69014fef3e7012ce535228bb774d4a971a1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -4977,15 +4977,15 @@ clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n \t       tree decl, tree placeholder)\n {\n   copy_body_data id;\n-  struct pointer_map_t *decl_map = pointer_map_create ();\n+  hash_map<tree, tree> decl_map;\n \n-  *pointer_map_insert (decl_map, omp_decl1) = placeholder;\n-  *pointer_map_insert (decl_map, omp_decl2) = decl;\n+  decl_map.put (omp_decl1, placeholder);\n+  decl_map.put (omp_decl2, decl);\n   memset (&id, 0, sizeof (id));\n   id.src_fn = DECL_CONTEXT (omp_decl1);\n   id.dst_fn = current_function_decl;\n   id.src_cfun = DECL_STRUCT_FUNCTION (id.src_fn);\n-  id.decl_map = decl_map;\n+  id.decl_map = &decl_map;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -4994,7 +4994,6 @@ clone_omp_udr (tree stmt, tree omp_decl1, tree omp_decl2,\n   id.transform_lang_insert_block = NULL;\n   id.eh_lp_nr = 0;\n   walk_tree (&stmt, copy_tree_body_r, &id, NULL);\n-  pointer_map_destroy (decl_map);\n   return stmt;\n }\n "}, {"sha": "ec08e91219771e34ca4d02deac021deb39410c04", "filename": "gcc/except.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -527,7 +527,7 @@ struct duplicate_eh_regions_data\n {\n   duplicate_eh_regions_map label_map;\n   void *label_map_data;\n-  struct pointer_map_t *eh_map;\n+  hash_map<void *, void *> *eh_map;\n };\n \n static void\n@@ -536,12 +536,9 @@ duplicate_eh_regions_1 (struct duplicate_eh_regions_data *data,\n {\n   eh_landing_pad old_lp, new_lp;\n   eh_region new_r;\n-  void **slot;\n \n   new_r = gen_eh_region (old_r->type, outer);\n-  slot = pointer_map_insert (data->eh_map, (void *)old_r);\n-  gcc_assert (*slot == NULL);\n-  *slot = (void *)new_r;\n+  gcc_assert (!data->eh_map->put (old_r, new_r));\n \n   switch (old_r->type)\n     {\n@@ -586,9 +583,7 @@ duplicate_eh_regions_1 (struct duplicate_eh_regions_data *data,\n \tcontinue;\n \n       new_lp = gen_eh_landing_pad (new_r);\n-      slot = pointer_map_insert (data->eh_map, (void *)old_lp);\n-      gcc_assert (*slot == NULL);\n-      *slot = (void *)new_lp;\n+      gcc_assert (!data->eh_map->put (old_lp, new_lp));\n \n       new_lp->post_landing_pad\n \t= data->label_map (old_lp->post_landing_pad, data->label_map_data);\n@@ -609,7 +604,7 @@ duplicate_eh_regions_1 (struct duplicate_eh_regions_data *data,\n    that allows the caller to remap uses of both EH regions and\n    EH landing pads.  */\n \n-struct pointer_map_t *\n+hash_map<void *, void *> *\n duplicate_eh_regions (struct function *ifun,\n \t\t      eh_region copy_region, int outer_lp,\n \t\t      duplicate_eh_regions_map map, void *map_data)\n@@ -623,7 +618,7 @@ duplicate_eh_regions (struct function *ifun,\n \n   data.label_map = map;\n   data.label_map_data = map_data;\n-  data.eh_map = pointer_map_create ();\n+  data.eh_map = new hash_map<void *, void *>;\n \n   outer_region = get_eh_region_from_lp_number (outer_lp);\n "}, {"sha": "5c2aa3de9392f775cfefcc790c8bc3e4d775db1b", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #  define GCC_EXCEPT_H\n #endif\n \n+#include \"hash-map.h\"\n #include \"hashtab.h\"\n \n struct function;\n@@ -249,7 +250,7 @@ extern rtx expand_builtin_extend_pointer (tree);\n extern void expand_dw2_landing_pad_for_region (eh_region);\n \n typedef tree (*duplicate_eh_regions_map) (tree, void *);\n-extern struct pointer_map_t *duplicate_eh_regions\n+extern hash_map<void *, void *> *duplicate_eh_regions\n   (struct function *, eh_region, int, duplicate_eh_regions_map, void *);\n \n extern void sjlj_emit_function_exit_after (rtx);"}, {"sha": "b13b7f73675c427f362990ede7b43aaab411d538", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n@@ -373,7 +374,7 @@ enum count_phis_status\n };\n  \n /* Pointer map embodying a mapping from statements to candidates.  */\n-static struct pointer_map_t *stmt_cand_map;\n+static hash_map<gimple, slsr_cand_t> *stmt_cand_map;\n \n /* Obstack for candidates.  */\n static struct obstack cand_obstack;\n@@ -435,7 +436,7 @@ static hash_table<cand_chain_hasher> *base_cand_map;\n /* Pointer map used by tree_to_aff_combination_expand.  */\n static struct pointer_map_t *name_expansions;\n /* Pointer map embodying a mapping from bases to alternative bases.  */\n-static struct pointer_map_t *alt_base_map;\n+static hash_map<tree, tree> *alt_base_map;\n \n /* Given BASE, use the tree affine combiniation facilities to\n    find the underlying tree expression for BASE, with any\n@@ -447,7 +448,7 @@ static struct pointer_map_t *alt_base_map;\n static tree\n get_alternative_base (tree base)\n {\n-  tree *result = (tree *) pointer_map_contains (alt_base_map, base);\n+  tree *result = alt_base_map->get (base);\n \n   if (result == NULL)\n     {\n@@ -459,13 +460,9 @@ get_alternative_base (tree base)\n       aff.offset = 0;\n       expr = aff_combination_to_tree (&aff);\n \n-      result = (tree *) pointer_map_insert (alt_base_map, base);\n-      gcc_assert (!*result);\n+      gcc_assert (!alt_base_map->put (base, base == expr ? NULL : expr));\n \n-      if (expr == base)\n-\t*result = NULL;\n-      else\n-\t*result = expr;\n+      return expr == base ? NULL : expr;\n     }\n \n   return *result;\n@@ -724,7 +721,7 @@ base_cand_from_table (tree base_in)\n   if (!def)\n     return (slsr_cand_t) NULL;\n \n-  result = (slsr_cand_t *) pointer_map_contains (stmt_cand_map, def);\n+  result = stmt_cand_map->get (def);\n   \n   if (result && (*result)->kind != CAND_REF)\n     return *result;\n@@ -737,9 +734,7 @@ base_cand_from_table (tree base_in)\n static void\n add_cand_for_stmt (gimple gs, slsr_cand_t c)\n {\n-  void **slot = pointer_map_insert (stmt_cand_map, gs);\n-  gcc_assert (!*slot);\n-  *slot = c;\n+  gcc_assert (!stmt_cand_map->put (gs, c));\n }\n \f\n /* Given PHI which contains a phi statement, determine whether it\n@@ -3628,7 +3623,7 @@ pass_strength_reduction::execute (function *fun)\n   cand_vec.create (128);\n \n   /* Allocate the mapping from statements to candidate indices.  */\n-  stmt_cand_map = pointer_map_create ();\n+  stmt_cand_map = new hash_map<gimple, slsr_cand_t>;\n \n   /* Create the obstack where candidate chains will reside.  */\n   gcc_obstack_init (&chain_obstack);\n@@ -3637,7 +3632,7 @@ pass_strength_reduction::execute (function *fun)\n   base_cand_map = new hash_table<cand_chain_hasher> (500);\n \n   /* Allocate the mapping from bases to alternative bases.  */\n-  alt_base_map = pointer_map_create ();\n+  alt_base_map = new hash_map<tree, tree>;\n \n   /* Initialize the loop optimizer.  We need to detect flow across\n      back edges, and this gives us dominator information as well.  */\n@@ -3654,7 +3649,7 @@ pass_strength_reduction::execute (function *fun)\n       dump_cand_chains ();\n     }\n \n-  pointer_map_destroy (alt_base_map);\n+  delete alt_base_map;\n   free_affine_expand_cache (&name_expansions);\n \n   /* Analyze costs and make appropriate replacements.  */\n@@ -3664,7 +3659,7 @@ pass_strength_reduction::execute (function *fun)\n   delete base_cand_map;\n   base_cand_map = NULL;\n   obstack_free (&chain_obstack, NULL);\n-  pointer_map_destroy (stmt_cand_map);\n+  delete stmt_cand_map;\n   cand_vec.release ();\n   obstack_free (&cand_obstack, NULL);\n "}, {"sha": "ec48844b81f97129299f8d3cf475e6706ad40ce5", "filename": "gcc/hash-map.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -93,7 +93,7 @@ struct default_hashmap_traits\n   static void\n   mark_key_deleted (T *&k)\n     {\n-      k = static_cast<T *> (1);\n+      k = reinterpret_cast<T *> (1);\n     }\n \n   template<typename T>\n@@ -185,6 +185,11 @@ class hash_map\n       return e->m_value;\n     }\n \n+  void remove (const Key &k)\n+    {\n+      m_table.remove_elt_with_hash (k, Traits::hash (k));\n+    }\n+\n   /* Call the call back on each pair of key and value with the passed in\n      arg.  */\n \n@@ -196,6 +201,15 @@ class hash_map\n \tf ((*iter).m_key, (*iter).m_value, a);\n     }\n \n+  template<typename Arg, bool (*f)(const Key &, Value *, Arg)>\n+  void traverse (Arg a) const\n+    {\n+      for (typename hash_table<hash_entry>::iterator iter = m_table.begin ();\n+\t   iter != m_table.end (); ++iter)\n+\tif (!f ((*iter).m_key, &(*iter).m_value, a))\n+\t  break;\n+    }\n+\n private:\n   hash_table<hash_entry> m_table;\n };"}, {"sha": "265b88eaf8f52ffcdbc4201203687d19035f80d9", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -389,7 +389,7 @@ cgraph_node_set_new (void)\n   cgraph_node_set new_node_set;\n \n   new_node_set = XCNEW (struct cgraph_node_set_def);\n-  new_node_set->map = pointer_map_create ();\n+  new_node_set->map = new hash_map<cgraph_node *, size_t>;\n   new_node_set->nodes.create (0);\n   return new_node_set;\n }\n@@ -400,19 +400,17 @@ cgraph_node_set_new (void)\n void\n cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n {\n-  void **slot;\n+  bool existed_p;\n+  size_t &index = set->map->get_or_insert (node, &existed_p);\n \n-  slot = pointer_map_insert (set->map, node);\n-\n-  if (*slot)\n+  if (existed_p)\n     {\n-      int index = (size_t) *slot - 1;\n       gcc_checking_assert ((set->nodes[index]\n \t\t           == node));\n       return;\n     }\n \n-  *slot = (void *)(size_t) (set->nodes.length () + 1);\n+  index = set->nodes.length () + 1;\n \n   /* Insert into node vector.  */\n   set->nodes.safe_push (node);\n@@ -424,15 +422,14 @@ cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n void\n cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n {\n-  void **slot, **last_slot;\n   int index;\n   struct cgraph_node *last_node;\n \n-  slot = pointer_map_contains (set->map, node);\n+  size_t *slot = set->map->get (node);\n   if (slot == NULL || !*slot)\n     return;\n \n-  index = (size_t) *slot - 1;\n+  index = *slot - 1;\n   gcc_checking_assert (set->nodes[index]\n \t      \t       == node);\n \n@@ -441,16 +438,16 @@ cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n   last_node = set->nodes.pop ();\n   if (last_node != node)\n     {\n-      last_slot = pointer_map_contains (set->map, last_node);\n+      size_t *last_slot = set->map->get (last_node);\n       gcc_checking_assert (last_slot && *last_slot);\n-      *last_slot = (void *)(size_t) (index + 1);\n+      *last_slot = index + 1;\n \n       /* Move the last element to the original spot of NODE.  */\n       set->nodes[index] = last_node;\n     }\n \n   /* Remove element from hash table.  */\n-  *slot = NULL;\n+  set->map->remove (node);\n }\n \n \n@@ -460,14 +457,14 @@ cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n cgraph_node_set_iterator\n cgraph_node_set_find (cgraph_node_set set, struct cgraph_node *node)\n {\n-  void **slot;\n+  size_t *slot;\n   cgraph_node_set_iterator csi;\n \n-  slot = pointer_map_contains (set->map, node);\n+  slot = set->map->get (node);\n   if (slot == NULL || !*slot)\n     csi.index = (unsigned) ~0;\n   else\n-    csi.index = (size_t)*slot - 1;\n+    csi.index = *slot - 1;\n   csi.set = set;\n \n   return csi;\n@@ -505,7 +502,7 @@ void\n free_cgraph_node_set (cgraph_node_set set)\n {\n   set->nodes.release ();\n-  pointer_map_destroy (set->map);\n+  delete set->map;\n   free (set);\n }\n \n@@ -518,7 +515,7 @@ varpool_node_set_new (void)\n   varpool_node_set new_node_set;\n \n   new_node_set = XCNEW (struct varpool_node_set_def);\n-  new_node_set->map = pointer_map_create ();\n+  new_node_set->map = new hash_map<varpool_node *, size_t>;\n   new_node_set->nodes.create (0);\n   return new_node_set;\n }\n@@ -529,19 +526,18 @@ varpool_node_set_new (void)\n void\n varpool_node_set_add (varpool_node_set set, varpool_node *node)\n {\n-  void **slot;\n-\n-  slot = pointer_map_insert (set->map, node);\n+  bool existed;\n+  size_t &slot = set->map->get_or_insert (node, &existed);\n \n-  if (*slot)\n+  if (existed)\n     {\n-      int index = (size_t) *slot - 1;\n+      int index = slot - 1;\n       gcc_checking_assert ((set->nodes[index]\n \t\t           == node));\n       return;\n     }\n \n-  *slot = (void *)(size_t) (set->nodes.length () + 1);\n+  slot = set->nodes.length () + 1;\n \n   /* Insert into node vector.  */\n   set->nodes.safe_push (node);\n@@ -553,15 +549,14 @@ varpool_node_set_add (varpool_node_set set, varpool_node *node)\n void\n varpool_node_set_remove (varpool_node_set set, varpool_node *node)\n {\n-  void **slot, **last_slot;\n   int index;\n   varpool_node *last_node;\n \n-  slot = pointer_map_contains (set->map, node);\n+  size_t *slot = set->map->get (node);\n   if (slot == NULL || !*slot)\n     return;\n \n-  index = (size_t) *slot - 1;\n+  index = *slot - 1;\n   gcc_checking_assert (set->nodes[index]\n \t      \t       == node);\n \n@@ -570,16 +565,16 @@ varpool_node_set_remove (varpool_node_set set, varpool_node *node)\n   last_node = set->nodes.pop ();\n   if (last_node != node)\n     {\n-      last_slot = pointer_map_contains (set->map, last_node);\n+      size_t *last_slot = set->map->get (last_node);\n       gcc_checking_assert (last_slot && *last_slot);\n-      *last_slot = (void *)(size_t) (index + 1);\n+      *last_slot = index + 1;\n \n       /* Move the last element to the original spot of NODE.  */\n       set->nodes[index] = last_node;\n     }\n \n   /* Remove element from hash table.  */\n-  *slot = NULL;\n+  set->map->remove (node);\n }\n \n \n@@ -589,14 +584,13 @@ varpool_node_set_remove (varpool_node_set set, varpool_node *node)\n varpool_node_set_iterator\n varpool_node_set_find (varpool_node_set set, varpool_node *node)\n {\n-  void **slot;\n   varpool_node_set_iterator vsi;\n \n-  slot = pointer_map_contains (set->map, node);\n+  size_t *slot = set->map->get (node);\n   if (slot == NULL || !*slot)\n     vsi.index = (unsigned) ~0;\n   else\n-    vsi.index = (size_t)*slot - 1;\n+    vsi.index = *slot - 1;\n   vsi.set = set;\n \n   return vsi;\n@@ -625,7 +619,7 @@ void\n free_varpool_node_set (varpool_node_set set)\n {\n   set->nodes.release ();\n-  pointer_map_destroy (set->map);\n+  delete set->map;\n   free (set);\n }\n "}, {"sha": "12b649a7ded736458cb1dfd1ed54b8dd1b473977", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -93,7 +93,7 @@ lto_symtab_encoder_new (bool for_input)\n   lto_symtab_encoder_t encoder = XCNEW (struct lto_symtab_encoder_d);\n \n   if (!for_input)\n-    encoder->map = pointer_map_create ();\n+    encoder->map = new hash_map<symtab_node *, size_t>;\n   encoder->nodes.create (0);\n   return encoder;\n }\n@@ -106,7 +106,7 @@ lto_symtab_encoder_delete (lto_symtab_encoder_t encoder)\n {\n    encoder->nodes.release ();\n    if (encoder->map)\n-     pointer_map_destroy (encoder->map);\n+     delete encoder->map;\n    free (encoder);\n }\n \n@@ -120,7 +120,6 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n \t\t\t   symtab_node *node)\n {\n   int ref;\n-  void **slot;\n \n   if (!encoder->map)\n     {\n@@ -131,18 +130,17 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n       return ref;\n     }\n \n-  slot = pointer_map_contains (encoder->map, node);\n+  size_t *slot = encoder->map->get (node);\n   if (!slot || !*slot)\n     {\n       lto_encoder_entry entry = {node, false, false, false};\n       ref = encoder->nodes.length ();\n       if (!slot)\n-        slot = pointer_map_insert (encoder->map, node);\n-      *slot = (void *) (intptr_t) (ref + 1);\n+        encoder->map->put (node, ref + 1);\n       encoder->nodes.safe_push (entry);\n     }\n   else\n-    ref = (size_t) *slot - 1;\n+    ref = *slot - 1;\n \n   return ref;\n }\n@@ -153,32 +151,29 @@ bool\n lto_symtab_encoder_delete_node (lto_symtab_encoder_t encoder,\n \t\t\t        symtab_node *node)\n {\n-  void **slot, **last_slot;\n   int index;\n   lto_encoder_entry last_node;\n \n-  slot = pointer_map_contains (encoder->map, node);\n+  size_t *slot = encoder->map->get (node);\n   if (slot == NULL || !*slot)\n     return false;\n \n-  index = (size_t) *slot - 1;\n+  index = *slot - 1;\n   gcc_checking_assert (encoder->nodes[index].node == node);\n \n   /* Remove from vector. We do this by swapping node with the last element\n      of the vector.  */\n   last_node = encoder->nodes.pop ();\n   if (last_node.node != node)\n     {\n-      last_slot = pointer_map_contains (encoder->map, last_node.node);\n-      gcc_checking_assert (last_slot && *last_slot);\n-      *last_slot = (void *)(size_t) (index + 1);\n+      gcc_assert (encoder->map->put (last_node.node, index + 1));\n \n       /* Move the last element to the original spot of NODE.  */\n       encoder->nodes[index] = last_node;\n     }\n \n   /* Remove element from hash table.  */\n-  *slot = NULL;\n+  encoder->map->remove (node);\n   return true;\n }\n "}, {"sha": "7cab1cbc5e38a40ef3a234a4e7103ba6edd82722", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -443,7 +443,7 @@ struct lto_encoder_entry\n struct lto_symtab_encoder_d\n {\n   vec<lto_encoder_entry> nodes;\n-  pointer_map_t *map;\n+  hash_map<symtab_node *, size_t> *map;\n };\n \n typedef struct lto_symtab_encoder_d *lto_symtab_encoder_t;\n@@ -1032,8 +1032,8 @@ static inline int\n lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n \t\t\t   symtab_node *node)\n {\n-  void **slot = pointer_map_contains (encoder->map, node);\n-  return (slot && *slot ? (size_t) *(slot) - 1 : LCC_NOT_FOUND);\n+  size_t *slot = encoder->map->get (node);\n+  return (slot && *slot ? *(slot) - 1 : LCC_NOT_FOUND);\n }\n \n /* Return true if iterator LSE points to nothing.  */"}, {"sha": "0fe2a402d55aabd50e172fcfb8a7f4cff6addcd0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -812,16 +812,14 @@ is_reference (tree decl)\n static inline tree\n lookup_decl (tree var, omp_context *ctx)\n {\n-  tree *n;\n-  n = (tree *) pointer_map_contains (ctx->cb.decl_map, var);\n+  tree *n = ctx->cb.decl_map->get (var);\n   return *n;\n }\n \n static inline tree\n maybe_lookup_decl (const_tree var, omp_context *ctx)\n {\n-  tree *n;\n-  n = (tree *) pointer_map_contains (ctx->cb.decl_map, var);\n+  tree *n = ctx->cb.decl_map->get (const_cast<tree> (var));\n   return n ? *n : NULL_TREE;\n }\n \n@@ -1359,7 +1357,7 @@ new_omp_context (gimple stmt, omp_context *outer_ctx)\n       ctx->depth = 1;\n     }\n \n-  ctx->cb.decl_map = pointer_map_create ();\n+  ctx->cb.decl_map = new hash_map<tree, tree>;\n \n   return ctx;\n }\n@@ -1408,7 +1406,7 @@ delete_omp_context (splay_tree_value value)\n {\n   omp_context *ctx = (omp_context *) value;\n \n-  pointer_map_destroy (ctx->cb.decl_map);\n+  delete ctx->cb.decl_map;\n \n   if (ctx->field_map)\n     splay_tree_delete (ctx->field_map);\n@@ -6541,7 +6539,6 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gimple_stmt_iterator psi;\n       gimple phi;\n       edge re, ene;\n-      edge_var_map_vector *head;\n       edge_var_map *vm;\n       size_t i;\n \n@@ -6552,7 +6549,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n \t appropriate phi nodes in iter_part_bb instead.  */\n       se = single_pred_edge (fin_bb);\n       re = single_succ_edge (trip_update_bb);\n-      head = redirect_edge_var_map_vector (re);\n+      vec<edge_var_map> *head = redirect_edge_var_map_vector (re);\n       ene = single_succ_edge (entry_bb);\n \n       psi = gsi_start_phis (fin_bb);\n@@ -9219,7 +9216,7 @@ task_copyfn_remap_type (struct omp_taskcopy_context *tcctx, tree orig_type)\n       walk_tree (&DECL_FIELD_OFFSET (new_f), copy_tree_body_r,\n \t\t &tcctx->cb, NULL);\n       new_fields = new_f;\n-      *pointer_map_insert (tcctx->cb.decl_map, f) = new_f;\n+      tcctx->cb.decl_map->put (f, new_f);\n     }\n   TYPE_FIELDS (type) = nreverse (new_fields);\n   layout_type (type);\n@@ -9286,7 +9283,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n       tcctx.cb.copy_decl = task_copyfn_copy_decl;\n       tcctx.cb.eh_lp_nr = 0;\n       tcctx.cb.transform_call_graph_edges = CB_CGE_MOVE;\n-      tcctx.cb.decl_map = pointer_map_create ();\n+      tcctx.cb.decl_map = new hash_map<tree, tree>;\n       tcctx.ctx = ctx;\n \n       if (record_needs_remap)\n@@ -9311,12 +9308,12 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  tree *p;\n \n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  p = (tree *) pointer_map_contains (tcctx.cb.decl_map, decl);\n+\t  p = tcctx.cb.decl_map->get (decl);\n \t  if (p == NULL)\n \t    continue;\n \t  n = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \t  sf = (tree) n->value;\n-\t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n+\t  sf = *tcctx.cb.decl_map->get (sf);\n \t  src = build_simple_mem_ref_loc (loc, sarg);\n \t  src = omp_build_component_ref (src, sf);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (*p), *p, src);\n@@ -9335,11 +9332,11 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  break;\n \tf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n-\t  f = *(tree *) pointer_map_contains (tcctx.cb.decl_map, f);\n+\t  f = *tcctx.cb.decl_map->get (f);\n \tn = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \tsf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n-\t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n+\t  sf = *tcctx.cb.decl_map->get (sf);\n \tsrc = build_simple_mem_ref_loc (loc, sarg);\n \tsrc = omp_build_component_ref (src, sf);\n \tdst = build_simple_mem_ref_loc (loc, arg);\n@@ -9356,13 +9353,13 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  break;\n \tf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n-\t  f = *(tree *) pointer_map_contains (tcctx.cb.decl_map, f);\n+\t  f = *tcctx.cb.decl_map->get (f);\n \tn = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \tif (n != NULL)\n \t  {\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n-\t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n+\t      sf = *tcctx.cb.decl_map->get (sf);\n \t    src = build_simple_mem_ref_loc (loc, sarg);\n \t    src = omp_build_component_ref (src, sf);\n \t    if (use_pointer_for_field (decl, NULL) || is_reference (decl))\n@@ -9382,13 +9379,13 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \tn = splay_tree_lookup (ctx->field_map, (splay_tree_key) decl);\n \tf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n-\t  f = *(tree *) pointer_map_contains (tcctx.cb.decl_map, f);\n+\t  f = *tcctx.cb.decl_map->get (f);\n \tn = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \tif (n != NULL)\n \t  {\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n-\t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n+\t      sf = *tcctx.cb.decl_map->get (sf);\n \t    src = build_simple_mem_ref_loc (loc, sarg);\n \t    src = omp_build_component_ref (src, sf);\n \t    if (use_pointer_for_field (decl, NULL))\n@@ -9419,15 +9416,15 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  if (n == NULL)\n \t    continue;\n \t  f = (tree) n->value;\n-\t  f = *(tree *) pointer_map_contains (tcctx.cb.decl_map, f);\n+\t  f = *tcctx.cb.decl_map->get (f);\n \t  gcc_assert (DECL_HAS_VALUE_EXPR_P (decl));\n \t  ind = DECL_VALUE_EXPR (decl);\n \t  gcc_assert (TREE_CODE (ind) == INDIRECT_REF);\n \t  gcc_assert (DECL_P (TREE_OPERAND (ind, 0)));\n \t  n = splay_tree_lookup (ctx->sfield_map,\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  sf = (tree) n->value;\n-\t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n+\t  sf = *tcctx.cb.decl_map->get (sf);\n \t  src = build_simple_mem_ref_loc (loc, sarg);\n \t  src = omp_build_component_ref (src, sf);\n \t  src = build_simple_mem_ref_loc (loc, src);\n@@ -9438,7 +9435,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  n = splay_tree_lookup (ctx->field_map,\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  df = (tree) n->value;\n-\t  df = *(tree *) pointer_map_contains (tcctx.cb.decl_map, df);\n+\t  df = *tcctx.cb.decl_map->get (df);\n \t  ptr = build_simple_mem_ref_loc (loc, arg);\n \t  ptr = omp_build_component_ref (ptr, df);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (ptr), ptr,\n@@ -9450,7 +9447,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n   append_to_statement_list (t, &list);\n \n   if (tcctx.cb.decl_map)\n-    pointer_map_destroy (tcctx.cb.decl_map);\n+    delete tcctx.cb.decl_map;\n   pop_gimplify_context (NULL);\n   BIND_EXPR_BODY (bind) = list;\n   pop_cfun ();"}, {"sha": "34ebdc3658f35e66c8cc8f4d24534d0cdbb298e9", "filename": "gcc/predict.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cfgloop.h\"\n #include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-expr.h\"\n@@ -490,11 +491,6 @@ rtl_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n   return false;\n }\n \n-/* This map contains for a basic block the list of predictions for the\n-   outgoing edges.  */\n-\n-static struct pointer_map_t *bb_predictions;\n-\n /*  Structure representing predictions in tree level. */\n \n struct edge_prediction {\n@@ -504,19 +500,24 @@ struct edge_prediction {\n     int ep_probability;\n };\n \n+/* This map contains for a basic block the list of predictions for the\n+   outgoing edges.  */\n+\n+static hash_map<const_basic_block, edge_prediction *> *bb_predictions;\n+\n /* Return true if the one of outgoing edges is already predicted by\n    PREDICTOR.  */\n \n bool\n gimple_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n {\n   struct edge_prediction *i;\n-  void **preds = pointer_map_contains (bb_predictions, bb);\n+  edge_prediction **preds = bb_predictions->get (bb);\n \n   if (!preds)\n     return false;\n \n-  for (i = (struct edge_prediction *) *preds; i; i = i->ep_next)\n+  for (i = *preds; i; i = i->ep_next)\n     if (i->ep_predictor == predictor)\n       return true;\n   return false;\n@@ -618,10 +619,10 @@ gimple_predict_edge (edge e, enum br_predictor predictor, int probability)\n       && flag_guess_branch_prob && optimize)\n     {\n       struct edge_prediction *i = XNEW (struct edge_prediction);\n-      void **preds = pointer_map_insert (bb_predictions, e->src);\n+      edge_prediction *&preds = bb_predictions->get_or_insert (e->src);\n \n-      i->ep_next = (struct edge_prediction *) *preds;\n-      *preds = i;\n+      i->ep_next = preds;\n+      preds = i;\n       i->ep_probability = probability;\n       i->ep_predictor = predictor;\n       i->ep_edge = e;\n@@ -633,16 +634,14 @@ gimple_predict_edge (edge e, enum br_predictor predictor, int probability)\n void\n remove_predictions_associated_with_edge (edge e)\n {\n-  void **preds;\n-\n   if (!bb_predictions)\n     return;\n \n-  preds = pointer_map_contains (bb_predictions, e->src);\n+  edge_prediction **preds = bb_predictions->get (e->src);\n \n   if (preds)\n     {\n-      struct edge_prediction **prediction = (struct edge_prediction **) preds;\n+      struct edge_prediction **prediction = preds;\n       struct edge_prediction *next;\n \n       while (*prediction)\n@@ -664,13 +663,13 @@ remove_predictions_associated_with_edge (edge e)\n static void\n clear_bb_predictions (basic_block bb)\n {\n-  void **preds = pointer_map_contains (bb_predictions, bb);\n+  edge_prediction **preds = bb_predictions->get (bb);\n   struct edge_prediction *pred, *next;\n \n   if (!preds)\n     return;\n \n-  for (pred = (struct edge_prediction *) *preds; pred; pred = next)\n+  for (pred = *preds; pred; pred = next)\n     {\n       next = pred->ep_next;\n       free (pred);\n@@ -903,7 +902,6 @@ combine_predictions_for_bb (basic_block bb)\n   int nedges = 0;\n   edge e, first = NULL, second = NULL;\n   edge_iterator ei;\n-  void **preds;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n@@ -935,12 +933,12 @@ combine_predictions_for_bb (basic_block bb)\n   if (dump_file)\n     fprintf (dump_file, \"Predictions for bb %i\\n\", bb->index);\n \n-  preds = pointer_map_contains (bb_predictions, bb);\n+  edge_prediction **preds = bb_predictions->get (bb);\n   if (preds)\n     {\n       /* We implement \"first match\" heuristics and use probability guessed\n \t by predictor with smallest index.  */\n-      for (pred = (struct edge_prediction *) *preds; pred; pred = pred->ep_next)\n+      for (pred = *preds; pred; pred = pred->ep_next)\n \t{\n \t  enum br_predictor predictor = pred->ep_predictor;\n \t  int probability = pred->ep_probability;\n@@ -2243,14 +2241,14 @@ tree_bb_level_predictions (void)\n \n #ifdef ENABLE_CHECKING\n \n-/* Callback for pointer_map_traverse, asserts that the pointer map is\n+/* Callback for hash_map::traverse, asserts that the pointer map is\n    empty.  */\n \n-static bool\n-assert_is_empty (const void *key ATTRIBUTE_UNUSED, void **value,\n-\t\t void *data ATTRIBUTE_UNUSED)\n+bool\n+assert_is_empty (const_basic_block const &, edge_prediction *const &value,\n+\t\t void *)\n {\n-  gcc_assert (!*value);\n+  gcc_assert (!value);\n   return false;\n }\n #endif\n@@ -2375,7 +2373,7 @@ tree_estimate_probability (void)\n   create_preheaders (CP_SIMPLE_PREHEADERS);\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n-  bb_predictions = pointer_map_create ();\n+  bb_predictions = new hash_map<const_basic_block, edge_prediction *>;\n   tree_bb_level_predictions ();\n   record_loop_exits ();\n \n@@ -2389,9 +2387,9 @@ tree_estimate_probability (void)\n     combine_predictions_for_bb (bb);\n \n #ifdef ENABLE_CHECKING\n-  pointer_map_traverse (bb_predictions, assert_is_empty, NULL);\n+  bb_predictions->traverse<void *, assert_is_empty> (NULL);\n #endif\n-  pointer_map_destroy (bb_predictions);\n+  delete bb_predictions;\n   bb_predictions = NULL;\n \n   estimate_bb_frequencies (false);"}, {"sha": "cfa65273efbe245b1a10c12454c9150fdd9e40bd", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n+#include \"hash-map.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"trans-mem.h\"\n@@ -92,7 +93,7 @@ static const int initial_cfg_capacity = 20;\n    more persistent.  The key is getting notification of changes to\n    the CFG (particularly edge removal, creation and redirection).  */\n \n-static struct pointer_map_t *edge_to_cases;\n+static hash_map<edge, tree> *edge_to_cases;\n \n /* If we record edge_to_cases, this bitmap will hold indexes\n    of basic blocks that end in a GIMPLE_SWITCH which we touched\n@@ -1048,19 +1049,17 @@ make_cond_expr_edges (basic_block bb)\n    SWITCH_EXPRs and structure sharing rules, then free the hash table\n    element.  */\n \n-static bool\n-edge_to_cases_cleanup (const void *key ATTRIBUTE_UNUSED, void **value,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n+bool\n+edge_to_cases_cleanup (edge const &, tree const &value, void *)\n {\n   tree t, next;\n \n-  for (t = (tree) *value; t; t = next)\n+  for (t = value; t; t = next)\n     {\n       next = CASE_CHAIN (t);\n       CASE_CHAIN (t) = NULL;\n     }\n \n-  *value = NULL;\n   return true;\n }\n \n@@ -1070,7 +1069,7 @@ void\n start_recording_case_labels (void)\n {\n   gcc_assert (edge_to_cases == NULL);\n-  edge_to_cases = pointer_map_create ();\n+  edge_to_cases = new hash_map<edge, tree>;\n   touched_switch_bbs = BITMAP_ALLOC (NULL);\n }\n \n@@ -1089,8 +1088,8 @@ end_recording_case_labels (void)\n {\n   bitmap_iterator bi;\n   unsigned i;\n-  pointer_map_traverse (edge_to_cases, edge_to_cases_cleanup, NULL);\n-  pointer_map_destroy (edge_to_cases);\n+  edge_to_cases->traverse<void *, edge_to_cases_cleanup> (NULL);\n+  delete edge_to_cases;\n   edge_to_cases = NULL;\n   EXECUTE_IF_SET_IN_BITMAP (touched_switch_bbs, 0, i, bi)\n     {\n@@ -1113,17 +1112,17 @@ end_recording_case_labels (void)\n static tree\n get_cases_for_edge (edge e, gimple t)\n {\n-  void **slot;\n+  tree *slot;\n   size_t i, n;\n \n   /* If we are not recording cases, then we do not have CASE_LABEL_EXPR\n      chains available.  Return NULL so the caller can detect this case.  */\n   if (!recording_case_labels_p ())\n     return NULL;\n \n-  slot = pointer_map_contains (edge_to_cases, e);\n+  slot = edge_to_cases->get (e);\n   if (slot)\n-    return (tree) *slot;\n+    return *slot;\n \n   /* If we did not find E in the hash table, then this must be the first\n      time we have been queried for information about E & T.  Add all the\n@@ -1139,12 +1138,12 @@ get_cases_for_edge (edge e, gimple t)\n \n       /* Add it to the chain of CASE_LABEL_EXPRs referencing E, or create\n \t a new chain.  */\n-      slot = pointer_map_insert (edge_to_cases, this_edge);\n-      CASE_CHAIN (elt) = (tree) *slot;\n-      *slot = elt;\n+      tree &s = edge_to_cases->get_or_insert (this_edge);\n+      CASE_CHAIN (elt) = s;\n+      s = elt;\n     }\n \n-  return (tree) *pointer_map_contains (edge_to_cases, e);\n+  return *edge_to_cases->get (e);\n }\n \n /* Create the edges for a GIMPLE_SWITCH starting at block BB.  */\n@@ -2577,12 +2576,11 @@ last_and_only_stmt (basic_block bb)\n static void\n reinstall_phi_args (edge new_edge, edge old_edge)\n {\n-  edge_var_map_vector *v;\n   edge_var_map *vm;\n   int i;\n   gimple_stmt_iterator phis;\n \n-  v = redirect_edge_var_map_vector (old_edge);\n+  vec<edge_var_map> *v = redirect_edge_var_map_vector (old_edge);\n   if (!v)\n     return;\n \n@@ -6268,22 +6266,20 @@ gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n    The duplicates are recorded in VARS_MAP.  */\n \n static void\n-replace_by_duplicate_decl (tree *tp, struct pointer_map_t *vars_map,\n+replace_by_duplicate_decl (tree *tp, hash_map<tree, tree> *vars_map,\n \t\t\t   tree to_context)\n {\n   tree t = *tp, new_t;\n   struct function *f = DECL_STRUCT_FUNCTION (to_context);\n-  void **loc;\n \n   if (DECL_CONTEXT (t) == to_context)\n     return;\n \n-  loc = pointer_map_contains (vars_map, t);\n+  bool existed;\n+  tree &loc = vars_map->get_or_insert (t, &existed);\n \n-  if (!loc)\n+  if (!existed)\n     {\n-      loc = pointer_map_insert (vars_map, t);\n-\n       if (SSA_VAR_P (t))\n \t{\n \t  new_t = copy_var_decl (t, DECL_NAME (t), TREE_TYPE (t));\n@@ -6296,10 +6292,10 @@ replace_by_duplicate_decl (tree *tp, struct pointer_map_t *vars_map,\n \t}\n       DECL_CONTEXT (new_t) = to_context;\n \n-      *loc = new_t;\n+      loc = new_t;\n     }\n   else\n-    new_t = (tree) *loc;\n+    new_t = loc;\n \n   *tp = new_t;\n }\n@@ -6309,15 +6305,14 @@ replace_by_duplicate_decl (tree *tp, struct pointer_map_t *vars_map,\n    VARS_MAP maps old ssa names and var_decls to the new ones.  */\n \n static tree\n-replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n+replace_ssa_name (tree name, hash_map<tree, tree> *vars_map,\n \t\t  tree to_context)\n {\n-  void **loc;\n   tree new_name;\n \n   gcc_assert (!virtual_operand_p (name));\n \n-  loc = pointer_map_contains (vars_map, name);\n+  tree *loc = vars_map->get (name);\n \n   if (!loc)\n     {\n@@ -6335,11 +6330,10 @@ replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n \tnew_name = copy_ssa_name_fn (DECL_STRUCT_FUNCTION (to_context),\n \t\t\t\t     name, SSA_NAME_DEF_STMT (name));\n \n-      loc = pointer_map_insert (vars_map, name);\n-      *loc = new_name;\n+      vars_map->put (name, new_name);\n     }\n   else\n-    new_name = (tree) *loc;\n+    new_name = *loc;\n \n   return new_name;\n }\n@@ -6350,9 +6344,9 @@ struct move_stmt_d\n   tree new_block;\n   tree from_context;\n   tree to_context;\n-  struct pointer_map_t *vars_map;\n+  hash_map<tree, tree> *vars_map;\n   htab_t new_label_map;\n-  struct pointer_map_t *eh_map;\n+  hash_map<void *, void *> *eh_map;\n   bool remap_decls_p;\n };\n \n@@ -6429,11 +6423,9 @@ static int\n move_stmt_eh_region_nr (int old_nr, struct move_stmt_d *p)\n {\n   eh_region old_r, new_r;\n-  void **slot;\n \n   old_r = get_eh_region_from_number (old_nr);\n-  slot = pointer_map_contains (p->eh_map, old_r);\n-  new_r = (eh_region) *slot;\n+  new_r = static_cast<eh_region> (*p->eh_map->get (old_r));\n \n   return new_r->index;\n }\n@@ -6767,7 +6759,7 @@ new_label_mapper (tree decl, void *data)\n    subblocks.  */\n \n static void\n-replace_block_vars_by_duplicates (tree block, struct pointer_map_t *vars_map,\n+replace_block_vars_by_duplicates (tree block, hash_map<tree, tree> *vars_map,\n \t\t\t\t  tree to_context)\n {\n   tree *tp, t;\n@@ -6845,7 +6837,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   edge e;\n   edge_iterator ei;\n   htab_t new_label_map;\n-  struct pointer_map_t *vars_map, *eh_map;\n+  hash_map<void *, void *> *eh_map;\n   struct loop *loop = entry_bb->loop_father;\n   struct loop *loop0 = get_loop (saved_cfun, 0);\n   struct move_stmt_d d;\n@@ -6989,14 +6981,14 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   /* Move blocks from BBS into DEST_CFUN.  */\n   gcc_assert (bbs.length () >= 2);\n   after = dest_cfun->cfg->x_entry_block_ptr;\n-  vars_map = pointer_map_create ();\n+  hash_map<tree, tree> vars_map;\n \n   memset (&d, 0, sizeof (d));\n   d.orig_block = orig_block;\n   d.new_block = DECL_INITIAL (dest_cfun->decl);\n   d.from_context = cfun->decl;\n   d.to_context = dest_cfun->decl;\n-  d.vars_map = vars_map;\n+  d.vars_map = &vars_map;\n   d.new_label_map = new_label_map;\n   d.eh_map = eh_map;\n   d.remap_decls_p = true;\n@@ -7051,13 +7043,12 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n     }\n \n   replace_block_vars_by_duplicates (DECL_INITIAL (dest_cfun->decl),\n-\t\t\t\t    vars_map, dest_cfun->decl);\n+\t\t\t\t    &vars_map, dest_cfun->decl);\n \n   if (new_label_map)\n     htab_delete (new_label_map);\n   if (eh_map)\n-    pointer_map_destroy (eh_map);\n-  pointer_map_destroy (vars_map);\n+    delete eh_map;\n \n   /* Rewire the entry and exit blocks.  The successor to the entry\n      block turns into the successor of DEST_FN's ENTRY_BLOCK_PTR in"}, {"sha": "2b6927e0437030a0d405adcb268fb77cbcf571c6", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -865,16 +865,14 @@ remove_forwarder_block_with_phi (basic_block bb)\n \n \t  if (TREE_CODE (def) == SSA_NAME)\n \t    {\n-\t      edge_var_map_vector *head;\n-\t      edge_var_map *vm;\n-\t      size_t i;\n-\n \t      /* If DEF is one of the results of PHI nodes removed during\n \t\t redirection, replace it with the PHI argument that used\n \t\t to be on E.  */\n-\t      head = redirect_edge_var_map_vector (e);\n-\t      FOR_EACH_VEC_SAFE_ELT (head, i, vm)\n+\t      vec<edge_var_map> *head = redirect_edge_var_map_vector (e);\n+\t      size_t length = head ? head->length () : 0;\n+\t      for (size_t i = 0; i < length; i++)\n \t\t{\n+\t\t  edge_var_map *vm = &(*head)[i];\n \t\t  tree old_arg = redirect_edge_var_map_result (vm);\n \t\t  tree new_arg = redirect_edge_var_map_def (vm);\n "}, {"sha": "db2818490a97bbbbaa582a8b2197ba75943f213f", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -406,7 +406,7 @@ struct leh_tf_state\n   size_t goto_queue_active;\n \n   /* Pointer map to help in searching goto_queue when it is large.  */\n-  struct pointer_map_t *goto_queue_map;\n+  hash_map<gimple, goto_queue_node *> *goto_queue_map;\n \n   /* The set of unique labels seen as entries in the goto queue.  */\n   vec<tree> dest_array;\n@@ -441,7 +441,6 @@ static gimple_seq\n find_goto_replacement (struct leh_tf_state *tf, treemple stmt)\n {\n   unsigned int i;\n-  void **slot;\n \n   if (tf->goto_queue_active < LARGE_GOTO_QUEUE)\n     {\n@@ -456,19 +455,18 @@ find_goto_replacement (struct leh_tf_state *tf, treemple stmt)\n \n   if (!tf->goto_queue_map)\n     {\n-      tf->goto_queue_map = pointer_map_create ();\n+      tf->goto_queue_map = new hash_map<gimple, goto_queue_node *>;\n       for (i = 0; i < tf->goto_queue_active; i++)\n \t{\n-\t  slot = pointer_map_insert (tf->goto_queue_map,\n-                                     tf->goto_queue[i].stmt.g);\n-          gcc_assert (*slot == NULL);\n-\t  *slot = &tf->goto_queue[i];\n+\t  bool existed = tf->goto_queue_map->put (tf->goto_queue[i].stmt.g,\n+\t\t\t\t\t\t  &tf->goto_queue[i]);\n+\t  gcc_assert (!existed);\n \t}\n     }\n \n-  slot = pointer_map_contains (tf->goto_queue_map, stmt.g);\n+  goto_queue_node **slot = tf->goto_queue_map->get (stmt.g);\n   if (slot != NULL)\n-    return (((struct goto_queue_node *) *slot)->repl_stmt);\n+    return ((*slot)->repl_stmt);\n \n   return NULL;\n }\n@@ -1372,7 +1370,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   tree tmp;\n   gimple switch_stmt;\n   gimple_seq finally;\n-  struct pointer_map_t *cont_map = NULL;\n+  hash_map<tree, gimple> *cont_map = NULL;\n   /* The location of the TRY_FINALLY stmt.  */\n   location_t tf_loc = gimple_location (tf->try_finally_expr);\n   /* The location of the finally block.  */\n@@ -1511,40 +1509,35 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       if (case_label_vec.length () <= case_index || !case_label_vec[case_index])\n         {\n           tree case_lab;\n-          void **slot;\n \t  tmp = build_int_cst (integer_type_node, switch_id);\n           case_lab = build_case_label (tmp, NULL,\n \t\t\t\t       create_artificial_label (tf_loc));\n           /* We store the cont_stmt in the pointer map, so that we can recover\n              it in the loop below.  */\n           if (!cont_map)\n-            cont_map = pointer_map_create ();\n-          slot = pointer_map_insert (cont_map, case_lab);\n-          *slot = q->cont_stmt;\n+            cont_map = new hash_map<tree, gimple>;\n+          cont_map->put (case_lab, q->cont_stmt);\n           case_label_vec.quick_push (case_lab);\n         }\n     }\n   for (j = last_case_index; j < last_case_index + nlabels; j++)\n     {\n       gimple cont_stmt;\n-      void **slot;\n \n       last_case = case_label_vec[j];\n \n       gcc_assert (last_case);\n       gcc_assert (cont_map);\n \n-      slot = pointer_map_contains (cont_map, last_case);\n-      gcc_assert (slot);\n-      cont_stmt = *(gimple *) slot;\n+      cont_stmt = *cont_map->get (last_case);\n \n       x = gimple_build_label (CASE_LABEL (last_case));\n       gimple_seq_add_stmt (&switch_body, x);\n       gimple_seq_add_stmt (&switch_body, cont_stmt);\n       maybe_record_in_goto_queue (state, cont_stmt);\n     }\n   if (cont_map)\n-    pointer_map_destroy (cont_map);\n+    delete cont_map;\n \n   replace_goto_queue (tf);\n \n@@ -1734,7 +1727,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   this_tf.dest_array.release ();\n   free (this_tf.goto_queue);\n   if (this_tf.goto_queue_map)\n-    pointer_map_destroy (this_tf.goto_queue_map);\n+    delete this_tf.goto_queue_map;\n \n   /* If there was an old (aka outer) eh_seq, append the current eh_seq.\n      If there was no old eh_seq, then the append is trivially already done.  */\n@@ -2921,10 +2914,10 @@ maybe_clean_or_replace_eh_stmt (gimple old_stmt, gimple new_stmt)\n bool\n maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple new_stmt,\n \t\t\t    struct function *old_fun, gimple old_stmt,\n-\t\t\t    struct pointer_map_t *map, int default_lp_nr)\n+\t\t\t    hash_map<void *, void *> *map,\n+\t\t\t    int default_lp_nr)\n {\n   int old_lp_nr, new_lp_nr;\n-  void **slot;\n \n   if (!stmt_could_throw_p (new_stmt))\n     return false;\n@@ -2941,17 +2934,15 @@ maybe_duplicate_eh_stmt_fn (struct function *new_fun, gimple new_stmt,\n       eh_landing_pad old_lp, new_lp;\n \n       old_lp = (*old_fun->eh->lp_array)[old_lp_nr];\n-      slot = pointer_map_contains (map, old_lp);\n-      new_lp = (eh_landing_pad) *slot;\n+      new_lp = static_cast<eh_landing_pad> (*map->get (old_lp));\n       new_lp_nr = new_lp->index;\n     }\n   else\n     {\n       eh_region old_r, new_r;\n \n       old_r = (*old_fun->eh->region_array)[-old_lp_nr];\n-      slot = pointer_map_contains (map, old_r);\n-      new_r = (eh_region) *slot;\n+      new_r = static_cast<eh_region> (*map->get (old_r));\n       new_lp_nr = -new_r->index;\n     }\n \n@@ -3154,7 +3145,7 @@ make_pass_refactor_eh (gcc::context *ctxt)\n /* At the end of gimple optimization, we can lower RESX.  */\n \n static bool\n-lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n+lower_resx (basic_block bb, gimple stmt, hash_map<eh_region, tree> *mnt_map)\n {\n   int lp_nr;\n   eh_region src_r, dst_r;\n@@ -3199,14 +3190,13 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n       if (lp_nr < 0)\n \t{\n \t  basic_block new_bb;\n-\t  void **slot;\n \t  tree lab;\n \n \t  /* We are resuming into a MUST_NOT_CALL region.  Expand a call to\n \t     the failure decl into a new block, if needed.  */\n \t  gcc_assert (dst_r->type == ERT_MUST_NOT_THROW);\n \n-\t  slot = pointer_map_contains (mnt_map, dst_r);\n+\t  tree *slot = mnt_map->get (dst_r);\n \t  if (slot == NULL)\n \t    {\n \t      gimple_stmt_iterator gsi2;\n@@ -3221,12 +3211,11 @@ lower_resx (basic_block bb, gimple stmt, struct pointer_map_t *mnt_map)\n \t      gimple_set_location (x, dst_r->u.must_not_throw.failure_loc);\n \t      gsi_insert_after (&gsi2, x, GSI_CONTINUE_LINKING);\n \n-\t      slot = pointer_map_insert (mnt_map, dst_r);\n-\t      *slot = lab;\n+\t      mnt_map->put (dst_r, lab);\n \t    }\n \t  else\n \t    {\n-\t      lab = (tree) *slot;\n+\t      lab = *slot;\n \t      new_bb = label_to_block (lab);\n \t    }\n \n@@ -3334,24 +3323,21 @@ unsigned\n pass_lower_resx::execute (function *fun)\n {\n   basic_block bb;\n-  struct pointer_map_t *mnt_map;\n   bool dominance_invalidated = false;\n   bool any_rewritten = false;\n \n-  mnt_map = pointer_map_create ();\n+  hash_map<eh_region, tree> mnt_map;\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple last = last_stmt (bb);\n       if (last && is_gimple_resx (last))\n \t{\n-\t  dominance_invalidated |= lower_resx (bb, last, mnt_map);\n+\t  dominance_invalidated |= lower_resx (bb, last, &mnt_map);\n \t  any_rewritten = true;\n \t}\n     }\n \n-  pointer_map_destroy (mnt_map);\n-\n   if (dominance_invalidated)\n     {\n       free_dominance_info (CDI_DOMINATORS);"}, {"sha": "51c2adcc86e7062832590019b416bc41f05a2ab5", "filename": "gcc/tree-eh.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-eh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-eh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -20,6 +20,10 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_EH_H\n #define GCC_TREE_EH_H\n \n+#include \"hash-map.h\"\n+\n+typedef struct eh_region_d *eh_region;\n+\n extern void using_eh_for_cleanups (void);\n extern void add_stmt_to_eh_lp (gimple, int);\n extern bool remove_stmt_from_eh_lp_fn (struct function *, gimple);\n@@ -43,7 +47,7 @@ extern bool maybe_clean_eh_stmt (gimple);\n extern bool maybe_clean_or_replace_eh_stmt (gimple, gimple);\n extern bool maybe_duplicate_eh_stmt_fn (struct function *, gimple,\n \t\t\t\t\tstruct function *, gimple,\n-\t\t\t\t\tstruct pointer_map_t *, int);\n+\t\t\t\t\thash_map<void *, void *> *, int);\n extern bool maybe_duplicate_eh_stmt (gimple, gimple);\n extern void maybe_remove_unreachable_handlers (void);\n extern bool verify_eh_edges (gimple);"}, {"sha": "e2b7990b765e8b626e77511f7c7a2a0d495540ee", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 48, "deletions": 54, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -135,7 +135,7 @@ static tree declare_return_variable (copy_body_data *, tree, tree, basic_block);\n static void remap_block (tree *, copy_body_data *);\n static void copy_bind_expr (tree *, int *, copy_body_data *);\n static void declare_inline_vars (tree, tree);\n-static void remap_save_expr (tree *, void *, int *);\n+static void remap_save_expr (tree *, hash_map<tree, tree> *, int *);\n static void prepend_lexical_block (tree current_block, tree new_block);\n static tree copy_decl_to_var (tree, copy_body_data *);\n static tree copy_result_decl_to_var (tree, copy_body_data *);\n@@ -149,12 +149,12 @@ static bool delete_unreachable_blocks_update_callgraph (copy_body_data *id);\n void\n insert_decl_map (copy_body_data *id, tree key, tree value)\n {\n-  *pointer_map_insert (id->decl_map, key) = value;\n+  id->decl_map->put (key, value);\n \n   /* Always insert an identity map as well.  If we see this same new\n      node again, we won't want to duplicate it a second time.  */\n   if (key != value)\n-    *pointer_map_insert (id->decl_map, value) = value;\n+    id->decl_map->put (value, value);\n }\n \n /* Insert a tree->tree mapping for ID.  This is only used for\n@@ -176,9 +176,9 @@ insert_debug_decl_map (copy_body_data *id, tree key, tree value)\n   gcc_assert (TREE_CODE (value) == VAR_DECL);\n \n   if (!id->debug_map)\n-    id->debug_map = pointer_map_create ();\n+    id->debug_map = new hash_map<tree, tree>;\n \n-  *pointer_map_insert (id->debug_map, key) = value;\n+  id->debug_map->put (key, value);\n }\n \n /* If nonzero, we're remapping the contents of inlined debug\n@@ -197,7 +197,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n \n-  n = (tree *) pointer_map_contains (id->decl_map, name);\n+  n = id->decl_map->get (name);\n   if (n)\n     return unshare_expr (*n);\n \n@@ -213,7 +213,7 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t  gimple_stmt_iterator gsi;\n \t  tree val = SSA_NAME_VAR (name);\n \n-\t  n = (tree *) pointer_map_contains (id->decl_map, val);\n+\t  n = id->decl_map->get (val);\n \t  if (n != NULL)\n \t    val = *n;\n \t  if (TREE_CODE (val) != PARM_DECL)\n@@ -342,7 +342,7 @@ remap_decl (tree decl, copy_body_data *id)\n \n   /* See if we have remapped this declaration.  */\n \n-  n = (tree *) pointer_map_contains (id->decl_map, decl);\n+  n = id->decl_map->get (decl);\n \n   if (!n && processing_debug_stmt)\n     {\n@@ -562,7 +562,7 @@ remap_type (tree type, copy_body_data *id)\n     return type;\n \n   /* See if we have remapped this type.  */\n-  node = (tree *) pointer_map_contains (id->decl_map, type);\n+  node = id->decl_map->get (type);\n   if (node)\n     return *node;\n \n@@ -887,7 +887,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       /* If the enclosing record type is variably_modified_type_p, the field\n \t has already been remapped.  Otherwise, it need not be.  */\n-      tree *n = (tree *) pointer_map_contains (id->decl_map, *tp);\n+      tree *n = id->decl_map->get (*tp);\n       if (n)\n \t*tp = *n;\n       *walk_subtrees = 0;\n@@ -981,8 +981,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n       if (old_block)\n \t{\n \t  tree *n;\n-\t  n = (tree *) pointer_map_contains (id->decl_map,\n-\t\t\t\t\t     TREE_BLOCK (*tp));\n+\t  n = id->decl_map->get (TREE_BLOCK (*tp));\n \t  if (n)\n \t    new_block = *n;\n \t}\n@@ -1108,7 +1107,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  tree decl = TREE_OPERAND (*tp, 0), value;\n \t  tree *n;\n \n-\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n+\t  n = id->decl_map->get (decl);\n \t  if (n)\n \t    {\n \t      value = *n;\n@@ -1125,7 +1124,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  /* Get rid of *& from inline substitutions that can happen when a\n \t     pointer argument is an ADDR_EXPR.  */\n \t  tree decl = TREE_OPERAND (*tp, 0);\n-\t  tree *n = (tree *) pointer_map_contains (id->decl_map, decl);\n+\t  tree *n = id->decl_map->get (decl);\n \t  if (n)\n \t    {\n \t      /* If we happen to get an ADDR_EXPR in n->value, strip\n@@ -1206,8 +1205,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  if (TREE_BLOCK (*tp))\n \t    {\n \t      tree *n;\n-\t      n = (tree *) pointer_map_contains (id->decl_map,\n-\t\t\t\t\t\t TREE_BLOCK (*tp));\n+\t      n = id->decl_map->get (TREE_BLOCK (*tp));\n \t      if (n)\n \t\tnew_block = *n;\n \t    }\n@@ -1261,11 +1259,9 @@ static int\n remap_eh_region_nr (int old_nr, copy_body_data *id)\n {\n   eh_region old_r, new_r;\n-  void **slot;\n \n   old_r = get_eh_region_from_number_fn (id->src_cfun, old_nr);\n-  slot = pointer_map_contains (id->eh_map, old_r);\n-  new_r = (eh_region) *slot;\n+  new_r = static_cast<eh_region> (*id->eh_map->get (old_r));\n \n   return new_r->index;\n }\n@@ -1483,7 +1479,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  tree decl = gimple_assign_lhs (stmt), value;\n \t  tree *n;\n \n-\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n+\t  n = id->decl_map->get (decl);\n \t  if (n)\n \t    {\n \t      value = *n;\n@@ -1597,7 +1593,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n   if (gimple_block (copy))\n     {\n       tree *n;\n-      n = (tree *) pointer_map_contains (id->decl_map, gimple_block (copy));\n+      n = id->decl_map->get (gimple_block (copy));\n       gcc_assert (n);\n       gimple_set_block (copy, *n);\n     }\n@@ -2191,8 +2187,7 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t      if (LOCATION_BLOCK (locus))\n \t\t{\n \t\t  tree *n;\n-\t\t  n = (tree *) pointer_map_contains (id->decl_map,\n-\t\t\tLOCATION_BLOCK (locus));\n+\t\t  n = id->decl_map->get (LOCATION_BLOCK (locus));\n \t\t  gcc_assert (n);\n \t\t  if (*n)\n \t\t    locus = COMBINE_LOCATION_DATA (line_table, locus, *n);\n@@ -2638,7 +2633,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   if (id->eh_map)\n     {\n-      pointer_map_destroy (id->eh_map);\n+      delete id->eh_map;\n       id->eh_map = NULL;\n     }\n \n@@ -2659,7 +2654,7 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n \n   if (gimple_block (stmt))\n     {\n-      n = (tree *) pointer_map_contains (id->decl_map, gimple_block (stmt));\n+      n = id->decl_map->get (gimple_block (stmt));\n       gimple_set_block (stmt, n ? *n : id->block);\n     }\n \n@@ -2675,14 +2670,14 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n     t = gimple_debug_bind_get_var (stmt);\n \n   if (TREE_CODE (t) == PARM_DECL && id->debug_map\n-      && (n = (tree *) pointer_map_contains (id->debug_map, t)))\n+      && (n = id->debug_map->get (t)))\n     {\n       gcc_assert (TREE_CODE (*n) == VAR_DECL);\n       t = *n;\n     }\n   else if (TREE_CODE (t) == VAR_DECL\n \t   && !is_global_var (t)\n-\t   && !pointer_map_contains (id->decl_map, t))\n+\t   && !id->decl_map->get (t))\n     /* T is a non-localized variable.  */;\n   else\n     walk_tree (&t, remap_gimple_op_r, &wi, NULL);\n@@ -3076,7 +3071,7 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n      parameter following the array.  */\n   for (p = parms, i = 0; p; p = DECL_CHAIN (p), i++)\n     {\n-      tree *varp = (tree *) pointer_map_contains (id->decl_map, p);\n+      tree *varp = id->decl_map->get (p);\n       if (varp\n \t  && TREE_CODE (*varp) == VAR_DECL)\n \t{\n@@ -3089,7 +3084,7 @@ initialize_inlined_parameters (copy_body_data *id, gimple stmt,\n \t     by the parameter setup.  */\n \t  if (def)\n \t    {\n-\t      tree *defp = (tree *) pointer_map_contains (id->decl_map, def);\n+\t      tree *defp = id->decl_map->get (def);\n \t      if (defp\n \t\t  && TREE_CODE (*defp) == SSA_NAME\n \t\t  && SSA_NAME_VAR (*defp) == var)\n@@ -4135,7 +4130,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n {\n   tree use_retvar;\n   tree fn;\n-  struct pointer_map_t *st, *dst;\n+  hash_map<tree, tree> *dst;\n+  hash_map<tree, tree> *st = NULL;\n   tree return_slot;\n   tree modify_dest;\n   location_t saved_location;\n@@ -4291,7 +4287,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n   st = id->decl_map;\n-  id->decl_map = pointer_map_create ();\n+  id->decl_map = new hash_map<tree, tree>;\n   dst = id->debug_map;\n   id->debug_map = NULL;\n \n@@ -4415,10 +4411,10 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   /* Clean up.  */\n   if (id->debug_map)\n     {\n-      pointer_map_destroy (id->debug_map);\n+      delete id->debug_map;\n       id->debug_map = dst;\n     }\n-  pointer_map_destroy (id->decl_map);\n+  delete id->decl_map;\n   id->decl_map = st;\n \n   /* Unlink the calls virtual operands before replacing it.  */\n@@ -4772,24 +4768,23 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n    the function into which the copy will be placed.  */\n \n static void\n-remap_save_expr (tree *tp, void *st_, int *walk_subtrees)\n+remap_save_expr (tree *tp, hash_map<tree, tree> *st, int *walk_subtrees)\n {\n-  struct pointer_map_t *st = (struct pointer_map_t *) st_;\n   tree *n;\n   tree t;\n \n   /* See if we already encountered this SAVE_EXPR.  */\n-  n = (tree *) pointer_map_contains (st, *tp);\n+  n = st->get (*tp);\n \n   /* If we didn't already remap this SAVE_EXPR, do so now.  */\n   if (!n)\n     {\n       t = copy_node (*tp);\n \n       /* Remember this SAVE_EXPR.  */\n-      *pointer_map_insert (st, *tp) = t;\n+      st->put (*tp, t);\n       /* Make sure we don't remap an already-remapped SAVE_EXPR.  */\n-      *pointer_map_insert (st, t) = t;\n+      st->put (t, t);\n     }\n   else\n     {\n@@ -4836,7 +4831,7 @@ replace_locals_op (tree *tp, int *walk_subtrees, void *data)\n {\n   struct walk_stmt_info *wi = (struct walk_stmt_info*) data;\n   copy_body_data *id = (copy_body_data *) wi->info;\n-  struct pointer_map_t *st = id->decl_map;\n+  hash_map<tree, tree> *st = id->decl_map;\n   tree *n;\n   tree expr = *tp;\n \n@@ -4846,7 +4841,7 @@ replace_locals_op (tree *tp, int *walk_subtrees, void *data)\n       || TREE_CODE (expr) == LABEL_DECL)\n     {\n       /* Lookup the declaration.  */\n-      n = (tree *) pointer_map_contains (st, expr);\n+      n = st->get (expr);\n \n       /* If it's there, remap it.  */\n       if (n)\n@@ -4928,7 +4923,7 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   memset (&id, 0, sizeof (id));\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n-  id.decl_map = pointer_map_create ();\n+  id.decl_map = new hash_map<tree, tree>;\n   id.debug_map = NULL;\n \n   id.copy_decl = copy_decl_no_change;\n@@ -4953,9 +4948,9 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   walk_gimple_seq (copy, replace_locals_stmt, replace_locals_op, &wi);\n \n   /* Clean up.  */\n-  pointer_map_destroy (id.decl_map);\n+  delete id.decl_map;\n   if (id.debug_map)\n-    pointer_map_destroy (id.debug_map);\n+    delete id.debug_map;\n \n   return copy;\n }\n@@ -5145,7 +5140,7 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n         *parg = new_tree;\n \tparg = &DECL_CHAIN (new_tree);\n       }\n-    else if (!pointer_map_contains (id->decl_map, arg))\n+    else if (!id->decl_map->get (arg))\n       {\n \t/* Make an equivalent VAR_DECL.  If the argument was used\n \t   as temporary variable later in function, the uses will be\n@@ -5368,7 +5363,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   /* Generate a new name for the new version. */\n   id.statements_to_fold = new hash_set<gimple>;\n \n-  id.decl_map = pointer_map_create ();\n+  id.decl_map = new hash_map<tree, tree>;\n   id.debug_map = NULL;\n   id.src_fn = old_decl;\n   id.dst_fn = new_decl;\n@@ -5530,9 +5525,9 @@ tree_function_versioning (tree old_decl, tree new_decl,\n     }\n \n   /* Clean up.  */\n-  pointer_map_destroy (id.decl_map);\n+  delete id.decl_map;\n   if (id.debug_map)\n-    pointer_map_destroy (id.debug_map);\n+    delete id.debug_map;\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n@@ -5587,22 +5582,22 @@ maybe_inline_call_in_expr (tree exp)\n   /* We can only try to inline \"const\" functions.  */\n   if (fn && TREE_READONLY (fn) && DECL_SAVED_TREE (fn))\n     {\n-      struct pointer_map_t *decl_map = pointer_map_create ();\n       call_expr_arg_iterator iter;\n       copy_body_data id;\n       tree param, arg, t;\n+      hash_map<tree, tree> decl_map;\n \n       /* Remap the parameters.  */\n       for (param = DECL_ARGUMENTS (fn), arg = first_call_expr_arg (exp, &iter);\n \t   param;\n \t   param = DECL_CHAIN (param), arg = next_call_expr_arg (&iter))\n-\t*pointer_map_insert (decl_map, param) = arg;\n+\tdecl_map.put (param, arg);\n \n       memset (&id, 0, sizeof (id));\n       id.src_fn = fn;\n       id.dst_fn = current_function_decl;\n       id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n-      id.decl_map = decl_map;\n+      id.decl_map = &decl_map;\n \n       id.copy_decl = copy_decl_no_change;\n       id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -5620,7 +5615,6 @@ maybe_inline_call_in_expr (tree exp)\n       id.eh_lp_nr = 0;\n \n       t = copy_tree_body (&id);\n-      pointer_map_destroy (decl_map);\n \n       /* We can only return something suitable for use in a GENERIC\n \t expression tree.  */\n@@ -5642,15 +5636,15 @@ build_duplicate_type (tree type)\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n   id.src_cfun = cfun;\n-  id.decl_map = pointer_map_create ();\n+  id.decl_map = new hash_map<tree, tree>;\n   id.debug_map = NULL;\n   id.copy_decl = copy_decl_no_change;\n \n   type = remap_type_1 (type, &id);\n \n-  pointer_map_destroy (id.decl_map);\n+  delete id.decl_map;\n   if (id.debug_map)\n-    pointer_map_destroy (id.debug_map);\n+    delete id.debug_map;\n \n   TYPE_CANONICAL (type) = type;\n "}, {"sha": "53059da57b3347ca734c0c4f4f64eda098f79e77", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_INLINE_H\n #define GCC_TREE_INLINE_H\n \n+#include \"hash-map.h\"\n #include \"hash-set.h\"\n \n struct cgraph_edge;\n@@ -64,7 +65,7 @@ struct copy_body_data\n \n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n-  struct pointer_map_t *decl_map;\n+  hash_map<tree, tree> *decl_map;\n \n   /* Create a new decl to replace DECL in the destination function.  */\n   tree (*copy_decl) (tree, struct copy_body_data *);\n@@ -81,7 +82,7 @@ struct copy_body_data\n \n   /* Maps region and landing pad structures from the function being copied\n      to duplicates created within the function we inline into.  */\n-  struct pointer_map_t *eh_map;\n+  hash_map<void *, void *> *eh_map;\n \n   /* We use the same mechanism do all sorts of different things.  Rather\n      than enumerating the different cases, we categorize the behavior\n@@ -132,7 +133,7 @@ struct copy_body_data\n      equivalents in the function into which it is being inlined, where\n      the originals have been mapped to a value rather than to a\n      variable.  */\n-  struct pointer_map_t *debug_map;\n+  hash_map<tree, tree> *debug_map;\n  \n   /* Cilk keywords currently need to replace some variables that\n      ordinary nested functions do not.  */ "}, {"sha": "7d5c039927ee0fc01bc9373e27280be895f58d5d", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -93,8 +93,8 @@ struct nesting_info\n   struct nesting_info *inner;\n   struct nesting_info *next;\n \n-  struct pointer_map_t *field_map;\n-  struct pointer_map_t *var_map;\n+  hash_map<tree, tree> *field_map;\n+  hash_map<tree, tree> *var_map;\n   hash_set<tree *> *mem_refs;\n   bitmap suppress_expansion;\n \n@@ -286,15 +286,13 @@ static tree\n lookup_field_for_decl (struct nesting_info *info, tree decl,\n \t\t       enum insert_option insert)\n {\n-  void **slot;\n-\n   if (insert == NO_INSERT)\n     {\n-      slot = pointer_map_contains (info->field_map, decl);\n-      return slot ? (tree) *slot : NULL_TREE;\n+      tree *slot = info->field_map->get (decl);\n+      return slot ? *slot : NULL_TREE;\n     }\n \n-  slot = pointer_map_insert (info->field_map, decl);\n+  tree *slot = &info->field_map->get_or_insert (decl);\n   if (!*slot)\n     {\n       tree field = make_node (FIELD_DECL);\n@@ -324,7 +322,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n \tinfo->any_parm_remapped = true;\n     }\n \n-  return (tree) *slot;\n+  return *slot;\n }\n \n /* Build or return the variable that holds the static chain within\n@@ -521,15 +519,13 @@ static tree\n lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n \t\t       enum insert_option insert)\n {\n-  void **slot;\n-\n   if (insert == NO_INSERT)\n     {\n-      slot = pointer_map_contains (info->var_map, decl);\n-      return slot ? (tree) *slot : NULL_TREE;\n+      tree *slot = info->var_map->get (decl);\n+      return slot ? *slot : NULL_TREE;\n     }\n \n-  slot = pointer_map_insert (info->var_map, decl);\n+  tree *slot = &info->var_map->get_or_insert (decl);\n   if (!*slot)\n     {\n       tree field = make_node (FIELD_DECL);\n@@ -543,7 +539,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n       info->any_tramp_created = true;\n     }\n \n-  return (tree) *slot;\n+  return *slot;\n }\n \n /* Build or return the field within the non-local frame state that holds\n@@ -730,8 +726,8 @@ static struct nesting_info *\n create_nesting_tree (struct cgraph_node *cgn)\n {\n   struct nesting_info *info = XCNEW (struct nesting_info);\n-  info->field_map = pointer_map_create ();\n-  info->var_map = pointer_map_create ();\n+  info->field_map = new hash_map<tree, tree>;\n+  info->var_map = new hash_map<tree, tree>;\n   info->mem_refs = new hash_set<tree *>;\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n@@ -834,12 +830,11 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   tree target_context;\n   struct nesting_info *i;\n   tree x, field, new_decl;\n-  void **slot;\n \n-  slot = pointer_map_insert (info->var_map, decl);\n+  tree *slot = &info->var_map->get_or_insert (decl);\n \n   if (*slot)\n-    return (tree) *slot;\n+    return *slot;\n \n   target_context = decl_function_context (decl);\n \n@@ -1483,11 +1478,10 @@ static tree\n get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n {\n   tree x, new_decl;\n-  void **slot;\n \n-  slot = pointer_map_insert (info->var_map, decl);\n+  tree *slot = &info->var_map->get_or_insert (decl);\n   if (*slot)\n-    return (tree) *slot;\n+    return *slot;\n \n   /* Make sure frame_decl gets created.  */\n   (void) get_frame_type (info);\n@@ -2064,7 +2058,6 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n {\n   struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree label, new_label, target_context, x, field;\n-  void **slot;\n   gimple call;\n   gimple stmt = gsi_stmt (*gsi);\n \n@@ -2098,15 +2091,15 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n      (hairy target-specific) non-local goto receiver code to be generated\n      when we expand rtl.  Enter this association into var_map so that we\n      can insert the new label into the IL during a second pass.  */\n-  slot = pointer_map_insert (i->var_map, label);\n+  tree *slot = &i->var_map->get_or_insert (label);\n   if (*slot == NULL)\n     {\n       new_label = create_artificial_label (UNKNOWN_LOCATION);\n       DECL_NONLOCAL (new_label) = 1;\n       *slot = new_label;\n     }\n   else\n-    new_label = (tree) *slot;\n+    new_label = *slot;\n \n   /* Build: __builtin_nl_goto(new_label, &chain->nl_goto_field).  */\n   field = get_nl_goto_field (i);\n@@ -2136,7 +2129,6 @@ convert_nl_goto_receiver (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   struct nesting_info *const info = (struct nesting_info *) wi->info;\n   tree label, new_label;\n   gimple_stmt_iterator tmp_gsi;\n-  void **slot;\n   gimple stmt = gsi_stmt (*gsi);\n \n   if (gimple_code (stmt) != GIMPLE_LABEL)\n@@ -2147,7 +2139,7 @@ convert_nl_goto_receiver (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n   label = gimple_label_label (stmt);\n \n-  slot = pointer_map_contains (info->var_map, label);\n+  tree *slot = info->var_map->get (label);\n   if (!slot)\n     {\n       *handled_ops_p = false;\n@@ -2513,7 +2505,7 @@ static tree\n nesting_copy_decl (tree decl, copy_body_data *id)\n {\n   struct nesting_copy_body_data *nid = (struct nesting_copy_body_data *) id;\n-  void **slot = pointer_map_contains (nid->root->var_map, decl);\n+  tree *slot = nid->root->var_map->get (decl);\n \n   if (slot)\n     return (tree) *slot;\n@@ -2542,15 +2534,14 @@ contains_remapped_vars (tree *tp, int *walk_subtrees, void *data)\n {\n   struct nesting_info *root = (struct nesting_info *) data;\n   tree t = *tp;\n-  void **slot;\n \n   if (DECL_P (t))\n     {\n       *walk_subtrees = 0;\n-      slot = pointer_map_contains (root->var_map, t);\n+      tree *slot = root->var_map->get (t);\n \n       if (slot)\n-\treturn (tree) *slot;\n+\treturn *slot;\n     }\n   return NULL;\n }\n@@ -2580,7 +2571,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n \t      && variably_modified_type_p (type, NULL)))\n \t  continue;\n \n-\tif (pointer_map_contains (root->var_map, TREE_OPERAND (val, 0))\n+\tif (root->var_map->get (TREE_OPERAND (val, 0))\n \t    || walk_tree (&type, contains_remapped_vars, root, NULL))\n \t  break;\n       }\n@@ -2590,15 +2581,14 @@ remap_vla_decls (tree block, struct nesting_info *root)\n \n   memset (&id, 0, sizeof (id));\n   id.cb.copy_decl = nesting_copy_decl;\n-  id.cb.decl_map = pointer_map_create ();\n+  id.cb.decl_map = new hash_map<tree, tree>;\n   id.root = root;\n \n   for (; var; var = DECL_CHAIN (var))\n     if (TREE_CODE (var) == VAR_DECL && DECL_HAS_VALUE_EXPR_P (var))\n       {\n \tstruct nesting_info *i;\n \ttree newt, context;\n-\tvoid **slot;\n \n \tval = DECL_VALUE_EXPR (var);\n \ttype = TREE_TYPE (var);\n@@ -2608,7 +2598,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n \t      && variably_modified_type_p (type, NULL)))\n \t  continue;\n \n-\tslot = pointer_map_contains (root->var_map, TREE_OPERAND (val, 0));\n+\ttree *slot = root->var_map->get (TREE_OPERAND (val, 0));\n \tif (!slot && !walk_tree (&type, contains_remapped_vars, root, NULL))\n \t  continue;\n \n@@ -2651,7 +2641,7 @@ remap_vla_decls (tree block, struct nesting_info *root)\n \t  SET_DECL_VALUE_EXPR (var, val);\n       }\n \n-  pointer_map_destroy (id.cb.decl_map);\n+  delete id.cb.decl_map;\n }\n \n /* Fold the MEM_REF *E.  */\n@@ -2830,7 +2820,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \n \t  memset (&id, 0, sizeof (id));\n \t  id.cb.copy_decl = nesting_copy_decl;\n-\t  id.cb.decl_map = pointer_map_create ();\n+\t  id.cb.decl_map = new hash_map<tree, tree>;\n \t  id.root = root;\n \n \t  for (; debug_var; debug_var = DECL_CHAIN (debug_var))\n@@ -2865,7 +2855,7 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t\t  TYPE_NAME (newt) = remap_decl (TYPE_NAME (newt), &id.cb);\n \t      }\n \n-\t  pointer_map_destroy (id.cb.decl_map);\n+\t  delete id.cb.decl_map;\n \t}\n \n       scope = gimple_seq_first_stmt (gimple_body (root->context));\n@@ -2931,8 +2921,8 @@ free_nesting_tree (struct nesting_info *root)\n   do\n     {\n       next = iter_nestinfo_next (node);\n-      pointer_map_destroy (node->var_map);\n-      pointer_map_destroy (node->field_map);\n+      delete node->var_map;\n+      delete node->field_map;\n       delete node->mem_refs;\n       free (node);\n       node = next;"}, {"sha": "2f80497ea60199a5a7747d99dbea00cccd162a23", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -74,11 +74,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"alloc-pool.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"pointer-set.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -290,7 +290,7 @@ struct assign_link\n static alloc_pool link_pool;\n \n /* Base (tree) -> Vector (vec<access_p> *) map.  */\n-static struct pointer_map_t *base_access_vec;\n+static hash_map<tree, auto_vec<access_p> > *base_access_vec;\n \n /* Candidate hash table helpers.  */\n \n@@ -518,13 +518,7 @@ access_has_replacements_p (struct access *acc)\n static vec<access_p> *\n get_base_access_vector (tree base)\n {\n-  void **slot;\n-\n-  slot = pointer_map_contains (base_access_vec, base);\n-  if (!slot)\n-    return NULL;\n-  else\n-    return *(vec<access_p> **) slot;\n+  return base_access_vec->get (base);\n }\n \n /* Find an access with required OFFSET and SIZE in a subtree of accesses rooted\n@@ -667,24 +661,13 @@ sra_initialize (void)\n   gcc_obstack_init (&name_obstack);\n   access_pool = create_alloc_pool (\"SRA accesses\", sizeof (struct access), 16);\n   link_pool = create_alloc_pool (\"SRA links\", sizeof (struct assign_link), 16);\n-  base_access_vec = pointer_map_create ();\n+  base_access_vec = new hash_map<tree, auto_vec<access_p> >;\n   memset (&sra_stats, 0, sizeof (sra_stats));\n   encountered_apply_args = false;\n   encountered_recursive_call = false;\n   encountered_unchangable_recursive_call = false;\n }\n \n-/* Hook fed to pointer_map_traverse, deallocate stored vectors.  */\n-\n-static bool\n-delete_base_accesses (const void *key ATTRIBUTE_UNUSED, void **value,\n-\t\t     void *data ATTRIBUTE_UNUSED)\n-{\n-  vec<access_p> *access_vec = (vec<access_p> *) *value;\n-  vec_free (access_vec);\n-  return true;\n-}\n-\n /* Deallocate all general structures.  */\n \n static void\n@@ -699,8 +682,7 @@ sra_deinitialize (void)\n   free_alloc_pool (link_pool);\n   obstack_free (&name_obstack, NULL);\n \n-  pointer_map_traverse (base_access_vec, delete_base_accesses, NULL);\n-  pointer_map_destroy (base_access_vec);\n+  delete base_access_vec;\n }\n \n /* Remove DECL from candidates for SRA and write REASON to the dump file if\n@@ -849,26 +831,15 @@ mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple stmt)\n static struct access *\n create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)\n {\n-  vec<access_p> *v;\n   struct access *access;\n-  void **slot;\n \n   access = (struct access *) pool_alloc (access_pool);\n   memset (access, 0, sizeof (struct access));\n   access->base = base;\n   access->offset = offset;\n   access->size = size;\n \n-  slot = pointer_map_contains (base_access_vec, base);\n-  if (slot)\n-    v = (vec<access_p> *) *slot;\n-  else\n-    vec_alloc (v, 32);\n-\n-  v->safe_push (access);\n-\n-  *((vec<access_p> **)\n-\tpointer_map_insert (base_access_vec, base)) = v;\n+  base_access_vec->get_or_insert (base).safe_push (access);\n \n   return access;\n }"}, {"sha": "0cbb3ae17a2911adcc085507b686f0daf804fa97", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple-pretty-print.h\"\n #include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -103,7 +104,7 @@ struct lim_aux_data\n \n /* Maps statements to their lim_aux_data.  */\n \n-static struct pointer_map_t *lim_aux_data_map;\n+static hash_map<gimple, lim_aux_data *> *lim_aux_data_map;\n \n /* Description of a memory reference location.  */\n \n@@ -225,20 +226,20 @@ static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n static struct lim_aux_data *\n init_lim_data (gimple stmt)\n {\n-  void **p = pointer_map_insert (lim_aux_data_map, stmt);\n+  lim_aux_data *p = XCNEW (struct lim_aux_data);\n+  lim_aux_data_map->put (stmt, p);\n \n-  *p = XCNEW (struct lim_aux_data);\n-  return (struct lim_aux_data *) *p;\n+  return p;\n }\n \n static struct lim_aux_data *\n get_lim_data (gimple stmt)\n {\n-  void **p = pointer_map_contains (lim_aux_data_map, stmt);\n+  lim_aux_data **p = lim_aux_data_map->get (stmt);\n   if (!p)\n     return NULL;\n \n-  return (struct lim_aux_data *) *p;\n+  return *p;\n }\n \n /* Releases the memory occupied by DATA.  */\n@@ -253,11 +254,11 @@ free_lim_aux_data (struct lim_aux_data *data)\n static void\n clear_lim_data (gimple stmt)\n {\n-  void **p = pointer_map_contains (lim_aux_data_map, stmt);\n+  lim_aux_data **p = lim_aux_data_map->get (stmt);\n   if (!p)\n     return;\n \n-  free_lim_aux_data ((struct lim_aux_data *) *p);\n+  free_lim_aux_data (*p);\n   *p = NULL;\n }\n \n@@ -2429,7 +2430,7 @@ tree_ssa_lim_initialize (void)\n \n   bitmap_obstack_initialize (&lim_bitmap_obstack);\n   gcc_obstack_init (&mem_ref_obstack);\n-  lim_aux_data_map = pointer_map_create ();\n+  lim_aux_data_map = new hash_map<gimple, lim_aux_data *>;\n \n   if (flag_tm)\n     compute_transaction_bits ();\n@@ -2484,7 +2485,7 @@ tree_ssa_lim_finalize (void)\n     SET_ALWAYS_EXECUTED_IN (bb, NULL);\n \n   bitmap_obstack_release (&lim_bitmap_obstack);\n-  pointer_map_destroy (lim_aux_data_map);\n+  delete lim_aux_data_map;\n \n   delete memory_accesses.refs;\n   memory_accesses.refs = NULL;"}, {"sha": "158a0814d692e9b3a07907139606d0fd834a9b74", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -70,7 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"basic-block.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n@@ -293,7 +293,7 @@ struct ivopts_data\n   struct loop *current_loop;\n \n   /* Numbers of iterations for all exits of the current loop.  */\n-  struct pointer_map_t *niters;\n+  hash_map<edge, tree_niter_desc *> *niters;\n \n   /* Number of registers used in it.  */\n   unsigned regs_used;\n@@ -814,15 +814,15 @@ static struct tree_niter_desc *\n niter_for_exit (struct ivopts_data *data, edge exit)\n {\n   struct tree_niter_desc *desc;\n-  void **slot;\n+  tree_niter_desc **slot;\n \n   if (!data->niters)\n     {\n-      data->niters = pointer_map_create ();\n+      data->niters = new hash_map<edge, tree_niter_desc *>;\n       slot = NULL;\n     }\n   else\n-    slot = pointer_map_contains (data->niters, exit);\n+    slot = data->niters->get (exit);\n \n   if (!slot)\n     {\n@@ -837,11 +837,10 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n \t  XDELETE (desc);\n \t  desc = NULL;\n \t}\n-      slot = pointer_map_insert (data->niters, exit);\n-      *slot = desc;\n+      data->niters->put (exit, desc);\n     }\n   else\n-    desc = (struct tree_niter_desc *) *slot;\n+    desc = *slot;\n \n   return desc;\n }\n@@ -6704,15 +6703,12 @@ remove_unused_ivs (struct ivopts_data *data)\n }\n \n /* Frees memory occupied by struct tree_niter_desc in *VALUE. Callback\n-   for pointer_map_traverse.  */\n+   for hash_map::traverse.  */\n \n-static bool\n-free_tree_niter_desc (const void *key ATTRIBUTE_UNUSED, void **value,\n-                      void *data ATTRIBUTE_UNUSED)\n+bool\n+free_tree_niter_desc (edge const &, tree_niter_desc *const &value, void *)\n {\n-  struct tree_niter_desc *const niter = (struct tree_niter_desc *) *value;\n-\n-  free (niter);\n+  free (value);\n   return true;\n }\n \n@@ -6727,8 +6723,8 @@ free_loop_data (struct ivopts_data *data)\n \n   if (data->niters)\n     {\n-      pointer_map_traverse (data->niters, free_tree_niter_desc, NULL);\n-      pointer_map_destroy (data->niters);\n+      data->niters->traverse<void *, free_tree_niter_desc> (NULL);\n+      delete data->niters;\n       data->niters = NULL;\n     }\n "}, {"sha": "2e8337c8e6f65469dd24f2e886d77030abbb6209", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-inline.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-fold.h\"\n@@ -216,7 +216,7 @@ static int next_operand_entry_id;\n static long *bb_rank;\n \n /* Operand->rank hashtable.  */\n-static struct pointer_map_t *operand_rank;\n+static hash_map<tree, long> *operand_rank;\n \n /* Forward decls.  */\n static long get_rank (tree);\n@@ -362,20 +362,17 @@ propagate_rank (long rank, tree op)\n static inline long\n find_operand_rank (tree e)\n {\n-  void **slot = pointer_map_contains (operand_rank, e);\n-  return slot ? (long) (intptr_t) *slot : -1;\n+  long *slot = operand_rank->get (e);\n+  return slot ? *slot : -1;\n }\n \n /* Insert {E,RANK} into the operand rank hashtable.  */\n \n static inline void\n insert_operand_rank (tree e, long rank)\n {\n-  void **slot;\n   gcc_assert (rank > 0);\n-  slot = pointer_map_insert (operand_rank, e);\n-  gcc_assert (!*slot);\n-  *slot = (void *) (intptr_t) rank;\n+  gcc_assert (!operand_rank->put (e, rank));\n }\n \n /* Given an expression E, return the rank of the expression.  */\n@@ -4635,7 +4632,7 @@ init_reassoc (void)\n      deeper loops come later.  */\n   pre_and_rev_post_order_compute (NULL, bbs, false);\n   bb_rank = XCNEWVEC (long, last_basic_block_for_fn (cfun));\n-  operand_rank = pointer_map_create ();\n+  operand_rank = new hash_map<tree, long>;\n \n   /* Give each default definition a distinct rank.  This includes\n      parameters and the static chain.  Walk backwards over all\n@@ -4676,7 +4673,7 @@ fini_reassoc (void)\n   statistics_counter_event (cfun, \"Built-in powi calls created\",\n \t\t\t    reassociate_stats.pows_created);\n \n-  pointer_map_destroy (operand_rank);\n+  delete operand_rank;\n   free_alloc_pool (operand_entry_pool);\n   free (bb_rank);\n   plus_negates.release ();"}, {"sha": "521d77863760837f7802f6eccfe46a38323a365b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -319,7 +319,7 @@ static inline bool type_can_have_subvars (const_tree);\n static alloc_pool variable_info_pool;\n \n /* Map varinfo to final pt_solution.  */\n-static pointer_map_t *final_solutions;\n+static hash_map<varinfo_t, pt_solution *> *final_solutions;\n struct obstack final_solutions_obstack;\n \n /* Table of variable info structures for constraint variables.\n@@ -393,19 +393,19 @@ new_var_info (tree t, const char *name)\n \n /* A map mapping call statements to per-stmt variables for uses\n    and clobbers specific to the call.  */\n-static struct pointer_map_t *call_stmt_vars;\n+static hash_map<gimple, varinfo_t> *call_stmt_vars;\n \n /* Lookup or create the variable for the call statement CALL.  */\n \n static varinfo_t\n get_call_vi (gimple call)\n {\n-  void **slot_p;\n   varinfo_t vi, vi2;\n \n-  slot_p = pointer_map_insert (call_stmt_vars, call);\n-  if (*slot_p)\n-    return (varinfo_t) *slot_p;\n+  bool existed;\n+  varinfo_t *slot_p = &call_stmt_vars->get_or_insert (call, &existed);\n+  if (existed)\n+    return *slot_p;\n \n   vi = new_var_info (NULL_TREE, \"CALLUSED\");\n   vi->offset = 0;\n@@ -421,7 +421,7 @@ get_call_vi (gimple call)\n \n   vi->next = vi2->id;\n \n-  *slot_p = (void *) vi;\n+  *slot_p = vi;\n   return vi;\n }\n \n@@ -431,11 +431,9 @@ get_call_vi (gimple call)\n static varinfo_t\n lookup_call_use_vi (gimple call)\n {\n-  void **slot_p;\n-\n-  slot_p = pointer_map_contains (call_stmt_vars, call);\n+  varinfo_t *slot_p = call_stmt_vars->get (call);\n   if (slot_p)\n-    return (varinfo_t) *slot_p;\n+    return *slot_p;\n \n   return NULL;\n }\n@@ -2794,18 +2792,16 @@ solve_graph (constraint_graph_t graph)\n }\n \n /* Map from trees to variable infos.  */\n-static struct pointer_map_t *vi_for_tree;\n+static hash_map<tree, varinfo_t> *vi_for_tree;\n \n \n /* Insert ID as the variable id for tree T in the vi_for_tree map.  */\n \n static void\n insert_vi_for_tree (tree t, varinfo_t vi)\n {\n-  void **slot = pointer_map_insert (vi_for_tree, t);\n   gcc_assert (vi);\n-  gcc_assert (*slot == NULL);\n-  *slot = vi;\n+  gcc_assert (!vi_for_tree->put (t, vi));\n }\n \n /* Find the variable info for tree T in VI_FOR_TREE.  If T does not\n@@ -2814,11 +2810,11 @@ insert_vi_for_tree (tree t, varinfo_t vi)\n static varinfo_t\n lookup_vi_for_tree (tree t)\n {\n-  void **slot = pointer_map_contains (vi_for_tree, t);\n+  varinfo_t *slot = vi_for_tree->get (t);\n   if (slot == NULL)\n     return NULL;\n \n-  return (varinfo_t) *slot;\n+  return *slot;\n }\n \n /* Return a printable name for DECL  */\n@@ -2876,11 +2872,11 @@ alias_get_name (tree decl)\n static varinfo_t\n get_vi_for_tree (tree t)\n {\n-  void **slot = pointer_map_contains (vi_for_tree, t);\n+  varinfo_t *slot = vi_for_tree->get (t);\n   if (slot == NULL)\n     return get_varinfo (create_variable_info_for (t, alias_get_name (t)));\n \n-  return (varinfo_t) *slot;\n+  return *slot;\n }\n \n /* Get a scalar constraint expression for a new temporary variable.  */\n@@ -6077,17 +6073,16 @@ find_what_var_points_to (varinfo_t orig_vi)\n   bitmap finished_solution;\n   bitmap result;\n   varinfo_t vi;\n-  void **slot;\n   struct pt_solution *pt;\n \n   /* This variable may have been collapsed, let's get the real\n      variable.  */\n   vi = get_varinfo (find (orig_vi->id));\n \n   /* See if we have already computed the solution and return it.  */\n-  slot = pointer_map_insert (final_solutions, vi);\n+  pt_solution **slot = &final_solutions->get_or_insert (vi);\n   if (*slot != NULL)\n-    return *(struct pt_solution *)*slot;\n+    return **slot;\n \n   *slot = pt = XOBNEW (&final_solutions_obstack, struct pt_solution);\n   memset (pt, 0, sizeof (struct pt_solution));\n@@ -6687,16 +6682,16 @@ init_alias_vars (void)\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n   constraints.create (8);\n   varmap.create (8);\n-  vi_for_tree = pointer_map_create ();\n-  call_stmt_vars = pointer_map_create ();\n+  vi_for_tree = new hash_map<tree, varinfo_t>;\n+  call_stmt_vars = new hash_map<gimple, varinfo_t>;\n \n   memset (&stats, 0, sizeof (stats));\n   shared_bitmap_table = new hash_table<shared_bitmap_hasher> (511);\n   init_base_vars ();\n \n   gcc_obstack_init (&fake_var_decl_obstack);\n \n-  final_solutions = pointer_map_create ();\n+  final_solutions = new hash_map<varinfo_t, pt_solution *>;\n   gcc_obstack_init (&final_solutions_obstack);\n }\n \n@@ -6945,8 +6940,8 @@ delete_points_to_sets (void)\n     fprintf (dump_file, \"Points to sets created:%d\\n\",\n \t     stats.points_to_sets_created);\n \n-  pointer_map_destroy (vi_for_tree);\n-  pointer_map_destroy (call_stmt_vars);\n+  delete vi_for_tree;\n+  delete call_stmt_vars;\n   bitmap_obstack_release (&pta_obstack);\n   constraints.release ();\n \n@@ -6967,7 +6962,7 @@ delete_points_to_sets (void)\n \n   obstack_free (&fake_var_decl_obstack, NULL);\n \n-  pointer_map_destroy (final_solutions);\n+  delete final_solutions;\n   obstack_free (&final_solutions_obstack, NULL);\n }\n "}, {"sha": "217b9fc769ee1730058db0e739e8d2663097e737", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 20, "deletions": 61, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -49,38 +49,33 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-into-ssa.h\"\n #include \"tree-ssa.h\"\n #include \"tree-inline.h\"\n+#include \"hash-map.h\"\n #include \"hashtab.h\"\n #include \"tree-pass.h\"\n #include \"diagnostic-core.h\"\n #include \"cfgloop.h\"\n #include \"cfgexpand.h\"\n \n /* Pointer map of variable mappings, keyed by edge.  */\n-static struct pointer_map_t *edge_var_maps;\n+static hash_map<edge, auto_vec<edge_var_map> > *edge_var_maps;\n \n \n /* Add a mapping with PHI RESULT and PHI DEF associated with edge E.  */\n \n void\n redirect_edge_var_map_add (edge e, tree result, tree def, source_location locus)\n {\n-  void **slot;\n-  edge_var_map_vector *head;\n   edge_var_map new_node;\n \n   if (edge_var_maps == NULL)\n-    edge_var_maps = pointer_map_create ();\n+    edge_var_maps = new hash_map<edge, auto_vec<edge_var_map> >;\n \n-  slot = pointer_map_insert (edge_var_maps, e);\n-  head = (edge_var_map_vector *) *slot;\n-  if (!head)\n-    vec_safe_reserve (head, 5);\n+  auto_vec<edge_var_map> &slot = edge_var_maps->get_or_insert (e);\n   new_node.def = def;\n   new_node.result = result;\n   new_node.locus = locus;\n \n-  vec_safe_push (head, new_node);\n-  *slot = head;\n+  slot.safe_push (new_node);\n }\n \n \n@@ -89,95 +84,60 @@ redirect_edge_var_map_add (edge e, tree result, tree def, source_location locus)\n void\n redirect_edge_var_map_clear (edge e)\n {\n-  void **slot;\n-  edge_var_map_vector *head;\n-\n   if (!edge_var_maps)\n     return;\n \n-  slot = pointer_map_contains (edge_var_maps, e);\n+  auto_vec<edge_var_map> *head = edge_var_maps->get (e);\n \n-  if (slot)\n-    {\n-      head = (edge_var_map_vector *) *slot;\n-      vec_free (head);\n-      *slot = NULL;\n-    }\n+  if (head)\n+    head->release ();\n }\n \n \n /* Duplicate the redirected var mappings in OLDE in NEWE.\n \n-   Since we can't remove a mapping, let's just duplicate it.  This assumes a\n-   pointer_map can have multiple edges mapping to the same var_map (many to\n-   one mapping), since we don't remove the previous mappings.  */\n+   This assumes a hash_map can have multiple edges mapping to the same\n+   var_map (many to one mapping), since we don't remove the previous mappings.\n+   */\n \n void\n redirect_edge_var_map_dup (edge newe, edge olde)\n {\n-  void **new_slot, **old_slot;\n-  edge_var_map_vector *head;\n-\n   if (!edge_var_maps)\n     return;\n \n-  new_slot = pointer_map_insert (edge_var_maps, newe);\n-  old_slot = pointer_map_contains (edge_var_maps, olde);\n-  if (!old_slot)\n+  auto_vec<edge_var_map> *head = edge_var_maps->get (olde);\n+  if (!head)\n     return;\n-  head = (edge_var_map_vector *) *old_slot;\n \n-  edge_var_map_vector *new_head = NULL;\n-  if (head)\n-    new_head = vec_safe_copy (head);\n-  else\n-    vec_safe_reserve (new_head, 5);\n-  *new_slot = new_head;\n+  edge_var_maps->get_or_insert (newe).safe_splice (*head);\n }\n \n \n /* Return the variable mappings for a given edge.  If there is none, return\n    NULL.  */\n \n-edge_var_map_vector *\n+vec<edge_var_map> *\n redirect_edge_var_map_vector (edge e)\n {\n-  void **slot;\n-\n   /* Hey, what kind of idiot would... you'd be surprised.  */\n   if (!edge_var_maps)\n     return NULL;\n \n-  slot = pointer_map_contains (edge_var_maps, e);\n+  auto_vec<edge_var_map> *slot = edge_var_maps->get (e);\n   if (!slot)\n     return NULL;\n \n-  return (edge_var_map_vector *) *slot;\n-}\n-\n-/* Used by redirect_edge_var_map_destroy to free all memory.  */\n-\n-static bool\n-free_var_map_entry (const void *key ATTRIBUTE_UNUSED,\n-\t\t    void **value,\n-\t\t    void *data ATTRIBUTE_UNUSED)\n-{\n-  edge_var_map_vector *head = (edge_var_map_vector *) *value;\n-  vec_free (head);\n-  return true;\n+  return slot;\n }\n \n /* Clear the edge variable mappings.  */\n \n void\n redirect_edge_var_map_destroy (void)\n {\n-  if (edge_var_maps)\n-    {\n-      pointer_map_traverse (edge_var_maps, free_var_map_entry, NULL);\n-      pointer_map_destroy (edge_var_maps);\n-      edge_var_maps = NULL;\n-    }\n+  delete edge_var_maps;\n+  edge_var_maps = NULL;\n }\n \n \n@@ -223,12 +183,11 @@ void\n flush_pending_stmts (edge e)\n {\n   gimple phi;\n-  edge_var_map_vector *v;\n   edge_var_map *vm;\n   int i;\n   gimple_stmt_iterator gsi;\n \n-  v = redirect_edge_var_map_vector (e);\n+  vec<edge_var_map> *v = redirect_edge_var_map_vector (e);\n   if (!v)\n     return;\n "}, {"sha": "835686c664cc4f61c4f23a75723b77c269863fae", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -35,7 +35,7 @@ typedef vec<edge_var_map, va_heap, vl_embed> edge_var_map_vector;\n extern void redirect_edge_var_map_add (edge, tree, tree, source_location);\n extern void redirect_edge_var_map_clear (edge);\n extern void redirect_edge_var_map_dup (edge, edge);\n-extern edge_var_map_vector *redirect_edge_var_map_vector (edge);\n+extern vec<edge_var_map> *redirect_edge_var_map_vector (edge);\n extern void redirect_edge_var_map_destroy (void);\n extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);"}, {"sha": "3b72fce9e46f12b64a5c06d50831b7d34040c42b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b787e7a2c2c9be2f548d4c76ec324b71859851a4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b787e7a2c2c9be2f548d4c76ec324b71859851a4", "patch": "@@ -94,6 +94,7 @@\n #include \"varasm.h\"\n #include \"stor-layout.h\"\n #include \"pointer-set.h\"\n+#include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"basic-block.h\"\n #include \"tm_p.h\"\n@@ -2019,12 +2020,12 @@ vt_get_canonicalize_base (rtx loc)\n \n /* This caches canonicalized addresses for VALUEs, computed using\n    information in the global cselib table.  */\n-static struct pointer_map_t *global_get_addr_cache;\n+static hash_map<rtx, rtx> *global_get_addr_cache;\n \n /* This caches canonicalized addresses for VALUEs, computed using\n    information from the global cache and information pertaining to a\n    basic block being analyzed.  */\n-static struct pointer_map_t *local_get_addr_cache;\n+static hash_map<rtx, rtx> *local_get_addr_cache;\n \n static rtx vt_canonicalize_addr (dataflow_set *, rtx);\n \n@@ -2036,13 +2037,13 @@ static rtx\n get_addr_from_global_cache (rtx const loc)\n {\n   rtx x;\n-  void **slot;\n \n   gcc_checking_assert (GET_CODE (loc) == VALUE);\n   \n-  slot = pointer_map_insert (global_get_addr_cache, loc);\n-  if (*slot)\n-    return (rtx)*slot;\n+  bool existed;\n+  rtx *slot = &global_get_addr_cache->get_or_insert (loc, &existed);\n+  if (existed)\n+    return *slot;\n \n   x = canon_rtx (get_addr (loc));\n \n@@ -2056,8 +2057,7 @@ get_addr_from_global_cache (rtx const loc)\n \t{\n \t  /* The table may have moved during recursion, recompute\n \t     SLOT.  */\n-\t  slot = pointer_map_contains (global_get_addr_cache, loc);\n-\t  *slot = x = nx;\n+\t  *global_get_addr_cache->get (loc) = x = nx;\n \t}\n     }\n \n@@ -2072,16 +2072,16 @@ static rtx\n get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n {\n   rtx x;\n-  void **slot;\n   decl_or_value dv;\n   variable var;\n   location_chain l;\n \n   gcc_checking_assert (GET_CODE (loc) == VALUE);\n   \n-  slot = pointer_map_insert (local_get_addr_cache, loc);\n-  if (*slot)\n-    return (rtx)*slot;\n+  bool existed;\n+  rtx *slot = &local_get_addr_cache->get_or_insert (loc, &existed);\n+  if (existed)\n+    return *slot;\n \n   x = get_addr_from_global_cache (loc);\n   \n@@ -2095,7 +2095,7 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n       rtx nx = vt_canonicalize_addr (set, x);\n       if (nx != x)\n \t{\n-\t  slot = pointer_map_contains (local_get_addr_cache, loc);\n+\t  slot = local_get_addr_cache->get (loc);\n \t  *slot = x = nx;\n \t}\n       return x;\n@@ -2116,7 +2116,7 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n \t  rtx nx = vt_canonicalize_addr (set, l->loc);\n \t  if (x != nx)\n \t    {\n-\t      slot = pointer_map_contains (local_get_addr_cache, loc);\n+\t      slot = local_get_addr_cache->get (loc);\n \t      *slot = x = nx;\n \t    }\n \t  break;\n@@ -2503,11 +2503,10 @@ val_store (dataflow_set *set, rtx val, rtx loc, rtx insn, bool modified)\n \n /* Clear (canonical address) slots that reference X.  */\n \n-static bool\n-local_get_addr_clear_given_value (const void *v ATTRIBUTE_UNUSED,\n-\t\t\t\t  void **slot, void *x)\n+bool\n+local_get_addr_clear_given_value (rtx const &, rtx *slot, rtx x)\n {\n-  if (vt_get_canonicalize_base ((rtx)*slot) == x)\n+  if (vt_get_canonicalize_base (*slot) == x)\n     *slot = NULL;\n   return true;\n }\n@@ -2530,11 +2529,10 @@ val_reset (dataflow_set *set, decl_or_value dv)\n   if (var->onepart == ONEPART_VALUE)\n     {\n       rtx x = dv_as_value (dv);\n-      void **slot;\n       \n       /* Relationships in the global cache don't change, so reset the\n \t local cache entry only.  */\n-      slot = pointer_map_contains (local_get_addr_cache, x);\n+      rtx *slot = local_get_addr_cache->get (x);\n       if (slot)\n \t{\n \t  /* If the value resolved back to itself, odds are that other\n@@ -2543,8 +2541,8 @@ val_reset (dataflow_set *set, decl_or_value dv)\n \t     old X but resolved to something else remain ok as long as\n \t     that something else isn't also reset.  */\n \t  if (*slot == x)\n-\t    pointer_map_traverse (local_get_addr_cache,\n-\t\t\t\t  local_get_addr_clear_given_value, x);\n+\t    local_get_addr_cache\n+\t      ->traverse<rtx, local_get_addr_clear_given_value> (x);\n \t  *slot = NULL;\n \t}\n     }\n@@ -6660,7 +6658,7 @@ compute_bb_dataflow (basic_block bb)\n   dataflow_set_copy (out, in);\n \n   if (MAY_HAVE_DEBUG_INSNS)\n-    local_get_addr_cache = pointer_map_create ();\n+    local_get_addr_cache = new hash_map<rtx, rtx>;\n \n   FOR_EACH_VEC_ELT (VTI (bb)->mos, i, mo)\n     {\n@@ -6943,7 +6941,7 @@ compute_bb_dataflow (basic_block bb)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      pointer_map_destroy (local_get_addr_cache);\n+      delete local_get_addr_cache;\n       local_get_addr_cache = NULL;\n \n       dataflow_set_equiv_regs (out);\n@@ -9477,13 +9475,13 @@ vt_emit_notes (void)\n       emit_notes_for_differences (BB_HEAD (bb), &cur, &VTI (bb)->in);\n \n       if (MAY_HAVE_DEBUG_INSNS)\n-\tlocal_get_addr_cache = pointer_map_create ();\n+\tlocal_get_addr_cache = new hash_map<rtx, rtx>;\n \n       /* Emit the notes for the changes in the basic block itself.  */\n       emit_notes_in_bb (bb, &cur);\n \n       if (MAY_HAVE_DEBUG_INSNS)\n-\tpointer_map_destroy (local_get_addr_cache);\n+\tdelete local_get_addr_cache;\n       local_get_addr_cache = NULL;\n \n       /* Free memory occupied by the in hash table, we won't need it\n@@ -9916,7 +9914,7 @@ vt_initialize (void)\n       valvar_pool = create_alloc_pool (\"small variable_def pool\",\n \t\t\t\t       sizeof (struct variable_def), 256);\n       preserved_values.create (256);\n-      global_get_addr_cache = pointer_map_create ();\n+      global_get_addr_cache = new hash_map<rtx, rtx>;\n     }\n   else\n     {\n@@ -10263,7 +10261,7 @@ vt_finalize (void)\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       if (global_get_addr_cache)\n-\tpointer_map_destroy (global_get_addr_cache);\n+\tdelete global_get_addr_cache;\n       global_get_addr_cache = NULL;\n       if (loc_exp_dep_pool)\n \tfree_alloc_pool (loc_exp_dep_pool);"}]}