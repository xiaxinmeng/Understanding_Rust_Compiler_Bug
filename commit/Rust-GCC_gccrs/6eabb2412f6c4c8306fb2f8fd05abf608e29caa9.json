{"sha": "6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhYmIyNDEyZjZjNGM4MzA2ZmIyZjhmZDA1YWJmNjA4ZTI5Y2FhOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-11T20:22:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-11T20:22:41Z"}, "message": "extend.texi (C++ Signatures): Remove node.\n\n\t* extend.texi (C++ Signatures): Remove node.\n\t* invoke.texi: Remove discussion of -fhandle-signatures,\n\tsignature, sigof, __signature__, and __sigof__.\n\n\t* Make-lang.in (CXX_SRCS): Remove sig.c.\n\t* Makefile.in (CXX_OBJS): Remove sig.o.\n\t(sig.o): Remove.\n\t* cp-tree.h (CPTI_OPAQUE_TYPE): Remove.\n\t(CPTI_SIGNATURE_TYPE): Likewise.\n\t(CPTI_SIGTABLE_ENTRY_TYPE): Likewise.\n\t(opaque_type_node): Likewise.\n\t(signature_type_node): Likewise.\n\t(sigtable_entry_type): Likewise.\n\t(flag_handle_signatures): Likewise.\n\t(lang_type): Remove is_signature, is_signature_pointer,\n\tis_signature_reference, has_opaque_typedecls,\n\tsigtables_has_been_generated.  Adjust dummy.  Remove signature,\n\tsignature_pointer_to, signature_reference_to.\n\t(IS_SIGNATURE): Remove.\n\t(SET_SIGNATURE): Remove.\n\t(CLEAR_SIGNATURE): Remove.\n\t(IS_SIGNATURE_POINTER): Remove.\n\t(IS_SIGNATURE_REFERENCE): Remove.\n\t(SIGNATURE_HAS_OPAQUE_TYPEDECLS): Remove.\n\t(SIGTABLE_HAS_BEEN_GENERATED): Remove.\n\t(CLASSTYPE_SIGNATURE): Remove.\n\t(SIGNATURE_TYPE): Remove.\n\t(SIGNATURE_METHOD_VEC): Remove.\n\t(SIGNATURE_POINTER_TO): Remove.\n\t(SIGNATURE_REFERENCE_TO): Remove.\n\t(lang_decl_flags): Remove is_default_implementation.  Rename\n\tmemfunc_pointer_to to saved_tree.\n\t(IS_DEFAULT_IMPLEMENTATION): Remove.\n\t(DECL_MEMFUNC_POINTER_TO): Remove.\n\t(DECL_MEMFUNC_POINTING_TO): Remove.\n\t(DECL_SAVED_TREE): Adjust definition.\n\t(tag_types): Remove signature_type_node.\n\t(SIGNATURE_FIELD_NAME): Remove.\n\t(SIGNATURE_FIELD_NAME_FORMAT): Likewise.\n\t(SIGNATURE_OPTR_NAME): Likewise.\n\t(SIGNATURE_SPTR_NAME): Likewise.\n\t(SIGNATURE_POINTER_NAME): Likewise.\n\t(SIGNATURE_POINTER_NAME_FORMAT): Likewise.\n\t(SIGNATURE_REFERENCE_NAME): Likewise.\n\t(SIGNATURE_REFERNECE_NAME_FORMAT): Likewise.\n\t(SIGTABLE_PTR_TYPE): Likewise.\n\t(SIGTABLE_NAME_FORMAT): Likewise.\n\t(SIGTABLE_NAME_FORMAT_LONG): Likewise.\n\t(SIGTABLE_TAG_NAME): Likewise.\n\t(SIGTABLE_VB_OFF_NAME): Likewise.\n\t(SIGTABLE_VT_OFF_NAME): Likewise.\n\t(finish_base_specifiers): Change prototype.\n\t(build_signature_pointer_type): Remove.\n\t(build_signature_reference_type): Remove.\n\t(build_signature_pointer_constructor): Remove.\n\t(build_signature_method_call): Remove.\n\t(build_optr_ref): Likewise.\n\t(append_signature_fields): Likewise.\n\t(signature_error): Likewise.\n\t* call.c (build_this): Remove signature support.\n\t(build_over_call): Likewise.\n\t(build_new_method_call): Likewise.\n\t* class.c (add_implicitly_declared_members): Likewise.\n\t(finish_struct_1): Likewise.\n\t(finish_struct): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(convert_to_pointer_force): Likewise.\n\t(ocp_convert): Likewise.\n\t* decl.c (sigtable_decl_p): Remove.\n\t(init_decl_processing): Remove support for signatures.\n\t(cp_finish_decl): Likewise.\n\t(grokdeclarator): Likewise.\n\t(grokparms): Likewise.\n\t(xref_tag): Likewise.\n\t(start_function): Likewise.\n\t(start_method): Likewise.\n\t* decl2.c (finish_sigtable_vardecl): Remove.\n\t(flag_handle_signatures): Remove.\n\t(lang_f_options): Remove handle-signatures.\n\t(grokfield): Remove support for signatures.\n\t(grokbitfield): Likewise.\n\t(finish_file): Likewise.\n\t(reparse_absdcl_as_casts): Likewise.\n\t* error.c (dump_type_real): Likewise.\n\t(dump_function_decl): Likewise.\n\t* friend.c (make_friend_class): Likewise.\n\t* gxx.gperf: Remove __signature__, signature, __sigof__, sigof.\n\t* hash.h: Regenerated.\n\t* init.c (build_new_1): Remove support for signatures.\n\t* lang-options.h: Remove -fhandle-signatures,\n\t-fno-handle-signatures.\n\t* lex.c (init_parse): Remove support for signatures.\n\t(yyprint): Likewise.\n\t* lex.h (rid): Remove RID_SIGNATURE.\n\t* method.c (build_decl_overload_real): Remove support for\n\tsignatures.\n\t(hack_identifier): Likewise.\n\t* parse.y (base_class): Likewise.\n\t(base_class.1): Likewise.\n\t(access_specifier): Likewise.\n\t* search.c (lookup_member): Likewise.\n\t* semantics.c (finish_qualified_object_call_expr): Likewise.\n\t(finish_template_type_parm): Likewise.\n\t(begin_class_definition): Likewise.\n\t(finish_base_specifier): Likewise.\n\t* sig.c: Remove.\n\t* tree.c (build_cplus_method_type): Remove support for signatures.\n\t* typeck.c (require_complete_type): Likewise.\n\t(c_sizeof): Likewise.\n\t(c_alignof): Likewise.\n\t(build_object_ref): Likewise.\n\t(build_component_ref): Likewise.\n\t(build_indirect_ref): Likewise.\n\t(build_c_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.c (signature_error): Remove.\n\t(store_init_value): Remove support for signatures.\n\t(digest_init): Likewise.\n\t(build_x_arrow): Likewise.\n\t(build_functional_cast): Likewise.\n\t* xref.c (GNU_xref_decl): Likewise.\n\nFrom-SVN: r28677", "tree": {"sha": "a85a706a6d7637e50290fb77ee7eabbc48eae4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a85a706a6d7637e50290fb77ee7eabbc48eae4e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/comments", "author": null, "committer": null, "parents": [{"sha": "b6062b273ff29769c373f0c541c6fe76a642a1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6062b273ff29769c373f0c541c6fe76a642a1b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6062b273ff29769c373f0c541c6fe76a642a1b0"}], "stats": {"total": 10312, "additions": 3541, "deletions": 6771}, "files": [{"sha": "080fc15bdaaad7a6747f01940d1061e6493246d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -1,3 +1,9 @@\n+Wed Aug 11 12:59:37 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* extend.texi (C++ Signatures): Remove node.\n+\t* invoke.texi: Remove discussion of -fhandle-signatures,\n+\tsignature, sigof, __signature__, and __sigof__.\n+\n Wed Aug 11 03:38:25 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (JAVAGC): Removed."}, {"sha": "032285519a6fe88a9a9469243586f5d08b6c8c02", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -116,7 +116,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/rtti.c $(srcdir)/cp/method.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n- $(srcdir)/cp/parse.y $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c \\\n+ $(srcdir)/cp/parse.y $(srcdir)/cp/typeck2.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c \\\n  $(srcdir)/cp/dump.c\n "}, {"sha": "5860d3d11e814d1addd0e7410c164089f1d7d93e", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -185,7 +185,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n \n # Language-specific object files for g++\n \n-CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n+CXX_OBJS = call.o decl.o errfn.o expr.o pt.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n  except.o friend.o init.o method.o search.o semantics.o tree.o xref.o \\\n  repo.o dump.o @extra_cxx_objs@\n@@ -302,8 +302,6 @@ error.o : error.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n-sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n semantics.o: semantics.c $(CONFIG_H) $(CXX_TREE_H) lex.h \\"}, {"sha": "a4ed95b7fa8537a444fd9fd95d98bf87542d6a5a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -2191,11 +2191,7 @@ build_this (obj)\n      tree obj;\n {\n   /* Fix this to work on non-lvalues.  */\n-  if (IS_SIGNATURE_POINTER (TREE_TYPE (obj))\n-      || IS_SIGNATURE_REFERENCE (TREE_TYPE (obj)))\n-    return obj;\n-  else\n-    return build_unary_op (ADDR_EXPR, obj, 0);\n+  return build_unary_op (ADDR_EXPR, obj, 0);\n }\n \n static void\n@@ -3899,11 +3895,8 @@ build_over_call (cand, args, flags)\n \n          So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n-      if (TREE_CODE (parmtype) == POINTER_TYPE)\n-\tt = convert_pointer_to_real (TREE_TYPE (parmtype), TREE_VALUE (arg));\n-      else\n-\t/* This happens with signatures.  */\n-\tt = convert_force (parmtype, TREE_VALUE (arg), CONV_C_CAST);\n+      my_friendly_assert (TREE_CODE (parmtype) == POINTER_TYPE, 19990811);\n+      t = convert_pointer_to_real (TREE_TYPE (parmtype), TREE_VALUE (arg));\n       converted_args = expr_tree_cons (NULL_TREE, t, converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n@@ -4084,9 +4077,7 @@ build_over_call (cand, args, flags)\n \n   mark_used (fn);\n \n-  if (DECL_CLASS_SCOPE_P (fn) && IS_SIGNATURE (DECL_CONTEXT (fn)))\n-    return build_signature_method_call (fn, converted_args);\n-  else if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n+  if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n     {\n       tree t, *p = &TREE_VALUE (converted_args);\n       tree binfo = get_binfo\n@@ -4182,25 +4173,14 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n \n       /* XXX this should be handled before we get here.  */\n-      if (! IS_AGGR_TYPE (basetype)\n-\t  && ! (TYPE_LANG_SPECIFIC (basetype)\n-\t\t&& (IS_SIGNATURE_POINTER (basetype)\n-\t\t    || IS_SIGNATURE_REFERENCE (basetype))))\n+      if (! IS_AGGR_TYPE (basetype))\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n \t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t      name, instance, basetype);\n \n \t  return error_mark_node;\n \t}\n-\n-      /* If `instance' is a signature pointer/reference and `name' is\n-\t not a constructor, we are calling a signature member function.\n-\t In that case set the `basetype' to the signature type.  */\n-      if ((IS_SIGNATURE_POINTER (basetype)\n-\t   || IS_SIGNATURE_REFERENCE (basetype))\n-\t  && TYPE_IDENTIFIER (basetype) != name)\n-\tbasetype = SIGNATURE_TYPE (basetype);\n     }\n \n   if (basetype_path == NULL_TREE)"}, {"sha": "bc1d58108fbbf86132b5078ccfd1a9cb15a77927", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -3153,8 +3153,7 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   tree *f;\n \n   /* Destructor.  */\n-  if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n-      && !IS_SIGNATURE (t))\n+  if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t))\n     {\n       default_fn = cons_up_default_function (t, name, 0);\n       check_for_override (default_fn, t);\n@@ -3174,16 +3173,15 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n   /* Default constructor.  */\n-  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor\n-      && ! IS_SIGNATURE (t))\n+  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor)\n     {\n       default_fn = cons_up_default_function (t, name, 2);\n       TREE_CHAIN (default_fn) = implicit_fns;\n       implicit_fns = default_fn;\n     }\n \n   /* Copy constructor.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n+  if (! TYPE_HAS_INIT_REF (t) && ! TYPE_FOR_JAVA (t))\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */\n@@ -3194,7 +3192,7 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n     }\n \n   /* Assignment operator.  */\n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n+  if (! TYPE_HAS_ASSIGN_REF (t) && ! TYPE_FOR_JAVA (t))\n     {\n       default_fn = cons_up_default_function (t, name,\n \t\t\t\t\t     5 + cant_have_assignment);\n@@ -3332,16 +3330,6 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-#if 0\n-  /* This is in general too late to do this.  I moved the main case up to\n-     left_curly, what else needs to move?  */\n-  if (! IS_SIGNATURE (t))\n-    {\n-      my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n-      my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);\n-    }\n-#endif\n-\n   old = suspend_momentary ();\n \n   /* Install struct as DECL_FIELD_CONTEXT of each field decl.\n@@ -3578,8 +3566,7 @@ finish_struct_1 (t)\n \t  cant_have_default_ctor = 1;\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n \n-\t  if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n-\t      && extra_warnings)\n+\t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n \t    {\n \t      if (DECL_NAME (x))\n \t\tcp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n@@ -3706,10 +3693,6 @@ finish_struct_1 (t)\n \t\t make it through without complaint.  */\n \t      abstract_virtuals_error (x, type);\n \t\t      \n-\t      /* Don't let signatures make it through either.  */\n-\t      if (IS_SIGNATURE (type))\n-\t\tsignature_error (x, type);\n-\t\t      \n \t      if (code == UNION_TYPE)\n \t\t{\n \t\t  const char *fie = NULL;\n@@ -3799,8 +3782,7 @@ finish_struct_1 (t)\n   TYPE_NEEDS_CONSTRUCTING (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| has_virtual || any_default_members);\n-  if (! IS_SIGNATURE (t))\n-    CLASSTYPE_NON_AGGREGATE (t)\n+  CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n   CLASSTYPE_NON_POD_P (t)\n       = non_pod_class || CLASSTYPE_NON_AGGREGATE (t)\n@@ -4347,10 +4329,6 @@ tree\n finish_struct (t, attributes)\n      tree t, attributes;\n {\n-  /* Append the fields we need for constructing signature tables.  */\n-  if (IS_SIGNATURE (t))\n-    append_signature_fields (t);\n-\n   /* Now that we've got all the field declarations, reverse everything\n      as necessary.  */\n   unreverse_member_declarations (t);"}, {"sha": "1f9a0b29701345381437d6c61fcacd235e0a1c35", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 13, "deletions": 109, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -377,9 +377,6 @@ enum cp_tree_index\n     CPTI_UNION_TYPE,\n     CPTI_ENUM_TYPE,\n     CPTI_UNKNOWN_TYPE,\n-    CPTI_OPAQUE_TYPE,\n-    CPTI_SIGNATURE_TYPE,\n-    CPTI_SIGTABLE_ENTRY_TYPE,\n     CPTI_VTBL_TYPE,\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n@@ -423,9 +420,6 @@ extern tree cp_global_trees[CPTI_MAX];\n #define union_type_node\t\t\tcp_global_trees[CPTI_UNION_TYPE]\n #define enum_type_node\t\t\tcp_global_trees[CPTI_ENUM_TYPE]\n #define unknown_type_node\t\tcp_global_trees[CPTI_UNKNOWN_TYPE]\n-#define opaque_type_node\t\tcp_global_trees[CPTI_OPAQUE_TYPE]\n-#define signature_type_node\t\tcp_global_trees[CPTI_SIGNATURE_TYPE]\n-#define sigtable_entry_type\t\tcp_global_trees[CPTI_SIGTABLE_ENTRY_TYPE]\n #define vtbl_type_node\t\t\tcp_global_trees[CPTI_VTBL_TYPE]\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n@@ -582,10 +576,6 @@ extern int flag_elide_constructors;\n \n extern int flag_ansi;\n \n-/* Nonzero means recognize and handle signature language constructs.  */\n-\n-extern int flag_handle_signatures;\n-\n /* Nonzero means that member functions defined in class scope are\n    inline by default.  */\n \n@@ -785,32 +775,28 @@ struct lang_type\n       unsigned use_template : 2;\n       unsigned got_semicolon : 1;\n       unsigned ptrmemfunc_flag : 1;\n-      unsigned is_signature : 1;\n-\n-      unsigned is_signature_pointer : 1;\n-      unsigned is_signature_reference : 1;\n-      unsigned has_opaque_typedecls : 1;\n-      unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n+\n       unsigned has_real_assign_ref : 1;\n       unsigned has_const_init_ref : 1;\n       unsigned has_complex_init_ref : 1;\n-\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n       unsigned is_partial_instantiation : 1;\n       unsigned has_mutable : 1;\n+\n       unsigned com_interface : 1;\n       unsigned non_pod_class : 1;\n+\n       /* When adding a flag here, consider whether or not it ought to\n \t apply to a template instance if it applies to the template.\n \t If so, make sure to copy it in instantiate_class_template!  */\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 9;\n+      unsigned dummy : 14;\n     } type_flags;\n \n   int vsize;\n@@ -835,9 +821,6 @@ struct lang_type\n \n   union tree_node *methods;\n \n-  union tree_node *signature;\n-  union tree_node *signature_pointer_to;\n-  union tree_node *signature_reference_to;\n   union tree_node *template_info;\n   tree befriending_classes;\n };\n@@ -888,45 +871,6 @@ struct lang_type\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n #define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.redefined)\n \n-/* Nonzero means that this type is a signature.  */\n-# define IS_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)?TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature:0)\n-# define SET_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature=1)\n-# define CLEAR_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature=0)\n-\n-/* Nonzero means that this type is a signature pointer type.  */\n-# define IS_SIGNATURE_POINTER(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature_pointer)\n-\n-/* Nonzero means that this type is a signature reference type.  */\n-# define IS_SIGNATURE_REFERENCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.is_signature_reference)\n-\n-/* Nonzero means that this signature contains opaque type declarations.  */\n-#define SIGNATURE_HAS_OPAQUE_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_opaque_typedecls)\n-\n-/* Nonzero means that a signature table has been generated\n-   for this signature.  */\n-#define SIGTABLE_HAS_BEEN_GENERATED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.sigtable_has_been_generated)\n-\n-/* If NODE is a class, this is the signature type that contains NODE's\n-   signature after it has been computed using sigof().  */\n-#define CLASSTYPE_SIGNATURE(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n-\n-/* If NODE is a signature pointer or signature reference, this is the\n-   signature type the pointer/reference points to.  */\n-#define SIGNATURE_TYPE(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n-\n-/* If NODE is a signature, this is a vector of all methods defined\n-   in the signature or in its base types together with their default\n-   implementations.  */\n-#define SIGNATURE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature)\n-\n-/* If NODE is a signature, this is the _TYPE node that contains NODE's\n-   signature pointer type.  */\n-#define SIGNATURE_POINTER_TO(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature_pointer_to)\n-\n-/* If NODE is a signature, this is the _TYPE node that contains NODE's\n-   signature reference type.  */\n-#define SIGNATURE_REFERENCE_TO(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature_reference_to)\n-\n /* The is the basetype that contains NODE's rtti.  */\n #define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC(NODE)->rtti)\n \n@@ -1229,30 +1173,27 @@ struct lang_decl_flags\n   unsigned static_function : 1;\n   unsigned const_memfunc : 1;\n   unsigned volatile_memfunc : 1;\n-\n   unsigned abstract_virtual : 1;\n   unsigned permanent_attr : 1 ;\n+\n   unsigned constructor_for_vbase_attr : 1;\n   unsigned mutable_flag : 1;\n-  unsigned is_default_implementation : 1;\n   unsigned saved_inline : 1;\n   unsigned use_template : 2;\n-\n   unsigned nonconverting : 1;\n   unsigned declared_inline : 1;\n   unsigned not_really_extern : 1;\n+\n   unsigned needs_final_overrider : 1;\n   unsigned bitfield : 1;\n   unsigned defined_in_class : 1;\n-  unsigned dummy : 4;\n+  unsigned dummy : 5;\n \n   tree access;\n   tree context;\n \n-  /* In a template FUNCTION_DECL, this is DECL_SAVED_TREE.\n-     In a non-template FUNCTION_DECL, this is DECL_MEMFUNC_POINTER_TO.\n-     In a FIELD_DECL, this is DECL_MEMFUNC_POINTING_TO.  */\n-  tree memfunc_pointer_to;\n+  /* In a template FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n+  tree saved_tree;\n \n   union {\n     /* In a FUNCTION_DECL, this is DECL_TEMPLATE_INFO.  */\n@@ -1323,10 +1264,6 @@ struct lang_decl\n #define SET_DECL_TINFO_FN_P(NODE) \\\n   (DECL_LANG_SPECIFIC((NODE))->decl_flags.mutable_flag = 1)\n \n-/* For FUNCTION_DECLs: nonzero means that this function is a default\n-   implementation of a signature method.  */\n-#define IS_DEFAULT_IMPLEMENTATION(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.is_default_implementation)\n-\n /* Nonzero for _DECL means that this decl appears in (or will appear\n    in) as a member in a RECORD_TYPE or UNION_TYPE node.  It is also for\n    detecting circularity in case members are multiply defined.  In the\n@@ -1477,15 +1414,6 @@ struct lang_decl\n #define DECL_SAVED_INLINE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->decl_flags.saved_inline)\n \n-/* For a FUNCTION_DECL: if this function was declared inside a signature\n-   declaration, this is the corresponding member function pointer that was\n-   created for it.  */\n-#define DECL_MEMFUNC_POINTER_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n-\n-/* For a FIELD_DECL: this points to the signature member function from\n-   which this signature member function pointer was created.  */\n-#define DECL_MEMFUNC_POINTING_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n-\n /* For a VAR_DECL or FUNCTION_DECL: template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n   (DECL_LANG_SPECIFIC(NODE)->decl_flags.u.template_info)\n@@ -1573,7 +1501,8 @@ struct lang_decl\n \n /* In a template FUNCTION_DECL, the tree structure that will be\n    substituted into to obtain instantiations.  */\n-#define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n+#define DECL_SAVED_TREE(NODE) \\\n+  (DECL_LANG_SPECIFIC ((NODE))->decl_flags.saved_tree)\n \n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -2201,8 +2130,7 @@ extern int flag_new_for_scope;\n   (TREE_COMPLEXITY ((NODE)))\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n-enum tag_types { record_type, class_type, union_type, enum_type,\n-\t\t   signature_type };\n+enum tag_types { record_type, class_type, union_type, enum_type };\n \n /* The various kinds of lvalues we distinguish.  */\n typedef enum cp_lvalue_kind {\n@@ -2492,21 +2420,6 @@ extern int current_function_parms_stored;\n #define VTABLE_PFN_NAME\t\t\"__pfn\"\n #define VTABLE_DELTA2_NAME\t\"__delta2\"\n \n-#define SIGNATURE_FIELD_NAME\t\"__s_\"\n-#define SIGNATURE_FIELD_NAME_FORMAT \"__s_%s\"\n-#define SIGNATURE_OPTR_NAME\t\"__optr\"\n-#define SIGNATURE_SPTR_NAME\t\"__sptr\"\n-#define SIGNATURE_POINTER_NAME\t\"__sp_\"\n-#define SIGNATURE_POINTER_NAME_FORMAT \"__%s%s%ssp_%s\"\n-#define SIGNATURE_REFERENCE_NAME \"__sr_\"\n-#define SIGNATURE_REFERENCE_NAME_FORMAT \"__%s%s%ssr_%s\"\n-\n-#define SIGTABLE_PTR_TYPE\t\"__sigtbl_ptr_type\"\n-#define SIGTABLE_NAME_FORMAT\t\"__st_%s_%s\"\n-#define SIGTABLE_NAME_FORMAT_LONG \"__st_%s_%s_%d\"\n-#define SIGTABLE_TAG_NAME\t\"__tag\"\n-#define SIGTABLE_VB_OFF_NAME\t\"__vb_off\"\n-#define SIGTABLE_VT_OFF_NAME\t\"__vt_off\"\n #define EXCEPTION_CLEANUP_NAME \t\"exception cleanup\"\n \n #define THIS_NAME_P(ID_NODE) (strcmp(IDENTIFIER_POINTER (ID_NODE), \"this\") == 0)\n@@ -3423,19 +3336,11 @@ extern tree finish_member_class_template        PROTO((tree));\n extern void finish_template_decl                PROTO((tree));\n extern tree finish_template_type                PROTO((tree, tree, int));\n extern void enter_scope_of                      PROTO((tree));\n-extern tree finish_base_specifier               PROTO((tree, tree, int));\n+extern tree finish_base_specifier               PROTO((tree, tree));\n extern void finish_member_declaration           PROTO((tree));\n extern void check_multiple_declarators          PROTO((void));\n extern tree finish_typeof\t\t\tPROTO((tree));\n \n-/* in sig.c */\n-extern tree build_signature_pointer_type\tPROTO((tree));\n-extern tree build_signature_reference_type\tPROTO((tree));\n-extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n-extern tree build_signature_method_call\t\tPROTO((tree, tree));\n-extern tree build_optr_ref\t\t\tPROTO((tree));\n-extern void append_signature_fields\t\tPROTO((tree));\n-\n /* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));\n extern int peekyylex\t\t\t\tPROTO((void));\n@@ -3612,7 +3517,6 @@ extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n extern void readonly_error\t\t\tPROTO((tree, const char *, int));\n extern int abstract_virtuals_error\t\tPROTO((tree, tree));\n-extern void signature_error\t\t\tPROTO((tree, tree));\n extern void incomplete_type_error\t\tPROTO((tree, tree));\n extern void my_friendly_abort\t\t\tPROTO((int))\n   ATTRIBUTE_NORETURN;"}, {"sha": "388c7b864c4f677d652fdc1541fcbae4c1ffaef9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -234,10 +234,6 @@ cp_convert_to_pointer (type, expr)\n \n   my_friendly_assert (form != OFFSET_TYPE, 186);\n \n-  if (TYPE_LANG_SPECIFIC (intype)\n-      && (IS_SIGNATURE_POINTER (intype) || IS_SIGNATURE_REFERENCE (intype)))\n-    return convert_to_pointer (type, build_optr_ref (expr));\n-\n   if (integer_zerop (expr))\n     {\n       if (TYPE_PTRMEMFUNC_P (type))\n@@ -287,15 +283,6 @@ convert_to_pointer_force (type, expr)\n       return expr;\n     }\n \n-  /* Convert signature pointer/reference to `void *' first.  */\n-  if (form == RECORD_TYPE\n-      && (IS_SIGNATURE_POINTER (intype) || IS_SIGNATURE_REFERENCE (intype)))\n-    {\n-      expr = build_optr_ref (expr);\n-      intype = TREE_TYPE (expr);\n-      form = TREE_CODE (intype);\n-    }\n-\n   if (form == POINTER_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n@@ -801,29 +788,6 @@ ocp_convert (type, expr, convtype, flags)\n \n       dtype = TYPE_MAIN_VARIANT (dtype);\n \n-      /* Conversion of object pointers or signature pointers/references\n-\t to signature pointers/references.  */\n-\n-      if (TYPE_LANG_SPECIFIC (type)\n-\t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n-\t{\n-\t  tree constructor = build_signature_pointer_constructor (type, expr);\n-\t  tree sig_ty = SIGNATURE_TYPE (type);\n-\t  tree sig_ptr;\n-\n-\t  if (constructor == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  sig_ptr = get_temp_name (type, 1);\n-\t  DECL_INITIAL (sig_ptr) = constructor;\n-\t  CLEAR_SIGNATURE (sig_ty);\n-\t  cp_finish_decl (sig_ptr, constructor, NULL_TREE, 0, 0);\n-\t  SET_SIGNATURE (sig_ty);\n-\t  TREE_READONLY (sig_ptr) = 1;\n-\n-\t  return sig_ptr;\n-\t}\n-\n       /* Conversion between aggregate types.  New C++ semantics allow\n \t objects of derived type to be cast to objects of base type.\n \t Old semantics only allowed this between pointers."}, {"sha": "3dd53e9af633b657ea32e5ea770e30537f4efcb9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 232, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -239,8 +239,6 @@ tree error_mark_list;\n \ttree class_star_type_node;\n \ttree class_type_node, record_type_node, union_type_node, enum_type_node;\n \ttree unknown_type_node;\n-\ttree opaque_type_node, signature_type_node;\n-\ttree sigtable_entry_type;\n \n    Array type `vtable_entry_type[]'\n \n@@ -1809,18 +1807,6 @@ vtype_decl_p (t, data)\n \t  && CLASSTYPE_VSIZE (TREE_TYPE (t)));\n }\n \n-/* Returns non-zero if T is a signature table.  */\n-\n-int \n-sigtable_decl_p (t, data)\n-     tree t;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  return (TREE_CODE (t) == VAR_DECL\n-\t  && TREE_TYPE (t) != error_mark_node\n-\t  && IS_SIGNATURE (TREE_TYPE (t)));\n-}\n-\n /* Return the declarations that are members of the namespace NS.  */\n \n tree\n@@ -6119,7 +6105,6 @@ init_decl_processing ()\n   tree fields[20];\n   int wchar_type_size;\n   tree array_domain_type;\n-  tree vb_off_identifier = NULL_TREE;\n \n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");\n@@ -6197,12 +6182,6 @@ init_decl_processing ()\n   delta_identifier = get_identifier (VTABLE_DELTA_NAME);\n   delta2_identifier = get_identifier (VTABLE_DELTA2_NAME);\n   pfn_or_delta2_identifier = get_identifier (\"__pfn_or_delta2\");\n-  if (flag_handle_signatures)\n-    {\n-      tag_identifier = get_identifier (SIGTABLE_TAG_NAME);\n-      vb_off_identifier = get_identifier (SIGTABLE_VB_OFF_NAME);\n-      vt_off_identifier = get_identifier (SIGTABLE_VT_OFF_NAME);\n-    }\n \n   /* Define `int' and `char' first so that dbx will output them first.  */\n \n@@ -6449,11 +6428,6 @@ init_decl_processing ()\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n-  /* This is for handling opaque types in signatures.  */\n-  opaque_type_node = copy_node (ptr_type_node);\n-  TYPE_MAIN_VARIANT (opaque_type_node) = opaque_type_node;\n-  record_builtin_type (RID_MAX, 0, opaque_type_node);\n-\n   /* This is special for C++ so functions can be overloaded.  */\n   wchar_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (WCHAR_TYPE)));\n@@ -6520,44 +6494,6 @@ init_decl_processing ()\n   layout_type (vtbl_ptr_type_node);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n-  /* Simplify life by making a \"sigtable_entry_type\".  Give its\n-     fields names so that the debugger can use them.  */\n-\n-  if (flag_handle_signatures)\n-    {\n-      sigtable_entry_type = make_lang_type (RECORD_TYPE);\n-      fields[0] = build_lang_field_decl (FIELD_DECL, tag_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, vb_off_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[3] = build_lang_field_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t\t delta_type_node);\n-      fields[4] = build_lang_field_decl (FIELD_DECL, pfn_identifier,\n-\t\t\t\t\t ptr_type_node);\n-\n-      /* Set the alignment to the max of the alignment of ptr_type_node and\n-\t delta_type_node.  Double alignment wastes a word on the Sparc.  */\n-      finish_builtin_type (sigtable_entry_type, SIGTABLE_PTR_TYPE, fields, 4,\n-\t\t\t   (TYPE_ALIGN (ptr_type_node) > TYPE_ALIGN (delta_type_node))\n-\t\t\t   ? ptr_type_node\n-\t\t\t   : delta_type_node);\n-\n-      /* Make this part of an invisible union.  */\n-      fields[5] = copy_node (fields[4]);\n-      TREE_TYPE (fields[5]) = delta_type_node;\n-      DECL_NAME (fields[5]) = vt_off_identifier;\n-      DECL_MODE (fields[5]) = TYPE_MODE (delta_type_node);\n-      DECL_SIZE (fields[5]) = TYPE_SIZE (delta_type_node);\n-      TREE_UNSIGNED (fields[5]) = 0;\n-      TREE_CHAIN (fields[4]) = fields[5];\n-\n-      sigtable_entry_type = build_qualified_type (sigtable_entry_type, \n-\t\t\t\t\t\t  TYPE_QUAL_CONST);\n-      record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n-    }\n-\n   std_node = build_decl (NAMESPACE_DECL, \n \t\t\t get_identifier (flag_honor_std ? \"fake std\":\"std\"),\n \t\t\t void_type_node);\n@@ -7544,8 +7480,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     init = NULL_TREE;\n   else if (DECL_EXTERNAL (decl))\n     ;\n-  else if (TREE_CODE (type) == REFERENCE_TYPE\n-\t   || (TYPE_LANG_SPECIFIC (type) && IS_SIGNATURE_REFERENCE (type)))\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (TREE_STATIC (decl))\n \tmake_decl_rtl (decl, NULL_PTR,\n@@ -7902,14 +7837,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      || TREE_CODE (type) == METHOD_TYPE))\n \tabstract_virtuals_error (decl, TREE_TYPE (type));\n \n-      if (TYPE_LANG_SPECIFIC (core_type) && IS_SIGNATURE (core_type))\n-\tsignature_error (decl, core_type);\n-      else if ((TREE_CODE (type) == FUNCTION_TYPE\n-\t\t|| TREE_CODE (type) == METHOD_TYPE)\n-\t       && TYPE_LANG_SPECIFIC (TREE_TYPE (type))\n-\t       && IS_SIGNATURE (TREE_TYPE (type)))\n-\tsignature_error (decl, TREE_TYPE (type));\n-\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t;\n       else if (DECL_EXTERNAL (decl)\n@@ -8994,7 +8921,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   int explicit_int = 0;\n   int explicit_char = 0;\n   int defaulted_int = 0;\n-  int opaque_typedef = 0;\n   tree typedef_decl = NULL_TREE;\n   const char *name;\n   tree typedef_type = NULL_TREE;\n@@ -9484,10 +9410,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   typedef_type = type;\n \n   /* No type at all: default to `int', and set DEFAULTED_INT\n-     because it was not a user-defined typedef.\n-     Except when we have a `typedef' inside a signature, in\n-     which case the type defaults to `unknown type' and is\n-     instantiated when assigning to a signature pointer or ref.  */\n+     because it was not a user-defined typedef.  */\n \n   if (type == NULL_TREE\n       && (RIDBIT_SETP (RID_SIGNED, specbits)\n@@ -9509,15 +9432,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \ttype = build_pointer_type (ctor_return_type);\n       else if (return_type == return_conversion)\n \ttype = ctor_return_type;\n-      else if (current_class_type\n-\t       && IS_SIGNATURE (current_class_type)\n-\t       && RIDBIT_SETP (RID_TYPEDEF, specbits)\n-\t       && (decl_context == FIELD || decl_context == NORMAL))\n-\t{\n-\t  explicit_int = 0;\n-\t  opaque_typedef = 1;\n-\t  type = copy_node (opaque_type_node);\n-\t}\n       else\n \t{\n \t  /* We handle `main' specially here, because 'main () { }' is so\n@@ -9799,37 +9713,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && ANON_AGGR_TYPE_P (TREE_VALUE (declspecs)))\n     decl_context = FIELD;\n \n-  /* Give error if `const,' `volatile,' `inline,' `friend,' or `virtual'\n-     is used in a signature member function declaration.  */\n-  if (decl_context == FIELD\n-      && IS_SIGNATURE (current_class_type)\n-      && RIDBIT_NOTSETP (RID_TYPEDEF, specbits))\n-    {\n-      if (type_quals != TYPE_UNQUALIFIED)\n-\t{\n-\t  error (\"type qualifiers specified for signature member function `%s'\", name);\n-\t  type_quals = TYPE_UNQUALIFIED;\n-\t}\n-      if (inlinep)\n-\t{\n-\t  error (\"`inline' specified for signature member function `%s'\", name);\n-\t  /* Later, we'll make signature member functions inline.  */\n-\t  inlinep = 0;\n-\t}\n-      if (friendp)\n-\t{\n-\t  error (\"`friend' declaration in signature definition\");\n-\t  friendp = 0;\n-\t}\n-      if (virtualp)\n-\t{\n-\t  error (\"`virtual' specified for signature member function `%s'\",\n-\t\t name);\n-\t  /* Later, we'll make signature member functions virtual.  */\n-\t  virtualp = 0;\n-\t}\n-    }\n-\n   /* Warn about storage classes that are invalid for certain\n      kinds of declarations (parameters, typenames, etc.).  */\n \n@@ -9844,7 +9727,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       else if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n \t;\n       else if (decl_context == FIELD\n-\t       && ! IS_SIGNATURE (current_class_type)\n  \t       /* C++ allows static class elements  */\n  \t       && RIDBIT_SETP (RID_STATIC, specbits))\n  \t/* C++ also allows inlines and signed and unsigned elements,\n@@ -9867,11 +9749,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  op = IDENTIFIER_OPNAME_P (tmp);\n \t\t}\n \t      error (\"storage class specified for %s `%s'\",\n-\t\t     IS_SIGNATURE (current_class_type)\n-\t\t     ? (op\n-\t\t\t? \"signature member operator\"\n-\t\t\t: \"signature member function\")\n-\t\t     : (op ? \"member operator\" : \"field\"),\n+\t\t     op ? \"member operator\" : \"field\",\n \t\t     op ? operator_name_string (tmp) : name);\n \t    }\n \t  else\n@@ -9881,12 +9759,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  RIDBIT_RESET (RID_REGISTER, specbits);\n \t  RIDBIT_RESET (RID_AUTO, specbits);\n \t  RIDBIT_RESET (RID_EXTERN, specbits);\n-\n-\t  if (decl_context == FIELD && IS_SIGNATURE (current_class_type))\n-\t    {\n-\t      RIDBIT_RESET (RID_STATIC, specbits);\n-\t      staticp = 0;\n-\t    }\n \t}\n     }\n   else if (RIDBIT_SETP (RID_EXTERN, specbits) && initialized && !funcdef_flag)\n@@ -10290,13 +10162,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\terror (\"return value type specifier for constructor ignored\");\n \t\t    }\n \t\t    type = build_pointer_type (ctype);\n-\t\t    if (decl_context == FIELD\n-\t\t\t&& IS_SIGNATURE (current_class_type))\n-\t\t      {\n-\t\t\terror (\"constructor not allowed in signature\");\n-\t\t\treturn void_type_node;\n-\t\t      }\t\t\t  \n-\t\t    else if (decl_context == FIELD)\n+\t\t    if (decl_context == FIELD)\n \t\t      {\n \t\t\tif (! member_function_or_else (ctype, current_class_type,\n \t\t\t\t\t\t       \"constructor for alien class `%s' cannot be member\"))\n@@ -10403,31 +10269,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t     but to the target of the pointer.  */\n \t  type_quals = TYPE_UNQUALIFIED;\n \n-\t  if (IS_SIGNATURE (type))\n-\t    {\n-\t      if (TREE_CODE (declarator) == ADDR_EXPR)\n-\t\t{\n-\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE\n-\t\t      && TYPE_SIZE (type))\n-\t\t    cp_warning (\"empty signature `%T' used in signature reference declaration\",\n-\t\t\t\ttype);\n-#if 0\n-\t\t  type = build_signature_reference_type (type);\n-#else\n-\t\t  sorry (\"signature reference\");\n-\t\t  return NULL_TREE;\n-#endif\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (CLASSTYPE_METHOD_VEC (type) == NULL_TREE\n-\t\t      && TYPE_SIZE (type))\n-\t\t    cp_warning (\"empty signature `%T' used in signature pointer declaration\",\n-\t\t\t\ttype);\n-\t\t  type = build_signature_pointer_type (type);\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (declarator) == ADDR_EXPR)\n+\t  if (TREE_CODE (declarator) == ADDR_EXPR)\n \t    {\n \t      if (TREE_CODE (type) == VOID_TYPE)\n \t\terror (\"invalid type: `void &'\");\n@@ -10736,8 +10578,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    cp_pedwarn (\"ANSI C++ forbids nested type `%D' with same name as enclosing class\",\n \t\t\tdeclarator);\n \t  decl = build_lang_decl (TYPE_DECL, declarator, type);\n-\t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n-\t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n \t}\n       else\n \t{\n@@ -10851,11 +10691,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters.  */\n       if (type_quals != TYPE_UNQUALIFIED)\n-\t{\n-\t  if (IS_SIGNATURE (type))\n-\t    error (\"type qualifiers specified for signature type\");\n-\t  type_quals = TYPE_UNQUALIFIED;\n-\t}\n+\ttype_quals = TYPE_UNQUALIFIED;\n \n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n@@ -10965,16 +10801,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \tbad_specifiers (decl, \"parameter\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n-\tif (current_class_type\n-\t    && IS_SIGNATURE (current_class_type))\n-\t  {\n-\t    if (inlinep)\n-\t      error (\"parameter of signature member function declared `inline'\");\n-\t    if (RIDBIT_SETP (RID_AUTO, specbits))\n-\t      error (\"parameter of signature member function declared `auto'\");\n-\t    if (RIDBIT_SETP (RID_REGISTER, specbits))\n-\t      error (\"parameter of signature member function declared `register'\");\n-\t  }\n \n \t/* Compute the type actually passed in the parmlist,\n \t   for the case where there is no prototype.\n@@ -11671,13 +11497,6 @@ grokparms (first_parm, funcdef_flag)\n \t\t    }\n                   else if (abstract_virtuals_error (decl, type))\n \t\t    any_error = 1;  /* Seems like a good idea. */\n-                  else if (TREE_CODE (type) == RECORD_TYPE\n-                           && TYPE_LANG_SPECIFIC (type)\n-                           && IS_SIGNATURE (type))\n-                    {\n-                      signature_error (decl, type);\n-                      any_error = 1;  /* Seems like a good idea. */\n-                    }\n \t\t  else if (POINTER_TYPE_P (type))\n \t\t    {\n \t\t      tree t = type;\n@@ -12208,8 +12027,6 @@ tag_name (code)\n       return \"union \";\n     case enum_type:\n       return \"enum\";\n-    case signature_type:\n-      return \"signature\";\n     default:\n       my_friendly_abort (981122);\n     }\n@@ -12255,7 +12072,6 @@ xref_tag (code_type_node, name, globalize)\n     {\n     case record_type:\n     case class_type:\n-    case signature_type:\n       code = RECORD_TYPE;\n       break;\n     case union_type:\n@@ -12420,17 +12236,6 @@ xref_tag (code_type_node, name, globalize)\n \t  ref = make_lang_type (code);\n \t  TYPE_CONTEXT (ref) = context;\n \n-\t  if (tag_code == signature_type)\n-\t    {\n-\t      SET_SIGNATURE (ref);\n-\t      /* Since a signature type will be turned into the type\n-\t\t of signature tables, it's not only an interface.  */\n-\t      CLASSTYPE_INTERFACE_ONLY (ref) = 0;\n-\t      SET_CLASSTYPE_INTERFACE_KNOWN (ref);\n-\t      /* A signature doesn't have a vtable.  */\n-\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ref) = 0;\n-\t    }\n-\n #ifdef NONNESTED_CLASSES\n \t  /* Class types don't nest the way enums do.  */\n \t  class_binding_level = (struct binding_level *)0;\n@@ -12464,7 +12269,7 @@ xref_tag (code_type_node, name, globalize)\n     {\n       if (tag_code == class_type)\n \tCLASSTYPE_DECLARED_CLASS (ref) = 1;\n-      else if (tag_code == record_type || tag_code == signature_type)\n+      else if (tag_code == record_type)\n \tCLASSTYPE_DECLARED_CLASS (ref) = 0;\n     }\n \n@@ -13305,35 +13110,28 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t     we keep the consistency between `current_class_type'\n \t     and `current_class_ptr'.  */\n \t  tree t = current_function_parms;\n-\n+\t  int i;\n+\t      \n \t  my_friendly_assert (t != NULL_TREE\n \t\t\t      && TREE_CODE (t) == PARM_DECL, 162);\n-\n-\t  if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n-\t    {\n-\t      int i;\n-\n-\t      if (! hack_decl_function_context (decl1))\n-\t\ttemporary_allocation ();\n-\t      i = suspend_momentary ();\n-\n-\t      /* Normally, build_indirect_ref returns\n-\t\t current_class_ref whenever current_class_ptr is\n-\t\t dereferenced.  This time, however, we want it to\n-\t\t *create* current_class_ref, so we temporarily clear\n-\t\t current_class_ptr to fool it.  */\n-\t      current_class_ptr = NULL_TREE;\n-\t      current_class_ref = build_indirect_ref (t, NULL_PTR);\n-\t      current_class_ptr = t;\n-\n-\t      resume_momentary (i);\n-\t      if (! hack_decl_function_context (decl1))\n-\t\tend_temporary_allocation ();\n-\t    }\n-\t  else\n-\t    /* We're having a signature pointer here.  */\n-\t    current_class_ref = current_class_ptr = t;\n-\n+\t  my_friendly_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE,\n+\t\t\t      19990811);\n+\t  \n+\t  if (! hack_decl_function_context (decl1))\n+\t    temporary_allocation ();\n+\t  i = suspend_momentary ();\n+\t  \n+\t  /* Normally, build_indirect_ref returns current_class_ref\n+\t     whenever current_class_ptr is dereferenced.  This time,\n+\t     however, we want it to *create* current_class_ref, so we\n+\t     temporarily clear current_class_ptr to fool it.  */\n+\t  current_class_ptr = NULL_TREE;\n+\t  current_class_ref = build_indirect_ref (t, NULL_PTR);\n+\t  current_class_ptr = t;\n+\t  \n+\t  resume_momentary (i);\n+\t  if (! hack_decl_function_context (decl1))\n+\t    end_temporary_allocation ();\n \t}\n     }\n   else\n@@ -14273,9 +14071,6 @@ start_method (declspecs, declarator, attrlist)\n     /* Not a function, tell parser to report parse error.  */\n     return NULL_TREE;\n \n-  if (IS_SIGNATURE (current_class_type))\n-    IS_DEFAULT_IMPLEMENTATION (fndecl) = 1;\n-\n   if (DECL_IN_AGGR_P (fndecl))\n     {\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (fndecl)) != current_class_type)"}, {"sha": "8141d7619a2d28e455b0209a27b833e413b8939d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -73,7 +73,6 @@ static void mark_vtable_entries PROTO((tree));\n static void grok_function_init PROTO((tree, tree));\n static int finish_vtable_vardecl PROTO((tree *, void *));\n static int prune_vtable_vardecl PROTO((tree *, void *));\n-static int finish_sigtable_vardecl PROTO((tree *, void *));\n static int is_namespace_ancestor PROTO((tree, tree));\n static void add_using_namespace PROTO((tree, tree, int));\n static tree ambiguous_decl PROTO((tree, tree, tree,int));\n@@ -385,10 +384,6 @@ int flag_this_is_variable;\n \n int flag_elide_constructors = 1;\n \n-/* Nonzero means recognize and handle signature language constructs.  */\n-\n-int flag_handle_signatures;\n-\n /* Nonzero means that member functions defined in class scope are\n    inline by default.  */\n \n@@ -509,7 +504,6 @@ lang_f_options[] =\n   {\"for-scope\", &flag_new_for_scope, 2},\n   {\"gnu-keywords\", &flag_no_gnu_keywords, 0},\n   {\"handle-exceptions\", &flag_exceptions, 1},\n-  {\"handle-signatures\", &flag_handle_signatures, 1},\n   {\"honor-std\", &flag_honor_std, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n@@ -1648,13 +1642,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       return value;\n     }\n \n-  if (IS_SIGNATURE (current_class_type)\n-      && TREE_CODE (value) != FUNCTION_DECL)\n-    {\n-      error (\"field declaration not allowed in signature\");\n-      return void_type_node;\n-    }\n-\n   if (DECL_IN_AGGR_P (value))\n     {\n       cp_error (\"`%D' is already defined in `%T'\", value,\n@@ -1667,13 +1654,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n   if (init)\n     {\n-      if (IS_SIGNATURE (current_class_type)\n-\t  && TREE_CODE (value) == FUNCTION_DECL)\n-\t{\n-\t  error (\"function declarations cannot have initializers in signature\");\n-\t  init = NULL_TREE;\n-\t}\n-      else if (TREE_CODE (value) == FUNCTION_DECL)\n+      if (TREE_CODE (value) == FUNCTION_DECL)\n \t{\n \t  grok_function_init (value, init);\n \t  init = NULL_TREE;\n@@ -1771,12 +1752,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       if (DECL_FRIEND_P (value))\n \treturn void_type_node;\n \n-#if 0 /* Just because a fn is declared doesn't mean we'll try to define it.  */\n-      if (current_function_decl && ! IS_SIGNATURE (current_class_type))\n-\tcp_error (\"method `%#D' of local class must be defined in class body\",\n-\t\t  value);\n-#endif\n-\n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n     }\n@@ -1818,12 +1793,6 @@ grokbitfield (declarator, declspecs, width)\n       return NULL_TREE;\n     }\n \n-  if (IS_SIGNATURE (current_class_type))\n-    {\n-      error (\"field declaration not allowed in signature\");\n-      return void_type_node;\n-    }\n-\n   if (DECL_IN_AGGR_P (value))\n     {\n       cp_error (\"`%D' is already defined in the class %T\", value,\n@@ -2729,20 +2698,6 @@ prune_vtable_vardecl (t, data)\n   return 1;\n }\n \n-static int\n-finish_sigtable_vardecl (t, data)\n-     tree *t;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  /* We don't need to mark sigtable entries as addressable here as is done\n-     for vtables.  Since sigtables, unlike vtables, are always written out,\n-     that was already done in build_signature_table_constructor.  */\n-\n-  rest_of_decl_compilation (*t, NULL_PTR, 1, 1);\n-  *t = TREE_CHAIN (*t);\n-  return 1;\n-}\n-\n /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n    inline function or template instantiation at end-of-file.  */\n \n@@ -3587,14 +3542,9 @@ finish_file ()\n \t them now.  */\n       instantiate_pending_templates ();\n \n-      /* Write out signature-tables and virtual tables as required.\n-\t Note that writing out the virtual table for a template class\n-\t may cause the instantiation of members of that class.  */\n-      if (flag_handle_signatures\n-\t  && walk_globals (sigtable_decl_p,\n-\t\t\t   finish_sigtable_vardecl,\n-\t\t\t   /*data=*/0))\n-\treconsider = 1;\n+      /* Write out virtual tables as required.  Note that writing out\n+\t the virtual table for a template class may cause the\n+\t instantiation of members of that class.  */\n       if (walk_globals (vtable_decl_p,\n \t\t\tfinish_vtable_vardecl,\n \t\t\t/*data=*/0))\n@@ -3800,12 +3750,6 @@ reparse_absdcl_as_casts (decl, expr)\n       type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n       decl = TREE_OPERAND (decl, 0);\n \n-      if (IS_SIGNATURE (type))\n-\t{\n-\t  error (\"cast specifies signature type\");\n-\t  return error_mark_node;\n-\t}\n-\n       expr = digest_init (type, expr, (tree *) 0);\n       if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n \t{"}, {"sha": "9c911ada7b8218b957b46c8be4017a06bb165a2a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -227,18 +227,7 @@ dump_type_real (t, v, canonical_name)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n-      if (TYPE_LANG_SPECIFIC (t)\n-\t  && (IS_SIGNATURE_POINTER (t) || IS_SIGNATURE_REFERENCE (t)))\n-\t{\n-\t  dump_qualifiers (t, after);\n-\t  dump_type_real (SIGNATURE_TYPE (t), v, canonical_name);\n-\t  if (IS_SIGNATURE_POINTER (t))\n-\t    OB_PUTC ('*');\n-\t  else\n-\t    OB_PUTC ('&');\n-\t}\n-      else\n-\tdump_aggr_type (t, v, canonical_name);\n+      dump_aggr_type (t, v, canonical_name);\n       break;\n \n     case TYPE_DECL:\n@@ -356,8 +345,6 @@ aggr_variety (t)\n     return \"union\";\n   else if (TYPE_LANG_SPECIFIC (t) && CLASSTYPE_DECLARED_CLASS (t))\n     return \"class\";\n-  else if (TYPE_LANG_SPECIFIC (t) && IS_SIGNATURE (t))\n-    return \"signature\";\n   else\n     return \"struct\";\n }\n@@ -1035,15 +1022,8 @@ dump_function_decl (t, v)\n     dump_type_suffix (TREE_TYPE (fntype), 1, 0);\n \n   if (TREE_CODE (fntype) == METHOD_TYPE)\n-    {\n-      if (IS_SIGNATURE (cname))\n-\t/* We look at the type pointed to by the `optr' field of `this.'  */\n-\tdump_qualifiers\n-\t  (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_VALUE (TYPE_ARG_TYPES (fntype))))), before);\n-      else\n-\tdump_qualifiers\n-\t  (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))), before);\n-    }\n+    dump_qualifiers (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n+\t\t     before);\n   \n   if (v >= 2)\n     dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), 0);"}, {"sha": "410eaf5c82bfc9492cc4258c9072510437b857a0", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -243,12 +243,7 @@ make_friend_class (type, friend_type)\n   tree classes;\n   int is_template_friend;\n \n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"`friend' declaration in signature definition\");\n-      return;\n-    }\n-  if (IS_SIGNATURE (friend_type) || ! IS_AGGR_TYPE (friend_type))\n+  if (! IS_AGGR_TYPE (friend_type))\n     {\n       cp_error (\"invalid type `%T' declared `friend'\", friend_type);\n       return;"}, {"sha": "4c191c542dc243833b0615fb0576cf4bf380988c", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -25,10 +25,8 @@ __real, REALPART, RID_UNUSED\n __real__, REALPART, RID_UNUSED\n __restrict, CV_QUALIFIER, RID_RESTRICT\n __restrict__, CV_QUALIFIER, RID_RESTRICT\n-__signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED\n-__sigof__, SIGOF, RID_UNUSED\t\t/* Extension */,\n __typeof, TYPEOF, RID_UNUSED\n __typeof__, TYPEOF, RID_UNUSED\n __volatile, CV_QUALIFIER, RID_VOLATILE\n@@ -84,9 +82,7 @@ register, SCSPEC, RID_REGISTER,\n reinterpret_cast, REINTERPRET_CAST, RID_UNUSED,\n return, RETURN_KEYWORD, RID_UNUSED,\n short, TYPESPEC, RID_SHORT,\n-signature, AGGR, RID_SIGNATURE\t/* Extension */,\n signed, TYPESPEC, RID_SIGNED,\n-sigof, SIGOF, RID_UNUSED\t\t/* Extension */,\n sizeof, SIZEOF, RID_UNUSED,\n static, SCSPEC, RID_STATIC,\n static_cast, STATIC_CAST, RID_UNUSED,"}, {"sha": "4d7fac782c977ef16eee1a0a9b06b6066056ae6e", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 140, "deletions": 138, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -1,14 +1,14 @@\n-/* C code produced by gperf version 2.7 */\n-/* Command-line: gperf -L C -F , 0, 0 -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../../egcs/gcc/cp/gxx.gperf  */\n+/* C code produced by gperf version 2.7.1 (19981006 egcs) */\n+/* Command-line: gperf -L C -F , 0, 0 -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../gcc/cp/gxx.gperf  */\n /* Command-line: gperf -L KR-C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { const char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 107\n+#define TOTAL_KEYWORDS 103\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 244\n-/* maximum key range = 241, duplicates = 0 */\n+#define MAX_HASH_VALUE 274\n+/* maximum key range = 271, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -18,34 +18,34 @@ hash (str, len)\n      register const char *str;\n      register unsigned int len;\n {\n-  static unsigned char asso_values[] =\n+  static unsigned short asso_values[] =\n     {\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245,   0, 245,  92,   3,   3,\n-        0,   0,  75,  24,   0,  90, 245,  10,  31,  49,\n-       23,  74,   0,  24,  30,  37,   6,  77,  10,  19,\n-        5,   4, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245, 245, 245, 245, 245,\n-      245, 245, 245, 245, 245, 245\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275,   0, 275,  97,   1,  19,\n+       40,   0,  12,  68,   0,  74, 275,   0,  11,  67,\n+       27,   0,  70,   6,  96,  43,   6,  37,   3,  10,\n+        8, 104, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n+      275, 275, 275, 275, 275, 275\n     };\n   register int hval = len;\n \n@@ -79,156 +79,158 @@ is_reserved_word (str, len)\n     {\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"else\", ELSE, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"delete\", DELETE, RID_UNUSED,},\n-      {\"case\", CASE, RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"__real__\", REALPART, RID_UNUSED},\n-      {\"double\", TYPESPEC, RID_DOUBLE,},\n+      {\"\", 0, 0},\n       {\"true\", CXX_TRUE, RID_UNUSED,},\n-      {\"catch\", CATCH, RID_UNUSED,},\n-      {\"typeid\", TYPEID, RID_UNUSED,},\n-      {\"try\", TRY, RID_UNUSED,},\n-      {\"void\", TYPESPEC, RID_VOID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"private\", VISSPEC, RID_PRIVATE,},\n+      {\"or_eq\", ASSIGN, RID_UNUSED,},\n+      {\"export\", SCSPEC, RID_EXPORT,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"template\", TEMPLATE, RID_TEMPLATE,},\n-      {\"protected\", VISSPEC, RID_PROTECTED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"__const__\", CV_QUALIFIER, RID_CONST},\n+      {\"__volatile\", CV_QUALIFIER, RID_VOLATILE},\n+      {\"__real\", REALPART, RID_UNUSED},\n+      {\"__volatile__\", CV_QUALIFIER, RID_VOLATILE},\n+      {\"__const\", CV_QUALIFIER, RID_CONST},\n+      {\"xor_eq\", ASSIGN, RID_UNUSED,},\n+      {\"throw\", THROW, RID_UNUSED,},\n+      {\"__complex__\", TYPESPEC, RID_COMPLEX},\n+      {\"case\", CASE, RID_UNUSED,},\n+      {\"typeof\", TYPEOF, RID_UNUSED,},\n+      {\"\", 0, 0},\n+      {\"while\", WHILE, RID_UNUSED,},\n+      {\"bool\", TYPESPEC, RID_BOOL,},\n+      {\"__complex\", TYPESPEC, RID_COMPLEX},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"extern\", SCSPEC, RID_EXTERN,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n       {\"not\", '!', RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"xor_eq\", ASSIGN, RID_UNUSED,},\n+      {\"typedef\", SCSPEC, RID_TYPEDEF,},\n+      {\"virtual\", SCSPEC, RID_VIRTUAL,},\n+      {\"not_eq\", EQCOMPARE, RID_UNUSED,},\n+      {\"new\", NEW, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"__real\", REALPART, RID_UNUSED},\n-      {\"xor\", '^', RID_UNUSED,},\n-      {\"compl\", '~', RID_UNUSED,},\n-      {\"public\", VISSPEC, RID_PUBLIC,},\n+      {\"do\", DO, RID_UNUSED,},\n+      {\"catch\", CATCH, RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"delete\", DELETE, RID_UNUSED,},\n+      {\"double\", TYPESPEC, RID_DOUBLE,},\n       {\"__extension__\", EXTENSION, RID_UNUSED},\n-      {\"__restrict__\", CV_QUALIFIER, RID_RESTRICT},\n-      {\"\", 0, 0},\n+      {\"__alignof__\", ALIGNOF, RID_UNUSED},\n       {\"__asm__\", ASM_KEYWORD, RID_UNUSED},\n-      {\"new\", NEW, RID_UNUSED,},\n-      {\"__restrict\", CV_QUALIFIER, RID_RESTRICT},\n       {\"\", 0, 0},\n-      {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"switch\", SWITCH, RID_UNUSED,},\n+      {\"typeid\", TYPEID, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"const\", CV_QUALIFIER, RID_CONST,},\n-      {\"static\", SCSPEC, RID_STATIC,},\n-      {\"not_eq\", EQCOMPARE, RID_UNUSED,},\n+      {\"__null\", CONSTANT, RID_NULL},\n+      {\"switch\", SWITCH, RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"friend\", SCSPEC, RID_FRIEND,},\n+      {\"__alignof\", ALIGNOF, RID_UNUSED},\n+      {\"false\", CXX_FALSE, RID_UNUSED,},\n+      {\"sizeof\", SIZEOF, RID_UNUSED,},\n       {\"__inline\", SCSPEC, RID_INLINE},\n-      {\"while\", WHILE, RID_UNUSED,},\n+      {\"\", 0, 0},\n       {\"__inline__\", SCSPEC, RID_INLINE},\n-      {\"__imag__\", IMAGPART, RID_UNUSED},\n       {\"\", 0, 0},\n-      {\"const_cast\", CONST_CAST, RID_UNUSED,},\n       {\"static_cast\", STATIC_CAST, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"union\", AGGR, RID_UNION,},\n+      {\"continue\", CONTINUE, RID_UNUSED,},\n+      {\"\", 0, 0},\n+      {\"goto\", GOTO, RID_UNUSED,},\n+      {\"const\", CV_QUALIFIER, RID_CONST,},\n+      {\"static\", SCSPEC, RID_STATIC,},\n+      {\"__imag__\", IMAGPART, RID_UNUSED},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"private\", VISSPEC, RID_PRIVATE,},\n       {\"typename\", TYPENAME_KEYWORD, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"__alignof__\", ALIGNOF, RID_UNUSED},\n-      {\"signed\", TYPESPEC, RID_SIGNED,},\n-      {\"char\", TYPESPEC, RID_CHAR,},\n+      {\"int\", TYPESPEC, RID_INT,},\n+      {\"__signed__\", TYPESPEC, RID_SIGNED},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"void\", TYPESPEC, RID_VOID,},\n+      {\"if\", IF, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"bool\", TYPESPEC, RID_BOOL,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"do\", DO, RID_UNUSED,},\n+      {\"template\", TEMPLATE, RID_TEMPLATE,},\n+      {\"__attribute\", ATTRIBUTE, RID_UNUSED},\n+      {\"struct\", AGGR, RID_RECORD,},\n+      {\"__attribute__\", ATTRIBUTE, RID_UNUSED},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"this\", THIS, RID_UNUSED,},\n+      {\"const_cast\", CONST_CAST, RID_UNUSED,},\n+      {\"or\", OROR, RID_UNUSED,},\n+      {\"explicit\", SCSPEC, RID_EXPLICIT,},\n       {\"\", 0, 0},\n-      {\"short\", TYPESPEC, RID_SHORT,},\n-      {\"__imag\", IMAGPART, RID_UNUSED},\n+      {\"auto\", SCSPEC, RID_AUTO,},\n+      {\"bitor\", '|', RID_UNUSED,},\n+      {\"break\", BREAK, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"friend\", SCSPEC, RID_FRIEND,},\n+      {\"compl\", '~', RID_UNUSED,},\n+      {\"public\", VISSPEC, RID_PUBLIC,},\n+      {\"xor\", '^', RID_UNUSED,},\n+      {\"__restrict__\", CV_QUALIFIER, RID_RESTRICT},\n+      {\"and_eq\", ASSIGN, RID_UNUSED,},\n       {\"class\", AGGR, RID_CLASS,},\n-      {\"long\", TYPESPEC, RID_LONG,},\n-      {\"this\", THIS, RID_UNUSED,},\n-      {\"virtual\", SCSPEC, RID_VIRTUAL,},\n-      {\"export\", SCSPEC, RID_EXPORT,},\n-      {\"typeof\", TYPEOF, RID_UNUSED,},\n+      {\"for\", FOR, RID_UNUSED,},\n+      {\"__restrict\", CV_QUALIFIER, RID_RESTRICT},\n+      {\"try\", TRY, RID_UNUSED,},\n       {\"__typeof__\", TYPEOF, RID_UNUSED},\n-      {\"__const__\", CV_QUALIFIER, RID_CONST},\n-      {\"__volatile\", CV_QUALIFIER, RID_VOLATILE},\n       {\"__asm\", ASM_KEYWORD, RID_UNUSED},\n-      {\"__volatile__\", CV_QUALIFIER, RID_VOLATILE},\n-      {\"__const\", CV_QUALIFIER, RID_CONST},\n-      {\"continue\", CONTINUE, RID_UNUSED,},\n-      {\"and\", ANDAND, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"signed\", TYPESPEC, RID_SIGNED,},\n+      {\"__label__\", LABEL, RID_UNUSED},\n+      {\"\", 0, 0},\n+      {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n+      {\"float\", TYPESPEC, RID_FLOAT,},\n+      {\"\", 0, 0},\n       {\"__signed\", TYPESPEC, RID_SIGNED},\n-      {\"int\", TYPESPEC, RID_INT,},\n-      {\"__signed__\", TYPESPEC, RID_SIGNED},\n-      {\"bitand\", '&', RID_UNUSED,},\n-      {\"enum\", ENUM, RID_UNUSED,},\n-      {\"or_eq\", ASSIGN, RID_UNUSED,},\n-      {\"throw\", THROW, RID_UNUSED,},\n-      {\"reinterpret_cast\", REINTERPRET_CAST, RID_UNUSED,},\n-      {\"or\", OROR, RID_UNUSED,},\n-      {\"__attribute\", ATTRIBUTE, RID_UNUSED},\n-      {\"for\", FOR, RID_UNUSED,},\n-      {\"__attribute__\", ATTRIBUTE, RID_UNUSED},\n-      {\"break\", BREAK, RID_UNUSED,},\n-      {\"default\", DEFAULT, RID_UNUSED,},\n-      {\"bitor\", '|', RID_UNUSED,},\n-      {\"dynamic_cast\", DYNAMIC_CAST, RID_UNUSED,},\n-      {\"__null\", CONSTANT, RID_NULL},\n       {\"\", 0, 0},\n-      {\"__complex__\", TYPESPEC, RID_COMPLEX},\n-      {\"false\", CXX_FALSE, RID_UNUSED,},\n-      {\"sizeof\", SIZEOF, RID_UNUSED,},\n-      {\"__complex\", TYPESPEC, RID_COMPLEX},\n+      {\"__typeof\", TYPEOF, RID_UNUSED},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"and_eq\", ASSIGN, RID_UNUSED,},\n       {\"__builtin_va_arg\", VA_ARG, RID_UNUSED},\n-      {\"namespace\", NAMESPACE, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"struct\", AGGR, RID_RECORD,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"protected\", VISSPEC, RID_PROTECTED,},\n+      {\"\", 0, 0},\n+      {\"namespace\", NAMESPACE, RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"using\", USING, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__label__\", LABEL, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"explicit\", SCSPEC, RID_EXPLICIT,},\n-      {\"return\", RETURN_KEYWORD, RID_UNUSED,},\n+      {\"enum\", ENUM, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"__alignof\", ALIGNOF, RID_UNUSED},\n+      {\"and\", ANDAND, RID_UNUSED,},\n+      {\"__imag\", IMAGPART, RID_UNUSED},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n+      {\"bitand\", '&', RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"short\", TYPESPEC, RID_SHORT,},\n+      {\"long\", TYPESPEC, RID_LONG,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"asm\", ASM_KEYWORD, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"signature\", AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"inline\", SCSPEC, RID_INLINE,},\n       {\"\", 0, 0},\n-      {\"mutable\", SCSPEC, RID_MUTABLE,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"register\", SCSPEC, RID_REGISTER,},\n+      {\"default\", DEFAULT, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__typeof\", TYPEOF, RID_UNUSED},\n-      {\"\", 0, 0},\n-      {\"typedef\", SCSPEC, RID_TYPEDEF,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"if\", IF, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__sigof__\", SIGOF, RID_UNUSED\t\t/* Extension */,},\n       {\"unsigned\", TYPESPEC, RID_UNSIGNED,},\n-      {\"goto\", GOTO, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"float\", TYPESPEC, RID_FLOAT,},\n-      {\"union\", AGGR, RID_UNION,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"inline\", SCSPEC, RID_INLINE,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"sigof\", SIGOF, RID_UNUSED\t\t/* Extension */,},\n+      {\"return\", RETURN_KEYWORD, RID_UNUSED,},\n+      {\"asm\", ASM_KEYWORD, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__signature__\", AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"mutable\", SCSPEC, RID_MUTABLE,},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"dynamic_cast\", DYNAMIC_CAST, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"operator\", OPERATOR, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"char\", TYPESPEC, RID_CHAR,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"reinterpret_cast\", REINTERPRET_CAST, RID_UNUSED,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"auto\", SCSPEC, RID_AUTO,}\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"register\", SCSPEC, RID_REGISTER,}\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "3a70672495e7135053901d985a902cf38509c1f9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -2214,12 +2214,6 @@ build_new_1 (exp)\n   if (abstract_virtuals_error (NULL_TREE, true_type))\n     return error_mark_node;\n \n-  if (TYPE_LANG_SPECIFIC (true_type) && IS_SIGNATURE (true_type))\n-    {\n-      signature_error (NULL_TREE, true_type);\n-      return error_mark_node;\n-    }\n-  \n   /* When we allocate an array, and the corresponding deallocation\n      function takes a second argument of type size_t, and that's the\n      \"usual deallocation function\", we allocate some extra space at"}, {"sha": "c0a4a34680cd7d57ffbd4634a014af9b0f300e9f", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -56,8 +56,6 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-gnu-keywords\", \"Do not recognise GNU defined keywords\" },\n   { \"-fhandle-exceptions\", \"\" },\n   { \"-fno-handle-exceptions\", \"\" },\n-  { \"-fhandle-signatures\", \"Handle signature language constructs\" },\n-  { \"-fno-handle-signatures\", \"\" },\n   { \"-fhonor-std\", \"Treat the namespace `std' as a normal namespace\" },\n   { \"-fno-honor-std\", \"\" },\n   { \"-fhuge-objects\", \"Enable support for huge objects\" },"}, {"sha": "30eaa85e4ab4db38ee75b224cf7ad4c3e54cda8d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -733,11 +733,6 @@ init_parse (filename)\n   /* This is for ANSI C++.  */\n   ridpointers[(int) RID_MUTABLE] = get_identifier (\"mutable\");\n \n-  /* Signature handling extensions.  */\n-  signature_type_node = build_int_2 (signature_type, 0);\n-  TREE_TYPE (signature_type_node) = signature_type_node;\n-  ridpointers[(int) RID_SIGNATURE] = signature_type_node;\n-\n   /* Create the built-in __null node.  Note that we can't yet call for\n      type_for_size here because integer_type_node and so forth are not\n      set up.  Therefore, we don't set the type of these nodes until\n@@ -850,13 +845,6 @@ init_parse (filename)\n       UNSET_RESERVED_WORD (\"headof\");\n     }\n \n-  if (! flag_handle_signatures || flag_no_gnu_keywords)\n-    {\n-      /* Easiest way to not recognize signature\n-\t handling extensions...  */\n-      UNSET_RESERVED_WORD (\"signature\");\n-      UNSET_RESERVED_WORD (\"sigof\");\n-    }\n   if (flag_no_asm || flag_no_gnu_keywords)\n     UNSET_RESERVED_WORD (\"typeof\");\n   if (! flag_operator_names)\n@@ -941,8 +929,6 @@ yyprint (file, yychar, yylval)\n \tfprintf (file, \" `union'\");\n       else if (yylval.ttype == enum_type_node)\n \tfprintf (file, \" `enum'\");\n-      else if (yylval.ttype == signature_type_node)\n-\tfprintf (file, \" `signature'\");\n       else\n \tmy_friendly_abort (80);\n       break;"}, {"sha": "8f997ad189fe97fa446090f22a03d235b2c44655", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -76,7 +76,6 @@ enum rid\n   RID_PROTECTED,\n   RID_EXCEPTION,\n   RID_TEMPLATE,\n-  RID_SIGNATURE,\n   RID_NULL,\n   /* Before adding enough to get up to 64, the RIDBIT_* macros\n      will have to be changed a little.  */"}, {"sha": "4fb10a8ac1b3658ca0900203da4ca02e8d8aedd1", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -1654,12 +1654,7 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \n       if (for_method)\n \t{\n-\t  tree this_type = TREE_VALUE (parms);\n-\n-\t  if (TREE_CODE (this_type) == RECORD_TYPE)  /* a signature pointer */\n-\t    this_type = SIGNATURE_TYPE (this_type);\n-\t  else\n-\t    this_type = TREE_TYPE (this_type);\n+\t  tree this_type = TREE_TYPE (TREE_VALUE (parms));\n \n \t  build_mangled_name_for_type (this_type);\n \n@@ -1948,9 +1943,6 @@ hack_identifier (value, name)\n       if (TREE_CODE (value) == OVERLOAD)\n \tvalue = OVL_CURRENT (value);\n \n-      if (IS_SIGNATURE (DECL_CLASS_CONTEXT (value)))\n-\treturn value;\n-\n       decl = maybe_dummy_object (DECL_CLASS_CONTEXT (value), 0);\n       value = build_component_ref (decl, name, NULL_TREE, 1);\n     }"}, {"sha": "6dccedc3b4b5cf084382e8eeeff21a89acf0744a", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3298, "deletions": 3353, "changes": 6651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9"}, {"sha": "792292b673f534f8094dac919e8ec57fde803f42", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -2340,61 +2340,15 @@ base_class_list:\n \n base_class:\n \t  base_class.1\n-\t\t{ $$ = finish_base_specifier (access_default_node, $1,\n-\t\t\t\t\t      current_aggr \n-\t\t\t\t\t      == signature_type_node); }\n+\t\t{ $$ = finish_base_specifier (access_default_node, $1); }\n \t| base_class_access_list see_typename base_class.1\n-                { $$ = finish_base_specifier ($1, $3, \n-\t\t\t\t\t      current_aggr \n-\t\t\t\t\t      == signature_type_node); } \n+                { $$ = finish_base_specifier ($1, $3); }\n \t;\n \n base_class.1:\n \t  typename_sub\n \t\t{ if ($$ != error_mark_node) $$ = TYPE_MAIN_DECL ($1); }\n \t| nonnested_type\n-\t| SIGOF '(' expr ')'\n-\t\t{\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    {\n-\t\t      if (IS_AGGR_TYPE (TREE_TYPE ($3)))\n-\t\t\t{\n-\t\t\t  sorry (\"`sigof' as base signature specifier\");\n-\t\t\t  $$ = TREE_TYPE ($3);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  error (\"`sigof' applied to non-aggregate expression\");\n-\t\t\t  $$ = error_mark_node;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"`sigof' in struct or class declaration\");\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-\t\t}\n-\t| SIGOF '(' type_id ')'\n-\t\t{\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    {\n-\t\t      if (IS_AGGR_TYPE (groktypename ($3.t)))\n-\t\t\t{\n-\t\t\t  sorry (\"`sigof' as base signature specifier\");\n-\t\t\t  $$ = groktypename ($3.t);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  error (\"`sigof' applied to non-aggregate expression\");\n-\t\t\t  $$ = error_mark_node;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"`sigof' in struct or class declaration\");\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-\t\t}\n \t;\n \n base_class_access_list:\n@@ -2437,12 +2391,6 @@ opt.component_decl_list:\n access_specifier:\n \t  VISSPEC ':'\n                 {\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    {\n-\t\t      error (\"access specifier not allowed in signature\");\n-\t\t      $1 = access_public_node;\n-\t\t    }\n-\n \t\t  current_access_specifier = $1;\n                 }\n \t;"}, {"sha": "f68edd677133b3c95208c6764b55a3b91f6c23c6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -1458,8 +1458,6 @@ lookup_member (xbasetype, name, protect, want_type)\n      In the case of overloaded function names, access control is\n      applied to the function selected by overloaded resolution.  */\n   if (rval && protect && !is_overloaded_fn (rval)\n-      && !IS_SIGNATURE_POINTER (DECL_REAL_CONTEXT (rval))\n-      && !IS_SIGNATURE_REFERENCE (DECL_REAL_CONTEXT (rval))\n       && !enforce_access (xbasetype, rval))\n     return error_mark_node;\n "}, {"sha": "1b6490000ee635f95c13de755d23e83f0bd5d209", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -1035,14 +1035,8 @@ finish_qualified_object_call_expr (fn, object, args)\n      tree object;\n      tree args;\n {\n-  if (IS_SIGNATURE (TREE_OPERAND (fn, 0)))\n-    {\n-      warning (\"signature name in scope resolution ignored\");\n-      return finish_object_call_expr (TREE_OPERAND (fn, 1), object, args);\n-    }\n-  else\n-    return build_scoped_method_call (object, TREE_OPERAND (fn, 0),\n-\t\t\t\t     TREE_OPERAND (fn, 1), args);\n+  return build_scoped_method_call (object, TREE_OPERAND (fn, 0),\n+\t\t\t\t   TREE_OPERAND (fn, 1), args);\n }\n \n /* Finish a pseudo-destructor call expression of OBJECT, with SCOPE\n@@ -1231,9 +1225,7 @@ finish_template_type_parm (aggr, identifier)\n      tree aggr;\n      tree identifier;\n {\n-  if (aggr == signature_type_node)\n-    sorry (\"signature as template type parameter\");\n-  else if (aggr != class_type_node)\n+  if (aggr != class_type_node)\n     {\n       pedwarn (\"template type parameters must use the keyword `class' or `typename'\");\n       aggr = class_type_node;\n@@ -1364,24 +1356,22 @@ begin_class_definition (t)\n   /* Reset the interface data, at the earliest possible\n      moment, as it might have been set via a class foo;\n      before.  */\n-  /* Don't change signatures.  */\n-  if (! IS_SIGNATURE (t))\n-    {\n-      tree name = TYPE_IDENTIFIER (t);\n-      \n-      if (! ANON_AGGRNAME_P (name))\n-\t{\n-\t  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-\t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n-\t    (t, interface_unknown);\n-\t}\n-\n-      /* Only leave this bit clear if we know this\n-\t class is part of an interface-only specification.  */\n-      if (! CLASSTYPE_INTERFACE_KNOWN (t)\n-\t  || ! CLASSTYPE_INTERFACE_ONLY (t))\n-\tCLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n-    }\n+  {\n+    tree name = TYPE_IDENTIFIER (t);\n+    \n+    if (! ANON_AGGRNAME_P (name))\n+      {\n+\tCLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+\tSET_CLASSTYPE_INTERFACE_UNKNOWN_X\n+\t  (t, interface_unknown);\n+      }\n+    \n+    /* Only leave this bit clear if we know this\n+       class is part of an interface-only specification.  */\n+    if (! CLASSTYPE_INTERFACE_KNOWN (t)\n+\t|| ! CLASSTYPE_INTERFACE_ONLY (t))\n+      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n+  }\n #if 0\n   tmp = TYPE_IDENTIFIER ($<ttype>0);\n   if (tmp && IDENTIFIER_TEMPLATE (tmp))\n@@ -1652,11 +1642,9 @@ enter_scope_of (sr)\n    access_{default,public,protected_private}[_virtual]_node.*/\n \n tree \n-finish_base_specifier (access_specifier, base_class,\n-\t\t       current_aggr_is_signature)\n+finish_base_specifier (access_specifier, base_class)\n      tree access_specifier;\n      tree base_class;\n-     int current_aggr_is_signature;\n {\n   tree type;\n   tree result;\n@@ -1668,27 +1656,9 @@ finish_base_specifier (access_specifier, base_class,\n     }\n   else\n     type = TREE_TYPE (base_class);\n-  if (current_aggr_is_signature && access_specifier)\n-    error (\"access and source specifiers not allowed in signature\");\n+\n   if (! is_aggr_type (type, 1))\n     result = NULL_TREE;\n-  else if (current_aggr_is_signature\n-\t   && (! type) && (! IS_SIGNATURE (type)))\n-    {\n-      error (\"class name not allowed as base signature\");\n-      result = NULL_TREE;\n-    }\n-  else if (current_aggr_is_signature)\n-    {\n-      sorry (\"signature inheritance, base type `%s' ignored\",\n-\t     IDENTIFIER_POINTER (access_specifier));\n-      result = build_tree_list (access_public_node, type);\n-    }\n-  else if (type && IS_SIGNATURE (type))\n-    {\n-      error (\"signature name not allowed as base class\");\n-      result = NULL_TREE;\n-    }\n   else\n     result = build_tree_list (access_specifier, type);\n "}, {"sha": "f170df52a606850b1b73c939f0bd8612ca62c3b4", "filename": "gcc/cp/sig.c", "status": "removed", "additions": 0, "deletions": 1067, "changes": 1067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,1067 +0,0 @@\n-/* Functions dealing with signatures and signature pointers/references.\n-   Copyright (C) 1992, 93-97, 1998 Free Software Foundation, Inc.\n-   Contributed by Gerald Baumgartner (gb@cs.purdue.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"obstack.h\"\n-#include \"tree.h\"\n-#include \"cp-tree.h\"\n-#include \"flags.h\"\n-#include \"assert.h\"\n-#include \"toplev.h\"\n-\n-extern struct obstack *current_obstack;\n-extern struct obstack permanent_obstack;\n-extern struct obstack *saveable_obstack;\n-\n-static tree save_this PROTO((tree));\n-static tree build_sptr_ref PROTO((tree));\n-static tree build_member_function_pointer PROTO((tree));\n-static void undo_casts PROTO((tree));\n-static tree build_signature_pointer_or_reference_name\n-\tPROTO((tree, int, int));\n-static void build_signature_pointer_or_reference_decl\n-\tPROTO((tree, tree));\n-static tree build_signature_pointer_or_reference_type \n-\tPROTO((tree, int, int));\n-static tree get_sigtable_name PROTO((tree, tree));\n-static tree build_signature_table_constructor PROTO((tree, tree));\n-static int match_method_types PROTO((tree, tree));\n-static tree build_sigtable PROTO((tree, tree, tree));\n-\n-/* Used to help generate globally unique names for signature tables.  */\n-\n-static int global_sigtable_name_counter;\n-\n-/* Build an identifier for a signature pointer or reference, so we\n-   can use it's name in function name mangling.  */\n-\n-static tree\n-build_signature_pointer_or_reference_name (to_type, type_quals, refp)\n-     tree to_type;\n-     int type_quals;\n-     int refp;\n-{\n-  const char * sig_name = TYPE_NAME_STRING (to_type);\n-  int name_len = TYPE_NAME_LENGTH (to_type) + 3 /* Enough room for\n-\t\t\t\t\t\t   C,V,R.  */;\n-  char * name;\n-\n-  const char *const_rep = (type_quals & TYPE_QUAL_CONST) ? \"C\" : \"\";\n-  const char *restrict_rep = (type_quals & TYPE_QUAL_RESTRICT) ? \"R\" : \"\"; \n-  const char *volatile_rep = (type_quals & TYPE_QUAL_VOLATILE) ? \"C\" : \"\";\n-\n-  if (refp)\n-    {\n-      name = (char *) alloca (name_len + sizeof (SIGNATURE_REFERENCE_NAME) +2);\n-      sprintf (name, SIGNATURE_REFERENCE_NAME_FORMAT,\n-\t       const_rep, volatile_rep, restrict_rep, sig_name);\n-    }\n-  else\n-    {\n-      name = (char *) alloca (name_len + sizeof (SIGNATURE_POINTER_NAME) + 2);\n-      sprintf (name, SIGNATURE_POINTER_NAME_FORMAT,\n-\t       const_rep, volatile_rep, restrict_rep, sig_name);\n-    }\n-  return get_identifier (name);\n-}\n-\n-/* Build a DECL node for a signature pointer or reference, so we can\n-   tell the debugger the structure of signature pointers/references.\n-   This function is called at most eight times for a given signature,\n-   once for each [const] [volatile] signature pointer/reference.  */\n-\n-static void\n-build_signature_pointer_or_reference_decl (type, name)\n-     tree type, name;\n-{\n-  tree decl;\n-\n-  /* We don't enter this declaration in any sort of symbol table.  */\n-  decl = build_decl (TYPE_DECL, name, type);\n-  TYPE_NAME (type) = decl;\n-  TREE_CHAIN (type) = decl;\n-}\n-\n-/* Construct, lay out and return the type of pointers or references to\n-   signature TO_TYPE.  If such a type has already been constructed,\n-   reuse it. If TYPE_QUALS are specified, qualify the `optr'.  If we\n-   are constructing a const/volatile type variant and the main type\n-   variant doesn't exist yet, it is built as well.  If REFP is 1, we\n-   construct a signature reference, otherwise a signature pointer is\n-   constructed.\n-\n-   This function is a subroutine of `build_signature_pointer_type' and\n-   `build_signature_reference_type'.  */\n-\n-static tree\n-build_signature_pointer_or_reference_type (to_type, type_quals, refp)\n-     tree to_type;\n-     int type_quals;\n-     int refp;\n-{\n-  register tree t, m;\n-  register struct obstack *ambient_obstack = current_obstack;\n-  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n-\n-  m = refp ? SIGNATURE_REFERENCE_TO (to_type) : SIGNATURE_POINTER_TO (to_type);\n-\n-  /* If we don't have the main variant yet, construct it.  */\n-  if (m == NULL_TREE && type_quals != TYPE_UNQUALIFIED)\n-    m = build_signature_pointer_or_reference_type (to_type, \n-\t\t\t\t\t\t   TYPE_UNQUALIFIED, refp);\n-\n-  /* Treat any nonzero argument as 1.  */\n-  refp = !!refp;\n-\n-  /* If not generating auxiliary info, search the chain of variants to see\n-     if there is already one there just like the one we need to have.  If so,\n-     use that existing one.\n-\n-     We don't do this in the case where we are generating aux info because\n-     in that case we want each typedef names to get it's own distinct type\n-     node, even if the type of this new typedef is the same as some other\n-     (existing) type.  */\n-\n-  if (m && !flag_gen_aux_info)\n-    for (t = m; t; t = TYPE_NEXT_VARIANT (t))\n-      if (type_quals == CP_TYPE_QUALS (TREE_TYPE (TREE_TYPE\n-\t\t\t\t\t\t  (TYPE_FIELDS (t)))))\n-        return t;\n-\n-  /* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */\n-  if (TREE_PERMANENT (to_type))\n-    {\n-      current_obstack = &permanent_obstack;\n-      saveable_obstack = &permanent_obstack;\n-    }\n-\n-  /* A signature pointer or reference to a signature `s' looks like this:\n-\n-       struct {\n-         void * optr;\n-\t const s * sptr;\n-       };\n-\n-     A `const' signature pointer/reference is a\n-\n-       struct {\n-         const void * optr;\n-\t const s * sptr;\n-       };\n-\n-     Similarly, for `volatile' and `const volatile'.  */\n-\n-  t = make_lang_type (RECORD_TYPE);\n-  {\n-    tree obj_type = build_qualified_type (void_type_node, type_quals);\n-    tree optr_type = build_pointer_type (obj_type);\n-    tree optr, sptr;\n-\n-    optr = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t  get_identifier (SIGNATURE_OPTR_NAME),\n-\t\t\t\t  optr_type);\n-    DECL_FIELD_CONTEXT (optr) = t;\n-    DECL_CLASS_CONTEXT (optr) = t;\n-\n-    if (m)\n-      /* We can share the `sptr' field among type variants.  */\n-      sptr = TREE_CHAIN (TYPE_FIELDS (m));\n-    else\n-      {\n-\ttree sig_tbl_type = \n-\t  cp_build_qualified_type (to_type, TYPE_QUAL_CONST);\n-\t\n-\tsptr = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),\n-\t\t\t\t      build_pointer_type (sig_tbl_type));\n-\tDECL_FIELD_CONTEXT (sptr) = t;\n-\tDECL_CLASS_CONTEXT (sptr) = t;\n-\tTREE_CHAIN (sptr) = NULL_TREE;\n-      }\n-\n-    TREE_CHAIN (optr) = sptr;\n-    TYPE_FIELDS (t) = optr;\n-    /* Allow signature pointers/references to be grabbed 2 words at a time.\n-       For this to work on a Sparc, we need 8-byte alignment.  */\n-    TYPE_ALIGN (t) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t  TYPE_ALIGN (optr_type));\n-\n-    /* A signature pointer/reference type isn't a `real' class type.  */\n-    SET_IS_AGGR_TYPE (t, 0);\n-  }\n-\n-  {\n-    tree name = build_signature_pointer_or_reference_name (to_type, \n-\t\t\t\t\t\t\t   type_quals,\n-\t\t\t\t\t\t\t   refp);\n-\n-    /* Build a DECL node for this type, so the debugger has access to it.  */\n-    build_signature_pointer_or_reference_decl (t, name);\n-  }\n-\n-  CLASSTYPE_GOT_SEMICOLON (t) = 1;\n-  IS_SIGNATURE_POINTER (t) = ! refp;\n-  IS_SIGNATURE_REFERENCE (t) = refp;\n-  SIGNATURE_TYPE (t) = to_type;\n-\n-  if (m)\n-    {\n-      /* Add this type to the chain of variants of TYPE.\n-\t Every type has to be its own TYPE_MAIN_VARIANT.  */\n-      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n-      TYPE_NEXT_VARIANT (m) = t;\n-    }\n-  else if (refp)\n-    /* Record this type as the reference to TO_TYPE.  */\n-    SIGNATURE_REFERENCE_TO (to_type) = t;\n-  else\n-    /* Record this type as the pointer to TO_TYPE.  */\n-    SIGNATURE_POINTER_TO (to_type) = t;\n-\n-  /* Lay out the type.  This function has many callers that are concerned\n-     with expression-construction, and this simplifies them all.\n-     Also, it guarantees the TYPE_SIZE is permanent if the type is.  */\n-  layout_type (t);\n-\n-  current_obstack = ambient_obstack;\n-  saveable_obstack = ambient_saveable_obstack;\n-\n-  /* Output debug information for this type.  */\n-  rest_of_type_compilation (t, 1);\n-\n-  return t;\n-}\n-\n-/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */\n-\n-tree\n-build_signature_pointer_type (to_type)\n-     tree to_type;\n-{\n-  return\n-    build_signature_pointer_or_reference_type (TYPE_MAIN_VARIANT (to_type),\n-\t\t\t\t\t       CP_TYPE_QUALS (to_type), 0);\n-}\n-\n-/* Construct, lay out and return the type of pointers to signature TO_TYPE.  */\n-\n-tree\n-build_signature_reference_type (to_type)\n-     tree to_type;\n-{\n-  return\n-    build_signature_pointer_or_reference_type (TYPE_MAIN_VARIANT (to_type),\n-\t\t\t\t\t       CP_TYPE_QUALS (to_type), 1);\n-}\n-\n-/* Return the name of the signature table (as an IDENTIFIER_NODE)\n-   for the given signature type SIG_TYPE and rhs type RHS_TYPE.  */\n-\n-static tree\n-get_sigtable_name (sig_type, rhs_type)\n-     tree sig_type, rhs_type;\n-{\n-  tree sig_type_id = build_typename_overload (sig_type);\n-  tree rhs_type_id = build_typename_overload (rhs_type);\n-  char *buf = (char *) alloca (sizeof (SIGTABLE_NAME_FORMAT_LONG)\n-\t\t\t       + IDENTIFIER_LENGTH (sig_type_id)\n-\t\t\t       + IDENTIFIER_LENGTH (rhs_type_id) + 20);\n-  const char *sig_ptr = IDENTIFIER_POINTER (sig_type_id);\n-  const char *rhs_ptr = IDENTIFIER_POINTER (rhs_type_id);\n-  int i, j;\n-\n-  for (i = 0; sig_ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++)\n-    /* do nothing */;\n-  while (sig_ptr[i] >= '0' && sig_ptr[i] <= '9')\n-    i += 1;\n-\n-  for (j = 0; rhs_ptr[j] == OPERATOR_TYPENAME_FORMAT[j]; j++)\n-    /* do nothing */;\n-  while (rhs_ptr[j] >= '0' && rhs_ptr[j] <= '9')\n-    j += 1;\n-\n-  if (IS_SIGNATURE (rhs_type))\n-    sprintf (buf, SIGTABLE_NAME_FORMAT_LONG, sig_ptr+i, rhs_ptr+j,\n-\t     global_sigtable_name_counter++);\n-  else\n-    sprintf (buf, SIGTABLE_NAME_FORMAT, sig_ptr+i, rhs_ptr+j);\n-  return get_identifier (buf);\n-}\n-\n-/* Build a field decl that points to a signature member function.  */\n-\n-static tree\n-build_member_function_pointer (member)\n-     tree member;\n-{\n-  const char *namstr = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (member));\n-  int namlen = IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (member));\n-  char *name;\n-  tree entry;\n-  \n-  name = (char *) alloca (namlen + sizeof (SIGNATURE_FIELD_NAME) + 2);\n-  sprintf (name, SIGNATURE_FIELD_NAME_FORMAT, namstr);\n-\n-  /* @@ Do we really want to xref signature table fields?  */\n-  GNU_xref_ref (current_function_decl, name);\n-\n-  entry = build_lang_field_decl (FIELD_DECL, get_identifier (name),\n-\t\t\t\t sigtable_entry_type);\n-  TREE_CONSTANT (entry) = 1;\n-  TREE_READONLY (entry) = 1;\n-\n-  /* @@ Do we really want to xref signature table fields?  */\n-  GNU_xref_decl (current_function_decl, entry);\n-\n-  return entry;\n-}\n-\n-/* For each FUNCTION_DECL in a signature we construct a member function\n-   pointer of the appropriate type.  We also need two flags to test\n-   whether the member function pointer points to a virtual function or\n-   to a default implementation.  Those flags will be the two lower order\n-   bits of the member function pointer (or the two higher order bits,\n-   based on the configuration).\n-\n-   The new FIELD_DECLs are appended at the end of the last (and only)\n-   sublist of `list_of_fieldlists.'\n-\n-   T is the signature type.\n-  \n-   As a side effect, each member function in the signature gets the\n-   `decl.ignored' bit turned on, so we don't output debug info for it.  */\n-\n-void\n-append_signature_fields (t)\n-     tree t;\n-{\n-  tree x;\n-  tree mfptr;\n-  tree last_mfptr = NULL_TREE;\n-  tree mfptr_list = NULL_TREE;\n-\t      \n-  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n-    {\n-      if (TREE_CODE (x) == FUNCTION_DECL)\n-\t{\n-\t  mfptr = build_member_function_pointer (x);\n-\t  DECL_MEMFUNC_POINTER_TO (x) = mfptr;\n-\t  DECL_MEMFUNC_POINTING_TO (mfptr) = x;\n-\t  DECL_IGNORED_P (x) = 1;\n-\t  DECL_IN_AGGR_P (mfptr) = 1;\n-\t  if (! mfptr_list)\n-\t    mfptr_list = last_mfptr = mfptr;\n-\t  else\n-\t    {\n-\t      TREE_CHAIN (last_mfptr) = mfptr;\n-\t      last_mfptr = mfptr;\n-\t    }\n-\t}\n-    }\n-\n-  /* The member function pointers must come after the TYPE_DECLs, in\n-     this case, because build_signature_table_constructor depends on\n-     finding opaque TYPE_DECLS before the functions that make use of\n-     them.  */\n-  if (last_mfptr)\n-    TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), mfptr_list);\n-}\n-\n-/* Compare the types of a signature member function and a class member\n-   function.  Returns 1 if the types are in the C++ `<=' relationship.\n-\n-   If we have a signature pointer/reference as argument or return type\n-   we don't want to do a recursive conformance check.  The conformance\n-   check only succeeds if both LHS and RHS refer to the same signature\n-   pointer.  Otherwise we need to keep information about parameter types\n-   around at run time to initialize the signature table correctly.  */\n-\n-static int\n-match_method_types (sig_mtype, class_mtype)\n-     tree sig_mtype, class_mtype;\n-{\n-  tree sig_return_type = TREE_TYPE (sig_mtype);\n-  tree sig_arg_types = TYPE_ARG_TYPES (sig_mtype);\n-  tree class_return_type = TREE_TYPE (class_mtype);\n-  tree class_arg_types = TYPE_ARG_TYPES (class_mtype);\n-\n-  /* The return types have to be the same.  */\n-  if (!same_type_p (sig_return_type, class_return_type))\n-    return 0;\n-\n-  /* Compare the first argument `this.'  */\n-  {\n-    /* Get the type of what the `optr' is pointing to.  */\n-    tree sig_this\n-      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_VALUE (sig_arg_types))));\n-    tree class_this = TREE_VALUE (class_arg_types);\n-\n-    if (TREE_CODE (class_this) == RECORD_TYPE)\t/* Is `this' a sig ptr?  */\n-      class_this = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (class_this)));\n-    else\n-      class_this = TREE_TYPE (class_this);\n-\n-    /* If a signature method's `this' is const or volatile, so has to be\n-       the corresponding class method's `this.'  */\n-    if (!at_least_as_qualified_p (class_this, sig_this))\n-      return 0;\n-  }\n-\n-  sig_arg_types = TREE_CHAIN (sig_arg_types);\n-  class_arg_types = TREE_CHAIN (class_arg_types);\n-\n-  /* The number of arguments and the argument types have to be the same.  */\n-  return compparms (sig_arg_types, class_arg_types);\n-}\n-\n-/* Undo casts of opaque type variables to the RHS types.  */\n-\n-static void\n-undo_casts (sig_ty)\n-     tree sig_ty;\n-{\n-  tree field = TYPE_FIELDS (sig_ty);\n-\n-  /* Since all the FIELD_DECLs for the signature table entries are at the end\n-     of the chain (see `append_signature_fields'), we can do it this way.  */\n-  for (; field && TREE_CODE (field) != FIELD_DECL; field = TREE_CHAIN (field))\n-    if (TYPE_MAIN_VARIANT (TREE_TYPE (field)) == opaque_type_node)\n-      TREE_TYPE (TREE_TYPE (field)) = TREE_TYPE (ptr_type_node);\n-}\n-\n-/* Do the type checking necessary to see whether the `rhs' conforms to\n-   the lhs's `sig_ty'.  Depending on the type of `rhs' return a NULL_TREE,\n-   an integer_zero_node, a constructor, or an expression offsetting the\n-   `rhs' signature table.  */\n-\n-static tree\n-build_signature_table_constructor (sig_ty, rhs)\n-     tree sig_ty, rhs;\n-{\n-  tree rhstype = TREE_TYPE (rhs);\n-  tree sig_field = TYPE_FIELDS (sig_ty);\n-  tree result = NULL_TREE;\n-  tree first_rhs_field = NULL_TREE;\n-  tree last_rhs_field = NULL_TREE;\n-  int sig_ptr_p = IS_SIGNATURE (rhstype);\n-  int offset_p = sig_ptr_p;\n-\n-  rhstype = sig_ptr_p ? rhstype : TREE_TYPE (rhstype);\n-\n-  if (CLASSTYPE_TAGS (sig_ty))\n-    {\n-      sorry (\"conformance check with signature containing class declarations\");\n-      return error_mark_node;\n-    }\n-\n-  for (; sig_field; sig_field = TREE_CHAIN (sig_field))\n-    {\n-      tree basetype_path, baselink, basetypes;\n-      tree sig_method, sig_mname, sig_mtype;\n-      tree rhs_method, tbl_entry;\n-\n-      if (TREE_CODE (sig_field) == TYPE_DECL)\n-\t{\n-\t  tree sig_field_type = TREE_TYPE (sig_field);\n-\n-\t  if (TYPE_MAIN_VARIANT (sig_field_type) == opaque_type_node)\n-\t    {\n-\t      /* We've got an opaque type here.  */\n-\t      tree oty_name = DECL_NAME (sig_field);\n-\t      tree oty_type = lookup_field (rhstype, oty_name, 1, 1);\n-\n-\t      if (oty_type == NULL_TREE || oty_type == error_mark_node)\n-\t\t{\n-\t\t  cp_error (\"class `%T' does not contain type `%T'\",\n-\t\t\t    rhstype, oty_type);\n-\t\t  undo_casts (sig_ty);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      oty_type = TREE_TYPE (oty_type);\n-\n-\t      /* Cast `sig_field' to be of type `oty_type'.  This will be\n-\t\t undone in `undo_casts' by walking over all the TYPE_DECLs.  */\n-\t      TREE_TYPE (sig_field_type) = TREE_TYPE (oty_type);\n-\t    }\n-\t  /* If we don't have an opaque type, we can ignore the `typedef'.  */\n-\t  continue;\n-\t}\n-\n-      /* Find the signature method corresponding to `sig_field'.  */\n-      sig_method = DECL_MEMFUNC_POINTING_TO (sig_field);\n-      sig_mname = DECL_NAME (sig_method);\n-      sig_mtype = TREE_TYPE (sig_method);\n-\n-      basetype_path = TYPE_BINFO (rhstype);\n-      baselink = lookup_fnfields (basetype_path, sig_mname, 0);\n-      if (baselink == NULL_TREE || baselink == error_mark_node)\n-\t{\n-\t  if (! IS_DEFAULT_IMPLEMENTATION (sig_method))\n-\t    {\n-\t      cp_error (\"class `%T' does not contain method `%D'\",\n-\t\t\trhstype, sig_mname);\n-\t      undo_casts (sig_ty);\n-\t      return error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We use the signature's default implementation.  */\n-\t      rhs_method = sig_method;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Find the class method of the correct type.  */\n-\t  tree rhs_methods;\n-\t  basetypes = TREE_PURPOSE (baselink);\n-\t  if (TREE_CODE (basetypes) == TREE_LIST)\n-\t    basetypes = TREE_VALUE (basetypes);\n-\n-\t  rhs_methods = TREE_VALUE (baselink);\n-\t  for (; rhs_methods; rhs_methods = OVL_NEXT (rhs_methods))\n-\t    if ((rhs_method = OVL_CURRENT (rhs_methods))\n-\t\t&& sig_mname == DECL_NAME (rhs_method)\n-\t\t&& ! DECL_STATIC_FUNCTION_P (rhs_method)\n-\t\t&& match_method_types (sig_mtype, TREE_TYPE (rhs_method)))\n-\t      break;\n-\n-\t  if (rhs_methods == NULL_TREE\n-\t      || !accessible_p (basetypes, rhs_method))\n-\t    {\n-\t      cp_error (\"`%T' does not contain a method conforming to `%#D'\",\n-\t\t     rhstype, sig_method);\n-\t      undo_casts (sig_ty);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-\n-      if (sig_ptr_p && rhs_method != sig_method)\n-\t{\n-\t  tree rhs_field = DECL_MEMFUNC_POINTER_TO (rhs_method);\n-\n-\t  if (first_rhs_field == NULL_TREE)\n-\t    {\n-\t      first_rhs_field = rhs_field;\n-\t      last_rhs_field = rhs_field;\n-\t    }\n-\t  else if (TREE_CHAIN (last_rhs_field) == rhs_field)\n-\t    last_rhs_field = rhs_field;\n-\t  else\n-\t    offset_p = 0;\n-\t  \n-\t  tbl_entry = build_component_ref (rhs, DECL_NAME (rhs_field),\n-\t\t\t\t\t   NULL_TREE, 1);\n-\t}\n-      else\n-\t{\n-\t  tree tag, vb_off, delta, idx, pfn = NULL_TREE, vt_off = NULL_TREE;\n-\t  tree tag_decl, vb_off_decl, delta_decl, index_decl;\n-\t  tree pfn_decl, vt_off_decl;\n-\n-\t  if (rhs_method == sig_method)\n-\t    {\n-\t      /* default implementation */\n-\t      tag = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n-\t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n-\t      delta = integer_zero_node;\n-\t      idx = integer_zero_node;\n-\t      pfn = build_addr_func (rhs_method);\n-\t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n-\t      TREE_TYPE (pfn) = ptr_type_node;\n-\t      TREE_ADDRESSABLE (rhs_method) = 1;\n-\t      offset_p = 0;\t/* we can't offset the rhs sig table */\n-\t    }\n-\t  else if (DECL_VINDEX (rhs_method))\n-\t    {\n-\t      /* virtual member function */\n-\t      tag = integer_one_node;\n-\t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n-\t      if (flag_vtable_thunks)\n-\t\tdelta = BINFO_OFFSET\n-\t\t  (get_binfo (DECL_CONTEXT (rhs_method), rhstype, 1));\n-\t      else\n-\t\tdelta = BINFO_OFFSET\n-\t\t  (get_binfo (DECL_CLASS_CONTEXT (rhs_method), rhstype, 1));\n-\t      idx = DECL_VINDEX (rhs_method);\n-\t      vt_off = get_vfield_offset (get_binfo (DECL_CONTEXT (rhs_method),\n-\t\t\t\t\t\t     rhstype, 0));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* non-virtual member function */\n-\t      tag = integer_zero_node;\n-\t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n-\t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n-\t\t\t\t\t       rhstype, 1));\n-\t      idx = integer_zero_node;\n-\t      pfn = build_addr_func (rhs_method);\n-\t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n-\t      TREE_TYPE (pfn) = ptr_type_node;\n-\t      TREE_ADDRESSABLE (rhs_method) = 1;\n-\t    }\n-\n-\t  /* Since digest_init doesn't handle initializing selected fields\n-\t     of a struct (i.e., anonymous union), we build the constructor\n-\t     by hand, without calling digest_init.  */\n-\t  tag_decl = TYPE_FIELDS (sigtable_entry_type);\n-\t  vb_off_decl = TREE_CHAIN (tag_decl);\n-\t  delta_decl = TREE_CHAIN (vb_off_decl);\n-\t  index_decl = TREE_CHAIN (delta_decl);\n-\t  pfn_decl = TREE_CHAIN (index_decl);\n-\t  vt_off_decl = TREE_CHAIN (pfn_decl);\n-\t  \n-\t  tag = cp_convert (TREE_TYPE (tag_decl), tag);\n-\t  vb_off = cp_convert (TREE_TYPE (vb_off_decl), vb_off);\n-\t  delta = cp_convert (TREE_TYPE (delta_decl), delta);\n-\t  idx = cp_convert (TREE_TYPE (index_decl), idx);\n-\n-\t  if (DECL_VINDEX (rhs_method))\n-\t    {\n-\t      vt_off = cp_convert (TREE_TYPE (vt_off_decl), vt_off);\n-\n-\t      tbl_entry = build_tree_list (vt_off_decl, vt_off);\n-\t    }\n-\t  else\n-\t    {\n-\t      pfn = cp_convert (TREE_TYPE (pfn_decl), pfn);\n-\n-\t      tbl_entry = build_tree_list (pfn_decl, pfn);\n-\t    }\n-\t  tbl_entry = tree_cons (delta_decl, delta,\n-\t\t\t\t tree_cons (index_decl, idx, tbl_entry));\n-\t  tbl_entry = tree_cons (tag_decl, tag,\n-\t\t\t\t tree_cons (vb_off_decl, vb_off, tbl_entry));\n-\t  tbl_entry = build (CONSTRUCTOR, sigtable_entry_type,\n-\t\t\t     NULL_TREE, tbl_entry);\n-\n-\t  TREE_CONSTANT (tbl_entry) = 1;\n-\t}\n-\n-      /* Chain those function address expressions together.  */\n-      if (result)\n-\tresult = tree_cons (NULL_TREE, tbl_entry, result);\n-      else\n-\tresult = build_tree_list (NULL_TREE, tbl_entry);\n-    }\n-\n-  if (result == NULL_TREE)\n-    {\n-      /* The signature was empty, we don't need a signature table.  */\n-      undo_casts (sig_ty);\n-      return NULL_TREE;\n-    }\n-\n-  if (offset_p)\n-    {\n-      if (first_rhs_field == TYPE_FIELDS (rhstype))\n-\t{\n-\t  /* The sptr field on the lhs can be copied from the rhs.  */\n-\t  undo_casts (sig_ty);\n-\t  return integer_zero_node;\n-\t}\n-      else\n-\t{\n-\t  /* The sptr field on the lhs will point into the rhs sigtable.  */\n-\t  undo_casts (sig_ty);\n-\t  return build_component_ref (rhs, DECL_NAME (first_rhs_field),\n-\t\t\t\t      NULL_TREE, 0);\n-\t}\n-    }\n-\n-  /* We need to construct a new signature table.  */\n-  result = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (result));\n-  TREE_HAS_CONSTRUCTOR (result) = 1;\n-  TREE_CONSTANT (result) = !sig_ptr_p;\n-\n-  undo_casts (sig_ty);\n-  return result;\n-}\n-\n-/* Build a signature table declaration and initialize it or return an\n-   existing one if we built one already.  If we don't get a constructor\n-   as initialization expression, we don't need a new signature table\n-   variable and just hand back the init expression.\n-\n-   The declaration processing is done by hand instead of using `cp_finish_decl'\n-   so that we can make signature pointers global variables instead of\n-   static ones.  */\n-\n-static tree\n-build_sigtable (sig_type, rhs_type, init_from)\n-     tree sig_type, rhs_type, init_from;\n-{\n-  tree name = NULL_TREE;\n-  tree decl = NULL_TREE;\n-  tree init_expr;\n-\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-\n-  if (! IS_SIGNATURE (rhs_type))\n-    {\n-      name = get_sigtable_name (sig_type, rhs_type);\n-      decl = IDENTIFIER_GLOBAL_VALUE (name);\n-    }\n-  if (decl == NULL_TREE)\n-    {\n-      tree init = NULL_TREE;\n-\n-      /* We allow only one signature table to be generated for signatures\n-\t with opaque types.  Otherwise we create a loophole in the type\n-\t system since we could cast data from one classes implementation\n-\t of the opaque type to that of another class.  */\n-      if (SIGNATURE_HAS_OPAQUE_TYPEDECLS (sig_type)\n-\t  && SIGTABLE_HAS_BEEN_GENERATED (sig_type))\n-\t{\n-\t  error (\"signature with opaque type implemented by multiple classes\");\n-\t  return error_mark_node;\n-\t}\n-      SIGTABLE_HAS_BEEN_GENERATED (sig_type) = 1;\n-\n-      init_expr = build_signature_table_constructor (sig_type, init_from);\n-      if (init_expr == NULL_TREE || TREE_CODE (init_expr) != CONSTRUCTOR)\n-\treturn init_expr;\n-\n-      if (name == NULL_TREE)\n-\tname = get_sigtable_name (sig_type, rhs_type);\n-      {\n-\ttree context = current_function_decl;\n-\n-\t/* Make the signature table global, not just static in whichever\n-\t   function a signature pointer/ref is used for the first time.  */\n-\tcurrent_function_decl = NULL_TREE;\n-\tdecl = pushdecl_top_level (build_decl (VAR_DECL, name, sig_type));\n-\tcurrent_function_decl = context;\n-      }\n-      SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n-      store_init_value (decl, init_expr);\n-      if (IS_SIGNATURE (rhs_type))\n-\t{\n-\t  init = DECL_INITIAL (decl);\n-\t  DECL_INITIAL (decl) = error_mark_node;\n-\t}\n-\n-      DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t       DECL_ALIGN (decl));\n-#if 0\n-      /* GDB-4.7 doesn't find the initialization value of a signature table\n-\t when it is constant.  */\n-      TREE_READONLY (decl) = 1;\n-#endif\n-      TREE_STATIC (decl) = 1;\n-      TREE_USED (decl) = 1;\n-\n-      make_decl_rtl (decl, NULL, 1);\n-      if (IS_SIGNATURE (rhs_type))\n-\texpand_static_init (decl, init);\n-    }\n-\n-  pop_obstacks ();\n-\n-  return decl;\n-}\n-\n-/* Create a constructor or modify expression if the LHS of an assignment\n-   is a signature pointer or a signature reference.  If LHS is a record\n-   type node, we build a constructor, otherwise a compound expression.  */\n-\n-tree\n-build_signature_pointer_constructor (lhs, rhs)\n-     tree lhs, rhs;\n-{\n-  register struct obstack *ambient_obstack = current_obstack;\n-  register struct obstack *ambient_saveable_obstack = saveable_obstack;\n-  int initp = (TREE_CODE (lhs) == RECORD_TYPE);\n-  tree lhstype = initp ? lhs : TREE_TYPE (lhs);\n-  tree rhstype = TREE_TYPE (rhs);\n-  tree sig_ty  = SIGNATURE_TYPE (lhstype);\n-  tree sig_tbl, sptr_expr, optr_expr;\n-  tree result;\n-\n-  if (! ((TREE_CODE (rhstype) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (rhstype)) == RECORD_TYPE)\n-\t || (TYPE_LANG_SPECIFIC (rhstype)\n-\t     && (IS_SIGNATURE_POINTER (rhstype)\n-\t\t || IS_SIGNATURE_REFERENCE (rhstype)))))\n-    {\n-      error (\"invalid assignment to signature pointer or reference\");\n-      return error_mark_node;\n-    }\n-\n-  if (TYPE_SIZE (sig_ty) == NULL_TREE)\n-    {\n-      cp_error (\"undefined signature `%T' used in signature %s declaration\",\n-\t\tsig_ty,\n-\t\tIS_SIGNATURE_POINTER (lhstype) ? \"pointer\" : \"reference\");\n-      return error_mark_node;\n-    }\n-\n-  /* If SIG_TY is permanent, make the signature table constructor and\n-     the signature pointer/reference constructor permanent too.  */\n-  if (TREE_PERMANENT (sig_ty))\n-    {\n-      current_obstack = &permanent_obstack;\n-      saveable_obstack = &permanent_obstack;\n-    }\n-\n-  if (TYPE_LANG_SPECIFIC (rhstype)\n-      && (IS_SIGNATURE_POINTER (rhstype) || IS_SIGNATURE_REFERENCE (rhstype)))\n-    {\n-      if (SIGNATURE_TYPE (rhstype) == sig_ty)\n-\t{\n-\t  /* LHS and RHS are signature pointers/refs of the same signature.  */\n-\t  optr_expr = build_optr_ref (rhs);\n-\t  sptr_expr = build_sptr_ref (rhs);\n-\t}\n-      else\n-\t{\n-\t  /* We need to create a new signature table and copy\n-\t     elements from the rhs signature table.  */\n-\t  tree rhs_sptr_ref = build_sptr_ref (rhs);\n-\t  tree rhs_tbl = build1 (INDIRECT_REF, SIGNATURE_TYPE (rhstype),\n-\t\t\t\t rhs_sptr_ref);\n-\n-\t  sig_tbl = build_sigtable (sig_ty, SIGNATURE_TYPE (rhstype), rhs_tbl);\n-\t  if (sig_tbl == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  optr_expr = build_optr_ref (rhs);\n-\t  if (sig_tbl == NULL_TREE)\n-\t    /* The signature was empty.  The signature pointer is\n-\t       pretty useless, but the user has been warned.  */\n-\t    sptr_expr = copy_node (null_pointer_node);\n-\t  else if (sig_tbl == integer_zero_node)\n-\t    sptr_expr = rhs_sptr_ref;\n-\t  else\n-\t    sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n-\t  TREE_TYPE (sptr_expr) = build_pointer_type (sig_ty);\n-\t}\n-    }\n-  else\n-    {\n-      sig_tbl = build_sigtable (sig_ty, TREE_TYPE (rhstype), rhs);\n-      if (sig_tbl == error_mark_node)\n-\treturn error_mark_node;\n-\n-      optr_expr = rhs;\n-      if (sig_tbl == NULL_TREE)\n-\t/* The signature was empty.  The signature pointer is\n-\t   pretty useless, but the user has been warned.  */\n-\t{\n-\t  sptr_expr = copy_node (null_pointer_node);\n-\t  TREE_TYPE (sptr_expr) = build_pointer_type (sig_ty);\n-\t}\n-      else\n-\tsptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n-    }\n-\n-  if (initp)\n-    {\n-      result = tree_cons (NULL_TREE, optr_expr,\n-\t\t\t  build_tree_list (NULL_TREE, sptr_expr));\n-      result = build_nt (CONSTRUCTOR, NULL_TREE, result);\n-      result = digest_init (lhstype, result, 0);\n-    }\n-  else\n-    {\n-      if (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype))\n-\t  readonly_error (lhs, \"assignment\", 0);\n-\n-      optr_expr = build_modify_expr (build_optr_ref (lhs), NOP_EXPR,\n-\t\t\t\t     optr_expr);\n-      sptr_expr = build_modify_expr (build_sptr_ref (lhs), NOP_EXPR,\n-\t\t\t\t     sptr_expr);\n-\n-      result = tree_cons (NULL_TREE, optr_expr,\n-\t\t\t  tree_cons (NULL_TREE, sptr_expr,\n-\t\t\t\t     build_tree_list (NULL_TREE, lhs)));\n-      result = build_compound_expr (result);\n-    }\n-\n-  current_obstack = ambient_obstack;\n-  saveable_obstack = ambient_saveable_obstack;\n-  return result;\n-}\n-\n-/* Build a temporary variable declaration for the instance of a signature\n-   member function call if it isn't a declaration node already.  Simply\n-   using a SAVE_EXPR doesn't work since we need `this' in both branches\n-   of a conditional expression.  */\n-\n-static tree\n-save_this (instance)\n-     tree instance;\n-{\n-  tree decl;\n-\n-  if (TREE_CODE_CLASS (TREE_CODE (instance)) == 'd')\n-    decl = instance;\n-  else\n-    {\n-      decl = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (instance));\n-      DECL_REGISTER (decl) = 1;\n-      layout_decl (decl, 0);\n-      expand_decl (decl);\n-    }\n-\n-  return decl;\n-}\n-\n-/* Build a signature member function call.  Looks up the signature table\n-   entry corresponding to FUNCTION.  Depending on the value of the CODE\n-   field, either call the function in PFN directly, or use OFFSET to\n-   index the object's virtual function table.  */\n-\n-tree\n-build_signature_method_call (function, parms)\n-     tree function, parms;\n-{\n-  tree instance = TREE_VALUE (parms);\n-  tree saved_instance = save_this (instance);\t/* Create temp for `this'.  */\n-  tree object_ptr = build_optr_ref (saved_instance);\n-  tree new_object_ptr, new_parms;\n-  tree signature_tbl_ptr = build_sptr_ref (saved_instance);\n-  tree sig_field_name = DECL_NAME (DECL_MEMFUNC_POINTER_TO (function));\n-  tree basetype = DECL_CONTEXT (function);\n-  tree basetype_path = TYPE_BINFO (basetype);\n-  tree tbl_entry = build_component_ref (build1 (INDIRECT_REF, basetype,\n-\t\t\t\t\t\tsignature_tbl_ptr),\n-\t\t\t\t\tsig_field_name, basetype_path, 1);\n-  tree tag, delta, pfn, vt_off, idx, vfn;\n-  tree deflt_call = NULL_TREE, direct_call, virtual_call, result;\n-\n-  tbl_entry = save_expr (tbl_entry);\n-  tag = build_component_ref (tbl_entry, tag_identifier, NULL_TREE, 1);\n-  delta = build_component_ref (tbl_entry, delta_identifier, NULL_TREE, 1);\n-  pfn = build_component_ref (tbl_entry, pfn_identifier, NULL_TREE, 1);\n-  vt_off = build_component_ref (tbl_entry, vt_off_identifier, NULL_TREE, 1);\n-  idx = build_component_ref (tbl_entry, index_identifier, NULL_TREE, 1);\n-  TREE_TYPE (pfn) = build_pointer_type (TREE_TYPE (function)); \n-\n-  if (IS_DEFAULT_IMPLEMENTATION (function))\n-    {\n-      pfn = save_expr (pfn);\n-      deflt_call = build_function_call (pfn, parms);\n-    }\n-\n-  new_object_ptr = build (PLUS_EXPR, build_pointer_type (basetype),\n-\t\t\t  cp_convert (ptrdiff_type_node, object_ptr),\n-\t\t\t  cp_convert (ptrdiff_type_node, delta));\n-\n-  parms = tree_cons (NULL_TREE,\n-\t\t     cp_convert (build_pointer_type (basetype), object_ptr),\n-\t\t     TREE_CHAIN (parms));\n-  new_parms = tree_cons (NULL_TREE, new_object_ptr, TREE_CHAIN (parms));\n-\n-  {\n-    /* Cast the signature method to have `this' of a normal pointer type.  */\n-    tree old_this = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))));\n-\n-    TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))))\n-      = build_qualified_type (build_pointer_type (basetype),\n-\t\t\t      TYPE_QUALS (old_this));\n-\n-    direct_call = build_function_call (pfn, new_parms);\n-\n-    {\n-      tree vfld, vtbl, aref;\n-\n-      vfld = build (PLUS_EXPR,\n-\t\t    build_pointer_type (build_pointer_type (vtbl_type_node)),\n-\t\t    cp_convert (ptrdiff_type_node, object_ptr),\n-\t\t    cp_convert (ptrdiff_type_node, vt_off));\n-      vtbl = build_indirect_ref (build_indirect_ref (vfld, NULL_PTR),\n-\t\t\t\t NULL_PTR);\n-      aref = build_array_ref (vtbl, idx);\n-\n-      if (flag_vtable_thunks)\n-\tvfn = aref;\n-      else\n-\tvfn = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n-\n-      TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n-\n-      virtual_call = build_function_call (vfn, new_parms);\n-    }\n-\n-    /* Undo the cast, make `this' a signature pointer again.  */\n-    TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))) = old_this;\n-  }\n-\n-  /* Once the function was found, there should be no reason why we\n-     couldn't build the member function pointer call.  */\n-  if (!direct_call || direct_call == error_mark_node\n-      || !virtual_call || virtual_call == error_mark_node\n-      || (IS_DEFAULT_IMPLEMENTATION (function)\n-\t  && (!deflt_call || deflt_call == error_mark_node)))\n-    {\n-      compiler_error (\"cannot build call of signature member function `%s'\",\n-\t\t      fndecl_as_string (function, 1));\n-      return error_mark_node;\n-    }\n-\n-  if (IS_DEFAULT_IMPLEMENTATION (function))\n-    {\n-      tree test = build_binary_op_nodefault (LT_EXPR, tag, integer_zero_node,\n-\t\t\t\t\t     LT_EXPR);\n-      result = build_conditional_expr (tag,\n-\t\t\t\t       build_conditional_expr (test,\n-\t\t\t\t\t\t\t       deflt_call,\n-\t\t\t\t\t\t\t       virtual_call),\n-\t\t\t\t       direct_call);\n-    }\n-  else\n-    result = build_conditional_expr (tag, virtual_call, direct_call);\n-\n-  /* If we created a temporary variable for `this', initialize it first.  */\n-  if (instance != saved_instance)\n-    result = build (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t    build_modify_expr (saved_instance, NOP_EXPR, instance),\n-\t\t    result);\n-\n-  return result;\n-}\n-\n-/* Create a COMPONENT_REF expression for referencing the OPTR field\n-   of a signature pointer or reference.  */\n-\n-tree\n-build_optr_ref (instance)\n-     tree instance;\n-{\n-  tree field = get_identifier (SIGNATURE_OPTR_NAME);\n-\n-  return build_component_ref (instance, field, NULL_TREE, 1);\n-}\n-\n-/* Create a COMPONENT_REF expression for referencing the SPTR field\n-   of a signature pointer or reference.  */\n-\n-static tree\n-build_sptr_ref (instance)\n-     tree instance;\n-{\n-  tree field = get_identifier (SIGNATURE_SPTR_NAME);\n-\n-  return build_component_ref (instance, field, NULL_TREE, 1);\n-}"}, {"sha": "592b6023dbc8ae9d9d2ba47e963aecff39d4af54", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -410,10 +410,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n \n   TYPE_METHOD_BASETYPE (t) = TYPE_MAIN_VARIANT (basetype);\n   TREE_TYPE (t) = rettype;\n-  if (IS_SIGNATURE (basetype))\n-    ptype = build_signature_pointer_type (basetype);\n-  else\n-    ptype = build_pointer_type (basetype);\n+  ptype = build_pointer_type (basetype);\n \n   /* The actual arglist for this function includes a \"hidden\" argument\n      which is \"this\".  Put it into the list of argument types.  */"}, {"sha": "0b71e72d85cbbf3cd1394b6651cc915a8e10b23d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -104,10 +104,7 @@ require_complete_type (value)\n \n   /* First, detect a valid value with a complete type.  */\n   if (TYPE_SIZE (type) != 0\n-      && TYPE_SIZE (type) != size_zero_node\n-      && ! (TYPE_LANG_SPECIFIC (type)\n-\t    && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))\n-\t    && TYPE_SIZE (SIGNATURE_TYPE (type)) == 0))\n+      && TYPE_SIZE (type) != size_zero_node)\n     return value;\n \n   /* If we see X::Y, we build an OFFSET_TYPE which has\n@@ -1697,14 +1694,7 @@ c_sizeof (type)\n   if (code == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* @@ This also produces an error for a signature ref.\n-        In that case we should be able to do better.  */\n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"`sizeof' applied to a signature type\");\n-      return size_int (0);\n-    }\n-  else if (code == OFFSET_TYPE)\n+  if (code == OFFSET_TYPE)\n     {\n       cp_error (\"`sizeof' applied to non-static member\");\n       return size_int (0);\n@@ -1816,14 +1806,6 @@ c_alignof (type)\n   if (code == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  /* @@ This also produces an error for a signature ref.\n-        In that case we should be able to do better.  */\n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"`__alignof' applied to a signature type\");\n-      return size_int (1);\n-    }\n-\n   t = size_int (TYPE_ALIGN (type) / BITS_PER_UNIT);\n   force_fit_type (t, 0);\n   return t;\n@@ -2038,11 +2020,6 @@ build_object_ref (datum, basetype, field)\n \t\tbasetype, field, dtype);\n       return error_mark_node;\n     }\n-  else if (IS_SIGNATURE (basetype))\n-    {\n-      warning (\"signature name in scope resolution ignored\");\n-      return build_component_ref (datum, field, NULL_TREE, 1);\n-    }\n   else if (is_aggr_type (basetype, 1))\n     {\n       tree binfo = binfo_or_else (basetype, dtype);\n@@ -2401,8 +2378,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t not const, even within a const object.  */\n       if (DECL_LANG_SPECIFIC (field) && DECL_MUTABLE_P (field))\n \ttype_quals &= ~TYPE_QUAL_CONST;\n-      if (!IS_SIGNATURE (field_type))\n-\tfield_type = cp_build_qualified_type (field_type, type_quals);\n+      field_type = cp_build_qualified_type (field_type, type_quals);\n     }\n \n   ref = fold (build (COMPONENT_REF, field_type,\n@@ -2513,9 +2489,6 @@ build_indirect_ref (ptr, errorstring)\n      pointer to member, so it's cool to check for this here.  */\n   else if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n     error (\"invalid use of `%s' on pointer to member\", errorstring);\n-  else if (TREE_CODE (type) == RECORD_TYPE\n-\t   && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n-    error (\"cannot dereference signature pointer/reference\");\n   else if (pointer != error_mark_node)\n     {\n       if (errorstring)\n@@ -5580,12 +5553,6 @@ build_c_cast (type, expr)\n       return error_mark_node;\n     }\n \n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"cast specifies signature type\");\n-      return error_mark_node;\n-    }\n-\n   if (processing_template_decl)\n     {\n       tree t = build_min (CAST_EXPR, type,\n@@ -5726,14 +5693,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   newrhs = rhs;\n \n-  /* Handle assignment to signature pointers/refs.  */\n-\n-  if (TYPE_LANG_SPECIFIC (lhstype)\n-      && (IS_SIGNATURE_POINTER (lhstype) || IS_SIGNATURE_REFERENCE (lhstype)))\n-    {\n-      return build_signature_pointer_constructor (lhs, rhs);\n-    }\n-\n   /* Handle control structure constructs used as \"lvalues\".  */\n \n   switch (TREE_CODE (lhs))\n@@ -5923,11 +5882,6 @@ build_modify_expr (lhs, modifycode, rhs)\n   /* Warn about storing in something that is `const'.  */\n   /* For C++, don't warn if this is initialization.  */\n   if (modifycode != INIT_EXPR\n-      /* For assignment to `const' signature pointer/reference fields,\n-\t don't warn either, we already printed a better message before.  */\n-      && ! (TREE_CODE (lhs) == COMPONENT_REF\n-\t    && (IS_SIGNATURE_POINTER (TREE_TYPE (TREE_OPERAND (lhs, 0)))\n-\t\t|| IS_SIGNATURE_REFERENCE (TREE_TYPE (TREE_OPERAND (lhs, 0)))))\n       && (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype)\n \t  /* Functions are not modifiable, even though they are\n \t     lvalues.  */\n@@ -6735,10 +6689,6 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \n   type = complete_type (type);\n \n-  if (TYPE_LANG_SPECIFIC (type)\n-      && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n-    return build_signature_pointer_constructor (type, rhs);\n-\n   if (IS_AGGR_TYPE (type))\n     return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n "}, {"sha": "db1387218822f8705a9956fc74f877544225b42e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -177,39 +177,6 @@ abstract_virtuals_error (decl, type)\n   return 1;\n }\n \n-/* Print an error message for invalid use of a signature type.\n-   Signatures are treated similar to abstract classes here, they\n-   cannot be instantiated.  */\n-\n-void\n-signature_error (decl, type)\n-     tree decl;\n-     tree type;\n-{\n-  if (decl)\n-    {\n-      if (TREE_CODE (decl) == RESULT_DECL)\n-\treturn;\n-\n-      if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error (\"cannot declare variable `%D' to be of signature type `%T'\",\n-\t\t  decl, type);\n-      else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error (\"cannot declare parameter `%D' to be of signature type `%T'\",\n-\t\t  decl, type);\n-      else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error (\"cannot declare field `%D' to be of signature type `%T'\",\n-\t\t  decl, type);\n-      else if (TREE_CODE (decl) == FUNCTION_DECL\n-\t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error (\"invalid return type for method `%#D'\", decl);\n-      else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error (\"invalid return type for function `%#D'\", decl);\n-    }\n-  else\n-    cp_error (\"cannot allocate an object of signature type `%T'\", type);\n-}\n-\n /* Print an error message for invalid use of an incomplete type.\n    VALUE is the expression that was used (or 0 if that isn't known)\n    and TYPE is the type that was invalid.  */\n@@ -418,17 +385,7 @@ store_init_value (decl, init)\n \t  && TREE_CODE (init) != CONSTRUCTOR)\n \tmy_friendly_abort (109);\n \n-      /* Although we are not allowed to declare variables of signature\n-\t type, we complain about a possible constructor call in such a\n-\t declaration as well.  */\n-      if (TREE_CODE (init) == TREE_LIST\n-\t  && IS_SIGNATURE (type))\n-\t{\n-\t  cp_error (\"constructor syntax cannot be used with signature type `%T'\",\n-\t\t    type);\n-\t  init = error_mark_node;\n-\t}\n-      else if (TREE_CODE (init) == TREE_LIST)\n+      if (TREE_CODE (init) == TREE_LIST)\n \t{\n \t  cp_error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n \t  init = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (init));\n@@ -532,13 +489,7 @@ store_init_value (decl, init)\n #if 0 /* No, that's C.  jason 9/19/94 */\n   else\n     {\n-      if (pedantic && TREE_CODE (value) == CONSTRUCTOR\n-\t  /* Don't complain about non-constant initializers of\n-\t     signature tables and signature pointers/references.  */\n-\t  && ! (TYPE_LANG_SPECIFIC (type)\n-\t\t&& (IS_SIGNATURE (type)\n-\t\t    || IS_SIGNATURE_POINTER (type)\n-\t\t    || IS_SIGNATURE_REFERENCE (type))))\n+      if (pedantic && TREE_CODE (value) == CONSTRUCTOR)\n \t{\n \t  if (! TREE_CONSTANT (value) || ! TREE_STATIC (value))\n \t    pedwarn (\"ANSI C++ forbids non-constant aggregate initializer expressions\");\n@@ -666,9 +617,7 @@ digest_init (type, init, tail)\n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == REFERENCE_TYPE\n       || code == BOOLEAN_TYPE || code == COMPLEX_TYPE\n-      || TYPE_PTRMEMFUNC_P (type)\n-      || (code == RECORD_TYPE && ! raw_constructor\n-\t  && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type))))\n+      || TYPE_PTRMEMFUNC_P (type))\n     {\n       if (raw_constructor)\n \t{\n@@ -1194,11 +1143,6 @@ build_x_arrow (datum)\n   else\n     last_rval = default_conversion (rval);\n \n-  /* Signature pointers are not dereferenced.  */\n-  if (TYPE_LANG_SPECIFIC (TREE_TYPE (last_rval))\n-      && IS_SIGNATURE_POINTER (TREE_TYPE (last_rval)))\n-    return last_rval;\n-\n   if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n     return build_indirect_ref (last_rval, NULL_PTR);\n \n@@ -1318,12 +1262,6 @@ build_functional_cast (exp, parms)\n   if (processing_template_decl)\n     return build_min (CAST_EXPR, type, parms);\n \n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"signature type not allowed in cast or constructor expression\");\n-      return error_mark_node;\n-    }\n-\n   if (! IS_AGGR_TYPE (type))\n     {\n       /* this must build a C cast */"}, {"sha": "2952f36b525f3ca0211986cf698c18b41a2c8f65", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -367,7 +367,6 @@ GNU_xref_decl (fndecl,decl)\n   else if (TREE_CODE (decl) == RECORD_TYPE)\n     {\n       if (CLASSTYPE_DECLARED_CLASS (decl)) cls = \"CLASSID\";\n-      else if (IS_SIGNATURE (decl)) cls = \"SIGNATUREID\";\n       else cls = \"STRUCTID\";\n       decl = TYPE_NAME (decl);\n       uselin = TRUE;\n@@ -417,8 +416,7 @@ GNU_xref_decl (fndecl,decl)\n \t   (cur_scope != NULL ? cur_scope->lid : 0),\n \t   cls, fctname(fndecl), buf);\n \n-  if (STREQL (cls, \"STRUCTID\") || STREQL (cls, \"UNIONID\")\n-      || STREQL (cls, \"SIGNATUREID\"))\n+  if (STREQL (cls, \"STRUCTID\") || STREQL (cls, \"UNIONID\"))\n     {\n       cls = \"CLASSID\";\n       fprintf (xref_file, \"DCL %s %d %s %d %s %s %s\\n\","}, {"sha": "253b0e635673a8aba62018762c8e5cdbdcff439c", "filename": "gcc/extend.texi", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -3158,9 +3158,6 @@ Predefined Macros,cpp.info,The C Preprocessor}).\n                          each needed template instantiation is emitted.\n * Bound member functions:: You can extract a function pointer to the\n                         method denoted by a @samp{->*} or @samp{.*} expression.\n-* C++ Signatures::\tYou can specify abstract types to get subtype\n-\t\t\t polymorphism independent from inheritance.\n-                        \n @end menu\n \n @node Naming Results\n@@ -3654,141 +3651,3 @@ fptr p = (fptr)(a.*fp);\n \n You must specify @samp{-Wno-pmf-conversions} to use this extension.\n \n-@node C++ Signatures\n-@section Type Abstraction using Signatures\n-\n-@findex signature\n-@cindex type abstraction, C++\n-@cindex C++ type abstraction\n-@cindex subtype polymorphism, C++\n-@cindex C++ subtype polymorphism\n-@cindex signatures, C++\n-@cindex C++ signatures\n-\n-In GNU C++, you can use the keyword @code{signature} to define a\n-completely abstract class interface as a datatype.  You can connect this\n-abstraction with actual classes using signature pointers.  If you want\n-to use signatures, run the GNU compiler with the\n-@samp{-fhandle-signatures} command-line option.  (With this option, the\n-compiler reserves a second keyword @code{sigof} as well, for a future\n-extension.)\n-\n-Roughly, signatures are type abstractions or interfaces of classes.\n-Some other languages have similar facilities.  C++ signatures are\n-related to ML's signatures, Haskell's type classes, definition modules\n-in Modula-2, interface modules in Modula-3, abstract types in Emerald,\n-type modules in Trellis/Owl, categories in Scratchpad II, and types in\n-POOL-I.  For a more detailed discussion of signatures, see\n-@cite{Signatures: A Language Extension for Improving Type Abstraction and\n-Subtype Polymorphism in C++}\n-by @w{Gerald} Baumgartner and Vincent F. Russo (Tech report\n-CSD--TR--95--051, Dept. of Computer Sciences, Purdue University,\n-August 1995, a slightly improved version appeared in\n-@emph{Software---Practice & Experience}, @b{25}(8), pp. 863--889,\n-August 1995).  You can get the tech report by anonymous FTP from\n-@code{ftp.cs.purdue.edu} in @file{pub/gb/Signature-design.ps.gz}.\n-\n-Syntactically, a signature declaration is a collection of\n-member function declarations and nested type declarations.\n-For example, this signature declaration defines a new abstract type\n-@code{S} with member functions @samp{int foo ()} and @samp{int bar (int)}:\n-\n-@example\n-signature S\n-@{\n-  int foo ();\n-  int bar (int);\n-@};\n-@end example\n-\n-Since signature types do not include implementation definitions, you\n-cannot write an instance of a signature directly.  Instead, you can\n-define a pointer to any class that contains the required interfaces as a\n-@dfn{signature pointer}.  Such a class @dfn{implements} the signature\n-type.\n-@c Eventually signature references should work too.\n-\n-To use a class as an implementation of @code{S}, you must ensure that\n-the class has public member functions @samp{int foo ()} and @samp{int\n-bar (int)}.  The class can have other member functions as well, public\n-or not; as long as it offers what's declared in the signature, it is\n-suitable as an implementation of that signature type.\n-\n-For example, suppose that @code{C} is a class that meets the\n-requirements of signature @code{S} (@code{C} @dfn{conforms to}\n-@code{S}).  Then\n-\n-@example\n-C obj;\n-S * p = &obj;\n-@end example\n-\n-@noindent\n-defines a signature pointer @code{p} and initializes it to point to an\n-object of type @code{C}.\n-The member function call @w{@samp{int i = p->foo ();}}\n-executes @samp{obj.foo ()}.\n-\n-@cindex @code{signature} in C++, advantages\n-Abstract virtual classes provide somewhat similar facilities in standard\n-C++.  There are two main advantages to using signatures instead:\n-\n-@enumerate\n-@item\n-Subtyping becomes independent from inheritance.  A class or signature\n-type @code{T} is a subtype of a signature type @code{S} independent of\n-any inheritance hierarchy as long as all the member functions declared\n-in @code{S} are also found in @code{T}.  So you can define a subtype\n-hierarchy that is completely independent from any inheritance\n-(implementation) hierarchy, instead of being forced to use types that\n-mirror the class inheritance hierarchy.\n-\n-@item\n-Signatures allow you to work with existing class hierarchies as\n-implementations of a signature type.  If those class hierarchies are\n-only available in compiled form, you're out of luck with abstract virtual\n-classes, since an abstract virtual class cannot be retrofitted on top of\n-existing class hierarchies.  So you would be required to write interface\n-classes as subtypes of the abstract virtual class.\n-@end enumerate\n-\n-@cindex default implementation, signature member function\n-@cindex signature member function default implementation\n-There is one more detail about signatures.  A signature declaration can\n-contain member function @emph{definitions} as well as member function\n-declarations.  A signature member function with a full definition is\n-called a @emph{default implementation}; classes need not contain that\n-particular interface in order to conform.  For example, a\n-class @code{C} can conform to the signature\n-\n-@example\n-signature T\n-@{\n-  int f (int);\n-  int f0 () @{ return f (0); @};\n-@};\n-@end example\n-\n-@noindent\n-whether or not @code{C} implements the member function @samp{int f0 ()}.\n-If you define @code{C::f0}, that definition takes precedence;\n-otherwise, the default implementation @code{S::f0} applies.\n-\n-@ignore\n-There will be more support for signatures in the future.\n-Add to this doc as the implementation grows.\n-In particular, the following features are planned but not yet\n-implemented:\n-@itemize @bullet\n-@item signature references,\n-@item signature inheritance,\n-@item the @code{sigof} construct for extracting the signature information\n-      of a class,\n-@item views for renaming member functions when matching a class type\n-      with a signature type,\n-@item specifying exceptions with signature member functions, and\n-@item signature templates.\n-@end itemize\n-This list is roughly in the order in which we intend to implement\n-them.  Watch this space for updates.\n-@end ignore"}, {"sha": "c5e6bb2c44f8fd04bd9aeb7475755f4fca2a0b0c", "filename": "gcc/invoke.texi", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eabb2412f6c4c8306fb2f8fd05abf608e29caa9/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=6eabb2412f6c4c8306fb2f8fd05abf608e29caa9", "patch": "@@ -105,7 +105,7 @@ in the following sections.\n @smallexample\n -fno-access-control  -fcheck-new  -fconserve-space  -fdollars-in-identifiers\n -fno-elide-constructors  -fexternal-templates  -ffor-scope  \n--fno-for-scope  -fno-gnu-keywords  -fguiding-decls  -fhandle-signatures\n+-fno-for-scope  -fno-gnu-keywords  -fguiding-decls\n -fhonor-std -fhuge-objects  -fno-implicit-templates  -finit-priority\n -fno-implement-inlines -fname-mangling-version-@var{n}  -fno-default-inline  \n -foperator-names  -fno-optional-diags  -fpermissive -frepo  -fstrict-prototype\n@@ -1025,10 +1025,9 @@ but to allow and give a warning for old-style code that would\n otherwise be invalid, or have different behavior.\n \n @item -fno-gnu-keywords\n-Do not recognize @code{classof}, @code{headof}, @code{signature},\n-@code{sigof} or @code{typeof} as a keyword, so that code can use these\n-words as identifiers.  You can use the keywords @code{__classof__},\n-@code{__headof__}, @code{__signature__}, @code{__sigof__}, and\n+Do not recognize @code{classof}, @code{headof}, or @code{typeof} as a\n+keyword, so that code can use these words as identifiers.  You can use\n+the keywords @code{__classof__}, @code{__headof__}, and\n @code{__typeof__} instead.  @samp{-ansi} implies\n @samp{-fno-gnu-keywords}.\n \n@@ -1046,12 +1045,6 @@ with other name mangling versions.  Like all options that change the\n ABI, all C++ code, @emph{including libgcc.a} must be built with the same\n setting of this option.\n \n-@item -fhandle-signatures\n-Recognize the @code{signature} and @code{sigof} keywords for specifying\n-abstract types.  The default (@samp{-fno-handle-signatures}) is not to\n-recognize them.  @xref{C++ Signatures, Type Abstraction using\n-Signatures}.\n-\n @item -fhonor-std\n Treat the @code{namespace std} as a namespace, instead of ignoring\n it. For compatibility with earlier versions of g++, the compiler will,"}, {"sha": "a3e927743f3a7fefca334f1680786b4d319078b0", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig01.C", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig01.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,33 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment\n-// Test assignment to local signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S * p;\n-\n-  p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g (0));\n-\n-  return 0;\n-}"}, {"sha": "f739a282c1bde503b318849ffb1c3b28b2d291bc", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig02.C", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig02.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,45 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment\n-// Test assigning objects of different classes to local signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-};\n-\n-class D\n-{\n-public:\n-  char * f (void) { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  D b;\n-  S * p;\n-  int i;\n-\n-  for (i = 0; i < 2; i++)\n-    {\n-      if (i == 0)\n-\tp = &a;\n-      else\n-\tp = &b;\n-      printf (\"%s\", p->f ());\n-    }\n-  printf (\"\\n\");\n-\n-  return 0;\n-}"}, {"sha": "d791c7edbefdd803fecbbceb32547735b5a4abeb", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig03.C", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig03.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,33 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr overloading\n-// Test overloading of signature member functions.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * f (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * f (int);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S * p;\n-\n-  p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->f (0));\n-\n-  return 0;\n-}"}, {"sha": "af5495915916dcc993ab855bf1b16e4d7bd948cd", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig04.C", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig04.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,46 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr this\n-// Test passing of 'this' pointer through signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C;\n-int inc_mod_4 (C *);\n-\n-class C\n-{\n-public:\n-  char * text[4];\n-  int    i;\n-  int    get_i (void) { return i; }\n-  char * msg   (void) { i = inc_mod_4 (this);  return text[i]; }\n-};\n-\n-signature S\n-{\n-  char * msg (void);\n-};\n-\n-int inc_mod_4 (C * p)\n-{\n-  return (p->get_i () + 1) % 4;\n-}\n-\n-int main (void)\n-{\n-  C o = { \"P\", \"A\", \"S\", \"S\", -1 };\n-  S * p;\n-  int i;\n-\n-  p = &o;\n-\n-  for (i = 0; i < 4; i++)\n-    printf (\"%s\", p->msg ());\n-\n-  printf (\"\\n\");\n-\n-  return 0;\n-}"}, {"sha": "3023e348dfb350b71458092616a35da8ede6fabb", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig05.C", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig05.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,31 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr initialization\n-// Test initialization of a local signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S * p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g (0));\n-\n-  return 0;\n-}"}, {"sha": "b6476d5f90543b08212e6d1c7dc19566a3580af0", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig06.C", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig06.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig06.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig06.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,31 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr initialization\n-// Test initialization of a local signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-C a;\n-S * p = &a;\n-\n-int main (void)\n-{\n-  printf (\"%s%s\\n\", p->f (), p->g (0));\n-\n-  return 0;\n-}"}, {"sha": "18a47be7e6e0afc8b28c96f39e5ee1847c51d2d9", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig07.C", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig07.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig07.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig07.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,29 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr default-argument\n-// Test calling a signature member function with default argument.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (char * text) { return text; }\n-};\n-\n-signature S\n-{\n-  char * f (char * text = \"PA\");\n-};\n-\n-C a;\n-S * p = &a;\n-\n-int main (void)\n-{\n-  printf (\"%s%s\\n\", p->f (), p->f (\"SS\"));\n-\n-  return 0;\n-}"}, {"sha": "2d5d14d997084d95129be9bfb5e327ac20d5732d", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig08.C", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig08.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig08.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig08.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,40 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr argument return-value\n-// Test passing a signature pointer to a function and returning it from one.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * text;\n-  char * get_msg (void) const { return text; }\n-};\n-\n-const C a = { \"PA\" };\n-const C b = { \"SS\" };\n-\n-signature S\n-{\n-  char * get_msg (void) const;\n-};\n-\n-char * f (const S * p)\n-{\n-  return p->get_msg ();\n-}\n-\n-const S * g (const C * p)\n-{\n-  return p;\n-}\n-\n-int main (void)\n-{\n-  printf (\"%s%s\\n\", f(&a), g(&b)->get_msg ());\n-\n-  return 0;\n-}"}, {"sha": "a2e3b33e192bdff2832764c11d0f991b9f42abf4", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig09.C", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig09.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig09.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig09.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,34 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment initialization new\n-// Test assignment to/initialization of signature pointer with run-time value.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  int f (void) { return 1; }\n-};\n-\n-signature S\n-{\n-  int f (void);\n-};\n-\n-S * p1 = new C;\n-\n-int main (void)\n-{\n-  S * p2 = new C;\n-  S * p3;\n-\n-  p3 = new C;\n-\n-  if (p1->f () + p2->f () + p3->f () == 3)\n-    printf (\"PASS\\n\");\n-\n-  return 0;\n-}"}, {"sha": "e16f2eeb095723cb242b5ed455fad01f5b184309", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig10.C", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig10.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,38 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr argument return-value new\n-// Test passing a signature pointer to a function and returning it from one.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-  char * text;\n-public:\n-  C (char * s) { text = s; }\n-  char * get_msg (void) const { return text; }\n-};\n-\n-signature S\n-{\n-  char * get_msg (void) const;\n-};\n-\n-char * f (const S * p)\n-{\n-  return p->get_msg ();\n-}\n-\n-const S * g (const C * p)\n-{\n-  return p;\n-}\n-\n-int main (void)\n-{\n-  printf (\"%s%s\\n\", f(new C (\"PA\")), g(new C (\"SS\"))->get_msg ());\n-\n-  return 0;\n-}"}, {"sha": "892695f3fa39ec719a66964fd939476cdcf8a994", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig11.C", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig11.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,34 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr array\n-// Test a signature pointer array.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-};\n-\n-class D\n-{\n-public:\n-  char * f (void) { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-};\n-\n-int main (void)\n-{\n-  S * p[2] = { new C, new D };\n-\n-  printf (\"%s%s\\n\", p[0]->f (), p[1]->f ());\n-\n-  return 0;\n-}"}, {"sha": "2747a805915c5da031b50c4c69a90e5d5162b410", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig12.C", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig12.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,40 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr structure\n-// Test a signature pointer structure.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-};\n-\n-class D\n-{\n-public:\n-  char * f (void) { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-};\n-\n-struct SP\n-{\n-  S * p;\n-  S * q;\n-};\n-\n-int main (void)\n-{\n-  SP o = { new C, new D };\n-\n-  printf (\"%s%s\\n\", o.p->f (), o.q->f ());\n-\n-  return 0;\n-}"}, {"sha": "f5da9f8088802fa58106c19d45e9b0aba538da7e", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig13.C", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig13.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,38 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment initialization\n-// Test assignment of/initialization with same type signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  int f (void) { return 1; }\n-};\n-\n-signature S\n-{\n-  int f (void);\n-};\n-\n-C a;\n-S * p1 = &a;\n-S * q1 = p1;\n-\n-int main (void)\n-{\n-  C a;\n-  S * p2 = &a;\n-  S * q2 = p2;\n-  S * q3;\n-\n-  q3 = p2;\n-\n-  if (q1->f () + q2->f () + q3->f () == 3)\n-    printf (\"PASS\\n\");\n-\n-  return 0;\n-}"}, {"sha": "6ce1d02d1bfca6dfdba417454b90fe4d8f5451a3", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig14.C", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig14.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,55 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment initialization\n-// Test assignment of/initialization with different type signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  int f (void) { return 1; }\n-  int g (int)  { return 2; }\n-};\n-\n-signature S\n-{\n-  int f (void);\n-  int g (int);\n-};\n-\n-signature T\n-{\n-  int f (void);\n-};\n-\n-signature U\n-{\n-  int g (int);\n-};\n-\n-C a;\n-S * p1 = &a;\n-T * q1 = p1;\n-U * r1 = p1;\n-\n-int main (void)\n-{\n-  C a;\n-  S * p2 = &a;\n-  T * q2 = p2;\n-  U * r2 = p2;\n-  T * q3;\n-  U * r3;\n-\n-  q3 = p2;\n-  r3 = p2;\n-\n-  if (q1->f () + q2->f () + q3->f () == 3\n-      && r1->g (0) + r2->g (0) + r3->g (0) == 6)\n-    printf (\"PASS\\n\");\n-\n-  return 0;\n-}"}, {"sha": "f0ae52e9ea7ad78713d6fdcd2807265d09681f1c", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig15.C", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig15.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,35 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr cast\n-// Test casting a signature pointer to a class pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S * p;\n-  C * q;\n-\n-  p = &a;\n-  q = (C *) p;\n-\n-  printf (\"%s%s\\n\", q->f (), q->g (0));\n-\n-  return 0;\n-}"}, {"sha": "35475e9f50470c2780012a864dc51a9a11e40b70", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig16.C", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig16.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,44 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr cast\n-// Test casting a class pointer to an anonymous signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"S\"; }\n-  char * h (void) { return \"FAIL\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-signature T\n-{\n-  char * f (void);\n-};\n-\n-C a;\n-signature { char * g (int); } * r1 =\n-  (signature { char * h (void); char * g (int); } *) &a;\n-\n-int main (void)\n-{\n-  C a;\n-  S * p = &a;\n-  T * q = p;\n-  signature { char * g (int); } * r2 =\n-    (signature { char * h (void); char * g (int); } *) &a;\n-\n-  printf (\"%s%s%s\\n\", q->f (), r1->g (0), r2->g (0));\n-\n-  return 0;\n-}"}, {"sha": "6d1d1d94df6775907806df49d068a8e2d466180e", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig17.C", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig17.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,54 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr cast\n-// Test casting a class pointer through a chain of signature pointers.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-class D : public C\n-{\n-public:\n-  char * h (void) { return \"FAIL\"; }\n-};\n-\n-class E : public C\n-{\n-public:\n-  int foo (int) { return 0; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-signature T\n-{\n-  char * f (void);\n-};\n-\n-int main (void)\n-{\n-  D a;\n-  S * p;\n-  T * q;\n-  signature { char * g (int); } * r;\n-\n-  p = &a;\n-  q = (T*) (signature { char * f (void); int foo (int); } *) (E*) (S*) (C*) p;\n-  r = (signature { char * h (void); char * g (int); } *) &a;\n-\n-  printf (\"%s%s\\n\", q->f (), r->g (0));\n-\n-  return 0;\n-}"}, {"sha": "ba0ec8689cdb75c6c94faa2a6ac79bc7b559a998", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig18.C", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig18.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,33 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment virtual\n-// Test assignment of object from virtual class to signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  virtual char * f (void) { return \"PA\"; }\n-  virtual char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S * p;\n-\n-  p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g (0));\n-\n-  return 0;\n-}"}, {"sha": "160a4a3bd49ef8711980b772d4ce607df293f8f2", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig19.C", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig19.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,38 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr initialization virtual\n-// Test initialization of signature pointer with object from abstract class.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  virtual char * f (void) = 0;\n-  virtual char * g (int)  = 0;\n-};\n-\n-class D : public C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C * p = new D;\n-  S * q = p;\n-\n-  printf (\"%s%s\\n\", q->f (), q->g (0));\n-\n-  return 0;\n-}"}, {"sha": "a8228de74b99735104ecc88bbb5f5662a5516e0e", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig20.C", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig20.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,38 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr initialization virtual\n-// Test initialization of signature pointer with object from virtual class.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  virtual char * f (void) { return \"FA\"; }\n-  virtual char * g (int)  { return \"IL\"; }\n-};\n-\n-class D : public C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-  char * g (int)  { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (int);\n-};\n-\n-int main (void)\n-{\n-  C * p = new D;\n-  S * q = p;\n-\n-  printf (\"%s%s\\n\", q->f (), q->g (0));\n-\n-  return 0;\n-}"}, {"sha": "faad45b6403d101c9703acce7c4ec5049edc39d0", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig21.C", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig21.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,56 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment virtual\n-// Test assignment of objects of different types to same signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  virtual char * f (void) = 0;\n-};\n-\n-class D : public C\n-{\n-public:\n-  char * f (void) { return \"P\"; }\n-};\n-\n-class E\n-{\n-public:\n-  char * f (void) { return \"AS\"; }\n-};\n-\n-class F : public C\n-{\n-public:\n-  char * f (void) { return \"S\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-};\n-\n-int main (void)\n-{\n-  E a;\n-  C * p = new D;\n-  S * q;\n-\n-  q = p;\n-  printf (\"%s\", q->f ());\n-\n-  q = &a;\n-  printf (\"%s\", q->f ());\n-\n-  p = new F;\n-  q = p;\n-  printf (\"%s\\n\", q->f ());\n-\n-  return 0;\n-}"}, {"sha": "25b0a1aa5d1bb7becd9cbc4bdb2f636b8fa4b121", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig22.C", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig22.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,59 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment initialization\n-// Test assignment to/init of sigptr that requires copying sigtable slots.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  int f (void) { return 1; }\n-  int g (int)  { return 2; }\n-  int h (void) { return 666; }\n-};\n-\n-signature S\n-{\n-  int f (void);\n-  int g (int);\n-  int h (void);\n-};\n-\n-signature T\n-{\n-  int f (void);\n-  int h (void);\n-};\n-\n-signature U\n-{\n-  int h (void);\n-  int g (int);\n-};\n-\n-C a;\n-S * p  = &a;\n-T * q1 = p;\n-U * r1 = p;\n-\n-int main (void)\n-{\n-  C a;\n-  S * p  = &a;\n-  T * q2 = p;\n-  U * r2 = p;;\n-  T * q3;\n-  U * r3;\n-\n-  q3 = p;\n-  r3 = p;\n-\n-  if (q1->f () + q2->f () + q3->f () == 3\n-      && r1->g (0) + r2->g (0) + r3->g (0) == 6)\n-    printf (\"PASS\\n\");\n-\n-  return 0;\n-}"}, {"sha": "767cfa31281cb966f9df48cfe2254b5335914e2d", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig23.C", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig23.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,53 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment local-signature\n-// Test assignment to signature pointer of local signature.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-char * PA (void)\n-{\n-  class C\n-  {\n-  public:\n-    char * f (void) { return \"PA\"; }\n-  };\n-\n-  signature S\n-  {\n-    char * f (void);\n-  };\n-\n-  C a;\n-  S * p = &a;\n-\n-  return p->f ();\n-}\n-\n-char * SS (void)\n-{\n-  class C\n-  {\n-  public:\n-    char * f (void) { return \"SS\"; }\n-  };\n-\n-  signature S\n-  {\n-    char * f (void);\n-  };\n-\n-  C a;\n-  S * p = &a;\n-\n-  return p->f ();\n-}\n-\n-int main (void)\n-{\n-  printf (\"%s%s\\n\", PA (), SS ());\n-\n-  return 0;\n-}"}, {"sha": "2dca6f994ce30d2b5e51f287f3462a9b7fb1b75c", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig24.C", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig24.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,36 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr opaque-type\n-// Test calling member functions taking/returning opaque type through sigptr.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-signature S\n-{\n-  typedef t;\n-  char * f (t);\n-  t g (void);\n-  t h (void);\n-};\n-\n-class C\n-{\n-public:\n-  typedef char * t;\n-  char * f (t text) { return text; }\n-  t g (void) { return \"PA\"; }\n-  t h (void) { return \"SS\"; }\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  S *  p = &a;\n-  S::t w = p->h ();\n-\n-  printf (\"%s%s\\n\", p->f (p->g ()), p->f (w));\n-\n-  return 0;\n-}"}, {"sha": "d00ef57ca5e1890c70e9e2e235e2796442ab8e55", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig25.C", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig25.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,33 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr default-implementation\n-// Test calling default implementation through signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C { };\n-\n-class D\n-{\n-public:\n-  char * f (void) { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void) { return \"PA\"; }\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  D b;\n-  S * p = &a;\n-  S * q = &b;\n-\n-  printf (\"%s%s\\n\", p->f (), q->f ());\n-\n-  return 0;\n-}"}, {"sha": "399737b4a37d6cf3d4294fb1b5873365b670e9fe", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig26.C", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig26.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,34 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr default-implementation\n-// Test calling default implementation through signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C { };\n-\n-class D\n-{\n-public:\n-  char * f (void) { return \"SS\"; }\n-};\n-\n-signature S\n-{\n-  char * f (void) { return \"PA\"; }\n-  char * g (void) { return f (); }\n-};\n-\n-int main (void)\n-{\n-  C a;\n-  D b;\n-  S * p = &a;\n-  S * q = &b;\n-\n-  printf (\"%s%s\\n\", p->g (), q->g ());\n-\n-  return 0;\n-}"}, {"sha": "7b9e7d2961701658df855fb5ee00f69be8979e12", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig27.C", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig27.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,38 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr multiple-inheritance\n-// Test class defined by multiple inheritance as implementation of signature.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * f (void) { return \"PA\"; }\n-};\n-\n-class D\n-{\n-public:\n-  char * g (void) { return \"SS\"; }\n-};\n-\n-class E : public C, public D { };\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (void);\n-};\n-\n-int main (void)\n-{\n-  E a;\n-  S * p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g ());\n-\n-  return 0;\n-}"}, {"sha": "4edff680ce854d7f006440aa6d35655ffa08edfc", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig28.C", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig28.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,46 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr multiple-inheritance\n-// Test correct adjustment of `this' pointer in case of multiple inheritance.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-  char * text;\n-public:\n-  C () { text = \"PA\"; }\n-  char * f (void) { return text; }\n-};\n-\n-class D\n-{\n-  char * text;\n-public:\n-  D () { text = \"SS\"; }\n-  char * g (void) { return text; }\n-};\n-\n-class E : public C, public D\n-{\n-public:\n-  E () : C (), D () { }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (void);\n-};\n-\n-int main (void)\n-{\n-  E a;\n-  S * p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g ());\n-\n-  return 0;\n-}"}, {"sha": "e5c5e392643681581d981978cbd5898368e2b859", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig29.C", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig29.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,46 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr multiple-inheritance\n-// Test calling virtual function from MI class through signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-  char * text;\n-public:\n-  C () { text = \"PA\"; }\n-  virtual char * f (void) { return text; }\n-};\n-\n-class D\n-{\n-  char * text;\n-public:\n-  D () { text = \"SS\"; }\n-  virtual char * g (void) { return text; }\n-};\n-\n-class E : public C, public D\n-{\n-public:\n-  E () : C (), D () { }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (void);\n-};\n-\n-int main (void) \n-{ \n-  E a;\n-  S * p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g ());\n-\n-  return 0;\n-}"}, {"sha": "3e93e114b86713bba05f921eb1e86c40582410fe", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig30.C", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig30.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,48 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr multiple-inheritance\n-// Test calling overwritten virtual functions through signature pointer.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  char * text1;\n-  C () { text1 = \"PA\"; }\n-  virtual char * f (void) = 0;\n-};\n-\n-class D\n-{\n-public:\n-  char * text2;\n-  D () { text2 = \"SS\"; }\n-  virtual char * g (void) = 0;\n-};\n-\n-class E : public C, public D\n-{\n-public:\n-  E () : C (), D () { };\n-  char * f (void) { return text1; }\n-  char * g (void) { return text2; }\n-};\n-\n-signature S\n-{\n-  char * f (void);\n-  char * g (void);\n-};\n-\n-int main (void)\n-{\n-  E a;\n-  S * p = &a;\n-\n-  printf (\"%s%s\\n\", p->f (), p->g ());\n-\n-  return 0;\n-}"}, {"sha": "90fa9e9d47a8d1041daff82851975319dffbb9d6", "filename": "gcc/testsuite/g++.old-deja/g++.gb/sig31.C", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6062b273ff29769c373f0c541c6fe76a642a1b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.gb%2Fsig31.C?ref=b6062b273ff29769c373f0c541c6fe76a642a1b0", "patch": "@@ -1,52 +0,0 @@\n-// Special g++ Options: -fhandle-signatures\n-// GROUPS passed gb sigptr assignment sigsigtable\n-// Test use of multiple signature-signature tables for same signature pair.\n-\n-extern \"C\"\n-{\n-  int printf (char *, ...);\n-}\n-\n-class C\n-{\n-public:\n-  virtual int f (void) { return 1; }\n-  int g (int)          { return 2; }\n-};\n-\n-class D : public C\n-{\n-public:\n-  int f (void) { return 3; }\n-  int g (int)  { return 4; }\n-};\n-\n-signature S\n-{\n-  int f (void);\n-  int g (int);\n-};\n-\n-signature T\n-{\n-  int g (int);\n-  int f (void);\n-};\n-\n-int main (void)\n-{\n-  S * p = new C;\n-  T * q = p;\n-  T * r;\n-\n-  p = new D;\n-  r = p;\n-\n-  if (q->f () == 1 && q->g (0) == 2\n-      && r->f () == 3 && r->g (0) == 4)\n-    printf (\"PASS\\n\");\n-  else\n-    printf (\"FAIL\\n\");\n-\n-  return 0;\n-}"}]}