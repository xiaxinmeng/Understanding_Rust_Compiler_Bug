{"sha": "15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViYWMxOTE5YWFiOGE0ZmNiZDAxNTBlMzBmMWJjNTNhZTJiMjcxZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T08:53:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-11T08:53:50Z"}, "message": "Removed.\n\nFrom-SVN: r251963", "tree": {"sha": "e0208c57193e2043250aeb4484fa870e98a73862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0208c57193e2043250aeb4484fa870e98a73862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f/comments", "author": null, "committer": null, "parents": [{"sha": "971d03a33a6e1de4fd740c093c73dcd8ccf11ac8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/971d03a33a6e1de4fd740c093c73dcd8ccf11ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/971d03a33a6e1de4fd740c093c73dcd8ccf11ac8"}], "stats": {"total": 1051, "additions": 0, "deletions": 1051}, "files": [{"sha": "3dec199a263bdcaebd2296040a0f4856c7435e7a", "filename": "gcc/ada/9drpc.adb", "status": "removed", "additions": 0, "deletions": 1051, "changes": 1051, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/971d03a33a6e1de4fd740c093c73dcd8ccf11ac8/gcc%2Fada%2F9drpc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/971d03a33a6e1de4fd740c093c73dcd8ccf11ac8/gcc%2Fada%2F9drpc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F9drpc.adb?ref=971d03a33a6e1de4fd740c093c73dcd8ccf11ac8", "patch": "@@ -1,1051 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                           S Y S T E M . R P C                            --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Version for ???\n-\n-with Unchecked_Deallocation;\n-with Ada.Streams;\n-\n-with System.RPC.Net_Trace;\n-with System.RPC.Garlic;\n-with System.RPC.Streams;\n-pragma Elaborate (System.RPC.Garlic);\n-\n-package body System.RPC is\n-\n-   --  ??? general note: the debugging calls are very heavy, especially\n-   --  those that create exception handlers in every procedure. Do we\n-   --  really still need all this stuff?\n-\n-   use type Ada.Streams.Stream_Element_Count;\n-   use type Ada.Streams.Stream_Element_Offset;\n-\n-   use type Garlic.Protocol_Access;\n-   use type Garlic.Lock_Method;\n-\n-   Max_Of_Message_Id : constant := 127;\n-\n-   subtype Message_Id_Type is\n-     Integer range -Max_Of_Message_Id .. Max_Of_Message_Id;\n-   --  A message id is either a request id or reply id. A message id is\n-   --  provided with a message to a receiving stub which uses the opposite\n-   --  as a reply id. A message id helps to retrieve to which task is\n-   --  addressed a reply. When the environment task receives a message, the\n-   --  message id is extracted : a positive message id stands for a call, a\n-   --  negative message id stands for a reply. A null message id stands for\n-   --  an asynchronous request.\n-\n-   subtype Request_Id_Type is Message_Id_Type range 1 .. Max_Of_Message_Id;\n-   --  When a message id is positive, it is a request\n-\n-   type Message_Length_Per_Request is array (Request_Id_Type)\n-      of Ada.Streams.Stream_Element_Count;\n-\n-   Header_Size : Ada.Streams.Stream_Element_Count :=\n-                   Streams.Get_Integer_Initial_Size +\n-                     Streams.Get_SEC_Initial_Size;\n-   --  Initial size needed for frequently used header streams\n-\n-   Stream_Error : exception;\n-   --  Occurs when a read procedure is executed on an empty stream\n-   --  or when a write procedure is executed on a full stream\n-\n-   Partition_RPC_Receiver : RPC_Receiver;\n-   --  Cache the RPC_Receiver passed by Establish_RPC_Receiver\n-\n-   type Anonymous_Task_Node;\n-\n-   type Anonymous_Task_Node_Access is access Anonymous_Task_Node;\n-   --  Types we need to construct a singly linked list of anonymous tasks\n-   --  This pool is maintained to avoid a task creation each time a RPC\n-   --  occurs - to be cont'd\n-\n-   task type Anonymous_Task_Type (Self : Anonymous_Task_Node_Access) is\n-\n-      entry Start\n-         (Message_Id   : Message_Id_Type;\n-          Partition    : Partition_ID;\n-          Params_Size  : Ada.Streams.Stream_Element_Count;\n-          Result_Size  : Ada.Streams.Stream_Element_Count;\n-          Protocol     : Garlic.Protocol_Access);\n-      --  This entry provides an anonymous task a remote call to perform.\n-      --  This task calls for a Request id is provided to construct the\n-      --  reply id by using -Request. Partition is used to send the reply\n-      --  message. Params_Size is the size of the calling stub Params stream.\n-      --  Then Protocol (used by the environment task previously) allows\n-      --  extraction of the message following the header (The header is\n-      --  extracted by the environment task)\n-      --  Note: grammar in above is obscure??? needs cleanup\n-\n-   end Anonymous_Task_Type;\n-\n-   type Anonymous_Task_Access is access Anonymous_Task_Type;\n-\n-   type Anonymous_Task_List is record\n-      Head     : Anonymous_Task_Node_Access;\n-      Tail     : Anonymous_Task_Node_Access;\n-   end record;\n-\n-   type Anonymous_Task_Node is record\n-      Element : Anonymous_Task_Access;\n-      Next    : Anonymous_Task_Node_Access;\n-   end record;\n-   --  Types we need to construct a singly linked list of anonymous tasks.\n-   --  This pool is maintained to avoid a task creation each time a RPC occurs.\n-\n-   protected Garbage_Collector is\n-\n-      procedure Allocate\n-         (Item : out Anonymous_Task_Node_Access);\n-      --  Anonymous task pool management : if there is an anonymous task\n-      --  left, use it. Otherwise, allocate a new one\n-\n-      procedure Deallocate\n-         (Item : in out Anonymous_Task_Node_Access);\n-      --  Anonymous task pool management : queue this task in the pool\n-      --  of inactive anonymous tasks.\n-\n-   private\n-\n-      Anonymous_List : Anonymous_Task_Node_Access;\n-      --  The list root of inactive anonymous tasks\n-\n-   end Garbage_Collector;\n-\n-   task Dispatcher is\n-\n-      entry New_Request (Request : out Request_Id_Type);\n-      --  To get a new request\n-\n-      entry Wait_On (Request_Id_Type)\n-        (Length : out Ada.Streams.Stream_Element_Count);\n-      --  To block the calling stub when it waits for a reply\n-      --  When it is resumed, we provide the size of the reply\n-\n-      entry Wake_Up\n-        (Request : Request_Id_Type;\n-         Length  : Ada.Streams.Stream_Element_Count);\n-      --  To wake up the calling stub when the environment task has\n-      --  received a reply for this request\n-\n-   end Dispatcher;\n-\n-   task Environnement is\n-\n-      entry Start;\n-      --  Receive no message until Partition_Receiver is set\n-      --  Establish_RPC_Receiver decides when the environment task\n-      --  is allowed to start\n-\n-   end Environnement;\n-\n-   protected Partition_Receiver is\n-\n-      entry Is_Set;\n-      --  Blocks if the Partition_RPC_Receiver has not been set\n-\n-      procedure Set;\n-      --  Done by Establish_RPC_Receiver when Partition_RPC_Receiver\n-      --  is known\n-\n-   private\n-\n-      Was_Set : Boolean := False;\n-      --  True when Partition_RPC_Receiver has been set\n-\n-   end Partition_Receiver;\n-   --  Anonymous tasks have to wait for the Partition_RPC_Receiver\n-   --  to be established\n-\n-   type Debug_Level is\n-      (D_Elaborate,        --  About the elaboration of this package\n-       D_Communication,    --  About calls to Send and Receive\n-       D_Debug,            --  Verbose\n-       D_Exception);       --  Exception handler\n-   --  Debugging levels\n-\n-   package Debugging is new System.RPC.Net_Trace (Debug_Level, \"RPC : \");\n-   --  Debugging package\n-\n-   procedure D\n-     (Flag : Debug_Level; Info : String) renames Debugging.Debug;\n-   --  Shortcut\n-\n-   ------------------------\n-   -- Partition_Receiver --\n-   ------------------------\n-\n-   protected body Partition_Receiver is\n-\n-      -------------------------------\n-      -- Partition_Receiver.Is_Set --\n-      -------------------------------\n-\n-      entry Is_Set when Was_Set is\n-      begin\n-         null;\n-      end Is_Set;\n-\n-      ----------------------------\n-      -- Partition_Receiver.Set --\n-      ----------------------------\n-\n-      procedure Set is\n-      begin\n-         Was_Set := True;\n-      end Set;\n-\n-   end Partition_Receiver;\n-\n-   ---------------\n-   -- Head_Node --\n-   ---------------\n-\n-   procedure Head_Node\n-     (Index  : out Packet_Node_Access;\n-      Stream : Params_Stream_Type)\n-   is\n-   begin\n-      Index := Stream.Extra.Head;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Head_Node\");\n-         raise;\n-   end Head_Node;\n-\n-   ---------------\n-   -- Tail_Node --\n-   ---------------\n-\n-   procedure Tail_Node\n-     (Index  : out Packet_Node_Access;\n-      Stream : Params_Stream_Type)\n-   is\n-   begin\n-      Index := Stream.Extra.Tail;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Tail_Node\");\n-         raise;\n-   end Tail_Node;\n-\n-   ---------------\n-   -- Null_Node --\n-   ---------------\n-\n-   function Null_Node (Index : Packet_Node_Access) return Boolean is\n-   begin\n-      return Index = null;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Null_Node\");\n-         raise;\n-   end Null_Node;\n-\n-   ----------------------\n-   -- Delete_Head_Node --\n-   ----------------------\n-\n-   procedure Delete_Head_Node (Stream : in out Params_Stream_Type) is\n-\n-      procedure Free is\n-        new Unchecked_Deallocation\n-        (Packet_Node, Packet_Node_Access);\n-\n-      Next_Node : Packet_Node_Access := Stream.Extra.Head.Next;\n-\n-   begin\n-      --  Delete head node and free memory usage\n-\n-      Free (Stream.Extra.Head);\n-      Stream.Extra.Head := Next_Node;\n-\n-      --  If the extra storage is empty, update tail as well\n-\n-      if Stream.Extra.Head = null then\n-         Stream.Extra.Tail := null;\n-      end if;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Delete_Head_Node\");\n-         raise;\n-   end Delete_Head_Node;\n-\n-   ---------------\n-   -- Next_Node --\n-   ---------------\n-\n-   procedure Next_Node (Node : in out Packet_Node_Access) is\n-   begin\n-      --  Node is set to the next node\n-      --  If not possible, Stream_Error is raised\n-\n-      if Node = null then\n-         raise Stream_Error;\n-      else\n-         Node := Node.Next;\n-      end if;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Next_Node\");\n-         raise;\n-   end Next_Node;\n-\n-   ---------------------\n-   -- Append_New_Node --\n-   ---------------------\n-\n-   procedure Append_New_Node (Stream : in out Params_Stream_Type) is\n-      Index : Packet_Node_Access;\n-\n-   begin\n-      --  Set Index to the end of the linked list\n-\n-      Tail_Node (Index, Stream);\n-\n-      if Null_Node (Index) then\n-\n-         --  The list is empty : set head as well\n-\n-         Stream.Extra.Head := new Packet_Node;\n-         Stream.Extra.Tail := Stream.Extra.Head;\n-\n-      else\n-         --  The list is not empty : link new node with tail\n-\n-         Stream.Extra.Tail.Next := new Packet_Node;\n-         Stream.Extra.Tail := Stream.Extra.Tail.Next;\n-\n-      end if;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Append_New_Node\");\n-         raise;\n-   end Append_New_Node;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   procedure Read\n-     (Stream : in out Params_Stream_Type;\n-      Item   : out Ada.Streams.Stream_Element_Array;\n-      Last   : out Ada.Streams.Stream_Element_Offset)\n-     renames System.RPC.Streams.Read;\n-\n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write\n-     (Stream : in out Params_Stream_Type;\n-      Item   : Ada.Streams.Stream_Element_Array)\n-     renames System.RPC.Streams.Write;\n-\n-   -----------------------\n-   -- Garbage_Collector --\n-   -----------------------\n-\n-   protected body Garbage_Collector is\n-\n-      --------------------------------\n-      -- Garbage_Collector.Allocate --\n-      --------------------------------\n-\n-      procedure Allocate (Item : out Anonymous_Task_Node_Access) is\n-         New_Anonymous_Task_Node : Anonymous_Task_Node_Access;\n-         Anonymous_Task          : Anonymous_Task_Access;\n-\n-      begin\n-         --  If the list is empty, allocate a new anonymous task\n-         --  Otherwise, reuse the first queued anonymous task\n-\n-         if Anonymous_List = null then\n-\n-            --  Create a new anonymous task\n-            --  Provide this new task with its id to allow it\n-            --  to enqueue itself into the free anonymous task list\n-            --  with the function Deallocate\n-\n-            New_Anonymous_Task_Node := new Anonymous_Task_Node;\n-            Anonymous_Task :=\n-             new Anonymous_Task_Type (New_Anonymous_Task_Node);\n-            New_Anonymous_Task_Node.all := (Anonymous_Task, null);\n-\n-         else\n-            --  Extract one task from the list\n-            --  Set the Next field to null to avoid possible bugs\n-\n-            New_Anonymous_Task_Node  := Anonymous_List;\n-            Anonymous_List := Anonymous_List.Next;\n-            New_Anonymous_Task_Node.Next := null;\n-\n-         end if;\n-\n-         --  Item is an out parameter\n-\n-         Item := New_Anonymous_Task_Node;\n-\n-      exception\n-         when others =>\n-            D (D_Exception, \"exception in Allocate (Anonymous Task)\");\n-            raise;\n-      end Allocate;\n-\n-      ----------------------------------\n-      -- Garbage_Collector.Deallocate --\n-      ----------------------------------\n-\n-      procedure Deallocate (Item : in out Anonymous_Task_Node_Access) is\n-      begin\n-         --  Enqueue the task in the free list\n-\n-         Item.Next := Anonymous_List;\n-         Anonymous_List := Item;\n-\n-      exception\n-         when others =>\n-            D (D_Exception, \"exception in Deallocate (Anonymous Task)\");\n-            raise;\n-      end Deallocate;\n-\n-   end Garbage_Collector;\n-\n-   ------------\n-   -- Do_RPC --\n-   ------------\n-\n-   procedure Do_RPC\n-     (Partition  : Partition_ID;\n-      Params     : access Params_Stream_Type;\n-      Result     : access Params_Stream_Type)\n-   is\n-      Protocol   : Protocol_Access;\n-      Request    : Request_Id_Type;\n-      Header     : aliased Params_Stream_Type (Header_Size);\n-      R_Length   : Ada.Streams.Stream_Element_Count;\n-\n-   begin\n-      --  Parameters order :\n-      --       Opcode   (provided and used by garlic)\n-      --   (1) Size     (provided by s-rpc and used by garlic)\n-      --                (size of (2)+(3)+(4)+(5))\n-      --   (2) Request  (provided by calling stub (resp receiving stub) and\n-      --                 used by anonymous task (resp Do_RPC))\n-      --                *** ZERO IF APC ***\n-      --   (3) Res.len. (provided by calling stubs and used by anonymous task)\n-      --                *** ZERO IF APC ***\n-      --   (4) Receiver (provided by calling stubs and used by anonymous task)\n-      --   (5) Params   (provided by calling stubs and used by anonymous task)\n-\n-      --  The call is a remote call or a local call. A local call occurs\n-      --  when the pragma All_Calls_Remote has been specified. Do_RPC is\n-      --  called and the execution has to be performed in the PCS\n-\n-      if Partition /= Garlic.Get_My_Partition_ID then\n-\n-         --  Get a request id to be resumed when the reply arrives\n-\n-         Dispatcher.New_Request (Request);\n-\n-         --  Build header = request (2) + result.initial_size (3)\n-\n-         D (D_Debug, \"Do_RPC - Build header\");\n-         Streams.Allocate (Header);\n-         Streams.Integer_Write_Attribute            --  (2)\n-           (Header'Access, Request);\n-         System.RPC.Streams.SEC_Write_Attribute     --  (3)\n-           (Header'Access, Result.Initial_Size);\n-\n-         --  Get a protocol method to communicate with the remote partition\n-         --  and give the message size\n-\n-         D (D_Communication,\n-            \"Do_RPC - Lookup for protocol to talk to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Initiate_Send\n-           (Partition,\n-            Streams.Get_Stream_Size (Header'Access) +\n-            Streams.Get_Stream_Size (Params), --  (1)\n-            Protocol,\n-            Garlic.Remote_Call);\n-\n-         --  Send the header by using the protocol method\n-\n-         D (D_Communication, \"Do_RPC - Send Header to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Send\n-           (Protocol.all,\n-            Partition,\n-            Header'Access);                         --  (2) + (3)\n-\n-         --  The header is deallocated\n-\n-         Streams.Deallocate (Header);\n-\n-         --  Send Params from Do_RPC\n-\n-         D (D_Communication, \"Do_RPC - Send Params to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Send\n-           (Protocol.all,\n-            Partition,\n-            Params);                                --  (4) + (5)\n-\n-         --  Let Garlic know we have nothing else to send\n-\n-         Garlic.Complete_Send\n-           (Protocol.all,\n-            Partition);\n-         D (D_Debug, \"Do_RPC - Suspend\");\n-\n-         --  Wait for a reply and get the reply message length\n-\n-         Dispatcher.Wait_On (Request) (R_Length);\n-         D (D_Debug, \"Do_RPC - Resume\");\n-\n-         declare\n-            New_Result : aliased Params_Stream_Type (R_Length);\n-         begin\n-            --  Adjust the Result stream size right now to be able to load\n-            --  the stream in one receive call. Create a temporary result\n-            --  that will be substituted to Do_RPC one\n-\n-            Streams.Allocate (New_Result);\n-\n-            --  Receive the reply message from receiving stub\n-\n-            D (D_Communication, \"Do_RPC - Receive Result from partition\" &\n-            Partition_ID'Image (Partition));\n-            Garlic.Receive\n-              (Protocol.all,\n-               Partition,\n-               New_Result'Access);\n-\n-            --  Let Garlic know we have nothing else to receive\n-\n-            Garlic.Complete_Receive\n-              (Protocol.all,\n-               Partition);\n-\n-            --  Update calling stub Result stream\n-\n-            D (D_Debug, \"Do_RPC - Reconstruct Result\");\n-            Streams.Deallocate (Result.all);\n-            Result.Initial := New_Result.Initial;\n-            Streams.Dump (\"|||\", Result.all);\n-\n-         end;\n-\n-      else\n-         --  Do RPC locally and first wait for Partition_RPC_Receiver to be\n-         --  set\n-\n-         Partition_Receiver.Is_Set;\n-         D (D_Debug, \"Do_RPC - Locally\");\n-         Partition_RPC_Receiver.all (Params, Result);\n-\n-      end if;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Do_RPC\");\n-         raise;\n-   end Do_RPC;\n-\n-   ------------\n-   -- Do_APC --\n-   ------------\n-\n-   procedure Do_APC\n-     (Partition  : Partition_ID;\n-      Params     : access Params_Stream_Type)\n-   is\n-      Message_Id : Message_Id_Type := 0;\n-      Protocol   : Protocol_Access;\n-      Header     : aliased Params_Stream_Type (Header_Size);\n-\n-   begin\n-      --  For more information, see above\n-      --  Request = 0 as we are not waiting for a reply message\n-      --  Result length = 0 as we don't expect a result at all\n-\n-      if Partition /= Garlic.Get_My_Partition_ID then\n-\n-         --  Build header = request (2) + result.initial_size (3)\n-         --  As we have an APC, the request id is null to indicate\n-         --  to the receiving stub that we do not expect a reply\n-         --  This comes from 0 = -0\n-\n-         D (D_Debug, \"Do_APC - Build Header\");\n-         Streams.Allocate (Header);\n-         Streams.Integer_Write_Attribute\n-           (Header'Access, Integer (Message_Id));\n-         Streams.SEC_Write_Attribute\n-           (Header'Access, 0);\n-\n-         --  Get a protocol method to communicate with the remote partition\n-         --  and give the message size\n-\n-         D (D_Communication,\n-            \"Do_APC - Lookup for protocol to talk to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Initiate_Send\n-           (Partition,\n-            Streams.Get_Stream_Size (Header'Access) +\n-            Streams.Get_Stream_Size (Params),\n-            Protocol,\n-            Garlic.Remote_Call);\n-\n-         --  Send the header by using the protocol method\n-\n-         D (D_Communication, \"Do_APC - Send Header to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Send\n-           (Protocol.all,\n-            Partition,\n-            Header'Access);\n-\n-         --  The header is deallocated\n-\n-         Streams.Deallocate (Header);\n-\n-         --  Send Params from Do_APC\n-\n-         D (D_Communication, \"Do_APC - Send Params to partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Send\n-           (Protocol.all,\n-            Partition,\n-            Params);\n-\n-         --  Let Garlic know we have nothing else to send\n-\n-         Garlic.Complete_Send\n-           (Protocol.all,\n-            Partition);\n-      else\n-\n-         declare\n-            Result   : aliased Params_Stream_Type (0);\n-         begin\n-            --  Result is here a dummy parameter\n-            --  No reason to deallocate as it is not allocated at all\n-\n-            Partition_Receiver.Is_Set;\n-            D (D_Debug, \"Do_APC - Locally\");\n-            Partition_RPC_Receiver.all (Params, Result'Access);\n-\n-         end;\n-\n-      end if;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Do_APC\");\n-         raise;\n-   end Do_APC;\n-\n-   ----------------------------\n-   -- Establish_RPC_Receiver --\n-   ----------------------------\n-\n-   procedure Establish_RPC_Receiver\n-     (Partition : Partition_ID;\n-      Receiver  : RPC_Receiver)\n-   is\n-   begin\n-      --  Set Partition_RPC_Receiver and allow RPC mechanism\n-\n-      Partition_RPC_Receiver := Receiver;\n-      Partition_Receiver.Set;\n-      D (D_Elaborate, \"Partition_Receiver is set\");\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Establish_RPC_Receiver\");\n-         raise;\n-   end Establish_RPC_Receiver;\n-\n-   ----------------\n-   -- Dispatcher --\n-   ----------------\n-\n-   task body Dispatcher is\n-      Last_Request : Request_Id_Type := Request_Id_Type'First;\n-      Current_Rqst : Request_Id_Type := Request_Id_Type'First;\n-      Current_Size : Ada.Streams.Stream_Element_Count;\n-\n-   begin\n-      loop\n-         --  Three services:\n-\n-         --    New_Request to get an entry in Dispatcher table\n-\n-         --    Wait_On for Do_RPC calls\n-\n-         --    Wake_Up called by environment task when a Do_RPC receives\n-         --    the result of its remote call\n-\n-         select\n-            accept New_Request (Request : out Request_Id_Type) do\n-               Request := Last_Request;\n-\n-               --  << TODO >>\n-               --  ??? Availability check\n-\n-               if Last_Request = Request_Id_Type'Last then\n-                  Last_Request := Request_Id_Type'First;\n-               else\n-                  Last_Request := Last_Request + 1;\n-               end if;\n-\n-            end New_Request;\n-\n-         or\n-            accept Wake_Up\n-              (Request : Request_Id_Type;\n-               Length  : Ada.Streams.Stream_Element_Count)\n-            do\n-               --  The environment reads the header and has been notified\n-               --  of the reply id and the size of the result message\n-\n-               Current_Rqst := Request;\n-               Current_Size := Length;\n-\n-            end Wake_Up;\n-\n-            --  << TODO >>\n-            --  ??? Must be select with delay for aborted tasks\n-\n-            select\n-\n-               accept Wait_On (Current_Rqst)\n-                 (Length  : out Ada.Streams.Stream_Element_Count)\n-               do\n-                  Length := Current_Size;\n-               end Wait_On;\n-\n-            or\n-               --  To free the Dispatcher when a task is aborted\n-\n-               delay 1.0;\n-\n-            end select;\n-\n-         or\n-            terminate;\n-         end select;\n-\n-      end loop;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Dispatcher body\");\n-         raise;\n-   end Dispatcher;\n-\n-   -------------------------\n-   -- Anonymous_Task_Type --\n-   -------------------------\n-\n-   task body Anonymous_Task_Type is\n-      Whoami       : Anonymous_Task_Node_Access := Self;\n-      C_Message_Id : Message_Id_Type;                  --  Current Message Id\n-      C_Partition  : Partition_ID;                     --  Current Partition\n-      Params_S     : Ada.Streams.Stream_Element_Count; --  Params message size\n-      Result_S     : Ada.Streams.Stream_Element_Count; --  Result message size\n-      C_Protocol   : Protocol_Access;                  --  Current Protocol\n-\n-   begin\n-      loop\n-         --  Get a new RPC to execute\n-\n-         select\n-            accept Start\n-              (Message_Id   : Message_Id_Type;\n-               Partition    : Partition_ID;\n-               Params_Size  : Ada.Streams.Stream_Element_Count;\n-               Result_Size  : Ada.Streams.Stream_Element_Count;\n-               Protocol     : Protocol_Access)\n-            do\n-               C_Message_Id := Message_Id;\n-               C_Partition  := Partition;\n-               Params_S     := Params_Size;\n-               Result_S     := Result_Size;\n-               C_Protocol   := Protocol;\n-            end Start;\n-         or\n-            terminate;\n-         end select;\n-\n-         declare\n-            Params : aliased Params_Stream_Type (Params_S);\n-            Result : aliased Params_Stream_Type (Result_S);\n-            Header : aliased Params_Stream_Type (Header_Size);\n-\n-         begin\n-            --  We reconstruct all the client context : Params and Result\n-            --  with the SAME size, then we receive Params from calling stub\n-\n-            D (D_Communication,\n-               \"Anonymous Task - Receive Params from partition\" &\n-               Partition_ID'Image (C_Partition));\n-            Garlic.Receive\n-               (C_Protocol.all,\n-                C_Partition,\n-                Params'Access);\n-\n-            --  Let Garlic know we don't receive anymore\n-\n-            Garlic.Complete_Receive\n-               (C_Protocol.all,\n-                C_Partition);\n-\n-            --  Check that Partition_RPC_Receiver has been set\n-\n-            Partition_Receiver.Is_Set;\n-\n-            --  Do it locally\n-\n-            D (D_Debug,\n-               \"Anonymous Task - Perform Partition_RPC_Receiver for request\" &\n-               Message_Id_Type'Image (C_Message_Id));\n-            Partition_RPC_Receiver (Params'Access, Result'Access);\n-\n-            --  If this was a RPC we send the result back\n-            --  Otherwise, do nothing else than deallocation\n-\n-            if C_Message_Id /= 0 then\n-\n-               --  Build Header = -C_Message_Id + Result Size\n-               --  Provide the request id to the env task of the calling\n-               --  stub partition We get the real result stream size : the\n-               --  calling stub (in Do_RPC) updates its size to this one\n-\n-               D (D_Debug, \"Anonymous Task - Build Header\");\n-               Streams.Allocate (Header);\n-               Streams.Integer_Write_Attribute\n-                 (Header'Access, Integer (-C_Message_Id));\n-               Streams.SEC_Write_Attribute\n-                 (Header'Access,\n-                  Streams.Get_Stream_Size (Result'Access));\n-\n-               --  Get a protocol method to communicate with the remote\n-               --  partition and give the message size\n-\n-               D (D_Communication,\n-                  \"Anonymous Task - Lookup for protocol talk to partition\" &\n-                  Partition_ID'Image (C_Partition));\n-               Garlic.Initiate_Send\n-                 (C_Partition,\n-                  Streams.Get_Stream_Size (Header'Access) +\n-                  Streams.Get_Stream_Size (Result'Access),\n-                  C_Protocol,\n-                  Garlic.Remote_Call);\n-\n-               --  Send the header by using the protocol method\n-\n-               D (D_Communication,\n-                  \"Anonymous Task - Send Header to partition\" &\n-                  Partition_ID'Image (C_Partition));\n-               Garlic.Send\n-                 (C_Protocol.all,\n-                  C_Partition,\n-                  Header'Access);\n-\n-               --  Send Result toDo_RPC\n-\n-               D (D_Communication,\n-                  \"Anonymous Task - Send Result to partition\" &\n-                  Partition_ID'Image (C_Partition));\n-               Garlic.Send\n-                 (C_Protocol.all,\n-                  C_Partition,\n-                  Result'Access);\n-\n-               --  Let Garlic know we don't send anymore\n-\n-               Garlic.Complete_Send\n-                 (C_Protocol.all,\n-                  C_Partition);\n-               Streams.Deallocate (Header);\n-            end if;\n-\n-            Streams.Deallocate (Params);\n-            Streams.Deallocate (Result);\n-         end;\n-\n-         --  Enqueue into the anonymous task free list : become inactive\n-\n-         Garbage_Collector.Deallocate (Whoami);\n-\n-      end loop;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Anonymous_Task_Type body\");\n-         raise;\n-   end Anonymous_Task_Type;\n-\n-   -----------------\n-   -- Environment --\n-   -----------------\n-\n-   task body Environnement is\n-      Partition    : Partition_ID;\n-      Message_Size : Ada.Streams.Stream_Element_Count;\n-      Result_Size  : Ada.Streams.Stream_Element_Count;\n-      Message_Id   : Message_Id_Type;\n-      Header       : aliased Params_Stream_Type (Header_Size);\n-      Protocol     : Protocol_Access;\n-      Anonymous    : Anonymous_Task_Node_Access;\n-\n-   begin\n-      --  Wait the Partition_RPC_Receiver to be set\n-\n-      accept Start;\n-      D (D_Elaborate, \"Environment task elaborated\");\n-\n-      loop\n-         --  We receive first a fixed size message : the header\n-         --  Header = Message Id + Message Size\n-\n-         Streams.Allocate (Header);\n-\n-         --  Garlic provides the size of the received message and the\n-         --  protocol to use to communicate with the calling partition\n-\n-         Garlic.Initiate_Receive\n-           (Partition,\n-            Message_Size,\n-            Protocol,\n-            Garlic.Remote_Call);\n-         D (D_Communication,\n-            \"Environment task - Receive protocol to talk to active partition\" &\n-            Partition_ID'Image (Partition));\n-\n-         --  Extract the header to route the message either to\n-         --  an anonymous task (Message Id > 0 <=> Request Id)\n-         --  or to a waiting task (Message Id < 0 <=> Reply Id)\n-\n-         D (D_Communication,\n-            \"Environment task - Receive Header from partition\" &\n-            Partition_ID'Image (Partition));\n-         Garlic.Receive\n-           (Protocol.all,\n-            Partition,\n-            Header'Access);\n-\n-         --  Evaluate the remaining size of the message\n-\n-         Message_Size := Message_Size -\n-            Streams.Get_Stream_Size (Header'Access);\n-\n-         --  Extract from header : message id and message size\n-\n-         Streams.Integer_Read_Attribute (Header'Access, Message_Id);\n-         Streams.SEC_Read_Attribute (Header'Access, Result_Size);\n-\n-         if Streams.Get_Stream_Size (Header'Access) /= 0 then\n-\n-            --  If there are stream elements left in the header ???\n-\n-            D (D_Exception, \"Header is not empty\");\n-            raise Program_Error;\n-\n-         end if;\n-\n-         if Message_Id < 0 then\n-\n-            --  The message was sent by a receiving stub : wake up the\n-            --  calling task - We have a reply there\n-\n-            D (D_Debug, \"Environment Task - Receive Reply from partition\" &\n-               Partition_ID'Image (Partition));\n-            Dispatcher.Wake_Up (-Message_Id, Result_Size);\n-\n-         else\n-            --  The message was send by a calling stub : get an anonymous\n-            --  task to perform the job\n-\n-            D (D_Debug, \"Environment Task - Receive Request from partition\" &\n-               Partition_ID'Image (Partition));\n-            Garbage_Collector.Allocate (Anonymous);\n-\n-            --  We subtracted the size of the header from the size of the\n-            --  global message in order to provide immediately Params size\n-\n-            Anonymous.Element.Start\n-              (Message_Id,\n-               Partition,\n-               Message_Size,\n-               Result_Size,\n-               Protocol);\n-\n-         end if;\n-\n-         --  Deallocate header : unnecessary - WARNING\n-\n-         Streams.Deallocate (Header);\n-\n-      end loop;\n-\n-   exception\n-      when others =>\n-         D (D_Exception, \"exception in Environment\");\n-         raise;\n-   end Environnement;\n-\n-begin\n-   --  Set debugging information\n-\n-   Debugging.Set_Environment_Variable (\"RPC\");\n-   Debugging.Set_Debugging_Name (\"D\", D_Debug);\n-   Debugging.Set_Debugging_Name (\"E\", D_Exception);\n-   Debugging.Set_Debugging_Name (\"C\", D_Communication);\n-   Debugging.Set_Debugging_Name (\"Z\", D_Elaborate);\n-   D (D_Elaborate, \"To be elaborated\");\n-\n-   --  When this body is elaborated we should ensure that RCI name server\n-   --  has been already elaborated : this means that Establish_RPC_Receiver\n-   --  has already been called and that Partition_RPC_Receiver is set\n-\n-   Environnement.Start;\n-   D (D_Elaborate, \"ELABORATED\");\n-\n-end System.RPC;"}]}