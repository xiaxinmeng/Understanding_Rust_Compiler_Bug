{"sha": "cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "node_id": "C_kwDOANBUbNoAKGNmNjhmNWE2ZDIwZGIyYWVlMmYzZTY3NGFkM2YxMGUxYzQ1OGVkZjk", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-03-31T15:14:42Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-03-31T15:17:21Z"}, "message": "ipa-cp: Do not create clones for values outside known value range (PR 102513)\n\nPR 102513 shows we emit bogus array access warnings when IPA-CP\ncreates clones specialized for values which it deduces from arithmetic\njump functions describing self-recursive calls.  Those can however be\navoided if we consult the IPA-VR information that the same pass also\nhas.\n\nThe patch below does that at the stage when normally values are only\nexamined for profitability.  It would be better not to create lattices\ndescribing such bogus values in the first place, however that presents\nan ordering problem, the pass currently propagates all information,\nand so both constants and VR, in no particular order when processing\nSCCs, and so this approach seemed much simpler.\n\nI plan to rearrange the pass so that it clones in multiple passes over\nthe call graph (or rather the lattice dependence graph) and it feels\nnatural to only do propagation for these kinds of recursion in the\nsecond or later passes, which would fix the issue more elegantly.\n\ngcc/ChangeLog:\n\n2022-02-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102513\n\t* ipa-cp.cc (decide_whether_version_node): Skip scalar values\n\twhich do not fit the known value_range.\n\ngcc/testsuite/ChangeLog:\n\n2022-02-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102513\n\t* gcc.dg/ipa/pr102513.c: New test.", "tree": {"sha": "97fbed59a81aab7eb1fc7faacc1c34125434168d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97fbed59a81aab7eb1fc7faacc1c34125434168d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmJFxgEACgkQv2PBvD+k\nNUCg8A//QunOgRgIcq4h2PP7DAHhNrLegMtrohUMmgj+l8b8hQzzK9IuOUTl6DKC\nyySMc1lkVZ+rMB4t3vfa9SJ/2DXvBBsHSwNQWJPcU7Yt45PFAwVAq+O0O3P9Gnpn\nZnlK9IDB7Tw++eYzhfmkIYqn52sC7ef0sYGaZ47TrIyiNFmuolrMSYc1dINTQIls\nd2xyKsLa6uS8VBO/MEqLgE+zDrmqD6U7+9L/spmgzxXoCtevfQFW/jvQp8brmAL9\nwkQBP1IAR3ANi9hAqR70+WcjSKKN1j8htdY+eQzKLSwwJPFb44lm0vq+ZQxGr2Wz\niPfi/dZke9dIqZQk//5goJgiABdP+1UmjXCBVZMRqmFmKpWtXdtVAgC78lxcKRAs\nzkPOod1Syele7Aesh4QnXrh4l8mrH8lCiAB3gnHV6k56ozHWthfvbMdDjSQ+SF0A\nZjI3AMIuEk3pIT+dT8jyWt5lt4IvgY+ePX5WE5jSs+aRvPo6fpAAM5jrg+pe35rA\nOjNr239Z0DWH7FK2HOGUezvgzHmS8sqRICv7UeoBxJ329f5vlL8bBc+eHOYcViQ5\nrOmhZTej8I9vqVRhqWWNYhnrH/Fqc1ioA8MBPRyIQRL6zPka8lEKfXHifO4reOe/\nL/380AcTOFnGMdhnG0CNN9EN+4QA0Okw5UGO93MChgXwOHTH3/I=\n=hgM2\n-----END PGP SIGNATURE-----", "payload": "tree 97fbed59a81aab7eb1fc7faacc1c34125434168d\nparent f6d65e803623c7ba6c8eb92ce5975fc1b90cd91e\nauthor Martin Jambor <mjambor@suse.cz> 1648739682 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1648739841 +0200\n\nipa-cp: Do not create clones for values outside known value range (PR 102513)\n\nPR 102513 shows we emit bogus array access warnings when IPA-CP\ncreates clones specialized for values which it deduces from arithmetic\njump functions describing self-recursive calls.  Those can however be\navoided if we consult the IPA-VR information that the same pass also\nhas.\n\nThe patch below does that at the stage when normally values are only\nexamined for profitability.  It would be better not to create lattices\ndescribing such bogus values in the first place, however that presents\nan ordering problem, the pass currently propagates all information,\nand so both constants and VR, in no particular order when processing\nSCCs, and so this approach seemed much simpler.\n\nI plan to rearrange the pass so that it clones in multiple passes over\nthe call graph (or rather the lattice dependence graph) and it feels\nnatural to only do propagation for these kinds of recursion in the\nsecond or later passes, which would fix the issue more elegantly.\n\ngcc/ChangeLog:\n\n2022-02-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102513\n\t* ipa-cp.cc (decide_whether_version_node): Skip scalar values\n\twhich do not fit the known value_range.\n\ngcc/testsuite/ChangeLog:\n\n2022-02-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/102513\n\t* gcc.dg/ipa/pr102513.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d65e803623c7ba6c8eb92ce5975fc1b90cd91e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d65e803623c7ba6c8eb92ce5975fc1b90cd91e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d65e803623c7ba6c8eb92ce5975fc1b90cd91e"}], "stats": {"total": 61, "additions": 59, "deletions": 2}, "files": [{"sha": "8628140d6d91c8e22e0974107f1314c8ee8dbfea", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "patch": "@@ -6154,8 +6154,32 @@ decide_whether_version_node (struct cgraph_node *node)\n \t{\n \t  ipcp_value<tree> *val;\n \t  for (val = lat->values; val; val = val->next)\n-\t    ret |= decide_about_value (node, i, -1, val, &avals,\n-\t\t\t\t       &self_gen_clones);\n+\t    {\n+\t      /* If some values generated for self-recursive calls with\n+\t\t arithmetic jump functions fall outside of the known\n+\t\t value_range for the parameter, we can skip them.  VR interface\n+\t\t supports this only for integers now.  */\n+\t      if (TREE_CODE (val->value) == INTEGER_CST\n+\t\t  && !plats->m_value_range.bottom_p ()\n+\t\t  && !plats->m_value_range.m_vr.contains_p (val->value))\n+\t\t{\n+\t\t  /* This can happen also if a constant present in the source\n+\t\t     code falls outside of the range of parameter's type, so we\n+\t\t     cannot assert.  */\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \" - skipping%s value \",\n+\t\t\t       val->self_recursion_generated_p ()\n+\t\t\t       ? \" self_recursion_generated\" : \"\");\n+\t\t      print_ipcp_constant_value (dump_file, val->value);\n+\t\t      fprintf (dump_file, \" because it is outside known \"\n+\t\t\t       \"value range.\\n\");\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\t      ret |= decide_about_value (node, i, -1, val, &avals,\n+\t\t\t\t\t &self_gen_clones);\n+\t    }\n \t}\n \n       if (!plats->aggs_bottom)"}, {"sha": "9ee5431b730d533758c7ae0f3265189247406fd6", "filename": "gcc/testsuite/gcc.dg/ipa/pr102513.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr102513.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr102513.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr102513.c?ref=cf68f5a6d20db2aee2f3e674ad3f10e1c458edf9", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Warray-bounds\" } */\n+\n+extern int block2[7][256];\n+\n+static int encode_block(int block2[7][256], unsigned level)\n+{\n+    int best_score = 0;\n+\n+    for (unsigned x = 0; x < level; x++) {\n+        int v = block2[1][x];\n+        block2[level][x] = 0;\n+        best_score += v * v;\n+    }\n+\n+    if (level > 0 && best_score > 64) {\n+        int score = 0;\n+\n+        score += encode_block(block2, level - 1);\n+        score += encode_block(block2, level - 1);\n+\n+        if (score < best_score) {\n+            best_score = score;\n+        }\n+    }\n+\n+    return best_score;\n+}\n+\n+int foo(void)\n+{\n+    return encode_block(block2, 5);\n+}"}]}