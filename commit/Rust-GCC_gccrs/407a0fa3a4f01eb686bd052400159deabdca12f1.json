{"sha": "407a0fa3a4f01eb686bd052400159deabdca12f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA3YTBmYTNhNGYwMWViNjg2YmQwNTI0MDAxNTlkZWFiZGNhMTJmMQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-07-23T12:31:51Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-07-23T12:31:51Z"}, "message": "Implement regex_iterator and regex_token_iterator.\n\n2013-07-23  Tim Shen  <timshen91@gmail.com>\n\n\tImplement regex_iterator and regex_token_iterator.\n\t* include/bits/regex.h: regex_iterator and regex_token_iterator.\n\t* testsuite/28_regex/iterators/regex_iterator/char/string_01.cc:\n\tNew.\n\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_01.cc:\n\tNew.\n\t* testsuite/28_regex/iterators/regex_token_iterator/char/string_01.cc:\n\tNew.\n\t* testsuite/28_regex/iterators/regex_token_iterator/wchar_t/string_01.cc:\n\tNew.\n\nFrom-SVN: r201169", "tree": {"sha": "e835627101effffddb47426eb2e8821eba0f6953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e835627101effffddb47426eb2e8821eba0f6953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/407a0fa3a4f01eb686bd052400159deabdca12f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/407a0fa3a4f01eb686bd052400159deabdca12f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/407a0fa3a4f01eb686bd052400159deabdca12f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/407a0fa3a4f01eb686bd052400159deabdca12f1/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00edcfbe01b2bd34ff997984a6e73bcc184c727c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00edcfbe01b2bd34ff997984a6e73bcc184c727c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00edcfbe01b2bd34ff997984a6e73bcc184c727c"}], "stats": {"total": 527, "additions": 472, "deletions": 55}, "files": [{"sha": "ab21abefed50ef4ab9d772695cceaa832f52cffa", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -1,3 +1,16 @@\n+2013-07-23  Tim Shen  <timshen91@gmail.com>\n+\n+\tImplement regex_iterator and regex_token_iterator.\n+\t* include/bits/regex.h: regex_iterator and regex_token_iterator.\n+\t* testsuite/28_regex/iterators/regex_iterator/char/string_01.cc:\n+\tNew.\n+\t* testsuite/28_regex/iterators/regex_iterator/wchar_t/string_01.cc:\n+\tNew.\n+\t* testsuite/28_regex/iterators/regex_token_iterator/char/string_01.cc:\n+\tNew.\n+\t* testsuite/28_regex/iterators/regex_token_iterator/wchar_t/string_01.cc:\n+\tNew.\n+\n 2013-07-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/std/random: Add back <cstdio> include."}, {"sha": "9848f717fc6fc704122fd1ca701ecff7e70aff18", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 251, "deletions": 55, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -2540,88 +2540,137 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       /**\n        * @brief Provides a singular iterator, useful for indicating\n        * one-past-the-end of a range.\n-       * @todo Implement this function.\n        * @doctodo\n        */\n-      regex_iterator();\n+      regex_iterator()\n+      : _M_match()\n+      { }\n       \n       /**\n        * Constructs a %regex_iterator...\n        * @param __a  [IN] The start of a text range to search.\n        * @param __b  [IN] One-past-the-end of the text range to search.\n        * @param __re [IN] The regular expression to match.\n        * @param __m  [IN] Policy flags for match rules.\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n \t\t     regex_constants::match_flag_type __m\n-\t\t     = regex_constants::match_default);\n+\t\t     = regex_constants::match_default)\n+      : _M_begin(__a), _M_end(__b), _M_pregex(&__re), _M_flags(__m), _M_match()\n+      { regex_search(_M_begin, _M_end, _M_match, *_M_pregex, _M_flags); }\n \n       /**\n        * Copy constructs a %regex_iterator.\n-       * @todo Implement this function.\n        * @doctodo\n        */\n-      regex_iterator(const regex_iterator& __rhs);\n+      regex_iterator(const regex_iterator& __rhs) = default;\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_iterator&\n-      operator=(const regex_iterator& __rhs);\n+      operator=(const regex_iterator& __rhs) = default;\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       bool\n-      operator==(const regex_iterator& __rhs);\n+      operator==(const regex_iterator& __rhs) const;\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       bool\n-      operator!=(const regex_iterator& __rhs);\n+      operator!=(const regex_iterator& __rhs) const\n+      { return !(*this == __rhs); }\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       const value_type&\n-      operator*();\n+      operator*() const\n+      { return _M_match; }\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       const value_type*\n-      operator->();\n+      operator->() const\n+      { return &_M_match; }\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_iterator&\n       operator++();\n       \n       /**\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_iterator\n-      operator++(int);\n+      operator++(int)\n+      {\n+        auto __tmp = *this;\n+        ++(*this);\n+        return __tmp;\n+      }\n       \n     private:\n       // these members are shown for exposition only:\n-      _Bi_iter                         begin;\n-      _Bi_iter                         end;\n-      const regex_type*                pregex;\n-      regex_constants::match_flag_type flags;\n-      match_results<_Bi_iter>          match;\n+      _Bi_iter                         _M_begin;\n+      _Bi_iter                         _M_end;\n+      const regex_type*                _M_pregex;\n+      regex_constants::match_flag_type _M_flags;\n+      match_results<_Bi_iter>          _M_match;\n     };\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    bool\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator==(const regex_iterator& __rhs) const\n+    {\n+      return (_M_match.empty() && __rhs._M_match.empty())\n+        || (_M_begin == __rhs._M_begin\n+            && _M_end == __rhs._M_end\n+            && _M_pregex == __rhs._M_pregex\n+            && _M_flags == __rhs._M_flags\n+            && _M_match[0] == __rhs._M_match[0]);\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator++()\n+    {\n+      if (_M_match[0].matched)\n+        {\n+          auto __start = _M_match[0].second;\n+          if (_M_match[0].first == _M_match[0].second)\n+            if (__start == _M_end)\n+              {\n+                _M_match = value_type();\n+                return *this;\n+              }\n+            else\n+              {\n+                if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n+                                 | regex_constants::match_not_null\n+                                 | regex_constants::match_continuous))\n+                  return *this;\n+                else\n+                  ++__start;\n+              }\n+          _M_flags |= regex_constants::match_prev_avail;\n+          if (!regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n+            _M_match = value_type();\n+        }\n+      return *this;\n+    }\n   \n   typedef regex_iterator<const char*>             cregex_iterator;\n   typedef regex_iterator<string::const_iterator>  sregex_iterator;\n@@ -2639,8 +2688,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * value of an iterator of this class is a std::sub_match object.\n    */\n   template<typename _Bi_iter,\n-\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n-\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+           typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+           typename _Rx_traits = regex_traits<_Ch_type> >\n     class regex_token_iterator\n     {\n     public:\n@@ -2654,13 +2703,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     public:\n       /**\n        * @brief Default constructs a %regex_token_iterator.\n-       * @todo Implement this function.\n        * \n        * A default-constructed %regex_token_iterator is a singular iterator\n        * that will compare equal to the one-past-the-end value for any\n        * iterator of the same type.\n        */\n-      regex_token_iterator();\n+      regex_token_iterator()\n+      : _M_position(), _M_result(nullptr), _M_suffix(), _M_n(0), _M_subs()\n+      { }\n       \n       /**\n        * Constructs a %regex_token_iterator...\n@@ -2679,31 +2729,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        *                          subexpression from a match within the text.\n        * @param __m          [IN] Policy flags for match rules.\n        *\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n \t\t\t   int __submatch = 0,\n \t\t\t   regex_constants::match_flag_type __m\n-\t\t\t   = regex_constants::match_default);\n+\t\t\t   = regex_constants::match_default)\n+      : _M_position(__a, __b, __re, __m), _M_subs(1, __submatch), _M_n(0)\n+      { _M_init(__a, __b); }\n \n       /**\n        * Constructs a %regex_token_iterator...\n        * @param __a          [IN] The start of the text to search.\n        * @param __b          [IN] One-past-the-end of the text to search.\n        * @param __re         [IN] The regular expression to search for.\n        * @param __submatches [IN] A list of subexpressions to return for each\n-       *                        regular expression match within the text.\n+       *                          regular expression match within the text.\n        * @param __m          [IN] Policy flags for match rules.\n        *\n-       * @todo Implement this function.\n        * @doctodo\n        */\n       regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n \t\t\t   const regex_type& __re,\n \t\t\t   const std::vector<int>& __submatches,\n \t\t\t   regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n+\t\t\t     = regex_constants::match_default)\n+      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)\n+      { _M_init(__a, __b); }\n \n       /**\n        * Constructs a %regex_token_iterator...\n@@ -2713,84 +2765,228 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * @param __submatches [IN] A list of subexpressions to return for each\n        *                          regular expression match within the text.\n        * @param __m          [IN] Policy flags for match rules.\n-       \n-       * @todo Implement this function.\n+       *\n+       * @doctodo\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t   const regex_type& __re,\n+                           initializer_list<int> __submatches,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default)\n+      : _M_position(__a, __b, __re, __m), _M_subs(__submatches), _M_n(0)\n+      { _M_init(__a, __b); }\n+\n+      /**\n+       * Constructs a %regex_token_iterator...\n+       * @param __a          [IN] The start of the text to search.\n+       * @param __b          [IN] One-past-the-end of the text to search.\n+       * @param __re         [IN] The regular expression to search for.\n+       * @param __submatches [IN] A list of subexpressions to return for each\n+       *                          regular expression match within the text.\n+       * @param __m          [IN] Policy flags for match rules.\n+       *\n        * @doctodo\n        */\n       template<std::size_t _Nm>\n         regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n \t\t\t     const regex_type& __re,\n \t\t\t     const int (&__submatches)[_Nm],\n \t\t\t     regex_constants::match_flag_type __m\n-\t\t\t     = regex_constants::match_default);\n+\t\t\t     = regex_constants::match_default)\n+      : _M_position(__a, __b, __re, __m),\n+      _M_subs(__submatches, *(&__submatches+1)), _M_n(0)\n+      { _M_init(__a, __b); }\n \n       /**\n        * @brief Copy constructs a %regex_token_iterator.\n        * @param __rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n        */\n-      regex_token_iterator(const regex_token_iterator& __rhs);\n+      regex_token_iterator(const regex_token_iterator& __rhs)\n+      : _M_position(__rhs.position), _M_subs(__rhs.subs), _M_n(__rhs.N),\n+      _M_result(__rhs.result), _M_suffix(__rhs.suffix),\n+      _M_has_m1(__rhs._M_has_m1)\n+      {\n+        if (__rhs._M_result == &__rhs._M_suffix)\n+          _M_result = &_M_suffix;\n+      }\n \n       /**\n        * @brief Assigns a %regex_token_iterator to another.\n        * @param __rhs [IN] A %regex_token_iterator to copy.\n-       * @todo Implement this function.\n        */\n       regex_token_iterator&\n       operator=(const regex_token_iterator& __rhs);\n \n       /**\n        * @brief Compares a %regex_token_iterator to another for equality.\n-       * @todo Implement this function.\n        */\n       bool\n       operator==(const regex_token_iterator& __rhs) const;\n \n       /**\n        * @brief Compares a %regex_token_iterator to another for inequality.\n-       * @todo Implement this function.\n        */\n       bool\n-      operator!=(const regex_token_iterator& __rhs) const;\n+      operator!=(const regex_token_iterator& __rhs) const\n+      { return !(*this == __rhs); }\n \n       /**\n        * @brief Dereferences a %regex_token_iterator.\n-       * @todo Implement this function.\n        */\n       const value_type&\n-      operator*() const;\n+      operator*() const\n+      { return *_M_result; }\n \n       /**\n        * @brief Selects a %regex_token_iterator member.\n-       * @todo Implement this function.\n        */\n       const value_type*\n-      operator->() const;\n+      operator->() const\n+      { return _M_result; }\n \n       /**\n        * @brief Increments a %regex_token_iterator.\n-       * @todo Implement this function.\n        */\n       regex_token_iterator&\n       operator++();\n \n       /**\n        * @brief Postincrements a %regex_token_iterator.\n-       * @todo Implement this function.\n        */\n       regex_token_iterator\n-      operator++(int);\n+      operator++(int)\n+      {\n+        auto __tmp = *this;\n+        ++(*this);\n+        return __tmp;\n+      }\n \n     private: // data members for exposition only:\n-      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n+      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _Position;\n+\n+      void\n+      _M_init(_Bi_iter __a, _Bi_iter __b);\n \n-      position_iterator __position;\n-      const value_type* __result;\n-      value_type        __suffix;\n-      std::size_t       __n;\n-      std::vector<int>  __subs;\n+      const value_type&\n+      _M_current_match() const\n+      {\n+        if (_M_subs[_M_n] == -1)\n+          return (*_M_position).prefix();\n+        else\n+          return (*_M_position)[_M_subs[_M_n]];\n+      }\n+\n+      bool\n+      _M_end_of_seq() const\n+      { return _M_result != nullptr; }\n+\n+      _Position _M_position;\n+      const value_type* _M_result;\n+      value_type        _M_suffix;\n+      std::size_t       _M_n;\n+      std::vector<int>  _M_subs;\n+\n+      bool              _M_has_m1; // subs contains -1\n     };\n \n+  template<typename _Bi_iter,\n+           typename _Ch_type,\n+           typename _Rx_traits>\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator=(const regex_token_iterator& __rhs)\n+    {\n+      _M_position = __rhs._M_position;\n+      _M_subs = __rhs._M_subs;\n+      _M_n = __rhs._M_n;\n+      _M_result = __rhs._M_result;\n+      _M_suffix = __rhs._M_suffix;\n+      _M_has_m1 = __rhs._M_has_m1;\n+      if (__rhs._M_result == &__rhs._M_suffix)\n+        _M_result = &_M_suffix;\n+    }\n+\n+  template<typename _Bi_iter,\n+           typename _Ch_type,\n+           typename _Rx_traits>\n+    bool\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator==(const regex_token_iterator& __rhs) const\n+    {\n+      if (_M_end_of_seq() && __rhs._M_end_of_seq())\n+        return true;\n+      if (_M_suffix.matched && __rhs._M_suffix.matched\n+          && _M_suffix == __rhs._M_suffix)\n+        return true;\n+      if (_M_end_of_seq() || _M_suffix.matched\n+          || __rhs._M_end_of_seq() || __rhs._M_suffix.matched)\n+        return false;\n+      return _M_position == __rhs._M_position\n+        && _M_n == __rhs._M_n\n+        && _M_subs == __rhs._M_subs;\n+    }\n+\n+  template<typename _Bi_iter,\n+           typename _Ch_type,\n+           typename _Rx_traits>\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator++()\n+    {\n+      _Position __prev = _M_position;\n+      if (_M_suffix.matched)\n+        *this = regex_token_iterator();\n+      else if (_M_n + 1 < _M_subs.size())\n+        {\n+          _M_n++;\n+          _M_result = &_M_current_match();\n+        }\n+      else\n+        {\n+          _M_n = 0;\n+          ++_M_position;\n+          if (_M_position != _Position())\n+            _M_result = &_M_current_match();\n+          else if (_M_has_m1 && __prev->suffix().length() != 0)\n+            {\n+              _M_suffix.matched = true;\n+              _M_suffix.first = __prev->suffix().first;\n+              _M_suffix.second = __prev->suffix().second;\n+              _M_result = &_M_suffix;\n+            }\n+          else\n+            *this = regex_token_iterator();\n+        }\n+      return *this;\n+    }\n+\n+  template<typename _Bi_iter,\n+           typename _Ch_type,\n+           typename _Rx_traits>\n+    void\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    _M_init(_Bi_iter __a, _Bi_iter __b)\n+    {\n+      _M_has_m1 = false;\n+      for (auto __it : _M_subs)\n+        if (__it == -1)\n+          {\n+            _M_has_m1 = true;\n+            break;\n+          }\n+      if (_M_position != _Position())\n+        _M_result = &_M_current_match();\n+      else if (_M_has_m1)\n+        {\n+          _M_suffix.matched = true;\n+          _M_suffix.first = __a;\n+          _M_suffix.second = __b;\n+          _M_result = &_M_suffix;\n+        }\n+      else\n+        _M_result = nullptr;\n+    }\n+\n   /** @brief Token iterator for C-style NULL-terminated strings. */\n   typedef regex_token_iterator<const char*>             cregex_token_iterator;\n "}, {"sha": "066b6bade13a4a85e46f8b3c87d1497604211d79", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_01.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fchar%2Fstring_01.cc?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-07-20  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 regex_iterator\n+// Tests operator++() of regex_iterator class\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::basic_regex<char> re(\"asdf\");\n+  const char s[] = \"ffasdf88asdf99asdf00asdf77\";\n+  int cnt = 0;\n+  for (std::regex_iterator<const char*> it(s, *(&s+1)-1, re), e;\n+       it != e; ++it)\n+    {\n+      VERIFY( it->size() == 1 );\n+      VERIFY( std::string((*it)[0].first, (*it)[0].second) == \"asdf\" );\n+      cnt++;\n+    }\n+  VERIFY( cnt == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1b6e9a5464f6d4f5f6128196df39356f22d4f79b", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/wchar_t/string_01.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_iterator%2Fwchar_t%2Fstring_01.cc?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-07-20  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.1 regex_iterator\n+// Tests operator++() of regex_iterator class\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::basic_regex<wchar_t> re(L\"asdf\");\n+  const wchar_t s[] = L\"ffasdf88asdf99asdf00asdf77\";\n+  int cnt = 0;\n+  for (std::regex_iterator<const wchar_t*> it(s, *(&s+1)-1, re), e;\n+       it != e; ++it)\n+    {\n+      VERIFY( it->size() == 1 );\n+      VERIFY( std::wstring((*it)[0].first, (*it)[0].second) == L\"asdf\" );\n+      cnt++;\n+    }\n+  VERIFY( cnt == 4 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7f2f1afd5fe6b5f5d3f0d0d7165f2062f4f2e230", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/char/string_01.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fchar%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fchar%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fchar%2Fstring_01.cc?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-07-20  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.2 regex_token_iterator\n+// Tests \"split\" of regex_token_iterator class\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::basic_regex<char> re(\" \");\n+  const char s[] = \"Quick brown fox.\";\n+  int cnt = 0;\n+  std::cregex_token_iterator iter(s, *(&s+1)-1, re, -1);\n+  VERIFY( std::string(iter->first, iter->second) == \"Quick\" );\n+  ++iter;\n+  VERIFY( std::string(iter->first, iter->second) == \"brown\" );\n+  ++iter;\n+  VERIFY( std::string(iter->first, iter->second) == \"fox.\" );\n+  ++iter;\n+  VERIFY( iter == std::cregex_token_iterator() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "239ef943f754f15274d4996d4697a1afc4f7af39", "filename": "libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/wchar_t/string_01.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fwchar_t%2Fstring_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/407a0fa3a4f01eb686bd052400159deabdca12f1/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fwchar_t%2Fstring_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fiterators%2Fregex_token_iterator%2Fwchar_t%2Fstring_01.cc?ref=407a0fa3a4f01eb686bd052400159deabdca12f1", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-07-20  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.12.2 regex_token_iterator\n+// Tests \"split\" of regex_token_iterator class\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::basic_regex<wchar_t> re(L\" \");\n+  const wchar_t s[] = L\"Quick brown fox.\";\n+  int cnt = 0;\n+  std::wcregex_token_iterator iter(s, *(&s+1)-1, re, -1);\n+  VERIFY( std::wstring(iter->first, iter->second) == L\"Quick\" );\n+  ++iter;\n+  VERIFY( std::wstring(iter->first, iter->second) == L\"brown\" );\n+  ++iter;\n+  VERIFY( std::wstring(iter->first, iter->second) == L\"fox.\" );\n+  ++iter;\n+  VERIFY( iter == std::wcregex_token_iterator() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}