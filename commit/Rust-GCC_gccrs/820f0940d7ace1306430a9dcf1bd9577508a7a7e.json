{"sha": "820f0940d7ace1306430a9dcf1bd9577508a7a7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwZjA5NDBkN2FjZTEzMDY0MzBhOWRjZjFiZDk1Nzc1MDhhN2E3ZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-24T16:49:11Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-24T16:49:11Z"}, "message": "Reset PHI base0 flag if it's clear in any argument [PR101977, ...]\n\nResolves:\nPR middle-end/101600 - Spurious -Warray-bounds downcasting a polymorphic pointer\nPR middle-end/101977 - bogus -Warray-bounds on a negative index into a parameter in conditional with null\n\ngcc/ChangeLog:\n\n\tPR middle-end/101600\n\tPR middle-end/101977\n\t* gimple-ssa-warn-access.cc (maybe_warn_for_bound): Tighten up\n\tthe phrasing of a warning.\n\t(check_access): Use the remaining size after subtracting any offset\n\trather than the whole object size.\n\t* pointer-query.cc (access_ref::get_ref): Clear BASE0 flag if it's\n\tclear for any nonnull PHI argument.\n\t(compute_objsize): Clear argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/101600\n\tPR middle-end/101977\n\t* g++.dg/pr100574.C: Prune out valid warning.\n\t* gcc.dg/pr20126.c: Same.\n\t* gcc.dg/Wstringop-overread.c: Adjust text of expected warnings.\n\tAdd new instances.\n\t* gcc.dg/warn-strnlen-no-nul.c: Same.\n\t* g++.dg/warn/Warray-bounds-26.C: New test.\n\t* gcc.dg/Warray-bounds-88.c: New test.", "tree": {"sha": "b9517cd7a654bf06337532a5395539c4eaa6c55e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9517cd7a654bf06337532a5395539c4eaa6c55e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/820f0940d7ace1306430a9dcf1bd9577508a7a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820f0940d7ace1306430a9dcf1bd9577508a7a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820f0940d7ace1306430a9dcf1bd9577508a7a7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820f0940d7ace1306430a9dcf1bd9577508a7a7e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d692ef43b2b3368c92c3fb757c7884fc94ee627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d692ef43b2b3368c92c3fb757c7884fc94ee627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d692ef43b2b3368c92c3fb757c7884fc94ee627"}], "stats": {"total": 367, "additions": 286, "deletions": 81}, "files": [{"sha": "5df97a6473a02f38bdbae076b129963a6b31af54", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -704,6 +704,15 @@ maybe_warn_for_bound (opt_code opt, location_t loc, GimpleOrTree exp, tree func,\n   if (opt == OPT_Wstringop_overread)\n     {\n       bool maybe = pad && pad->src.phi ();\n+      if (maybe)\n+\t{\n+\t  /* Issue a \"maybe\" warning only if the PHI refers to objects\n+\t     at least one of which has more space remaining than the bound.\n+\t     Otherwise, if the bound is greater, use the definitive form.  */\n+\t  offset_int remmax = pad->src.size_remaining ();\n+\t  if (remmax < wi::to_offset (bndrng[0]))\n+\t    maybe = false;\n+\t}\n \n       if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n \t{\n@@ -788,6 +797,15 @@ maybe_warn_for_bound (opt_code opt, location_t loc, GimpleOrTree exp, tree func,\n     }\n \n   bool maybe = pad && pad->dst.phi ();\n+  if (maybe)\n+    {\n+      /* Issue a \"maybe\" warning only if the PHI refers to objects\n+\t at least one of which has more space remaining than the bound.\n+\t Otherwise, if the bound is greater, use the definitive form.  */\n+      offset_int remmax = pad->dst.size_remaining ();\n+      if (remmax < wi::to_offset (bndrng[0]))\n+\tmaybe = false;\n+    }\n   if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n     {\n       if (bndrng[0] == bndrng[1])\n@@ -1418,7 +1436,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n       location_t loc = get_location (exp);\n       tree size = dstsize;\n       if (pad && pad->mode == access_read_only)\n-\tsize = wide_int_to_tree (sizetype, pad->src.sizrng[1]);\n+\tsize = wide_int_to_tree (sizetype, pad->src.size_remaining ());\n \n       if (range[0] && maxread && tree_fits_uhwi_p (size))\n \t{"}, {"sha": "ba8f8a9dc69b316703b5fc924e2402478d867fe8", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -634,10 +634,10 @@ access_ref::phi () const\n   return as_a <gphi *> (def_stmt);\n }\n \n-/* Determine and return the largest object to which *THIS.  If *THIS\n-   refers to a PHI and PREF is nonnull, fill *PREF with the details\n-   of the object determined by compute_objsize(ARG, OSTYPE) for each\n-   PHI argument ARG.  */\n+/* Determine and return the largest object to which *THIS refers.  If\n+   *THIS refers to a PHI and PREF is nonnull, fill *PREF with the details\n+   of the object determined by compute_objsize(ARG, OSTYPE) for each PHI\n+   argument ARG.  */\n \n tree\n access_ref::get_ref (vec<access_ref> *all_refs,\n@@ -659,21 +659,25 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n   if (!psnlim->visit_phi (ref))\n     return NULL_TREE;\n \n-  /* Reflects the range of offsets of all PHI arguments refer to the same\n-     object (i.e., have the same REF).  */\n-  access_ref same_ref;\n-  /* The conservative result of the PHI reflecting the offset and size\n-     of the largest PHI argument, regardless of whether or not they all\n-     refer to the same object.  */\n   pointer_query empty_qry;\n   if (!qry)\n     qry = &empty_qry;\n \n+  /* The conservative result of the PHI reflecting the offset and size\n+     of the largest PHI argument, regardless of whether or not they all\n+     refer to the same object.  */\n   access_ref phi_ref;\n   if (pref)\n     {\n+      /* The identity of the object has not been determined yet but\n+\t PREF->REF is set by the caller to the PHI for convenience.\n+\t The size is negative/invalid and the offset is zero (it's\n+\t updated only after the identity of the object has been\n+\t established).  */\n+      gcc_assert (pref->sizrng[0] < 0);\n+      gcc_assert (pref->offrng[0] == 0 && pref->offrng[1] == 0);\n+\n       phi_ref = *pref;\n-      same_ref = *pref;\n     }\n \n   /* Set if any argument is a function array (or VLA) parameter not\n@@ -682,8 +686,6 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n   /* The size of the smallest object referenced by the PHI arguments.  */\n   offset_int minsize = 0;\n   const offset_int maxobjsize = wi::to_offset (max_object_size ());\n-  /* The offset of the PHI, not reflecting those of its arguments.  */\n-  const offset_int orng[2] = { phi_ref.offrng[0], phi_ref.offrng[1] };\n \n   const unsigned nargs = gimple_phi_num_args (phi_stmt);\n   for (unsigned i = 0; i < nargs; ++i)\n@@ -695,28 +697,31 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n \t/* A PHI with all null pointer arguments.  */\n \treturn NULL_TREE;\n \n-      /* Add PREF's offset to that of the argument.  */\n-      phi_arg_ref.add_offset (orng[0], orng[1]);\n       if (TREE_CODE (arg) == SSA_NAME)\n \tqry->put_ref (arg, phi_arg_ref);\n \n       if (all_refs)\n \tall_refs->safe_push (phi_arg_ref);\n \n-      const bool arg_known_size = (phi_arg_ref.sizrng[0] != 0\n-\t\t\t\t   || phi_arg_ref.sizrng[1] != maxobjsize);\n-\n       parmarray |= phi_arg_ref.parmarray;\n \n       const bool nullp = integer_zerop (arg) && (i || i + 1 < nargs);\n \n       if (phi_ref.sizrng[0] < 0)\n \t{\n+\t  /* If PHI_REF doesn't contain a meaningful result yet set it\n+\t     to the result for the first argument.  */\n \t  if (!nullp)\n-\t    same_ref = phi_arg_ref;\n-\t  phi_ref = phi_arg_ref;\n+\t    phi_ref = phi_arg_ref;\n+\n+\t  /* Set if the current argument refers to one or more objects of\n+\t     known size (or range of sizes), as opposed to referring to\n+\t     one or more unknown object(s).  */\n+\t  const bool arg_known_size = (phi_arg_ref.sizrng[0] != 0\n+\t\t\t\t       || phi_arg_ref.sizrng[1] != maxobjsize);\n \t  if (arg_known_size)\n \t    minsize = phi_arg_ref.sizrng[0];\n+\n \t  continue;\n \t}\n \n@@ -740,41 +745,24 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n       offset_int phirem[2];\n       phirem[1] = phi_ref.size_remaining (phirem);\n \n-      if (phi_arg_ref.ref != same_ref.ref)\n-\tsame_ref.ref = NULL_TREE;\n+      /* Reset the PHI's BASE0 flag if any of the nonnull arguments\n+\t refers to an object at an unknown offset.  */\n+      if (!phi_arg_ref.base0)\n+\tphi_ref.base0 = false;\n \n       if (phirem[1] < argrem[1]\n \t  || (phirem[1] == argrem[1]\n \t      && phi_ref.sizrng[1] < phi_arg_ref.sizrng[1]))\n \t/* Use the argument with the most space remaining as the result,\n \t   or the larger one if the space is equal.  */\n \tphi_ref = phi_arg_ref;\n-\n-      /* Set SAME_REF.OFFRNG to the maximum range of all arguments.  */\n-      if (phi_arg_ref.offrng[0] < same_ref.offrng[0])\n-\tsame_ref.offrng[0] = phi_arg_ref.offrng[0];\n-      if (same_ref.offrng[1] < phi_arg_ref.offrng[1])\n-\tsame_ref.offrng[1] = phi_arg_ref.offrng[1];\n     }\n \n-  if (!same_ref.ref && same_ref.offrng[0] != 0)\n-    /* Clear BASE0 if not all the arguments refer to the same object and\n-       if not all their offsets are zero-based.  This allows the final\n-       PHI offset to out of bounds for some arguments but not for others\n-       (or negative even of all the arguments are BASE0), which is overly\n-       permissive.  */\n-    phi_ref.base0 = false;\n-\n-  if (same_ref.ref)\n-    phi_ref = same_ref;\n-  else\n-    {\n-      /* Replace the lower bound of the largest argument with the size\n-\t of the smallest argument, and set PARMARRAY if any argument\n-\t was one.  */\n-      phi_ref.sizrng[0] = minsize;\n-      phi_ref.parmarray = parmarray;\n-    }\n+  /* Replace the lower bound of the largest argument with the size\n+     of the smallest argument, and set PARMARRAY if any argument\n+     was one.  */\n+  phi_ref.sizrng[0] = minsize;\n+  phi_ref.parmarray = parmarray;\n \n   if (phi_ref.sizrng[0] < 0)\n     {\n@@ -804,6 +792,14 @@ access_ref::size_remaining (offset_int *pmin /* = NULL */) const\n   if (!pmin)\n     pmin = &minbuf;\n \n+  if (sizrng[0] < 0)\n+    {\n+      /* If the identity of the object hasn't been determined return\n+\t the maximum size range.  */\n+      *pmin = 0;\n+      return wi::to_offset (max_object_size ());\n+    }\n+\n   /* add_offset() ensures the offset range isn't inverted.  */\n   gcc_checking_assert (offrng[0] <= offrng[1]);\n \n@@ -1597,6 +1593,11 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n     {\n       pref->ref = ptr;\n \n+      /* Reset the offset in case it was set by a prior call and not\n+\t cleared by the caller.  The offset is only adjusted after\n+\t the identity of the object has been determined.  */\n+      pref->offrng[0] = pref->offrng[1] = 0;\n+\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (ptr)))\n \t{\n \t  /* Set the maximum size if the reference is to the pointer\n@@ -1607,6 +1608,9 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t  return true;\n \t}\n \n+      /* Valid offsets into the object are nonnegative.  */\n+      pref->base0 = true;\n+\n       if (tree size = decl_init_size (ptr, false))\n \tif (TREE_CODE (size) == INTEGER_CST)\n \t  {\n@@ -1960,6 +1964,11 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n {\n   pointer_query qry;\n   qry.rvals = rvals;\n+\n+  /* Clear and invalidate in case *PREF is being reused.  */\n+  pref->offrng[0] = pref->offrng[1] = 0;\n+  pref->sizrng[0] = pref->sizrng[1] = -1;\n+\n   ssa_name_limit_t snlim;\n   if (!compute_objsize_r (ptr, ostype, pref, snlim, &qry))\n     return NULL_TREE;\n@@ -1982,6 +1991,10 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, pointer_query *ptr_qry)\n   else\n     ptr_qry = &qry;\n \n+  /* Clear and invalidate in case *PREF is being reused.  */\n+  pref->offrng[0] = pref->offrng[1] = 0;\n+  pref->sizrng[0] = pref->sizrng[1] = -1;\n+\n   ssa_name_limit_t snlim;\n   if (!compute_objsize_r (ptr, ostype, pref, snlim, ptr_qry))\n     return NULL_TREE;"}, {"sha": "0df62aa70ad28423b3baa3e9bbc2cefaa8553129", "filename": "gcc/testsuite/g++.dg/pr100574.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100574.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100574.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100574.C?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -40,6 +40,8 @@ template <typename _Tp, typename _Alloc>\n template <typename...>\n void vector<_Tp, _Alloc>::_M_realloc_insert() {\n   __alloc_traits::pointer __trans_tmp_5;\n+  /* __len is used uninitialized below, which might trigger warnings,\n+     even without -Wall (and other than -Wuninitialized).  */\n   long __len(__len || max_size()), __elems_before;\n   __trans_tmp_5 = _M_allocate___n\n     ? __alloc_traits::allocate(_M_impl, _M_allocate___n)\n@@ -62,3 +64,5 @@ void ReadTrackChunk()\n     case MIDIST_PITCHBEND:\n       block.data.push_back();\n }\n+\n+// { dg-prune-output \"warning\" }"}, {"sha": "f72ac9d4b51248152708c9b280e7459bc880c02e", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-26.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-26.C?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -0,0 +1,27 @@\n+/* PR middle-end/101600 - Spurious -Warray-bounds downcasting a polymorphic\n+   pointer\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct S1 { virtual ~S1(); };\n+struct S2 { int m; };\n+struct S3 { virtual ~S3(); };\n+struct S4: S1, S2, S3 {};\n+\n+int f1 ();\n+\n+void f2 (S3 *);\n+\n+void f3 (S2 *p)\n+{\n+  for (int i = f1 (); f1 (); )\n+    {\n+      if (i == 0)\n+  \t{\n+  \t  p = 0;\n+  \t  break;\n+  \t}\n+    }\n+\n+  f2 (static_cast<S4 *>(p));  // { dg-bogus \"-Warray-bounds\" }\n+}"}, {"sha": "8cee8d28571d79c2d194fa695a8d9ae74a46c1cf", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-88.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-88.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-88.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-88.c?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -0,0 +1,134 @@\n+/* PR middle-end/101977 - bogus -Warray-bounds on a negative index into\n+   a parameter in conditional with null\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct A { int i; };\n+struct B { struct A a1; struct A a2; };\n+\n+\n+void nowarn_p_0_0 (struct A *p, int i)\n+{\n+  struct A *q = i < 0 ? p : 0 < i ? (struct A*)0 : 0;\n+  struct B *r = (struct B*)((char *)q - __builtin_offsetof (struct B, a2));\n+  r->a1.i = 0;\n+}\n+\n+void nowarn_0_p_0 (struct A *p, int i)\n+{\n+  struct A *q = i < 0 ? 0 : 0 < i ? p : 0;\n+  struct B *r = (struct B*)((char *)q - __builtin_offsetof (struct B, a2));\n+  r->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+void nowarn_0_0_p (struct A *p, int i)\n+{\n+  struct A *q = i < 0 ? 0 : 0 < i ? 0 : p;\n+  struct B *r = (struct B*)((char *)q - __builtin_offsetof (struct B, a2));\n+  r->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+\n+void nowarn_p_q_0 (struct A *p, struct A *q, int i)\n+{\n+  struct A *r = i < 0 ? p : 0 < i ? q : 0;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+void nowarn_p_0_q (struct A *p, struct A *q, int i)\n+{\n+  struct A *r = i < 0 ? p : 0 < i ? 0 : q;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+void nowarn_0_p_q (struct A *p, struct A *q, int i)\n+{\n+  struct A *r = i < 0 ? 0 : 0 < i ? p : q;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;\n+}\n+\n+\n+void nowarn_p_q_r (struct A *p, struct A *q, struct A *r, int i)\n+{\n+  struct A *s = i < 0 ? p : 0 < i ? q : r;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+\n+extern struct B b1, b2, b3;\n+\n+void nowarn_p_b1_0 (struct A *p, int i)\n+{\n+  struct A *r = i < 0 ? p : 0 < i ? &b1.a2 : 0;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+void nowarn_p_0_b1 (struct A *p, int i)\n+{\n+  struct A *r = i < 0 ? p : 0 < i ? 0 : &b1.a2;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;      // { dg-bogus \"-Warray-bounds\" }\n+}\n+\n+void nowarn_0_p_b1 (struct A *p, int i)\n+{\n+  struct A *r = i < 0 ? 0 : 0 < i ? p : &b1.a2;\n+  struct B *s = (struct B*)((char *)r - __builtin_offsetof (struct B, a2));\n+  s->a1.i = 0;\n+}\n+\n+\n+void nowarn_p_b1_b2 (struct A *p, int i)\n+{\n+  struct A *s = i < 0 ? p : 0 < i ? &b1.a2 : &b2.a2;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+void nowarn_b1_p_b2 (struct A *p, int i)\n+{\n+  struct A *s = i < 0 ? &b1.a2 : 0 < i ? p : &b2.a2;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+void nowarn_b1_b2_p (struct A *p, int i)\n+{\n+  struct A *s = i < 0 ? &b1.a2 : 0 < i ? &b2.a2 : p;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+void nowarn_b1_b2_b3 (struct A *p, int i)\n+{\n+  struct A *s = i < 0 ? &b1.a2 : 0 < i ? &b2.a2 : &b3.a2;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+\n+void nowarn_0_b1_b2 (int i)\n+{\n+  struct A *s = i < 0 ? 0 : 0 < i ? &b1.a2 : &b2.a2;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+void warn_b1_0_b2 (int i)\n+{\n+  struct A *s = i < 0 ? &b1.a2 : 0 < i ? 0 : &b2.a2;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}\n+\n+void warn_b1_b2_0 (int i)\n+{\n+  struct A *s = i < 0 ? &b1.a2 : 0 < i ? &b2.a2 : 0;\n+  struct B *t = (struct B*)((char *)s - __builtin_offsetof (struct B, a2));\n+  t->a1.i = 0;\n+}"}, {"sha": "7db74029819225e4c697503603c49dbaef0db87c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overread.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread.c?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -317,9 +317,9 @@ void test_strnlen_array (int i, int i0, unsigned n)\n   T (strnlen (a1, n));\n \n   T (strnlen (a1 + 1, 0));\n-  T (strnlen (a1 + 1, 1));      // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a1 + 1, 1));      // { dg-warning \"'strnlen' specified bound 1 exceeds source size 0\" }\n   T (strnlen (a1 + 1, i0));\n-  T (strnlen (a1 + 1, i0 + 1)); // { dg-warning \"'strnlen' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strnlen (a1 + 1, i0 + 1)); // { dg-warning \"'strnlen' specified bound \\\\\\[1, \\\\d+] exceeds source size 0\" }\n   T (strnlen (a1 + 1, n));\n   T (strnlen (a1 + i, 0));\n   T (strnlen (a1 + i, 1));\n@@ -335,7 +335,7 @@ void test_strnlen_array (int i, int i0, unsigned n)\n   T (strnlen (a1 + i0, 2));     // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" }\n   T (strnlen (a1 + i0, n));\n   T (strnlen (a1 + i0 + 1, 0));\n-  T (strnlen (a1 + i0 + 1, 1)); // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a1 + i0 + 1, 1)); // { dg-warning \"'strnlen' specified bound 1 exceeds source size 0\" }\n   T (strnlen (a1 + i0 + 1, n));\n \n   T (strnlen (a2, 0));\n@@ -344,10 +344,10 @@ void test_strnlen_array (int i, int i0, unsigned n)\n   T (strnlen (a2, n));\n   T (strnlen (a2 + 1, 0));\n   T (strnlen (a2 + 1, 1));\n-  T (strnlen (a2 + 1, 2));      // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\"  \"pr87492\" { xfail *-*-* } }\n+  T (strnlen (a2 + 1, 2));      // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\"  \"pr87492\" }\n   T (strnlen (a2 + 1, n));\n   T (strnlen (a2 + 2, 0));\n-  T (strnlen (a2 + 2, 1));      // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a2 + 2, 1));      // { dg-warning \"'strnlen' specified bound 1 exceeds source size 0\" }\n   T (strnlen (a2 + 2, n));\n   T (strnlen (a2 + i, 0));\n   T (strnlen (a2 + i, 1));\n@@ -365,13 +365,13 @@ void test_strnlen_array (int i, int i0, unsigned n)\n \n   T (strnlen (a2 + i0 + 1, 0));\n   T (strnlen (a2 + i0 + 1, 1));\n-  T (strnlen (a2 + i0 + 1, 2));\n+  T (strnlen (a2 + i0 + 1, 2)); // { dg-warning \"'strnlen' specified bound 2 exceeds source size 1\" }\n   T (strnlen (a2 + i0 + 1, n));\n \n   T (strnlen (a2 + i0 + 2, 0));\n-  T (strnlen (a2 + i0 + 2, 1)); // { dg-warning \"'strnlen' reading 1 byte from a region of size 0\" }\n+  T (strnlen (a2 + i0 + 2, 1)); // { dg-warning \"'strnlen' specified bound 1 exceeds source size 0\" }\n   T (strnlen (a2 + i0 + 2, i0));\n-  T (strnlen (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strnlen' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strnlen (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strnlen' specified bound \\\\\\[1, \\\\d+] exceeds source size 0\" }\n   T (strnlen (a2 + i0 + 2, n));\n }\n \n@@ -512,9 +512,9 @@ void test_strndup_array (int i, int i0, unsigned n)\n   T (strndup (a1, 2));          // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n   T (strndup (a1, n));\n   T (strndup (a1 + 1, 0));\n-  T (strndup (a1 + 1, 1));      // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a1 + 1, 1));      // { dg-warning \"'strndup' specified bound 1 exceeds source size 0\" }\n   T (strndup (a1 + 1, i0));\n-  T (strndup (a1 + 1, i0 + 1)); // { dg-warning \"'strndup' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strndup (a1 + 1, i0 + 1)); // { dg-warning \"'strndup' specified bound \\\\\\[1, \\\\d+] exceeds source size 0\" }\n   T (strndup (a1 + 1, n));\n   T (strndup (a1 + i, 0));\n   T (strndup (a1 + i, 1));\n@@ -529,7 +529,7 @@ void test_strndup_array (int i, int i0, unsigned n)\n   T (strndup (a1 + i0, 1));\n   T (strndup (a1 + i0, n));\n   T (strndup (a1 + i0 + 1, 0));\n-  T (strndup (a1 + i0 + 1, 1)); // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a1 + i0 + 1, 1)); // { dg-warning \"'strndup' specified bound 1 exceeds source size 0\" }\n   T (strndup (a1 + i0 + 1, n));\n \n   T (strndup (a2, 0));\n@@ -538,10 +538,10 @@ void test_strndup_array (int i, int i0, unsigned n)\n   T (strndup (a2, n));\n   T (strndup (a2 + 1, 0));\n   T (strndup (a2 + 1, 1));\n-  T (strndup (a2 + 1, 2));\n+  T (strndup (a2 + 1, 2));      // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n   T (strndup (a2 + 1, n));\n   T (strndup (a2 + 2, 0));\n-  T (strndup (a2 + 2, 1));      // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a2 + 2, 1));      // { dg-warning \"'strndup' specified bound 1 exceeds source size 0\" }\n   T (strndup (a2 + 2, n));\n   T (strndup (a2 + i, 0));\n   T (strndup (a2 + i, 1));\n@@ -559,13 +559,13 @@ void test_strndup_array (int i, int i0, unsigned n)\n \n   T (strndup (a2 + i0 + 1, 0));\n   T (strndup (a2 + i0 + 1, 1));\n-  T (strndup (a2 + i0 + 1, 2));\n+  T (strndup (a2 + i0 + 1, 2)); // { dg-warning \"'strndup' specified bound 2 exceeds source size 1\" }\n   T (strndup (a2 + i0 + 1, n));\n \n   T (strndup (a2 + i0 + 2, 0));\n-  T (strndup (a2 + i0 + 2, 1)); // { dg-warning \"'strndup' reading 1 byte from a region of size 0\" }\n+  T (strndup (a2 + i0 + 2, 1)); // { dg-warning \"'strndup' specified bound 1 exceeds source size 0\" }\n   T (strndup (a2 + i0 + 2, i0));\n-  T (strndup (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strndup' reading between 1 and \\[0-9\\]+ bytes from a region of size 0\" }\n+  T (strndup (a2 + i0 + 2, i0 + 1)); // { dg-warning \"'strndup' specified bound \\\\\\[1, \\\\d+] exceeds source size 0\" }\n   T (strndup (a2 + i0 + 2, n));\n }\n "}, {"sha": "10aeec74f396090be3472a5d52a9bd3a99162db7", "filename": "gcc/testsuite/gcc.dg/pr20126.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -34,6 +34,10 @@ foo (S *x, S *y)\n   while (e <= g)\n     {\n       const char *t = e + 1;\n+      /* The pointer E below increases but the bound H stays constant,\n+\t letting the latter exceed the size remaining in the argument\n+\t pointed to by the formed, which might be detected by\n+\t -Wstringop-overread.  */\n       if (__builtin_memcmp (e, f, h) == 0)\n         return 1;\n       e = t;\n@@ -48,3 +52,5 @@ main (void)\n     abort ();\n   return 0;\n }\n+\n+/* { dg-prune-output \"-Wstringop-overread\" } */"}, {"sha": "846e9300750e29181619e07cb6850ada7ef81597", "filename": "gcc/testsuite/gcc.dg/warn-strnlen-no-nul.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820f0940d7ace1306430a9dcf1bd9577508a7a7e/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c?ref=820f0940d7ace1306430a9dcf1bd9577508a7a7e", "patch": "@@ -143,14 +143,17 @@ T (v0 ? b[1] : \"\", bsz);\n T (v0 ? b[2] : \"\", bsz);\n T (v0 ? b[3] : \"\", bsz);\n \n-T (v0 ? \"\" : b[0], bsz + 1);      /* { dg-warning \"bound 6 may exceed source size 5\" } */\n-T (v0 ? \"\" : b[1], bsz + 1);\n-T (v0 ? \"\" : b[2], bsz + 1);\n-T (v0 ? \"\" : b[3], bsz + 1);      /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[0] : \"\", bsz + 1);      /* { dg-warning \"bound 6 may exceed source size 5\" } */\n-T (v0 ? b[1] : \"\", bsz + 1);\n-T (v0 ? b[2] : \"\", bsz + 1);\n-T (v0 ? b[3] : \"\", bsz + 1);      /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n+/* The warnings below are strictly correct but the strnlen calls are safe\n+   because the reads are bounded by the length of the constant arguments.\n+   It might make sense to relax the warning to avoid triggering for them.  */\n+T (v0 ? \"\" : b[0], bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? \"\" : b[1], bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? \"\" : b[2], bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? \"\" : b[3], bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[0] : \"\", bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[1] : \"\", bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[2] : \"\", bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[3] : \"\", bsz + 1);      /* { dg-warning \"bound 6 exceeds source size 5\" } */\n \n T (v0 ? \"\" : b[i0], bsz);\n T (v0 ? \"\" : b[i1], bsz);\n@@ -164,11 +167,11 @@ T (v0 ? b[i3] : \"\", bsz);\n T (v0 ? \"\" : b[i0], bsz + 1);\n T (v0 ? \"\" : b[i1], bsz + 1);\n T (v0 ? \"\" : b[i2], bsz + 1);\n-T (v0 ? \"\" : b[i3], bsz + 1);     /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n+T (v0 ? \"\" : b[i3], bsz + 1);     /* { dg-warning \"bound 6 exceeds source size 5\" \"pr86937\" } */\n T (v0 ? b[i0] : \"\", bsz + 1);\n T (v0 ? b[i1] : \"\", bsz + 1);\n T (v0 ? b[i2] : \"\", bsz + 1);\n-T (v0 ? b[i3] : \"\", bsz + 1);     /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n+T (v0 ? b[i3] : \"\", bsz + 1);     /* { dg-warning \"bound 6 exceeds source size 5\" \"pr86937\" } */\n \n T (v0 ? \"1234\" : b[3], bsz);\n T (v0 ? \"1234\" : b[i3], bsz);\n@@ -180,15 +183,15 @@ T (v0 ? b[0] : b[2], bsz);\n T (v0 ? b[2] : b[3], bsz);\n T (v0 ? b[3] : b[2], bsz);\n \n-T (v0 ? \"1234\" : b[3], bsz + 1);  /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? \"1234\" : b[i3], bsz + 1); /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[3] : \"1234\", bsz + 1);  /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[i3] : \"1234\", bsz + 1); /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n+T (v0 ? \"1234\" : b[3], bsz + 1);  /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? \"1234\" : b[i3], bsz + 1); /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[3] : \"1234\", bsz + 1);  /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[i3] : \"1234\", bsz + 1); /* { dg-warning \"bound 6 exceeds source size 5\" } */\n \n-T (v0 ? a : b[3], bsz + 1);       /* { dg-warning \"bound 6 may exceed source size 5\" \"pr86937\" { xfail *-*-*} } */\n-T (v0 ? b[0] : b[2], bsz + 1);    /* { dg-warning \"bound 6 may exceed source size 5\" \"pr86937\" } */\n-T (v0 ? b[2] : b[3], bsz + 1);    /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[3] : b[2], bsz + 1);    /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n+T (v0 ? a : b[3], bsz + 1);       /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[0] : b[2], bsz + 1);    /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[2] : b[3], bsz + 1);    /* { dg-warning \"bound 6 exceeds source size 5\" } */\n+T (v0 ? b[3] : b[2], bsz + 1);    /* { dg-warning \"bound 6 exceeds source size 5\" } */\n \n struct A { char a[5], b[5]; };\n "}]}