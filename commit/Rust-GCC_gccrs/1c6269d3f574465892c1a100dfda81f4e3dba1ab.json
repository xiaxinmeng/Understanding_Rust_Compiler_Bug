{"sha": "1c6269d3f574465892c1a100dfda81f4e3dba1ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM2MjY5ZDNmNTc0NDY1ODkyYzFhMTAwZGZkYTgxZjRlM2RiYTFhYg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-07-05T10:57:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:57:42Z"}, "message": "aspects.adb: Add an entry for SPARK_Mode in table Canonical_Aspect.\n\n2013-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Add an entry for SPARK_Mode in table Canonical_Aspect.\n\t* aspects.ads: Add an entry for SPARK_Mode in tables Aspect_Id,\n\tAspect_Argument, Aspect_Names.\n\t* atree.adb (Node32): New routine.\n\t(Set_Node32): New routine.\n\t* atree.ads (Node32): New routine.\n\t(Set_Node32): New routine.\n\t* einfo.adb: Node32 is now used as SPARK_Mode_Pragmas.\n\t(Set_SPARK_Mode_Pragmas): New routine.\n\t(SPARK_Mode_Pragmas): New routine.\n\t(Write_Field32_Name): Add and entry for SPARK_Modes.\n\t* einfo.ads: Add attribute SPARK_Mode_Pragmas along with usage\n\tin various entities.\n\t(Set_SPARK_Mode_Pragmas): New routine and\n\tpragma Inline.\n\t(SPARK_Mode_Pragmas): New routine and pragma Inline.\n\t* gnat_rm.texi: Add sections explaining the syntax and semantics\n\tof aspect/pragma SPARK_Mode.\n\t* gnat_ugn.texi: Add pragma SPARK_Mode to the list of\n\tconfiguration pragmas.\n\t* lib.adb (Set_SPARK_Mode_Pragma): New routine.\n\t(SPARK_Mode_Pragma): New routine.\n\t* lib.ads: Alphabetize the comments on fields of record\n\tUnit_Record. Add new field SPARK_Mode_Pragma along with\n\tcomment on its usage. Update the layout of record Unit_Record.\n\t(Set_SPARK_Mode_Pragma): New routine and pragma Inline.\n\t(SPARK_Mode_Pragma): New routine and pragma Inline.\n\t* lib-load.adb (Create_Dummy_Package_Unit): Initialize\n\tfield SPARK_Mode_Pragma.\n\t(Load_Main_Source): Initialize field SPARK_Mode_Pragma.\n\t(Load_Unit): Initialize field SPARK_Mode_Pragma.\n\t* lib-writ.adb (Add_Preprocessing_Dependency): Initialize field\n\tSPARK_Mode_Pragma.\n\t(Ensure_System_Dependency): Initialize field SPARK_Mode_Pragma.\n\t* opt.ads: Alphabetize verification flags. Store the\n\tcompilation-wide SPARK mode in variable Global_SPARK_Mode.\n\t* par-prag.adb: Pragma SPARK_Mode does not need special processing\n\tby the parser.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Convert aspect\n\tSPARK_Mode into a pragma.\n\t(Check_Aspect_At_Freeze_Point): Aspect SPARK_Mode does not need\n\tdelayed processing.\n\t* sem_prag.adb: Add an entry for SPARK_Mode in table Sig_Flags.\n\t(Analyze_Pragma): Add processing for pragma SPARK_Mode.\n\t(Get_SPARK_Mode_Id): New routine.\n\t(Is_Elaboration_SPARK_Mode): New routine.\n\t(Is_Private_SPARK_Mode): New routine.\n\t* sem_prag.ads (Get_SPARK_Mode_Id): New routine.\n\t(Is_Elaboration_SPARK_Mode): New routine.\n\t(Is_Private_SPARK_Mode): New routine.\n\t* sinfo.ads: Update the comment on the usage of field Next_Pragma.\n\t* snames.ads-tmpl: Add new predefined name for SPARK_Mode and\n\tAuto. Add new pragma Id for SPARK_Mode.\n\t* types.ads: Add new type SPARK_Mode_Id.\n\nFrom-SVN: r200711", "tree": {"sha": "d9d0f449322c41f0b8dc1b336a7e557d2d66170d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9d0f449322c41f0b8dc1b336a7e557d2d66170d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c6269d3f574465892c1a100dfda81f4e3dba1ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6269d3f574465892c1a100dfda81f4e3dba1ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c6269d3f574465892c1a100dfda81f4e3dba1ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c6269d3f574465892c1a100dfda81f4e3dba1ab/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fc154c8cc66d8ab7baca7d80573ecd0f64c3a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc154c8cc66d8ab7baca7d80573ecd0f64c3a10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc154c8cc66d8ab7baca7d80573ecd0f64c3a10"}], "stats": {"total": 1201, "additions": 958, "deletions": 243}, "files": [{"sha": "5d222e79e9422e4032471d23db7a1b4219fb52c0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1,3 +1,60 @@\n+2013-07-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Add an entry for SPARK_Mode in table Canonical_Aspect.\n+\t* aspects.ads: Add an entry for SPARK_Mode in tables Aspect_Id,\n+\tAspect_Argument, Aspect_Names.\n+\t* atree.adb (Node32): New routine.\n+\t(Set_Node32): New routine.\n+\t* atree.ads (Node32): New routine.\n+\t(Set_Node32): New routine.\n+\t* einfo.adb: Node32 is now used as SPARK_Mode_Pragmas.\n+\t(Set_SPARK_Mode_Pragmas): New routine.\n+\t(SPARK_Mode_Pragmas): New routine.\n+\t(Write_Field32_Name): Add and entry for SPARK_Modes.\n+\t* einfo.ads: Add attribute SPARK_Mode_Pragmas along with usage\n+\tin various entities.\n+\t(Set_SPARK_Mode_Pragmas): New routine and\n+\tpragma Inline.\n+\t(SPARK_Mode_Pragmas): New routine and pragma Inline.\n+\t* gnat_rm.texi: Add sections explaining the syntax and semantics\n+\tof aspect/pragma SPARK_Mode.\n+\t* gnat_ugn.texi: Add pragma SPARK_Mode to the list of\n+\tconfiguration pragmas.\n+\t* lib.adb (Set_SPARK_Mode_Pragma): New routine.\n+\t(SPARK_Mode_Pragma): New routine.\n+\t* lib.ads: Alphabetize the comments on fields of record\n+\tUnit_Record. Add new field SPARK_Mode_Pragma along with\n+\tcomment on its usage. Update the layout of record Unit_Record.\n+\t(Set_SPARK_Mode_Pragma): New routine and pragma Inline.\n+\t(SPARK_Mode_Pragma): New routine and pragma Inline.\n+\t* lib-load.adb (Create_Dummy_Package_Unit): Initialize\n+\tfield SPARK_Mode_Pragma.\n+\t(Load_Main_Source): Initialize field SPARK_Mode_Pragma.\n+\t(Load_Unit): Initialize field SPARK_Mode_Pragma.\n+\t* lib-writ.adb (Add_Preprocessing_Dependency): Initialize field\n+\tSPARK_Mode_Pragma.\n+\t(Ensure_System_Dependency): Initialize field SPARK_Mode_Pragma.\n+\t* opt.ads: Alphabetize verification flags. Store the\n+\tcompilation-wide SPARK mode in variable Global_SPARK_Mode.\n+\t* par-prag.adb: Pragma SPARK_Mode does not need special processing\n+\tby the parser.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Convert aspect\n+\tSPARK_Mode into a pragma.\n+\t(Check_Aspect_At_Freeze_Point): Aspect SPARK_Mode does not need\n+\tdelayed processing.\n+\t* sem_prag.adb: Add an entry for SPARK_Mode in table Sig_Flags.\n+\t(Analyze_Pragma): Add processing for pragma SPARK_Mode.\n+\t(Get_SPARK_Mode_Id): New routine.\n+\t(Is_Elaboration_SPARK_Mode): New routine.\n+\t(Is_Private_SPARK_Mode): New routine.\n+\t* sem_prag.ads (Get_SPARK_Mode_Id): New routine.\n+\t(Is_Elaboration_SPARK_Mode): New routine.\n+\t(Is_Private_SPARK_Mode): New routine.\n+\t* sinfo.ads: Update the comment on the usage of field Next_Pragma.\n+\t* snames.ads-tmpl: Add new predefined name for SPARK_Mode and\n+\tAuto. Add new pragma Id for SPARK_Mode.\n+\t* types.ads: Add new type SPARK_Mode_Id.\n+\n 2013-07-05  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Aspect_Specifications): For"}, {"sha": "d02edb25702ec2c8c1fc3c821c63a1bf97d4b8c2", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -403,6 +403,7 @@ package body Aspects is\n     Aspect_Simple_Storage_Pool_Type     => Aspect_Simple_Storage_Pool_Type,\n     Aspect_Size                         => Aspect_Size,\n     Aspect_Small                        => Aspect_Small,\n+    Aspect_SPARK_Mode                   => Aspect_SPARK_Mode,\n     Aspect_Static_Predicate             => Aspect_Predicate,\n     Aspect_Storage_Pool                 => Aspect_Storage_Pool,\n     Aspect_Storage_Size                 => Aspect_Storage_Size,"}, {"sha": "5a093af21cfb206e59378acab9751cedad628805", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -116,6 +116,7 @@ package Aspects is\n       Aspect_Simple_Storage_Pool,           -- GNAT\n       Aspect_Size,\n       Aspect_Small,\n+      Aspect_SPARK_Mode,                    -- GNAT\n       Aspect_Static_Predicate,\n       Aspect_Storage_Pool,\n       Aspect_Storage_Size,\n@@ -322,6 +323,7 @@ package Aspects is\n       Aspect_Simple_Storage_Pool     => Name,\n       Aspect_Size                    => Expression,\n       Aspect_Small                   => Expression,\n+      Aspect_SPARK_Mode              => Name,\n       Aspect_Static_Predicate        => Expression,\n       Aspect_Storage_Pool            => Name,\n       Aspect_Storage_Size            => Expression,\n@@ -423,6 +425,7 @@ package Aspects is\n       Aspect_Simple_Storage_Pool_Type     => Name_Simple_Storage_Pool_Type,\n       Aspect_Size                         => Name_Size,\n       Aspect_Small                        => Name_Small,\n+      Aspect_SPARK_Mode                   => Name_SPARK_Mode,\n       Aspect_Static_Predicate             => Name_Static_Predicate,\n       Aspect_Storage_Pool                 => Name_Storage_Pool,\n       Aspect_Storage_Size                 => Name_Storage_Size,"}, {"sha": "a6105e2c4278fc3b8d8c0b05ee345249ba6456a4", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -2532,6 +2532,12 @@ package body Atree is\n          return Node_Id (Nodes.Table (N + 5).Field7);\n       end Node31;\n \n+      function Node32 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 5).Field8);\n+      end Node32;\n+\n       function List1 (N : Node_Id) return List_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5243,6 +5249,12 @@ package body Atree is\n          Nodes.Table (N + 5).Field7 := Union_Id (Val);\n       end Set_Node31;\n \n+      procedure Set_Node32 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field8 := Union_Id (Val);\n+      end Set_Node32;\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "d1056b07a32745bdf95c107dfa7d86b7e199b976", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1174,6 +1174,9 @@ package Atree is\n       function Node31 (N : Node_Id) return Node_Id;\n       pragma Inline (Node31);\n \n+      function Node32 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node32);\n+\n       function List1 (N : Node_Id) return List_Id;\n       pragma Inline (List1);\n \n@@ -2459,6 +2462,9 @@ package Atree is\n       procedure Set_Node31 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node31);\n \n+      procedure Set_Node32 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node32);\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List1);\n "}, {"sha": "bca20443beda89cf6756788e35631e3b95adf1a8", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -246,7 +246,7 @@ package body Einfo is\n \n    --    Thunk_Entity                    Node31\n \n-   --    (unused)                        Node32\n+   --    SPARK_Mode_Pragmas              Node32\n \n    --    (unused)                        Node33\n \n@@ -2825,6 +2825,21 @@ package body Einfo is\n       return Ureal21 (Id);\n    end Small_Value;\n \n+   function SPARK_Mode_Pragmas (Id : E) return N is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function,         --  subprogram variants\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+      return Node32 (Id);\n+   end SPARK_Mode_Pragmas;\n+\n    function Spec_Entity (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Package_Body or else Is_Formal (Id));\n@@ -5469,6 +5484,22 @@ package body Einfo is\n       Set_Ureal21 (Id, V);\n    end Set_Small_Value;\n \n+   procedure Set_SPARK_Mode_Pragmas (Id : E; V : N) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Function,         --  subprogram variants\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n+                       E_Package,\n+                       E_Package_Body));\n+\n+      Set_Node32 (Id, V);\n+   end Set_SPARK_Mode_Pragmas;\n+\n    procedure Set_Spec_Entity (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Package_Body or else Is_Formal (Id));\n@@ -9149,6 +9180,16 @@ package body Einfo is\n    procedure Write_Field32_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Function                                   |\n+              E_Generic_Function                           |\n+              E_Generic_Package                            |\n+              E_Generic_Procedure                          |\n+              E_Package                                    |\n+              E_Package_Body                               |\n+              E_Procedure                                  |\n+              E_Subprogram_Body                            =>\n+            Write_Str (\"SPARK_Mode_Pragmas\");\n+\n          when others                                       =>\n             Write_Str (\"Field32??\");\n       end case;"}, {"sha": "0df288056180c0335938f89d95c242f8dc18440a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -3757,6 +3757,11 @@ package Einfo is\n --       Small of the type, either as given in a representation clause, or\n --       as computed (as a power of two) by the compiler.\n \n+--    SPARK_Mode_Pragmas (Node32)\n+--       Present in the entities of subprogram specs and bodies as well as in\n+--       package specs and bodies. Points to a list of SPARK_Mode pragmas that\n+--       apply to the related construct.\n+\n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n --       spec entity. Also defined in subprogram body parameters in the\n@@ -5394,6 +5399,7 @@ package Einfo is\n    --    Subprograms_For_Type                (Node29)\n    --    Corresponding_Equality              (Node30)   (implicit /= only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n+   --    SPARK_Mode_Pragmas                  (Node32)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Elaboration_Entity_Required         (Flag174)\n    --    Default_Expressions_Processed       (Flag108)\n@@ -5591,6 +5597,7 @@ package Einfo is\n    --    Abstract_States                     (Elist25)\n    --    Package_Instantiation               (Node26)\n    --    Current_Use_Clause                  (Node27)\n+   --    SPARK_Mode_Pragmas                  (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Discard_Names                       (Flag88)\n@@ -5621,6 +5628,7 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Finalizer                           (Node24)   (non-generic case only)\n+   --    SPARK_Mode_Pragmas                  (Node32)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Has_Anonymous_Master                (Flag253)\n    --    Scope_Depth                         (synth)\n@@ -5667,6 +5675,7 @@ package Einfo is\n    --    Extra_Formals                       (Node28)\n    --    Static_Initialization               (Node30)   (init_proc only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n+   --    SPARK_Mode_Pragmas                  (Node32)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Delay_Cleanups                      (Flag114)\n    --    Discard_Names                       (Flag88)\n@@ -5837,6 +5846,7 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Extra_Formals                       (Node28)\n+   --    SPARK_Mode_Pragmas                  (Node32)\n    --    Scope_Depth                         (synth)\n \n    --  E_Subprogram_Type\n@@ -6531,6 +6541,7 @@ package Einfo is\n    function Size_Depends_On_Discriminant        (Id : E) return B;\n    function Size_Known_At_Compile_Time          (Id : E) return B;\n    function Small_Value                         (Id : E) return R;\n+   function SPARK_Mode_Pragmas                  (Id : E) return N;\n    function Spec_Entity                         (Id : E) return E;\n    function Static_Elaboration_Desired          (Id : E) return B;\n    function Static_Initialization               (Id : E) return N;\n@@ -7145,6 +7156,7 @@ package Einfo is\n    procedure Set_Size_Depends_On_Discriminant    (Id : E; V : B := True);\n    procedure Set_Size_Known_At_Compile_Time      (Id : E; V : B := True);\n    procedure Set_Small_Value                     (Id : E; V : R);\n+   procedure Set_SPARK_Mode_Pragmas              (Id : E; V : N);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n    procedure Set_Static_Initialization           (Id : E; V : N);\n@@ -7891,6 +7903,7 @@ package Einfo is\n    pragma Inline (Size_Depends_On_Discriminant);\n    pragma Inline (Size_Known_At_Compile_Time);\n    pragma Inline (Small_Value);\n+   pragma Inline (SPARK_Mode_Pragmas);\n    pragma Inline (Spec_Entity);\n    pragma Inline (Static_Elaboration_Desired);\n    pragma Inline (Static_Initialization);\n@@ -8305,6 +8318,7 @@ package Einfo is\n    pragma Inline (Set_Size_Depends_On_Discriminant);\n    pragma Inline (Set_Size_Known_At_Compile_Time);\n    pragma Inline (Set_Small_Value);\n+   pragma Inline (Set_SPARK_Mode_Pragmas);\n    pragma Inline (Set_Spec_Entity);\n    pragma Inline (Set_Static_Elaboration_Desired);\n    pragma Inline (Set_Static_Initialization);"}, {"sha": "4b0c37c34d04fb5c792cd930410a185eb3e8abbb", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -232,6 +232,7 @@ Implementation Defined Pragmas\n * Pragma Source_File_Name::\n * Pragma Source_File_Name_Project::\n * Pragma Source_Reference::\n+* Pragma SPARK_Mode::\n * Pragma Static_Elaboration_Desired::\n * Pragma Stream_Convert::\n * Pragma Style_Checks::\n@@ -290,6 +291,7 @@ Implementation Defined Aspects\n * Aspect Shared::\n * Aspect Simple_Storage_Pool::\n * Aspect Simple_Storage_Pool_Type::\n+* Aspect SPARK_Mode::\n * Aspect Suppress_Debug_Info::\n * Aspect Test_Case::\n * Aspect Universal_Aliasing::\n@@ -1044,6 +1046,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Source_File_Name::\n * Pragma Source_File_Name_Project::\n * Pragma Source_Reference::\n+* Pragma SPARK_Mode::\n * Pragma Static_Elaboration_Desired::\n * Pragma Stream_Convert::\n * Pragma Style_Checks::\n@@ -5996,6 +5999,80 @@ The second argument must be a string literal, it cannot be a static\n string expression other than a string literal.  This is because its value\n is needed for error messages issued by all phases of the compiler.\n \n+@node Pragma SPARK_Mode\n+@unnumberedsec Pragma SPARK_Mode\n+@findex SPARK_Mode\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma SPARK_Mode [ (On | Off | Auto) ] ;\n+@end smallexample\n+\n+@noindent\n+This pragma is used to designate whether a contract and its implementation must\n+follow the SPARK 2014 programming language syntactic and semantic rules. The\n+pragma is intended for use with formal verification tools and has no effect on\n+the generated code.\n+\n+When used as a configuration pragma over a whole compilation or in a particular\n+compilation unit, it sets the mode of the units involved, in particular:\n+\n+@itemize @bullet\n+\n+@item\n+@code{On}: All entities in the units must follow the SPARK 2014 language, and\n+an error will be generated if not, unless locally overridden by a local\n+SPARK_Mode pragma or aspect. @code{On} is the default mode when pragma\n+SPARK_Mode is used without an argument.\n+\n+@item\n+@code{Off}: The units are considered to be in Ada by default and therefore not\n+part of SPARK 2014 unless overridden locally. These units may be called by SPARK\n+2014 units.\n+\n+@item\n+@code{Auto}: The formal verification tools will automatically detect whether\n+each entity is in SPARK 2014 or in Ada.\n+\n+@end itemize\n+\n+Pragma SPARK_Mode can be used as a local pragma with the following semantics:\n+\n+@itemize @bullet\n+\n+@item\n+Auto cannot be used as a mode argument.\n+\n+@item\n+When the pragma appears immediately within the visible declarations of a\n+package, it marks the whole package (spec and body) in or out of SPARK 2014.\n+\n+@item\n+When the pragma appears immediately within the private declarations of a\n+package, it marks the private part in or out of SPARK 2014.\n+\n+@item\n+When the pragma appears immediately within the declarations of a package body,\n+it marks the whole body in or out of SPARK 2014.\n+\n+@item\n+When the pragma appears immediately within the elaboration statements of a\n+package body, it marks the statements in or out of SPARK 2014.\n+\n+@item\n+When the pragma appears after a subprogram declaration, it marks the whole\n+subprogram (spec and body) in or out of SPARK 2014.\n+\n+@item\n+When the pragma appears immediately within the declarations of a subprogram\n+body, it marks the whole body in or out of SPARK 2014.\n+\n+@item\n+Any other use of the pragma is illegal.\n+\n+@end itemize\n+\n @node Pragma Static_Elaboration_Desired\n @unnumberedsec Pragma Static_Elaboration_Desired\n @findex Static_Elaboration_Desired\n@@ -6048,8 +6125,7 @@ of this type.  It must name a function whose argument type may be any\n subtype, and whose returned type must be the type given as the first\n argument to the pragma.\n \n-The meaning of the @var{Read}\n-parameter is that if a stream attribute directly\n+The meaning of the @var{Read} parameter is that if a stream attribute directly\n or indirectly specifies reading of the type given as the first parameter,\n then a value of the type given as the argument to the Read function is\n read from the stream, and then the Read function is used to convert this\n@@ -7180,6 +7256,7 @@ clause.\n * Aspect Shared::\n * Aspect Simple_Storage_Pool::\n * Aspect Simple_Storage_Pool_Type::\n+* Aspect SPARK_Mode::\n * Aspect Suppress_Debug_Info::\n * Aspect Test_Case::\n * Aspect Universal_Aliasing::\n@@ -7433,6 +7510,12 @@ attribute definition clause.\n @noindent\n This aspect is equivalent to pragma @code{Simple_Storage_Pool_Type}.\n \n+@node Aspect SPARK_Mode\n+@unnumberedsec Aspect SPARK_Mode\n+@findex SPARK_Mode\n+@noindent\n+This aspect is equivalent to pragma @code{SPARK_Mode}.\n+\n @node Aspect Suppress_Debug_Info\n @unnumberedsec Aspect Suppress_Debug_Info\n @findex Suppress_Debug_Info"}, {"sha": "86eb6b3a711e4fccc2f07814611902d3a1ff1c70", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -11611,6 +11611,7 @@ recognized by GNAT:\n    Short_Circuit_And_Or\n    Source_File_Name\n    Source_File_Name_Project\n+   SPARK_Mode\n    Style_Checks\n    Suppress\n    Suppress_Exception_Locations"}, {"sha": "6d65c81383c723093baa4f0cbe6d2ba3b4dd4dac", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -206,28 +206,29 @@ package body Lib.Load is\n       Unum := Units.Last;\n \n       Units.Table (Unum) := (\n-        Cunit            => Cunit,\n-        Cunit_Entity     => Cunit_Entity,\n-        Dependency_Num   => 0,\n-        Dynamic_Elab     => False,\n-        Error_Location   => Sloc (With_Node),\n-        Expected_Unit    => Spec_Name,\n-        Fatal_Error      => True,\n-        Generate_Code    => False,\n-        Has_Allocator    => False,\n-        Has_RACW         => False,\n-        Is_Compiler_Unit => False,\n-        Ident_String     => Empty,\n-        Loading          => False,\n-        Main_Priority    => Default_Main_Priority,\n-        Main_CPU         => Default_Main_CPU,\n-        Munit_Index      => 0,\n-        Serial_Number    => 0,\n-        Source_Index     => No_Source_File,\n-        Unit_File_Name   => Get_File_Name (Spec_Name, Subunit => False),\n-        Unit_Name        => Spec_Name,\n-        Version          => 0,\n-        OA_Setting       => 'O');\n+        Cunit             => Cunit,\n+        Cunit_Entity      => Cunit_Entity,\n+        Dependency_Num    => 0,\n+        Dynamic_Elab      => False,\n+        Error_Location    => Sloc (With_Node),\n+        Expected_Unit     => Spec_Name,\n+        Fatal_Error       => True,\n+        Generate_Code     => False,\n+        Has_Allocator     => False,\n+        Has_RACW          => False,\n+        Is_Compiler_Unit  => False,\n+        Ident_String      => Empty,\n+        Loading           => False,\n+        Main_Priority     => Default_Main_Priority,\n+        Main_CPU          => Default_Main_CPU,\n+        Munit_Index       => 0,\n+        Serial_Number     => 0,\n+        Source_Index      => No_Source_File,\n+        Unit_File_Name    => Get_File_Name (Spec_Name, Subunit => False),\n+        Unit_Name         => Spec_Name,\n+        Version           => 0,\n+        OA_Setting        => 'O',\n+        SPARK_Mode_Pragma => Empty);\n \n       Set_Comes_From_Source_Default (Save_CS);\n       Set_Error_Posted (Cunit_Entity);\n@@ -312,28 +313,29 @@ package body Lib.Load is\n          end if;\n \n          Units.Table (Main_Unit) := (\n-           Cunit            => Empty,\n-           Cunit_Entity     => Empty,\n-           Dependency_Num   => 0,\n-           Dynamic_Elab     => False,\n-           Error_Location   => No_Location,\n-           Expected_Unit    => No_Unit_Name,\n-           Fatal_Error      => False,\n-           Generate_Code    => False,\n-           Has_Allocator    => False,\n-           Has_RACW         => False,\n-           Is_Compiler_Unit => False,\n-           Ident_String     => Empty,\n-           Loading          => True,\n-           Main_Priority    => Default_Main_Priority,\n-           Main_CPU         => Default_Main_CPU,\n-           Munit_Index      => 0,\n-           Serial_Number    => 0,\n-           Source_Index     => Main_Source_File,\n-           Unit_File_Name   => Fname,\n-           Unit_Name        => No_Unit_Name,\n-           Version          => Version,\n-           OA_Setting       => 'O');\n+           Cunit             => Empty,\n+           Cunit_Entity      => Empty,\n+           Dependency_Num    => 0,\n+           Dynamic_Elab      => False,\n+           Error_Location    => No_Location,\n+           Expected_Unit     => No_Unit_Name,\n+           Fatal_Error       => False,\n+           Generate_Code     => False,\n+           Has_Allocator     => False,\n+           Has_RACW          => False,\n+           Is_Compiler_Unit  => False,\n+           Ident_String      => Empty,\n+           Loading           => True,\n+           Main_Priority     => Default_Main_Priority,\n+           Main_CPU          => Default_Main_CPU,\n+           Munit_Index       => 0,\n+           Serial_Number     => 0,\n+           Source_Index      => Main_Source_File,\n+           Unit_File_Name    => Fname,\n+           Unit_Name         => No_Unit_Name,\n+           Version           => Version,\n+           OA_Setting        => 'O',\n+           SPARK_Mode_Pragma => Empty);\n       end if;\n    end Load_Main_Source;\n \n@@ -675,28 +677,29 @@ package body Lib.Load is\n \n          if Src_Ind /= No_Source_File then\n             Units.Table (Unum) := (\n-              Cunit            => Empty,\n-              Cunit_Entity     => Empty,\n-              Dependency_Num   => 0,\n-              Dynamic_Elab     => False,\n-              Error_Location   => Sloc (Error_Node),\n-              Expected_Unit    => Uname_Actual,\n-              Fatal_Error      => False,\n-              Generate_Code    => False,\n-              Has_Allocator    => False,\n-              Has_RACW         => False,\n-              Is_Compiler_Unit => False,\n-              Ident_String     => Empty,\n-              Loading          => True,\n-              Main_Priority    => Default_Main_Priority,\n-              Main_CPU         => Default_Main_CPU,\n-              Munit_Index      => 0,\n-              Serial_Number    => 0,\n-              Source_Index     => Src_Ind,\n-              Unit_File_Name   => Fname,\n-              Unit_Name        => Uname_Actual,\n-              Version          => Source_Checksum (Src_Ind),\n-              OA_Setting       => 'O');\n+              Cunit             => Empty,\n+              Cunit_Entity      => Empty,\n+              Dependency_Num    => 0,\n+              Dynamic_Elab      => False,\n+              Error_Location    => Sloc (Error_Node),\n+              Expected_Unit     => Uname_Actual,\n+              Fatal_Error       => False,\n+              Generate_Code     => False,\n+              Has_Allocator     => False,\n+              Has_RACW          => False,\n+              Is_Compiler_Unit  => False,\n+              Ident_String      => Empty,\n+              Loading           => True,\n+              Main_Priority     => Default_Main_Priority,\n+              Main_CPU          => Default_Main_CPU,\n+              Munit_Index       => 0,\n+              Serial_Number     => 0,\n+              Source_Index      => Src_Ind,\n+              Unit_File_Name    => Fname,\n+              Unit_Name         => Uname_Actual,\n+              Version           => Source_Checksum (Src_Ind),\n+              OA_Setting        => 'O',\n+              SPARK_Mode_Pragma => Empty);\n \n             --  Parse the new unit\n "}, {"sha": "e5c0912ad966243eb34974c21ff222f193f822b9", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -71,28 +71,29 @@ package body Lib.Writ is\n    begin\n       Units.Increment_Last;\n       Units.Table (Units.Last) :=\n-        (Unit_File_Name   => File_Name (S),\n-         Unit_Name        => No_Unit_Name,\n-         Expected_Unit    => No_Unit_Name,\n-         Source_Index     => S,\n-         Cunit            => Empty,\n-         Cunit_Entity     => Empty,\n-         Dependency_Num   => 0,\n-         Dynamic_Elab     => False,\n-         Fatal_Error      => False,\n-         Generate_Code    => False,\n-         Has_Allocator    => False,\n-         Has_RACW         => False,\n-         Is_Compiler_Unit => False,\n-         Ident_String     => Empty,\n-         Loading          => False,\n-         Main_Priority    => -1,\n-         Main_CPU         => -1,\n-         Munit_Index      => 0,\n-         Serial_Number    => 0,\n-         Version          => 0,\n-         Error_Location   => No_Location,\n-         OA_Setting       => 'O');\n+        (Unit_File_Name    => File_Name (S),\n+         Unit_Name         => No_Unit_Name,\n+         Expected_Unit     => No_Unit_Name,\n+         Source_Index      => S,\n+         Cunit             => Empty,\n+         Cunit_Entity      => Empty,\n+         Dependency_Num    => 0,\n+         Dynamic_Elab      => False,\n+         Fatal_Error       => False,\n+         Generate_Code     => False,\n+         Has_Allocator     => False,\n+         Has_RACW          => False,\n+         Is_Compiler_Unit  => False,\n+         Ident_String      => Empty,\n+         Loading           => False,\n+         Main_Priority     => -1,\n+         Main_CPU          => -1,\n+         Munit_Index       => 0,\n+         Serial_Number     => 0,\n+         Version           => 0,\n+         Error_Location    => No_Location,\n+         OA_Setting        => 'O',\n+         SPARK_Mode_Pragma => Empty);\n    end Add_Preprocessing_Dependency;\n \n    ------------------------------\n@@ -128,28 +129,29 @@ package body Lib.Writ is\n \n       Units.Increment_Last;\n       Units.Table (Units.Last) := (\n-        Unit_File_Name   => System_Fname,\n-        Unit_Name        => System_Uname,\n-        Expected_Unit    => System_Uname,\n-        Source_Index     => System_Source_File_Index,\n-        Cunit            => Empty,\n-        Cunit_Entity     => Empty,\n-        Dependency_Num   => 0,\n-        Dynamic_Elab     => False,\n-        Fatal_Error      => False,\n-        Generate_Code    => False,\n-        Has_Allocator    => False,\n-        Has_RACW         => False,\n-        Is_Compiler_Unit => False,\n-        Ident_String     => Empty,\n-        Loading          => False,\n-        Main_Priority    => -1,\n-        Main_CPU         => -1,\n-        Munit_Index      => 0,\n-        Serial_Number    => 0,\n-        Version          => 0,\n-        Error_Location   => No_Location,\n-        OA_Setting       => 'O');\n+        Unit_File_Name    => System_Fname,\n+        Unit_Name         => System_Uname,\n+        Expected_Unit     => System_Uname,\n+        Source_Index      => System_Source_File_Index,\n+        Cunit             => Empty,\n+        Cunit_Entity      => Empty,\n+        Dependency_Num    => 0,\n+        Dynamic_Elab      => False,\n+        Fatal_Error       => False,\n+        Generate_Code     => False,\n+        Has_Allocator     => False,\n+        Has_RACW          => False,\n+        Is_Compiler_Unit  => False,\n+        Ident_String      => Empty,\n+        Loading           => False,\n+        Main_Priority     => -1,\n+        Main_CPU          => -1,\n+        Munit_Index       => 0,\n+        Serial_Number     => 0,\n+        Version           => 0,\n+        Error_Location    => No_Location,\n+        OA_Setting        => 'O',\n+        SPARK_Mode_Pragma => Empty);\n \n       --  Parse system.ads so that the checksum is set right\n       --  Style checks are not applied."}, {"sha": "e220b20e08e87d28128433310cd1dba4dd57bd11", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -166,6 +166,11 @@ package body Lib is\n       return Units.Table (U).Source_Index;\n    end Source_Index;\n \n+   function SPARK_Mode_Pragma (U : Unit_Number_Type) return Node_Id is\n+   begin\n+      return Units.Table (U).SPARK_Mode_Pragma;\n+   end SPARK_Mode_Pragma;\n+\n    function Unit_File_Name (U : Unit_Number_Type) return File_Name_Type is\n    begin\n       return Units.Table (U).Unit_File_Name;\n@@ -254,6 +259,11 @@ package body Lib is\n       Units.Table (U).OA_Setting := C;\n    end Set_OA_Setting;\n \n+   procedure Set_SPARK_Mode_Pragma (U : Unit_Number_Type; N : Node_Id) is\n+   begin\n+      Units.Table (U).SPARK_Mode_Pragma := N;\n+   end Set_SPARK_Mode_Pragma;\n+\n    procedure Set_Unit_Name (U : Unit_Number_Type; N : Unit_Name_Type) is\n    begin\n       Units.Table (U).Unit_Name := N;"}, {"sha": "eb10a8bd21021f471378e7fa6a886604b6272948", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 126, "deletions": 116, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -265,38 +265,6 @@ package Lib is\n    --  The first entry in the table, subscript Main_Unit, is for the main file.\n    --  Each entry in this units table contains the following data.\n \n-   --    Unit_File_Name\n-   --      The name of the source file containing the unit. Set when the entry\n-   --      is created by a call to Lib.Load, and then cannot be changed.\n-\n-   --    Source_Index\n-   --      The index in the source file table of the corresponding source file.\n-   --      Set when the entry is created by a call to Lib.Load and then cannot\n-   --      be changed.\n-\n-   --    Munit_Index\n-   --      The index of the unit within the file for multiple unit per file\n-   --      mode. Set to zero in normal single unit per file mode.\n-\n-   --    Error_Location\n-   --      This is copied from the Sloc field of the Enode argument passed\n-   --      to Load_Unit. It refers to the enclosing construct which caused\n-   --      this unit to be loaded, e.g. most typically the with clause that\n-   --      referenced the unit, and is used for error handling in Par.Load.\n-\n-   --    Expected_Unit\n-   --      This is the expected unit name for a file other than the main unit,\n-   --      since these are cases where we load the unit using Lib.Load and we\n-   --      know the unit that is expected. It must be the same as Unit_Name\n-   --      if it is set (see test in Par.Load). Expected_Unit is set to\n-   --      No_Name for the main unit.\n-\n-   --    Unit_Name\n-   --      The name of the unit. Initialized to No_Name by Lib.Load, and then\n-   --      set by the parser when the unit is parsed to the unit name actually\n-   --      found in the file (which should, in the absence of errors) be the\n-   --      same name as Expected_Unit.\n-\n    --    Cunit\n    --      Pointer to the N_Compilation_Unit node. Initially set to Empty by\n    --      Lib.Load, and then reset to the required node by the parser when\n@@ -320,6 +288,19 @@ package Lib is\n    --      checks specified (as the result of using the -gnatE compilation\n    --      option or a pragma Elaboration_Checks (Dynamic).\n \n+   --    Error_Location\n+   --      This is copied from the Sloc field of the Enode argument passed\n+   --      to Load_Unit. It refers to the enclosing construct which caused\n+   --      this unit to be loaded, e.g. most typically the with clause that\n+   --      referenced the unit, and is used for error handling in Par.Load.\n+\n+   --    Expected_Unit\n+   --      This is the expected unit name for a file other than the main unit,\n+   --      since these are cases where we load the unit using Lib.Load and we\n+   --      know the unit that is expected. It must be the same as Unit_Name\n+   --      if it is set (see test in Par.Load). Expected_Unit is set to\n+   --      No_Name for the main unit.\n+\n    --    Fatal_Error\n    --      A flag that is initialized to False, and gets set to True if a fatal\n    --      error occurs during the processing of a unit. A fatal error is one\n@@ -335,6 +316,10 @@ package Lib is\n    --      code is to be generated. This includes the unit explicitly compiled,\n    --      together with its specification, and any subunits.\n \n+   --    Has_Allocator\n+   --      This flag is set if a subprogram unit has an allocator after the\n+   --      BEGIN (it is used to set the AB flag in the M ALI line).\n+\n    --    Has_RACW\n    --      A Boolean flag, initially set to False when a unit entry is created,\n    --      and set to True if the unit defines a remote access to class wide\n@@ -366,9 +351,9 @@ package Lib is\n    --      that the default affinity is to be used (and is also used for\n    --      entries that do not correspond to possible main programs).\n \n-   --    Has_Allocator\n-   --      This flag is set if a subprogram unit has an allocator after the\n-   --      BEGIN (it is used to set the AB flag in the M ALI line).\n+   --    Munit_Index\n+   --      The index of the unit within the file for multiple unit per file\n+   --      mode. Set to zero in normal single unit per file mode.\n \n    --    OA_Setting\n    --      This is a character field containing L if Optimize_Alignment mode\n@@ -381,6 +366,25 @@ package Lib is\n    --      routine which increments the current value and returns it. This\n    --      serial number is separate for each unit.\n \n+   --    Source_Index\n+   --      The index in the source file table of the corresponding source file.\n+   --      Set when the entry is created by a call to Lib.Load and then cannot\n+   --      be changed.\n+\n+   --    SPARK_Mode_Pragma\n+   --      Pointer to the configuration pragma SPARK_Mode that applies to the\n+   --      whole unit.\n+\n+   --    Unit_File_Name\n+   --      The name of the source file containing the unit. Set when the entry\n+   --      is created by a call to Lib.Load, and then cannot be changed.\n+\n+   --    Unit_Name\n+   --      The name of the unit. Initialized to No_Name by Lib.Load, and then\n+   --      set by the parser when the unit is parsed to the unit name actually\n+   --      found in the file (which should, in the absence of errors) be the\n+   --      same name as Expected_Unit.\n+\n    --    Version\n    --      This field holds the version of the unit, which is computed as\n    --      the exclusive or of the checksums of this unit, and all its\n@@ -404,43 +408,45 @@ package Lib is\n    Default_Main_CPU : constant Int := -1;\n    --  Value used in Main_CPU field to indicate default main affinity\n \n-   function Cunit            (U : Unit_Number_Type) return Node_Id;\n-   function Cunit_Entity     (U : Unit_Number_Type) return Entity_Id;\n-   function Dependency_Num   (U : Unit_Number_Type) return Nat;\n-   function Dynamic_Elab     (U : Unit_Number_Type) return Boolean;\n-   function Error_Location   (U : Unit_Number_Type) return Source_Ptr;\n-   function Expected_Unit    (U : Unit_Number_Type) return Unit_Name_Type;\n-   function Fatal_Error      (U : Unit_Number_Type) return Boolean;\n-   function Generate_Code    (U : Unit_Number_Type) return Boolean;\n-   function Ident_String     (U : Unit_Number_Type) return Node_Id;\n-   function Has_Allocator    (U : Unit_Number_Type) return Boolean;\n-   function Has_RACW         (U : Unit_Number_Type) return Boolean;\n-   function Is_Compiler_Unit (U : Unit_Number_Type) return Boolean;\n-   function Loading          (U : Unit_Number_Type) return Boolean;\n-   function Main_CPU         (U : Unit_Number_Type) return Int;\n-   function Main_Priority    (U : Unit_Number_Type) return Int;\n-   function Munit_Index      (U : Unit_Number_Type) return Nat;\n-   function OA_Setting       (U : Unit_Number_Type) return Character;\n-   function Source_Index     (U : Unit_Number_Type) return Source_File_Index;\n-   function Unit_File_Name   (U : Unit_Number_Type) return File_Name_Type;\n-   function Unit_Name        (U : Unit_Number_Type) return Unit_Name_Type;\n+   function Cunit             (U : Unit_Number_Type) return Node_Id;\n+   function Cunit_Entity      (U : Unit_Number_Type) return Entity_Id;\n+   function Dependency_Num    (U : Unit_Number_Type) return Nat;\n+   function Dynamic_Elab      (U : Unit_Number_Type) return Boolean;\n+   function Error_Location    (U : Unit_Number_Type) return Source_Ptr;\n+   function Expected_Unit     (U : Unit_Number_Type) return Unit_Name_Type;\n+   function Fatal_Error       (U : Unit_Number_Type) return Boolean;\n+   function Generate_Code     (U : Unit_Number_Type) return Boolean;\n+   function Ident_String      (U : Unit_Number_Type) return Node_Id;\n+   function Has_Allocator     (U : Unit_Number_Type) return Boolean;\n+   function Has_RACW          (U : Unit_Number_Type) return Boolean;\n+   function Is_Compiler_Unit  (U : Unit_Number_Type) return Boolean;\n+   function Loading           (U : Unit_Number_Type) return Boolean;\n+   function Main_CPU          (U : Unit_Number_Type) return Int;\n+   function Main_Priority     (U : Unit_Number_Type) return Int;\n+   function Munit_Index       (U : Unit_Number_Type) return Nat;\n+   function OA_Setting        (U : Unit_Number_Type) return Character;\n+   function Source_Index      (U : Unit_Number_Type) return Source_File_Index;\n+   function SPARK_Mode_Pragma (U : Unit_Number_Type) return Node_Id;\n+   function Unit_File_Name    (U : Unit_Number_Type) return File_Name_Type;\n+   function Unit_Name         (U : Unit_Number_Type) return Unit_Name_Type;\n    --  Get value of named field from given units table entry\n \n-   procedure Set_Cunit            (U : Unit_Number_Type; N : Node_Id);\n-   procedure Set_Cunit_Entity     (U : Unit_Number_Type; E : Entity_Id);\n-   procedure Set_Dynamic_Elab     (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Error_Location   (U : Unit_Number_Type; W : Source_Ptr);\n-   procedure Set_Fatal_Error      (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Generate_Code    (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Has_RACW         (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Has_Allocator    (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Is_Compiler_Unit (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Ident_String     (U : Unit_Number_Type; N : Node_Id);\n-   procedure Set_Loading          (U : Unit_Number_Type; B : Boolean := True);\n-   procedure Set_Main_CPU         (U : Unit_Number_Type; P : Int);\n-   procedure Set_Main_Priority    (U : Unit_Number_Type; P : Int);\n-   procedure Set_OA_Setting       (U : Unit_Number_Type; C : Character);\n-   procedure Set_Unit_Name        (U : Unit_Number_Type; N : Unit_Name_Type);\n+   procedure Set_Cunit             (U : Unit_Number_Type; N : Node_Id);\n+   procedure Set_Cunit_Entity      (U : Unit_Number_Type; E : Entity_Id);\n+   procedure Set_Dynamic_Elab      (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Error_Location    (U : Unit_Number_Type; W : Source_Ptr);\n+   procedure Set_Fatal_Error       (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Generate_Code     (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Has_RACW          (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Has_Allocator     (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Is_Compiler_Unit  (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Ident_String      (U : Unit_Number_Type; N : Node_Id);\n+   procedure Set_Loading           (U : Unit_Number_Type; B : Boolean := True);\n+   procedure Set_Main_CPU          (U : Unit_Number_Type; P : Int);\n+   procedure Set_Main_Priority     (U : Unit_Number_Type; P : Int);\n+   procedure Set_OA_Setting        (U : Unit_Number_Type; C : Character);\n+   procedure Set_SPARK_Mode_Pragma (U : Unit_Number_Type; N : Node_Id);\n+   procedure Set_Unit_Name         (U : Unit_Number_Type; N : Unit_Name_Type);\n    --  Set value of named field for given units table entry. Note that we\n    --  do not have an entry for each possible field, since some of the fields\n    --  can only be set by specialized interfaces (defined below).\n@@ -707,66 +713,70 @@ private\n    pragma Inline (Set_Main_CPU);\n    pragma Inline (Set_Main_Priority);\n    pragma Inline (Set_OA_Setting);\n+   pragma Inline (Set_SPARK_Mode_Pragma);\n    pragma Inline (Set_Unit_Name);\n    pragma Inline (Source_Index);\n+   pragma Inline (SPARK_Mode_Pragma);\n    pragma Inline (Unit_File_Name);\n    pragma Inline (Unit_Name);\n \n    type Unit_Record is record\n-      Unit_File_Name   : File_Name_Type;\n-      Unit_Name        : Unit_Name_Type;\n-      Munit_Index      : Nat;\n-      Expected_Unit    : Unit_Name_Type;\n-      Source_Index     : Source_File_Index;\n-      Cunit            : Node_Id;\n-      Cunit_Entity     : Entity_Id;\n-      Dependency_Num   : Int;\n-      Ident_String     : Node_Id;\n-      Main_Priority    : Int;\n-      Main_CPU         : Int;\n-      Serial_Number    : Nat;\n-      Version          : Word;\n-      Error_Location   : Source_Ptr;\n-      Fatal_Error      : Boolean;\n-      Generate_Code    : Boolean;\n-      Has_RACW         : Boolean;\n-      Is_Compiler_Unit : Boolean;\n-      Dynamic_Elab     : Boolean;\n-      Loading          : Boolean;\n-      Has_Allocator    : Boolean;\n-      OA_Setting       : Character;\n+      Unit_File_Name    : File_Name_Type;\n+      Unit_Name         : Unit_Name_Type;\n+      Munit_Index       : Nat;\n+      Expected_Unit     : Unit_Name_Type;\n+      Source_Index      : Source_File_Index;\n+      Cunit             : Node_Id;\n+      Cunit_Entity      : Entity_Id;\n+      Dependency_Num    : Int;\n+      Ident_String      : Node_Id;\n+      Main_Priority     : Int;\n+      Main_CPU          : Int;\n+      Serial_Number     : Nat;\n+      Version           : Word;\n+      Error_Location    : Source_Ptr;\n+      Fatal_Error       : Boolean;\n+      Generate_Code     : Boolean;\n+      Has_RACW          : Boolean;\n+      Is_Compiler_Unit  : Boolean;\n+      Dynamic_Elab      : Boolean;\n+      Loading           : Boolean;\n+      Has_Allocator     : Boolean;\n+      OA_Setting        : Character;\n+      SPARK_Mode_Pragma : Node_Id;\n    end record;\n \n    --  The following representation clause ensures that the above record\n    --  has no holes. We do this so that when instances of this record are\n    --  written by Tree_Gen, we do not write uninitialized values to the file.\n \n    for Unit_Record use record\n-      Unit_File_Name   at  0 range 0 .. 31;\n-      Unit_Name        at  4 range 0 .. 31;\n-      Munit_Index      at  8 range 0 .. 31;\n-      Expected_Unit    at 12 range 0 .. 31;\n-      Source_Index     at 16 range 0 .. 31;\n-      Cunit            at 20 range 0 .. 31;\n-      Cunit_Entity     at 24 range 0 .. 31;\n-      Dependency_Num   at 28 range 0 .. 31;\n-      Ident_String     at 32 range 0 .. 31;\n-      Main_Priority    at 36 range 0 .. 31;\n-      Main_CPU         at 40 range 0 .. 31;\n-      Serial_Number    at 44 range 0 .. 31;\n-      Version          at 48 range 0 .. 31;\n-      Error_Location   at 52 range 0 .. 31;\n-      Fatal_Error      at 56 range 0 ..  7;\n-      Generate_Code    at 57 range 0 ..  7;\n-      Has_RACW         at 58 range 0 ..  7;\n-      Dynamic_Elab     at 59 range 0 ..  7;\n-      Is_Compiler_Unit at 60 range 0 ..  7;\n-      OA_Setting       at 61 range 0 ..  7;\n-      Loading          at 62 range 0 ..  7;\n-      Has_Allocator    at 63 range 0 ..  7;\n+      Unit_File_Name    at  0 range 0 .. 31;\n+      Unit_Name         at  4 range 0 .. 31;\n+      Munit_Index       at  8 range 0 .. 31;\n+      Expected_Unit     at 12 range 0 .. 31;\n+      Source_Index      at 16 range 0 .. 31;\n+      Cunit             at 20 range 0 .. 31;\n+      Cunit_Entity      at 24 range 0 .. 31;\n+      Dependency_Num    at 28 range 0 .. 31;\n+      Ident_String      at 32 range 0 .. 31;\n+      Main_Priority     at 36 range 0 .. 31;\n+      Main_CPU          at 40 range 0 .. 31;\n+      Serial_Number     at 44 range 0 .. 31;\n+      Version           at 48 range 0 .. 31;\n+      Error_Location    at 52 range 0 .. 31;\n+      Fatal_Error       at 56 range 0 ..  7;\n+      Generate_Code     at 57 range 0 ..  7;\n+      Has_RACW          at 58 range 0 ..  7;\n+      Dynamic_Elab      at 59 range 0 ..  7;\n+      Is_Compiler_Unit  at 60 range 0 ..  7;\n+      OA_Setting        at 61 range 0 ..  7;\n+      Loading           at 62 range 0 ..  7;\n+      Has_Allocator     at 63 range 0 ..  7;\n+      SPARK_Mode_Pragma at 64 range 0 .. 31;\n    end record;\n \n-   for Unit_Record'Size use 64 * 8;\n+   for Unit_Record'Size use 68 * 8;\n    --  This ensures that we did not leave out any fields\n \n    package Units is new Table.Table ("}, {"sha": "a4cbafd38880a8dd73ac4b544932f6111c7a949e", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1970,6 +1970,21 @@ package Opt is\n    -- Modes for Formal Verification --\n    -----------------------------------\n \n+   Frame_Condition_Mode : Boolean := False;\n+   --  Specific mode to be used in combination with SPARK_Mode. If set to\n+   --  true, ALI files containing the frame conditions (global effects) are\n+   --  generated, and Why files are *not* generated. If not true, Why files\n+   --  are generated. Set by debug flag -gnatd.G.\n+\n+   Formal_Extensions : Boolean := False;\n+   --  When this flag is set, new aspects/pragmas/attributes are accepted,\n+   --  whose main purpose is to facilitate formal verification. Set by debug\n+   --  flag -gnatd.V.\n+\n+   Global_SPARK_Mode : SPARK_Mode_Id := None;\n+   --  The mode applicable to the whole compilation. The global mode can be set\n+   --  in a configuration file such as gnat.adc.\n+\n    SPARK_Mode : Boolean := False;\n    --  Specific compiling mode targeting formal verification through the\n    --  generation of Why code for those parts of the input code that belong to\n@@ -1978,22 +1993,11 @@ package Opt is\n    --  from the SPARK restriction defined in GNAT to detect violations of a\n    --  subset of SPARK 2005 rules.\n \n-   Frame_Condition_Mode : Boolean := False;\n-   --  Specific mode to be used in combination with SPARK_Mode. If set to\n-   --  true, ALI files containing the frame conditions (global effects) are\n-   --  generated, and Why files are *not* generated. If not true, Why files\n-   --  are generated. Set by debug flag -gnatd.G.\n-\n    SPARK_Strict_Mode : Boolean := False;\n    --  Interpret compiler permissions as strictly as possible. E.g. base ranges\n    --  for integers are limited to the strict minimum with this option. Set by\n    --  debug flag -gnatd.D.\n \n-   Formal_Extensions : Boolean := False;\n-   --  When this flag is set, new aspects/pragmas/attributes are accepted,\n-   --  whose main purpose is to facilitate formal verification. Set by debug\n-   --  flag -gnatd.V.\n-\n    function Full_Expander_Active return Boolean;\n    pragma Inline (Full_Expander_Active);\n    --  Returns the value of (Expander_Active and not SPARK_Mode). This \"flag\""}, {"sha": "07242fb45963d54c0a9e218c54b92b4f6c7cc135", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1262,6 +1262,7 @@ begin\n            Pragma_Short_Circuit_And_Or           |\n            Pragma_Short_Descriptors              |\n            Pragma_Simple_Storage_Pool_Type       |\n+           Pragma_SPARK_Mode                     |\n            Pragma_Storage_Size                   |\n            Pragma_Storage_Unit                   |\n            Pragma_Static_Elaboration_Desired     |"}, {"sha": "5378fa3ff74fba37a0fd4b29f995695b80eec5e5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1659,6 +1659,16 @@ package body Sem_Ch13 is\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n+               --  SPARK_Mode\n+\n+               when Aspect_SPARK_Mode =>\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_SPARK_Mode);\n+                  Delay_Required := False;\n+\n                --  Relative_Deadline\n \n                when Aspect_Relative_Deadline =>\n@@ -7390,6 +7400,7 @@ package body Sem_Ch13 is\n               Aspect_Postcondition        |\n               Aspect_Pre                  |\n               Aspect_Precondition         |\n+              Aspect_SPARK_Mode           |\n               Aspect_Test_Case     =>\n             raise Program_Error;\n "}, {"sha": "36c3d7fc2b0a003cc507709221c6027c485bf38c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 431, "deletions": 1, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -213,6 +213,11 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n+   function Get_SPARK_Mode_Id (N : Name_Id) return SPARK_Mode_Id;\n+   --  Subsidiary to the analysis of pragma SPARK_Mode as well as subprogram\n+   --  Get_SPARK_Mode_Id. Convert a name into a corresponding value of type\n+   --  SPARK_Mode_Id.\n+\n    function Original_Name (N : Node_Id) return Name_Id;\n    --  N is a pragma node or aspect specification node. This function returns\n    --  the name of the pragma or aspect in original source form, taking into\n@@ -16315,6 +16320,351 @@ package body Sem_Prag is\n          when Pragma_Source_Reference =>\n             GNAT_Pragma;\n \n+         ----------------\n+         -- SPARK_Mode --\n+         ----------------\n+\n+         --  pragma SPARK_Mode (On | Off | Auto);\n+\n+         when Pragma_SPARK_Mode => SPARK_Mod : declare\n+            procedure Chain_Pragma (Context : Entity_Id; Prag : Node_Id);\n+            --  Associate a SPARK_Mode pragma with the context where it lives.\n+            --  If the context is a package spec or a body, the routine checks\n+            --  the consistency between modes of visible/private declarations\n+            --  and body declarations/statements.\n+\n+            procedure Check_Conformance\n+              (Governing_Id : Entity_Id;\n+               New_Id       : Entity_Id);\n+            --  Verify the \"monotonicity\" of SPARK modes between two entities.\n+            --  The order of modes is Off < Auto < On. Governing_Id establishes\n+            --  the mode of the context. New_Id attempts to redefine the known\n+            --  mode.\n+\n+            procedure Check_Pragma_Conformance\n+              (Governing_Mode : Node_Id;\n+               New_Mode       : Node_Id);\n+            --  Verify the \"monotonicity\" of two SPARK_Mode pragmas. The order\n+            --  of modes is Off < Auto < On. Governing_Mode is the established\n+            --  mode dictated by the context. New_Mode attempts to redefine the\n+            --  governing mode.\n+\n+            function Get_SPARK_Mode_Name (Id : SPARK_Mode_Id) return Name_Id;\n+            --  Convert a value of type SPARK_Mode_Id into a corresponding name\n+\n+            procedure Redefinition_Error (Mode : SPARK_Mode_Id);\n+            --  Emit an error on an attempt to redefine existing mode Mode. The\n+            --  message is associated with the first argument of the current\n+            --  pragma.\n+\n+            procedure Redefinition_Error (Prag : Node_Id);\n+            --  Emit an error on an attempt to redefine the mode of Prag. The\n+            --  message is associated with the first argument of the current\n+            --  pragma.\n+\n+            ------------------\n+            -- Chain_Pragma --\n+            ------------------\n+\n+            procedure Chain_Pragma (Context : Entity_Id; Prag : Node_Id) is\n+               Existing_Prag : constant Node_Id :=\n+                                 SPARK_Mode_Pragmas (Context);\n+            begin\n+               --  The context does not have a prior mode defined\n+\n+               if No (Existing_Prag) then\n+                  Set_SPARK_Mode_Pragmas (Context, Prag);\n+\n+               --  Chain the new mode on the list of SPARK_Mode pragmas. Verify\n+               --  the consistency between the existing mode and the new one.\n+\n+               else\n+                  Set_Next_Pragma (Existing_Prag, Prag);\n+\n+                  Check_Pragma_Conformance\n+                    (Governing_Mode => Existing_Prag,\n+                     New_Mode       => Prag);\n+               end if;\n+            end Chain_Pragma;\n+\n+            -----------------------\n+            -- Check_Conformance --\n+            -----------------------\n+\n+            procedure Check_Conformance\n+              (Governing_Id : Entity_Id;\n+               New_Id       : Entity_Id)\n+            is\n+               Gov_Prag : constant Node_Id :=\n+                            SPARK_Mode_Pragmas (Governing_Id);\n+               New_Prag : constant Node_Id := SPARK_Mode_Pragmas (New_Id);\n+\n+            begin\n+               --  Nothing to do when one or both entities lack a mode\n+\n+               if No (Gov_Prag) or else No (New_Prag) then\n+                  return;\n+               end if;\n+\n+               --  Do not compare the modes of a package spec and body when the\n+               --  spec mode appears in the private part. In this case the spec\n+               --  mode does not affect the body.\n+\n+               if Ekind_In (Governing_Id, E_Generic_Package, E_Package)\n+                 and then Ekind (New_Id) = E_Package_Body\n+                 and then Is_Private_SPARK_Mode (Gov_Prag)\n+               then\n+                  null;\n+\n+               --  Test the pragmas\n+\n+               else\n+                  Check_Pragma_Conformance\n+                    (Governing_Mode => Gov_Prag,\n+                     New_Mode       => New_Prag);\n+               end if;\n+            end Check_Conformance;\n+\n+            ------------------------------\n+            -- Check_Pragma_Conformance --\n+            ------------------------------\n+\n+            procedure Check_Pragma_Conformance\n+              (Governing_Mode : Node_Id;\n+               New_Mode       : Node_Id)\n+            is\n+               Gov_M : constant SPARK_Mode_Id :=\n+                         Get_SPARK_Mode_Id (Governing_Mode);\n+               New_M : constant SPARK_Mode_Id := Get_SPARK_Mode_Id (New_Mode);\n+\n+            begin\n+               --  The new mode is less restrictive than the established mode\n+\n+               if Gov_M < New_M then\n+                  Error_Msg_Name_1 := Get_SPARK_Mode_Name (New_M);\n+                  Error_Msg_N (\"cannot define 'S'P'A'R'K mode %\", New_Mode);\n+\n+                  Error_Msg_Name_1 := Get_SPARK_Mode_Name (Gov_M);\n+                  Error_Msg_Sloc   := Sloc (Governing_Mode);\n+                  Error_Msg_N\n+                    (\"\\mode is less restrictive than mode % defined #\",\n+                     New_Mode);\n+               end if;\n+            end Check_Pragma_Conformance;\n+\n+            -------------------------\n+            -- Get_SPARK_Mode_Name --\n+            -------------------------\n+\n+            function Get_SPARK_Mode_Name (Id : SPARK_Mode_Id) return Name_Id is\n+            begin\n+               if Id = SPARK_On then\n+                  return Name_On;\n+               elsif Id = SPARK_Off then\n+                  return Name_Off;\n+               elsif Id = SPARK_Auto then\n+                  return Name_Auto;\n+\n+               --  Mode \"None\" should never be used in error message generation\n+\n+               else\n+                  raise Program_Error;\n+               end if;\n+            end Get_SPARK_Mode_Name;\n+\n+            ------------------------\n+            -- Redefinition_Error --\n+            ------------------------\n+\n+            procedure Redefinition_Error (Mode : SPARK_Mode_Id) is\n+            begin\n+               Error_Msg_Name_1 := Get_SPARK_Mode_Name (Mode);\n+               Error_Msg_N\n+                 (\"cannot redefine 'S'P'A'R'K mode, already set to %\", Arg1);\n+            end Redefinition_Error;\n+\n+            ------------------------\n+            -- Redefinition_Error --\n+            ------------------------\n+\n+            procedure Redefinition_Error (Prag : Node_Id) is\n+               Mode : constant Name_Id :=\n+                        Chars (Get_Pragma_Arg (First\n+                         (Pragma_Argument_Associations (Prag))));\n+            begin\n+               Error_Msg_Name_1 := Mode;\n+               Error_Msg_Sloc   := Sloc (Prag);\n+               Error_Msg_N\n+                 (\"cannot redefine 'S'P'A'R'K mode, already set to % #\", Arg1);\n+            end Redefinition_Error;\n+\n+            --  Local variables\n+\n+            Body_Id   : Entity_Id;\n+            Context   : Node_Id;\n+            Mode      : Name_Id;\n+            Mode_Id   : SPARK_Mode_Id;\n+            Spec_Id   : Entity_Id;\n+            Stmt      : Node_Id;\n+            Unit_Prag : Node_Id;\n+\n+         --  Start of processing for SPARK_Mode\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_At_Most_N_Arguments (1);\n+\n+            --  Check the legality of the mode\n+\n+            if Arg_Count = 1 then\n+               Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off, Name_Auto);\n+               Mode := Chars (Get_Pragma_Arg (Arg1));\n+\n+            --  A SPARK_Mode without an argument defaults to \"On\"\n+\n+            else\n+               Mode := Name_On;\n+            end if;\n+\n+            Mode_Id := Get_SPARK_Mode_Id (Mode);\n+            Context := Parent (N);\n+\n+            --  The pragma appears in a configuration file\n+\n+            if No (Context) then\n+               Check_Valid_Configuration_Pragma;\n+\n+               --  Set the global mode\n+\n+               if Global_SPARK_Mode = None then\n+                  Global_SPARK_Mode := Mode_Id;\n+\n+               --  Catch an attempt to redefine an existing global mode by\n+               --  using multiple configuration files.\n+\n+               elsif Global_SPARK_Mode /= Mode_Id then\n+                  Redefinition_Error (Global_SPARK_Mode);\n+               end if;\n+\n+            --  When the pragma is placed before the declaration of a unit, it\n+            --  configures the whole unit.\n+\n+            elsif Nkind (Context) = N_Compilation_Unit then\n+               Check_Valid_Configuration_Pragma;\n+\n+               Unit_Prag := SPARK_Mode_Pragma (Current_Sem_Unit);\n+\n+               --  Set the unit mode\n+\n+               if No (Unit_Prag) then\n+                  Set_SPARK_Mode_Pragma (Current_Sem_Unit, N);\n+\n+               --  Catch an attempt to redefine the unit mode by using multiple\n+               --  pragmas declared in the same region.\n+\n+               else\n+                  Redefinition_Error (Unit_Prag);\n+               end if;\n+\n+            --  The pragma applies to a [library unit] subprogram or package\n+\n+            else\n+               --  Mode \"Auto\" cannot be used in nested subprograms or packages\n+\n+               if Mode_Id = SPARK_Auto then\n+                  Error_Pragma_Arg\n+                    (\"mode `Auto` can only apply to the configuration variant \"\n+                     & \"of pragma %\", Arg1);\n+               end if;\n+\n+               --  Verify the placement of the pragma with respect to package\n+               --  or subprogram declarations and detect duplicates.\n+\n+               Stmt := Prev (N);\n+               while Present (Stmt) loop\n+\n+                  --  Skip prior pragmas, but check for duplicates\n+\n+                  if Nkind (Stmt) = N_Pragma then\n+                     if Pragma_Name (Stmt) = Pname then\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_Sloc   := Sloc (Stmt);\n+                        Error_Msg_N\n+                          (\"pragma % duplicates pragma declared #\", N);\n+                     end if;\n+\n+                  --  Skip internally generated code\n+\n+                  elsif not Comes_From_Source (Stmt) then\n+                     null;\n+\n+                  --  The pragma applies to a package or subprogram declaration\n+\n+                  elsif Nkind_In (Stmt, N_Generic_Package_Declaration,\n+                                        N_Generic_Subprogram_Declaration,\n+                                        N_Package_Declaration,\n+                                        N_Subprogram_Declaration)\n+                  then\n+                     Spec_Id := Defining_Unit_Name (Specification (Stmt));\n+                     Chain_Pragma (Spec_Id, N);\n+                     return;\n+\n+                  --  The pragma does not apply to a legal construct, issue an\n+                  --  error and stop the analysis.\n+\n+                  else\n+                     Pragma_Misplaced;\n+                     exit;\n+                  end if;\n+\n+                  Stmt := Prev (Stmt);\n+               end loop;\n+\n+               --  If we get here, then we ran out of preceding statements. The\n+               --  pragma is immediately within a body.\n+\n+               if Nkind_In (Context, N_Package_Body,\n+                                     N_Subprogram_Body)\n+               then\n+                  Spec_Id := Corresponding_Spec (Context);\n+\n+                  if Nkind (Context) = N_Subprogram_Body then\n+                     Context := Specification (Context);\n+                  end if;\n+\n+                  Body_Id := Defining_Unit_Name (Context);\n+\n+                  Chain_Pragma (Body_Id, N);\n+                  Check_Conformance (Spec_Id, Body_Id);\n+\n+               --  The pragma is at the top level of a package spec\n+\n+               elsif Nkind (Context) = N_Package_Specification then\n+                  Spec_Id := Defining_Unit_Name (Context);\n+                  Chain_Pragma (Spec_Id, N);\n+\n+               --  The pragma applies to the statements of a package body\n+\n+               elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n+                 and then Nkind (Parent (Context)) = N_Package_Body\n+               then\n+                  Context := Parent (Context);\n+                  Spec_Id := Corresponding_Spec (Context);\n+                  Body_Id := Defining_Unit_Name (Context);\n+\n+                  Chain_Pragma (Body_Id, N);\n+                  Check_Conformance (Spec_Id, Body_Id);\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error.\n+\n+               else\n+                  Pragma_Misplaced;\n+               end if;\n+            end if;\n+         end SPARK_Mod;\n+\n          --------------------------------\n          -- Static_Elaboration_Desired --\n          --------------------------------\n@@ -18268,6 +18618,43 @@ package body Sem_Prag is\n       return Result;\n    end Get_Base_Subprogram;\n \n+   -----------------------\n+   -- Get_SPARK_Mode_Id --\n+   -----------------------\n+\n+   function Get_SPARK_Mode_Id (N : Name_Id) return SPARK_Mode_Id is\n+   begin\n+      if N = Name_On then\n+         return SPARK_On;\n+      elsif N = Name_Off then\n+         return SPARK_Off;\n+      elsif N = Name_Auto then\n+         return SPARK_Auto;\n+\n+      --  Any other argument is erroneous\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+   end Get_SPARK_Mode_Id;\n+\n+   -----------------------\n+   -- Get_SPARK_Mode_Id --\n+   -----------------------\n+\n+   function Get_SPARK_Mode_Id (N : Node_Id) return SPARK_Mode_Id is\n+      Mode : Node_Id;\n+\n+   begin\n+      pragma Assert\n+        (Nkind (N) = N_Pragma\n+          and then Present (Pragma_Argument_Associations (N)));\n+\n+      Mode := First (Pragma_Argument_Associations (N));\n+\n+      return Get_SPARK_Mode_Id (Chars (Get_Pragma_Arg (Mode)));\n+   end Get_SPARK_Mode_Id;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -18332,11 +18719,33 @@ package body Sem_Prag is\n    --  Start of processing for Is_Config_Static_String\n \n    begin\n-\n       Name_Len := 0;\n+\n       return Add_Config_Static_String (Arg);\n    end Is_Config_Static_String;\n \n+   -------------------------------\n+   -- Is_Elaboration_SPARK_Mode --\n+   -------------------------------\n+\n+   function Is_Elaboration_SPARK_Mode (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert\n+        (Nkind (N) = N_Pragma\n+          and then Pragma_Name (N) = Name_SPARK_Mode\n+          and then Is_List_Member (N));\n+\n+      --  Pragma SPARK_Mode affects the elaboration of a package body when it\n+      --  appears in the statement part of the body.\n+\n+      return\n+         Present (Parent (N))\n+           and then Nkind (Parent (N)) = N_Handled_Sequence_Of_Statements\n+           and then List_Containing (N) = Statements (Parent (N))\n+           and then Present (Parent (Parent (N)))\n+           and then Nkind (Parent (Parent (N))) = N_Package_Body;\n+   end Is_Elaboration_SPARK_Mode;\n+\n    -----------------------------------------\n    -- Is_Non_Significant_Pragma_Reference --\n    -----------------------------------------\n@@ -18524,6 +18933,7 @@ package body Sem_Prag is\n       Pragma_Source_File_Name               => -1,\n       Pragma_Source_File_Name_Project       => -1,\n       Pragma_Source_Reference               => -1,\n+      Pragma_SPARK_Mode                     =>  0,\n       Pragma_Storage_Size                   => -1,\n       Pragma_Storage_Unit                   => -1,\n       Pragma_Static_Elaboration_Desired     => -1,\n@@ -18682,6 +19092,26 @@ package body Sem_Prag is\n       end if;\n    end Is_Pragma_String_Literal;\n \n+   ---------------------------\n+   -- Is_Private_SPARK_Mode --\n+   ---------------------------\n+\n+   function Is_Private_SPARK_Mode (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert\n+        (Nkind (N) = N_Pragma\n+          and then Pragma_Name (N) = Name_SPARK_Mode\n+          and then Is_List_Member (N));\n+\n+      --  For pragma SPARK_Mode to be private, it has to appear in the private\n+      --  declarations of a package.\n+\n+      return\n+        Present (Parent (N))\n+          and then Nkind (Parent (N)) = N_Package_Specification\n+          and then List_Containing (N) = Private_Declarations (Parent (N));\n+   end Is_Private_SPARK_Mode;\n+\n    -----------------------------\n    -- Is_Valid_Assertion_Kind --\n    -----------------------------"}, {"sha": "fcbe9889861878e643a12106c4a00afbee8a03d8", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -113,6 +113,9 @@ package Sem_Prag is\n    --  True have their analysis delayed until after the main program is parsed\n    --  and analyzed.\n \n+   function Get_SPARK_Mode_Id (N : Node_Id) return SPARK_Mode_Id;\n+   --  Given a pragma SPARK_Mode node, return the corresponding mode id\n+\n    procedure Initialize;\n    --  Initializes data structures used for pragma processing. Must be called\n    --  before analyzing each new main source program.\n@@ -127,6 +130,10 @@ package Sem_Prag is\n    --  length, and then returns True. If it is not of the correct form, then an\n    --  appropriate error message is posted, and False is returned.\n \n+   function Is_Elaboration_SPARK_Mode (N : Node_Id) return Boolean;\n+   --  Determine whether pragma SPARK_Mode appears in the statement part of a\n+   --  package body.\n+\n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean;\n    --  The node N is a node for an entity and the issue is whether the\n    --  occurrence is a reference for the purposes of giving warnings about\n@@ -143,6 +150,10 @@ package Sem_Prag is\n    --  False is returned, then the argument is treated as an entity reference\n    --  to the operator.\n \n+   function Is_Private_SPARK_Mode (N : Node_Id) return Boolean;\n+   --  Determine whether pragma SPARK_Mode appears in the private part of a\n+   --  package.\n+\n    function Is_Valid_Assertion_Kind (Nam : Name_Id) return Boolean;\n    --  Returns True if Nam is one of the names recognized as a valid assertion\n    --  kind by the Assertion_Policy pragma. Note that the 'Class cases are"}, {"sha": "f66aeee203a1c1dce6fb3d88c7eb0866f8c78d98", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -1539,6 +1539,10 @@ package Sinfo is\n    --      Used by processing for Pre/Postcondition pragmas to store a list of\n    --      pragmas associated with the spec of a subprogram (see Sem_Prag for\n    --      details).\n+   --\n+   --      Used by processing for pragma SPARK_Mode to store multiple pragmas\n+   --      the apply to the same construct. These are visible/private mode for\n+   --      a package spec and declarative/statement mode for package body.\n \n    --  Next_Rep_Item (Node5-Sem)\n    --    Present in pragma nodes, attribute definition nodes, enumeration rep"}, {"sha": "bfe21bdd7c6b7966bc6067684729dc50a161c38f", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -436,6 +436,7 @@ package Snames is\n    Name_Short_Descriptors              : constant Name_Id := N + $; -- GNAT\n    Name_Source_File_Name               : constant Name_Id := N + $; -- GNAT\n    Name_Source_File_Name_Project       : constant Name_Id := N + $; -- GNAT\n+   Name_SPARK_Mode                     : constant Name_Id := N + $; -- GNAT\n    Name_Style_Checks                   : constant Name_Id := N + $; -- GNAT\n    Name_Suppress                       : constant Name_Id := N + $;\n    Name_Suppress_Exception_Locations   : constant Name_Id := N + $; -- GNAT\n@@ -673,6 +674,7 @@ package Snames is\n    Name_Assertion                      : constant Name_Id := N + $;\n    Name_Assertions                     : constant Name_Id := N + $;\n    Name_Attribute_Name                 : constant Name_Id := N + $;\n+   Name_Auto                           : constant Name_Id := N + $;\n    Name_Body_File_Name                 : constant Name_Id := N + $;\n    Name_Boolean_Entry_Barriers         : constant Name_Id := N + $;\n    Name_By_Any                         : constant Name_Id := N + $;\n@@ -1748,6 +1750,7 @@ package Snames is\n       Pragma_Short_Descriptors,\n       Pragma_Source_File_Name,\n       Pragma_Source_File_Name_Project,\n+      Pragma_SPARK_Mode,\n       Pragma_Style_Checks,\n       Pragma_Suppress,\n       Pragma_Suppress_Exception_Locations,"}, {"sha": "4bbaa6b43da777eaf1e85b4efed65726a7cf099e", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c6269d3f574465892c1a100dfda81f4e3dba1ab/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=1c6269d3f574465892c1a100dfda81f4e3dba1ab", "patch": "@@ -876,4 +876,12 @@ package Types is\n      SE_Empty_Storage_Pool ..\n      SE_Object_Too_Large;\n \n+   ----------------------------------------\n+   -- Types Used for SPARK Mode Handling --\n+   ----------------------------------------\n+\n+   type SPARK_Mode_Id is (None, SPARK_Off, SPARK_Auto, SPARK_On);\n+   --  Type used to represent all legal modes that can be set by aspect/pragma\n+   --  SPARK_Mode.\n+\n end Types;"}]}