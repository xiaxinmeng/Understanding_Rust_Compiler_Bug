{"sha": "e32869a17b788bee9ca782b174a546b1db17b5ea", "node_id": "C_kwDOANBUbNoAKGUzMjg2OWExN2I3ODhiZWU5Y2E3ODJiMTc0YTU0NmIxZGIxN2I1ZWE", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-09T13:42:32Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-09T13:42:32Z"}, "message": "c++: detecting copy-init context during CTAD [PR102137]\n\nHere we're failing to communicate to cp_finish_decl from tsubst_expr\nthat we're in a copy-initialization context (via the LOOKUP_ONLYCONVERTING\nflag), which causes us to always consider explicit deduction guides when\nperforming CTAD for a templated variable initializer.\n\nIt turns out this bug also affects consideration of explicit conversion\noperators for the same reason.  But consideration of explicit constructors\nseems unaffacted thanks to code in build_aggr_init that sets\nLOOKUP_ONLYCONVERTING when the initializer represents copy-initialization.\n\nSo this patch fixes this by making cp_finish_decl set LOOKUP_ONLYCONVERTING\njust like build_aggr_init does, by inspecting the initializer, so that\ncallers don't need to explicitly pass this flag appropriately.\n\n\tPR c++/102137\n\tPR c++/87820\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (is_copy_initialization): Declare.\n\t* decl.cc (cp_finish_decl): Set LOOKUP_ONLYCONVERTING\n\twhen is_copy_initialization is true.\n\t* init.cc (build_aggr_init): Split out copy-initialization\n\tcheck into ...\n\t(is_copy_initialization): ... here.\n\t* pt.cc (instantiate_decl): Pass 0 instead of\n\tLOOKUP_ONLYCONVERTING as flags to cp_finish_decl.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/explicit15.C: New test.\n\t* g++.dg/cpp1z/class-deduction108.C: New test.", "tree": {"sha": "0f76ecbece601e5557fb797850b3d603a0a6103a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f76ecbece601e5557fb797850b3d603a0a6103a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e32869a17b788bee9ca782b174a546b1db17b5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32869a17b788bee9ca782b174a546b1db17b5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32869a17b788bee9ca782b174a546b1db17b5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32869a17b788bee9ca782b174a546b1db17b5ea/comments", "author": null, "committer": null, "parents": [{"sha": "fe548eb8436f3906e6a3c6e3e8707d24e60ec0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe548eb8436f3906e6a3c6e3e8707d24e60ec0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe548eb8436f3906e6a3c6e3e8707d24e60ec0fa"}], "stats": {"total": 187, "additions": 180, "deletions": 7}, "files": [{"sha": "b71bce1ab979ec69dbd90fc57a8d2b0fd6881172", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -7037,6 +7037,7 @@ extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\t(tree, tree, int,\n                                                  tsubst_flags_t);\n extern int is_class_type\t\t\t(tree, int);\n+extern bool is_copy_initialization\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);"}, {"sha": "992e38385c2546a82c56cbf6cb47611879fd5d48", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -7962,6 +7962,9 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   if (type == error_mark_node)\n     return;\n \n+  if (VAR_P (decl) && is_copy_initialization (init))\n+    flags |= LOOKUP_ONLYCONVERTING;\n+\n   /* Warn about register storage specifiers except when in GNU global\n      or local register variable extension.  */\n   if (VAR_P (decl) && DECL_REGISTER (decl) && asmspec_tree == NULL_TREE)"}, {"sha": "cd1d6f828022f5de43b9c58e4cb4bedb76145a1a", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -2019,11 +2019,7 @@ build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n       return stmt_expr;\n     }\n \n-  if (init && init != void_type_node\n-      && TREE_CODE (init) != TREE_LIST\n-      && !(TREE_CODE (init) == TARGET_EXPR\n-\t   && TARGET_EXPR_DIRECT_INIT_P (init))\n-      && !DIRECT_LIST_INIT_P (init))\n+  if (is_copy_initialization (init))\n     flags |= LOOKUP_ONLYCONVERTING;\n \n   is_global = begin_init_stmts (&stmt_expr, &compound_stmt);\n@@ -2331,6 +2327,19 @@ is_class_type (tree type, int or_else)\n   return 1;\n }\n \n+/* Returns true iff the initializer INIT represents copy-initialization\n+   (and therefore we must set LOOKUP_ONLYCONVERTING when processing it).  */\n+\n+bool\n+is_copy_initialization (tree init)\n+{\n+  return (init && init != void_type_node\n+\t  && TREE_CODE (init) != TREE_LIST\n+\t  && !(TREE_CODE (init) == TARGET_EXPR\n+\t       && TARGET_EXPR_DIRECT_INIT_P (init))\n+\t  && !DIRECT_LIST_INIT_P (init));\n+}\n+\n /* Build a reference to a member of an aggregate.  This is not a C++\n    `&', but really something which can have its address taken, and\n    then act as a pointer to member, for example TYPE :: FIELD can have"}, {"sha": "f8069b2ea0ebace2a6dcd9d388f103c419ebeb87", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -26581,8 +26581,7 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n \t      const_init\n \t\t= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (code_pattern);\n \t      cp_finish_decl (d, init, /*init_const_expr_p=*/const_init,\n-\t\t\t      /*asmspec_tree=*/NULL_TREE,\n-\t\t\t      LOOKUP_ONLYCONVERTING);\n+\t\t\t      /*asmspec_tree=*/NULL_TREE, 0);\n \t    }\n \t  if (enter_context)\n \t    pop_nested_class ();"}, {"sha": "58ce97b2ad9d2a8191a139bc31235581a0bc9879", "filename": "gcc/testsuite/g++.dg/cpp0x/explicit15.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit15.C?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -0,0 +1,83 @@\n+// PR c++/87820\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  constexpr explicit operator int() const { return 0; }\n+};\n+\n+template<class T>\n+void f() {\n+  A a;\n+  T t1 = a; // { dg-error \"cannot convert\" }\n+  T t2 = {a}; // { dg-error \"cannot convert\" }\n+  T t3(a);\n+  T t4{a};\n+  T t5 = T(a);\n+  T t6 = T{a};\n+  new T(a);\n+  new T{a};\n+}\n+\n+template<class T>\n+void g() {\n+  T t;\n+  int n1 = t; // { dg-error \"cannot convert\" }\n+  int n2 = {t}; // { dg-error \"cannot convert\" }\n+  int n3(t);\n+  int n4{t};\n+  int n5 = int(t);\n+  int n6 = int{t};\n+  new int(t);\n+  new int{t};\n+}\n+\n+template void f<int>();\n+template void g<A>();\n+\n+template<class T>\n+struct B {\n+  static constexpr A a{};\n+  static constexpr T t1 = a; // { dg-error \"cannot convert\" }\n+  static constexpr T t2 = {a}; // { dg-error \"cannot convert\" }\n+  static constexpr T t4{a};\n+  static constexpr T t5 = T(a);\n+  static constexpr T t6 = T{a};\n+};\n+\n+template<class T>\n+struct C {\n+  static constexpr T t{};\n+  static constexpr int n1 = t; // { dg-error \"cannot convert\" }\n+  static constexpr int n2 = {t}; // { dg-error \"cannot convert\" }\n+  static constexpr int n4{t};\n+  static constexpr int n5 = int(t);\n+  static constexpr int n6 = int{t};\n+};\n+\n+template struct B<int>;\n+template struct C<A>;\n+\n+#if __cpp_inline_variables\n+template<class T>\n+struct D {\n+  static inline A a;\n+  static inline T t1 = a; // { dg-error \"cannot convert\" \"\" { target c++17 } }\n+  static inline T t2 = {a}; // { dg-error \"cannot convert\" \"\" { target c++17 } }\n+  static inline T t4{a};\n+  static inline T t5 = T(a);\n+  static inline T t6 = T{a};\n+};\n+\n+template<class T>\n+struct E {\n+  static inline T t;\n+  static inline int n1 = t; // { dg-error \"cannot convert\" \"\" { target c++17 } }\n+  static inline int n2 = {t}; // { dg-error \"cannot convert\" \"\" { target c++17 } }\n+  static inline int n4{t};\n+  static inline int n5 = int(t);\n+  static inline int n6 = int{t};\n+};\n+\n+template struct D<int>;\n+template struct E<A>;\n+#endif"}, {"sha": "e82c4bafb048ff83a6b5fda288a2132ea966a608", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction108.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction108.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32869a17b788bee9ca782b174a546b1db17b5ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction108.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction108.C?ref=e32869a17b788bee9ca782b174a546b1db17b5ea", "patch": "@@ -0,0 +1,78 @@\n+// PR c++/102137\n+// { dg-do compile { target c++17 } }\n+\n+template<class T>\n+struct A {\n+  constexpr A() { }\n+  constexpr A(int) { }\n+};\n+\n+explicit A(...) -> A<int>;\n+\n+template<template<class> class TT>\n+void f() {\n+  TT x1 = 0; // { dg-error \"deduction|no match\" }\n+  TT x2 = {0}; // { dg-error \"explicit deduction guide\" }\n+  TT x3(0);\n+  TT x4{0};\n+  TT x5;\n+  new TT(0);\n+  new TT{0};\n+  new TT();\n+  new TT{};\n+  new TT;\n+}\n+\n+template<class T>\n+void g(T t) {\n+  A a1 = t; // { dg-error \"deduction|no match\" }\n+  A a2 = {t}; // { dg-error \"explicit deduction guide\" }\n+  A a3(t);\n+  A a4{t};\n+  A a5;\n+  new A(t);\n+  new A{t};\n+}\n+\n+template void f<A>();\n+template void g(int);\n+\n+template<template<class> class TT>\n+struct B {\n+  static inline TT x1 = 0; // { dg-error \"deduction|no match\" }\n+  static inline TT x2 = {0}; // { dg-error \"explicit deduction guide\" }\n+  static inline TT x4{0};\n+  static inline TT x5;\n+};\n+\n+template<class T>\n+struct C {\n+  static inline T t;\n+  static inline A a1 = t; // { dg-error \"deduction|no match\" }\n+  static inline A a2 = {t}; // { dg-error \"explicit deduction guide\" }\n+  static inline A a4{t};\n+  static inline A a5{};\n+};\n+\n+template struct B<A>;\n+template struct C<int>;\n+\n+template<template<class> class TT>\n+struct E {\n+  static constexpr TT x1 = 0; // { dg-error \"deduction|no match\" }\n+  static constexpr TT x2 = {0}; // { dg-error \"explicit deduction guide\" }\n+  static constexpr TT x4{0};\n+  static constexpr TT x5{};\n+};\n+\n+template<class T>\n+struct F {\n+  static constexpr T t{};\n+  static constexpr A a1 = t; // { dg-error \"deduction|no match\" }\n+  static constexpr A a2 = {t}; // { dg-error \"explicit deduction guide\" }\n+  static constexpr A a4{t};\n+  static constexpr A a5{};\n+};\n+\n+template struct E<A>;\n+template struct F<int>;"}]}