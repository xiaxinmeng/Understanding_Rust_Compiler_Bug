{"sha": "398b1daa2d620c9d317f84651c62a6286e476d32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk4YjFkYWEyZDYyMGM5ZDMxN2Y4NDY1MWM2MmE2Mjg2ZTQ3NmQzMg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2012-11-06T23:55:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-11-06T23:55:39Z"}, "message": "tm: Add uninstrumented code path\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r193271", "tree": {"sha": "16d986ed828729b0f4c133bd97a226cb4bd2be5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16d986ed828729b0f4c133bd97a226cb4bd2be5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/398b1daa2d620c9d317f84651c62a6286e476d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/398b1daa2d620c9d317f84651c62a6286e476d32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/398b1daa2d620c9d317f84651c62a6286e476d32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/398b1daa2d620c9d317f84651c62a6286e476d32/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "066b83541dbfbf39b6f0521cd2e5338cbb4c3e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066b83541dbfbf39b6f0521cd2e5338cbb4c3e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066b83541dbfbf39b6f0521cd2e5338cbb4c3e78"}], "stats": {"total": 944, "additions": 631, "deletions": 313}, "files": [{"sha": "1283309b838730a652b0ed6b9cfb3a730e35d510", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -1,3 +1,26 @@\n+2012-11-06  Aldy Hernandez  <aldyh@redhat.com>\n+            Richard Henderson  <rth@redhat.com>\n+\n+\t* cfg-flags.def (TM_UNINSTRUMENTED, TM_ABORT): New.\n+\t* trans-mem.c (PROB_VERY_LIKELY, PROB_UNLIKELY, PROB_LIKELY): New.\n+\t(struct tm_region): Add tm_state, restart_block,\n+\toriginal_transaction_was_outer.\n+\t(tm_region_init_0): Initialize them.\n+\t(collect_bb2reg, get_bb_regions_instrumented): New.\n+\t(tm_log_emit_save_or_restores): Merge into ...\n+\t(expand_transaction): ... here.\n+\t(generate_tm_state, propagate_tm_flags_out): New.\n+\t(execute_tm_mark): Avoid processing blocks more than once.\n+\t(split_bb_make_tm_edge): Split out from ...\n+\t(make_tm_edge): ... here.  And merge the rest into ...\n+\t(expand_block_edges): ... here.\n+\t(execute_tm_edges): Avoid processing blocks more than once.\n+\t(ipa_uninstrument_transaction): New.\n+\t(ipa_tm_scan_calls_transaction): Use it.  Rebuild cgraph and ssa.\n+\t(ipa_tm_execute): Init and free original_copy_tables.\n+\t* trans-mem.h (PR_MULTIWAYCODE): New.\n+\t* tree-cfg.c (make_edges): Use EDGE_TM_ABORT.\n+\n 2012-11-06  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* cfghooks.c (copy_bbs): Handle a null loop_father."}, {"sha": "aea8f06bd665b73dde7b8048211559b3b7938b8a", "filename": "gcc/cfg-flags.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Fcfg-flags.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Fcfg-flags.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg-flags.def?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -171,6 +171,12 @@ DEF_EDGE_FLAG(CAN_FALLTHRU, 13)\n    This flag is only used for the RTL CFG.  */\n DEF_EDGE_FLAG(LOOP_EXIT, 14)\n \n+/* Uninstrumented edge out of a GIMPLE_TRANSACTION statement.  */\n+DEF_EDGE_FLAG(TM_UNINSTRUMENTED, 15)\n+\n+/* Abort (over) edge out of a GIMPLE_TRANSACTION statement.  */\n+DEF_EDGE_FLAG(TM_ABORT, 16)\n+\n #endif\n \n /*"}, {"sha": "96ca4ba2aebb233a7db86c269016d5e504dad2e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -1,3 +1,15 @@\n+2012-11-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-c++-common/tm/trxn-expr-3.c: Adjust for uninstrumented code path.\n+\t* gcc.dg/tm/debug-1.c: Same.\n+\t* gcc.dg/tm/irrevocable-3.c: Same.\n+\t* gcc.dg/tm/irrevocable-4.c: Same.\n+\t* gcc.dg/tm/memopt-10.c: Same.\n+\t* gcc.dg/tm/memopt-11.c: Same.\n+\t* gcc.dg/tm/props-4.c: Same.\n+\t* gcc.dg/tm/wrap-3.c: Same.\n+\t* gcc.dg/tm/wrap-4.c: Same.\n+\n 2012-11-06  Andrew Pinski  <apinski@cavium.com>\n \n \t* g++.dg/abi/aarch64_guard1.C: Add -fno-section-anchors."}, {"sha": "db66873dc80932e833dc45cf456264e05e0a1c07", "filename": "gcc/testsuite/c-c++-common/tm/trxn-expr-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-3.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -10,5 +10,5 @@ int f2()\n }\n \n /* { dg-final { scan-tree-dump-times \"ITM_RU\" 2 \"tmmark\" } } */\n-/* { dg-final { scan-tree-dump-times \"ITM_commitTransaction\" 2 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_commitTransaction\" 4 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "01acfae4d03b309f26d826981e7989abe4ffe845", "filename": "gcc/testsuite/gcc.dg/tm/debug-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -20,7 +20,7 @@ main() {\n }\n \n /* { dg-final { scan-tree-dump-times \": 13:.*b = 9898\" 1 \"tmmark\" } } */\n-/* { dg-final { scan-tree-dump-times \": 14:.*__transaction\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \": 14:.*_ITM_beginTransaction\" 1 \"tmmark\" } } */\n /* { dg-final { scan-tree-dump-times \": 15:.*ITM_WU. \\\\(&z\" 1 \"tmmark\" } } */\n /* { dg-final { scan-tree-dump-times \": 16:.*ITM_WU. \\\\(&a\" 1 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "fdf3e52e2e412bd9f8c7de654e72526e8b0f8b8d", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -10,5 +10,5 @@ foo()\n \t}\n }\n \n-/* { dg-final { scan-tree-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"doesGoIrrevocable\" 1 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "72075df36c05242a743ed64975add6f650f7202f", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -12,5 +12,5 @@ foo()\n \t}\n }\n \n-/* { dg-final { scan-tree-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"hasNoIrrevocable\" 0 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "0978bce912d7f86e478ee74ed35169329790f369", "filename": "gcc/testsuite/gcc.dg/tm/memopt-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -24,5 +24,5 @@ int f()\n \n /* { dg-final { scan-tree-dump-times \"ITM_LU\" 0 \"tmmark\" } } */\n /* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n-/* { dg-final { scan-tree-dump-times \"tm_save\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"int tm_save\" 1 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "36aa66412b9bd6fa6f3662c0cacc70e15d3ec2cb", "filename": "gcc/testsuite/gcc.dg/tm/memopt-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -25,5 +25,5 @@ int f()\n \n /* { dg-final { scan-tree-dump-times \"ITM_LU\" 0 \"tmmark\" } } */\n /* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n-/* { dg-final { scan-tree-dump-times \"tm_save\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"int tm_save\" 1 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "c34f5e619e391164ad920f9b796578f7bf1a1bb3", "filename": "gcc/testsuite/gcc.dg/tm/props-4.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -22,6 +22,5 @@ foo(void)\n \n /* { dg-final { scan-tree-dump-times \" instrumentedCode\" 1 \"tmedge\" } } */\n /* { dg-final { scan-tree-dump-times \"hasNoAbort\" 0 \"tmedge\" } } */\n-/* { dg-final { scan-tree-dump-times \"LABEL=<L0>\" 1 \"tmmark\" } } */\n /* { dg-final { cleanup-tree-dump \"tmedge\" } } */\n /* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "673247103dcc8ba2b99448ec76f4e45216dff3ee", "filename": "gcc/testsuite/gcc.dg/tm/wrap-3.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -10,5 +10,8 @@ void foo()\n   __transaction_relaxed { free (p); }\n }\n \n-/* { dg-final { scan-tree-dump-times \"free\" 0 \"optimized\" } } */\n+/* We still have one call to free()-- on the uninstrumented path\n+   everything is as usual.  */\n+/* { dg-final { scan-tree-dump-times \"free\" 1 \"optimized\" } } */\n+\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9a4ec061f89a1c443b03ab351bb5cd972a1a3ded", "filename": "gcc/testsuite/gcc.dg/tm/wrap-4.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -11,5 +11,8 @@ void foo()\n   __transaction_relaxed { candy(); }\n }\n \n-/* { dg-final { scan-tree-dump-times \"candy\" 0 \"optimized\" } } */\n+/* We still have one call to candy()-- on the uninstrumented path\n+   everything is as usual.  */\n+/* { dg-final { scan-tree-dump-times \"candy \\\\(\\\\);\" 1 \"optimized\" } } */\n+\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "642e088a0ed9456335d00d98f9d2a21772e5e0e1", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 572, "deletions": 301, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -37,6 +37,9 @@\n \n \n #define PROB_VERY_UNLIKELY\t(REG_BR_PROB_BASE / 2000 - 1)\n+#define PROB_VERY_LIKELY\t(PROB_ALWAYS - PROB_VERY_UNLIKELY)\n+#define PROB_UNLIKELY\t\t(REG_BR_PROB_BASE / 5 - 1)\n+#define PROB_LIKELY\t\t(PROB_ALWAYS - PROB_VERY_LIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n #define A_RUNINSTRUMENTEDCODE\t0x0001\n@@ -133,6 +136,10 @@\n \tover:\n */\n \n+static void *expand_regions (struct tm_region *,\n+\t\t\t     void *(*callback)(struct tm_region *, void *),\n+\t\t\t     void *);\n+\n \f\n /* Return the attributes we want to examine for X, or NULL if it's not\n    something we examine.  We look at function types, but allow pointers\n@@ -1243,72 +1250,6 @@ tm_log_emit_restores (basic_block entry_block, basic_block bb)\n     }\n }\n \n-/* Emit the checks for performing either a save or a restore sequence.\n-\n-   TRXN_PROP is either A_SAVELIVEVARIABLES or A_RESTORELIVEVARIABLES.\n-\n-   The code sequence is inserted in a new basic block created in\n-   END_BB which is inserted between BEFORE_BB and the destination of\n-   FALLTHRU_EDGE.\n-\n-   STATUS is the return value from _ITM_beginTransaction.\n-   ENTRY_BLOCK is the entry block for the transaction.\n-   EMITF is a callback to emit the actual save/restore code.\n-\n-   The basic block containing the conditional checking for TRXN_PROP\n-   is returned.  */\n-static basic_block\n-tm_log_emit_save_or_restores (basic_block entry_block,\n-\t\t\t      unsigned trxn_prop,\n-\t\t\t      tree status,\n-\t\t\t      void (*emitf)(basic_block, basic_block),\n-\t\t\t      basic_block before_bb,\n-\t\t\t      edge fallthru_edge,\n-\t\t\t      basic_block *end_bb)\n-{\n-  basic_block cond_bb, code_bb;\n-  gimple cond_stmt, stmt;\n-  gimple_stmt_iterator gsi;\n-  tree t1, t2;\n-  int old_flags = fallthru_edge->flags;\n-\n-  cond_bb = create_empty_bb (before_bb);\n-  code_bb = create_empty_bb (cond_bb);\n-  *end_bb = create_empty_bb (code_bb);\n-  if (current_loops && before_bb->loop_father)\n-    {\n-      add_bb_to_loop (cond_bb, before_bb->loop_father);\n-      add_bb_to_loop (code_bb, before_bb->loop_father);\n-      add_bb_to_loop (*end_bb, before_bb->loop_father);\n-    }\n-  redirect_edge_pred (fallthru_edge, *end_bb);\n-  fallthru_edge->flags = EDGE_FALLTHRU;\n-  make_edge (before_bb, cond_bb, old_flags);\n-\n-  set_immediate_dominator (CDI_DOMINATORS, cond_bb, before_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, code_bb, cond_bb);\n-\n-  gsi = gsi_last_bb (cond_bb);\n-\n-  /* t1 = status & A_{property}.  */\n-  t1 = create_tmp_reg (TREE_TYPE (status), NULL);\n-  t2 = build_int_cst (TREE_TYPE (status), trxn_prop);\n-  stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1, status, t2);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\n-  /* if (t1).  */\n-  t2 = build_int_cst (TREE_TYPE (status), 0);\n-  cond_stmt = gimple_build_cond (NE_EXPR, t1, t2, NULL, NULL);\n-  gsi_insert_after (&gsi, cond_stmt, GSI_CONTINUE_LINKING);\n-\n-  emitf (entry_block, code_bb);\n-\n-  make_edge (cond_bb, code_bb, EDGE_TRUE_VALUE);\n-  make_edge (cond_bb, *end_bb, EDGE_FALSE_VALUE);\n-  make_edge (code_bb, *end_bb, EDGE_FALLTHRU);\n-\n-  return cond_bb;\n-}\n \f\n static tree lower_sequence_tm (gimple_stmt_iterator *, bool *,\n \t\t\t       struct walk_stmt_info *);\n@@ -1767,12 +1708,26 @@ struct tm_region\n   /* Link to the next outer transaction.  */\n   struct tm_region *outer;\n \n-  /* The GIMPLE_TRANSACTION statement beginning this transaction.  */\n+  /* The GIMPLE_TRANSACTION statement beginning this transaction.\n+     After TM_MARK, this gets replaced by a call to\n+     BUILT_IN_TM_START.  */\n   gimple transaction_stmt;\n \n-  /* The entry block to this region.  */\n+  /* After TM_MARK expands the GIMPLE_TRANSACTION into a call to\n+     BUILT_IN_TM_START, this field is true if the transaction is an\n+     outer transaction.  */\n+  bool original_transaction_was_outer;\n+\n+  /* Return value from BUILT_IN_TM_START.  */\n+  tree tm_state;\n+\n+  /* The entry block to this region.  This will always be the first\n+     block of the body of the transaction.  */\n   basic_block entry_block;\n \n+  /* The first block after an expanded call to _ITM_beginTransaction.  */\n+  basic_block restart_block;\n+\n   /* The set of all blocks that end the region; NULL if only EXIT_BLOCK.\n      These blocks are still a part of the region (i.e., the border is\n      inclusive). Note that this set is only complete for paths in the CFG\n@@ -1821,6 +1776,8 @@ tm_region_init_0 (struct tm_region *outer, basic_block bb, gimple stmt)\n   region->outer = outer;\n \n   region->transaction_stmt = stmt;\n+  region->original_transaction_was_outer = false;\n+  region->tm_state = NULL;\n \n   /* There are either one or two edges out of the block containing\n      the GIMPLE_TRANSACTION, one to the actual region and one to the\n@@ -2195,6 +2152,7 @@ expand_assign_tm (struct tm_region *region, gimple_stmt_iterator *gsi)\n       return;\n     }\n \n+  // Remove original load/store statement.\n   gsi_remove (gsi, true);\n \n   if (load_p && !store_p)\n@@ -2248,7 +2206,9 @@ expand_assign_tm (struct tm_region *region, gimple_stmt_iterator *gsi)\n   if (!store_p)\n     requires_barrier (region->entry_block, lhs, gcall);\n \n-  /* add_stmt_to_tm_region  (region, gcall); */\n+  // The calls to build_tm_{store,load} above inserted the instrumented\n+  // call into the stream.\n+  // gsi_insert_before (gsi, gcall, GSI_SAME_STMT);\n }\n \n \n@@ -2484,6 +2444,65 @@ get_tm_region_blocks (basic_block entry_block,\n   return bbs;\n }\n \n+// Callback for expand_regions, collect innermost region data for each bb.\n+static void *\n+collect_bb2reg (struct tm_region *region, void *data)\n+{\n+  VEC(tm_region_p, heap) *bb2reg = (VEC(tm_region_p, heap) *) data;\n+  VEC (basic_block, heap) *queue;\n+  unsigned int i;\n+  basic_block bb;\n+\n+  queue = get_tm_region_blocks (region->entry_block,\n+\t\t\t\tregion->exit_blocks,\n+\t\t\t\tregion->irr_blocks,\n+\t\t\t\tNULL,\n+\t\t\t\t/*stop_at_irr_p=*/false);\n+\n+  // We expect expand_region to perform a post-order traversal of the region\n+  // tree.  Therefore the last region seen for any bb is the innermost.\n+  FOR_EACH_VEC_ELT (basic_block, queue, i, bb)\n+    VEC_replace (tm_region_p, bb2reg, bb->index, region);\n+\n+  VEC_free (basic_block, heap, queue);\n+  return NULL;\n+}\n+\n+// Returns a vector, indexed by BB->INDEX, of the innermost tm_region to\n+// which a basic block belongs.  Note that we only consider the instrumented\n+// code paths for the region; the uninstrumented code paths are ignored.\n+//\n+// ??? This data is very similar to the bb_regions array that is collected\n+// during tm_region_init.  Or, rather, this data is similar to what could\n+// be used within tm_region_init.  The actual computation in tm_region_init\n+// begins and ends with bb_regions entirely full of NULL pointers, due to\n+// the way in which pointers are swapped in and out of the array.\n+//\n+// ??? Our callers expect that blocks are not shared between transactions.\n+// When the optimizers get too smart, and blocks are shared, then during\n+// the tm_mark phase we'll add log entries to only one of the two transactions,\n+// and in the tm_edge phase we'll add edges to the CFG that create invalid\n+// cycles.  The symptom being SSA defs that do not dominate their uses.\n+// Note that the optimizers were locally correct with their transformation,\n+// as we have no info within the program that suggests that the blocks cannot\n+// be shared.\n+//\n+// ??? There is currently a hack inside tree-ssa-pre.c to work around the\n+// only known instance of this block sharing.\n+\n+static VEC(tm_region_p, heap) *\n+get_bb_regions_instrumented (void)\n+{\n+  unsigned n = last_basic_block;\n+  VEC(tm_region_p, heap) *ret;\n+\n+  ret = VEC_alloc (tm_region_p, heap, n);\n+  VEC_safe_grow_cleared (tm_region_p, heap, ret, n);\n+  expand_regions (all_tm_regions, collect_bb2reg, ret);\n+\n+  return ret;\n+}\n+\n /* Set the IN_TRANSACTION for all gimple statements that appear in a\n    transaction.  */\n \n@@ -2518,6 +2537,285 @@ compute_transaction_bits (void)\n     bitmap_obstack_release (&tm_obstack);\n }\n \n+/* Replace the GIMPLE_TRANSACTION in this region with the corresponding\n+   call to BUILT_IN_TM_START.  */\n+\n+static void *\n+expand_transaction (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree tm_start = builtin_decl_explicit (BUILT_IN_TM_START);\n+  basic_block transaction_bb = gimple_bb (region->transaction_stmt);\n+  tree tm_state = region->tm_state;\n+  tree tm_state_type = TREE_TYPE (tm_state);\n+  edge abort_edge = NULL;\n+  edge inst_edge = NULL;\n+  edge uninst_edge = NULL;\n+  edge fallthru_edge = NULL;\n+\n+  // Identify the various successors of the transaction start.\n+  {\n+    edge_iterator i;\n+    edge e;\n+    FOR_EACH_EDGE (e, i, transaction_bb->succs)\n+      {\n+        if (e->flags & EDGE_TM_ABORT)\n+\t  abort_edge = e;\n+        else if (e->flags & EDGE_TM_UNINSTRUMENTED)\n+\t  uninst_edge = e;\n+\telse\n+\t  inst_edge = e;\n+        if (e->flags & EDGE_FALLTHRU)\n+\t  fallthru_edge = e;\n+      }\n+  }\n+\n+  /* ??? There are plenty of bits here we're not computing.  */\n+  {\n+    int subcode = gimple_transaction_subcode (region->transaction_stmt);\n+    int flags = 0;\n+    if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n+      flags |= PR_DOESGOIRREVOCABLE;\n+    if ((subcode & GTMA_MAY_ENTER_IRREVOCABLE) == 0)\n+      flags |= PR_HASNOIRREVOCABLE;\n+    /* If the transaction does not have an abort in lexical scope and is not\n+       marked as an outer transaction, then it will never abort.  */\n+    if ((subcode & GTMA_HAVE_ABORT) == 0 && (subcode & GTMA_IS_OUTER) == 0)\n+      flags |= PR_HASNOABORT;\n+    if ((subcode & GTMA_HAVE_STORE) == 0)\n+      flags |= PR_READONLY;\n+    if (inst_edge)\n+      flags |= PR_INSTRUMENTEDCODE;\n+    if (uninst_edge)\n+      flags |= PR_UNINSTRUMENTEDCODE;\n+    if (subcode & GTMA_IS_OUTER)\n+      region->original_transaction_was_outer = true;\n+    tree t = build_int_cst (tm_state_type, flags);\n+    gimple call = gimple_build_call (tm_start, 1, t);\n+    gimple_call_set_lhs (call, tm_state);\n+    gimple_set_location (call, gimple_location (region->transaction_stmt));\n+\n+    // Replace the GIMPLE_TRANSACTION with the call to BUILT_IN_TM_START.\n+    gimple_stmt_iterator gsi = gsi_last_bb (transaction_bb);\n+    gcc_assert (gsi_stmt (gsi) == region->transaction_stmt);\n+    gsi_insert_before (&gsi, call, GSI_SAME_STMT);\n+    gsi_remove (&gsi, true);\n+    region->transaction_stmt = call;\n+  }\n+\n+  // Generate log saves.\n+  if (!VEC_empty (tree, tm_log_save_addresses))\n+    tm_log_emit_saves (region->entry_block, transaction_bb);\n+\n+  // In the beginning, we've no tests to perform on transaction restart.\n+  // Note that after this point, transaction_bb becomes the \"most recent\n+  // block containing tests for the transaction\".\n+  region->restart_block = region->entry_block;\n+\n+  // Generate log restores.\n+  if (!VEC_empty (tree, tm_log_save_addresses))\n+    {\n+      basic_block test_bb = create_empty_bb (transaction_bb);\n+      basic_block code_bb = create_empty_bb (test_bb);\n+      basic_block join_bb = create_empty_bb (code_bb);\n+      if (current_loops && transaction_bb->loop_father)\n+\t{\n+\t  add_bb_to_loop (test_bb, transaction_bb->loop_father);\n+\t  add_bb_to_loop (code_bb, transaction_bb->loop_father);\n+\t  add_bb_to_loop (join_bb, transaction_bb->loop_father);\n+\t}\n+      if (region->restart_block == region->entry_block)\n+\tregion->restart_block = test_bb;\n+\n+      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t2 = build_int_cst (tm_state_type, A_RESTORELIVEVARIABLES);\n+      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n+\t\t\t\t\t\t  tm_state, t2);\n+      gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      t2 = build_int_cst (tm_state_type, 0);\n+      stmt = gimple_build_cond (NE_EXPR, t1, t2, NULL, NULL);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      tm_log_emit_restores (region->entry_block, code_bb);\n+\n+      edge ei = make_edge (transaction_bb, test_bb, EDGE_FALLTHRU);\n+      edge et = make_edge (test_bb, code_bb, EDGE_TRUE_VALUE);\n+      edge ef = make_edge (test_bb, join_bb, EDGE_FALSE_VALUE);\n+      redirect_edge_pred (fallthru_edge, join_bb);\n+\n+      join_bb->frequency = test_bb->frequency = transaction_bb->frequency;\n+      join_bb->count = test_bb->count = transaction_bb->count;\n+\n+      ei->probability = PROB_ALWAYS;\n+      et->probability = PROB_LIKELY;\n+      ef->probability = PROB_UNLIKELY;\n+      et->count = apply_probability(test_bb->count, et->probability);\n+      ef->count = apply_probability(test_bb->count, ef->probability);\n+\n+      code_bb->count = et->count;\n+      code_bb->frequency = EDGE_FREQUENCY (et);\n+\n+      transaction_bb = join_bb;\n+    }\n+\n+  // If we have an ABORT edge, create a test to perform the abort.\n+  if (abort_edge)\n+    {\n+      basic_block test_bb = create_empty_bb (transaction_bb);\n+      if (current_loops && transaction_bb->loop_father)\n+\tadd_bb_to_loop (test_bb, transaction_bb->loop_father);\n+      if (region->restart_block == region->entry_block)\n+\tregion->restart_block = test_bb;\n+\n+      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t2 = build_int_cst (tm_state_type, A_ABORTTRANSACTION);\n+      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n+\t\t\t\t\t\t  tm_state, t2);\n+      gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      t2 = build_int_cst (tm_state_type, 0);\n+      stmt = gimple_build_cond (NE_EXPR, t1, t2, NULL, NULL);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      edge ei = make_edge (transaction_bb, test_bb, EDGE_FALLTHRU);\n+      test_bb->frequency = transaction_bb->frequency;\n+      test_bb->count = transaction_bb->count;\n+      ei->probability = PROB_ALWAYS;\n+\n+      // Not abort edge.  If both are live, chose one at random as we'll\n+      // we'll be fixing that up below.\n+      redirect_edge_pred (fallthru_edge, test_bb);\n+      fallthru_edge->flags = EDGE_FALSE_VALUE;\n+      fallthru_edge->probability = PROB_VERY_LIKELY;\n+      fallthru_edge->count\n+\t= apply_probability(test_bb->count, fallthru_edge->probability);\n+\n+      // Abort/over edge.\n+      redirect_edge_pred (abort_edge, test_bb);\n+      abort_edge->flags = EDGE_TRUE_VALUE;\n+      abort_edge->probability = PROB_VERY_UNLIKELY;\n+      abort_edge->count\n+\t= apply_probability(test_bb->count, abort_edge->probability);\n+\n+      transaction_bb = test_bb;\n+    }\n+\n+  // If we have both instrumented and uninstrumented code paths, select one.\n+  if (inst_edge && uninst_edge)\n+    {\n+      basic_block test_bb = create_empty_bb (transaction_bb);\n+      if (current_loops && transaction_bb->loop_father)\n+\tadd_bb_to_loop (test_bb, transaction_bb->loop_father);\n+      if (region->restart_block == region->entry_block)\n+\tregion->restart_block = test_bb;\n+\n+      tree t1 = create_tmp_reg (tm_state_type, NULL);\n+      tree t2 = build_int_cst (tm_state_type, A_RUNUNINSTRUMENTEDCODE);\n+\n+      gimple stmt = gimple_build_assign_with_ops (BIT_AND_EXPR, t1,\n+\t\t\t\t\t\t  tm_state, t2);\n+      gimple_stmt_iterator gsi = gsi_last_bb (test_bb);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      t2 = build_int_cst (tm_state_type, 0);\n+      stmt = gimple_build_cond (NE_EXPR, t1, t2, NULL, NULL);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      // Create the edge into test_bb first, as we want to copy values\n+      // out of the fallthru edge.\n+      edge e = make_edge (transaction_bb, test_bb, fallthru_edge->flags);\n+      e->probability = fallthru_edge->probability;\n+      test_bb->count = e->count = fallthru_edge->count;\n+      test_bb->frequency = EDGE_FREQUENCY (e);\n+\n+      // Now update the edges to the inst/uninist implementations.\n+      // For now assume that the paths are equally likely.  When using HTM,\n+      // we'll try the uninst path first and fallback to inst path if htm\n+      // buffers are exceeded.  Without HTM we start with the inst path and\n+      // use the uninst path when falling back to serial mode.\n+      redirect_edge_pred (inst_edge, test_bb);\n+      inst_edge->flags = EDGE_FALSE_VALUE;\n+      inst_edge->probability = REG_BR_PROB_BASE / 2;\n+      inst_edge->count\n+\t= apply_probability(test_bb->count, inst_edge->probability);\n+\n+      redirect_edge_pred (uninst_edge, test_bb);\n+      uninst_edge->flags = EDGE_TRUE_VALUE;\n+      uninst_edge->probability = REG_BR_PROB_BASE / 2;\n+      uninst_edge->count\n+\t= apply_probability(test_bb->count, uninst_edge->probability);\n+    }\n+\n+  // If we have no previous special cases, and we have PHIs at the beginning\n+  // of the atomic region, this means we have a loop at the beginning of the\n+  // atomic region that shares the first block.  This can cause problems with\n+  // the transaction restart abnormal edges to be added in the tm_edges pass.\n+  // Solve this by adding a new empty block to receive the abnormal edges.\n+  if (region->restart_block == region->entry_block\n+      && phi_nodes (region->entry_block))\n+    {\n+      basic_block empty_bb = create_empty_bb (transaction_bb);\n+      region->restart_block = empty_bb;\n+      if (current_loops && transaction_bb->loop_father)\n+\tadd_bb_to_loop (empty_bb, transaction_bb->loop_father);\n+\n+      redirect_edge_pred (fallthru_edge, empty_bb);\n+      make_edge (transaction_bb, empty_bb, EDGE_FALLTHRU);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Generate the temporary to be used for the return value of\n+   BUILT_IN_TM_START.  */\n+\n+static void *\n+generate_tm_state (struct tm_region *region, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree tm_start = builtin_decl_explicit (BUILT_IN_TM_START);\n+  region->tm_state =\n+    create_tmp_reg (TREE_TYPE (TREE_TYPE (tm_start)), \"tm_state\");\n+\n+  // Reset the subcode, post optimizations.  We'll fill this in\n+  // again as we process blocks.\n+  if (region->exit_blocks)\n+    {\n+      unsigned int subcode\n+\t= gimple_transaction_subcode (region->transaction_stmt);\n+\n+      if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n+\tsubcode &= (GTMA_DECLARATION_MASK | GTMA_DOES_GO_IRREVOCABLE\n+\t\t    | GTMA_MAY_ENTER_IRREVOCABLE);\n+      else\n+\tsubcode &= GTMA_DECLARATION_MASK;\n+      gimple_transaction_set_subcode (region->transaction_stmt, subcode);\n+    }\n+\n+  return NULL;\n+}\n+\n+// Propagate flags from inner transactions outwards.\n+static void\n+propagate_tm_flags_out (struct tm_region *region)\n+{\n+  if (region == NULL)\n+    return;\n+  propagate_tm_flags_out (region->inner);\n+\n+  if (region->outer && region->outer->transaction_stmt)\n+    {\n+      unsigned s = gimple_transaction_subcode (region->transaction_stmt);\n+      s &= (GTMA_HAVE_ABORT | GTMA_HAVE_LOAD | GTMA_HAVE_STORE\n+            | GTMA_MAY_ENTER_IRREVOCABLE);\n+      s |= gimple_transaction_subcode (region->outer->transaction_stmt);\n+      gimple_transaction_set_subcode (region->outer->transaction_stmt, s);\n+    }\n+\n+  propagate_tm_flags_out (region->next);\n+}\n+\n /* Entry point to the MARK phase of TM expansion.  Here we replace\n    transactional memory statements with calls to builtins, and function\n    calls with their transactional clones (if available).  But we don't\n@@ -2526,46 +2824,34 @@ compute_transaction_bits (void)\n static unsigned int\n execute_tm_mark (void)\n {\n-  struct tm_region *region;\n-  basic_block bb;\n-  VEC (basic_block, heap) *queue;\n-  size_t i;\n-\n-  queue = VEC_alloc (basic_block, heap, 10);\n   pending_edge_inserts_p = false;\n \n-  for (region = all_tm_regions; region ; region = region->next)\n-    {\n-      tm_log_init ();\n-      /* If we have a transaction...  */\n-      if (region->exit_blocks)\n-\t{\n-\t  unsigned int subcode\n-\t    = gimple_transaction_subcode (region->transaction_stmt);\n+  expand_regions (all_tm_regions, generate_tm_state, NULL);\n \n-\t  /* Collect a new SUBCODE set, now that optimizations are done...  */\n-\t  if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n-\t    subcode &= (GTMA_DECLARATION_MASK | GTMA_DOES_GO_IRREVOCABLE\n-\t\t\t| GTMA_MAY_ENTER_IRREVOCABLE);\n-\t  else\n-\t    subcode &= GTMA_DECLARATION_MASK;\n-\t  gimple_transaction_set_subcode (region->transaction_stmt, subcode);\n-\t}\n+  tm_log_init ();\n \n-      queue = get_tm_region_blocks (region->entry_block,\n-\t\t\t\t    region->exit_blocks,\n-\t\t\t\t    region->irr_blocks,\n-\t\t\t\t    NULL,\n-\t\t\t\t    /*stop_at_irr_p=*/true);\n-      for (i = 0; VEC_iterate (basic_block, queue, i, bb); ++i)\n-\texpand_block_tm (region, bb);\n-      VEC_free (basic_block, heap, queue);\n+  VEC(tm_region_p, heap) *bb_regions = get_bb_regions_instrumented ();\n+  struct tm_region *r;\n+  unsigned i;\n \n-      tm_log_emit ();\n-    }\n+  // Expand memory operations into calls into the runtime.\n+  // This collects log entries as well.\n+  FOR_EACH_VEC_ELT (tm_region_p, bb_regions, i, r)\n+    if (r != NULL)\n+      expand_block_tm (r, BASIC_BLOCK (i));\n+\n+  // Propagate flags from inner transactions outwards.\n+  propagate_tm_flags_out (all_tm_regions);\n+\n+  // Expand GIMPLE_TRANSACTIONs into calls into the runtime.\n+  expand_regions (all_tm_regions, expand_transaction, NULL);\n+\n+  tm_log_emit ();\n+  tm_log_delete ();\n \n   if (pending_edge_inserts_p)\n     gsi_commit_edge_inserts ();\n+  free_dominance_info (CDI_DOMINATORS);\n   return 0;\n }\n \n@@ -2590,23 +2876,33 @@ struct gimple_opt_pass pass_tm_mark =\n  }\n };\n \f\n-/* Create an abnormal call edge from BB to the first block of the region\n-   represented by STATE.  Also record the edge in the TM_RESTART map.  */\n+\n+/* Create an abnormal edge from STMT at iter, splitting the block\n+   as necessary.  Adjust *PNEXT as needed for the split block.  */\n \n static inline void\n-make_tm_edge (gimple stmt, basic_block bb, struct tm_region *region)\n+split_bb_make_tm_edge (gimple stmt, basic_block dest_bb,\n+                       gimple_stmt_iterator iter, gimple_stmt_iterator *pnext)\n {\n-  void **slot;\n-  struct tm_restart_node *n, dummy;\n+  basic_block bb = gimple_bb (stmt);\n+  if (!gsi_one_before_end_p (iter))\n+    {\n+      edge e = split_block (bb, stmt);\n+      *pnext = gsi_start_bb (e->dest);\n+    }\n+  make_edge (bb, dest_bb, EDGE_ABNORMAL);\n \n+  // Record the need for the edge for the benefit of the rtl passes.\n   if (cfun->gimple_df->tm_restart == NULL)\n     cfun->gimple_df->tm_restart = htab_create_ggc (31, struct_ptr_hash,\n \t\t\t\t\t\t   struct_ptr_eq, ggc_free);\n \n+  struct tm_restart_node dummy;\n   dummy.stmt = stmt;\n-  dummy.label_or_list = gimple_block_label (region->entry_block);\n-  slot = htab_find_slot (cfun->gimple_df->tm_restart, &dummy, INSERT);\n-  n = (struct tm_restart_node *) *slot;\n+  dummy.label_or_list = gimple_block_label (dest_bb);\n+\n+  void **slot = htab_find_slot (cfun->gimple_df->tm_restart, &dummy, INSERT);\n+  struct tm_restart_node *n = (struct tm_restart_node *) *slot;\n   if (n == NULL)\n     {\n       n = ggc_alloc_tm_restart_node ();\n@@ -2616,216 +2912,86 @@ make_tm_edge (gimple stmt, basic_block bb, struct tm_region *region)\n     {\n       tree old = n->label_or_list;\n       if (TREE_CODE (old) == LABEL_DECL)\n-\told = tree_cons (NULL, old, NULL);\n+        old = tree_cons (NULL, old, NULL);\n       n->label_or_list = tree_cons (NULL, dummy.label_or_list, old);\n     }\n-\n-  make_edge (bb, region->entry_block, EDGE_ABNORMAL);\n }\n \n-\n /* Split block BB as necessary for every builtin function we added, and\n    wire up the abnormal back edges implied by the transaction restart.  */\n \n static void\n-expand_block_edges (struct tm_region *region, basic_block bb)\n+expand_block_edges (struct tm_region *const region, basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator gsi, next_gsi;\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi = next_gsi)\n     {\n-      bool do_next = true;\n       gimple stmt = gsi_stmt (gsi);\n \n-      /* ??? TM_COMMIT (and any other tm builtin function) in a nested\n-\t transaction has an abnormal edge back to the outer-most transaction\n-\t (there are no nested retries), while a TM_ABORT also has an abnormal\n-\t backedge to the inner-most transaction.  We haven't actually saved\n-\t the inner-most transaction here.  We should be able to get to it\n-\t via the region_nr saved on STMT, and read the transaction_stmt from\n-\t that, and find the first region block from there.  */\n-      /* ??? Shouldn't we split for any non-pure, non-irrevocable function?  */\n-      if (gimple_code (stmt) == GIMPLE_CALL\n-\t  && (gimple_call_flags (stmt) & ECF_TM_BUILTIN) != 0)\n+      next_gsi = gsi;\n+      gsi_next (&next_gsi);\n+\n+      // ??? Shouldn't we split for any non-pure, non-irrevocable function?\n+      if (gimple_code (stmt) != GIMPLE_CALL\n+\t  || (gimple_call_flags (stmt) & ECF_TM_BUILTIN) == 0)\n+\tcontinue;\n+\n+      if (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)) == BUILT_IN_TM_ABORT)\n \t{\n-\t  if (gsi_one_before_end_p (gsi))\n-\t    make_tm_edge (stmt, bb, region);\n-\t  else\n+\t  // If we have a ``_transaction_cancel [[outer]]'', there is only\n+\t  // one abnormal edge: to the transaction marked OUTER.\n+\t  // All compiler-generated instances of BUILT_IN_TM_ABORT have a\n+\t  // constant argument, which we can examine here.  Users invoking\n+\t  // TM_ABORT directly get what they deserve.\n+\t  tree arg = gimple_call_arg (stmt, 0);\n+\t  if (TREE_CODE (arg) == INTEGER_CST\n+\t      && (TREE_INT_CST_LOW (arg) & AR_OUTERABORT) != 0\n+\t      && !decl_is_tm_clone (current_function_decl))\n \t    {\n-\t      edge e = split_block (bb, stmt);\n-\t      make_tm_edge (stmt, bb, region);\n-\t      bb = e->dest;\n-\t      gsi = gsi_start_bb (bb);\n-\t      do_next = false;\n+\t      // Find the GTMA_IS_OUTER transaction.\n+\t      for (struct tm_region *o = region; o; o = o->outer)\n+\t\tif (o->original_transaction_was_outer)\n+\t\t  {\n+\t\t    split_bb_make_tm_edge (stmt, o->restart_block,\n+\t\t\t\t\t   gsi, &next_gsi);\n+\t\t    break;\n+\t\t  }\n+\n+\t      // Otherwise, the front-end should have semantically checked\n+\t      // outer aborts, but in either case the target region is not\n+\t      // within this function.\n+\t      continue;\n \t    }\n \n-\t  /* Delete any tail-call annotation that may have been added.\n-\t     The tail-call pass may have mis-identified the commit as being\n-\t     a candidate because we had not yet added this restart edge.  */\n-\t  gimple_call_set_tail (stmt, false);\n+\t  // Non-outer, TM aborts have an abnormal edge to the inner-most\n+\t  // transaction, the one being aborted;\n+\t  split_bb_make_tm_edge (stmt, region->restart_block, gsi, &next_gsi);\n \t}\n \n-      if (do_next)\n-\tgsi_next (&gsi);\n-    }\n-}\n-\n-/* Expand the GIMPLE_TRANSACTION statement into the STM library call.  */\n-\n-static void\n-expand_transaction (struct tm_region *region)\n-{\n-  tree status, tm_start;\n-  basic_block atomic_bb, slice_bb;\n-  gimple_stmt_iterator gsi;\n-  tree t1, t2;\n-  gimple g;\n-  int flags, subcode;\n-\n-  tm_start = builtin_decl_explicit (BUILT_IN_TM_START);\n-  status = create_tmp_reg (TREE_TYPE (TREE_TYPE (tm_start)), \"tm_state\");\n-\n-  /* ??? There are plenty of bits here we're not computing.  */\n-  subcode = gimple_transaction_subcode (region->transaction_stmt);\n-  if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n-    flags = PR_DOESGOIRREVOCABLE | PR_UNINSTRUMENTEDCODE;\n-  else\n-    flags = PR_INSTRUMENTEDCODE;\n-  if ((subcode & GTMA_MAY_ENTER_IRREVOCABLE) == 0)\n-    flags |= PR_HASNOIRREVOCABLE;\n-  /* If the transaction does not have an abort in lexical scope and is not\n-     marked as an outer transaction, then it will never abort.  */\n-  if ((subcode & GTMA_HAVE_ABORT) == 0\n-      && (subcode & GTMA_IS_OUTER) == 0)\n-    flags |= PR_HASNOABORT;\n-  if ((subcode & GTMA_HAVE_STORE) == 0)\n-    flags |= PR_READONLY;\n-  t2 = build_int_cst (TREE_TYPE (status), flags);\n-  g = gimple_build_call (tm_start, 1, t2);\n-  gimple_call_set_lhs (g, status);\n-  gimple_set_location (g, gimple_location (region->transaction_stmt));\n-\n-  atomic_bb = gimple_bb (region->transaction_stmt);\n-\n-  if (!VEC_empty (tree, tm_log_save_addresses))\n-    tm_log_emit_saves (region->entry_block, atomic_bb);\n-\n-  gsi = gsi_last_bb (atomic_bb);\n-  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-  gsi_remove (&gsi, true);\n-\n-  if (!VEC_empty (tree, tm_log_save_addresses))\n-    region->entry_block =\n-      tm_log_emit_save_or_restores (region->entry_block,\n-\t\t\t\t    A_RESTORELIVEVARIABLES,\n-\t\t\t\t    status,\n-\t\t\t\t    tm_log_emit_restores,\n-\t\t\t\t    atomic_bb,\n-\t\t\t\t    FALLTHRU_EDGE (atomic_bb),\n-\t\t\t\t    &slice_bb);\n-  else\n-    slice_bb = atomic_bb;\n-\n-  /* If we have an ABORT statement, create a test following the start\n-     call to perform the abort.  */\n-  if (gimple_transaction_label (region->transaction_stmt))\n-    {\n-      edge e;\n-      basic_block test_bb;\n-\n-      test_bb = create_empty_bb (slice_bb);\n-      if (current_loops && slice_bb->loop_father)\n-\tadd_bb_to_loop (test_bb, slice_bb->loop_father);\n-      if (VEC_empty (tree, tm_log_save_addresses))\n-\tregion->entry_block = test_bb;\n-      gsi = gsi_last_bb (test_bb);\n-\n-      t1 = create_tmp_reg (TREE_TYPE (status), NULL);\n-      t2 = build_int_cst (TREE_TYPE (status), A_ABORTTRANSACTION);\n-      g = gimple_build_assign_with_ops (BIT_AND_EXPR, t1, status, t2);\n-      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\n-      t2 = build_int_cst (TREE_TYPE (status), 0);\n-      g = gimple_build_cond (NE_EXPR, t1, t2, NULL, NULL);\n-      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\n-      e = FALLTHRU_EDGE (slice_bb);\n-      redirect_edge_pred (e, test_bb);\n-      e->flags = EDGE_FALSE_VALUE;\n-      e->probability = PROB_ALWAYS - PROB_VERY_UNLIKELY;\n-\n-      e = BRANCH_EDGE (atomic_bb);\n-      redirect_edge_pred (e, test_bb);\n-      e->flags = EDGE_TRUE_VALUE;\n-      e->probability = PROB_VERY_UNLIKELY;\n-\n-      e = make_edge (slice_bb, test_bb, EDGE_FALLTHRU);\n-    }\n-\n-  /* If we've no abort, but we do have PHIs at the beginning of the atomic\n-     region, that means we've a loop at the beginning of the atomic region\n-     that shares the first block.  This can cause problems with the abnormal\n-     edges we're about to add for the transaction restart.  Solve this by\n-     adding a new empty block to receive the abnormal edges.  */\n-  else if (phi_nodes (region->entry_block))\n-    {\n-      edge e;\n-      basic_block empty_bb;\n-\n-      region->entry_block = empty_bb = create_empty_bb (atomic_bb);\n-      if (current_loops && atomic_bb->loop_father)\n-\tadd_bb_to_loop (empty_bb, atomic_bb->loop_father);\n-\n-      e = FALLTHRU_EDGE (atomic_bb);\n-      redirect_edge_pred (e, empty_bb);\n-\n-      e = make_edge (atomic_bb, empty_bb, EDGE_FALLTHRU);\n-    }\n-\n-  /* The GIMPLE_TRANSACTION statement no longer exists.  */\n-  region->transaction_stmt = NULL;\n-}\n-\n-static void expand_regions (struct tm_region *);\n-\n-/* Helper function for expand_regions.  Expand REGION and recurse to\n-   the inner region.  */\n-\n-static void\n-expand_regions_1 (struct tm_region *region)\n-{\n-  if (region->exit_blocks)\n-    {\n-      unsigned int i;\n-      basic_block bb;\n-      VEC (basic_block, heap) *queue;\n+      // All TM builtins have an abnormal edge to the outer-most transaction.\n+      // We never restart inner transactions.  For tm clones, we know a-priori\n+      // that the outer-most transaction is outside the function.\n+      if (decl_is_tm_clone (current_function_decl))\n+\tcontinue;\n \n-      /* Collect the set of blocks in this region.  Do this before\n-\t splitting edges, so that we don't have to play with the\n-\t dominator tree in the middle.  */\n-      queue = get_tm_region_blocks (region->entry_block,\n-\t\t\t\t    region->exit_blocks,\n-\t\t\t\t    region->irr_blocks,\n-\t\t\t\t    NULL,\n-\t\t\t\t    /*stop_at_irr_p=*/false);\n-      expand_transaction (region);\n-      for (i = 0; VEC_iterate (basic_block, queue, i, bb); ++i)\n-\texpand_block_edges (region, bb);\n-      VEC_free (basic_block, heap, queue);\n-    }\n-  if (region->inner)\n-    expand_regions (region->inner);\n-}\n+      if (cfun->gimple_df->tm_restart == NULL)\n+\tcfun->gimple_df->tm_restart\n+\t  = htab_create_ggc (31, struct_ptr_hash, struct_ptr_eq, ggc_free);\n \n-/* Expand regions starting at REGION.  */\n+      // All TM builtins have an abnormal edge to the outer-most transaction.\n+      // We never restart inner transactions.\n+      for (struct tm_region *o = region; o; o = o->outer)\n+\tif (!o->outer)\n+\t  {\n+            split_bb_make_tm_edge (stmt, o->restart_block, gsi, &next_gsi);\n+\t    break;\n+\t  }\n \n-static void\n-expand_regions (struct tm_region *region)\n-{\n-  while (region)\n-    {\n-      expand_regions_1 (region);\n-      region = region->next;\n+      // Delete any tail-call annotation that may have been added.\n+      // The tail-call pass may have mis-identified the commit as being\n+      // a candidate because we had not yet added this restart edge.\n+      gimple_call_set_tail (stmt, false);\n     }\n }\n \n@@ -2834,8 +3000,15 @@ expand_regions (struct tm_region *region)\n static unsigned int\n execute_tm_edges (void)\n {\n-  expand_regions (all_tm_regions);\n-  tm_log_delete ();\n+  VEC(tm_region_p, heap) *bb_regions = get_bb_regions_instrumented ();\n+  struct tm_region *r;\n+  unsigned i;\n+\n+  FOR_EACH_VEC_ELT (tm_region_p, bb_regions, i, r)\n+    if (r != NULL)\n+      expand_block_edges (r, BASIC_BLOCK (i));\n+\n+  VEC_free (tm_region_p, heap, bb_regions);\n \n   /* We've got to release the dominance info now, to indicate that it\n      must be rebuilt completely.  Otherwise we'll crash trying to update\n@@ -2867,6 +3040,54 @@ struct gimple_opt_pass pass_tm_edges =\n   | TODO_verify_ssa,\t\t\t/* todo_flags_finish */\n  }\n };\n+\f\n+/* Helper function for expand_regions.  Expand REGION and recurse to\n+   the inner region.  Call CALLBACK on each region.  CALLBACK returns\n+   NULL to continue the traversal, otherwise a non-null value which\n+   this function will return as well.  */\n+\n+static void *\n+expand_regions_1 (struct tm_region *region,\n+\t\t  void *(*callback)(struct tm_region *, void *),\n+\t\t  void *data)\n+{\n+  void *retval = NULL;\n+  if (region->exit_blocks)\n+    {\n+      retval = callback (region, data);\n+      if (retval)\n+\treturn retval;\n+    }\n+  if (region->inner)\n+    {\n+      retval = expand_regions (region->inner, callback, data);\n+      if (retval)\n+\treturn retval;\n+    }\n+  return retval;\n+}\n+\n+/* Traverse the regions enclosed and including REGION.  Execute\n+   CALLBACK for each region, passing DATA.  CALLBACK returns NULL to\n+   continue the traversal, otherwise a non-null value which this\n+   function will return as well.  */\n+\n+static void *\n+expand_regions (struct tm_region *region,\n+\t\tvoid *(*callback)(struct tm_region *, void *),\n+\t\tvoid *data)\n+{\n+  void *retval = NULL;\n+  while (region)\n+    {\n+      retval = expand_regions_1 (region, callback, data);\n+      if (retval)\n+\treturn retval;\n+      region = region->next;\n+    }\n+  return retval;\n+}\n+\n \f\n /* A unique TM memory operation.  */\n typedef struct tm_memop\n@@ -3657,6 +3878,35 @@ maybe_push_queue (struct cgraph_node *node,\n     }\n }\n \n+/* Duplicate the basic blocks in QUEUE for use in the uninstrumented\n+   code path.  QUEUE are the basic blocks inside the transaction\n+   represented in REGION.\n+\n+   Later in split_code_paths() we will add the conditional to choose\n+   between the two alternatives.  */\n+\n+static void\n+ipa_uninstrument_transaction (struct tm_region *region,\n+\t\t\t      VEC (basic_block, heap) *queue)\n+{\n+  gimple transaction = region->transaction_stmt;\n+  basic_block transaction_bb = gimple_bb (transaction);\n+  int n = VEC_length (basic_block, queue);\n+  basic_block *new_bbs = XNEWVEC (basic_block, n);\n+\n+  copy_bbs (VEC_address (basic_block, queue), n, new_bbs,\n+\t    NULL, 0, NULL, NULL, transaction_bb);\n+  edge e = make_edge (transaction_bb, new_bbs[0], EDGE_TM_UNINSTRUMENTED);\n+  add_phi_args_after_copy (new_bbs, n, e);\n+\n+  // Now we will have a GIMPLE_ATOMIC with 3 possible edges out of it.\n+  //   a) EDGE_FALLTHRU into the transaction\n+  //   b) EDGE_TM_ABORT out of the transaction\n+  //   c) EDGE_TM_UNINSTRUMENTED into the uninstrumented blocks.\n+\n+  free (new_bbs);\n+}\n+\n /* A subroutine of ipa_tm_scan_calls_transaction and ipa_tm_scan_calls_clone.\n    Queue all callees within block BB.  */\n \n@@ -3718,11 +3968,29 @@ ipa_tm_scan_calls_transaction (struct tm_ipa_cg_data *d,\n       bbs = get_tm_region_blocks (r->entry_block, r->exit_blocks, NULL,\n \t\t\t\t  d->transaction_blocks_normal, false);\n \n+      // Generate the uninstrumented code path for this transaction.\n+      ipa_uninstrument_transaction (r, bbs);\n+\n       FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n \tipa_tm_scan_calls_block (callees_p, bb, false);\n \n       VEC_free (basic_block, heap, bbs);\n     }\n+\n+  // ??? copy_bbs should maintain cgraph edges for the blocks as it is\n+  // copying them, rather than forcing us to do this externally.\n+  rebuild_cgraph_edges ();\n+\n+  // ??? In ipa_uninstrument_transaction we don't try to update dominators\n+  // because copy_bbs doesn't return a VEC like iterate_fix_dominators expects.\n+  // Instead, just release dominators here so update_ssa recomputes them.\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  // When building the uninstrumented code path, copy_bbs will have invoked\n+  // create_new_def_for starting an \"ssa update context\".  There is only one\n+  // instance of this context, so resolve ssa updates before moving on to\n+  // the next function.\n+  update_ssa (TODO_update_ssa);\n }\n \n /* Scan all calls in NODE as if this is the transactional clone,\n@@ -4819,6 +5087,7 @@ ipa_tm_execute (void)\n #endif\n \n   bitmap_obstack_initialize (&tm_obstack);\n+  initialize_original_copy_tables ();\n \n   /* For all local functions marked tm_callable, queue them.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n@@ -4852,7 +5121,8 @@ ipa_tm_execute (void)\n \t  {\n \t    d = get_cg_data (&node, true);\n \n-\t    /* Scan for calls that are in each transaction.  */\n+\t    /* Scan for calls that are in each transaction, and\n+\t       generate the uninstrumented code path.  */\n \t    ipa_tm_scan_calls_transaction (d, &tm_callees);\n \n \t    /* Put it in the worklist so we can scan the function\n@@ -5057,6 +5327,7 @@ ipa_tm_execute (void)\n   VEC_free (cgraph_node_p, heap, tm_callees);\n   VEC_free (cgraph_node_p, heap, irr_worklist);\n   bitmap_obstack_release (&tm_obstack);\n+  free_original_copy_tables ();\n \n   FOR_EACH_FUNCTION (node)\n     node->symbol.aux = NULL;\n@@ -5084,7 +5355,7 @@ struct simple_ipa_opt_pass pass_ipa_tm =\n   0,\t\t\t                /* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  0,             \t\t\t/* todo_flags_finish */\n+  TODO_update_ssa,      \t\t/* todo_flags_finish */\n  },\n };\n "}, {"sha": "58ad2a2914d414d43e1d71e0426bc50433ab6744", "filename": "gcc/trans-mem.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftrans-mem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftrans-mem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.h?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -21,6 +21,7 @@\n /* These defines must match the enumerations in libitm.h.  */\n #define PR_INSTRUMENTEDCODE\t0x0001\n #define PR_UNINSTRUMENTEDCODE\t0x0002\n+#define PR_MULTIWAYCODE\t\t(PR_INSTRUMENTEDCODE | PR_UNINSTRUMENTEDCODE)\n #define PR_HASNOXMMUPDATE\t0x0004\n #define PR_HASNOABORT\t\t0x0008\n #define PR_HASNOIRREVOCABLE\t0x0020"}, {"sha": "5f74646ea875c96f8ab24ff80855b13cd8f1bfff", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/398b1daa2d620c9d317f84651c62a6286e476d32/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=398b1daa2d620c9d317f84651c62a6286e476d32", "patch": "@@ -666,7 +666,7 @@ make_edges (void)\n \t      {\n \t\ttree abort_label = gimple_transaction_label (last);\n \t\tif (abort_label)\n-\t\t  make_edge (bb, label_to_block (abort_label), 0);\n+\t\t  make_edge (bb, label_to_block (abort_label), EDGE_TM_ABORT);\n \t\tfallthru = true;\n \t      }\n \t      break;\n@@ -2062,7 +2062,7 @@ gimple_debug_bb_n (int n)\n /* Dump the CFG on stderr.\n \n    FLAGS are the same used by the tree dumping functions\n-   (see TDF_* in tree-pass.h).  */\n+   (see TDF_* in dumpfile.h).  */\n \n void\n gimple_debug_cfg (int flags)\n@@ -6737,7 +6737,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n }\n \n \n-/* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in tree-pass.h)\n+/* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in dumpfile.h)\n    */\n \n void"}]}