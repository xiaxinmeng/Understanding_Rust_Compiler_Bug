{"sha": "d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEzZWNjMmRjNzU3ZDRmZDFkYjk3NzQxYWFhM2Y0NGU1YWExNzY2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2016-06-22T10:51:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:51:37Z"}, "message": "sem_prag.adb: Revert unwanted change in previous commit, only keep message fix.\n\n2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb: Revert unwanted change in previous commit,\n\tonly keep message fix.\n\nFrom-SVN: r237699", "tree": {"sha": "92c6eb71f663dcaf3389f2ef6344aee43f244e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92c6eb71f663dcaf3389f2ef6344aee43f244e2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "017d237edea10a76df68065e0be70be518b68217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017d237edea10a76df68065e0be70be518b68217", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017d237edea10a76df68065e0be70be518b68217"}], "stats": {"total": 590, "additions": 296, "deletions": 294}, "files": [{"sha": "c24cc040c4c14e470f5f3dcabece4f4f8f30c514", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "patch": "@@ -1,3 +1,8 @@\n+2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb: Revert unwanted change in previous commit,\n+\tonly keep message fix.\n+\n 2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.ads (Build_Classwide_Expression): new procedure to"}, {"sha": "c9213f18fbde96f72cc770977af37d0dde825588", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 291, "deletions": 294, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d13ecc2dc757d4fd1db97741aaa3f44e5aa1766d", "patch": "@@ -44,7 +44,6 @@ with Exp_Dist;  use Exp_Dist;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n-with Gnatvsn;   use Gnatvsn;\n with Lib;       use Lib;\n with Lib.Writ;  use Lib.Writ;\n with Lib.Xref;  use Lib.Xref;\n@@ -166,39 +165,39 @@ package body Sem_Prag is\n      Table_Increment      => 100,\n      Table_Name           => \"Name_Externals\");\n \n-     --------------------------------------------------------\n-     -- Handling of inherited classwide pre/postconditions --\n-     --------------------------------------------------------\n-\n-     --  Following AI12-0113, the expression for a classwide condition is\n-     --  transformed for a subprogram that inherits it, by replacing calls\n-     --  to primitive operations of the original controlling type into the\n-     --  corresponding overriding operations of the derived type. The following\n-     --  hash table manages this mapping, and is expanded on demand whenever\n-     --  such inherited expression needs to be constructed.\n-\n-     --  The mapping is also used to check whether an inherited operation has\n-     --  a condition that depends on overridden operations. For such an\n-     --  operation we must create a wrapper that is then treated as a normal\n-     --  overriding. In SPARK mode such operations are illegal.\n-\n-     --  For a given root type there may be several type extensions with their\n-     --  own overriding operations, so at various times a given operation of\n-     --  the root will be mapped into different overridings. The root type is\n-     --  also mapped into the current type extension to indicate that its\n-     --  operations are mapped into the overriding operations of that current\n-     --  type extension.\n-\n-      subtype Num_Primitives is Integer range 0 .. 510;\n-      function Entity_Hash (E : Entity_Id) return Num_Primitives;\n-\n-      package Primitives_Mapping is new Gnat.HTable.Simple_Htable\n-        (Header_Num => Num_Primitives,\n-         Key        => Entity_Id,\n-         Element    => Entity_Id,\n-         No_element => Empty,\n-         Hash       => Entity_Hash,\n-         Equal      => \"=\");\n+   --------------------------------------------------------\n+   -- Handling of inherited classwide pre/postconditions --\n+   --------------------------------------------------------\n+\n+   --  Following AI12-0113, the expression for a classwide condition is\n+   --  transformed for a subprogram that inherits it, by replacing calls\n+   --  to primitive operations of the original controlling type into the\n+   --  corresponding overriding operations of the derived type. The following\n+   --  hash table manages this mapping, and is expanded on demand whenever\n+   --  such inherited expression needs to be constructed.\n+\n+   --  The mapping is also used to check whether an inherited operation has\n+   --  a condition that depends on overridden operations. For such an\n+   --  operation we must create a wrapper that is then treated as a normal\n+   --  overriding. In SPARK mode such operations are illegal.\n+\n+   --  For a given root type there may be several type extensions with their\n+   --  own overriding operations, so at various times a given operation of\n+   --  the root will be mapped into different overridings. The root type is\n+   --  also mapped into the current type extension to indicate that its\n+   --  operations are mapped into the overriding operations of that current\n+   --  type extension.\n+\n+   subtype Num_Primitives is Integer range 0 .. 510;\n+   function Entity_Hash (E : Entity_Id) return Num_Primitives;\n+\n+   package Primitives_Mapping is new Gnat.HTable.Simple_Htable\n+     (Header_Num => Num_Primitives,\n+      Key        => Entity_Id,\n+      Element    => Entity_Id,\n+      No_element => Empty,\n+      Hash       => Entity_Hash,\n+      Equal      => \"=\");\n \n    -------------------------------------\n    -- Local Subprograms and Variables --\n@@ -230,11 +229,6 @@ package body Sem_Prag is\n    --  Query whether a particular item appears in a mixed list of nodes and\n    --  entities. It is assumed that all nodes in the list have entities.\n \n-   --  procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id);\n-   --  Build the expression for an inherited classwide condition. Prag is\n-   --  the pragma constructed from the corresponding aspect of the parent\n-   --  subprogram, and Subp is the overridding operation.\n-\n    procedure Check_Postcondition_Use_In_Inlined_Subprogram\n      (Prag    : Node_Id;\n       Spec_Id : Entity_Id);\n@@ -327,18 +321,17 @@ package body Sem_Prag is\n    --  pragma. Entity name for unit and its parents is taken from item in\n    --  previous with_clause that mentions the unit.\n \n-   Dummy : Integer := 0;\n-   pragma Volatile (Dummy);\n-   --  Dummy volatile integer used in bodies of ip/rv to prevent optimization\n-\n    procedure Update_Primitives_Mapping\n      (Inher_Id : Entity_Id;\n       Subp_Id  : Entity_Id);\n-\n-   --  map primitive operations of the parent type to the corresponding\n-   --  operations of the descendant. note that the descendant type may\n+   --  Map primitive operations of the parent type to the corresponding\n+   --  operations of the descendant. Note that the descendant type may\n    --  not be frozen yet, so we cannot use the dispatch table directly.\n \n+   Dummy : Integer := 0;\n+   pragma Volatile (Dummy);\n+   --  Dummy volatile integer used in bodies of ip/rv to prevent optimization\n+\n    procedure ip;\n    pragma No_Inline (ip);\n    --  A dummy procedure called when pragma Inspection_Point is analyzed. This\n@@ -17630,39 +17623,28 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (0);\n \n-            --  Remove backward compatibility if Build_Type is FSF or GPL\n-            --  and generate a warning.\n-\n-            declare\n-               Ignore : constant Boolean := Build_Type in FSF .. GPL;\n-            begin\n-               if Ignore then\n-                  Error_Pragma (\"pragma% is ignored, has no effect??\");\n-               else\n-                  No_Run_Time_Mode           := True;\n-                  Configurable_Run_Time_Mode := True;\n+            No_Run_Time_Mode           := True;\n+            Configurable_Run_Time_Mode := True;\n \n-                  --  Set Duration to 32 bits if word size is 32\n+            --  Set Duration to 32 bits if word size is 32\n \n-                  if Ttypes.System_Word_Size = 32 then\n-                     Duration_32_Bits_On_Target := True;\n-                  end if;\n+            if Ttypes.System_Word_Size = 32 then\n+               Duration_32_Bits_On_Target := True;\n+            end if;\n \n-                  --  Set appropriate restrictions\n+            --  Set appropriate restrictions\n \n-                  Set_Restriction (No_Finalization, N);\n-                  Set_Restriction (No_Exception_Handlers, N);\n-                  Set_Restriction (Max_Tasks, N, 0);\n-                  Set_Restriction (No_Tasking, N);\n-               end if;\n-            end;\n+            Set_Restriction (No_Finalization, N);\n+            Set_Restriction (No_Exception_Handlers, N);\n+            Set_Restriction (Max_Tasks, N, 0);\n+            Set_Restriction (No_Tasking, N);\n \n-         -----------------------\n-         -- No_Tagged_Streams --\n-         -----------------------\n+            -----------------------\n+            -- No_Tagged_Streams --\n+            -----------------------\n \n-         --  pragma No_Tagged_Streams;\n-         --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n+            --  pragma No_Tagged_Streams;\n+            --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n \n          when Pragma_No_Tagged_Streams => No_Tagged_Strms : declare\n             E    : Entity_Id;\n@@ -22356,7 +22338,22 @@ package body Sem_Prag is\n \n          when Pragma_Universal_Data =>\n             GNAT_Pragma;\n-            Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n+\n+            --  If this is a configuration pragma, then set the universal\n+            --  addressing option, otherwise confirm that the pragma satisfies\n+            --  the requirements of library unit pragma placement and leave it\n+            --  to the GNAAMP back end to detect the pragma (avoids transitive\n+            --  setting of the option due to withed units).\n+\n+            if Is_Configuration_Pragma then\n+               Universal_Addressing_On_AAMP := True;\n+            else\n+               Check_Valid_Library_Unit_Pragma;\n+            end if;\n+\n+            if not AAMP_On_Target then\n+               Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n+            end if;\n \n          ----------------\n          -- Unmodified --\n@@ -26327,6 +26324,103 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n+   --------------------------------\n+   -- Build_Classwide_Expression --\n+   --------------------------------\n+\n+   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id) is\n+      function Replace_Entity (N : Node_Id) return Traverse_Result;\n+      --  Replace reference to formal of inherited operation or to primitive\n+      --  operation of root type, with corresponding entity for derived type,\n+      --  when constructing the classwide condition of an overridding\n+      --  subprogram.\n+\n+      --------------------\n+      -- Replace_Entity --\n+      --------------------\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result is\n+         New_E : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then Present (Entity (N))\n+           and then\n+             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+           and then\n+             (Nkind (Parent (N)) /= N_Attribute_Reference\n+               or else Attribute_Name (Parent (N)) /= Name_Class)\n+         then\n+            --  The replacement does not apply to dispatching calls within the\n+            --  condition, but only to calls whose static tag is that of the\n+            --  parent type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then Present (Controlling_Argument (Parent (N)))\n+            then\n+               return OK;\n+            end if;\n+\n+            --  Determine whether entity has a renaming\n+\n+            New_E := Primitives_Mapping.Get (Entity (N));\n+\n+            if Present (New_E) then\n+               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n+            end if;\n+\n+            --  Check that there are no calls left to abstract operations if\n+            --  the current subprogram is not abstract.\n+\n+            if Nkind (Parent (N)) = N_Function_Call\n+              and then N = Name (Parent (N))\n+            then\n+               if not Is_Abstract_Subprogram (Subp)\n+                 and then Is_Abstract_Subprogram (Entity (N))\n+               then\n+                  Error_Msg_Sloc := Sloc (Current_Scope);\n+                  Error_Msg_NE\n+                    (\"cannot call abstract subprogram in inherited condition \"\n+                      & \"for&#\", N, Current_Scope);\n+\n+               elsif SPARK_Mode = On\n+                 and then Warn_On_Suspicious_Contract\n+                 and then Present (Alias (Subp))\n+               then\n+                  Error_Msg_NE\n+                    (\"?inherited condition is modified, build a wrapper \"\n+                     & \"for&\", Parent (Subp), Subp);\n+               end if;\n+            end if;\n+\n+            --  Update type of function call node, which should be the same as\n+            --  the function's return type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+            then\n+               Set_Etype (Parent (N), Etype (Entity (N)));\n+            end if;\n+\n+         --  The whole expression will be reanalyzed\n+\n+         elsif Nkind (N) in N_Has_Etype then\n+            Set_Analyzed (N, False);\n+         end if;\n+\n+         return OK;\n+      end Replace_Entity;\n+\n+      procedure Replace_Condition_Entities is\n+        new Traverse_Proc (Replace_Entity);\n+\n+   --  Start of processing for Build_Classwide_Expression\n+\n+   begin\n+      Replace_Condition_Entities (Prag);\n+   end Build_Classwide_Expression;\n+\n    -----------------------------------\n    -- Build_Pragma_Check_Equivalent --\n    -----------------------------------\n@@ -26337,7 +26431,6 @@ package body Sem_Prag is\n       Inher_Id       : Entity_Id := Empty;\n       Keep_Pragma_Id : Boolean := False) return Node_Id\n    is\n-\n       function Suppress_Reference (N : Node_Id) return Traverse_Result;\n       --  Detect whether node N references a formal parameter subject to\n       --  pragma Unreferenced. If this is the case, set Comes_From_Source\n@@ -26355,9 +26448,9 @@ package body Sem_Prag is\n          if Is_Entity_Name (N) and then Present (Entity (N)) then\n             Formal := Entity (N);\n \n-            --  The formal parameter is subject to pragma Unreferenced.\n-            --  Prevent the generation of a reference by resetting the\n-            --  Comes_From_Source flag.\n+            --  The formal parameter is subject to pragma Unreferenced. Prevent\n+            --  the generation of references by resetting the Comes_From_Source\n+            --  flag.\n \n             if Is_Formal (Formal)\n               and then Has_Pragma_Unreferenced (Formal)\n@@ -26835,100 +26928,6 @@ package body Sem_Prag is\n       end if;\n    end Check_Missing_Part_Of;\n \n-   --------------------------------\n-   -- Build_Classwide_Expression --\n-   --------------------------------\n-\n-   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id) is\n-      function Replace_Entity (N : Node_Id) return Traverse_Result;\n-      --  Replace reference to formal of inherited operation or to primitive\n-      --  operation of root type, with corresponding entity for derived type,\n-      --  when constructing the classwide condition of an overridding\n-      --  subprogram.\n-\n-      --------------------\n-      -- Replace_Entity --\n-      --------------------\n-\n-      function Replace_Entity (N : Node_Id) return Traverse_Result is\n-         New_E : Entity_Id;\n-\n-      begin\n-         if Nkind (N) = N_Identifier\n-           and then Present (Entity (N))\n-           and then\n-             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n-           and then\n-             (Nkind (Parent (N)) /= N_Attribute_Reference\n-               or else Attribute_Name (Parent (N)) /= Name_Class)\n-         then\n-            --  The replacement does not apply to dispatching calls within the\n-            --  condition, but only to calls whose static tag is that of the\n-            --  parent type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-              and then Present (Controlling_Argument (Parent (N)))\n-            then\n-               return OK;\n-            end if;\n-\n-            --  Determine whether entity has a renaming\n-\n-            New_E := Primitives_Mapping.Get (Entity (N));\n-\n-            if Present (New_E) then\n-               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n-            end if;\n-\n-            --  Check that there are no calls left to abstract operations if\n-            --  the current subprogram is not abstract.\n-\n-            if Nkind (Parent (N)) = N_Function_Call\n-              and then N = Name (Parent (N))\n-            then\n-               if not Is_Abstract_Subprogram (Subp)\n-                 and then Is_Abstract_Subprogram (Entity (N))\n-               then\n-                  Error_Msg_Sloc := Sloc (Current_Scope);\n-                  Error_Msg_NE\n-                    (\"cannot call abstract subprogram in inherited condition \"\n-                      & \"for&#\", N, Current_Scope);\n-\n-               elsif Present (Alias (Subp))\n-                 and then Warn_On_Suspicious_Contract\n-                 and then SPARK_Mode = On\n-               then\n-                  Error_Msg_NE (\"?inherited condition is modified, \"\n-                  & \"build a wrapper for&\", Parent (Subp), Subp);\n-               end if;\n-            end if;\n-\n-            --  Update type of function call node, which should be the same as\n-            --  the function's return type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-            then\n-               Set_Etype (Parent (N), Etype (Entity (N)));\n-            end if;\n-\n-         --  The whole expression will be reanalyzed\n-\n-         elsif Nkind (N) in N_Has_Etype then\n-            Set_Analyzed (N, False);\n-         end if;\n-\n-         return OK;\n-      end Replace_Entity;\n-\n-      procedure Replace_Condition_Entities is\n-        new Traverse_Proc (Replace_Entity);\n-\n-   begin\n-      Replace_Condition_Entities (Prag);\n-   end Build_Classwide_Expression;\n-\n    ---------------------------------------------------\n    -- Check_Postcondition_Use_In_Inlined_Subprogram --\n    ---------------------------------------------------\n@@ -27489,6 +27488,15 @@ package body Sem_Prag is\n       end if;\n    end Duplication_Error;\n \n+   -----------------\n+   -- Entity_Hash --\n+   -----------------\n+\n+   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n+   begin\n+      return Num_Primitives (E mod 511);\n+   end Entity_Hash;\n+\n    --------------------------\n    -- Find_Related_Context --\n    --------------------------\n@@ -27848,15 +27856,6 @@ package body Sem_Prag is\n       return Result;\n    end Get_Base_Subprogram;\n \n-   -----------------\n-   -- Entity_Hash --\n-   -----------------\n-\n-   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n-   begin\n-      return Num_Primitives (E mod 511);\n-   end Entity_Hash;\n-\n    -----------------------\n    -- Get_SPARK_Mode_Type --\n    -----------------------\n@@ -29104,6 +29103,102 @@ package body Sem_Prag is\n       Generate_Reference (Entity (With_Item), N, Set_Ref => False);\n    end Set_Elab_Unit_Name;\n \n+   -------------------\n+   -- Test_Case_Arg --\n+   -------------------\n+\n+   function Test_Case_Arg\n+     (Prag        : Node_Id;\n+      Arg_Nam     : Name_Id;\n+      From_Aspect : Boolean := False) return Node_Id\n+   is\n+      Aspect : constant Node_Id := Corresponding_Aspect (Prag);\n+      Arg    : Node_Id;\n+      Args   : Node_Id;\n+\n+   begin\n+      pragma Assert (Nam_In (Arg_Nam, Name_Ensures,\n+                                      Name_Mode,\n+                                      Name_Name,\n+                                      Name_Requires));\n+\n+      --  The caller requests the aspect argument\n+\n+      if From_Aspect then\n+         if Present (Aspect)\n+           and then Nkind (Expression (Aspect)) = N_Aggregate\n+         then\n+            Args := Expression (Aspect);\n+\n+            --  \"Name\" and \"Mode\" may appear without an identifier as a\n+            --  positional association.\n+\n+            if Present (Expressions (Args)) then\n+               Arg := First (Expressions (Args));\n+\n+               if Present (Arg) and then Arg_Nam = Name_Name then\n+                  return Arg;\n+               end if;\n+\n+               --  Skip \"Name\"\n+\n+               Arg := Next (Arg);\n+\n+               if Present (Arg) and then Arg_Nam = Name_Mode then\n+                  return Arg;\n+               end if;\n+            end if;\n+\n+            --  Some or all arguments may appear as component associatons\n+\n+            if Present (Component_Associations (Args)) then\n+               Arg := First (Component_Associations (Args));\n+               while Present (Arg) loop\n+                  if Chars (First (Choices (Arg))) = Arg_Nam then\n+                     return Arg;\n+                  end if;\n+\n+                  Next (Arg);\n+               end loop;\n+            end if;\n+         end if;\n+\n+      --  Otherwise retrieve the argument directly from the pragma\n+\n+      else\n+         Arg := First (Pragma_Argument_Associations (Prag));\n+\n+         if Present (Arg) and then Arg_Nam = Name_Name then\n+            return Arg;\n+         end if;\n+\n+         --  Skip argument \"Name\"\n+\n+         Arg := Next (Arg);\n+\n+         if Present (Arg) and then Arg_Nam = Name_Mode then\n+            return Arg;\n+         end if;\n+\n+         --  Skip argument \"Mode\"\n+\n+         Arg := Next (Arg);\n+\n+         --  Arguments \"Requires\" and \"Ensures\" are optional and may not be\n+         --  present at all.\n+\n+         while Present (Arg) loop\n+            if Chars (Arg) = Arg_Nam then\n+               return Arg;\n+            end if;\n+\n+            Next (Arg);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Test_Case_Arg;\n+\n    -------------------------------\n    -- Update_Primitives_Mapping --\n    -------------------------------\n@@ -29113,6 +29208,7 @@ package body Sem_Prag is\n       Subp_Id  : Entity_Id)\n    is\n       function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n+      --  ??? what does this routine do?\n \n       -------------------------\n       -- Overridden_Ancestor --\n@@ -29125,8 +29221,7 @@ package body Sem_Prag is\n       begin\n          Anc := S;\n \n-         --  Locate the ancestor subprogram with the proper controlling\n-         --  type.\n+         --  Locate the ancestor subprogram with the proper controlling type\n \n          while Present (Overridden_Operation (Anc)) loop\n             Anc := Overridden_Operation (Anc);\n@@ -29148,21 +29243,20 @@ package body Sem_Prag is\n    --  Start of processing for Primitive_Mapping\n \n    begin\n-      --  if the types are already in the map, it has been previously built\n-      --  for some other overriding primitive.\n+      --  If the types are already in the map, it has been previously built for\n+      --  some other overriding primitive.\n \n-      if Primitives_Mapping.Get (Old_Typ)  = Typ then\n+      if Primitives_Mapping.Get (Old_Typ) = Typ then\n          return;\n \n       else\n-\n-         --  initialize new mapping with the primitive operations.\n+         --  Initialize new mapping with the primitive operations\n \n          Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n \n-         --  look for primitive operations of the current type that have\n+         --  Look for primitive operations of the current type that have\n          --  overridden an operation of the type related to the original\n-         --  class-wide precondition. there may be several intermediate\n+         --  class-wide precondition. There may be several intermediate\n          --  overridings between them.\n \n          while Present (Decl) loop\n@@ -29184,10 +29278,10 @@ package body Sem_Prag is\n             Next (Decl);\n          end loop;\n \n-         --  now examine inherited operations. these do not override, but have\n-         --  an alias, which is the entity used in a call. that alias may be\n+         --  Now examine inherited operations. these do not override, but have\n+         --  an alias, which is the entity used in a call. That alias may be\n          --  inherited or come from source, in which case it may override an\n-         --  earlier operation. we only need to examine inherited functions,\n+         --  earlier operation. We only need to examine inherited functions,\n          --  that can appear within the inherited expression.\n \n          Prim := First_Entity (Scope (Subp_Id));\n@@ -29220,10 +29314,9 @@ package body Sem_Prag is\n             Next_Entity (Prim);\n          end loop;\n \n-         --  if the parent operation is an interface operation, the\n-         --  overriding indicator is not present. instead, we get from\n-         --  the interface operation the primitive of the current type\n-         --  that implements it.\n+         --  If the parent operation is an interface operation, the overriding\n+         --  indicator is not present. Instead, we get from the interface\n+         --  operation the primitive of the current type that implements it.\n \n          if Is_Interface (Old_Typ) then\n             Old_Elmt := First_Elmt (Collect_Primitive_Operations (Old_Typ));\n@@ -29240,106 +29333,10 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n-      --  map the types themselves, so that the process is not repeated for\n+      --  Map the types themselves, so that the process is not repeated for\n       --  other overriding primitives.\n \n       Primitives_Mapping.Set (Old_Typ, Typ);\n    end Update_Primitives_Mapping;\n \n-   -------------------\n-   -- Test_Case_Arg --\n-   -------------------\n-\n-   function Test_Case_Arg\n-     (Prag        : Node_Id;\n-      Arg_Nam     : Name_Id;\n-      From_Aspect : Boolean := False) return Node_Id\n-   is\n-      Aspect : constant Node_Id := Corresponding_Aspect (Prag);\n-      Arg    : Node_Id;\n-      Args   : Node_Id;\n-\n-   begin\n-      pragma Assert (Nam_In (Arg_Nam, Name_Ensures,\n-                                      Name_Mode,\n-                                      Name_Name,\n-                                      Name_Requires));\n-\n-      --  The caller requests the aspect argument\n-\n-      if From_Aspect then\n-         if Present (Aspect)\n-           and then Nkind (Expression (Aspect)) = N_Aggregate\n-         then\n-            Args := Expression (Aspect);\n-\n-            --  \"Name\" and \"Mode\" may appear without an identifier as a\n-            --  positional association.\n-\n-            if Present (Expressions (Args)) then\n-               Arg := First (Expressions (Args));\n-\n-               if Present (Arg) and then Arg_Nam = Name_Name then\n-                  return Arg;\n-               end if;\n-\n-               --  Skip \"Name\"\n-\n-               Arg := Next (Arg);\n-\n-               if Present (Arg) and then Arg_Nam = Name_Mode then\n-                  return Arg;\n-               end if;\n-            end if;\n-\n-            --  Some or all arguments may appear as component associatons\n-\n-            if Present (Component_Associations (Args)) then\n-               Arg := First (Component_Associations (Args));\n-               while Present (Arg) loop\n-                  if Chars (First (Choices (Arg))) = Arg_Nam then\n-                     return Arg;\n-                  end if;\n-\n-                  Next (Arg);\n-               end loop;\n-            end if;\n-         end if;\n-\n-      --  Otherwise retrieve the argument directly from the pragma\n-\n-      else\n-         Arg := First (Pragma_Argument_Associations (Prag));\n-\n-         if Present (Arg) and then Arg_Nam = Name_Name then\n-            return Arg;\n-         end if;\n-\n-         --  Skip argument \"Name\"\n-\n-         Arg := Next (Arg);\n-\n-         if Present (Arg) and then Arg_Nam = Name_Mode then\n-            return Arg;\n-         end if;\n-\n-         --  Skip argument \"Mode\"\n-\n-         Arg := Next (Arg);\n-\n-         --  Arguments \"Requires\" and \"Ensures\" are optional and may not be\n-         --  present at all.\n-\n-         while Present (Arg) loop\n-            if Chars (Arg) = Arg_Nam then\n-               return Arg;\n-            end if;\n-\n-            Next (Arg);\n-         end loop;\n-      end if;\n-\n-      return Empty;\n-   end Test_Case_Arg;\n-\n end Sem_Prag;"}]}