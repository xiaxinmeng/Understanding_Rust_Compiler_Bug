{"sha": "7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMzOWM4OGRjNThkM2Y2NGEyOGU4ZjA4ZmU5ZWQ0Y2Y5MjliZTdhMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T22:57:54Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-04T22:57:54Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r888", "tree": {"sha": "c919150c2d673b62e735c3e440b25c7de6616e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c919150c2d673b62e735c3e440b25c7de6616e33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0/comments", "author": null, "committer": null, "parents": [{"sha": "8241a41f2a3055cf85818dea5502a668d0881be8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8241a41f2a3055cf85818dea5502a668d0881be8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8241a41f2a3055cf85818dea5502a668d0881be8"}], "stats": {"total": 450, "additions": 306, "deletions": 144}, "files": [{"sha": "73c09eb2f8246338411e138c6f056a6448620dd8", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 306, "deletions": 144, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=7339c88dc58d3f64a28e8f08fe9ed4cf929be7a0", "patch": "@@ -90,8 +90,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n \n-static struct obstack obstack;\n+static struct obstack obstack, obstack1;\n struct obstack *rtl_obstack = &obstack;\n+struct obstack *hash_obstack = &obstack1;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -256,6 +257,7 @@ static void check_defs ();\n static rtx convert_const_symbol_ref ();\n static rtx make_canonical ();\n static struct attr_value *get_attr_value ();\n+static rtx copy_rtx_unchanging ();\n static void expand_delays ();\n static rtx operate_exp ();\n static void expand_units ();\n@@ -348,7 +350,8 @@ attr_hash_add_rtx (hashcode, rtl)\n {\n   register struct attr_hash *h;\n \n-  h = (struct attr_hash *) xmalloc (sizeof (struct attr_hash));\n+  h = (struct attr_hash *) obstack_alloc (hash_obstack,\n+\t\t\t\t\t  sizeof (struct attr_hash));\n   h->hashcode = hashcode;\n   h->u.rtl = rtl;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -364,7 +367,8 @@ attr_hash_add_string (hashcode, str)\n {\n   register struct attr_hash *h;\n \n-  h = (struct attr_hash *) xmalloc (sizeof (struct attr_hash));\n+  h = (struct attr_hash *) obstack_alloc (hash_obstack,\n+\t\t\t\t\t  sizeof (struct attr_hash));\n   h->hashcode = -hashcode;\n   h->u.str = str;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -388,6 +392,7 @@ attr_rtx (va_alist)\n   register rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n   int hashcode;\n   register struct attr_hash *h;\n+  struct obstack *old_obstack = rtl_obstack;\n \n   va_start (p);\n   code = va_arg (p, enum rtx_code);\n@@ -409,6 +414,7 @@ attr_rtx (va_alist)\n \n       if (h == 0)\n \t{\n+\t  rtl_obstack = hash_obstack;\n \t  rt_val = rtx_alloc (code);\n \t  XEXP (rt_val, 0) = arg0;\n \t}\n@@ -430,6 +436,7 @@ attr_rtx (va_alist)\n \n       if (h == 0)\n \t{\n+\t  rtl_obstack = hash_obstack;\n \t  rt_val = rtx_alloc (code);\n \t  XEXP (rt_val, 0) = arg0;\n \t  XEXP (rt_val, 1) = arg1;\n@@ -449,6 +456,7 @@ attr_rtx (va_alist)\n \n       if (h == 0)\n \t{\n+\t  rtl_obstack = hash_obstack;\n \t  rt_val = rtx_alloc (code);\n \t  XSTR (rt_val, 0) = arg0;\n \t}\n@@ -470,6 +478,7 @@ attr_rtx (va_alist)\n \n       if (h == 0)\n \t{\n+\t  rtl_obstack = hash_obstack;\n \t  rt_val = rtx_alloc (code);\n \t  XSTR (rt_val, 0) = arg0;\n \t  XSTR (rt_val, 1) = arg1;\n@@ -512,6 +521,7 @@ attr_rtx (va_alist)\n       return rt_val;\n     }\n \n+  rtl_obstack = old_obstack;\n   va_end (p);\n   attr_hash_add_rtx (hashcode, rt_val);\n   return rt_val;\n@@ -649,7 +659,7 @@ check_attr_test (exp, is_const)\n \t\t  RTX_UNCHANGING_P (exp) = 1;\n \t\t  return exp;\n \t\t}\n-\t    else\n+\t      else\n \t\tfatal (\"Unknown attribute `%s' in EQ_ATTR\", XEXP (exp, 0));\n \t    }\n \n@@ -1053,16 +1063,26 @@ make_canonical (attr, exp)\n \n     case COND:\n     cond:\n-      /* First, check for degenerate COND. */\n-      if (XVECLEN (exp, 0) == 0)\n-\treturn make_canonical (attr, XEXP (exp, 1));\n+      {\n+\tint allsame = 1;\n+\trtx defval;\n \n-      for (i = 0; i < XVECLEN (exp, 0); i += 2)\n-\tXVECEXP (exp, 0, i + 1)\n-\t\t= make_canonical (attr, XVECEXP (exp, 0, i + 1));\n+\t/* First, check for degenerate COND. */\n+\tif (XVECLEN (exp, 0) == 0)\n+\t  return make_canonical (attr, XEXP (exp, 1));\n+\tdefval = XEXP (exp, 1) = make_canonical (attr, XEXP (exp, 1));\n \n-      XEXP (exp, 1) = make_canonical (attr, XEXP (exp, 1));\n-      break;\n+\tfor (i = 0; i < XVECLEN (exp, 0); i += 2)\n+\t  {\n+\t    XVECEXP (exp, 0, i + 1)\n+\t      = make_canonical (attr, XVECEXP (exp, 0, i + 1));\n+\t    if (! rtx_equal_p (XVECEXP (exp, 0, i + 1), defval))\n+\t      allsame = 0;\n+\t  }\n+\tif (allsame)\n+\t  return defval;\n+\tbreak;\n+      }\n     }\n \n   return exp;\n@@ -1261,22 +1281,46 @@ operate_exp (op, left, right)\n       else if (GET_CODE (right) == IF_THEN_ELSE)\n \t{\n \t  /* Apply recursively to all values within.  */\n-\t  return attr_rtx (IF_THEN_ELSE, XEXP (right, 0),\n-\t\t\t   operate_exp (op, left, XEXP (right, 1)),\n-\t\t\t   operate_exp (op, left, XEXP (right, 2)));\n+\t  rtx newleft = operate_exp (op, left, XEXP (right, 1));\n+\t  rtx newright = operate_exp (op, left, XEXP (right, 2));\n+\t  if (rtx_equal_p (newleft, newright))\n+\t    return newleft;\n+\t  return attr_rtx (IF_THEN_ELSE, XEXP (right, 0), newleft, newright);\n \t}\n       else if (GET_CODE (right) == COND)\n \t{\n+\t  int allsame = 1;\n+\t  rtx defval;\n+\n \t  newexp = rtx_alloc (COND);\n \t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (right, 0));\n+\t  defval = XEXP (newexp, 1) = operate_exp (op, left, XEXP (right, 1));\n+\n \t  for (i = 0; i < XVECLEN (right, 0); i += 2)\n \t    {\n \t      XVECEXP (newexp, 0, i) = XVECEXP (right, 0, i);\n \t      XVECEXP (newexp, 0, i + 1)\n \t\t= operate_exp (op, left, XVECEXP (right, 0, i + 1));\n+\t      if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n+\t\t\t\t defval))     \n+\t\tallsame = 0;\n \t    }\n \n-\t  XEXP (newexp, 1) = operate_exp (op, left, XEXP (right, 1));\n+\t  /* If the resulting cond is trivial (all alternatives\n+\t     give the same value), optimize it away.  */\n+\t  if (allsame)\n+\t    {\n+\t      obstack_free (rtl_obstack, newexp);\n+\t      return operate_exp (op, left, XEXP (right, 1));\n+\t    }\n+\n+\t  /* If the result is the same as the RIGHT operand,\n+\t     just use that.  */\n+\t  if (rtx_equal_p (newexp, right))\n+\t    {\n+\t      obstack_free (rtl_obstack, newexp);\n+\t      return right;\n+\t    }\n \n \t  return newexp;\n \t}\n@@ -1287,23 +1331,46 @@ operate_exp (op, left, right)\n   /* Otherwise, do recursion the other way.  */\n   else if (GET_CODE (left) == IF_THEN_ELSE)\n     {\n-      return attr_rtx (IF_THEN_ELSE, XEXP (left, 0),\n-\t\t       operate_exp (op, XEXP (left, 1), right),\n-\t\t       operate_exp (op, XEXP (left, 2), right));\n+      rtx newleft = operate_exp (op, XEXP (left, 1), right);\n+      rtx newright = operate_exp (op, XEXP (left, 2), right);\n+      if (rtx_equal_p (newleft, newright))\n+\treturn newleft;\n+      return attr_rtx (IF_THEN_ELSE, XEXP (left, 0), newleft, newright);\n     }\n-\n   else if (GET_CODE (left) == COND)\n     {\n+      int allsame = 1;\n+      rtx defval;\n+\n       newexp = rtx_alloc (COND);\n       XVEC (newexp, 0) = rtvec_alloc (XVECLEN (left, 0));\n+      defval = XEXP (newexp, 1) = operate_exp (op, XEXP (left, 1), right);\n+\n       for (i = 0; i < XVECLEN (left, 0); i += 2)\n \t{\n \t  XVECEXP (newexp, 0, i) = XVECEXP (left, 0, i);\n \t  XVECEXP (newexp, 0, i + 1)\n \t    = operate_exp (op, XVECEXP (left, 0, i + 1), right);\n+\t  if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n+\t\t\t     defval))     \n+\t    allsame = 0;\n \t}\n \n-      XEXP (newexp, 1) = operate_exp (op, XEXP (left, 1), right);\n+      /* If the cond is trivial (all alternatives give the same value),\n+\t optimize it away.  */\n+      if (allsame)\n+\t{\n+\t  obstack_free (rtl_obstack, newexp);\n+\t  return operate_exp (op, XEXP (left, 1), right);\n+\t}\n+\n+      /* If the result is the same as the LEFT operand,\n+\t just use that.  */\n+      if (rtx_equal_p (newexp, left))\n+\t{\n+\t  obstack_free (rtl_obstack, newexp);\n+\t  return left;\n+\t}\n \n       return newexp;\n     }\n@@ -1618,138 +1685,136 @@ max_fn (exp)\n \n    Also call ourselves on any COND operations that are values of this COND.\n \n-   We only do the first replacement found directly and call ourselves\n-   recursively for subsequent replacements.  */\n+   We do not modify EXP; rather, we make and return a new rtx.  */\n \n static rtx\n simplify_cond (exp, insn_code, insn_index)\n      rtx exp;\n      int insn_code, insn_index;\n {\n   int i, j;\n-  rtx newtest;\n-  rtx value;\n-  rtx newexp = exp;\n+  /* We store the desired contents here,\n+     then build a new expression if they don't match EXP.  */\n+  rtx defval = XEXP (exp, 1);\n+  int len = XVECLEN (exp, 0);\n+  rtx *tests = (rtx *) alloca (len * sizeof (rtx));\n+  int allsame = 1;\n+  char *spacer, *first_spacer;\n \n-  for (i = 0; i < XVECLEN (exp, 0); i += 2)\n-    {\n-      newtest = SIMPLIFY_TEST_EXP (XVECEXP (exp, 0, i), insn_code, insn_index);\n-      if (newtest == true_rtx)\n-\t{\n-\t  /* Make a new COND with any previous conditions and the value for\n-\t     this pair as the default value.  */\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (i);\n-\t  for (j = 0; j < i; j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n+  /* This lets us free all storage allocated below, if appropriate.  */\n+  first_spacer = (char *) obstack_next_free (rtl_obstack);\n \n-\t  XEXP (newexp, 1) = XVECEXP (exp, 0, i + 1);\n-\t  break;\n-\t}\n+  bcopy (&XVECEXP (exp, 0, 0), tests, len * sizeof (rtx));\n \n-      else if (newtest == false_rtx)\n-\t{\n-\t  /* Build a new COND without this test.  */\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0) - 2);\n-\t  for (j = 0; j < i; j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n+  /* See if default value needs simplification.  */\n+  if (GET_CODE (defval) == COND)\n+    defval = simplify_cond (defval, insn_code, insn_index);\n \n-\t  for (j = i; j < XVECLEN (newexp, 0); j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j + 2);\n+  /* Simplify now, just to see what tests we can get rid of.  */\n \n-\t  XEXP (newexp, 1) = XEXP (exp, 1);\n-\t  break;\n-\t}\n+  /* Work from back to front, so if all values match the default,\n+     we get rid of all of them.  */\n+  for (i = len - 2; i >= 0; i -= 2)\n+    {\n+      rtx newtest, newval;\n \n-      else if (newtest != XVECEXP (exp, 0, i))\n-\t{\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0));\n-\t  for (j = 0; j < XVECLEN (exp, 0); j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n-\t  XEXP (newexp, 1) = XEXP (exp, 1);\n+      /* Simplify this test.  */\n+      newtest = SIMPLIFY_TEST_EXP (tests[i], insn_code, insn_index);\n \n-\t  XVECEXP (newexp, 0, i) = newtest;\n-\t  break;\n+      newval = tests[i + 1];\n+      /* See if this value may need simplification.  */\n+      if (GET_CODE (newval) == COND)\n+\tnewval = simplify_cond (newval, insn_code, insn_index);\n+\n+      /* Look for ways to delete or combine this test.  */\n+      if (newtest == true_rtx)\n+\t{\n+\t  /* If test is true, make this value the default\n+\t     and discard this + any following tests.  */\n+\t  len = i;\n+\t  defval = tests[i];\n \t}\n \n-      /* See if this value may need simplification.  */\n-      if (GET_CODE (XVECEXP (exp, 0, i + 1)) == COND)\n+      else if (newtest == false_rtx)\n \t{\n-\t  value = simplify_cond (XVECEXP (exp, 0, i + 1),\n-\t\t\t\t insn_code, insn_index);\n-\t  if (value != XVECEXP (exp, 0, i + 1))\n-\t    {\n-\t      newexp = rtx_alloc (COND);\n-\t      XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0));\n-\t      for (j = 0; j < XVECLEN (exp, 0); j++)\n-\t\tXVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n-\t      XEXP (newexp, 1) = XEXP (exp, 1);\n+\t  /* If test is false, discard it and its value.  */\n+\t  for (j = i; j < len - 2; j++)\n+\t    tests[j] = tests[j + 2];\n \n-\t      XVECEXP (newexp, 0, i + 1) = value;\n-\t      break;\n-\t    }\n+\t  len -= 2;\n \t}\n \n       /* If this is the last condition in a COND and our value is the same\n \t as the default value, our test isn't needed.  */\n-      if (i == XVECLEN (exp, 0) - 2\n-\t  && rtx_equal_p (XVECEXP (exp, 0, i + 1), XEXP (exp, 1)))\n-\t{\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0) - 2);\n-\t  for (j = 0; j < i; j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n-\t  XEXP (newexp, 1) = XEXP (exp, 1);\n-\t  break;\n-\t}\n+      else if (i == len - 2 && rtx_equal_p (newval, defval))\n+\tlen -= 2;\n+    }\n \n-      /* If this value and the value for the next test are the same, merge the\n-         tests.  */\n-      else if (i != XVECLEN (exp, 0) - 2\n-\t       && rtx_equal_p (XVECEXP (exp, 0, i + 1),\n-\t\t\t       XVECEXP (exp, 0, i + 3)))\n-\t{\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0) - 2);\n-\t  for (j = 0; j < i; j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n+  obstack_free (rtl_obstack, first_spacer);\n \n-\t  XVECEXP (newexp, 0, j)\n-\t    = insert_right_side (IOR, XVECEXP (exp, 0, i),\n-\t\t\t\t XVECEXP (exp, 0, i + 2),\n-\t\t\t\t insn_code, insn_index);\n-\t  XVECEXP (newexp, 0, j + 1) = XVECEXP (exp, 0, i + 1);\n+  if (len == 0)\n+    {\n+      defval = XEXP (exp, 1);\n+      if (GET_CODE (defval) == COND)\n+\treturn simplify_cond (defval, insn_code, insn_index);\n+      return defval;\n+    }\n+  else\n+    {\n+      rtx newexp;\n \n-\t  for (j = i + 2; j < XVECLEN (newexp, 0); j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j + 2);\n+      /* Simplify again, for real this time.  */\n \n-\t  XEXP (newexp, 1) = XEXP (exp, 1);\n-\t  break;\n-\t}\n-    }\n+      if (GET_CODE (defval) == COND)\n+\tdefval = simplify_cond (defval, insn_code, insn_index);\n \n-  /* See if default value needs simplification.  */\n-  if (GET_CODE (XEXP (exp, 1)) == COND)\n-    {\n-      value = simplify_cond (XEXP (exp, 1), insn_code, insn_index);\n-      if (value != XEXP (exp, 1))\n+      for (i = len - 2; i >= 0; i -= 2)\n \t{\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (exp, 0));\n-\t  for (j = 0; j < XVECLEN (exp, 0); j++)\n-\t    XVECEXP (newexp, 0, j) = XVECEXP (exp, 0, j);\n-\t  XEXP (newexp, 1) = value;\n+\t  /* See if this value may need simplification.  */\n+\t  if (GET_CODE (tests[i + 1]) == COND)\n+\t    tests[i + 1] = simplify_cond (tests[i + 1], insn_code, insn_index);\n+\n+\t  /* Simplify this test.  */\n+\t  tests[i] = SIMPLIFY_TEST_EXP (tests[i], insn_code, insn_index);\n+\n+\t  /* If this value and the value for the next test are the same, merge the\n+\t     tests.  */\n+\t  if (i != len - 2\n+\t      && rtx_equal_p (tests[i + 1], tests[i + 3]))\n+\t    {\n+\t      /* Merge following test into this one.  */\n+\t      tests[i]\n+\t\t= insert_right_side (IOR, tests[i], tests[i + 2],\n+\t\t\t\t     insn_code, insn_index);\n+\n+\t      /* Delete the following test/value.  */\n+\t      for (j = i + 2; j < len - 2; j++)\n+\t\ttests[j] = tests[j + 2];\n+\t      len -= 2;\n+\t    }\n \t}\n+\n+      /* See if we changed anything.  */\n+      if (len != XVECLEN (exp, 0) || defval != XEXP (exp, 1))\n+\tallsame = 0;\n+      else\n+\tfor (i = 0; i < len; i++)\n+\t  if (! rtx_equal_p (tests[i], XVECEXP (exp, 0, i)))\n+\t    {\n+\t      allsame = 0;\n+\t      break;\n+\t    }\n+\n+      if (allsame)\n+\treturn exp;\n+\n+      newexp = rtx_alloc (COND);\n+\n+      XVEC (newexp, 0) = rtvec_alloc (len);\n+      bcopy (tests, &XVECEXP (newexp, 0, 0), len * sizeof (rtx));\n+      XEXP (newexp, 1) = defval;\n+      return newexp;\n     }\n-  \n-  if (exp == newexp)\n-    return exp;\n-  else if (XVECLEN (newexp, 0) == 1)\n-    return XVECEXP (newexp, 0, 0);\n-  else\n-    return simplify_cond (newexp, insn_code, insn_index);\n }\n \f\n /* Remove an insn entry from an attribute value.  */\n@@ -1807,6 +1872,26 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n {\n   rtx newexp;\n \n+  /* Avoid consing in some special cases.  */\n+  if (code == AND && term == true_rtx)\n+    return exp;\n+  if (code == AND && term == false_rtx)\n+    return false_rtx;\n+  if (code == AND && exp == true_rtx)\n+    return term;\n+  if (code == AND && exp == false_rtx)\n+    return false_rtx;\n+  if (code == IOR && term == true_rtx)\n+    return true_rtx;\n+  if (code == IOR && term == false_rtx)\n+    return exp;\n+  if (code == IOR && exp == true_rtx)\n+    return true_rtx;\n+  if (code == IOR && exp == false_rtx)\n+    return term;\n+  if (rtx_equal_p (exp, term))\n+    return exp;\n+\n   if (GET_CODE (term) == code)\n     {\n       exp = insert_right_side (code, exp, XEXP (term, 0),\n@@ -1819,16 +1904,19 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n \n   if (GET_CODE (exp) == code)\n     {\n-      /* Make a copy of this expression and call recursively.  */\n-      newexp = attr_rtx (code, XEXP (exp, 0),\n-\t\t\t insert_right_side (code, XEXP (exp, 1),\n-\t\t\t\t\t    term, insn_code, insn_index));\n+      rtx new = insert_right_side (code, XEXP (exp, 1),\n+\t\t\t\t   term, insn_code, insn_index);\n+      if (new != XEXP (exp, 1))\n+\t/* Make a copy of this expression and call recursively.  */\n+\tnewexp = attr_rtx (code, XEXP (exp, 0), new);\n+      else\n+\tnewexp = exp;\n     }\n   else\n     {\n       /* Insert the new term.  */\n       newexp = attr_rtx (code, exp, term);\n-      }\n+    }\n \n   return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n }\n@@ -1892,6 +1980,8 @@ make_alternative_compare (mask)\n    computation.  If a test condition involves an address, we leave the EQ_ATTR\n    intact because addresses are only valid for the `length' attribute.  */\n \n+/* ??? Kenner, document the meanings of the arguments!!!  */\n+\n static rtx\n evaluate_eq_attr (exp, value, insn_code, insn_index)\n      rtx exp;\n@@ -1929,8 +2019,10 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \n       for (i = 0; i < XVECLEN (value, 0); i += 2)\n \t{\n-\t  right = insert_right_side (AND, andexp,\n-\t\t\t\t     XVECEXP (value, 0, i),\n+\t  rtx this = SIMPLIFY_TEST_EXP (XVECEXP (value, 0, i),\n+\t\t\t\t\tinsn_code, insn_index);\n+\n+\t  right = insert_right_side (AND, andexp, this,\n \t\t\t\t     insn_code, insn_index);\n \t  right = insert_right_side (AND, right,\n \t\t\tevaluate_eq_attr (exp, XVECEXP (value, 0, i + 1),\n@@ -1940,7 +2032,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \t\t\t\t     insn_code, insn_index);\n \n \t  /* Add this condition into the AND expression.  */\n-\t  newexp = attr_rtx (NOT, XVECEXP (value, 0, i));\n+\t  newexp = attr_rtx (NOT, this);\n \t  andexp = insert_right_side (AND, andexp, newexp,\n \t\t\t\t      insn_code, insn_index);\n \t}\n@@ -1964,9 +2056,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n   if (address_used)\n     {\n       if (! RTX_UNCHANGING_P (exp))\n-\texp = copy_rtx (exp);\n-\n-      RTX_UNCHANGING_P (exp) = 1;\n+\treturn copy_rtx_unchanging (exp);\n       return exp;\n     }\n   else\n@@ -2194,6 +2284,21 @@ simplify_test_exp (exp, insn_code, insn_index)\n   struct insn_ent *ie;\n   int i;\n   rtx newexp = exp;\n+  char *spacer = (char *) obstack_next_free (rtl_obstack);\n+\n+  static rtx loser = 0;\n+  static int count = 0;\n+  static stopcount = 0;\n+\n+  if (exp == loser)\n+    do_nothing ();\n+  count++;\n+  if (count == stopcount)\n+    do_nothing ();\n+\n+  /* Don't re-simplify something we already simplified.  */\n+  if (RTX_UNCHANGING_P (exp))\n+    return exp;\n \n   switch (GET_CODE (exp))\n     {\n@@ -2228,11 +2333,20 @@ simplify_test_exp (exp, insn_code, insn_index)\n \tleft = simplify_and_tree (left, &right, insn_code, insn_index);\n \n       if (left == false_rtx || right == false_rtx)\n-\treturn false_rtx;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return false_rtx;\n+\t}\n       else if (left == true_rtx)\n-\treturn right;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t}\n       else if (right == true_rtx)\n-\treturn left;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t}\n \n       /* See if all or all but one of the insn's alternatives are specified\n \t in this tree.  Optimize if so.  */\n@@ -2286,11 +2400,20 @@ simplify_test_exp (exp, insn_code, insn_index)\n \tleft = simplify_or_tree (left, &right, insn_code, insn_index);\n \n       if (right == true_rtx || left == true_rtx)\n-\treturn true_rtx;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return true_rtx;\n+\t}\n       else if (left == false_rtx)\n-\treturn right;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t}\n       else if (right == false_rtx)\n-\treturn left;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t}\n \n       /* Test for simple cases where the distributive law is useful.  I.e.,\n \t    convert (ior (and (x) (y))\n@@ -2352,14 +2475,23 @@ simplify_test_exp (exp, insn_code, insn_index)\n       break;\n \n     case NOT:\n+      if (GET_CODE (XEXP (exp, 0)) == NOT)\n+\treturn SIMPLIFY_TEST_EXP (XEXP (XEXP (exp, 0), 0),\n+\t\t\t\t  insn_code, insn_index);\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n       if (GET_CODE (left) == NOT)\n \treturn XEXP (left, 0);\n \n       if (left == false_rtx)\n-\treturn true_rtx;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return true_rtx;\n+\t}\n       else if (left == true_rtx)\n-\treturn false_rtx;\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return false_rtx;\n+\t}\n \n       /* Try to apply De`Morgan's laws.  */\n       else if (GET_CODE (left) == IOR)\n@@ -2401,12 +2533,14 @@ simplify_test_exp (exp, insn_code, insn_index)\n      to process (i.e., we are canonicalizing something.).  */\n   if (insn_code != -2 && ! RTX_UNCHANGING_P (newexp))\n     {\n-      newexp = copy_rtx (newexp);\n-      RTX_UNCHANGING_P (newexp) = 1;\n+      return copy_rtx_unchanging (newexp);\n     }\n \n   return newexp;\n }\n+\n+do_nothing ()\n+{}\n \f\n /* Optimize the attribute lists by seeing if we can determine conditional\n    values from the known values of other attributes.  This will save subroutine\n@@ -3819,6 +3953,33 @@ xmalloc (size)\n   return val;\n }\n \n+static rtx\n+copy_rtx_unchanging (orig)\n+     register rtx orig;\n+{\n+  register rtx copy;\n+  register RTX_CODE code;\n+\n+  code = GET_CODE (orig);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+      return orig;\n+    }\n+\n+  copy = rtx_alloc (code);\n+  PUT_MODE (copy, GET_MODE (orig));\n+  RTX_UNCHANGING_P (copy) = 1;\n+  \n+  bcopy (&XEXP (orig, 0), &XEXP (copy, 0),\n+\t GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n+  return copy;\n+}\n+\n static void\n fatal (s, a1, a2)\n      char *s;\n@@ -3852,6 +4013,7 @@ main (argc, argv)\n   rtx tem;\n \n   obstack_init (rtl_obstack);\n+  obstack_init (hash_obstack);\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");"}]}