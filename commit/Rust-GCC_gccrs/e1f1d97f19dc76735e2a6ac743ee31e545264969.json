{"sha": "e1f1d97f19dc76735e2a6ac743ee31e545264969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmMWQ5N2YxOWRjNzY3MzVlMmE2YWM3NDNlZTMxZTU0NTI2NDk2OQ==", "commit": {"author": {"name": "Sa Liu", "email": "saliu@de.ibm.com", "date": "2007-01-10T05:24:01Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2007-01-10T05:24:01Z"}, "message": "spu.h (STACK_SAVE_AREA): Use VOIDmode for SAVE_FUNCTION...\n\n\t* spu.h (STACK_SAVE_AREA): Use VOIDmode for SAVE_FUNCTION, SImode\n\tfor SAVE_NONLOCAL and Pmode for any other save level.\n\t* spu-protos.h (spu_restore_stack_block): Declare.\n\t* spu.md (save_stack_block): Remove.\n\t(restore_stack_block): Call spu_restore_stack_block.\n\t* spu.c (spu_restore_stack_block): New function.\n\t(spu_expand_epilogue): Remove old comment.\n\nCo-Authored-By: Ben Elliston <bje@au.ibm.com>\n\nFrom-SVN: r120633", "tree": {"sha": "bea351683ab93d045457f78d4bf70cf776fb658d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bea351683ab93d045457f78d4bf70cf776fb658d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f1d97f19dc76735e2a6ac743ee31e545264969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f1d97f19dc76735e2a6ac743ee31e545264969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f1d97f19dc76735e2a6ac743ee31e545264969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f1d97f19dc76735e2a6ac743ee31e545264969/comments", "author": {"login": "sa-liu", "id": 47213938, "node_id": "MDQ6VXNlcjQ3MjEzOTM4", "avatar_url": "https://avatars.githubusercontent.com/u/47213938?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sa-liu", "html_url": "https://github.com/sa-liu", "followers_url": "https://api.github.com/users/sa-liu/followers", "following_url": "https://api.github.com/users/sa-liu/following{/other_user}", "gists_url": "https://api.github.com/users/sa-liu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sa-liu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sa-liu/subscriptions", "organizations_url": "https://api.github.com/users/sa-liu/orgs", "repos_url": "https://api.github.com/users/sa-liu/repos", "events_url": "https://api.github.com/users/sa-liu/events{/privacy}", "received_events_url": "https://api.github.com/users/sa-liu/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b30ba3b6c852a87355a84a3bcf179b1526ed37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b30ba3b6c852a87355a84a3bcf179b1526ed37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b30ba3b6c852a87355a84a3bcf179b1526ed37b"}], "stats": {"total": 90, "additions": 64, "deletions": 26}, "files": [{"sha": "3d1f0188961d69a76acca08c21a2008e91c812c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1f1d97f19dc76735e2a6ac743ee31e545264969", "patch": "@@ -1,3 +1,14 @@\n+2007-01-10  Sa Liu  <saliu@de.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* spu.h (STACK_SAVE_AREA): Use VOIDmode for SAVE_FUNCTION, SImode\n+\tfor SAVE_NONLOCAL and Pmode for any other save level.\n+\t* spu-protos.h (spu_restore_stack_block): Declare.\n+\t* spu.md (save_stack_block): Remove.\n+\t(restore_stack_block): Call spu_restore_stack_block.\n+\t* spu.c (spu_restore_stack_block): New function.\n+\t(spu_expand_epilogue): Remove old comment.\n+\n 2007-01-09  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/30322"}, {"sha": "6f87ec02581e3264da40abf7ee3fa8e1577dbefe", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=e1f1d97f19dc76735e2a6ac743ee31e545264969", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License as published by the Free\n@@ -78,6 +78,7 @@ extern rtx array_to_constant (enum machine_mode mode, unsigned char *arr);\n extern enum machine_mode spu_eh_return_filter_mode (void);\n extern void spu_allocate_stack (rtx op0, rtx op1);\n extern void spu_restore_stack_nonlocal (rtx op0, rtx op1);\n+extern void spu_restore_stack_block (rtx op0, rtx op1);\n extern rtx spu_gen_subreg (enum machine_mode mode, rtx x);\n extern int spu_safe_dma(HOST_WIDE_INT channel);\n extern void spu_builtin_splats (rtx ops[]);"}, {"sha": "e30d00e140ba514642c1b591490db322707c6c2f", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e1f1d97f19dc76735e2a6ac743ee31e545264969", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2006 Free Software Foundation, Inc.\n+/* Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n \n    This file is free software; you can redistribute it and/or modify it under\n    the terms of the GNU General Public License as published by the Free\n@@ -1702,8 +1702,6 @@ spu_expand_epilogue (bool sibcall_p)\n   if (total_size > 0)\n     {\n       if (current_function_calls_alloca)\n-\t/* Load it from the back chain because our save_stack_block and\n-\t   restore_stack_block do nothing. */\n \tframe_emit_load (STACK_POINTER_REGNUM, sp_reg, 0);\n       else\n \tframe_emit_add_imm (sp_reg, sp_reg, total_size, scratch_reg_0);\n@@ -4306,6 +4304,32 @@ spu_init_builtins (void)\n     }\n }\n \n+void\n+spu_restore_stack_block (rtx op0 ATTRIBUTE_UNUSED, rtx op1)\n+{\n+  static unsigned char arr[16] =\n+    { 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3 };\n+\n+  rtx temp = gen_reg_rtx (Pmode);\n+  rtx temp2 = gen_reg_rtx (V4SImode);\n+  rtx temp3 = gen_reg_rtx (V4SImode);\n+  rtx pat = gen_reg_rtx (TImode);\n+  rtx sp = gen_rtx_REG (V4SImode, STACK_POINTER_REGNUM);\n+\n+  emit_move_insn (pat, array_to_constant (TImode, arr));\n+\n+  /* Restore the sp.  */\n+  emit_move_insn (temp, op1);\n+  emit_move_insn (temp2, gen_frame_mem (V4SImode, stack_pointer_rtx));\n+\n+  /* Compute available stack size for sp.  */\n+  emit_insn (gen_subsi3 (temp, temp, stack_pointer_rtx));\n+  emit_insn (gen_shufb (temp3, temp, temp, pat));\n+\n+  emit_insn (gen_addv4si3 (sp, sp, temp3));\n+  emit_move_insn (gen_frame_mem (V4SImode, stack_pointer_rtx), temp2);\n+}\n+\n int\n spu_safe_dma (HOST_WIDE_INT channel)\n {"}, {"sha": "240d2458995189ba5b306e3e570e5cb9bb4fb8a5", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=e1f1d97f19dc76735e2a6ac743ee31e545264969", "patch": "@@ -96,7 +96,10 @@ extern const char *spu_fixed_range_string;\n \n #define MAX_FIXED_MODE_SIZE 128\n \n-#define STACK_SAVEAREA_MODE(save_level) SImode\n+#define STACK_SAVEAREA_MODE(save_level) \\\n+  (save_level == SAVE_FUNCTION ? VOIDmode \\\n+    : save_level == SAVE_NONLOCAL ? SImode \\\n+      : Pmode)\n \n #define STACK_SIZE_MODE SImode\n "}, {"sha": "8e8fad2d114d3b7b2036dde8fd06a20b46ae55f1", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f1d97f19dc76735e2a6ac743ee31e545264969/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=e1f1d97f19dc76735e2a6ac743ee31e545264969", "patch": "@@ -1,4 +1,4 @@\n-;; Copyright (C) 2006 Free Software Foundation, Inc.\n+;; Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n \n ;; This file is free software; you can redistribute it and/or modify it under\n ;; the terms of the GNU General Public License as published by the Free\n@@ -3116,16 +3116,19 @@ selb\\t%0,%4,%0,%3\"\n   \"spu_allocate_stack (operands[0], operands[1]); DONE;\")\n \n ;; These patterns say how to save and restore the stack pointer.  We need not\n-;; save the stack pointer at function or block level since we are careful to\n-;; preserve the backchain.  Doing nothing at block level means the stack space\n-;; is allocated until the end of the function.  This is currently safe to do\n-;; because gcc uses the frame pointer for the whole function, so the worst that\n-;; happens is wasted stack space.  That could be bad if a VLA is declared in a\n-;; loop, because new space will be allocated every iteration, but users can\n-;; work around that case.  Ideally we could detect when we are in a loop and\n-;; generate the more complicated code in that case.\n+;; save the stack pointer at function level since we are careful to preserve \n+;; the backchain.  \n+;; \n+\n+;; At block level the stack pointer is saved and restored, so that the\n+;; stack space allocated within a block is deallocated when leaving\n+;; block scope.  By default, according to the SPU ABI, the stack\n+;; pointer and available stack size are saved in a register. Upon\n+;; restoration, the stack pointer is simply copied back, and the\n+;; current available stack size is calculated against the restored\n+;; stack pointer.\n ;;\n-;; For nonlocal gotos, we must save both the stack pointer and its\n+;; For nonlocal gotos, we must save the stack pointer and its\n ;; backchain and restore both.  Note that in the nonlocal case, the\n ;; save area is a memory location.\n \n@@ -3141,19 +3144,15 @@ selb\\t%0,%4,%0,%3\"\n   \"\"\n   \"DONE;\")\n \n-(define_expand \"save_stack_block\"\n-  [(match_operand 0 \"general_operand\" \"\")\n-   (match_operand 1 \"general_operand\" \"\")]\n-  \"\"\n-  \"DONE; \")\n-\n (define_expand \"restore_stack_block\"\n-  [(use (match_operand 0 \"spu_reg_operand\" \"\"))\n-   (set (match_dup 2) (match_dup 3))\n-   (set (match_dup 0) (match_operand 1 \"spu_reg_operand\" \"\"))\n-   (set (match_dup 3) (match_dup 2))]\n+  [(match_operand 0 \"spu_reg_operand\" \"\")\n+   (match_operand 1 \"memory_operand\" \"\")]\n   \"\"\n-  \"DONE;\")\n+  \"\n+  {\n+    spu_restore_stack_block (operands[0], operands[1]);\n+    DONE;\n+  }\")\n \n (define_expand \"save_stack_nonlocal\"\n   [(match_operand 0 \"memory_operand\" \"\")"}]}