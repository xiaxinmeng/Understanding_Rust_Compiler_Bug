{"sha": "63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNjZTE0ZTAzYjkzZTM1MTI4NmM5YzdiMGQyMGFiYjVkODViMGYyMA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-30T00:00:22Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-30T00:00:22Z"}, "message": "ira.c validate_equiv_mem\n\nThis function is used to validate REG_EQUIV notes generated by ira,\nand to validate potential insn combines performed by ira.  The two\nconditions are not exactly the same, with reload being more\nrestrictive.  Separate them so more combines/moves can occur.\n\nFor example, this sequence from cfgexpand.c:expand_gimple_cond\n\tcallq  _Z18update_bb_for_insnP15basic_block_def\n\tmov    0x10(%rbx),%rdi\n\tmov    0x0(%rip),%rbp        # x_rtl+0x34\n\tcallq  _Z9safe_as_aIP8rtx_insn7rtx_defET_PT0_\n\tmov    %r13,%rdx\n\tmov    %rbp,%rsi\n\tmov    %rax,%rdi\n\tcallq  _Z18create_basic_blockP7rtx_defS0_P15basic_block_def\n\nbecomes\n\tcallq  _Z18update_bb_for_insnP15basic_block_def\n\tmov    0x10(%rbx),%rdi\n\tcallq  _Z9safe_as_aIP8rtx_insn7rtx_defET_PT0_\n\tmov    0x0(%rip),%rsi        # x_rtl+0x34\n\tmov    %r13,%rdx\n\tmov    %rax,%rdi\n\tcallq  _Z18create_basic_blockP7rtx_defS0_P15basic_block_def\n\n\t* ira.c (enum valid_equiv): New.\n\t(validate_equiv_mem): Return enum.\n\t(update_equiv_mem): Create replacement in more cases.\n\t(add_store_equivs): Update validate_equiv_mem call.\n\nFrom-SVN: r235661", "tree": {"sha": "a725f9a222e218eee12c6290bad3b78c73e16c97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a725f9a222e218eee12c6290bad3b78c73e16c97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63ce14e03b93e351286c9c7b0d20abb5d85b0f20/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00544fa6d5f94f73502017d4a1b6b28e9abdc19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00544fa6d5f94f73502017d4a1b6b28e9abdc19"}], "stats": {"total": 88, "additions": 58, "deletions": 30}, "files": [{"sha": "9daedf3f91833e1b92f12492072079a1e3c0c139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ce14e03b93e351286c9c7b0d20abb5d85b0f20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ce14e03b93e351286c9c7b0d20abb5d85b0f20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "patch": "@@ -1,3 +1,10 @@\n+2016-04-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* ira.c (enum valid_equiv): New.\n+\t(validate_equiv_mem): Return enum.\n+\t(update_equiv_mem): Create replacement in more cases.\n+\t(add_store_equivs): Update validate_equiv_mem call.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \t* ira.c (combine_and_move_insns): Rather than scanning insns,"}, {"sha": "7acf680638560e01a36e13b1ac7a5e9d649e2d80", "filename": "gcc/ira.c", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63ce14e03b93e351286c9c7b0d20abb5d85b0f20/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63ce14e03b93e351286c9c7b0d20abb5d85b0f20/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=63ce14e03b93e351286c9c7b0d20abb5d85b0f20", "patch": "@@ -2951,43 +2951,56 @@ validate_equiv_mem_from_store (rtx dest, const_rtx set ATTRIBUTE_UNUSED,\n     info->equiv_mem_modified = true;\n }\n \n+enum valid_equiv { valid_none, valid_combine, valid_reload };\n+\n /* Verify that no store between START and the death of REG invalidates\n    MEMREF.  MEMREF is invalidated by modifying a register used in MEMREF,\n    by storing into an overlapping memory location, or with a non-const\n    CALL_INSN.\n \n-   Return 1 if MEMREF remains valid.  */\n-static int\n+   Return VALID_RELOAD if MEMREF remains valid for both reload and\n+   combine_and_move insns, VALID_COMBINE if only valid for\n+   combine_and_move_insns, and VALID_NONE otherwise.  */\n+static enum valid_equiv\n validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n {\n   rtx_insn *insn;\n   rtx note;\n   struct equiv_mem_data info = { memref, false };\n+  enum valid_equiv ret = valid_reload;\n \n   /* If the memory reference has side effects or is volatile, it isn't a\n      valid equivalence.  */\n   if (side_effects_p (memref))\n-    return 0;\n+    return valid_none;\n \n   for (insn = start; insn; insn = NEXT_INSN (insn))\n     {\n-      if (! INSN_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\n \n       if (find_reg_note (insn, REG_DEAD, reg))\n-\treturn 1;\n+\treturn ret;\n \n-      /* This used to ignore readonly memory and const/pure calls.  The problem\n-\t is the equivalent form may reference a pseudo which gets assigned a\n-\t call clobbered hard reg.  When we later replace REG with its\n-\t equivalent form, the value in the call-clobbered reg has been\n-\t changed and all hell breaks loose.  */\n       if (CALL_P (insn))\n-\treturn 0;\n+\t{\n+\t  /* We can combine a reg def from one insn into a reg use in\n+\t     another over a call if the memory is readonly or the call\n+\t     const/pure.  However, we can't set reg_equiv notes up for\n+\t     reload over any call.  The problem is the equivalent form\n+\t     may reference a pseudo which gets assigned a call\n+\t     clobbered hard reg.  When we later replace REG with its\n+\t     equivalent form, the value in the call-clobbered reg has\n+\t     been changed and all hell breaks loose.  */\n+\t  ret = valid_combine;\n+\t  if (!MEM_READONLY_P (memref)\n+\t      && !RTL_CONST_OR_PURE_CALL_P (insn))\n+\t    return valid_none;\n+\t}\n \n       note_stores (PATTERN (insn), validate_equiv_mem_from_store, &info);\n       if (info.equiv_mem_modified)\n-\treturn 0;\n+\treturn valid_none;\n \n       /* If a register mentioned in MEMREF is modified via an\n \t auto-increment, we lose the equivalence.  Do the same if one\n@@ -2999,10 +3012,10 @@ validate_equiv_mem (rtx_insn *start, rtx reg, rtx memref)\n \t     || REG_NOTE_KIND (note) == REG_DEAD)\n \t    && REG_P (XEXP (note, 0))\n \t    && reg_overlap_mentioned_p (XEXP (note, 0), memref))\n-\t  return 0;\n+\t  return valid_none;\n     }\n \n-  return 0;\n+  return valid_none;\n }\n \n /* Returns zero if X is known to be invariant.  */\n@@ -3510,24 +3523,32 @@ update_equiv_regs (void)\n \t     note.  */\n \t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \n-\t  if (note == NULL_RTX && REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n-\t      && MEM_P (SET_SRC (set))\n-\t      && validate_equiv_mem (insn, dest, SET_SRC (set)))\n-\t    note = set_unique_reg_note (insn, REG_EQUIV, copy_rtx (SET_SRC (set)));\n-\n+\t  rtx replacement = NULL_RTX;\n \t  if (note)\n+\t    replacement = XEXP (note, 0);\n+\t  else if (REG_BASIC_BLOCK (regno) >= NUM_FIXED_BLOCKS\n+\t\t   && MEM_P (SET_SRC (set)))\n \t    {\n-\t      int regno = REGNO (dest);\n-\t      rtx x = XEXP (note, 0);\n+\t      enum valid_equiv validity;\n+\t      validity = validate_equiv_mem (insn, dest, SET_SRC (set));\n+\t      if (validity != valid_none)\n+\t\t{\n+\t\t  replacement = copy_rtx (SET_SRC (set));\n+\t\t  if (validity == valid_reload)\n+\t\t    note = set_unique_reg_note (insn, REG_EQUIV, replacement);\n+\t\t}\n+\t    }\n \n-\t      /* If we haven't done so, record for reload that this is an\n-\t\t equivalencing insn.  */\n-\t      if (!reg_equiv[regno].is_arg_equivalence)\n-\t\tira_reg_equiv[regno].init_insns\n-\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n-\t\t\t\t       ira_reg_equiv[regno].init_insns);\n+\t  /* If we haven't done so, record for reload that this is an\n+\t     equivalencing insn.  */\n+\t  if (note && !reg_equiv[regno].is_arg_equivalence)\n+\t    ira_reg_equiv[regno].init_insns\n+\t      = gen_rtx_INSN_LIST (VOIDmode, insn,\n+\t\t\t\t   ira_reg_equiv[regno].init_insns);\n \n-\t      reg_equiv[regno].replacement = x;\n+\t  if (replacement)\n+\t    {\n+\t      reg_equiv[regno].replacement = replacement;\n \t      reg_equiv[regno].src_p = &SET_SRC (set);\n \t      reg_equiv[regno].loop_depth = (short) loop_depth;\n \n@@ -3548,7 +3569,7 @@ update_equiv_regs (void)\n \t\t     calls.  */\n \n \t\t  if (REG_N_REFS (regno) == 2\n-\t\t      && (rtx_equal_p (x, src)\n+\t\t      && (rtx_equal_p (replacement, src)\n \t\t\t  || ! equiv_init_varies_p (src))\n \t\t      && NONJUMP_INSN_P (insn)\n \t\t      && equiv_init_movable_p (PATTERN (insn), regno))\n@@ -3599,7 +3620,7 @@ add_store_equivs (void)\n \t  && (init_insn = reg_equiv[regno].init_insns->insn ()) != 0\n \t  && bitmap_bit_p (&seen_insns, INSN_UID (init_insn))\n \t  && ! find_reg_note (init_insn, REG_EQUIV, NULL_RTX)\n-\t  && validate_equiv_mem (init_insn, src, dest)\n+\t  && validate_equiv_mem (init_insn, src, dest) == valid_reload\n \t  && ! memref_used_between_p (dest, init_insn, insn)\n \t  /* Attaching a REG_EQUIV note will fail if INIT_INSN has\n \t     multiple sets.  */"}]}