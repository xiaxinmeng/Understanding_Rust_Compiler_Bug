{"sha": "ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "node_id": "C_kwDOANBUbNoAKGZmNWYzMDA1ZDBlMGM5NzcxZTA0MmZjNDVjOGYxMmZjMWFlNWEzNzM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-24T09:34:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-24T09:34:19Z"}, "message": "Merge #1051\n\n1051: macros: Add remaining restrictions for follow-set restrictions r=CohenArthur a=CohenArthur\n\nAdds the remaining restrictions for follow-set ambiguities in macros.\r\nThis means adding the remaining allowed tokens for all fragment\r\nspecifiers with follow-up restrictions, as well as handling allowed\r\nfragment specifiers in certain cases. For example, :vis specifiers can\r\nsometimes be followed by fragments, if they have the :ident, :ty or\r\n:path specifier. Likewise for :path and :ty which can be followed by a\r\n:block.\r\n\r\nFinally, we also allow *any* fragment after a matcher: Since the matcher\r\nis delimiter by parentheses, brackets or curlies, anything is allowed\r\nafterwards.\r\n\r\nSome edge cases or allowed tokens that we cannot handle yet remain, for which FIXMEs exist. I'll open up corresponding issues. \r\n\r\nAddresses #947 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "42538b9379105f303a23f649a1f95f03377b7cca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42538b9379105f303a23f649a1f95f03377b7cca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiPDsbCRBK7hj4Ov3rIwAAblgIAAFqfhZncA1op8gCJlmlEL4K\nUPCquVM08k+bbvBnwAeuno8qN6h7DEIjir4MkpfrJEpU3Q1dX2tJ7qTf22LDbkQl\nGwVwjKS6ibahrkx55XoM7XkE8D+yud5h7j8rg+aPlScMyjeMQbzQyMgvknZVvZj7\n3VE8ahyoqlH8CZZeOlhHW12Svtfy4TFs/eTm4x6N200HfWvRJcDPi/WacWKmDkhV\nXp649hDNNrgf8FP4+Q0Kx6oSdfQ52iYFMjwH6ajDMX9O0QKTjKxt2K2t7TJYmxoP\nYy9edPLIrNLB6GxTAlVSBKT3UVV2IjqK+HeVgq2k6RnEjxQUtrRTOEguy7ME+j0=\n=vTO4\n-----END PGP SIGNATURE-----\n", "payload": "tree 42538b9379105f303a23f649a1f95f03377b7cca\nparent 90f938c2ecefbf16b4793a4135531ed5394a52ac\nparent 6821a642ab796aba5024032e3ace118a5e8277e1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648114459 +0000\ncommitter GitHub <noreply@github.com> 1648114459 +0000\n\nMerge #1051\n\n1051: macros: Add remaining restrictions for follow-set restrictions r=CohenArthur a=CohenArthur\n\nAdds the remaining restrictions for follow-set ambiguities in macros.\r\nThis means adding the remaining allowed tokens for all fragment\r\nspecifiers with follow-up restrictions, as well as handling allowed\r\nfragment specifiers in certain cases. For example, :vis specifiers can\r\nsometimes be followed by fragments, if they have the :ident, :ty or\r\n:path specifier. Likewise for :path and :ty which can be followed by a\r\n:block.\r\n\r\nFinally, we also allow *any* fragment after a matcher: Since the matcher\r\nis delimiter by parentheses, brackets or curlies, anything is allowed\r\nafterwards.\r\n\r\nSome edge cases or allowed tokens that we cannot handle yet remain, for which FIXMEs exist. I'll open up corresponding issues. \r\n\r\nAddresses #947 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90f938c2ecefbf16b4793a4135531ed5394a52ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f938c2ecefbf16b4793a4135531ed5394a52ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90f938c2ecefbf16b4793a4135531ed5394a52ac"}, {"sha": "6821a642ab796aba5024032e3ace118a5e8277e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6821a642ab796aba5024032e3ace118a5e8277e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6821a642ab796aba5024032e3ace118a5e8277e1"}], "stats": {"total": 147, "additions": 120, "deletions": 27}, "files": [{"sha": "2b50ac1be9db21251e25b54a1c115233239d9ed3", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -128,19 +128,29 @@ class MacroFragSpec\n       }\n   }\n \n-  bool has_follow_set_restrictions ()\n+  bool has_follow_set_restrictions () const\n   {\n     switch (kind)\n       {\n       case EXPR:\n       case STMT:\n-\t// FIXME: Add the following cases once we can handle them properly\n-\t// in `is_match_compatible()`\n-\t// case PAT:\n-\t// // case PAT_PARAM: FIXME: Doesn't <metavar>:pat_param exist?\n-\t// case PATH:\n-\t// case TY:\n-\t// case VIS:\n+      case PAT:\n+      case PATH:\n+      case TY:\n+      case VIS:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  bool has_follow_set_fragment_restrictions () const\n+  {\n+    switch (kind)\n+      {\n+      case PAT:\n+      case TY:\n+      case VIS:\n \treturn true;\n       default:\n \treturn false;\n@@ -188,7 +198,7 @@ class MacroMatchFragment : public MacroMatch\n   }\n \n   Identifier get_ident () const { return ident; }\n-  MacroFragSpec get_frag_spec () const { return frag_spec; }\n+  const MacroFragSpec &get_frag_spec () const { return frag_spec; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "bbc6d5ddfcb725a87810deb4fb7782e4e68f3bb0", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -165,6 +165,7 @@ enum PrimitiveCoreType\n   RS_TOKEN_KEYWORD (CONST, \"const\")                                            \\\n   RS_TOKEN_KEYWORD (CONTINUE, \"continue\")                                      \\\n   RS_TOKEN_KEYWORD (CRATE, \"crate\")                                            \\\n+  /* FIXME: Do we need to add $crate (DOLLAR_CRATE) as a reserved kw? */       \\\n   RS_TOKEN_KEYWORD (DO, \"do\") /* unused */                                     \\\n   RS_TOKEN_KEYWORD (DYN, \"dyn\")                                                \\\n   RS_TOKEN_KEYWORD (ELSE, \"else\")                                              \\"}, {"sha": "57c532486e5206b584300c66a2913be30c731bcf", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 82, "deletions": 18, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -93,15 +93,83 @@ extract_module_path (const AST::AttrVec &inner_attrs,\n   return path;\n }\n \n+template <typename T>\n+static bool\n+contains (std::vector<T> &vec, T elm)\n+{\n+  return std::find (vec.begin (), vec.end (), elm) != vec.end ();\n+}\n+\n+static bool\n+peculiar_fragment_match_compatible_fragment (\n+  const AST::MacroFragSpec &last_spec, const AST::MacroFragSpec &spec,\n+  Location match_locus)\n+{\n+  static std::unordered_map<AST::MacroFragSpec::Kind,\n+\t\t\t    std::vector<AST::MacroFragSpec::Kind>>\n+    fragment_follow_set\n+    = {{AST::MacroFragSpec::PATH, {AST::MacroFragSpec::BLOCK}},\n+       {AST::MacroFragSpec::TY, {AST::MacroFragSpec::BLOCK}},\n+       {AST::MacroFragSpec::VIS,\n+\t{AST::MacroFragSpec::IDENT, AST::MacroFragSpec::TY,\n+\t AST::MacroFragSpec::PATH}}};\n+\n+  auto is_valid\n+    = contains (fragment_follow_set[last_spec.get_kind ()], spec.get_kind ());\n+\n+  if (!is_valid)\n+    rust_error_at (\n+      match_locus,\n+      \"fragment specifier %<%s%> is not allowed after %<%s%> fragments\",\n+      spec.as_string ().c_str (), last_spec.as_string ().c_str ());\n+\n+  return is_valid;\n+}\n+\n static bool\n peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n \t\t\t\t    AST::MacroMatch &match)\n {\n   static std::unordered_map<AST::MacroFragSpec::Kind, std::vector<TokenId>>\n-    follow_set = {\n-      {AST::MacroFragSpec::EXPR, {MATCH_ARROW, COMMA, SEMICOLON}},\n-      {AST::MacroFragSpec::STMT, {MATCH_ARROW, COMMA, SEMICOLON}},\n-    };\n+    follow_set\n+    = {{AST::MacroFragSpec::EXPR, {MATCH_ARROW, COMMA, SEMICOLON}},\n+       {AST::MacroFragSpec::STMT, {MATCH_ARROW, COMMA, SEMICOLON}},\n+       {AST::MacroFragSpec::PAT, {MATCH_ARROW, COMMA, EQUAL, PIPE, IF, IN}},\n+       {AST::MacroFragSpec::PATH,\n+\t{MATCH_ARROW, COMMA, EQUAL, PIPE, SEMICOLON, COLON, RIGHT_ANGLE,\n+\t RIGHT_SHIFT, LEFT_SQUARE, LEFT_CURLY, AS, WHERE}},\n+       {AST::MacroFragSpec::TY,\n+\t{MATCH_ARROW, COMMA, EQUAL, PIPE, SEMICOLON, COLON, RIGHT_ANGLE,\n+\t RIGHT_SHIFT, LEFT_SQUARE, LEFT_CURLY, AS, WHERE}},\n+       {AST::MacroFragSpec::VIS,\n+\t{\n+\t  COMMA,\n+\t  IDENTIFIER /* FIXME: Other than `priv` */,\n+\t  LEFT_PAREN,\n+\t  LEFT_SQUARE,\n+\t  EXCLAM,\n+\t  ASTERISK,\n+\t  AMP,\n+\t  LOGICAL_AND,\n+\t  QUESTION_MARK,\n+\t  LIFETIME,\n+\t  LEFT_ANGLE,\n+\t  LEFT_SHIFT,\n+\t  SUPER,\n+\t  SELF,\n+\t  SELF_ALIAS,\n+\t  EXTERN_TOK,\n+\t  CRATE,\n+\t  UNDERSCORE,\n+\t  FOR,\n+\t  IMPL,\n+\t  FN_TOK,\n+\t  UNSAFE,\n+\t  TYPEOF,\n+\t  DYN\n+\t  // FIXME: Add Non kw identifiers\n+\t  // FIXME: Add $crate as valid\n+\t}}};\n \n   Location error_locus = match.get_match_locus ();\n \n@@ -117,9 +185,7 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n \tauto tok = static_cast<AST::Token *> (&match);\n \tauto &allowed_toks\n \t  = follow_set[last_match.get_frag_spec ().get_kind ()];\n-\tauto is_valid = std::find (allowed_toks.begin (), allowed_toks.end (),\n-\t\t\t\t   tok->get_id ())\n-\t\t\t!= allowed_toks.end ();\n+\tauto is_valid = contains (allowed_toks, tok->get_id ());\n \tif (!is_valid)\n \t  // FIXME: Add hint about allowed fragments\n \t  rust_error_at (tok->get_match_locus (),\n@@ -143,10 +209,17 @@ peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n \t  error_locus = matches.front ()->get_match_locus ();\n \tbreak;\n       }\n-    default:\n+      case AST::MacroMatch::Fragment: {\n+\tauto last_spec = last_match.get_frag_spec ();\n+\tauto fragment = static_cast<AST::MacroMatchFragment *> (&match);\n+\tif (last_spec.has_follow_set_fragment_restrictions ())\n+\t  return peculiar_fragment_match_compatible_fragment (\n+\t    last_spec, fragment->get_frag_spec (), match.get_match_locus ());\n+      }\n       break;\n     }\n \n+  // FIXME: Improve error message\n   rust_error_at (error_locus, \"fragment not allowed after %<%s%> fragment\",\n \t\t last_match.get_frag_spec ().as_string ().c_str ());\n \n@@ -213,16 +286,7 @@ is_match_compatible (AST::MacroMatch &last_match, AST::MacroMatch &match)\n \t  return true;\n \tbreak;\n       }\n-      case AST::MacroMatch::Matcher: {\n-\t// Likewise for another matcher\n-\tauto matcher = static_cast<AST::MacroMatcher *> (&last_match);\n-\tnew_last = get_back_ptr (matcher->get_matches ());\n-\t// If there are no matches in the matcher, then it can be followed by\n-\t// anything\n-\tif (!new_last)\n-\t  return true;\n-\tbreak;\n-      }\n+    case AST::MacroMatch::Matcher:\n     case AST::MacroMatch::Tok:\n       return true;\n     }"}, {"sha": "2ccd33e50d3a49e31852f2fbb3b3cfb1174e0201", "filename": "gcc/testsuite/rust/compile/macro33.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro33.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro33.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro33.rs?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -0,0 +1,5 @@\n+macro_rules! forbidden_frag {\n+    ($t:ty $not_block:ident) => {{}}; // { dg-error \"fragment specifier .ident. is not allowed after .ty. fragments\" }\n+                                      // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-1 }\n+                                      // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "105d042fd50b34936c15da597b602e8411c31530", "filename": "gcc/testsuite/rust/compile/macro34.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro34.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro34.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro34.rs?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -0,0 +1,3 @@\n+macro_rules! allowed_after_expr_matcher {\n+    (($t:expr) bok) => {{}}; // follow-set restrictions do not apply after a matcher, but they do apply inside the matcher\n+}"}, {"sha": "a08bfd4581c010ffcead05a353410281f1438085", "filename": "gcc/testsuite/rust/compile/macro35.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro35.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro35.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro35.rs?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -0,0 +1,7 @@\n+macro_rules! inside_matcher {\n+    (($e:expr tok) tok) => {{}}; // { dg-error \"token .tok. is not allowed after .expr. fragment\" }\n+                                 // { dg-error \"failed to parse macro matcher\" \"\" { target *-*-* } .-1 }\n+                                 // { dg-error \"failed to parse macro match\" \"\" { target *-*-* } .-2 }\n+                                 // { dg-error \"required first macro rule\" \"\" { target *-*-* } .-3 }\n+                                 // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-4 }\n+}"}, {"sha": "e5d66b22b7bbe87cb2b60f580f567ae379ee5f2c", "filename": "gcc/testsuite/rust/compile/macro36.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro36.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro36.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro36.rs?ref=ff5f3005d0e0c9771e042fc45c8f12fc1ae5a373", "patch": "@@ -0,0 +1,3 @@\n+macro_rules! ty_allowed {\n+    ($t:ty $b:block) => {{}};\n+}"}]}