{"sha": "3bd62c453dbd6b0b17a431d9f1231017c25ca3a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkNjJjNDUzZGJkNmIwYjE3YTQzMWQ5ZjEyMzEwMTdjMjVjYTNhMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-03-17T14:24:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-03-17T14:24:56Z"}, "message": "* gmon.c: Remove.\n\nFrom-SVN: r96608", "tree": {"sha": "1667258f7bc4f02be8ddd2f14dbc420651c0af05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1667258f7bc4f02be8ddd2f14dbc420651c0af05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ff01d4d50e41aa121a583fd69d42626045127af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff01d4d50e41aa121a583fd69d42626045127af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff01d4d50e41aa121a583fd69d42626045127af"}], "stats": {"total": 330, "additions": 4, "deletions": 326}, "files": [{"sha": "eeecc6bcbacb6da4d701aaa4949f68d539403f7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bd62c453dbd6b0b17a431d9f1231017c25ca3a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bd62c453dbd6b0b17a431d9f1231017c25ca3a3", "patch": "@@ -1,3 +1,7 @@\n+2005-03-17  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* gmon.c: Remove.\n+\n 2005-03-17  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/arc/arc.c (arc_cpu_string): Make static.  Default to \"base\""}, {"sha": "aa4fd166ea1aac5424206d783e5b4daa7556e201", "filename": "gcc/gmon.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff01d4d50e41aa121a583fd69d42626045127af/gcc%2Fgmon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff01d4d50e41aa121a583fd69d42626045127af/gcc%2Fgmon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgmon.c?ref=3ff01d4d50e41aa121a583fd69d42626045127af", "patch": "@@ -1,326 +0,0 @@\n-/*-\n- * Copyright (c) 1991, 1998 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. [rescinded 22 July 1999]\n- * 4. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- */\n-\n-#ifndef lint\n-static char sccsid[] = \"@(#)gmon.c\t5.3 (Berkeley) 5/22/91\";\n-#endif /* not lint */\n-\n-#if 0\n-#include <unistd.h>\n-\n-#endif\n-#ifdef DEBUG\n-#include <stdio.h>\n-#endif\n-\n-#include \"gmon.h\"\n-\n-extern mcount() asm (\"mcount\");\n-extern char *minbrk asm (\"minbrk\");\n-\n-#ifdef __alpha\n-extern char *sbrk ();\n-#endif\n-\n-    /*\n-     *\tfroms is actually a bunch of unsigned shorts indexing tos\n-     */\n-static int\t\tprofiling = 3;\n-static unsigned short\t*froms;\n-static struct tostruct\t*tos = 0;\n-static long\t\ttolimit = 0;\n-static char\t\t*s_lowpc = 0;\n-static char\t\t*s_highpc = 0;\n-static unsigned long\ts_textsize = 0;\n-\n-static int\tssiz;\n-static char\t*sbuf;\n-static int\ts_scale;\n-    /* see profil(2) where this is describe (incorrectly) */\n-#define\t\tSCALE_1_TO_1\t0x10000L\n-\n-#define\tMSG \"No space for profiling buffer(s)\\n\"\n-\n-monstartup(lowpc, highpc)\n-    char\t*lowpc;\n-    char\t*highpc;\n-{\n-    int\t\t\tmonsize;\n-    char\t\t*buffer;\n-    int\t\t\to;\n-\n-\t/*\n-\t *\tround lowpc and highpc to multiples of the density we're using\n-\t *\tso the rest of the scaling (here and in gprof) stays in ints.\n-\t */\n-    lowpc = (char *)\n-\t    ROUNDDOWN((unsigned) lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n-    s_lowpc = lowpc;\n-    highpc = (char *)\n-\t    ROUNDUP((unsigned) highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n-    s_highpc = highpc;\n-    s_textsize = highpc - lowpc;\n-    monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n-    buffer = sbrk( monsize );\n-    if ( buffer == (char *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\treturn;\n-    }\n-    froms = (unsigned short *) sbrk( s_textsize / HASHFRACTION );\n-    if ( froms == (unsigned short *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\tfroms = 0;\n-\treturn;\n-    }\n-    tolimit = s_textsize * ARCDENSITY / 100;\n-    if ( tolimit < MINARCS ) {\n-\ttolimit = MINARCS;\n-    } else if ( tolimit > 65534 ) {\n-\ttolimit = 65534;\n-    }\n-    tos = (struct tostruct *) sbrk( tolimit * sizeof( struct tostruct ) );\n-    if ( tos == (struct tostruct *) -1 ) {\n-\twrite( 2 , MSG , sizeof(MSG) );\n-\tfroms = 0;\n-\ttos = 0;\n-\treturn;\n-    }\n-    minbrk = sbrk(0);\n-    tos[0].link = 0;\n-    sbuf = buffer;\n-    ssiz = monsize;\n-    ( (struct phdr *) buffer ) -> lpc = lowpc;\n-    ( (struct phdr *) buffer ) -> hpc = highpc;\n-    ( (struct phdr *) buffer ) -> ncnt = ssiz;\n-    monsize -= sizeof(struct phdr);\n-    if ( monsize <= 0 )\n-\treturn;\n-    o = highpc - lowpc;\n-    if( monsize < o )\n-#ifndef hp300\n-\ts_scale = ( (float) monsize / o ) * SCALE_1_TO_1;\n-#else /* avoid floating point */\n-    {\n-\tint quot = o / monsize;\n-\n-\tif (quot >= 0x10000)\n-\t\ts_scale = 1;\n-\telse if (quot >= 0x100)\n-\t\ts_scale = 0x10000 / quot;\n-\telse if (o >= 0x800000)\n-\t\ts_scale = 0x1000000 / (o / (monsize >> 8));\n-\telse\n-\t\ts_scale = 0x1000000 / ((o << 8) / monsize);\n-    }\n-#endif\n-    else\n-\ts_scale = SCALE_1_TO_1;\n-    moncontrol(1);\n-}\n-\n-_mcleanup()\n-{\n-    int\t\t\tfd;\n-    int\t\t\tfromindex;\n-    int\t\t\tendfrom;\n-    char\t\t*frompc;\n-    int\t\t\ttoindex;\n-    struct rawarc\trawarc;\n-\n-    moncontrol(0);\n-    fd = creat( \"gmon.out\" , 0666 );\n-    if ( fd < 0 ) {\n-\tperror( \"mcount: gmon.out\" );\n-\treturn;\n-    }\n-#   ifdef DEBUG\n-\tfprintf( stderr , \"[mcleanup] sbuf 0x%x ssiz %d\\n\" , sbuf , ssiz );\n-#   endif DEBUG\n-    write( fd , sbuf , ssiz );\n-    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));\n-    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {\n-\tif ( froms[fromindex] == 0 ) {\n-\t    continue;\n-\t}\n-\tfrompc = s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms));\n-\tfor (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {\n-#\t    ifdef DEBUG\n-\t\tfprintf( stderr ,\n-\t\t\t\"[mcleanup] frompc 0x%x selfpc 0x%x count %d\\n\" ,\n-\t\t\tfrompc , tos[toindex].selfpc , tos[toindex].count );\n-#\t    endif DEBUG\n-\t    rawarc.raw_frompc = (unsigned long) frompc;\n-\t    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n-\t    rawarc.raw_count = tos[toindex].count;\n-\t    write( fd , &rawarc , sizeof rawarc );\n-\t}\n-    }\n-    close( fd );\n-}\n-\n-mcount()\n-{\n-\tregister char\t\t\t*selfpc;\n-\tregister unsigned short\t\t*frompcindex;\n-\tregister struct tostruct\t*top;\n-\tregister struct tostruct\t*prevtop;\n-\tregister long\t\t\ttoindex;\n-\n-\t/*\n-\t *\tfind the return address for mcount,\n-\t *\tand the return address for mcount's caller.\n-\t */\n-\n-\t/* selfpc = pc pushed by mcount call.\n-\t   This identifies the function that was just entered.  */\n-\tselfpc = (void *) __builtin_return_address (0);\n-\t/* frompcindex = pc in preceding frame.\n-\t   This identifies the caller of the function just entered.  */\n-\tfrompcindex = (void *) __builtin_return_address (1);\n-\t/*\n-\t *\tcheck that we are profiling\n-\t *\tand that we aren't recursively invoked.\n-\t */\n-\tif (profiling) {\n-\t\tgoto out;\n-\t}\n-\tprofiling++;\n-\t/*\n-\t *\tcheck that frompcindex is a reasonable pc value.\n-\t *\tfor example:\tsignal catchers get called from the stack,\n-\t *\t\t\tnot from text space.  too bad.\n-\t */\n-\tfrompcindex = (unsigned short *) ((long) frompcindex - (long) s_lowpc);\n-\tif ((unsigned long) frompcindex > s_textsize) {\n-\t\tgoto done;\n-\t}\n-\tfrompcindex =\n-\t    &froms[((long) frompcindex) / (HASHFRACTION * sizeof(*froms))];\n-\ttoindex = *frompcindex;\n-\tif (toindex == 0) {\n-\t\t/*\n-\t\t *\tfirst time traversing this arc\n-\t\t */\n-\t\ttoindex = ++tos[0].link;\n-\t\tif (toindex >= tolimit) {\n-\t\t\tgoto overflow;\n-\t\t}\n-\t\t*frompcindex = toindex;\n-\t\ttop = &tos[toindex];\n-\t\ttop->selfpc = selfpc;\n-\t\ttop->count = 1;\n-\t\ttop->link = 0;\n-\t\tgoto done;\n-\t}\n-\ttop = &tos[toindex];\n-\tif (top->selfpc == selfpc) {\n-\t\t/*\n-\t\t *\tarc at front of chain; usual case.\n-\t\t */\n-\t\ttop->count++;\n-\t\tgoto done;\n-\t}\n-\t/*\n-\t *\thave to go looking down chain for it.\n-\t *\ttop points to what we are looking at,\n-\t *\tprevtop points to previous top.\n-\t *\twe know it is not at the head of the chain.\n-\t */\n-\tfor (; /* goto done */; ) {\n-\t\tif (top->link == 0) {\n-\t\t\t/*\n-\t\t\t *\ttop is end of the chain and none of the chain\n-\t\t\t *\thad top->selfpc == selfpc.\n-\t\t\t *\tso we allocate a new tostruct\n-\t\t\t *\tand link it to the head of the chain.\n-\t\t\t */\n-\t\t\ttoindex = ++tos[0].link;\n-\t\t\tif (toindex >= tolimit) {\n-\t\t\t\tgoto overflow;\n-\t\t\t}\n-\t\t\ttop = &tos[toindex];\n-\t\t\ttop->selfpc = selfpc;\n-\t\t\ttop->count = 1;\n-\t\t\ttop->link = *frompcindex;\n-\t\t\t*frompcindex = toindex;\n-\t\t\tgoto done;\n-\t\t}\n-\t\t/*\n-\t\t *\totherwise, check the next arc on the chain.\n-\t\t */\n-\t\tprevtop = top;\n-\t\ttop = &tos[top->link];\n-\t\tif (top->selfpc == selfpc) {\n-\t\t\t/*\n-\t\t\t *\tthere it is.\n-\t\t\t *\tincrement its count\n-\t\t\t *\tmove it to the head of the chain.\n-\t\t\t */\n-\t\t\ttop->count++;\n-\t\t\ttoindex = prevtop->link;\n-\t\t\tprevtop->link = top->link;\n-\t\t\ttop->link = *frompcindex;\n-\t\t\t*frompcindex = toindex;\n-\t\t\tgoto done;\n-\t\t}\n-\n-\t}\n-done:\n-\tprofiling--;\n-\t/* and fall through */\n-out:\n-\treturn;\t\t/* normal return restores saved registers */\n-\n-overflow:\n-\tprofiling++; /* halt further profiling */\n-#   define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n-\twrite(2, TOLIMIT, sizeof(TOLIMIT));\n-\tgoto out;\n-}\n-\n-/* Control profiling;\n-  \tprofiling is what mcount checks to see if\n-  \tall the data structures are ready.  */\n-\n-moncontrol(mode)\n-    int mode;\n-{\n-    if (mode) {\n-\t/* start */\n-\tprofil(sbuf + sizeof(struct phdr), ssiz - sizeof(struct phdr),\n-\t\t(int)s_lowpc, s_scale);\n-\tprofiling = 0;\n-    } else {\n-\t/* stop */\n-\tprofil((char *) 0, 0, 0, 0);\n-\tprofiling = 3;\n-    }\n-}\n-"}]}