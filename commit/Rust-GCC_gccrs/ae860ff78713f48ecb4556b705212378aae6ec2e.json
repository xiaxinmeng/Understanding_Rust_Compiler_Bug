{"sha": "ae860ff78713f48ecb4556b705212378aae6ec2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU4NjBmZjc4NzEzZjQ4ZWNiNDU1NmI3MDUyMTIzNzhhYWU2ZWMyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-07-20T22:56:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-07-20T22:56:05Z"}, "message": "gcse.c: Include cselib.h\n\n\t* gcse.c: Include cselib.h\n\t(constptop_register): Break out from ...\n\t(cprop_insn): ... here; kill basic_block argument.\n\t(do_local_cprop, local_cprop_pass): New functions.\n\t(one_cprop_pass): Call local_cprop_pass.\n\nFrom-SVN: r55615", "tree": {"sha": "2e02554dc60e8ae63b81cc75fcbd9109e1ebb1e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e02554dc60e8ae63b81cc75fcbd9109e1ebb1e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae860ff78713f48ecb4556b705212378aae6ec2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae860ff78713f48ecb4556b705212378aae6ec2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae860ff78713f48ecb4556b705212378aae6ec2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae860ff78713f48ecb4556b705212378aae6ec2e/comments", "author": null, "committer": null, "parents": [{"sha": "0da65b89f1c0930d104b273a9218fb63226f4cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da65b89f1c0930d104b273a9218fb63226f4cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da65b89f1c0930d104b273a9218fb63226f4cad"}], "stats": {"total": 194, "additions": 148, "deletions": 46}, "files": [{"sha": "42cf042b6dd863bc0b7b51a5a5c451b1047bc8c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae860ff78713f48ecb4556b705212378aae6ec2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae860ff78713f48ecb4556b705212378aae6ec2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae860ff78713f48ecb4556b705212378aae6ec2e", "patch": "@@ -1,3 +1,11 @@\n+Sun Jul 21 00:54:54 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c: Include cselib.h\n+\t(constptop_register): Break out from ...\n+\t(cprop_insn): ... here; kill basic_block argument.\n+\t(do_local_cprop, local_cprop_pass): New functions.\n+\t(one_cprop_pass): Call local_cprop_pass.\n+\n 2002-07-20  Roger Sayle  <roger@eyesopen.com>\n \n \t* simplify-rtx.c (simplify_relational_operation): Optimize"}, {"sha": "d46f81bc800adb56796670bf3eb2d4eb5f811cad", "filename": "gcc/gcse.c", "status": "modified", "additions": 140, "deletions": 46, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae860ff78713f48ecb4556b705212378aae6ec2e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae860ff78713f48ecb4556b705212378aae6ec2e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ae860ff78713f48ecb4556b705212378aae6ec2e", "patch": "@@ -162,6 +162,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"ggc.h\"\n #include \"params.h\"\n+#include \"cselib.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc gmalloc\n@@ -613,9 +614,10 @@ static int cprop_jump\t\tPARAMS ((basic_block, rtx, rtx, rtx, rtx));\n static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));\n static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n-static int cprop_insn\t\tPARAMS ((basic_block, rtx, int));\n+static int cprop_insn\t\tPARAMS ((rtx, int));\n static int cprop\t\tPARAMS ((int));\n static int one_cprop_pass\tPARAMS ((int, int));\n+static bool constprop_register\tPARAMS ((rtx, rtx, rtx, int));\n static struct expr *find_bypass_set PARAMS ((int, int));\n static int bypass_block\t\t    PARAMS ((basic_block, rtx, rtx));\n static int bypass_conditional_jumps PARAMS ((void));\n@@ -701,6 +703,8 @@ static void free_insn_expr_list_list\tPARAMS ((rtx *));\n static void clear_modify_mem_tables\tPARAMS ((void));\n static void free_modify_mem_tables\tPARAMS ((void));\n static rtx gcse_emit_move_after\t\tPARAMS ((rtx, rtx, rtx));\n+static bool do_local_cprop\t\tPARAMS ((rtx, rtx, int));\n+static void local_cprop_pass\t\tPARAMS ((int));\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -4152,12 +4156,48 @@ cprop_jump (bb, setcc, jump, from, src)\n   return 1;\n }\n \n+static bool\n+constprop_register (insn, from, to, alter_jumps)\n+     rtx insn;\n+     rtx from;\n+     rtx to;\n+     int alter_jumps;\n+{\n+  rtx sset;\n+\n+  /* Check for reg or cc0 setting instructions followed by\n+     conditional branch instructions first.  */\n+  if (alter_jumps\n+      && (sset = single_set (insn)) != NULL\n+      && any_condjump_p (NEXT_INSN (insn)) && onlyjump_p (NEXT_INSN (insn)))\n+    {\n+      rtx dest = SET_DEST (sset);\n+      if ((REG_P (dest) || CC0_P (dest))\n+\t  && cprop_jump (BLOCK_FOR_INSN (insn), insn, NEXT_INSN (insn), from, to))\n+\treturn 1;\n+    }\n+\n+  /* Handle normal insns next.  */\n+  if (GET_CODE (insn) == INSN\n+      && try_replace_reg (from, to, insn))\n+    return 1;\n+\n+  /* Try to propagate a CONST_INT into a conditional jump.\n+     We're pretty specific about what we will handle in this\n+     code, we can extend this as necessary over time.\n+\n+     Right now the insn in question must look like\n+     (set (pc) (if_then_else ...))  */\n+  else if (alter_jumps && any_condjump_p (insn) && onlyjump_p (insn))\n+    return cprop_jump (BLOCK_FOR_INSN (insn), NULL, insn, from, to);\n+  return 0;\n+}\n+\n /* Perform constant and copy propagation on INSN.\n    The result is non-zero if a change was made.  */\n \n static int\n-cprop_insn (bb, insn, alter_jumps)\n-     basic_block bb;\n+cprop_insn (insn, alter_jumps)\n      rtx insn;\n      int alter_jumps;\n {\n@@ -4210,56 +4250,18 @@ cprop_insn (bb, insn, alter_jumps)\n       /* Constant propagation.  */\n       if (CONSTANT_P (src))\n \t{\n-\t  rtx sset;\n-\n-\t  /* Check for reg or cc0 setting instructions followed by\n-\t     conditional branch instructions first.  */\n-\t  if (alter_jumps\n-\t      && (sset = single_set (insn)) != NULL\n-\t      && any_condjump_p (NEXT_INSN (insn))\n-\t      && onlyjump_p (NEXT_INSN (insn)))\n-\t    {\n-\t      rtx dest = SET_DEST (sset);\n-\t      if ((REG_P (dest) || CC0_P (dest))\n-\t\t  && cprop_jump (bb, insn, NEXT_INSN (insn),\n-\t\t\t\t reg_used->reg_rtx, src))\n-\t\t{\n-\t\t  changed = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  /* Handle normal insns next.  */\n-\t  if (GET_CODE (insn) == INSN\n-\t      && try_replace_reg (reg_used->reg_rtx, src, insn))\n+          if (constprop_register (insn, reg_used->reg_rtx, src, alter_jumps))\n \t    {\n \t      changed = 1;\n \t      const_prop_count++;\n \t      if (gcse_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"CONST-PROP: Replacing reg %d in \",\n-\t\t\t   regno);\n-\t\t  fprintf (gcse_file, \"insn %d with constant \",\n-\t\t\t   INSN_UID (insn));\n+\t\t  fprintf (gcse_file, \"GLOBAL CONST-PROP: Replacing reg %d in \", regno);\n+\t\t  fprintf (gcse_file, \"insn %d with constant \", INSN_UID (insn));\n \t\t  print_rtl (gcse_file, src);\n \t\t  fprintf (gcse_file, \"\\n\");\n \t\t}\n-\n-\t      /* The original insn setting reg_used may or may not now be\n-\t\t deletable.  We leave the deletion to flow.  */\n \t    }\n-\n-\t  /* Try to propagate a CONST_INT into a conditional jump.\n-\t     We're pretty specific about what we will handle in this\n-\t     code, we can extend this as necessary over time.\n-\n-\t     Right now the insn in question must look like\n-\t     (set (pc) (if_then_else ...))  */\n-\t  else if (alter_jumps\n-\t\t   && any_condjump_p (insn)\n-\t\t   && onlyjump_p (insn))\n-\t    changed |= cprop_jump (bb, NULL, insn, reg_used->reg_rtx, src);\n-\n \t}\n       else if (GET_CODE (src) == REG\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n@@ -4271,7 +4273,7 @@ cprop_insn (bb, insn, alter_jumps)\n \t      copy_prop_count++;\n \t      if (gcse_file != NULL)\n \t\t{\n-\t\t  fprintf (gcse_file, \"COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t  fprintf (gcse_file, \"GLOBAL COPY-PROP: Replacing reg %d in insn %d\",\n \t\t\t   regno, INSN_UID (insn));\n \t\t  fprintf (gcse_file, \" with reg %d\\n\", REGNO (src));\n \t\t}\n@@ -4288,6 +4290,96 @@ cprop_insn (bb, insn, alter_jumps)\n   return changed;\n }\n \n+static bool\n+do_local_cprop (x, insn, alter_jumps)\n+     rtx x;\n+     rtx insn;\n+     int alter_jumps;\n+{\n+  rtx newreg = NULL, newcnst = NULL;\n+\n+  /* Rule out USE instructions and ASM statements as we don't want to change the hard\n+     registers mentioned.  */\n+  if (GET_CODE (x) == REG\n+      && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+          || (GET_CODE (PATTERN (insn)) != USE && asm_noperands (PATTERN (insn)) < 0)))\n+    {\n+      cselib_val *val = cselib_lookup (x, GET_MODE (x), 0);\n+      struct elt_loc_list *l;\n+\n+      if (!val)\n+\treturn false;\n+      for (l = val->locs; l; l = l->next)\n+\t{\n+\t  rtx this_rtx = l->loc;\n+\t  if (CONSTANT_P (this_rtx))\n+\t    newcnst = this_rtx;\n+\t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER)\n+\t    newreg = this_rtx;\n+\t}\n+      if (newcnst && constprop_register (insn, x, newcnst, alter_jumps))\n+\t{\n+\t  if (gcse_file != NULL)\n+\t    {\n+\t      fprintf (gcse_file, \"LOCAL CONST-PROP: Replacing reg %d in \",\n+\t\t       REGNO (x));\n+\t      fprintf (gcse_file, \"insn %d with constant \",\n+\t\t       INSN_UID (insn));\n+\t      print_rtl (gcse_file, newcnst);\n+\t      fprintf (gcse_file, \"\\n\");\n+\t    }\n+\t  const_prop_count++;\n+\t  return true;\n+\t}\n+      else if (newreg && newreg != x && try_replace_reg (x, newreg, insn))\n+\t{\n+\t  if (gcse_file != NULL)\n+\t    {\n+\t      fprintf (gcse_file,\n+\t\t       \"LOCAL COPY-PROP: Replacing reg %d in insn %d\",\n+\t\t       REGNO (x), INSN_UID (insn));\n+\t      fprintf (gcse_file, \" with reg %d\\n\", REGNO (newreg));\n+\t    }\n+\t  copy_prop_count++;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+static void\n+local_cprop_pass (alter_jumps)\n+     int alter_jumps;\n+{\n+  rtx insn;\n+  struct reg_use *reg_used;\n+\n+  cselib_init ();\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\t{\n+\t  rtx note = find_reg_equal_equiv_note (insn);\n+\n+\t  do\n+\t    {\n+\t      reg_use_count = 0;\n+\t      note_uses (&PATTERN (insn), find_used_regs, NULL);\n+\t      if (note)\n+\t\tfind_used_regs (&XEXP (note, 0), NULL);\n+\n+\t      for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n+\t\t   reg_used++, reg_use_count--)\n+\t\tif (do_local_cprop (reg_used->reg_rtx, insn, alter_jumps))\n+\t\t  break;\n+\t    }\n+\t  while (reg_use_count);\n+\t}\n+      cselib_process_insn (insn);\n+    }\n+  cselib_finish ();\n+}\n+\n /* Forward propagate copies.  This includes copies and constants.  Return\n    non-zero if a change was made.  */\n \n@@ -4319,7 +4411,7 @@ cprop (alter_jumps)\n \t   insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n \t  {\n-\t    changed |= cprop_insn (bb, insn, alter_jumps);\n+\t    changed |= cprop_insn (insn, alter_jumps);\n \n \t    /* Keep track of everything modified by this insn.  */\n \t    /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n@@ -4349,6 +4441,8 @@ one_cprop_pass (pass, alter_jumps)\n   const_prop_count = 0;\n   copy_prop_count = 0;\n \n+  local_cprop_pass (alter_jumps);\n+\n   alloc_set_hash_table (max_cuid);\n   compute_set_hash_table ();\n   if (gcse_file)"}]}