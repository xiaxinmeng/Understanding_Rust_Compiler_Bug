{"sha": "5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEzNmNhZTI3NWFkODRjYzdlNjIzZjJmNTgyOWJkYWQ3NjdlM2Y2YQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-25T12:50:55Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-26T08:54:57Z"}, "message": "d: Merge upstream dmd 609c3ce2d, phobos 3dd5df686\n\nD front-end changes:\n\n - Contracts for pre- and postconditions are now implicitly \"this\"\n   const, so that state can no longer be altered in these functions.\n\n - Inside a constructor scope, assigning to aggregate declaration\n   members is done by considering the first assignment as initialization\n   and subsequent assignments as modifications of the constructed\n   object.  For const/immutable fields the initialization is accepted in\n   the constructor but subsequent modifications are not.  However this\n   rule did not apply when inside a constructor scope there is a call to\n   a different constructor.  This been changed so it is now an error\n   when there's a double initialization of immutable fields inside a\n   constructor.\n\nPhobos changes:\n\n - Don't run unit-tests for unsupported clocks in std.datetime.  The\n   phobos and phobos_shared tests now add -fversion=Linux_Pre_2639 if\n   required.\n\n - Deprecate public extern(C) bindings for getline and getdelim in\n   std.stdio.  The correct module for bindings is core.sys.posix.stdio.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12153\n\t     https://github.com/dlang/phobos/pull/7768\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 609c3ce2d.\n\t* d-compiler.cc (Compiler::loadModule): Rename to ...\n\t(Compiler::onParseModule): ... this.\n\t(Compiler::onImport): New function.\n\t* d-lang.cc (d_parse_file): Remove call to Compiler::loadModule.\n\nlibphobos/ChangeLog:\n\n\t* src/MERGE: Merge upstream phobos 3dd5df686.\n\t* testsuite/libphobos.phobos/phobos.exp: Add compiler flag\n\t-fversion=Linux_Pre_2639 if target is linux_pre_2639.\n\t* testsuite/libphobos.phobos_shared/phobos_shared.exp: Likewise.", "tree": {"sha": "ce6b996b6cfcb1b1aa73bcc7786c07ef8df504b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce6b996b6cfcb1b1aa73bcc7786c07ef8df504b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb77a934eec8fe52e4c5612f5264127290bc517d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb77a934eec8fe52e4c5612f5264127290bc517d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb77a934eec8fe52e4c5612f5264127290bc517d"}], "stats": {"total": 820, "additions": 496, "deletions": 324}, "files": [{"sha": "3907d0106841b861e86125d48bdcac3c3ec23d5e", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -157,7 +157,7 @@ Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n     - core.stdc.*: For all gcc library builtins.  */\n \n void\n-Compiler::loadModule (Module *m)\n+Compiler::onParseModule (Module *m)\n {\n   ModuleDeclaration *md = m->md;\n \n@@ -180,3 +180,13 @@ Compiler::loadModule (Module *m)\n \td_add_builtin_module (m);\n     }\n }\n+\n+/* A callback function that is called once an imported module is parsed.\n+   If the callback returns true, then it tells the front-end that the\n+   driver intends on compiling the import.  */\n+\n+bool\n+Compiler::onImport (Module *)\n+{\n+  return false;\n+}"}, {"sha": "0fd207da7f3b3f7e738e108572e07be29e2df090", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -980,7 +980,6 @@ d_parse_file (void)\n \n       m->importedFrom = m;\n       m->parse ();\n-      Compiler::loadModule (m);\n \n       if (m->isDocFile)\n \t{"}, {"sha": "228eed838b239c2fd0b2927b06a48998d029ef2e", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -1,4 +1,4 @@\n-3a7ebef73cc01d4a877a95cf95cd3776c9e3ee66\n+609c3ce2d5d5d8a3dc4ba12c5e6e1100873f9ed1\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "7f9006ce851209b26c67a0c8845d942707eae7ee", "filename": "gcc/d/dmd/compiler.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.h?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -27,12 +27,17 @@ extern Module *entrypoint;\n // Module in which the D main is\n extern Module *rootHasMain;\n \n+extern bool includeImports;\n+// array of module patterns used to include/exclude imported modules\n+extern Array<const char*> includeModulePatterns;\n+extern Array<Module *> compiledImports;\n+\n struct Compiler\n {\n     // CTFE support for cross-compilation.\n     static Expression *paintAsType(UnionExp *, Expression *, Type *);\n     // Backend\n-    static void loadModule(Module *);\n     static void genCmain(Scope *);\n     static bool onImport(Module *);\n+    static void onParseModule(Module *);\n };"}, {"sha": "d20f6636445f7a2954704941b08704d9365807ac", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -145,6 +145,20 @@ int Declaration::checkModify(Loc loc, Scope *sc, Type *, Expression *e1, int fla\n         }\n     }\n \n+    if (e1 && e1->op == TOKthis && isField())\n+    {\n+        VarDeclaration *vthis = e1->isThisExp()->var;\n+        for (Scope *scx = sc; scx; scx = scx->enclosing)\n+        {\n+            if (scx->func == vthis->parent && (scx->flags & SCOPEcontract))\n+            {\n+                if (!flag)\n+                    error(loc, \"cannot modify parameter `this` in contract\");\n+                return 2;   // do not report type related errors\n+            }\n+        }\n+    }\n+\n     if (v && (isCtorinit() || isField()))\n     {\n         // It's only modifiable if inside the right constructor"}, {"sha": "95c263fc42533cb42c8bf082f8125c55c1de36c3", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -375,8 +375,15 @@ Module *Module::load(Loc loc, Identifiers *packages, Identifier *ident)\n \n     m = m->parse();\n \n-    Compiler::loadModule(m);\n-\n+    // Call onImport here because if the module is going to be compiled then we\n+    // need to determine it early because it affects semantic analysis. This is\n+    // being done after parsing the module so the full module name can be taken\n+    // from whatever was declared in the file.\n+    if (!m->isRoot() && Compiler::onImport(m))\n+    {\n+        m->importedFrom = m;\n+        assert(m->isRoot());\n+    }\n     return m;\n }\n \n@@ -736,6 +743,7 @@ Module *Module::parse()\n         // Add to global array of all modules\n         amodules.push(this);\n     }\n+    Compiler::onParseModule(this);\n     return this;\n }\n "}, {"sha": "7cebd9a3023ad23e6f28a245a4e51d3c5524fd21", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -3344,6 +3344,13 @@ class ExpressionSemanticVisitor : public Visitor\n                 return setError();\n             }\n \n+            // https://issues.dlang.org/show_bug.cgi?id=18719\n+            // If `exp` is a call expression to another constructor\n+            // then it means that all struct/class fields will be\n+            // initialized after this call.\n+            for (size_t i = 0; i < sc->fieldinit_dim; i++)\n+                sc->fieldinit[i] |= CSXthis_ctor;\n+\n             if (!sc->intypeof && !(sc->callSuper & CSXhalt))\n             {\n                 if (sc->noctor || sc->callSuper & CSXlabel)"}, {"sha": "2f1d648bf3526c75c915a528e7c5f8a2751c7a13", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -2181,7 +2181,6 @@ void FuncDeclaration::semantic3(Scope *sc)\n             sc2->flags = (sc2->flags & ~SCOPEcontract) | SCOPErequire;\n \n             // BUG: need to error if accessing out parameters\n-            // BUG: need to treat parameters as const\n             // BUG: need to disallow returns and throws\n             // BUG: verify that all in and ref parameters are read\n             freq = ::semantic(freq, sc2);\n@@ -2213,7 +2212,6 @@ void FuncDeclaration::semantic3(Scope *sc)\n             sc2 = scout;    //push\n             sc2->flags = (sc2->flags & ~SCOPEcontract) | SCOPEensure;\n \n-            // BUG: need to treat parameters as const\n             // BUG: need to disallow returns and throws\n             if (fensure && f->next->ty != Tvoid)\n                 buildResultVar(scout, f->next);"}, {"sha": "633414b1530d09e6aa509f7602b5e370ddff4747", "filename": "gcc/d/dmd/root/array.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.h?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -28,9 +28,9 @@ struct Array\n   public:\n     Array()\n     {\n-        data.ptr = SMALLARRAYCAP ? &smallarray[0] : NULL;\n+        data.ptr = NULL;\n         length = 0;\n-        data.length = SMALLARRAYCAP;\n+        data.length = 0;\n     }\n \n     ~Array()"}, {"sha": "28df93a1997588d5e53c70eabaff112f2b72ce99", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18143.d", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18143.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18143.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18143.d?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -0,0 +1,43 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail18143.d(20): Error: variable `fail18143.S.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(21): Error: variable `fail18143.S.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(25): Error: variable `fail18143.S.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(26): Error: variable `fail18143.S.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(35): Error: variable `fail18143.C.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(36): Error: variable `fail18143.C.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(40): Error: variable `fail18143.C.a` cannot modify parameter `this` in contract\n+fail_compilation/fail18143.d(41): Error: variable `fail18143.C.a` cannot modify parameter `this` in contract\n+---\n+*/\n+\n+struct S\n+{\n+    int a;\n+\n+    this(int n)\n+    in { a = n; }   // error, modifying this.a in contract\n+    out { a = n; }  // error, modifying this.a in contract\n+    do { }\n+\n+    void foo(int n)\n+    in { a = n; }   // error, modifying this.a in contract\n+    out { a = n; }  // error, modifying this.a in contract\n+    do { }\n+}\n+\n+class C\n+{\n+    int a;\n+\n+    this(int n)\n+    in { a = n; }   // error, modifying this.a in contract\n+    out { a = n; }  // error, modifying this.a in contract\n+    do { }\n+\n+    void foo(int n)\n+    in { a = n; }   // error, modifying this.a in contract\n+    out { a = n; }  // error, modifying this.a in contract\n+    do { }\n+}"}, {"sha": "7d993d1348542c2d24002d2862155dc7764417d7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18719.d", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18719.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18719.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18719.d?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -0,0 +1,41 @@\n+// https://issues.dlang.org/show_bug.cgi?id=18719\n+\n+// REQUIRED_ARGS:\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail18719.d(30): Error: immutable field `x` initialized multiple times\n+       Previous initialization is here.\n+---\n+*/\n+\n+struct S\n+{\n+    int x = -1;\n+    this(int y) immutable\n+    {\n+        x = y;\n+        import std.stdio;\n+        writeln(\"Ctor called with \", y);\n+    }\n+    void opAssign(int) immutable;\n+}\n+\n+class C\n+{\n+    S x;\n+    this() immutable\n+    {\n+        this(42); /* Initializes x. */\n+        x = 13; /* Breaking immutable, or ok? */\n+    }\n+    this(int x) immutable\n+    {\n+        this.x = x;\n+    }\n+}\n+\n+void main()\n+{\n+    new immutable C;\n+}"}, {"sha": "1d8f8dfb46dc91b829407b1635e3f709f89e556b", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -1,4 +1,4 @@\n-38873fe6ee70fe8e2b7a41b7c3663e090e27d61b\n+3dd5df6864b3849450d3657e219b90909663a513\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "0b11ed967459555b1682439e53910dff4d910e8a", "filename": "libphobos/src/std/datetime/systime.d", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -39,6 +39,16 @@ version (unittest)\n     initializeTests();\n }\n \n+version (unittest) private bool clockSupported(ClockType c)\n+{\n+    // Skip unsupported clocks on older linux kernels, assume that only\n+    // CLOCK_MONOTONIC and CLOCK_REALTIME exist, as that is the lowest\n+    // common denominator supported by all versions of Linux pre-2.6.12.\n+    version (Linux_Pre_2639)\n+        return c == ClockType.normal || c == ClockType.precise;\n+    else\n+        return true;\n+}\n \n /++\n     Effectively a namespace to make it clear that the methods it contains are\n@@ -95,10 +105,13 @@ public:\n         foreach (ct; AliasSeq!(ClockType.coarse, ClockType.precise, ClockType.second))\n         {\n             scope(failure) writefln(\"ClockType.%s\", ct);\n-            auto value1 = Clock.currTime!ct;\n-            auto value2 = Clock.currTime!ct(UTC());\n-            assert(value1 <= value2, format(\"%s %s\", value1, value2));\n-            assert(abs(value1 - value2) <= seconds(2));\n+            static if (clockSupported(ct))\n+            {\n+                auto value1 = Clock.currTime!ct;\n+                auto value2 = Clock.currTime!ct(UTC());\n+                assert(value1 <= value2, format(\"%s %s (ClockType: %s)\", value1, value2, ct));\n+                assert(abs(value1 - value2) <= seconds(2), format(\"ClockType.%s\", ct));\n+            }\n         }\n     }\n \n@@ -270,10 +283,13 @@ public:\n         foreach (ct; AliasSeq!(ClockType.coarse, ClockType.precise, ClockType.second))\n         {\n             scope(failure) writefln(\"ClockType.%s\", ct);\n-            auto value1 = Clock.currStdTime!ct;\n-            auto value2 = Clock.currStdTime!ct;\n-            assert(value1 <= value2, format(\"%s %s\", value1, value2));\n-            assert(abs(value1 - value2) <= limit);\n+            static if (clockSupported(ct))\n+            {\n+                auto value1 = Clock.currStdTime!ct;\n+                auto value2 = Clock.currStdTime!ct;\n+                assert(value1 <= value2, format(\"%s %s (ClockType: %s)\", value1, value2, ct));\n+                assert(abs(value1 - value2) <= limit);\n+            }\n         }\n     }\n "}, {"sha": "380ecfc2bcd49746f61974a592e7952e6077ecb7", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -164,6 +164,16 @@ class FileException : Exception\n      +/\n     immutable uint errno;\n \n+    private this(in char[] name, in char[] msg, string file, size_t line, uint errno) @safe pure\n+    {\n+        if (msg.empty)\n+            super(name.idup, file, line);\n+        else\n+            super(text(name, \": \", msg), file, line);\n+\n+        this.errno = errno;\n+    }\n+\n     /++\n         Constructor which takes an error message.\n \n@@ -175,12 +185,7 @@ class FileException : Exception\n      +/\n     this(in char[] name, in char[] msg, string file = __FILE__, size_t line = __LINE__) @safe pure\n     {\n-        if (msg.empty)\n-            super(name.idup, file, line);\n-        else\n-            super(text(name, \": \", msg), file, line);\n-\n-        errno = 0;\n+        this(name, msg, file, line, 0);\n     }\n \n     /++\n@@ -200,17 +205,15 @@ class FileException : Exception\n                           string file = __FILE__,\n                           size_t line = __LINE__) @safe\n     {\n-        this(name, sysErrorString(errno), file, line);\n-        this.errno = errno;\n+        this(name, sysErrorString(errno), file, line, errno);\n     }\n     else version (Posix) this(in char[] name,\n                              uint errno = .errno,\n                              string file = __FILE__,\n                              size_t line = __LINE__) @trusted\n     {\n         import std.exception : errnoString;\n-        this(name, errnoString(errno), file, line);\n-        this.errno = errno;\n+        this(name, errnoString(errno), file, line, errno);\n     }\n }\n "}, {"sha": "c59bc4c219b0309ce9b9b27455753175b619f1f1", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 309, "deletions": 293, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -37,48 +37,55 @@ else version (CRuntime_DigitalMars)\n     // Specific to the way Digital Mars C does stdio\n     version = DIGITAL_MARS_STDIO;\n }\n-\n-version (CRuntime_Glibc)\n+else version (CRuntime_Glibc)\n {\n     // Specific to the way Gnu C does stdio\n     version = GCC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (CRuntime_Bionic)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (CRuntime_Musl)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n-\n-version (OSX)\n+else version (CRuntime_UClibc)\n+{\n+    // uClibc supports GCC IO\n+    version = GCC_IO;\n+}\n+else version (OSX)\n+{\n+    version = GENERIC_IO;\n+}\n+else version (iOS)\n+{\n+    version = GENERIC_IO;\n+}\n+else version (TVOS)\n+{\n+    version = GENERIC_IO;\n+}\n+else version (WatchOS)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (FreeBSD)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (NetBSD)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (DragonFlyBSD)\n {\n     version = GENERIC_IO;\n-    version = HAS_GETDELIM;\n }\n else version (Solaris)\n {\n     version = GENERIC_IO;\n-    version = NO_GETDELIM;\n }\n \n // Character type used for operating system filesystem APIs\n@@ -105,6 +112,11 @@ version (Windows)\n     import core.sys.windows.windows : HANDLE;\n }\n \n+version (Posix)\n+{\n+    static import core.sys.posix.stdio; // getdelim\n+}\n+\n version (DIGITAL_MARS_STDIO)\n {\n     extern (C)\n@@ -244,11 +256,19 @@ else\n     static assert(0, \"unsupported C I/O system\");\n }\n \n-version (HAS_GETDELIM) extern(C) nothrow @nogc\n+static if (__traits(compiles, core.sys.posix.stdio.getdelim))\n {\n-    ptrdiff_t getdelim(char**, size_t*, int, FILE*);\n-    // getline() always comes together with getdelim()\n-    ptrdiff_t getline(char**, size_t*, FILE*);\n+    extern(C) nothrow @nogc\n+    {\n+        // @@@DEPRECATED_2.104@@@\n+        deprecated(\"To be removed after 2.104. Use core.sys.posix.stdio.getdelim instead.\")\n+        ptrdiff_t getdelim(char**, size_t*, int, FILE*);\n+\n+        // @@@DEPRECATED_2.104@@@\n+        // getline() always comes together with getdelim()\n+        deprecated(\"To be removed after 2.104. Use core.sys.posix.stdio.getline instead.\")\n+        ptrdiff_t getline(char**, size_t*, FILE*);\n+    }\n }\n \n //------------------------------------------------------------------------------\n@@ -4718,59 +4738,142 @@ private struct ReadlnAppender\n }\n \n // Private implementation of readln\n-version (DIGITAL_MARS_STDIO)\n-private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation /*ignored*/)\n+private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation orientation)\n {\n-    FLOCK(fps);\n-    scope(exit) FUNLOCK(fps);\n+    version (DIGITAL_MARS_STDIO)\n+    {\n+        FLOCK(fps);\n+        scope(exit) FUNLOCK(fps);\n \n-    /* Since fps is now locked, we can create an \"unshared\" version\n-     * of fp.\n-     */\n-    auto fp = cast(_iobuf*) fps;\n+        /* Since fps is now locked, we can create an \"unshared\" version\n+         * of fp.\n+         */\n+        auto fp = cast(_iobuf*) fps;\n \n-    ReadlnAppender app;\n-    app.initialize(buf);\n+        ReadlnAppender app;\n+        app.initialize(buf);\n \n-    if (__fhnd_info[fp._file] & FHND_WCHAR)\n-    {   /* Stream is in wide characters.\n-         * Read them and convert to chars.\n-         */\n-        static assert(wchar_t.sizeof == 2);\n-        for (int c = void; (c = FGETWC(fp)) != -1; )\n+        if (__fhnd_info[fp._file] & FHND_WCHAR)\n+        {   /* Stream is in wide characters.\n+             * Read them and convert to chars.\n+             */\n+            static assert(wchar_t.sizeof == 2);\n+            for (int c = void; (c = FGETWC(fp)) != -1; )\n+            {\n+                if ((c & ~0x7F) == 0)\n+                {\n+                    app.putchar(cast(char) c);\n+                    if (c == terminator)\n+                        break;\n+                }\n+                else\n+                {\n+                    if (c >= 0xD800 && c <= 0xDBFF)\n+                    {\n+                        int c2 = void;\n+                        if ((c2 = FGETWC(fp)) != -1 ||\n+                                c2 < 0xDC00 && c2 > 0xDFFF)\n+                        {\n+                            StdioException(\"unpaired UTF-16 surrogate\");\n+                        }\n+                        c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n+                    }\n+                    app.putdchar(cast(dchar) c);\n+                }\n+            }\n+            if (ferror(fps))\n+                StdioException();\n+        }\n+\n+        else if (fp._flag & _IONBF)\n         {\n-            if ((c & ~0x7F) == 0)\n+            /* Use this for unbuffered I/O, when running\n+             * across buffer boundaries, or for any but the common\n+             * cases.\n+             */\n+        L1:\n+            int c;\n+            while ((c = FGETC(fp)) != -1)\n             {\n                 app.putchar(cast(char) c);\n                 if (c == terminator)\n-                    break;\n+                {\n+                    buf = app.data;\n+                    return buf.length;\n+                }\n+\n             }\n-            else\n-            {\n-                if (c >= 0xD800 && c <= 0xDBFF)\n+\n+            if (ferror(fps))\n+                StdioException();\n+        }\n+        else\n+        {\n+            int u = fp._cnt;\n+            char* p = fp._ptr;\n+            int i;\n+            if (fp._flag & _IOTRAN)\n+            {   /* Translated mode ignores \\r and treats ^Z as end-of-file\n+                 */\n+                char c;\n+                while (1)\n                 {\n-                    int c2 = void;\n-                    if ((c2 = FGETWC(fp)) != -1 ||\n-                            c2 < 0xDC00 && c2 > 0xDFFF)\n+                    if (i == u)         // if end of buffer\n+                        goto L1;        // give up\n+                    c = p[i];\n+                    i++;\n+                    if (c != '\\r')\n                     {\n-                        StdioException(\"unpaired UTF-16 surrogate\");\n+                        if (c == terminator)\n+                            break;\n+                        if (c != 0x1A)\n+                            continue;\n+                        goto L1;\n+                    }\n+                    else\n+                    {   if (i != u && p[i] == terminator)\n+                            break;\n+                        goto L1;\n                     }\n-                    c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n                 }\n-                app.putdchar(cast(dchar) c);\n+                app.putonly(p[0 .. i]);\n+                app.buf[i - 1] = cast(char) terminator;\n+                if (terminator == '\\n' && c == '\\r')\n+                    i++;\n             }\n+            else\n+            {\n+                while (1)\n+                {\n+                    if (i == u)         // if end of buffer\n+                        goto L1;        // give up\n+                    auto c = p[i];\n+                    i++;\n+                    if (c == terminator)\n+                        break;\n+                }\n+                app.putonly(p[0 .. i]);\n+            }\n+            fp._cnt -= i;\n+            fp._ptr += i;\n         }\n-        if (ferror(fps))\n-            StdioException();\n-    }\n \n-    else if (fp._flag & _IONBF)\n+        buf = app.data;\n+        return buf.length;\n+    }\n+    else version (MICROSOFT_STDIO)\n     {\n-        /* Use this for unbuffered I/O, when running\n-         * across buffer boundaries, or for any but the common\n-         * cases.\n+        FLOCK(fps);\n+        scope(exit) FUNLOCK(fps);\n+\n+        /* Since fps is now locked, we can create an \"unshared\" version\n+         * of fp.\n          */\n-      L1:\n+        auto fp = cast(_iobuf*) fps;\n+\n+        ReadlnAppender app;\n+        app.initialize(buf);\n+\n         int c;\n         while ((c = FGETC(fp)) != -1)\n         {\n@@ -4785,295 +4888,208 @@ private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orie\n \n         if (ferror(fps))\n             StdioException();\n+        buf = app.data;\n+        return buf.length;\n     }\n-    else\n+    else static if (__traits(compiles, core.sys.posix.stdio.getdelim))\n     {\n-        int u = fp._cnt;\n-        char* p = fp._ptr;\n-        int i;\n-        if (fp._flag & _IOTRAN)\n-        {   /* Translated mode ignores \\r and treats ^Z as end-of-file\n+        import core.stdc.stdlib : free;\n+        import core.stdc.wchar_ : fwide;\n+\n+        if (orientation == File.Orientation.wide)\n+        {\n+            /* Stream is in wide characters.\n+             * Read them and convert to chars.\n              */\n-            char c;\n-            while (1)\n+            FLOCK(fps);\n+            scope(exit) FUNLOCK(fps);\n+            auto fp = cast(_iobuf*) fps;\n+            version (Windows)\n             {\n-                if (i == u)         // if end of buffer\n-                    goto L1;        // give up\n-                c = p[i];\n-                i++;\n-                if (c != '\\r')\n+                buf.length = 0;\n+                for (int c = void; (c = FGETWC(fp)) != -1; )\n                 {\n-                    if (c == terminator)\n-                        break;\n-                    if (c != 0x1A)\n-                        continue;\n-                    goto L1;\n+                    if ((c & ~0x7F) == 0)\n+                    {   buf ~= c;\n+                        if (c == terminator)\n+                            break;\n+                    }\n+                    else\n+                    {\n+                        if (c >= 0xD800 && c <= 0xDBFF)\n+                        {\n+                            int c2 = void;\n+                            if ((c2 = FGETWC(fp)) != -1 ||\n+                                    c2 < 0xDC00 && c2 > 0xDFFF)\n+                            {\n+                                StdioException(\"unpaired UTF-16 surrogate\");\n+                            }\n+                            c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n+                        }\n+                        import std.utf : encode;\n+                        encode(buf, c);\n+                    }\n                 }\n-                else\n-                {   if (i != u && p[i] == terminator)\n+                if (ferror(fp))\n+                    StdioException();\n+                return buf.length;\n+            }\n+            else version (Posix)\n+            {\n+                buf.length = 0;\n+                for (int c; (c = FGETWC(fp)) != -1; )\n+                {\n+                    import std.utf : encode;\n+\n+                    if ((c & ~0x7F) == 0)\n+                        buf ~= cast(char) c;\n+                    else\n+                        encode(buf, cast(dchar) c);\n+                    if (c == terminator)\n                         break;\n-                    goto L1;\n                 }\n+                if (ferror(fps))\n+                    StdioException();\n+                return buf.length;\n+            }\n+            else\n+            {\n+                static assert(0);\n             }\n-            app.putonly(p[0 .. i]);\n-            app.buf[i - 1] = cast(char) terminator;\n-            if (terminator == '\\n' && c == '\\r')\n-                i++;\n         }\n-        else\n+\n+        static char *lineptr = null;\n+        static size_t n = 0;\n+        scope(exit)\n         {\n-            while (1)\n+            if (n > 128 * 1024)\n             {\n-                if (i == u)         // if end of buffer\n-                    goto L1;        // give up\n-                auto c = p[i];\n-                i++;\n-                if (c == terminator)\n-                    break;\n+                // Bound memory used by readln\n+                free(lineptr);\n+                lineptr = null;\n+                n = 0;\n             }\n-            app.putonly(p[0 .. i]);\n         }\n-        fp._cnt -= i;\n-        fp._ptr += i;\n-    }\n-\n-    buf = app.data;\n-    return buf.length;\n-}\n-\n-version (MICROSOFT_STDIO)\n-private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation /*ignored*/)\n-{\n-    FLOCK(fps);\n-    scope(exit) FUNLOCK(fps);\n-\n-    /* Since fps is now locked, we can create an \"unshared\" version\n-     * of fp.\n-     */\n-    auto fp = cast(_iobuf*) fps;\n-\n-    ReadlnAppender app;\n-    app.initialize(buf);\n \n-    int c;\n-    while ((c = FGETC(fp)) != -1)\n-    {\n-        app.putchar(cast(char) c);\n-        if (c == terminator)\n+        auto s = core.sys.posix.stdio.getdelim(&lineptr, &n, terminator, fps);\n+        if (s < 0)\n         {\n-            buf = app.data;\n-            return buf.length;\n+            if (ferror(fps))\n+                StdioException();\n+            buf.length = 0;                // end of file\n+            return 0;\n         }\n \n+        if (s <= buf.length)\n+        {\n+            buf = buf[0 .. s];\n+            buf[] = lineptr[0 .. s];\n+        }\n+        else\n+        {\n+            buf = lineptr[0 .. s].dup;\n+        }\n+        return s;\n     }\n-\n-    if (ferror(fps))\n-        StdioException();\n-    buf = app.data;\n-    return buf.length;\n-}\n-\n-version (HAS_GETDELIM)\n-private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation orientation)\n-{\n-    import core.stdc.stdlib : free;\n-    import core.stdc.wchar_ : fwide;\n-\n-    if (orientation == File.Orientation.wide)\n+    else // version (NO_GETDELIM)\n     {\n-        /* Stream is in wide characters.\n-         * Read them and convert to chars.\n-         */\n+        import core.stdc.wchar_ : fwide;\n+\n         FLOCK(fps);\n         scope(exit) FUNLOCK(fps);\n         auto fp = cast(_iobuf*) fps;\n-        version (Windows)\n+        if (orientation == File.Orientation.wide)\n         {\n-            buf.length = 0;\n-            for (int c = void; (c = FGETWC(fp)) != -1; )\n+            /* Stream is in wide characters.\n+             * Read them and convert to chars.\n+             */\n+            version (Windows)\n             {\n-                if ((c & ~0x7F) == 0)\n-                {   buf ~= c;\n-                    if (c == terminator)\n-                        break;\n-                }\n-                else\n+                buf.length = 0;\n+                for (int c; (c = FGETWC(fp)) != -1; )\n                 {\n-                    if (c >= 0xD800 && c <= 0xDBFF)\n+                    if ((c & ~0x7F) == 0)\n+                    {   buf ~= c;\n+                        if (c == terminator)\n+                            break;\n+                    }\n+                    else\n                     {\n-                        int c2 = void;\n-                        if ((c2 = FGETWC(fp)) != -1 ||\n-                                c2 < 0xDC00 && c2 > 0xDFFF)\n+                        if (c >= 0xD800 && c <= 0xDBFF)\n                         {\n-                            StdioException(\"unpaired UTF-16 surrogate\");\n+                            int c2 = void;\n+                            if ((c2 = FGETWC(fp)) != -1 ||\n+                                    c2 < 0xDC00 && c2 > 0xDFFF)\n+                            {\n+                                StdioException(\"unpaired UTF-16 surrogate\");\n+                            }\n+                            c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n                         }\n-                        c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n+                        import std.utf : encode;\n+                        encode(buf, c);\n                     }\n-                    import std.utf : encode;\n-                    encode(buf, c);\n                 }\n+                if (ferror(fp))\n+                    StdioException();\n+                return buf.length;\n             }\n-            if (ferror(fp))\n-                StdioException();\n-            return buf.length;\n-        }\n-        else version (Posix)\n-        {\n-            buf.length = 0;\n-            for (int c; (c = FGETWC(fp)) != -1; )\n+            else version (Posix)\n             {\n                 import std.utf : encode;\n-\n-                if ((c & ~0x7F) == 0)\n-                    buf ~= cast(char) c;\n-                else\n-                    encode(buf, cast(dchar) c);\n-                if (c == terminator)\n-                    break;\n-            }\n-            if (ferror(fps))\n-                StdioException();\n-            return buf.length;\n-        }\n-        else\n-        {\n-            static assert(0);\n-        }\n-    }\n-\n-    static char *lineptr = null;\n-    static size_t n = 0;\n-    scope(exit)\n-    {\n-        if (n > 128 * 1024)\n-        {\n-            // Bound memory used by readln\n-            free(lineptr);\n-            lineptr = null;\n-            n = 0;\n-        }\n-    }\n-\n-    auto s = getdelim(&lineptr, &n, terminator, fps);\n-    if (s < 0)\n-    {\n-        if (ferror(fps))\n-            StdioException();\n-        buf.length = 0;                // end of file\n-        return 0;\n-    }\n-\n-    if (s <= buf.length)\n-    {\n-        buf = buf[0 .. s];\n-        buf[] = lineptr[0 .. s];\n-    }\n-    else\n-    {\n-        buf = lineptr[0 .. s].dup;\n-    }\n-    return s;\n-}\n-\n-version (NO_GETDELIM)\n-private size_t readlnImpl(FILE* fps, ref char[] buf, dchar terminator, File.Orientation orientation)\n-{\n-    import core.stdc.wchar_ : fwide;\n-\n-    FLOCK(fps);\n-    scope(exit) FUNLOCK(fps);\n-    auto fp = cast(_iobuf*) fps;\n-    if (orientation == File.Orientation.wide)\n-    {\n-        /* Stream is in wide characters.\n-         * Read them and convert to chars.\n-         */\n-        version (Windows)\n-        {\n-            buf.length = 0;\n-            for (int c; (c = FGETWC(fp)) != -1; )\n-            {\n-                if ((c & ~0x7F) == 0)\n-                {   buf ~= c;\n+                buf.length = 0;\n+                for (int c; (c = FGETWC(fp)) != -1; )\n+                {\n+                    if ((c & ~0x7F) == 0)\n+                        buf ~= cast(char) c;\n+                    else\n+                        encode(buf, cast(dchar) c);\n                     if (c == terminator)\n                         break;\n                 }\n-                else\n-                {\n-                    if (c >= 0xD800 && c <= 0xDBFF)\n-                    {\n-                        int c2 = void;\n-                        if ((c2 = FGETWC(fp)) != -1 ||\n-                                c2 < 0xDC00 && c2 > 0xDFFF)\n-                        {\n-                            StdioException(\"unpaired UTF-16 surrogate\");\n-                        }\n-                        c = ((c - 0xD7C0) << 10) + (c2 - 0xDC00);\n-                    }\n-                    import std.utf : encode;\n-                    encode(buf, c);\n-                }\n+                if (ferror(fps))\n+                    StdioException();\n+                return buf.length;\n             }\n-            if (ferror(fp))\n-                StdioException();\n-            return buf.length;\n-        }\n-        else version (Posix)\n-        {\n-            import std.utf : encode;\n-            buf.length = 0;\n-            for (int c; (c = FGETWC(fp)) != -1; )\n+            else\n             {\n-                if ((c & ~0x7F) == 0)\n-                    buf ~= cast(char) c;\n-                else\n-                    encode(buf, cast(dchar) c);\n-                if (c == terminator)\n-                    break;\n+                static assert(0);\n             }\n-            if (ferror(fps))\n-                StdioException();\n-            return buf.length;\n         }\n-        else\n-        {\n-            static assert(0);\n-        }\n-    }\n \n-    // Narrow stream\n-    // First, fill the existing buffer\n-    for (size_t bufPos = 0; bufPos < buf.length; )\n-    {\n-        immutable c = FGETC(fp);\n-        if (c == -1)\n-        {\n-            buf.length = bufPos;\n-            goto endGame;\n-        }\n-        buf[bufPos++] = cast(char) c;\n-        if (c == terminator)\n+        // Narrow stream\n+        // First, fill the existing buffer\n+        for (size_t bufPos = 0; bufPos < buf.length; )\n         {\n-            // No need to test for errors in file\n-            buf.length = bufPos;\n-            return bufPos;\n+            immutable c = FGETC(fp);\n+            if (c == -1)\n+            {\n+                buf.length = bufPos;\n+                goto endGame;\n+            }\n+            buf[bufPos++] = cast(char) c;\n+            if (c == terminator)\n+            {\n+                // No need to test for errors in file\n+                buf.length = bufPos;\n+                return bufPos;\n+            }\n         }\n-    }\n-    // Then, append to it\n-    for (int c; (c = FGETC(fp)) != -1; )\n-    {\n-        buf ~= cast(char) c;\n-        if (c == terminator)\n+        // Then, append to it\n+        for (int c; (c = FGETC(fp)) != -1; )\n         {\n-            // No need to test for errors in file\n-            return buf.length;\n+            buf ~= cast(char) c;\n+            if (c == terminator)\n+            {\n+                // No need to test for errors in file\n+                return buf.length;\n+            }\n         }\n-    }\n \n-  endGame:\n-    if (ferror(fps))\n-        StdioException();\n-    return buf.length;\n+    endGame:\n+        if (ferror(fps))\n+            StdioException();\n+        return buf.length;\n+    }\n }\n \n @system unittest"}, {"sha": "0975ab1f801bd2638336f9caba1d5063bac1488d", "filename": "libphobos/testsuite/libphobos.phobos/phobos.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Ftestsuite%2Flibphobos.phobos%2Fphobos.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Ftestsuite%2Flibphobos.phobos%2Fphobos.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.phobos%2Fphobos.exp?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -27,6 +27,12 @@ if { ![is-effective-target d_runtime_has_std_library] } {\n # Gather a list of all tests.\n set tests [lsort [filter_libphobos_unittests [find $srcdir/../src \"*.d\"]]]\n \n+set version_flags \"\"\n+\n+if { [is-effective-target linux_pre_2639] } {\n+    lappend version_flags \"-fversion=Linux_Pre_2639\"\n+}\n+\n set libphobos_skip_tests {\n     # Skip curl tests if library is not available\n     { libphobos.phobos/etc/c/curl.d { ! libcurl_available } }\n@@ -39,7 +45,7 @@ dg-init\n # Main loop.\n foreach test $tests {\n     set libphobos_test_name \"$subdir/[dg-trim-dirname $srcdir/../src $test]\"\n-    dg-runtest $test \"\" \"-fmain -fbuilding-libphobos-tests\"\n+    dg-runtest $test \"\" \"-fmain -fbuilding-libphobos-tests $version_flags\"\n     set libphobos_test_name \"\"\n }\n "}, {"sha": "da31304490806ed8710a8fc726961da10a5bcbba", "filename": "libphobos/testsuite/libphobos.phobos_shared/phobos_shared.exp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Ftestsuite%2Flibphobos.phobos_shared%2Fphobos_shared.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a36cae275ad84cc7e623f2f5829bdad767e3f6a/libphobos%2Ftestsuite%2Flibphobos.phobos_shared%2Fphobos_shared.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.phobos_shared%2Fphobos_shared.exp?ref=5a36cae275ad84cc7e623f2f5829bdad767e3f6a", "patch": "@@ -27,6 +27,12 @@ if { ![is-effective-target d_runtime_has_std_library] } {\n # Gather a list of all tests.\n set tests [lsort [filter_libphobos_unittests [find $srcdir/../src \"*.d\"]]]\n \n+set version_flags \"\"\n+\n+if { [is-effective-target linux_pre_2639] } {\n+    lappend version_flags \"-fversion=Linux_Pre_2639\"\n+}\n+\n set libphobos_skip_tests {\n     # Skip curl tests if library is not available\n     { libphobos.phobos_shared/etc/c/curl.d { ! libcurl_available } }\n@@ -40,7 +46,7 @@ dg-init\n foreach test $tests {\n     set libphobos_test_name \"$subdir/[dg-trim-dirname $srcdir/../src $test]\"\n     dg-runtest $test \"-fversion=Shared -shared-libphobos\" \\\n-\t\"-fmain -fbuilding-libphobos-tests -fno-moduleinfo\"\n+\t\"-fmain -fbuilding-libphobos-tests -fno-moduleinfo $version_flags\"\n     set libphobos_test_name \"\"\n }\n "}]}