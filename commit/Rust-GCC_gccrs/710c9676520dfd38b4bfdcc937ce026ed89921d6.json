{"sha": "710c9676520dfd38b4bfdcc937ce026ed89921d6", "node_id": "C_kwDOANBUbNoAKDcxMGM5Njc2NTIwZGZkMzhiNGJmZGNjOTM3Y2UwMjZlZDg5OTIxZDY", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-12-06T18:50:04Z"}, "committer": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2022-12-06T18:50:04Z"}, "message": "Update -Warray-bounds with -fstrict-flex-arrays.\n\n     A. add the following to clarify the relationship between -Warray-bounds\n        and the LEVEL of -fstrict-flex-array:\n\n     By default, the trailing array of a structure will be treated as a\n     flexible array member by '-Warray-bounds' or '-Warray-bounds=N' if\n     it is declared as either a flexible array member per C99 standard\n     onwards ('[]'), a GCC zero-length array extension ('[0]'), or an\n     one-element array ('[1]').  As a result, out of bounds subscripts\n     or offsets into zero-length arrays or one-element arrays are not\n     warned by default.\n\n     You can add the option '-fstrict-flex-arrays' or\n     '-fstrict-flex-arrays=LEVEL' to control how this option treat\n     trailing array of a structure as a flexible array member.\n\n     when LEVEL<=1, no change to the default behavior.\n\n     when LEVEL=2, additional warnings will be issued for out of bounds\n     subscripts or offsets into one-element arrays;\n\n     when LEVEL=3, in addition to LEVEL=2, additional warnings will be\n     issued for out of bounds subscripts or offsets into zero-length\n     arrays.\n\n     B. change -Warray-bounds=2 to exclude its control on how to treat\n        trailing arrays as flexible array members:\n\n     '-Warray-bounds=2'\n          This warning level also warns about the intermediate results\n          of pointer arithmetic that may yield out of bounds values.\n          This warning level may give a larger number of false positives\n          and is deactivated by default.\n\ngcc/ChangeLog:\n\n\t* attribs.cc (strict_flex_array_level_of): New function.\n\t* attribs.h (strict_flex_array_level_of): Prototype for new function.\n\t* doc/invoke.texi: Update -Warray-bounds by specifying the impact from\n\t-fstrict-flex-arrays. Also update -Warray-bounds=2 by eliminating its\n\timpact on treating trailing arrays as flexible array members.\n\t* gimple-array-bounds.cc (get_up_bounds_for_array_ref): New function.\n\t(check_out_of_bounds_and_warn): New function.\n\t(array_bounds_checker::check_array_ref): Update with call to the above\n\tnew functions.\n\t* tree.cc (array_ref_flexible_size_p): Add one new argument.\n\t(component_ref_sam_type): New function.\n\t(component_ref_size): Control with level of strict-flex-array.\n\t* tree.h (array_ref_flexible_size_p): Update prototype.\n\t(enum struct special_array_member): Add two new enum values.\n\t(component_ref_sam_type): New prototype.\n\ngcc/c/ChangeLog:\n\n\t* c-decl.cc (is_flexible_array_member_p): Call new function\n\tstrict_flex_array_level_of.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Warray-bounds-11.c: Update warnings for -Warray-bounds=2.\n\t* gcc.dg/Warray-bounds-flex-arrays-1.c: New test.\n\t* gcc.dg/Warray-bounds-flex-arrays-2.c: New test.\n\t* gcc.dg/Warray-bounds-flex-arrays-3.c: New test.\n\t* gcc.dg/Warray-bounds-flex-arrays-4.c: New test.\n\t* gcc.dg/Warray-bounds-flex-arrays-5.c: New test.\n\t* gcc.dg/Warray-bounds-flex-arrays-6.c: New test.", "tree": {"sha": "81a6bc70c710cba93ab79a61180ce822fe31ae13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81a6bc70c710cba93ab79a61180ce822fe31ae13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/710c9676520dfd38b4bfdcc937ce026ed89921d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710c9676520dfd38b4bfdcc937ce026ed89921d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710c9676520dfd38b4bfdcc937ce026ed89921d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710c9676520dfd38b4bfdcc937ce026ed89921d6/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcfc7ac94dbcf6c86c0c58ce6dc1d8bd853e4093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfc7ac94dbcf6c86c0c58ce6dc1d8bd853e4093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfc7ac94dbcf6c86c0c58ce6dc1d8bd853e4093"}], "stats": {"total": 637, "additions": 512, "deletions": 125}, "files": [{"sha": "095def4d6b053668eb16a68bfe9274cb6ac02424", "filename": "gcc/attribs.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fattribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fattribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.cc?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -2456,6 +2456,36 @@ init_attr_rdwr_indices (rdwr_map *rwm, tree attrs)\n     }\n }\n \n+/* Get the LEVEL of the strict_flex_array for the ARRAY_FIELD based on the\n+   values of attribute strict_flex_array and the flag_strict_flex_arrays.  */\n+unsigned int\n+strict_flex_array_level_of (tree array_field)\n+{\n+  gcc_assert (TREE_CODE (array_field) == FIELD_DECL);\n+  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n+\n+  tree attr_strict_flex_array\n+    = lookup_attribute (\"strict_flex_array\", DECL_ATTRIBUTES (array_field));\n+  /* If there is a strict_flex_array attribute attached to the field,\n+     override the flag_strict_flex_arrays.  */\n+  if (attr_strict_flex_array)\n+    {\n+      /* Get the value of the level first from the attribute.  */\n+      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n+      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n+      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n+      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n+\n+      /* The attribute has higher priority than flag_struct_flex_array.  */\n+      strict_flex_array_level = attr_strict_flex_array_level;\n+    }\n+  return strict_flex_array_level;\n+}\n+\n+\n /* Return the access specification for a function parameter PARM\n    or null if the current function has no such specification.  */\n "}, {"sha": "742811e6fdac73fc8306a37e791ff911a6f5196b", "filename": "gcc/attribs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -398,4 +398,6 @@ extern void init_attr_rdwr_indices (rdwr_map *, tree);\n extern attr_access *get_parm_access (rdwr_map &, tree,\n \t\t\t\t     tree = current_function_decl);\n \n+extern unsigned int strict_flex_array_level_of (tree);\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "111f05e2a40efba88dacfdc310980fd4939267db", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -9067,26 +9067,7 @@ is_flexible_array_member_p (bool is_last_field,\n   bool is_one_element_array = one_element_array_type_p (TREE_TYPE (x));\n   bool is_flexible_array = flexible_array_member_type_p (TREE_TYPE (x));\n \n-  unsigned int strict_flex_array_level = flag_strict_flex_arrays;\n-\n-  tree attr_strict_flex_array = lookup_attribute (\"strict_flex_array\",\n-\t\t\t\t\t\t  DECL_ATTRIBUTES (x));\n-  /* If there is a strict_flex_array attribute attached to the field,\n-     override the flag_strict_flex_arrays.  */\n-  if (attr_strict_flex_array)\n-    {\n-      /* Get the value of the level first from the attribute.  */\n-      unsigned HOST_WIDE_INT attr_strict_flex_array_level = 0;\n-      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n-      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n-      gcc_assert (TREE_VALUE (attr_strict_flex_array) != NULL_TREE);\n-      attr_strict_flex_array = TREE_VALUE (attr_strict_flex_array);\n-      gcc_assert (tree_fits_uhwi_p (attr_strict_flex_array));\n-      attr_strict_flex_array_level = tree_to_uhwi (attr_strict_flex_array);\n-\n-      /* The attribute has higher priority than flag_struct_flex_array.  */\n-      strict_flex_array_level = attr_strict_flex_array_level;\n-    }\n+  unsigned int strict_flex_array_level = strict_flex_array_level_of (x);\n \n   switch (strict_flex_array_level)\n     {"}, {"sha": "726392409b67277f454e6ae30bdbbdbf024a6123", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -8040,17 +8040,34 @@ is enabled by @option{-Wall}.  It is more effective when @option{-ftree-vrp}\n is active (the default for @option{-O2} and above) but a subset of instances\n are issued even without optimization.\n \n+By default, the trailing array of a structure will be treated as a flexible\n+array member by @option{-Warray-bounds} or @option{-Warray-bounds=@var{n}}\n+if it is declared as either a flexible array member per C99 standard onwards\n+(@samp{[]}), a GCC zero-length array extension (@samp{[0]}), or an one-element\n+array (@samp{[1]}). As a result, out of bounds subscripts or offsets into\n+zero-length arrays or one-element arrays are not warned by default.\n+\n+You can add the option @option{-fstrict-flex-arrays} or\n+@option{-fstrict-flex-arrays=@var{level}} to control how this\n+option treat trailing array of a structure as a flexible array member:\n+\n+when @var{level}<=1, no change to the default behavior.\n+\n+when @var{level}=2, additional warnings will be issued for out of bounds\n+subscripts or offsets into one-element arrays;\n+\n+when @var{level}=3, in addition to @var{level}=2, additional warnings will be\n+issued for out of bounds subscripts or offsets into zero-length arrays.\n+\n @table @gcctabopt\n @item -Warray-bounds=1\n This is the default warning level of @option{-Warray-bounds} and is enabled\n by @option{-Wall}; higher levels are not, and must be explicitly requested.\n \n @item -Warray-bounds=2\n-This warning level also warns about out of bounds accesses to trailing\n-struct members of one-element array types (@pxref{Zero Length}) and about\n-the intermediate results of pointer arithmetic that may yield out of bounds\n-values.  This warning level may give a larger number of false positives and\n-is deactivated by default.\n+This warning level also warns about the intermediate results of pointer\n+arithmetic that may yield out of bounds values. This warning level may\n+give a larger number of false positives and is deactivated by default.\n @end table\n \n @item -Warray-compare"}, {"sha": "59bd9ebc5756ad6141535414c83ff46df603b270", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 96, "deletions": 54, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -160,38 +160,17 @@ trailing_array (tree arg, tree *pref)\n   return array_ref_flexible_size_p (arg);\n }\n \n-/* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible\n-   arrays and \"struct\" hacks. If VRP can determine that the array\n-   subscript is a constant, check if it is outside valid range.  If\n-   the array subscript is a RANGE, warn if it is non-overlapping with\n-   valid range.  IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside\n-   a ADDR_EXPR.  Return  true if a warning has been issued or if\n-   no-warning is set.  */\n+/* Acquire the upper bound and upper bound plus one for the array\n+   reference REF and record them into UP_BOUND and UP_BOUND_P1.\n+   Set *DECL to the decl or expresssion REF refers to.  */\n \n-bool\n-array_bounds_checker::check_array_ref (location_t location, tree ref,\n-\t\t\t\t       gimple *stmt, bool ignore_off_by_one)\n+static void\n+get_up_bounds_for_array_ref (tree ref, tree *decl,\n+\t\t\t     tree *up_bound, tree *up_bound_p1)\n {\n-  if (warning_suppressed_p (ref, OPT_Warray_bounds_))\n-    /* Return true to have the caller prevent warnings for enclosing\n-       refs.  */\n-    return true;\n-\n-  tree low_sub = TREE_OPERAND (ref, 1);\n-  tree up_sub = low_sub;\n-  tree up_bound = array_ref_up_bound (ref);\n-\n-  /* Referenced decl if one can be determined.  */\n-  tree decl = NULL_TREE;\n-\n-  /* Set for accesses to interior zero-length arrays.  */\n-  special_array_member sam{ };\n-\n-  tree up_bound_p1;\n-\n-  if (!up_bound\n-      || TREE_CODE (up_bound) != INTEGER_CST\n-      || (warn_array_bounds < 2 && trailing_array (ref, &decl)))\n+  if (!(*up_bound)\n+      || TREE_CODE (*up_bound) != INTEGER_CST\n+      || trailing_array (ref, decl))\n     {\n       /* Accesses to trailing arrays via pointers may access storage\n \t beyond the types array bounds.  For such arrays, or for flexible\n@@ -203,8 +182,8 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n       if (TREE_CODE (eltsize) != INTEGER_CST\n \t  || integer_zerop (eltsize))\n \t{\n-\t  up_bound = NULL_TREE;\n-\t  up_bound_p1 = NULL_TREE;\n+\t  *up_bound = NULL_TREE;\n+\t  *up_bound_p1 = NULL_TREE;\n \t}\n       else\n \t{\n@@ -217,7 +196,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t    {\n \t      /* Try to determine the size of the trailing array from\n \t\t its initializer (if it has one).  */\n-\t      if (tree refsize = component_ref_size (arg, &sam))\n+\t      if (tree refsize = component_ref_size (arg))\n \t\tif (TREE_CODE (refsize) == INTEGER_CST)\n \t\t  maxbound = refsize;\n \t    }\n@@ -236,15 +215,15 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t\t    {\n \t\t      /* Try to determine the size from a pointer to\n \t\t\t an array if BASE is one.  */\n-\t\t      if (tree size = get_ref_size (base, &decl))\n+\t\t      if (tree size = get_ref_size (base, decl))\n \t\t\tmaxbound = size;\n \t\t    }\n \t\t  else if (!compref && DECL_P (base))\n \t\t    if (tree basesize = DECL_SIZE_UNIT (base))\n \t\t      if (TREE_CODE (basesize) == INTEGER_CST)\n \t\t\t{\n \t\t\t  maxbound = basesize;\n-\t\t\t  decl = base;\n+\t\t\t  *decl = base;\n \t\t\t}\n \n \t\t  if (known_gt (off, 0))\n@@ -256,21 +235,33 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t  else\n \t    maxbound = fold_convert (sizetype, maxbound);\n \n-\t  up_bound_p1 = int_const_binop (TRUNC_DIV_EXPR, maxbound, eltsize);\n+\t  *up_bound_p1 = int_const_binop (TRUNC_DIV_EXPR, maxbound, eltsize);\n \n-\t  if (up_bound_p1 != NULL_TREE)\n-\t    up_bound = int_const_binop (MINUS_EXPR, up_bound_p1,\n+\t  if (*up_bound_p1 != NULL_TREE)\n+\t    *up_bound = int_const_binop (MINUS_EXPR, *up_bound_p1,\n \t\t\t\t\tbuild_int_cst (ptrdiff_type_node, 1));\n \t  else\n-\t    up_bound = NULL_TREE;\n+\t    *up_bound = NULL_TREE;\n \t}\n     }\n   else\n-    up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound,\n-\t\t\t\t   build_int_cst (TREE_TYPE (up_bound), 1));\n+    *up_bound_p1 = int_const_binop (PLUS_EXPR, *up_bound,\n+\t\t\t\t   build_int_cst (TREE_TYPE (*up_bound), 1));\n+  return;\n+}\n \n-  tree low_bound = array_ref_low_bound (ref);\n+/* Given the LOW_SUB_ORG, LOW_SUB and UP_SUB, and the computed UP_BOUND\n+   and UP_BOUND_P1, check whether the array reference REF is out of bound.\n+   Issue warnings if out of bound, return TRUE if warnings are issued.  */\n \n+static bool\n+check_out_of_bounds_and_warn (location_t location, tree ref,\n+\t\t\t      tree low_sub_org, tree low_sub, tree up_sub,\n+\t\t\t      tree up_bound, tree up_bound_p1,\n+\t\t\t      const value_range *vr,\n+\t\t\t      bool ignore_off_by_one)\n+{\n+  tree low_bound = array_ref_low_bound (ref);\n   tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n \n   bool warned = false;\n@@ -279,18 +270,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n   if (up_bound && tree_int_cst_equal (low_bound, up_bound_p1))\n     warned = warning_at (location, OPT_Warray_bounds_,\n \t\t\t \"array subscript %E is outside array bounds of %qT\",\n-\t\t\t low_sub, artype);\n-\n-  const value_range *vr = NULL;\n-  if (TREE_CODE (low_sub) == SSA_NAME)\n-    {\n-      vr = get_value_range (low_sub, stmt);\n-      if (!vr->undefined_p () && !vr->varying_p ())\n-\t{\n-\t  low_sub = vr->kind () == VR_RANGE ? vr->max () : vr->min ();\n-\t  up_sub = vr->kind () == VR_RANGE ? vr->min () : vr->max ();\n-\t}\n-    }\n+\t\t\t low_sub_org, artype);\n \n   if (warned)\n     ; /* Do nothing.  */\n@@ -321,6 +301,68 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n     warned = warning_at (location, OPT_Warray_bounds_,\n \t\t\t \"array subscript %E is below array bounds of %qT\",\n \t\t\t low_sub, artype);\n+  return warned;\n+}\n+\n+/* Checks one ARRAY_REF in REF, located at LOCUS.  Ignores flexible\n+   arrays and \"struct\" hacks.  If VRP can determine that the array\n+   subscript is a constant, check if it is outside valid range.  If\n+   the array subscript is a RANGE, warn if it is non-overlapping with\n+   valid range.  IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside\n+   a ADDR_EXPR.  Return  true if a warning has been issued or if\n+   no-warning is set.  */\n+\n+bool\n+array_bounds_checker::check_array_ref (location_t location, tree ref,\n+\t\t\t\t       gimple *stmt, bool ignore_off_by_one)\n+{\n+  if (warning_suppressed_p (ref, OPT_Warray_bounds_))\n+    /* Return true to have the caller prevent warnings for enclosing\n+       refs.  */\n+    return true;\n+\n+  /* Upper bound and Upper bound plus one for -Warray-bounds.  */\n+  tree up_bound = array_ref_up_bound (ref);\n+  tree up_bound_p1 = NULL_TREE;\n+\n+  /* Referenced decl if one can be determined.  */\n+  tree decl = NULL_TREE;\n+\n+  /* Set to the type of the special array member for a COMPONENT_REF.  */\n+  special_array_member sam{ };\n+\n+  tree arg = TREE_OPERAND (ref, 0);\n+  const bool compref = TREE_CODE (arg) == COMPONENT_REF;\n+\n+  if (compref)\n+    /* Try to determine special array member type for this COMPONENT_REF.  */\n+    sam = component_ref_sam_type (arg);\n+\n+  get_up_bounds_for_array_ref (ref, &decl, &up_bound, &up_bound_p1);\n+\n+  bool warned = false;\n+\n+  tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n+  tree low_sub_org = TREE_OPERAND (ref, 1);\n+  tree up_sub = low_sub_org;\n+  tree low_sub = low_sub_org;\n+\n+  const value_range *vr = NULL;\n+  if (TREE_CODE (low_sub_org) == SSA_NAME)\n+    {\n+      vr = get_value_range (low_sub_org, stmt);\n+      if (!vr->undefined_p () && !vr->varying_p ())\n+\t{\n+\t  low_sub = vr->kind () == VR_RANGE ? vr->max () : vr->min ();\n+\t  up_sub = vr->kind () == VR_RANGE ? vr->min () : vr->max ();\n+\t}\n+    }\n+\n+  warned = check_out_of_bounds_and_warn (location, ref,\n+\t\t\t\t\t low_sub_org, low_sub, up_sub,\n+\t\t\t\t\t up_bound, up_bound_p1, vr,\n+\t\t\t\t\t ignore_off_by_one);\n+\n \n   if (!warned && sam == special_array_member::int_0)\n     warned = warning_at (location, OPT_Wzero_length_bounds,"}, {"sha": "3ba2bb67fa06cc1a7a48986f47516022adbda913", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-11.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -78,7 +78,7 @@ void foo(int (*a)[3])\n \n \th->j[4] = 1;\t// flexible array member\n \th0->j[4] = 1;\t// zero-sized array extension\n-\th1->j[4] = 1;\t/* { dg-warning \"subscript 4 is above array bound\" } */\n+\th1->j[4] = 1;\t/* { dg-bogus \"subscript 4 is above array bound\" } */\n \th3->j[4] = 1;\t/* { dg-warning \"subscript 4 is above array bound\" } */\n \n \tstruct h0b* h0b = malloc(sizeof(struct h) + 3 * sizeof(int));"}, {"sha": "d36ba4d86cbdf3981024b3a1e91e7859c6acbf1a", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-1.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* { dg-do compile} */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=1 -Warray-bounds\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    trailing_1->c[2] = 2; /* { dg-bogus \"array subscript \" } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n+\n+}"}, {"sha": "f63206e19483dafcb3d0ca1c2f6e4f5e445df4a7", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-2.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=2 -Warray-bounds\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    trailing_1->c[2] = 2; /* { dg-warning \"array subscript 2 is above array bounds of\"  } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n+\n+}"}, {"sha": "e3273714e8bb5da2d8dbe21c23456038b131690b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-3.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=3 -Warray-bounds\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */ \n+    trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */ \n+    trailing_0->c[1] = 1; /*{ dg-warning \"array subscript 1 is outside array bounds of\" } */ \n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript\" } */\n+\n+}"}, {"sha": "cabaea77dc2d572a7f4f9b7fc8ce5a68089006a7", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-4.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=1 -Warray-bounds=2\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    trailing_1->c[2] = 2; /* { dg-bogus \"array subscript \" } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n+\n+}"}, {"sha": "8b7db6e4f397479c49e4a0aa5d8439219d79d48c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-5.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-5.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=2 -Warray-bounds=2\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5;   /*{ dg-warning \"array subscript 5 is above array bounds of\" } */\n+    trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */\n+    trailing_0->c[1] = 1; /* { dg-bogus \"array subscript \" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n+\n+}"}, {"sha": "035bf481396cb4220158dd671e5dfc3c016593c0", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-flex-arrays-6.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-flex-arrays-6.c?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -0,0 +1,39 @@\n+/* Test -fstrict-flex-arrays + -Warray-bounds=2.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-flex-arrays=3 -Warray-bounds=2\" } */\n+\n+struct trailing_array_1 {\n+    int a;\n+    int b;\n+    int c[4]; \n+};\n+\n+struct trailing_array_2 {\n+    int a;\n+    int b;\n+    int c[1]; \n+};\n+\n+struct trailing_array_3 {\n+    int a;\n+    int b;\n+    int c[0];\n+};\n+struct trailing_array_4 {\n+    int a;\n+    int b;\n+    int c[];\n+};\n+\n+void __attribute__((__noinline__)) stuff(\n+    struct trailing_array_1 *normal,\n+    struct trailing_array_2 *trailing_1,\n+    struct trailing_array_3 *trailing_0,\n+    struct trailing_array_4 *trailing_flex)\n+{\n+    normal->c[5] = 5; \t/*{ dg-warning \"array subscript 5 is above array bounds of\" } */ \n+    trailing_1->c[2] = 2; /*{ dg-warning \"array subscript 2 is above array bounds of\" } */\n+    trailing_0->c[1] = 1; /*{ dg-warning \"array subscript 1 is outside array bounds of\" } */\n+    trailing_flex->c[10] = 10; /* { dg-bogus \"array subscript \" } */\n+\n+}"}, {"sha": "b40c95ae8c43003e2b1e9cc77d9b86d926693c6b", "filename": "gcc/tree.cc", "status": "modified", "additions": 118, "deletions": 41, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -12719,15 +12719,21 @@ array_ref_up_bound (tree exp)\n    int test (uint8_t *p, uint32_t t[1][1], int n) {\n    for (int i = 0; i < 4; i++, p++)\n      t[i][0] = ...;\n+\n+   If non-null, set IS_TRAILING_ARRAY to true if the ref is the above case A.\n */\n \n bool\n-array_ref_flexible_size_p (tree ref)\n+array_ref_flexible_size_p (tree ref, bool *is_trailing_array /* = NULL */)\n {\n-  /* the TYPE for this array referece.  */\n+  /* The TYPE for this array referece.  */\n   tree atype = NULL_TREE;\n-  /* the FIELD_DECL for the array field in the containing structure.  */\n+  /* The FIELD_DECL for the array field in the containing structure.  */\n   tree afield_decl = NULL_TREE;\n+  /* Whether this array is the trailing array of a structure.  */\n+  bool is_trailing_array_tmp = false;\n+  if (!is_trailing_array)\n+    is_trailing_array = &is_trailing_array_tmp;\n \n   if (TREE_CODE (ref) == ARRAY_REF\n       || TREE_CODE (ref) == ARRAY_RANGE_REF)\n@@ -12815,7 +12821,10 @@ array_ref_flexible_size_p (tree ref)\n   if (! TYPE_SIZE (atype)\n       || ! TYPE_DOMAIN (atype)\n       || ! TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n-    return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+    {\n+      *is_trailing_array = afield_decl && TREE_CODE (afield_decl) == FIELD_DECL;\n+      return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+    }\n \n   /* If the reference is based on a declared entity, the size of the array\n      is constrained by its given domain.  (Do not trust commons PR/69368).  */\n@@ -12837,21 +12846,34 @@ array_ref_flexible_size_p (tree ref)\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (atype))) != INTEGER_CST\n \t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST\n           || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (atype))) != INTEGER_CST)\n-\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t{\n+\t  *is_trailing_array\n+\t    = afield_decl && TREE_CODE (afield_decl) == FIELD_DECL;\n+\t  return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t}\n       if (! get_addr_base_and_unit_offset (ref_to_array, &offset))\n-\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t{\n+\t  *is_trailing_array\n+\t    = afield_decl && TREE_CODE (afield_decl) == FIELD_DECL;\n+\t  return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t}\n \n       /* If at least one extra element fits it is a flexarray.  */\n       if (known_le ((wi::to_offset (TYPE_MAX_VALUE (TYPE_DOMAIN (atype)))\n \t\t     - wi::to_offset (TYPE_MIN_VALUE (TYPE_DOMAIN (atype)))\n \t\t     + 2)\n \t\t    * wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (atype))),\n \t\t    wi::to_offset (DECL_SIZE_UNIT (ref)) - offset))\n-\treturn afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t{\n+\t  *is_trailing_array\n+\t    = afield_decl && TREE_CODE (afield_decl) == FIELD_DECL;\n+\t  return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n+\t}\n \n       return false;\n     }\n \n+  *is_trailing_array = afield_decl && TREE_CODE (afield_decl) == FIELD_DECL;\n   return afield_decl ? !DECL_NOT_FLEXARRAY (afield_decl) : true;\n }\n \n@@ -12913,11 +12935,63 @@ get_initializer_for (tree init, tree decl)\n   return NULL_TREE;\n }\n \n+/* Determines the special array member type for the array reference REF.  */\n+special_array_member\n+component_ref_sam_type (tree ref)\n+{\n+  special_array_member sam_type = special_array_member::none;\n+\n+  tree member = TREE_OPERAND (ref, 1);\n+  tree memsize = DECL_SIZE_UNIT (member);\n+  if (memsize)\n+    {\n+      tree memtype = TREE_TYPE (member);\n+      if (TREE_CODE (memtype) != ARRAY_TYPE)\n+\treturn sam_type;\n+\n+      bool trailing = false;\n+      (void)array_ref_flexible_size_p (ref, &trailing);\n+      bool zero_length = integer_zerop (memsize);\n+      if (!trailing && !zero_length)\n+\t/* MEMBER is an interior array with\n+\t  more than one element.  */\n+\treturn special_array_member::int_n;\n+\n+      if (zero_length)\n+\t{\n+\t  if (trailing)\n+\t    return special_array_member::trail_0;\n+\t  else\n+\t    return special_array_member::int_0;\n+\t}\n+\n+      if (!zero_length)\n+\tif (tree dom = TYPE_DOMAIN (memtype))\n+\t  if (tree min = TYPE_MIN_VALUE (dom))\n+\t    if (tree max = TYPE_MAX_VALUE (dom))\n+\t      if (TREE_CODE (min) == INTEGER_CST\n+\t\t  && TREE_CODE (max) == INTEGER_CST)\n+\t\t{\n+\t\t  offset_int minidx = wi::to_offset (min);\n+\t\t  offset_int maxidx = wi::to_offset (max);\n+\t\t  offset_int neltsm1 = maxidx - minidx;\n+\t\t  if (neltsm1 > 0)\n+\t\t    /* MEMBER is a trailing array with more than\n+\t\t       one elements.  */\n+\t\t    return special_array_member::trail_n;\n+\n+\t\t  if (neltsm1 == 0)\n+\t\t    return special_array_member::trail_1;\n+\t\t}\n+    }\n+\n+  return sam_type;\n+}\n+\n /* Determines the size of the member referenced by the COMPONENT_REF\n    REF, using its initializer expression if necessary in order to\n    determine the size of an initialized flexible array member.\n-   If non-null, set *ARK when REF refers to an interior zero-length\n-   array or a trailing one-element array.\n+   If non-null, set *SAM to the type of special array member.\n    Returns the size as sizetype (which might be zero for an object\n    with an uninitialized flexible array member) or null if the size\n    cannot be determined.  */\n@@ -12930,7 +13004,7 @@ component_ref_size (tree ref, special_array_member *sam /* = NULL */)\n   special_array_member sambuf;\n   if (!sam)\n     sam = &sambuf;\n-  *sam = special_array_member::none;\n+  *sam = component_ref_sam_type (ref);\n \n   /* The object/argument referenced by the COMPONENT_REF and its type.  */\n   tree arg = TREE_OPERAND (ref, 0);\n@@ -12951,43 +13025,46 @@ component_ref_size (tree ref, special_array_member *sam /* = NULL */)\n \treturn (tree_int_cst_equal (memsize, TYPE_SIZE_UNIT (memtype))\n \t\t? memsize : NULL_TREE);\n \n-      bool trailing = array_ref_flexible_size_p (ref);\n-      bool zero_length = integer_zerop (memsize);\n-      if (!trailing && !zero_length)\n-\t/* MEMBER is either an interior array or is an array with\n-\t   more than one element.  */\n+      /* 2-or-more elements arrays are treated as normal arrays by default.  */\n+      if (*sam == special_array_member::int_n\n+\t  || *sam == special_array_member::trail_n)\n \treturn memsize;\n \n-      if (zero_length)\n+      /* flag_strict_flex_arrays will control how to treat\n+\t the trailing arrays as flexiable array members.  */\n+\n+      tree afield_decl = TREE_OPERAND (ref, 1);\n+      unsigned int strict_flex_array_level\n+\t= strict_flex_array_level_of (afield_decl);\n+\n+      switch (strict_flex_array_level)\n \t{\n-\t  if (trailing)\n-\t    *sam = special_array_member::trail_0;\n-\t  else\n-\t    {\n-\t      *sam = special_array_member::int_0;\n-\t      memsize = NULL_TREE;\n-\t    }\n+\t  case 3:\n+\t    /* Treaing 0-length trailing arrays as normal array.  */\n+\t    if (*sam == special_array_member::trail_0)\n+\t      return size_zero_node;\n+\t    /* FALLTHROUGH.  */\n+\t  case 2:\n+\t    /* Treating 1-element trailing arrays as normal array.  */\n+\t    if (*sam == special_array_member::trail_1)\n+\t      return memsize;\n+\t    /* FALLTHROUGH.  */\n+\t  case 1:\n+\t    /* Treating 2-or-more elements trailing arrays as normal\n+\t       array.  */\n+\t    if (*sam == special_array_member::trail_n)\n+\t      return memsize;\n+\t    /* FALLTHROUGH.  */\n+\t  case 0:\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n \t}\n \n-      if (!zero_length)\n-\tif (tree dom = TYPE_DOMAIN (memtype))\n-\t  if (tree min = TYPE_MIN_VALUE (dom))\n-\t    if (tree max = TYPE_MAX_VALUE (dom))\n-\t      if (TREE_CODE (min) == INTEGER_CST\n-\t\t  && TREE_CODE (max) == INTEGER_CST)\n-\t\t{\n-\t\t  offset_int minidx = wi::to_offset (min);\n-\t\t  offset_int maxidx = wi::to_offset (max);\n-\t\t  offset_int neltsm1 = maxidx - minidx;\n-\t\t  if (neltsm1 > 0)\n-\t\t    /* MEMBER is an array with more than one element.  */\n-\t\t    return memsize;\n-\n-\t\t  if (neltsm1 == 0)\n-\t\t    *sam = special_array_member::trail_1;\n-\t\t}\n+\tif (*sam == special_array_member::int_0)\n+\t  memsize = NULL_TREE;\n \n-      /* For a reference to a zero- or one-element array member of a union\n+      /* For a reference to a flexible array member of a union\n \t use the size of the union instead of the size of the member.  */\n       if (TREE_CODE (argtype) == UNION_TYPE)\n \tmemsize = TYPE_SIZE_UNIT (argtype);"}, {"sha": "23223ca0c87115d21f863f352f4a8ff85f426c16", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/710c9676520dfd38b4bfdcc937ce026ed89921d6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=710c9676520dfd38b4bfdcc937ce026ed89921d6", "patch": "@@ -5553,22 +5553,26 @@ extern tree array_ref_low_bound (tree);\n /* Returns true if REF is an array reference, a component reference,\n    or a memory reference to an array whose actual size might be larger\n    than its upper bound implies.  */\n-extern bool array_ref_flexible_size_p (tree);\n+extern bool array_ref_flexible_size_p (tree, bool * = NULL);\n \n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n extern tree component_ref_field_offset (tree);\n \n-/* Describes a \"special\" array member due to which component_ref_size\n-   returns null.  */\n+/* Describes a \"special\" array member for a COMPONENT_REF.  */\n enum struct special_array_member\n   {\n     none,\t/* Not a special array member.  */\n     int_0,\t/* Interior array member with size zero.  */\n     trail_0,\t/* Trailing array member with size zero.  */\n-    trail_1\t/* Trailing array member with one element.  */\n+    trail_1,\t/* Trailing array member with one element.  */\n+    trail_n,\t/* Trailing array member with two or more elements.  */\n+    int_n\t/* Interior array member with one or more elements.  */\n   };\n \n+/* Determines the special array member type for a COMPONENT_REF.  */\n+extern special_array_member component_ref_sam_type (tree);\n+\n /* Return the size of the member referenced by the COMPONENT_REF, using\n    its initializer expression if necessary in order to determine the size\n    of an initialized flexible array member.  The size might be zero for"}]}