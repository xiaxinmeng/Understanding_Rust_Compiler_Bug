{"sha": "7efc3f2d9ed7370243b867ab34038a239e6ead3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmYzNmMmQ5ZWQ3MzcwMjQzYjg2N2FiMzQwMzhhMjM5ZTZlYWQzZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T08:30:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T08:30:00Z"}, "message": "[multiple changes]\n\n2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_Composite_Equality): code cleanup: use component\n\ttype in all cases to compute list of primitive operations, because full\n\tview may be an itype that is not attached to the list of declarations.\n\n2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* bindgen.adb (Gen_Adafinal_Ada): Generate an early return if the\n\tlibrary has already been finalized.\n\t(Gen_Adafinal_C): Likewise.\n\t(Gen_Adainit_Ada): Generate an early return if the library has\n\talready been elaborated.\n\t(Gen_Adainit_C): Likewise.\n\t(Gen_Output_File_Ada): Generate an elaboration flag.\n\t(Gen_Output_File_C): Likewise.\n\nFrom-SVN: r177331", "tree": {"sha": "a2c116c1487a6eb6cc572281eef82b36744a9790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2c116c1487a6eb6cc572281eef82b36744a9790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7efc3f2d9ed7370243b867ab34038a239e6ead3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efc3f2d9ed7370243b867ab34038a239e6ead3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efc3f2d9ed7370243b867ab34038a239e6ead3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efc3f2d9ed7370243b867ab34038a239e6ead3d/comments", "author": null, "committer": null, "parents": [{"sha": "f65df6093be0c1a6a519122683ed0b305850203a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65df6093be0c1a6a519122683ed0b305850203a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65df6093be0c1a6a519122683ed0b305850203a"}], "stats": {"total": 140, "additions": 105, "deletions": 35}, "files": [{"sha": "2e2afc9ebfa29fa99f5c0f2dae271df2fd456b33", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7efc3f2d9ed7370243b867ab34038a239e6ead3d", "patch": "@@ -1,3 +1,20 @@\n+2011-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Composite_Equality): code cleanup: use component\n+\ttype in all cases to compute list of primitive operations, because full\n+\tview may be an itype that is not attached to the list of declarations.\n+\n+2011-08-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* bindgen.adb (Gen_Adafinal_Ada): Generate an early return if the\n+\tlibrary has already been finalized.\n+\t(Gen_Adafinal_C): Likewise.\n+\t(Gen_Adainit_Ada): Generate an early return if the library has\n+\talready been elaborated.\n+\t(Gen_Adainit_C): Likewise.\n+\t(Gen_Output_File_Ada): Generate an elaboration flag.\n+\t(Gen_Output_File_C): Likewise.\n+\n 2011-08-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch4.adb (Expand_Allocator_Expression): Disable the generation of"}, {"sha": "353e91da5845782c950d13b106d277481b731d13", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=7efc3f2d9ed7370243b867ab34038a239e6ead3d", "patch": "@@ -428,8 +428,20 @@ package body Bindgen is\n    begin\n       WBI (\"   procedure \" & Ada_Final_Name.all & \" is\");\n \n+      if Bind_Main_Program and then VM_Target = No_VM then\n+         WBI (\"      procedure s_stalib_adafinal;\");\n+         Set_String (\"      pragma Import (C, s_stalib_adafinal, \");\n+         Set_String (\"\"\"system__standard_library__adafinal\"\");\");\n+         Write_Statement_Buffer;\n+      end if;\n+\n+      WBI (\"   begin\");\n+      WBI (\"      if not Is_Elaborated then\");\n+      WBI (\"         return;\");\n+      WBI (\"      end if;\");\n+      WBI (\"      Is_Elaborated := False;\");\n+\n       if not Bind_Main_Program then\n-         WBI (\"   begin\");\n          if Lib_Final_Built then\n             WBI (\"      finalize_library;\");\n          else\n@@ -439,17 +451,12 @@ package body Bindgen is\n       --  Main program case\n \n       elsif VM_Target = No_VM then\n-         WBI (\"      procedure s_stalib_adafinal;\");\n-         WBI (\"      pragma Import (C, s_stalib_adafinal, \" &\n-              \"\"\"system__standard_library__adafinal\"\");\");\n-         WBI (\"   begin\");\n          WBI (\"      s_stalib_adafinal;\");\n \n       --  Pragma Import C cannot be used on virtual machine targets, therefore\n       --  call the runtime finalization routine directly.\n \n       else\n-         WBI (\"   begin\");\n          WBI (\"      System.Standard_Library.Adafinal;\");\n       end if;\n \n@@ -465,6 +472,10 @@ package body Bindgen is\n    begin\n       WBI (\"void \" & Ada_Final_Name.all & \" (void) {\");\n \n+      WBI (\"   if (!is_elaborated)\");\n+      WBI (\"      return;\");\n+      WBI (\"   is_elaborated = 0;\");\n+\n       if not Bind_Main_Program then\n          if Lib_Final_Built then\n             WBI (\"   finalize_library ();\");\n@@ -685,6 +696,11 @@ package body Bindgen is\n \n          WBI (\"   begin\");\n \n+         WBI (\"      if Is_Elaborated then\");\n+         WBI (\"         return;\");\n+         WBI (\"      end if;\");\n+         WBI (\"      Is_Elaborated := True;\");\n+\n          Set_String (\"      Main_Priority := \");\n          Set_Int    (Main_Priority);\n          Set_Char   (';');\n@@ -941,6 +957,10 @@ package body Bindgen is\n       WBI (\"void \" & Ada_Init_Name.all & \" (void)\");\n       WBI (\"{\");\n \n+      WBI (\"   if (is_elaborated)\");\n+      WBI (\"      return;\");\n+      WBI (\"   is_elaborated = 1;\");\n+\n       --  Standard library suppressed\n \n       if Suppress_Standard_Library_On_Target then\n@@ -3077,6 +3097,9 @@ package body Bindgen is\n          WBI (\"\");\n       end if;\n \n+      WBI (\"   Is_Elaborated : Boolean := False;\");\n+      WBI (\"\");\n+\n       --  Generate the adafinal routine unless there is no finalization to do\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n@@ -3300,6 +3323,9 @@ package body Bindgen is\n          WBI (\"\");\n       end if;\n \n+      WBI (\"static char is_elaborated = 0;\");\n+      WBI (\"\");\n+\n       --  Generate the adafinal routine unless there is no finalization to do\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then"}, {"sha": "506ec40a8a6b8e970883ea1301ab57e4769d59da", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efc3f2d9ed7370243b867ab34038a239e6ead3d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7efc3f2d9ed7370243b867ab34038a239e6ead3d", "patch": "@@ -2103,6 +2103,54 @@ package body Exp_Ch4 is\n       Prim      : Elmt_Id;\n       Eq_Op     : Entity_Id;\n \n+      function Find_Primitive_Eq return Node_Id;\n+      --  AI05-0123: Locate primitive equality for type if it exists, and\n+      --  build the corresponding call. If operation is abstract, replace\n+      --  call with an explicit raise. Return Empty if there is no primitive.\n+\n+      -----------------------\n+      -- Find_Primitive_Eq --\n+      -----------------------\n+\n+      function Find_Primitive_Eq return Node_Id is\n+         Prim_E : Elmt_Id;\n+         Prim   : Node_Id;\n+\n+      begin\n+         Prim_E := First_Elmt (Collect_Primitive_Operations (Typ));\n+         while Present (Prim_E) loop\n+            Prim := Node (Prim_E);\n+\n+            --  Locate primitive equality with the right signature\n+\n+            if Chars (Prim) = Name_Op_Eq\n+              and then Etype (First_Formal (Prim)) =\n+                         Etype (Next_Formal (First_Formal (Prim)))\n+              and then Etype (Prim) = Standard_Boolean\n+            then\n+               if Is_Abstract_Subprogram (Prim) then\n+                  return\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Explicit_Raise);\n+\n+               else\n+                  return\n+                    Make_Function_Call (Loc,\n+                      Name => New_Reference_To (Prim, Loc),\n+                      Parameter_Associations => New_List (Lhs, Rhs));\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Prim_E);\n+         end loop;\n+\n+         --  If not found, predefined operation will be used\n+\n+         return Empty;\n+      end Find_Primitive_Eq;\n+\n+   --  Start of processing for Expand_Composite_Equality\n+\n    begin\n       if Is_Private_Type (Typ) then\n          Full_Type := Underlying_Type (Typ);\n@@ -2324,43 +2372,22 @@ package body Exp_Ch4 is\n          elsif Ada_Version >= Ada_2012 then\n \n             --  if no TSS has been created for the type, check whether there is\n-            --  a primitive equality declared for it. If it is abstract replace\n-            --  the call with an explicit raise (AI05-0123).\n+            --  a primitive equality declared for it.\n \n             declare\n-               Prim : Elmt_Id;\n+               Ada_2012_Op : constant Node_Id := Find_Primitive_Eq;\n \n             begin\n-               Prim := First_Elmt (Collect_Primitive_Operations (Full_Type));\n-               while Present (Prim) loop\n+               if Present (Ada_2012_Op) then\n+                  return Ada_2012_Op;\n+               else\n \n-                  --  Locate primitive equality with the right signature\n+               --  Use predefined equality if no user-defined primitive exists\n \n-                  if Chars (Node (Prim)) = Name_Op_Eq\n-                    and then Etype (First_Formal (Node (Prim))) =\n-                               Etype (Next_Formal (First_Formal (Node (Prim))))\n-                    and then Etype (Node (Prim)) = Standard_Boolean\n-                  then\n-                     if Is_Abstract_Subprogram (Node (Prim)) then\n-                        return\n-                          Make_Raise_Program_Error (Loc,\n-                            Reason => PE_Explicit_Raise);\n-                     else\n-                        return\n-                          Make_Function_Call (Loc,\n-                            Name => New_Reference_To (Node (Prim), Loc),\n-                            Parameter_Associations => New_List (Lhs, Rhs));\n-                     end if;\n-                  end if;\n-\n-                  Next_Elmt (Prim);\n-               end loop;\n+                  return Make_Op_Eq (Loc, Lhs, Rhs);\n+               end if;\n             end;\n \n-            --  Use predefined equality iff no user-defined primitive exists\n-\n-            return Make_Op_Eq (Loc, Lhs, Rhs);\n-\n          else\n             return Expand_Record_Equality (Nod, Full_Type, Lhs, Rhs, Bodies);\n          end if;"}]}