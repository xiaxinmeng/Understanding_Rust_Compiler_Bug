{"sha": "3ae9def08565c36af2dc0bff495545ee1e9db642", "node_id": "C_kwDOANBUbNoAKDNhZTlkZWYwODU2NWMzNmFmMmRjMGJmZjQ5NTU0NWVlMWU5ZGI2NDI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-03T13:25:38Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-03T15:33:23Z"}, "message": "Move range allocator code to value-range-storage.*\n\nNow that vrange_storage is in its own file, I think it's prudent to\nmove all the vrange allocator code there since it's all related.\nThe users of value-range.h do not need to know the implementation\ndetails of the storage facilities.\n\nTested and benchmarked on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-cache.cc: Include value-range-storage.h.\n\t* gimple-range-cache.h (class block_range_cache): Add \"class\" to\n\tm_range_allocator.\n\t* gimple-range-edge.cc\n\t(gimple_outgoing_range::gimple_outgoing_range): Allocate allocator.\n\t(gimple_outgoing_range::~gimple_outgoing_range): Free allocator.\n\t(gimple_outgoing_range::calc_switch_ranges): Dereference allocator.\n\t* gimple-range-edge.h: Add \"class\" to m_range_allocator.\n\t* gimple-range-infer.cc\n\t(infer_range_manager::infer_range_manager): Allocate allocator.\n\t(infer_range_manager::~infer_range_manager): Free allocator.\n\t(infer_range_manager::get_nonzero): Dereference allocator.\n\t(infer_range_manager::add_range): Same.\n\t* gimple-range-infer.h (class vrange_allocator): Add \"class\" to\n\tm_range_allocator.\n\t* value-range-storage.h (class vrange_allocator): Move from\n\tvalue-range.h.\n\t(class obstack_vrange_allocator): Same.\n\t(class ggc_vrange_allocator): Same.\n\t(vrange_allocator::alloc_vrange): Same.\n\t(vrange_allocator::alloc_irange): Same.\n\t* value-range.h (class vrange_allocator): Move to value-range-storage.h.\n\t(class obstack_vrange_allocator): Same.\n\t(class ggc_vrange_allocator): Same.", "tree": {"sha": "2dc04b1d77cc6cf291fa183a0c6a74deea50708b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dc04b1d77cc6cf291fa183a0c6a74deea50708b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ae9def08565c36af2dc0bff495545ee1e9db642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae9def08565c36af2dc0bff495545ee1e9db642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ae9def08565c36af2dc0bff495545ee1e9db642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae9def08565c36af2dc0bff495545ee1e9db642/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17f2e2b77b6610afb8fafd41d0537d3e4429efe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f2e2b77b6610afb8fafd41d0537d3e4429efe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f2e2b77b6610afb8fafd41d0537d3e4429efe0"}], "stats": {"total": 245, "additions": 124, "deletions": 121}, "files": [{"sha": "9be8bc6123b65d72824b8dbc501b662c8203a8bd", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n+#include \"value-range-storage.h\"\n #include \"tree-cfg.h\"\n #include \"target.h\"\n #include \"attribs.h\""}, {"sha": "0341192c9cbdfd4d7bfce129dae52481499110d7", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -44,7 +44,7 @@ class block_range_cache\n   vec<class ssa_block_ranges *> m_ssa_ranges;\n   ssa_block_ranges &get_block_ranges (tree name);\n   ssa_block_ranges *query_block_ranges (tree name);\n-  vrange_allocator *m_range_allocator;\n+  class vrange_allocator *m_range_allocator;\n   bitmap_obstack m_bitmaps;\n };\n "}, {"sha": "194e8f87a4b840716f84c39fe4b8d4e57ad821e0", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"gimple-range.h\"\n+#include \"value-range-storage.h\"\n \n // If there is a range control statment at the end of block BB, return it.\n // Otherwise return NULL.\n@@ -68,13 +69,15 @@ gimple_outgoing_range::gimple_outgoing_range (int max_sw_edges)\n {\n   m_edge_table = NULL;\n   m_max_edges = max_sw_edges;\n+  m_range_allocator = new obstack_vrange_allocator;\n }\n \n \n gimple_outgoing_range::~gimple_outgoing_range ()\n {\n   if (m_edge_table)\n     delete m_edge_table;\n+  delete m_range_allocator;\n }\n \n \n@@ -162,13 +165,13 @@ gimple_outgoing_range::calc_switch_ranges (gswitch *sw)\n       // If there was an existing range and it doesn't fit, we lose the memory.\n       // It'll get reclaimed when the obstack is freed.  This seems less\n       // intrusive than allocating max ranges for each case.\n-      slot = m_range_allocator.clone <irange> (case_range);\n+      slot = m_range_allocator->clone <irange> (case_range);\n     }\n \n   irange *&slot = m_edge_table->get_or_insert (default_edge, &existed);\n   // This should be the first call into this switch.\n   gcc_checking_assert (!existed);\n-  irange *dr = m_range_allocator.clone <irange> (default_range);\n+  irange *dr = m_range_allocator->clone <irange> (default_range);\n   slot = dr;\n }\n "}, {"sha": "1a4dee9f41b322236254c3aed2ac5f45299d231d", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -47,7 +47,7 @@ class gimple_outgoing_range\n \n   int m_max_edges;\n   hash_map<edge, irange *> *m_edge_table;\n-  obstack_vrange_allocator m_range_allocator;\n+  class obstack_vrange_allocator *m_range_allocator;\n };\n \n // If there is a range control statement at the end of block BB, return it."}, {"sha": "2d12f86ce890e5349d3f93c3f42c85fdd633168d", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n+#include \"value-range-storage.h\"\n #include \"tree-cfg.h\"\n #include \"target.h\"\n #include \"attribs.h\"\n@@ -166,6 +167,7 @@ infer_range_manager::infer_range_manager (bool do_search)\n   // Non-zero elements are very common, so cache them for each ssa-name.\n   m_nonzero.create (0);\n   m_nonzero.safe_grow_cleared (num_ssa_names + 1);\n+  m_range_allocator = new obstack_vrange_allocator;\n }\n \n // Destruct a range infer manager.\n@@ -176,6 +178,7 @@ infer_range_manager::~infer_range_manager ()\n   obstack_free (&m_list_obstack, NULL);\n   m_on_exit.release ();\n   bitmap_obstack_release (&m_bitmaps);\n+  delete m_range_allocator;\n }\n \n // Return a non-zero range value of the appropriate type for NAME from\n@@ -189,7 +192,7 @@ infer_range_manager::get_nonzero (tree name)\n     m_nonzero.safe_grow_cleared (num_ssa_names + 20);\n   if (!m_nonzero[v])\n     {\n-      m_nonzero[v] = m_range_allocator.alloc_vrange (TREE_TYPE (name));\n+      m_nonzero[v] = m_range_allocator->alloc_vrange (TREE_TYPE (name));\n       m_nonzero[v]->set_nonzero (TREE_TYPE (name));\n     }\n   return *(m_nonzero[v]);\n@@ -261,15 +264,15 @@ infer_range_manager::add_range (tree name, basic_block bb, const vrange &r)\n       else\n \t{\n \t  vrange &v = cur;\n-\t  ptr->range = m_range_allocator.clone (v);\n+\t  ptr->range = m_range_allocator->clone (v);\n \t}\n       return;\n     }\n \n   // Otherwise create a record.\n   bitmap_set_bit (m_on_exit[bb->index].m_names, SSA_NAME_VERSION (name));\n   ptr = (exit_range *)obstack_alloc (&m_list_obstack, sizeof (exit_range));\n-  ptr->range = m_range_allocator.clone (r);\n+  ptr->range = m_range_allocator->clone (r);\n   ptr->name = name;\n   ptr->next = m_on_exit[bb->index].head;\n   m_on_exit[bb->index].head = ptr;"}, {"sha": "468b7d112868fbcf264cc502cc338bc5c80637e8", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -78,7 +78,7 @@ class infer_range_manager\n   bitmap m_seen;\n   bitmap_obstack m_bitmaps;\n   struct obstack m_list_obstack;\n-  obstack_vrange_allocator m_range_allocator;\n+  class obstack_vrange_allocator *m_range_allocator;\n };\n \n #endif // GCC_GIMPLE_RANGE_SIDE_H"}, {"sha": "7e005e4db5647bd9d9308a7f34ad1bfe2910b8ff", "filename": "gcc/value-range-storage.h", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fvalue-range-storage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fvalue-range-storage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.h?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -21,6 +21,27 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VALUE_RANGE_STORAGE_H\n #define GCC_VALUE_RANGE_STORAGE_H\n \n+// This class is used to allocate the minimum amount of storage needed\n+// for a given range.  Storage is automatically freed at destruction\n+// of the class.\n+\n+class vrange_allocator\n+{\n+public:\n+  vrange_allocator () { }\n+  virtual ~vrange_allocator () { }\n+  // Allocate a range of TYPE.\n+  vrange *alloc_vrange (tree type);\n+  // Allocate a memory block of BYTES.\n+  virtual void *alloc (unsigned bytes) = 0;\n+  virtual void free (void *p) = 0;\n+  // Return a clone of SRC.\n+  template <typename T> T *clone (const T &src);\n+private:\n+  irange *alloc_irange (unsigned pairs);\n+  void operator= (const vrange_allocator &) = delete;\n+};\n+\n // This class is used to allocate chunks of memory that can store\n // ranges as memory efficiently as possible.  It is meant to be used\n // when long term storage of a range is needed.  The class can be used\n@@ -40,10 +61,6 @@ class vrange_storage\n   vrange_allocator *m_alloc;\n };\n \n-\n-// INTERNAL USE ONLY.  The remaining interfaces are only exposed for\n-// the GTY machinery to play nice with tree_ssa_name.\n-\n // A chunk of memory pointing to an irange storage.\n \n class GTY ((variable_size)) irange_storage_slot\n@@ -82,4 +99,92 @@ class GTY ((variable_size)) irange_storage_slot\n   trailing_wide_ints<MAX_INTS> m_ints;\n };\n \n+class obstack_vrange_allocator : public vrange_allocator\n+{\n+public:\n+  obstack_vrange_allocator ()\n+  {\n+    obstack_init (&m_obstack);\n+  }\n+  virtual ~obstack_vrange_allocator () final override\n+  {\n+    obstack_free (&m_obstack, NULL);\n+  }\n+  virtual void *alloc (unsigned bytes) final override\n+  {\n+    return obstack_alloc (&m_obstack, bytes);\n+  }\n+  virtual void free (void *) final override { }\n+private:\n+  obstack m_obstack;\n+};\n+\n+class ggc_vrange_allocator : public vrange_allocator\n+{\n+public:\n+  ggc_vrange_allocator () { }\n+  virtual ~ggc_vrange_allocator () final override { }\n+  virtual void *alloc (unsigned bytes) final override\n+  {\n+    return ggc_internal_alloc (bytes);\n+  }\n+  virtual void free (void *p) final override\n+  {\n+    return ggc_free (p);\n+  }\n+};\n+\n+// Return a new range to hold ranges of TYPE.  The newly allocated\n+// range is initialized to VR_UNDEFINED.\n+\n+inline vrange *\n+vrange_allocator::alloc_vrange (tree type)\n+{\n+  if (irange::supports_p (type))\n+    return alloc_irange (2);\n+\n+  gcc_unreachable ();\n+}\n+\n+// Return a new range with NUM_PAIRS.\n+\n+inline irange *\n+vrange_allocator::alloc_irange (unsigned num_pairs)\n+{\n+  // Never allocate 0 pairs.\n+  // Don't allocate 1 either, or we get legacy value_range's.\n+  if (num_pairs < 2)\n+    num_pairs = 2;\n+\n+  size_t nbytes = sizeof (tree) * 2 * num_pairs;\n+\n+  // Allocate the irange and required memory for the vector.\n+  void *r = alloc (sizeof (irange));\n+  tree *mem = static_cast <tree *> (alloc (nbytes));\n+  return new (r) irange (mem, num_pairs);\n+}\n+\n+// Return a clone of an irange.\n+\n+template <>\n+inline irange *\n+vrange_allocator::clone <irange> (const irange &src)\n+{\n+  irange *r = alloc_irange (src.num_pairs ());\n+  *r = src;\n+  return r;\n+}\n+\n+// Return a clone of a vrange.\n+\n+template <>\n+inline vrange *\n+vrange_allocator::clone <vrange> (const vrange &src)\n+{\n+  if (is_a <irange> (src))\n+    return clone <irange> (as_a <irange> (src));\n+\n+  gcc_unreachable ();\n+}\n+\n #endif // GCC_VALUE_RANGE_STORAGE_H"}, {"sha": "8ee7793baeb9bd0a242d8885ddcf0986b38a8545", "filename": "gcc/value-range.h", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae9def08565c36af2dc0bff495545ee1e9db642/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=3ae9def08565c36af2dc0bff495545ee1e9db642", "patch": "@@ -896,113 +896,4 @@ vrp_val_min (const_tree type)\n   return NULL_TREE;\n }\n \n-// This is the range storage class.  It is used to allocate the\n-// minimum amount of storage needed for a given range.  Storage is\n-// automatically freed at destruction of the class.\n-\n-class vrange_allocator\n-{\n-public:\n-  vrange_allocator () { }\n-  virtual ~vrange_allocator () { }\n-  // Allocate a range of TYPE.\n-  vrange *alloc_vrange (tree type);\n-  // Allocate a memory block of BYTES.\n-  virtual void *alloc (unsigned bytes) = 0;\n-  virtual void free (void *p) = 0;\n-  // Return a clone of SRC.\n-  template <typename T> T *clone (const T &src);\n-private:\n-  irange *alloc_irange (unsigned pairs);\n-  void operator= (const vrange_allocator &) = delete;\n-};\n-\n-class obstack_vrange_allocator : public vrange_allocator\n-{\n-public:\n-  obstack_vrange_allocator ()\n-  {\n-    obstack_init (&m_obstack);\n-  }\n-  virtual ~obstack_vrange_allocator () final override\n-  {\n-    obstack_free (&m_obstack, NULL);\n-  }\n-  virtual void *alloc (unsigned bytes) final override\n-  {\n-    return obstack_alloc (&m_obstack, bytes);\n-  }\n-  virtual void free (void *) final override { }\n-private:\n-  obstack m_obstack;\n-};\n-\n-class ggc_vrange_allocator : public vrange_allocator\n-{\n-public:\n-  ggc_vrange_allocator () { }\n-  virtual ~ggc_vrange_allocator () final override { }\n-  virtual void *alloc (unsigned bytes) final override\n-  {\n-    return ggc_internal_alloc (bytes);\n-  }\n-  virtual void free (void *p) final override\n-  {\n-    return ggc_free (p);\n-  }\n-};\n-\n-// Return a new range to hold ranges of TYPE.  The newly allocated\n-// range is initialized to VR_UNDEFINED.\n-\n-inline vrange *\n-vrange_allocator::alloc_vrange (tree type)\n-{\n-  if (irange::supports_p (type))\n-    return alloc_irange (2);\n-\n-  gcc_unreachable ();\n-}\n-\n-// Return a new range with NUM_PAIRS.\n-\n-inline irange *\n-vrange_allocator::alloc_irange (unsigned num_pairs)\n-{\n-  // Never allocate 0 pairs.\n-  // Don't allocate 1 either, or we get legacy value_range's.\n-  if (num_pairs < 2)\n-    num_pairs = 2;\n-\n-  size_t nbytes = sizeof (tree) * 2 * num_pairs;\n-\n-  // Allocate the irange and required memory for the vector.\n-  void *r = alloc (sizeof (irange));\n-  tree *mem = static_cast <tree *> (alloc (nbytes));\n-  return new (r) irange (mem, num_pairs);\n-}\n-\n-// Return a clone of an irange.\n-\n-template <>\n-inline irange *\n-vrange_allocator::clone <irange> (const irange &src)\n-{\n-  irange *r = alloc_irange (src.num_pairs ());\n-  *r = src;\n-  return r;\n-}\n-\n-// Return a clone of a vrange.\n-\n-template <>\n-inline vrange *\n-vrange_allocator::clone <vrange> (const vrange &src)\n-{\n-  if (is_a <irange> (src))\n-    return clone <irange> (as_a <irange> (src));\n-\n-  gcc_unreachable ();\n-}\n-\n #endif // GCC_VALUE_RANGE_H"}]}