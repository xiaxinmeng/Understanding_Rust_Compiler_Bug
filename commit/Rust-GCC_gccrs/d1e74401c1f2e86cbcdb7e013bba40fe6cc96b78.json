{"sha": "d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlNzQ0MDFjMWYyZTg2Y2JjZGI3ZTAxM2JiYTQwZmU2Y2M5NmI3OA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2010-09-06T06:43:54Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-06T06:43:54Z"}, "message": "i386.md (iptrsize): New mode attribute.\n\n\t* config/i386/i386.md (iptrsize): New mode attribute.\n\t(tp_seg): Ditto.\n\t(*load_tp_<mode>): Macroize insn from *load_tp_{si,di} using P\n\tmode iterator.\n\t(*add_tp_<mode>): Ditto from *add_tp_{si,di}.\n\t(stack_protect_set_<mode>): Ditto from stack_protect_set_{si,di}.\n\t(stack_protect_test_<mode>): Ditto from stack_protect_test_{si,di}.\n\t(stack_tls_protect_set_<mode>): Ditto from\n\tstack_tls_protect_set_{si,di}.  Use %@ to output segment register\n\tof thread base pointer load.\n\t(stack_tls_protect_test_<mode>): Ditto from\n\tstack_tls_protect_test_{si,di}.  Use %@ to output segment register\n\tof thread base pointer load.\n\t(stack_protect_set): Rewrite using indirect functions.\n\t(stack_protect_test): Ditto.\n\t* config/i386/i386.c (ix86_print_operand_punct_valid): Add '@'.\n\t(ix86_print_operand): Handle '@'.\n\nFrom-SVN: r163900", "tree": {"sha": "f202f25b0e3e69cb976f9622a269ae05e3086577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f202f25b0e3e69cb976f9622a269ae05e3086577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "195a95c4300bd699e86aae541119b3b41b407e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195a95c4300bd699e86aae541119b3b41b407e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/195a95c4300bd699e86aae541119b3b41b407e38"}], "stats": {"total": 235, "additions": 100, "deletions": 135}, "files": [{"sha": "1b47551611e01e0bbc1f4b584f909a773b01fe5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "patch": "@@ -1,3 +1,23 @@\n+2010-09-06  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (iptrsize): New mode attribute.\n+\t(tp_seg): Ditto.\n+\t(*load_tp_<mode>): Macroize insn from *load_tp_{si,di} using P\n+\tmode iterator.\n+\t(*add_tp_<mode>): Ditto from *add_tp_{si,di}.\n+\t(stack_protect_set_<mode>): Ditto from stack_protect_set_{si,di}.\n+\t(stack_protect_test_<mode>): Ditto from stack_protect_test_{si,di}.\n+\t(stack_tls_protect_set_<mode>): Ditto from\n+\tstack_tls_protect_set_{si,di}.  Use %@ to output segment register\n+\tof thread base pointer load.\n+\t(stack_tls_protect_test_<mode>): Ditto from\n+\tstack_tls_protect_test_{si,di}.  Use %@ to output segment register\n+\tof thread base pointer load.\n+\t(stack_protect_set): Rewrite using indirect functions.\n+\t(stack_protect_test): Ditto.\n+\t* config/i386/i386.c (ix86_print_operand_punct_valid): Add '@'.\n+\t(ix86_print_operand): Handle '@'.\n+\n 2010-09-05  Giuseppe Scrivano  <gscrivano@gnu.org>\n \n \t* tree-tailcall.c (process_assignment): Handle NEGATE_EXPR and"}, {"sha": "fac660b632e8c657f0422e7c460d7c1dbd711954", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "patch": "@@ -12404,6 +12404,7 @@ get_some_local_dynamic_name (void)\n    Y -- print condition for XOP pcom* instruction.\n    + -- print a branch hint as 'cs' or 'ds' prefix\n    ; -- print a semicolon (after prefixes due to bug in older gas).\n+   @ -- print a segment register of thread base pointer load\n  */\n \n void\n@@ -12882,6 +12883,19 @@ ix86_print_operand (FILE *file, rtx x, int code)\n #endif\n \t  return;\n \n+\tcase '@':\n+\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n+\t    putc ('%', file);\n+\n+\t  /* The kernel uses a different segment register for performance\n+\t     reasons; a system call would not have to trash the userspace\n+\t     segment register, which would be expensive.  */\n+\t  if (TARGET_64BIT && ix86_cmodel != CM_KERNEL)\n+\t    fputs (\"fs\", file);\n+\t  else\n+\t    fputs (\"gs\", file);\n+\t  return;\n+\n \tdefault:\n \t    output_operand_lossage (\"invalid operand code '%c'\", code);\n \t}\n@@ -13012,7 +13026,8 @@ ix86_print_operand (FILE *file, rtx x, int code)\n static bool\n ix86_print_operand_punct_valid_p (unsigned char code)\n {\n-  return (code == '*' || code == '+' || code == '&' || code == ';');\n+  return (code == '@' || code == '*' || code == '+'\n+\t  || code == '&' || code == ';');\n }\n \f\n /* Print a memory operand whose address is ADDR.  */"}, {"sha": "9780eef90470bf811b2e05edc713f2aa50d92493", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 64, "deletions": 134, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d1e74401c1f2e86cbcdb7e013bba40fe6cc96b78", "patch": "@@ -59,6 +59,7 @@\n ;; Y -- print condition for XOP pcom* instruction.\n ;; + -- print a branch hint as 'cs' or 'ds' prefix\n ;; ; -- print a semicolon (after prefixes due to bug in older gas).\n+;; @ -- print a segment register of thread base pointer load\n \n ;; UNSPEC usage:\n \n@@ -821,6 +822,12 @@\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n+;; Pointer size prefix for integer modes (Intel asm dialect)\n+(define_mode_attr iptrsize [(QI \"BYTE\")\n+\t\t\t    (HI \"WORD\")\n+\t\t\t    (SI \"DWORD\")\n+\t\t\t    (DI \"QWORD\")])\n+\n ;; Register class for integer modes.\n (define_mode_attr r [(QI \"q\") (HI \"r\") (SI \"r\") (DI \"r\")])\n \n@@ -12042,50 +12049,28 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"\")\n \n-;; Load and add the thread base pointer from %gs:0.\n+;; Segment register for the thread base ptr load\n+(define_mode_attr tp_seg [(SI \"gs\") (DI \"fs\")])\n \n-(define_insn \"*load_tp_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(const_int 0)] UNSPEC_TP))]\n-  \"!TARGET_64BIT\"\n-  \"mov{l}\\t{%%gs:0, %0|%0, DWORD PTR gs:0}\"\n-  [(set_attr \"type\" \"imov\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"length\" \"7\")\n-   (set_attr \"memory\" \"load\")\n-   (set_attr \"imm_disp\" \"false\")])\n-\n-(define_insn \"*add_tp_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (unspec:SI [(const_int 0)] UNSPEC_TP)\n-\t\t (match_operand:SI 1 \"register_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n-  \"add{l}\\t{%%gs:0, %0|%0, DWORD PTR gs:0}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"length\" \"7\")\n-   (set_attr \"memory\" \"load\")\n-   (set_attr \"imm_disp\" \"false\")])\n-\n-(define_insn \"*load_tp_di\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(const_int 0)] UNSPEC_TP))]\n-  \"TARGET_64BIT\"\n-  \"mov{q}\\t{%%fs:0, %0|%0, QWORD PTR fs:0}\"\n+;; Load and add the thread base pointer from %gs:0.\n+(define_insn \"*load_tp_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(const_int 0)] UNSPEC_TP))]\n+  \"\"\n+  \"mov{<imodesuffix>}\\t{%%<tp_seg>:0, %0|%0, <iptrsize> PTR <tp_seg>:0}\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n    (set_attr \"memory\" \"load\")\n    (set_attr \"imm_disp\" \"false\")])\n \n-(define_insn \"*add_tp_di\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (unspec:DI [(const_int 0)] UNSPEC_TP)\n-\t\t (match_operand:DI 1 \"register_operand\" \"0\")))\n+(define_insn \"*add_tp_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(plus:P (unspec:P [(const_int 0)] UNSPEC_TP)\n+\t\t(match_operand:P 1 \"register_operand\" \"0\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"add{q}\\t{%%fs:0, %0|%0, QWORD PTR fs:0}\"\n+  \"\"\n+  \"add{<imodesuffix>}\\t{%%<tp_seg>:0, %0|%0, <iptrsize> PTR <tp_seg>:0}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"0\")\n    (set_attr \"length\" \"7\")\n@@ -12219,8 +12204,6 @@\n   operands[4] = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : operands[0];\n   emit_insn (gen_tls_dynamic_gnu2_64 (operands[4], operands[1]));\n })\n-\n-;;\n \f\n ;; These patterns match the binary 387 instructions for addM3, subM3,\n ;; mulM3 and divM3.  There are three patterns for each of DFmode and\n@@ -17344,66 +17327,40 @@\n    (match_operand 1 \"memory_operand\" \"\")]\n   \"\"\n {\n+  rtx (*insn)(rtx, rtx);\n+\n #ifdef TARGET_THREAD_SSP_OFFSET\n-  if (TARGET_64BIT)\n-    emit_insn (gen_stack_tls_protect_set_di (operands[0],\n-\t\t\t\t\tGEN_INT (TARGET_THREAD_SSP_OFFSET)));\n-  else\n-    emit_insn (gen_stack_tls_protect_set_si (operands[0],\n-\t\t\t\t\tGEN_INT (TARGET_THREAD_SSP_OFFSET)));\n+  operands[1] = GEN_INT (TARGET_THREAD_SSP_OFFSET);\n+  insn = (TARGET_64BIT\n+\t  ? gen_stack_tls_protect_set_di\n+\t  : gen_stack_tls_protect_set_si);\n #else\n-  if (TARGET_64BIT)\n-    emit_insn (gen_stack_protect_set_di (operands[0], operands[1]));\n-  else\n-    emit_insn (gen_stack_protect_set_si (operands[0], operands[1]));\n+  insn = (TARGET_64BIT\n+\t  ? gen_stack_protect_set_di\n+\t  : gen_stack_protect_set_si);\n #endif\n+\n+  emit_insn (insn (operands[0], operands[1]));\n   DONE;\n })\n \n-(define_insn \"stack_protect_set_si\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n-   (set (match_scratch:SI 2 \"=&r\") (const_int 0))\n+(define_insn \"stack_protect_set_<mode>\"\n+  [(set (match_operand:P 0 \"memory_operand\" \"=m\")\n+\t(unspec:P [(match_operand:P 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+   (set (match_scratch:P 2 \"=&r\") (const_int 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"mov{l}\\t{%1, %2|%2, %1}\\;mov{l}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"stack_protect_set_di\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n-   (set (match_scratch:DI 2 \"=&r\") (const_int 0))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  \"mov{q}\\t{%1, %2|%2, %1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\"\n+  \"mov{<imodesuffix>}\\t{%1, %2|%2, %1}\\;mov{<imodesuffix>}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn \"stack_tls_protect_set_si\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(unspec:SI [(match_operand:SI 1 \"const_int_operand\" \"i\")]\n-\t\t   UNSPEC_SP_TLS_SET))\n-   (set (match_scratch:SI 2 \"=&r\") (const_int 0))\n+(define_insn \"stack_tls_protect_set_<mode>\"\n+  [(set (match_operand:P 0 \"memory_operand\" \"=m\")\n+\t(unspec:P [(match_operand:P 1 \"const_int_operand\" \"i\")]\n+\t\t  UNSPEC_SP_TLS_SET))\n+   (set (match_scratch:P 2 \"=&r\") (const_int 0))\n    (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"mov{l}\\t{%%gs:%P1, %2|%2, DWORD PTR gs:%P1}\\;mov{l}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"stack_tls_protect_set_di\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(unspec:DI [(match_operand:DI 1 \"const_int_operand\" \"i\")]\n-\t\t   UNSPEC_SP_TLS_SET))\n-   (set (match_scratch:DI 2 \"=&r\") (const_int 0))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  {\n-     /* The kernel uses a different segment register for performance reasons; a\n-        system call would not have to trash the userspace segment register,\n-        which would be expensive */\n-     if (ix86_cmodel != CM_KERNEL)\n-        return \"mov{q}\\t{%%fs:%P1, %2|%2, QWORD PTR fs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n-     else\n-        return \"mov{q}\\t{%%gs:%P1, %2|%2, QWORD PTR gs:%P1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\";\n-  }\n+  \"mov{<imodesuffix>}\\t{%@:%P1, %2|%2, <iptrsize> PTR %@:%P1}\\;mov{<imodesuffix>}\\t{%2, %0|%0, %2}\\;xor{l}\\t%k2, %k2\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_expand \"stack_protect_test\"\n@@ -17414,71 +17371,44 @@\n {\n   rtx flags = gen_rtx_REG (CCZmode, FLAGS_REG);\n \n+  rtx (*insn)(rtx, rtx, rtx);\n+\n #ifdef TARGET_THREAD_SSP_OFFSET\n-  if (TARGET_64BIT)\n-    emit_insn (gen_stack_tls_protect_test_di (flags, operands[0],\n-\t\t\t\t\tGEN_INT (TARGET_THREAD_SSP_OFFSET)));\n-  else\n-    emit_insn (gen_stack_tls_protect_test_si (flags, operands[0],\n-\t\t\t\t\tGEN_INT (TARGET_THREAD_SSP_OFFSET)));\n+  operands[1] = GEN_INT (TARGET_THREAD_SSP_OFFSET);\n+  insn = (TARGET_64BIT\n+\t  ? gen_stack_tls_protect_test_di\n+\t  : gen_stack_tls_protect_test_si);\n #else\n-  if (TARGET_64BIT)\n-    emit_insn (gen_stack_protect_test_di (flags, operands[0], operands[1]));\n-  else\n-    emit_insn (gen_stack_protect_test_si (flags, operands[0], operands[1]));\n+  insn = (TARGET_64BIT\n+\t  ? gen_stack_protect_test_di\n+\t  : gen_stack_protect_test_si);\n #endif\n \n+  emit_insn (insn (flags, operands[0], operands[1]));\n+\n   emit_jump_insn (gen_cbranchcc4 (gen_rtx_EQ (VOIDmode, flags, const0_rtx),\n \t\t\t\t  flags, const0_rtx, operands[2]));\n   DONE;\n })\n \n-(define_insn \"stack_protect_test_si\"\n+(define_insn \"stack_protect_test_<mode>\"\n   [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n-\t(unspec:CCZ [(match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:SI 2 \"memory_operand\" \"m\")]\n+\t(unspec:CCZ [(match_operand:P 1 \"memory_operand\" \"m\")\n+\t\t     (match_operand:P 2 \"memory_operand\" \"m\")]\n \t\t    UNSPEC_SP_TEST))\n-   (clobber (match_scratch:SI 3 \"=&r\"))]\n+   (clobber (match_scratch:P 3 \"=&r\"))]\n   \"\"\n-  \"mov{l}\\t{%1, %3|%3, %1}\\;xor{l}\\t{%2, %3|%3, %2}\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"stack_protect_test_di\"\n-  [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n-\t(unspec:CCZ [(match_operand:DI 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:DI 2 \"memory_operand\" \"m\")]\n-\t\t    UNSPEC_SP_TEST))\n-   (clobber (match_scratch:DI 3 \"=&r\"))]\n-  \"TARGET_64BIT\"\n-  \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%2, %3|%3, %2}\"\n+  \"mov{<imodesuffix>}\\t{%1, %3|%3, %1}\\;xor{<imodesuffix>}\\t{%2, %3|%3, %2}\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn \"stack_tls_protect_test_si\"\n+(define_insn \"stack_tls_protect_test_<mode>\"\n   [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n-\t(unspec:CCZ [(match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"i\")]\n+\t(unspec:CCZ [(match_operand:P 1 \"memory_operand\" \"m\")\n+\t\t     (match_operand:P 2 \"const_int_operand\" \"i\")]\n \t\t    UNSPEC_SP_TLS_TEST))\n-   (clobber (match_scratch:SI 3 \"=r\"))]\n+   (clobber (match_scratch:P 3 \"=r\"))]\n   \"\"\n-  \"mov{l}\\t{%1, %3|%3, %1}\\;xor{l}\\t{%%gs:%P2, %3|%3, DWORD PTR gs:%P2}\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"stack_tls_protect_test_di\"\n-  [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n-\t(unspec:CCZ [(match_operand:DI 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:DI 2 \"const_int_operand\" \"i\")]\n-\t\t    UNSPEC_SP_TLS_TEST))\n-   (clobber (match_scratch:DI 3 \"=r\"))]\n-  \"TARGET_64BIT\"\n-  {\n-     /* The kernel uses a different segment register for performance reasons; a\n-        system call would not have to trash the userspace segment register,\n-        which would be expensive */\n-     if (ix86_cmodel != CM_KERNEL)\n-        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%fs:%P2, %3|%3, QWORD PTR fs:%P2}\";\n-     else\n-        return \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%%gs:%P2, %3|%3, QWORD PTR gs:%P2}\";\n-  }\n+  \"mov{<imodesuffix>}\\t{%1, %3|%3, %1}\\;xor{<imodesuffix>}\\t{%@:%P2, %3|%3, <iptrsize> PTR %@:%P2}\"\n   [(set_attr \"type\" \"multi\")])\n \n (define_insn \"sse4_2_crc32<mode>\""}]}