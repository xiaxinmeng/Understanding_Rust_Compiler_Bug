{"sha": "270a1283e6ce05c38474011515817f7816c8adb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwYTEyODNlNmNlMDVjMzg0NzQwMTE1MTU4MTdmNzgxNmM4YWRiNw==", "commit": {"author": {"name": "David Ayers", "email": "d.ayers@inode.at", "date": "2005-03-02T19:37:03Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2005-03-02T19:37:03Z"}, "message": "re PR libobjc/19024 (name collisions libobjc/libmysqlclient)\n\n2005-03-02  David Ayers  <d.ayers@inode.at>\n\n        PR libobjc/19024\n        * Makefile.in (OBJS): Add hash_compat.lo.\n        (OBJS_GC): Add hash_compat_gc.lo.\n        (hash_compat_gc.lo): New target and rule.\n        * objc/hash.h (hash_new, hash_delete, hash_add, hash_remove)\n        (hash_next, hash_value_for_key, hash_is_key_in_hash)\n        (hash_ptr, hash_string, compare_ptrs, compare_strings): Prefix\n        with objc_.  Add deprecated non prefixed inlined versions.\n        (OBJC_IGNORE_DEPRECATED_API): New macro to hide deprecated\n        declarations.\n        * hash.c (hash_new, hash_delete, hash_add, hash_remove, hash_next)\n        (hash_value_for_key, hash_is_key_in_hash): Prefix with objc_ and\n        update callers.\n        * hash_compat.c: New file.\n        * archive.c: Update callers.\n        * init.c: Likewise.\n        * selector.c: Likewise.\n        * libobjc.def: Add objc_ versions of hash functions.\n\nFrom-SVN: r95793", "tree": {"sha": "f8c018cf0dc8e69a8a6c34bca7dd95174ee9c3ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8c018cf0dc8e69a8a6c34bca7dd95174ee9c3ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/270a1283e6ce05c38474011515817f7816c8adb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/270a1283e6ce05c38474011515817f7816c8adb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/270a1283e6ce05c38474011515817f7816c8adb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/270a1283e6ce05c38474011515817f7816c8adb7/comments", "author": null, "committer": null, "parents": [{"sha": "13396b14c0ef1eceba7f6e40b947d99b6cdbe387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13396b14c0ef1eceba7f6e40b947d99b6cdbe387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13396b14c0ef1eceba7f6e40b947d99b6cdbe387"}], "stats": {"total": 458, "additions": 351, "deletions": 107}, "files": [{"sha": "e9da0f5cc1deadf5720e14ba3a9c942a406fcde5", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -1,3 +1,24 @@\n+2005-03-02  David Ayers  <d.ayers@inode.at>\n+\n+\tPR libobjc/19024\n+\t* Makefile.in (OBJS): Add hash_compat.lo.\n+\t(OBJS_GC): Add hash_compat_gc.lo.\n+\t(hash_compat_gc.lo): New target and rule.\n+\t* objc/hash.h (hash_new, hash_delete, hash_add, hash_remove)\n+\t(hash_next, hash_value_for_key, hash_is_key_in_hash)\n+\t(hash_ptr, hash_string, compare_ptrs, compare_strings): Prefix\n+\twith objc_.  Add deprecated non prefixed inlined versions.\n+\t(OBJC_IGNORE_DEPRECATED_API): New macro to hide deprecated\n+\tdeclarations.\n+\t* hash.c (hash_new, hash_delete, hash_add, hash_remove, hash_next)\n+\t(hash_value_for_key, hash_is_key_in_hash): Prefix with objc_ and\n+\tupdate callers.\n+\t* hash_compat.c: New file.\n+\t* archive.c: Update callers.\n+\t* init.c: Likewise.\n+\t* selector.c: Likewise.\n+\t* libobjc.def: Add objc_ versions of hash functions.\n+\n 2005-02-28  Andrew Pinski <pinskia@physics.uc.edu>\n \n \tPR libobjc/20252"}, {"sha": "32901679b955c9663dd4591470185e9ab08a1df9", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -146,13 +146,13 @@ OBJC_H = hash.h objc-list.h sarray.h objc.h objc-api.h \\\n OBJS =    archive.lo class.lo encoding.lo gc.lo hash.lo init.lo linking.lo \\\n \t  misc.lo nil_method.lo NXConstStr.lo Object.lo objects.lo \\\n \t  Protocol.lo sarray.lo selector.lo sendmsg.lo thr.lo \\\n-\t  $(OBJC_THREAD_FILE).lo exception.lo\n+\t  $(OBJC_THREAD_FILE).lo exception.lo hash_compat.lo\n \n OBJS_GC = archive_gc.lo class_gc.lo encoding_gc.lo gc_gc.lo hash_gc.lo \\\n \t  init_gc.lo linking_gc.lo misc_gc.lo nil_method_gc.lo \\\n \t  NXConstStr_gc.lo Object_gc.lo objects_gc.lo Protocol_gc.lo \\\n \t  sarray_gc.lo selector_gc.lo sendmsg_gc.lo thr_gc.lo \\\n-\t  $(OBJC_THREAD_FILE)_gc.lo exception_gc.lo\n+\t  $(OBJC_THREAD_FILE)_gc.lo exception_gc.lo hash_compat_gc.lo\n \n runtime-info.h: \n \techo \"\" > tmp-runtime.m\n@@ -183,6 +183,10 @@ hash_gc.lo: hash.c\n \t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n \t\t$(INCLUDES) $<\n \n+hash_compat_gc.lo: hash_compat.c\n+\t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n+\t\t$(INCLUDES) $<\n+\n init_gc.lo: init.c\n \t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n \t\t$(INCLUDES) $<"}, {"sha": "5c3616ca329fb5a6c2a189e65c8e1da5e1ff666b", "filename": "libobjc/archive.c", "status": "modified", "additions": 73, "deletions": 62, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Farchive.c?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -301,12 +301,13 @@ objc_write_string_atomic (struct objc_typed_stream *stream,\n \t\t\t  unsigned char *string, unsigned int nbytes)\n {\n   unsigned long key;\n-  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, string))))\n+  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table, string))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(string)), string);\n+      objc_hash_add (&stream->stream_table,\n+\t\t     LONG2PTR(key=PTR2LONG(string)), string);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn objc_write_string (stream, string, nbytes);\n       return length;\n@@ -386,7 +387,7 @@ int\n objc_write_object_reference (struct objc_typed_stream *stream, id object)\n {\n   unsigned long key;\n-  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n+  if ((key = PTR2LONG(objc_hash_value_for_key (stream->object_table, object))))\n     return objc_write_use_common (stream, key);\n \n   __objc_write_extension (stream, _BX_OBJREF);\n@@ -415,7 +416,7 @@ int\n objc_write_object (struct objc_typed_stream *stream, id object)\n {\n   unsigned long key;\n-  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n+  if ((key = PTR2LONG(objc_hash_value_for_key (stream->object_table, object))))\n     return objc_write_use_common (stream, key);\n \n   else if (object == nil)\n@@ -424,7 +425,8 @@ objc_write_object (struct objc_typed_stream *stream, id object)\n   else\n     {\n       int length;\n-      hash_add (&stream->object_table, LONG2PTR(key=PTR2LONG(object)), object);\n+      objc_hash_add (&stream->object_table,\n+\t\t     LONG2PTR(key=PTR2LONG(object)), object);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_object (stream, object);\n       return length;\n@@ -446,12 +448,13 @@ objc_write_class (struct objc_typed_stream *stream,\n \t\t\t struct objc_class *class)\n {\n   unsigned long key;\n-  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, class))))\n+  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table, class))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, LONG2PTR(key = PTR2LONG(class)), class);\n+      objc_hash_add (&stream->stream_table,\n+\t\t     LONG2PTR(key = PTR2LONG(class)), class);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_class (stream, class);\n       return length;\n@@ -482,12 +485,13 @@ objc_write_selector (struct objc_typed_stream *stream, SEL selector)\n     return __objc_write_selector (stream, selector);\n \n   sel_name = sel_get_name (selector);\n-  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, sel_name))))\n+  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table,\n+\t\t\t\t\t       sel_name))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, \n+      objc_hash_add (&stream->stream_table, \n \t\tLONG2PTR(key = PTR2LONG(sel_name)), (char *) sel_name);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_selector (stream, selector);\n@@ -755,7 +759,7 @@ objc_read_string (struct objc_typed_stream *stream,\n \t  int length = buf[0]&_B_VALUE;\n \t  (*string) = (char*)objc_malloc (length + 1);\n \t  if (key)\n-\t    hash_add (&stream->stream_table, LONG2PTR(key), *string);\n+\t    objc_hash_add (&stream->stream_table, LONG2PTR(key), *string);\n \t  len = (*stream->read) (stream->physical, *string, length);\n \t  (*string)[length] = '\\0';\n \t}\n@@ -765,7 +769,7 @@ objc_read_string (struct objc_typed_stream *stream,\n \t{\n \t  char *tmp;\n \t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  tmp = hash_value_for_key (stream->stream_table, LONG2PTR (key));\n+\t  tmp = objc_hash_value_for_key (stream->stream_table, LONG2PTR (key));\n \t  *string = objc_malloc (strlen (tmp) + 1);\n \t  strcpy (*string, tmp);\n \t}\n@@ -778,7 +782,7 @@ objc_read_string (struct objc_typed_stream *stream,\n \t  if (len) {\n \t    (*string) = (char*)objc_malloc (nbytes + 1);\n \t    if (key)\n-\t      hash_add (&stream->stream_table, LONG2PTR(key), *string);\n+\t      objc_hash_add (&stream->stream_table, LONG2PTR(key), *string);\n \t    len = (*stream->read) (stream->physical, *string, nbytes);\n \t    (*string)[nbytes] = '\\0';\n \t  }\n@@ -823,7 +827,7 @@ objc_read_object (struct objc_typed_stream *stream, id *object)\n \n \t  /* register? */\n \t  if (key)\n-\t    hash_add (&stream->object_table, LONG2PTR(key), *object);\n+\t    objc_hash_add (&stream->object_table, LONG2PTR(key), *object);\n \n \t  /* send -read: */\n \t  if (__objc_responds_to (*object, read_sel))\n@@ -841,17 +845,19 @@ objc_read_object (struct objc_typed_stream *stream, id *object)\n \t  if (key)\n \t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  (*object) = hash_value_for_key (stream->object_table, LONG2PTR(key));\n+\t  (*object) = objc_hash_value_for_key (stream->object_table,\n+\t\t\t\t\t       LONG2PTR(key));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n \t{\n \t  struct objc_list *other;\n \t  len = objc_read_unsigned_long (stream, &key);\n-\t  other = (struct objc_list *) hash_value_for_key (stream->object_refs, \n+\t  other \n+\t    = (struct objc_list *) objc_hash_value_for_key (stream->object_refs, \n \t\t\t\t\t\t\t   LONG2PTR(key));\n-\t  hash_add (&stream->object_refs, LONG2PTR(key), \n-\t\t    (void *)list_cons (object, other));\n+\t  objc_hash_add (&stream->object_refs, LONG2PTR(key), \n+\t\t\t (void *)list_cons (object, other));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n@@ -898,18 +904,20 @@ objc_read_class (struct objc_typed_stream *stream, Class *class)\n \n \t  /* register */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, LONG2PTR(key), *class);\n+\t    objc_hash_add (&stream->stream_table, LONG2PTR(key), *class);\n \n \t  objc_read_unsigned_long (stream, &version);\n-\t  hash_add (&stream->class_table, (*class)->name, (void *)version);\n+\t  objc_hash_add (&stream->class_table,\n+\t\t\t (*class)->name, (void *)version);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n \t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  *class = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n+\t  *class = objc_hash_value_for_key (stream->stream_table,\n+\t\t\t\t\t    LONG2PTR(key));\n \t  if (! *class)\n \t    objc_error (nil, OBJC_ERR_BAD_CLASS,\n \t\t        \"cannot find class for key %lu\", key);\n@@ -956,16 +964,17 @@ objc_read_selector (struct objc_typed_stream *stream, SEL* selector)\n \n \t  /* register */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, LONG2PTR(key), (void *) *selector);\n+\t    objc_hash_add (&stream->stream_table,\n+\t\t\t   LONG2PTR(key), (void *) *selector);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n \t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  (*selector) = hash_value_for_key (stream->stream_table, \n-\t\t\t\t\t    LONG2PTR(key));\n+\t  (*selector) = objc_hash_value_for_key (stream->stream_table, \n+\t\t\t\t\t\t LONG2PTR(key));\n \t}\n \n       else\n@@ -1475,54 +1484,54 @@ __objc_write_typed_stream_signature (TypedStream *stream)\n \n static void __objc_finish_write_root_object(struct objc_typed_stream *stream)\n {\n-  hash_delete (stream->object_table);\n-  stream->object_table = hash_new(64,\n-\t\t\t\t  (hash_func_type)hash_ptr,\n-\t\t\t\t  (compare_func_type)compare_ptrs);\n+  objc_hash_delete (stream->object_table);\n+  stream->object_table = objc_hash_new (64,\n+\t\t\t\t\t(hash_func_type) objc_hash_ptr,\n+\t\t\t\t\t(compare_func_type) objc_compare_ptrs);\n }\n \n static void __objc_finish_read_root_object(struct objc_typed_stream *stream)\n {\n   node_ptr node;\n   SEL awake_sel = sel_get_any_uid (\"awake\");\n-  cache_ptr free_list = hash_new (64,\n-\t\t\t\t  (hash_func_type) hash_ptr,\n-\t\t\t\t  (compare_func_type) compare_ptrs);\n+  cache_ptr free_list = objc_hash_new (64,\n+\t\t\t\t       (hash_func_type) objc_hash_ptr,\n+\t\t\t\t       (compare_func_type) objc_compare_ptrs);\n \n   /* resolve object forward references */\n-  for (node = hash_next (stream->object_refs, NULL); node;\n-       node = hash_next (stream->object_refs, node))\n+  for (node = objc_hash_next (stream->object_refs, NULL); node;\n+       node = objc_hash_next (stream->object_refs, node))\n     {\n       struct objc_list *reflist = node->value;\n       const void *key = node->key;\n-      id object = hash_value_for_key (stream->object_table, key);\n+      id object = objc_hash_value_for_key (stream->object_table, key);\n       while (reflist)\n \t{\n \t  *((id*) reflist->head) = object;\n-\t  if (hash_value_for_key (free_list,reflist) == NULL)\n-\t    hash_add (&free_list,reflist,reflist);\n+\t  if (objc_hash_value_for_key (free_list,reflist) == NULL)\n+\t    objc_hash_add (&free_list,reflist,reflist);\n \n \t  reflist = reflist->tail;\n \t}\n     }\n     \n   /* apply __objc_free to all objects stored in free_list */\n-  for (node = hash_next (free_list, NULL); node;\n-       node = hash_next (free_list, node))\n+  for (node = objc_hash_next (free_list, NULL); node;\n+       node = objc_hash_next (free_list, node))\n     objc_free ((void *) node->key);\n \n-  hash_delete (free_list);\n+  objc_hash_delete (free_list);\n \n   /* empty object reference table */\n-  hash_delete (stream->object_refs);\n-  stream->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n-\t\t\t\t (compare_func_type)compare_ptrs);\n+  objc_hash_delete (stream->object_refs);\n+  stream->object_refs = objc_hash_new (8, (hash_func_type) objc_hash_ptr,\n+\t\t\t\t       (compare_func_type) objc_compare_ptrs);\n   \n   /* call -awake for all objects read  */\n   if (awake_sel)\n     {\n-      for (node = hash_next (stream->object_table, NULL); node;\n-\t   node = hash_next (stream->object_table, node))\n+      for (node = objc_hash_next (stream->object_table, NULL); node;\n+\t   node = objc_hash_next (stream->object_table, node))\n \t{\n \t  id object = node->value;\n \t  if (__objc_responds_to (object, awake_sel))\n@@ -1531,10 +1540,10 @@ static void __objc_finish_read_root_object(struct objc_typed_stream *stream)\n     }\n \n   /* empty object table */\n-  hash_delete (stream->object_table);\n-  stream->object_table = hash_new(64,\n-\t\t\t\t  (hash_func_type)hash_ptr,\n-\t\t\t\t  (compare_func_type)compare_ptrs);\n+  objc_hash_delete (stream->object_table);\n+  stream->object_table = objc_hash_new(64,\n+\t\t\t\t       (hash_func_type)objc_hash_ptr,\n+\t\t\t\t       (compare_func_type)objc_compare_ptrs);\n }\n \n /*\n@@ -1548,21 +1557,22 @@ objc_open_typed_stream (FILE *physical, int mode)\n \n   s->mode = mode;\n   s->physical = physical;\n-  s->stream_table = hash_new (64,\n-\t\t\t      (hash_func_type) hash_ptr,\n-\t\t\t      (compare_func_type) compare_ptrs);\n-  s->object_table = hash_new (64,\n-\t\t\t      (hash_func_type) hash_ptr,\n-\t\t\t      (compare_func_type) compare_ptrs);\n+  s->stream_table = objc_hash_new (64,\n+\t\t\t\t   (hash_func_type) objc_hash_ptr,\n+\t\t\t\t   (compare_func_type) objc_compare_ptrs);\n+  s->object_table = objc_hash_new (64,\n+\t\t\t\t   (hash_func_type) objc_hash_ptr,\n+\t\t\t\t   (compare_func_type) objc_compare_ptrs);\n   s->eof = (objc_typed_eof_func) __objc_feof;\n   s->flush = (objc_typed_flush_func) fflush;\n   s->writing_root_p = 0;\n   if (mode == OBJC_READONLY)\n     {\n-      s->class_table = hash_new (8, (hash_func_type) hash_string,\n-\t\t\t\t (compare_func_type) compare_strings);\n-      s->object_refs = hash_new (8, (hash_func_type) hash_ptr,\n-\t\t\t\t (compare_func_type) compare_ptrs);\n+      s->class_table \n+\t= objc_hash_new (8, (hash_func_type) objc_hash_string,\n+\t\t\t (compare_func_type) objc_compare_strings);\n+      s->object_refs = objc_hash_new (8, (hash_func_type) objc_hash_ptr,\n+\t\t\t\t      (compare_func_type) objc_compare_ptrs);\n       s->read = (objc_typed_read_func) __objc_fread;\n       s->write = (objc_typed_write_func) __objc_no_write;\n       __objc_read_typed_stream_signature (s);\n@@ -1621,12 +1631,12 @@ objc_close_typed_stream (TypedStream *stream)\n   if (stream->mode == OBJC_READONLY)\n     {\n       __objc_finish_read_root_object (stream); /* Just in case... */\n-      hash_delete (stream->class_table);\n-      hash_delete (stream->object_refs);\n+      objc_hash_delete (stream->class_table);\n+      objc_hash_delete (stream->object_refs);\n     }\n \n-  hash_delete (stream->stream_table);\n-  hash_delete (stream->object_table);\n+  objc_hash_delete (stream->stream_table);\n+  objc_hash_delete (stream->object_table);\n \n   if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n     fclose ((FILE *)stream->physical);\n@@ -1650,7 +1660,8 @@ long\n objc_get_stream_class_version (TypedStream *stream, Class class)\n {\n   if (stream->class_table)\n-    return PTR2LONG(hash_value_for_key (stream->class_table, class->name));\n+    return PTR2LONG(objc_hash_value_for_key (stream->class_table,\n+\t\t\t\t\t     class->name));\n   else\n     return class_get_version (class);\n }"}, {"sha": "e2072b605f78aad30ddf4eb71678f17ea40a0dc6", "filename": "libobjc/hash.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash.c?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -40,8 +40,8 @@ Boston, MA 02111-1307, USA.  */\n   ((cache)->size * 2)\n \n cache_ptr\n-hash_new (unsigned int size, hash_func_type hash_func,\n-\t  compare_func_type compare_func)\n+objc_hash_new (unsigned int size, hash_func_type hash_func,\n+\t       compare_func_type compare_func)\n {\n   cache_ptr cache;\n \n@@ -77,25 +77,25 @@ hash_new (unsigned int size, hash_func_type hash_func,\n \n \n void\n-hash_delete (cache_ptr cache)\n+objc_hash_delete (cache_ptr cache)\n {\n   node_ptr node;\n   node_ptr next_node;\n   unsigned int i;\n \n   /* Purge all key/value pairs from the table.  */\n   /* Step through the nodes one by one and remove every node WITHOUT\n-     using hash_next. this makes hash_delete much more efficient. */\n+     using objc_hash_next. this makes objc_hash_delete much more efficient. */\n   for (i = 0;i < cache->size;i++) {\n     if ((node = cache->node_table[i])) {\n       /* an entry in the hash table has been found, now step through the\n \t nodes next in the list and free them. */\n       while ((next_node = node->next)) {\n-\thash_remove (cache,node->key);\n+\tobjc_hash_remove (cache,node->key);\n \tnode = next_node;\n       }\n \n-      hash_remove (cache,node->key);\n+      objc_hash_remove (cache,node->key);\n     }\n   }\n \n@@ -106,7 +106,7 @@ hash_delete (cache_ptr cache)\n \n \n void\n-hash_add (cache_ptr *cachep, const void *key, void *value)\n+objc_hash_add (cache_ptr *cachep, const void *key, void *value)\n {\n   size_t indx = (*(*cachep)->hash_func)(*cachep, key);\n   node_ptr node = (node_ptr) objc_calloc (1, sizeof (struct cache_node));\n@@ -149,19 +149,19 @@ hash_add (cache_ptr *cachep, const void *key, void *value)\n        primitive functions thereby increasing its\n        correctness.  */\n     node_ptr node1 = NULL;\n-    cache_ptr new = hash_new (EXPANSION (*cachep),\n-\t\t\t      (*cachep)->hash_func,\n-\t\t\t      (*cachep)->compare_func);\n+    cache_ptr new = objc_hash_new (EXPANSION (*cachep),\n+\t\t\t\t   (*cachep)->hash_func,\n+\t\t\t\t   (*cachep)->compare_func);\n \n     DEBUG_PRINTF (\"Expanding cache %#x from %d to %d\\n\",\n \t\t  (int) *cachep, (*cachep)->size, new->size);\n \n     /* Copy the nodes from the first hash table to the new one.  */\n-    while ((node1 = hash_next (*cachep, node1)))\n-      hash_add (&new, node1->key, node1->value);\n+    while ((node1 = objc_hash_next (*cachep, node1)))\n+      objc_hash_add (&new, node1->key, node1->value);\n \n     /* Trash the old cache.  */\n-    hash_delete (*cachep);\n+    objc_hash_delete (*cachep);\n \n     /* Return a pointer to the new hash table.  */\n     *cachep = new;\n@@ -170,7 +170,7 @@ hash_add (cache_ptr *cachep, const void *key, void *value)\n \n \n void\n-hash_remove (cache_ptr cache, const void *key)\n+objc_hash_remove (cache_ptr cache, const void *key)\n {\n   size_t indx = (*cache->hash_func)(cache, key);\n   node_ptr node = cache->node_table[indx];\n@@ -206,7 +206,7 @@ hash_remove (cache_ptr cache, const void *key)\n \n \n node_ptr\n-hash_next (cache_ptr cache, node_ptr node)\n+objc_hash_next (cache_ptr cache, node_ptr node)\n {\n   /* If the scan is being started then reset the last node\n      visitied pointer and bucket index.  */\n@@ -246,7 +246,7 @@ hash_next (cache_ptr cache, node_ptr node)\n    Return NULL if the KEY is not recorded.  */\n \n void *\n-hash_value_for_key (cache_ptr cache, const void *key)\n+objc_hash_value_for_key (cache_ptr cache, const void *key)\n {\n   node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n   void *retval = NULL;\n@@ -267,7 +267,7 @@ hash_value_for_key (cache_ptr cache, const void *key)\n    Return NO if it does not */\n \n BOOL\n-hash_is_key_in_hash (cache_ptr cache, const void *key)\n+objc_hash_is_key_in_hash (cache_ptr cache, const void *key)\n {\n   node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n "}, {"sha": "46c273858a63926271fe1c797e69dd03a947fa0a", "filename": "libobjc/hash_compat.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fhash_compat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fhash_compat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash_compat.c?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -0,0 +1,97 @@\n+/* Binary compatibility hash implementations for Objective C.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#define OBJC_IGNORE_DEPRECATED_API 1\n+#include \"hash.h\"\n+\n+cache_ptr\n+hash_new (unsigned int size,\n+\t  hash_func_type hash_func,\n+\t  compare_func_type compare_func)\n+{\n+  return objc_hash_new(size, hash_func, compare_func);\n+}\n+\n+void\n+hash_delete(cache_ptr cache)\n+{\n+  objc_hash_delete(cache);\n+}\n+\n+void\n+hash_add (cache_ptr *cachep, const void *key, void *value)\n+{\n+  objc_hash_add(cachep, key, value);\n+}\n+\n+void\n+hash_remove (cache_ptr cache, const void *key)\n+{\n+  objc_hash_remove (cache, key);\n+}\n+\n+node_ptr\n+hash_next (cache_ptr cache, node_ptr node)\n+{\n+  return objc_hash_next (cache, node);\n+}\n+\n+void *\n+hash_value_for_key (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_value_for_key (cache, key);\n+}\n+\n+BOOL\n+hash_is_key_in_hash (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_is_key_in_hash (cache, key);\n+}\n+\n+unsigned int\n+hash_ptr (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_ptr (cache, key);\n+}\n+\n+unsigned int \n+hash_string (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_string (cache, key);\n+}\n+\n+int \n+compare_ptrs (const void *k1, const void *k2)\n+{\n+  return objc_compare_ptrs (k1, k2);\n+}\n+\n+int \n+compare_strings (const void *k1, const void *k2)\n+{\n+  return objc_compare_strings (k1, k2);\n+}\n+"}, {"sha": "3eb53866f38a6d0b704ec379f96031d31cd7dc0b", "filename": "libobjc/init.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -363,10 +363,12 @@ __objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n       Method_t mth = &method_list->method_list[i];\n \n       if (mth->method_name && sel_eq (mth->method_name, op)\n-\t  && ! hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n+\t  && ! objc_hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n \t{\n \t  /* Add this method into the +load hash table */\n-\t  hash_add (&__objc_load_methods, mth->method_imp, mth->method_imp);\n+\t  objc_hash_add (&__objc_load_methods,\n+\t\t\t mth->method_imp,\n+\t\t\t mth->method_imp);\n \n \t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n \n@@ -538,8 +540,9 @@ __objc_exec_class (Module_t module)\n       __objc_init_class_tables ();\n       __objc_init_dispatch_tables ();\n       __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n-      __objc_load_methods\n-\t  = hash_new (128, (hash_func_type)hash_ptr, compare_ptrs);\n+      __objc_load_methods = objc_hash_new (128, \n+\t\t\t\t\t   (hash_func_type)objc_hash_ptr,\n+\t\t\t\t\t   objc_compare_ptrs);\n       previous_constructors = 1;\n     }\n "}, {"sha": "bd50959cf07ca122b28c33d3c07242795b9cb7a7", "filename": "libobjc/libobjc.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Flibobjc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Flibobjc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Flibobjc.def?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -22,6 +22,7 @@ LIBRARY libobjc\n EXPORTS\n search_for_method_in_list\n objc_get_uninstalled_dtable\n+objc_hash_is_key_in_hash\n hash_is_key_in_hash\n objc_verror\n _objc_load_callback\n@@ -155,9 +156,15 @@ sarray_lazy_copy\n sarray_new\n sarray_realloc\n sarray_remove_garbage\n+objc_hash_add\n hash_add\n+objc_hash_delete\n hash_delete\n+objc_hash_new\n hash_new\n+objc_hash_next\n hash_next\n+objc_hash_remove\n hash_remove\n+objc_hash_value_for_key\n hash_value_for_key"}, {"sha": "48e33d37593f4422ba2cb29bad4ecc066479148f", "filename": "libobjc/objc/hash.h", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fhash.h?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -62,7 +62,7 @@ typedef struct cache_node\n  *\n  * Unfortunately there is a mutual data structure reference problem with this\n  * typedef.  Therefore, to remove compiler warnings the functions passed to\n- * hash_new will have to be casted to this type. \n+ * objc_hash_new will have to be casted to this type. \n  */\n typedef unsigned int (*hash_func_type) (void *, const void *);\n \n@@ -111,25 +111,25 @@ extern cache_ptr module_hash_table, class_hash_table;\n \n /* Allocate and initialize a hash table.  */ \n \n-cache_ptr hash_new (unsigned int size,\n-\t\t    hash_func_type hash_func,\n-\t\t    compare_func_type compare_func);\n+cache_ptr objc_hash_new (unsigned int size,\n+\t\t\t hash_func_type hash_func,\n+\t\t\t compare_func_type compare_func);\n                        \n /* Deallocate all of the hash nodes and the cache itself.  */\n \n-void hash_delete (cache_ptr cache);\n+void objc_hash_delete (cache_ptr cache);\n \n /* Add the key/value pair to the hash table.  If the\n    hash table reaches a level of fullness then it will be resized. \n                                                    \n    assert if the key is already in the hash.  */\n \n-void hash_add (cache_ptr *cachep, const void *key, void *value);\n+void objc_hash_add (cache_ptr *cachep, const void *key, void *value);\n      \n /* Remove the key/value pair from the hash table.  \n    assert if the key isn't in the table.  */\n \n-void hash_remove (cache_ptr cache, const void *key);\n+void objc_hash_remove (cache_ptr cache, const void *key);\n \n /* Used to index through the hash table.  Start with NULL\n    to get the first entry.\n@@ -140,15 +140,15 @@ void hash_remove (cache_ptr cache, const void *key);\n    Cache nodes are returned such that key or value can\n    be extracted.  */\n \n-node_ptr hash_next (cache_ptr cache, node_ptr node);\n+node_ptr objc_hash_next (cache_ptr cache, node_ptr node);\n \n /* Used to return a value from a hash table using a given key.  */\n \n-void *hash_value_for_key (cache_ptr cache, const void *key);\n+void *objc_hash_value_for_key (cache_ptr cache, const void *key);\n \n /* Used to determine if the given key exists in the hash table */\n \n-BOOL hash_is_key_in_hash (cache_ptr cache, const void *key);\n+BOOL objc_hash_is_key_in_hash (cache_ptr cache, const void *key);\n \n /************************************************\n \n@@ -163,7 +163,7 @@ BOOL hash_is_key_in_hash (cache_ptr cache, const void *key);\n    except for those likely to be 0 due to alignment.)  */\n \n static inline unsigned int\n-hash_ptr (cache_ptr cache, const void *key)\n+objc_hash_ptr (cache_ptr cache, const void *key)\n {\n   return ((size_t)key / sizeof (void *)) & cache->mask;\n }\n@@ -172,7 +172,7 @@ hash_ptr (cache_ptr cache, const void *key)\n /* Calculate a hash code by iterating over a NULL \n    terminate string.  */\n static inline unsigned int \n-hash_string (cache_ptr cache, const void *key)\n+objc_hash_string (cache_ptr cache, const void *key)\n {\n   unsigned int ret = 0;\n   unsigned int ctr = 0;\n@@ -189,15 +189,15 @@ hash_string (cache_ptr cache, const void *key)\n \n /* Compare two pointers for equality.  */\n static inline int \n-compare_ptrs (const void *k1, const void *k2)\n+objc_compare_ptrs (const void *k1, const void *k2)\n {\n   return (k1 == k2);\n }\n \n \n /* Compare two strings.  */\n static inline int \n-compare_strings (const void *k1, const void *k2)\n+objc_compare_strings (const void *k1, const void *k2)\n {\n   if (k1 == k2)\n     return 1;\n@@ -207,6 +207,107 @@ compare_strings (const void *k1, const void *k2)\n     return ! strcmp ((const char *) k1, (const char *) k2);\n }\n \n+#ifndef OBJC_IGNORE_DEPRECATED_API\n+/* Deprecated as of 4.1 */\n+\n+static inline cache_ptr\n+hash_new (unsigned int size,\n+\t  hash_func_type hash_func,\n+\t  compare_func_type compare_func) __attribute__ ((deprecated));\n+static inline cache_ptr\n+hash_new (unsigned int size,\n+\t  hash_func_type hash_func,\n+\t  compare_func_type compare_func)\n+{\n+  return objc_hash_new(size, hash_func, compare_func);\n+}\n+\n+static inline void\n+hash_delete(cache_ptr cache) __attribute__ ((deprecated));\n+static inline void\n+hash_delete(cache_ptr cache)\n+{\n+  objc_hash_delete(cache);\n+}\n+\n+static inline void\n+hash_add (cache_ptr *cachep,\n+\t  const void *key,\n+\t  void *value) __attribute__ ((deprecated));\n+static inline void\n+hash_add (cache_ptr *cachep, const void *key, void *value)\n+{\n+  objc_hash_add(cachep, key, value);\n+}\n+\n+static inline void\n+hash_remove (cache_ptr cache, const void *key) __attribute__ ((deprecated));\n+static inline void\n+hash_remove (cache_ptr cache, const void *key)\n+{\n+  objc_hash_remove (cache, key);\n+}\n+\n+static inline node_ptr\n+hash_next (cache_ptr cache, node_ptr node) __attribute__ ((deprecated));\n+static inline node_ptr\n+hash_next (cache_ptr cache, node_ptr node)\n+{\n+  return objc_hash_next (cache, node);\n+}\n+\n+static inline void *\n+hash_value_for_key (cache_ptr cache,\n+\t\t    const void *key) __attribute__ ((deprecated));\n+static inline void *\n+hash_value_for_key (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_value_for_key (cache, key);\n+}\n+\n+static inline BOOL\n+hash_is_key_in_hash (cache_ptr cache,\n+\t\t     const void *key) __attribute__ ((deprecated));\n+static inline BOOL\n+hash_is_key_in_hash (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_is_key_in_hash (cache, key);\n+}\n+\n+static inline unsigned int\n+hash_ptr (cache_ptr cache, const void *key) __attribute__ ((deprecated));\n+static inline unsigned int\n+hash_ptr (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_ptr (cache, key);\n+}\n+\n+static inline unsigned int \n+hash_string (cache_ptr cache, const void *key) __attribute__ ((deprecated));\n+static inline unsigned int \n+hash_string (cache_ptr cache, const void *key)\n+{\n+  return objc_hash_string (cache, key);\n+}\n+\n+static inline int \n+compare_ptrs (const void *k1, const void *k2) __attribute__ ((deprecated));\n+static inline int \n+compare_ptrs (const void *k1, const void *k2)\n+{\n+  return objc_compare_ptrs (k1, k2);\n+}\n+\n+static inline int \n+compare_strings (const void *k1, const void *k2) __attribute__ ((deprecated));\n+static inline int \n+compare_strings (const void *k1, const void *k2)\n+{\n+  return objc_compare_strings (k1, k2);\n+}\n+#endif /* IGNORE_DEPRECATED_API */\n+\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "ce8acf7ac3af3d7f5c2168f19be0f9d2142d3814", "filename": "libobjc/selector.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270a1283e6ce05c38474011515817f7816c8adb7/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=270a1283e6ce05c38474011515817f7816c8adb7", "patch": "@@ -43,9 +43,9 @@ void __objc_init_selector_tables (void)\n   __objc_selector_array = sarray_new (SELECTOR_HASH_SIZE, 0);\n   __objc_selector_names = sarray_new (SELECTOR_HASH_SIZE, 0);\n   __objc_selector_hash\n-    = hash_new (SELECTOR_HASH_SIZE,\n-\t\t(hash_func_type) hash_string,\n-\t\t(compare_func_type) compare_strings);\n+    = objc_hash_new (SELECTOR_HASH_SIZE,\n+\t\t     (hash_func_type) objc_hash_string,\n+\t\t     (compare_func_type) objc_compare_strings);\n }  \n \n /* This routine is given a class and records all of the methods in its class\n@@ -195,7 +195,7 @@ sel_get_typed_uid (const char *name, const char *types)\n \n   objc_mutex_lock (__objc_runtime_mutex);\n \n-  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n   if (i == 0)\n     {\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -235,7 +235,7 @@ sel_get_any_typed_uid (const char *name)\n \n   objc_mutex_lock (__objc_runtime_mutex);\n \n-  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n   if (i == 0)\n     {\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -266,7 +266,7 @@ sel_get_any_uid (const char *name)\n \n   objc_mutex_lock (__objc_runtime_mutex);\n \n-  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n   if (soffset_decode (i) == 0)\n     {\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -368,7 +368,7 @@ __sel_register_typed_name (const char *name, const char *types,\n   sidx i;\n   struct objc_list *l;\n \n-  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n   if (soffset_decode (i) != 0)\n     {\n       for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n@@ -453,7 +453,7 @@ __sel_register_typed_name (const char *name, const char *types,\n     sarray_at_put_safe (__objc_selector_names, i, (void *) new_name);\n     sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n     if (is_new)\n-      hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n+      objc_hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n   }\n \n   sarray_realloc (__objc_uninstalled_dtable, __objc_selector_max_index + 1);"}]}