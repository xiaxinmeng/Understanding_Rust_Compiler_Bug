{"sha": "b34fd25c83e4a098405b5d520a260fb3ac32b14e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM0ZmQyNWM4M2U0YTA5ODQwNWI1ZDUyMGEyNjBmYjNhYzMyYjE0ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-12T13:49:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-12T13:49:34Z"}, "message": "cgraph.h (struct varpool_node): Add aux.\n\n\n\t* cgraph.h (struct varpool_node): Add aux.\n\t* varasm.c (find_decl_and_mark_needed): Force output of varpool nodes.\n\t* varpool.c (varpool_remove_node): Do not remove initializer.\n\t(varpool_reset_queue): Export.\n\t(varpool_finalize_decl): Volatile vars are forced to be output.\n\t* lto-symtab.c (lto_varpool_replace_node): Clear out initializer of\n\treplaced decl.\n\t* ipa.c (enqueue_cgraph_node, enqueue_varpool_node,\n\tprocess_references, varpool_can_remove_if_no_refs): New functions.\n\t(cgraph_remove_unreachable_nodes): Handle variables too.\n\nFrom-SVN: r159321", "tree": {"sha": "8ecab4363a29f5b524dad95f3f7d8676be43b1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ecab4363a29f5b524dad95f3f7d8676be43b1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b34fd25c83e4a098405b5d520a260fb3ac32b14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34fd25c83e4a098405b5d520a260fb3ac32b14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b34fd25c83e4a098405b5d520a260fb3ac32b14e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34fd25c83e4a098405b5d520a260fb3ac32b14e/comments", "author": null, "committer": null, "parents": [{"sha": "49f19b1cfcccac7b821d14db46afeb323f56a87d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f19b1cfcccac7b821d14db46afeb323f56a87d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49f19b1cfcccac7b821d14db46afeb323f56a87d"}], "stats": {"total": 243, "additions": 181, "deletions": 62}, "files": [{"sha": "c5d8e6d966bac88fe67f9752ae6dfd5dadc56506", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -1,3 +1,16 @@\n+2010-05-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (struct varpool_node): Add aux.\n+\t* varasm.c (find_decl_and_mark_needed): Force output of varpool nodes.\n+\t* varpool.c (varpool_remove_node): Do not remove initializer.\n+\t(varpool_reset_queue): Export.\n+\t(varpool_finalize_decl): Volatile vars are forced to be output.\n+\t* lto-symtab.c (lto_varpool_replace_node): Clear out initializer of\n+\treplaced decl.\n+\t* ipa.c (enqueue_cgraph_node, enqueue_varpool_node,\n+\tprocess_references, varpool_can_remove_if_no_refs): New functions.\n+\t(cgraph_remove_unreachable_nodes): Handle variables too.\n+\n 2010-05-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/44088"}, {"sha": "60effb0f5ceca06940699809d05f7bd347119869", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -2387,7 +2387,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n bool\n cgraph_node_can_be_local_p (struct cgraph_node *node)\n {\n-  return (!node->needed\n+  return (!node->needed && !node->address_taken\n \t  && ((DECL_COMDAT (node->decl) && !node->same_comdat_group)\n \t      || !node->local.externally_visible));\n }"}, {"sha": "eaf9bfd5cd3a339e3afa8942b82b9d4ee19d430c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -439,6 +439,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n      nodes a pointer to the normal node.  */\n   struct varpool_node *extra_name;\n   struct ipa_ref_list ref_list;\n+  PTR GTY ((skip)) aux;\n   /* Ordering of all cgraph nodes.  */\n   int order;\n \n@@ -673,6 +674,7 @@ void varpool_remove_unreferenced_decls (void);\n void varpool_empty_needed_queue (void);\n bool varpool_extra_name_alias (tree, tree);\n const char * varpool_node_name (struct varpool_node *node);\n+void varpool_reset_queue (void);\n \n /* Walk all reachable static variables.  */\n #define FOR_EACH_STATIC_VARIABLE(node) \\"}, {"sha": "1fc3fdd41a64bf7b79295b6634bfcdcc183d90a3", "filename": "gcc/ipa.c", "status": "modified", "additions": 157, "deletions": 55, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -118,6 +118,69 @@ update_inlined_to_pointer (struct cgraph_node *node, struct cgraph_node *inlined\n       }\n }\n \n+/* Add cgraph NODE to queue starting at FIRST.  */\n+\n+static void\n+enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first)\n+{\n+  node->aux = *first;\n+  *first = node;\n+}\n+\n+/* Add varpool NODE to queue starting at FIRST.  */\n+\n+static void\n+enqueue_varpool_node (struct varpool_node *node, struct varpool_node **first)\n+{\n+  node->aux = *first;\n+  *first = node;\n+}\n+\n+/* Process references.  */\n+\n+static void\n+process_references (struct ipa_ref_list *list,\n+\t\t    struct cgraph_node **first,\n+\t\t    struct varpool_node **first_varpool,\n+\t\t    bool before_inlining_p)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+    {\n+      if (ref->refered_type == IPA_REF_CGRAPH)\n+\t{\n+\t  struct cgraph_node *node = ipa_ref_node (ref);\n+\t  if (!node->reachable\n+\t      && (!DECL_EXTERNAL (node->decl)\n+\t          || before_inlining_p))\n+\t    {\n+\t      node->reachable = true;\n+\t      enqueue_cgraph_node (node, first);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  struct varpool_node *node = ipa_ref_varpool_node (ref);\n+\t  if (!node->needed)\n+\t    {\n+\t      varpool_mark_needed_node (node);\n+\t      enqueue_varpool_node (node, first_varpool);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Return true when function NODE can be removed from callgraph\n+   if all direct calls are eliminated.  */\n+\n+static inline bool\n+varpool_can_remove_if_no_refs (struct varpool_node *node)\n+{\n+  return (!node->force_output && !node->used_from_other_partition\n+  \t  && (DECL_COMDAT (node->decl) || !node->externally_visible));\n+}\n+\n /* Perform reachability analysis and reclaim all unreachable nodes.\n    If BEFORE_INLINING_P is true this function is called before inlining\n    decisions has been made.  If BEFORE_INLINING_P is false this function also\n@@ -127,8 +190,10 @@ bool\n cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   struct cgraph_node *first = (struct cgraph_node *) (void *) 1;\n+  struct varpool_node *first_varpool = (struct varpool_node *) (void *) 1;\n   struct cgraph_node *processed = (struct cgraph_node *) (void *) 2;\n   struct cgraph_node *node, *next;\n+  struct varpool_node *vnode, *vnext;\n   bool changed = false;\n \n #ifdef ENABLE_CHECKING\n@@ -140,84 +205,107 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (node = cgraph_nodes; node; node = node->next)\n     gcc_assert (!node->aux);\n #endif\n+  varpool_reset_queue ();\n   for (node = cgraph_nodes; node; node = node->next)\n     if (!cgraph_can_remove_if_no_direct_calls_p (node)\n \t&& ((!DECL_EXTERNAL (node->decl))\n-            || !node->analyzed\n             || before_inlining_p))\n       {\n         gcc_assert (!node->global.inlined_to);\n-\tnode->aux = first;\n-\tfirst = node;\n+\tenqueue_cgraph_node (node, &first);\n \tnode->reachable = true;\n       }\n     else\n       {\n         gcc_assert (!node->aux);\n \tnode->reachable = false;\n       }\n+  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+    {\n+      vnode->next_needed = NULL;\n+      vnode->prev_needed = NULL;\n+      if (!varpool_can_remove_if_no_refs (vnode))\n+\t{\n+\t  vnode->needed = false;\n+\t  varpool_mark_needed_node (vnode);\n+\t  enqueue_varpool_node (vnode, &first_varpool);\n+\t}\n+      else\n+\tvnode->needed = false;\n+    }\n \n   /* Perform reachability analysis.  As a special case do not consider\n      extern inline functions not inlined as live because we won't output\n      them at all.  */\n-  while (first != (void *) 1)\n+  while (first != (struct cgraph_node *) (void *) 1\n+  \t || first_varpool != (struct varpool_node *) (void *) 1)\n     {\n-      struct cgraph_edge *e;\n-      node = first;\n-      first = (struct cgraph_node *) first->aux;\n-      node->aux = processed;\n-\n-      if (node->reachable)\n-        for (e = node->callees; e; e = e->next_callee)\n-\t  if (!e->callee->reachable\n-\t      && node->analyzed\n-\t      && (!e->inline_failed || !e->callee->analyzed\n-\t\t  || (!DECL_EXTERNAL (e->callee->decl))\n-                  || before_inlining_p))\n+      if (first != (struct cgraph_node *) (void *) 1)\n+\t{\n+\t  struct cgraph_edge *e;\n+\t  node = first;\n+\t  first = (struct cgraph_node *) first->aux;\n+\t  node->aux = processed;\n+\n+\t  if (node->reachable)\n+\t    for (e = node->callees; e; e = e->next_callee)\n+\t      if (!e->callee->reachable\n+\t\t  && node->analyzed\n+\t\t  && (!e->inline_failed || !e->callee->analyzed\n+\t\t      || (!DECL_EXTERNAL (e->callee->decl))\n+\t\t      || before_inlining_p))\n+\t\t{\n+\t\t  bool prev_reachable = e->callee->reachable;\n+\t\t  e->callee->reachable |= node->reachable;\n+\t\t  if (!e->callee->aux\n+\t\t      || (e->callee->aux == processed\n+\t\t\t  && prev_reachable != e->callee->reachable))\n+\t\t    {\n+\t\t      e->callee->aux = first;\n+\t\t      first = e->callee;\n+\t\t    }\n+\t\t}\n+\n+\t  /* If any function in a comdat group is reachable, force\n+\t     all other functions in the same comdat group to be\n+\t     also reachable.  */\n+\t  if (node->same_comdat_group\n+\t      && node->reachable\n+\t      && !node->global.inlined_to)\n \t    {\n-\t      bool prev_reachable = e->callee->reachable;\n-\t      e->callee->reachable |= node->reachable;\n-\t      if (!e->callee->aux\n-\t          || (e->callee->aux == processed\n-\t\t      && prev_reachable != e->callee->reachable))\n-\t        {\n-\t          e->callee->aux = first;\n-\t          first = e->callee;\n-\t        }\n+\t      for (next = node->same_comdat_group;\n+\t\t   next != node;\n+\t\t   next = next->same_comdat_group)\n+\t\tif (!next->reachable)\n+\t\t  {\n+\t\t    next->aux = first;\n+\t\t    first = next;\n+\t\t    next->reachable = true;\n+\t\t  }\n \t    }\n \n-      /* If any function in a comdat group is reachable, force\n-\t all other functions in the same comdat group to be\n-\t also reachable.  */\n-      if (node->same_comdat_group\n-\t  && node->reachable\n-\t  && !node->global.inlined_to)\n-\t{\n-\t  for (next = node->same_comdat_group;\n-\t       next != node;\n-\t       next = next->same_comdat_group)\n-\t    if (!next->reachable)\n-\t      {\n-\t\tnext->aux = first;\n-\t\tfirst = next;\n-\t\tnext->reachable = true;\n-\t      }\n-\t}\n-\n-      /* We can freely remove inline clones even if they are cloned, however if\n-\t function is clone of real clone, we must keep it around in order to\n-\t make materialize_clones produce function body with the changes\n-\t applied.  */\n-      while (node->clone_of && !node->clone_of->aux && !gimple_has_body_p (node->decl))\n-        {\n-\t  bool noninline = node->clone_of->decl != node->decl;\n-\t  node = node->clone_of;\n-\t  if (noninline)\n+\t  /* We can freely remove inline clones even if they are cloned, however if\n+\t     function is clone of real clone, we must keep it around in order to\n+\t     make materialize_clones produce function body with the changes\n+\t     applied.  */\n+\t  while (node->clone_of && !node->clone_of->aux && !gimple_has_body_p (node->decl))\n \t    {\n-\t      node->aux = first;\n-\t      first = node;\n-\t      break;\n+\t      bool noninline = node->clone_of->decl != node->decl;\n+\t      node = node->clone_of;\n+\t      if (noninline)\n+\t      \t{\n+\t\t  enqueue_cgraph_node (node, &first);\n+\t\t  break;\n+\t\t}\n \t    }\n+\t  process_references (&node->ref_list, &first, &first_varpool, before_inlining_p);\n+\t}\n+      if (first_varpool != (struct varpool_node *) (void *) 1)\n+\t{\n+\t  vnode = first_varpool;\n+\t  first_varpool = (struct varpool_node *)first_varpool->aux;\n+\t  vnode->aux = NULL;\n+\t  process_references (&vnode->ref_list, &first, &first_varpool, before_inlining_p);\n \t}\n     }\n \n@@ -274,6 +362,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  else\n \t\t    gcc_assert (!clone->in_other_partition);\n \t\t  cgraph_node_remove_callees (node);\n+\t\t  ipa_remove_all_references (&node->ref_list);\n \t\t  if (node->prev_sibling_clone)\n \t\t    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n \t\t  else if (node->clone_of)\n@@ -304,6 +393,19 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       node->aux = NULL;\n     }\n+  if (file)\n+    fprintf (file, \"\\nReclaiming variables:\");\n+  for (vnode = varpool_nodes; vnode; vnode = vnext)\n+    {\n+      vnext = vnode->next;\n+      if (!vnode->needed)\n+        {\n+\t   if (file)\n+\t     fprintf (file, \" %s\", varpool_node_name (vnode));\n+\t   varpool_remove_node (vnode);\n+\t}\n+    }\n+\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif"}, {"sha": "f8a244cbeecebdecca0797ef1206d131274f0740", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -291,6 +291,9 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n     prevailing_node = prevailing_node->extra_name;\n   ipa_clone_refering (NULL, prevailing_node, &vnode->ref_list);\n \n+  /* Be sure we can garbage collect the initializer.  */\n+  if (DECL_INITIAL (vnode->decl))\n+    DECL_INITIAL (vnode->decl) = error_mark_node;\n   /* Finally remove the replaced node.  */\n   varpool_remove_node (vnode);\n }"}, {"sha": "302d36b9f3428b076f2c0ad64bfc5a93c6aaddeb", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -688,7 +688,7 @@ copy_bind_expr (tree *tp, int *walk_subtrees, copy_body_data *id)\n /* Create a new gimple_seq by remapping all the statements in BODY\n    using the inlining information in ID.  */\n \n-gimple_seq\n+static gimple_seq\n remap_gimple_seq (gimple_seq body, copy_body_data *id)\n {\n   gimple_stmt_iterator si;"}, {"sha": "dba5eb2d8816582c258220a8ab46813341e5da9f", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -174,15 +174,13 @@ tree maybe_inline_call_in_expr (tree);\n bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree *, int *, void *);\n tree copy_decl_no_change (tree decl, copy_body_data *id);\n-void save_body (tree, tree *, tree *);\n int estimate_move_cost (tree type);\n int estimate_num_insns (gimple, eni_weights *);\n int estimate_num_insns_fn (tree, eni_weights *);\n int count_insns_seq (gimple_seq, eni_weights *);\n bool tree_versionable_function_p (tree);\n bool tree_can_inline_p (struct cgraph_edge *e);\n \n-extern gimple_seq remap_gimple_seq (gimple_seq, copy_body_data *);\n extern tree remap_decl (tree decl, copy_body_data *id);\n extern tree remap_type (tree type, copy_body_data *id);\n extern gimple_seq copy_gimple_seq_and_replace_locals (gimple_seq seq);"}, {"sha": "15ff1b3c212f993b84e3b4bac1b91e6f6af46598", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -5650,6 +5650,7 @@ find_decl_and_mark_needed (tree decl, tree target)\n   else if (vnode)\n     {\n       varpool_mark_needed_node (vnode);\n+      vnode->force_output = 1;\n       return vnode->decl;\n     }\n   else"}, {"sha": "39a6565842a29801f7b62ab6a7b8e8d1a66646b6", "filename": "gcc/varpool.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34fd25c83e4a098405b5d520a260fb3ac32b14e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=b34fd25c83e4a098405b5d520a260fb3ac32b14e", "patch": "@@ -196,8 +196,6 @@ varpool_remove_node (struct varpool_node *node)\n     }\n   ipa_remove_all_references (&node->ref_list);\n   ipa_remove_all_refering (&node->ref_list);\n-  if (DECL_INITIAL (node->decl))\n-    DECL_INITIAL (node->decl) = error_mark_node;\n   ggc_free (node);\n }\n \n@@ -302,7 +300,7 @@ varpool_mark_needed_node (struct varpool_node *node)\n }\n \n /* Reset the queue of needed nodes.  */\n-static void\n+void\n varpool_reset_queue (void)\n {\n   varpool_last_needed_node = NULL;\n@@ -383,6 +381,8 @@ varpool_finalize_decl (tree decl)\n   if (node->needed)\n     varpool_enqueue_needed_node (node);\n   node->finalized = true;\n+  if (TREE_THIS_VOLATILE (decl))\n+    node->force_output = true;\n \n   if (decide_is_variable_needed (node, decl))\n     varpool_mark_needed_node (node);"}]}