{"sha": "3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxYmU1YmVjMzNiYmYyMTMxZDgwYTMzZDc4MmNjY2E1ODgyZjdiYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2014-07-31T13:51:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:51:38Z"}, "message": "trans.c, misc.c: Remove references to VMS.\n\n        * gcc-interface/trans.c, gcc-interface/misc.c: Remove references\n        to VMS. Misc clean ups.\n\nFrom-SVN: r213370", "tree": {"sha": "506791695a5842e4e35fec0d00767623b1f328eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/506791695a5842e4e35fec0d00767623b1f328eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba0c6e4769cb6e81289ea4a0c536260e859fc795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0c6e4769cb6e81289ea4a0c536260e859fc795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba0c6e4769cb6e81289ea4a0c536260e859fc795"}], "stats": {"total": 99, "additions": 37, "deletions": 62}, "files": [{"sha": "1333672da6919d821fda6a78da121150c5956af7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "patch": "@@ -1,3 +1,8 @@\n+2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gcc-interface/trans.c, gcc-interface/misc.c: Remove references\n+\tto VMS. Misc clean ups.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* cstand.adb, einfo.adb, einfo.ads, errout.adb, exp_attr.adb,"}, {"sha": "3d1ea17a8f4cdc5ab0d5491724146d195f630a89", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "patch": "@@ -774,11 +774,6 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \n \t  else\n \t    gcc_unreachable();\n-\n-\t  if (fmt == &vax_f_format\n-\t      || fmt == &vax_d_format\n-\t      || fmt == &vax_g_format)\n-\t    float_rep = VAX_Native;\n \t}\n \n       /* First register any C types for this mode that the front end"}, {"sha": "6df6dea3435e5c2c27134b57546c97e18633d2ff", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1be5bec33bbf2131d80a33d782ccca5882f7ba/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=3f1be5bec33bbf2131d80a33d782ccca5882f7ba", "patch": "@@ -4899,26 +4899,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t       gnu_except_ptr_stack->last (),\n \t       convert (TREE_TYPE (gnu_except_ptr_stack->last ()),\n \t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr)));\n-\n-\t  /* If this is the distinguished exception \"Non_Ada_Error\" (and we are\n-\t     in VMS mode), also allow a non-Ada exception (a VMS condition) t\n-\t     match.  */\n-\t  if (Is_Non_Ada_Error (Entity (gnat_temp)))\n-\t    {\n-\t      tree gnu_comp\n-\t\t= build_component_ref\n-\t\t  (build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t   gnu_except_ptr_stack->last ()),\n-\t\t   get_identifier (\"lang\"), NULL_TREE, false);\n-\n-\t      this_choice\n-\t\t= build_binary_op\n-\t\t  (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t   build_binary_op (EQ_EXPR, boolean_type_node, gnu_comp,\n-\t\t\t\t    build_int_cst (TREE_TYPE (gnu_comp), 'V')),\n-\t\t   this_choice);\n-\t    }\n-\t}\n+}\n       else\n \tgcc_unreachable ();\n \n@@ -8299,32 +8280,37 @@ static tree\n build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t\t       tree right, Node_Id gnat_node)\n {\n+  const unsigned int precision = TYPE_PRECISION (gnu_type);\n   tree lhs = gnat_protect_expr (left);\n   tree rhs = gnat_protect_expr (right);\n   tree type_max = TYPE_MAX_VALUE (gnu_type);\n   tree type_min = TYPE_MIN_VALUE (gnu_type);\n-  tree gnu_expr;\n-  tree tmp1, tmp2;\n   tree zero = convert (gnu_type, integer_zero_node);\n-  tree rhs_lt_zero;\n-  tree check_pos;\n-  tree check_neg;\n-  tree check;\n-  int precision = TYPE_PRECISION (gnu_type);\n+  tree gnu_expr, rhs_lt_zero, tmp1, tmp2;\n+  tree check_pos, check_neg, check;\n \n-  gcc_assert (!(precision & (precision - 1))); /* ensure power of 2 */\n+  /* Assert that the precision is a power of 2.  */\n+  gcc_assert ((precision & (precision - 1)) == 0);\n \n   /* Prefer a constant or known-positive rhs to simplify checks.  */\n   if (!TREE_CONSTANT (rhs)\n       && commutative_tree_code (code)\n-      && (TREE_CONSTANT (lhs) || (!tree_expr_nonnegative_p (rhs)\n-\t\t\t\t  && tree_expr_nonnegative_p (lhs))))\n+      && (TREE_CONSTANT (lhs)\n+\t  || (!tree_expr_nonnegative_p (rhs)\n+\t      && tree_expr_nonnegative_p (lhs))))\n     {\n       tree tmp = lhs;\n       lhs = rhs;\n       rhs = tmp;\n     }\n \n+  gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n+\n+  /* If we can fold the expression to a constant, just return it.\n+     The caller will deal with overflow, no need to generate a check.  */\n+  if (TREE_CONSTANT (gnu_expr))\n+    return gnu_expr;\n+\n   rhs_lt_zero = tree_expr_nonnegative_p (rhs)\n \t\t? boolean_false_node\n \t\t: build_binary_op (LT_EXPR, boolean_type_node, rhs, zero);\n@@ -8341,7 +8327,7 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   if (!TREE_CONSTANT (rhs))\n     {\n       /* Even for add/subtract double size to get another base type.  */\n-      int needed_precision = precision * 2;\n+      const unsigned int needed_precision = precision * 2;\n \n       if (code == MULT_EXPR && precision == 64)\n \t{\n@@ -8352,49 +8338,45 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t\t\t\t\t\t       convert (int_64, rhs)));\n \t}\n \n-      else if (needed_precision <= BITS_PER_WORD\n-\t       || (code == MULT_EXPR\n-\t\t   && needed_precision <= LONG_LONG_TYPE_SIZE))\n+      if (needed_precision <= BITS_PER_WORD\n+\t  || (code == MULT_EXPR && needed_precision <= LONG_LONG_TYPE_SIZE))\n \t{\n \t  tree wide_type = gnat_type_for_size (needed_precision, 0);\n-\n \t  tree wide_result = build_binary_op (code, wide_type,\n \t\t\t\t\t      convert (wide_type, lhs),\n \t\t\t\t\t      convert (wide_type, rhs));\n \n-\t  tree check = build_binary_op\n+\t  check = build_binary_op\n \t    (TRUTH_ORIF_EXPR, boolean_type_node,\n \t     build_binary_op (LT_EXPR, boolean_type_node, wide_result,\n \t\t\t      convert (wide_type, type_min)),\n \t     build_binary_op (GT_EXPR, boolean_type_node, wide_result,\n \t\t\t      convert (wide_type, type_max)));\n \n-\t  tree result = convert (gnu_type, wide_result);\n-\n \t  return\n-\t    emit_check (check, result, CE_Overflow_Check_Failed, gnat_node);\n+\t    emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n \t}\n \n-      else if (code == PLUS_EXPR || code == MINUS_EXPR)\n+      if (code == PLUS_EXPR || code == MINUS_EXPR)\n \t{\n \t  tree unsigned_type = gnat_type_for_size (precision, 1);\n-\t  tree wrapped_expr = convert\n-\t    (gnu_type, build_binary_op (code, unsigned_type,\n+\t  tree wrapped_expr\n+\t    = convert (gnu_type,\n+\t\t       build_binary_op (code, unsigned_type,\n \t\t\t\t\tconvert (unsigned_type, lhs),\n \t\t\t\t\tconvert (unsigned_type, rhs)));\n \n-\t  tree result = convert\n-\t    (gnu_type, build_binary_op (code, gnu_type, lhs, rhs));\n-\n \t  /* Overflow when (rhs < 0) ^ (wrapped_expr < lhs)), for addition\n \t     or when (rhs < 0) ^ (wrapped_expr > lhs) for subtraction.  */\n-\t  tree check = build_binary_op\n-\t    (TRUTH_XOR_EXPR, boolean_type_node, rhs_lt_zero,\n-\t     build_binary_op (code == PLUS_EXPR ? LT_EXPR : GT_EXPR,\n-\t\t\t      boolean_type_node, wrapped_expr, lhs));\n+\t  check\n+\t    = build_binary_op (TRUTH_XOR_EXPR, boolean_type_node, rhs_lt_zero,\n+\t\t\t       build_binary_op (code == PLUS_EXPR\n+\t\t\t\t\t\t? LT_EXPR : GT_EXPR,\n+\t\t\t\t\t        boolean_type_node,\n+\t\t\t\t\t\twrapped_expr, lhs));\n \n \t  return\n-\t    emit_check (check, result, CE_Overflow_Check_Failed, gnat_node);\n+\t    emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n \t}\n    }\n \n@@ -8468,13 +8450,6 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n       gcc_unreachable();\n     }\n \n-  gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n-\n-  /* If we can fold the expression to a constant, just return it.\n-     The caller will deal with overflow, no need to generate a check.  */\n-  if (TREE_CONSTANT (gnu_expr))\n-    return gnu_expr;\n-\n   check = fold_build3 (COND_EXPR, boolean_type_node, rhs_lt_zero, check_neg,\n \t\t       check_pos);\n "}]}