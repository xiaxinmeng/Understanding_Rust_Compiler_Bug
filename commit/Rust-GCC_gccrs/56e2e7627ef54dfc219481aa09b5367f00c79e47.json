{"sha": "56e2e7627ef54dfc219481aa09b5367f00c79e47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlMmU3NjI3ZWY1NGRmYzIxOTQ4MWFhMDliNTM2N2YwMGM3OWU0Nw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-11-09T15:07:07Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-09T15:07:07Z"}, "message": "Add prototype header file\nImport some code from Cygnus internal sources.\n\nFrom-SVN: r30459", "tree": {"sha": "f7fe63ada2ec66ef38051f710e5e1cb14c89c59b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7fe63ada2ec66ef38051f710e5e1cb14c89c59b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56e2e7627ef54dfc219481aa09b5367f00c79e47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e2e7627ef54dfc219481aa09b5367f00c79e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e2e7627ef54dfc219481aa09b5367f00c79e47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e2e7627ef54dfc219481aa09b5367f00c79e47/comments", "author": null, "committer": null, "parents": [{"sha": "f1c7f597114e15479edb43c4ae78c1fe48b53f3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c7f597114e15479edb43c4ae78c1fe48b53f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c7f597114e15479edb43c4ae78c1fe48b53f3b"}], "stats": {"total": 2658, "additions": 1969, "deletions": 689}, "files": [{"sha": "15122c17574ed199690fded2b5d0a465c63c655d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56e2e7627ef54dfc219481aa09b5367f00c79e47", "patch": "@@ -1,3 +1,31 @@\n+Tue Nov  9 14:55:44 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/m32r/m32r-protos.h: New file: Prototypes for functions\n+\tdefined in m32r.c\n+\t\n+\t* config/m32r/m32r.h: Move prototypes to m32r-protos.h\n+\tAdd support for subtargets.\n+\tAdd prototypes for new predicates.\n+\tAdd scheduling macros.\n+\t\n+\t* config/m32r/m32r.c: Fix compile time warnings.\n+\t(int8_operand): New predicate function.\n+\t(reg_or_cmp_int16_operand): New predicate function.\n+\t(extend_operand): New predicate function.\n+\t(m32r_adjust_code): New scheduling function.\n+\t(m32r_adjust_priorty): New scheduling function.\n+\t(m32r_sched_init): New scheduling function.\n+\t(m32r_sched_reorder): New scheduling function.\n+\t(m32r_sched_variable_issue): New scheduling function.\n+\t(direct_return): New codegen function.\n+\t(m32r_not_same_reg): New rtl testsing function.\n+\t\n+\t* config/m32r/m32r.md: Fix compile time warnings.\n+\tAdd support for pre decrement and post increment memory\n+\treferences.\n+\tAdd S<cc> patterns.\n+\tAdd fabs patterns.\n+\t\n Mon Nov  8 22:20:13 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* global.c (EXECUTE_IF_CONFLICT): Don't define."}, {"sha": "d6bd9ae0f951b54fb0fd9b8efb71565fb19b5588", "filename": "gcc/config/m32r/m32r-protos.h", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=56e2e7627ef54dfc219481aa09b5367f00c79e47", "patch": "@@ -0,0 +1,110 @@\n+/* Prototypes for m32r.c functions used in the md file & elsewhere.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Function prototypes that cannot exist in v850.h due to dependency\n+   compilcations.  */\n+#define Mmode enum machine_mode\n+\n+extern void   sbss_section\t\t\tPROTO ((void));\n+extern void   sdata_section\t\t\tPROTO ((void));\n+extern void   m32r_init\t\t\t\tPROTO ((void));\n+extern void   m32r_init_expanders\t\tPROTO ((void));\n+extern unsigned m32r_compute_frame_size\t\tPROTO ((int));\n+extern int    m32r_first_insn_address\t\tPROTO ((void));\n+extern void   m32r_expand_prologue\t\tPROTO ((void));\n+extern void   m32r_output_function_prologue\tPROTO ((FILE *, int));\n+extern void   m32r_output_function_epilogue\tPROTO ((FILE *, int));\n+extern void   m32r_finalize_pic\t\t\tPROTO ((void));\n+extern void   m32r_asm_file_start\t\tPROTO ((FILE *));\n+extern void   m32r_sched_init \t\t\tPROTO ((FILE *, int));\n+extern int    direct_return \t\t\tPROTO ((void));\n+#ifdef TREE_CODE\n+extern int    m32r_valid_machine_decl_attribute\tPROTO ((tree, tree, tree, tree));\n+extern int    m32r_comp_type_attributes\t\tPROTO ((tree, tree));\n+extern void   m32r_select_section\t\tPROTO ((tree, int));\n+extern void   m32r_encode_section_info\t\tPROTO ((tree));\n+extern enum m32r_function_type m32r_compute_function_type PROTO ((tree));\n+extern void   m32r_select_section \t\tPROTO ((tree, int));\n+extern void   m32r_set_default_type_attributes  PROTO ((tree));\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern void   m32r_setup_incoming_varargs\tPROTO ((CUMULATIVE_ARGS *, Mmode, tree, int *, int));\n+extern int    function_arg_partial_nregs\tPROTO ((CUMULATIVE_ARGS *, Mmode, tree, int));\n+#endif\n+#endif /* TREE_CODE */\n+\n+#ifdef RTX_CODE\n+extern int    easy_di_const\t\t\tPROTO ((rtx));\n+extern int    easy_df_const\t\t\tPROTO ((rtx));\n+extern int    m32r_select_cc_mode\t\tPROTO ((int, rtx, rtx));\n+extern rtx    gen_compare\t\t\tPROTO ((enum rtx_code, rtx, rtx, int));\n+extern rtx    gen_split_move_double\t\tPROTO ((rtx *));\n+extern int    m32r_address_code\t\t\tPROTO ((rtx));\n+extern void   m32r_initialize_trampoline\tPROTO ((rtx, rtx, rtx));\n+extern int    zero_and_one\t\t\tPROTO ((rtx, rtx));\n+extern char * emit_cond_move\t\t\tPROTO ((rtx *, rtx));\n+extern char * m32r_output_block_move \t\tPROTO ((rtx, rtx *));\n+extern void   m32r_expand_block_move \t\tPROTO ((rtx *));\n+extern void   m32r_print_operand\t\tPROTO ((FILE *, rtx, int));\n+extern void   m32r_print_operand_address\tPROTO ((FILE *, rtx));\n+extern int    m32r_address_cost \t\tPROTO ((rtx));\n+extern int    m32r_adjust_cost \t\t\tPROTO ((rtx, rtx, rtx, int));\n+extern int    m32r_adjust_priority \t\tPROTO ((rtx, int));\n+extern void   m32r_sched_reorder \t\tPROTO ((FILE *, int, rtx *, int));\n+extern int    m32r_sched_variable_issue \tPROTO ((FILE *, int, rtx, int));\n+extern int    m32r_not_same_reg \t\tPROTO ((rtx, rtx));\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern int    call_address_operand\t\tPROTO ((rtx, Mmode));\n+extern int    call_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    symbolic_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    small_data_operand\t\tPROTO ((rtx, Mmode));\n+extern int    addr24_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    addr32_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    call26_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    seth_add3_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    cmp_int16_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    uint16_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    reg_or_int16_operand\t\tPROTO ((rtx, Mmode));\n+extern int    reg_or_uint16_operand\t\tPROTO ((rtx, Mmode));\n+extern int    reg_or_cmp_int16_operand\t\tPROTO ((rtx, Mmode));\n+extern int    two_insn_const_operand\t\tPROTO ((rtx, Mmode));\n+extern int    move_src_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    move_double_src_operand\t\tPROTO ((rtx, Mmode));\n+extern int    move_dest_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    eqne_comparison_operator\t\tPROTO ((rtx, Mmode));\n+extern int    signed_comparison_operator\tPROTO ((rtx, Mmode));\n+extern int    memreg_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    small_insn_p\t\t\tPROTO ((rtx, Mmode));\n+extern int    large_insn_p\t\t\tPROTO ((rtx, Mmode));\n+extern int    conditional_move_operand\t\tPROTO ((rtx, Mmode));\n+extern int    carry_compare_operand\t\tPROTO ((rtx, Mmode));\n+extern int    m32r_block_immediate_operand \tPROTO ((rtx, Mmode));\n+extern int    extend_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    reg_or_eq_int16_operand\t\tPROTO ((rtx, Mmode));\n+extern int    int8_operand\t\t\tPROTO ((rtx, Mmode));\n+#endif /* HAVE_MACHINE_MODES */\n+\n+#ifdef TREE_CODE\n+extern struct rtx_def * m32r_va_arg\t\tPROTO ((tree, tree));\n+#endif /* TREE_CODE */\n+#endif /* RTX_CODE */\n+\n+#undef  Mmode"}, {"sha": "f547332a306682972da78bc57a07e2e9f2304d51", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 405, "deletions": 98, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=56e2e7627ef54dfc219481aa09b5367f00c79e47", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"m32r-protos.h\"\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n@@ -44,16 +45,18 @@ rtx m32r_compare_op0, m32r_compare_op1;\n char m32r_punct_chars[256];\n \n /* Selected code model.  */\n-char *m32r_model_string = M32R_MODEL_DEFAULT;\n+const char * m32r_model_string = M32R_MODEL_DEFAULT;\n enum m32r_model m32r_model;\n \n /* Selected SDA support.  */\n-char *m32r_sdata_string = M32R_SDATA_DEFAULT;\n+const char * m32r_sdata_string = M32R_SDATA_DEFAULT;\n enum m32r_sdata m32r_sdata;\n \n+/* Scheduler support */\n+int m32r_sched_odd_word_p;\n \n /* Forward declaration.  */\n-static void init_reg_tables\tPROTO((void));\n+static void init_reg_tables\t\t\tPROTO ((void));\n \n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n \n@@ -88,7 +91,6 @@ m32r_init ()\n     m32r_sdata = M32R_SDATA_USE;\n   else\n     error (\"bad value (%s) for -msdata switch\", m32r_sdata_string);\n-\n }\n \n /* Vectors to keep interesting information about registers where it can easily\n@@ -104,7 +106,7 @@ enum m32r_mode_class\n {\n   C_MODE,\n   S_MODE, D_MODE, T_MODE, O_MODE,\n-  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n+  SF_MODE, DF_MODE, TF_MODE, OF_MODE, A_MODE\n };\n \n /* Modes for condition codes.  */\n@@ -119,14 +121,16 @@ enum m32r_mode_class\n /* Modes for quad-word and smaller quantities.  */\n #define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n \n+/* Modes for accumulators.  */\n+#define A_MODES (1 << (int) A_MODE)\n \n /* Value is 1 if register/mode pair is acceptable on arc.  */\n \n unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] =\n {\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, C_MODES\n+  S_MODES, C_MODES, A_MODES\n };\n \n unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n@@ -451,23 +455,21 @@ m32r_init_expanders ()\n /* Acceptable arguments to the call insn.  */\n \n int\n-call_address_operand (op, int_mode)\n+call_address_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  return symbolic_operand (op, int_mode);\n+  return symbolic_operand (op, mode);\n \n /* Constants and values in registers are not OK, because\n    the m32r BL instruction can only support PC relative branching.  */ \n }\n \n int\n-call_operand (op, int_mode)\n+call_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n-\n   if (GET_CODE (op) != MEM)\n     return 0;\n   op = XEXP (op, 0);\n@@ -477,9 +479,9 @@ call_operand (op, int_mode)\n /* Returns 1 if OP is a symbol reference.  */\n \n int\n-symbolic_operand (op, int_mode)\n+symbolic_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (op))\n     {\n@@ -496,9 +498,9 @@ symbolic_operand (op, int_mode)\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n-small_data_operand (op, int_mode)\n+small_data_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (! TARGET_SDATA_USE)\n     return 0;\n@@ -519,9 +521,9 @@ small_data_operand (op, int_mode)\n /* Return 1 if OP is a symbol that can use 24 bit addressing.  */\n \n int\n-addr24_operand (op, int_mode)\n+addr24_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR24;\n@@ -551,24 +553,24 @@ addr24_operand (op, int_mode)\n /* Return 1 if OP is a symbol that needs 32 bit addressing.  */\n \n int\n-addr32_operand (op, int_mode)\n+addr32_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR32;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return (! addr24_operand (op, int_mode)\n-\t    && ! small_data_operand (op, int_mode));\n+    return (! addr24_operand (op, mode)\n+\t    && ! small_data_operand (op, mode));\n \n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n     {\n-      return (! addr24_operand (op, int_mode)\n-\t      && ! small_data_operand (op, int_mode));\n+      return (! addr24_operand (op, mode)\n+\t      && ! small_data_operand (op, mode));\n     }\n \n   return 0;\n@@ -577,9 +579,9 @@ addr32_operand (op, int_mode)\n /* Return 1 if OP is a function that can be called with the `bl' insn.  */\n \n int\n-call26_operand (op, int_mode)\n+call26_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == SYMBOL_REF)\n     return ! LARGE_NAME_P (XSTR (op, 0));\n@@ -590,9 +592,9 @@ call26_operand (op, int_mode)\n /* Returns 1 if OP is an acceptable operand for seth/add3.  */\n \n int\n-seth_add3_operand (op, int_mode)\n+seth_add3_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       || GET_CODE (op) == LABEL_REF)\n@@ -608,13 +610,25 @@ seth_add3_operand (op, int_mode)\n   return 0;\n }\n \n+/* Return true if OP is a signed 8 bit immediate value.  */\n+\n+int\n+int8_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  return INT8_P (INTVAL (op));\n+}\n+\n /* Return true if OP is a signed 16 bit immediate value\n    useful in comparisons.  */\n \n int\n-cmp_int16_operand (op, int_mode)\n+cmp_int16_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -624,24 +638,22 @@ cmp_int16_operand (op, int_mode)\n /* Return true if OP is an unsigned 16 bit immediate value.  */\n \n int\n-uint16_operand (op, int_mode)\n+uint16_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n   return UINT16_P (INTVAL (op));\n }\n \n-/* Return true if OP is a register or signed 8 bit value.  */\n+/* Return true if OP is a register or signed 16 bit value.  */\n \n int\n-reg_or_int16_operand (op, int_mode)\n+reg_or_int16_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n-\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n@@ -652,28 +664,46 @@ reg_or_int16_operand (op, int_mode)\n /* Return true if OP is a register or an unsigned 16 bit value.  */\n \n int\n-reg_or_uint16_operand (op, int_mode)\n+reg_or_uint16_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n-\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n   return UINT16_P (INTVAL (op));\n }\n \n-/* Return true if OP is a register or signed 16 bit value for compares.  */\n+/* Return true if OP is a register or an integer value that can be\n+   used is SEQ/SNE.  We can use either XOR of the value or ADD of\n+   the negative of the value for the constant.  Don't allow 0,\n+   because that is special cased.  */\n \n int\n-reg_or_cmp_int16_operand (op, int_mode)\n+reg_or_eq_int16_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n+  HOST_WIDE_INT value;\n \n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  value = INTVAL (op);\n+  return (value != 0) && (UINT16_P (value) || CMP_INT16_P (-value));\n+}\n+\n+/* Return true if OP is a register or signed 16 bit value for compares.  */\n+\n+int\n+reg_or_cmp_int16_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n@@ -684,9 +714,9 @@ reg_or_cmp_int16_operand (op, int_mode)\n /* Return true if OP is a const_int requiring two instructions to load.  */\n \n int\n-two_insn_const_operand (op, int_mode)\n+two_insn_const_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -701,16 +731,15 @@ two_insn_const_operand (op, int_mode)\n    move source.  */\n \n int\n-move_src_operand (op, int_mode)\n+move_src_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF :\n     case CONST :\n-      return addr24_operand (op, int_mode);\n+      return addr24_operand (op, mode);\n     case CONST_INT :\n       /* ??? We allow more cse opportunities if we only allow constants\n \t loadable with one insn, and split the rest into two.  The instances\n@@ -743,6 +772,9 @@ move_src_operand (op, int_mode)\n       else\n \treturn register_operand (op, mode);\n     case MEM :\n+      if (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t  || GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+\treturn 0;\t\t/* loads can't do pre-{inc,dec} */\n       return address_operand (XEXP (op, 0), mode);\n     default :\n       return 0;\n@@ -753,11 +785,10 @@ move_src_operand (op, int_mode)\n    move source.  */\n \n int\n-move_double_src_operand (op, int_mode)\n+move_double_src_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case CONST_INT :\n@@ -769,7 +800,7 @@ move_double_src_operand (op, int_mode)\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a\n \t pseudo-reg and is now a stack slot.  */\n       if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn move_double_src_operand (SUBREG_REG (op), int_mode);\n+\treturn move_double_src_operand (SUBREG_REG (op), mode);\n       else\n \treturn register_operand (op, mode);\n     case MEM :\n@@ -786,11 +817,10 @@ move_double_src_operand (op, int_mode)\n /* Return true if OP is an acceptable argument for a move destination.  */\n \n int\n-move_dest_operand (op, int_mode)\n+move_dest_operand (op, mode)\n      rtx op;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case REG :\n@@ -803,6 +833,8 @@ move_dest_operand (op, int_mode)\n       else\n \treturn register_operand (op, mode);\n     case MEM :\n+      if (GET_CODE (XEXP (op, 0)) == POST_INC)\n+\treturn 0;\t\t/* stores can't do post inc */\n       return address_operand (XEXP (op, 0), mode);\n     default :\n       return 0;\n@@ -853,9 +885,9 @@ easy_df_const (op)\n /* Return 1 if OP is an EQ or NE comparison operator.  */\n \n int\n-eqne_comparison_operator (op, int_mode)\n+eqne_comparison_operator (op, mode)\n     rtx op;\n-    int int_mode ATTRIBUTE_UNUSED;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -867,9 +899,9 @@ eqne_comparison_operator (op, int_mode)\n /* Return 1 if OP is a signed comparison operator.  */\n \n int\n-signed_comparison_operator (op, int_mode)\n+signed_comparison_operator (op, mode)\n     rtx op;\n-    int int_mode ATTRIBUTE_UNUSED;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -883,20 +915,48 @@ signed_comparison_operator (op, int_mode)\n    This is used in insn length calcs.  */\n \n int\n-memreg_operand (op, int_mode)\n+memreg_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n }\n \n+/* Return true if OP is an acceptable input argument for a zero/sign extend\n+   operation.  */\n+\n+int\n+extend_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx addr;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+    case SUBREG :\n+      return register_operand (op, mode);\n+\n+    case MEM :\n+      addr = XEXP (op, 0);\n+      if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n+\treturn 0;\t\t/* loads can't do pre inc/pre dec */\n+\n+      return address_operand (addr, mode);\n+\n+    default :\n+      return 0;\n+    }\n+}\n+\n /* Return non-zero if the operand is an insn that is a small insn.\n    Allow const_int 0 as well, which is a placeholder for NOP slots.  */\n \n int\n-small_insn_p (op, int_mode)\n+small_insn_p (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n     return 1;\n@@ -910,9 +970,9 @@ small_insn_p (op, int_mode)\n /* Return non-zero if the operand is an insn that is a large insn.  */\n \n int\n-large_insn_p (op, int_mode)\n+large_insn_p (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_RTX_CLASS (GET_CODE (op)) != 'i')\n     return 0;\n@@ -932,13 +992,13 @@ m32r_select_cc_mode (op, x, y)\n      rtx x ATTRIBUTE_UNUSED;\n      rtx y ATTRIBUTE_UNUSED;\n {\n-  return (int)SImode;\n+  return (int) CCmode;\n }\n \n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for compare [arg0 of the if_then_else].\n    If need_compare is true then the comparison insn must be generated, rather\n-   than being susummed into the following branch instruction. */\n+   than being susummed into the following branch instruction.  */\n \n rtx\n gen_compare (code, x, y, need_compare)\n@@ -965,7 +1025,7 @@ gen_compare (code, x, y, need_compare)\n     case GEU: compare_code = LTU; branch_code = EQ; break;\n \n     default:\n-      abort();\n+      abort ();\n     }\n \n   if (need_compare)\n@@ -992,7 +1052,7 @@ gen_compare (code, x, y, need_compare)\n \t  if (register_operand (y, SImode) \t\t/* reg equal to reg.  */\n \t      || y == const0_rtx) \t   \t\t/* req equal to zero. */\n \t    {\n-\t\temit_insn (gen_cmp_eqsi_insn (x, y));\n+\t      emit_insn (gen_cmp_eqsi_insn (x, y));\n \t\t\n \t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n \t    }\n@@ -1031,7 +1091,7 @@ gen_compare (code, x, y, need_compare)\n \t\t  code = NE;\n \t\t  break;\n \t\tdefault:\n-\t\t  abort();\n+\t\t  abort ();\n \t\t}\n \t      \n \t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n@@ -1083,7 +1143,6 @@ gen_compare (code, x, y, need_compare)\n \t}\n     }\n   else\n-    if (! TARGET_OLD_COMPARE)\n     {\n       /* reg/reg equal comparison */\n       if (compare_code == EQ\n@@ -1280,13 +1339,12 @@ gen_split_move_double (operands)\n /* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n \n int\n-function_arg_partial_nregs (cum, int_mode, type, named)\n+function_arg_partial_nregs (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n-     int int_mode;\n+     enum machine_mode mode;\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n   int ret;\n   int size = (((mode == BLKmode && type)\n \t       ? int_size_in_bytes (type)\n@@ -1310,14 +1368,13 @@ function_arg_partial_nregs (cum, int_mode, type, named)\n    and mode MODE, and we rely on this fact.  */\n \n void\n-m32r_setup_incoming_varargs (cum, int_mode, type, pretend_size, no_rtl)\n+m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n      CUMULATIVE_ARGS *cum;\n-     int int_mode;\n+     enum machine_mode mode;\n      tree type;\n      int *pretend_size;\n      int no_rtl;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n   int first_anon_arg;\n \n   if (no_rtl)\n@@ -1353,6 +1410,7 @@ m32r_setup_incoming_varargs (cum, int_mode, type, pretend_size, no_rtl)\n     }\n }\n \n+\f\n /* Implement `va_arg'.  */\n \n rtx\n@@ -1415,6 +1473,218 @@ m32r_va_arg (valist, type)\n   return addr_rtx;\n }\n \f\n+int\n+m32r_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     rtx link ATTRIBUTE_UNUSED;\n+     rtx dep_insn ATTRIBUTE_UNUSED;\n+     int cost;\n+{\n+  return cost;\n+}\n+\n+\f\n+/* A C statement (sans semicolon) to update the integer scheduling\n+   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n+   the INSN earlier, increase the priority to execute INSN later.\n+   Do not define this macro if you do not need to adjust the\n+   scheduling priorities of insns.\n+\n+   On the m32r, increase the priority of long instructions so that\n+   the short instructions are scheduled ahead of the long ones.  */\n+\n+int\n+m32r_adjust_priority (insn, priority)\n+     rtx insn;\n+     int priority;\n+{\n+  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+    {\n+      enum rtx_code code = GET_CODE (PATTERN (insn));\n+      if (code != USE && code != CLOBBER && code != ADDR_VEC\n+\t  && get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n+\tpriority <<= 3;\n+    }\n+\n+  return priority;\n+}\n+\n+\f\n+/* Initialize for scheduling a group of instructions.  */\n+\n+void\n+m32r_sched_init (stream, verbose)\n+     FILE * stream ATTRIBUTE_UNUSED;\n+     int verbose ATTRIBUTE_UNUSED;\n+{\n+  m32r_sched_odd_word_p = FALSE;\n+}\n+\n+\f\n+/* Reorder the schedulers priority list if needed */\n+\n+void\n+m32r_sched_reorder (stream, verbose, ready, n_ready)\n+     FILE * stream;\n+     int verbose;\n+     rtx * ready;\n+     int n_ready;\n+{\n+  if (TARGET_DEBUG)\n+    return;\n+\n+  if (verbose <= 7)\n+    stream = (FILE *)0;\n+\n+  if (stream)\n+    fprintf (stream,\n+\t     \";;\\t\\t::: Looking at %d insn(s) on ready list, boundary is %s word\\n\",\n+\t     n_ready,\n+\t     (m32r_sched_odd_word_p) ? \"odd\" : \"even\");\n+\n+  if (n_ready > 1)\n+    {\n+      rtx * long_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * long_tail = long_head;\n+      rtx * short_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * short_tail = short_head;\n+      rtx * new_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * new_tail = new_head + (n_ready - 1);\n+      int   i;\n+\n+      /* Loop through the instructions, classifing them as short/long.  Try\n+\t to keep 2 short together and/or 1 long.  Note, the ready list is\n+\t actually ordered backwards, so keep it in that manner.  */\n+      for (i = n_ready-1; i >= 0; i--)\n+\t{\n+\t  rtx insn = ready[i];\n+\t  enum rtx_code code;\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n+\t      || (code = GET_CODE (PATTERN (insn))) == USE\n+\t      || code == CLOBBER || code == ADDR_VEC)\n+\t    {\n+\t      /* Dump all current short/long insns just in case */\n+\t      while (long_head != long_tail)\n+\t\t*new_tail-- = *long_head++;\n+\n+\t      while (short_head != short_tail)\n+\t\t*new_tail-- = *short_head++;\n+\n+\t      *new_tail-- = insn;\n+\t      if (stream)\n+\t\tfprintf (stream,\n+\t\t\t \";;\\t\\t::: Skipping non instruction %d\\n\",\n+\t\t\t INSN_UID (insn));\n+\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n+\t\t*long_tail++ = insn;\n+\n+\t      else\n+\t\t*short_tail++ = insn;\n+\t    }\n+\t}\n+\n+      /* If we are on an odd word, emit a single short instruction if\n+\t we can */\n+      if (m32r_sched_odd_word_p && short_head != short_tail)\n+\t*new_tail-- = *short_head++;\n+\n+      /* Now dump out all of the long instructions */\n+      while (long_head != long_tail)\n+\t*new_tail-- = *long_head++;\n+\n+      /* Now dump out all of the short instructions */\n+      while (short_head != short_tail)\n+\t*new_tail-- = *short_head++;\n+\n+      if (new_tail+1 != new_head)\n+\tabort ();\n+\n+      bcopy ((char *) new_head, (char *) ready, sizeof (rtx) * n_ready);\n+      if (stream)\n+\t{\n+#ifdef HAIFA\n+\t  fprintf (stream, \";;\\t\\t::: New ready list:               \");\n+\t  debug_ready_list (ready, n_ready);\n+#else\n+\t  int i;\n+\t  for (i = 0; i < n_ready; i++)\n+\t    {\n+\t      rtx insn = ready[i];\n+\t      enum rtx_code code;\n+\n+\t      fprintf (stream, \" %d\", INSN_UID (ready[i]));\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n+\t\t  || (code = GET_CODE (PATTERN (insn))) == USE\n+\t\t  || code == CLOBBER || code == ADDR_VEC)\n+\t\tfputs (\"(?)\", stream);\n+\n+\t      else if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n+\t\tfputs (\"(l)\", stream);\n+\n+\t      else\n+\t\tfputs (\"(s)\", stream);\n+\t    }\n+\n+\t  fprintf (stream, \"\\n\");\n+#endif\n+\t}\n+    }\n+}\n+\n+\f\n+/* If we have a machine that can issue a variable # of instructions\n+   per cycle, indicate how many more instructions can be issued\n+   after the current one.  */\n+int\n+m32r_sched_variable_issue (stream, verbose, insn, how_many)\n+     FILE * stream;\n+     int verbose;\n+     rtx insn;\n+     int how_many;\n+{\n+  int orig_odd_word_p = m32r_sched_odd_word_p;\n+  int short_p = FALSE;\n+\n+  how_many--;\n+  if (how_many > 0 && !TARGET_DEBUG)\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\thow_many++;\n+\n+      else if (GET_CODE (PATTERN (insn)) == USE\n+\t       || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t       || GET_CODE (PATTERN (insn)) == ADDR_VEC)\n+\thow_many++;\n+\n+      else if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n+\t{\n+\t  how_many = 0;\n+\t  m32r_sched_odd_word_p = 0;\n+\t}\n+      else\n+\t{\n+\t  m32r_sched_odd_word_p = !m32r_sched_odd_word_p;\n+\t  short_p = TRUE;\n+\t}\n+    }\n+\n+  if (verbose > 7 && stream)\n+    fprintf (stream,\n+\t     \";;\\t\\t::: %s insn %d starts on an %s word, can emit %d more instruction(s)\\n\",\n+\t     short_p ? \"short\" : \"long\",\n+\t     INSN_UID (insn),\n+\t     orig_odd_word_p ? \"odd\" : \"even\",\n+\t     how_many);\n+\n+  return how_many;\n+}\n+\f\n /* Cost functions.  */\n \n /* Provide the costs of an addressing mode that contains ADDR.\n@@ -1638,7 +1908,7 @@ m32r_expand_prologue ()\n {\n   int regno;\n   int frame_size;\n-  unsigned int gmask = current_frame_info.gmask;\n+  unsigned int gmask;\n \n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n@@ -1848,6 +2118,22 @@ m32r_output_function_epilogue (file, size)\n   current_frame_info = zero_frame_info;\n   m32r_compute_function_type (NULL_TREE);\n }\n+\f\n+/* Return non-zero if this function is known to have a null or 1 instruction\n+   epilogue.  */\n+\n+int\n+direct_return ()\n+{\n+  if (!reload_completed)\n+    return FALSE;\n+\n+  if (! current_frame_info.initialized)\n+    m32r_compute_frame_size (get_frame_size ());\n+\n+  return current_frame_info.total_size == 0;\n+}\n+\n \f\n /* PIC */\n \n@@ -1968,7 +2254,7 @@ m32r_print_operand (file, x, code)\n \n \tif (GET_CODE (x) != CONST_DOUBLE\n \t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT)\n-\t  abort ();\n+\t  fatal_insn (\"Bad insn for 'A'\", x);\n \tREAL_VALUE_FROM_CONST_DOUBLE (d, x);\n \tREAL_VALUE_TO_DECIMAL (d, \"%.20e\", str);\n \tfprintf (file, \"%s\", str);\n@@ -2088,21 +2374,21 @@ m32r_print_operand (file, x, code)\n       if (GET_CODE (addr) == PRE_INC)\n \t{\n \t  if (GET_CODE (XEXP (addr, 0)) != REG)\n-\t    abort ();\n+\t    fatal_insn (\"Pre-increment address is not a register\", x);\n \n \t  fprintf (file, \"@+%s\", reg_names[REGNO (XEXP (addr, 0))]);\n \t}\n       else if (GET_CODE (addr) == PRE_DEC)\n \t{\n \t  if (GET_CODE (XEXP (addr, 0)) != REG)\n-\t    abort ();\n+\t    fatal_insn (\"Pre-decrement address is not a register\", x);\n \n \t  fprintf (file, \"@-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n \t}\n       else if (GET_CODE (addr) == POST_INC)\n \t{\n \t  if (GET_CODE (XEXP (addr, 0)) != REG)\n-\t    abort ();\n+\t    fatal_insn (\"Post-increment address is not a register\", x);\n \n \t  fprintf (file, \"@%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n \t}\n@@ -2180,7 +2466,7 @@ m32r_print_operand_address (file, addr)\n \t      fputs (reg_names[REGNO (base)], file);\n \t    }\n \t  else\n-\t    abort ();\n+\t    fatal_insn (\"Bad address\", addr);\n \t}\n       else if (GET_CODE (base) == LO_SUM)\n \t{\n@@ -2196,12 +2482,12 @@ m32r_print_operand_address (file, addr)\n \t  fputs (reg_names[REGNO (XEXP (base, 0))], file);\n \t}\n       else\n-\tabort ();\n+\tfatal_insn (\"Bad address\", addr);\n       break;\n \n     case LO_SUM :\n       if (GET_CODE (XEXP (addr, 0)) != REG)\n-\tabort ();\n+\tfatal_insn (\"Lo_sum not of register\", addr);\n       if (small_data_operand (XEXP (addr, 1), VOIDmode))\n \tfputs (\"sda(\", file);\n       else\n@@ -2244,12 +2530,10 @@ zero_and_one (operand1, operand2)\n \n /* Return non-zero if the operand is suitable for use in a conditional move sequence.  */\n int\n-conditional_move_operand (operand, int_mode)\n+conditional_move_operand (operand, mode)\n      rtx operand;\n-     int int_mode;\n+     enum machine_mode mode;\n {\n-  enum machine_mode mode = (enum machine_mode)int_mode;\n-\n   /* Only defined for simple integers so far... */\n   if (mode != SImode && mode != HImode && mode != QImode)\n     return FALSE;\n@@ -2276,13 +2560,13 @@ conditional_move_operand (operand, int_mode)\n \n /* Return true if the code is a test of the carry bit */\n int\n-carry_compare_operand (op, int_mode)\n+carry_compare_operand (op, mode)\n      rtx op;\n-     int int_mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   rtx x;\n \n-  if (GET_MODE (op) != SImode && GET_MODE (op) != VOIDmode)\n+  if (GET_MODE (op) != CCmode && GET_MODE (op) != VOIDmode)\n     return FALSE;\n \n   if (GET_CODE (op) != NE && GET_CODE (op) != EQ)\n@@ -2299,7 +2583,6 @@ carry_compare_operand (op, int_mode)\n   return TRUE;\n }\n \n-\n /* Generate the correct assembler code to handle the conditional loading of a\n    value into a register.  It is known that the operands satisfy the\n    conditional_move_operand() function above.  The destination is operand[0].\n@@ -2341,6 +2624,30 @@ emit_cond_move (operands, insn)\n   return buffer;\n }\n \n+/* Returns true if the registers contained in the two\n+   rtl expressions are different. */\n+int\n+m32r_not_same_reg (a, b)\n+     rtx a;\n+     rtx b;\n+{\n+  int reg_a = -1;\n+  int reg_b = -2;\n+  \n+  while (GET_CODE (a) == SUBREG)\n+    a = SUBREG_REG (a);\n+  \n+  if (GET_CODE (a) == REG)\n+    reg_a = REGNO (a);\n+  \n+  while (GET_CODE (b) == SUBREG)\n+    b = SUBREG_REG (b);\n+  \n+  if (GET_CODE (b) == REG)\n+    reg_b = REGNO (b);\n+  \n+  return reg_a != reg_b;\n+}\n \n \f\n /* Use a library function to move some bytes.  */\n@@ -2600,7 +2907,7 @@ m32r_output_block_move (insn, operands)\n int\n m32r_block_immediate_operand (op, mode)\n      rtx op;\n-     int mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != CONST_INT\n       || INTVAL (op) > MAX_MOVE_BYTES"}, {"sha": "a19548622bd8989f43cf0dc4eb99376f67ffddb2", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 582, "deletions": 456, "changes": 1038, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=56e2e7627ef54dfc219481aa09b5367f00c79e47", "patch": "@@ -34,51 +34,101 @@ Boston, MA 02111-1307, USA.  */\n #undef WCHAR_TYPE_SIZE\n #undef ASM_FILE_START\n #undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#undef TARGET_VERSION\n+#undef CPP_SPEC\n+#undef ASM_SPEC\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+#undef SUBTARGET_SWITCHES\n \f\n /* Print subsidiary information on the compiler version in use.  */\n+#ifndef\tTARGET_VERSION\n #define TARGET_VERSION fprintf (stderr, \" (m32r)\")\n-\n+#endif\n \n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n-#undef SWITCH_TAKES_ARG\n+#undef  SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR) \\\n (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n /* Names to predefine in the preprocessor for this target machine.  */\n /* __M32R__ is defined by the existing compiler so we use that.  */\n #define CPP_PREDEFINES \"-Acpu(m32r) -Amachine(m32r) -D__M32R__\"\n \n+/* This macro defines names of additional specifications to put in the specs\n+   that can be used in various specifications like CC1_SPEC.  Its definition\n+   is an initializer with a subgrouping for each command option.\n \n-#define CC1_SPEC \"%{G*}\"\n+   Each subgrouping contains a string constant, that defines the\n+   specification name, and a string constant that used by the GNU CC driver\n+   program.\n \n-/* Options to pass on to the assembler.  */\n-#undef  ASM_SPEC\n-#define ASM_SPEC \"%{v}\"\n+   Do not define this macro if it does not need to do anything.  */\n \n-#if 0 /* not supported yet */\n-#undef  ASM_SPEC\n-#define ASM_SPEC \"%{v} %{mrelax:-relax}\"\n+#ifndef SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS\n #endif\n-     \n \n-#undef ASM_FINAL_SPEC\n+#ifndef\tASM_CPU_SPEC\n+#define\tASM_CPU_SPEC \"\"\n+#endif\n \n-#undef LINK_SPEC\n+#ifndef\tCPP_CPU_SPEC\n+#define\tCPP_CPU_SPEC \"\"\n+#endif\n+\n+#ifndef\tCC1_CPU_SPEC\n+#define\tCC1_CPU_SPEC \"\"\n+#endif\n+\n+#ifndef\tLINK_CPU_SPEC\n+#define\tLINK_CPU_SPEC \"\"\n+#endif\n+\n+#ifndef STARTFILE_CPU_SPEC\n+#define STARTFILE_CPU_SPEC \"%{!shared:crt0.o%s} crtinit.o%s\"\n+#endif\n+\n+#ifndef ENDFILE_CPU_SPEC\n+#define ENDFILE_CPU_SPEC \"-lgloss crtfini.o%s\"\n+#endif\n+\n+#ifndef RELAX_SPEC\n #if 0 /* not supported yet */\n-#define LINK_SPEC \"%{v} %{mrelax:-relax}\"\n+#define RELAX_SPEC \"%{mrelax:-relax}\"\n #else\n-#define LINK_SPEC \"%{v}\"\n+#define RELAX_SPEC \"\"\n+#endif\n #endif\n \n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crtinit.o%s\"\n+#define EXTRA_SPECS\t\t\t\t\t\t\t\\\n+  { \"asm_cpu\",\t\t\tASM_CPU_SPEC },\t\t\t\t\\\n+  { \"cpp_cpu\",\t\t\tCPP_CPU_SPEC },\t\t\t\t\\\n+  { \"cc1_cpu\",\t\t\tCC1_CPU_SPEC },\t\t\t\t\\\n+  { \"link_cpu\",\t\t\tLINK_CPU_SPEC },\t\t\t\\\n+  { \"startfile_cpu\",\t\tSTARTFILE_CPU_SPEC },\t\t\t\\\n+  { \"endfile_cpu\",\t\tENDFILE_CPU_SPEC },\t\t\t\\\n+  { \"relax\",\t\t\tRELAX_SPEC },\t\t\t\t\\\n+  SUBTARGET_EXTRA_SPECS\n \n+#define CC1_SPEC \"%{G*} %(cc1_cpu)\"\n \n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC \"-lgloss crtfini.o%s\"\n+/* Options to pass on to the assembler.  */\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"%{v} %(asm_cpu) %(relax)\"\n+\n+#undef  ASM_FINAL_SPEC\n+\n+#define LINK_SPEC \"%{v} %(link_cpu) %(relax)\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%(startfile_cpu)\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"%(endfile_cpu)\"\n \n-     \n #undef LIB_SPEC\n \f\n /* Run-time compilation parameters selecting different hardware subsets.  */\n@@ -91,76 +141,73 @@ extern int target_flags;\n    This can cause incorrect debugging information as line numbers may\n    turn out wrong.  This shouldn't be specified unless accompanied with -O2\n    [where the user expects debugging information to be less accurate].  */\n-#define TARGET_RELAX_MASK 1\n+#define TARGET_RELAX_MASK \t(1 << 0)\n \n /* For miscellaneous debugging purposes.  */\n-#define TARGET_DEBUG_MASK 2\n-#define TARGET_DEBUG (target_flags & TARGET_DEBUG_MASK)\n+#define TARGET_DEBUG_MASK \t(1 << 1)\n+#define TARGET_DEBUG \t\t(target_flags & TARGET_DEBUG_MASK)\n \n /* Align loops to 32 byte boundaries (cache line size).  */\n /* ??? This option is experimental and is not documented.  */\n-#define TARGET_ALIGN_LOOPS_MASK 4\n-#define TARGET_ALIGN_LOOPS (target_flags & TARGET_ALIGN_LOOPS_MASK)\n+#define TARGET_ALIGN_LOOPS_MASK (1 << 2)\n+#define TARGET_ALIGN_LOOPS \t(target_flags & TARGET_ALIGN_LOOPS_MASK)\n \n-/* Use old compare/branch support (kept around for awhile for\n-   comparison and backoff purposes).  */\n-/* ??? This option is experimental and is not documented.\n-   Eventually it will be deleted.  */\n-#define TARGET_OLD_COMPARE_MASK 8\n-#define TARGET_OLD_COMPARE (target_flags & TARGET_OLD_COMPARE_MASK)\n+/* Change issue rate.  */\n+#define TARGET_ISSUE_RATE_MASK\t(1 << 3)\n+#define TARGET_ISSUE_RATE\t(target_flags & TARGET_ISSUE_RATE_MASK)\n \n-/* Target machine to compile for.  */\n-#define TARGET_M32R 1\n+/* Change branch cost */\n+#define TARGET_BRANCH_COST_MASK\t(1 << 4)\n+#define TARGET_BRANCH_COST\t(target_flags & TARGET_BRANCH_COST_MASK)\n \n+/* Target machine to compile for.  */\n+#define TARGET_M32R \t\t1\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n-#define TARGET_SWITCHES \\\n-{ \\\n-/*  { \"relax\",\t\t\tTARGET_RELAX_MASK },\t\t\t\\\n-    { \"no-relax\",\t\t-TARGET_RELAX_MASK },*/\t\t\t\\\n-    { \"debug\",\t\t\tTARGET_DEBUG_MASK },\t\t\t\\\n-    { \"align-loops\",\t\tTARGET_ALIGN_LOOPS_MASK },\t\t\\\n-    { \"no-align-loops\",\t\t-TARGET_ALIGN_LOOPS_MASK },\t\t\\\n-    { \"old-compare\",\t\tTARGET_OLD_COMPARE_MASK },\t\t\\\n-    { \"no-old-compare\",\t\t-TARGET_OLD_COMPARE_MASK },\t\t\\\n-    SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n-    { \"\", TARGET_DEFAULT }\t\t\t\t\t\t\\\n-}\n-\n-#define TARGET_DEFAULT (0)\n-\n+#ifndef SUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES\n+#endif\n \n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable. \n-   The variable, type `char *', is set to the variable part of the\n-   given option if the fixed part matches.  The actual option name\n-   is made by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n \n-\textern char *m88k_short_data;\n-\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+/*  { \"relax\",\t\t\tTARGET_RELAX_MASK, \"\" },\t\t\\\n+    { \"no-relax\",\t\t-TARGET_RELAX_MASK, \"\" },*/\t\t\\\n+    { \"debug\",\t\t\tTARGET_DEBUG_MASK, \t\t\t\\\n+\t\"Display compile time statistics\" },\t\t\t\t\\\n+    { \"align-loops\",\t\tTARGET_ALIGN_LOOPS_MASK, \t\t\\\n+\t\"Align all loops to 32 byte boundary\" },\t\t\t\\\n+    { \"no-align-loops\",\t\t-TARGET_ALIGN_LOOPS_MASK, \"\" },\t\t\\\n+    { \"issue-rate=1\",\t\tTARGET_ISSUE_RATE_MASK, \t\t\\\n+\t\"Only issue one instruction per cycle\" },\t\t\t\\\n+    { \"issue-rate=2\",\t\t-TARGET_ISSUE_RATE_MASK, \"\" },\t\t\\\n+    { \"branch-cost=1\",\t\tTARGET_BRANCH_COST_MASK, \t\t\\\n+\t\"Prefer branches over conditional execution\" },\t\t\t\\\n+    { \"branch-cost=2\",\t\t-TARGET_BRANCH_COST_MASK, \"\" },\t\t\\\n+    SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n+    { \"\", TARGET_DEFAULT, \"\" }\t\t\t\t\t\t\\\n+}\n \n-extern char *m32r_model_string;\n-extern char *m32r_sdata_string;\n+extern const char * m32r_model_string;\n+extern const char * m32r_sdata_string;\n \n+#ifndef SUBTARGET_OPTIONS\n+#define SUBTARGET_OPTIONS\n+#endif\n \n-#define TARGET_OPTIONS \\\n-{\t\t\t\t\t\t\\\n-  { \"model=\",\t&m32r_model_string\t},\t\\\n-  { \"sdata=\",\t&m32r_sdata_string\t},\t\\\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"model=\", & m32r_model_string, \"Code size: small, medium or large\" },\\\n+  { \"sdata=\", & m32r_sdata_string, \"Small data area: none, sdata, use\" } \\\n+  SUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n }\n \n /* Code Models\n@@ -196,7 +243,9 @@ extern enum m32r_model m32r_model;\n #define TARGET_CALL32 (m32r_model == M32R_MODEL_LARGE)\n \n /* The default is the small model.  */\n+#ifndef M32R_MODEL_DEFAULT\n #define M32R_MODEL_DEFAULT \"small\"\n+#endif\n \n /* Small Data Area\n \n@@ -232,7 +281,9 @@ extern enum m32r_model m32r_model;\n \n /* Maximum size of variables that go in .sdata/.sbss.\n    The -msdata=foo switch also controls how small variables are handled.  */\n+#ifndef SDATA_DEFAULT_SIZE\n #define SDATA_DEFAULT_SIZE 8\n+#endif\n \n extern int g_switch_value;\t\t/* value of the -G xx switch */\n extern int g_switch_set;\t\t/* whether -G xx was passed.  */\n@@ -246,13 +297,21 @@ extern enum m32r_sdata m32r_sdata;\n \n /* Default is to disable the SDA\n    [for upward compatibility with previous toolchains].  */\n+#ifndef M32R_SDATA_DEFAULT\n #define M32R_SDATA_DEFAULT \"none\"\n+#endif\n \n /* Define this macro as a C expression for the initializer of an array of\n    strings to tell the driver program which options are defaults for this\n    target and thus do not need to be handled specially when using\n    `MULTILIB_OPTIONS'.  */\n-#define MULTILIB_DEFAULTS { \"mmodel=small\", \"m32r\" }\n+#ifndef SUBTARGET_MULTILIB_DEFAULTS\n+#define SUBTARGET_MULTILIB_DEFAULTS\n+#endif\n+\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS { \"mmodel=small\" SUBTARGET_MULTILIB_DEFAULTS }\n+#endif\n \n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -263,11 +322,39 @@ extern enum m32r_sdata m32r_sdata;\n    Don't use this macro to turn on various extra optimizations for\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n-#define OVERRIDE_OPTIONS \\\n-do {\t\t\t\t\\\n-  /* These need to be done at start up.  It's convenient to do them here.  */ \\\n-  m32r_init ();\t\t\t\\\n-} while (0)\n+#ifndef SUBTARGET_OVERRIDE_OPTIONS\n+#define SUBTARGET_OVERRIDE_OPTIONS\n+#endif\n+\n+#define OVERRIDE_OPTIONS\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      /* These need to be done at start up.\t\\\n+\t It's convenient to do them here.  */\t\\\n+      m32r_init ();\t\t\t\t\\\n+      SUBTARGET_OVERRIDE_OPTIONS\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#ifndef SUBTARGET_OPTIMIZATION_OPTIONS\n+#define SUBTARGET_OPTIMIZATION_OPTIONS\n+#endif\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (LEVEL == 1)\t\t\t\t\\\n+\tflag_regmove = TRUE;\t\t\t\\\n+      \t\t\t\t\t\t\\\n+      if (SIZE)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  flag_omit_frame_pointer = TRUE;\t\\\n+\t  flag_strength_reduce = FALSE;\t\t\\\n+\t}\t\t\t\t\t\\\n+      \t\t\t\t\t\t\\\n+      SUBTARGET_OPTIMIZATION_OPTIONS\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* Define this macro if debugging can be performed even without a\n    frame pointer.  If this macro is defined, GNU CC will turn on the\n@@ -314,12 +401,12 @@ do {\t\t\t\t\\\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.  */\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE) \\\n-if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-    && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n-{\t\t\t\t\t\t\\\n-  (MODE) = SImode;\t\t\t\t\\\n-}\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+    {\t\t\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n+    }\n \n /* Define this macro if the promotion described by `PROMOTE_MODE'\n    should also be done for outgoing function arguments.  */\n@@ -362,15 +449,15 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n #define FASTEST_ALIGNMENT 32\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\\\n   ((TREE_CODE (EXP) == STRING_CST\t\\\n     && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n    ? FASTEST_ALIGNMENT : (ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\t\t\t\\\n    && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n \n /* Set this nonzero if move instructions will actually fail to work\n@@ -411,7 +498,14 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 18\n+\n+#define M32R_NUM_REGISTERS \t19\n+\n+#ifndef SUBTARGET_NUM_REGISTERS\n+#define SUBTARGET_NUM_REGISTERS 0\n+#endif\n+\n+#define FIRST_PSEUDO_REGISTER (M32R_NUM_REGISTERS + SUBTARGET_NUM_REGISTERS)\n \t\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -427,15 +521,21 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    15    - stack pointer\n    16    - arg pointer\n    17    - carry flag\n+   18\t - accumulator\n \n-   \n    By default, the extension registers are not available.  */\n \n-#define FIXED_REGISTERS \\\n-{ 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n-  1, 1 }\n+#ifndef SUBTARGET_FIXED_REGISTERS\n+#define SUBTARGET_FIXED_REGISTERS\n+#endif\n \n+#define FIXED_REGISTERS\t\t\\\n+{\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n+  1, 1, 1\t\t\t\\\n+  SUBTARGET_FIXED_REGISTERS\t\\\n+}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -444,11 +544,17 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#define CALL_USED_REGISTERS \\\n-{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-  1, 1 }\n+#ifndef SUBTARGET_CALL_USED_REGISTERS\n+#define SUBTARGET_CALL_USED_REGISTERS\n+#endif\n \n+#define CALL_USED_REGISTERS\t\\\n+{\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+  1, 1, 1\t\t\t\\\n+  SUBTARGET_CALL_USED_REGISTERS\t\\\n+}\n \n /* Zero or more C statements that may conditionally modify two variables\n    `fixed_regs' and `call_used_regs' (both of type `char []') after they\n@@ -459,17 +565,33 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n \n    You need not define this macro if it has no work to do.  */\n \n-/*#define CONDITIONAL_REGISTER_USAGE*/\n+#ifdef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#define CONDITIONAL_REGISTER_USAGE SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#endif\n \n /* If defined, an initializer for a vector of integers, containing the\n    numbers of hard registers in the order in which GNU CC should\n    prefer to use them (from most preferred to least).  */\n+\n+#ifndef SUBTARGET_REG_ALLOC_ORDER\n+#define SUBTARGET_REG_ALLOC_ORDER\n+#endif\n+\n #if 1 /* better for int code */\n-#define REG_ALLOC_ORDER \\\n-{ 4, 5, 6, 7, 2, 3, 8, 9, 10, 11, 12, 13, 14, 0, 1, 15, 16, 17 }\n+#define REG_ALLOC_ORDER\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  4,  5,  6,  7,  2,  3,  8,  9, 10,\t\t\\\n+  11, 12, 13, 14,  0,  1, 15, 16, 17, 18\t\\\n+  SUBTARGET_REG_ALLOC_ORDER\t\t\t\\\n+}\n+\n #else /* better for fp code at expense of int code */\n-#define REG_ALLOC_ORDER \\\n-{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 }\n+#define REG_ALLOC_ORDER\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+   0,  1,  2,  3,  4,  5,  6,  7,  8,\t\t\\\n+   9, 10, 11, 12, 13, 14, 15, 16, 17, 18\t\\\n+  SUBTARGET_REG_ALLOC_ORDER\t\t\t\\\n+}\n #endif\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -525,38 +647,61 @@ extern unsigned int m32r_mode_class[];\n    It is important that any condition codes have class NO_REGS.\n    See `register_operand'.  */\n \n-enum reg_class {\n-  NO_REGS, CARRY_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+enum reg_class\n+{\n+  NO_REGS, CARRY_REG, ACCUM_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n /* Give names of register classes as strings for dump file.   */\n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"CARRY_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+  { \"NO_REGS\", \"CARRY_REG\", \"ACCUM_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS \\\n-{ {0}, {0x20000}, {0x1ffff}, {0x3ffff} }\n+#ifndef SUBTARGET_REG_CLASS_CARRY\n+#define SUBTARGET_REG_CLASS_CARRY 0\n+#endif\n+\n+#ifndef SUBTARGET_REG_CLASS_ACCUM\n+#define SUBTARGET_REG_CLASS_ACCUM 0\n+#endif\n+\n+#ifndef SUBTARGET_REG_CLASS_GENERAL\n+#define SUBTARGET_REG_CLASS_GENERAL 0\n+#endif\n+\n+#ifndef SUBTARGET_REG_CLASS_ALL\n+#define SUBTARGET_REG_CLASS_ALL 0\n+#endif\n \n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000 },\t\t\t\t\t\t\t\t\\\n+  { 0x20000 | SUBTARGET_REG_CLASS_CARRY },\t\t\t\t\\\n+  { 0x40000 | SUBTARGET_REG_CLASS_ACCUM },\t\t\t\t\\\n+  { 0x1ffff | SUBTARGET_REG_CLASS_GENERAL },\t\t\t\t\\\n+  { 0x7ffff | SUBTARGET_REG_CLASS_ALL },\t\t\t\t\\\n+}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n-#define REGNO_REG_CLASS(REGNO) \\\n-(m32r_regno_reg_class[REGNO])\n+#define REGNO_REG_CLASS(REGNO) (m32r_regno_reg_class[REGNO])\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n+((C) == 'c'\t? CARRY_REG\t\t\t\t\t\t\\\n+ : (C) == 'a'\t? ACCUM_REGS\t\t\t\t\t\t\\\n+ :\t\t  NO_REGS)\n \n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n@@ -596,15 +741,20 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    'P' is used for 16 bit signed immediates for compares\n        (values in the range -32767 to +32768).  */\n \n-/* local to this file */\n+/* Return true if a value is inside a range.  */\n+#define IN_RANGE_P(VALUE, LOW, HIGH)\t\t\t\t\t\\\n+  (((unsigned HOST_WIDE_INT)((VALUE) - (LOW)))\t\t\t\t\\\n+   <= ((unsigned HOST_WIDE_INT)((HIGH) - (LOW))))\n+\n+/* Local to this file.  */\n #define INT8_P(X) ((X) >= -0x80 && (X) <= 0x7f)\n #define INT16_P(X) ((X) >= -0x8000 && (X) <= 0x7fff)\n #define CMP_INT16_P(X) ((X) >= -0x7fff && (X) <= 0x8000)\n-#define UINT16_P(X) ((X) >= 0 && (X) <= 0xffff)\n+#define UINT16_P(X) (((unsigned HOST_WIDE_INT)(X)) <= 0xffff)\n #define UPPER16_P(X) (((X) & 0xffff) == 0\t\t\t\t\\\n \t\t      && ((X) >> 16) >= -0x8000\t\t\t\t\\\n \t\t      && ((X) >> 16) <= 0x7fff)\n-#define UINT24_P(X) ((X) >= 0 && (X) < 0x1000000)\n+#define UINT24_P(X) (((unsigned HOST_WIDE_INT) (X)) < 0x1000000)\n #define INT32_P(X) (((X) >= -(HOST_WIDE_INT) 0x80000000\t\t\t\\\n \t\t     && (X) <= (HOST_WIDE_INT) 0x7fffffff)\t\t\\\n \t\t    || (unsigned HOST_WIDE_INT) (X) <= 0xffffffff)\n@@ -639,25 +789,23 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    be 0 regardless of VALUE.  */\n /* Q is for symbolic addresses loadable with ld24.\n    R is for symbolic addresses when ld24 can't be used.\n-   S is unused.\n+   S is for stores with pre {inc,dec}rement\n    T is for indirect of a pointer.\n-   U is for pushes and pops of the stack pointer.  */\n+   U is for loads with post increment.  */\n \n #define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\t\\\n-((C) == 'Q'\t\t\t\t\t\t\t\t\\\n- ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\t\t\\\n-    || addr24_operand (VALUE, VOIDmode))\t\t\t\t\\\n- : (C) == 'R'\t\t\t\t\t\t\t\t\\\n- ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\t\t\\\n-    || addr32_operand (VALUE, VOIDmode))\t\t\t\t\\\n- : (C) == 'S'\t\t\t\t\t\t\t\t\\\n- ? 0\t\t\t\t\t\t\t\t\t\\\n- : (C) == 'T'\t\t\t\t\t\t\t\t\\\n- ?  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n-     && memreg_operand (VALUE, GET_MODE (VALUE)))\t\t\t\\\n- : (C) == 'U'\t\t\t\t\t\t\t\t\\\n- ?  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n-     && PUSH_POP_P (GET_MODE (VALUE), XEXP (VALUE, 0)))\t\t\t\\\n+(  (C) == 'Q' ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\\\n+\t\t || addr24_operand (VALUE, VOIDmode))\t\t\t\\\n+ : (C) == 'R' ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\\\n+\t\t || addr32_operand (VALUE, VOIDmode))\t\t\t\\\n+ : (C) == 'S' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+\t\t && STORE_PREINC_PREDEC_P (GET_MODE (VALUE),\t\t\\\n+\t\t\t\t\t   XEXP (VALUE, 0)))\t\t\\\n+ : (C) == 'T' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+\t\t && memreg_operand (VALUE, GET_MODE (VALUE)))\t\t\\\n+ : (C) == 'U' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+\t\t && LOAD_POSTINC_P (GET_MODE (VALUE),\t\t\t\\\n+\t\t\t\t    XEXP (VALUE, 0)))\t\t\t\\\n  : 0)\n \f\n /* Stack layout and stack pointer usage.  */\n@@ -745,18 +893,31 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n #define RETURN_ADDR_REGNUM 14\n /* #define GP_REGNUM 12 */\n #define CARRY_REGNUM 17\n+#define ACCUM_REGNUM 18\n #define M32R_MAX_INT_REGS 16\n \n-     \n-#define GPR_P(REGNO) ((unsigned) (REGNO) < M32R_MAX_INT_REGS)\n+#ifndef SUBTARGET_GPR_P\n+#define SUBTARGET_GPR_P(REGNO) 0\n+#endif\n+\n+#ifndef SUBTARGET_ACCUM_P\n+#define SUBTARGET_ACCUM_P(REGNO) 0\n+#endif\n+\n+#ifndef SUBTARGET_CARRY_P\n+#define SUBTARGET_CARRY_P(REGNO) 0\n+#endif\n+\n+#define GPR_P(REGNO)   (IN_RANGE_P ((REGNO), 0, 15) || SUBTARGET_GPR_P (REGNO))\n+#define ACCUM_P(REGNO) ((REGNO) == ACCUM_REGNUM || SUBTARGET_ACCUM_P (REGNO))\n+#define CARRY_P(REGNO) ((REGNO) == CARRY_REGNUM || SUBTARGET_CARRY_P (REGNO))\n \f\n /* Eliminating the frame and arg pointers.  */\n \n /* A C expression which is nonzero if a function must have and use a\n    frame pointer.  This expression is evaluated in the reload pass.\n    If its value is nonzero the function will have a frame pointer.  */\n-#define FRAME_POINTER_REQUIRED \\\n-(current_function_calls_alloca)\n+#define FRAME_POINTER_REQUIRED current_function_calls_alloca\n \n #if 0\n /* C statement to store the difference between the frame pointer\n@@ -776,10 +937,10 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    Note that the elimination of the argument pointer with the stack\n    pointer is specified first since that is the preferred elimination.  */\n \n-#define ELIMINABLE_REGS \\\n-{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\t\\\n- { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\t\t\\\n- { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}\t\t\t\\\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,\t STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM }}\n \n /* A C expression that returns non-zero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n@@ -788,10 +949,10 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    cases preventing register elimination are things that the compiler\n    already knows about.  */\n \n-#define CAN_ELIMINATE(FROM, TO) \\\n-((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n- ? ! frame_pointer_needed\t\t\t\t\t\t\\\n- : 1)\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+  ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n+   ? ! frame_pointer_needed\t\t\t\t\t\t\\\n+   : 1)\n \n /* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n    specifies the initial difference between the specified pair of\n@@ -837,7 +998,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    which.  */\n #if 0\n #define REG_PARM_STACK_SPACE(FNDECL) \\\n-(M32R_MAX_PARM_REGS * UNITS_PER_WORD)\n+  (M32R_MAX_PARM_REGS * UNITS_PER_WORD)\n #endif\n \n /* Value is the number of bytes of arguments automatically\n@@ -849,7 +1010,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n #define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0\n \n /* Nonzero if we do not know how to pass TYPE solely in registers. */\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n+#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\\\n   ((TYPE) != 0\t\t\t\t\t\t\\\n    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n        || TREE_ADDRESSABLE (TYPE)))\n@@ -864,26 +1025,26 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n-((CUM) = 0)\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+  ((CUM) = 0)\n \n /* The number of registers used for parameter passing.  Local to this file.  */\n #define M32R_MAX_PARM_REGS 4\n \n /* 1 if N is a possible register number for function argument passing.  */\n #define FUNCTION_ARG_REGNO_P(N) \\\n-((unsigned) (N) < M32R_MAX_PARM_REGS)\n+  ((unsigned) (N) < M32R_MAX_PARM_REGS)\n \n /* The ROUND_ADVANCE* macros are local to this file.  */\n /* Round SIZE up to a word boundary.  */\n #define ROUND_ADVANCE(SIZE) \\\n-(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Round arg MODE/TYPE up to the next word boundary.  */\n #define ROUND_ADVANCE_ARG(MODE, TYPE) \\\n-((MODE) == BLKmode\t\t\t\t\\\n- ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n- : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n+  ((MODE) == BLKmode\t\t\t\t\\\n+   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n+   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n \n /* Round CUM up to the necessary point for argument MODE/TYPE.  */\n #if 0\n@@ -902,7 +1063,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    we're given).\n    This macro is only used in this file.  */\n #define PASS_IN_REG_P(CUM, MODE, TYPE, NAMED) \\\n-(ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) < M32R_MAX_PARM_REGS)\n+  (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) < M32R_MAX_PARM_REGS)\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -919,16 +1080,16 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n /* On the M32R the first M32R_MAX_PARM_REGS args are normally in registers\n    and the rest are pushed.  */\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-(PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\t\\\n- ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n- : 0)\n+  (PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\\\n+   ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+   : 0)\n \n /* ??? Quick hack to try to get varargs working the normal way.  */\n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n-(((! current_function_varargs || (NAMED))\t\t\t\t\\\n-  && PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED)))\t\t\t\\\n- ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n- : 0)\n+  (((! current_function_varargs || (NAMED))\t\t\t\t\\\n+    && PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED)))\t\t\t\\\n+   ? gen_rtx_REG ((MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+   : 0)\n \n /* A C expression for the number of words, at the beginning of an\n    argument, must be put in registers.  The value must be zero for\n@@ -953,13 +1114,13 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    appropriate for passing a pointer to that type.  */\n /* All arguments greater than 8 bytes are passed this way.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n-((TYPE) && int_size_in_bytes (TYPE) > 8)\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n-((CUM) = (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) \\\n+  ((CUM) = (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) \\\n \t  + ROUND_ADVANCE_ARG ((MODE), (TYPE))))\n \n /* If defined, a C expression that gives the alignment boundary, in bits,\n@@ -1001,7 +1162,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    this case.  */\n \n #define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_SIZE, NO_RTL) \\\n-m32r_setup_incoming_varargs (&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+ m32r_setup_incoming_varargs (&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n \n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n@@ -1118,11 +1279,9 @@ do { \\\n \n /* We have post-inc load and pre-dec,pre-inc store,\n    but only for 4 byte vals.  */\n-#if 0\n #define HAVE_PRE_DECREMENT 1\n #define HAVE_PRE_INCREMENT 1\n #define HAVE_POST_INCREMENT 1\n-#endif\n \n /* Recognize any constant value that is a valid address.  */\n #define CONSTANT_ADDRESS_P(X) \\\n@@ -1135,11 +1294,11 @@ do { \\\n    We allow all CONST_DOUBLE's as the md file patterns will force the\n    constant to memory if they can't handle them.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) \\\n-(! (GET_CODE (X) == CONST \\\n-    && GET_CODE (XEXP (X, 0)) == PLUS \\\n-    && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF \\\n-    && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT \\\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n+(! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+    && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n+    && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\t\\\n+    && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n     && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -1166,7 +1325,7 @@ do { \\\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n+#define REG_OK_FOR_BASE_P(X)\t\t\\\n (GPR_P (REGNO (X))\t\t\t\\\n  || (REGNO (X)) == ARG_POINTER_REGNUM\t\\\n  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n@@ -1181,21 +1340,20 @@ do { \\\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.  */\n \n-/* local to this file */\n-#define RTX_OK_FOR_BASE_P(X) \\\n-(REG_P (X) && REG_OK_FOR_BASE_P (X))\n+/* Local to this file.  */\n+#define RTX_OK_FOR_BASE_P(X) (REG_P (X) && REG_OK_FOR_BASE_P (X))\n \n-/* local to this file */\n+/* Local to this file.  */\n #define RTX_OK_FOR_OFFSET_P(X) \\\n (GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n \n-/* local to this file */\n+/* Local to this file.  */\n #define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\t\\\n (GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n  && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n  && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n \n-/* local to this file */\n+/* Local to this file.  */\n /* For LO_SUM addresses, do not allow them if the MODE is > 1 word,\n    since more than one instruction will be required.  */\n #define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\t\t\\\n@@ -1204,13 +1362,21 @@ do { \\\n  && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n  && CONSTANT_P (XEXP (X, 1)))\n \n-/* local to this file */\n-/* Memory address that is a push/pop of the stack pointer.  */\n-#define PUSH_POP_P(MODE, X)\t\t\t\t\t\t\\\n-((MODE) == SImode\t\t\t\t\t\t\t\\\n- && (GET_CODE (X) == POST_INC\t\t\t\t\t\t\\\n-     || GET_CODE (X) == PRE_INC\t\t\t\t\t\t\\\n-     || GET_CODE (X) == PRE_DEC))\n+/* Local to this file.  */\n+/* Is this a load and increment operation.  */\n+#define LOAD_POSTINC_P(MODE, X)\t\t\t\t\t\t\\\n+(((MODE) == SImode || (MODE) == SFmode)\t\t\t\t\t\\\n+ && GET_CODE (X) == POST_INC\t\t\t\t\t\t\\\n+ && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n+\n+/* Local to this file.  */\n+/* Is this a increment/decrement and store operation.  */\n+#define STORE_PREINC_PREDEC_P(MODE, X)\t\t\t\t\t\\\n+(((MODE) == SImode || (MODE) == SFmode)\t\t\t\t\t\\\n+ && (GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC)\t\t\\\n+ && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n { if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\t\t\\\n@@ -1219,7 +1385,9 @@ do { \\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n   if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (PUSH_POP_P ((MODE), (X)))\t\t\t\t\t\t\\\n+  if (LOAD_POSTINC_P ((MODE), (X)))\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (STORE_PREINC_PREDEC_P ((MODE), (X)))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\t\t\\\n }\n \n@@ -1277,7 +1445,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    return it with a return statement.  Otherwise, break from the switch.  */\n /* Small integers are as cheap as registers.  4 byte values can be fetched\n    as immediate constants - let's give that the cost of an extra insn.  */\n-#define CONST_COSTS(X, CODE, OUTER_CODE) \\\n+#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n   case CONST_INT :\t\t\t\t\t\t\\\n     if (INT16_P (INTVAL (X)))\t\t\t\t\t\\\n       return 0;\t\t\t\t\t\t\t\\\n@@ -1311,22 +1479,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A value of 2 here causes GCC to avoid using branches in comparisons like\n    while (a < N && a).  Branches aren't that expensive on the M32R so\n    we define this as 1.  Defining it as 2 had a heavy hit in fp-bit.c.  */\n-#define BRANCH_COST 1\n+#define BRANCH_COST ((TARGET_BRANCH_COST) ? 2 : 1)\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  The purpose for the cost of MULT is to encourage\n    `synth_mult' to find a synthetic multiply when reasonable.\n \n    If we need more than 12 insns to do a multiply, then go out-of-line,\n    since the call overhead will be < 10% of the cost of the multiply.  */\n-#define RTX_COSTS(X, CODE, OUTER_CODE) \\\n-  case MULT :\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (3);\t\t\t\t\\\n-  case DIV :\t\t\t\t\t\t\\\n-  case UDIV :\t\t\t\t\t\t\\\n-  case MOD :\t\t\t\t\t\t\\\n-  case UMOD :\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (10);\t\t\t\t\\\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\\\n+  case MULT :\t\t\t\t\\\n+    return COSTS_N_INSNS (3);\t\t\\\n+  case DIV :\t\t\t\t\\\n+  case UDIV :\t\t\t\t\\\n+  case MOD :\t\t\t\t\\\n+  case UMOD :\t\t\t\t\\\n+    return COSTS_N_INSNS (10);\n \n /* Nonzero if access to memory by bytes is slow and undesirable.\n    For RISC chips, it means that access to memory by bytes is no\n@@ -1343,28 +1511,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n    register.  */\n #define NO_RECURSIVE_FUNCTION_CSE\n \n-/* Enable the register move pass.\n-   This is useful for machines with only 2 address instructions.\n-   It's not currently enabled by default because on the stanford benchmarks\n-   the improvement wasn't significant and in a couple of cases caused a\n-   significant de-optimization.  */\n-/* #define ENABLE_REGMOVE_PASS */\n-\n /* A C statement (sans semicolon) to update the integer variable COST based on\n    the relationship between INSN that is dependent on DEP_INSN through the\n    dependence LINK.  The default is to make no adjustment to COST.  This can be\n    used for example to specify to the scheduler that an output- or\n    anti-dependence does not incur the same cost as a data-dependence.  */\n \n-/* #define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n-  (COST) = m32r_adjust_cost (INSN, LINK, DEP_INSN, COST) */\n+#define ADJUST_COST(INSN,LINK,DEP_INSN,COST) \\\n+  (COST) = m32r_adjust_cost (INSN, LINK, DEP_INSN, COST)\n \n /* A C statement (sans semicolon) to update the integer scheduling\n    priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n    the INSN earlier, increase the priority to execute INSN later.\n    Do not define this macro if you do not need to adjust the\n    scheduling priorities of insns.  */\n-/* #define ADJUST_PRIORITY (INSN) */\n+#define ADJUST_PRIORITY(INSN) \\\n+  INSN_PRIORITY (INSN) = m32r_adjust_priority (INSN, INSN_PRIORITY (INSN))\n \n /* Macro to determine whether the Haifa scheduler is used.  */\n #ifdef HAIFA\n@@ -1374,10 +1536,32 @@ do {\t\t\t\t\t\t\t\t\t\\\n #endif\n \n /* Indicate how many instructions can be issued at the same time.\n-   This is 1/2 of a lie.  The m32r can issue only 1 long insn at\n-   once, but 2.  However doing so allows the scheduler to group\n-   the two short insns together.  */\n-#define ISSUE_RATE 2\n+   This is sort of a lie.  The m32r can issue only 1 long insn at\n+   once, but it can issue 2 short insns.  The default therefore is\n+   set at 2, but this can be overridden by the command line option\n+   -missue-rate=1 */\n+#define ISSUE_RATE ((TARGET_ISSUE_RATE) ? 1 : 2)\n+\n+/* If we have a machine that can issue a variable # of instructions\n+   per cycle, indicate how many more instructions can be issued\n+   after the current one.  */\n+#define MD_SCHED_VARIABLE_ISSUE(STREAM, VERBOSE, INSN, HOW_MANY)\t\\\n+(HOW_MANY) = m32r_sched_variable_issue (STREAM, VERBOSE, INSN, HOW_MANY)\n+\n+/* Whether we are on an odd word boundary while scheduling.  */\n+extern int m32r_sched_odd_word_p;\n+\n+/* Hook to run before scheduling a block of insns.  */\n+#define MD_SCHED_INIT(STREAM, VERBOSE) m32r_sched_init (STREAM, VERBOSE)\n+\n+/* Hook to reorder the list of ready instructions.  */\n+#define MD_SCHED_REORDER(STREAM, VERBOSE, READY, N_READY, CLOCK, CIM) \t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      m32r_sched_reorder (STREAM, VERBOSE, READY, N_READY);\t\t\\\n+      CIM = issue_rate;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* When the `length' insn attribute is used, this macro specifies the\n    value to be assigned to the address of the first insn in a\n@@ -1394,26 +1578,26 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define SDATA_SECTION_ASM_OP\t\"\\t.section .sdata\"\n #define SBSS_SECTION_ASM_OP\t\"\\t.section .sbss\"\n /* This one is for svr4.h.  */\n-#undef CONST_SECTION_ASM_OP\n+#undef  CONST_SECTION_ASM_OP\n #define CONST_SECTION_ASM_OP\t\"\\t.section .rodata\"\n \n /* A list of names for sections other than the standard two, which are\n    `in_text' and `in_data'.  You need not define this macro\n    on a system with no other sections (that GCC needs to use).  */\n-#undef EXTRA_SECTIONS\n+#undef  EXTRA_SECTIONS\n #define EXTRA_SECTIONS in_sdata, in_sbss, in_const, in_ctors, in_dtors\n \n /* One or more functions to be defined in \"varasm.c\".  These\n    functions should do jobs analogous to those of `text_section' and\n    `data_section', for your additional sections.  Do not define this\n    macro if you do not define `EXTRA_SECTIONS'.  */\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS \\\n-CONST_SECTION_FUNCTION \\\n-CTORS_SECTION_FUNCTION \\\n-DTORS_SECTION_FUNCTION \\\n-SDATA_SECTION_FUNCTION \\\n-SBSS_SECTION_FUNCTION\n+#undef  EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\\\n+  CONST_SECTION_FUNCTION\t\\\n+  CTORS_SECTION_FUNCTION\t\\\n+  DTORS_SECTION_FUNCTION\t\\\n+  SDATA_SECTION_FUNCTION\t\\\n+  SBSS_SECTION_FUNCTION\n \n #define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n@@ -1441,8 +1625,7 @@ sbss_section ()\t\t\t\t\t\t\t\t\\\n    output of EXP.  You can assume that EXP is either a `VAR_DECL' node\n    or a constant of some sort.  RELOC indicates whether the initial value\n    of EXP requires link-time relocations.  */\n-extern void m32r_select_section ();\n-#undef SELECT_SECTION\n+#undef  SELECT_SECTION\n #define SELECT_SECTION(EXP, RELOC) m32r_select_section ((EXP), (RELOC))\n \n /* A C statement or statements to switch to the appropriate section for\n@@ -1573,54 +1756,64 @@ do {\t\t\t\t\t\t\t\\\n #define ASM_APP_OFF \"\"\n \n /* This is how to output an assembler line defining a `char' constant.  */\n-#define ASM_OUTPUT_CHAR(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.byte\\t\");\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.byte\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an assembler line defining a `short' constant.  */\n-#define ASM_OUTPUT_SHORT(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.hword\\t\");\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.hword\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an assembler line defining an `int' constant.\n    We also handle symbol output here.  */\n-#define ASM_OUTPUT_INT(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t\");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n-#define ASM_OUTPUT_FLOAT(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\t\\\n-  long t;\t\t\t\t\t\t\\\n-  char str[30];\t\t\t\t\t\t\\\n-  REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n-  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n-  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\",\t\t\\\n-\t   t, ASM_COMMENT_START, str);\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      long t;\t\t\t\t\t\t\\\n+      char str[30];\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n+      fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\",\t\t\\\n+\t       t, ASM_COMMENT_START, str);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an assembler line defining a `double' constant.  */\n-#define ASM_OUTPUT_DOUBLE(FILE, VALUE) \\\n-do {\t\t\t\t\t\t\t\\\n-  long t[2];\t\t\t\t\t\t\\\n-  char str[30];\t\t\t\t\t\t\\\n-  REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n-  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n-  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\\t.word\\t0x%lx\\n\", \\\n-\t   t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      long t[2];\t\t\t\t\t\t\\\n+      char str[30];\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\\\n+      fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\\t.word\\t0x%lx\\n\",\t\\\n+\t       t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n-#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)\t\t\t\t\\\n   fprintf (FILE, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n \n /* The assembler's parentheses characters.  */\n@@ -1631,30 +1824,36 @@ do {\t\t\t\t\t\t\t\\\n    such as the label on a static function or variable NAME.  */\n /* On the M32R we need to ensure the next instruction starts on a 32 bit\n    boundary [the previous insn must either be 2 16 bit insns or 1 32 bit].  */\n-#define ASM_OUTPUT_LABEL(FILE, NAME) \\\n-do {\t\t\t\t\t\\\n-  assemble_name (FILE, NAME);\t\t\\\n-  fputs (\":\\n\", FILE);\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\\\n+      fputs (\":\\n\", FILE);\t\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n-#define ASM_GLOBALIZE_LABEL(FILE, NAME) \\\n-do {\t\t\t\t\\\n-  fputs (\"\\t.global\\t\", FILE);\t\\\n-  assemble_name (FILE, NAME);\t\\\n-  fputs (\"\\n\", FILE);\t\t\\\n-} while (0)\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      fputs (\"\\t.global\\t\", FILE);\t\\\n+      assemble_name (FILE, NAME);\t\\\n+      fputs (\"\\n\", FILE);\t\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n-#undef ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-do {\t\t\t\t\t\t\t\\\n-  const char * real_name;\t\t\t\t\\\n-  STRIP_NAME_ENCODING (real_name, (NAME));\t\t\\\n-  asm_fprintf (FILE, \"%U%s\", real_name);\t\t\\\n-} while (0)           \n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      const char * real_name;\t\t\t\\\n+      STRIP_NAME_ENCODING (real_name, (NAME));\t\\\n+      asm_fprintf (FILE, \"%U%s\", real_name);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)           \n \n /* If -Os, don't force line number labels to begin at the beginning of\n    the word; we still want the assembler to try to put things in parallel,\n@@ -1666,63 +1865,74 @@ do {\t\t\t\t\t\t\t\\\n \n #undef\tASM_OUTPUT_SOURCE_LINE\n #define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    static int sym_lineno = 1;\t\t\t\t\t\t\\\n-    fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n-\t     line, sym_lineno);\t\t\t\t\t\t\\\n-    assemble_name (file,\t\t\t\t\t\t\\\n-\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n-    fprintf (file,\t\t\t\t\t\t\t\\\n-\t     (optimize_size || TARGET_M32R)\t\t\t\t\\\n-\t     ? \"\\n\\t.debugsym .LM%d\\n\"\t\t\t\t\t\\\n-\t     : \"\\n.LM%d:\\n\",\t\t\t\t\t\t\\\n-\t     sym_lineno);\t\t\t\t\t\t\\\n-    sym_lineno += 1;\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static int sym_lineno = 1;\t\t\t\t\t\\\n+      fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n+\t       line, sym_lineno);\t\t\t\t\t\\\n+      assemble_name\t\t\t\t\t\t\t\\\n+\t(file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\t\\\n+      fprintf (file, (optimize_size || TARGET_M32R)\t\t\t\\\n+\t       ? \"\\n\\t.debugsym .LM%d\\n\"\t\t\t\t\\\n+\t       : \"\\n.LM%d:\\n\",\t\t\t\t\t\t\\\n+\t       sym_lineno);\t\t\t\t\t\t\\\n+      sym_lineno += 1;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n    LABELNO is an integer which is different for each call.  */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \\\n-do {\t\t\t\t\t\t\t\\\n-  (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO));\t\\\n-} while (0)\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\\\n+      sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO));\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n-#define REGISTER_NAMES \\\n+#ifndef SUBTARGET_REGISTER_NAMES\n+#define SUBTARGET_REGISTER_NAMES\n+#endif\n+\n+#define REGISTER_NAMES\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n   \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"fp\", \"lr\", \"sp\",\t\\\n-  \"ap\", \"cbit\"\t\t\t\t\t\t\\\n+  \"ap\", \"cbit\", \"a0\"\t\t\t\t\t\\\n+  SUBTARGET_REGISTER_NAMES\t\t\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures containing\n    a name and a register number.  This macro defines additional names\n    for hard registers, thus allowing the `asm' option in declarations\n    to refer to registers using alternate names.  */\n-#define ADDITIONAL_REGISTER_NAMES \\\n+#ifndef SUBTARGET_ADDITIONAL_REGISTER_NAMES\n+#define SUBTARGET_ADDITIONAL_REGISTER_NAMES\n+#endif\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\\\n {\t\t\t\t\t\\\n   /*{ \"gp\", GP_REGNUM },*/\t\t\\\n   { \"r13\", FRAME_POINTER_REGNUM },\t\\\n   { \"r14\", RETURN_ADDR_REGNUM },\t\\\n   { \"r15\", STACK_POINTER_REGNUM },\t\\\n+  SUBTARGET_ADDITIONAL_REGISTER_NAMES\t\\\n }\n \n /* A C expression which evaluates to true if CODE is a valid\n    punctuation character for use in the `PRINT_OPERAND' macro.  */\n extern char m32r_punct_chars[];\n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-m32r_punct_chars[(unsigned char) (CHAR)]\n+  m32r_punct_chars[(unsigned char) (CHAR)]\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n #define PRINT_OPERAND(FILE, X, CODE) \\\n-m32r_print_operand (FILE, X, CODE)\n+  m32r_print_operand (FILE, X, CODE)\n \n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand that is a memory\n@@ -1733,7 +1943,7 @@ m32r_print_operand (FILE, X, CODE)\n    define the macro `ENCODE_SECTION_INFO' to store the information\n    into the `symbol_ref', and then check for it here.  */\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n-m32r_print_operand_address (FILE, ADDR)\n+  m32r_print_operand_address (FILE, ADDR)\n \n /* If defined, C string expressions to be used for the `%R', `%L',\n    `%U', and `%I' options of `asm_fprintf' (see `final.c').  These\n@@ -1746,40 +1956,59 @@ m32r_print_operand_address (FILE, ADDR)\n #define IMMEDIATE_PREFIX \"#\"\n \n /* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-do {\t\t\t\t\t\t\t\\\n-  char label[30];\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n+   do\t\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\\\n+       char label[30];\t\t\t\t\t\\\n+       ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+       fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n+       assemble_name (FILE, label);\t\t\t\\\n+       fprintf (FILE, \"\\n\");\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-do {\t\t\t\t\t\t\t\\\n-  char label[30];\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n-  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \"-\");\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \")\\n\");\t\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      char label[30];\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+      fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n+      assemble_name (FILE, label);\t\t\t\\\n+      fprintf (FILE, \"-\");\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n+      assemble_name (FILE, label);\t\t\t\\\n+      fprintf (FILE, \")\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* The desired alignment for the location counter at the beginning\n    of a loop.  */\n /* On the M32R, align loops to 32 byte boundaries (cache line size)\n    if -malign-loops.  */\n #define LOOP_ALIGN(LABEL) (TARGET_ALIGN_LOOPS ? 5 : 0)\n \n+/* Define this to be the maximum number of insns to move around when moving\n+   a loop test from the top of a loop to the bottom\n+   and seeing whether to duplicate it.  The default is thirty.\n+\n+   Loop unrolling currently doesn't like this optimization, so\n+   disable doing if we are unrolling loops and saving space.  */\n+#define LOOP_TEST_THRESHOLD (optimize_size\t\t\t\t\\\n+\t\t\t     && !flag_unroll_loops\t\t\t\\\n+\t\t\t     && !flag_unroll_all_loops ? 2 : 30)\n+\n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n /* .balign is used to avoid confusion.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-do { if ((LOG) != 0) fprintf (FILE, \"\\t.balign %d\\n\", 1 << (LOG)); } while (0)\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if ((LOG) != 0)\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.balign %d\\n\", 1 << (LOG));\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Like `ASM_OUTPUT_COMMON' except takes the required alignment as a\n    separate, explicit argument.  If you define this macro, it is used in\n@@ -1789,51 +2018,19 @@ do { if ((LOG) != 0) fprintf (FILE, \"\\t.balign %d\\n\", 1 << (LOG)); } while (0)\n \n #define SCOMMON_ASM_OP \".scomm\"\n \n-#undef ASM_OUTPUT_ALIGNED_COMMON\n-#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (! TARGET_SDATA_NONE\t\t\t\t\t\t\\\n-      && (SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\t\\\n-    fprintf ((FILE), \"\\t%s\\t\", SCOMMON_ASM_OP);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n-} while (0)\n-\n-#if 0 /* not needed, delete later */\n-/* Like `ASM_OUTPUT_LOCAL' except takes the required alignment as a\n-   separate, explicit argument.  If you define this macro, it is used in\n-   place of `ASM_OUTPUT_LOCAL', and gives you more flexibility in\n-   handling the required alignment of the variable.  The alignment is\n-   specified as the number of bits.  */\n-\n-#undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if ((SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      sbss_section ();\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_ALIGN (FILE, exact_log2 (ALIGN / BITS_PER_UNIT));\t\\\n-      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n-      ASM_OUTPUT_SKIP (FILE, SIZE);\t\t\t\t\t\\\n-      if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\\\n-\t  assemble_name (FILE, NAME);\t\t\t\t\t\\\n-\t  fprintf (FILE, \",%d\\n\",  SIZE);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      /* This is copied from svr4.h.  */\t\t\t\t\\\n-      fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+      if (! TARGET_SDATA_NONE\t\t\t\t\t\t\\\n+\t  && (SIZE) > 0 && (SIZE) <= g_switch_value)\t\t\t\\\n+\tfprintf ((FILE), \"\\t%s\\t\", SCOMMON_ASM_OP);\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\\\n       assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n-      ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\\\n+      fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-#endif\n+  while (0)\n \n /* Like `ASM_OUTPUT_BSS' except takes the required alignment as a\n    separate, explicit argument.  If you define this macro, it is used in\n@@ -1843,20 +2040,27 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n    For the M32R we need sbss support.  */\n \n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  ASM_GLOBALIZE_LABEL (FILE, NAME);\t\t\t\t\t\\\n-  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n-} while (0)\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      ASM_GLOBALIZE_LABEL (FILE, NAME);\t\t\t\t\\\n+      ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Debugging information.  */\n \n /* Generate DBX and DWARF debugging information.  */\n+#undef\tDBX_DEBUGGING_INFO\n+#undef\tDWARF_DEBUGGING_INFO\n+#undef\tDWARF2_DEBUGGING_INFO\n+\n #define DBX_DEBUGGING_INFO\n #define DWARF_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO\n \n /* Prefer STABS (for now).  */\n-#undef PREFERRED_DEBUGGING_TYPE\n+#undef  PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n /* How to renumber registers for dbx and gdb.  */\n@@ -1916,7 +2120,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n /* ??? The M32R doesn't have full 32 bit pointers, but making this PSImode has\n-   its own problems (you have to add extendpsisi2 and truncsipsi2).\n+   it's own problems (you have to add extendpsisi2 and truncsipsi2).\n    Try to avoid it.  */\n #define Pmode SImode\n \n@@ -1933,11 +2137,11 @@ m32r_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    incompatible, one if they are compatible, and two if they are\n    nearly compatible (which causes a warning to be generated).  */\n #define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n-m32r_comp_type_attributes (TYPE1, TYPE2)\n+  m32r_comp_type_attributes (TYPE1, TYPE2)\n \n /* Give newly defined TYPE some default attributes.  */\n #define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n-m32r_set_default_type_attributes (TYPE)\n+  m32r_set_default_type_attributes (TYPE)\n \f\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n@@ -1950,8 +2154,8 @@ enum m32r_function_type\n {\n   M32R_FUNCTION_UNKNOWN, M32R_FUNCTION_NORMAL, M32R_FUNCTION_INTERRUPT\n };\n-#define M32R_INTERRUPT_P(TYPE) \\\n-((TYPE) == M32R_FUNCTION_INTERRUPT)\n+\n+#define M32R_INTERRUPT_P(TYPE) ((TYPE) == M32R_FUNCTION_INTERRUPT)\n \n /* Define this if you have defined special-purpose predicates in the\n    file `MACHINE.c'.  This macro is called within an initializer of an\n@@ -1973,97 +2177,19 @@ enum m32r_function_type\n \t\t\t\t  CONST_DOUBLE }},\t\t\t\\\n { \"two_insn_const_operand\",\t{ CONST_INT }},\t\t\t\t\\\n { \"symbolic_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n+{ \"seth_add3_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n+{ \"int8_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n+{ \"uint16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n { \"reg_or_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n { \"reg_or_uint16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n { \"reg_or_cmp_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n-{ \"reg_or_zero_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"reg_or_eq_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n { \"cmp_int16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n { \"call_address_operand\",\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n+{ \"extend_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n { \"small_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n+{ \"m32r_not_same_reg\",\t\t{ REG, SUBREG }},\t\t\t\\\n { \"m32r_block_immediate_operand\",{ CONST_INT }},\t\t\t\\\n { \"large_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n { \"seth_add3_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\n \n-/* Functions declared in m32r.c */\n-#define XPROTO(ARGS) ()\n-#define STDIO_XPROTO(ARGS) ()\n-\n-#ifndef TREE_CODE\n-union tree_node;\n-#define Tree union tree_node *\n-#else\n-#define Tree tree\n-#endif\n-\n-#ifndef RTX_CODE\n-struct rtx_def;\n-#define Rtx struct rtx_def *\n-#else\n-#define Rtx rtx\n-#endif\n-\n-extern void sbss_section\t\t\tXPROTO((void));\n-extern void sdata_section\t\t\tXPROTO((void));\n-extern void m32r_init\t\t\t\tXPROTO((void));\n-extern int  m32r_valid_machine_decl_attribute\tXPROTO((Tree, Tree, Tree, Tree));\n-extern int  m32r_comp_type_attributes\t\tXPROTO((Tree, Tree));\n-extern void m32r_select_section\t\t\tXPROTO((Tree, int));\n-extern void m32r_encode_section_info\t\tXPROTO((Tree));\n-extern void m32r_init_expanders\t\t\tXPROTO((void));\n-extern int  call_address_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  call_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  symbolic_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  small_data_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  addr24_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  addr32_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  call26_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  seth_add3_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  cmp_int16_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  uint16_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  reg_or_int16_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  reg_or_uint16_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  reg_or_cmp_nt16_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  two_insn_const_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  move_src_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  move_double_src_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  move_dest_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  easy_di_const\t\t\tXPROTO((Rtx));\n-extern int  easy_df_const\t\t\tXPROTO((Rtx));\n-extern int  eqne_comparison_operator\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  signed_comparison_operator\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  memreg_operand\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  small_insn_p\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  large_insn_p\t\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  m32r_select_cc_mode\t\t\tXPROTO((int, Rtx, Rtx));\n-extern Rtx  gen_compare\t\t\t\tXPROTO((int, Rtx, Rtx, int));\n-extern Rtx  gen_split_move_double\t\tXPROTO((Rtx *));\n-extern int  function_arg_partial_nregs\t\tXPROTO((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       int, Tree, int));\n-extern void m32r_setup_incoming_varargs\t\tXPROTO((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t       int, Tree, int *,\n-\t\t\t\t\t\t       int));\n-extern struct rtx_def *m32r_va_arg\t\tXPROTO((Tree, Tree));\n-extern int  m32r_address_code\t\t\tXPROTO((Rtx));\n-extern enum m32r_function_type m32r_compute_function_type\n-\t\t\t\t\t\tXPROTO((Tree));\n-extern unsigned m32r_compute_frame_size\t\tXPROTO((int));\n-extern int  m32r_first_insn_address\t\tXPROTO((void));\n-extern void m32r_expand_prologue\t\tXPROTO((void));\n-extern void m32r_output_function_prologue\tSTDIO_XPROTO((FILE *, int));\n-extern void m32r_output_function_epilogue\tSTDIO_XPROTO((FILE *, int));\n-extern void m32r_finalize_pic\t\t\tXPROTO((void));\n-extern void m32r_initialize_trampoline\t\tXPROTO((Rtx, Rtx, Rtx));\n-extern void m32r_asm_file_start\t\t\tSTDIO_XPROTO((FILE *));\n-extern void m32r_print_operand\t\t\tSTDIO_XPROTO((FILE *, Rtx, int));\n-extern void m32r_print_operand_address\t\tSTDIO_XPROTO((FILE *, Rtx));\n-extern int  zero_and_one\t\t\tXPROTO((Rtx, Rtx));\n-extern int  conditional_move_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern int  carry_compare_operand\t\tXPROTO((Rtx, enum machine_mode));\n-extern char *emit_cond_move\t\t\tXPROTO((Rtx *, Rtx));\n-\n-extern char * m32r_output_block_move XPROTO((Rtx, Rtx *));\n-extern int    m32r_block_immediate_operand XPROTO((Rtx, enum machine_mode));\n-extern void   m32r_expand_block_move XPROTO((Rtx *));\n-\n-#undef XPROTO\n-#undef STDIO_XPROTO"}, {"sha": "57ca196fdcd68459e326ab9d0b2711191b9912e6", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 844, "deletions": 135, "changes": 979, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e2e7627ef54dfc219481aa09b5367f00c79e47/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=56e2e7627ef54dfc219481aa09b5367f00c79e47", "patch": "@@ -69,8 +69,6 @@\n (define_attr \"m32r\" \"no,yes\"\n   (const (symbol_ref \"(TARGET_M32R != 0)\")))\n \n-\n-\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -220,10 +218,6 @@\n   3 0\n   [(eq_attr \"insn_size\" \"short\")])\n \n-\n-\f\n-;; Instruction grouping\n-\n \f\n ;; Expand prologue as RTL\n (define_expand \"prologue\"\n@@ -340,7 +334,7 @@\n \n ;; ??? Do we need a const_double constraint here for large unsigned values?\n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,r,r,r,T,U,m\")\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,r,r,r,T,S,m\")\n \t(match_operand:SI 1 \"move_src_operand\" \"r,I,J,MQ,L,n,T,U,m,r,r,r\"))]\n   \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n   \"*\n@@ -359,6 +353,10 @@\n \t    return \\\"mv %0,%1\\\";\n \n \t  case MEM:\n+\t    if (GET_CODE (XEXP (operands[1], 0)) == POST_INC\n+\t\t&& XEXP (XEXP (operands[1], 0), 0) == stack_pointer_rtx)\n+\t      return \\\"pop %0\\\";\n+\n \t    return \\\"ld %0,%1\\\";\n \n \t  case CONST_INT:\n@@ -386,7 +384,13 @@\n \n   else if (GET_CODE (operands[0]) == MEM\n \t   && (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG))\n-    return \\\"st %1,%0\\\";\n+    {\n+      if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t  && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx)\n+\treturn \\\"push %1\\\";\n+\n+      return \\\"st %1,%0\\\";\n+    }\n \n   abort ();\n }\"\n@@ -568,19 +572,21 @@\n }\")\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,r,T,m\")\n-\t(match_operand:SF 1 \"move_src_operand\" \"r,F,T,m,r,r\"))]\n+  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,r,r,T,S,m\")\n+\t(match_operand:SF 1 \"move_src_operand\" \"r,F,U,S,m,r,r,r\"))]\n   \"register_operand (operands[0], SFmode) || register_operand (operands[1], SFmode)\"\n   \"@\n    mv %0,%1\n    #\n    ld %0,%1\n    ld %0,%1\n+   ld %0,%1\n+   st %1,%0\n    st %1,%0\n    st %1,%0\"\n   ;; ??? Length of alternative 1 is either 2, 4 or 8.\n-  [(set_attr \"type\" \"int2,multi,load2,load4,store2,store4\")\n-   (set_attr \"length\" \"2,8,2,4,2,4\")])\n+  [(set_attr \"type\" \"int2,multi,load2,load2,load4,store2,store2,store4\")\n+   (set_attr \"length\" \"2,8,2,2,4,2,2,4\")])\n \n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -624,7 +630,7 @@\n \n (define_insn \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n+\t(zero_extend:HI (match_operand:QI 1 \"extend_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#255\n@@ -635,7 +641,7 @@\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n+\t(zero_extend:SI (match_operand:QI 1 \"extend_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#255\n@@ -646,7 +652,7 @@\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"extend_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#65535\n@@ -655,111 +661,84 @@\n   [(set_attr \"type\" \"int4,load2,load4\")\n    (set_attr \"length\" \"4,2,4\")])\n \f\n-;; Sign extension instructions.\n-;; ??? See v850.md.\n-\n-;; These patterns originally accepted general_operands, however, slightly\n-;; better code is generated by only accepting register_operands, and then\n-;; letting combine generate the lds[hb] insns.\n-;; [This comment copied from sparc.md, I think.]\n+;; Signed conversions from a smaller integer to a larger integer\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"extend_operand\" \"0,T,m\")))]\n+  \"\"\n+  \"@\n+    #\n+    ldb %0,%1\n+    ldb %0,%1\"\n+  [(set_attr \"type\" \"multi,load2,load4\")\n+   (set_attr \"length\" \"2,2,4\")])\n \n-(define_expand \"extendqihi2\"\n+(define_split\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n-  \"\"\n+  \"reload_completed\"\n+  [(match_dup 2)\n+   (match_dup 3)]\n   \"\n {\n-  rtx temp = gen_reg_rtx (SImode);\n-  rtx shift_24 = GEN_INT (24);\n-  int op1_subword = 0;\n-  int op0_subword = 0;\n+  rtx op0   = gen_lowpart (SImode, operands[0]);\n+  rtx shift = gen_rtx (CONST_INT, VOIDmode, 24);\n \n-  if (GET_CODE (operand1) == SUBREG)\n-    {\n-      op1_subword = SUBREG_WORD (operand1);\n-      operand1 = XEXP (operand1, 0);\n-    }\n-  if (GET_CODE (operand0) == SUBREG)\n-    {\n-      op0_subword = SUBREG_WORD (operand0);\n-      operand0 = XEXP (operand0, 0);\n-    }\n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n-\t\t\t\t\t\top1_subword),\n-\t\t\t  shift_24));\n-  if (GET_MODE (operand0) != SImode)\n-    operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subword);\n-  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-  DONE;\n+  operands[2] = gen_ashlsi3 (op0, op0, shift);\n+  operands[3] = gen_ashrsi3 (op0, op0, shift);\n }\")\n \n-(define_insn \"*sign_extendqihi2_insn\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"T,m\")))]\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"extend_operand\" \"0,T,m\")))]\n   \"\"\n-  \"ldb %0,%1\"\n-  [(set_attr \"type\" \"load2,load4\")\n-   (set_attr \"length\" \"2,4\")])\n+  \"@\n+    #\n+    ldb %0,%1\n+    ldb %0,%1\"\n+  [(set_attr \"type\" \"multi,load2,load4\")\n+   (set_attr \"length\" \"4,2,4\")])\n \n-(define_expand \"extendqisi2\"\n+(define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n-  \"\"\n+  \"reload_completed\"\n+  [(match_dup 2)\n+   (match_dup 3)]\n   \"\n {\n-  rtx temp = gen_reg_rtx (SImode);\n-  rtx shift_24 = GEN_INT (24);\n-  int op1_subword = 0;\n-\n-  if (GET_CODE (operand1) == SUBREG)\n-    {\n-      op1_subword = SUBREG_WORD (operand1);\n-      operand1 = XEXP (operand1, 0);\n-    }\n+  rtx op0   = gen_lowpart (SImode, operands[0]);\n+  rtx shift = gen_rtx (CONST_INT, VOIDmode, 24);\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n-\t\t\t  shift_24));\n-  emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-  DONE;\n+  operands[2] = gen_ashlsi3 (op0, op0, shift);\n+  operands[3] = gen_ashrsi3 (op0, op0, shift);\n }\")\n \n-(define_insn \"*sign_extendqisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"T,m\")))]\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"extend_operand\" \"0,T,m\")))]\n   \"\"\n-  \"ldb %0,%1\"\n-  [(set_attr \"type\" \"load2,load4\")\n-   (set_attr \"length\" \"2,4\")])\n+  \"@\n+    #\n+    ldh %0,%1\n+    ldh %0,%1\"\n+  [(set_attr \"type\" \"multi,load2,load4\")\n+   (set_attr \"length\" \"4,2,4\")])\n \n-(define_expand \"extendhisi2\"\n+(define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n-  \"\"\n+  \"reload_completed\"\n+  [(match_dup 2)\n+   (match_dup 3)]\n   \"\n {\n-  rtx temp = gen_reg_rtx (SImode);\n-  rtx shift_16 = GEN_INT (16);\n-  int op1_subword = 0;\n+  rtx op0   = gen_lowpart (SImode, operands[0]);\n+  rtx shift = gen_rtx (CONST_INT, VOIDmode, 16);\n \n-  if (GET_CODE (operand1) == SUBREG)\n-    {\n-      op1_subword = SUBREG_WORD (operand1);\n-      operand1 = XEXP (operand1, 0);\n-    }\n-\n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n-\t\t\t  shift_16));\n-  emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n-  DONE;\n+  operands[2] = gen_ashlsi3 (op0, op0, shift);\n+  operands[3] = gen_ashrsi3 (op0, op0, shift);\n }\")\n-\n-(define_insn \"*sign_extendhisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"T,m\")))]\n-  \"\"\n-  \"ldh %0,%1\"\n-  [(set_attr \"type\" \"load2,load4\")\n-   (set_attr \"length\" \"2,4\")])\n \f\n ;; Arithmetic instructions.\n \n@@ -977,36 +956,99 @@\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+\t\t(match_operand:SI 2 \"reg_or_uint16_operand\" \"r,K\")))]\n   \"\"\n-  \"@\n-   and %0,%2\n-   and3 %0,%1,%#%2\\\\t; %X2\"\n+  \"*\n+{\n+  /* If we are worried about space, see if we can break this up into two\n+     short instructions, which might eliminate a NOP being inserted.  */\n+  if (optimize_size\n+      && m32r_not_same_reg (operands[0], operands[1])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INT8_P (INTVAL (operands[2])))\n+    return \\\"#\\\";\n+\n+  else if (GET_CODE (operands[2]) == CONST_INT)\n+    return \\\"and3 %0,%1,%#%X2\\\";\n+\n+  return \\\"and %0,%2\\\";\n+}\"\n   [(set_attr \"type\" \"int2,int4\")\n    (set_attr \"length\" \"2,4\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"int8_operand\" \"\")))]\n+  \"optimize_size && m32r_not_same_reg (operands[0], operands[1])\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (and:SI (match_dup 1) (match_dup 0)))]\n+  \"\")\n+\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+\t\t(match_operand:SI 2 \"reg_or_uint16_operand\" \"r,K\")))]\n   \"\"\n-  \"@\n-   or %0,%2\n-   or3 %0,%1,%#%2\\\\t; %X2\"\n+  \"*\n+{\n+  /* If we are worried about space, see if we can break this up into two\n+     short instructions, which might eliminate a NOP being inserted.  */\n+  if (optimize_size\n+      && m32r_not_same_reg (operands[0], operands[1])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INT8_P (INTVAL (operands[2])))\n+    return \\\"#\\\";\n+\n+  else if (GET_CODE (operands[2]) == CONST_INT)\n+    return \\\"or3 %0,%1,%#%X2\\\";\n+\n+  return \\\"or %0,%2\\\";\n+}\"\n   [(set_attr \"type\" \"int2,int4\")\n    (set_attr \"length\" \"2,4\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"int8_operand\" \"\")))]\n+  \"optimize_size && m32r_not_same_reg (operands[0], operands[1])\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 0)))]\n+  \"\")\n+\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,K\")))]\n+\t\t(match_operand:SI 2 \"reg_or_uint16_operand\" \"r,K\")))]\n   \"\"\n-  \"@\n-   xor %0,%2\n-   xor3 %0,%1,%#%2\\\\t; %X2\"\n+  \"*\n+{\n+  /* If we are worried about space, see if we can break this up into two\n+     short instructions, which might eliminate a NOP being inserted.  */\n+  if (optimize_size\n+      && m32r_not_same_reg (operands[0], operands[1])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INT8_P (INTVAL (operands[2])))\n+    return \\\"#\\\";\n+\n+  else if (GET_CODE (operands[2]) == CONST_INT)\n+    return \\\"xor3 %0,%1,%#%X2\\\";\n+\n+  return \\\"xor %0,%2\\\";\n+}\"\n   [(set_attr \"type\" \"int2,int4\")\n    (set_attr \"length\" \"2,4\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"int8_operand\" \"\")))]\n+  \"optimize_size && m32r_not_same_reg (operands[0], operands[1])\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (xor:SI (match_dup 1) (match_dup 0)))]\n+  \"\")\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n@@ -1074,8 +1116,8 @@\n \n (define_expand \"cmpsi\"\n   [(set (reg:SI 17)\n-\t(compare:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1084,7 +1126,6 @@\n   DONE;\n }\")\n \n-\n ;; The cmp_xxx_insn patterns set the condition bit to the result of the\n ;; comparison.  There isn't a \"compare equal\" instruction so cmp_eqsi_insn\n ;; is quite inefficient.  However, it is rarely used.\n@@ -1128,7 +1169,7 @@\n (define_insn \"cmp_ltusi_insn\"\n   [(set (reg:SI 17)\n \t(ltu:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n-\t        (match_operand:SI 1 \"reg_or_uint16_operand\" \"r,K\")))]\n+\t        (match_operand:SI 1 \"reg_or_int16_operand\" \"r,J\")))]\n   \"\"\n   \"@\n    cmpu %0,%1\n@@ -1162,7 +1203,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)EQ, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (EQ, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bne\"\n@@ -1173,7 +1214,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)NE, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (NE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgt\"\n@@ -1184,7 +1225,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)GT, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (GT, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"ble\"\n@@ -1195,7 +1236,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)LE, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (LE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bge\"\n@@ -1206,7 +1247,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)GE, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (GE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"blt\"\n@@ -1217,7 +1258,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)LT, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (LT, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgtu\"\n@@ -1228,7 +1269,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)GTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (GTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bleu\"\n@@ -1239,7 +1280,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)LEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (LEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgeu\"\n@@ -1250,7 +1291,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)GEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (GEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bltu\"\n@@ -1261,7 +1302,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare ((int)LTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n+  operands[1] = gen_compare (LTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n ;; Now match both normal and inverted jump.\n@@ -1491,6 +1532,636 @@\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 8)))])\n \f\n+;; S<cc> operations to set a register to 1/0 based on a comparison\n+\n+(define_expand \"seq\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (GET_CODE (op2) == CONST_INT && INTVAL (op2) == 0)\n+    {\n+      emit_insn (gen_seq_zero_insn (op0, op1));\n+      DONE;\n+    }\n+\n+  if (! reg_or_eq_int16_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_seq_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"seq_zero_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t       (const_int 0)))\n+   (clobber (reg:SI 17))]\n+  \"TARGET_M32R\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (const_int 0)))\n+   (clobber (reg:SI 17))]\n+  \"TARGET_M32R\"\n+  [(match_dup 3)]\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  start_sequence ();\n+  emit_insn (gen_cmp_ltusi_insn (op1, GEN_INT (1)));\n+  emit_insn (gen_movcc_insn (op0));\n+  operands[3] = gen_sequence ();\n+  end_sequence ();\n+}\")\n+\n+(define_insn \"seq_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,??r,r\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"r,r,r,r\")\n+\t       (match_operand:SI 2 \"reg_or_eq_int16_operand\" \"r,r,r,PK\")))\n+   (clobber (reg:SI 17))\n+   (clobber (match_scratch:SI 3 \"=1,2,&r,r\"))]\n+  \"TARGET_M32R\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8,8,10,10\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(eq:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"reg_or_eq_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))\n+   (clobber (match_scratch:SI 3 \"\"))]\n+  \"TARGET_M32R && reload_completed\"\n+  [(match_dup 4)]\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op3 = operands[3];\n+  HOST_WIDE_INT value;\n+\n+  if (GET_CODE (op2) == REG && GET_CODE (op3) == REG\n+      && REGNO (op2) == REGNO (op3))\n+    {\n+      op1 = operands[2];\n+      op2 = operands[1];\n+    }\n+\n+  start_sequence ();\n+  if (GET_CODE (op1) == REG && GET_CODE (op3) == REG\n+      && REGNO (op1) != REGNO (op3))\n+    {\n+      emit_move_insn (op3, op1);\n+      op1 = op3;\n+    }\n+\n+  if (GET_CODE (op2) == CONST_INT && (value = INTVAL (op2)) != 0\n+      && CMP_INT16_P (value))\n+    emit_insn (gen_addsi3 (op3, op1, GEN_INT (-value)));\n+  else\n+    emit_insn (gen_xorsi3 (op3, op1, op2));\n+\n+  emit_insn (gen_cmp_ltusi_insn (op3, GEN_INT (1)));\n+  emit_insn (gen_movcc_insn (op0));\n+  operands[4] = gen_sequence ();\n+  end_sequence ();\n+}\")\n+\n+(define_expand \"sne\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (GET_CODE (op2) != CONST_INT\n+      || (INTVAL (op2) != 0 && UINT16_P (INTVAL (op2))))\n+    {\n+      rtx reg;\n+\n+      if (reload_completed || reload_in_progress)\n+\tFAIL;\n+\n+      reg = gen_reg_rtx (SImode);\n+      emit_insn (gen_xorsi3 (reg, op1, op2));\n+      op1 = reg;\n+\n+      if (! register_operand (op1, mode))\n+        op1 = force_reg (mode, op1);\n+\n+      emit_insn (gen_sne_zero_insn (op0, op1));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"sne_zero_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t       (const_int 0)))\n+   (clobber (reg:SI 17))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (const_int 0)))\n+   (clobber (reg:SI 17))\n+   (clobber (match_scratch:SI 2 \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(const_int 0))\n+   (set (reg:SI 17)\n+\t(ltu:SI (match_dup 2)\n+\t\t(match_dup 1)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))]\n+  \"\")\n+\t\n+(define_expand \"slt\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! reg_or_int16_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_slt_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"slt_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t       (match_operand:SI 2 \"reg_or_int16_operand\" \"r,J\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4,6\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  [(set (reg:SI 17)\n+\t(lt:SI (match_dup 1)\n+\t       (match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))]\n+  \"\")\n+\n+(define_expand \"sle\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      HOST_WIDE_INT value = INTVAL (op2);\n+      if (value >= 2147483647)\n+\t{\n+\t  emit_move_insn (op0, GEN_INT (1));\n+\t  DONE;\n+\t}\n+\n+      op2 = GEN_INT (value+1);\n+      if (value < -32768 || value >= 32767)\n+\top2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_slt_insn (op0, op1, op2));\n+      DONE;\n+    }\n+\n+  if (! register_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sle_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"sle_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t       (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"!optimize_size\"\n+  [(set (reg:SI 17)\n+\t(lt:SI (match_dup 2)\n+\t       (match_dup 1)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(const_int 1)))]\n+  \"\")\n+\n+;; If optimizing for space, use -(reg - 1) to invert the comparison rather than\n+;; xor reg,reg,1 which might eliminate a NOP being inserted.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(le:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"optimize_size\"\n+  [(set (reg:SI 17)\n+\t(lt:SI (match_dup 2)\n+\t       (match_dup 1)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_dup 0)))]\n+  \"\")\n+\n+(define_expand \"sgt\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! register_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_slt_insn (op0, op2, op1));\n+  DONE;\n+}\")\n+\n+(define_expand \"sge\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! reg_or_int16_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sge_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"sge_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t       (match_operand:SI 2 \"reg_or_int16_operand\" \"r,J\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8,10\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"!optimize_size\"\n+  [(set (reg:SI 17)\n+\t(lt:SI (match_dup 1)\n+\t       (match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(const_int 1)))]\n+  \"\")\n+\n+;; If optimizing for space, use -(reg - 1) to invert the comparison rather than\n+;; xor reg,reg,1 which might eliminate a NOP being inserted.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ge:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t       (match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"optimize_size\"\n+  [(set (reg:SI 17)\n+\t(lt:SI (match_dup 1)\n+\t       (match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_dup 0)))]\n+  \"\")\n+\n+(define_expand \"sltu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! reg_or_int16_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sltu_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"sltu_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_int16_operand\" \"r,J\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6,8\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ltu:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  [(set (reg:SI 17)\n+\t(ltu:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))]\n+  \"\")\n+\n+(define_expand \"sleu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      HOST_WIDE_INT value = INTVAL (op2);\n+      if (value >= 2147483647)\n+\t{\n+\t  emit_move_insn (op0, GEN_INT (1));\n+\t  DONE;\n+\t}\n+\n+      op2 = GEN_INT (value+1);\n+      if (value < 0 || value >= 32767)\n+\top2 = force_reg (mode, op2);\n+\n+      emit_insn (gen_sltu_insn (op0, op1, op2));\n+      DONE;\n+    }\n+\n+  if (! register_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sleu_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"sleu_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"!optimize_size\"\n+  [(set (reg:SI 17)\n+\t(ltu:SI (match_dup 2)\n+\t\t(match_dup 1)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(const_int 1)))]\n+  \"\")\n+\n+;; If optimizing for space, use -(reg - 1) to invert the comparison rather than\n+;; xor reg,reg,1 which might eliminate a NOP being inserted.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(leu:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"optimize_size\"\n+  [(set (reg:SI 17)\n+\t(ltu:SI (match_dup 2)\n+\t\t(match_dup 1)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_dup 0)))]\n+  \"\")\n+\n+(define_expand \"sgtu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! register_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sltu_insn (op0, op2, op1));\n+  DONE;\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = m32r_compare_op0;\n+  rtx op2 = m32r_compare_op1;\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (mode != SImode)\n+    FAIL;\n+\n+  if (! register_operand (op1, mode))\n+    op1 = force_reg (mode, op1);\n+\n+  if (! reg_or_int16_operand (op2, mode))\n+    op2 = force_reg (mode, op2);\n+\n+  emit_insn (gen_sgeu_insn (op0, op1, op2));\n+  DONE;\n+}\")\n+\n+(define_insn \"sgeu_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_int16_operand\" \"r,J\")))\n+   (clobber (reg:SI 17))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8,10\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"!optimize_size\"\n+  [(set (reg:SI 17)\n+\t(ltu:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(xor:SI (match_dup 0)\n+\t\t(const_int 1)))]\n+  \"\")\n+\n+;; If optimizing for space, use -(reg - 1) to invert the comparison rather than\n+;; xor reg,reg,1 which might eliminate a NOP being inserted.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(geu:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_int16_operand\" \"\")))\n+   (clobber (reg:SI 17))]\n+  \"optimize_size\"\n+  [(set (reg:SI 17)\n+\t(ltu:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (set (match_dup 0)\n+\t(reg:SI 17))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (set (match_dup 0)\n+\t(neg:SI (match_dup 0)))]\n+  \"\")\n+\n+(define_insn \"movcc_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(reg:SI 17))]\n+  \"\"\n+  \"mvfc %0, cbr\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"2\")])\n+\n+\f\n ;; Unconditional and other jump instructions.\n \n (define_insn \"jump\"\n@@ -1510,6 +2181,13 @@\n   \"jmp %a0\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"length\" \"2\")])\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"direct_return ()\"\n+  \"jmp lr\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"length\" \"2\")])\n  \n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n@@ -1646,10 +2324,51 @@\n   [(set_attr \"type\" \"int2\")\n    (set_attr \"length\" \"2\")])\n \f\n+;; Speed up fabs and provide correct sign handling for -0\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_dup 2)\n+\t\t   (const_int 1)))\n+   (set (match_dup 2)\n+\t(lshiftrt:SI (match_dup 2)\n+\t\t     (const_int 1)))]\n+  \"operands[2] = gen_highpart (SImode, operands[0]);\")\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_dup 2)\n+\t\t   (const_int 1)))\n+   (set (match_dup 2)\n+\t(lshiftrt:SI (match_dup 2)\n+\t\t     (const_int 1)))]\n+  \"operands[2] = gen_highpart (SImode, operands[0]);\")\n+\f\n ;; Conditional move instructions\n ;; Based on those done for the d10v\n \n-\n (define_expand \"movsicc\"\n   [\n    (set (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -1666,11 +2385,11 @@\n     FAIL;\n \n   /* Generate the comparision that will set the carry flag.  */\n-  operands[1] = gen_compare ((int)GET_CODE (operands[1]), m32r_compare_op0,\n+  operands[1] = gen_compare (GET_CODE (operands[1]), m32r_compare_op0,\n \t\t\t     m32r_compare_op1, TRUE);\n \n   /* See other movsicc pattern below for reason why.  */\n-  emit_insn (gen_blockage());\n+  emit_insn (gen_blockage ());\n }\")\n \n ;; Generate the conditional instructions based on how the carry flag is examined.\n@@ -1688,19 +2407,9 @@\n   ]\n )\n \n-(define_insn \"movcc_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(reg:SI 17))]\n-  \"\"\n-  \"mvfc %0, cbr\"\n-  [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"2\")]\n-)\n-\n \f\n ;; Split up troublesome insns for better scheduling.\n-\f\n-;; Peepholes go at the end.\n+;; FIXME: Peepholes go at the end.\n \n ;; ??? Setting the type attribute may not be useful, but for completeness\n ;; we do it."}]}