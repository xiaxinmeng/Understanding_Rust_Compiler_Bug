{"sha": "7324bf49ceb4aaca385ae0c32095901b96a2c969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyNGJmNDljZWI0YWFjYTM4NWFlMGMzMjA5NTkwMWI5NmEyYzk2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-19T15:20:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-19T15:20:16Z"}, "message": "[multiple changes]\n\n2004-04-19  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* 5isystem.ads: Removed, unused.\n\n\t* gnat_rm.texi: Redo 1.13 change.\n\n2004-04-19  Robert Dewar  <dewar@gnat.com>\n\n\t* s-stoele.ads: Clean up definition of Storage_Offset (the new\n\tdefinition is cleaner, avoids the kludge of explicit Standard operator\n\treferences, and also is consistent with a visible System.Address with\n\tno visible operations.\n\n\t* s-geveop.adb: Add declarations to avoid assumption of visible\n\toperations on type System.Address (since these might not be available\n\tif Address is a non-private type for which the operations\n\tare made abstract).\n\n\t* sem_eval.adb: Minor reformatting\n\n\t* s-carsi8.ads, s-carun8.ads, s-casi16.ads, s-casi32.ads,\n\ts-casi64.ads, s-caun16.ads, s-caun32.ads, s-caun64.ads: Minor\n\treformatting (new function spec format).\n\n\t* s-auxdec.adb, s-carsi8.adb, s-carun8.adb, s-casi16.adb,\n\ts-casi32.adb, s-casi64.adb, s-caun16.adb, s-caun32.adb,\n\ts-caun64.adb: Add declarations to avoid assumption of visible\n\toperations on type System.Address (since these might not be available\n\tif Address is a non-private type for which the operations are made\n\tabstract).\n\n\t* lib.ads, lib.adb (Synchronize_Serial_Number): New procedure.\n\n\t* exp_intr.adb: Minor comment update\n\n\t* exp_aggr.adb, exp_attr.adb, exp_ch13.adb: Minor reformatting.\n\n\t* 5omastop.adb: Add declarations to avoid assumption of visible\n\toperations on type System.Address (since these might not be available\n\tif Address is a non-private type for which the operations\n\tare made abstract).\n\n2004-04-19  Vincent Celier  <celier@gnat.com>\n\n\t* switch-m.adb: (Scan_Make_Switches): Process new switch -eL\n\n\t* prj-pars.ads (Parse): New Boolean parameter Process_Languages,\n\tdefaulted to Ada.\n\n\t* prj-proc.adb (Process): New Boolean parameter Process_Languages,\n\tdefaulted to Ada.\n\tCall Check with Process_Languages.\n\t(Check): New Boolean parameter Process_Languages. Call Recursive_Check\n\twith Process_Languages.\n\t(Recursive_Check): New Boolean parameter Process_Languages. Call\n\tNmsc.Ada_Check or Nmsc.Other_Languages_Check according to\n\tProcess_Languages.\n\n\t* prj-proc.ads (Process): New Boolean parameter Process_Languages,\n\n\t* prj-util.ads, prj-util.adb (Executable_Of): New Boolean\n\tparameter Ada_Main, defaulted to True.\n\tCheck for Ada specific characteristics only when Ada_Main is True.\n\n\t* opt.ads: (Follow_Links): New Boolean flag for gnatmake\n\n\t* prj.adb: (Project_Empty): Add new Project_Data components.\n\n\t* prj.ads: New types and tables for non Ada languages.\n\t(Project_Data): New components Languages, Impl_Suffixes,\n\tFirst_Other_Source, Last_Other_Source, Imported_Directories_Switches,\n\tInclude_Path, Include_Data_Set.\n\n\t* prj-env.ads, prj-env.adb: Minor reformatting\n\n\t* prj-nmsc.ads, prj-nmsc.adb: (Other_Languages_Check): New procedure\n\tPut subprograms in alphabetical order\n\n\t* prj-pars.adb (Parse): New Boolean parameter Process_Languages,\n\tdefaulted to Ada; Call Prj.Proc.Process with Process_Languages and\n\tOpt.Follow_Links.\n\n\t* mlib-prj.adb: Back out modification in last version, as they are\n\tincorrect.\n\t(Build_Library.Check_Libs): Remove useless pragma Warnings (Off)\n\n\t* make.adb: (Mains): Moved to package Makeutl\n\t(Linker_Opts): Moved to package Makeutl\n\t(Is_External_Assignment): Moved to package Makeutl\n\t(Test_If_Relative_Path): Moved to package Makeutl\n\t(Gnatmake): Move sorting of linker options to function\n\tMakeutl.Linker_Options_Switches.\n\n\t* Makefile.in: Add makeutl.o to the object files for gnatmake\n\n\t* makeusg.adb: Add line for new switch -eL.\n\n\t* gnatls.adb (Image): New function.\n\t(Output_Unit): If in verbose mode, output the list of restrictions\n\tspecified by pragmas Restrictions.\n\n\t* 5bml-tgt.adb, 5vml-tgt.adb (Build_Dynamic_Library): Do not use\n\tText_IO.\n\n\t* a-calend.adb (Split): Shift the date by multiple of 56 years, if\n\tneeded, to put it in the range 1970 (included) - 2026 (excluded).\n\t(Time_Of): Do not shift Unix_Min_Year (1970).\n\tShift the date by multiple of 56 years, if needed, to put it in the\n\trange 1970 (included) - 2026 (excluded).\n\n\t* adaint.h, adaint.c (__gnat_set_executable): New function.\n\n2004-04-19  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* trans.c (tree_transform, case N_Subprogram_Body): Temporarily push\n\tand pop GC context.\n\t(tree_transform, case N_Procedure_Call): Fix typo in setting TREE_TYPE.\n\t(tree_transform, case N_Label): Don't set LABEL_STMT_FIRST_IN_EH.\n\t(tree_transform, case N_Procedure_Call_Statement): Build a tree.\n\t(tree_transform, case N_Code_Statement): Likewise.\n\t(gnat_expand_stmt, case LABEL_STMT): Don't look at\n\tLABEL_STMT_FIRST_IN_EH.\n\t(gnat_expand_stmt, case ASM_STMT): New case.\n\n\t* utils2.c (build_unary_op): Properly set TREE_READONLY of\n\tUNCONSTRAINED_ARRAY_REF.\n\n\t* utils.c (poplevel): Temporarily push/pop GC context around inline\n\tfunction expansion.\n\n\t* decl.c (maybe_variable): Properly set TREE_READONLY of\n\tUNCONSTRAINED_ARRAY_REF.\n\t(make_packable_type): Only reference TYPE_IS_PADDING_P for RECORD_TYPE.\n\n\t* ada-tree.def: (ASM_STMT): New.\n\n\t* ada-tree.h: (LABEL_STMT_FIRST_IN_EH): Deleted.\n\t(ASM_STMT_TEMPLATE, ASM_STMT_OUTPUT, ASM_STMT_ORIG_OUT,\n\tASM_STMT_INPUT): New.\n\t(ASM_STMT_CLOBBER): Likewise.\n\n2004-04-19  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* a-except.adb, s-parint.ads, s-parint.adb, types.ads, types.h: Use\n\tgeneral rcheck mechanism to raise Program_Error for E.4(18), instead\n\tof a custom raiser in System.Partition_Interface.\n\tPart of general cleanup work before PolyORB integration.\n\n\t* snames.ads, snames.adb: Add new runtime library entities and names\n\tfor PolyORB DSA.\n\n\t* sem_dist.ads, sem_dist.adb (Get_Subprogram_Id): Move from sem_dist to\n\texp_dist.\n\t(Build_Subprogram_Id): New subprogram provided by exp_dist\n\tCode reorganisation in preparation for PolyORB integration.\n\n\t* exp_dist.ads, exp_dist.adb (Get_Subprogram_Id): Move from sem_dist to\n\texp_dist.\n\t(Build_Subprogram_Id): New subprogram provided by exp_dist\n\n\t* sem_ch4.adb (Analyze_One_Call): Fix error message for mismatch in\n\tactual parameter types for call to dereference of an\n\taccess-to-subprogram type.\n\n\t* rtsfind.ads: Add new runtime library entities and names for PolyORB\n\tDSA.\n\n\t* gnatlink.adb (Value): Remove. Use Interfaces.C.Strings.Value\n\tinstead, which has the same behaviour here since we never pass it a\n\tNULL pointer.\n\n\t* link.c (run_path_option, Solaris case): Use -Wl, as for other\n\tplatforms.\n\n\t* Makefile.in: adjust object file lists for gnatlink and gnatmake\n\tto account for new dependency upon Interfaces.C.Strings + link.o\n\tFor x86 FreeBSD, use 86numaux.\n\n\t* make.adb, gnatcmd.adb: Linker_Library_Path_Option has been moved up\n\tfrom Mlib.Tgt to Mlib.\n\n\t* mlib.ads, mlib.adb (Linker_Library_Path_Option): New subprogram, now\n\ttarget-independent.\n\n\t* mlib-tgt.ads, mlib-tgt.adb (Linker_Library_Path_Option): Remove\n\ttarget-specific versions of this subprogram, now implemented as a\n\ttarget-independent function in Mlib.\n\n\t* 5aml-tgt.adb, 5bml-tgt.adb, 5gml-tgt.adb, 5hml-tgt.adb, 5lml-tgt.adb,\n\t5sml-tgt.adb, 5vml-tgt.adb, 5zml-tgt.adb, 5wml-tgt.adb\n\t(Linker_Library_Path_Option): Remove target-specific versions of this\n\tsubprogram, now implemented as a target-independent function in Mlib.\n\n\t* atree.adb: (Allocate_Initialize_Node): New subprogram.\n\tFactors out node table slots allocation.\n\t(Fix_Parents): New subprogram.\n\tEncapsulate the pattern of fixing up parent pointers for syntactic\n\tchildren of a rewritten node.\n\t(New_Copy_Tree): Use New_Copy to copy non-entity nodes.\n\t(Rewrite): Use New_Copy when creating saved copy of original node.\n\t(Replace): Use Copy_Node to copy nodes.\n\n2004-04-19  Javier Miranda  <miranda@gnat.com>\n\n\t* sprint.adb (Sprint_Node_Actual): Give support to the new\n\tAccess_To_Subprogram node available in Access_Definition nodes. In\n\taddition, give support to the AI-231 node fields: null-exclusion,\n\tall-present, constant-present.\n\n\t* sem_util.ads, sem_util.adb: (Has_Declarations): New subprogram\n\n\t* sinfo.ads, sinfo.adb:\n\tNew field Access_To_Subprogram_Definition in Access_Definition nodes\n\n\t* sem_ch6.adb (Process_Formals): Move here the code that creates and\n\tdecorates internal subtype declaration corresponding to the\n\tnull-excluding formal. This code was previously in Set_Actual_Subtypes.\n\tIn addition, carry out some code cleanup on this code. In case of\n\taccess to protected subprogram call\n\tReplace_Anonymous_Access_To_Protected_Subprogram.\n\t(Set_Actual_Subtypes): Code cleanup.\n\n\t* sem_ch8.adb (Analyze_Object_Renaming): Remove un-necessary call to\n\tFind_Type in case of anonymous access renamings. Add warning in case of\n\tnull-excluding attribute used in anonymous access renaming.\n\n\t* sem_ch3.ads (Replace_Anonymous_Access_To_Protected_Subprogram): New\n\tsubprogram\n\n\t* sem_ch3.adb (Replace_Anonymous_Access_To_Protected_Subprogram): New\n\tsubprogram.\n\t(Access_Definition): In case of anonymous access to subprograms call\n\tthe corresponding semantic routine to decorate the node.\n\t(Access_Subprogram_Declaration): Addition of some comments indicating\n\tsome code that probably should be added here. Detected by comparison\n\twith the access_definition subprogram.\n\t(Analyze_Component_Declaration): In case of access to protected\n\tsubprogram call Replace_Anonymous_Access_To_Protected.\n\t(Array_Type_Declaration): In case of access to protected subprogram call\n\tReplace_Anonymous_Access_To_Protected_Subprogram.\n\t(Process_Discriminants): In case of access to protected subprogram call\n\tReplace_Anonymous_Access_To_Protected_Subprogram.\n\n\t* par.adb (P_Access_Definition): New formal that indicates if the\n\tnull-exclusion part was present.\n\t(P_Access_Type_Definition): New formal that indicates if the caller has\n\talready parsed the null-excluding part.\n\n\t* par-ch3.adb (P_Subtype_Declaration): Code cleanup.\n\t(P_Identifier_Declarations): Code cleanup and give support to renamings\n\tof anonymous access to subprogram types.\n\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Code cleanup.\n\t(P_Array_Type_Definition): Give support to AI-254.\n\t(P_Component_Items): Give support to AI-254.\n\t(P_Access_Definition): New formal that indicates if the header was\n\talready parsed by the caller.\n\t(P_Access_Type_Definition): New formal that indicates if the caller has\n\talready parsed the null-excluding part.\n\n\t* par-ch6.adb (P_Formal_Part): Add the null-excluding parameter to the\n\tcall to P_Access_Definition.\n\n2004-04-19  Geert Bosch  <bosch@gnat.com>\n\n\t* checks.adb (Apply_Float_Conversion_Check): New procedure to implement\n\tthe delicate semantics of floating-point to integer conversion.\n\t(Apply_Type_Conversion_Checks): Use Apply_Float_Conversion_Check.\n\n\t* eval_fat.adb (Machine_Mantissa): Moved to spec.\n\t(Machine_Radix): New function.\n\n\t* eval_fat.ads (Machine_Mantissa): Moved from body for use in\n\tconversion checks.\n\t(Machine_Radix): New function also for use in conversion checks.\n\n2004-04-19  Ed Schonberg  <schonberg@gnat.com>\n\n\t* par-prag.adb (Source_File_Name_Project): Fix typo in error message.\n\n\t* exp_ch9.adb (Expand_Access_Protected_Subprogram_Type): Call analyze\n\tto decorate the access-to-protected subprogram and the equivalent type.\n\n\t* checks.adb (Null_Exclusion_Static_Checks): Code cleanup. Give support\n\tto anonymous access to subprogram types.\n\n\t* exp_ch4.adb (Expand_N_In): Preserve Static flag before\n\tconstant-folding, for legality checks in contexts that require an RM\n\tstatic expression.\n\n\t* exp_ch6.adb (Expand_N_Function_Call): If call may generate large\n\ttemporary but stack checking is not enabled, increment serial number\n\tto so that symbol generation is consistent with and without stack\n\tchecking.\n\n\t* exp_util.ads, exp_util.adb (May_Generate_Large_Temp): Predicate is\n\tindependent on whether stack checking is enabled, caller must check\n\tthe corresponding flag.\n\n\t* sem_ch3.adb (Constrain_Index): Index bounds given by attributes need\n\trange checks.\n\t(Build_Derived_Concurrent_Type): Inherit Is_Constrained flag from\n\tparent if it has discriminants.\n\t(Build_Derived_Private_Type): Constructed full view does\n\tnot come from source.\n\t(Process_Discriminants): Default discriminants on a tagged type are\n\tlegal if this is the internal completion of a private untagged\n\tderivation.\n\n\t* sem_ch6.adb (Set_Actual_Subtypes): The generated declaration needs\n\tno constraint checks, because it corresponds to an existing object.\n\n\t* sem_prag.adb (Process_Convention): Pragma applies\n\tonly to subprograms in the same declarative part, i.e. the same unit,\n\tnot the same scope.\n\n\t* sem_res.adb (Valid_Conversion): In an instance or inlined body,\n\tignore type mismatch on a numeric conversion if expression comes from\n\texpansion.\n\n2004-04-19  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* sem_elim.adb (Process_Eliminate_Pragma): Remove the processing for\n\tHomonym_Number parameter, add processing for Source_Location parameter\n\tcorresponding.\n\t(Check_Eliminated): Remove the check for homonym numbers, add the check\n\tfor source location traces.\n\n\t* sem_elim.ads (Process_Eliminate_Pragma): Replace Arg_Homonym_Number\n\twith Arg_Source_Location corresponding to the changes in the format of\n\tthe pragma.\n\n\t* sem_prag.adb: (Analyze_Pragma): Changes in the processing of\n\tEliminate pragma corresponding to the changes in the format of the\n\tpragma: Homonym_Number is replaced with Source_Location, two ways of\n\tdistinguishing homonyms are mutially-exclusive.\n\n2004-04-19  Joel Brobecker  <brobecker@gnat.com>\n\n\t* get_targ.ads (Get_No_Dollar_In_Label): Remove.\n\n\t* exp_dbug.adb (Output_Homonym_Numbers_Suffix): Remove use of\n\tNo_Dollar_In_Label, no longer necessary, as it is always True.\n\t(Strip_Suffixes): Likewise.\n\n2004-04-19  Gary Dismukes  <dismukes@gnat.com>\n\n\t* s-stalib.ads (type Exception_Code): Use Integer'Size for exponent of\n\tmodulus for compatibility with size clause on targets with 16-bit\n\tInteger.\n\n\t* layout.adb (Discrimify): In the case of private types, set Vtyp to\n\tfull type to fix type mismatches on calls to size functions for\n\tdiscriminant-dependent array components.\n\n2004-04-19  Jerome Guitton  <guitton@act-europe.fr>\n\n\t* Makefile.in (gnatlib-zcx): New target, for building a ZCX run-time\n\tlib.\n\n2004-04-19  Pascal Obry  <obry@gnat.com>\n\n\t* mdll-utl.adb (Locate): New version is idempotent.\n\nFrom-SVN: r80856", "tree": {"sha": "978d1dfc5330e89503dce76f1c63cf981f4b9d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/978d1dfc5330e89503dce76f1c63cf981f4b9d73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7324bf49ceb4aaca385ae0c32095901b96a2c969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7324bf49ceb4aaca385ae0c32095901b96a2c969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7324bf49ceb4aaca385ae0c32095901b96a2c969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7324bf49ceb4aaca385ae0c32095901b96a2c969/comments", "author": null, "committer": null, "parents": [{"sha": "10b5935eb21a9828cf77e08e2b7e43238be7df40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b5935eb21a9828cf77e08e2b7e43238be7df40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b5935eb21a9828cf77e08e2b7e43238be7df40"}], "stats": {"total": 10294, "additions": 6240, "deletions": 4054}, "files": [{"sha": "2474da3ea84674275b3ce5b8aa78af2b9d3b52cf", "filename": "gcc/ada/5aml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5aml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5aml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5aml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2002-2003 Free Software Foundation, Inc.      --\n+--              Copyright (C) 2002-2004 Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -341,15 +341,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,-rpath,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "c95d64893a4370ec5874e9879e7776a080ff4ba5", "filename": "gcc/ada/5bml-tgt.adb", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5bml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5bml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2003, Ada Core Technologies, Inc.             --\n+--           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,14 +31,16 @@\n --  This is the AIX version of the body.\n \n with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n-with Ada.Text_IO; use Ada.Text_IO;\n+with GNAT.OS_Lib;       use GNAT.OS_Lib;\n+\n with MLib.Fil;\n with MLib.Utl;\n-with Namet;  use Namet;\n-with Osint;  use Osint;\n+with Namet;    use Namet;\n+with Osint;    use Osint;\n with Opt;\n-with Output; use Output;\n+with Output;   use Output;\n with Prj.Com;\n+with Prj.Util; use Prj.Util;\n \n package body MLib.Tgt is\n \n@@ -172,14 +174,13 @@ package body MLib.Tgt is\n \n             if Thread_Options = null then\n                declare\n-                  File : Ada.Text_IO.File_Type;\n+                  File : Text_File;\n                   Line : String (1 .. 100);\n                   Last : Natural;\n \n                begin\n                   Open\n-                    (File, In_File,\n-                     Include_Dir_Default_Prefix & \"/s-osinte.ads\");\n+                    (File, Include_Dir_Default_Prefix & \"/s-osinte.ads\");\n \n                   while not End_Of_File (File) loop\n                      Get_Line (File, Line, Last);\n@@ -297,10 +298,12 @@ package body MLib.Tgt is\n \n       else\n          declare\n-            Lib_Dir : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Dir);\n+            Lib_Dir  : constant String :=\n+                         Get_Name_String\n+                           (Projects.Table (Project).Library_Dir);\n             Lib_Name : constant String :=\n-              Get_Name_String (Projects.Table (Project).Library_Name);\n+                         Get_Name_String\n+                           (Projects.Table (Project).Library_Name);\n \n          begin\n             if Projects.Table (Project).Library_Kind = Static then\n@@ -349,18 +352,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      --  On AIX, any path specify with an -L switch is automatically added\n-      --  to the library path. So, nothing is needed here.\n-\n-      return null;\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "c18819918dd7f1bda909f89b15d8b5444a744360", "filename": "gcc/ada/5gml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5gml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5gml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2003, Ada Core Technologies, Inc.             --\n+--           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -324,15 +324,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,-rpath,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "4eb2934cb5128c3a104f20c2907bd1746d3d5b9f", "filename": "gcc/ada/5hml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5hml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5hml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2003, Ada Core Technologies, Inc.             --\n+--           Copyright (C) 2003-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -329,15 +329,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,+b,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "b418fd2e834af0fc2641c0a612aed5305e935cd6", "filename": "gcc/ada/5isystem.ads", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b5935eb21a9828cf77e08e2b7e43238be7df40/gcc%2Fada%2F5isystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b5935eb21a9828cf77e08e2b7e43238be7df40/gcc%2Fada%2F5isystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5isystem.ads?ref=10b5935eb21a9828cf77e08e2b7e43238be7df40", "patch": "@@ -1,166 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                      (VxWorks/LEVEL B Version PPC)                       --\n---                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Level B certifiable VxWorks version\n-\n-pragma Restrictions (No_Finalization);\n-pragma Restrictions (No_Exception_Registration);\n-pragma Restrictions (No_Abort_Statements);\n-\n-pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n-\n-package System is\n-pragma Pure (System);\n---  Note that we take advantage of the implementation permission to\n---  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := Integer'Last;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 1.0 / 60.0;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is private;\n-   Null_Address : constant Address;\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 32;\n-   Memory_Size  : constant := 2 ** 32;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := High_Order_First;\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   --  256        is reserved for the VxWorks kernel\n-   --  248 - 255  correspond to hardware interrupt levels 0 .. 7\n-   --  247        is a catchall default \"interrupt\" priority for signals,\n-   --             allowing higher priority than normal tasks, but lower than\n-   --             hardware priority levels.  Protected Object ceilings can\n-   --             override these values.\n-   --  246        is used by the Interrupt_Manager task\n-\n-   Max_Priority           : constant Positive := 245;\n-   Max_Interrupt_Priority : constant Positive := 255;\n-\n-   subtype Any_Priority       is Integer      range   0 .. 255;\n-   subtype Priority           is Any_Priority range   0 .. 245;\n-   subtype Interrupt_Priority is Any_Priority range 246 .. 255;\n-\n-   Default_Priority : constant Priority := 122;\n-\n-private\n-\n-   type Address is mod Memory_Size;\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   AAMP                      : constant Boolean := False;\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := False;\n-   Command_Line_Args         : constant Boolean := False;\n-   Configurable_Run_Time     : constant Boolean := True;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := True;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Functions_Return_By_DSP   : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   OpenVMS                   : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n-   Support_64_Bit_Divides    : constant Boolean := True;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := True;\n-   ZCX_By_Default            : constant Boolean := False;\n-   GCC_ZCX_Support           : constant Boolean := False;\n-   Front_End_ZCX_Support     : constant Boolean := False;\n-\n-   --  Obsolete entries, to be removed eventually (bootstrap issues!)\n-\n-   High_Integrity_Mode       : constant Boolean := True;\n-   Long_Shifts_Inlined       : constant Boolean := False;\n-\n-end System;"}, {"sha": "00ab3928b7940b9b80a68733a60b653916478525", "filename": "gcc/ada/5lml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5lml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5lml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2003, Free Software Foundation, Inc.     --\n+--              Copyright (C) 2001-2004, Free Software Foundation, Inc.     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -326,15 +326,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,-rpath,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "96ac1138d7e096b922e16ec12bde79e8c0d711d3", "filename": "gcc/ada/5omastop.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5omastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5omastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5omastop.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                            (Version for x86)                             --\n --                                                                          --\n---           Copyright (C) 1999-2002 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1999-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,12 @@ with System.Memory;\n \n package body System.Machine_State_Operations is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System).\n+\n    use System.Exceptions;\n \n    type Uns8  is mod 2 ** 8;"}, {"sha": "ac5e4b937fe840712328843c1c2aa605f86c8e4d", "filename": "gcc/ada/5sml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5sml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5sml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2002-2003 Free Software Foundation, Inc.      --\n+--              Copyright (C) 2002-2004 Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -323,15 +323,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,-R,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "6db0dccb9dcef434a58aaa36129c375856e9d73e", "filename": "gcc/ada/5vml-tgt.adb", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5vml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5vml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -28,9 +28,9 @@\n --  This is the VMS version of the body\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n-with Ada.Text_IO;             use Ada.Text_IO;\n \n with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;                use GNAT.OS_Lib;\n \n with MLib.Fil;\n with MLib.Utl;\n@@ -289,14 +289,16 @@ package body MLib.Tgt is\n       if Auto_Init then\n          declare\n             Macro_File_Name : constant String := Lib_Filename & \"$init.asm\";\n-            Macro_File      : Ada.Text_IO.File_Type;\n+            Macro_File      : File_Descriptor;\n             Init_Proc       : String := Lib_Filename & \"INIT\";\n             Popen_Result    : System.Address;\n             Pclose_Result   : Integer;\n+            Len             : Natural;\n+            OK              : Boolean := True;\n \n             Command  : constant String :=\n                          Macro_Name & \" \" & Macro_File_Name & ASCII.NUL;\n-            --  The command to invoke the macro-assembler on the generated\n+            --  The command to invoke the assembler on the generated auto-init\n             --  assembly file.\n \n             Mode : constant String := \"r\" & ASCII.NUL;\n@@ -311,22 +313,42 @@ package body MLib.Tgt is\n                Write_Line (\"\"\"\");\n             end if;\n \n+            --  Create and write the auto-init assembly file\n+\n+            declare\n+               First_Line : constant String :=\n+                              ASCII.HT & \".section LIB$INITIALIZE,GBL,NOWRT\" &\n+               ASCII.LF;\n+               Second_Line : constant String :=\n+                               ASCII.HT & \".long \" & Init_Proc & ASCII.LF;\n+               --  First and second lines of the auto-init assembly file\n+\n             begin\n-               Create (Macro_File, Out_File, Macro_File_Name);\n+               Macro_File := Create_File (Macro_File_Name, Text);\n+               OK := Macro_File /= Invalid_FD;\n+\n+               if OK then\n+                  Len := Write\n+                    (Macro_File, First_Line (First_Line'First)'Address,\n+                     First_Line'Length);\n+                  OK := Len = First_Line'Length;\n+               end if;\n \n-               Put_Line\n-                 (Macro_File,\n-                  ASCII.HT & \".section LIB$INITIALIZE,GBL,NOWRT\");\n-               Put_Line\n-                 (Macro_File,\n-                  ASCII.HT & \".long \" & Init_Proc);\n+               if OK then\n+                  Len := Write\n+                    (Macro_File, Second_Line (Second_Line'First)'Address,\n+                     Second_Line'Length);\n+                  OK := Len = Second_Line'Length;\n+               end if;\n \n-               Close (Macro_File);\n+               if OK then\n+                  Close (Macro_File, OK);\n+               end if;\n \n-            exception\n-               when others =>\n+               if not OK then\n                   Fail (\"creation of auto-init assembly file \"\"\",\n                         Macro_File_Name, \"\"\" failed\");\n+               end if;\n             end;\n \n             --  Invoke the macro-assembler\n@@ -642,15 +664,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return null;\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "485be34bea6aec90c11cc5c147b4e3df806ab2e8", "filename": "gcc/ada/5wml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5wml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5wml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 2002-2003, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 2002-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -308,15 +308,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return null;\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "9b3f5757463b79aaad7a15b7a554ed8d17e4702c", "filename": "gcc/ada/5zml-tgt.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5zml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2F5zml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zml-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2003 Free Software Foundation, Inc.           --\n+--           Copyright (C) 2003-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -278,15 +278,6 @@ package body MLib.Tgt is\n       end if;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return new String'(\"-Wl,-R,\");\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "ae718b0bb3adbeb35ace78af52167fad72b4b392", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 365, "deletions": 2, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1,4 +1,367 @@\n-2004-04-17  Laurent GUERBY <laurent@guerby.net>\n+2004-04-19  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* 5isystem.ads: Removed, unused.\n+\n+\t* gnat_rm.texi: Redo 1.13 change.\n+\n+2004-04-19  Robert Dewar  <dewar@gnat.com>\n+\n+\t* s-stoele.ads: Clean up definition of Storage_Offset (the new\n+\tdefinition is cleaner, avoids the kludge of explicit Standard operator\n+\treferences, and also is consistent with a visible System.Address with\n+\tno visible operations.\n+\n+\t* s-geveop.adb: Add declarations to avoid assumption of visible\n+\toperations on type System.Address (since these might not be available\n+\tif Address is a non-private type for which the operations\n+\tare made abstract).\n+\n+\t* sem_eval.adb: Minor reformatting\n+\n+\t* s-carsi8.ads, s-carun8.ads, s-casi16.ads, s-casi32.ads,\n+\ts-casi64.ads, s-caun16.ads, s-caun32.ads, s-caun64.ads: Minor\n+\treformatting (new function spec format).\n+\n+\t* s-auxdec.adb, s-carsi8.adb, s-carun8.adb, s-casi16.adb,\n+\ts-casi32.adb, s-casi64.adb, s-caun16.adb, s-caun32.adb,\n+\ts-caun64.adb: Add declarations to avoid assumption of visible\n+\toperations on type System.Address (since these might not be available\n+\tif Address is a non-private type for which the operations are made\n+\tabstract).\n+\n+\t* lib.ads, lib.adb (Synchronize_Serial_Number): New procedure.\n+\n+\t* exp_intr.adb: Minor comment update\n+\n+\t* exp_aggr.adb, exp_attr.adb, exp_ch13.adb: Minor reformatting.\n+\n+\t* 5omastop.adb: Add declarations to avoid assumption of visible\n+\toperations on type System.Address (since these might not be available\n+\tif Address is a non-private type for which the operations\n+\tare made abstract).\n+\n+2004-04-19  Vincent Celier  <celier@gnat.com>\n+\n+\t* switch-m.adb: (Scan_Make_Switches): Process new switch -eL\n+\n+\t* prj-pars.ads (Parse): New Boolean parameter Process_Languages,\n+\tdefaulted to Ada.\n+\n+\t* prj-proc.adb (Process): New Boolean parameter Process_Languages,\n+\tdefaulted to Ada.\n+\tCall Check with Process_Languages.\n+\t(Check): New Boolean parameter Process_Languages. Call Recursive_Check\n+\twith Process_Languages.\n+\t(Recursive_Check): New Boolean parameter Process_Languages. Call\n+\tNmsc.Ada_Check or Nmsc.Other_Languages_Check according to\n+\tProcess_Languages.\n+\n+\t* prj-proc.ads (Process): New Boolean parameter Process_Languages,\n+\n+\t* prj-util.ads, prj-util.adb (Executable_Of): New Boolean\n+\tparameter Ada_Main, defaulted to True.\n+\tCheck for Ada specific characteristics only when Ada_Main is True.\n+\n+\t* opt.ads: (Follow_Links): New Boolean flag for gnatmake\n+\n+\t* prj.adb: (Project_Empty): Add new Project_Data components.\n+\n+\t* prj.ads: New types and tables for non Ada languages.\n+\t(Project_Data): New components Languages, Impl_Suffixes,\n+\tFirst_Other_Source, Last_Other_Source, Imported_Directories_Switches,\n+\tInclude_Path, Include_Data_Set.\n+\n+\t* prj-env.ads, prj-env.adb: Minor reformatting\n+\n+\t* prj-nmsc.ads, prj-nmsc.adb: (Other_Languages_Check): New procedure\n+\tPut subprograms in alphabetical order\n+\n+\t* prj-pars.adb (Parse): New Boolean parameter Process_Languages,\n+\tdefaulted to Ada; Call Prj.Proc.Process with Process_Languages and\n+\tOpt.Follow_Links.\n+\n+\t* mlib-prj.adb: Back out modification in last version, as they are\n+\tincorrect.\n+\t(Build_Library.Check_Libs): Remove useless pragma Warnings (Off)\n+\n+\t* make.adb: (Mains): Moved to package Makeutl\n+\t(Linker_Opts): Moved to package Makeutl\n+\t(Is_External_Assignment): Moved to package Makeutl\n+\t(Test_If_Relative_Path): Moved to package Makeutl\n+\t(Gnatmake): Move sorting of linker options to function\n+\tMakeutl.Linker_Options_Switches.\n+\n+\t* Makefile.in: Add makeutl.o to the object files for gnatmake\n+\n+\t* makeusg.adb: Add line for new switch -eL.\n+\n+\t* gnatls.adb (Image): New function.\n+\t(Output_Unit): If in verbose mode, output the list of restrictions\n+\tspecified by pragmas Restrictions.\n+\n+\t* 5bml-tgt.adb, 5vml-tgt.adb (Build_Dynamic_Library): Do not use\n+\tText_IO.\n+\n+\t* a-calend.adb (Split): Shift the date by multiple of 56 years, if\n+\tneeded, to put it in the range 1970 (included) - 2026 (excluded).\n+\t(Time_Of): Do not shift Unix_Min_Year (1970).\n+\tShift the date by multiple of 56 years, if needed, to put it in the\n+\trange 1970 (included) - 2026 (excluded).\n+\n+\t* adaint.h, adaint.c (__gnat_set_executable): New function.\n+\n+2004-04-19  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* trans.c (tree_transform, case N_Subprogram_Body): Temporarily push\n+\tand pop GC context.\n+\t(tree_transform, case N_Procedure_Call): Fix typo in setting TREE_TYPE.\n+\t(tree_transform, case N_Label): Don't set LABEL_STMT_FIRST_IN_EH.\n+\t(tree_transform, case N_Procedure_Call_Statement): Build a tree.\n+\t(tree_transform, case N_Code_Statement): Likewise.\n+\t(gnat_expand_stmt, case LABEL_STMT): Don't look at\n+\tLABEL_STMT_FIRST_IN_EH.\n+\t(gnat_expand_stmt, case ASM_STMT): New case.\n+\n+\t* utils2.c (build_unary_op): Properly set TREE_READONLY of\n+\tUNCONSTRAINED_ARRAY_REF.\n+\n+\t* utils.c (poplevel): Temporarily push/pop GC context around inline\n+\tfunction expansion.\n+\n+\t* decl.c (maybe_variable): Properly set TREE_READONLY of\n+\tUNCONSTRAINED_ARRAY_REF.\n+\t(make_packable_type): Only reference TYPE_IS_PADDING_P for RECORD_TYPE.\n+\n+\t* ada-tree.def: (ASM_STMT): New.\n+\n+\t* ada-tree.h: (LABEL_STMT_FIRST_IN_EH): Deleted.\n+\t(ASM_STMT_TEMPLATE, ASM_STMT_OUTPUT, ASM_STMT_ORIG_OUT,\n+\tASM_STMT_INPUT): New.\n+\t(ASM_STMT_CLOBBER): Likewise.\n+\n+2004-04-19  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* a-except.adb, s-parint.ads, s-parint.adb, types.ads, types.h: Use\n+\tgeneral rcheck mechanism to raise Program_Error for E.4(18), instead\n+\tof a custom raiser in System.Partition_Interface.\n+\tPart of general cleanup work before PolyORB integration.\n+\n+\t* snames.ads, snames.adb: Add new runtime library entities and names\n+\tfor PolyORB DSA.\n+\n+\t* sem_dist.ads, sem_dist.adb (Get_Subprogram_Id): Move from sem_dist to\n+\texp_dist.\n+\t(Build_Subprogram_Id): New subprogram provided by exp_dist\n+\tCode reorganisation in preparation for PolyORB integration.\n+\n+\t* exp_dist.ads, exp_dist.adb (Get_Subprogram_Id): Move from sem_dist to\n+\texp_dist.\n+\t(Build_Subprogram_Id): New subprogram provided by exp_dist\n+\n+\t* sem_ch4.adb (Analyze_One_Call): Fix error message for mismatch in\n+\tactual parameter types for call to dereference of an\n+\taccess-to-subprogram type.\n+\n+\t* rtsfind.ads: Add new runtime library entities and names for PolyORB\n+\tDSA.\n+\n+\t* gnatlink.adb (Value): Remove. Use Interfaces.C.Strings.Value\n+\tinstead, which has the same behaviour here since we never pass it a\n+\tNULL pointer.\n+\n+\t* link.c (run_path_option, Solaris case): Use -Wl, as for other\n+\tplatforms.\n+\n+\t* Makefile.in: adjust object file lists for gnatlink and gnatmake\n+\tto account for new dependency upon Interfaces.C.Strings + link.o\n+\tFor x86 FreeBSD, use 86numaux.\n+\n+\t* make.adb, gnatcmd.adb: Linker_Library_Path_Option has been moved up\n+\tfrom Mlib.Tgt to Mlib.\n+\n+\t* mlib.ads, mlib.adb (Linker_Library_Path_Option): New subprogram, now\n+\ttarget-independent.\n+\n+\t* mlib-tgt.ads, mlib-tgt.adb (Linker_Library_Path_Option): Remove\n+\ttarget-specific versions of this subprogram, now implemented as a\n+\ttarget-independent function in Mlib.\n+\n+\t* 5aml-tgt.adb, 5bml-tgt.adb, 5gml-tgt.adb, 5hml-tgt.adb, 5lml-tgt.adb,\n+\t5sml-tgt.adb, 5vml-tgt.adb, 5zml-tgt.adb, 5wml-tgt.adb\n+\t(Linker_Library_Path_Option): Remove target-specific versions of this\n+\tsubprogram, now implemented as a target-independent function in Mlib.\n+\n+\t* atree.adb: (Allocate_Initialize_Node): New subprogram.\n+\tFactors out node table slots allocation.\n+\t(Fix_Parents): New subprogram.\n+\tEncapsulate the pattern of fixing up parent pointers for syntactic\n+\tchildren of a rewritten node.\n+\t(New_Copy_Tree): Use New_Copy to copy non-entity nodes.\n+\t(Rewrite): Use New_Copy when creating saved copy of original node.\n+\t(Replace): Use Copy_Node to copy nodes.\n+\n+2004-04-19  Javier Miranda  <miranda@gnat.com>\n+\n+\t* sprint.adb (Sprint_Node_Actual): Give support to the new\n+\tAccess_To_Subprogram node available in Access_Definition nodes. In\n+\taddition, give support to the AI-231 node fields: null-exclusion,\n+\tall-present, constant-present.\n+\n+\t* sem_util.ads, sem_util.adb: (Has_Declarations): New subprogram\n+\n+\t* sinfo.ads, sinfo.adb: \n+\tNew field Access_To_Subprogram_Definition in Access_Definition nodes\n+\n+\t* sem_ch6.adb (Process_Formals): Move here the code that creates and\n+\tdecorates internal subtype declaration corresponding to the\n+\tnull-excluding formal. This code was previously in Set_Actual_Subtypes.\n+\tIn addition, carry out some code cleanup on this code. In case of\n+\taccess to protected subprogram call\n+\tReplace_Anonymous_Access_To_Protected_Subprogram.\n+\t(Set_Actual_Subtypes): Code cleanup.\n+\n+\t* sem_ch8.adb (Analyze_Object_Renaming): Remove un-necessary call to\n+\tFind_Type in case of anonymous access renamings. Add warning in case of\n+\tnull-excluding attribute used in anonymous access renaming.\n+\n+\t* sem_ch3.ads (Replace_Anonymous_Access_To_Protected_Subprogram): New\n+\tsubprogram\n+\n+\t* sem_ch3.adb (Replace_Anonymous_Access_To_Protected_Subprogram): New\n+\tsubprogram.\n+\t(Access_Definition): In case of anonymous access to subprograms call\n+\tthe corresponding semantic routine to decorate the node.\n+\t(Access_Subprogram_Declaration): Addition of some comments indicating\n+\tsome code that probably should be added here. Detected by comparison\n+\twith the access_definition subprogram.\n+\t(Analyze_Component_Declaration): In case of access to protected\n+\tsubprogram call Replace_Anonymous_Access_To_Protected.\n+\t(Array_Type_Declaration): In case of access to protected subprogram call\n+\tReplace_Anonymous_Access_To_Protected_Subprogram.\n+\t(Process_Discriminants): In case of access to protected subprogram call\n+\tReplace_Anonymous_Access_To_Protected_Subprogram.\n+\n+\t* par.adb (P_Access_Definition): New formal that indicates if the\n+\tnull-exclusion part was present.\n+\t(P_Access_Type_Definition): New formal that indicates if the caller has\n+\talready parsed the null-excluding part.\n+\n+\t* par-ch3.adb (P_Subtype_Declaration): Code cleanup.\n+\t(P_Identifier_Declarations): Code cleanup and give support to renamings\n+\tof anonymous access to subprogram types.\n+\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Code cleanup.\n+\t(P_Array_Type_Definition): Give support to AI-254.\n+\t(P_Component_Items): Give support to AI-254.\n+\t(P_Access_Definition): New formal that indicates if the header was\n+\talready parsed by the caller.\n+\t(P_Access_Type_Definition): New formal that indicates if the caller has\n+\talready parsed the null-excluding part.\n+\n+\t* par-ch6.adb (P_Formal_Part): Add the null-excluding parameter to the\n+\tcall to P_Access_Definition.\n+\n+2004-04-19  Geert Bosch  <bosch@gnat.com>\n+\n+\t* checks.adb (Apply_Float_Conversion_Check): New procedure to implement\n+\tthe delicate semantics of floating-point to integer conversion.\n+\t(Apply_Type_Conversion_Checks): Use Apply_Float_Conversion_Check.\n+\n+\t* eval_fat.adb (Machine_Mantissa): Moved to spec.\n+\t(Machine_Radix): New function.\n+\n+\t* eval_fat.ads (Machine_Mantissa): Moved from body for use in\n+\tconversion checks.\n+\t(Machine_Radix): New function also for use in conversion checks.\n+\n+2004-04-19  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* par-prag.adb (Source_File_Name_Project): Fix typo in error message.\n+\n+\t* exp_ch9.adb (Expand_Access_Protected_Subprogram_Type): Call analyze\n+\tto decorate the access-to-protected subprogram and the equivalent type.\n+\n+\t* checks.adb (Null_Exclusion_Static_Checks): Code cleanup. Give support\n+\tto anonymous access to subprogram types.\n+\n+\t* exp_ch4.adb (Expand_N_In): Preserve Static flag before\n+\tconstant-folding, for legality checks in contexts that require an RM\n+\tstatic expression.\n+\n+\t* exp_ch6.adb (Expand_N_Function_Call): If call may generate large\n+\ttemporary but stack checking is not enabled, increment serial number\n+\tto so that symbol generation is consistent with and without stack\n+\tchecking.\n+\n+\t* exp_util.ads, exp_util.adb (May_Generate_Large_Temp): Predicate is\n+\tindependent on whether stack checking is enabled, caller must check\n+\tthe corresponding flag.\n+\n+\t* sem_ch3.adb (Constrain_Index): Index bounds given by attributes need\n+\trange checks.\n+\t(Build_Derived_Concurrent_Type): Inherit Is_Constrained flag from\n+\tparent if it has discriminants.\n+\t(Build_Derived_Private_Type): Constructed full view does\n+\tnot come from source.\n+\t(Process_Discriminants): Default discriminants on a tagged type are\n+\tlegal if this is the internal completion of a private untagged\n+\tderivation.\n+\n+\t* sem_ch6.adb (Set_Actual_Subtypes): The generated declaration needs\n+\tno constraint checks, because it corresponds to an existing object.\n+\n+\t* sem_prag.adb (Process_Convention): Pragma applies\n+\tonly to subprograms in the same declarative part, i.e. the same unit,\n+\tnot the same scope.\n+\n+\t* sem_res.adb (Valid_Conversion): In an instance or inlined body,\n+\tignore type mismatch on a numeric conversion if expression comes from\n+\texpansion.\n+\n+2004-04-19  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* sem_elim.adb (Process_Eliminate_Pragma): Remove the processing for\n+\tHomonym_Number parameter, add processing for Source_Location parameter\n+\tcorresponding.\n+\t(Check_Eliminated): Remove the check for homonym numbers, add the check\n+\tfor source location traces.\n+\n+\t* sem_elim.ads (Process_Eliminate_Pragma): Replace Arg_Homonym_Number\n+\twith Arg_Source_Location corresponding to the changes in the format of\n+\tthe pragma.\n+\n+\t* sem_prag.adb: (Analyze_Pragma): Changes in the processing of\n+\tEliminate pragma corresponding to the changes in the format of the\n+\tpragma: Homonym_Number is replaced with Source_Location, two ways of\n+\tdistinguishing homonyms are mutially-exclusive.\n+\n+2004-04-19  Joel Brobecker  <brobecker@gnat.com>\n+\n+\t* get_targ.ads (Get_No_Dollar_In_Label): Remove.\n+\n+\t* exp_dbug.adb (Output_Homonym_Numbers_Suffix): Remove use of\n+\tNo_Dollar_In_Label, no longer necessary, as it is always True.\n+\t(Strip_Suffixes): Likewise.\n+\n+2004-04-19  Gary Dismukes  <dismukes@gnat.com>\n+\n+\t* s-stalib.ads (type Exception_Code): Use Integer'Size for exponent of\n+\tmodulus for compatibility with size clause on targets with 16-bit\n+\tInteger.\n+\n+\t* layout.adb (Discrimify): In the case of private types, set Vtyp to\n+\tfull type to fix type mismatches on calls to size functions for\n+\tdiscriminant-dependent array components.\n+\n+2004-04-19  Jerome Guitton  <guitton@act-europe.fr>\n+\n+\t* Makefile.in (gnatlib-zcx): New target, for building a ZCX run-time\n+\tlib.\n+\n+2004-04-19  Pascal Obry  <obry@gnat.com>\n+\n+\t* mdll-utl.adb (Locate): New version is idempotent.\n+\n+2004-04-17  Laurent Guerby <laurent@guerby.net>\n \n \tPR ada/14988 (partial)\n \t* impunit.adb: Fix typo.\n@@ -692,7 +1055,7 @@\n \t(gnat_to_gnu_entity, case E_Array_Type): Don't set and clear it.\n \t* misc.c (LANG_HOOK_HASH_TYPE): Redefine.\n \n-2004-03-19  Laurent GUERBY <laurent@guerby.net>\n+2004-03-19  Laurent Guerby <laurent@guerby.net>\n \n \t* sem_prag.adb (Suppress_Unsuppress_Echeck): use loop instead of \n \taggregate, allows bootstrap from 3.3 on powerpc-darwin."}, {"sha": "ad17a50f033d0bb77359918d75f4b636b8d1c090", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -300,21 +300,23 @@ Makefile: ../config.status $(srcdir)/Makefile.in $(srcdir)/../version.c\n # Lists of files for various purposes.\n \n GNATLINK_OBJS = gnatlink.o link.o \\\n- ali.o alloc.o butil.o casing.o csets.o debug.o fmap.o fname.o gnatvsn.o \\\n- hostparm.o namet.o opt.o osint.o output.o rident.o sdefault.o \\\n- stylesw.o switch.o table.o tree_io.o types.o validsw.o widechar.o\n+ a-except.o ali.o alloc.o butil.o casing.o csets.o debug.o fmap.o fname.o gnatvsn.o \\\n+ hostparm.o interfac.o i-c.o i-cstrin.o namet.o opt.o osint.o output.o rident.o \\\n+ s-exctab.o s-secsta.o s-stalib.o s-stoele.o sdefault.o stylesw.o switch.o system.o \\\n+ table.o tree_io.o types.o validsw.o widechar.o\n \n-GNATMAKE_OBJS = ctrl_c.o ali.o ali-util.o s-casuti.o \\\n+GNATMAKE_OBJS = a-except.o ctrl_c.o ali.o ali-util.o s-casuti.o \\\n  alloc.o atree.o binderr.o butil.o casing.o csets.o debug.o elists.o einfo.o\\\n  erroutc.o errutil.o err_vars.o fmap.o fname.o fname-uf.o fname-sf.o \\\n- gnatmake.o gnatvsn.o hostparm.o krunch.o lib.o make.o makeusg.o \\\n- mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o mlib-utl.o \\\n+ gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o link.o \\\n+ make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o mlib-utl.o \\\n  namet.o nlists.o opt.o osint.o osint-m.o output.o \\\n  prj.o prj-attr.o prj-com.o prj-dect.o prj-env.o prj-err.o prj-ext.o prj-nmsc.o \\\n  prj-pars.o prj-part.o prj-proc.o prj-strt.o prj-tree.o prj-util.o \\\n- rident.o scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o \\\n+ rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n+ scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o \\\n  sinfo.o sinput.o sinput-c.o sinput-p.o \\\n- snames.o stand.o stringt.o styleg.o stylesw.o validsw.o switch.o switch-m.o \\\n+ snames.o stand.o stringt.o styleg.o stylesw.o system.o validsw.o switch.o switch-m.o \\\n  table.o targparm.o tempdir.o tree_io.o types.o \\\n  uintp.o  uname.o urealp.o usage.o widechar.o \\\n  $(EXTRA_GNATMAKE_OBJS)\n@@ -865,6 +867,8 @@ endif\n ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<45intnam.ads \\\n+  a-numaux.adb<86numaux.adb \\\n+  a-numaux.ads<86numaux.ads \\\n   g-soccon.ads<35soccon.ads \\\n   s-inmaop.adb<7sinmaop.adb \\\n   s-intman.adb<7sintman.adb \\\n@@ -2020,6 +2024,15 @@ gnatlib-sjlj: ../stamp-gnatlib1\n \t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n \t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n \n+gnatlib-zcx: ../stamp-gnatlib1\n+\tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := True;/' rts/system.ads > rts/s.ads\n+\t$(MV) rts/s.ads rts/system.ads\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n+\n # .s files for cross-building\n gnat-cross: force\n \tmake $(GNAT1_ADA_OBJS) CC=\"gcc -B../stage1/\" CFLAGS=\"-S -gnatp\""}, {"sha": "fdab0cb557298e704e92fa698dbda2ef26d38012", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -89,14 +89,20 @@ package body Ada.Calendar is\n    --  TM.all cannot be represented.\n \n    --  The following constants are used in adjusting Ada dates so that they\n-   --  fit into the range that can be handled by Unix (1970 - 2038). The trick\n-   --  is that the number of days in any four year period in the Ada range of\n-   --  years (1901 - 2099) has a constant number of days. This is because we\n-   --  have the special case of 2000 which, contrary to the normal exception\n-   --  for centuries, is a leap year after all.\n+   --  fit into a 56 year range that can be handled by Unix (1970 included -\n+   --  2026 excluded). Dates that are not in this 56 year range are shifted\n+   --  by multiples of 56 years to fit in this range\n+   --  The trick is that the number of days in any four year period in the Ada\n+   --  range of years (1901 - 2099) has a constant number of days. This is\n+   --  because we have the special case of 2000 which, contrary to the normal\n+   --  exception for centuries, is a leap year after all.\n+   --  56 has been chosen, because it is not only a multiple of 4, but also\n+   --  a multiple of 7. Thus two dates 56 years apart fall on the same day of\n+   --  the week, and the Daylight Saving Time change dates are usually the same\n+   --  for these two years.\n \n    Unix_Year_Min : constant := 1970;\n-   Unix_Year_Max : constant := 2038;\n+   Unix_Year_Max : constant := 2026;\n \n    Ada_Year_Min : constant := 1901;\n    Ada_Year_Max : constant := 2099;\n@@ -106,9 +112,10 @@ package body Ada.Calendar is\n    Days_In_Month : constant array (Month_Number) of Day_Number :=\n                      (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n \n-   Days_In_4_Years     : constant := 365 * 3 + 366;\n-   Seconds_In_4_Years  : constant := 86_400 * Days_In_4_Years;\n-   Seconds_In_4_YearsD : constant Duration := Duration (Seconds_In_4_Years);\n+   Days_In_4_Years      : constant := 365 * 3 + 366;\n+   Seconds_In_4_Years   : constant := 86_400 * Days_In_4_Years;\n+   Seconds_In_56_Years  : constant := Seconds_In_4_Years * 14;\n+   Seconds_In_56_YearsD : constant := Duration (Seconds_In_56_Years);\n \n    ---------\n    -- \"+\" --\n@@ -270,15 +277,6 @@ package body Ada.Calendar is\n       LowD  : constant Duration := Duration (Low);\n       HighD : constant Duration := Duration (High);\n \n-      --  The following declare the maximum duration value that can be\n-      --  successfully converted to a 32-bit integer suitable for passing\n-      --  to the localtime_r function. Note that we cannot assume that the\n-      --  localtime_r function expands to accept 64-bit input on a 64-bit\n-      --  machine, but we can count on a 32-bit range on all machines.\n-\n-      Max_Time  : constant := 2 ** 31 - 1;\n-      Max_TimeD : constant Duration := Duration (Max_Time);\n-\n       --  Finally the actual variables used in the computation\n \n       D                : Duration;\n@@ -309,21 +307,21 @@ package body Ada.Calendar is\n       --  EPOCH through EPOCH + N seconds). N is in practice 2 ** 31 - 1.\n \n       --  If we have a value outside this range, then we first adjust it\n-      --  to be in the required range by adding multiples of four years.\n+      --  to be in the required range by adding multiples of 56 years.\n       --  For the range we are interested in, the number of days in any\n-      --  consecutive four year period is constant. Then we do the split\n+      --  consecutive 56 year period is constant. Then we do the split\n       --  on the adjusted value, and readjust the years value accordingly.\n \n       Year_Val := 0;\n \n       while D < 0.0 loop\n-         D := D + Seconds_In_4_YearsD;\n-         Year_Val := Year_Val - 4;\n+         D := D + Seconds_In_56_YearsD;\n+         Year_Val := Year_Val - 56;\n       end loop;\n \n-      while D > Max_TimeD loop\n-         D := D - Seconds_In_4_YearsD;\n-         Year_Val := Year_Val + 4;\n+      while D >= Seconds_In_56_YearsD loop\n+         D := D - Seconds_In_56_YearsD;\n+         Year_Val := Year_Val + 56;\n       end loop;\n \n       --  Now we need to take the value D, which is now non-negative, and\n@@ -435,18 +433,19 @@ package body Ada.Calendar is\n       TM_Val.tm_mon  := Month - 1;\n \n       --  For the year, we have to adjust it to a year that Unix can handle.\n-      --  We do this in four year steps, since the number of days in four\n-      --  years is constant, so the timezone effect on the conversion from\n-      --  local time to GMT is unaffected.\n-\n-      while Year_Val <= Unix_Year_Min loop\n-         Year_Val := Year_Val + 4;\n-         Duration_Adjust := Duration_Adjust - Seconds_In_4_YearsD;\n+      --  We do this in 56 year steps, since the number of days in 56 years\n+      --  is constant, so the timezone effect on the conversion from local\n+      --  time to GMT is unaffected; also the DST change dates are usually\n+      --  not modified.\n+\n+      while Year_Val < Unix_Year_Min loop\n+         Year_Val := Year_Val + 56;\n+         Duration_Adjust := Duration_Adjust - Seconds_In_56_YearsD;\n       end loop;\n \n       while Year_Val >= Unix_Year_Max loop\n-         Year_Val := Year_Val - 4;\n-         Duration_Adjust := Duration_Adjust + Seconds_In_4_YearsD;\n+         Year_Val := Year_Val - 56;\n+         Duration_Adjust := Duration_Adjust + Seconds_In_56_YearsD;\n       end loop;\n \n       TM_Val.tm_year := Year_Val - 1900;"}, {"sha": "c07790ab4fe132140a15a12384a993998b0a9e32", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -501,6 +501,7 @@ package body Ada.Exceptions is\n    procedure Rcheck_26 (File : Big_String_Ptr; Line : Integer);\n    procedure Rcheck_27 (File : Big_String_Ptr; Line : Integer);\n    procedure Rcheck_28 (File : Big_String_Ptr; Line : Integer);\n+   procedure Rcheck_29 (File : Big_String_Ptr; Line : Integer);\n \n    pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n    pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n@@ -531,6 +532,7 @@ package body Ada.Exceptions is\n    pragma Export (C, Rcheck_26, \"__gnat_rcheck_26\");\n    pragma Export (C, Rcheck_27, \"__gnat_rcheck_27\");\n    pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n+   pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n \n    ---------------------------------------------\n    -- Reason Strings for Run-Time Check Calls --\n@@ -565,11 +567,13 @@ package body Ada.Exceptions is\n    Rmsg_21 : constant String := \"potentially blocking operation\"   & NUL;\n    Rmsg_22 : constant String := \"stubbed subprogram called\"        & NUL;\n    Rmsg_23 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_24 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_25 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_26 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_27 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_28 : constant String := \"restriction violation\"            & NUL;\n+   Rmsg_24 : constant String := \"illegal use of\"\n+             & \" remote access-to-class-wide type, see RM E.4(18)\" & NUL;\n+   Rmsg_25 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_26 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_27 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_28 : constant String := \"object too large\"                 & NUL;\n+   Rmsg_29 : constant String := \"restriction violation\"            & NUL;\n \n    -----------------------\n    -- Polling Interface --\n@@ -1146,7 +1150,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_24 (File : Big_String_Ptr; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_24'Address));\n+      Raise_Program_Error_Msg (File, Line, To_Ptr (Rmsg_24'Address));\n    end Rcheck_24;\n \n    procedure Rcheck_25 (File : Big_String_Ptr; Line : Integer) is\n@@ -1169,6 +1173,11 @@ package body Ada.Exceptions is\n       Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_28'Address));\n    end Rcheck_28;\n \n+   procedure Rcheck_29 (File : Big_String_Ptr; Line : Integer) is\n+   begin\n+      Raise_Storage_Error_Msg (File, Line, To_Ptr (Rmsg_29'Address));\n+   end Rcheck_29;\n+\n    -------------\n    -- Reraise --\n    -------------"}, {"sha": "e5fe7eb61fad11b6905206b050427df3cfc79e01", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -101,9 +101,12 @@ DEFTREECODE (IF_STMT, \"if_stmt\", 's', 4)\n /* A goto just points to the label: GOTO_STMT_LABEL.  */\n DEFTREECODE (GOTO_STMT, \"goto_stmt\", 's', 1)\n \n-/* A label: LABEL_STMT_LABEL is the label and LABEL_STMT_FIRST_IN_EH is set\n-   if this is the first label of an exception handler.  */\n+/* A label: LABEL_STMT_LABEL is the label.  */\n DEFTREECODE (LABEL_STMT, \"label_stmt\", 's', 1)\n \n /* A \"return\".  RETURN_STMT_EXPR is the value to return if non-null.  */\n DEFTREECODE (RETURN_STMT, \"return_stmt\", 's', 1)\n+\n+/* An \"asm\" statement.  The operands are ASM_STMT_TEMPLATE, ASM_STMT_OUTPUT,\n+   ASM_STMT_ORIG_OUT, ASM_STMT_INPUT, and ASM_STMT_CLOBBER.  */\n+DEFTREECODE (ASM_STMT, \"asm_stmt\", 's', 5)"}, {"sha": "3f6faeddb30894ef30c468df46cf9e2fd9df3abb", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -302,7 +302,9 @@ struct lang_type GTY(())\n #define IF_STMT_ELSE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 3)\n #define GOTO_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, GOTO_STMT, 0)\n #define LABEL_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LABEL_STMT, 0)\n-#define LABEL_STMT_FIRST_IN_EH(NODE) \\\n-  (LABEL_STMT_CHECK (NODE)->common.unsigned_flag)\n #define RETURN_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, RETURN_STMT, 0)\n-\n+#define ASM_STMT_TEMPLATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 0)\n+#define ASM_STMT_OUTPUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 1)\n+#define ASM_STMT_ORIG_OUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 2)\n+#define ASM_STMT_INPUT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 3)\n+#define ASM_STMT_CLOBBER(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, ASM_STMT, 4)"}, {"sha": "58d955a7bbb5c4aee19012289998a64427d220aa", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1471,6 +1471,20 @@ __gnat_set_writable (char *name)\n #endif\n }\n \n+void\n+__gnat_set_executable (char *name)\n+{\n+#ifndef __vxworks\n+  struct stat statbuf;\n+\n+  if (stat (name, &statbuf) == 0)\n+  {\n+    statbuf.st_mode = statbuf.st_mode | S_IXUSR;\n+    chmod (name, statbuf.st_mode);\n+  }\n+#endif\n+}\n+\n void\n __gnat_set_readonly (char *name)\n {"}, {"sha": "66f234e8cfbade4f7007761ecb8c7e000c4a591a", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -83,6 +83,7 @@ extern int    __gnat_is_writable_file\t\t   (char *);\n extern int    __gnat_is_readable_file\t\t   (char *name);\n extern void   __gnat_set_readonly                  (char *name);\n extern void   __gnat_set_writable                  (char *name);\n+extern void   __gnat_set_executable                (char *name);\n extern int    __gnat_is_symbolic_link\t\t   (char *name);\n extern int    __gnat_portable_spawn                (char *[]);\n extern int    __gnat_portable_no_block_spawn       (char *[]);"}, {"sha": "c03a183619441febc85b812b38ef052e0a39ac4e", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 123, "deletions": 165, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -380,11 +380,64 @@ package body Atree is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Fix_Parent (Field : Union_Id; Old_Node, New_Node : Node_Id);\n-   --  This subprogram is used to fixup parent pointers that are rendered\n-   --  incorrect because of a node copy. Field is checked to see if it\n-   --  points to a node, list, or element list that has a parent that\n-   --  points to Old_Node. If so, the parent is reset to point to New_Node.\n+   procedure Fix_Parents (Old_Node, New_Node : Node_Id);\n+   --  Fixup parent pointers for the syntactic children of New_Node after\n+   --  a copy, setting them to New_Node when they pointed to Old_Node.\n+\n+   function Allocate_Initialize_Node\n+     (Src            : Node_Id;\n+      With_Extension : Boolean) return Node_Id;\n+   --  Allocate a new node or node extension. If Src is not empty,\n+   --  the information for the newly-allocated node is copied from it.\n+\n+   ------------------------------\n+   -- Allocate_Initialize_Node --\n+   ------------------------------\n+\n+   function Allocate_Initialize_Node\n+     (Src            : Node_Id;\n+      With_Extension : Boolean) return Node_Id\n+   is\n+      New_Id : Node_Id     := Src;\n+      Nod    : Node_Record := Default_Node;\n+      Ext1   : Node_Record := Default_Node_Extension;\n+      Ext2   : Node_Record := Default_Node_Extension;\n+      Ext3   : Node_Record := Default_Node_Extension;\n+   begin\n+      if Present (Src) then\n+         Nod := Nodes.Table (Src);\n+\n+         if Has_Extension (Src) then\n+            Ext1 := Nodes.Table (Src + 1);\n+            Ext2 := Nodes.Table (Src + 2);\n+            Ext3 := Nodes.Table (Src + 3);\n+         end if;\n+      end if;\n+\n+      if not (Present (Src)\n+               and then not Has_Extension (Src)\n+               and then With_Extension\n+               and then Src = Nodes.Last)\n+      then\n+         --  We are allocating a new node, or extending a node\n+         --  other than Nodes.Last.\n+\n+         Nodes.Append (Nod);\n+         New_Id := Nodes.Last;\n+         Orig_Nodes.Append (New_Id);\n+         Node_Count := Node_Count + 1;\n+      end if;\n+\n+      if With_Extension then\n+         Nodes.Append (Ext1);\n+         Nodes.Append (Ext2);\n+         Nodes.Append (Ext3);\n+      end if;\n+\n+      Orig_Nodes.Set_Last (Nodes.Last);\n+      Allocate_List_Tables (Nodes.Last);\n+      return New_Id;\n+   end Allocate_Initialize_Node;\n \n    --------------\n    -- Analyzed --\n@@ -584,17 +637,7 @@ package body Atree is\n          return Copy_Entity (Source);\n \n       else\n-         Nodes.Increment_Last;\n-         New_Id := Nodes.Last;\n-         Nodes.Table (New_Id) := Nodes.Table (Source);\n-         Nodes.Table (New_Id).Link := Empty_List_Or_Node;\n-         Nodes.Table (New_Id).In_List := False;\n-         Nodes.Table (New_Id).Rewrite_Ins := False;\n-         Node_Count := Node_Count + 1;\n-\n-         Orig_Nodes.Increment_Last;\n-         Allocate_List_Tables (Nodes.Last);\n-         Orig_Nodes.Table (New_Id) := New_Id;\n+         New_Id := New_Copy (Source);\n \n          --  Recursively copy descendents\n \n@@ -787,58 +830,53 @@ package body Atree is\n       pragma Inline (Debug_Extend_Node);\n \n    begin\n-      if Node /= Nodes.Last then\n-         Nodes.Increment_Last;\n-         Nodes.Table (Nodes.Last) := Nodes.Table (Node);\n-         Result := Nodes.Last;\n-\n-         Orig_Nodes.Increment_Last;\n-         Orig_Nodes.Table (Nodes.Last) := Nodes.Last;\n+      pragma Assert (not (Has_Extension (Node)));\n+      Result := Allocate_Initialize_Node (Node, With_Extension => True);\n+      pragma Debug (Debug_Extend_Node);\n+      return Result;\n+   end Extend_Node;\n \n-      else\n-         Result := Node;\n-      end if;\n+   -----------------\n+   -- Fix_Parents --\n+   -----------------\n \n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n+   procedure Fix_Parents (Old_Node, New_Node : Node_Id) is\n \n-      Orig_Nodes.Set_Last (Nodes.Last);\n-      Allocate_List_Tables (Nodes.Last);\n+      procedure Fix_Parent (Field : Union_Id; Old_Node, New_Node : Node_Id);\n+      --  Fixup one parent pointer. Field is checked to see if it\n+      --  points to a node, list, or element list that has a parent that\n+      --  points to Old_Node. If so, the parent is reset to point to New_Node.\n \n-      pragma Debug (Debug_Extend_Node);\n-      return Result;\n-   end Extend_Node;\n+      procedure Fix_Parent (Field : Union_Id; Old_Node, New_Node : Node_Id) is\n+      begin\n+         --  Fix parent of node that is referenced by Field. Note that we must\n+         --  exclude the case where the node is a member of a list, because in\n+         --  this case the parent is the parent of the list.\n \n-   ----------------\n-   -- Fix_Parent --\n-   ----------------\n+         if Field in Node_Range\n+           and then Present (Node_Id (Field))\n+           and then not Nodes.Table (Node_Id (Field)).In_List\n+           and then Parent (Node_Id (Field)) = Old_Node\n+         then\n+            Set_Parent (Node_Id (Field), New_Node);\n \n-   procedure Fix_Parent (Field : Union_Id; Old_Node, New_Node : Node_Id) is\n-   begin\n-      --  Fix parent of node that is referenced by Field. Note that we must\n-      --  exclude the case where the node is a member of a list, because in\n-      --  this case the parent is the parent of the list.\n-\n-      if Field in Node_Range\n-        and then Present (Node_Id (Field))\n-        and then not Nodes.Table (Node_Id (Field)).In_List\n-        and then Parent (Node_Id (Field)) = Old_Node\n-      then\n-         Set_Parent (Node_Id (Field), New_Node);\n+         --  Fix parent of list that is referenced by Field\n \n-      --  Fix parent of list that is referenced by Field\n+         elsif Field in List_Range\n+           and then Present (List_Id (Field))\n+           and then Parent (List_Id (Field)) = Old_Node\n+         then\n+            Set_Parent (List_Id (Field), New_Node);\n+         end if;\n+      end Fix_Parent;\n \n-      elsif Field in List_Range\n-        and then Present (List_Id (Field))\n-        and then Parent (List_Id (Field)) = Old_Node\n-      then\n-         Set_Parent (List_Id (Field), New_Node);\n-      end if;\n-   end Fix_Parent;\n+   begin\n+      Fix_Parent (Field1 (New_Node), Old_Node, New_Node);\n+      Fix_Parent (Field2 (New_Node), Old_Node, New_Node);\n+      Fix_Parent (Field3 (New_Node), Old_Node, New_Node);\n+      Fix_Parent (Field4 (New_Node), Old_Node, New_Node);\n+      Fix_Parent (Field5 (New_Node), Old_Node, New_Node);\n+   end Fix_Parents;\n \n    -----------------------------------\n    -- Get_Comes_From_Source_Default --\n@@ -942,38 +980,23 @@ package body Atree is\n    --------------\n \n    function New_Copy (Source : Node_Id) return Node_Id is\n-      New_Id : Node_Id;\n+      New_Id : Node_Id := Source;\n \n    begin\n-      if Source <= Empty_Or_Error then\n-         return Source;\n+      if Source > Empty_Or_Error then\n+\n+         New_Id := Allocate_Initialize_Node (Source, Has_Extension (Source));\n \n-      else\n-         Nodes.Increment_Last;\n-         New_Id := Nodes.Last;\n-         Nodes.Table (New_Id) := Nodes.Table (Source);\n          Nodes.Table (New_Id).Link := Empty_List_Or_Node;\n          Nodes.Table (New_Id).In_List := False;\n-         Nodes.Table (New_Id).Rewrite_Ins := False;\n \n-         Orig_Nodes.Increment_Last;\n-         Orig_Nodes.Table (New_Id) := New_Id;\n+         --  If the original is marked as a rewrite insertion, then unmark\n+         --  the copy, since we inserted the original, not the copy.\n \n-         if Has_Extension (Source) then\n-            Nodes.Increment_Last;\n-            Nodes.Table (New_Id + 1) := Nodes.Table (Source + 1);\n-            Nodes.Increment_Last;\n-            Nodes.Table (New_Id + 2) := Nodes.Table (Source + 2);\n-            Nodes.Increment_Last;\n-            Nodes.Table (New_Id + 3) := Nodes.Table (Source + 3);\n-\n-            Orig_Nodes.Set_Last (Nodes.Last);\n-         end if;\n-\n-         Allocate_List_Tables (Nodes.Last);\n-         Node_Count := Node_Count + 1;\n-         return New_Id;\n+         Nodes.Table (New_Id).Rewrite_Ins := False;\n       end if;\n+\n+      return New_Id;\n    end New_Copy;\n \n    -------------------\n@@ -1353,17 +1376,7 @@ package body Atree is\n             return Assoc (Old_Node);\n \n          else\n-            Nodes.Increment_Last;\n-            New_Node := Nodes.Last;\n-            Nodes.Table (New_Node) := Nodes.Table (Old_Node);\n-            Nodes.Table (New_Node).Link := Empty_List_Or_Node;\n-            Nodes.Table (New_Node).In_List := False;\n-            Node_Count := Node_Count + 1;\n-\n-            Orig_Nodes.Increment_Last;\n-            Allocate_List_Tables (Nodes.Last);\n-\n-            Orig_Nodes.Table (Nodes.Last) := Nodes.Last;\n+            New_Node := New_Copy (Old_Node);\n \n             --  If the node we are copying is the associated node of a\n             --  previously copied Itype, then adjust the associated node\n@@ -1416,10 +1429,6 @@ package body Atree is\n             Set_Field5\n               (New_Node, Copy_Field_With_Replacement (Field5 (New_Node)));\n \n-            --  If the original is marked as a rewrite insertion, then unmark\n-            --  the copy, since we inserted the original, not the copy.\n-\n-            Nodes.Table (New_Node).Rewrite_Ins := False;\n \n             --  Adjust Sloc of new node if necessary\n \n@@ -1838,7 +1847,7 @@ package body Atree is\n       begin\n          if Debug_Flag_N then\n             Write_Str (\"Allocate entity, Id = \");\n-            Write_Int (Int (Nodes.Last));\n+            Write_Int (Int (Ent));\n             Write_Str (\"  \");\n             Write_Location (New_Sloc);\n             Write_Str (\"  \");\n@@ -1852,8 +1861,7 @@ package body Atree is\n    begin\n       pragma Assert (New_Node_Kind in N_Entity);\n \n-      Nodes.Increment_Last;\n-      Ent := Nodes.Last;\n+      Ent := Allocate_Initialize_Node (Empty, With_Extension => True);\n \n       --  If this is a node with a real location and we are generating\n       --  source nodes, then reset Current_Error_Node. This is useful\n@@ -1863,26 +1871,10 @@ package body Atree is\n          Current_Error_Node := Ent;\n       end if;\n \n-      Nodes.Table (Nodes.Last)        := Default_Node;\n-      Nodes.Table (Nodes.Last).Nkind  := New_Node_Kind;\n-      Nodes.Table (Nodes.Last).Sloc   := New_Sloc;\n+      Nodes.Table (Ent).Nkind  := New_Node_Kind;\n+      Nodes.Table (Ent).Sloc   := New_Sloc;\n       pragma Debug (New_Entity_Debugging_Output);\n \n-      Orig_Nodes.Increment_Last;\n-      Orig_Nodes.Table (Nodes.Last) := Nodes.Last;\n-\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n-\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n-\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last) := Default_Node_Extension;\n-\n-      Orig_Nodes.Set_Last (Nodes.Last);\n-      Allocate_List_Tables (Nodes.Last);\n-      Node_Count := Node_Count + 1;\n       return Ent;\n    end New_Entity;\n \n@@ -1908,7 +1900,7 @@ package body Atree is\n       begin\n          if Debug_Flag_N then\n             Write_Str (\"Allocate node, Id = \");\n-            Write_Int (Int (Nodes.Last));\n+            Write_Int (Int (Nod));\n             Write_Str (\"  \");\n             Write_Location (New_Sloc);\n             Write_Str (\"  \");\n@@ -1921,12 +1913,10 @@ package body Atree is\n \n    begin\n       pragma Assert (New_Node_Kind not in N_Entity);\n-      Nodes.Increment_Last;\n-      Nodes.Table (Nodes.Last)        := Default_Node;\n-      Nodes.Table (Nodes.Last).Nkind  := New_Node_Kind;\n-      Nodes.Table (Nodes.Last).Sloc   := New_Sloc;\n+      Nod := Allocate_Initialize_Node (Empty, With_Extension => False);\n+      Nodes.Table (Nod).Nkind := New_Node_Kind;\n+      Nodes.Table (Nod).Sloc  := New_Sloc;\n       pragma Debug (New_Node_Debugging_Output);\n-      Nod := Nodes.Last;\n \n       --  If this is a node with a real location and we are generating\n       --  source nodes, then reset Current_Error_Node. This is useful\n@@ -1936,10 +1926,6 @@ package body Atree is\n          Current_Error_Node := Nod;\n       end if;\n \n-      Node_Count := Node_Count + 1;\n-      Orig_Nodes.Increment_Last;\n-      Allocate_List_Tables (Nodes.Last);\n-      Orig_Nodes.Table (Nodes.Last) := Nodes.Last;\n       return Nod;\n    end New_Node;\n \n@@ -2054,11 +2040,7 @@ package body Atree is\n       end if;\n \n       New_Node := New_Copy (Source);\n-      Fix_Parent (Field1 (Source), Source, New_Node);\n-      Fix_Parent (Field2 (Source), Source, New_Node);\n-      Fix_Parent (Field3 (Source), Source, New_Node);\n-      Fix_Parent (Field4 (Source), Source, New_Node);\n-      Fix_Parent (Field5 (Source), Source, New_Node);\n+      Fix_Parents (Source, New_Node);\n \n       --  We now set the parent of the new node to be the same as the\n       --  parent of the source. Almost always this parent will be\n@@ -2085,8 +2067,6 @@ package body Atree is\n    -------------\n \n    procedure Replace (Old_Node, New_Node : Node_Id) is\n-      Old_Link : constant Union_Id := Nodes.Table (Old_Node).Link;\n-      Old_InL  : constant Boolean  := Nodes.Table (Old_Node).In_List;\n       Old_Post : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n       Old_CFS  : constant Boolean  := Nodes.Table (Old_Node).Comes_From_Source;\n \n@@ -2098,19 +2078,13 @@ package body Atree is\n \n       --  Do copy, preserving link and in list status and comes from source\n \n-      Nodes.Table (Old_Node)                   := Nodes.Table (New_Node);\n-      Nodes.Table (Old_Node).Link              := Old_Link;\n-      Nodes.Table (Old_Node).In_List           := Old_InL;\n+      Copy_Node (Source => New_Node, Destination => Old_Node);\n       Nodes.Table (Old_Node).Comes_From_Source := Old_CFS;\n       Nodes.Table (Old_Node).Error_Posted      := Old_Post;\n \n       --  Fix parents of substituted node, since it has changed identity\n \n-      Fix_Parent (Field1 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field2 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field3 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field4 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field5 (Old_Node), New_Node, Old_Node);\n+      Fix_Parents (New_Node, Old_Node);\n \n       --  Since we are doing a replace, we assume that the original node\n       --  is intended to become the new replaced node. The call would be\n@@ -2129,10 +2103,8 @@ package body Atree is\n \n    procedure Rewrite (Old_Node, New_Node : Node_Id) is\n \n-      Old_Link    : constant Union_Id := Nodes.Table (Old_Node).Link;\n-      Old_In_List : constant Boolean  := Nodes.Table (Old_Node).In_List;\n       Old_Error_P : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n-      --  These three fields are always preserved in the new node\n+      --  This fields is always preserved in the new node\n \n       Old_Paren_Count     : Paren_Count_Type;\n       Old_Must_Not_Freeze : Boolean;\n@@ -2165,36 +2137,22 @@ package body Atree is\n       --  that does not reference the Old_Node.\n \n       if Orig_Nodes.Table (Old_Node) = Old_Node then\n-         Nodes.Increment_Last;\n-         Sav_Node := Nodes.Last;\n-         Nodes.Table (Sav_Node)         := Nodes.Table (Old_Node);\n-         Nodes.Table (Sav_Node).In_List := False;\n-         Nodes.Table (Sav_Node).Link    := Union_Id (Parent (Old_Node));\n-\n-         Orig_Nodes.Increment_Last;\n-         Allocate_List_Tables (Nodes.Last);\n-\n+         Sav_Node := New_Copy (Old_Node);\n          Orig_Nodes.Table (Sav_Node) := Sav_Node;\n          Orig_Nodes.Table (Old_Node) := Sav_Node;\n       end if;\n \n       --  Copy substitute node into place, preserving old fields as required\n \n-      Nodes.Table (Old_Node)              := Nodes.Table (New_Node);\n-      Nodes.Table (Old_Node).Link         := Old_Link;\n-      Nodes.Table (Old_Node).In_List      := Old_In_List;\n+      Copy_Node (Source => New_Node, Destination => Old_Node);\n       Nodes.Table (Old_Node).Error_Posted := Old_Error_P;\n \n       if Nkind (New_Node) in N_Subexpr then\n          Set_Paren_Count     (Old_Node, Old_Paren_Count);\n          Set_Must_Not_Freeze (Old_Node, Old_Must_Not_Freeze);\n       end if;\n \n-      Fix_Parent (Field1 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field2 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field3 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field4 (Old_Node), New_Node, Old_Node);\n-      Fix_Parent (Field5 (Old_Node), New_Node, Old_Node);\n+      Fix_Parents (New_Node, Old_Node);\n    end Rewrite;\n \n    ------------------"}, {"sha": "aaad1a488c37f0a98d9997827182b4fe098f158a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 364, "deletions": 114, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -31,6 +31,7 @@ with Errout;   use Errout;\n with Exp_Ch2;  use Exp_Ch2;\n with Exp_Util; use Exp_Util;\n with Elists;   use Elists;\n+with Eval_Fat; use Eval_Fat;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n@@ -187,6 +188,14 @@ package body Checks is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Apply_Float_Conversion_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id);\n+   --  The checks on a conversion from a floating-point type to an integer\n+   --  type are delicate. They have to be performed before conversion, they\n+   --  have to raise an exception when the operand is a NaN, and rounding must\n+   --  be taken into account to determine the safe bounds of the operand.\n+\n    procedure Apply_Selected_Length_Checks\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n@@ -1346,6 +1355,186 @@ package body Checks is\n       end if;\n    end Apply_Divide_Check;\n \n+   ----------------------------------\n+   -- Apply_Float_Conversion_Check --\n+   ----------------------------------\n+\n+   --  Let F and I be the source and target types of the conversion.\n+   --  The Ada standard specifies that a floating-point value X is rounded\n+   --  to the nearest integer, with halfway cases being rounded away from\n+   --  zero. The rounded value of X is checked against I'Range.\n+\n+   --  The catch in the above paragraph is that there is no good way\n+   --  to know whether the round-to-integer operation resulted in\n+   --  overflow. A remedy is to perform a range check in the floating-point\n+   --  domain instead, however:\n+   --      (1)  The bounds may not be known at compile time\n+   --      (2)  The check must take into account possible rounding.\n+   --      (3)  The range of type I may not be exactly representable in F.\n+   --      (4)  The end-points I'First - 0.5 and I'Last + 0.5 may or may\n+   --           not be in range, depending on the sign of  I'First and I'Last.\n+   --      (5)  X may be a NaN, which will fail any comparison\n+\n+   --  The following steps take care of these issues converting X:\n+   --      (1) If either I'First or I'Last is not known at compile time, use\n+   --          I'Base instead of I in the next three steps and perform a\n+   --          regular range check against I'Range after conversion.\n+   --      (2) If I'First - 0.5 is representable in F then let Lo be that\n+   --          value and define Lo_OK as (I'First > 0). Otherwise, let Lo be\n+   --          F'Machine (T) and let Lo_OK be (Lo >= I'First). In other words,\n+   --          take one of the closest floating-point numbers to T, and see if\n+   --          it is in range or not.\n+   --      (3) If I'Last + 0.5 is representable in F then let Hi be that value\n+   --          and define Hi_OK as (I'Last < 0). Otherwise, let Hi be\n+   --          F'Rounding (T) and let Hi_OK be (Hi <= I'Last).\n+   --      (4) Raise CE when (Lo_OK and X < Lo) or (not Lo_OK and X <= Lo)\n+   --                     or (Hi_OK and X > Hi) or (not Hi_OK and X >= Hi)\n+\n+   procedure Apply_Float_Conversion_Check\n+     (Ck_Node    : Node_Id;\n+      Target_Typ : Entity_Id)\n+   is\n+      LB          : constant Node_Id := Type_Low_Bound (Target_Typ);\n+      HB          : constant Node_Id := Type_High_Bound (Target_Typ);\n+      Loc         : constant Source_Ptr := Sloc (Ck_Node);\n+      Expr_Type   : constant Entity_Id  := Base_Type (Etype (Ck_Node));\n+      Target_Base : constant Entity_Id  := Implementation_Base_Type\n+                                             (Target_Typ);\n+      Max_Bound   : constant Uint := UI_Expon\n+                                       (Machine_Radix (Expr_Type),\n+                                        Machine_Mantissa (Expr_Type) - 1) - 1;\n+      --  Largest bound, so bound plus or minus half is a machine number of F\n+\n+      Ifirst,\n+      Ilast     : Uint;         --  Bounds of integer type\n+      Lo, Hi    : Ureal;        --  Bounds to check in floating-point domain\n+      Lo_OK,\n+      Hi_OK     : Boolean;      --  True iff Lo resp. Hi belongs to I'Range\n+\n+      Lo_Chk,\n+      Hi_Chk    : Node_Id;      --  Expressions that are False iff check fails\n+\n+      Reason    : RT_Exception_Code;\n+\n+   begin\n+      if not Compile_Time_Known_Value (LB)\n+          or not Compile_Time_Known_Value (HB)\n+      then\n+         declare\n+            --  First check that the value falls in the range of the base\n+            --  type, to prevent overflow during conversion and then\n+            --  perform a regular range check against the (dynamic) bounds.\n+\n+            Par : constant Node_Id := Parent (Ck_Node);\n+\n+            pragma Assert (Target_Base /= Target_Typ);\n+            pragma Assert (Nkind (Par) = N_Type_Conversion);\n+\n+            Temp : constant Entity_Id :=\n+                    Make_Defining_Identifier (Loc,\n+                      Chars => New_Internal_Name ('T'));\n+\n+         begin\n+            Apply_Float_Conversion_Check (Ck_Node, Target_Base);\n+            Set_Etype (Temp, Target_Base);\n+\n+            Insert_Action (Parent (Par),\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Object_Definition => New_Occurrence_Of (Target_Typ, Loc),\n+                Expression => New_Copy_Tree (Par)),\n+                Suppress => All_Checks);\n+\n+            Insert_Action (Par,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Not_In (Loc,\n+                    Left_Opnd  => New_Occurrence_Of (Temp, Loc),\n+                    Right_Opnd => New_Occurrence_Of (Target_Typ, Loc)),\n+                Reason => CE_Range_Check_Failed));\n+            Rewrite (Par, New_Occurrence_Of (Temp, Loc));\n+\n+            return;\n+         end;\n+      end if;\n+\n+      --  Get the bounds of the target type\n+\n+      Ifirst := Expr_Value (LB);\n+      Ilast  := Expr_Value (HB);\n+\n+      --  Check against lower bound\n+\n+      if abs (Ifirst) < Max_Bound then\n+         Lo := UR_From_Uint (Ifirst) - Ureal_Half;\n+         Lo_OK := (Ifirst > 0);\n+      else\n+         Lo := Machine (Expr_Type, UR_From_Uint (Ifirst), Round_Even, Ck_Node);\n+         Lo_OK := (Lo >= UR_From_Uint (Ifirst));\n+      end if;\n+\n+      if Lo_OK then\n+\n+         --  Lo_Chk := (X >= Lo)\n+\n+         Lo_Chk := Make_Op_Ge (Loc,\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Right_Opnd => Make_Real_Literal (Loc, Lo));\n+\n+      else\n+         --  Lo_Chk := (X > Lo)\n+\n+         Lo_Chk := Make_Op_Gt (Loc,\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Right_Opnd => Make_Real_Literal (Loc, Lo));\n+      end if;\n+\n+      --  Check against higher bound\n+\n+      if abs (Ilast) < Max_Bound then\n+         Hi := UR_From_Uint (Ilast) + Ureal_Half;\n+         Hi_OK := (Ilast < 0);\n+      else\n+         Hi := Machine (Expr_Type, UR_From_Uint (Ilast), Round_Even, Ck_Node);\n+         Hi_OK := (Hi <= UR_From_Uint (Ilast));\n+      end if;\n+\n+      if Hi_OK then\n+\n+         --  Hi_Chk := (X <= Hi)\n+\n+         Hi_Chk := Make_Op_Le (Loc,\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Right_Opnd => Make_Real_Literal (Loc, Hi));\n+\n+      else\n+         --  Hi_Chk := (X < Hi)\n+\n+         Hi_Chk := Make_Op_Lt (Loc,\n+                     Left_Opnd => Duplicate_Subexpr_No_Checks (Ck_Node),\n+                     Right_Opnd => Make_Real_Literal (Loc, Hi));\n+      end if;\n+\n+      --  If the bounds of the target type are the same as those of the\n+      --  base type, the check is an overflow check as a range check is\n+      --  not performed in these cases.\n+\n+      if Expr_Value (Type_Low_Bound (Target_Base)) = Ifirst\n+        and then Expr_Value (Type_High_Bound (Target_Base)) = Ilast\n+      then\n+         Reason := CE_Overflow_Check_Failed;\n+      else\n+         Reason := CE_Range_Check_Failed;\n+      end if;\n+\n+      --  Raise CE if either conditions does not hold\n+\n+      Insert_Action (Ck_Node,\n+        Make_Raise_Constraint_Error (Loc,\n+          Condition => Make_Op_Not (Loc, Make_Op_And (Loc, Lo_Chk, Hi_Chk)),\n+          Reason    => Reason));\n+   end Apply_Float_Conversion_Check;\n+\n    ------------------------\n    -- Apply_Length_Check --\n    ------------------------\n@@ -1918,18 +2107,27 @@ package body Checks is\n             --  and no floating point type is involved in the type conversion\n             --  then fixed point values must be read as integral values.\n \n+            Float_To_Int : constant Boolean :=\n+                             Is_Floating_Point_Type (Expr_Type)\n+                               and then Is_Integer_Type (Target_Type);\n+\n          begin\n             if not Overflow_Checks_Suppressed (Target_Base)\n               and then not In_Subrange_Of (Expr_Type, Target_Base, Conv_OK)\n+              and then not Float_To_Int\n             then\n                Set_Do_Overflow_Check (N);\n             end if;\n \n             if not Range_Checks_Suppressed (Target_Type)\n               and then not Range_Checks_Suppressed (Expr_Type)\n             then\n-               Apply_Scalar_Range_Check\n-                 (Expr, Target_Type, Fixed_Int => Conv_OK);\n+               if Float_To_Int then\n+                  Apply_Float_Conversion_Check (Expr, Target_Type);\n+               else\n+                  Apply_Scalar_Range_Check\n+                    (Expr, Target_Type, Fixed_Int => Conv_OK);\n+               end if;\n             end if;\n          end;\n \n@@ -2193,162 +2391,214 @@ package body Checks is\n \n    procedure Null_Exclusion_Static_Checks (N : Node_Id) is\n       K                  : constant Node_Kind := Nkind (N);\n-      Expr               : Node_Id;\n       Typ                : Entity_Id;\n       Related_Nod        : Node_Id;\n       Has_Null_Exclusion : Boolean := False;\n \n-      --  Following declarations and subprograms are just used to qualify the\n-      --  error messages\n-\n       type Msg_Kind is (Components, Formals, Objects);\n       Msg_K : Msg_Kind := Objects;\n+      --  Used by local subprograms to generate precise error messages\n \n-      procedure Must_Be_Initialized;\n-      procedure Null_Not_Allowed;\n+      procedure Check_Must_Be_Access\n+        (Typ                : Entity_Id;\n+         Has_Null_Exclusion : Boolean);\n+      --  ??? local subprograms must have comment on spec\n \n-      -------------------------\n-      -- Must_Be_Initialized --\n-      -------------------------\n+      procedure Check_Already_Null_Excluding_Type\n+        (Typ                : Entity_Id;\n+         Has_Null_Exclusion : Boolean;\n+         Related_Nod        : Node_Id);\n+      --  ??? local subprograms must have comment on spec\n+\n+      procedure Check_Must_Be_Initialized\n+        (N           : Node_Id;\n+         Related_Nod : Node_Id);\n+      --  ??? local subprograms must have comment on spec\n+\n+      procedure Check_Null_Not_Allowed (N : Node_Id);\n+      --  ??? local subprograms must have comment on spec\n+\n+      --  ??? following bodies lack comments\n \n-      procedure Must_Be_Initialized is\n+      --------------------------\n+      -- Check_Must_Be_Access --\n+      --------------------------\n+\n+      procedure Check_Must_Be_Access\n+        (Typ                : Entity_Id;\n+         Has_Null_Exclusion : Boolean)\n+      is\n       begin\n-         case Msg_K is\n-            when Components =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) null-excluding components must be initialized\",\n-                  Related_Nod);\n-\n-            when Formals =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) null-excluding formals must be initialized\",\n-                  Related_Nod);\n-\n-            when Objects =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) null-excluding objects must be initialized\",\n-                  Related_Nod);\n-         end case;\n-      end Must_Be_Initialized;\n+         if Has_Null_Exclusion\n+           and then not Is_Access_Type (Typ)\n+         then\n+            Error_Msg_N (\"(Ada 0Y) must be an access type\", Related_Nod);\n+         end if;\n+      end Check_Must_Be_Access;\n \n-      ----------------------\n-      -- Null_Not_Allowed --\n-      ----------------------\n+      ---------------------------------------\n+      -- Check_Already_Null_Excluding_Type --\n+      ---------------------------------------\n \n-      procedure Null_Not_Allowed is\n+      procedure Check_Already_Null_Excluding_Type\n+        (Typ                : Entity_Id;\n+         Has_Null_Exclusion : Boolean;\n+         Related_Nod        : Node_Id)\n+      is\n       begin\n-         case Msg_K is\n-            when Components =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) NULL not allowed in null-excluding components\",\n-                  Expr);\n-\n-            when Formals =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) NULL not allowed in null-excluding formals\",\n-                  Expr);\n-\n-            when Objects =>\n-               Error_Msg_N\n-                 (\"(Ada 0Y) NULL not allowed in null-excluding objects\",\n-                  Expr);\n-         end case;\n-      end Null_Not_Allowed;\n+         if Has_Null_Exclusion\n+           and then Can_Never_Be_Null (Typ)\n+         then\n+            Error_Msg_N\n+              (\"(Ada 0Y) already a null-excluding type\", Related_Nod);\n+         end if;\n+      end Check_Already_Null_Excluding_Type;\n+\n+      -------------------------------\n+      -- Check_Must_Be_Initialized --\n+      -------------------------------\n+\n+      procedure Check_Must_Be_Initialized\n+        (N           : Node_Id;\n+         Related_Nod : Node_Id)\n+      is\n+         Expr        : constant Node_Id := Expression (N);\n+\n+      begin\n+         pragma Assert (Nkind (N) = N_Component_Declaration\n+                          or else Nkind (N) = N_Object_Declaration);\n+\n+         if not Present (Expr) then\n+            case Msg_K is\n+               when Components =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) null-excluding components must be initialized\",\n+                     Related_Nod);\n+\n+               when Formals =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) null-excluding formals must be initialized\",\n+                     Related_Nod);\n+\n+               when Objects =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) null-excluding objects must be initialized\",\n+                     Related_Nod);\n+            end case;\n+         end if;\n+      end Check_Must_Be_Initialized;\n+\n+      ----------------------------\n+      -- Check_Null_Not_Allowed --\n+      ----------------------------\n+\n+      procedure Check_Null_Not_Allowed (N : Node_Id) is\n+         Expr : constant Node_Id := Expression (N);\n+\n+      begin\n+         if Present (Expr)\n+           and then Nkind (Expr) = N_Null\n+         then\n+            case Msg_K is\n+               when Components =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) NULL not allowed in null-excluding components\",\n+                     Expr);\n+\n+               when Formals =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) NULL not allowed in null-excluding formals\",\n+                     Expr);\n+\n+               when Objects =>\n+                  Error_Msg_N\n+                    (\"(Ada 0Y) NULL not allowed in null-excluding objects\",\n+                     Expr);\n+            end case;\n+         end if;\n+      end Check_Null_Not_Allowed;\n \n    --  Start of processing for Null_Exclusion_Static_Checks\n \n    begin\n       pragma Assert (K = N_Component_Declaration\n-                     or else K = N_Parameter_Specification\n-                     or else K = N_Object_Declaration\n-                     or else K = N_Discriminant_Specification\n-                     or else K = N_Allocator);\n-\n-      Expr := Expression (N);\n+                       or else K = N_Parameter_Specification\n+                       or else K = N_Object_Declaration\n+                       or else K = N_Discriminant_Specification\n+                       or else K = N_Allocator);\n \n       case K is\n          when N_Component_Declaration =>\n-            Msg_K               := Components;\n-            Has_Null_Exclusion  := Null_Exclusion_Present\n-                                     (Component_Definition (N));\n-            Typ                 := Etype (Subtype_Indication\n-                                           (Component_Definition (N)));\n-            Related_Nod         := Subtype_Indication\n-                                     (Component_Definition (N));\n+            Msg_K := Components;\n+\n+            if not Present (Access_Definition (Component_Definition (N))) then\n+               Has_Null_Exclusion  := Null_Exclusion_Present\n+                                        (Component_Definition (N));\n+               Typ := Etype (Subtype_Indication (Component_Definition (N)));\n+               Related_Nod := Subtype_Indication (Component_Definition (N));\n+               Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n+               Check_Already_Null_Excluding_Type\n+                 (Typ, Has_Null_Exclusion, Related_Nod);\n+               Check_Must_Be_Initialized (N, Related_Nod);\n+            end if;\n+\n+            Check_Null_Not_Allowed (N);\n \n          when N_Parameter_Specification =>\n-            Msg_K              := Formals;\n+            Msg_K := Formals;\n             Has_Null_Exclusion := Null_Exclusion_Present (N);\n-            Typ                := Entity (Parameter_Type (N));\n-            Related_Nod        := Parameter_Type (N);\n+            Typ := Entity (Parameter_Type (N));\n+            Related_Nod := Parameter_Type (N);\n+            Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n+            Check_Already_Null_Excluding_Type\n+              (Typ, Has_Null_Exclusion, Related_Nod);\n+            Check_Null_Not_Allowed (N);\n \n          when N_Object_Declaration =>\n-            Msg_K              := Objects;\n+            Msg_K := Objects;\n             Has_Null_Exclusion := Null_Exclusion_Present (N);\n-            Typ                := Entity (Object_Definition (N));\n-            Related_Nod        := Object_Definition (N);\n+            Typ := Entity (Object_Definition (N));\n+            Related_Nod := Object_Definition (N);\n+            Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n+            Check_Already_Null_Excluding_Type\n+              (Typ, Has_Null_Exclusion, Related_Nod);\n+            Check_Must_Be_Initialized (N, Related_Nod);\n+            Check_Null_Not_Allowed (N);\n \n          when N_Discriminant_Specification =>\n-            Msg_K              := Components;\n-\n-            if Nkind (Discriminant_Type (N)) = N_Access_Definition then\n+            Msg_K := Components;\n \n-               --  This case is special. We do not want to carry out some of\n-               --  the null-excluding checks. Reason: the analysis of the\n-               --  access_definition propagates the null-excluding attribute\n-               --  to the can_never_be_null entity attribute (and thus it is\n-               --  wrong to check it now)\n-\n-               Has_Null_Exclusion := False;\n-            else\n+            if Nkind (Discriminant_Type (N)) /= N_Access_Definition then\n                Has_Null_Exclusion := Null_Exclusion_Present (N);\n+               Typ := Etype (Defining_Identifier (N));\n+               Related_Nod := Discriminant_Type (N);\n+               Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n+               Check_Already_Null_Excluding_Type\n+                 (Typ, Has_Null_Exclusion, Related_Nod);\n             end if;\n \n-            Typ                := Etype (Defining_Identifier (N));\n-            Related_Nod        := Discriminant_Type (N);\n+            Check_Null_Not_Allowed (N);\n \n          when N_Allocator =>\n-            Msg_K              := Objects;\n+            Msg_K := Objects;\n             Has_Null_Exclusion := Null_Exclusion_Present (N);\n-            Typ                := Etype (Expr);\n+            Typ := Etype (Expression (N));\n \n-            if Nkind (Expr) = N_Qualified_Expression then\n-               Related_Nod     := Subtype_Mark (Expr);\n+            if Nkind (Expression (N)) = N_Qualified_Expression then\n+               Related_Nod := Subtype_Mark (Expression (N));\n             else\n-               Related_Nod     := Expr;\n+               Related_Nod := Expression (N);\n             end if;\n \n+            Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n+            Check_Already_Null_Excluding_Type\n+              (Typ, Has_Null_Exclusion, Related_Nod);\n+            Check_Null_Not_Allowed (N);\n+\n          when others =>\n             pragma Assert (False);\n             null;\n       end case;\n-\n-      --  Check that the entity was already decorated\n-\n-      pragma Assert (Typ /= Empty);\n-\n-      if Has_Null_Exclusion\n-        and then not Is_Access_Type (Typ)\n-      then\n-         Error_Msg_N (\"(Ada 0Y) must be an access type\", Related_Nod);\n-\n-      elsif Has_Null_Exclusion\n-        and then Can_Never_Be_Null (Typ)\n-      then\n-         Error_Msg_N\n-           (\"(Ada 0Y) already a null-excluding type\", Related_Nod);\n-\n-      elsif (Nkind (N) = N_Component_Declaration\n-             or else Nkind (N) = N_Object_Declaration)\n-        and not Present (Expr)\n-      then\n-         Must_Be_Initialized;\n-\n-      elsif Present (Expr)\n-        and then Nkind (Expr) = N_Null\n-      then\n-         Null_Not_Allowed;\n-      end if;\n    end Null_Exclusion_Static_Checks;\n \n    ----------------------------------"}, {"sha": "83bfec045b97043e93df534133b5d3791391bf26", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1060,10 +1060,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n-\t  SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl,\n-\t      create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n-\t\t\t       gnu_expr, 0, Is_Public (gnat_entity), 0,\n-\t\t\t       static_p, 0));\n+\t  SET_DECL_CONST_CORRESPONDING_VAR\n+\t    (gnu_decl,\n+\t     create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t\t\t      gnu_expr, 0, Is_Public (gnat_entity), 0,\n+\t\t\t      static_p, 0));\n \n \t/* If this is declared in a block that contains an block with an\n \t   exception handler, we must force this variable in memory to\n@@ -4407,8 +4408,15 @@ maybe_variable (tree gnu_operand, Node_Id gnat_node)\n   set_lineno (gnat_node, 1);\n \n   if (TREE_CODE (gnu_operand) == UNCONSTRAINED_ARRAY_REF)\n-    return build1 (UNCONSTRAINED_ARRAY_REF, TREE_TYPE (gnu_operand),\n-\t\t   variable_size (TREE_OPERAND (gnu_operand, 0)));\n+    {\n+      tree gnu_result = build1 (UNCONSTRAINED_ARRAY_REF,\n+\t\t\t\tTREE_TYPE (gnu_operand),\n+\t\t\t\tvariable_size (TREE_OPERAND (gnu_operand, 0)));\n+\n+      TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result)\n+\t= TYPE_READONLY (TREE_TYPE (TREE_TYPE (gnu_operand)));\n+      return gnu_result;\n+    }\n   else\n     return variable_size (gnu_operand);\n }\n@@ -4600,8 +4608,10 @@ make_packable_type (tree type)\n   TYPE_LEFT_JUSTIFIED_MODULAR_P (new_type)\n     = TYPE_LEFT_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n-  TYPE_IS_PADDING_P (new_type) = TYPE_IS_PADDING_P (type);\n-  if (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    TYPE_IS_PADDING_P (new_type) = TYPE_IS_PADDING_P (type);\n+  else if (TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n       TYPE_SIZE (new_type) = TYPE_SIZE (type);\n       TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (type);"}, {"sha": "d083c32ba5cde5dbe5592d429516dd7515c08d17", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -83,9 +83,6 @@ package body Eval_Fat is\n    function Machine_Emin (RT : R) return Int;\n    --  Return value of the Machine_Emin attribute\n \n-   function Machine_Mantissa (RT : R) return Nat;\n-   --  Return value of the Machine_Mantissa attribute\n-\n    --------------\n    -- Adjacent --\n    --------------\n@@ -706,6 +703,16 @@ package body Eval_Fat is\n       return Mant;\n    end Machine_Mantissa;\n \n+   -------------------\n+   -- Machine_Radix --\n+   -------------------\n+\n+   function Machine_Radix (RT : R) return Nat is\n+      pragma Warnings (Off, RT);\n+   begin\n+      return Radix;\n+   end Machine_Radix;\n+\n    -----------\n    -- Model --\n    -----------"}, {"sha": "4f245696491e70fbd6b8a82d9a275f7ed703ce92", "filename": "gcc/ada/eval_fat.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Feval_fat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Feval_fat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -66,6 +66,10 @@ package Eval_Fat is\n \n    function Leading_Part      (RT : R; X : T; Radix_Digits : UI)    return T;\n \n+   function Machine_Mantissa  (RT : R)                              return Nat;\n+\n+   function Machine_Radix     (RT : R)                              return Nat;\n+\n    function Model             (RT : R; X : T)                       return T;\n \n    function Pred              (RT : R; X : T)                       return T;"}, {"sha": "8dd7492a6318f5ab10453c797dd9e8236305e987", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1165,7 +1165,7 @@ package body Exp_Aggr is\n \n       Aggr_Low  : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_L);\n       Aggr_High : constant Node_Id := Duplicate_Subexpr_No_Checks (Aggr_H);\n-      --  After Duplicate_Subexpr these are side-effect free.\n+      --  After Duplicate_Subexpr these are side-effect free\n \n       Low        : Node_Id;\n       High       : Node_Id;"}, {"sha": "040377e2f6d4f0ea1c27c030c8077272af491ff6", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -3625,8 +3625,8 @@ package body Exp_Attr is\n          --     type(X)'Pos (X) >= 0\n \n          --  We can't quite generate it that way because of the requirement\n-         --  for the non-standard second argument of False, so we have to\n-         --  explicitly create:\n+         --  for the non-standard second argument of False in the resulting\n+         --  rep_to_pos call, so we have to explicitly create:\n \n          --     _rep_to_pos (X, False) >= 0\n \n@@ -3635,7 +3635,7 @@ package body Exp_Attr is\n \n          --    _rep_to_pos (X, False) >= 0\n          --      and then\n-         --     (X >= type(X)'First and then type(X)'Last <= X)\n+         --       (X >= type(X)'First and then type(X)'Last <= X)\n \n          elsif Is_Enumeration_Type (Ptyp)\n            and then Present (Enum_Pos_To_Rep (Base_Type (Ptyp)))\n@@ -3710,7 +3710,7 @@ package body Exp_Attr is\n \n          --  But that's precisely what won't work because of possible\n          --  unwanted optimization (and indeed the basic motivation for\n-         --  the Valid attribute -is exactly that this test does not work.\n+         --  the Valid attribute is exactly that this test does not work!)\n          --  What will work is:\n \n          --     Btyp!(X) >= Btyp!(type(X)'First)"}, {"sha": "60a11478cb7dec65e1563008c55e10672f18f0f0", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -93,7 +93,6 @@ package body Exp_Ch13 is\n \n             declare\n                Decl : constant Node_Id := Declaration_Node (Ent);\n-\n             begin\n                if Nkind (Decl) = N_Object_Declaration\n                   and then Present (Expression (Decl))"}, {"sha": "aec55719a8db7eaa6e217f503e1c01079612b870", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -374,6 +374,7 @@ package body Exp_Ch4 is\n \n          --  We analyze by hand the new internal allocator to avoid\n          --  any recursion and inappropriate call to Initialize\n+\n          if not Aggr_In_Place then\n             Remove_Side_Effects (Exp);\n          end if;\n@@ -2698,10 +2699,11 @@ package body Exp_Ch4 is\n    -----------------\n \n    procedure Expand_N_In (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Rtyp : constant Entity_Id  := Etype (N);\n-      Lop  : constant Node_Id    := Left_Opnd (N);\n-      Rop  : constant Node_Id    := Right_Opnd (N);\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Rtyp   : constant Entity_Id  := Etype (N);\n+      Lop    : constant Node_Id    := Left_Opnd (N);\n+      Rop    : constant Node_Id    := Right_Opnd (N);\n+      Static : constant Boolean    := Is_OK_Static_Expression (N);\n \n    begin\n       --  If we have an explicit range, do a bit of optimization based\n@@ -2717,11 +2719,14 @@ package body Exp_Ch4 is\n          begin\n             --  If either check is known to fail, replace result\n             --  by False, since the other check does not matter.\n+            --  Preserve the static flag for legality checks, because\n+            --  we are constant-folding beyond RM 4.9.\n \n             if Lcheck = LT or else Ucheck = GT then\n                Rewrite (N,\n                  New_Reference_To (Standard_False, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n+               Set_Is_Static_Expression (N, Static);\n                return;\n \n             --  If both checks are known to succeed, replace result\n@@ -2731,6 +2736,7 @@ package body Exp_Ch4 is\n                Rewrite (N,\n                  New_Reference_To (Standard_True, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n+               Set_Is_Static_Expression (N, Static);\n                return;\n \n             --  If lower bound check succeeds and upper bound check is"}, {"sha": "c9d59c22d499c50e4fed8d12dca8de956d72d140", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 84, "deletions": 63, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1626,9 +1626,8 @@ package body Exp_Ch6 is\n                     Get_Remotely_Callable\n                       (Duplicate_Subexpr_Move_Checks (Actual))),\n                 Then_Statements => New_List (\n-                  Make_Procedure_Call_Statement (Loc,\n-                    New_Occurrence_Of (RTE\n-                      (RE_Raise_Program_Error_For_E_4_18), Loc)))));\n+                  Make_Raise_Program_Error (Loc,\n+                    Reason => PE_Illegal_RACW_E_4_18))));\n          end if;\n \n          Next_Actual (Actual);\n@@ -2459,18 +2458,19 @@ package body Exp_Ch6 is\n \n             declare\n                Original_Assignment : constant Node_Id := Parent (N);\n-               Saved_Assignment    : constant Node_Id :=\n-                                       Relocate_Node (Original_Assignment);\n-               pragma Warnings (Off, Saved_Assignment);\n+\n+            begin\n                --  Preserve the original assignment node to keep the\n                --  complete assignment subtree consistent enough for\n-               --  Analyze_Assignment to proceed. We do not use the\n-               --  saved value, the point was just to do the relocation.\n+               --  Analyze_Assignment to proceed (specifically, the\n+               --  original Lhs node must still have an assignment\n+               --  statement as its parent).\n+\n                --  We cannot rely on Original_Node to go back from the\n                --  block node to the assignment node, because the\n                --  assignment might already be a rewrite substitution.\n \n-            begin\n+               Discard_Node (Relocate_Node (Original_Assignment));\n                Rewrite (Original_Assignment, Blk);\n             end;\n \n@@ -2766,11 +2766,16 @@ package body Exp_Ch6 is\n    ----------------------------\n \n    procedure Expand_N_Function_Call (N : Node_Id) is\n-      Typ : constant Entity_Id := Etype (N);\n+      Typ   : constant Entity_Id := Etype (N);\n \n       function Returned_By_Reference return Boolean;\n       --  If the return type is returned through the secondary stack. that is\n       --  by reference, we don't want to create a temp to force stack checking.\n+      --  Shouldn't this function be moved to exp_util???\n+\n+      ---------------------------\n+      -- Returned_By_Reference --\n+      ---------------------------\n \n       function Returned_By_Reference return Boolean is\n          S : Entity_Id := Current_Scope;\n@@ -2816,68 +2821,84 @@ package body Exp_Ch6 is\n              or else Expression (Parent (N)) /= N)\n         and then not Returned_By_Reference\n       then\n-         --  Note: it might be thought that it would be OK to use a call to\n-         --  Force_Evaluation here, but that's not good enough, because that\n-         --  results in a 'Reference construct that may still need a temporary.\n+         if Stack_Checking_Enabled then\n \n-         declare\n-            Loc      : constant Source_Ptr := Sloc (N);\n-            Temp_Obj : constant Entity_Id :=\n-                         Make_Defining_Identifier (Loc,\n-                           Chars => New_Internal_Name ('F'));\n-            Temp_Typ : Entity_Id := Typ;\n-            Decl     : Node_Id;\n-            A        : Node_Id;\n-            F        : Entity_Id;\n-            Proc     : Entity_Id;\n+            --  Note: it might be thought that it would be OK to use a call\n+            --  to Force_Evaluation here, but that's not good enough, because\n+            --  that can results in a 'Reference construct that may still\n+            --  need a temporary.\n \n-         begin\n-            if Is_Tagged_Type (Typ)\n-              and then Present (Controlling_Argument (N))\n-            then\n-               if Nkind (Parent (N)) /= N_Procedure_Call_Statement\n-                 and then Nkind (Parent (N)) /= N_Function_Call\n+            declare\n+               Loc      : constant Source_Ptr := Sloc (N);\n+               Temp_Obj : constant Entity_Id :=\n+                            Make_Defining_Identifier (Loc,\n+                              Chars => New_Internal_Name ('F'));\n+               Temp_Typ : Entity_Id := Typ;\n+               Decl     : Node_Id;\n+               A        : Node_Id;\n+               F        : Entity_Id;\n+               Proc     : Entity_Id;\n+\n+            begin\n+               if Is_Tagged_Type (Typ)\n+                 and then Present (Controlling_Argument (N))\n                then\n-                  --  If this is a tag-indeterminate call, the object must\n-                  --  be classwide.\n+                  if Nkind (Parent (N)) /= N_Procedure_Call_Statement\n+                    and then Nkind (Parent (N)) /= N_Function_Call\n+                  then\n+                     --  If this is a tag-indeterminate call, the object must\n+                     --  be classwide.\n \n-                  if Is_Tag_Indeterminate (N) then\n-                     Temp_Typ := Class_Wide_Type (Typ);\n-                  end if;\n+                     if Is_Tag_Indeterminate (N) then\n+                        Temp_Typ := Class_Wide_Type (Typ);\n+                     end if;\n \n-               else\n-                  --  If this is a dispatching call that is itself the\n-                  --  controlling argument of an enclosing call, the nominal\n-                  --  subtype of the object that replaces it must be classwide,\n-                  --  so that dispatching will take place properly. If it is\n-                  --  not a controlling argument, the object is not classwide.\n-\n-                  Proc := Entity (Name (Parent (N)));\n-                  F    := First_Formal (Proc);\n-                  A    := First_Actual (Parent (N));\n-\n-                  while A /= N loop\n-                     Next_Formal (F);\n-                     Next_Actual (A);\n-                  end loop;\n+                  else\n+                     --  If this is a dispatching call that is itself the\n+                     --  controlling argument of an enclosing call, the\n+                     --  nominal subtype of the object that replaces it must\n+                     --  be classwide, so that dispatching will take place\n+                     --  properly. If it is not a controlling argument, the\n+                     --  object is not classwide.\n+\n+                     Proc := Entity (Name (Parent (N)));\n+                     F    := First_Formal (Proc);\n+                     A    := First_Actual (Parent (N));\n+\n+                     while A /= N loop\n+                        Next_Formal (F);\n+                        Next_Actual (A);\n+                     end loop;\n \n-                  if Is_Controlling_Formal (F) then\n-                     Temp_Typ := Class_Wide_Type (Typ);\n+                     if Is_Controlling_Formal (F) then\n+                        Temp_Typ := Class_Wide_Type (Typ);\n+                     end if;\n                   end if;\n                end if;\n-            end if;\n \n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp_Obj,\n-                Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n-                Constant_Present    => True,\n-                Expression          => Relocate_Node (N));\n-            Set_Assignment_OK (Decl);\n-\n-            Insert_Actions (N, New_List (Decl));\n-            Rewrite (N, New_Occurrence_Of (Temp_Obj, Loc));\n-         end;\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp_Obj,\n+                   Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n+                   Constant_Present    => True,\n+                   Expression          => Relocate_Node (N));\n+               Set_Assignment_OK (Decl);\n+\n+               Insert_Actions (N, New_List (Decl));\n+               Rewrite (N, New_Occurrence_Of (Temp_Obj, Loc));\n+            end;\n+\n+         else\n+            --  If stack-checking is not enabled, increment serial number\n+            --  for internal names, so that subsequent symbols are consistent\n+            --  with and without stack-checking.\n+\n+            Synchronize_Serial_Number;\n+\n+            --  Now we can expand the call with consistent symbol names\n+\n+            Expand_Call (N);\n+         end if;\n \n       --  Normal case, expand the call\n "}, {"sha": "c712eacc108051e5cc48373725c2402e941797f1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -3282,10 +3282,11 @@ package body Exp_Ch9 is\n           Defining_Identifier => D_T2,\n           Type_Definition => Def1);\n \n+      Analyze (Decl1);\n       Insert_After (N, Decl1);\n \n       --  Create Equivalent_Type, a record with two components for an\n-      --  an access to object an an access to subprogram.\n+      --  access to object and an access to subprogram.\n \n       Comps := New_List (\n         Make_Component_Declaration (Loc,\n@@ -3314,6 +3315,7 @@ package body Exp_Ch9 is\n                 Make_Component_List (Loc,\n                   Component_Items => Comps)));\n \n+      Analyze (Decl2);\n       Insert_After (Decl1, Decl2);\n       Set_Equivalent_Type (T, E_T);\n    end Expand_Access_Protected_Subprogram_Type;"}, {"sha": "be3eee56af7e0e2f52394302be2202157c849914", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1996-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -913,12 +913,7 @@ package body Exp_Dbug is\n \n          --  If we exit the loop then suffix must be output\n \n-         if No_Dollar_In_Label then\n-            Add_Str_To_Name_Buffer (\"__\");\n-         else\n-            Add_Char_To_Name_Buffer ('$');\n-         end if;\n-\n+         Add_Str_To_Name_Buffer (\"__\");\n          Add_Str_To_Name_Buffer (Homonym_Numbers (1 .. Homonym_Len));\n          Homonym_Len := 0;\n       end if;\n@@ -1310,54 +1305,28 @@ package body Exp_Dbug is\n \n       --  Search for and strip homonym numbers suffix\n \n-      --  Case of __ used for homonym numbers suffix\n-\n-      if No_Dollar_In_Label then\n-         for J in reverse 2 .. Name_Len - 2 loop\n-            if Name_Buffer (J) = '_'\n-              and then Name_Buffer (J + 1) = '_'\n-            then\n-               if Name_Buffer (J + 2) in '0' .. '9' then\n-                  if Homonym_Len > 0 then\n-                     Homonym_Len := Homonym_Len + 1;\n-                     Homonym_Numbers (Homonym_Len) := '-';\n-                  end if;\n-\n-                  SL := Name_Len - (J + 1);\n-\n-                  Homonym_Numbers (Homonym_Len + 1 .. Homonym_Len + SL) :=\n-                    Name_Buffer (J + 2 .. Name_Len);\n-                  Name_Len := J - 1;\n-                  Homonym_Len := Homonym_Len + SL;\n+      for J in reverse 2 .. Name_Len - 2 loop\n+         if Name_Buffer (J) = '_'\n+           and then Name_Buffer (J + 1) = '_'\n+         then\n+            if Name_Buffer (J + 2) in '0' .. '9' then\n+               if Homonym_Len > 0 then\n+                  Homonym_Len := Homonym_Len + 1;\n+                  Homonym_Numbers (Homonym_Len) := '-';\n                end if;\n \n-               exit;\n-            end if;\n-         end loop;\n-\n-      --  Case of $ used for homonym numbers suffix\n-\n-      else\n-         for J in reverse 2 .. Name_Len - 1 loop\n-            if Name_Buffer (J) = '$' then\n-               if Name_Buffer (J + 1) in '0' .. '9' then\n-                  if Homonym_Len > 0 then\n-                     Homonym_Len := Homonym_Len + 1;\n-                     Homonym_Numbers (Homonym_Len) := '-';\n-                  end if;\n+               SL := Name_Len - (J + 1);\n \n-                  SL := Name_Len - J;\n+               Homonym_Numbers (Homonym_Len + 1 .. Homonym_Len + SL) :=\n+                 Name_Buffer (J + 2 .. Name_Len);\n+               Name_Len := J - 1;\n+               Homonym_Len := Homonym_Len + SL;\n+            end if;\n \n-                  Homonym_Numbers (Homonym_Len + 1 .. Homonym_Len + SL) :=\n-                    Name_Buffer (J + 1 .. Name_Len);\n-                  Name_Len := J - 1;\n-                  Homonym_Len := Homonym_Len + SL;\n-               end if;\n+            exit;\n+         end if;\n+      end loop;\n \n-               exit;\n-            end if;\n-         end loop;\n-      end if;\n    end Strip_Suffixes;\n \n end Exp_Dbug;"}, {"sha": "51dd15e89938bdea71d7493c3c331b9db6e629c0", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -80,6 +80,10 @@ package body Exp_Dist is\n    -- Local subprograms --\n    -----------------------\n \n+   function Get_Subprogram_Id (E : Entity_Id) return Int;\n+   --  Given a subprogram defined in a RCI package, get its subprogram id\n+   --  which will be used for remote calls.\n+\n    procedure Build_General_Calling_Stubs\n      (Decls                     : in List_Id;\n       Statements                : in List_Id;\n@@ -2749,6 +2753,18 @@ package body Exp_Dist is\n             Make_Handled_Sequence_Of_Statements (Loc, Statements));\n    end Build_Subprogram_Calling_Stubs;\n \n+   -------------------------\n+   -- Build_Subprogram_Id --\n+   -------------------------\n+\n+   function Build_Subprogram_Id\n+     (Loc : Source_Ptr;\n+      E   : Entity_Id) return Node_Id\n+   is\n+   begin\n+      return Make_Integer_Literal (Loc, Get_Subprogram_Id (E));\n+   end Build_Subprogram_Id;\n+\n    --------------------------------------\n    -- Build_Subprogram_Receiving_Stubs --\n    --------------------------------------\n@@ -2789,7 +2805,7 @@ package body Exp_Dist is\n       Excep_Code    : List_Id;\n \n       Parameter_List : constant List_Id := New_List;\n-      --  List of parameters to be passed to the subprogram.\n+      --  List of parameters to be passed to the subprogram\n \n       Current_Parameter : Node_Id;\n \n@@ -3469,6 +3485,47 @@ package body Exp_Dist is\n       return End_String;\n    end Get_String_Id;\n \n+   -----------------------\n+   -- Get_Subprogram_Id --\n+   -----------------------\n+\n+   function Get_Subprogram_Id (E : Entity_Id) return Int is\n+      Current_Declaration : Node_Id;\n+      Result              : Int := 0;\n+\n+   begin\n+      pragma Assert\n+        (Is_Remote_Call_Interface (Scope (E))\n+           and then\n+             (Nkind (Parent (E)) = N_Procedure_Specification\n+                or else\n+              Nkind (Parent (E)) = N_Function_Specification));\n+\n+      Current_Declaration :=\n+        First (Visible_Declarations\n+          (Package_Specification_Of_Scope (Scope (E))));\n+\n+      while Current_Declaration /= Empty loop\n+         if Nkind (Current_Declaration) = N_Subprogram_Declaration\n+           and then Comes_From_Source (Current_Declaration)\n+         then\n+            if Defining_Unit_Name\n+                 (Specification (Current_Declaration)) = E\n+            then\n+               return Result;\n+            end if;\n+\n+            Result := Result + 1;\n+         end if;\n+\n+         Next (Current_Declaration);\n+      end loop;\n+\n+      --  Error if we do not find it\n+\n+      raise Program_Error;\n+   end Get_Subprogram_Id;\n+\n    ----------\n    -- Hash --\n    ----------"}, {"sha": "10cbc60bdb4ac74abcaa7c741c6ef431db6b5899", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,4 +78,9 @@ package Exp_Dist is\n    --  Build stub for a shared passive package. U is the analyzed\n    --  compilation unit for a package declaration.\n \n+   function Build_Subprogram_Id\n+     (Loc : Source_Ptr;\n+      E   : Entity_Id) return Node_Id;\n+   --  Build a literal representing the remote subprogram identifier of E\n+\n end Exp_Dist;"}, {"sha": "9fe4052297066146c96bed6a3e38b2e67ee3e765", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -214,7 +214,7 @@ package body Exp_Intr is\n       Nam : Name_Id;\n \n    begin\n-      --  If the intrinsic subprogram is generic, gets its original name.\n+      --  If the intrinsic subprogram is generic, gets its original name\n \n       if Present (Parent (E))\n         and then Present (Generic_Parent (Parent (E)))"}, {"sha": "e38bcce3bafbbacdf405107249e8c2998142c2e2", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -3056,10 +3056,7 @@ package body Exp_Util is\n \n    function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean is\n    begin\n-      if not Stack_Checking_Enabled then\n-         return False;\n-\n-      elsif not Size_Known_At_Compile_Time (Typ) then\n+      if not Size_Known_At_Compile_Time (Typ) then\n          return False;\n \n       elsif Esize (Typ) /= 0 and then Esize (Typ) <= 256 then\n@@ -3785,7 +3782,9 @@ package body Exp_Util is\n       --  in stack checking mode.\n \n       elsif Size_Known_At_Compile_Time (Otyp)\n-        and then not May_Generate_Large_Temp (Otyp)\n+        and then\n+          (not Stack_Checking_Enabled\n+             or else not May_Generate_Large_Temp (Otyp))\n         and then not (Is_Record_Type (Otyp) and then not Is_Constrained (Otyp))\n       then\n          return True;"}, {"sha": "2382207831baa23c88ba3563a067f7145b2eee50", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -490,12 +490,13 @@ package Exp_Util is\n \n    function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean;\n    --  Determines if the given type, Typ, may require a large temporary\n-   --  of the type that causes trouble if stack checking is enabled. The\n-   --  result is True only if stack checking is enabled and the size of\n-   --  the type is known at compile time and large, where large is defined\n-   --  hueristically by the body of this routine. The purpose of this\n-   --  routine is to help avoid generating troublesome temporaries that\n-   --  intefere with the stack checking mechanism.\n+   --  of the kind that causes back-end trouble if stack checking is enabled.\n+   --  The result is True only the size of the type is known at compile time\n+   --  and large, where large is defined heuristically by the body of this\n+   --  routine. The purpose of this routine is to help avoid generating\n+   --  troublesome temporaries that interfere with stack checking mechanism.\n+   --  Note that the caller has to check whether stack checking is actually\n+   --  enabled in order to guide the expansion (typically of a function call).\n \n    procedure Remove_Side_Effects\n      (Exp          : Node_Id;\n@@ -505,14 +506,14 @@ package Exp_Util is\n    --  if necessary by an equivalent subexpression that is guaranteed to be\n    --  side effect free. This is done by extracting any actions that could\n    --  cause side effects, and inserting them using Insert_Actions into the\n-   --  tree to which Exp is attached. Exp must be analayzed and resolved\n+   --  tree to which Exp is attached. Exp must be analyzed and resolved\n    --  before the call and is analyzed and resolved on return. The Name_Req\n    --  may only be set to True if Exp has the form of a name, and the\n    --  effect is to guarantee that any replacement maintains the form of a\n    --  name. If Variable_Ref is set to TRUE, a variable is considered as a\n    --  side effect (used in implementing Force_Evaluation). Note: after a\n-   --  call to Remove_Side_Effects, it is safe to use a call to\n-   --  New_Copy_Tree to obtain a copy of the resulting expression.\n+   --  call to Remove_Side_Effects, it is safe to call New_Copy_Tree to\n+   --  obtain a copy of the resulting expression.\n \n    function Safe_Unchecked_Type_Conversion (Exp : Node_Id) return Boolean;\n    --  Given the node for an N_Unchecked_Type_Conversion, return True"}, {"sha": "f3d62ffd32545e82f3129417649d924a0d586f56", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,9 +81,6 @@ pragma Preelaborate (Get_Targ);\n    function Get_Maximum_Alignment return Pos;\n    pragma Import (C, Get_Maximum_Alignment, \"get_target_maximum_alignment\");\n \n-   function Get_No_Dollar_In_Label return Boolean;\n-   pragma Import (C, Get_No_Dollar_In_Label, \"get_target_no_dollar_in_label\");\n-\n    function Get_Float_Words_BE return Nat;\n    pragma Import (C, Get_Float_Words_BE, \"get_float_words_be\");\n "}, {"sha": "0c64029fcc179adfd04d395b90107a19b59fdc78", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -12565,8 +12565,9 @@ of the length corresponding to the @code{@var{type}'Size} value in Ada.\n @noindent\n The interface to C++ makes use of the following pragmas, which are\n primarily intended to be constructed automatically using a binding generator\n-tool, although it is possible to construct them by hand.  Ada Core\n-Technologies does not currently supply a suitable binding generator tool.\n+tool, although it is possible to construct them by hand.  No suitable binding\n+generator tool is supplied with GNAT though.\n+\n \n Using these pragmas it is possible to achieve complete\n inter-operability between Ada tagged types and C class definitions."}, {"sha": "3ef0e327b5bfe65db09cade4275b16c76f3921dd", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -278,7 +278,7 @@ procedure GNATCmd is\n       There_Are_Libraries : in out Boolean)\n    is\n       Path_Option : constant String_Access :=\n-                      MLib.Tgt.Linker_Library_Path_Option;\n+                      MLib.Linker_Library_Path_Option;\n \n    begin\n       --  Case of library project\n@@ -936,7 +936,7 @@ begin\n             declare\n                There_Are_Libraries  : Boolean := False;\n                Path_Option : constant String_Access :=\n-                               MLib.Tgt.Linker_Library_Path_Option;\n+                               MLib.Linker_Library_Path_Option;\n \n             begin\n                Library_Paths.Set_Last (0);"}, {"sha": "0b9bd2ab9e7f8e8c8b625ce283f2f22aeb93c983", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -42,6 +42,7 @@ with Ada.Command_Line;     use Ada.Command_Line;\n with Ada.Exceptions;       use Ada.Exceptions;\n with GNAT.OS_Lib;          use GNAT.OS_Lib;\n with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with Interfaces.C.Strings; use Interfaces.C.Strings;\n with System.CRTL;\n \n procedure Gnatlink is\n@@ -121,8 +122,6 @@ procedure Gnatlink is\n    --  This table collects the arguments to be passed to compile the binder\n    --  generated file.\n \n-   subtype chars_ptr is System.Address;\n-\n    Gcc : String_Access := Program_Name (\"gcc\");\n \n    Read_Mode  : constant String := \"r\" & ASCII.Nul;\n@@ -184,9 +183,6 @@ procedure Gnatlink is\n    procedure Process_Binder_File (Name : in String);\n    --  Reads the binder file and extracts linker arguments.\n \n-   function Value (chars : chars_ptr) return String;\n-   --  Return NUL-terminated string chars as an Ada string.\n-\n    procedure Write_Header;\n    --  Show user the program name, version and copyright.\n \n@@ -652,18 +648,18 @@ procedure Gnatlink is\n       RB_Nlast     : Integer;             -- Slice last index\n       RB_Nfirst    : Integer;             -- Slice first index\n \n-      Run_Path_Option_Ptr : Address;\n+      Run_Path_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n       pragma Import (C, Run_Path_Option_Ptr, \"run_path_option\");\n       --  Pointer to string representing the native linker option which\n       --  specifies the path where the dynamic loader should find shared\n       --  libraries. Equal to null string if this system doesn't support it.\n \n-      Object_Library_Ext_Ptr : Address;\n+      Object_Library_Ext_Ptr : Interfaces.C.Strings.chars_ptr;\n       pragma Import (C, Object_Library_Ext_Ptr, \"object_library_extension\");\n       --  Pointer to string specifying the default extension for\n       --  object libraries, e.g. Unix uses \".a\", VMS uses \".olb\".\n \n-      Object_File_Option_Ptr : Address;\n+      Object_File_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n       pragma Import (C, Object_File_Option_Ptr, \"object_file_option\");\n       --  Pointer to a string representing the linker option which specifies\n       --  the response file.\n@@ -1247,31 +1243,6 @@ procedure Gnatlink is\n       Status := fclose (Fd);\n    end Process_Binder_File;\n \n-   -----------\n-   -- Value --\n-   -----------\n-\n-   function Value (chars : chars_ptr) return String is\n-      function Strlen (chars : chars_ptr) return Natural;\n-      pragma Import (C, Strlen);\n-\n-   begin\n-      if chars = Null_Address then\n-         return \"\";\n-\n-      else\n-         declare\n-            subtype Result_Type is String (1 .. Strlen (chars));\n-\n-            Result : Result_Type;\n-            for Result'Address use chars;\n-\n-         begin\n-            return Result;\n-         end;\n-      end if;\n-   end Value;\n-\n    ------------------\n    -- Write_Header --\n    ------------------"}, {"sha": "6b3d07e7065443fd65e1244a854324a7c9f51d65", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -37,9 +37,12 @@ with Opt;         use Opt;\n with Osint;       use Osint;\n with Osint.L;     use Osint.L;\n with Output;      use Output;\n+with Rident;      use Rident;\n with Targparm;    use Targparm;\n with Types;       use Types;\n \n+with GNAT.Case_Util; use GNAT.Case_Util;\n+\n procedure Gnatls is\n    pragma Ident (Gnat_Static_Version_String);\n \n@@ -147,7 +150,7 @@ procedure Gnatls is\n    --  Print out FS either in a coded form if verbose is false or in an\n    --  expanded form otherwise.\n \n-   procedure Output_Unit (U_Id : Unit_Id);\n+   procedure Output_Unit (ALI : ALI_Id; U_Id : Unit_Id);\n    --  Print out information on the unit when requested\n \n    procedure Reset_Print;\n@@ -159,6 +162,9 @@ procedure Gnatls is\n    procedure Usage;\n    --  Print usage message\n \n+   function Image (Restriction : Restriction_Id) return String;\n+   --  Returns the capitalized image of Restriction\n+\n    -----------------\n    -- Add_Lib_Dir --\n    -----------------\n@@ -361,6 +367,31 @@ procedure Gnatls is\n       end if;\n    end Find_Status;\n \n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Restriction : Restriction_Id) return String is\n+      Result : String := Restriction'Img;\n+      Skip   : Boolean := True;\n+\n+   begin\n+      for J in Result'Range loop\n+         if Skip then\n+            Skip := False;\n+            Result (J) := To_Upper (Result (J));\n+\n+         elsif Result (J) = '_' then\n+            Skip := True;\n+\n+         else\n+            Result (J) := To_Lower (Result (J));\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Image;\n+\n    -------------------\n    -- Output_Object --\n    -------------------\n@@ -480,7 +511,7 @@ procedure Gnatls is\n    -- Output_Unit --\n    -----------------\n \n-   procedure Output_Unit (U_Id : Unit_Id) is\n+   procedure Output_Unit (ALI : ALI_Id; U_Id : Unit_Id) is\n       Kind : Character;\n       U    : Unit_Record renames Units.Table (U_Id);\n \n@@ -604,6 +635,35 @@ procedure Gnatls is\n                end if;\n \n             end if;\n+\n+            declare\n+               Restrictions : constant Restrictions_Info :=\n+                                ALIs.Table (ALI).Restrictions;\n+            begin\n+               --  If the source was compiled with pragmas Restrictions,\n+               --  Display these restrictions.\n+\n+               if Restrictions.Set /= (All_Restrictions => False) then\n+                  Write_Eol; Write_Str (\"     Restrictions  =>\");\n+\n+                  --  For boolean restrictions, just display the name of the\n+                  --  restriction; for valued restrictions, also display the\n+                  --  restriction value.\n+\n+                  for Restriction in All_Restrictions loop\n+                     if Restrictions.Set (Restriction) then\n+                        Write_Eol;\n+                        Write_Str (\"       \");\n+                        Write_Str (Image (Restriction));\n+\n+                        if Restriction in All_Parameter_Restrictions then\n+                           Write_Str (\" =>\");\n+                           Write_Str (Restrictions.Value (Restriction)'Img);\n+                        end if;\n+                     end if;\n+                  end loop;\n+               end if;\n+            end;\n          end if;\n \n          if Print_Source then\n@@ -1049,7 +1109,7 @@ begin\n                   Write_Eol;\n                end if;\n \n-               Output_Unit (U);\n+               Output_Unit (Id, U);\n \n                --  Output source now, unless if it will be done as part of\n                --  outputing dependencies."}, {"sha": "e1757666545090770db290a4303ee52eaa6e2358", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -993,6 +993,12 @@ package body Layout is\n                Decl := Parent (Parent (Entity (N)));\n                Size := (Discrim, Size.Nod);\n                Vtyp := Defining_Identifier (Decl);\n+\n+               --  Ensure that we get a private type's full type\n+\n+               if Present (Underlying_Type (Vtyp)) then\n+                  Vtyp := Underlying_Type (Vtyp);\n+               end if;\n             end if;\n \n             Typ := Etype (N);"}, {"sha": "e726c2d760ff043a31227a01009cc34a9202042c", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -945,6 +945,16 @@ package body Lib is\n         (Option => S, Unit => Current_Sem_Unit);\n    end Store_Linker_Option_String;\n \n+   -------------------------------\n+   -- Synchronize_Serial_Number --\n+   -------------------------------\n+\n+   procedure Synchronize_Serial_Number is\n+      TSN : Int renames Units.Table (Current_Sem_Unit).Serial_Number;\n+   begin\n+      TSN := TSN + 1;\n+   end Synchronize_Serial_Number;\n+\n    ---------------\n    -- Tree_Read --\n    ---------------"}, {"sha": "d45ccfba74644f54b9a2cf58e59fb710036c67c9", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -527,6 +527,15 @@ package Lib is\n    --  Increment Serial_Number field for current unit, and return the\n    --  incremented value.\n \n+   procedure Synchronize_Serial_Number;\n+   --  This function increments the Serial_Number field for the current\n+   --  unit but does not return the incremented value. This is used when\n+   --  there is a situation where one path of control increments a serial\n+   --  number (using Increment_Serial_Number), and the other path does not\n+   --  and it is important to keep the serial numbers synchronized in the\n+   --  two cases (e.g. when the references in a package and a client must\n+   --  be kept consistent).\n+\n    procedure Replace_Linker_Option_String\n      (S : String_Id; Match_String : String);\n    --  Replace an existing Linker_Option if the prefix Match_String"}, {"sha": "a7ae922b62afafa61111c3388fe3c5b8aaae0910", "filename": "gcc/ada/link.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -147,7 +147,7 @@ const char *object_library_extension = \".olb\";\n \n #elif defined (sun)\n const char *object_file_option = \"\";\n-const char *run_path_option = \"-R\";\n+const char *run_path_option = \"-Wl,-R,\";\n char shared_libgnat_default = STATIC;\n int link_max = 2147483647;\n unsigned char objlist_file_supported = 0;"}, {"sha": "264527ed250f6490be1f39a75cfb7e3279f11ee8", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 22, "deletions": 335, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -35,6 +35,7 @@ with Fname.UF; use Fname.UF;\n with Gnatvsn;  use Gnatvsn;\n with Hostparm; use Hostparm;\n with Makeusg;\n+with Makeutl;  use Makeutl;\n with MLib.Prj;\n with MLib.Tgt; use MLib.Tgt;\n with MLib.Utl;\n@@ -47,7 +48,6 @@ with Output;   use Output;\n with Prj;      use Prj;\n with Prj.Com;\n with Prj.Env;\n-with Prj.Ext;\n with Prj.Pars;\n with Prj.Util;\n with SFN_Scan;\n@@ -180,30 +180,6 @@ package body Make is\n      Table_Name           => \"Make.Q\");\n    --  This is the actual Q.\n \n-   --  Package Mains is used to store the mains specified on the command line\n-   --  and to retrieve them when a project file is used, to verify that the\n-   --  files exist and that they belong to a project file.\n-\n-   package Mains is\n-\n-      --  Mains are stored in a table. An index is used to retrieve the mains\n-      --  from the table.\n-\n-      procedure Add_Main (Name : String);\n-      --  Add one main to the table\n-\n-      procedure Delete;\n-      --  Empty the table\n-\n-      procedure Reset;\n-      --  Reset the index to the beginning of the table\n-\n-      function Next_Main return String;\n-      --  Increase the index and return the next main.\n-      --  If table is exhausted, return an empty string.\n-\n-   end Mains;\n-\n    --  The following instantiations and variables are necessary to save what\n    --  is found on the command line, in case there is a project file specified.\n \n@@ -271,19 +247,6 @@ package body Make is\n      Table_Increment      => 100,\n      Table_Name           => \"Make.Library_Projs\");\n \n-   type Linker_Options_Data is record\n-      Project : Project_Id;\n-      Options : String_List_Id;\n-   end record;\n-\n-   package Linker_Opts is new Table.Table (\n-     Table_Component_Type => Linker_Options_Data,\n-     Table_Index_Type     => Integer,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 10,\n-     Table_Increment      => 100,\n-     Table_Name           => \"Make.Linker_Opts\");\n-\n    --  Two variables to keep the last binder and linker switch index\n    --  in tables Binder_Switches and Linker_Switches, before adding\n    --  switches from the project file (if any) and switches from the\n@@ -588,16 +551,6 @@ package body Make is\n    --  Check what steps (Compile, Bind, Link) must be executed.\n    --  Set the step flags accordingly.\n \n-   function Is_External_Assignment (Argv : String) return Boolean;\n-   --  Verify that an external assignment switch is syntactically correct.\n-   --  Correct forms are\n-   --      -Xname=value\n-   --      -X\"name=other value\"\n-   --  Assumptions: 'First = 1, Argv (1 .. 2) = \"-X\"\n-   --  When this function returns True, the external assignment has\n-   --  been entered by a call to Prj.Ext.Add, so that in a project\n-   --  file, External (\"name\") will return \"value\".\n-\n    function In_Ada_Lib_Dir  (File : File_Name_Type) return Boolean;\n    --  Get directory prefix of this file and get lib mark stored in name\n    --  table for this directory. Then check if an Ada lib mark has been set.\n@@ -628,16 +581,6 @@ package body Make is\n    --  the extension \".ali\". If there is no switches for either names, try the\n    --  default switches for Ada. If all failed, return No_Variable_Value.\n \n-   procedure Test_If_Relative_Path\n-     (Switch             : in out String_Access;\n-      Parent             : String_Access;\n-      Including_L_Switch : Boolean := True);\n-   --  Test if Switch is a relative search path switch.\n-   --  If it is, fail if Parent is null, otherwise prepend the path with\n-   --  Parent. This subprogram is only called when using project files.\n-   --  For gnatbind switches, Including_L_Switch is False, because the\n-   --  argument of the -L switch is not a path.\n-\n    function Is_In_Object_Directory\n      (Source_File   : File_Name_Type;\n       Full_Lib_File : File_Name_Type) return Boolean;\n@@ -3562,16 +3505,21 @@ package body Make is\n                                       Normalize_Pathname\n                                         (Real_Path.all,\n                                          Case_Sensitive => False);\n+                                    Proj_Path : constant String :=\n+                                      Normalize_Pathname\n+                                        (Project_Path,\n+                                         Case_Sensitive => False);\n+\n                                  begin\n                                     Free (Real_Path);\n \n                                     --  Fail if it is not the correct path\n \n-                                    if Normed_Path /= Project_Path then\n+                                    if Normed_Path /= Proj_Path then\n                                        if Verbose_Mode then\n                                           Write_Str (Normed_Path);\n                                           Write_Str (\" /= \");\n-                                          Write_Line (Project_Path);\n+                                          Write_Line (Proj_Path);\n                                        end if;\n \n                                        Make_Failed\n@@ -4963,7 +4911,7 @@ package body Make is\n                There_Are_Libraries  : Boolean := False;\n                Linker_Switches_Last : constant Integer := Linker_Switches.Last;\n                Path_Option : constant String_Access :=\n-                               MLib.Tgt.Linker_Library_Path_Option;\n+                               MLib.Linker_Library_Path_Option;\n                Current : Natural;\n                Proj2   : Project_Id;\n                Depth   : Natural;\n@@ -5118,95 +5066,14 @@ package body Make is\n                   --  other than the main project\n \n                   declare\n-                     Linker_Package : Package_Id;\n-                     Options : Variable_Value;\n-\n-                  begin\n-                     Linker_Opts.Init;\n-\n-                     for Index in 1 .. Projects.Last loop\n-                        if Index /= Main_Project then\n-                           Linker_Package :=\n-                             Prj.Util.Value_Of\n-                               (Name => Name_Linker,\n-                                In_Packages =>\n-                                  Projects.Table (Index).Decl.Packages);\n-                           Options :=\n-                             Prj.Util.Value_Of\n-                               (Name => Name_Ada,\n-                                Attribute_Or_Array_Name => Name_Linker_Options,\n-                                In_Package => Linker_Package);\n-\n-                           --  If attribute is present, add the project with\n-                           --  the attribute to table Linker_Opts.\n-\n-                           if Options /= Nil_Variable_Value then\n-                              Linker_Opts.Increment_Last;\n-                              Linker_Opts.Table (Linker_Opts.Last) :=\n-                                (Project => Index, Options => Options.Values);\n-                           end if;\n-                        end if;\n-                     end loop;\n-                  end;\n+                     Linker_Options : constant String_List :=\n+                       Linker_Options_Switches (Main_Project);\n \n-                  declare\n-                     Opt1    : Linker_Options_Data;\n-                     Opt2    : Linker_Options_Data;\n-                     Depth   : Natural;\n-                     Options : String_List_Id;\n-                     Option  : Name_Id;\n                   begin\n-                     --  Sort the project by increasing depths\n-\n-                     for Index in 1 .. Linker_Opts.Last loop\n-                        Opt1 := Linker_Opts.Table (Index);\n-                        Depth := Projects.Table (Opt1.Project).Depth;\n-\n-                        for J in Index + 1 .. Linker_Opts.Last loop\n-                           Opt2 := Linker_Opts.Table (J);\n-\n-                           if\n-                             Projects.Table (Opt2.Project).Depth < Depth\n-                           then\n-                              Linker_Opts.Table (Index) := Opt2;\n-                              Linker_Opts.Table (J) := Opt1;\n-                              Opt1 := Opt2;\n-                              Depth :=\n-                                Projects.Table (Opt1.Project).Depth;\n-                           end if;\n-                        end loop;\n-\n-                        --  If Dir_Path has not been computed for this project,\n-                        --  do it now.\n-\n-                        if Projects.Table (Opt1.Project).Dir_Path = null then\n-                           Projects.Table (Opt1.Project).Dir_Path :=\n-                             new String'\n-                               (Get_Name_String\n-                                  (Projects.Table (Opt1.Project). Directory));\n-                        end if;\n-\n-                        Options := Opt1.Options;\n-\n-                        --  Add each of the options to the linker switches\n-\n-                        while Options /= Nil_String loop\n-                           Option := String_Elements.Table (Options).Value;\n-                           Options := String_Elements.Table (Options).Next;\n-                           Linker_Switches.Increment_Last;\n-                           Linker_Switches.Table (Linker_Switches.Last) :=\n-                             new String'(Get_Name_String (Option));\n-\n-                           --  Object files and -L switches specified with\n-                           --  relative paths and must be converted to\n-                           --  absolute paths.\n-\n-                           Test_If_Relative_Path\n-                             (Switch =>\n-                                Linker_Switches.Table (Linker_Switches.Last),\n-                              Parent => Projects.Table (Opt1.Project).Dir_Path,\n-                              Including_L_Switch => True);\n-                        end loop;\n+                     for Option in Linker_Options'Range loop\n+                        Linker_Switches.Increment_Last;\n+                        Linker_Switches.Table (Linker_Switches.Last) :=\n+                          Linker_Options (Option);\n                      end loop;\n                   end;\n                end if;\n@@ -5781,9 +5648,9 @@ package body Make is\n       Marking_Label := 1;\n    end Initialize;\n \n-   -----------------------------------\n-   -- Insert_Project_Sources_Into_Q --\n-   -----------------------------------\n+   ----------------------------\n+   -- Insert_Project_Sources --\n+   ----------------------------\n \n    procedure Insert_Project_Sources\n      (The_Project  : Project_Id;\n@@ -5962,47 +5829,6 @@ package body Make is\n       Q.Increment_Last;\n    end Insert_Q;\n \n-   ----------------------------\n-   -- Is_External_Assignment --\n-   ----------------------------\n-\n-   function Is_External_Assignment (Argv : String) return Boolean is\n-      Start     : Positive := 3;\n-      Finish    : Natural := Argv'Last;\n-      Equal_Pos : Natural;\n-\n-   begin\n-      if Argv'Last < 5 then\n-         return False;\n-\n-      elsif Argv (3) = '\"' then\n-         if Argv (Argv'Last) /= '\"' or else Argv'Last < 7 then\n-            return False;\n-         else\n-            Start := 4;\n-            Finish := Argv'Last - 1;\n-         end if;\n-      end if;\n-\n-      Equal_Pos := Start;\n-\n-      while Equal_Pos <= Finish and then Argv (Equal_Pos) /= '=' loop\n-         Equal_Pos := Equal_Pos + 1;\n-      end loop;\n-\n-      if Equal_Pos = Start\n-        or else Equal_Pos >= Finish\n-      then\n-         return False;\n-\n-      else\n-         Prj.Ext.Add\n-           (External_Name => Argv (Start .. Equal_Pos - 1),\n-            Value         => Argv (Equal_Pos + 1 .. Finish));\n-         return True;\n-      end if;\n-   end Is_External_Assignment;\n-\n    ---------------------\n    -- Is_In_Obsoleted --\n    ---------------------\n@@ -6245,68 +6071,6 @@ package body Make is\n       Set_Standard_Error;\n    end List_Depend;\n \n-   -----------\n-   -- Mains --\n-   -----------\n-\n-   package body Mains is\n-\n-      package Names is new Table.Table\n-        (Table_Component_Type => File_Name_Type,\n-         Table_Index_Type     => Integer,\n-         Table_Low_Bound      => 1,\n-         Table_Initial        => 10,\n-         Table_Increment      => 100,\n-         Table_Name           => \"Make.Mains.Names\");\n-      --  The table that stores the main\n-\n-      Current : Natural := 0;\n-      --  The index of the last main retrieved from the table\n-\n-      --------------\n-      -- Add_Main --\n-      --------------\n-\n-      procedure Add_Main (Name : String) is\n-      begin\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (Name);\n-         Names.Increment_Last;\n-         Names.Table (Names.Last) := Name_Find;\n-      end Add_Main;\n-\n-      ------------\n-      -- Delete --\n-      ------------\n-\n-      procedure Delete is\n-      begin\n-         Names.Set_Last (0);\n-         Reset;\n-      end Delete;\n-\n-      ---------------\n-      -- Next_Main --\n-      ---------------\n-\n-      function Next_Main return String is\n-      begin\n-         if Current >= Names.Last then\n-            return \"\";\n-\n-         else\n-            Current := Current + 1;\n-            return Get_Name_String (Names.Table (Current));\n-         end if;\n-      end Next_Main;\n-\n-      procedure Reset is\n-      begin\n-         Current := 0;\n-      end Reset;\n-\n-   end Mains;\n-\n    ----------\n    -- Mark --\n    ----------\n@@ -6979,6 +6743,7 @@ package body Make is\n             --  unless we are dealing with a debug switch (starts with 'd')\n \n          elsif Argv (2) /= 'd'\n+           and then Argv (2) /= 'e'\n            and then Argv (2 .. Argv'Last) /= \"C\"\n            and then Argv (2 .. Argv'Last) /= \"F\"\n            and then Argv (2 .. Argv'Last) /= \"M\"\n@@ -7099,85 +6864,6 @@ package body Make is\n       return Switches;\n    end Switches_Of;\n \n-   ---------------------------\n-   -- Test_If_Relative_Path --\n-   ---------------------------\n-\n-   procedure Test_If_Relative_Path\n-     (Switch             : in out String_Access;\n-      Parent             : String_Access;\n-      Including_L_Switch : Boolean := True)\n-   is\n-   begin\n-      if Switch /= null then\n-\n-         declare\n-            Sw : String (1 .. Switch'Length);\n-            Start : Positive;\n-\n-         begin\n-            Sw := Switch.all;\n-\n-            if Sw (1) = '-' then\n-               if Sw'Length >= 3\n-                 and then (Sw (2) = 'A'\n-                           or else Sw (2) = 'I'\n-                           or else (Including_L_Switch and then Sw (2) = 'L'))\n-               then\n-                  Start := 3;\n-\n-                  if Sw = \"-I-\" then\n-                     return;\n-                  end if;\n-\n-               elsif Sw'Length >= 4\n-                 and then (Sw (2 .. 3) = \"aL\"\n-                           or else Sw (2 .. 3) = \"aO\"\n-                           or else Sw (2 .. 3) = \"aI\")\n-               then\n-                  Start := 4;\n-\n-               else\n-                  return;\n-               end if;\n-\n-               --  Because relative path arguments to --RTS= may be relative\n-               --  to the search directory prefix, those relative path\n-               --  arguments are not converted.\n-\n-               if not Is_Absolute_Path (Sw (Start .. Sw'Last)) then\n-                  if Parent = null or else Parent'Length = 0 then\n-                     Make_Failed\n-                       (\"relative search path switches (\"\"\",\n-                        Sw,\n-                        \"\"\") are not allowed\");\n-\n-                  else\n-                     Switch :=\n-                       new String'\n-                         (Sw (1 .. Start - 1) &\n-                          Parent.all &\n-                          Directory_Separator &\n-                          Sw (Start .. Sw'Last));\n-                  end if;\n-               end if;\n-\n-            else\n-               if not Is_Absolute_Path (Sw) then\n-                  if Parent = null or else Parent'Length = 0 then\n-                     Make_Failed\n-                       (\"relative paths (\"\"\", Sw, \"\"\") are not allowed\");\n-\n-                  else\n-                     Switch :=\n-                       new String'(Parent.all & Directory_Separator & Sw);\n-                  end if;\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-   end Test_If_Relative_Path;\n-\n    -----------\n    -- Usage --\n    -----------\n@@ -7225,6 +6911,7 @@ package body Make is\n begin\n    --  Make sure that in case of failure, the temp files will be deleted\n \n-   Prj.Com.Fail := Make_Failed'Access;\n-   MLib.Fail    := Make_Failed'Access;\n+   Prj.Com.Fail    := Make_Failed'Access;\n+   MLib.Fail       := Make_Failed'Access;\n+   Makeutl.Do_Fail := Make_Failed'Access;\n end Make;"}, {"sha": "49b7a0df4754fd3d33b4c8522cd0ec862fd3ca7d", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,6 +88,12 @@ begin\n    Write_Str (\"  -D dir   Specify dir as the object directory\");\n    Write_Eol;\n \n+   --  Line for -eL\n+\n+   Write_Str (\"  -eL      Follow symbolic links when processing \" &\n+              \"project files\");\n+   Write_Eol;\n+\n    --  Line for -f\n \n    Write_Str (\"  -f       Force recompilations of non predefined units\");"}, {"sha": "80da0ebd9213b17bd97dc619b0ea94760fbb7262", "filename": "gcc/ada/mdll-utl.adb", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmdll-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmdll-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll-utl.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -308,53 +308,60 @@ package body MDLL.Utl is\n    begin\n       --  dlltool\n \n-      Dlltool_Exec := OS_Lib.Locate_Exec_On_Path (Dlltool_Name);\n-\n       if Dlltool_Exec = null then\n-         Exceptions.Raise_Exception\n-           (Tools_Error'Identity, Dlltool_Name & \" not found in path\");\n+         Dlltool_Exec := OS_Lib.Locate_Exec_On_Path (Dlltool_Name);\n \n-      elsif Verbose then\n-         Text_IO.Put_Line (\"using \" & Dlltool_Exec.all);\n+         if Dlltool_Exec = null then\n+            Exceptions.Raise_Exception\n+              (Tools_Error'Identity, Dlltool_Name & \" not found in path\");\n+\n+         elsif Verbose then\n+            Text_IO.Put_Line (\"using \" & Dlltool_Exec.all);\n+         end if;\n       end if;\n \n       --  gcc\n \n-      Gcc_Exec     := OS_Lib.Locate_Exec_On_Path (Gcc_Name);\n-\n       if Gcc_Exec = null then\n-         Exceptions.Raise_Exception\n-           (Tools_Error'Identity, Gcc_Name & \" not found in path\");\n+         Gcc_Exec := OS_Lib.Locate_Exec_On_Path (Gcc_Name);\n+\n+         if Gcc_Exec = null then\n+            Exceptions.Raise_Exception\n+              (Tools_Error'Identity, Gcc_Name & \" not found in path\");\n \n-      elsif Verbose then\n-         Text_IO.Put_Line (\"using \" & Gcc_Exec.all);\n+         elsif Verbose then\n+            Text_IO.Put_Line (\"using \" & Gcc_Exec.all);\n+         end if;\n       end if;\n \n       --  gnatbind\n \n-      Gnatbind_Exec     := OS_Lib.Locate_Exec_On_Path (Gnatbind_Name);\n-\n       if Gnatbind_Exec = null then\n-         Exceptions.Raise_Exception\n-           (Tools_Error'Identity, Gnatbind_Name & \" not found in path\");\n+         Gnatbind_Exec := OS_Lib.Locate_Exec_On_Path (Gnatbind_Name);\n+\n+         if Gnatbind_Exec = null then\n+            Exceptions.Raise_Exception\n+              (Tools_Error'Identity, Gnatbind_Name & \" not found in path\");\n \n-      elsif Verbose then\n-         Text_IO.Put_Line (\"using \" & Gnatbind_Exec.all);\n+         elsif Verbose then\n+            Text_IO.Put_Line (\"using \" & Gnatbind_Exec.all);\n+         end if;\n       end if;\n \n       --  gnatlink\n \n-      Gnatlink_Exec     := OS_Lib.Locate_Exec_On_Path (Gnatlink_Name);\n-\n       if Gnatlink_Exec = null then\n-         Exceptions.Raise_Exception\n-           (Tools_Error'Identity, Gnatlink_Name & \" not found in path\");\n+         Gnatlink_Exec := OS_Lib.Locate_Exec_On_Path (Gnatlink_Name);\n \n-      elsif Verbose then\n-         Text_IO.Put_Line (\"using \" & Gnatlink_Exec.all);\n-         Text_IO.New_Line;\n-      end if;\n+         if Gnatlink_Exec = null then\n+            Exceptions.Raise_Exception\n+              (Tools_Error'Identity, Gnatlink_Name & \" not found in path\");\n \n+         elsif Verbose then\n+            Text_IO.Put_Line (\"using \" & Gnatlink_Exec.all);\n+            Text_IO.New_Line;\n+         end if;\n+      end if;\n    end Locate;\n \n end MDLL.Utl;"}, {"sha": "70d8741f42eabb7a2d1b17fdb36b49af43dc1fc9", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -308,9 +308,6 @@ package body MLib.Prj is\n       Libdecgnat_Needed : Boolean := False;\n       --  On OpenVMS, set to True if library needs to be linked with libdecgnat\n \n-      Check_Libdecgnat : Boolean := Hostparm.OpenVMS;\n-      --  Set to False if package Dec is part of the library sources.\n-\n       Data : Project_Data := Projects.Table (For_Project);\n \n       Object_Directory_Path : constant String :=\n@@ -375,8 +372,7 @@ package body MLib.Prj is\n       --  to link with -lgnarl (this is the case when there is a dependency\n       --  on s-osinte.ads). On OpenVMS, set Libdecgnat_Needed if the ALI file\n       --  indicates that there is a need to link with -ldecgnat (this is the\n-      --  case when there is a dependency on dec.ads, except when it is the\n-      --  DEC library, the one that contains package DEC).\n+      --  case when there is a dependency on dec.ads).\n \n       procedure Process (The_ALI : File_Name_Type);\n       --  Check if the closure of a library unit which is or should be in the\n@@ -509,16 +505,8 @@ package body MLib.Prj is\n          Id       : ALI.ALI_Id;\n \n       begin\n-         --  On OpenVMS, if we have package DEC, it means this is the DEC lib:\n-         --  no need to link with itself.\n-\n-         if Check_Libdecgnat and then ALI_File = \"dec.ali\" then\n-            Check_Libdecgnat := False;\n-            Libdecgnat_Needed := False;\n-         end if;\n-\n          if not Libgnarl_Needed or\n-           (Check_Libdecgnat and then (not Libdecgnat_Needed))\n+           (Hostparm.OpenVMS and then (not Libdecgnat_Needed))\n          then\n             --  Scan the ALI file\n \n@@ -535,15 +523,15 @@ package body MLib.Prj is\n                           Read_Lines => \"D\");\n             Free (Text);\n \n-            --  Look for s-osinte.ads and dec.ads in the dependencies\n+            --  Look for s-osinte.ads in the dependencies\n \n             for Index in ALI.ALIs.Table (Id).First_Sdep ..\n                          ALI.ALIs.Table (Id).Last_Sdep\n             loop\n                if ALI.Sdep.Table (Index).Sfile = S_Osinte_Ads then\n                   Libgnarl_Needed := True;\n \n-               elsif Check_Libdecgnat and then\n+               elsif Hostparm.OpenVMS and then\n                      ALI.Sdep.Table (Index).Sfile = S_Dec_Ads\n                then\n                   Libdecgnat_Needed := True;\n@@ -1950,10 +1938,7 @@ package body MLib.Prj is\n       end if;\n \n       Status := fclose (Fd);\n-\n-      --  It is safe to ignore any error when closing, because the file was\n-      --  only opened for reading.\n-\n+      --  Is it really right to ignore any close error ???\n    end Process_Binder_File;\n \n    ------------------"}, {"sha": "dc1377372578ce55759faa6bb75e6eb487c5a337", "filename": "gcc/ada/mlib-tgt.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -190,15 +190,6 @@ package body MLib.Tgt is\n       return No_Name;\n    end Library_File_Name_For;\n \n-   --------------------------------\n-   -- Linker_Library_Path_Option --\n-   --------------------------------\n-\n-   function Linker_Library_Path_Option return String_Access is\n-   begin\n-      return null;\n-   end Linker_Library_Path_Option;\n-\n    ----------------\n    -- Object_Ext --\n    ----------------"}, {"sha": "5d142ae9a5c476c978b53328008db2509bbc8265", "filename": "gcc/ada/mlib-tgt.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -101,11 +101,6 @@ package MLib.Tgt is\n    function Is_Archive_Ext (Ext : String) return Boolean;\n    --  Returns True iff Ext is an extension for a library\n \n-   function Linker_Library_Path_Option return String_Access;\n-   --  Linker option to specify to the linker the library directory path.\n-   --  If non null, the library directory path is to be appended.\n-   --  Should be deallocated by the caller, when no longer needed.\n-\n    procedure Build_Dynamic_Library\n      (Ofiles       : Argument_List;\n       Foreign      : Argument_List;"}, {"sha": "3cefb6d2c9065bd17424f4470d09ce3a86d762bc", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1999-2003, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 1999-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,6 +25,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n+with Interfaces.C.Strings;\n \n with Hostparm;\n with Opt;\n@@ -40,6 +41,9 @@ with System;\n \n package body MLib is\n \n+   pragma Linker_Options (\"link.o\");\n+   --  For run_path_option string.\n+\n    -------------------\n    -- Build_Library --\n    -------------------\n@@ -285,13 +289,34 @@ package body MLib is\n       end if;\n    end Copy_ALI_Files;\n \n+   --------------------------------\n+   -- Linker_Library_Path_Option --\n+   --------------------------------\n+\n+   function Linker_Library_Path_Option return String_Access is\n+\n+      Run_Path_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n+      pragma Import (C, Run_Path_Option_Ptr, \"run_path_option\");\n+      --  Pointer to string representing the native linker option which\n+      --  specifies the path where the dynamic loader should find shared\n+      --  libraries. Equal to null string if this system doesn't support it.\n+\n+      S : constant String := Interfaces.C.Strings.Value (Run_Path_Option_Ptr);\n+\n+   begin\n+      if S'Length = 0 then\n+         return null;\n+      else\n+         return new String'(S);\n+      end if;\n+   end Linker_Library_Path_Option;\n+\n --  Package elaboration\n \n begin\n-   if Hostparm.OpenVMS then\n-\n-      --  Copy_Attributes always fails on VMS\n+   --  Copy_Attributes always fails on VMS\n \n+   if Hostparm.OpenVMS then\n       Preserve := None;\n    end if;\n end MLib;"}, {"sha": "eb9b3fe8f075b8a7a9f086dd5f9d2c2409b55e82", "filename": "gcc/ada/mlib.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fmlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1999-2003, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 1999-2004, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,6 +65,11 @@ package MLib is\n    --  Copy all ALI files Files to directory To.\n    --  Mark Interfaces ALI files as interfaces, if any.\n \n+   function Linker_Library_Path_Option return String_Access;\n+   --  Linker option to specify to the linker the library directory path.\n+   --  If non null, the library directory path is to be appended.\n+   --  Should be deallocated by the caller, when no longer needed.\n+\n private\n \n    Preserve : Attribute := Time_Stamps;"}, {"sha": "9fea924caecf56b6925fc39f70c11cc3abcb275d", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -526,6 +526,10 @@ package Opt is\n    --  then elaboration flag checks are to be generated in the binder\n    --  generated file.\n \n+   Follow_Links : Boolean := False;\n+   --  GNATMAKE\n+   --  Set to True (-eL) to process the project files in trusted mode\n+\n    Front_End_Inlining : Boolean := False;\n    --  GNAT\n    --  Set True to activate inlining by front-end expansion."}, {"sha": "dad0101e46a794879e765b9cd63fc9651efd357f", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 193, "deletions": 94, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -741,10 +741,8 @@ package body Ch3 is\n          Scan; -- past NEW\n       end if;\n \n-      if Extensions_Allowed then                      --  Ada 0Y (AI-231)\n-         Not_Null_Present := P_Null_Exclusion;\n-         Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n-      end if;\n+      Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+      Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n \n       Set_Subtype_Indication\n         (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n@@ -1293,7 +1291,6 @@ package body Ch3 is\n \n             else\n                Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n-               Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n                Set_Constant_Present (Decl_Node, True);\n \n                if Token_Name = Name_Aliased then\n@@ -1312,10 +1309,8 @@ package body Ch3 is\n                     (Decl_Node, P_Array_Type_Definition);\n \n                else\n-                  if Extensions_Allowed then              --  Ada 0Y (AI-231)\n-                     Not_Null_Present := P_Null_Exclusion;\n-                     Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n-                  end if;\n+                  Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+                  Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n \n                   Set_Object_Definition (Decl_Node,\n                      P_Subtype_Indication (Not_Null_Present));\n@@ -1351,7 +1346,6 @@ package body Ch3 is\n             Scan; -- past ALIASED\n             Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n             Set_Aliased_Present (Decl_Node, True);\n-            Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n \n             if Token = Tok_Constant then\n                Scan; -- past CONSTANT\n@@ -1363,11 +1357,8 @@ package body Ch3 is\n                  (Decl_Node, P_Array_Type_Definition);\n \n             else\n-               if Extensions_Allowed then               --  Ada 0Y (AI-231)\n-                  Not_Null_Present := P_Null_Exclusion;\n-                  Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n-               end if;\n-\n+               Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+               Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n                Set_Object_Definition (Decl_Node,\n                   P_Subtype_Indication (Not_Null_Present));\n             end if;\n@@ -1378,6 +1369,74 @@ package body Ch3 is\n             Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n             Set_Object_Definition (Decl_Node, P_Array_Type_Definition);\n \n+         --  Ada 0Y (AI-254)\n+\n+         elsif Token = Tok_Not then\n+\n+            --  OBJECT_DECLARATION ::=\n+            --    DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n+            --      [NULL_EXCLUSION] SUBTYPE_INDICATION [:= EXPRESSION];\n+\n+            --  OBJECT_RENAMING_DECLARATION ::=\n+            --    ...\n+            --  | DEFINING_IDENTIFIER : ACCESS_DEFINITION renames object_NAME;\n+\n+            Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+\n+            if Token = Tok_Access then\n+               if not Extensions_Allowed then\n+                  Error_Msg_SP\n+                    (\"generalized use of anonymous access types \" &\n+                     \"is an Ada 0Y extension\");\n+                  Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n+               end if;\n+\n+               Acc_Node := P_Access_Definition (Not_Null_Present);\n+\n+               if Token /= Tok_Renames then\n+                  Error_Msg_SC (\"'RENAMES' expected\");\n+                  raise Error_Resync;\n+               end if;\n+\n+               Scan; --  past renames\n+               No_List;\n+               Decl_Node :=\n+                 New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n+               Set_Access_Definition (Decl_Node, Acc_Node);\n+               Set_Name (Decl_Node, P_Name);\n+\n+            else\n+               Type_Node := P_Subtype_Mark;\n+\n+               --  Object renaming declaration\n+\n+               if Token_Is_Renames then\n+                  Error_Msg_SP (\"(Ada 0Y) null-exclusion not allowed in \"\n+                                & \"object renamings\");\n+                  raise Error_Resync;\n+\n+               --  Object declaration\n+\n+               else\n+                  Decl_Node := New_Node (N_Object_Declaration, Ident_Sloc);\n+                  Set_Null_Exclusion_Present (Decl_Node, Not_Null_Present);\n+                  Set_Object_Definition\n+                    (Decl_Node,\n+                     P_Subtype_Indication (Type_Node, Not_Null_Present));\n+\n+                  --  RENAMES at this point means that we had the combination\n+                  --  of a constraint on the Type_Node and renames, which is\n+                  --  illegal\n+\n+                  if Token_Is_Renames then\n+                     Error_Msg_N (\"constraint not allowed in object renaming \"\n+                                  & \"declaration\",\n+                                  Constraint (Object_Definition (Decl_Node)));\n+                     raise Error_Resync;\n+                  end if;\n+               end if;\n+            end if;\n+\n          --  Ada 0Y (AI-230): Access Definition case\n \n          elsif Token = Tok_Access then\n@@ -1388,7 +1447,7 @@ package body Ch3 is\n                Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n             end if;\n \n-            Acc_Node := P_Access_Definition;\n+            Acc_Node := P_Access_Definition (Null_Exclusion_Present => False);\n \n             if Token /= Tok_Renames then\n                Error_Msg_SC (\"'RENAMES' expected\");\n@@ -1405,20 +1464,11 @@ package body Ch3 is\n          --  Subtype indication case\n \n          else\n-            if Extensions_Allowed then                   --  Ada 0Y (AI-231)\n-               Not_Null_Present := P_Null_Exclusion;\n-            end if;\n-\n             Type_Node := P_Subtype_Mark;\n \n             --  Object renaming declaration\n \n             if Token_Is_Renames then\n-               if Not_Null_Present then\n-                  Error_Msg_SP\n-                    (\"(Ada 0Y) null-exclusion not allowed in renamings\");\n-               end if;\n-\n                No_List;\n                Decl_Node :=\n                  New_Node (N_Object_Renaming_Declaration, Ident_Sloc);\n@@ -1551,11 +1601,8 @@ package body Ch3 is\n          Scan;\n       end if;\n \n-      if Extensions_Allowed then                         --  Ada 0Y (AI-231)\n-         Not_Null_Present := P_Null_Exclusion;\n-         Set_Null_Exclusion_Present (Typedef_Node, Not_Null_Present);\n-      end if;\n-\n+      Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231)\n+      Set_Null_Exclusion_Present (Typedef_Node, Not_Null_Present);\n       Set_Subtype_Indication (Typedef_Node,\n          P_Subtype_Indication (Not_Null_Present));\n \n@@ -2130,6 +2177,7 @@ package body Ch3 is\n       Not_Null_Present : Boolean := False;\n       Subs_List        : List_Id;\n       Scan_State       : Saved_Scan_State;\n+      Aliased_Present  : Boolean := False;\n \n    begin\n       Array_Loc := Token_Ptr;\n@@ -2189,6 +2237,17 @@ package body Ch3 is\n \n       CompDef_Node := New_Node (N_Component_Definition, Token_Ptr);\n \n+      if Token_Name = Name_Aliased then\n+         Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n+      end if;\n+\n+      if Token = Tok_Aliased then\n+         Aliased_Present := True;\n+         Scan; -- past ALIASED\n+      end if;\n+\n+      Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231/AI-254)\n+\n       --  Ada 0Y (AI-230): Access Definition case\n \n       if Token = Tok_Access then\n@@ -2199,28 +2258,21 @@ package body Ch3 is\n             Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n          end if;\n \n-         Set_Subtype_Indication (CompDef_Node, Empty);\n-         Set_Aliased_Present    (CompDef_Node, False);\n-         Set_Access_Definition  (CompDef_Node, P_Access_Definition);\n-      else\n-         Set_Access_Definition  (CompDef_Node, Empty);\n-\n-         if Token_Name = Name_Aliased then\n-            Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n-         end if;\n-\n-         if Token = Tok_Aliased then\n-            Set_Aliased_Present (CompDef_Node, True);\n-            Scan; -- past ALIASED\n+         if Aliased_Present then\n+            Error_Msg_SP (\"ALIASED not allowed here\");\n          end if;\n \n-         if Extensions_Allowed then                       --  Ada 0Y (AI-231)\n-            Not_Null_Present := P_Null_Exclusion;\n-            Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n-         end if;\n+         Set_Subtype_Indication     (CompDef_Node, Empty);\n+         Set_Aliased_Present        (CompDef_Node, False);\n+         Set_Access_Definition      (CompDef_Node,\n+           P_Access_Definition (Not_Null_Present));\n+      else\n \n-         Set_Subtype_Indication (CompDef_Node,\n-            P_Subtype_Indication (Not_Null_Present));\n+         Set_Access_Definition      (CompDef_Node, Empty);\n+         Set_Aliased_Present        (CompDef_Node, Aliased_Present);\n+         Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n+         Set_Subtype_Indication     (CompDef_Node,\n+           P_Subtype_Indication (Not_Null_Present));\n       end if;\n \n       Set_Component_Definition (Def_Node, CompDef_Node);\n@@ -2444,7 +2496,6 @@ package body Ch3 is\n                Specification_Node :=\n                  New_Node (N_Discriminant_Specification, Ident_Sloc);\n                Set_Defining_Identifier (Specification_Node, Idents (Ident));\n-\n                Not_Null_Present := P_Null_Exclusion;       --  Ada 0Y (AI-231)\n \n                if Token = Tok_Access then\n@@ -2454,11 +2505,10 @@ package body Ch3 is\n                   end if;\n \n                   Set_Discriminant_Type\n-                    (Specification_Node, P_Access_Definition);\n-                  Set_Null_Exclusion_Present               --  Ada 0Y (AI-231)\n-                    (Discriminant_Type (Specification_Node),\n-                     Not_Null_Present);\n+                    (Specification_Node,\n+                     P_Access_Definition (Not_Null_Present));\n                else\n+\n                   Set_Discriminant_Type\n                     (Specification_Node, P_Subtype_Mark);\n                   No_Constraint;\n@@ -2876,6 +2926,7 @@ package body Ch3 is\n    --  items, do we need to add this capability sometime in the future ???\n \n    procedure P_Component_Items (Decls : List_Id) is\n+      Aliased_Present  : Boolean := False;\n       CompDef_Node     : Node_Id;\n       Decl_Node        : Node_Id;\n       Scan_State       : Saved_Scan_State;\n@@ -2935,6 +2986,19 @@ package body Ch3 is\n \n             CompDef_Node := New_Node (N_Component_Definition, Token_Ptr);\n \n+            if Token_Name = Name_Aliased then\n+               Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n+            end if;\n+\n+            if Token = Tok_Aliased then\n+               Aliased_Present := True;\n+               Scan; -- past ALIASED\n+            end if;\n+\n+            Not_Null_Present := P_Null_Exclusion; --  Ada 0Y (AI-231/AI-254)\n+\n+            --  Ada 0Y (AI-230): Access Definition case\n+\n             if Token = Tok_Access then\n                if not Extensions_Allowed then\n                   Error_Msg_SP\n@@ -2943,35 +3007,28 @@ package body Ch3 is\n                   Error_Msg_SP (\"\\unit must be compiled with -gnatX switch\");\n                end if;\n \n+               if Aliased_Present then\n+                  Error_Msg_SP (\"ALIASED not allowed here\");\n+               end if;\n+\n                Set_Subtype_Indication (CompDef_Node, Empty);\n                Set_Aliased_Present    (CompDef_Node, False);\n-               Set_Access_Definition  (CompDef_Node, P_Access_Definition);\n+               Set_Access_Definition  (CompDef_Node,\n+                 P_Access_Definition (Not_Null_Present));\n             else\n \n-               Set_Access_Definition (CompDef_Node, Empty);\n-\n-               if Token_Name = Name_Aliased then\n-                  Check_95_Keyword (Tok_Aliased, Tok_Identifier);\n-               end if;\n-\n-               if Token = Tok_Aliased then\n-                  Scan; -- past ALIASED\n-                  Set_Aliased_Present (CompDef_Node, True);\n-               end if;\n+               Set_Access_Definition      (CompDef_Node, Empty);\n+               Set_Aliased_Present        (CompDef_Node, Aliased_Present);\n+               Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n \n                if Token = Tok_Array then\n                   Error_Msg_SC\n                     (\"anonymous arrays not allowed as components\");\n                   raise Error_Resync;\n                end if;\n \n-               if Extensions_Allowed then                 --  Ada 0Y (AI-231)\n-                  Not_Null_Present := P_Null_Exclusion;\n-                  Set_Null_Exclusion_Present (CompDef_Node, Not_Null_Present);\n-               end if;\n-\n                Set_Subtype_Indication (CompDef_Node,\n-                  P_Subtype_Indication (Not_Null_Present));\n+                 P_Subtype_Indication (Not_Null_Present));\n             end if;\n \n             Set_Component_Definition (Decl_Node, CompDef_Node);\n@@ -3231,15 +3288,18 @@ package body Ch3 is\n \n    --  PARAMETER_AND_RESULT_PROFILE ::= [FORMAL_PART] RETURN SUBTYPE_MARK\n \n-   --  The caller has checked that the initial token is ACCESS\n+   --  Ada 0Y (AI-254): If Header_Already_Parsed then the caller has already\n+   --  parsed the null_exclusion part and has also removed the ACCESS token;\n+   --  otherwise the caller has just checked that the initial token is ACCESS\n \n    --  Error recovery: can raise Error_Resync\n \n-   function P_Access_Type_Definition return Node_Id is\n-      Prot_Flag        : Boolean;\n-      Access_Loc       : Source_Ptr;\n-      Not_Null_Present : Boolean := False;\n-      Type_Def_Node    : Node_Id;\n+   function P_Access_Type_Definition\n+     (Header_Already_Parsed : Boolean := False) return Node_Id is\n+      Access_Loc            : constant Source_Ptr := Token_Ptr;\n+      Prot_Flag             : Boolean;\n+      Not_Null_Present      : Boolean := False;\n+      Type_Def_Node         : Node_Id;\n \n       procedure Check_Junk_Subprogram_Name;\n       --  Used in access to subprogram definition cases to check for an\n@@ -3266,13 +3326,11 @@ package body Ch3 is\n    --  Start of processing for P_Access_Type_Definition\n \n    begin\n-      if Extensions_Allowed then                          --  Ada 0Y (AI-231)\n-         Not_Null_Present := P_Null_Exclusion;\n+      if not Header_Already_Parsed then\n+         Not_Null_Present := P_Null_Exclusion;         --  Ada 0Y (AI-231)\n+         Scan; -- past ACCESS\n       end if;\n \n-      Access_Loc := Token_Ptr;\n-      Scan; -- past ACCESS\n-\n       if Token_Name = Name_Protected then\n          Check_95_Keyword (Tok_Protected, Tok_Procedure);\n          Check_95_Keyword (Tok_Protected, Tok_Function);\n@@ -3366,33 +3424,74 @@ package body Ch3 is\n \n    --  ACCESS_DEFINITION ::=\n    --    [NULL_EXCLUSION] access [GENERAL_ACCESS_MODIFIER] SUBTYPE_MARK\n+   --  | ACCESS_TO_SUBPROGRAM_DEFINITION\n+   --\n+   --  ACCESS_TO_SUBPROGRAM_DEFINITION\n+   --    [NULL_EXCLUSION] access [protected] procedure PARAMETER_PROFILE\n+   --  | [NULL_EXCLUSION] access [protected] function\n+   --    PARAMETER_AND_RESULT_PROFILE\n \n-   --  The caller has checked that the initial token is ACCESS\n+   --  The caller has parsed the null-exclusion part and it has also checked\n+   --  that the next token is ACCESS\n \n    --  Error recovery: cannot raise Error_Resync\n \n-   function P_Access_Definition return Node_Id is\n-      Def_Node : Node_Id;\n+   function P_Access_Definition\n+     (Null_Exclusion_Present : Boolean) return Node_Id is\n+      Def_Node  : Node_Id;\n+      Subp_Node : Node_Id;\n \n    begin\n       Def_Node := New_Node (N_Access_Definition, Token_Ptr);\n       Scan; -- past ACCESS\n \n-      --  Ada 0Y (AI-231)\n+      --  Ada 0Y (AI-254/AI-231)\n \n       if Extensions_Allowed then\n-         if Token = Tok_All then\n-            Scan; -- past ALL\n-            Set_All_Present (Def_Node);\n \n-         elsif Token = Tok_Constant then\n-            Scan; -- past CONSTANT\n-            Set_Constant_Present (Def_Node);\n+         --  Ada 0Y (AI-254): Access_To_Subprogram_Definition\n+\n+         if Token = Tok_Protected\n+           or else Token = Tok_Procedure\n+           or else Token = Tok_Function\n+         then\n+            Subp_Node :=\n+              P_Access_Type_Definition (Header_Already_Parsed => True);\n+            Set_Null_Exclusion_Present (Subp_Node, Null_Exclusion_Present);\n+            Set_Access_To_Subprogram_Definition (Def_Node, Subp_Node);\n+\n+         --  Ada 0Y (AI-231)\n+         --  [NULL_EXCLUSION] access [GENERAL_ACCESS_MODIFIER] SUBTYPE_MARK\n+\n+         else\n+            Set_Null_Exclusion_Present (Def_Node, Null_Exclusion_Present);\n+\n+            if Token = Tok_All then\n+               Scan; -- past ALL\n+               Set_All_Present (Def_Node);\n+\n+            elsif Token = Tok_Constant then\n+               Scan; -- past CONSTANT\n+               Set_Constant_Present (Def_Node);\n+            end if;\n+\n+            Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n+            No_Constraint;\n          end if;\n+\n+      --  Ada 95\n+\n+      else\n+         --  Ada 0Y (AI-254): The null-exclusion present is never present\n+         --  in Ada 83 and Ada 95\n+\n+         pragma Assert (Null_Exclusion_Present = False);\n+\n+         Set_Null_Exclusion_Present (Def_Node, False);\n+         Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n+         No_Constraint;\n       end if;\n \n-      Set_Subtype_Mark (Def_Node, P_Subtype_Mark);\n-      No_Constraint;\n       return Def_Node;\n    end P_Access_Definition;\n "}, {"sha": "406545d4316b8eb9e71f6e2e88bd9c9bab754b6c", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -963,8 +963,8 @@ package body Ch6 is\n                      Error_Msg_SC (\"(Ada 83) access parameters not allowed\");\n                   end if;\n \n-                  Set_Parameter_Type\n-                    (Specification_Node, P_Access_Definition);\n+                  Set_Parameter_Type (Specification_Node,\n+                    P_Access_Definition (Not_Null_Present));\n \n                else\n                   if Token = Tok_In or else Token = Tok_Out then"}, {"sha": "941d7d256e092c4cab39f15dee8791779f1c3cfb", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -655,7 +655,7 @@ begin\n                if Nast /= 1 then\n                   Error_Msg_N\n                     (\"file name pattern must have exactly one * character\",\n-                     Arg2);\n+                     Arg1);\n                   return Pragma_Node;\n                end if;\n "}, {"sha": "85a2fde13e23c3d408c39c4ac6364c564bf94a4a", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -557,8 +557,6 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  variable, then the caller can change it to an appropriate missing\n       --  begin message if indeed the BEGIN is missing.\n \n-      function P_Access_Definition                    return Node_Id;\n-      function P_Access_Type_Definition               return Node_Id;\n       function P_Array_Type_Definition                return Node_Id;\n       function P_Basic_Declarative_Items              return List_Id;\n       function P_Constraint_Opt                       return Node_Id;\n@@ -576,6 +574,17 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Subtype_Mark_Resync                  return Node_Id;\n       function P_Unknown_Discriminant_Part_Opt        return Boolean;\n \n+      function P_Access_Definition\n+        (Null_Exclusion_Present : Boolean) return Node_Id;\n+      --  Ada 0Y (AI-231/AI-254): The caller parses the null-exclusion part\n+      --  and indicates if it was present\n+\n+      function P_Access_Type_Definition\n+        (Header_Already_Parsed : Boolean := False) return Node_Id;\n+      --  Ada 0Y (AI-254): The formal is used to indicate if the caller has\n+      --  parsed the null_exclusion part. In this case the caller has also\n+      --  removed the ACCESS token\n+\n       procedure P_Component_Items (Decls : List_Id);\n       --  Scan out one or more component items and append them to the\n       --  given list. Only scans out more than one declaration in the\n@@ -1268,7 +1277,6 @@ begin\n \n                Save_Style_Check : constant Boolean := Style_Check;\n \n-\n             begin\n                Operating_Mode := Check_Syntax;\n                Style_Check := False;"}, {"sha": "ba2b04f546e3b46988f3a446e7e02f0936dece20", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -572,7 +572,9 @@ package body Prj.Env is\n       --  For call to Close\n \n       procedure Check (Project : Project_Id);\n-      --  ??? requires a comment\n+      --  Recursive procedure that put in the config pragmas file any non\n+      --  standard naming schemes, if it is not already in the file, then call\n+      --  itself for any imported project.\n \n       procedure Check_Temp_File;\n       --  Check that a temporary file has been opened."}, {"sha": "32dd37674a83949941bb7eb5512e9e5fe1785c39", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -24,16 +24,16 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package implements services for Project-aware tools, related\n---  to the environment (gnat.adc, ADA_INCLUDE_PATH, ADA_OBJECTS_PATH)\n+--  This package implements services for Project-aware tools, mostly related\n+--  to the environment (configuration pragma files, path files, mapping files).\n \n with GNAT.OS_Lib; use GNAT.OS_Lib;\n \n package Prj.Env is\n \n    procedure Initialize;\n-   --  Put Standard_Naming_Data into Namings table (called by Prj.Initialize)\n-   --  Above comment is obsolete (see body) ???\n+   --  Called by Prj.Initialize to perform required initialization\n+   --  steps for this package.\n \n    procedure Print_Sources;\n    --  Output the list of sources, after Project files have been scanned"}, {"sha": "f49af20afa6f93efcd455b920efb942f8550bcc5", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 2620, "deletions": 1707, "changes": 4327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969"}, {"sha": "9202ad33c40d746e2a2c2a0ce79c27d3cabc4d91", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -24,35 +24,52 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Check the Naming Scheme of a project file, find the directories\n---  and the source files.\n+--  Check the Naming Scheme of a project file, find the source files.\n \n private package Prj.Nmsc is\n \n    --  It would be nicer to have a higher level statement of what these\n    --  procedures do (related to their names), rather than just an english\n    --  language summary of the implementation ???\n \n+   procedure Other_Languages_Check\n+     (Project      : Project_Id;\n+      Report_Error : Put_Line_Access);\n+   --  Call Language_Independent_Check\n+   --\n+   --  Check the naming scheme for the supported languages (c, c++, ...) other\n+   --  than Ada. Find the source files if any.\n+   --\n+   --  If Report_Error is null, use the standard error reporting mechanism\n+   --  (Errout). Otherwise, report errors using Report_Error.\n+\n    procedure Ada_Check\n      (Project      : Project_Id;\n       Report_Error : Put_Line_Access;\n-      Trusted_Mode : Boolean);\n-   --  Call Language_Independent_Check.\n-   --  Check the naming scheme for Ada.\n-   --  Find the Ada source files if any.\n+      Follow_Links : Boolean);\n+   --  Call Language_Independent_Check\n+   --\n+   --  Check the naming scheme for Ada\n+   --\n+   --  Find the Ada source files if any\n+   --\n    --  If Report_Error is null , use the standard error reporting mechanism\n    --  (Errout). Otherwise, report errors using Report_Error.\n-   --  If Trusted_Mode is True, it is assumed that the project doesn't contain\n+   --\n+   --  If Follow_Links is False, it is assumed that the project doesn't contain\n    --  any file duplicated through symbolic links (although the latter are\n    --  still valid if they point to a file which is outside of the project),\n    --  and that no directory has a name which is a valid source name.\n \n    procedure Language_Independent_Check\n      (Project      : Project_Id;\n       Report_Error : Put_Line_Access);\n-   --  Check the object directory and the source directories.\n-   --  Check the library attributes, including the library directory if any.\n-   --  Get the set of specification and implementation suffixes, if any.\n+   --  Check the object directory and the source directories\n+   --\n+   --  Check the library attributes, including the library directory if any\n+   --\n+   --  Get the set of specification and implementation suffixes, if any\n+   --\n    --  If Report_Error is null , use the standard error reporting mechanism\n    --  (Errout). Otherwise, report errors using Report_Error.\n "}, {"sha": "bf2668805076f773396ab3eed05b004055ea125a", "filename": "gcc/ada/prj-pars.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-pars.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-pars.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2002 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,9 +26,10 @@\n \n with Ada.Exceptions; use Ada.Exceptions;\n \n-with Prj.Err;  use Prj.Err;\n+with Opt;\n with Output;   use Output;\n with Prj.Com;  use Prj.Com;\n+with Prj.Err;  use Prj.Err;\n with Prj.Part;\n with Prj.Proc;\n with Prj.Tree; use Prj.Tree;\n@@ -42,7 +43,8 @@ package body Prj.Pars is\n    procedure Parse\n      (Project           : out Project_Id;\n       Project_File_Name : String;\n-      Packages_To_Check : String_List_Access := All_Packages)\n+      Packages_To_Check : String_List_Access := All_Packages;\n+      Process_Languages : Languages_Processed := Ada_Language)\n    is\n       Project_Tree      : Project_Node_Id := Empty_Node;\n       The_Project       : Project_Id      := No_Project;\n@@ -64,7 +66,9 @@ package body Prj.Pars is\n            (Project           => The_Project,\n             Success           => Success,\n             From_Project_Node => Project_Tree,\n-            Report_Error      => null);\n+            Report_Error      => null,\n+            Process_Languages => Process_Languages,\n+            Follow_Links      => Opt.Follow_Links);\n          Prj.Err.Finalize;\n \n          if not Success then"}, {"sha": "be23e4bdc838e8354275c95ff56d7c11205dc114", "filename": "gcc/ada/prj-pars.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-pars.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-pars.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pars.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,7 +36,8 @@ package Prj.Pars is\n    procedure Parse\n      (Project           : out Project_Id;\n       Project_File_Name : String;\n-      Packages_To_Check : String_List_Access := All_Packages);\n+      Packages_To_Check : String_List_Access := All_Packages;\n+      Process_Languages : Languages_Processed := Ada_Language);\n    --  Parse a project files and all its imported project files.\n    --  If parsing is successful, Project_Id is the project ID\n    --  of the main project file; otherwise, Project_Id is set"}, {"sha": "170da259f9efdbb5c33557cd9c8cbe5acd97eba3", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -101,16 +101,22 @@ package body Prj.Proc is\n    --  recursively for all imported projects and a extended project, if any.\n    --  Then process the declarative items of the project.\n \n-   procedure Check (Project : in out Project_Id; Trusted_Mode : Boolean);\n+   procedure Check\n+     (Project           : in out Project_Id;\n+      Process_Languages : Languages_Processed;\n+      Follow_Links      : Boolean);\n    --  Set all projects to not checked, then call Recursive_Check for the\n    --  main project Project. Project is set to No_Project if errors occurred.\n-   --  See Prj.Nmsc.Ada_Check for information on Trusted_Mode.\n+   --  See Prj.Nmsc.Ada_Check for information on Follow_Links.\n \n-   procedure Recursive_Check (Project : Project_Id; Trusted_Mode : Boolean);\n+   procedure Recursive_Check\n+     (Project           : Project_Id;\n+      Process_Languages : Languages_Processed;\n+      Follow_Links      : Boolean);\n    --  If Project is not marked as checked, mark it as checked, call\n    --  Check_Naming_Scheme for the project, then call itself for a\n    --  possible extended project and all the imported projects of Project.\n-   --  See Prj.Nmsc.Ada_Check for information on Trusted_Mode\n+   --  See Prj.Nmsc.Ada_Check for information on Follow_Links\n \n    ---------\n    -- Add --\n@@ -207,15 +213,19 @@ package body Prj.Proc is\n    -- Check --\n    -----------\n \n-   procedure Check (Project : in out Project_Id; Trusted_Mode : Boolean) is\n+   procedure Check\n+     (Project           : in out Project_Id;\n+      Process_Languages : Languages_Processed;\n+      Follow_Links      : Boolean) is\n    begin\n       --  Make sure that all projects are marked as not checked\n \n       for Index in 1 .. Projects.Last loop\n          Projects.Table (Index).Checked := False;\n       end loop;\n \n-      Recursive_Check (Project, Trusted_Mode);\n+      Recursive_Check (Project, Process_Languages, Follow_Links);\n+\n    end Check;\n \n    ----------------\n@@ -817,7 +827,8 @@ package body Prj.Proc is\n       Success           : out Boolean;\n       From_Project_Node : Project_Node_Id;\n       Report_Error      : Put_Line_Access;\n-      Trusted_Mode      : Boolean := False)\n+      Process_Languages : Languages_Processed := Ada_Language;\n+      Follow_Links      : Boolean := True)\n    is\n       Obj_Dir    : Name_Id;\n       Extending  : Project_Id;\n@@ -841,7 +852,7 @@ package body Prj.Proc is\n          Extended_By       => No_Project);\n \n       if Project /= No_Project then\n-         Check (Project, Trusted_Mode);\n+         Check (Project, Process_Languages, Follow_Links);\n       end if;\n \n       --  If main project is an extending all project, set the object\n@@ -1755,7 +1766,11 @@ package body Prj.Proc is\n    -- Recursive_Check --\n    ---------------------\n \n-   procedure Recursive_Check (Project : Project_Id; Trusted_Mode : Boolean) is\n+   procedure Recursive_Check\n+     (Project           : Project_Id;\n+      Process_Languages : Languages_Processed;\n+      Follow_Links      : Boolean)\n+   is\n       Data                  : Project_Data;\n       Imported_Project_List : Project_List := Empty_Project_List;\n \n@@ -1776,15 +1791,15 @@ package body Prj.Proc is\n          --  Call itself for a possible extended project.\n          --  (if there is no extended project, then nothing happens).\n \n-         Recursive_Check (Data.Extends, Trusted_Mode);\n+         Recursive_Check (Data.Extends, Process_Languages, Follow_Links);\n \n          --  Call itself for all imported projects\n \n          Imported_Project_List := Data.Imported_Projects;\n          while Imported_Project_List /= Empty_Project_List loop\n             Recursive_Check\n               (Project_Lists.Table (Imported_Project_List).Project,\n-               Trusted_Mode);\n+               Process_Languages, Follow_Links);\n             Imported_Project_List :=\n               Project_Lists.Table (Imported_Project_List).Next;\n          end loop;\n@@ -1795,7 +1810,13 @@ package body Prj.Proc is\n             Write_Line (\"\"\"\");\n          end if;\n \n-         Prj.Nmsc.Ada_Check (Project, Error_Report, Trusted_Mode);\n+         case Process_Languages is\n+            when Ada_Language =>\n+               Prj.Nmsc.Ada_Check (Project, Error_Report, Follow_Links);\n+\n+            when Other_Languages =>\n+               Prj.Nmsc.Other_Languages_Check (Project, Error_Report);\n+         end case;\n       end if;\n    end Recursive_Check;\n "}, {"sha": "ca55a512a92e7dfea3c34bdbb3a129383c68ea08", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -37,15 +37,17 @@ package Prj.Proc is\n       Success           : out Boolean;\n       From_Project_Node : Project_Node_Id;\n       Report_Error      : Put_Line_Access;\n-      Trusted_Mode      : Boolean := False);\n+      Process_Languages : Languages_Processed := Ada_Language;\n+      Follow_Links      : Boolean := True);\n    --  Process a project file tree into project file data structures.\n    --  If Report_Error is null, use the error reporting mechanism.\n    --  Otherwise, report errors using Report_Error.\n    --\n-   --  If Trusted_Mode is True, it is assumed that the project doesn't contain\n+   --  If Follow_Links is False, it is assumed that the project doesn't contain\n    --  any file duplicated through symbolic links (although the latter are\n    --  still valid if they point to a file which is outside of the project),\n    --  and that no directory has a name which is a valid source name.\n+   --\n    --  Process is a bit of a junk name, how about Process_Project_Tree???\n \n end Prj.Proc;"}, {"sha": "4081e117508a96f039ea30e2d046ede8469587c8", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -74,7 +74,9 @@ package body Prj.Util is\n    -------------------\n \n    function Executable_Of\n-     (Project : Project_Id; Main : Name_Id) return Name_Id\n+     (Project  : Project_Id;\n+      Main     : Name_Id;\n+      Ada_Main : Boolean := True) return Name_Id\n    is\n       pragma Assert (Project /= No_Project);\n \n@@ -111,7 +113,7 @@ package body Prj.Util is\n \n    begin\n       if Builder_Package /= No_Package then\n-         if Executable = Nil_Variable_Value then\n+         if Executable = Nil_Variable_Value and Ada_Main then\n             Get_Name_String (Main);\n \n             --  Try as index the name minus the implementation suffix or minus\n@@ -212,15 +214,15 @@ package body Prj.Util is\n       --  otherwise remove any suffix ('.' followed by other characters), if\n       --  there is one.\n \n-      if Name_Len > Body_Append'Length\n+      if Ada_Main and then Name_Len > Body_Append'Length\n          and then Name_Buffer (Name_Len - Body_Append'Length + 1 .. Name_Len) =\n                     Body_Append\n       then\n          --  Found the body termination, remove it\n \n          Name_Len := Name_Len - Body_Append'Length;\n \n-      elsif Name_Len > Spec_Append'Length\n+      elsif Ada_Main and then Name_Len > Spec_Append'Length\n          and then Name_Buffer (Name_Len - Spec_Append'Length + 1 .. Name_Len) =\n                     Spec_Append\n       then\n@@ -379,8 +381,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Variable : Variable_Value;\n-      Default  : String)\n-      return     String\n+      Default  : String) return String\n    is\n    begin\n       if Variable.Kind /= Single\n@@ -395,8 +396,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Index    : Name_Id;\n-      In_Array : Array_Element_Id)\n-      return     Name_Id\n+      In_Array : Array_Element_Id) return Name_Id\n    is\n       Current    : Array_Element_Id := In_Array;\n       Element    : Array_Element;\n@@ -432,8 +432,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Index    : Name_Id;\n-      In_Array : Array_Element_Id)\n-      return     Variable_Value\n+      In_Array : Array_Element_Id) return Variable_Value\n    is\n       Current : Array_Element_Id := In_Array;\n       Element : Array_Element;\n@@ -468,8 +467,7 @@ package body Prj.Util is\n    function Value_Of\n      (Name                    : Name_Id;\n       Attribute_Or_Array_Name : Name_Id;\n-      In_Package              : Package_Id)\n-      return                    Variable_Value\n+      In_Package              : Package_Id) return Variable_Value\n    is\n       The_Array     : Array_Element_Id;\n       The_Attribute : Variable_Value := Nil_Variable_Value;\n@@ -504,8 +502,7 @@ package body Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       In_Array  : Name_Id;\n-      In_Arrays : Array_Id)\n-      return      Name_Id\n+      In_Arrays : Array_Id) return Name_Id\n    is\n       Current : Array_Id := In_Arrays;\n       The_Array : Array_Data;\n@@ -525,8 +522,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Name      : Name_Id;\n-      In_Arrays : Array_Id)\n-      return      Array_Element_Id\n+      In_Arrays : Array_Id) return Array_Element_Id\n    is\n       Current    : Array_Id := In_Arrays;\n       The_Array  : Array_Data;\n@@ -547,8 +543,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Name        : Name_Id;\n-      In_Packages : Package_Id)\n-      return        Package_Id\n+      In_Packages : Package_Id) return Package_Id\n    is\n       Current : Package_Id := In_Packages;\n       The_Package : Package_Element;\n@@ -566,8 +561,7 @@ package body Prj.Util is\n \n    function Value_Of\n      (Variable_Name : Name_Id;\n-      In_Variables  : Variable_Id)\n-      return          Variable_Value\n+      In_Variables  : Variable_Id) return Variable_Value\n    is\n       Current      : Variable_Id := In_Variables;\n       The_Variable : Variable;"}, {"sha": "c40b2949584ab77d70ca7b51185292e9c0b1a1bb", "filename": "gcc/ada/prj-util.ads", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj-util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,9 @@ with GNAT.OS_Lib; use GNAT.OS_Lib;\n package Prj.Util is\n \n    function Executable_Of\n-     (Project : Project_Id; Main : Name_Id) return Name_Id;\n+     (Project  : Project_Id;\n+      Main     : Name_Id;\n+      Ada_Main : Boolean := True) return Name_Id;\n    --  Return the value of the attribute Builder'Executable for file Main in\n    --  the project Project, if it exists. If there is no attribute Executable\n    --  for Main, remove the suffix from Main; then, if the attribute\n@@ -42,15 +44,13 @@ package Prj.Util is\n \n    function Value_Of\n      (Variable : Variable_Value;\n-      Default  : String)\n-      return     String;\n+      Default  : String) return String;\n    --  Get the value of a single string variable. If Variable is\n    --  Nil_Variable_Value, is a string list or is defaulted, return Default.\n \n    function Value_Of\n      (Index    : Name_Id;\n-      In_Array : Array_Element_Id)\n-      return     Name_Id;\n+      In_Array : Array_Element_Id) return Name_Id;\n    --  Get a single string array component. Returns No_Name if there is no\n    --  component Index, if In_Array is null, or if the component is a String\n    --  list. Depending on the attribute (only attributes may be associative\n@@ -60,8 +60,7 @@ package Prj.Util is\n \n    function Value_Of\n      (Index    : Name_Id;\n-      In_Array : Array_Element_Id)\n-      return     Variable_Value;\n+      In_Array : Array_Element_Id) return Variable_Value;\n    --  Get a string array component (single String or String list).\n    --  Returns Nil_Variable_Value if there is no component Index\n    --  or if In_Array is null.\n@@ -74,8 +73,7 @@ package Prj.Util is\n    function Value_Of\n      (Name                    : Name_Id;\n       Attribute_Or_Array_Name : Name_Id;\n-      In_Package              : Package_Id)\n-      return                    Variable_Value;\n+      In_Package              : Package_Id) return Variable_Value;\n    --  In a specific package,\n    --   - if there exists an array Attribute_Or_Array_Name with an index\n    --     Name, returns the corresponding component (depending on the\n@@ -89,32 +87,28 @@ package Prj.Util is\n    function Value_Of\n      (Index     : Name_Id;\n       In_Array  : Name_Id;\n-      In_Arrays : Array_Id)\n-      return      Name_Id;\n+      In_Arrays : Array_Id) return Name_Id;\n    --  Get a string array component in an array of an array list.\n    --  Returns No_Name if there is no component Index, if In_Arrays is null, if\n    --  In_Array is not found in In_Arrays or if the component is a String list.\n \n    function Value_Of\n      (Name      : Name_Id;\n-      In_Arrays : Array_Id)\n-      return      Array_Element_Id;\n+      In_Arrays : Array_Id) return Array_Element_Id;\n    --  Returns a specified array in an array list. Returns No_Array_Element\n    --  if In_Arrays is null or if Name is not the name of an array in\n    --  In_Arrays. The caller must ensure that Name is in lower case.\n \n    function Value_Of\n      (Name        : Name_Id;\n-      In_Packages : Package_Id)\n-      return        Package_Id;\n+      In_Packages : Package_Id) return Package_Id;\n    --  Returns a specified package in a package list. Returns No_Package\n    --  if In_Packages is null or if Name is not the name of a package in\n    --  Package_List. The caller must ensure that Name is in lower case.\n \n    function Value_Of\n      (Variable_Name : Name_Id;\n-      In_Variables  : Variable_Id)\n-      return          Variable_Value;\n+      In_Variables  : Variable_Id) return Variable_Value;\n    --  Returns a specified variable in a variable list. Returns null if\n    --  In_Variables is null or if Variable_Name is not the name of a\n    --  variable in In_Variables. Caller must ensure that Name is lower case."}, {"sha": "b71b7db512f7bc7ec336ec081292c8faaf697dc2", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -41,8 +41,6 @@ package body Prj is\n \n    The_Empty_String : Name_Id;\n \n-   Ada_Language     : constant Name_Id := Name_Ada;\n-\n    subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n \n    The_Casing_Images : constant array (Known_Casing) of String_Access :=\n@@ -74,7 +72,9 @@ package body Prj is\n       Implementation_Exceptions => No_Array_Element);\n \n    Project_Empty : constant Project_Data :=\n-     (First_Referred_By              => No_Project,\n+     (Languages                      => No_Languages,\n+      Impl_Suffixes                  => No_Impl_Suffixes,\n+      First_Referred_By              => No_Project,\n       Name                           => No_Name,\n       Path_Name                      => No_Name,\n       Virtual                        => False,\n@@ -99,6 +99,11 @@ package body Prj is\n       Symbol_Data                    => No_Symbols,\n       Sources_Present                => True,\n       Sources                        => Nil_String,\n+      First_Other_Source             => No_Other_Source,\n+      Last_Other_Source              => No_Other_Source,\n+      Imported_Directories_Switches  => null,\n+      Include_Path                   => null,\n+      Include_Data_Set               => False,\n       Source_Dirs                    => Nil_String,\n       Known_Order_Of_Source_Dirs     => True,\n       Object_Directory               => No_Name,\n@@ -247,11 +252,21 @@ package body Prj is\n          Name_Len := 1;\n          Name_Buffer (1) := '/';\n          Slash := Name_Find;\n+\n+         for Lang in Programming_Language loop\n+            Name_Len := Lang_Names (Lang)'Length;\n+            Name_Buffer (1 .. Name_Len) := Lang_Names (Lang).all;\n+            Lang_Name_Ids (Lang) := Name_Find;\n+            Name_Len := Lang_Suffixes (Lang)'Length;\n+            Name_Buffer (1 .. Name_Len) := Lang_Suffixes (Lang).all;\n+            Lang_Suffix_Ids (Lang) := Name_Find;\n+         end loop;\n+\n          Std_Naming_Data.Current_Spec_Suffix := Default_Ada_Spec_Suffix;\n          Std_Naming_Data.Current_Body_Suffix := Default_Ada_Body_Suffix;\n          Std_Naming_Data.Separate_Suffix     := Default_Ada_Body_Suffix;\n          Register_Default_Naming_Scheme\n-           (Language            => Ada_Language,\n+           (Language            => Name_Ada,\n             Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n             Default_Body_Suffix => Default_Ada_Body_Suffix);\n          Prj.Env.Initialize;"}, {"sha": "b9965bc4cbab470abaf039a2eb934fb5b7a81eda", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 120, "deletions": 1, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,103 @@ package Prj is\n    Slash : Name_Id;\n    --  \"/\", used as the path of locally removed files\n \n+   type Languages_Processed is (Ada_Language, Other_Languages);\n+   --  To specify how to process project files\n+\n+   type Programming_Language is\n+     (Lang_Ada, Lang_C, Lang_C_Plus_Plus, Lang_Fortran);\n+   --  The list of language supported\n+\n+   subtype Other_Programming_Language is\n+      Programming_Language range Lang_C .. Programming_Language'Last;\n+   type Languages_In_Project is array (Programming_Language) of Boolean;\n+   No_Languages : constant Languages_In_Project := (others => False);\n+\n+   type Impl_Suffix_Array is array (Programming_Language) of Name_Id;\n+   No_Impl_Suffixes : constant Impl_Suffix_Array := (others => No_Name);\n+\n+   Lang_Ada_Name         : aliased String := \"ada\";\n+   Lang_C_Name           : aliased String := \"c\";\n+   Lang_C_Plus_Plus_Name : aliased String := \"c++\";\n+   Lang_Fortran_Name     : aliased String := \"for\";\n+   Lang_Names : constant array (Programming_Language) of String_Access :=\n+     (Lang_Ada         => Lang_Ada_Name        'Access,\n+      Lang_C           => Lang_C_Name          'Access,\n+      Lang_C_Plus_Plus => Lang_C_Plus_Plus_Name'Access,\n+      Lang_Fortran     => Lang_Fortran_Name'Access);\n+   --  Names of the supported programming languages, to be used after switch\n+   --  -x when using a GCC compiler.\n+\n+   Lang_Name_Ids : array (Programming_Language) of Name_Id;\n+   --  Initialized by Prj.Initialize\n+\n+   Lang_Ada_Display_Name         : aliased String := \"Ada\";\n+   Lang_C_Display_Name           : aliased String := \"C\";\n+   Lang_C_Plus_Plus_Display_Name : aliased String := \"C++\";\n+   Lang_Fortran_Display_Name     : aliased String := \"Fortran\";\n+   Lang_Display_Names :\n+     constant array (Programming_Language) of String_Access :=\n+       (Lang_Ada         => Lang_Ada_Display_Name        'Access,\n+        Lang_C           => Lang_C_Display_Name          'Access,\n+        Lang_C_Plus_Plus => Lang_C_Plus_Plus_Display_Name'Access,\n+        Lang_Fortran     => Lang_Fortran_Display_Name'Access);\n+   --  Names of the supported programming languages, to be used for display\n+   --  purposes.\n+\n+   Ada_Impl_Suffix         : aliased String := \".adb\";\n+   C_Impl_Suffix           : aliased String := \".c\";\n+   C_Plus_Plus_Impl_Suffix : aliased String := \".cc\";\n+   Fortran_Impl_Suffix     : aliased String := \".for\";\n+   Lang_Suffixes : constant array (Programming_Language) of String_Access :=\n+     (Lang_Ada         => Ada_Impl_Suffix        'Access,\n+      Lang_C           => C_Impl_Suffix          'Access,\n+      Lang_C_Plus_Plus => C_Plus_Plus_Impl_Suffix'Access,\n+      Lang_Fortran     => Fortran_Impl_Suffix'Access);\n+   --  Default extension of the sources of the different languages.\n+\n+   Lang_Suffix_Ids : array (Programming_Language) of Name_Id;\n+   --  Initialized by Prj.Initialize\n+\n+   Gnatmake_String    : aliased String := \"gnatmake\";\n+   Gcc_String         : aliased String := \"gcc\";\n+   G_Plus_Plus_String : aliased String := \"g++\";\n+   G77_String         : aliased String := \"g77\";\n+   Default_Compiler_Names  :\n+     constant array (Programming_Language) of String_Access :=\n+     (Lang_Ada         => Gnatmake_String   'Access,\n+      Lang_C           => Gcc_String        'Access,\n+      Lang_C_Plus_Plus => G_Plus_Plus_String'Access,\n+      Lang_Fortran     => G77_String        'Access);\n+   --  Default names of the compilers for the supported languages.\n+   --  Used when no IDE'Compiler_Command is specified for a language.\n+   --  For Ada, specify the gnatmake executable.\n+\n+   type Other_Source_Id is new Nat;\n+   No_Other_Source : constant Other_Source_Id := 0;\n+   type Other_Source is record\n+      Language         : Programming_Language; --  language of the source\n+      File_Name        : Name_Id;              --  source file simple name\n+      Path_Name        : Name_Id;              --  source full path name\n+      Source_TS        : Time_Stamp_Type;      --  source file time stamp\n+      Object_Name      : Name_Id;              --  object file simple name\n+      Object_Path      : Name_Id;              --  object full path name\n+      Object_TS        : Time_Stamp_Type;      --  object file time stamp\n+      Dep_Name         : Name_Id;              --  dependency file simple name\n+      Dep_Path         : Name_Id;              --  dependency full path name\n+      Dep_TS           : Time_Stamp_Type;      --  dependency file time stamp\n+      Naming_Exception : Boolean := False;     --  True if a naming exception\n+      Next             : Other_Source_Id := No_Other_Source;\n+   end record;\n+\n+   package Other_Sources is new Table.Table\n+     (Table_Component_Type => Other_Source,\n+      Table_Index_Type     => Other_Source_Id,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 200,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Prj.Other_Sources\");\n+   --  The table for sources of languages other than Ada\n+\n    type Verbosity is (Default, Medium, High);\n    --  Verbosity when parsing GNAT Project Files\n    --    Default is default (very quiet, if no errors).\n@@ -347,6 +444,12 @@ package Prj is\n    --  The following record describes a project file representation\n \n    type Project_Data is record\n+      Languages : Languages_In_Project := No_Languages;\n+      --  Indicate the different languages of the source of this project\n+\n+      Impl_Suffixes : Impl_Suffix_Array := No_Impl_Suffixes;\n+      --  The source suffixes of the different languages other than Ada\n+\n       First_Referred_By  : Project_Id := No_Project;\n       --  The project, if any, that was the first to be known\n       --  as importing or extending this project.\n@@ -447,6 +550,22 @@ package Prj is\n       --  The list of all the source file names.\n       --  Set by Prj.Nmsc.Check_Naming_Scheme.\n \n+      First_Other_Source : Other_Source_Id := No_Other_Source;\n+      Last_Other_Source  : Other_Source_Id := No_Other_Source;\n+      --  Head and tail of the list of sources of languages other than Ada\n+\n+      Imported_Directories_Switches : Argument_List_Access := null;\n+      --  List of the -I switches to be used when compiling sources of\n+      --  languages other than Ada.\n+\n+      Include_Path : String_Access := null;\n+      --  Value to be used as CPATH, when using a GCC, instead of a list of\n+      --  -I switches.\n+\n+      Include_Data_Set : Boolean := False;\n+      --  Set to True when Imported_Directories_Switches or Include_Path are\n+      --  set.\n+\n       Source_Dirs : String_List_Id := Nil_String;\n       --  The list of all the source directories.\n       --  Set by Prj.Nmsc.Check_Naming_Scheme."}, {"sha": "aa51054055eadc0ac249f03c54be6fc0b7d47ae6", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 259, "deletions": 2, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -279,6 +279,7 @@ package Rtsfind is\n       System_Pack_63,\n       System_Parameters,\n       System_Partition_Interface,\n+      System_PolyORB_Interface,\n       System_Pool_Global,\n       System_Pool_Empty,\n       System_Pool_Local,\n@@ -1003,7 +1004,6 @@ package Rtsfind is\n      RE_Get_Unique_Remote_Pointer,       -- System.Partition_Interface\n      RE_RACW_Stub_Type,                  -- System.Partition_Interface\n      RE_RACW_Stub_Type_Access,           -- System.Partition_Interface\n-     RE_Raise_Program_Error_For_E_4_18,  -- System.Partition_Interface\n      RE_Raise_Program_Error_Unknown_Tag, -- System.Partition_Interface\n      RE_Register_Passive_Package,        -- System.Partition_Interface\n      RE_Register_Receiving_Stub,         -- System.Partition_Interface\n@@ -1022,6 +1022,135 @@ package Rtsfind is\n      RE_Partition_ID,                    -- System.RPC\n      RE_RPC_Receiver,                    -- System.RPC\n \n+     RE_To_PolyORB_String,               -- System.PolyORB_Interface\n+     RE_To_Standard_String,              -- System.PolyORB_Interface\n+     RE_Caseless_String_Eq,              -- System.PolyORB_Interface\n+     RE_TypeCode,                        -- System.PolyORB_Interface\n+     RE_Any,                             -- System.PolyORB_Interface\n+     RE_Mode_In,                         -- System.PolyORB_Interface\n+     RE_Mode_Out,                        -- System.PolyORB_Interface\n+     RE_Mode_Inout,                      -- System.PolyORB_Interface\n+     RE_NamedValue,                      -- System.PolyORB_Interface\n+     RE_Result_Name,                     -- System.PolyORB_Interface\n+     RE_Object_Ref,                      -- System.PolyORB_Interface\n+     RE_Create_Any,                      -- System.PolyORB_Interface\n+     RE_Any_Aggregate_Build,             -- System.PolyORB_Interface\n+     RE_Add_Aggregate_Element,           -- System.PolyORB_Interface\n+     RE_Get_Aggregate_Element,           -- System.PolyORB_Interface\n+     RE_Content_Type,                    -- System.PolyORB_Interface\n+     RE_Any_Member_Type,                 -- System.PolyORB_Interface\n+     RE_Get_Nested_Sequence_Length,      -- System.PolyORB_Interface\n+     RE_Extract_Union_Value,             -- System.PolyORB_Interface\n+     RE_NVList_Ref,                      -- System.PolyORB_Interface\n+     RE_NVList_Create,                   -- System.PolyORB_Interface\n+     RE_NVList_Add_Item,                 -- System.PolyORB_Interface\n+     RE_Request_Access,                  -- System.PolyORB_Interface\n+     RE_Request_Create,                  -- System.PolyORB_Interface\n+     RE_Request_Invoke,                  -- System.PolyORB_Interface\n+     RE_Request_Arguments,               -- System.PolyORB_Interface\n+     RE_Request_Set_Out,                 -- System.PolyORB_Interface\n+     RE_Request_Raise_Occurrence,        -- System.PolyORB_Interface\n+     RE_Nil_Exc_List,                    -- System.PolyORB_Interface\n+     RE_Servant,                         -- System.PolyORB_Interface\n+     RE_Copy_Any_Value,                  -- System.PolyORB_Interface\n+     RE_Set_Result,                      -- System.PolyORB_Interface\n+     RE_Register_Obj_Receiving_Stub,     -- System.PolyORB_Interface\n+     RE_Register_Pkg_Receiving_Stub,     -- System.PolyORB_Interface\n+     RE_Is_Nil,                          -- System.PolyORB_Interface\n+     RE_Entity_Ptr,                      -- System.PolyORB_Interface\n+     RE_Entity_Of,                       -- System.PolyORB_Interface\n+     RE_Inc_Usage,                       -- System.PolyORB_Interface\n+     RE_Set_Ref,                         -- System.PolyORB_Interface\n+     RE_Get_Local_Address,               -- System.PolyORB_Interface\n+     RE_Get_Reference,                   -- System.PolyORB_Interface\n+     RE_Local_Oid_To_Address,            -- System.PolyORB_Interface\n+     RE_RCI_Locator,                     -- System.PolyORB_Interface\n+     RE_RCI_Subp_Info,                   -- System.PolyORB_Interface\n+     RE_RCI_Subp_Info_Array,             -- System.PolyORB_Interface\n+     RE_Get_RAS_Ref,                     -- System.PolyORB_Interface\n+     RE_Asynchronous_P_To_Sync_Scope,    -- System.PolyORB_Interface\n+     RE_Buffer_Stream_Type,              -- System.PolyORB_Interface\n+     RE_Allocate_Buffer,                 -- System.PolyORB_Interface\n+     RE_Release_Buffer,                  -- System.PolyORB_Interface\n+     RE_BS_To_Any,                       -- System.PolyORB_Interface\n+     RE_Any_To_BS,                       -- System.PolyORB_Interface\n+\n+     RE_FA_AD,                           -- System.PolyORB_Interface\n+     RE_FA_AS,                           -- System.PolyORB_Interface\n+     RE_FA_B,                            -- System.PolyORB_Interface\n+     RE_FA_C,                            -- System.PolyORB_Interface\n+     RE_FA_F,                            -- System.PolyORB_Interface\n+     RE_FA_I,                            -- System.PolyORB_Interface\n+     RE_FA_LF,                           -- System.PolyORB_Interface\n+     RE_FA_LI,                           -- System.PolyORB_Interface\n+     RE_FA_LLF,                          -- System.PolyORB_Interface\n+     RE_FA_LLI,                          -- System.PolyORB_Interface\n+     RE_FA_LLU,                          -- System.PolyORB_Interface\n+     RE_FA_LU,                           -- System.PolyORB_Interface\n+     RE_FA_SF,                           -- System.PolyORB_Interface\n+     RE_FA_SI,                           -- System.PolyORB_Interface\n+     RE_FA_SSI,                          -- System.PolyORB_Interface\n+     RE_FA_SSU,                          -- System.PolyORB_Interface\n+     RE_FA_SU,                           -- System.PolyORB_Interface\n+     RE_FA_U,                            -- System.PolyORB_Interface\n+     RE_FA_WC,                           -- System.PolyORB_Interface\n+     RE_FA_String,                       -- System.PolyORB_Interface\n+     RE_FA_ObjRef,                       -- System.PolyORB_Interface\n+\n+     RE_TA_AD,                           -- System.PolyORB_Interface\n+     RE_TA_AS,                           -- System.PolyORB_Interface\n+     RE_TA_B,                            -- System.PolyORB_Interface\n+     RE_TA_C,                            -- System.PolyORB_Interface\n+     RE_TA_F,                            -- System.PolyORB_Interface\n+     RE_TA_I,                            -- System.PolyORB_Interface\n+     RE_TA_LF,                           -- System.PolyORB_Interface\n+     RE_TA_LI,                           -- System.PolyORB_Interface\n+     RE_TA_LLF,                          -- System.PolyORB_Interface\n+     RE_TA_LLI,                          -- System.PolyORB_Interface\n+     RE_TA_LLU,                          -- System.PolyORB_Interface\n+     RE_TA_LU,                           -- System.PolyORB_Interface\n+     RE_TA_SF,                           -- System.PolyORB_Interface\n+     RE_TA_SI,                           -- System.PolyORB_Interface\n+     RE_TA_SSI,                          -- System.PolyORB_Interface\n+     RE_TA_SSU,                          -- System.PolyORB_Interface\n+     RE_TA_SU,                           -- System.PolyORB_Interface\n+     RE_TA_U,                            -- System.PolyORB_Interface\n+     RE_TA_WC,                           -- System.PolyORB_Interface\n+     RE_TA_String,                       -- System.PolyORB_Interface\n+     RE_TA_ObjRef,                       -- System.PolyORB_Interface\n+     RE_TA_TC,                           -- System.PolyORB_Interface\n+\n+     RE_TC_Alias,                        -- System.PolyORB_Interface\n+     RE_TC_Build,                        -- System.PolyORB_Interface\n+     RE_Set_TC,                          -- System.PolyORB_Interface\n+     RE_TC_Any,                          -- System.PolyORB_Interface\n+     RE_TC_AD,                           -- System.PolyORB_Interface\n+     RE_TC_AS,                           -- System.PolyORB_Interface\n+     RE_TC_B,                            -- System.PolyORB_Interface\n+     RE_TC_C,                            -- System.PolyORB_Interface\n+     RE_TC_F,                            -- System.PolyORB_Interface\n+     RE_TC_I,                            -- System.PolyORB_Interface\n+     RE_TC_LF,                           -- System.PolyORB_Interface\n+     RE_TC_LI,                           -- System.PolyORB_Interface\n+     RE_TC_LLF,                          -- System.PolyORB_Interface\n+     RE_TC_LLI,                          -- System.PolyORB_Interface\n+     RE_TC_LLU,                          -- System.PolyORB_Interface\n+     RE_TC_LU,                           -- System.PolyORB_Interface\n+     RE_TC_SF,                           -- System.PolyORB_Interface\n+     RE_TC_SI,                           -- System.PolyORB_Interface\n+     RE_TC_SSI,                          -- System.PolyORB_Interface\n+     RE_TC_SSU,                          -- System.PolyORB_Interface\n+     RE_TC_SU,                           -- System.PolyORB_Interface\n+     RE_TC_U,                            -- System.PolyORB_Interface\n+     RE_TC_Void,                         -- System.PolyORB_Interface\n+     RE_TC_Opaque,                       -- System.PolyORB_Interface,\n+     RE_TC_WC,                           -- System.PolyORB_Interface\n+     RE_TC_Array,                        -- System.PolyORB_Interface,\n+     RE_TC_Sequence,                     -- System.PolyORB_Interface,\n+     RE_TC_String,                       -- System.PolyORB_Interface,\n+     RE_TC_Struct,                       -- System.PolyORB_Interface,\n+     RE_TC_Union,                        -- System.PolyORB_Interface,\n+\n      RE_IS_Is1,                          -- System.Scalar_Values\n      RE_IS_Is2,                          -- System.Scalar_Values\n      RE_IS_Is4,                          -- System.Scalar_Values\n@@ -1944,13 +2073,141 @@ package Rtsfind is\n      RE_Get_Unique_Remote_Pointer        => System_Partition_Interface,\n      RE_RACW_Stub_Type                   => System_Partition_Interface,\n      RE_RACW_Stub_Type_Access            => System_Partition_Interface,\n-     RE_Raise_Program_Error_For_E_4_18   => System_Partition_Interface,\n      RE_Raise_Program_Error_Unknown_Tag  => System_Partition_Interface,\n      RE_Register_Passive_Package         => System_Partition_Interface,\n      RE_Register_Receiving_Stub          => System_Partition_Interface,\n      RE_RCI_Info                         => System_Partition_Interface,\n      RE_Subprogram_Id                    => System_Partition_Interface,\n \n+     RE_To_PolyORB_String                => System_PolyORB_Interface,\n+     RE_To_Standard_String               => System_PolyORB_Interface,\n+     RE_Caseless_String_Eq               => System_PolyORB_Interface,\n+     RE_TypeCode                         => System_PolyORB_Interface,\n+     RE_Any                              => System_PolyORB_Interface,\n+     RE_Mode_In                          => System_PolyORB_Interface,\n+     RE_Mode_Out                         => System_PolyORB_Interface,\n+     RE_Mode_Inout                       => System_PolyORB_Interface,\n+     RE_NamedValue                       => System_PolyORB_Interface,\n+     RE_Result_Name                      => System_PolyORB_Interface,\n+     RE_Object_Ref                       => System_PolyORB_Interface,\n+     RE_Create_Any                       => System_PolyORB_Interface,\n+     RE_Any_Aggregate_Build              => System_PolyORB_Interface,\n+     RE_Add_Aggregate_Element            => System_PolyORB_Interface,\n+     RE_Get_Aggregate_Element            => System_PolyORB_Interface,\n+     RE_Content_Type                     => System_PolyORB_Interface,\n+     RE_Any_Member_Type                  => System_PolyORB_Interface,\n+     RE_Get_Nested_Sequence_Length       => System_PolyORB_Interface,\n+     RE_Extract_Union_Value              => System_PolyORB_Interface,\n+     RE_NVList_Ref                       => System_PolyORB_Interface,\n+     RE_NVList_Create                    => System_PolyORB_Interface,\n+     RE_NVList_Add_Item                  => System_PolyORB_Interface,\n+     RE_Request_Access                   => System_PolyORB_Interface,\n+     RE_Request_Create                   => System_PolyORB_Interface,\n+     RE_Request_Invoke                   => System_PolyORB_Interface,\n+     RE_Request_Arguments                => System_PolyORB_Interface,\n+     RE_Request_Set_Out                  => System_PolyORB_Interface,\n+     RE_Request_Raise_Occurrence         => System_PolyORB_Interface,\n+     RE_Nil_Exc_List                     => System_PolyORB_Interface,\n+     RE_Servant                          => System_PolyORB_Interface,\n+     RE_Copy_Any_Value                   => System_PolyORB_Interface,\n+     RE_Set_Result                       => System_PolyORB_Interface,\n+     RE_Register_Obj_Receiving_Stub      => System_PolyORB_Interface,\n+     RE_Register_Pkg_Receiving_Stub      => System_PolyORB_Interface,\n+     RE_Is_Nil                           => System_PolyORB_Interface,\n+     RE_Entity_Ptr                       => System_PolyORB_Interface,\n+     RE_Entity_Of                        => System_PolyORB_Interface,\n+     RE_Inc_Usage                        => System_PolyORB_Interface,\n+     RE_Set_Ref                          => System_PolyORB_Interface,\n+     RE_Get_Local_Address                => System_PolyORB_Interface,\n+     RE_Get_Reference                    => System_PolyORB_Interface,\n+     RE_Local_Oid_To_Address             => System_PolyORB_Interface,\n+     RE_RCI_Locator                      => System_PolyORB_Interface,\n+     RE_RCI_Subp_Info                    => System_PolyORB_Interface,\n+     RE_RCI_Subp_Info_Array              => System_PolyORB_Interface,\n+     RE_Get_RAS_Ref                      => System_PolyORB_Interface,\n+     RE_Asynchronous_P_To_Sync_Scope     => System_PolyORB_Interface,\n+     RE_Buffer_Stream_Type               => System_PolyORB_Interface,\n+     RE_Allocate_Buffer                  => System_PolyORB_Interface,\n+     RE_Release_Buffer                   => System_PolyORB_Interface,\n+     RE_BS_To_Any                        => System_PolyORB_Interface,\n+     RE_Any_To_BS                        => System_PolyORB_Interface,\n+\n+     RE_FA_AD                            => System_PolyORB_Interface,\n+     RE_FA_AS                            => System_PolyORB_Interface,\n+     RE_FA_B                             => System_PolyORB_Interface,\n+     RE_FA_C                             => System_PolyORB_Interface,\n+     RE_FA_F                             => System_PolyORB_Interface,\n+     RE_FA_I                             => System_PolyORB_Interface,\n+     RE_FA_LF                            => System_PolyORB_Interface,\n+     RE_FA_LI                            => System_PolyORB_Interface,\n+     RE_FA_LLF                           => System_PolyORB_Interface,\n+     RE_FA_LLI                           => System_PolyORB_Interface,\n+     RE_FA_LLU                           => System_PolyORB_Interface,\n+     RE_FA_LU                            => System_PolyORB_Interface,\n+     RE_FA_SF                            => System_PolyORB_Interface,\n+     RE_FA_SI                            => System_PolyORB_Interface,\n+     RE_FA_SSI                           => System_PolyORB_Interface,\n+     RE_FA_SSU                           => System_PolyORB_Interface,\n+     RE_FA_SU                            => System_PolyORB_Interface,\n+     RE_FA_U                             => System_PolyORB_Interface,\n+     RE_FA_WC                            => System_PolyORB_Interface,\n+     RE_FA_String                        => System_PolyORB_Interface,\n+     RE_FA_ObjRef                        => System_PolyORB_Interface,\n+\n+     RE_TA_AD                            => System_PolyORB_Interface,\n+     RE_TA_AS                            => System_PolyORB_Interface,\n+     RE_TA_B                             => System_PolyORB_Interface,\n+     RE_TA_C                             => System_PolyORB_Interface,\n+     RE_TA_F                             => System_PolyORB_Interface,\n+     RE_TA_I                             => System_PolyORB_Interface,\n+     RE_TA_LF                            => System_PolyORB_Interface,\n+     RE_TA_LI                            => System_PolyORB_Interface,\n+     RE_TA_LLF                           => System_PolyORB_Interface,\n+     RE_TA_LLI                           => System_PolyORB_Interface,\n+     RE_TA_LLU                           => System_PolyORB_Interface,\n+     RE_TA_LU                            => System_PolyORB_Interface,\n+     RE_TA_SF                            => System_PolyORB_Interface,\n+     RE_TA_SI                            => System_PolyORB_Interface,\n+     RE_TA_SSI                           => System_PolyORB_Interface,\n+     RE_TA_SSU                           => System_PolyORB_Interface,\n+     RE_TA_SU                            => System_PolyORB_Interface,\n+     RE_TA_U                             => System_PolyORB_Interface,\n+     RE_TA_WC                            => System_PolyORB_Interface,\n+     RE_TA_String                        => System_PolyORB_Interface,\n+     RE_TA_ObjRef                        => System_PolyORB_Interface,\n+     RE_TA_TC                            => System_PolyORB_Interface,\n+\n+     RE_TC_Alias                         => System_PolyORB_Interface,\n+     RE_TC_Build                         => System_PolyORB_Interface,\n+     RE_Set_TC                           => System_PolyORB_Interface,\n+     RE_TC_Any                           => System_PolyORB_Interface,\n+     RE_TC_AD                            => System_PolyORB_Interface,\n+     RE_TC_AS                            => System_PolyORB_Interface,\n+     RE_TC_B                             => System_PolyORB_Interface,\n+     RE_TC_C                             => System_PolyORB_Interface,\n+     RE_TC_F                             => System_PolyORB_Interface,\n+     RE_TC_I                             => System_PolyORB_Interface,\n+     RE_TC_LF                            => System_PolyORB_Interface,\n+     RE_TC_LI                            => System_PolyORB_Interface,\n+     RE_TC_LLF                           => System_PolyORB_Interface,\n+     RE_TC_LLI                           => System_PolyORB_Interface,\n+     RE_TC_LLU                           => System_PolyORB_Interface,\n+     RE_TC_LU                            => System_PolyORB_Interface,\n+     RE_TC_SF                            => System_PolyORB_Interface,\n+     RE_TC_SI                            => System_PolyORB_Interface,\n+     RE_TC_SSI                           => System_PolyORB_Interface,\n+     RE_TC_SSU                           => System_PolyORB_Interface,\n+     RE_TC_SU                            => System_PolyORB_Interface,\n+     RE_TC_U                             => System_PolyORB_Interface,\n+     RE_TC_Void                          => System_PolyORB_Interface,\n+     RE_TC_Opaque                        => System_PolyORB_Interface,\n+     RE_TC_WC                            => System_PolyORB_Interface,\n+     RE_TC_Array                         => System_PolyORB_Interface,\n+     RE_TC_Sequence                      => System_PolyORB_Interface,\n+     RE_TC_String                        => System_PolyORB_Interface,\n+     RE_TC_Struct                        => System_PolyORB_Interface,\n+     RE_TC_Union                         => System_PolyORB_Interface,\n+\n      RE_Global_Pool_Object               => System_Pool_Global,\n \n      RE_Unbounded_Reclaim_Pool           => System_Pool_Local,"}, {"sha": "f2f71b28b37a463eb101fcecb6bec260b8f0b3cc", "filename": "gcc/ada/s-auxdec.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-auxdec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-auxdec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/Or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,9 +102,8 @@ package body System.Aux_DEC is\n    function \"-\" (Left : Address; Right : Address) return Integer is\n       pragma Unsuppress (All_Checks);\n       --  Because this can raise Constraint_Error for 64-bit addresses\n-\n    begin\n-      return Integer (From_A (Left - Right));\n+      return Integer (From_A (Left) - From_A (Right));\n    end \"-\";\n \n    function \"-\" (Left : Address; Right : Integer) return Address is\n@@ -120,7 +119,6 @@ package body System.Aux_DEC is\n       type T_Ptr is access all Target;\n       function To_T_Ptr is new Unchecked_Conversion (Address, T_Ptr);\n       Ptr : constant T_Ptr := To_T_Ptr (A);\n-\n    begin\n       return Ptr.all;\n    end Fetch_From_Address;\n@@ -133,7 +131,6 @@ package body System.Aux_DEC is\n       type T_Ptr is access all Target;\n       function To_T_Ptr is new Unchecked_Conversion (Address, T_Ptr);\n       Ptr : constant T_Ptr := To_T_Ptr (A);\n-\n    begin\n       Ptr.all := T;\n    end Assign_To_Address;"}, {"sha": "70fc2d49645ec337529beaeff535962b149388cf", "filename": "gcc/ada/s-carsi8.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carsi8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carsi8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-carsi8.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Signed_8 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 32;\n    --  Used to process operands by words\n "}, {"sha": "f810dd6a4400827d656201b207d165764dbfef22", "filename": "gcc/ada/s-carsi8.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carsi8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carsi8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-carsi8.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Signed_8 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array\n@@ -57,8 +56,7 @@ package System.Compare_Array_Signed_8 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Same functionality as Compare_Array_U8 but always proceeds by\n    --  bytes. Used when the caller knows that the operands are unaligned,\n    --  or short enough that it makes no sense to go by words."}, {"sha": "4a231098f929e904d56ee85127caea50194e3565", "filename": "gcc/ada/s-carun8.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carun8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carun8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-carun8.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Unsigned_8 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 32;\n    --  Used to process operands by words\n "}, {"sha": "1e3de470fd7dbf69f603c62a79845c2e0b110856", "filename": "gcc/ada/s-carun8.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carun8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-carun8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-carun8.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Unsigned_8 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array\n@@ -57,8 +56,7 @@ package System.Compare_Array_Unsigned_8 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Same functionality as Compare_Array_U8 but always proceeds by\n    --  bytes. Used when the caller knows that the operands are unaligned,\n    --  or short enough that it makes no sense to go by words."}, {"sha": "596b076f81ebba117f8edfdf1b9cb8885702f52a", "filename": "gcc/ada/s-casi16.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi16.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi16.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi16.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Signed_16 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 32;\n    --  Used to process operands by words\n "}, {"sha": "d3c226fb7f05edf038cb6f8bda3a980784691a14", "filename": "gcc/ada/s-casi16.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi16.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi16.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi16.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Signed_16 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array"}, {"sha": "cee5a5703a433960ca84b53490306d8582e6f25a", "filename": "gcc/ada/s-casi32.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi32.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Signed_32 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is range -2**31 .. 2**31 - 1;\n    for Word'Size use 32;\n    --  Used to process operands by words"}, {"sha": "de35addd48a478cce1ebc196caf6ea1344644520", "filename": "gcc/ada/s-casi32.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi32.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "9d141358d4c7a725b1869654afdb262aa421722d", "filename": "gcc/ada/s-casi64.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi64.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Signed_64 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is range -2**63 .. 2**63 - 1;\n    for Word'Size use 64;\n    --  Used to process operands by words"}, {"sha": "0215badacb3606d5a2bbe6fd0a691921b9ca2f46", "filename": "gcc/ada/s-casi64.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-casi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-casi64.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Signed_64 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array"}, {"sha": "779b09709a557fb7099db38bc32c2a1ef0f29cd9", "filename": "gcc/ada/s-caun16.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun16.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun16.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun16.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Unsigned_16 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 32;\n    --  Used to process operands by words\n "}, {"sha": "5bf4e352b63971e1ceca694c93f690d24ccb24c5", "filename": "gcc/ada/s-caun16.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun16.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun16.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun16.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Unsigned_16 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array"}, {"sha": "8672464e229483e1219e2ce01b8d45bf977f72b7", "filename": "gcc/ada/s-caun32.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun32.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Unsigned_32 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 32;\n    for Word'Size use 32;\n    --  Used to process operands by words"}, {"sha": "9c6fb8da66640e8fa48d6530c930a66cb723505f", "filename": "gcc/ada/s-caun32.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun32.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Unsigned_32 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array"}, {"sha": "6e3c5ed56a044bae7a477f3f25e3ed031fc64f24", "filename": "gcc/ada/s-caun64.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun64.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,12 @@ with Unchecked_Conversion;\n \n package body System.Compare_Array_Unsigned_64 is\n \n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+   --  Provide addition operation on type Address (this may not be directly\n+   --  available if type System.Address is non-private and the operations on\n+   --  the type are made abstract to hide them from public users of System.\n+\n    type Word is mod 2 ** 64;\n    --  Used to process operands by words\n "}, {"sha": "c8421902b5d75f7c4e8fe3b8b26bbb6877f92ba1", "filename": "gcc/ada/s-caun64.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-caun64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-caun64.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2002 Free Software Foundation, Inc.            --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,8 +44,7 @@ package System.Compare_Array_Unsigned_64 is\n      (Left      : System.Address;\n       Right     : System.Address;\n       Left_Len  : Natural;\n-      Right_Len : Natural)\n-      return      Integer;\n+      Right_Len : Natural) return Integer;\n    --  Compare the array starting at address Left of length Left_Len\n    --  with the array starting at address Right of length Right_Len.\n    --  The comparison is in the normal Ada semantic sense of array"}, {"sha": "13233d0286c58d2398c398473cf43bfb59af28c4", "filename": "gcc/ada/s-geveop.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-geveop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-geveop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-geveop.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2002-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,6 +36,21 @@ with System.Storage_Elements; use System.Storage_Elements;\n with Ada.Unchecked_Conversion; use Ada;\n \n package body System.Generic_Vector_Operations is\n+\n+   --  Provide arithmetic operations on type Address (these may not be\n+   --  directly available if type System.Address is non-private and the\n+   --  operations on the type are made abstract to hide them from public\n+   --  users of System.\n+\n+   function \"mod\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"mod\");\n+\n+   function \"+\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"+\");\n+\n+   function \"-\" (Left, Right : Address) return Address;\n+   pragma Import (Intrinsic, \"-\");\n+\n    VU : constant Address := Vectors.Vector'Size / Storage_Unit;\n    EU : constant Address := Element_Array'Component_Size / Storage_Unit;\n "}, {"sha": "1174d75e565ad723bfa1692a799993284396ccc2", "filename": "gcc/ada/s-parint.adb", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-parint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-parint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parint.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                   (Dummy body for non-distributed case)                  --\n --                                                                          --\n---          Copyright (C) 1995-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1995-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -162,20 +162,6 @@ package body System.Partition_Interface is\n       null;\n    end Get_Unique_Remote_Pointer;\n \n-   ------------\n-   -- Launch --\n-   ------------\n-\n-   procedure Launch\n-     (Rsh_Command  : in String;\n-      Name_Is_Host : in Boolean;\n-      General_Name : in String;\n-      Command_Line : in String)\n-   is\n-   begin\n-      null;\n-   end Launch;\n-\n    -----------\n    -- Lower --\n    -----------\n@@ -195,17 +181,6 @@ package body System.Partition_Interface is\n       return T;\n    end Lower;\n \n-   ------------------------------------\n-   -- Raise_Program_Error_For_E_4_18 --\n-   ------------------------------------\n-\n-   procedure Raise_Program_Error_For_E_4_18 is\n-   begin\n-      Ada.Exceptions.Raise_Exception\n-        (Program_Error'Identity,\n-        \"Illegal usage of remote access to class-wide type. See RM E.4(18)\");\n-   end Raise_Program_Error_For_E_4_18;\n-\n    -------------------------------------\n    -- Raise_Program_Error_Unknown_Tag --\n    -------------------------------------"}, {"sha": "287b2b3e2fe15b9cee1781cb0ac5c9a0315de8fe", "filename": "gcc/ada/s-parint.ads", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-parint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-parint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parint.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1995-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1995-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -98,23 +98,6 @@ package System.Partition_Interface is\n      (Handler : in out RACW_Stub_Type_Access);\n    --  Get a unique pointer on a remote object\n \n-   procedure Launch\n-     (Rsh_Command  : in String;\n-      Name_Is_Host : in Boolean;\n-      General_Name : in String;\n-      Command_Line : in String);\n-   --  General_Name represents the name of the machine or the name of the\n-   --  partition (depending on the value of Name_Is_Host). Command_Line\n-   --  holds the extra options that will be given on the command line.\n-   --  Rsh_Command is typically \"rsh\", that will be used to launch the\n-   --  other partition.\n-\n-   procedure Raise_Program_Error_For_E_4_18;\n-   pragma No_Return (Raise_Program_Error_For_E_4_18);\n-   --  Raise Program_Error with an error message explaining why it has been\n-   --  raised. The rule in E.4 (18) is tricky and misleading for most users\n-   --  of the distributed systems annex.\n-\n    procedure Raise_Program_Error_Unknown_Tag\n      (E : in Ada.Exceptions.Exception_Occurrence);\n    pragma No_Return (Raise_Program_Error_Unknown_Tag);"}, {"sha": "c2865a95dbfd858bc19eb849aed0be3f8e69cc53", "filename": "gcc/ada/s-stalib.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-stalib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-stalib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stalib.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -97,7 +97,7 @@ package System.Standard_Library is\n    type Exception_Data_Ptr is access all Exception_Data;\n    --  An equivalent of Exception_Id that is public\n \n-   type Exception_Code is mod 2 ** 32;\n+   type Exception_Code is mod 2 ** Integer'Size;\n    --  A scalar value bound to some exception data. Typically used for\n    --  imported or exported exceptions on VMS. Having a separate type for this\n    --  is useful to enforce consistency throughout the various run-time units"}, {"sha": "1799a7e54760078417dc33895c17f1c4c5fc5209", "filename": "gcc/ada/s-stoele.ads", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-stoele.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fs-stoele.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stoele.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -51,12 +51,8 @@ pragma Pure (Storage_Elements);\n --  and it would be unsafe to treat such functions as pure.\n \n    type Storage_Offset is range\n-     -(2 ** (Standard.\"-\" (Standard'Address_Size, 1))) ..\n-     +(2 ** (Standard.\"-\" (Standard'Address_Size, 1))) - 1;\n-\n-   --  Note: the reason for the qualification of \"-\" here by Standard is\n-   --  that we have a current bug in GNAT that otherwise causes a bogus\n-   --  ambiguity when this unit is analyzed in an Rtsfind context.\n+     -(2 ** (Integer'(Standard'Address_Size) - 1)) ..\n+     +(2 ** (Integer'(Standard'Address_Size) - 1)) - Long_Long_Integer'(1);\n \n    subtype Storage_Count is Storage_Offset range 0 .. Storage_Offset'Last;\n "}, {"sha": "cf6cfac2d2e0199d17b63a1ca955c67a0f0c98f4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 178, "deletions": 23, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -677,6 +677,16 @@ package body Sem_Ch3 is\n          Error_Msg_N (\"task entries cannot have access parameters\", N);\n       end if;\n \n+      --  Ada 0Y (AI-254): In case of anonymous access to subprograms\n+      --  call the corresponding semantic routine\n+\n+      if Present (Access_To_Subprogram_Definition (N)) then\n+         Access_Subprogram_Declaration\n+           (T_Name => Anon_Type,\n+            T_Def  => Access_To_Subprogram_Definition (N));\n+         return Anon_Type;\n+      end if;\n+\n       Find_Type (Subtype_Mark (N));\n       Desig_Type := Entity (Subtype_Mark (N));\n \n@@ -818,6 +828,37 @@ package body Sem_Ch3 is\n \n       Set_Can_Never_Be_Null (T_Name, Null_Exclusion_Present (T_Def));\n \n+      --  -------------------------------------------------------------------\n+      --  I assume that the following statements should also be here.\n+      --  Need some tests to check it. Detected by comparison with the\n+      --  access_definition subprogram???\n+      --  -------------------------------------------------------------------\n+\n+      --  The anonymous access type is as public as the discriminated type or\n+      --  subprogram that defines it. It is imported (for back-end purposes)\n+      --  if the designated type is.\n+\n+--      Set_Is_Public (T_Name, Is_Public (Scope (T_Name)));\n+\n+      --  Ada 0Y (AI-50217): Propagate the attribute that indicates that the\n+      --  designated type comes from the limited view (for back-end purposes).\n+\n+--      Set_From_With_Type (T_Name, From_With_Type (Desig_Type));\n+\n+      --  The context is either a subprogram declaration or an access\n+      --  discriminant, in a private or a full type declaration. In\n+      --  the case of a subprogram, If the designated type is incomplete,\n+      --  the operation will be a primitive operation of the full type, to\n+      --  be updated subsequently.\n+\n+--        if Ekind (Desig_Type) = E_Incomplete_Type\n+--          and then Is_Overloadable (Current_Scope)\n+--        then\n+--           Append_Elmt (Current_Scope, Private_Dependents (Desig_Type));\n+--           Set_Has_Delayed_Freeze (Current_Scope);\n+--        end if;\n+      --  ---------------------------------------------------------------\n+\n       Check_Restriction (No_Access_Subprograms, T_Def);\n    end Access_Subprogram_Declaration;\n \n@@ -943,6 +984,17 @@ package body Sem_Ch3 is\n                 (Related_Nod => N,\n                  N => Access_Definition (Component_Definition (N)));\n \n+         --  Ada 0Y (AI-254)\n+\n+         if Present (Access_To_Subprogram_Definition\n+                      (Access_Definition (Component_Definition (N))))\n+           and then Protected_Present (Access_To_Subprogram_Definition\n+                                        (Access_Definition\n+                                          (Component_Definition (N))))\n+         then\n+            T := Replace_Anonymous_Access_To_Protected_Subprogram (N);\n+         end if;\n+\n       else\n          pragma Assert (False);\n          null;\n@@ -2932,6 +2984,17 @@ package body Sem_Ch3 is\n                            (Related_Nod => Related_Id,\n                             N           => Access_Definition (Component_Def));\n \n+         --  Ada 0Y (AI-254)\n+\n+         if Present (Access_To_Subprogram_Definition\n+                     (Access_Definition (Component_Def)))\n+           and then Protected_Present (Access_To_Subprogram_Definition\n+                                       (Access_Definition (Component_Def)))\n+         then\n+            Element_Type :=\n+              Replace_Anonymous_Access_To_Protected_Subprogram (Def);\n+         end if;\n+\n       else\n          pragma Assert (False);\n          null;\n@@ -3074,6 +3137,93 @@ package body Sem_Ch3 is\n \n    end Array_Type_Declaration;\n \n+   ------------------------------------------------------\n+   -- Replace_Anonymous_Access_To_Protected_Subprogram --\n+   ------------------------------------------------------\n+\n+   function Replace_Anonymous_Access_To_Protected_Subprogram\n+     (N : Node_Id) return Entity_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Curr_Scope : constant Scope_Stack_Entry :=\n+                     Scope_Stack.Table (Scope_Stack.Last);\n+\n+      Anon : constant Entity_Id :=\n+               Make_Defining_Identifier (Loc,\n+                 Chars => New_Internal_Name ('S'));\n+\n+      Acc  : Node_Id;\n+      Comp : Node_Id;\n+      Decl : Node_Id;\n+      P    : Node_Id := Parent (N);\n+\n+   begin\n+      Set_Is_Internal (Anon);\n+\n+      case Nkind (N) is\n+         when N_Component_Declaration       |\n+           N_Unconstrained_Array_Definition |\n+           N_Constrained_Array_Definition   =>\n+            Comp := Component_Definition (N);\n+            Acc  := Access_Definition (Component_Definition (N));\n+\n+         when N_Discriminant_Specification =>\n+            Comp := Discriminant_Type (N);\n+            Acc  := Discriminant_Type (N);\n+\n+         when N_Parameter_Specification =>\n+            Comp := Parameter_Type (N);\n+            Acc  := Parameter_Type (N);\n+\n+         when others =>\n+            null;\n+            pragma Assert (False);\n+      end case;\n+\n+      Decl := Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Anon,\n+                Type_Definition   =>\n+                  Access_To_Subprogram_Definition (Acc));\n+\n+      Mark_Rewrite_Insertion (Decl);\n+\n+      --  Insert the new declaration in the nearest enclosing scope\n+\n+      while not Has_Declarations (P) loop\n+         P := Parent (P);\n+      end loop;\n+\n+      Prepend (Decl, Declarations (P));\n+\n+      --  Replace the anonymous type with an occurrence of the new declaration.\n+      --  In all cases the rewriten node does not have the null-exclusion\n+      --  attribute because (if present) it was already inherited by the\n+      --  anonymous entity (Anon). Thus, in case of components we do not\n+      --  inherit this attribute.\n+\n+      if Nkind (N) = N_Parameter_Specification then\n+         Rewrite (Comp, New_Occurrence_Of (Anon, Loc));\n+         Set_Etype (Defining_Identifier (N), Anon);\n+         Set_Null_Exclusion_Present (N, False);\n+      else\n+         Rewrite (Comp,\n+           Make_Component_Definition (Loc,\n+             Subtype_Indication => New_Occurrence_Of (Anon, Loc)));\n+      end if;\n+\n+      Mark_Rewrite_Insertion (Comp);\n+\n+      --  Temporarily remove the current scope from the stack to add the new\n+      --  declarations to the enclosing scope\n+\n+      Scope_Stack.Decrement_Last;\n+      Analyze (Decl);\n+      Scope_Stack.Append (Curr_Scope);\n+\n+      return Anon;\n+   end Replace_Anonymous_Access_To_Protected_Subprogram;\n+\n    -------------------------------\n    -- Build_Derived_Access_Type --\n    -------------------------------\n@@ -3425,6 +3575,7 @@ package body Sem_Ch3 is\n       else\n          Set_First_Entity (Derived_Type, First_Entity (Parent_Type));\n          if Has_Discriminants (Parent_Type) then\n+            Set_Is_Constrained (Derived_Type, Is_Constrained (Parent_Type));\n             Set_Discriminant_Constraint (\n               Derived_Type, Discriminant_Constraint (Parent_Type));\n          end if;\n@@ -3917,10 +4068,12 @@ package body Sem_Ch3 is\n \n                --  Copy declaration for subsequent analysis, to\n                --  provide a completion for what is a private\n-               --  declaration.\n+               --  declaration. Indicate that the full type is\n+               --  internally generated.\n \n                Full_Decl := New_Copy_Tree (N);\n                Full_Der  := New_Copy (Derived_Type);\n+               Set_Comes_From_Source (Full_Decl, False);\n \n                Insert_After (N, Full_Decl);\n \n@@ -7916,10 +8069,9 @@ package body Sem_Ch3 is\n       Suffix       : Character;\n       Suffix_Index : Nat)\n    is\n-      Def_Id     : Entity_Id;\n-      R          : Node_Id := Empty;\n-      Checks_Off : Boolean := False;\n-      T          : constant Entity_Id := Etype (Index);\n+      Def_Id : Entity_Id;\n+      R      : Node_Id := Empty;\n+      T      : constant Entity_Id := Etype (Index);\n \n    begin\n       if Nkind (S) = N_Range\n@@ -7933,21 +8085,7 @@ package body Sem_Ch3 is\n          Set_Etype (S, T);\n          R := S;\n \n-         --  ??? Why on earth do we turn checks of in this very specific case ?\n-\n-         --  From the revision history: (Constrain_Index): Call\n-         --  Process_Range_Expr_In_Decl with range checking off for range\n-         --  bounds that are attributes. This avoids some horrible\n-         --  constraint error checks.\n-\n-         if Nkind (R) = N_Range\n-           and then Nkind (Low_Bound (R)) = N_Attribute_Reference\n-           and then Nkind (High_Bound (R)) = N_Attribute_Reference\n-         then\n-            Checks_Off := True;\n-         end if;\n-\n-         Process_Range_Expr_In_Decl (R, T, Empty_List, Checks_Off);\n+         Process_Range_Expr_In_Decl (R, T, Empty_List);\n \n          if not Error_Posted (S)\n            and then\n@@ -9274,7 +9412,7 @@ package body Sem_Ch3 is\n       elsif Is_Unchecked_Union (Parent_Type) then\n          Error_Msg_N (\"cannot derive from Unchecked_Union type\", N);\n \n-      --  Ada 0Y (AI-231)\n+      --  Ada 0Y (AI-231): Static check\n \n       elsif Is_Access_Type (Parent_Type)\n         and then Null_Exclusion_Present (Type_Definition (N))\n@@ -11467,6 +11605,17 @@ package body Sem_Ch3 is\n          if Nkind (Discriminant_Type (Discr)) = N_Access_Definition then\n             Discr_Type := Access_Definition (N, Discriminant_Type (Discr));\n \n+            --  Ada 0Y (AI-254)\n+\n+            if Present (Access_To_Subprogram_Definition\n+                         (Discriminant_Type (Discr)))\n+              and then Protected_Present (Access_To_Subprogram_Definition\n+                                           (Discriminant_Type (Discr)))\n+            then\n+               Discr_Type :=\n+                 Replace_Anonymous_Access_To_Protected_Subprogram (Discr);\n+            end if;\n+\n          else\n             Find_Type (Discriminant_Type (Discr));\n             Discr_Type := Etype (Discriminant_Type (Discr));\n@@ -11514,7 +11663,13 @@ package body Sem_Ch3 is\n                  (\"discriminant defaults not allowed for formal type\",\n                   Expression (Discr));\n \n-            elsif Is_Tagged_Type (Current_Scope) then\n+            --  Tagged types cannot have defaulted discriminants, but a\n+            --  non-tagged private type with defaulted discriminants\n+            --   can have a tagged completion.\n+\n+            elsif Is_Tagged_Type (Current_Scope)\n+              and then Comes_From_Source (N)\n+            then\n                Error_Msg_N\n                  (\"discriminants of tagged type cannot have defaults\",\n                   Expression (Discr));\n@@ -12310,7 +12465,7 @@ package body Sem_Ch3 is\n          Find_Type (S);\n          Check_Incomplete (S);\n \n-         --  Ada 0Y (AI-231)\n+         --  Ada 0Y (AI-231): Static check\n \n          if Extensions_Allowed\n            and then Present (Parent (S))"}, {"sha": "fb233a2d553e1e1c1d2ab01ab5a616bb930442e6", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -206,6 +206,13 @@ package Sem_Ch3  is\n    --  N_Incomplete_Type_Decl node N. If the declaration is a completion,\n    --  Prev is entity on the partial view, on which references are posted.\n \n+   function Replace_Anonymous_Access_To_Protected_Subprogram\n+     (N : Node_Id) return Entity_Id;\n+   --  Ada 0Y (AI-254): Create and decorate an internal full type declaration\n+   --  in the enclosing scope corresponding to an anonymous access to protected\n+   --  subprogram. In addition, replace the anonymous access by an occurrence\n+   --  of this internal type. Return the entity of this type declaration.\n+\n    procedure Set_Completion_Referenced (E : Entity_Id);\n    --  If E is the completion of a private or incomplete  type declaration,\n    --  or the completion of a deferred constant declaration, mark the entity"}, {"sha": "cce3e09c7c859f5c51469af03228058445d67dba", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -2095,8 +2095,22 @@ package body Sem_Ch4 is\n                         then\n                            Error_Msg_NE\n                              (\"  =='> in call to &#(inherited)!\", Actual, Nam);\n+\n+                        elsif Ekind (Nam) = E_Subprogram_Type then\n+                           declare\n+                              Access_To_Subprogram_Typ :\n+                                constant Entity_Id :=\n+                                  Defining_Identifier\n+                                    (Associated_Node_For_Itype (Nam));\n+                           begin\n+                              Error_Msg_NE (\n+                                \"  =='> in call to dereference of &#!\",\n+                                Actual, Access_To_Subprogram_Typ);\n+                           end;\n+\n                         else\n                            Error_Msg_NE (\"  =='> in call to &#!\", Actual, Nam);\n+\n                         end if;\n                      end if;\n                   end if;"}, {"sha": "4fe8cdbcea7b1e09e21bbb252e4b7786f79a73eb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 84, "deletions": 70, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -4881,15 +4881,94 @@ package body Sem_Ch6 is\n                  Parameter_Type (Param_Spec), Formal_Type);\n             end if;\n \n+            --  Ada 0Y (AI-231): Create and decorate an internal subtype\n+            --  declaration corresponding to the null-excluding type of the\n+            --  formal in the enclosing scope. In addition, replace the\n+            --  parameter type of the formal to this internal subtype.\n+\n+            if Null_Exclusion_Present (Param_Spec) then\n+               declare\n+                  Loc   : constant Source_Ptr := Sloc (Param_Spec);\n+\n+                  Anon  : constant Entity_Id :=\n+                            Make_Defining_Identifier (Loc,\n+                              Chars => New_Internal_Name ('S'));\n+\n+                  Curr_Scope : constant Scope_Stack_Entry :=\n+                                 Scope_Stack.Table (Scope_Stack.Last);\n+\n+                  Ptype : constant Node_Id := Parameter_Type (Param_Spec);\n+                  Decl  : Node_Id;\n+                  P     : Node_Id := Parent (Parent (Related_Nod));\n+\n+               begin\n+                  Set_Is_Internal (Anon);\n+\n+                  Decl :=\n+                    Make_Subtype_Declaration (Loc,\n+                      Defining_Identifier      => Anon,\n+                        Null_Exclusion_Present => True,\n+                        Subtype_Indication     =>\n+                          New_Occurrence_Of (Etype (Ptype), Loc));\n+\n+                  --  Propagate the null-excluding attribute to the new entity\n+\n+                  if Null_Exclusion_Present (Param_Spec) then\n+                     Set_Null_Exclusion_Present (Param_Spec, False);\n+                     Set_Can_Never_Be_Null (Anon);\n+                  end if;\n+\n+                  Mark_Rewrite_Insertion (Decl);\n+\n+                  --  Insert the new declaration in the nearest enclosing scope\n+\n+                  while not Has_Declarations (P) loop\n+                     P := Parent (P);\n+                  end loop;\n+\n+                  Prepend (Decl, Declarations (P));\n+\n+                  Rewrite (Ptype, New_Occurrence_Of (Anon, Loc));\n+                  Mark_Rewrite_Insertion (Ptype);\n+\n+                  --  Analyze the new declaration in the context of the\n+                  --  enclosing scope\n+\n+                  Scope_Stack.Decrement_Last;\n+                  Analyze (Decl);\n+                  Scope_Stack.Append (Curr_Scope);\n+\n+                  Formal_Type := Anon;\n+               end;\n+            end if;\n+\n+            --  Ada 0Y (AI-231): Static checks\n+\n+            if Null_Exclusion_Present (Param_Spec)\n+              or else Can_Never_Be_Null (Entity (Ptype))\n+            then\n+               Null_Exclusion_Static_Checks (Param_Spec);\n+            end if;\n+\n          --  An access formal type\n \n          else\n             Formal_Type :=\n               Access_Definition (Related_Nod, Parameter_Type (Param_Spec));\n+\n+            --  Ada 0Y (AI-254)\n+\n+            if Present (Access_To_Subprogram_Definition\n+                         (Parameter_Type (Param_Spec)))\n+              and then Protected_Present (Access_To_Subprogram_Definition\n+                                           (Parameter_Type (Param_Spec)))\n+            then\n+               Formal_Type :=\n+                 Replace_Anonymous_Access_To_Protected_Subprogram (Param_Spec);\n+            end if;\n          end if;\n \n          Set_Etype (Formal, Formal_Type);\n-\n          Default := Expression (Param_Spec);\n \n          if Present (Default) then\n@@ -4948,19 +5027,6 @@ package body Sem_Ch6 is\n \n                   Apply_Scalar_Range_Check (Default, Formal_Type);\n                end if;\n-\n-            end if;\n-\n-            --  Ada 0Y (AI-231): Static checks\n-\n-            Ptype := Parameter_Type (Param_Spec);\n-\n-            if Extensions_Allowed\n-              and then Nkind (Ptype) /= N_Access_Definition\n-              and then (Null_Exclusion_Present (Parent (Formal))\n-                        or else Can_Never_Be_Null (Entity (Ptype)))\n-            then\n-               Null_Exclusion_Static_Checks (Param_Spec);\n             end if;\n          end if;\n \n@@ -5010,7 +5076,6 @@ package body Sem_Ch6 is\n       T              : Entity_Id;\n       First_Stmt     : Node_Id := Empty;\n       AS_Needed      : Boolean;\n-      Null_Exclusion : Boolean := False;\n \n    begin\n       --  If this is an emtpy initialization procedure, no need to create\n@@ -5065,17 +5130,6 @@ package body Sem_Ch6 is\n          then\n             AS_Needed := True;\n \n-         --  Ada 0Y (AI-231)\n-\n-         elsif Extensions_Allowed\n-           and then Is_Access_Type (T)\n-           and then Null_Exclusion_Present (Parent (Formal))\n-           and then Nkind (Parameter_Type (Parent (Formal)))\n-                    /= N_Access_Definition\n-         then\n-            AS_Needed      := True;\n-            Null_Exclusion := True;\n-\n          --  All other cases do not need an actual subtype\n \n          else\n@@ -5086,40 +5140,7 @@ package body Sem_Ch6 is\n          --  unconstrained discriminated records.\n \n          if AS_Needed then\n-\n-            --  Ada 0Y (AI-231): Generate actual null-excluding subtype\n-\n-            if Extensions_Allowed\n-              and then Null_Exclusion\n-            then\n-               declare\n-                  Loc      : constant Source_Ptr := Sloc (Formal);\n-                  Anon     : constant Entity_Id :=\n-                               Make_Defining_Identifier (Loc,\n-                                 New_Internal_Name ('S'));\n-                  Ptype    : constant Node_Id\n-                               := Parameter_Type (Parent (Formal));\n-               begin\n-                  --  T == Etype (Formal)\n-                  Set_Is_Internal (Anon);\n-                  Decl :=\n-                    Make_Subtype_Declaration (Loc,\n-                      Defining_Identifier      => Anon,\n-                        Null_Exclusion_Present => True,\n-                        Subtype_Indication     =>\n-                          New_Occurrence_Of (Etype (Ptype), Loc));\n-                  Mark_Rewrite_Insertion (Decl);\n-                  Prepend (Decl, Declarations (Parent (N)));\n-\n-                  Rewrite (Ptype, New_Occurrence_Of (Anon, Loc));\n-                  Mark_Rewrite_Insertion (Ptype);\n-                  --   Set_Scope (Anon, Scope (Scope (Formal)));\n-\n-                  Set_Etype (Formal, Anon);\n-                  Set_Null_Exclusion_Present (Parent (Formal), False);\n-               end;\n-\n-            elsif Nkind (N) = N_Accept_Statement then\n+            if Nkind (N) = N_Accept_Statement then\n \n                --  If expansion is active, The formal is replaced by a local\n                --  variable that renames the corresponding entry of the\n@@ -5151,17 +5172,10 @@ package body Sem_Ch6 is\n                Mark_Rewrite_Insertion (Decl);\n             end if;\n \n-            Analyze (Decl);\n-\n-            --  Ada 0Y (AI-231): Previous analysis leaves the entity of the\n-            --  null-excluding subtype declaration associated with the internal\n-            --  scope; because this declaration has been inserted before the\n-            --  subprogram we associate it now with the enclosing scope.\n+            --  The declaration uses the bounds of an existing object,\n+            --  and therefore needs no constraint checks.\n \n-            if Null_Exclusion then\n-               Set_Scope (Defining_Identifier (Decl),\n-                          Scope (Scope (Formal)));\n-            end if;\n+            Analyze (Decl, Suppress => All_Checks);\n \n             --  We need to freeze manually the generated type when it is\n             --  inserted anywhere else than in a declarative part."}, {"sha": "379c74ce7ef02936df79068a3186ab5aae216ecf", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -683,10 +683,16 @@ package body Sem_Ch8 is\n          T := Entity (Subtype_Mark (N));\n          Analyze_And_Resolve (Nam, T);\n \n-      --  Ada 0Y (AI-230): Access renaming\n+      --  Ada 0Y (AI-230/AI-254): Access renaming\n \n       elsif Present (Access_Definition (N)) then\n-         Find_Type (Subtype_Mark (Access_Definition (N)));\n+\n+         if Null_Exclusion_Present (Access_Definition (N)) then\n+            Error_Msg_N (\"(Ada 0Y): null-excluding attribute ignored \"\n+                         & \"('R'M 8.5.1(6))?\", N);\n+            Set_Null_Exclusion_Present (Access_Definition (N), False);\n+         end if;\n+\n          T := Access_Definition\n                 (Related_Nod => N,\n                  N           => Access_Definition (N));"}, {"sha": "62db6fd257b0001711c87dd172ad2c68cab27f98", "filename": "gcc/ada/sem_dist.adb", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -151,47 +151,6 @@ package body Sem_Dist is\n       return End_String;\n    end Full_Qualified_Name;\n \n-   -----------------------\n-   -- Get_Subprogram_Id --\n-   -----------------------\n-\n-   function Get_Subprogram_Id (E : Entity_Id) return Int is\n-      Current_Declaration : Node_Id;\n-      Result              : Int := 0;\n-\n-   begin\n-      pragma Assert\n-        (Is_Remote_Call_Interface (Scope (E))\n-           and then\n-             (Nkind (Parent (E)) = N_Procedure_Specification\n-                or else\n-              Nkind (Parent (E)) = N_Function_Specification));\n-\n-      Current_Declaration :=\n-        First (Visible_Declarations\n-          (Package_Specification_Of_Scope (Scope (E))));\n-\n-      while Current_Declaration /= Empty loop\n-         if Nkind (Current_Declaration) = N_Subprogram_Declaration\n-           and then Comes_From_Source (Current_Declaration)\n-         then\n-            if Defining_Unit_Name\n-                 (Specification (Current_Declaration)) = E\n-            then\n-               return Result;\n-            end if;\n-\n-            Result := Result + 1;\n-         end if;\n-\n-         Next (Current_Declaration);\n-      end loop;\n-\n-      --  Error if we do not find it\n-\n-      raise Program_Error;\n-   end Get_Subprogram_Id;\n-\n    ------------------------\n    -- Is_All_Remote_Call --\n    ------------------------\n@@ -334,7 +293,6 @@ package body Sem_Dist is\n       RS_Pkg_E              : Entity_Id;\n       RAS_Type              : Entity_Id;\n       Async_E               : Entity_Id;\n-      Subp_Id               : Int;\n       Attribute_Subp        : Entity_Id;\n       Parameter             : Node_Id;\n \n@@ -373,8 +331,6 @@ package body Sem_Dist is\n       RS_Pkg_Specif := Parent (Remote_Subp_Decl);\n       RS_Pkg_E := Defining_Entity (RS_Pkg_Specif);\n \n-      Subp_Id := Get_Subprogram_Id (Remote_Subp);\n-\n       if Ekind (Remote_Subp) = E_Procedure\n         and then Is_Asynchronous (Remote_Subp)\n       then\n@@ -392,7 +348,7 @@ package body Sem_Dist is\n             New_List (\n               Parameter,\n               Make_String_Literal (Loc, Full_Qualified_Name (RS_Pkg_E)),\n-              Make_Integer_Literal (Loc, Subp_Id),\n+              Build_Subprogram_Id (Loc, Remote_Subp),\n               New_Occurrence_Of (Async_E, Loc)));\n \n       Rewrite (N, Tick_Access_Conv_Call);"}, {"sha": "efadbef664475a759d4b0d06d68ef728c72d9927", "filename": "gcc/ada/sem_dist.ads", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dist.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -83,10 +83,6 @@ package Sem_Dist is\n    --  aggregate and will return True in this case. Otherwise, it will\n    --  return False.\n \n-   function Get_Subprogram_Id (E : Entity_Id) return Int;\n-   --  Given a subprogram defined in a RCI package, get its subprogram id\n-   --  which will be used for remote calls.\n-\n    function Package_Specification_Of_Scope (E : Entity_Id) return Node_Id;\n    --  Return the N_Package_Specification corresponding to a scope E\n "}, {"sha": "31175493ee74de4e820cf53f1181d5a81408ea26", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 219, "deletions": 30, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -29,12 +29,12 @@ with Einfo;   use Einfo;\n with Errout;  use Errout;\n with Namet;   use Namet;\n with Nlists;  use Nlists;\n+with Sinput;  use Sinput;\n with Sinfo;   use Sinfo;\n with Snames;  use Snames;\n with Stand;   use Stand;\n with Stringt; use Stringt;\n with Table;\n-with Uintp;   use Uintp;\n \n with GNAT.HTable; use GNAT.HTable;\n package body Sem_Elim is\n@@ -83,8 +83,9 @@ package body Sem_Elim is\n       Result_Type : Name_Id;\n       --  Result type name if Result_Types parameter present, No_Name if not\n \n-      Homonym_Number : Uint;\n-      --  Homonyn number if Homonym_Number parameter present, No_Uint if not.\n+      Source_Location : Name_Id;\n+      --  String describing the source location of subprogram defining name if\n+      --  Source_Location parameter present, No_Name if not\n \n       Hash_Link : Access_Elim_Data;\n       --  Link for hash table use\n@@ -229,8 +230,6 @@ package body Sem_Elim is\n       Elmt : Access_Elim_Data;\n       Scop : Entity_Id;\n       Form : Entity_Id;\n-      Ctr  : Nat;\n-      Ent  : Entity_Id;\n \n       function Original_Chars (S : Entity_Id) return Name_Id;\n       --  If the candidate subprogram is a protected operation of a single\n@@ -360,22 +359,200 @@ package body Sem_Elim is\n             elsif Ekind (E) = E_Function\n               or else Ekind (E) = E_Procedure\n             then\n-               --  If Homonym_Number present, then see if it matches\n+               --  If Source_Location present, then see if it matches\n+\n+               if Elmt.Source_Location /= No_Name then\n+                  Get_Name_String (Elmt.Source_Location);\n+\n+                  declare\n+                     Sloc_Trace : constant String :=\n+                       Name_Buffer (1 .. Name_Len);\n+\n+                     Idx : Natural := Sloc_Trace'First;\n+                     --  Index in Sloc_Trace, if equals to 0, then we have\n+                     --  completely traversed Sloc_Trace\n+\n+                     Last : constant Natural := Sloc_Trace'Last;\n+\n+                     P      : Source_Ptr;\n+                     Sindex : Source_File_Index;\n+\n+                     function File_Mame_Match return Boolean;\n+                     --  This function is supposed to be called when Idx points\n+                     --  to the beginning of the new file name, and Name_Buffer\n+                     --  is set to contain the name of the proper source file\n+                     --  from the chain corresponding to the Sloc of E. First\n+                     --  it checks that these two files have the same name. If\n+                     --  this check is successful, moves Idx to point to the\n+                     --  beginning of the column number.\n+\n+                     function Line_Num_Match return Boolean;\n+                     --  This function is supposed to be called when Idx points\n+                     --  to the beginning of the column number, and P is\n+                     --  set to point to the proper Sloc the chain\n+                     --  corresponding to the Sloc of E. First it checks that\n+                     --  the line number Idx points on and the line number\n+                     --  corresponding to P are the same. If this check is\n+                     --  successful, moves Idx to point to the beginning of\n+                     --  the next file name in Sloc_Trace. If there is no file\n+                     --  name any more, Idx is set to 0.\n+\n+                     function Different_Trace_Lengths return Boolean;\n+                     --  From Idx and P, defines if there are in both traces\n+                     --  more element(s) in the instantiation chains. Returns\n+                     --  False if one trace contains more element(s), but\n+                     --  another does not. If both traces contains more\n+                     --  elements (that is, the function returns False), moves\n+                     --  P ahead in the chain corresponding to E, recomputes\n+                     --  Sindex and sets the name of the corresponding file in\n+                     --  Name_Buffer\n+\n+                     function Skip_Spaces return Natural;\n+                     --  If Sloc_Trace (Idx) is not space character, returns\n+                     --  Idx. Otherwise returns the index of the nearest\n+                     --  non-space character in Sloc_Trace to the right of\n+                     --  Idx. Returns 0 if there is no such character.\n+\n+                     function Different_Trace_Lengths return Boolean is\n+                     begin\n+                        P := Instantiation (Sindex);\n+\n+                        if (P = No_Location and then Idx /= 0)\n+                          or else\n+                           (P /= No_Location and then Idx = 0)\n+                        then\n+                           return True;\n+                        else\n \n-               if Elmt.Homonym_Number /= No_Uint then\n-                  Ctr := 1;\n+                           if P /= No_Location then\n+                              Sindex := Get_Source_File_Index (P);\n+                              Get_Name_String (File_Name (Sindex));\n+                           end if;\n \n-                  Ent := E;\n-                  while Present (Homonym (Ent))\n-                    and then Scope (Ent) = Scope (Homonym (Ent))\n-                  loop\n-                     Ctr := Ctr + 1;\n-                     Ent := Homonym (Ent);\n-                  end loop;\n+                           return False;\n+                        end if;\n+                     end Different_Trace_Lengths;\n \n-                  if Ctr /= Elmt.Homonym_Number then\n-                     goto Continue;\n-                  end if;\n+                     function File_Mame_Match return Boolean is\n+                        Tmp_Idx : Positive;\n+                        End_Idx : Positive;\n+                     begin\n+\n+                        if Idx = 0 then\n+                           return False;\n+                        end if;\n+\n+                        for J in Idx .. Last loop\n+                           if Sloc_Trace (J) = ':' then\n+                              Tmp_Idx := J - 1;\n+                              exit;\n+                           end if;\n+                        end loop;\n+\n+                        for J in reverse Idx .. Tmp_Idx loop\n+                           if Sloc_Trace (J) /= ' ' then\n+                              End_Idx := J;\n+                              exit;\n+                           end if;\n+                        end loop;\n+\n+                        if Sloc_Trace (Idx .. End_Idx) =\n+                           Name_Buffer (1 .. Name_Len)\n+                        then\n+                           Idx := Tmp_Idx + 2;\n+\n+                           Idx := Skip_Spaces;\n+\n+                           return True;\n+                        else\n+                           return False;\n+                        end if;\n+\n+                     end File_Mame_Match;\n+\n+                     function Line_Num_Match return Boolean is\n+                        N : Int := 0;\n+                     begin\n+\n+                        if Idx = 0 then\n+                           return False;\n+                        end if;\n+\n+                        while Idx <= Last\n+                           and then\n+                              Sloc_Trace (Idx) in '0' .. '9'\n+                        loop\n+                           N := N * 10 +\n+                            (Character'Pos (Sloc_Trace (Idx)) -\n+                             Character'Pos ('0'));\n+\n+                           Idx := Idx + 1;\n+                        end loop;\n+\n+                        if Get_Physical_Line_Number (P) =\n+                           Physical_Line_Number (N)\n+                        then\n+\n+                           while Sloc_Trace (Idx) /= '['\n+                               and then\n+                                 Idx <= Last\n+                           loop\n+                              Idx := Idx + 1;\n+                           end loop;\n+\n+                           if Sloc_Trace (Idx) = '['\n+                             and then\n+                               Idx < Last\n+                           then\n+                              Idx := Idx + 1;\n+                              Idx := Skip_Spaces;\n+                           else\n+                              Idx := 0;\n+                           end if;\n+\n+                           return True;\n+                        else\n+                           return False;\n+                        end if;\n+\n+                     end Line_Num_Match;\n+\n+                     function Skip_Spaces return Natural is\n+                        Res : Natural := Idx;\n+                     begin\n+\n+                        while Sloc_Trace (Res) = ' ' loop\n+                           Res := Res + 1;\n+\n+                           if Res > Last then\n+                              Res := 0;\n+                              exit;\n+                           end if;\n+                        end loop;\n+\n+                        return Res;\n+                     end Skip_Spaces;\n+\n+                  begin\n+                     P      := Sloc (E);\n+                     Sindex := Get_Source_File_Index (P);\n+                     Get_Name_String (File_Name (Sindex));\n+\n+                     Idx := Skip_Spaces;\n+\n+                     while Idx > 0 loop\n+\n+                        if not File_Mame_Match then\n+                           goto Continue;\n+                        elsif not Line_Num_Match then\n+                           goto Continue;\n+                        end if;\n+\n+                        if Different_Trace_Lengths then\n+                           goto Continue;\n+                        end if;\n+                     end loop;\n+                  end;\n                end if;\n \n                --  If we have a Result_Type, then we must have a function\n@@ -394,7 +571,14 @@ package body Sem_Elim is\n                if Elmt.Parameter_Types /= null then\n                   Form := First_Formal (E);\n \n-                  if No (Form) and then Elmt.Parameter_Types = null then\n+                  if No (Form)\n+                   and then\n+                    Elmt.Parameter_Types'Length = 1\n+                   and then\n+                    Elmt.Parameter_Types (1) = No_Name\n+                  then\n+                     --  Parameterless procedure matches\n+\n                      null;\n \n                   elsif Elmt.Parameter_Types = null then\n@@ -471,7 +655,7 @@ package body Sem_Elim is\n       Arg_Entity          : Node_Id;\n       Arg_Parameter_Types : Node_Id;\n       Arg_Result_Type     : Node_Id;\n-      Arg_Homonym_Number  : Node_Id)\n+      Arg_Source_Location : Node_Id)\n    is\n       Data : constant Access_Elim_Data := new Elim_Data;\n       --  Build result data here\n@@ -593,7 +777,13 @@ package body Sem_Elim is\n            and then Paren_Count (Arg_Parameter_Types) = 1\n          then\n             String_To_Name_Buffer (Strval (Arg_Parameter_Types));\n-            Data.Parameter_Types := new Names'(1 => Name_Find);\n+\n+            if Name_Len = 0 then\n+               --  Parameterless procedure\n+               Data.Parameter_Types := new Names'(1 => No_Name);\n+            else\n+               Data.Parameter_Types := new Names'(1 => Name_Find);\n+            end if;\n \n          --  Otherwise must be an aggregate\n \n@@ -647,25 +837,24 @@ package body Sem_Elim is\n          Data.Result_Type := No_Name;\n       end if;\n \n-      --  Process Homonym_Number argument\n+      --  Process Source_Location argument\n \n-      if Present (Arg_Homonym_Number) then\n+      if Present (Arg_Source_Location) then\n \n-         if Nkind (Arg_Homonym_Number) /= N_Integer_Literal then\n+         if Nkind (Arg_Source_Location) /= N_String_Literal then\n             Error_Msg_N\n-              (\"Homonym_Number argument for pragma% must be integer literal\",\n-               Arg_Homonym_Number);\n+              (\"Source_Location argument for pragma% must be string literal\",\n+               Arg_Source_Location);\n             return;\n          end if;\n \n-         Data.Homonym_Number := Intval (Arg_Homonym_Number);\n+         String_To_Name_Buffer (Strval (Arg_Source_Location));\n+         Data.Source_Location := Name_Find;\n \n       else\n-         Data.Homonym_Number := No_Uint;\n+         Data.Source_Location := No_Name;\n       end if;\n \n-      --  Now link this new entry into the hash table\n-\n       Elmt := Elim_Hash_Table.Get (Hash_Subprograms.Get_Key (Data));\n \n       --  If we already have an entry with this same key, then link"}, {"sha": "4e9911f8850293b4f265de81b9937e56e422d0c3", "filename": "gcc/ada/sem_elim.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_elim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_elim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@ package Sem_Elim is\n       Arg_Entity          : Node_Id;\n       Arg_Parameter_Types : Node_Id;\n       Arg_Result_Type     : Node_Id;\n-      Arg_Homonym_Number  : Node_Id);\n+      Arg_Source_Location : Node_Id);\n    --  Process eliminate pragma (given by Pragma_Node). The number of\n    --  arguments has been checked, as well as possible optional identifiers,\n    --  but no other checks have been made. This subprogram completes the"}, {"sha": "b33973f2051c80305ec738a23fb8c789a9031d14", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1954,6 +1954,7 @@ package body Sem_Eval is\n          if Nkind (Operand) = N_Raise_Constraint_Error then\n             Set_Raises_Constraint_Error (N);\n          end if;\n+\n          return;\n       end if;\n "}, {"sha": "3b8c2ff99e3efd8a8352f004003edebed848206f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1693,6 +1693,7 @@ package body Sem_Prag is\n          Id        : Node_Id;\n          E1        : Entity_Id;\n          Cname     : Name_Id;\n+         Comp_Unit : Unit_Number_Type;\n \n          procedure Set_Convention_From_Pragma (E : Entity_Id);\n          --  Set convention in entity E, and also flag that the entity has a\n@@ -1907,9 +1908,11 @@ package body Sem_Prag is\n             end if;\n \n          --  For the subprogram case, set proper convention for all homonyms\n-         --  in same scope.\n+         --  in same scope and the same declarative part, i.e. the same\n+         --  compilation unit.\n \n          else\n+            Comp_Unit := Get_Source_Unit (E);\n             Set_Convention_From_Pragma (E);\n \n             --  Treat a pragma Import as an implicit body, for GPS use.\n@@ -1928,6 +1931,7 @@ package body Sem_Prag is\n                --  than one Rep_Item chain, to be fixed later ???\n \n                if Comes_From_Source (E1)\n+                 and then Comp_Unit = Get_Source_Unit (E1)\n                  and then Nkind (Original_Node (Parent (E1))) /=\n                    N_Full_Type_Declaration\n                then\n@@ -3556,10 +3560,11 @@ package body Sem_Prag is\n                Set_Is_Statically_Allocated (E);\n \n                --  Warn if the corresponding W flag is set and the pragma\n-               --  comes from source. The latter may be not be true e.g. on\n+               --  comes from source. The latter may not be true e.g. on\n                --  VMS where we expand export pragmas for exception codes\n-               --  associated with imported or exported exceptions. We don't\n-               --  want the user to be warned about something he didn't write.\n+               --  associated with imported or exported exceptions. We do\n+               --  not want to generate a warning for something that the\n+               --  user did not write.\n \n                if Warn_On_Export_Import\n                  and then Comes_From_Source (Arg)\n@@ -5405,27 +5410,39 @@ package body Sem_Prag is\n          --    [,[Entity          =>]  IDENTIFIER |\n          --                            SELECTED_COMPONENT |\n          --                            STRING_LITERAL]\n-         --    [,[Parameter_Types =>]  PARAMETER_TYPES]\n-         --    [,[Result_Type     =>]  result_SUBTYPE_NAME]\n-         --    [,[Homonym_Number  =>]  INTEGER_LITERAL]);\n+         --    [,]OVERLOADING_RESOLUTION);\n+\n+         --  OVERLOADING_RESOLUTION ::= PARAMETER_AND_RESULT_TYPE_PROFILE |\n+         --                             SOURCE_LOCATION\n+\n+         --  PARAMETER_AND_RESULT_TYPE_PROFILE ::= PROCEDURE_PROFILE |\n+         --                                        FUNCTION_PROFILE\n+\n+         --  PROCEDURE_PROFILE ::= Parameter_Types => PARAMETER_TYPES\n+\n+         --  FUNCTION_PROFILE ::= [Parameter_Types => PARAMETER_TYPES,]\n+         --                       Result_Type => result_SUBTYPE_NAME]\n \n          --  PARAMETER_TYPES ::= (SUBTYPE_NAME {, SUBTYPE_NAME})\n          --  SUBTYPE_NAME    ::= STRING_LITERAL\n \n+         --  SOURCE_LOCATION ::= Source_Location => SOURCE_TRACE\n+         --  SOURCE_TRACE    ::= STRING_LITERAL\n+\n          when Pragma_Eliminate => Eliminate : declare\n             Args  : Args_List (1 .. 5);\n             Names : constant Name_List (1 .. 5) := (\n                       Name_Unit_Name,\n                       Name_Entity,\n                       Name_Parameter_Types,\n                       Name_Result_Type,\n-                      Name_Homonym_Number);\n+                      Name_Source_Location);\n \n             Unit_Name       : Node_Id renames Args (1);\n             Entity          : Node_Id renames Args (2);\n             Parameter_Types : Node_Id renames Args (3);\n             Result_Type     : Node_Id renames Args (4);\n-            Homonym_Number  : Node_Id renames Args (5);\n+            Source_Location : Node_Id renames Args (5);\n \n          begin\n             GNAT_Pragma;\n@@ -5441,18 +5458,29 @@ package body Sem_Prag is\n                           or else\n                         Present (Result_Type)\n                           or else\n-                        Present (Homonym_Number))\n+                        Present (Source_Location))\n             then\n                Error_Pragma (\"missing Entity argument for pragma%\");\n             end if;\n \n+            if (Present (Parameter_Types)\n+                       or else\n+                Present (Result_Type))\n+              and then\n+                Present (Source_Location)\n+            then\n+               Error_Pragma\n+                 (\"parameter profile and source location can not \" &\n+                  \"be used together in pragma%\");\n+            end if;\n+\n             Process_Eliminate_Pragma\n               (N,\n                Unit_Name,\n                Entity,\n                Parameter_Types,\n                Result_Type,\n-               Homonym_Number);\n+               Source_Location);\n          end Eliminate;\n \n          --------------------------"}, {"sha": "97f98380c2b0fe636a81e5356d2ee1adcaf1c07e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -3730,6 +3730,7 @@ package body Sem_Res is\n                --  we will try later to detect some cases here at run time by\n                --  expanding checking code (see Detect_Infinite_Recursion in\n                --  package Exp_Ch6).\n+\n                --  If the recursive call is within a handler we do not emit a\n                --  warning, because this is a common idiom: loop until input\n                --  is correct, catch illegal input in handler and restart.\n@@ -6866,6 +6867,12 @@ package body Sem_Res is\n       elsif Is_Numeric_Type (Target_Type)  then\n          if Opnd_Type = Universal_Fixed then\n             return True;\n+\n+         elsif (In_Instance or else In_Inlined_Body)\n+           and then not Comes_From_Source (N)\n+         then\n+            return True;\n+\n          else\n             return Conversion_Check (Is_Numeric_Type (Opnd_Type),\n                              \"illegal operand for numeric conversion\");"}, {"sha": "ddded5cc0fbd6f139b866d3ffee61b8b33b6ddc9", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -2674,6 +2674,23 @@ package body Sem_Util is\n       return Task_Body_Procedure (Declaration_Node (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n+   ----------------------\n+   -- Has_Declarations --\n+   ----------------------\n+\n+   function Has_Declarations (N : Node_Id) return Boolean is\n+      K : constant Node_Kind := Nkind (N);\n+   begin\n+      return    K = N_Accept_Statement\n+        or else K = N_Block_Statement\n+        or else K = N_Compilation_Unit_Aux\n+        or else K = N_Entry_Body\n+        or else K = N_Package_Body\n+        or else K = N_Protected_Body\n+        or else K = N_Subprogram_Body\n+        or else K = N_Task_Body;\n+   end Has_Declarations;\n+\n    --------------------\n    -- Has_Infinities --\n    --------------------"}, {"sha": "9a35d8db75bc863a591ccc173d9009473c483bf8", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -357,6 +357,9 @@ package Sem_Util is\n    --  Task_Body_Procedure field from the corresponding task type\n    --  declaration.\n \n+   function Has_Declarations (N : Node_Id) return Boolean;\n+   --  Determines if the node can have declarations\n+\n    function Has_Infinities (E : Entity_Id) return Boolean;\n    --  Determines if the range of the floating-point type E includes\n    --  infinities. Returns False if E is not a floating-point type.\n@@ -468,8 +471,8 @@ package Sem_Util is\n    --  an lvalue, but it can answer True when N is not an lvalue. An lvalue is\n    --  defined as any expression which appears in a context where a name is\n    --  required by the syntax, and the identity, rather than merely the value\n-   --  of the node is needed (for example, the prefix of an attribute is in\n-   --  this category).\n+   --  of the node is needed (for example, the prefix of an Access attribute\n+   --  is in this category).\n \n    function Is_Library_Level_Entity (E : Entity_Id) return Boolean;\n    --  A library-level declaration is one that is accessible from Standard,"}, {"sha": "65ee94ef2c07c734b59c3a4cb0744d25fad612c3", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -126,6 +126,14 @@ package body Sinfo is\n       return Node3 (N);\n    end Access_Definition;\n \n+   function Access_To_Subprogram_Definition\n+     (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition);\n+      return Node3 (N);\n+   end Access_To_Subprogram_Definition;\n+\n    function Access_Types_To_Process\n       (N : Node_Id) return Elist_Id is\n    begin\n@@ -2612,6 +2620,14 @@ package body Sinfo is\n       Set_Node3_With_Parent (N, Val);\n    end Set_Access_Definition;\n \n+   procedure Set_Access_To_Subprogram_Definition\n+     (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Access_Definition);\n+      Set_Node3_With_Parent (N, Val);\n+   end Set_Access_To_Subprogram_Definition;\n+\n    procedure Set_Access_Types_To_Process\n       (N : Node_Id; Val : Elist_Id) is\n    begin"}, {"sha": "63a6e0c243ed10ea9ebb0657882b1251405358dd", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -2705,13 +2705,17 @@ package Sinfo is\n \n       --  ACCESS_DEFINITION ::=\n       --    [NULL_EXCLUSION] access [GENERAL_ACCESS_MODIFIER] SUBTYPE_MARK\n+      --  | ACCESS_TO_SUBPROGRAM_DEFINITION\n+\n+      --  Note: access to subprograms are an Ada 0Y (AI-254) extension\n \n       --  N_Access_Definition\n       --  Sloc points to ACCESS\n       --  Null_Exclusion_Present (Flag9) (set to False if not present)\n       --  All_Present (Flag15)\n       --  Constant_Present (Flag17)\n       --  Subtype_Mark (Node4)\n+      --  Access_To_Subprogram_Definition (Node3) (set to Empty if not present)\n \n       -----------------------------------------\n       -- 3.10.1  Incomplete Type Declaration --\n@@ -4242,7 +4246,7 @@ package Sinfo is\n \n       --  PRIVATE_TYPE_DECLARATION ::=\n       --    type DEFINING_IDENTIFIER [DISCRIMINANT_PART]\n-      --      is [abstract] tagged] [limited] private;\n+      --      is [[abstract] tagged] [limited] private;\n \n       --  Note: TAGGED is not permitted in Ada 83 mode\n \n@@ -6929,6 +6933,9 @@ package Sinfo is\n    function Access_Definition\n      (N : Node_Id) return Node_Id;    -- Node3\n \n+   function Access_To_Subprogram_Definition\n+     (N : Node_Id) return Node_Id;    -- Node3\n+\n    function Access_Types_To_Process\n      (N : Node_Id) return Elist_Id;   -- Elist2\n \n@@ -7721,6 +7728,9 @@ package Sinfo is\n    procedure Set_Access_Definition\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n+   procedure Set_Access_To_Subprogram_Definition\n+     (N : Node_Id; Val : Node_Id);            -- Node3\n+\n    procedure Set_Access_Types_To_Process\n      (N : Node_Id; Val : Elist_Id);           -- Elist2\n \n@@ -8514,6 +8524,7 @@ package Sinfo is\n    pragma Inline (Accept_Handler_Records);\n    pragma Inline (Accept_Statement);\n    pragma Inline (Access_Definition);\n+   pragma Inline (Access_To_Subprogram_Definition);\n    pragma Inline (Access_Types_To_Process);\n    pragma Inline (Actions);\n    pragma Inline (Activation_Chain_Entity);\n@@ -8775,6 +8786,7 @@ package Sinfo is\n    pragma Inline (Set_Accept_Handler_Records);\n    pragma Inline (Set_Accept_Statement);\n    pragma Inline (Set_Access_Definition);\n+   pragma Inline (Set_Access_To_Subprogram_Definition);\n    pragma Inline (Set_Access_Types_To_Process);\n    pragma Inline (Set_Actions);\n    pragma Inline (Set_Activation_Chain_Entity);"}, {"sha": "7eec50aa701142fbc35addb1ba73538843a7133c", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -92,6 +92,9 @@ package body Snames is\n      \"finalize#\" &\n      \"next#\" &\n      \"prev#\" &\n+     \"_typecode#\" &\n+     \"_from_any#\" &\n+     \"_to_any#\" &\n      \"allocate#\" &\n      \"deallocate#\" &\n      \"dereference#\" &\n@@ -120,16 +123,25 @@ package body Snames is\n      \"async#\" &\n      \"get_active_partition_id#\" &\n      \"get_rci_package_receiver#\" &\n+     \"get_rci_package_ref#\" &\n      \"origin#\" &\n      \"params#\" &\n      \"partition#\" &\n      \"partition_interface#\" &\n      \"ras#\" &\n+     \"call#\" &\n      \"rci_name#\" &\n      \"receiver#\" &\n      \"result#\" &\n      \"rpc#\" &\n      \"subp_id#\" &\n+     \"operation#\" &\n+     \"argument#\" &\n+     \"arg_modes#\" &\n+     \"handler#\" &\n+     \"target#\" &\n+     \"req#\" &\n+     \"obj_typecode#\" &\n      \"Oabs#\" &\n      \"Oand#\" &\n      \"Omod#\" &"}, {"sha": "562a2803d891feddab74cd44dee760bed0740c45", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 600, "deletions": 585, "changes": 1185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -183,92 +183,107 @@ package Snames is\n    Name_Next                           : constant Name_Id := N + 033;\n    Name_Prev                           : constant Name_Id := N + 034;\n \n+   --  Names of TSS routines for implementation of DSA over PolyORB\n+\n+   Name_uTypeCode                      : constant Name_Id := N + 035;\n+   Name_uFrom_Any                      : constant Name_Id := N + 036;\n+   Name_uTo_Any                        : constant Name_Id := N + 037;\n+\n    --  Names of allocation routines, also needed by expander\n \n-   Name_Allocate                       : constant Name_Id := N + 035;\n-   Name_Deallocate                     : constant Name_Id := N + 036;\n-   Name_Dereference                    : constant Name_Id := N + 037;\n+   Name_Allocate                       : constant Name_Id := N + 038;\n+   Name_Deallocate                     : constant Name_Id := N + 039;\n+   Name_Dereference                    : constant Name_Id := N + 040;\n \n    --  Names of Text_IO generic subpackages (see Rtsfind.Text_IO_Kludge)\n \n-   First_Text_IO_Package               : constant Name_Id := N + 038;\n-   Name_Decimal_IO                     : constant Name_Id := N + 038;\n-   Name_Enumeration_IO                 : constant Name_Id := N + 039;\n-   Name_Fixed_IO                       : constant Name_Id := N + 040;\n-   Name_Float_IO                       : constant Name_Id := N + 041;\n-   Name_Integer_IO                     : constant Name_Id := N + 042;\n-   Name_Modular_IO                     : constant Name_Id := N + 043;\n-   Last_Text_IO_Package                : constant Name_Id := N + 043;\n+   First_Text_IO_Package               : constant Name_Id := N + 041;\n+   Name_Decimal_IO                     : constant Name_Id := N + 041;\n+   Name_Enumeration_IO                 : constant Name_Id := N + 042;\n+   Name_Fixed_IO                       : constant Name_Id := N + 043;\n+   Name_Float_IO                       : constant Name_Id := N + 044;\n+   Name_Integer_IO                     : constant Name_Id := N + 045;\n+   Name_Modular_IO                     : constant Name_Id := N + 046;\n+   Last_Text_IO_Package                : constant Name_Id := N + 046;\n \n    subtype Text_IO_Package_Name is Name_Id\n      range First_Text_IO_Package .. Last_Text_IO_Package;\n \n    --  Names of files in library for Ada.Text_IO and Ada.Wide_Text_IO\n \n-   Name_a_textio                       : constant Name_Id := N + 044;\n-   Name_a_witeio                       : constant Name_Id := N + 045;\n+   Name_a_textio                       : constant Name_Id := N + 047;\n+   Name_a_witeio                       : constant Name_Id := N + 048;\n \n    --  Some miscellaneous names used for error detection/recovery\n \n-   Name_Const                          : constant Name_Id := N + 046;\n-   Name_Error                          : constant Name_Id := N + 047;\n-   Name_Go                             : constant Name_Id := N + 048;\n-   Name_Put                            : constant Name_Id := N + 049;\n-   Name_Put_Line                       : constant Name_Id := N + 050;\n-   Name_To                             : constant Name_Id := N + 051;\n+   Name_Const                          : constant Name_Id := N + 049;\n+   Name_Error                          : constant Name_Id := N + 050;\n+   Name_Go                             : constant Name_Id := N + 051;\n+   Name_Put                            : constant Name_Id := N + 052;\n+   Name_Put_Line                       : constant Name_Id := N + 053;\n+   Name_To                             : constant Name_Id := N + 054;\n \n    --  Names for packages that are treated specially by the compiler\n \n-   Name_Finalization                   : constant Name_Id := N + 052;\n-   Name_Finalization_Root              : constant Name_Id := N + 053;\n-   Name_Interfaces                     : constant Name_Id := N + 054;\n-   Name_Standard                       : constant Name_Id := N + 055;\n-   Name_System                         : constant Name_Id := N + 056;\n-   Name_Text_IO                        : constant Name_Id := N + 057;\n-   Name_Wide_Text_IO                   : constant Name_Id := N + 058;\n+   Name_Finalization                   : constant Name_Id := N + 055;\n+   Name_Finalization_Root              : constant Name_Id := N + 056;\n+   Name_Interfaces                     : constant Name_Id := N + 057;\n+   Name_Standard                       : constant Name_Id := N + 058;\n+   Name_System                         : constant Name_Id := N + 059;\n+   Name_Text_IO                        : constant Name_Id := N + 060;\n+   Name_Wide_Text_IO                   : constant Name_Id := N + 061;\n \n    --  Names of identifiers used in expanding distribution stubs\n \n-   Name_Addr                           : constant Name_Id := N + 059;\n-   Name_Async                          : constant Name_Id := N + 060;\n-   Name_Get_Active_Partition_ID        : constant Name_Id := N + 061;\n-   Name_Get_RCI_Package_Receiver       : constant Name_Id := N + 062;\n-   Name_Origin                         : constant Name_Id := N + 063;\n-   Name_Params                         : constant Name_Id := N + 064;\n-   Name_Partition                      : constant Name_Id := N + 065;\n-   Name_Partition_Interface            : constant Name_Id := N + 066;\n-   Name_Ras                            : constant Name_Id := N + 067;\n-   Name_RCI_Name                       : constant Name_Id := N + 068;\n-   Name_Receiver                       : constant Name_Id := N + 069;\n-   Name_Result                         : constant Name_Id := N + 070;\n-   Name_Rpc                            : constant Name_Id := N + 071;\n-   Name_Subp_Id                        : constant Name_Id := N + 072;\n+   Name_Addr                           : constant Name_Id := N + 062;\n+   Name_Async                          : constant Name_Id := N + 063;\n+   Name_Get_Active_Partition_ID        : constant Name_Id := N + 064;\n+   Name_Get_RCI_Package_Receiver       : constant Name_Id := N + 065;\n+   Name_Get_RCI_Package_Ref            : constant Name_Id := N + 066;\n+   Name_Origin                         : constant Name_Id := N + 067;\n+   Name_Params                         : constant Name_Id := N + 068;\n+   Name_Partition                      : constant Name_Id := N + 069;\n+   Name_Partition_Interface            : constant Name_Id := N + 070;\n+   Name_Ras                            : constant Name_Id := N + 071;\n+   Name_Call                           : constant Name_Id := N + 072;\n+   Name_RCI_Name                       : constant Name_Id := N + 073;\n+   Name_Receiver                       : constant Name_Id := N + 074;\n+   Name_Result                         : constant Name_Id := N + 075;\n+   Name_Rpc                            : constant Name_Id := N + 076;\n+   Name_Subp_Id                        : constant Name_Id := N + 077;\n+   Name_Operation                      : constant Name_Id := N + 078;\n+   Name_Argument                       : constant Name_Id := N + 079;\n+   Name_Arg_Modes                      : constant Name_Id := N + 080;\n+   Name_Handler                        : constant Name_Id := N + 081;\n+   Name_Target                         : constant Name_Id := N + 082;\n+   Name_Req                            : constant Name_Id := N + 083;\n+   Name_Obj_TypeCode                   : constant Name_Id := N + 084;\n \n    --  Operator Symbol entries. The actual names have an upper case O at\n    --  the start in place of the Op_ prefix (e.g. the actual name that\n    --  corresponds to Name_Op_Abs is \"Oabs\".\n \n-   First_Operator_Name                 : constant Name_Id := N + 073;\n-   Name_Op_Abs                         : constant Name_Id := N + 073; -- \"abs\"\n-   Name_Op_And                         : constant Name_Id := N + 074; -- \"and\"\n-   Name_Op_Mod                         : constant Name_Id := N + 075; -- \"mod\"\n-   Name_Op_Not                         : constant Name_Id := N + 076; -- \"not\"\n-   Name_Op_Or                          : constant Name_Id := N + 077; -- \"or\"\n-   Name_Op_Rem                         : constant Name_Id := N + 078; -- \"rem\"\n-   Name_Op_Xor                         : constant Name_Id := N + 079; -- \"xor\"\n-   Name_Op_Eq                          : constant Name_Id := N + 080; -- \"=\"\n-   Name_Op_Ne                          : constant Name_Id := N + 081; -- \"/=\"\n-   Name_Op_Lt                          : constant Name_Id := N + 082; -- \"<\"\n-   Name_Op_Le                          : constant Name_Id := N + 083; -- \"<=\"\n-   Name_Op_Gt                          : constant Name_Id := N + 084; -- \">\"\n-   Name_Op_Ge                          : constant Name_Id := N + 085; -- \">=\"\n-   Name_Op_Add                         : constant Name_Id := N + 086; -- \"+\"\n-   Name_Op_Subtract                    : constant Name_Id := N + 087; -- \"-\"\n-   Name_Op_Concat                      : constant Name_Id := N + 088; -- \"&\"\n-   Name_Op_Multiply                    : constant Name_Id := N + 089; -- \"*\"\n-   Name_Op_Divide                      : constant Name_Id := N + 090; -- \"/\"\n-   Name_Op_Expon                       : constant Name_Id := N + 091; -- \"**\"\n-   Last_Operator_Name                  : constant Name_Id := N + 091;\n+   First_Operator_Name                 : constant Name_Id := N + 085;\n+   Name_Op_Abs                         : constant Name_Id := N + 085; -- \"abs\"\n+   Name_Op_And                         : constant Name_Id := N + 086; -- \"and\"\n+   Name_Op_Mod                         : constant Name_Id := N + 087; -- \"mod\"\n+   Name_Op_Not                         : constant Name_Id := N + 088; -- \"not\"\n+   Name_Op_Or                          : constant Name_Id := N + 089; -- \"or\"\n+   Name_Op_Rem                         : constant Name_Id := N + 090; -- \"rem\"\n+   Name_Op_Xor                         : constant Name_Id := N + 091; -- \"xor\"\n+   Name_Op_Eq                          : constant Name_Id := N + 092; -- \"=\"\n+   Name_Op_Ne                          : constant Name_Id := N + 093; -- \"/=\"\n+   Name_Op_Lt                          : constant Name_Id := N + 094; -- \"<\"\n+   Name_Op_Le                          : constant Name_Id := N + 095; -- \"<=\"\n+   Name_Op_Gt                          : constant Name_Id := N + 096; -- \">\"\n+   Name_Op_Ge                          : constant Name_Id := N + 097; -- \">=\"\n+   Name_Op_Add                         : constant Name_Id := N + 098; -- \"+\"\n+   Name_Op_Subtract                    : constant Name_Id := N + 099; -- \"-\"\n+   Name_Op_Concat                      : constant Name_Id := N + 100; -- \"&\"\n+   Name_Op_Multiply                    : constant Name_Id := N + 101; -- \"*\"\n+   Name_Op_Divide                      : constant Name_Id := N + 102; -- \"/\"\n+   Name_Op_Expon                       : constant Name_Id := N + 103; -- \"**\"\n+   Last_Operator_Name                  : constant Name_Id := N + 103;\n \n    --  Names for all pragmas recognized by GNAT. The entries with the comment\n    --  \"Ada 83\" are pragmas that are defined in Ada 83, but not in Ada 95.\n@@ -291,140 +306,140 @@ package Snames is\n    --  only in GNAT for the AAMP. They are ignored in other versions with\n    --  appropriate warnings.\n \n-   First_Pragma_Name                   : constant Name_Id := N + 092;\n+   First_Pragma_Name                   : constant Name_Id := N + 104;\n \n    --  Configuration pragmas are grouped at start\n \n-   Name_Ada_83                         : constant Name_Id := N + 092; -- GNAT\n-   Name_Ada_95                         : constant Name_Id := N + 093; -- GNAT\n-   Name_C_Pass_By_Copy                 : constant Name_Id := N + 094; -- GNAT\n-   Name_Compile_Time_Warning           : constant Name_Id := N + 095; -- GNAT\n-   Name_Component_Alignment            : constant Name_Id := N + 096; -- GNAT\n-   Name_Convention_Identifier          : constant Name_Id := N + 097; -- GNAT\n-   Name_Discard_Names                  : constant Name_Id := N + 098;\n-   Name_Elaboration_Checks             : constant Name_Id := N + 099; -- GNAT\n-   Name_Eliminate                      : constant Name_Id := N + 100; -- GNAT\n-   Name_Explicit_Overriding            : constant Name_Id := N + 101;\n-   Name_Extend_System                  : constant Name_Id := N + 102; -- GNAT\n-   Name_Extensions_Allowed             : constant Name_Id := N + 103; -- GNAT\n-   Name_External_Name_Casing           : constant Name_Id := N + 104; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + 105; -- GNAT\n-   Name_Initialize_Scalars             : constant Name_Id := N + 106; -- GNAT\n-   Name_Interrupt_State                : constant Name_Id := N + 107; -- GNAT\n-   Name_License                        : constant Name_Id := N + 108; -- GNAT\n-   Name_Locking_Policy                 : constant Name_Id := N + 109;\n-   Name_Long_Float                     : constant Name_Id := N + 110; -- VMS\n-   Name_No_Run_Time                    : constant Name_Id := N + 111; -- GNAT\n-   Name_No_Strict_Aliasing             : constant Name_Id := N + 112; -- GNAT\n-   Name_Normalize_Scalars              : constant Name_Id := N + 113;\n-   Name_Polling                        : constant Name_Id := N + 114; -- GNAT\n-   Name_Persistent_Data                : constant Name_Id := N + 115; -- GNAT\n-   Name_Persistent_Object              : constant Name_Id := N + 116; -- GNAT\n-   Name_Profile                        : constant Name_Id := N + 117; -- Ada0Y\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 118; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 119;\n-   Name_Ravenscar                      : constant Name_Id := N + 120;\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 121;\n-   Name_Restrictions                   : constant Name_Id := N + 122;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 123; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 124;\n-   Name_Source_File_Name               : constant Name_Id := N + 125; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 126; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 127; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 128;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 129; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 130;\n-   Name_Universal_Data                 : constant Name_Id := N + 131; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 132; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 133; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 134; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 135; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 135;\n+   Name_Ada_83                         : constant Name_Id := N + 104; -- GNAT\n+   Name_Ada_95                         : constant Name_Id := N + 105; -- GNAT\n+   Name_C_Pass_By_Copy                 : constant Name_Id := N + 106; -- GNAT\n+   Name_Compile_Time_Warning           : constant Name_Id := N + 107; -- GNAT\n+   Name_Component_Alignment            : constant Name_Id := N + 108; -- GNAT\n+   Name_Convention_Identifier          : constant Name_Id := N + 109; -- GNAT\n+   Name_Discard_Names                  : constant Name_Id := N + 110;\n+   Name_Elaboration_Checks             : constant Name_Id := N + 111; -- GNAT\n+   Name_Eliminate                      : constant Name_Id := N + 112; -- GNAT\n+   Name_Explicit_Overriding            : constant Name_Id := N + 113;\n+   Name_Extend_System                  : constant Name_Id := N + 114; -- GNAT\n+   Name_Extensions_Allowed             : constant Name_Id := N + 115; -- GNAT\n+   Name_External_Name_Casing           : constant Name_Id := N + 116; -- GNAT\n+   Name_Float_Representation           : constant Name_Id := N + 117; -- GNAT\n+   Name_Initialize_Scalars             : constant Name_Id := N + 118; -- GNAT\n+   Name_Interrupt_State                : constant Name_Id := N + 119; -- GNAT\n+   Name_License                        : constant Name_Id := N + 120; -- GNAT\n+   Name_Locking_Policy                 : constant Name_Id := N + 121;\n+   Name_Long_Float                     : constant Name_Id := N + 122; -- VMS\n+   Name_No_Run_Time                    : constant Name_Id := N + 123; -- GNAT\n+   Name_No_Strict_Aliasing             : constant Name_Id := N + 124; -- GNAT\n+   Name_Normalize_Scalars              : constant Name_Id := N + 125;\n+   Name_Polling                        : constant Name_Id := N + 126; -- GNAT\n+   Name_Persistent_Data                : constant Name_Id := N + 127; -- GNAT\n+   Name_Persistent_Object              : constant Name_Id := N + 128; -- GNAT\n+   Name_Profile                        : constant Name_Id := N + 129; -- Ada0Y\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 130; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 131;\n+   Name_Ravenscar                      : constant Name_Id := N + 132;\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 133;\n+   Name_Restrictions                   : constant Name_Id := N + 134;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 135; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 136;\n+   Name_Source_File_Name               : constant Name_Id := N + 137; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 138; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 139; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 140;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 141; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 142;\n+   Name_Universal_Data                 : constant Name_Id := N + 143; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 144; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 145; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 146; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 147; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 147;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 136; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 137;\n-   Name_Annotate                       : constant Name_Id := N + 138; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 148; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 149;\n+   Name_Annotate                       : constant Name_Id := N + 150; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Attribute_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 139; -- GNAT\n-   Name_Asynchronous                   : constant Name_Id := N + 140;\n-   Name_Atomic                         : constant Name_Id := N + 141;\n-   Name_Atomic_Components              : constant Name_Id := N + 142;\n-   Name_Attach_Handler                 : constant Name_Id := N + 143;\n-   Name_Comment                        : constant Name_Id := N + 144; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 145; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 146; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 147;\n-   Name_Convention                     : constant Name_Id := N + 148;\n-   Name_CPP_Class                      : constant Name_Id := N + 149; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 150; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 151; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 152; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 153; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 154; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 155;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 156;\n-   Name_Export                         : constant Name_Id := N + 157;\n-   Name_Export_Exception               : constant Name_Id := N + 158; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 159; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 160; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 161; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 162; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 163; -- GNAT\n-   Name_External                       : constant Name_Id := N + 164; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 165; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 166; -- VMS\n-   Name_Import                         : constant Name_Id := N + 167;\n-   Name_Import_Exception               : constant Name_Id := N + 168; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 169; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 170; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 171; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 172; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 173;\n-   Name_Inline_Always                  : constant Name_Id := N + 174; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 175; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 176;\n-   Name_Interface                      : constant Name_Id := N + 177; -- Ada 83\n-   Name_Interface_Name                 : constant Name_Id := N + 178; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 179;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 180;\n-   Name_Java_Constructor               : constant Name_Id := N + 181; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 182; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 183; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 184; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 185; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 186;\n-   Name_Linker_Section                 : constant Name_Id := N + 187; -- GNAT\n-   Name_List                           : constant Name_Id := N + 188;\n-   Name_Machine_Attribute              : constant Name_Id := N + 189; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 190; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 191; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 192; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 193; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 194; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 195;\n-   Name_Optional_Overriding            : constant Name_Id := N + 196;\n-   Name_Overriding                     : constant Name_Id := N + 197;\n-   Name_Pack                           : constant Name_Id := N + 198;\n-   Name_Page                           : constant Name_Id := N + 199;\n-   Name_Passive                        : constant Name_Id := N + 200; -- GNAT\n-   Name_Preelaborate                   : constant Name_Id := N + 201;\n-   Name_Priority                       : constant Name_Id := N + 202;\n-   Name_Psect_Object                   : constant Name_Id := N + 203; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 204;\n-   Name_Pure_Function                  : constant Name_Id := N + 205; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 206;\n-   Name_Remote_Types                   : constant Name_Id := N + 207;\n-   Name_Share_Generic                  : constant Name_Id := N + 208; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 209; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 210;\n+   Name_Assert                         : constant Name_Id := N + 151; -- GNAT\n+   Name_Asynchronous                   : constant Name_Id := N + 152;\n+   Name_Atomic                         : constant Name_Id := N + 153;\n+   Name_Atomic_Components              : constant Name_Id := N + 154;\n+   Name_Attach_Handler                 : constant Name_Id := N + 155;\n+   Name_Comment                        : constant Name_Id := N + 156; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 157; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 158; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 159;\n+   Name_Convention                     : constant Name_Id := N + 160;\n+   Name_CPP_Class                      : constant Name_Id := N + 161; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 162; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 163; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 164; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 165; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 166; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 167;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 168;\n+   Name_Export                         : constant Name_Id := N + 169;\n+   Name_Export_Exception               : constant Name_Id := N + 170; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 171; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 172; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 173; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 174; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 175; -- GNAT\n+   Name_External                       : constant Name_Id := N + 176; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 177; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 178; -- VMS\n+   Name_Import                         : constant Name_Id := N + 179;\n+   Name_Import_Exception               : constant Name_Id := N + 180; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 181; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 182; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 183; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 184; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 185;\n+   Name_Inline_Always                  : constant Name_Id := N + 186; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 187; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 188;\n+   Name_Interface                      : constant Name_Id := N + 189; -- Ada 83\n+   Name_Interface_Name                 : constant Name_Id := N + 190; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 191;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 192;\n+   Name_Java_Constructor               : constant Name_Id := N + 193; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 194; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 195; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 196; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 197; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 198;\n+   Name_Linker_Section                 : constant Name_Id := N + 199; -- GNAT\n+   Name_List                           : constant Name_Id := N + 200;\n+   Name_Machine_Attribute              : constant Name_Id := N + 201; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 202; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 203; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 204; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 205; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 206; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 207;\n+   Name_Optional_Overriding            : constant Name_Id := N + 208;\n+   Name_Overriding                     : constant Name_Id := N + 209;\n+   Name_Pack                           : constant Name_Id := N + 210;\n+   Name_Page                           : constant Name_Id := N + 211;\n+   Name_Passive                        : constant Name_Id := N + 212; -- GNAT\n+   Name_Preelaborate                   : constant Name_Id := N + 213;\n+   Name_Priority                       : constant Name_Id := N + 214;\n+   Name_Psect_Object                   : constant Name_Id := N + 215; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 216;\n+   Name_Pure_Function                  : constant Name_Id := N + 217; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 218;\n+   Name_Remote_Types                   : constant Name_Id := N + 219;\n+   Name_Share_Generic                  : constant Name_Id := N + 220; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 221; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 222;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -434,27 +449,27 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 211; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 212; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 213; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 214; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 215; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 216; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 217; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 218; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 219; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 220; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 221; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 222; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 223; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 224; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 225; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 226; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 227; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 228;\n-   Name_Volatile_Components            : constant Name_Id := N + 229;\n-   Name_Weak_External                  : constant Name_Id := N + 230; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 230;\n+   Name_Source_Reference               : constant Name_Id := N + 223; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 224; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 225; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 226; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 227; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 228; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 229; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 230; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 231; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 232; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 233; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 234; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 235; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 236; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 237; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 238; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 239; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 240;\n+   Name_Volatile_Components            : constant Name_Id := N + 241;\n+   Name_Weak_External                  : constant Name_Id := N + 242; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 242;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -465,98 +480,98 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 231;\n-   Name_Ada                            : constant Name_Id := N + 231;\n-   Name_Assembler                      : constant Name_Id := N + 232;\n-   Name_COBOL                          : constant Name_Id := N + 233;\n-   Name_CPP                            : constant Name_Id := N + 234;\n-   Name_Fortran                        : constant Name_Id := N + 235;\n-   Name_Intrinsic                      : constant Name_Id := N + 236;\n-   Name_Java                           : constant Name_Id := N + 237;\n-   Name_Stdcall                        : constant Name_Id := N + 238;\n-   Name_Stubbed                        : constant Name_Id := N + 239;\n-   Last_Convention_Name                : constant Name_Id := N + 239;\n+   First_Convention_Name               : constant Name_Id := N + 243;\n+   Name_Ada                            : constant Name_Id := N + 243;\n+   Name_Assembler                      : constant Name_Id := N + 244;\n+   Name_COBOL                          : constant Name_Id := N + 245;\n+   Name_CPP                            : constant Name_Id := N + 246;\n+   Name_Fortran                        : constant Name_Id := N + 247;\n+   Name_Intrinsic                      : constant Name_Id := N + 248;\n+   Name_Java                           : constant Name_Id := N + 249;\n+   Name_Stdcall                        : constant Name_Id := N + 250;\n+   Name_Stubbed                        : constant Name_Id := N + 251;\n+   Last_Convention_Name                : constant Name_Id := N + 251;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 240;\n-   Name_Assembly                       : constant Name_Id := N + 241;\n+   Name_Asm                            : constant Name_Id := N + 252;\n+   Name_Assembly                       : constant Name_Id := N + 253;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 242;\n+   Name_Default                        : constant Name_Id := N + 254;\n    --  Name_Exernal (previously defined as pragma)\n \n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 243;\n-   Name_Win32                          : constant Name_Id := N + 244;\n+   Name_DLL                            : constant Name_Id := N + 255;\n+   Name_Win32                          : constant Name_Id := N + 256;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 245;\n-   Name_Body_File_Name                 : constant Name_Id := N + 246;\n-   Name_Casing                         : constant Name_Id := N + 247;\n-   Name_Code                           : constant Name_Id := N + 248;\n-   Name_Component                      : constant Name_Id := N + 249;\n-   Name_Component_Size_4               : constant Name_Id := N + 250;\n-   Name_Copy                           : constant Name_Id := N + 251;\n-   Name_D_Float                        : constant Name_Id := N + 252;\n-   Name_Descriptor                     : constant Name_Id := N + 253;\n-   Name_Dot_Replacement                : constant Name_Id := N + 254;\n-   Name_Dynamic                        : constant Name_Id := N + 255;\n-   Name_Entity                         : constant Name_Id := N + 256;\n-   Name_External_Name                  : constant Name_Id := N + 257;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 258;\n-   Name_Form                           : constant Name_Id := N + 259;\n-   Name_G_Float                        : constant Name_Id := N + 260;\n-   Name_Gcc                            : constant Name_Id := N + 261;\n-   Name_Gnat                           : constant Name_Id := N + 262;\n-   Name_GPL                            : constant Name_Id := N + 263;\n-   Name_IEEE_Float                     : constant Name_Id := N + 264;\n-   Name_Homonym_Number                 : constant Name_Id := N + 265;\n-   Name_Internal                       : constant Name_Id := N + 266;\n-   Name_Link_Name                      : constant Name_Id := N + 267;\n-   Name_Lowercase                      : constant Name_Id := N + 268;\n-   Name_Max_Size                       : constant Name_Id := N + 269;\n-   Name_Mechanism                      : constant Name_Id := N + 270;\n-   Name_Mixedcase                      : constant Name_Id := N + 271;\n-   Name_Modified_GPL                   : constant Name_Id := N + 272;\n-   Name_Name                           : constant Name_Id := N + 273;\n-   Name_NCA                            : constant Name_Id := N + 274;\n-   Name_No                             : constant Name_Id := N + 275;\n-   Name_On                             : constant Name_Id := N + 276;\n-   Name_Parameter_Types                : constant Name_Id := N + 277;\n-   Name_Reference                      : constant Name_Id := N + 278;\n-   Name_No_Requeue                     : constant Name_Id := N + 279;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 280;\n-   Name_Restricted                     : constant Name_Id := N + 281;\n-   Name_Result_Mechanism               : constant Name_Id := N + 282;\n-   Name_Result_Type                    : constant Name_Id := N + 283;\n-   Name_Runtime                        : constant Name_Id := N + 284;\n-   Name_SB                             : constant Name_Id := N + 285;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 286;\n-   Name_Section                        : constant Name_Id := N + 287;\n-   Name_Semaphore                      : constant Name_Id := N + 288;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 289;\n-   Name_Static                         : constant Name_Id := N + 290;\n-   Name_Stack_Size                     : constant Name_Id := N + 291;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 292;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 293;\n-   Name_Task_Type                      : constant Name_Id := N + 294;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 295;\n-   Name_Top_Guard                      : constant Name_Id := N + 296;\n-   Name_UBA                            : constant Name_Id := N + 297;\n-   Name_UBS                            : constant Name_Id := N + 298;\n-   Name_UBSB                           : constant Name_Id := N + 299;\n-   Name_Unit_Name                      : constant Name_Id := N + 300;\n-   Name_Unknown                        : constant Name_Id := N + 301;\n-   Name_Unrestricted                   : constant Name_Id := N + 302;\n-   Name_Uppercase                      : constant Name_Id := N + 303;\n-   Name_User                           : constant Name_Id := N + 304;\n-   Name_VAX_Float                      : constant Name_Id := N + 305;\n-   Name_VMS                            : constant Name_Id := N + 306;\n-   Name_Working_Storage                : constant Name_Id := N + 307;\n+   Name_As_Is                          : constant Name_Id := N + 257;\n+   Name_Body_File_Name                 : constant Name_Id := N + 258;\n+   Name_Casing                         : constant Name_Id := N + 259;\n+   Name_Code                           : constant Name_Id := N + 260;\n+   Name_Component                      : constant Name_Id := N + 261;\n+   Name_Component_Size_4               : constant Name_Id := N + 262;\n+   Name_Copy                           : constant Name_Id := N + 263;\n+   Name_D_Float                        : constant Name_Id := N + 264;\n+   Name_Descriptor                     : constant Name_Id := N + 265;\n+   Name_Dot_Replacement                : constant Name_Id := N + 266;\n+   Name_Dynamic                        : constant Name_Id := N + 267;\n+   Name_Entity                         : constant Name_Id := N + 268;\n+   Name_External_Name                  : constant Name_Id := N + 269;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 270;\n+   Name_Form                           : constant Name_Id := N + 271;\n+   Name_G_Float                        : constant Name_Id := N + 272;\n+   Name_Gcc                            : constant Name_Id := N + 273;\n+   Name_Gnat                           : constant Name_Id := N + 274;\n+   Name_GPL                            : constant Name_Id := N + 275;\n+   Name_IEEE_Float                     : constant Name_Id := N + 276;\n+   Name_Homonym_Number                 : constant Name_Id := N + 277;\n+   Name_Internal                       : constant Name_Id := N + 278;\n+   Name_Link_Name                      : constant Name_Id := N + 279;\n+   Name_Lowercase                      : constant Name_Id := N + 280;\n+   Name_Max_Size                       : constant Name_Id := N + 281;\n+   Name_Mechanism                      : constant Name_Id := N + 282;\n+   Name_Mixedcase                      : constant Name_Id := N + 283;\n+   Name_Modified_GPL                   : constant Name_Id := N + 284;\n+   Name_Name                           : constant Name_Id := N + 285;\n+   Name_NCA                            : constant Name_Id := N + 286;\n+   Name_No                             : constant Name_Id := N + 287;\n+   Name_On                             : constant Name_Id := N + 288;\n+   Name_Parameter_Types                : constant Name_Id := N + 289;\n+   Name_Reference                      : constant Name_Id := N + 290;\n+   Name_No_Requeue                     : constant Name_Id := N + 291;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 292;\n+   Name_Restricted                     : constant Name_Id := N + 293;\n+   Name_Result_Mechanism               : constant Name_Id := N + 294;\n+   Name_Result_Type                    : constant Name_Id := N + 295;\n+   Name_Runtime                        : constant Name_Id := N + 296;\n+   Name_SB                             : constant Name_Id := N + 297;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 298;\n+   Name_Section                        : constant Name_Id := N + 299;\n+   Name_Semaphore                      : constant Name_Id := N + 300;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 301;\n+   Name_Static                         : constant Name_Id := N + 302;\n+   Name_Stack_Size                     : constant Name_Id := N + 303;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 304;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 305;\n+   Name_Task_Type                      : constant Name_Id := N + 306;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 307;\n+   Name_Top_Guard                      : constant Name_Id := N + 308;\n+   Name_UBA                            : constant Name_Id := N + 309;\n+   Name_UBS                            : constant Name_Id := N + 310;\n+   Name_UBSB                           : constant Name_Id := N + 311;\n+   Name_Unit_Name                      : constant Name_Id := N + 312;\n+   Name_Unknown                        : constant Name_Id := N + 313;\n+   Name_Unrestricted                   : constant Name_Id := N + 314;\n+   Name_Uppercase                      : constant Name_Id := N + 315;\n+   Name_User                           : constant Name_Id := N + 316;\n+   Name_VAX_Float                      : constant Name_Id := N + 317;\n+   Name_VMS                            : constant Name_Id := N + 318;\n+   Name_Working_Storage                : constant Name_Id := N + 319;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -570,374 +585,374 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 308;\n-   Name_Abort_Signal                   : constant Name_Id := N + 308;  -- GNAT\n-   Name_Access                         : constant Name_Id := N + 309;\n-   Name_Address                        : constant Name_Id := N + 310;\n-   Name_Address_Size                   : constant Name_Id := N + 311;  -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 312;\n-   Name_Alignment                      : constant Name_Id := N + 313;\n-   Name_Asm_Input                      : constant Name_Id := N + 314;  -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 315;  -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 316;  -- VMS\n-   Name_Bit                            : constant Name_Id := N + 317;  -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 318;\n-   Name_Bit_Position                   : constant Name_Id := N + 319;  -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 320;\n-   Name_Callable                       : constant Name_Id := N + 321;\n-   Name_Caller                         : constant Name_Id := N + 322;\n-   Name_Code_Address                   : constant Name_Id := N + 323;  -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 324;\n-   Name_Compose                        : constant Name_Id := N + 325;\n-   Name_Constrained                    : constant Name_Id := N + 326;\n-   Name_Count                          : constant Name_Id := N + 327;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 328; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 329;\n-   Name_Delta                          : constant Name_Id := N + 330;\n-   Name_Denorm                         : constant Name_Id := N + 331;\n-   Name_Digits                         : constant Name_Id := N + 332;\n-   Name_Elaborated                     : constant Name_Id := N + 333; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 334; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 335; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 336; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 337;\n-   Name_External_Tag                   : constant Name_Id := N + 338;\n-   Name_First                          : constant Name_Id := N + 339;\n-   Name_First_Bit                      : constant Name_Id := N + 340;\n-   Name_Fixed_Value                    : constant Name_Id := N + 341; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 342;\n-   Name_Has_Discriminants              : constant Name_Id := N + 343; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 344;\n-   Name_Img                            : constant Name_Id := N + 345; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 346; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 347; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 348;\n-   Name_Last_Bit                       : constant Name_Id := N + 349;\n-   Name_Leading_Part                   : constant Name_Id := N + 350;\n-   Name_Length                         : constant Name_Id := N + 351;\n-   Name_Machine_Emax                   : constant Name_Id := N + 352;\n-   Name_Machine_Emin                   : constant Name_Id := N + 353;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 354;\n-   Name_Machine_Overflows              : constant Name_Id := N + 355;\n-   Name_Machine_Radix                  : constant Name_Id := N + 356;\n-   Name_Machine_Rounds                 : constant Name_Id := N + 357;\n-   Name_Machine_Size                   : constant Name_Id := N + 358; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 359; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 360;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 361; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 362; -- GNAT\n-   Name_Model_Emin                     : constant Name_Id := N + 363;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 364;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 365;\n-   Name_Model_Small                    : constant Name_Id := N + 366;\n-   Name_Modulus                        : constant Name_Id := N + 367;\n-   Name_Null_Parameter                 : constant Name_Id := N + 368; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 369; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 370;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 371; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 372;\n-   Name_Pos                            : constant Name_Id := N + 373;\n-   Name_Position                       : constant Name_Id := N + 374;\n-   Name_Range                          : constant Name_Id := N + 375;\n-   Name_Range_Length                   : constant Name_Id := N + 376; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 377;\n-   Name_Safe_Emax                      : constant Name_Id := N + 378; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 379;\n-   Name_Safe_Large                     : constant Name_Id := N + 380; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 381;\n-   Name_Safe_Small                     : constant Name_Id := N + 382; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 383;\n-   Name_Scaling                        : constant Name_Id := N + 384;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 385;\n-   Name_Size                           : constant Name_Id := N + 386;\n-   Name_Small                          : constant Name_Id := N + 387;\n-   Name_Storage_Size                   : constant Name_Id := N + 388;\n-   Name_Storage_Unit                   : constant Name_Id := N + 389; -- GNAT\n-   Name_Tag                            : constant Name_Id := N + 390;\n-   Name_Target_Name                    : constant Name_Id := N + 391; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 392;\n-   Name_To_Address                     : constant Name_Id := N + 393; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 394; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 395; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 396;\n-   Name_Unchecked_Access               : constant Name_Id := N + 397;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 398;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 399; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 400; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 401; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 402;\n-   Name_Valid                          : constant Name_Id := N + 403;\n-   Name_Value_Size                     : constant Name_Id := N + 404; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 405;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 406; -- GNAT\n-   Name_Wide_Width                     : constant Name_Id := N + 407;\n-   Name_Width                          : constant Name_Id := N + 408;\n-   Name_Word_Size                      : constant Name_Id := N + 409; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 320;\n+   Name_Abort_Signal                   : constant Name_Id := N + 320;  -- GNAT\n+   Name_Access                         : constant Name_Id := N + 321;\n+   Name_Address                        : constant Name_Id := N + 322;\n+   Name_Address_Size                   : constant Name_Id := N + 323;  -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 324;\n+   Name_Alignment                      : constant Name_Id := N + 325;\n+   Name_Asm_Input                      : constant Name_Id := N + 326;  -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 327;  -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 328;  -- VMS\n+   Name_Bit                            : constant Name_Id := N + 329;  -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 330;\n+   Name_Bit_Position                   : constant Name_Id := N + 331;  -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 332;\n+   Name_Callable                       : constant Name_Id := N + 333;\n+   Name_Caller                         : constant Name_Id := N + 334;\n+   Name_Code_Address                   : constant Name_Id := N + 335;  -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 336;\n+   Name_Compose                        : constant Name_Id := N + 337;\n+   Name_Constrained                    : constant Name_Id := N + 338;\n+   Name_Count                          : constant Name_Id := N + 339;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 340; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 341;\n+   Name_Delta                          : constant Name_Id := N + 342;\n+   Name_Denorm                         : constant Name_Id := N + 343;\n+   Name_Digits                         : constant Name_Id := N + 344;\n+   Name_Elaborated                     : constant Name_Id := N + 345; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 346; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 347; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 348; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 349;\n+   Name_External_Tag                   : constant Name_Id := N + 350;\n+   Name_First                          : constant Name_Id := N + 351;\n+   Name_First_Bit                      : constant Name_Id := N + 352;\n+   Name_Fixed_Value                    : constant Name_Id := N + 353; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 354;\n+   Name_Has_Discriminants              : constant Name_Id := N + 355; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 356;\n+   Name_Img                            : constant Name_Id := N + 357; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 358; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 359; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 360;\n+   Name_Last_Bit                       : constant Name_Id := N + 361;\n+   Name_Leading_Part                   : constant Name_Id := N + 362;\n+   Name_Length                         : constant Name_Id := N + 363;\n+   Name_Machine_Emax                   : constant Name_Id := N + 364;\n+   Name_Machine_Emin                   : constant Name_Id := N + 365;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 366;\n+   Name_Machine_Overflows              : constant Name_Id := N + 367;\n+   Name_Machine_Radix                  : constant Name_Id := N + 368;\n+   Name_Machine_Rounds                 : constant Name_Id := N + 369;\n+   Name_Machine_Size                   : constant Name_Id := N + 370; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 371; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 372;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 373; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 374; -- GNAT\n+   Name_Model_Emin                     : constant Name_Id := N + 375;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 376;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 377;\n+   Name_Model_Small                    : constant Name_Id := N + 378;\n+   Name_Modulus                        : constant Name_Id := N + 379;\n+   Name_Null_Parameter                 : constant Name_Id := N + 380; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 381; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 382;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 383; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 384;\n+   Name_Pos                            : constant Name_Id := N + 385;\n+   Name_Position                       : constant Name_Id := N + 386;\n+   Name_Range                          : constant Name_Id := N + 387;\n+   Name_Range_Length                   : constant Name_Id := N + 388; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 389;\n+   Name_Safe_Emax                      : constant Name_Id := N + 390; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 391;\n+   Name_Safe_Large                     : constant Name_Id := N + 392; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 393;\n+   Name_Safe_Small                     : constant Name_Id := N + 394; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 395;\n+   Name_Scaling                        : constant Name_Id := N + 396;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 397;\n+   Name_Size                           : constant Name_Id := N + 398;\n+   Name_Small                          : constant Name_Id := N + 399;\n+   Name_Storage_Size                   : constant Name_Id := N + 400;\n+   Name_Storage_Unit                   : constant Name_Id := N + 401; -- GNAT\n+   Name_Tag                            : constant Name_Id := N + 402;\n+   Name_Target_Name                    : constant Name_Id := N + 403; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 404;\n+   Name_To_Address                     : constant Name_Id := N + 405; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 406; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 407; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 408;\n+   Name_Unchecked_Access               : constant Name_Id := N + 409;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 410;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 411; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 412; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 413; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 414;\n+   Name_Valid                          : constant Name_Id := N + 415;\n+   Name_Value_Size                     : constant Name_Id := N + 416; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 417;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 418; -- GNAT\n+   Name_Wide_Width                     : constant Name_Id := N + 419;\n+   Name_Width                          : constant Name_Id := N + 420;\n+   Name_Word_Size                      : constant Name_Id := N + 421; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 410;\n-   Name_Adjacent                       : constant Name_Id := N + 410;\n-   Name_Ceiling                        : constant Name_Id := N + 411;\n-   Name_Copy_Sign                      : constant Name_Id := N + 412;\n-   Name_Floor                          : constant Name_Id := N + 413;\n-   Name_Fraction                       : constant Name_Id := N + 414;\n-   Name_Image                          : constant Name_Id := N + 415;\n-   Name_Input                          : constant Name_Id := N + 416;\n-   Name_Machine                        : constant Name_Id := N + 417;\n-   Name_Max                            : constant Name_Id := N + 418;\n-   Name_Min                            : constant Name_Id := N + 419;\n-   Name_Model                          : constant Name_Id := N + 420;\n-   Name_Pred                           : constant Name_Id := N + 421;\n-   Name_Remainder                      : constant Name_Id := N + 422;\n-   Name_Rounding                       : constant Name_Id := N + 423;\n-   Name_Succ                           : constant Name_Id := N + 424;\n-   Name_Truncation                     : constant Name_Id := N + 425;\n-   Name_Value                          : constant Name_Id := N + 426;\n-   Name_Wide_Image                     : constant Name_Id := N + 427;\n-   Name_Wide_Value                     : constant Name_Id := N + 428;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 428;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 422;\n+   Name_Adjacent                       : constant Name_Id := N + 422;\n+   Name_Ceiling                        : constant Name_Id := N + 423;\n+   Name_Copy_Sign                      : constant Name_Id := N + 424;\n+   Name_Floor                          : constant Name_Id := N + 425;\n+   Name_Fraction                       : constant Name_Id := N + 426;\n+   Name_Image                          : constant Name_Id := N + 427;\n+   Name_Input                          : constant Name_Id := N + 428;\n+   Name_Machine                        : constant Name_Id := N + 429;\n+   Name_Max                            : constant Name_Id := N + 430;\n+   Name_Min                            : constant Name_Id := N + 431;\n+   Name_Model                          : constant Name_Id := N + 432;\n+   Name_Pred                           : constant Name_Id := N + 433;\n+   Name_Remainder                      : constant Name_Id := N + 434;\n+   Name_Rounding                       : constant Name_Id := N + 435;\n+   Name_Succ                           : constant Name_Id := N + 436;\n+   Name_Truncation                     : constant Name_Id := N + 437;\n+   Name_Value                          : constant Name_Id := N + 438;\n+   Name_Wide_Image                     : constant Name_Id := N + 439;\n+   Name_Wide_Value                     : constant Name_Id := N + 440;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 440;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 429;\n-   Name_Output                         : constant Name_Id := N + 429;\n-   Name_Read                           : constant Name_Id := N + 430;\n-   Name_Write                          : constant Name_Id := N + 431;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 431;\n+   First_Procedure_Attribute           : constant Name_Id := N + 441;\n+   Name_Output                         : constant Name_Id := N + 441;\n+   Name_Read                           : constant Name_Id := N + 442;\n+   Name_Write                          : constant Name_Id := N + 443;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 443;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 432;\n-   Name_Elab_Body                      : constant Name_Id := N + 432; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 433; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 434;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 444;\n+   Name_Elab_Body                      : constant Name_Id := N + 444; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 445; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 446;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 435;\n-   Name_Base                           : constant Name_Id := N + 435;\n-   Name_Class                          : constant Name_Id := N + 436;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 436;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 436;\n-   Last_Attribute_Name                 : constant Name_Id := N + 436;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 447;\n+   Name_Base                           : constant Name_Id := N + 447;\n+   Name_Class                          : constant Name_Id := N + 448;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 448;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 448;\n+   Last_Attribute_Name                 : constant Name_Id := N + 448;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 437;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 437;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 438;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 438;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 449;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 449;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 450;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 450;\n \n    --  Names of recognized queuing policy identifiers.\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 439;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 439;\n-   Name_Priority_Queuing               : constant Name_Id := N + 440;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 440;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 451;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 451;\n+   Name_Priority_Queuing               : constant Name_Id := N + 452;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 452;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_WIthinn_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 441;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 441;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 441;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 453;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 453;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 453;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 442;\n-   Name_Access_Check                   : constant Name_Id := N + 442;\n-   Name_Accessibility_Check            : constant Name_Id := N + 443;\n-   Name_Discriminant_Check             : constant Name_Id := N + 444;\n-   Name_Division_Check                 : constant Name_Id := N + 445;\n-   Name_Elaboration_Check              : constant Name_Id := N + 446;\n-   Name_Index_Check                    : constant Name_Id := N + 447;\n-   Name_Length_Check                   : constant Name_Id := N + 448;\n-   Name_Overflow_Check                 : constant Name_Id := N + 449;\n-   Name_Range_Check                    : constant Name_Id := N + 450;\n-   Name_Storage_Check                  : constant Name_Id := N + 451;\n-   Name_Tag_Check                      : constant Name_Id := N + 452;\n-   Name_All_Checks                     : constant Name_Id := N + 453;\n-   Last_Check_Name                     : constant Name_Id := N + 453;\n+   First_Check_Name                    : constant Name_Id := N + 454;\n+   Name_Access_Check                   : constant Name_Id := N + 454;\n+   Name_Accessibility_Check            : constant Name_Id := N + 455;\n+   Name_Discriminant_Check             : constant Name_Id := N + 456;\n+   Name_Division_Check                 : constant Name_Id := N + 457;\n+   Name_Elaboration_Check              : constant Name_Id := N + 458;\n+   Name_Index_Check                    : constant Name_Id := N + 459;\n+   Name_Length_Check                   : constant Name_Id := N + 460;\n+   Name_Overflow_Check                 : constant Name_Id := N + 461;\n+   Name_Range_Check                    : constant Name_Id := N + 462;\n+   Name_Storage_Check                  : constant Name_Id := N + 463;\n+   Name_Tag_Check                      : constant Name_Id := N + 464;\n+   Name_All_Checks                     : constant Name_Id := N + 465;\n+   Last_Check_Name                     : constant Name_Id := N + 465;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 454;\n-   Name_Abs                            : constant Name_Id := N + 455;\n-   Name_Accept                         : constant Name_Id := N + 456;\n-   Name_And                            : constant Name_Id := N + 457;\n-   Name_All                            : constant Name_Id := N + 458;\n-   Name_Array                          : constant Name_Id := N + 459;\n-   Name_At                             : constant Name_Id := N + 460;\n-   Name_Begin                          : constant Name_Id := N + 461;\n-   Name_Body                           : constant Name_Id := N + 462;\n-   Name_Case                           : constant Name_Id := N + 463;\n-   Name_Constant                       : constant Name_Id := N + 464;\n-   Name_Declare                        : constant Name_Id := N + 465;\n-   Name_Delay                          : constant Name_Id := N + 466;\n-   Name_Do                             : constant Name_Id := N + 467;\n-   Name_Else                           : constant Name_Id := N + 468;\n-   Name_Elsif                          : constant Name_Id := N + 469;\n-   Name_End                            : constant Name_Id := N + 470;\n-   Name_Entry                          : constant Name_Id := N + 471;\n-   Name_Exception                      : constant Name_Id := N + 472;\n-   Name_Exit                           : constant Name_Id := N + 473;\n-   Name_For                            : constant Name_Id := N + 474;\n-   Name_Function                       : constant Name_Id := N + 475;\n-   Name_Generic                        : constant Name_Id := N + 476;\n-   Name_Goto                           : constant Name_Id := N + 477;\n-   Name_If                             : constant Name_Id := N + 478;\n-   Name_In                             : constant Name_Id := N + 479;\n-   Name_Is                             : constant Name_Id := N + 480;\n-   Name_Limited                        : constant Name_Id := N + 481;\n-   Name_Loop                           : constant Name_Id := N + 482;\n-   Name_Mod                            : constant Name_Id := N + 483;\n-   Name_New                            : constant Name_Id := N + 484;\n-   Name_Not                            : constant Name_Id := N + 485;\n-   Name_Null                           : constant Name_Id := N + 486;\n-   Name_Of                             : constant Name_Id := N + 487;\n-   Name_Or                             : constant Name_Id := N + 488;\n-   Name_Others                         : constant Name_Id := N + 489;\n-   Name_Out                            : constant Name_Id := N + 490;\n-   Name_Package                        : constant Name_Id := N + 491;\n-   Name_Pragma                         : constant Name_Id := N + 492;\n-   Name_Private                        : constant Name_Id := N + 493;\n-   Name_Procedure                      : constant Name_Id := N + 494;\n-   Name_Raise                          : constant Name_Id := N + 495;\n-   Name_Record                         : constant Name_Id := N + 496;\n-   Name_Rem                            : constant Name_Id := N + 497;\n-   Name_Renames                        : constant Name_Id := N + 498;\n-   Name_Return                         : constant Name_Id := N + 499;\n-   Name_Reverse                        : constant Name_Id := N + 500;\n-   Name_Select                         : constant Name_Id := N + 501;\n-   Name_Separate                       : constant Name_Id := N + 502;\n-   Name_Subtype                        : constant Name_Id := N + 503;\n-   Name_Task                           : constant Name_Id := N + 504;\n-   Name_Terminate                      : constant Name_Id := N + 505;\n-   Name_Then                           : constant Name_Id := N + 506;\n-   Name_Type                           : constant Name_Id := N + 507;\n-   Name_Use                            : constant Name_Id := N + 508;\n-   Name_When                           : constant Name_Id := N + 509;\n-   Name_While                          : constant Name_Id := N + 510;\n-   Name_With                           : constant Name_Id := N + 511;\n-   Name_Xor                            : constant Name_Id := N + 512;\n+   Name_Abort                          : constant Name_Id := N + 466;\n+   Name_Abs                            : constant Name_Id := N + 467;\n+   Name_Accept                         : constant Name_Id := N + 468;\n+   Name_And                            : constant Name_Id := N + 469;\n+   Name_All                            : constant Name_Id := N + 470;\n+   Name_Array                          : constant Name_Id := N + 471;\n+   Name_At                             : constant Name_Id := N + 472;\n+   Name_Begin                          : constant Name_Id := N + 473;\n+   Name_Body                           : constant Name_Id := N + 474;\n+   Name_Case                           : constant Name_Id := N + 475;\n+   Name_Constant                       : constant Name_Id := N + 476;\n+   Name_Declare                        : constant Name_Id := N + 477;\n+   Name_Delay                          : constant Name_Id := N + 478;\n+   Name_Do                             : constant Name_Id := N + 479;\n+   Name_Else                           : constant Name_Id := N + 480;\n+   Name_Elsif                          : constant Name_Id := N + 481;\n+   Name_End                            : constant Name_Id := N + 482;\n+   Name_Entry                          : constant Name_Id := N + 483;\n+   Name_Exception                      : constant Name_Id := N + 484;\n+   Name_Exit                           : constant Name_Id := N + 485;\n+   Name_For                            : constant Name_Id := N + 486;\n+   Name_Function                       : constant Name_Id := N + 487;\n+   Name_Generic                        : constant Name_Id := N + 488;\n+   Name_Goto                           : constant Name_Id := N + 489;\n+   Name_If                             : constant Name_Id := N + 490;\n+   Name_In                             : constant Name_Id := N + 491;\n+   Name_Is                             : constant Name_Id := N + 492;\n+   Name_Limited                        : constant Name_Id := N + 493;\n+   Name_Loop                           : constant Name_Id := N + 494;\n+   Name_Mod                            : constant Name_Id := N + 495;\n+   Name_New                            : constant Name_Id := N + 496;\n+   Name_Not                            : constant Name_Id := N + 497;\n+   Name_Null                           : constant Name_Id := N + 498;\n+   Name_Of                             : constant Name_Id := N + 499;\n+   Name_Or                             : constant Name_Id := N + 500;\n+   Name_Others                         : constant Name_Id := N + 501;\n+   Name_Out                            : constant Name_Id := N + 502;\n+   Name_Package                        : constant Name_Id := N + 503;\n+   Name_Pragma                         : constant Name_Id := N + 504;\n+   Name_Private                        : constant Name_Id := N + 505;\n+   Name_Procedure                      : constant Name_Id := N + 506;\n+   Name_Raise                          : constant Name_Id := N + 507;\n+   Name_Record                         : constant Name_Id := N + 508;\n+   Name_Rem                            : constant Name_Id := N + 509;\n+   Name_Renames                        : constant Name_Id := N + 510;\n+   Name_Return                         : constant Name_Id := N + 511;\n+   Name_Reverse                        : constant Name_Id := N + 512;\n+   Name_Select                         : constant Name_Id := N + 513;\n+   Name_Separate                       : constant Name_Id := N + 514;\n+   Name_Subtype                        : constant Name_Id := N + 515;\n+   Name_Task                           : constant Name_Id := N + 516;\n+   Name_Terminate                      : constant Name_Id := N + 517;\n+   Name_Then                           : constant Name_Id := N + 518;\n+   Name_Type                           : constant Name_Id := N + 519;\n+   Name_Use                            : constant Name_Id := N + 520;\n+   Name_When                           : constant Name_Id := N + 521;\n+   Name_While                          : constant Name_Id := N + 522;\n+   Name_With                           : constant Name_Id := N + 523;\n+   Name_Xor                            : constant Name_Id := N + 524;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                : constant Name_Id := N + 513;\n-   Name_Divide                         : constant Name_Id := N + 513;\n-   Name_Enclosing_Entity               : constant Name_Id := N + 514;\n-   Name_Exception_Information          : constant Name_Id := N + 515;\n-   Name_Exception_Message              : constant Name_Id := N + 516;\n-   Name_Exception_Name                 : constant Name_Id := N + 517;\n-   Name_File                           : constant Name_Id := N + 518;\n-   Name_Import_Address                 : constant Name_Id := N + 519;\n-   Name_Import_Largest_Value           : constant Name_Id := N + 520;\n-   Name_Import_Value                   : constant Name_Id := N + 521;\n-   Name_Is_Negative                    : constant Name_Id := N + 522;\n-   Name_Line                           : constant Name_Id := N + 523;\n-   Name_Rotate_Left                    : constant Name_Id := N + 524;\n-   Name_Rotate_Right                   : constant Name_Id := N + 525;\n-   Name_Shift_Left                     : constant Name_Id := N + 526;\n-   Name_Shift_Right                    : constant Name_Id := N + 527;\n-   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 528;\n-   Name_Source_Location                : constant Name_Id := N + 529;\n-   Name_Unchecked_Conversion           : constant Name_Id := N + 530;\n-   Name_Unchecked_Deallocation         : constant Name_Id := N + 531;\n-   Name_To_Pointer                     : constant Name_Id := N + 532;\n-   Last_Intrinsic_Name                 : constant Name_Id := N + 532;\n+   First_Intrinsic_Name                : constant Name_Id := N + 525;\n+   Name_Divide                         : constant Name_Id := N + 525;\n+   Name_Enclosing_Entity               : constant Name_Id := N + 526;\n+   Name_Exception_Information          : constant Name_Id := N + 527;\n+   Name_Exception_Message              : constant Name_Id := N + 528;\n+   Name_Exception_Name                 : constant Name_Id := N + 529;\n+   Name_File                           : constant Name_Id := N + 530;\n+   Name_Import_Address                 : constant Name_Id := N + 531;\n+   Name_Import_Largest_Value           : constant Name_Id := N + 532;\n+   Name_Import_Value                   : constant Name_Id := N + 533;\n+   Name_Is_Negative                    : constant Name_Id := N + 534;\n+   Name_Line                           : constant Name_Id := N + 535;\n+   Name_Rotate_Left                    : constant Name_Id := N + 536;\n+   Name_Rotate_Right                   : constant Name_Id := N + 537;\n+   Name_Shift_Left                     : constant Name_Id := N + 538;\n+   Name_Shift_Right                    : constant Name_Id := N + 539;\n+   Name_Shift_Right_Arithmetic         : constant Name_Id := N + 540;\n+   Name_Source_Location                : constant Name_Id := N + 541;\n+   Name_Unchecked_Conversion           : constant Name_Id := N + 542;\n+   Name_Unchecked_Deallocation         : constant Name_Id := N + 543;\n+   Name_To_Pointer                     : constant Name_Id := N + 544;\n+   Last_Intrinsic_Name                 : constant Name_Id := N + 544;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 533;\n-   Name_Abstract                       : constant Name_Id := N + 533;\n-   Name_Aliased                        : constant Name_Id := N + 534;\n-   Name_Protected                      : constant Name_Id := N + 535;\n-   Name_Until                          : constant Name_Id := N + 536;\n-   Name_Requeue                        : constant Name_Id := N + 537;\n-   Name_Tagged                         : constant Name_Id := N + 538;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 538;\n+   First_95_Reserved_Word              : constant Name_Id := N + 545;\n+   Name_Abstract                       : constant Name_Id := N + 545;\n+   Name_Aliased                        : constant Name_Id := N + 546;\n+   Name_Protected                      : constant Name_Id := N + 547;\n+   Name_Until                          : constant Name_Id := N + 548;\n+   Name_Requeue                        : constant Name_Id := N + 549;\n+   Name_Tagged                         : constant Name_Id := N + 550;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 550;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 539;\n+   Name_Raise_Exception                : constant Name_Id := N + 551;\n \n    --  Additional reserved words in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Binder                         : constant Name_Id := N + 540;\n-   Name_Body_Suffix                    : constant Name_Id := N + 541;\n-   Name_Builder                        : constant Name_Id := N + 542;\n-   Name_Compiler                       : constant Name_Id := N + 543;\n-   Name_Cross_Reference                : constant Name_Id := N + 544;\n-   Name_Default_Switches               : constant Name_Id := N + 545;\n-   Name_Exec_Dir                       : constant Name_Id := N + 546;\n-   Name_Executable                     : constant Name_Id := N + 547;\n-   Name_Executable_Suffix              : constant Name_Id := N + 548;\n-   Name_Extends                        : constant Name_Id := N + 549;\n-   Name_Finder                         : constant Name_Id := N + 550;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 551;\n-   Name_Gnatls                         : constant Name_Id := N + 552;\n-   Name_Gnatstub                       : constant Name_Id := N + 553;\n-   Name_Implementation                 : constant Name_Id := N + 554;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 555;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 556;\n-   Name_Languages                      : constant Name_Id := N + 557;\n-   Name_Library_Dir                    : constant Name_Id := N + 558;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 559;\n-   Name_Library_GCC                    : constant Name_Id := N + 560;\n-   Name_Library_Interface              : constant Name_Id := N + 561;\n-   Name_Library_Kind                   : constant Name_Id := N + 562;\n-   Name_Library_Name                   : constant Name_Id := N + 563;\n-   Name_Library_Options                : constant Name_Id := N + 564;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 565;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 566;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 567;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 568;\n-   Name_Library_Version                : constant Name_Id := N + 569;\n-   Name_Linker                         : constant Name_Id := N + 570;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 571;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 572;\n-   Name_Naming                         : constant Name_Id := N + 573;\n-   Name_Object_Dir                     : constant Name_Id := N + 574;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 575;\n-   Name_Project                        : constant Name_Id := N + 576;\n-   Name_Separate_Suffix                : constant Name_Id := N + 577;\n-   Name_Source_Dirs                    : constant Name_Id := N + 578;\n-   Name_Source_Files                   : constant Name_Id := N + 579;\n-   Name_Source_List_File               : constant Name_Id := N + 580;\n-   Name_Spec                           : constant Name_Id := N + 581;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 582;\n-   Name_Specification                  : constant Name_Id := N + 583;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 584;\n-   Name_Specification_Suffix           : constant Name_Id := N + 585;\n-   Name_Switches                       : constant Name_Id := N + 586;\n+   Name_Binder                         : constant Name_Id := N + 552;\n+   Name_Body_Suffix                    : constant Name_Id := N + 553;\n+   Name_Builder                        : constant Name_Id := N + 554;\n+   Name_Compiler                       : constant Name_Id := N + 555;\n+   Name_Cross_Reference                : constant Name_Id := N + 556;\n+   Name_Default_Switches               : constant Name_Id := N + 557;\n+   Name_Exec_Dir                       : constant Name_Id := N + 558;\n+   Name_Executable                     : constant Name_Id := N + 559;\n+   Name_Executable_Suffix              : constant Name_Id := N + 560;\n+   Name_Extends                        : constant Name_Id := N + 561;\n+   Name_Finder                         : constant Name_Id := N + 562;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 563;\n+   Name_Gnatls                         : constant Name_Id := N + 564;\n+   Name_Gnatstub                       : constant Name_Id := N + 565;\n+   Name_Implementation                 : constant Name_Id := N + 566;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 567;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 568;\n+   Name_Languages                      : constant Name_Id := N + 569;\n+   Name_Library_Dir                    : constant Name_Id := N + 570;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 571;\n+   Name_Library_GCC                    : constant Name_Id := N + 572;\n+   Name_Library_Interface              : constant Name_Id := N + 573;\n+   Name_Library_Kind                   : constant Name_Id := N + 574;\n+   Name_Library_Name                   : constant Name_Id := N + 575;\n+   Name_Library_Options                : constant Name_Id := N + 576;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 577;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 578;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 579;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 580;\n+   Name_Library_Version                : constant Name_Id := N + 581;\n+   Name_Linker                         : constant Name_Id := N + 582;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 583;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 584;\n+   Name_Naming                         : constant Name_Id := N + 585;\n+   Name_Object_Dir                     : constant Name_Id := N + 586;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 587;\n+   Name_Project                        : constant Name_Id := N + 588;\n+   Name_Separate_Suffix                : constant Name_Id := N + 589;\n+   Name_Source_Dirs                    : constant Name_Id := N + 590;\n+   Name_Source_Files                   : constant Name_Id := N + 591;\n+   Name_Source_List_File               : constant Name_Id := N + 592;\n+   Name_Spec                           : constant Name_Id := N + 593;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 594;\n+   Name_Specification                  : constant Name_Id := N + 595;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 596;\n+   Name_Specification_Suffix           : constant Name_Id := N + 597;\n+   Name_Switches                       : constant Name_Id := N + 598;\n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 587;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 599;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 587;\n+   Last_Predefined_Name                : constant Name_Id := N + 599;\n \n    subtype Any_Operator_Name is Name_Id range\n      First_Operator_Name .. Last_Operator_Name;"}, {"sha": "57b2fe0fdaf15bfbcb09212b4e22226cc3adfa73", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -693,14 +693,27 @@ package body Sprint is\n \n          when N_Access_Definition =>\n \n-            --  Ada 0Y (AI-231)\n+            --  Ada 0Y (AI-254)\n \n-            if Null_Exclusion_Present (Node) then\n-               Write_Str (\"not null \");\n-            end if;\n+            if Present (Access_To_Subprogram_Definition (Node)) then\n+               Sprint_Node (Access_To_Subprogram_Definition (Node));\n+            else\n+               --  Ada 0Y (AI-231)\n \n-            Write_Str_With_Col_Check_Sloc (\"access \");\n-            Sprint_Node (Subtype_Mark (Node));\n+               if Null_Exclusion_Present (Node) then\n+                  Write_Str (\"not null \");\n+               end if;\n+\n+               Write_Str_With_Col_Check_Sloc (\"access \");\n+\n+               if All_Present (Node) then\n+                  Write_Str (\"all \");\n+               elsif Constant_Present (Node) then\n+                  Write_Str (\"constant \");\n+               end if;\n+\n+               Sprint_Node (Subtype_Mark (Node));\n+            end if;\n \n          when N_Access_Function_Definition =>\n "}, {"sha": "03124a1481c88a84961d7996b54d3e7b1a828f55", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -551,6 +551,27 @@ package body Switch.M is\n \n             return;\n \n+         --  Processing for e switch\n+\n+         when 'e' =>\n+            Ptr := Ptr + 1;\n+\n+            if Ptr > Max then\n+               raise Bad_Switch;\n+            end if;\n+\n+            case Switch_Chars (Ptr) is\n+\n+               --  processing for eL switch\n+\n+               when 'L' =>\n+                  Ptr := Ptr + 1;\n+                  Follow_Links := True;\n+\n+               when others =>\n+                  raise Bad_Switch;\n+            end case;\n+\n          --  Processing for f switch\n \n          when 'f' =>"}, {"sha": "9c5b3f5f88313b063d41bb5dc3ed31296c5e3ced", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -2073,10 +2073,6 @@ tree_transform (Node_Id gnat_node)\n \n     case N_Label:\n       gnu_result = build_nt (LABEL_STMT, gnat_to_gnu (Identifier (gnat_node)));\n-      LABEL_STMT_FIRST_IN_EH (gnu_result)\n-\t=  (Present (Parent (gnat_node))\n-\t    && Nkind (Parent (gnat_node)) == N_Exception_Handler\n-\t    && First (Statements (Parent (gnat_node))) == gnat_node);\n       break;\n \n     case N_Null_Statement:\n@@ -2649,6 +2645,9 @@ tree_transform (Node_Id gnat_node)\n \n \tgnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n \n+\t/* ??? Temporarily do this to avoid GC throwing away outer stuff.  */\n+\tggc_push_context ();\n+\n \t/* Set the line number in the decl to correspond to that of\n \t   the body so that the line number notes are written\n \t   correctly.  */\n@@ -2769,15 +2768,12 @@ tree_transform (Node_Id gnat_node)\n \tmark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n \twrite_symbols = save_write_symbols;\n \tdebug_hooks = save_debug_hooks;\n+\tggc_pop_context ();\n       }\n       break;\n \n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n-\n-      if (type_annotate_only)\n-\tbreak;\n-\n       {\n \t/* The GCC node corresponding to the GNAT subprogram name.  This can\n \t   either be a FUNCTION_DECL node if we are dealing with a standard\n@@ -2792,6 +2788,7 @@ tree_transform (Node_Id gnat_node)\n \tNode_Id gnat_actual;\n \ttree gnu_actual_list = NULL_TREE;\n \ttree gnu_name_list = NULL_TREE;\n+\ttree gnu_before_list = NULL_TREE;\n \ttree gnu_after_list = NULL_TREE;\n \ttree gnu_subprog_call;\n \n@@ -2827,8 +2824,9 @@ tree_transform (Node_Id gnat_node)\n \t\t\t    build_call_raise (PE_Stubbed_Subprogram_Called));\n \t      }\n \t    else\n-\t      expand_expr_stmt\n-\t        (build_call_raise (PE_Stubbed_Subprogram_Called));\n+\t      gnu_result\n+\t\t= build_nt (EXPR_STMT,\n+\t\t\t    build_call_raise (PE_Stubbed_Subprogram_Called));\n \t    break;\n \t  }\n \n@@ -2920,10 +2918,15 @@ tree_transform (Node_Id gnat_node)\n \t\t      }\n \n \t\t    /* Set up to move the copy back to the original.  */\n-\t\t    gnu_after_list = tree_cons (gnu_copy, gnu_actual,\n-\t\t\t\t\t\tgnu_after_list);\n-\n-\t\t    gnu_name = gnu_actual;\n+\t\t    gnu_temp\n+\t\t      = build_nt (EXPR_STMT,\n+\t\t\t\t  build (MODIFY_EXPR, TREE_TYPE (gnu_copy),\n+\t\t\t\t\t gnu_copy, gnu_actual));\n+\n+\t\t    TREE_TYPE (gnu_temp) = void_type_node;\n+\t\t    TREE_SLOC (gnu_temp) = Sloc (gnat_actual);\n+\t\t    TREE_CHAIN (gnu_temp) = gnu_after_list;\n+\t\t    gnu_after_list = gnu_temp;\n \t\t  }\n \t      }\n \n@@ -3115,6 +3118,7 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t\t   gnu_result);\n \n \t    gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\t    break;\n \t  }\n \n \t/* If this is the case where the GNAT tree contains a procedure call\n@@ -3218,26 +3222,29 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t\t      gnu_result);\n \t\t    }\n \n-\t\t  set_lineno (gnat_node, 1);\n-\t\t  expand_expr_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t\t     gnu_actual, gnu_result));\n+\t\t  gnu_result\n+\t\t    = build_nt (EXPR_STMT,\n+\t\t\t\tbuild_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\t\t gnu_actual, gnu_result));\n+\t\t  TREE_TYPE (gnu_result) = void_type_node;\n+\t\t  TREE_SLOC (gnu_result) = Sloc (gnat_actual);\n+\t\t  TREE_CHAIN (gnu_result) = gnu_before_list;\n+\t\t  gnu_before_list = gnu_result;\n \t\t  scalar_return_list = TREE_CHAIN (scalar_return_list);\n \t\t  gnu_name_list = TREE_CHAIN (gnu_name_list);\n \t\t}\n \t  }\n \telse\n \t  {\n-\t    set_lineno (gnat_node, 1);\n-\t    expand_expr_stmt (gnu_subprog_call);\n+\t    gnu_before_list = build_nt (EXPR_STMT, gnu_subprog_call);\n+\t    TREE_TYPE (gnu_before_list) = void_type_node;\n+\t    TREE_SLOC (gnu_before_list) = Sloc (gnat_node);\n \t  }\n \n-\t/* Handle anything we need to assign back.  */\n-\tfor (gnu_expr = gnu_after_list;\n-\t     gnu_expr;\n-\t     gnu_expr = TREE_CHAIN (gnu_expr))\n-\t  expand_expr_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t     TREE_PURPOSE (gnu_expr),\n-\t\t\t\t\t     TREE_VALUE (gnu_expr)));\n+\tgnu_result = chainon (nreverse (gnu_before_list),\n+\t\t\t      nreverse (gnu_after_list));\n+\tif (TREE_CHAIN (gnu_result))\n+\t  gnu_result = build_nt (BLOCK_STMT, gnu_result);\n       }\n       break;\n \n@@ -3895,22 +3902,10 @@ tree_transform (Node_Id gnat_node)\n \t  gnu_input_list = nreverse (gnu_input_list);\n \t  gnu_output_list = nreverse (gnu_output_list);\n \t  gnu_orig_out_list = nreverse (gnu_orig_out_list);\n-\t  expand_asm_operands (gnu_template, gnu_output_list, gnu_input_list,\n-\t\t\t       gnu_clobber_list, Is_Asm_Volatile (gnat_node),\n-\t\t\t       input_location);\n-\n-\t  /* Copy all the intermediate outputs into the specified outputs.  */\n-\t  for (; gnu_output_list;\n-\t       (gnu_output_list = TREE_CHAIN (gnu_output_list),\n-\t\tgnu_orig_out_list = TREE_CHAIN (gnu_orig_out_list)))\n-\t    if (TREE_VALUE (gnu_orig_out_list) != TREE_VALUE (gnu_output_list))\n-\t      {\n-\t\texpand_expr_stmt\n-\t\t  (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t    TREE_VALUE (gnu_orig_out_list),\n-\t\t\t\t    TREE_VALUE (gnu_output_list)));\n-\t\tfree_temp_slots ();\n-\t      }\n+\t  gnu_result = build_nt (ASM_STMT, gnu_template, gnu_output_list,\n+\t\t\t\t gnu_orig_out_list, gnu_input_list,\n+\t\t\t\t gnu_clobber_list);\n+\t  TREE_THIS_VOLATILE (gnu_result) = Is_Asm_Volatile (gnat_node);\n \t}\n       break;\n \n@@ -3974,11 +3969,12 @@ tree_transform (Node_Id gnat_node)\n \t\t\t\t\t gnu_ptr, gnu_byte_offset);\n \t    }\n \n-\t  set_lineno (gnat_node, 1);\n-\t  expand_expr_stmt\n-\t    (build_call_alloc_dealloc (gnu_ptr, gnu_obj_size, align,\n-\t\t\t\t       Procedure_To_Call (gnat_node),\n-\t\t\t\t       Storage_Pool (gnat_node), gnat_node));\n+\t  gnu_result\n+\t    = build_nt (EXPR_STMT,\n+\t\t\tbuild_call_alloc_dealloc\n+\t\t\t(gnu_ptr, gnu_obj_size, align,\n+\t\t\t Procedure_To_Call (gnat_node),\n+\t\t\t Storage_Pool (gnat_node), gnat_node));\n \t}\n       break;\n \n@@ -3997,15 +3993,14 @@ tree_transform (Node_Id gnat_node)\n \t is one.  */\n       if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n \t{\n-\t  set_lineno (gnat_node, 1);\n+\t  gnu_result = build_nt (EXPR_STMT, gnu_result);\n+\t  TREE_TYPE (gnu_result) = void_type_node;\n+\t  TREE_SLOC (gnu_result) = Sloc (gnat_node);\n \n \t  if (Present (Condition (gnat_node)))\n-\t    expand_start_cond (gnat_to_gnu (Condition (gnat_node)), 0);\n-\n-\t  expand_expr_stmt (gnu_result);\n-\t  if (Present (Condition (gnat_node)))\n-\t    expand_end_cond ();\n-\t  gnu_result = error_mark_node;\n+\t    gnu_result = build_nt (IF_STMT,\n+\t\t\t\t   gnat_to_gnu (Condition (gnat_node)),\n+\t\t\t\t   gnu_result, NULL_TREE, NULL_TREE);\n \t}\n       else\n \tgnu_result = build1 (NULL_EXPR, gnu_result_type, gnu_result);\n@@ -4235,7 +4230,7 @@ make_expr_stmt_from_rtl (rtx insns, Node_Id gnat_node)\n void\n gnat_expand_stmt (tree gnu_stmt)\n {\n-  tree gnu_elmt;\n+  tree gnu_elmt, gnu_elmt_2;\n \n   if (TREE_SLOC (gnu_stmt))\n     set_lineno_from_sloc (TREE_SLOC (gnu_stmt), 1);\n@@ -4283,11 +4278,6 @@ gnat_expand_stmt (tree gnu_stmt)\n \n     case LABEL_STMT:\n       expand_label (LABEL_STMT_LABEL (gnu_stmt));\n-      if (LABEL_STMT_FIRST_IN_EH (gnu_stmt))\n-\tnonlocal_goto_handler_labels\n-\t  = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t       label_rtx (LABEL_STMT_LABEL (gnu_stmt)),\n-\t\t\t       nonlocal_goto_handler_labels);\n       break;\n \n     case RETURN_STMT:\n@@ -4299,6 +4289,29 @@ gnat_expand_stmt (tree gnu_stmt)\n \texpand_null_return ();\n       break;\n \n+    case ASM_STMT:\n+      expand_asm_operands (ASM_STMT_TEMPLATE (gnu_stmt),\n+\t\t\t   ASM_STMT_OUTPUT (gnu_stmt),\n+\t\t\t   ASM_STMT_INPUT (gnu_stmt),\n+\t\t\t   ASM_STMT_CLOBBER (gnu_stmt),\n+\t\t\t   TREE_THIS_VOLATILE (gnu_stmt), input_location);\n+\n+      /* Copy all the intermediate outputs into the specified outputs.  */\n+      for ((gnu_elmt = ASM_STMT_OUTPUT (gnu_stmt),\n+\t    gnu_elmt_2 = ASM_STMT_ORIG_OUT (gnu_stmt));\n+\t   gnu_elmt;\n+\t   (gnu_elmt = TREE_CHAIN (gnu_elmt),\n+\t    gnu_elmt_2 = TREE_CHAIN (gnu_elmt_2)))\n+\tif (TREE_VALUE (gnu_elmt) != TREE_VALUE (gnu_elmt_2))\n+\t  {\n+\t    expand_expr_stmt\n+\t      (build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\tTREE_VALUE (gnu_elmt_2),\n+\t\t\t\tTREE_VALUE (gnu_elmt)));\n+\t    free_temp_slots ();\n+\t  }\n+      break;\n+\n     default:\n       abort ();\n     }"}, {"sha": "75a2acbc16d3c9c2f1eec3ad9469c0d8ab74d4bc", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -785,6 +785,7 @@ pragma Preelaborate (Types);\n      PE_Potentially_Blocking_Operation,\n      PE_Stubbed_Subprogram_Called,\n      PE_Unchecked_Union_Restriction,\n+     PE_Illegal_RACW_E_4_18,\n \n      SE_Empty_Storage_Pool,\n      SE_Explicit_Raise,\n@@ -798,7 +799,7 @@ pragma Preelaborate (Types);\n \n    subtype RT_PE_Exceptions is RT_Exception_Code range\n      PE_Access_Before_Elaboration ..\n-     PE_Unchecked_Union_Restriction;\n+     PE_Illegal_RACW_E_4_18;\n \n    subtype RT_SE_Exceptions is RT_Exception_Code range\n      SE_Empty_Storage_Pool .."}, {"sha": "b4c4eb4419fee862885423dcdbbd8c593726ee37", "filename": "gcc/ada/types.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -357,10 +357,11 @@ typedef Int Mechanism_Type;\n #define PE_Potentially_Blocking_Operation  21\n #define PE_Stubbed_Subprogram_Called       22\n #define PE_Unchecked_Union_Restriction     23\n-#define SE_Empty_Storage_Pool              24\n-#define SE_Explicit_Raise                  25\n-#define SE_Infinite_Recursion              26\n-#define SE_Object_Too_Large                27\n-#define SE_Restriction_Violation           28\n-\n-#define LAST_REASON_CODE                   28\n+#define PE_Illegal_RACW_E_4_18             24\n+#define SE_Empty_Storage_Pool              25\n+#define SE_Explicit_Raise                  26\n+#define SE_Infinite_Recursion              27\n+#define SE_Object_Too_Large                28\n+#define SE_Restriction_Violation           29\n+\n+#define LAST_REASON_CODE                   29"}, {"sha": "ac6e1628854dd5b2436e26cc9324c551e6443e11", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -310,7 +310,10 @@ poplevel (int keep, int reverse, int functionbody)\n \t&& DECL_INITIAL (decl_node) != 0)\n       {\n \tpush_function_context ();\n+\t/* ??? This is temporary.  */\n+\tggc_push_context ();\n \toutput_inline_function (decl_node);\n+\tggc_pop_context ();\n \tpop_function_context ();\n       }\n "}, {"sha": "5882d094b5db88448c1825a0ef20b6a9f1d9f8ff", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7324bf49ceb4aaca385ae0c32095901b96a2c969/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=7324bf49ceb4aaca385ae0c32095901b96a2c969", "patch": "@@ -1225,9 +1225,12 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t}\n \n       if (TYPE_FAT_POINTER_P (type))\n-\tresult = build1 (UNCONSTRAINED_ARRAY_REF,\n-\t\t\t TYPE_UNCONSTRAINED_ARRAY (type), operand);\n-\n+\t{\n+\t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n+\t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n+\t  TREE_READONLY (result) = TREE_STATIC (result)\n+\t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n+\t}\n       else if (TREE_CODE (operand) == ADDR_EXPR)\n \tresult = TREE_OPERAND (operand, 0);\n "}]}