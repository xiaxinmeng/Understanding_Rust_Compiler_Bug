{"sha": "c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyMDYyMzVmYmJiODVkNWNjZjc1NDcyZWY5ZWM2NjBiYTJhODllNw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-01-31T02:48:44Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2002-01-31T02:48:44Z"}, "message": "Initial revision\n\nFrom-SVN: r49359", "tree": {"sha": "0eaa8ae046638dfd9791683679211ae4812a9fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eaa8ae046638dfd9791683679211ae4812a9fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/comments", "author": null, "committer": null, "parents": [{"sha": "f5d09ce7478b854fd1869a70841f8650a9a39b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d09ce7478b854fd1869a70841f8650a9a39b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d09ce7478b854fd1869a70841f8650a9a39b4b"}], "stats": {"total": 589, "additions": 589, "deletions": 0}, "files": [{"sha": "01ab738f2f2316d57d01f86e94a956932aa3b9d8", "filename": "boehm-gc/backgraph.c", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fbackgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fbackgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackgraph.c?ref=c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "patch": "@@ -0,0 +1,447 @@\n+/*\n+ * Copyright (c) 2001 by Hewlett-Packard Company. All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ */\n+\n+/*\n+ * This implements a full, though not well-tuned, representation of the\n+ * backwards points-to graph.  This is used to test for non-GC-robust\n+ * data structures; the code is not used during normal garbage collection.\n+ *\n+ * One restriction is that we drop all back-edges from nodes with very\n+ * high in-degree, and simply add them add them to a list of such\n+ * nodes.  They are then treated as permanent roots.  Id this by itself\n+ * doesn't introduce a space leak, then such nodes can't contribute to\n+ * a growing space leak.\n+ */\n+\n+#ifdef MAKE_BACK_GRAPH\n+\n+#define MAX_IN\t10\t/* Maximum in-degree we handle directly */\n+\n+#include \"private/dbg_mlc.h\"\n+#include <unistd.h>\n+\n+#if !defined(DBG_HDRS_ALL) || (ALIGNMENT != CPP_WORDSZ/8) || !defined(UNIX_LIKE)\n+# error Configuration doesnt support MAKE_BACK_GRAPH\n+#endif\n+\n+/* We store single back pointers directly in the object's oh_bg_ptr field.   */\n+/* If there is more than one ptr to an object, we store q | FLAG_MANY, \t     */\n+/* where q is a pointer to a back_edges object.\t\t\t\t     */\n+/* Every once in a while we use a back_edges object even for a single\t     */\n+/* pointer, since we need the other fields in the back_edges structure to    */\n+/* be present in some fraction of the objects.  Otherwise we get serious     */\n+/* performance issues.\t\t\t\t\t\t\t     */\n+#define FLAG_MANY 2\n+\n+typedef struct back_edges_struct {\n+  word n_edges;\t/* Number of edges, including those in continuation\t*/\n+  \t\t/* structures.\t\t\t\t\t\t*/\n+  unsigned short flags;\n+#\tdefine RETAIN 1\t/* Directly points to a reachable object;\t*/\n+  \t\t\t/* retain for next GC.\t\t\t\t*/\n+  unsigned short height_gc_no;\n+  \t\t/* If height > 0, then the GC_gc_no value when it\t*/\n+  \t\t/* was computed.  If it was computed this cycle, then\t*/\n+  \t\t/* it is current.  If it was computed during the\t*/\n+  \t\t/* last cycle, then it represents the old height,\t*/\n+  \t\t/* which is only saved for live objects referenced by\t*/\n+  \t\t/* dead ones.  This may grow due to refs from newly\t*/\n+\t\t/* dead objects.\t\t\t\t        */\n+  signed_word height;\n+  \t\t/* Longest path through unreachable nodes to this node\t*/\n+  \t\t/* that we found using depth first search.\t\t*/\n+  \n+#   define HEIGHT_UNKNOWN ((signed_word)(-2))\n+#   define HEIGHT_IN_PROGRESS ((signed_word)(-1))\n+  ptr_t edges[MAX_IN];\n+  struct back_edges_struct *cont;\n+  \t\t/* Pointer to continuation structure; we use only the\t*/\n+  \t\t/* edges field in the continuation.\t\t\t*/\n+  \t\t/* also used as free list link.\t\t\t\t*/\n+} back_edges;\n+\n+/* Allocate a new back edge structure.  Should be more sophisticated\t*/\n+/* if this were production code.\t\t\t\t\t*/\n+#define MAX_BACK_EDGE_STRUCTS 100000\n+static back_edges *back_edge_space = 0;\n+int GC_n_back_edge_structs = 0;\t/* Serves as pointer to never used\t*/\n+\t\t\t\t/* back_edges space.\t\t\t*/\n+static back_edges *avail_back_edges = 0;\n+\t\t\t\t/* Pointer to free list of deallocated\t*/\n+\t\t\t\t/* back_edges structures.\t\t*/\n+\n+static back_edges * new_back_edges(void)\n+{\n+  if (0 == back_edge_space) {\n+    back_edge_space = (back_edges *)\n+\t    \t\tsbrk(MAX_BACK_EDGE_STRUCTS*sizeof(back_edges));\n+  }\n+  if (0 != avail_back_edges) {\n+    back_edges * result = avail_back_edges;\n+    avail_back_edges = result -> cont;\n+    result -> cont = 0;\n+    return result;\n+  }\n+  if (GC_n_back_edge_structs >= MAX_BACK_EDGE_STRUCTS - 1) {\n+    ABORT(\"needed too much space for back edges: adjust \"\n+\t  \"MAX_BACK_EDGE_STRUCTS\");\n+  }\n+  return back_edge_space + (GC_n_back_edge_structs++);\n+}\n+\n+/* Deallocate p and its associated continuation structures.\t*/\n+static void deallocate_back_edges(back_edges *p)\n+{\n+   back_edges *last = p;\n+\n+   while (0 != last -> cont) last = last -> cont;\n+   last -> cont = avail_back_edges;\n+   avail_back_edges = p;\n+}\n+\n+/* Table of objects that are currently on the depth-first search\t*/\n+/* stack.  Only objects with in-degree one are in this table.\t\t*/\n+/* Other objects are identified using HEIGHT_IN_PROGRESS.\t\t*/\n+/* This data structure NEEDS IMPROVEMENT.\t\t\t\t*/\n+#define MAX_IN_PROGRESS 10000\n+static ptr_t * in_progress_space = 0;\n+static int n_in_progress = 0;\n+\n+static void push_in_progress(ptr_t p)\n+{\n+  if (in_progress_space == 0)\n+      in_progress_space = sbrk(MAX_IN_PROGRESS * sizeof(ptr_t));\n+  if (n_in_progress == MAX_IN_PROGRESS)\n+      ABORT(\"Exceeded MAX_IN_PROGRESS\");\n+  in_progress_space[n_in_progress++] = p;\n+}\n+\n+static GC_bool is_in_progress(ptr_t p)\n+{\n+  int i;\n+  for (i = 0; i < n_in_progress; ++i) {\n+    if (in_progress_space[i] == p) return TRUE;\n+  }\n+  return FALSE;\n+}\n+\n+static void pop_in_progress(ptr_t p)\n+{\n+  --n_in_progress;\n+  GC_ASSERT(in_progress_space[n_in_progress] == p);\n+}\n+\n+#define GET_OH_BG_PTR(p) \\\n+\t\t(ptr_t)REVEAL_POINTER(((oh *)(p)) -> oh_bg_ptr)\n+#define SET_OH_BG_PTR(p,q) (((oh *)(p)) -> oh_bg_ptr) = HIDE_POINTER(q)\n+\n+/* Execute s once for each predecessor q of p in the points-to graph. \t*/\n+/* s should be a bracketed statement.  We declare q.\t\t\t*/\n+#define FOR_EACH_PRED(q, p, s) \\\n+  { \\\n+    ptr_t q = GET_OH_BG_PTR(p); \\\n+    if (!((word)q & FLAG_MANY)) { \\\n+      if (q && !((word)q & 1)) s \\\n+\t      /* !((word)q & 1) checks for a misnterpreted freelist link */ \\\n+    } else { \\\n+      back_edges *orig_be_ = (back_edges *)((word)q & ~FLAG_MANY); \\\n+      back_edges *be_ = orig_be_; \\\n+      int total_, local_; \\\n+      int n_edges_ = be_ -> n_edges; \\\n+      for (total_ = 0, local_ = 0; total_ < n_edges_; ++local_, ++total_) { \\\n+\t  if (local_ == MAX_IN) { \\\n+\t      be_ = be_ -> cont; \\\n+\t      local_ = 0; \\\n+\t  } \\\n+\t  q = be_ -> edges[local_]; s \\\n+      } \\\n+    } \\\n+  }\n+\n+/* Ensure that p has a back_edges structure associated with it.\t*/\n+static void ensure_struct(ptr_t p)\n+{\n+  ptr_t old_back_ptr = GET_OH_BG_PTR(p);\n+\n+  if (!((word)old_back_ptr & FLAG_MANY)) {\n+    back_edges *be = new_back_edges();\n+    be -> flags = 0;\n+    if (0 == old_back_ptr) {\n+      be -> n_edges = 0;\n+    } else {\n+      be -> n_edges = 1;\n+      be -> edges[0] = old_back_ptr;\n+    }\n+    be -> height = HEIGHT_UNKNOWN;\n+    be -> height_gc_no = GC_gc_no - 1;\n+    GC_ASSERT(be >= back_edge_space);\n+    SET_OH_BG_PTR(p, (word)be | FLAG_MANY);\n+  }\n+}\n+\n+/* Add the (forward) edge from p to q to the backward graph.  Both p\t*/\n+/* q are pointers to the object base, i.e. pointers to an oh.\t\t*/\n+static void add_edge(ptr_t p,  ptr_t q)\n+{\n+    ptr_t old_back_ptr = GET_OH_BG_PTR(q);\n+    back_edges * be, *be_cont;\n+    word i;\n+    static unsigned random_number = 13;\n+#   define GOT_LUCKY_NUMBER (((++random_number) & 0x7f) == 0)\n+      /* A not very random number we use to occasionally allocate a\t*/\n+      /* back_edges structure even for a single backward edge.  This\t*/\n+      /* prevents us from repeatedly tracing back through very long\t*/\n+      /* chains, since we will have some place to store height and\t*/\n+      /* in_progress flags along the way.\t\t\t\t*/\n+\n+    GC_ASSERT(p == GC_base(p) && q == GC_base(q));\n+    if (!GC_HAS_DEBUG_INFO(q) || !GC_HAS_DEBUG_INFO(p)) {\n+      /* This is really a misinterpreted free list link, since we saw */\n+      /* a pointer to a free list.  Dont overwrite it!\t\t      */\n+      return;\n+    }\n+    if (0 == old_back_ptr) {\n+\tSET_OH_BG_PTR(q, p);\n+\tif (GOT_LUCKY_NUMBER) ensure_struct(q);\n+\treturn;\n+    }\n+    /* Check whether it was already in the list of predecessors. */\n+      FOR_EACH_PRED(pred, q, { if (p == pred) return; });\n+    ensure_struct(q);\n+    old_back_ptr = GET_OH_BG_PTR(q);\n+    be = (back_edges *)((word)old_back_ptr & ~FLAG_MANY);\n+    for (i = be -> n_edges, be_cont = be; i > MAX_IN;\n+\tbe_cont = be_cont -> cont, i -= MAX_IN) {}\n+    if (i == MAX_IN) {\n+\tbe_cont -> cont = new_back_edges();\n+\tbe_cont = be_cont -> cont;\n+\ti = 0;\n+    }\n+    be_cont -> edges[i] = p;\n+    be -> n_edges++;\n+    if (be -> n_edges == 100) {\n+#       if 0\n+\t  if (GC_print_stats) {\n+\t    GC_err_printf0(\"The following object has in-degree >= 100:\\n\");\n+\t    GC_print_heap_obj(q);\n+\t  }\n+#\tendif\n+    }\n+}\n+\n+typedef void (*per_object_func)(ptr_t p, word n_words, word gc_descr);\n+\n+static void per_object_helper(struct hblk *h, word fn)\n+{\n+  hdr * hhdr = HDR(h);\n+  word sz = hhdr -> hb_sz;\n+  word descr = hhdr -> hb_descr;\n+  per_object_func f = (per_object_func)fn;\n+  int i = 0;\n+\n+  do {\n+    f((ptr_t)(h -> hb_body + i), sz, descr);\n+    i += sz;\n+  } while (i + sz <= BYTES_TO_WORDS(HBLKSIZE));\n+}\n+\n+void GC_apply_to_each_object(per_object_func f)\n+{\n+  GC_apply_to_all_blocks(per_object_helper, (word)f);\n+}\n+\n+static void reset_back_edge(ptr_t p, word n_words, word gc_descr)\n+{\n+  /* Skip any free list links, or dropped blocks */\n+  if (GC_HAS_DEBUG_INFO(p)) {\n+    ptr_t old_back_ptr = GET_OH_BG_PTR(p);\n+    if ((word)old_back_ptr & FLAG_MANY) {\n+      back_edges *be = (back_edges *)((word)old_back_ptr & ~FLAG_MANY);\n+      if (!(be -> flags & RETAIN)) {\n+\tdeallocate_back_edges(be);\n+        SET_OH_BG_PTR(p, 0); \n+      } else {\n+        word *currentp;\n+\n+\tGC_ASSERT(GC_is_marked(p));\n+\n+\t/* Back edges may point to objects that will not be retained. \t*/\n+\t/* Delete them for now, but remember the height.\t\t*/\n+\t/* Some will be added back at next GC.\t\t\t\t*/\n+\t  be -> n_edges = 0;\n+\t  if (0 != be -> cont) {\n+\t    deallocate_back_edges(be -> cont);\n+\t    be -> cont = 0;\n+\t  }\n+\n+\tGC_ASSERT(GC_is_marked(p));\n+\n+\t/* We only retain things for one GC cycle at a time.\t\t*/\n+\t  be -> flags &= ~RETAIN;\n+      }\n+    } else /* Simple back pointer */ {\n+      /* Clear to avoid dangling pointer. */\n+      SET_OH_BG_PTR(p, 0);\n+    }\n+  }\n+}\n+\n+static void add_back_edges(ptr_t p, word n_words, word gc_descr)\n+{\n+  word *currentp = (word *)(p + sizeof(oh));\n+\n+  /* For now, fix up non-length descriptors conservatively.\t*/\n+    if((gc_descr & GC_DS_TAGS) != GC_DS_LENGTH) {\n+      gc_descr = WORDS_TO_BYTES(n_words);\n+    }\n+  while (currentp < (word *)(p + gc_descr)) {\n+    word current = *currentp++;\n+    if (current >= (word)GC_least_plausible_heap_addr && \n+\tcurrent <= (word)GC_greatest_plausible_heap_addr) {\n+       ptr_t target = GC_base((GC_PTR)current);\n+       if (0 != target) {\n+\t add_edge(p, target);\n+       }\n+    }\n+  }\n+}\n+\n+/* Rebuild the reprentation of the backward reachability graph.\t*/\n+/* Does not examine mark bits.  Can be called before GC.\t*/\n+void GC_build_back_graph(void)\n+{\n+  GC_apply_to_each_object(add_back_edges);\n+}\n+\n+/* Return an approximation to the length of the longest simple path\t*/\n+/* through unreachable objects to p.  We refer to this as the height\t*/\n+/* of p.\t\t\t\t\t\t\t\t*/\n+static word backwards_height(ptr_t p)\n+{\n+  word result;\n+  ptr_t back_ptr = GET_OH_BG_PTR(p);\n+  back_edges *be;\n+\n+  if (0 == back_ptr) return 1;\n+  if (!((word)back_ptr & FLAG_MANY)) {\n+    if (is_in_progress(p)) return 0;  /* DFS back edge, i.e. we followed  */\n+    \t\t\t\t      /* an edge to an object already\t  */\n+    \t\t\t\t      /* on our stack: ignore\t\t  */\n+    push_in_progress(p);\n+    result = backwards_height(back_ptr)+1;\n+    pop_in_progress(p);\n+    return result;\n+  }\n+  be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n+  if (be -> height >= 0 && be -> height_gc_no == GC_gc_no)\n+      return be -> height;\n+  /* Ignore back edges in DFS */\n+    if (be -> height == HEIGHT_IN_PROGRESS) return 0;\n+  result = (be -> height > 0? be -> height : 1);\n+  be -> height = HEIGHT_IN_PROGRESS;\n+  FOR_EACH_PRED(q, p, {\n+    word this_height;\n+    if (GC_is_marked(q) && !(FLAG_MANY & (word)GET_OH_BG_PTR(p))) {\n+      if (GC_print_stats)\n+\t  GC_printf2(\"Found bogus pointer from 0x%lx to 0x%lx\\n\", q, p);\n+\t/* Reachable object \"points to\" unreachable one.\t\t*/\n+\t/* Could be caused by our lax treatment of GC descriptors.\t*/\n+      this_height = 1;\n+    } else {\n+        this_height = backwards_height(q);\n+    }\n+    if (this_height >= result) result = this_height + 1;\n+  });\n+  be -> height = result;\n+  be -> height_gc_no = GC_gc_no;\n+  return result;\n+}\n+\n+word GC_max_height;\n+ptr_t GC_deepest_obj;\n+\n+/* Compute the maximum height of every unreachable predecessor p of  a \t*/\n+/* reachable object.  Arrange to save the heights of all such objects p\t*/\n+/* so that they can be used in calculating the height of objects in the\t*/\n+/* next GC.\t\t\t\t\t\t\t\t*/\n+/* Set GC_max_height to be the maximum height we encounter, and \t*/\n+/* GC_deepest_obj to be the corresponding object.\t\t\t*/\n+static void update_max_height(ptr_t p, word n_words, word gc_descr)\n+{\n+  if (GC_is_marked(p) && GC_HAS_DEBUG_INFO(p)) {\n+    int i;\n+    word p_height = 0;\n+    ptr_t p_deepest_obj = 0;\n+    ptr_t back_ptr;\n+    back_edges *be = 0;\n+\n+    /* If we remembered a height last time, use it as a minimum.\t*/\n+    /* It may have increased due to newly unreachable chains pointing\t*/\n+    /* to p, but it can't have decreased.\t\t\t\t*/\n+    back_ptr = GET_OH_BG_PTR(p);\n+    if (0 != back_ptr && ((word)back_ptr & FLAG_MANY)) {\n+      be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n+      if (be -> height != HEIGHT_UNKNOWN) p_height = be -> height;\n+    }\n+    FOR_EACH_PRED(q, p, {\n+      if (!GC_is_marked(q) && GC_HAS_DEBUG_INFO(q)) {\n+        word q_height;\n+\n+        q_height = backwards_height(q);\n+\tif (q_height > p_height) {\n+\t  p_height = q_height;\n+\t  p_deepest_obj = q;\n+\t}\n+      }\n+    });\n+    if (p_height > 0) {\n+      /* Remember the height for next time. */\n+\tif (be == 0) {\n+    \t  ensure_struct(p);\n+    \t  back_ptr = GET_OH_BG_PTR(p);\n+  \t  be = (back_edges *)((word)back_ptr & ~FLAG_MANY);\n+\t}\n+\tbe -> flags |= RETAIN;\n+\tbe -> height = p_height;\n+\tbe -> height_gc_no = GC_gc_no;\n+    }\n+    if (p_height > GC_max_height) {\n+\tGC_max_height = p_height;\n+\tGC_deepest_obj = p_deepest_obj;\n+    }\n+  }\n+}\n+\n+void GC_traverse_back_graph(void)\n+{\n+  static word max_max_height = 0;\n+  GC_max_height = 0;\n+  GC_apply_to_each_object(update_max_height);\n+  GC_printf2(\"Maximum backwards height of reachable objects at GC %lu is %ld\\n\",\n+\t     (unsigned long) GC_gc_no, GC_max_height);\n+  if (GC_max_height > max_max_height) {\n+    max_max_height = GC_max_height;\n+    GC_printf0(\"The following unreachable object is last in a longest chain \"\n+\t       \"of unreachable objects:\\n\");\n+    GC_print_heap_obj(GC_deepest_obj);\n+  }\n+  if (GC_print_stats) {\n+    GC_printf1(\"Needed max total of %ld back-edge structs\\n\",\n+\t       GC_n_back_edge_structs);\n+  }\n+  GC_apply_to_each_object(reset_back_edge);\n+  GC_deepest_obj = 0;\n+}\n+\n+#endif /* MAKE_BACK_GRAPH */"}, {"sha": "bced2438285963fa4f871c92b8e98e22212f21b8", "filename": "boehm-gc/doc/README.ews4800", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fdoc%2FREADME.ews4800", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fdoc%2FREADME.ews4800", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.ews4800?ref=c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "patch": "@@ -0,0 +1,75 @@\n+GC on EWS4800\n+-------------\n+\n+1. About EWS4800\n+   EWS4800 is 32bit/64bit workstation.\n+\n+     Vender: NEC Corporation\n+     OS: UX/4800 R9.* - R13.* (SystemV R4.2)\n+     CPU: R4000, R4400, R10000 (MIPS)\n+\n+2. Compiler\n+\n+ 32bit:\n+   Use ANSI C compiler.\n+     CC = /usr/abiccs/bin/cc\n+\n+ 64bit:\n+   Use 64bit ANSI C compiler.\n+     CC = /usr/ccs64/bin/cc\n+     AR = /usr/ccs64/bin/ar\n+\n+3. ELF file format\n+   *** Caution: The following infomation is empirical. ***\n+\n+ 32bit:\n+   ELF file has an unique format. (See a.out(4) and end(3C).)\n+\n+     &_start\n+        :      text segment\n+     &etext\n+     DATASTART\n+        :      data segment (initialized)\n+     &edata\n+     DATASTART2\n+        :      data segment (uninitialized)\n+     &end\n+\n+   Here, DATASTART and DATASTART2 are macros of GC, and are defined as\n+   the following equations. (See include/private/gcconfig.h.)\n+   The algorithm for DATASTART is similar with the function\n+   GC_SysVGetDataStart() in os_dep.c.\n+\n+     DATASTART  = ((&etext + 0x3ffff) & ~0x3ffff) + (&etext & 0xffff)\n+\n+    Dynamically linked:\n+     DATASTART2 = (&_gp + 0x8000 + 0x3ffff) & ~0x3ffff\n+\n+    Statically linked:\n+     DATASTART2 = &edata\n+\n+   GC has to check addresses both between DATASTART and &edata, and\n+   between DATASTART2 and &end. If a program accesses between &etext\n+   and DATASTART, or between &edata and DATASTART2, the segmentation\n+   error occurs and the program stops.\n+\n+   If a program is statically linked, there is not a gap between\n+   &edata and DATASTART2. The global symbol &_DYNAMIC_LINKING is used\n+   for the detection.\n+\n+ 64bit:\n+   ELF file has a simple format. (See end(3C).)\n+\n+     _ftext\n+        :      text segment\n+     _etext\n+     _fdata = DATASTART\n+        :      data segment (initialized)\n+     _edata\n+     _fbss\n+        :      data segment (uninitialized)\n+     _end = DATAEND\n+\n+--\n+Hironori SAKAMOTO <hsaka@mth.biglobe.ne.jp>\n+"}, {"sha": "9f3a4b0a99d8e82b9d428ddcd2d33bef985c1561", "filename": "boehm-gc/sparc_mach_dep.S", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fsparc_mach_dep.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2206235fbbb85d5ccf75472ef9ec660ba2a89e7/boehm-gc%2Fsparc_mach_dep.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.S?ref=c2206235fbbb85d5ccf75472ef9ec660ba2a89e7", "patch": "@@ -0,0 +1,67 @@\n+!\tSPARCompiler 3.0 and later apparently no longer handles\n+!\tasm outside functions.  So we need a separate .s file\n+!\tThis is only set up for SunOS 5, not SunOS 4.\n+!\tAssumes this is called before the stack contents are\n+!\texamined.\n+\n+\t.seg \t\"text\"\n+\t.globl\tGC_save_regs_in_stack\n+\t.globl \tGC_push_regs\n+GC_save_regs_in_stack:\n+GC_push_regs:\n+#if defined(__arch64__) || defined(__sparcv9)\n+\tsave\t%sp,-128,%sp\n+\tflushw\n+\tret\n+\t  restore %sp,2047+128,%o0\n+#else /* 32 bit SPARC */\n+\tta\t0x3   ! ST_FLUSH_WINDOWS\n+\tmov\t%sp,%o0\n+\tretl\n+\tnop\n+#endif /* 32 bit SPARC */\n+.GC_save_regs_in_stack_end:\n+\t.size GC_save_regs_in_stack,.GC_save_regs_in_stack_end-GC_save_regs_in_stack\n+\t\n+\n+\t.globl\tGC_clear_stack_inner\n+GC_clear_stack_inner:\n+#if defined(__arch64__) || defined(__sparcv9)\n+\tmov %sp,%o2\t\t! Save sp\n+\tadd %sp,2047-8,%o3\t! p = sp+bias-8\n+\tadd %o1,-2047-192,%sp\t! Move sp out of the way,\n+  \t\t\t\t! so that traps still work.\n+  \t\t\t\t! Includes some extra words\n+  \t\t\t\t! so we can be sloppy below.\n+loop:\n+\tstx %g0,[%o3]\t\t! *(long *)p = 0\n+\tcmp %o3,%o1\n+\tbgu,pt %xcc, loop\t! if (p > limit) goto loop\n+          asm(\"add %o3,-8,%o3\t! p -= 8 (delay slot)\n+\tretl\n+    \t  mov %o2,%sp\t\t! Restore sp., delay slot\t\n+#else  /* 32 bit SPARC */\n+\tmov\t%sp,%o2\t\t! Save sp\n+\tadd\t%sp,-8,%o3\t! p = sp-8\n+\tclr\t%g1\t\t! [g0,g1] = 0\n+\tadd\t%o1,-0x60,%sp\t! Move sp out of the way,\n+\t\t\t\t! so that traps still work.\n+\t\t\t\t! Includes some extra words\n+\t\t\t\t! so we can be sloppy below.\n+loop:\n+\tstd\t%g0,[%o3]\t! *(long long *)p = 0\n+\tcmp\t%o3,%o1\n+\tbgu\tloop\t\t! if (p > limit) goto loop\n+\t  add\t%o3,-8,%o3\t! p -= 8 (delay slot)\n+\tretl\n+\t  mov\t%o2,%sp\t\t! Restore sp., delay slot\n+#endif  /* 32 bit SPARC */\n+.GC_clear_stack_inner_end:\n+      \t.size GC_clear_stack_inner,.GC_clear_stack_inner_end-GC_clear_stack_inner\n+\n+\t\n+\t\t\n+\t\t\n+\t\t\n+\t\t\n+\t"}]}