{"sha": "99dc72775ffa084451dfc05947102ea2f176e25e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlkYzcyNzc1ZmZhMDg0NDUxZGZjMDU5NDcxMDJlYTJmMTc2ZTI1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-02-15T21:22:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-02-15T21:22:56Z"}, "message": "bb-reorder.c (find_traces_1_round): Don't connect easy to copy successors with multiple predecessors.\n\n        * bb-reorder.c (find_traces_1_round): Don't connect easy to copy\n        successors with multiple predecessors.\n        (connect_traces): Try harder to copy traces of length 1.\n\n        * function.h (struct function): Add computed_goto_common_label,\n        computed_goto_common_reg.\n        * function.c (free_after_compilation): Zap them.\n        * stmt.c (expand_computed_goto): Use them to produce one\n        indirect branch per function.\n\nFrom-SVN: r62944", "tree": {"sha": "33f670d96dd4073de4b68f4ac4f97dfe221c8034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33f670d96dd4073de4b68f4ac4f97dfe221c8034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99dc72775ffa084451dfc05947102ea2f176e25e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99dc72775ffa084451dfc05947102ea2f176e25e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99dc72775ffa084451dfc05947102ea2f176e25e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99dc72775ffa084451dfc05947102ea2f176e25e/comments", "author": null, "committer": null, "parents": [{"sha": "b54cf83ae659949de888bb3ec2797b7858e6ee1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54cf83ae659949de888bb3ec2797b7858e6ee1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54cf83ae659949de888bb3ec2797b7858e6ee1a"}], "stats": {"total": 75, "additions": 65, "deletions": 10}, "files": [{"sha": "0942b3ab6fa750f6bc2fe56e6bc2580d0a3fe0a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99dc72775ffa084451dfc05947102ea2f176e25e", "patch": "@@ -38,6 +38,18 @@\n \t* config/rs6000/rs64.md: New file.\n \t[Some DFA descriptions based on work by Michael Hayes]\n \n+2003-02-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* bb-reorder.c (find_traces_1_round): Don't connect easy to copy\n+\tsuccessors with multiple predecessors.\n+\t(connect_traces): Try harder to copy traces of length 1.\n+\n+\t* function.h (struct function): Add computed_goto_common_label,\n+\tcomputed_goto_common_reg.\n+\t* function.c (free_after_compilation): Zap them.\n+\t* stmt.c (expand_computed_goto): Use them to produce one \n+\tindirect branch per function.\n+\n 2003-02-15  Richard Henderson  <rth@redhat.com>\n \n \t* cfgcleanup.c: Include params.h."}, {"sha": "49889ee2ba3eec07ff36f78276e7b8e5d21241c2", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=99dc72775ffa084451dfc05947102ea2f176e25e", "patch": "@@ -448,6 +448,12 @@ find_traces_1_round (branch_th, exec_th, count_th, traces, n_traces, round,\n \t\t  || prob < branch_th || freq < exec_th || e->count < count_th)\n \t\tcontinue;\n \n+\t      /* If the destination has multiple precessesors, and can be\n+\t\t duplicated cheaper than a jump, don't allow it to be added\n+\t\t to a trace.  We'll duplicate it when connecting traces.  */\n+\t      if (e->dest->pred->pred_next && copy_bb_p (e->dest, 0))\n+\t\tcontinue;\n+\n \t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq))\n \t\t{\n \t\t  best_edge = e;\n@@ -905,19 +911,27 @@ connect_traces (n_traces, traces)\n \t      /* Try to connect the traces by duplication of 1 block.  */\n \t      edge e2;\n \t      basic_block next_bb = NULL;\n+\t      bool try_copy = false;\n \n \t      for (e = traces[t].last->succ; e; e = e->succ_next)\n \t\tif (e->dest != EXIT_BLOCK_PTR\n \t\t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t\t    && !(e->flags & EDGE_COMPLEX)\n-\t\t    && (EDGE_FREQUENCY (e) >= freq_threshold)\n-\t\t    && (e->count >= count_threshold)\n-\t\t    && (!best\n-\t\t\t|| e->probability > best->probability))\n+\t\t    && (!best || e->probability > best->probability))\n \t\t  {\n \t\t    edge best2 = NULL;\n \t\t    int best2_len = 0;\n \n+\t\t    /* If the destination trace is only one block\n+\t\t       long, then no need to search the successor\n+\t\t       blocks of the trace.  Accept it.  */\n+\t\t   if (traces[bbd[e->dest->index].start_of_trace].length == 1)\n+\t\t     {\n+\t\t       best = e;\n+\t\t       try_copy = true;\n+\t\t       continue;\n+\t\t     }\n+\n \t\t    for (e2 = e->dest->succ; e2; e2 = e2->succ_next)\n \t\t      {\n \t\t\tint di = e2->dest->index;\n@@ -942,26 +956,36 @@ connect_traces (n_traces, traces)\n \t\t\t    else\n \t\t\t      best2_len = INT_MAX;\n \t\t\t    next_bb = e2->dest;\n+\t\t\t    try_copy = true;\n \t\t\t  }\n \t\t      }\n \t\t  }\n-\t      if (best && next_bb && copy_bb_p (best->dest, !optimize_size))\n+\n+\t      /* Copy tiny blocks always; copy larger blocks only when the\n+\t\t edge is traversed frequently enough.  */\n+\t      if (try_copy\n+\t\t  && copy_bb_p (best->dest,\n+\t\t\t\t!optimize_size\n+\t\t\t\t&& EDGE_FREQUENCY (best) >= freq_threshold\n+\t\t\t\t&& best->count >= count_threshold))\n \t\t{\n \t\t  basic_block new_bb;\n \n \t\t  if (rtl_dump_file)\n \t\t    {\n \t\t      fprintf (rtl_dump_file, \"Connection: %d %d \",\n \t\t\t       traces[t].last->index, best->dest->index);\n-\t\t      if (next_bb == EXIT_BLOCK_PTR)\n+\t\t      if (!next_bb)\n+\t\t\tfputc ('\\n', rtl_dump_file);\n+\t\t      else if (next_bb == EXIT_BLOCK_PTR)\n \t\t\tfprintf (rtl_dump_file, \"exit\\n\");\n \t\t      else\n \t\t\tfprintf (rtl_dump_file, \"%d\\n\", next_bb->index);\n \t\t    }\n \n \t\t  new_bb = copy_bb (best->dest, best, traces[t].last, t);\n \t\t  traces[t].last = new_bb;\n-\t\t  if (next_bb != EXIT_BLOCK_PTR)\n+\t\t  if (next_bb && next_bb != EXIT_BLOCK_PTR)\n \t\t    {\n \t\t      t = bbd[next_bb->index].start_of_trace;\n \t\t      RBI (traces[last_trace].last)->next = traces[t].first;"}, {"sha": "b20d41f784b1d7f673b177402acf60d258c19b62", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=99dc72775ffa084451dfc05947102ea2f176e25e", "patch": "@@ -452,6 +452,8 @@ free_after_compilation (f)\n   f->x_nonlocal_goto_stack_level = NULL;\n   f->x_cleanup_label = NULL;\n   f->x_return_label = NULL;\n+  f->computed_goto_common_label = NULL;\n+  f->computed_goto_common_reg = NULL;\n   f->x_save_expr_regs = NULL;\n   f->x_stack_slot_list = NULL;\n   f->x_rtl_expr_chain = NULL;"}, {"sha": "5d4258ffe5b7fc18b248eacb6248bff00cacbb32", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=99dc72775ffa084451dfc05947102ea2f176e25e", "patch": "@@ -268,6 +268,10 @@ struct function GTY(())\n      on machines which require execution of the epilogue on all returns.  */\n   rtx x_return_label;\n \n+  /* Label and register for unswitching computed gotos.  */\n+  rtx computed_goto_common_label;\n+  rtx computed_goto_common_reg;\n+\n   /* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n      So we can mark them all live at the end of the function, if nonopt.  */\n   rtx x_save_expr_regs;"}, {"sha": "bc7cc28a7c136af30a75043bf9fb5af665e44789", "filename": "gcc/stmt.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99dc72775ffa084451dfc05947102ea2f176e25e/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=99dc72775ffa084451dfc05947102ea2f176e25e", "patch": "@@ -539,10 +539,23 @@ expand_computed_goto (exp)\n #endif\n \n   emit_queue ();\n-  do_pending_stack_adjust ();\n-  emit_indirect_jump (x);\n \n-  current_function_has_computed_jump = 1;\n+  if (! cfun->computed_goto_common_label)\n+    {\n+      cfun->computed_goto_common_reg = copy_to_mode_reg (Pmode, x);\n+      cfun->computed_goto_common_label = gen_label_rtx ();\n+      emit_label (cfun->computed_goto_common_label);\n+  \n+      do_pending_stack_adjust ();\n+      emit_indirect_jump (cfun->computed_goto_common_reg);\n+\n+      current_function_has_computed_jump = 1;\n+    }\n+  else\n+    {\n+      emit_move_insn (cfun->computed_goto_common_reg, x);\n+      emit_jump (cfun->computed_goto_common_label);\n+    }\n }\n \f\n /* Handle goto statements and the labels that they can go to.  */"}]}