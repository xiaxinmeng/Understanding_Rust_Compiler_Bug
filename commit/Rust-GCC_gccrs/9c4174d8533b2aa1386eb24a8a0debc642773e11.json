{"sha": "9c4174d8533b2aa1386eb24a8a0debc642773e11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWM0MTc0ZDg1MzNiMmFhMTM4NmViMjRhOGEwZGViYzY0Mjc3M2UxMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-20T19:07:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-04-20T19:07:14Z"}, "message": "re PR fortran/43227 (ICE: segmentation fault in mio_expr)\n\n2010-04-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43227\n\t* resolve.c (resolve_fl_derived): If a component character\n\tlength has not been resolved, do so now.\n\t(resolve_symbol): The same as above for a symbol character\n\tlength.\n\t* trans-decl.c (gfc_create_module_variable): A 'length' decl is\n\tnot needed for a character valued, procedure pointer.\n\n\tPR fortran/43266\n\t* resolve.c (ensure_not_abstract_walker): If 'overriding' is\n\tnot found, return FAILURE rather than ICEing.\n\n2010-04-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43227\n\t* gfortran.dg/proc_decl_23.f90: New test.\n\n\tPR fortran/43266\n\t* gfortran.dg/abstract_type_6.f03: New test.\n\nFrom-SVN: r158570", "tree": {"sha": "16d8a2574a3d092a934b735111986d723b201239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16d8a2574a3d092a934b735111986d723b201239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c4174d8533b2aa1386eb24a8a0debc642773e11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4174d8533b2aa1386eb24a8a0debc642773e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4174d8533b2aa1386eb24a8a0debc642773e11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4174d8533b2aa1386eb24a8a0debc642773e11/comments", "author": null, "committer": null, "parents": [{"sha": "e96ccb30f5787417582b6ba5fde14c60aea5e9a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96ccb30f5787417582b6ba5fde14c60aea5e9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96ccb30f5787417582b6ba5fde14c60aea5e9a3"}], "stats": {"total": 136, "additions": 132, "deletions": 4}, "files": [{"sha": "6663603495549dfdd5f39b50246749b27412290d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -1,3 +1,17 @@\n+2010-04-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43227\n+\t* resolve.c (resolve_fl_derived): If a component character\n+\tlength has not been resolved, do so now.\n+\t(resolve_symbol): The same as above for a symbol character\n+\tlength.\n+\t* trans-decl.c (gfc_create_module_variable): A 'length' decl is\n+\tnot needed for a character valued, procedure pointer.\n+\n+\tPR fortran/43266\n+\t* resolve.c (ensure_not_abstract_walker): If 'overriding' is\n+\tnot found, return FAILURE rather than ICEing.\n+\n 2010-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/43339"}, {"sha": "b13edf98e1fc181a3dca1e9cfa8ccf34f1daaf89", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -10617,7 +10617,9 @@ ensure_not_abstract_walker (gfc_symbol* sub, gfc_symtree* st)\n     {\n       gfc_symtree* overriding;\n       overriding = gfc_find_typebound_proc (sub, NULL, st->name, true, NULL);\n-      gcc_assert (overriding && overriding->n.tb);\n+      if (!overriding)\n+\treturn FAILURE;\n+      gcc_assert (overriding->n.tb);\n       if (overriding->n.tb->deferred)\n \t{\n \t  gfc_error (\"Derived-type '%s' declared at %L must be ABSTRACT because\"\n@@ -10784,8 +10786,12 @@ resolve_fl_derived (gfc_symbol *sym)\n \t      /* Copy char length.  */\n \t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t\t{\n-\t\t  c->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t\t  gfc_expr_replace_comp (c->ts.u.cl->length, c);\n+\t\t  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n+\t\t  gfc_expr_replace_comp (cl->length, c);\n+\t\t  if (cl->length && !cl->resolved\n+\t\t        && gfc_resolve_expr (cl->length) == FAILURE)\n+\t\t    return FAILURE;\n+\t\t  c->ts.u.cl = cl;\n \t\t}\n \t    }\n \t  else if (c->ts.interface->name[0] != '\\0')\n@@ -11298,6 +11304,9 @@ resolve_symbol (gfc_symbol *sym)\n \t    {\n \t      sym->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n \t      gfc_expr_replace_symbols (sym->ts.u.cl->length, sym);\n+\t      if (sym->ts.u.cl->length && !sym->ts.u.cl->resolved\n+\t\t    && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n+\t\treturn;\n \t    }\n \t}\n       else if (sym->ts.interface->name[0] != '\\0')"}, {"sha": "11a75b4603321f2b60a56ed7f7db851b8ac10d97", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -3477,7 +3477,8 @@ gfc_create_module_variable (gfc_symbol * sym)\n       tree length;\n \n       length = sym->ts.u.cl->backend_decl;\n-      if (!INTEGER_CST_P (length))\n+      gcc_assert (length || sym->attr.proc_pointer);\n+      if (length && !INTEGER_CST_P (length))\n         {\n           pushdecl (length);\n           rest_of_decl_compilation (length, 1, 0);"}, {"sha": "3f1d530b0b6962057a4917b6292dead9b1b40f31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -1,3 +1,11 @@\n+2010-04-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43227\n+\t* gfortran.dg/proc_decl_23.f90: New test.\n+\n+\tPR fortran/43266\n+\t* gfortran.dg/abstract_type_6.f03: New test.\n+\n 2010-04-20  Xinliang David Li  <davidxl@google.com>\n \n \t* g++.dg/tree-ssa/fold-compare.C: New."}, {"sha": "bc8e5437ad5e47544ab75a84eebf55c2943db317", "filename": "gcc/testsuite/gfortran.dg/abstract_type_6.f03", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do \"compile\" }\n+! Test the fix for PR43266, in which an ICE followed correct error messages.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+! Reported in http://groups.google.ca/group/comp.lang.fortran/browse_thread/thread/f5ec99089ea72b79\n+!\n+!----------------\n+! library code\n+\n+module m\n+TYPE, ABSTRACT :: top\n+CONTAINS\n+   PROCEDURE(xxx), DEFERRED :: proc_a ! { dg-error \"must be a module procedure\" }\n+   ! some useful default behaviour\n+   PROCEDURE :: proc_c => top_c ! { dg-error \"must be a module procedure\" }\n+END TYPE top\n+\n+! Concrete middle class with useful behaviour\n+TYPE, EXTENDS(top) :: middle\n+CONTAINS\n+   ! do nothing, empty proc just to make middle concrete\n+   PROCEDURE :: proc_a => dummy_middle_a ! { dg-error \"must be a module procedure\" }\n+   ! some useful default behaviour\n+   PROCEDURE :: proc_b => middle_b ! { dg-error \"must be a module procedure\" }\n+END TYPE middle\n+\n+!----------------\n+! client code\n+\n+TYPE, EXTENDS(middle) :: bottom\n+CONTAINS\n+   ! useful proc to satisfy deferred procedure in top. Because we've\n+   ! extended middle we wouldn't get told off if we forgot this.\n+   PROCEDURE :: proc_a => bottom_a\n+   ! calls middle%proc_b and then provides extra behaviour\n+   PROCEDURE :: proc_b => bottom_b\n+   ! calls top_c and then provides extra behaviour\n+   PROCEDURE :: proc_c => bottom_c\n+END TYPE bottom\n+contains\n+SUBROUTINE bottom_b(obj)\n+   CLASS(Bottom) :: obj\n+   CALL obj%middle%proc_b ! { dg-error \"should be a SUBROUTINE\" }\n+   ! other stuff\n+END SUBROUTINE bottom_b\n+\n+SUBROUTINE bottom_c(obj)\n+   CLASS(Bottom) :: obj\n+   CALL top_c(obj)\n+   ! other stuff\n+END SUBROUTINE bottom_c \n+end module\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "fa50dc13c86eb2d39abcad6f72f70959eda34a7e", "filename": "gcc/testsuite/gfortran.dg/proc_decl_23.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4174d8533b2aa1386eb24a8a0debc642773e11/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_decl_23.f90?ref=9c4174d8533b2aa1386eb24a8a0debc642773e11", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do compile }\n+! Test the fix for PR43227, in which the lines below would segfault.\n+!\n+! Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+function char1 (s) result(res)\n+  character, dimension(:), intent(in) :: s\n+  character(len=size(s)) :: res\n+  do i = 1, size(s)\n+    res(i:i) = s(i)\n+  end do\n+end function char1\n+\n+module m_string\n+\n+  procedure(string_to_char) :: char1                    ! segfault\n+  procedure(string_to_char), pointer :: char2           ! segfault\n+  type t_string\n+    procedure(string_to_char), pointer, nopass :: char3 ! segfault\n+  end type t_string\n+\n+contains\n+\n+  function string_to_char (s) result(res)\n+    character, dimension(:), intent(in) :: s\n+    character(len=size(s)) :: res\n+    do i = 1, size(s)\n+      res(i:i) = s(i)\n+    end do\n+  end function string_to_char\n+\n+end module m_string\n+\n+  use m_string\n+  type(t_string) :: t\n+  print *, string_to_char ([\"a\",\"b\",\"c\"])\n+  char2 => string_to_char\n+  print *, char2 ([\"d\",\"e\",\"f\"])\n+  t%char3 => string_to_char\n+  print *, t%char3 ([\"g\",\"h\",\"i\"])\n+  print *, char1 ([\"j\",\"k\",\"l\"])\n+end\n+! { dg-final { cleanup-tree-dump \"m_string\" } }"}]}