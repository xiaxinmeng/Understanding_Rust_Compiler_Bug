{"sha": "1ebc2612da88cbb87faed5106329fd03831e0ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViYzI2MTJkYTg4Y2JiODdmYWVkNTEwNjMyOWZkMDM4MzFlMGViYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T15:15:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T15:15:32Z"}, "message": "[multiple changes]\n\n2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n\n\t* set_targ.adb (Read_Target_Dependent_Values): New subprogram.\n\t(elab body): Add provision for default target config file.\n\t* get_targ.ads, get_targ.adb (Get_Back_End_Config_File): New subprogram.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cbhase.adb (Delete): Raise Constraint_Error, not Program_Error,\n\twhen attempting to remove an element not in the set. This is\n\tthe given semantics for all set containers.\n\t* a-cborse.adb (Delete): Attempt removal first, to check for\n\ttampering, before checking whether this is an attempt to\n\tdelete a  non-existing element, and in fthe latter case raise\n\tConstraint_Error.\n\n2014-07-30  Vincent Celier  <celier@adacore.com>\n\n\t* prj-proc.adb (Recursive_Process): Do not create a new\n\tProject_Id if the project is already in the list of projects of\n\tthe tree.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Function_Return): Reject a return expression\n\twhose type is an incomplete formal type.\n\t(Analyze_Return_Type): Reject a return type that is an untagged\n\timcomplete formal type.\n\t(Process_Formals): Reject a formal parameter whose type is an\n\tuntagged formal incomplete type.\n\t* sem_res.adb (Resolve_Actuals): Reject an actual whose type is\n\tan untagged formal incomplete type.\n\nFrom-SVN: r213299", "tree": {"sha": "0656ba3aee338b7a7fcddd8348d9174e207cf1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0656ba3aee338b7a7fcddd8348d9174e207cf1ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ebc2612da88cbb87faed5106329fd03831e0ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ebc2612da88cbb87faed5106329fd03831e0ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ebc2612da88cbb87faed5106329fd03831e0ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ebc2612da88cbb87faed5106329fd03831e0ebc/comments", "author": null, "committer": null, "parents": [{"sha": "45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ec05e18a67b030cfc64802c9261b7ba2e7d34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ec05e18a67b030cfc64802c9261b7ba2e7d34c"}], "stats": {"total": 731, "additions": 432, "deletions": 299}, "files": [{"sha": "923f6cddce9dc3ffb22a68eef500512fda324d3b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -1,3 +1,36 @@\n+2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* set_targ.adb (Read_Target_Dependent_Values): New subprogram.\n+\t(elab body): Add provision for default target config file.\n+\t* get_targ.ads, get_targ.adb (Get_Back_End_Config_File): New subprogram.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cbhase.adb (Delete): Raise Constraint_Error, not Program_Error,\n+\twhen attempting to remove an element not in the set. This is\n+\tthe given semantics for all set containers.\n+\t* a-cborse.adb (Delete): Attempt removal first, to check for\n+\ttampering, before checking whether this is an attempt to\n+\tdelete a  non-existing element, and in fthe latter case raise\n+\tConstraint_Error.\n+\n+2014-07-30  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-proc.adb (Recursive_Process): Do not create a new\n+\tProject_Id if the project is already in the list of projects of\n+\tthe tree.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Function_Return): Reject a return expression\n+\twhose type is an incomplete formal type.\n+\t(Analyze_Return_Type): Reject a return type that is an untagged\n+\timcomplete formal type.\n+\t(Process_Formals): Reject a formal parameter whose type is an\n+\tuntagged formal incomplete type.\n+\t* sem_res.adb (Resolve_Actuals): Reject an actual whose type is\n+\tan untagged formal incomplete type.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_ugn.texi: Minor spelling correction."}, {"sha": "8d4a61ea43557b1a4f4e2fdea175227c6d0d5312", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -313,7 +313,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n \n       if X = 0 then\n-         raise Program_Error with \"attempt to delete element not in set\";\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n       HT_Ops.Free (Container, X);"}, {"sha": "979357ddc759ef22afa3b55a80687084cfcb3996", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -500,11 +500,12 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       X : constant Count_Type := Element_Keys.Find (Container, Item);\n \n    begin\n+      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n+\n       if X = 0 then\n-         raise Program_Error with \"attempt to delete element not in set\";\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n       Tree_Operations.Free (Container, X);\n    end Delete;\n "}, {"sha": "fa0c8b9b02389e0b3d3f1c0094ad918ebf41e947", "filename": "gcc/ada/get_targ.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fget_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fget_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -293,6 +293,15 @@ package body Get_Targ is\n       return C_Get_Double_Scalar_Alignment;\n    end Get_Double_Scalar_Alignment;\n \n+   ------------------------------\n+   -- Get_Back_End_Config_File --\n+   ------------------------------\n+\n+   function Get_Back_End_Config_File return String_Ptr is\n+   begin\n+      return null;\n+   end Get_Back_End_Config_File;\n+\n    ----------------------\n    -- Digits_From_Size --\n    ----------------------"}, {"sha": "6d484a3143e1fde556d3e667005dbba5b7ab8799", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -145,4 +145,9 @@ package Get_Targ is\n    procedure Register_Back_End_Types (Call_Back : Register_Type_Proc);\n    --  Calls the Call_Back function with information for each supported type\n \n+   function Get_Back_End_Config_File return String_Ptr;\n+   --  Return the back end configuration file, or null if none.\n+   --  If non null, this file should be used instead of calling the various\n+   --  Get_xxx functions in this package.\n+\n end Get_Targ;"}, {"sha": "561f4ec1e1c9fa67b3f32cd80ec285e46347ef9a", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -2845,20 +2845,42 @@ package body Prj.Proc is\n                return;\n             end if;\n \n-            Project :=\n-              new Project_Data'\n-                (Empty_Project\n-                  (Project_Qualifier_Of\n-                    (From_Project_Node, From_Project_Node_Tree)));\n-\n-            --  Note that at this point we do not know yet if the project has\n-            --  been withed from an encapsulated library or not.\n-\n-            In_Tree.Projects :=\n-              new Project_List_Element'\n-             (Project               => Project,\n-              From_Encapsulated_Lib => False,\n-              Next                  => In_Tree.Projects);\n+            --  Check if the project is already in the tree\n+\n+            Project := No_Project;\n+            declare\n+               List : Project_List := In_Tree.Projects;\n+               Path : constant Path_Name_Type :=\n+                        Path_Name_Of (From_Project_Node,\n+                                      From_Project_Node_Tree);\n+\n+            begin\n+               while List /= null loop\n+                  if List.Project.Path.Display_Name = Path then\n+                     Project := List.Project;\n+                     exit;\n+                  end if;\n+\n+                  List := List.Next;\n+               end loop;\n+            end;\n+\n+            if Project = No_Project then\n+               Project :=\n+                 new Project_Data'\n+                   (Empty_Project\n+                      (Project_Qualifier_Of\n+                         (From_Project_Node, From_Project_Node_Tree)));\n+\n+               --  Note that at this point we do not know yet if the project\n+               --  has been withed from an encapsulated library or not.\n+\n+               In_Tree.Projects :=\n+                 new Project_List_Element'\n+                   (Project               => Project,\n+                    From_Encapsulated_Lib => False,\n+                    Next                  => In_Tree.Projects);\n+            end if;\n \n             --  Keep track of this point\n "}, {"sha": "05359a9767611b6ddceb929cf963635e7358e81b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -981,6 +981,14 @@ package body Sem_Ch6 is\n             then\n                Error_Msg_N (\"cannot return local access to subprogram\", N);\n             end if;\n+\n+         --  The expression cannot be of a formal incomplete type\n+\n+         elsif Ekind (Etype (Expr)) = E_Incomplete_Type\n+           and then Is_Generic_Type (Etype (Expr))\n+         then\n+            Error_Msg_N\n+              (\"cannot return expression of a formal incomplete type\", N);\n          end if;\n \n          --  If the result type is class-wide, then check that the return\n@@ -1953,6 +1961,24 @@ package body Sem_Ch6 is\n                        (\"invalid use of incomplete type&\",\n                         Result_Definition (N), Typ);\n \n+                  --  The return type of a subprogram body cannot be of a\n+                  --  formal incomplete type.\n+\n+                  elsif Is_Generic_Type (Typ)\n+                    and then Nkind (Parent (N)) = N_Subprogram_Body\n+                  then\n+                     Error_Msg_N\n+                      (\"return type cannot be a formal incomplete type\",\n+                        Result_Definition (N));\n+\n+                  elsif Is_Class_Wide_Type (Typ)\n+                    and then Is_Generic_Type (Root_Type (Typ))\n+                    and then Nkind (Parent (N)) = N_Subprogram_Body\n+                  then\n+                     Error_Msg_N\n+                      (\"return type cannot be a formal incomplete type\",\n+                        Result_Definition (N));\n+\n                   elsif Is_Tagged_Type (Typ) then\n                      null;\n \n@@ -9827,7 +9853,8 @@ package body Sem_Ch6 is\n \n                if Is_Tagged_Type (Formal_Type)\n                  or else (Ada_Version >= Ada_2012\n-                           and then not From_Limited_With (Formal_Type))\n+                           and then not From_Limited_With (Formal_Type)\n+                           and then not Is_Generic_Type (Formal_Type))\n                then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n                     and then not Is_Generic_Type (Formal_Type)\n@@ -9864,8 +9891,17 @@ package body Sem_Ch6 is\n                   --  in bodies. Limited views of either kind are not allowed\n                   --  if there is no place at which the non-limited view can\n                   --  become available.\n+                  --  Incomplete formal untagged types are not allowed in\n+                  --  subprogram bodies (but are legal in their declarations).\n+\n+                  if Is_Generic_Type (Formal_Type)\n+                    and then not Is_Tagged_Type (Formal_Type)\n+                    and then Nkind (Parent (Related_Nod)) = N_Subprogram_Body\n+                  then\n+                     Error_Msg_N\n+                       (\"invalid use of formal incomplete type\", Param_Spec);\n \n-                  if Ada_Version >= Ada_2012 then\n+                  elsif Ada_Version >= Ada_2012 then\n                      if Is_Tagged_Type (Formal_Type)\n                        and then (not From_Limited_With (Formal_Type)\n                                   or else not In_Package_Body)"}, {"sha": "e7ed6648593c67f13af830466c6cb1069ace6c3d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -3864,6 +3864,16 @@ package body Sem_Res is\n             A_Typ := Etype (A);\n             F_Typ := Etype (F);\n \n+            --  An actual cannot be an untagged formal incomplete type\n+\n+            if Ekind (A_Typ) = E_Incomplete_Type\n+              and then not Is_Tagged_Type (A_Typ)\n+              and then Is_Generic_Type (A_Typ)\n+            then\n+               Error_Msg_N\n+                 (\"invalid use of untagged formal incomplete type\", A);\n+            end if;\n+\n             if Comes_From_Source (Original_Node (N))\n               and then Nkind_In (Original_Node (N), N_Function_Call,\n                                                     N_Procedure_Call_Statement)"}, {"sha": "704bea61339d43b65d7dadebd293942cc3ee54f2", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 296, "deletions": 279, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebc2612da88cbb87faed5106329fd03831e0ebc/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=1ebc2612da88cbb87faed5106329fd03831e0ebc", "patch": "@@ -130,6 +130,10 @@ package body Set_Targ is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Read_Target_Dependent_Values (File_Name : String);\n+   --  Read target dependent values from File_Name, and set the target\n+   --  dependent values (global variables) declared in this package.\n+\n    procedure Fail (E : String);\n    pragma No_Return (Fail);\n    --  Terminate program with fatal error message passed as parameter\n@@ -481,6 +485,260 @@ package body Set_Targ is\n       end if;\n    end Write_Target_Dependent_Values;\n \n+   ----------------------------------\n+   -- Read_Target_Dependent_Values --\n+   ----------------------------------\n+\n+   procedure Read_Target_Dependent_Values (File_Name : String) is\n+      File_Desc : File_Descriptor;\n+      N         : Natural;\n+\n+      type ANat is access all Natural;\n+      --  Pointer to Nat or Pos value (it is harmless to treat Pos values\n+      --  as Nat via Unchecked_Conversion).\n+\n+      function To_ANat is new Unchecked_Conversion (Address, ANat);\n+\n+      VP : ANat;\n+\n+      Buffer : String (1 .. 2000);\n+      Buflen : Natural;\n+      --  File information and length (2000 easily enough)\n+\n+      Nam_Buf : String (1 .. 40);\n+      Nam_Len : Natural;\n+\n+      procedure Check_Spaces;\n+      --  Checks that we have one or more spaces and skips them\n+\n+      procedure FailN (S : String);\n+      --  Calls Fail adding \" name in file xxx\", where name is the currently\n+      --  gathered name in Nam_Buf, surrounded by quotes, and xxx is the\n+      --  name of the file.\n+\n+      procedure Get_Name;\n+      --  Scan out name, leaving it in Nam_Buf with Nam_Len set. Calls\n+      --  Skip_Spaces to skip any following spaces. Note that the name is\n+      --  terminated by a sequence of at least two spaces.\n+\n+      function Get_Nat return Natural;\n+      --  N on entry points to decimal integer, scan out decimal integer\n+      --  and return it, leaving N pointing to following space or LF.\n+\n+      procedure Skip_Spaces;\n+      --  Skip past spaces\n+\n+      ------------------\n+      -- Check_Spaces --\n+      ------------------\n+\n+      procedure Check_Spaces is\n+      begin\n+         if N > Buflen or else Buffer (N) /= ' ' then\n+            FailN (\"missing space for\");\n+         end if;\n+\n+         Skip_Spaces;\n+         return;\n+      end Check_Spaces;\n+\n+      -----------\n+      -- FailN --\n+      -----------\n+\n+      procedure FailN (S : String) is\n+      begin\n+         Fail (S & \" \"\"\" & Nam_Buf (1 .. Nam_Len) & \"\"\" in file \"\n+               & File_Name);\n+      end FailN;\n+\n+      --------------\n+      -- Get_Name --\n+      --------------\n+\n+      procedure Get_Name is\n+      begin\n+         Nam_Len := 0;\n+\n+         --  Scan out name and put it in Nam_Buf\n+\n+         loop\n+            if N > Buflen or else Buffer (N) = ASCII.LF then\n+               FailN (\"incorrectly formatted line for\");\n+            end if;\n+\n+            --  Name is terminated by two blanks\n+\n+            exit when N < Buflen and then Buffer (N .. N + 1) = \"  \";\n+\n+            Nam_Len := Nam_Len + 1;\n+\n+            if Nam_Len > Nam_Buf'Last then\n+               Fail (\"name too long\");\n+            end if;\n+\n+            Nam_Buf (Nam_Len) := Buffer (N);\n+            N := N + 1;\n+         end loop;\n+\n+         Check_Spaces;\n+      end Get_Name;\n+\n+      -------------\n+      -- Get_Nat --\n+      -------------\n+\n+      function Get_Nat return Natural is\n+         Result : Natural := 0;\n+\n+      begin\n+         loop\n+            if N > Buflen\n+              or else Buffer (N) not in '0' .. '9'\n+              or else Result > 999\n+            then\n+               FailN (\"bad value for\");\n+            end if;\n+\n+            Result := Result * 10 + (Character'Pos (Buffer (N)) - 48);\n+            N := N + 1;\n+\n+            exit when N <= Buflen\n+              and then (Buffer (N) = ASCII.LF or else Buffer (N) = ' ');\n+         end loop;\n+\n+         return Result;\n+      end Get_Nat;\n+\n+      -----------------\n+      -- Skip_Spaces --\n+      -----------------\n+\n+      procedure Skip_Spaces is\n+      begin\n+         while N <= Buflen and Buffer (N) = ' ' loop\n+            N := N + 1;\n+         end loop;\n+      end Skip_Spaces;\n+\n+   --  Start of processing for Read_Target_Dependent_Values\n+\n+   begin\n+      File_Desc := Open_Read (File_Name, Text);\n+\n+      if File_Desc = Invalid_FD then\n+         Fail (\"cannot read file \" & File_Name);\n+      end if;\n+\n+      Buflen := Read (File_Desc, Buffer'Address, Buffer'Length);\n+\n+      if Buflen = Buffer'Length then\n+         Fail (\"file is too long: \" & File_Name);\n+      end if;\n+\n+      --  Scan through file for properly formatted entries in first section\n+\n+      N := 1;\n+      while N <= Buflen and then Buffer (N) /= ASCII.LF loop\n+         Get_Name;\n+\n+         --  Validate name and get corresponding value pointer\n+\n+         VP := null;\n+\n+         for J in DTN'Range loop\n+            if DTN (J).all = Nam_Buf (1 .. Nam_Len) then\n+               VP := To_ANat (DTV (J));\n+               DTR (J) := True;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if VP = null then\n+            FailN (\"unrecognized name\");\n+         end if;\n+\n+         --  Scan out value\n+\n+         VP.all := Get_Nat;\n+\n+         if N > Buflen or else Buffer (N) /= ASCII.LF then\n+            FailN (\"misformatted line for\");\n+         end if;\n+\n+         N := N + 1; -- skip LF\n+      end loop;\n+\n+      --  Fall through this loop when all lines in first section read.\n+      --  Check that values have been supplied for all entries.\n+\n+      for J in DTR'Range loop\n+         if not DTR (J) then\n+            Fail (\"missing entry for \" & DTN (J).all & \" in file \"\n+                  & File_Name);\n+         end if;\n+      end loop;\n+\n+      --  Now acquire FPT entries\n+\n+      if N >= Buflen then\n+         Fail (\"missing entries for FPT modes in file \" & File_Name);\n+      end if;\n+\n+      if Buffer (N) = ASCII.LF then\n+         N := N + 1;\n+      else\n+         Fail (\"missing blank line in file \" & File_Name);\n+      end if;\n+\n+      Num_FPT_Modes := 0;\n+      while N <= Buflen loop\n+         Get_Name;\n+\n+         Num_FPT_Modes := Num_FPT_Modes + 1;\n+\n+         declare\n+            E : FPT_Mode_Entry renames FPT_Mode_Table (Num_FPT_Modes);\n+\n+         begin\n+            E.NAME := new String'(Nam_Buf (1 .. Nam_Len));\n+\n+            E.DIGS := Get_Nat;\n+            Check_Spaces;\n+\n+            case Buffer (N) is\n+               when 'I'    =>\n+                  E.FLOAT_REP := IEEE_Binary;\n+               when 'V'    =>\n+                  E.FLOAT_REP := VAX_Native;\n+               when 'A'    =>\n+                  E.FLOAT_REP := AAMP;\n+               when others =>\n+                  FailN (\"bad float rep field for\");\n+            end case;\n+\n+            N := N + 1;\n+            Check_Spaces;\n+\n+            E.PRECISION := Get_Nat;\n+            Check_Spaces;\n+\n+            E.ALIGNMENT := Get_Nat;\n+\n+            if Buffer (N) /= ASCII.LF then\n+               FailN (\"junk at end of line for\");\n+            end if;\n+\n+            --  ??? We do not read E.SIZE, see Write_Target_Dependent_Values\n+\n+            E.SIZE :=\n+              (E.PRECISION + E.ALIGNMENT - 1) / E.ALIGNMENT * E.ALIGNMENT;\n+\n+            N := N + 1;\n+         end;\n+      end loop;\n+   end Read_Target_Dependent_Values;\n+\n --  Package Initialization, set target dependent values. This must be done\n --  early on, before we start accessing various compiler packages, since\n --  these values are used all over the place.\n@@ -565,40 +823,6 @@ begin\n       end loop;\n    end;\n \n-   --  If the switch is not set, we get all values from the back end\n-\n-   if Opt.Target_Dependent_Info_Read_Name = null then\n-\n-      --  Set values by direct calls to the back end\n-\n-      Bits_BE                    := Get_Bits_BE;\n-      Bits_Per_Unit              := Get_Bits_Per_Unit;\n-      Bits_Per_Word              := Get_Bits_Per_Word;\n-      Bytes_BE                   := Get_Bytes_BE;\n-      Char_Size                  := Get_Char_Size;\n-      Double_Float_Alignment     := Get_Double_Float_Alignment;\n-      Double_Scalar_Alignment    := Get_Double_Scalar_Alignment;\n-      Double_Size                := Get_Double_Size;\n-      Float_Size                 := Get_Float_Size;\n-      Float_Words_BE             := Get_Float_Words_BE;\n-      Int_Size                   := Get_Int_Size;\n-      Long_Double_Size           := Get_Long_Double_Size;\n-      Long_Long_Size             := Get_Long_Long_Size;\n-      Long_Size                  := Get_Long_Size;\n-      Maximum_Alignment          := Get_Maximum_Alignment;\n-      Max_Unaligned_Field        := Get_Max_Unaligned_Field;\n-      Pointer_Size               := Get_Pointer_Size;\n-      Short_Enums                := Get_Short_Enums;\n-      Short_Size                 := Get_Short_Size;\n-      Strict_Alignment           := Get_Strict_Alignment;\n-      System_Allocator_Alignment := Get_System_Allocator_Alignment;\n-      Wchar_T_Size               := Get_Wchar_T_Size;\n-      Words_BE                   := Get_Words_BE;\n-\n-      --  Register floating-point types from the back end\n-\n-      Register_Back_End_Types (Register_Float_Type'Access);\n-\n    --  Case of reading the target dependent values from file\n \n    --  This is bit more complex than might be expected, because it has to be\n@@ -607,257 +831,50 @@ begin\n    --  etc to read the file. We do this at the System.OS_Lib level since it is\n    --  too early to be using Osint directly.\n \n+   if Opt.Target_Dependent_Info_Read_Name /= null then\n+      Read_Target_Dependent_Values (Target_Dependent_Info_Read_Name.all);\n    else\n-      Read_Target_Dependent_Values : declare\n-         File_Desc : File_Descriptor;\n-         N         : Natural;\n-\n-         type ANat is access all Natural;\n-         --  Pointer to Nat or Pos value (it is harmless to treat Pos values\n-         --  as Nat via Unchecked_Conversion).\n-\n-         function To_ANat is new Unchecked_Conversion (Address, ANat);\n-\n-         VP : ANat;\n-\n-         Buffer : String (1 .. 2000);\n-         Buflen : Natural;\n-         --  File information and length (2000 easily enough)\n-\n-         Nam_Buf : String (1 .. 40);\n-         Nam_Len : Natural;\n-\n-         procedure Check_Spaces;\n-         --  Checks that we have one or more spaces and skips them\n-\n-         procedure FailN (S : String);\n-         --  Calls Fail adding \" name in file xxx\", where name is the currently\n-         --  gathered name in Nam_Buf, surrounded by quotes, and xxx is the\n-         --  name of the file.\n-\n-         procedure Get_Name;\n-         --  Scan out name, leaving it in Nam_Buf with Nam_Len set. Calls\n-         --  Skip_Spaces to skip any following spaces. Note that the name is\n-         --  terminated by a sequence of at least two spaces.\n-\n-         function Get_Nat return Natural;\n-         --  N on entry points to decimal integer, scan out decimal integer\n-         --  and return it, leaving N pointing to following space or LF.\n-\n-         procedure Skip_Spaces;\n-         --  Skip past spaces\n-\n-         ------------------\n-         -- Check_Spaces --\n-         ------------------\n-\n-         procedure Check_Spaces is\n-         begin\n-            if N > Buflen or else Buffer (N) /= ' ' then\n-               FailN (\"missing space for\");\n-            end if;\n-\n-            Skip_Spaces;\n-            return;\n-         end Check_Spaces;\n-\n-         -----------\n-         -- FailN --\n-         -----------\n-\n-         procedure FailN (S : String) is\n-         begin\n-            Fail (S & \" \"\"\" & Nam_Buf (1 .. Nam_Len) & \"\"\" in file \"\n-                  & Target_Dependent_Info_Read_Name.all);\n-         end FailN;\n-\n-         --------------\n-         -- Get_Name --\n-         --------------\n-\n-         procedure Get_Name is\n-         begin\n-            Nam_Len := 0;\n-\n-            --  Scan out name and put it in Nam_Buf\n-\n-            loop\n-               if N > Buflen or else Buffer (N) = ASCII.LF then\n-                  FailN (\"incorrectly formatted line for\");\n-               end if;\n-\n-               --  Name is terminated by two blanks\n-\n-               exit when N < Buflen and then Buffer (N .. N + 1) = \"  \";\n-\n-               Nam_Len := Nam_Len + 1;\n-\n-               if Nam_Len > Nam_Buf'Last then\n-                  Fail (\"name too long\");\n-               end if;\n-\n-               Nam_Buf (Nam_Len) := Buffer (N);\n-               N := N + 1;\n-            end loop;\n-\n-            Check_Spaces;\n-         end Get_Name;\n-\n-         -------------\n-         -- Get_Nat --\n-         -------------\n-\n-         function Get_Nat return Natural is\n-            Result : Natural := 0;\n-\n-         begin\n-            loop\n-               if N > Buflen\n-                 or else Buffer (N) not in '0' .. '9'\n-                 or else Result > 999\n-               then\n-                  FailN (\"bad value for\");\n-               end if;\n-\n-               Result := Result * 10 + (Character'Pos (Buffer (N)) - 48);\n-               N := N + 1;\n-\n-               exit when N <= Buflen\n-                 and then (Buffer (N) = ASCII.LF or else Buffer (N) = ' ');\n-            end loop;\n-\n-            return Result;\n-         end Get_Nat;\n-\n-         -----------------\n-         -- Skip_Spaces --\n-         -----------------\n-\n-         procedure Skip_Spaces is\n-         begin\n-            while N <= Buflen and Buffer (N) = ' ' loop\n-               N := N + 1;\n-            end loop;\n-         end Skip_Spaces;\n-\n-      --  Start of processing for Read_Target_Dependent_Values\n+      --  If the back-end comes with a target config file, then use it\n+      --  to set the values\n \n+      declare\n+         Back_End_Config_File : constant String_Ptr :=\n+           Get_Back_End_Config_File;\n       begin\n-         File_Desc := Open_Read (Target_Dependent_Info_Read_Name.all, Text);\n-\n-         if File_Desc = Invalid_FD then\n-            Fail (\"cannot read file \" & Target_Dependent_Info_Read_Name.all);\n-         end if;\n-\n-         Buflen := Read (File_Desc, Buffer'Address, Buffer'Length);\n+         if Back_End_Config_File /= null then\n+            Read_Target_Dependent_Values (Back_End_Config_File.all);\n \n-         if Buflen = Buffer'Length then\n-            Fail (\"file is too long: \" & Target_Dependent_Info_Read_Name.all);\n-         end if;\n-\n-         --  Scan through file for properly formatted entries in first section\n-\n-         N := 1;\n-         while N <= Buflen and then Buffer (N) /= ASCII.LF loop\n-            Get_Name;\n-\n-            --  Validate name and get corresponding value pointer\n-\n-            VP := null;\n-\n-            for J in DTN'Range loop\n-               if DTN (J).all = Nam_Buf (1 .. Nam_Len) then\n-                  VP := To_ANat (DTV (J));\n-                  DTR (J) := True;\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if VP = null then\n-               FailN (\"unrecognized name\");\n-            end if;\n-\n-            --  Scan out value\n-\n-            VP.all := Get_Nat;\n-\n-            if N > Buflen or else Buffer (N) /= ASCII.LF then\n-               FailN (\"misformatted line for\");\n-            end if;\n+         --  Otherwise we get all values from the back end directly\n \n-            N := N + 1; -- skip LF\n-         end loop;\n-\n-         --  Fall through this loop when all lines in first section read.\n-         --  Check that values have been supplied for all entries.\n-\n-         for J in DTR'Range loop\n-            if not DTR (J) then\n-               Fail (\"missing entry for \" & DTN (J).all & \" in file \"\n-                     & Target_Dependent_Info_Read_Name.all);\n-            end if;\n-         end loop;\n-\n-         --  Now acquire FPT entries\n-\n-         if N >= Buflen then\n-            Fail (\"missing entries for FPT modes in file \"\n-                  & Target_Dependent_Info_Read_Name.all);\n-         end if;\n-\n-         if Buffer (N) = ASCII.LF then\n-            N := N + 1;\n          else\n-            Fail (\"missing blank line in file \"\n-                  & Target_Dependent_Info_Read_Name.all);\n+            Bits_BE                    := Get_Bits_BE;\n+            Bits_Per_Unit              := Get_Bits_Per_Unit;\n+            Bits_Per_Word              := Get_Bits_Per_Word;\n+            Bytes_BE                   := Get_Bytes_BE;\n+            Char_Size                  := Get_Char_Size;\n+            Double_Float_Alignment     := Get_Double_Float_Alignment;\n+            Double_Scalar_Alignment    := Get_Double_Scalar_Alignment;\n+            Double_Size                := Get_Double_Size;\n+            Float_Size                 := Get_Float_Size;\n+            Float_Words_BE             := Get_Float_Words_BE;\n+            Int_Size                   := Get_Int_Size;\n+            Long_Double_Size           := Get_Long_Double_Size;\n+            Long_Long_Size             := Get_Long_Long_Size;\n+            Long_Size                  := Get_Long_Size;\n+            Maximum_Alignment          := Get_Maximum_Alignment;\n+            Max_Unaligned_Field        := Get_Max_Unaligned_Field;\n+            Pointer_Size               := Get_Pointer_Size;\n+            Short_Enums                := Get_Short_Enums;\n+            Short_Size                 := Get_Short_Size;\n+            Strict_Alignment           := Get_Strict_Alignment;\n+            System_Allocator_Alignment := Get_System_Allocator_Alignment;\n+            Wchar_T_Size               := Get_Wchar_T_Size;\n+            Words_BE                   := Get_Words_BE;\n+\n+            --  Register floating-point types from the back end\n+\n+            Register_Back_End_Types (Register_Float_Type'Access);\n          end if;\n-\n-         Num_FPT_Modes := 0;\n-         while N <= Buflen loop\n-            Get_Name;\n-\n-            Num_FPT_Modes := Num_FPT_Modes + 1;\n-\n-            declare\n-               E : FPT_Mode_Entry renames FPT_Mode_Table (Num_FPT_Modes);\n-\n-            begin\n-               E.NAME := new String'(Nam_Buf (1 .. Nam_Len));\n-\n-               E.DIGS := Get_Nat;\n-               Check_Spaces;\n-\n-               case Buffer (N) is\n-                  when 'I'    =>\n-                     E.FLOAT_REP := IEEE_Binary;\n-                  when 'V'    =>\n-                     E.FLOAT_REP := VAX_Native;\n-                  when 'A'    =>\n-                     E.FLOAT_REP := AAMP;\n-                  when others =>\n-                     FailN (\"bad float rep field for\");\n-               end case;\n-\n-               N := N + 1;\n-               Check_Spaces;\n-\n-               E.PRECISION := Get_Nat;\n-               Check_Spaces;\n-\n-               E.ALIGNMENT := Get_Nat;\n-\n-               if Buffer (N) /= ASCII.LF then\n-                  FailN (\"junk at end of line for\");\n-               end if;\n-\n-               --  ??? We do not read E.SIZE, see Write_Target_Dependent_Values\n-\n-               E.SIZE :=\n-                 (E.PRECISION + E.ALIGNMENT - 1) / E.ALIGNMENT * E.ALIGNMENT;\n-\n-               N := N + 1;\n-            end;\n-         end loop;\n-      end Read_Target_Dependent_Values;\n+      end;\n    end if;\n end Set_Targ;"}]}