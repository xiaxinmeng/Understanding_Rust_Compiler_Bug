{"sha": "bef08b718f9cacd17fb74fab77b125d2c92b7493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmMDhiNzE4ZjljYWNkMTdmYjc0ZmFiNzdiMTI1ZDJjOTJiNzQ5Mw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-11-17T20:09:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-11-17T20:09:56Z"}, "message": "Fix uninitialized src_range values for c_expr\n\ngcc/c/ChangeLog:\n\t* c-parser.c (set_c_expr_source_range): Bulletproof both\n\toverloaded implementations against NULL expr->value.\n\t(c_parser_braced_init): Set src_range for \"ret\" to a sane pair of\n\tvalues.\n\t(c_parser_unary_expression): Likewise when handling addresses of\n\tlabels.\n\t(c_parser_postfix_expression): Likewise for statement expressions,\n\tfor __FUNCTION__, __PRETTY_FUNCTION_ and __func__ keywords, for\n\t__builtin_va_arg, and for __builtin_offset_of.\n\t(c_parser_postfix_expression_after_paren_type): Initialize expr's\n\tsrc_range using the range of the braced initializer.\n\t(c_parser_transaction_expression): Set src_range for \"ret\" to a\n\tsane pair of values.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic-test-expressions-1.c (vector): New\n\tmacro.\n\t(test_braced_init): New function.\n\t(test_statement_expression): New function.\n\t(test_address_of_label): New function.\n\t(test_transaction_expressions): New function.\n\t(test_keywords): New function.\n\t(test_builtin_va_arg): New function.\n\t(test_builtin_offsetof): New function.\n\t* lib/multiline.exp (_build_multiline_regex): Escape braces.\n\nFrom-SVN: r230497", "tree": {"sha": "5ac459668109c02d425e211e6d65ca804b65d25e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ac459668109c02d425e211e6d65ca804b65d25e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bef08b718f9cacd17fb74fab77b125d2c92b7493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef08b718f9cacd17fb74fab77b125d2c92b7493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef08b718f9cacd17fb74fab77b125d2c92b7493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef08b718f9cacd17fb74fab77b125d2c92b7493/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f0b7c95485eb8e6e663d7fd8df5243192a3c7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f0b7c95485eb8e6e663d7fd8df5243192a3c7df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f0b7c95485eb8e6e663d7fd8df5243192a3c7df"}], "stats": {"total": 252, "additions": 213, "deletions": 39}, "files": [{"sha": "b561fa07cb0787c9e7254f6d8c10fc92c86608bd", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=bef08b718f9cacd17fb74fab77b125d2c92b7493", "patch": "@@ -1,3 +1,19 @@\n+2015-11-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-parser.c (set_c_expr_source_range): Bulletproof both\n+\toverloaded implementations against NULL expr->value.\n+\t(c_parser_braced_init): Set src_range for \"ret\" to a sane pair of\n+\tvalues.\n+\t(c_parser_unary_expression): Likewise when handling addresses of\n+\tlabels.\n+\t(c_parser_postfix_expression): Likewise for statement expressions,\n+\tfor __FUNCTION__, __PRETTY_FUNCTION_ and __func__ keywords, for\n+\t__builtin_va_arg, and for __builtin_offset_of.\n+\t(c_parser_postfix_expression_after_paren_type): Initialize expr's\n+\tsrc_range using the range of the braced initializer.\n+\t(c_parser_transaction_expression): Set src_range for \"ret\" to a\n+\tsane pair of values.\n+\n 2015-11-16  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* c-parser.c (c_finish_omp_declare_simd): Look for"}, {"sha": "7b10764a01e526f77d9fab9341c797bb946907ff", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=bef08b718f9cacd17fb74fab77b125d2c92b7493", "patch": "@@ -65,15 +65,17 @@ set_c_expr_source_range (c_expr *expr,\n {\n   expr->src_range.m_start = start;\n   expr->src_range.m_finish = finish;\n-  set_source_range (expr->value, start, finish);\n+  if (expr->value)\n+    set_source_range (expr->value, start, finish);\n }\n \n void\n set_c_expr_source_range (c_expr *expr,\n \t\t\t source_range src_range)\n {\n   expr->src_range = src_range;\n-  set_source_range (expr->value, src_range);\n+  if (expr->value)\n+    set_source_range (expr->value, src_range);\n }\n \n \f\n@@ -4268,7 +4270,8 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n \t    break;\n \t}\n     }\n-  if (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))\n+  c_token *next_tok = c_parser_peek_token (parser);\n+  if (next_tok->type != CPP_CLOSE_BRACE)\n     {\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n@@ -4278,9 +4281,11 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n       obstack_free (&braced_init_obstack, NULL);\n       return ret;\n     }\n+  location_t close_loc = next_tok->location;\n   c_parser_consume_token (parser);\n   ret = pop_init_level (brace_loc, 0, &braced_init_obstack);\n   obstack_free (&braced_init_obstack, NULL);\n+  set_c_expr_source_range (&ret, brace_loc, close_loc);\n   return ret;\n }\n \n@@ -6723,6 +6728,8 @@ c_parser_unary_expression (c_parser *parser)\n \t{\n \t  ret.value = finish_label_address_expr\n \t    (c_parser_peek_token (parser)->value, op_loc);\n+\t  set_c_expr_source_range (&ret, op_loc,\n+\t\t\t\t   c_parser_peek_token (parser)->get_finish ());\n \t  c_parser_consume_token (parser);\n \t}\n       else\n@@ -7366,11 +7373,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t    }\n \t  stmt = c_begin_stmt_expr ();\n \t  c_parser_compound_statement_nostart (parser);\n+\t  location_t close_loc = c_parser_peek_token (parser)->location;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  pedwarn (loc, OPT_Wpedantic,\n \t\t   \"ISO C forbids braced-groups within expressions\");\n \t  expr.value = c_finish_stmt_expr (brace_loc, stmt);\n+\t  set_c_expr_source_range (&expr, loc, close_loc);\n \t  mark_exp_read (expr.value);\n \t}\n       else if (c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n@@ -7421,6 +7430,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  expr.value = fname_decl (loc,\n \t\t\t\t   c_parser_peek_token (parser)->keyword,\n \t\t\t\t   c_parser_peek_token (parser)->value);\n+\t  set_c_expr_source_range (&expr, loc, loc);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_PRETTY_FUNCTION_NAME:\n@@ -7429,6 +7439,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  expr.value = fname_decl (loc,\n \t\t\t\t   c_parser_peek_token (parser)->keyword,\n \t\t\t\t   c_parser_peek_token (parser)->value);\n+\t  set_c_expr_source_range (&expr, loc, loc);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_C99_FUNCTION_NAME:\n@@ -7437,45 +7448,51 @@ c_parser_postfix_expression (c_parser *parser)\n \t  expr.value = fname_decl (loc,\n \t\t\t\t   c_parser_peek_token (parser)->keyword,\n \t\t\t\t   c_parser_peek_token (parser)->value);\n+\t  set_c_expr_source_range (&expr, loc, loc);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase RID_VA_ARG:\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  e1 = c_parser_expr_no_commas (parser, NULL);\n-\t  mark_exp_read (e1.value);\n-\t  e1.value = c_fully_fold (e1.value, false, NULL);\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  loc = c_parser_peek_token (parser)->location;\n-\t  t1 = c_parser_type_name (parser);\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n-\t  if (t1 == NULL)\n-\t    {\n-\t      expr.value = error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree type_expr = NULL_TREE;\n-\t      expr.value = c_build_va_arg (loc, e1.value,\n-\t\t\t\t\t   groktypename (t1, &type_expr, NULL));\n-\t      if (type_expr)\n-\t\t{\n-\t\t  expr.value = build2 (C_MAYBE_CONST_EXPR,\n-\t\t\t\t       TREE_TYPE (expr.value), type_expr,\n-\t\t\t\t       expr.value);\n-\t\t  C_MAYBE_CONST_EXPR_NON_CONST (expr.value) = true;\n-\t\t}\n-\t    }\n+\t  {\n+\t    location_t start_loc = loc;\n+\t    c_parser_consume_token (parser);\n+\t    if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    e1 = c_parser_expr_no_commas (parser, NULL);\n+\t    mark_exp_read (e1.value);\n+\t    e1.value = c_fully_fold (e1.value, false, NULL);\n+\t    if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+\t      {\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    loc = c_parser_peek_token (parser)->location;\n+\t    t1 = c_parser_type_name (parser);\n+\t    location_t end_loc = c_parser_peek_token (parser)->get_finish ();\n+\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t       \"expected %<)%>\");\n+\t    if (t1 == NULL)\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree type_expr = NULL_TREE;\n+\t\texpr.value = c_build_va_arg (loc, e1.value,\n+\t\t\t\t\t     groktypename (t1, &type_expr, NULL));\n+\t\tif (type_expr)\n+\t\t  {\n+\t\t    expr.value = build2 (C_MAYBE_CONST_EXPR,\n+\t\t\t\t\t TREE_TYPE (expr.value), type_expr,\n+\t\t\t\t\t expr.value);\n+\t\t    C_MAYBE_CONST_EXPR_NON_CONST (expr.value) = true;\n+\t\t  }\n+\t\tset_c_expr_source_range (&expr, start_loc, end_loc);\n+\t      }\n+\t  }\n \t  break;\n \tcase RID_OFFSETOF:\n \t  c_parser_consume_token (parser);\n@@ -7561,9 +7578,11 @@ c_parser_postfix_expression (c_parser *parser)\n \t      }\n \t    else\n \t      c_parser_error (parser, \"expected identifier\");\n+\t    location_t end_loc = c_parser_peek_token (parser)->get_finish ();\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n \t    expr.value = fold_offsetof (offsetof_ref);\n+\t    set_c_expr_source_range (&expr, loc, end_loc);\n \t  }\n \t  break;\n \tcase RID_CHOOSE_EXPR:\n@@ -7951,6 +7970,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t       : init.original_code == C_MAYBE_CONST_EXPR);\n   non_const |= !type_expr_const;\n   expr.value = build_compound_literal (start_loc, type, init.value, non_const);\n+  set_c_expr_source_range (&expr, init.src_range);\n   expr.original_code = ERROR_MARK;\n   expr.original_type = NULL;\n   if (type != error_mark_node && type_expr)\n@@ -17546,6 +17566,8 @@ c_parser_transaction_expression (c_parser *parser, enum rid keyword)\n \t: \"%<__transaction_relaxed %> \"\n \t\"without transactional memory support enabled\"));\n \n+  set_c_expr_source_range (&ret, loc, loc);\n+\n   return ret;\n }\n "}, {"sha": "a1f14587d2740ef6f3843217b21d4ca16209e3a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bef08b718f9cacd17fb74fab77b125d2c92b7493", "patch": "@@ -1,3 +1,16 @@\n+2015-11-17  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic-test-expressions-1.c (vector): New\n+\tmacro.\n+\t(test_braced_init): New function.\n+\t(test_statement_expression): New function.\n+\t(test_address_of_label): New function.\n+\t(test_transaction_expressions): New function.\n+\t(test_keywords): New function.\n+\t(test_builtin_va_arg): New function.\n+\t(test_builtin_offsetof): New function.\n+\t* lib/multiline.exp (_build_multiline_regex): Escape braces.\n+\n 2015-11-17  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/68308"}, {"sha": "0d8c7c5fa10804c3b4fbfce9912a97ad2606a32b", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-expressions-1.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-expressions-1.c?ref=bef08b718f9cacd17fb74fab77b125d2c92b7493", "patch": "@@ -397,6 +397,127 @@ void test_comma_operator (int a, int b)\n    { dg-end-multiline-output \"\" } */\n }\n \n+/* Braced initializers.  ***************************************/\n+\n+/* We can't test the ranges of these directly, since the underlying\n+   tree nodes don't retain a location.  However, we can test that they\n+   have ranges during parsing by building compound expressions using\n+   them, and verifying the ranges of the compound expressions.  */\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+void test_braced_init (void)\n+{\n+  /* Verify start of range.  */\n+  __emit_expression_range (0, (vector(4, float)){2., 2., 2., 2.} + 1); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (vector(4, float)){2., 2., 2., 2.} + 1);\n+                                                 ~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Verify end of range.  */\n+  __emit_expression_range (0, &(vector(4, float)){2., 2., 2., 2.}); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &(vector(4, float)){2., 2., 2., 2.});\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Statement expressions.  ***************************************/\n+\n+void test_statement_expression (void)\n+{\n+  __emit_expression_range (0, ({ static int a; a; }) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ({ static int a; a; }) );\n+                               ~^~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Other expressions.  */\n+\n+void test_address_of_label (void)\n+{\n+ label:\n+  __emit_expression_range (0, &&label );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &&label );\n+                               ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_transaction_expressions (void)\n+{\n+  int i;\n+  i = __transaction_atomic (42); /* { dg-error \"without transactional memory support enabled\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   i = __transaction_atomic (42);\n+       ^~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  i = __transaction_relaxed (42); /* { dg-error \"without transactional memory support enabled\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   i = __transaction_relaxed (42);\n+       ^~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_keywords (int i)\n+{\n+  __emit_expression_range (0, __FUNCTION__[i] );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __FUNCTION__[i] );\n+                               ~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, __PRETTY_FUNCTION__ );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __PRETTY_FUNCTION__ );\n+                               ^~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, __func__ );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __func__ );\n+                               ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_builtin_va_arg (__builtin_va_list v)\n+{\n+  __emit_expression_range (0,  __builtin_va_arg (v, int) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_va_arg (v, int) );\n+                                ~~~~~~~~~~~~~~~~~~~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,  __builtin_va_arg (v, int) + 1 );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_va_arg (v, int) + 1 );\n+                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+struct s\n+{\n+  int f;\n+};\n+\n+void test_builtin_offsetof (int i)\n+{\n+  __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );\n+                                ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );\n+                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n /* Examples of non-trivial expressions.  ****************************/\n \n extern double sqrt (double x);"}, {"sha": "c3d05064d56659cd377b9b5771dcf67515cd387f", "filename": "gcc/testsuite/lib/multiline.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2Flib%2Fmultiline.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bef08b718f9cacd17fb74fab77b125d2c92b7493/gcc%2Ftestsuite%2Flib%2Fmultiline.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fmultiline.exp?ref=bef08b718f9cacd17fb74fab77b125d2c92b7493", "patch": "@@ -181,6 +181,8 @@ proc _build_multiline_regex { multiline index } {\n \t                      \")\" \"\\\\)\"\n \t                      \"[\" \"\\\\[\"\n \t                      \"]\" \"\\\\]\"\n+\t                      \"{\" \"\\\\{\"\n+\t                      \"}\" \"\\\\}\"\n \t                      \".\" \"\\\\.\"\n \t                      \"\\\\\" \"\\\\\\\\\"\n \t                      \"?\" \"\\\\?\""}]}