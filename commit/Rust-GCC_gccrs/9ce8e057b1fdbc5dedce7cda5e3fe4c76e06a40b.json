{"sha": "9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlOGUwNTdiMWZkYmM1ZGVkY2U3Y2RhNWUzZmU0Yzc2ZTA2YTQwYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-07-04T10:51:31Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-07-04T10:51:31Z"}, "message": "ada-tree.h (SET_TYPE_LANG_SPECIFIC): Rewrite.\n\n\t* ada-tree.h (SET_TYPE_LANG_SPECIFIC): Rewrite.\n\t(SET_DECL_LANG_SPECIFIC): Likewise.\n\t(TYPE_RM_VALUE): New macro.\n\t(SET_TYPE_RM_VALUE): Likewise.\n\t(TYPE_RM_SIZE): Rewrite in terms of TYPE_RM_VALUE.\n\t(TYPE_RM_MIN_VALUE): Likewise.\n\t(TYPE_RM_MAX_VALUE): Likewise.\n\t(SET_TYPE_RM_SIZE): Rewrite in terms of SET_TYPE_RM_VALUE.\n\t(SET_TYPE_RM_MIN_VALUE): Likewise.\n\t(SET_TYPE_RM_MAX_VALUE): Likewise.\n\t* decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Remove kludge.\n\nFrom-SVN: r149225", "tree": {"sha": "81e33b8e897470a3f663976d11c678939860ecb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81e33b8e897470a3f663976d11c678939860ecb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/comments", "author": null, "committer": null, "parents": [{"sha": "d8bf0ab8388745c139f526fe5a8b72fc17d24523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8bf0ab8388745c139f526fe5a8b72fc17d24523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8bf0ab8388745c139f526fe5a8b72fc17d24523"}], "stats": {"total": 79, "additions": 47, "deletions": 32}, "files": [{"sha": "dc1f29a45960af95a04177a90bd8887b31412848", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "patch": "@@ -1,3 +1,17 @@\n+2009-07-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ada-tree.h (SET_TYPE_LANG_SPECIFIC): Rewrite.\n+\t(SET_DECL_LANG_SPECIFIC): Likewise.\n+\t(TYPE_RM_VALUE): New macro.\n+\t(SET_TYPE_RM_VALUE): Likewise.\n+\t(TYPE_RM_SIZE): Rewrite in terms of TYPE_RM_VALUE.\n+\t(TYPE_RM_MIN_VALUE): Likewise.\n+\t(TYPE_RM_MAX_VALUE): Likewise.\n+\t(SET_TYPE_RM_SIZE): Rewrite in terms of SET_TYPE_RM_VALUE.\n+\t(SET_TYPE_RM_MIN_VALUE): Likewise.\n+\t(SET_TYPE_RM_MAX_VALUE): Likewise.\n+\t* decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Remove kludge.\n+\n 2009-07-04  Laurent GUERBY  <laurent@guerby.net>\n \n \tPR ada/40631"}, {"sha": "8d157224f2919682a75080dab1263bf85b95c14f", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "patch": "@@ -40,19 +40,25 @@ struct GTY(()) lang_decl { tree t; };\n #define GET_TYPE_LANG_SPECIFIC(NODE) \\\n   (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n \n-#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n-  (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n-   = (TYPE_LANG_SPECIFIC (NODE)\t\t\\\n-      ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type)))->t = (X)\n+#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\t\t    \\\n+do {\t\t\t\t\t\t\t    \\\n+  tree tmp = (X);\t\t\t\t\t    \\\n+  if (!TYPE_LANG_SPECIFIC (NODE))\t\t\t    \\\n+    TYPE_LANG_SPECIFIC (NODE) = GGC_NEW (struct lang_type); \\\n+  TYPE_LANG_SPECIFIC (NODE)->t = tmp;\t\t\t    \\\n+} while (0)\n \n /* Macros to get and set the tree in DECL_LANG_SPECIFIC.  */\n #define GET_DECL_LANG_SPECIFIC(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n \n-#define SET_DECL_LANG_SPECIFIC(NODE, X)\t\\\n-  (DECL_LANG_SPECIFIC (NODE)\t\t\\\n-   = (DECL_LANG_SPECIFIC (NODE)\t\t\\\n-      ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl)))->t = (X)\n+#define SET_DECL_LANG_SPECIFIC(NODE, X)\t\t\t    \\\n+do {\t\t\t\t\t\t\t    \\\n+  tree tmp = (X);\t\t\t\t\t    \\\n+  if (!DECL_LANG_SPECIFIC (NODE))\t\t\t    \\\n+    DECL_LANG_SPECIFIC (NODE) = GGC_NEW (struct lang_decl); \\\n+  DECL_LANG_SPECIFIC (NODE)->t = tmp;\t\t\t    \\\n+} while (0)\n \n \n /* Flags added to type nodes.  */\n@@ -184,6 +190,19 @@ struct GTY(()) lang_decl { tree t; };\n /* For numerical types, this holds various RM-defined values.  */\n #define TYPE_RM_VALUES(NODE) TYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n \n+/* Macros to get and set the individual values in TYPE_RM_VALUES.  */\n+#define TYPE_RM_VALUE(NODE, N)\t\t\t\t    \\\n+  (TYPE_RM_VALUES (NODE)\t\t\t\t    \\\n+   ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), (N)) : NULL_TREE)\n+\n+#define SET_TYPE_RM_VALUE(NODE, N, X)\t\t   \\\n+do {\t\t\t\t\t\t   \\\n+  tree tmp = (X);\t\t\t\t   \\\n+  if (!TYPE_RM_VALUES (NODE))\t\t\t   \\\n+    TYPE_RM_VALUES (NODE) = make_tree_vec (3);\t   \\\n+  TREE_VEC_ELT (TYPE_RM_VALUES (NODE), (N)) = tmp; \\\n+} while (0)\n+\n /* For numerical types, this is the RM size of the type, aka its precision.\n    There is a discrepancy between what is called precision here (and more\n    generally throughout gigi) and what is called precision in the GCC type\n@@ -196,12 +215,8 @@ struct GTY(()) lang_decl { tree t; };\n    the optimizer can pretend that they simply don't exist.  Therefore they\n    must be within the range of values allowed by the precision in the GCC\n    sense, hence TYPE_PRECISION be set to the Esize, not the RM size.  */\n-#define TYPE_RM_SIZE(NODE) \\\n-  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 0) : NULL_TREE)\n-#define SET_TYPE_RM_SIZE(NODE, X)\t\t\\\n-  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n-\t\t = (TYPE_RM_VALUES (NODE)\t\\\n-\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 0) = (X)\n+#define TYPE_RM_SIZE(NODE) TYPE_RM_VALUE ((NODE), 0)\n+#define SET_TYPE_RM_SIZE(NODE, X) SET_TYPE_RM_VALUE ((NODE), 0, (X))\n \n /* For numerical types, this is the RM lower bound of the type.  There is\n    again a discrepancy between this lower bound and the GCC lower bound,\n@@ -212,12 +227,8 @@ struct GTY(()) lang_decl { tree t; };\n    the optimizer can pretend that they simply don't exist.  Therefore they\n    must be within the range of values allowed by the lower bound in the GCC\n    sense, hence the GCC lower bound be set to that of the base type.  */\n-#define TYPE_RM_MIN_VALUE(NODE) \\\n-  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 1) : NULL_TREE)\n-#define SET_TYPE_RM_MIN_VALUE(NODE, X)\t\t\\\n-  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n-\t\t = (TYPE_RM_VALUES (NODE)\t\\\n-\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 1) = (X)\n+#define TYPE_RM_MIN_VALUE(NODE) TYPE_RM_VALUE ((NODE), 1)\n+#define SET_TYPE_RM_MIN_VALUE(NODE, X) SET_TYPE_RM_VALUE ((NODE), 1, (X))\n \n /* For numerical types, this is the RM upper bound of the type.  There is\n    again a discrepancy between this upper bound and the GCC upper bound,\n@@ -228,12 +239,8 @@ struct GTY(()) lang_decl { tree t; };\n    the optimizer can pretend that they simply don't exist.  Therefore they\n    must be within the range of values allowed by the upper bound in the GCC\n    sense, hence the GCC upper bound be set to that of the base type.  */\n-#define TYPE_RM_MAX_VALUE(NODE) \\\n-  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 2) : NULL_TREE)\n-#define SET_TYPE_RM_MAX_VALUE(NODE, X)\t\t\\\n-  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n-\t\t = (TYPE_RM_VALUES (NODE)\t\\\n-\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 2) = (X)\n+#define TYPE_RM_MAX_VALUE(NODE) TYPE_RM_VALUE ((NODE), 2)\n+#define SET_TYPE_RM_MAX_VALUE(NODE, X) SET_TYPE_RM_VALUE ((NODE), 2, (X))\n \n /* For numerical types, this is the lower bound of the type, i.e. the RM lower\n    bound for language-defined types and the GCC lower bound for others.  */"}, {"sha": "42086128cd7c87025e640be941711ecb1aa90d2f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9ce8e057b1fdbc5dedce7cda5e3fe4c76e06a40b", "patch": "@@ -2629,12 +2629,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n #endif\n \t\t}\n \n-\t      /* ??? This is necessary to make sure that the container is\n-\t\t allocated with a null tree upfront; otherwise, it could\n-\t\t be allocated with an uninitialized tree that is accessed\n-\t\t before being set below.  See ada-tree.h for details.  */\n-\t      SET_TYPE_ACTUAL_BOUNDS (gnu_inner_type, NULL_TREE);\n-\n \t      for (gnat_index = First_Index (gnat_entity);\n \t\t   Present (gnat_index); gnat_index = Next_Index (gnat_index))\n \t\tSET_TYPE_ACTUAL_BOUNDS"}]}