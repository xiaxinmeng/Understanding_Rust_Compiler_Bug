{"sha": "6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0ZmJjYzlmZGZlYzQ1ZWYzNTczMmY2YTQ3NmQ4NTRiZGM4YmMyMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-12-11T22:15:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-12-11T22:15:14Z"}, "message": "re PR rtl-optimization/59446 (loop2_doloop creates constant comparison and dead jump)\n\n\tPR rtl-optimization/59446\n\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Properly\n\ttest for crossing a loop header.\n\nFrom-SVN: r205905", "tree": {"sha": "a9cb801a8330eb419428ec94b56e79153311866b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9cb801a8330eb419428ec94b56e79153311866b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20/comments", "author": null, "committer": null, "parents": [{"sha": "26084432876599a44feed25b1cd80da581b8e658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26084432876599a44feed25b1cd80da581b8e658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26084432876599a44feed25b1cd80da581b8e658"}], "stats": {"total": 62, "additions": 28, "deletions": 34}, "files": [{"sha": "d580c4d41b7b7063fabbe7cf0fb9054696f456ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "patch": "@@ -1,3 +1,9 @@\n+2013-12-11  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/59446\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Properly\n+\ttest for crossing a loop header.\n+\n 2013-12-11  Sriraman Tallam  <tmsriram@google.com>\n \n \tPR target/59390"}, {"sha": "af8fd850835b2ca592f0e76201340e7e14ec1c54", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=6d4fbcc9fdfec45ef35732f6a476d854bdc8bc20", "patch": "@@ -1449,44 +1449,32 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t    {\n \t      vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n-\t      /* Basically we're looking for a situation where we can see\n-\t  \t 3 or more loop structures on a jump threading path.  */\n-\n-\t      struct loop *first_father = (*path)[0]->e->src->loop_father;\n-\t      struct loop *second_father = NULL;\n-\t      for (unsigned int i = 0; i < path->length (); i++)\n+\t      for (unsigned int i = 0, crossed_headers = 0;\n+\t\t   i < path->length ();\n+\t\t   i++)\n \t\t{\n-\t\t  /* See if this is a loop father we have not seen before.  */\n-\t\t  if ((*path)[i]->e->dest->loop_father != first_father\n-\t\t      && (*path)[i]->e->dest->loop_father != second_father)\n+\t\t  basic_block dest = (*path)[i]->e->dest;\n+\t\t  crossed_headers += (dest == dest->loop_father->header);\n+\t\t  if (crossed_headers > 1)\n \t\t    {\n-\t\t      /* We've already seen two loop fathers, so we\n-\t\t\t need to trim this jump threading path.  */\n-\t\t      if (second_father != NULL)\n-\t\t\t{\n-\t\t\t  /* Trim from entry I onwards.  */\n-\t\t\t  for (unsigned int j = i; j < path->length (); j++)\n-\t\t\t    delete (*path)[j];\n-\t\t\t  path->truncate (i);\n-\n-\t\t\t  /* Now that we've truncated the path, make sure\n-\t\t\t     what's left is still valid.   We need at least\n-\t\t\t     two edges on the path and the last edge can not\n-\t\t\t     be a joiner.  This should never happen, but let's\n-\t\t\t     be safe.  */\n-\t\t\t  if (path->length () < 2\n-\t\t\t      || (path->last ()->type\n-\t\t\t\t  == EDGE_COPY_SRC_JOINER_BLOCK))\n-\t\t\t    {\n-\t\t\t      delete_jump_thread_path (path);\n-\t\t\t      e->aux = NULL;\n-\t\t\t    }\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else\n+\t\t      /* Trim from entry I onwards.  */\n+\t\t      for (unsigned int j = i; j < path->length (); j++)\n+\t\t\tdelete (*path)[j];\n+\t\t      path->truncate (i);\n+\n+\t\t      /* Now that we've truncated the path, make sure\n+\t\t\t what's left is still valid.   We need at least\n+\t\t\t two edges on the path and the last edge can not\n+\t\t\t be a joiner.  This should never happen, but let's\n+\t\t\t be safe.  */\n+\t\t      if (path->length () < 2\n+\t\t\t  || (path->last ()->type\n+\t\t\t      == EDGE_COPY_SRC_JOINER_BLOCK))\n \t\t\t{\n-\t\t\t  second_father = (*path)[i]->e->dest->loop_father;\n+\t\t\t  delete_jump_thread_path (path);\n+\t\t\t  e->aux = NULL;\n \t\t\t}\n+\t\t      break;\n \t\t    }\n \t\t}\n \t    }"}]}