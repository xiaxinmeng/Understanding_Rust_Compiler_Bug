{"sha": "d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4MzYyNzM1YjUzZTgwMTVjOGM5MmNkZThmNDlkM2M3ZTVjYmU4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-12T14:18:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-12T14:18:57Z"}, "message": "i386.h (VALID_FP_MODE_P): XFmode is invalid on x86_64.\n\n\t* i386.h (VALID_FP_MODE_P): XFmode is invalid on x86_64.\n\t(MODES_TIEABLE_P): QImodes and DImodes are tiable on x86_64.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Save QImodes as QImodes for x86_64.\n\t(STATIC_CHAIN_REGNUM): Set to r10 for x86_64.\n\t(PIC_OFFSET_TABLE_REGNUM): Set to INVALID_REGNUM for x86_64.\n\t(LIMIT_RELOAD_CLASS): Avoid limiting of QImodes on x86_64.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): No need to QImodes.\n\t(PUSH_ROUNDING): x86_64 rounds to 64bits.\n\t(CONSTANT_ADDRESS_P): Accept CONST_DOUBLE.\n\t(REGPARM_MAX): Set to 6 for x86_64.\n\t(SSE_REGPARM_MAX): Set to 16 for x86_64.\n\t* i386.c (hard_regno_mode_ok): QImodes can be in all general purpose\n\tregisters.\n\n\t* (patterns that does use upper halves): Update constraints\n\t'q' to 'Q' and 'r' to 'R'.\n\t(cmpqi_ext_1): Disable for 64bit.\n\t(cmpqi_ext_3_insn): Likewise.\n\t(movqi_extzv_1): Likewsie.\n\t(addqi_ext_1): Liekwsie\n\t(testqi_ext_1): Liekwsie\n\t(andqi_ext_1): Liekwsie\n\t(xorqi_ext_1): Liekwsie\n\t(cmpqi_ext_1_rex64): New.\n\t(cmpqi_ext_3_insn_rex64): Likewise.\n\t(movqi_extzv_1_rex64): Likewsie.\n\t(addqi_ext_1_rex64): Liekwsie\n\t(testqi_ext_1_rex64): Liekwsie\n\t(andqi_ext_1_rex64): Liekwsie\n\t(xorqi_ext_1_rex64): Liekwsie\n\nFrom-SVN: r40411", "tree": {"sha": "8328430b965143eb48a6d53239c6d4310adbef3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8328430b965143eb48a6d53239c6d4310adbef3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/comments", "author": null, "committer": null, "parents": [{"sha": "6336e96f4e12b085de085299334bbef79afed23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6336e96f4e12b085de085299334bbef79afed23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6336e96f4e12b085de085299334bbef79afed23c"}], "stats": {"total": 348, "additions": 281, "deletions": 67}, "files": [{"sha": "cf724abdf6aa10f9933bf591b933e808d7678ea0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "patch": "@@ -1,3 +1,36 @@\n+Mon Mar 12 15:16:36 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (VALID_FP_MODE_P): XFmode is invalid on x86_64.\n+\t(MODES_TIEABLE_P): QImodes and DImodes are tiable on x86_64.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Save QImodes as QImodes for x86_64.\n+\t(STATIC_CHAIN_REGNUM): Set to r10 for x86_64.\n+\t(PIC_OFFSET_TABLE_REGNUM): Set to INVALID_REGNUM for x86_64.\n+\t(LIMIT_RELOAD_CLASS): Avoid limiting of QImodes on x86_64.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): No need to QImodes.\n+\t(PUSH_ROUNDING): x86_64 rounds to 64bits.\n+\t(CONSTANT_ADDRESS_P): Accept CONST_DOUBLE.\n+\t(REGPARM_MAX): Set to 6 for x86_64.\n+\t(SSE_REGPARM_MAX): Set to 16 for x86_64.\n+\t* i386.c (hard_regno_mode_ok): QImodes can be in all general purpose\n+\tregisters.\n+\n+\t* (patterns that does use upper halves): Update constraints\n+\t'q' to 'Q' and 'r' to 'R'.\n+\t(cmpqi_ext_1): Disable for 64bit.\n+\t(cmpqi_ext_3_insn): Likewise.\n+\t(movqi_extzv_1): Likewsie.\n+\t(addqi_ext_1): Liekwsie\n+\t(testqi_ext_1): Liekwsie\n+\t(andqi_ext_1): Liekwsie\n+\t(xorqi_ext_1): Liekwsie\n+\t(cmpqi_ext_1_rex64): New.\n+\t(cmpqi_ext_3_insn_rex64): Likewise.\n+\t(movqi_extzv_1_rex64): Likewsie.\n+\t(addqi_ext_1_rex64): Liekwsie\n+\t(testqi_ext_1_rex64): Liekwsie\n+\t(andqi_ext_1_rex64): Liekwsie\n+\t(xorqi_ext_1_rex64): Liekwsie\n+\n 2001-03-11  Zack Weinberg  <zackw@stanford.edu>\n \n \t* configure.in: Move check for unsigned enumerated bitfields   "}, {"sha": "85aeca0e0d425b2bcdf2fd31ce4ca50950754525", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "patch": "@@ -9169,7 +9169,7 @@ ix86_hard_regno_mode_ok (regno, mode)\n     return 0;\n   /* Take care for QImode values - they can be in non-QI regs, but then\n      they do cause partial register stalls.  */\n-  if (regno < 4 || mode != QImode)\n+  if (regno < 4 || mode != QImode || TARGET_64BIT)\n     return 1;\n   return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n }"}, {"sha": "58f622bf8f417998efbad092edbe3550b4db3f41", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "patch": "@@ -861,9 +861,9 @@ extern int ix86_arch;\n \n #define VALID_FP_MODE_P(mode) \\\n     ((mode) == SFmode || (mode) == DFmode || (mode) == TFmode\t\\\n-     || (mode) == XFmode\t\t\t\t\t\\\n+     || (!TARGET_64BIT && (mode) == XFmode)\t\t\t\\\n      || (mode) == SCmode || (mode) == DCmode || (mode) == TCmode\\\n-     || (mode) == XCmode)\n+     || (!TARGET_64BIT && (mode) == XCmode))\n \n #define VALID_INT_MODE_P(mode) \\\n     ((mode) == QImode || (mode) == HImode || (mode) == SImode\t\\\n@@ -883,8 +883,15 @@ extern int ix86_arch;\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n   ((MODE1) == (MODE2)\t\t\t\t\t\t\\\n-   || ((MODE1) == SImode && (MODE2) == HImode)\t\t\t\\\n-   || ((MODE1) == HImode && (MODE2) == SImode))\n+   || (((MODE1) == HImode || (MODE1) == SImode\t\t\t\\\n+\t|| ((MODE1) == QImode\t\t\t\t\t\\\n+\t    && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))\t\\\n+        || ((MODE1) == DImode && TARGET_64BIT))\t\t\t\\\n+       && ((MODE2) == HImode || (MODE2) == SImode\t\t\\\n+\t   || ((MODE1) == QImode\t\t\t\t\\\n+\t       && (TARGET_64BIT || !TARGET_PARTIAL_REG_STALL))\t\\\n+\t   || ((MODE2) == DImode && TARGET_64BIT))))\n+\n \n /* Specify the modes required to caller save a given hard regno.\n    We do this on i386 to prevent flags from being saved at all.\n@@ -896,8 +903,8 @@ extern int ix86_arch;\n    : (MODE) == VOIDmode && (NREGS) != 1 ? VOIDmode\t\t\\\n    : (MODE) == VOIDmode ? choose_hard_reg_mode ((REGNO), (NREGS)) \\\n    : (MODE) == HImode && !TARGET_PARTIAL_REG_STALL ? SImode\t\\\n-   : (MODE) == QImode && (REGNO) >= 4 ? SImode : (MODE))\n-\n+   : (MODE) == QImode && (REGNO) >= 4 && !TARGET_64BIT ? SImode \\\n+   : (MODE))\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n@@ -955,12 +962,17 @@ extern int ix86_arch;\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 16\n \n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 2\n+/* Register in which static-chain is passed to a function.\n+   We do use ECX as static chain register for 32 bit ABI.  On the\n+   64bit ABI, ECX is an argument register, so we use R10 instead.  */\n+#define STATIC_CHAIN_REGNUM (TARGET_64BIT ? FIRST_REX_INT_REG + 10 - 8 : 2)\n \n /* Register to hold the addressing base for position independent\n-   code access to data items.  */\n-#define PIC_OFFSET_TABLE_REGNUM 3\n+   code access to data items.\n+   We don't use PIC pointer for 64bit mode.  Define the regnum to\n+   dummy value to prevent gcc from pesimizing code dealing with EBX.\n+ */\n+#define PIC_OFFSET_TABLE_REGNUM (TARGET_64BIT ? INVALID_REGNUM : 3)\n \n /* Register in which address to store a structure value\n    arrives in the function.  On the 386, the prologue\n@@ -1239,8 +1251,9 @@ enum reg_class\n    is necessary to be able to hold a value of mode MODE in a reload\n    register for which class CLASS would ordinarily be used. */\n \n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n-  ((MODE) == QImode && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS) \\\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) \t\t\t\\\n+  ((MODE) == QImode && !TARGET_64BIT\t\t\t\t\\\n+   && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS) \t\t\\\n    ? Q_REGS : (CLASS))\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -1269,7 +1282,8 @@ enum reg_class\n    pseudo.  */\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT) \\\n-  ((CLASS) == GENERAL_REGS && (MODE) == QImode ? Q_REGS : NO_REGS)\n+  ((CLASS) == GENERAL_REGS && !TARGET_64BIT && (MODE) == QImode\t\t\\\n+   ? Q_REGS : NO_REGS)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -1340,9 +1354,15 @@ enum reg_class\n    this says how many the stack pointer really advances by.\n    On 386 pushw decrements by exactly 2 no matter what the position was.\n    On the 386 there is no pushb; we use pushw instead, and this\n-   has the effect of rounding up to 2.  */\n+   has the effect of rounding up to 2.\n+ \n+   For 64bit ABI we round up to 8 bytes.\n+ */\n \n-#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & (-2))\n+#define PUSH_ROUNDING(BYTES) \\\n+  (TARGET_64BIT\t\t     \\\n+   ? (((BYTES) + 7) & (-8))  \\\n+   : (((BYTES) + 1) & (-2)))\n \n /* If defined, the maximum amount of space required for outgoing arguments will\n    be computed and placed into the variable\n@@ -1803,7 +1823,8 @@ pop{l} %0\"\t\t\t\t\t\t\t\\\n \n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\\\n+   || GET_CODE (X) == CONST_DOUBLE)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n@@ -2183,7 +2204,9 @@ while (0)\n    is also used as the pic register in ELF.  So for now, don't allow more than\n    3 registers to be passed in registers.  */\n \n-#define REGPARM_MAX 3\n+#define REGPARM_MAX (TARGET_64BIT ? 6 : 3)\n+\n+#define SSE_REGPARM_MAX (TARGET_64BIT ? 16 : 0)\n \n \f\n /* Specify the machine mode that this machine uses"}, {"sha": "b350729d62a2eae09e4721ad3272bb06d7bc4501", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 207, "deletions": 49, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d28362735b53e8015c8c92cde8f49d3c7e5cbe82/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d28362735b53e8015c8c92cde8f49d3c7e5cbe82", "patch": "@@ -1,7 +1,8 @@\n-;; GCC machine description for IA-32.\n+;; GCC machine description for IA-32 and x86-64.\n ;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n ;; Free Software Foundation, Inc.\n ;; Mostly by William Schelter.\n+;; x86_64 support added by Jan Hubicka\n ;;\n ;; This file is part of GNU CC.\n ;;\n@@ -1165,13 +1166,27 @@\n (define_insn \"*cmpqi_ext_1\"\n   [(set (reg 17)\n \t(compare\n-\t  (match_operand:QI 0 \"general_operand\" \"qm\")\n+\t  (match_operand:QI 0 \"general_operand\" \"Qm\")\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"q\")\n+\t      (match_operand 1 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)))]\n-  \"ix86_match_ccmode (insn, CCmode)\"\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\"\n+  \"cmp{b}\\\\t{%h1, %0|%0, %h1}\"\n+  [(set_attr \"type\" \"icmp\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*cmpqi_ext_1_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (match_operand:QI 0 \"ext_register_operand\" \"Q\")\n+\t  (subreg:QI\n+\t    (zero_extract:SI\n+\t      (match_operand 1 \"ext_register_operand\" \"Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\"\n   \"cmp{b}\\\\t{%h1, %0|%0, %h1}\"\n   [(set_attr \"type\" \"icmp\")\n    (set_attr \"mode\" \"QI\")])\n@@ -1181,7 +1196,7 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n \t  (match_operand:QI 1 \"const0_operand\" \"n\")))]\n@@ -1196,10 +1211,10 @@\n \t(compare:CC\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n-\t  (match_operand:QI 1 \"general_operand\" \"qmn\")))]\n+\t  (match_operand:QI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -1208,11 +1223,25 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n-\t  (match_operand:QI 1 \"general_operand\" \"qmn\")))]\n-  \"ix86_match_ccmode (insn, CCmode)\"\n+\t  (match_operand:QI 1 \"general_operand\" \"Qmn\")))]\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\"\n+  \"cmp{b}\\\\t{%1, %h0|%h0, %1}\"\n+  [(set_attr \"type\" \"icmp\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"cmpqi_ext_3_insn_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (subreg:QI\n+\t    (zero_extract:SI\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n+\t      (const_int 8)\n+\t      (const_int 8)) 0)\n+\t  (match_operand:QI 1 \"nonmemory_operand\" \"Qn\")))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCmode)\"\n   \"cmp{b}\\\\t{%1, %h0|%h0, %1}\"\n   [(set_attr \"type\" \"icmp\")\n    (set_attr \"mode\" \"QI\")])\n@@ -1222,12 +1251,12 @@\n \t(compare\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)\n \t  (subreg:QI\n \t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"q\")\n+\t      (match_operand 1 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)) 0)))]\n   \"ix86_match_ccmode (insn, CCmode)\"\n@@ -1995,8 +2024,8 @@\n    (set_attr \"length_immediate\" \"0\")])\n \n (define_insn \"*movsi_extv_1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"q\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=R\")\n+\t(sign_extract:SI (match_operand:SI 1 \"ext_register_operand\" \"Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8)))]\n   \"\"\n@@ -2005,8 +2034,8 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*movhi_extv_1\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extract:HI (match_operand:SI 1 \"register_operand\" \"q\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=R\")\n+\t(sign_extract:HI (match_operand:SI 1 \"ext_register_operand\" \"Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8)))]\n   \"\"\n@@ -2043,21 +2072,21 @@\n \t(const_string \"QI\")))])\n \n (define_insn \"*movsi_extzv_1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand 1 \"ext_register_operand\" \"q\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=R\")\n+\t(zero_extract:SI (match_operand 1 \"ext_register_operand\" \"Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8)))]\n   \"\"\n   \"movz{bl|x}\\\\t{%h1, %0|%0, %h1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*movqi_extzv_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,?r\")\n-        (subreg:QI (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"q,q\")\n+(define_insn \"*movqi_extzv_2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=Qm,?R\")\n+        (subreg:QI (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"Q,Q\")\n \t\t\t\t    (const_int 8)\n \t\t\t\t    (const_int 8)) 0))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n   \"*\n {\n   switch (get_attr_type (insn))\n@@ -2080,21 +2109,58 @@\n \t(const_string \"SI\")\n \t(const_string \"QI\")))])\n \n+(define_insn \"*movqi_extzv_2_rex64\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=Q,?R\")\n+        (subreg:QI (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"Q,Q\")\n+\t\t\t\t    (const_int 8)\n+\t\t\t\t    (const_int 8)) 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_IMOVX:\n+      return \\\"movz{bl|x}\\\\t{%h1, %k0|%k0, %h1}\\\";\n+    default:\n+      return \\\"mov{b}\\\\t{%h1, %0|%0, %h1}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (ior (not (match_operand:QI 0 \"q_regs_operand\" \"\"))\n+\t\t\t(ne (symbol_ref \"TARGET_MOVX\")\n+\t\t\t    (const_int 0)))\n+\t(const_string \"imovx\")\n+\t(const_string \"imov\")))\n+   (set (attr \"mode\")\n+     (if_then_else (eq_attr \"type\" \"imovx\")\n+\t(const_string \"SI\")\n+\t(const_string \"QI\")))])\n+\n (define_insn \"*movsi_insv_1\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"+q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"+Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(match_operand:SI 1 \"nonimmediate_operand\" \"qm\"))]\n-  \"\"\n+\t(match_operand:SI 1 \"nonimmediate_operand\" \"Qm\"))]\n+  \"!TARGET_64BIT\"\n+  \"mov{b}\\\\t{%b1, %h0|%h0, %b1}\"\n+  [(set_attr \"type\" \"imov\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*movsi_insv_1_rex64\"\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"+Q\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(match_operand:SI 1 \"ext_register_operand\" \"Q\"))]\n+  \"TARGET_64BIT\"\n   \"mov{b}\\\\t{%b1, %h0|%h0, %b1}\"\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*movqi_insv_2\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"+q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"+Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(and:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"q\")\n+\t(and:SI (lshiftrt:SI (match_operand:SI 1 \"ext_register_operand\" \"Q\")\n \t\t\t     (const_int 8))\n \t\t(const_int 255)))]\n   \"\"\n@@ -5448,7 +5514,42 @@\n \t    (const_int 8))\n \t  (match_operand:QI 2 \"general_operand\" \"qmn\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n+  \"*\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_INCDEC:\n+      if (operands[2] == const1_rtx)\n+\treturn \\\"inc{b}\\\\t%h0\\\";\n+      else if (operands[2] == constm1_rtx\n+\t       || (GET_CODE (operands[2]) == CONST_INT\n+\t\t   && INTVAL (operands[2]) == 255))\n+\treturn \\\"dec{b}\\\\t%h0\\\";\n+      abort();\n+\n+    default:\n+      return \\\"add{b}\\\\t{%2, %h0|%h0, %2}\\\";\n+    }\n+}\"\n+  [(set (attr \"type\")\n+     (if_then_else (match_operand:QI 2 \"incdec_operand\" \"\")\n+\t(const_string \"incdec\")\n+\t(const_string \"alu\")))\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*addqi_ext_1_rex64\"\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(plus:SI\n+\t  (zero_extract:SI\n+\t    (match_operand 1 \"ext_register_operand\" \"0\")\n+\t    (const_int 8)\n+\t    (const_int 8))\n+\t  (match_operand:QI 2 \"nonmemory_operand\" \"Qn\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n   \"*\n {\n   switch (get_attr_type (insn))\n@@ -5473,7 +5574,7 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*addqi_ext_2\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(plus:SI\n@@ -5482,7 +5583,7 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extract:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"q\")\n+\t    (match_operand 2 \"ext_register_operand\" \"Q\")\n \t    (const_int 8)\n \t    (const_int 8))))\n    (clobber (reg:CC 17))]\n@@ -6238,7 +6339,7 @@\n \t(compare\n \t  (and:SI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8))\n \t    (match_operand 1 \"const_int_operand\" \"n\"))\n@@ -6256,13 +6357,29 @@\n \t(compare\n \t  (and:SI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8))\n \t    (zero_extend:SI\n-\t      (match_operand:QI 1 \"nonimmediate_operand\" \"qm\")))\n+\t      (match_operand:QI 1 \"nonimmediate_operand\" \"Qm\")))\n \t  (const_int 0)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\"\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"test{b}\\\\t{%1, %h0|%h0, %1}\"\n+  [(set_attr \"type\" \"test\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*testqi_ext_1_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (and:SI\n+\t    (zero_extract:SI\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n+\t      (const_int 8)\n+\t      (const_int 8))\n+\t    (zero_extend:SI\n+\t      (match_operand:QI 1 \"ext_register_operand\" \"Q\")))\n+\t  (const_int 0)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"test{b}\\\\t{%1, %h0|%h0, %1}\"\n   [(set_attr \"type\" \"test\")\n    (set_attr \"mode\" \"QI\")])\n@@ -6272,11 +6389,11 @@\n \t(compare\n \t  (and:SI\n \t    (zero_extract:SI\n-\t      (match_operand 0 \"ext_register_operand\" \"q\")\n+\t      (match_operand 0 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8))\n \t    (zero_extract:SI\n-\t      (match_operand 1 \"ext_register_operand\" \"q\")\n+\t      (match_operand 1 \"ext_register_operand\" \"Q\")\n \t      (const_int 8)\n \t      (const_int 8)))\n \t  (const_int 0)))]\n@@ -6566,7 +6683,7 @@\n ;; for a QImode operand, which of course failed.\n \n (define_insn \"andqi_ext_0\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(and:SI \n@@ -6591,11 +6708,11 @@\n \t  (and:SI\n \t    (zero_extract:SI\n \t      (match_operand 1 \"ext_register_operand\" \"0\")\n-\t      (const_int 8)\n+\t\t(const_int 8)\n \t      (const_int 8))\n \t    (match_operand 2 \"const_int_operand\" \"n\"))\n \t  (const_int 0)))\n-   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(and:SI \n@@ -6612,7 +6729,7 @@\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*andqi_ext_1\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(and:SI \n@@ -6621,16 +6738,34 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"general_operand\" \"qm\"))))\n+\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"!TARGET_64BIT\"\n+  \"and{b}\\\\t{%2, %h0|%h0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length_immediate\" \"0\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*andqi_ext_1_rex64\"\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(and:SI \n+\t  (zero_extract:SI\n+\t    (match_operand 1 \"ext_register_operand\" \"0\")\n+\t    (const_int 8)\n+\t    (const_int 8))\n+\t  (zero_extend:SI\n+\t    (match_operand:QI 2 \"ext_register_operand\" \"Q\"))))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_64BIT\"\n   \"and{b}\\\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*andqi_ext_2\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(and:SI\n@@ -6639,7 +6774,7 @@\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (zero_extract:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"q\")\n+\t    (match_operand 2 \"ext_register_operand\" \"Q\")\n \t    (const_int 8)\n \t    (const_int 8))))\n    (clobber (reg:CC 17))]\n@@ -6924,14 +7059,14 @@\n    (set_attr \"mode\" \"QI,QI,SI\")])\n \n (define_insn \"*xorqi_ext_1\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=q\")\n+  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n \t(xor:SI \n \t  (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0\")\n \t  \t\t   (const_int 8)\n \t\t\t   (const_int 8))\n-\t  (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"q\")\n+\t  (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n \t  \t\t   (const_int 8)\n \t\t\t   (const_int 8))))\n    (clobber (reg:CC 17))]\n@@ -6984,7 +7119,28 @@\n \t(xor:SI \n \t  (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8))\n \t  (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\"\n+  \"!TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"xor{b}\\\\t{%2, %h0|%h0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"QI\")])\n+\n+(define_insn \"*xorqi_cc_ext_1_rex64\"\n+  [(set (reg 17)\n+\t(compare\n+\t  (xor:SI\n+\t    (zero_extract:SI\n+\t      (match_operand 1 \"ext_register_operand\" \"0\")\n+\t      (const_int 8)\n+\t      (const_int 8))\n+\t    (match_operand:QI 2 \"nonmemory_operand\" \"Qn\"))\n+\t  (const_int 0)))\n+   (set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 8))\n+\t(xor:SI \n+\t  (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8))\n+\t  (match_dup 2)))]\n+  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\"\n   \"xor{b}\\\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n@@ -7024,14 +7180,16 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"ix86_unary_operator_ok (NEG, DImode, operands)\"\n+  \"!TARGET_64BIT\n+   && ix86_unary_operator_ok (NEG, DImode, operands)\"\n   \"#\")\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"reload_completed\"\n+  \"reload_completed\n+   && !TARGET_64BIT\"\n   [(parallel\n     [(set (reg:CCZ 17)\n \t  (compare:CCZ (neg:SI (match_dup 2)) (const_int 0)))"}]}