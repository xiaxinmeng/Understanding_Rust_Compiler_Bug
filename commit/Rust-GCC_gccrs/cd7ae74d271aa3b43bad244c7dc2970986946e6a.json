{"sha": "cd7ae74d271aa3b43bad244c7dc2970986946e6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q3YWU3NGQyNzFhYTNiNDNiYWQyNDRjN2RjMjk3MDk4Njk0NmU2YQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-08-09T10:56:11Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-08-09T10:56:11Z"}, "message": "tree-vect-transform.c (vectorizable_store): Remove call to copy_virtual_operands() and call mark_symbols_for_renaming() for...\n\n\t* tree-vect-transform.c (vectorizable_store): Remove call to\n\tcopy_virtual_operands() and call mark_symbols_for_renaming() for\n\tthe created vector store.\n\t(vect_setup_realignment): Don't call copy_virtual_operands() and\n\tupdate_vuses_to_preheader(). \n\t(vectorizable_load): Don't call copy_virtual_operands(). \n\t(update_vuses_to_preheader): Remove.\n\nFrom-SVN: r127315", "tree": {"sha": "02df24d19d65d79981aa9158fb91bc2328904c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02df24d19d65d79981aa9158fb91bc2328904c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd7ae74d271aa3b43bad244c7dc2970986946e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7ae74d271aa3b43bad244c7dc2970986946e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7ae74d271aa3b43bad244c7dc2970986946e6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7ae74d271aa3b43bad244c7dc2970986946e6a/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbb85475daaa722ff0c8330b730857784df48bb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb85475daaa722ff0c8330b730857784df48bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb85475daaa722ff0c8330b730857784df48bb5"}], "stats": {"total": 126, "additions": 15, "deletions": 111}, "files": [{"sha": "010ed442ec7c97a2db00240bb70c821107a57bf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ae74d271aa3b43bad244c7dc2970986946e6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ae74d271aa3b43bad244c7dc2970986946e6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd7ae74d271aa3b43bad244c7dc2970986946e6a", "patch": "@@ -1,3 +1,13 @@\n+2007-08-09  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-transform.c (vectorizable_store): Remove call to\n+\tcopy_virtual_operands() and call mark_symbols_for_renaming() for\n+\tthe created vector store.\n+\t(vect_setup_realignment): Don't call copy_virtual_operands() and\n+\tupdate_vuses_to_preheader(). \n+\t(vectorizable_load): Don't call copy_virtual_operands(). \n+\t(update_vuses_to_preheader): Remove.\n+\n 2007-08-08  Chao-ying Fu  <fu@mips.com>\n \n \t* tree.def (FIXED_POINT_TYPE): New type."}, {"sha": "ac5c00d46ce7188f6220720e744bb008a684afd1", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 5, "deletions": 111, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7ae74d271aa3b43bad244c7dc2970986946e6a/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7ae74d271aa3b43bad244c7dc2970986946e6a/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cd7ae74d271aa3b43bad244c7dc2970986946e6a", "patch": "@@ -58,7 +58,6 @@ static tree vect_init_vector (tree, tree, tree);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n static bool vect_is_simple_cond (tree, loop_vec_info); \n-static void update_vuses_to_preheader (tree, struct loop*);\n static void vect_create_epilog_for_reduction (tree, tree, enum tree_code, tree);\n static tree get_initial_def_for_reduction (tree, tree, tree *);\n \n@@ -3871,8 +3870,6 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n-  ssa_op_iter iter;\n-  def_operand_p def_p;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n   stmt_vec_info prev_stmt_info = NULL;\n@@ -4089,36 +4086,12 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  /* Arguments are ready. Create the new vector stmt.  */\n \t  new_stmt = build_gimple_modify_stmt (data_ref, vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-\n-\t  /* Set the VDEFs for the vector pointer. If this virtual def\n-\t     has a use outside the loop and a loop peel is performed\n-\t     then the def may be renamed by the peel.  Mark it for\n-\t     renaming so the later use will also be renamed.  */\n-\t  copy_virtual_operands (new_stmt, next_stmt);\n-\t  if (j == 0)\n-\t    {\n-\t      /* The original store is deleted so the same SSA_NAMEs\n-\t\t can be used.  */\n-\t      FOR_EACH_SSA_TREE_OPERAND (def, next_stmt, iter, SSA_OP_VDEF)\n-\t\t{\n-\t\t  SSA_NAME_DEF_STMT (def) = new_stmt;\n-\t\t  mark_sym_for_renaming (SSA_NAME_VAR (def));\n-\t\t}\n-\t      \n-\t      STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n-\t    }\n+\t  mark_symbols_for_renaming (new_stmt);\n+\t  \n+          if (j == 0)\n+            STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n \t  else\n-\t    {\n-\t      /* Create new names for all the definitions created by COPY and\n-\t\t add replacement mappings for each new name.  */\n-\t      FOR_EACH_SSA_DEF_OPERAND (def_p, new_stmt, iter, SSA_OP_VDEF)\n-\t\t{\n-\t\t  create_new_def_for (DEF_FROM_PTR (def_p), new_stmt, def_p);\n-\t\t  mark_sym_for_renaming (SSA_NAME_VAR (DEF_FROM_PTR (def_p)));\n-\t\t}\n-\t      \n-\t      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-\t    }\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \n \t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n \t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n@@ -4204,8 +4177,6 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n   new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n   gcc_assert (!new_bb);\n   msq_init = GIMPLE_STMT_OPERAND (new_stmt, 0);\n-  copy_virtual_operands (new_stmt, stmt);\n-  update_vuses_to_preheader (new_stmt, loop);\n \n   /* 2. Create permutation mask, if required, in loop preheader.  */\n   if (targetm.vectorize.builtin_mask_for_load)\n@@ -4780,7 +4751,6 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n \t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-\t  copy_virtual_operands (new_stmt, stmt);\n \t  mark_symbols_for_renaming (new_stmt);\n \n \t  /* 3. Handle explicit realignment if necessary/supported.  */\n@@ -5277,82 +5247,6 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n }\n \n \n-/* Function update_vuses_to_preheader.\n-\n-   Input:\n-   STMT - a statement with potential VUSEs.\n-   LOOP - the loop whose preheader will contain STMT.\n-\n-   It's possible to vectorize a loop even though an SSA_NAME from a VUSE\n-   appears to be defined in a VDEF in another statement in a loop.\n-   One such case is when the VUSE is at the dereference of a __restricted__\n-   pointer in a load and the VDEF is at the dereference of a different\n-   __restricted__ pointer in a store.  Vectorization may result in\n-   copy_virtual_uses being called to copy the problematic VUSE to a new\n-   statement that is being inserted in the loop preheader.  This procedure\n-   is called to change the SSA_NAME in the new statement's VUSE from the\n-   SSA_NAME updated in the loop to the related SSA_NAME available on the\n-   path entering the loop.\n-\n-   When this function is called, we have the following situation:\n-\n-        # vuse <name1>\n-        S1: vload\n-    do {\n-        # name1 = phi < name0 , name2>\n-\n-        # vuse <name1>\n-        S2: vload\n-\n-        # name2 = vdef <name1>\n-        S3: vstore\n-\n-    }while...\n-\n-   Stmt S1 was created in the loop preheader block as part of misaligned-load\n-   handling. This function fixes the name of the vuse of S1 from 'name1' to\n-   'name0'.  */\n-\n-static void\n-update_vuses_to_preheader (tree stmt, struct loop *loop)\n-{\n-  basic_block header_bb = loop->header;\n-  edge preheader_e = loop_preheader_edge (loop);\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_VUSE)\n-    {\n-      tree ssa_name = USE_FROM_PTR (use_p);\n-      tree def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n-      tree name_var = SSA_NAME_VAR (ssa_name);\n-      basic_block bb = bb_for_stmt (def_stmt);\n-\n-      /* For a use before any definitions, def_stmt is a NOP_EXPR.  */\n-      if (!IS_EMPTY_STMT (def_stmt)\n-\t  && flow_bb_inside_loop_p (loop, bb))\n-        {\n-          /* If the block containing the statement defining the SSA_NAME\n-             is in the loop then it's necessary to find the definition\n-             outside the loop using the PHI nodes of the header.  */\n-\t  tree phi;\n-\t  bool updated = false;\n-\n-\t  for (phi = phi_nodes (header_bb); phi; phi = PHI_CHAIN (phi))\n-\t    {\n-\t      if (SSA_NAME_VAR (PHI_RESULT (phi)) == name_var)\n-\t\t{\n-\t\t  SET_USE (use_p, PHI_ARG_DEF (phi, preheader_e->dest_idx));\n-\t\t  updated = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  gcc_assert (updated);\n-\t}\n-    }\n-}\n-\n-\n /*   Function vect_update_ivs_after_vectorizer.\n \n      \"Advance\" the induction variables of LOOP to the value they should take"}]}