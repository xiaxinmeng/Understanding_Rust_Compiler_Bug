{"sha": "ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyZGZkZWYyZjJlMDFjNTc5ZGQyODBkYWExZDgxZmJlYjRkN2FjNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-12T14:01:08Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-12-12T14:01:08Z"}, "message": "Fortran: Enable inquiry references in data statements [PR98022].\n\n2020-12-12  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/98022\n\t* data.c (gfc_assign_data_value): Handle inquiry references in\n\tthe data statement object list.\n\ngcc/testsuite/\n\tPR fortran/98022\n\t* gfortran.dg/data_inquiry_ref.f90: New test.", "tree": {"sha": "de38e472022e77f57b153b0bab5c7a31ea39c4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de38e472022e77f57b153b0bab5c7a31ea39c4c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5/comments", "author": null, "committer": null, "parents": [{"sha": "0bd675183d94e6bca100c3aaaf87ee9676fb3c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd675183d94e6bca100c3aaaf87ee9676fb3c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd675183d94e6bca100c3aaaf87ee9676fb3c26"}], "stats": {"total": 107, "additions": 94, "deletions": 13}, "files": [{"sha": "3e52a5717b5017c45f5cec239630fdb14cdf43e0", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "patch": "@@ -20,14 +20,14 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* Notes for DATA statement implementation:\n-\t\t\t\t\t\t\t\t\t       \n+\n    We first assign initial value to each symbol by gfc_assign_data_value\n    during resolving DATA statement. Refer to check_data_variable and\n    traverse_data_list in resolve.c.\n-\t\t\t\t\t\t\t\t\t       \n+\n    The complexity exists in the handling of array section, implied do\n    and array of struct appeared in DATA statement.\n-\t\t\t\t\t\t\t\t\t       \n+\n    We call gfc_conv_structure, gfc_con_array_array_initializer,\n    etc., to convert the initial value. Refer to trans-expr.c and\n    trans-array.c.  */\n@@ -464,6 +464,54 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t    }\n \t  break;\n \n+\tcase REF_INQUIRY:\n+\n+\t  /* This breaks with the other reference types in that the output\n+\t     constructor has to be of type COMPLEX, whereas the lvalue is\n+\t     of type REAL.  The rvalue is copied to the real or imaginary\n+\t     part as appropriate.  */\n+\t  gcc_assert (ref->next == NULL && last_ts->type == BT_COMPLEX);\n+\t  expr = gfc_copy_expr (rvalue);\n+\t  if (!gfc_compare_types (&lvalue->ts, &expr->ts))\n+\t    gfc_convert_type (expr, &lvalue->ts, 0);\n+\n+\t  if (last_con->expr)\n+\t    gfc_free_expr (last_con->expr);\n+\n+\t  last_con->expr = gfc_get_constant_expr (BT_COMPLEX,\n+\t\t\t\t\t\t  last_ts->kind,\n+\t\t\t\t\t\t  &lvalue->where);\n+\n+\t  /* Rejection of LEN and KIND inquiry references is handled\n+\t     elsewhere. The error here is added as backup. The assertion\n+\t     of F2008 for RE and IM is also done elsewhere.  */\n+\t  switch (ref->u.i)\n+\t    {\n+\t    case INQUIRY_LEN:\n+\t    case INQUIRY_KIND:\n+\t      gfc_error (\"LEN or KIND inquiry ref in DATA statement at %L\",\n+\t\t\t &lvalue->where);\n+\t      goto abort;\n+\t    case INQUIRY_RE:\n+\t      mpfr_set (mpc_realref (last_con->expr->value.complex),\n+\t\t\texpr->value.real,\n+\t\t\tGFC_RND_MODE);\n+\t      mpfr_set_ui (mpc_imagref (last_con->expr->value.complex),\n+\t\t\t   0.0, GFC_RND_MODE);\n+\t      break;\n+\t    case INQUIRY_IM:\n+\t      mpfr_set (mpc_imagref (last_con->expr->value.complex),\n+\t\t\texpr->value.real,\n+\t\t\tGFC_RND_MODE);\n+\t      mpfr_set_ui (mpc_realref (last_con->expr->value.complex),\n+\t\t\t   0.0, GFC_RND_MODE);\n+\t      break;\n+\t    }\n+\n+\t  gfc_free_expr (expr);\n+\t  mpz_clear (offset);\n+\t  return true;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -513,7 +561,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t  && gfc_has_default_initializer (lvalue->ts.u.derived))\n \t{\n \t  gfc_error (\"Nonpointer object %qs with default initialization \"\n-\t\t     \"shall not appear in a DATA statement at %L\", \n+\t\t     \"shall not appear in a DATA statement at %L\",\n \t\t     symbol->name, &lvalue->where);\n \t  return false;\n \t}\n@@ -540,13 +588,13 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \n /* Modify the index of array section and re-calculate the array offset.  */\n \n-void \n+void\n gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n \t\t     mpz_t *offset_ret)\n {\n   int i;\n   mpz_t delta;\n-  mpz_t tmp; \n+  mpz_t tmp;\n   bool forwards;\n   int cmp;\n   gfc_expr *start, *end, *stride;\n@@ -567,21 +615,21 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n \t    forwards = true;\n \t  else\n \t    forwards = false;\n-\t  gfc_free_expr(stride);\t\n+\t  gfc_free_expr(stride);\n \t}\n       else\n \t{\n \t  mpz_add_ui (section_index[i], section_index[i], 1);\n \t  forwards = true;\n \t}\n-      \n+\n       if (ar->end[i])\n         {\n \t  end = gfc_copy_expr(ar->end[i]);\n \t  if(!gfc_simplify_expr(end, 1))\n \t    gfc_internal_error(\"Simplification error\");\n \t  cmp = mpz_cmp (section_index[i], end->value.integer);\n-\t  gfc_free_expr(end);\t\n+\t  gfc_free_expr(end);\n \t}\n       else\n \tcmp = mpz_cmp (section_index[i], ar->as->upper[i]->value.integer);\n@@ -595,7 +643,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n \t      if(!gfc_simplify_expr(start, 1))\n \t        gfc_internal_error(\"Simplification error\");\n \t      mpz_set (section_index[i], start->value.integer);\n-\t      gfc_free_expr(start); \n+\t      gfc_free_expr(start);\n \t    }\n \t  else\n \t    mpz_set (section_index[i], ar->as->lower[i]->value.integer);\n@@ -613,7 +661,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n       mpz_mul (tmp, tmp, delta);\n       mpz_add (*offset_ret, tmp, *offset_ret);\n \n-      mpz_sub (tmp, ar->as->upper[i]->value.integer, \n+      mpz_sub (tmp, ar->as->upper[i]->value.integer,\n \t       ar->as->lower[i]->value.integer);\n       mpz_add_ui (tmp, tmp, 1);\n       mpz_mul (delta, tmp, delta);\n@@ -699,7 +747,7 @@ gfc_formalize_init_value (gfc_symbol *sym)\n \n /* Get the integer value into RET_AS and SECTION from AS and AR, and return\n    offset.  */\n- \n+\n void\n gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)\n {\n@@ -741,7 +789,7 @@ gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)\n \t  gcc_unreachable ();\n \t}\n \n-      mpz_sub (tmp, ar->as->upper[i]->value.integer, \n+      mpz_sub (tmp, ar->as->upper[i]->value.integer,\n \t       ar->as->lower[i]->value.integer);\n       mpz_add_ui (tmp, tmp, 1);\n       mpz_mul (delta, tmp, delta);"}, {"sha": "38c76abf590be5658b54eeb1dc47c19ec2bce51f", "filename": "gcc/testsuite/gfortran.dg/data_inquiry_ref.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_inquiry_ref.f90?ref=ff2dfdef2f2e01c579dd280daa1d81fbeb4d7ac5", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR98022.\n+!\n+! Contributed by Arseny Solokha  <asolokha@gmx.com>\n+!\n+module ur\n+contains\n+! The reporter's test.\n+  function kn1() result(hm2)\n+    complex :: hm(1:2), hm2(1:2)\n+    data (hm(md)%re, md=1,2)/1.0, 2.0/\n+    hm2 = hm\n+  end function kn1\n+\n+! Check for derived types with complex components.\n+  function kn2() result(hm2)\n+    type t\n+      complex :: c\n+      integer :: i\n+    end type\n+    type (t) :: hm(1:2)\n+    complex :: hm2(1:2)\n+    data (hm(md)%c%im, md=1,2)/1.0, 2.0/\n+    data (hm(md)%i, md=1,2)/1, 2/\n+    hm2 = hm%c\n+  end function kn2\n+end module ur\n+\n+  use ur\n+  if (any (kn1() .ne. [(1.0,0.0),(2.0,0.0)])) stop 1\n+  if (any (kn2() .ne. [(0.0,1.0),(0.0,2.0)])) stop 2\n+end"}]}