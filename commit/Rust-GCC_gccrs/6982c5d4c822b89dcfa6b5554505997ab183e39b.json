{"sha": "6982c5d4c822b89dcfa6b5554505997ab183e39b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4MmM1ZDRjODIyYjg5ZGNmYTZiNTU1NDUwNTk5N2FiMTgzZTM5Yg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2007-12-09T18:02:08Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2007-12-09T18:02:08Z"}, "message": "re PR target/32889 (ICE in delete_output_reload, at reload1.c:7926)\n\n\tPR middle-end/32889\n\tPR target/34091\n\t* pa.md: Consolidate HImode and QImode move patterns into one pattern\n\teach, eliminating floating-point alternatives.\n\t* pa-protos.h (pa_cannot_change_mode_class, pa_modes_tieable_p):\n\tDeclare functions.\n\t* pa-64.h (SECONDARY_MEMORY_NEEDED): Define here.\n\t* pa.c (pa_secondary_reload): Use an intermediate general register\n\tfor copies to/from floating-point register classes.  Simplify code\n\tSHIFT_REGS class.  Provide additional comments.\n\t(pa_cannot_change_mode_class, pa_modes_tieable_p): New functions.\n\t* pa.h (MODES_TIEABLE_P): Use pa_modes_tieable_p.\n\t(SECONDARY_MEMORY_NEEDED): Delete define.\n\t(INT14_OK_STRICT): Define.\n\t(MODE_OK_FOR_SCALED_INDEXING_P): Allow SFmode and DFmode when using\n\tsoft float.\n\t(MODE_OK_FOR_UNSCALED_INDEXING_P): Likewise.\n\t(GO_IF_LEGITIMATE_ADDRESS): Use INT14_OK_STRICT in REG+D case for\n\tSFmode and DFmode.\n\t(LEGITIMIZE_RELOAD_ADDRESS): Use INT14_OK_STRICT in mask selection.\n\tAlign DImode offsets when generating 64-bit code.\n\t* pa32-regs.h (VALID_FP_MODE_P): Remove QImode and HImode.\n\t(CANNOT_CHANGE_MODE_CLASS): Define.\n\t* pa64-regs.h (VALID_FP_MODE_P): Remove QImode and HImode.\n\t(CANNOT_CHANGE_MODE_CLASS): Define using pa_cannot_change_mode_class.\n\nFrom-SVN: r130725", "tree": {"sha": "6c03efab36b85bc299f7ba354cfa23f643d60a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c03efab36b85bc299f7ba354cfa23f643d60a6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6982c5d4c822b89dcfa6b5554505997ab183e39b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6982c5d4c822b89dcfa6b5554505997ab183e39b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6982c5d4c822b89dcfa6b5554505997ab183e39b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6982c5d4c822b89dcfa6b5554505997ab183e39b/comments", "author": null, "committer": null, "parents": [{"sha": "fad0afd7d72cb63e47e70795baac30cb2880314a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad0afd7d72cb63e47e70795baac30cb2880314a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad0afd7d72cb63e47e70795baac30cb2880314a"}], "stats": {"total": 359, "additions": 197, "deletions": 162}, "files": [{"sha": "b3bb96efc087315a9600c7c39f598c97c2bd57e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -1,3 +1,31 @@\n+2007-12-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR middle-end/32889\n+\tPR target/34091\n+\t* pa.md: Consolidate HImode and QImode move patterns into one pattern\n+\teach, eliminating floating-point alternatives.\n+\t* pa-protos.h (pa_cannot_change_mode_class, pa_modes_tieable_p):\n+\tDeclare functions.\n+\t* pa-64.h (SECONDARY_MEMORY_NEEDED): Define here.\n+\t* pa.c (pa_secondary_reload): Use an intermediate general register\n+\tfor copies to/from floating-point register classes.  Simplify code\n+\tSHIFT_REGS class.  Provide additional comments.\n+\t(pa_cannot_change_mode_class, pa_modes_tieable_p): New functions.\n+\t* pa.h (MODES_TIEABLE_P): Use pa_modes_tieable_p.\n+\t(SECONDARY_MEMORY_NEEDED): Delete define.\n+\t(INT14_OK_STRICT): Define.\n+\t(MODE_OK_FOR_SCALED_INDEXING_P): Allow SFmode and DFmode when using\n+\tsoft float.\n+\t(MODE_OK_FOR_UNSCALED_INDEXING_P): Likewise.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use INT14_OK_STRICT in REG+D case for\n+\tSFmode and DFmode.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Use INT14_OK_STRICT in mask selection.\n+\tAlign DImode offsets when generating 64-bit code.\n+\t* pa32-regs.h (VALID_FP_MODE_P): Remove QImode and HImode.\n+\t(CANNOT_CHANGE_MODE_CLASS): Define.\n+\t* pa64-regs.h (VALID_FP_MODE_P): Remove QImode and HImode.\n+\t(CANNOT_CHANGE_MODE_CLASS): Define using pa_cannot_change_mode_class.\n+\n 2007-12-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/22244"}, {"sha": "67c8179c573fb44a7058b024ece9a565f304c216", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -84,3 +84,17 @@ along with GCC; see the file COPYING3.  If not see\n    want aggregates padded down.  */\n \n #define PAD_VARARGS_DOWN (!AGGREGATE_TYPE_P (type))\n+\n+/* In the PA architecture, it is not possible to directly move data\n+   between GENERAL_REGS and FP_REGS.  On the 32-bit port, we use the\n+   location at SP-16 because PA 1.X only supports 5-bit immediates for\n+   floating-point loads and stores.  We don't expose this location in\n+   the RTL to avoid scheduling related problems.  For example, the\n+   store and load could be separated by a call to a pure or const\n+   function which has no frame and this function might also use SP-16.\n+   We have 14-bit immediates on the 64-bit port, so we use secondary\n+   memory for the copies.  */\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+  (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\t\\\n+   || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1))\n+"}, {"sha": "7fc9dcad40f98770f5344f36d7ef4260977ccc53", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -172,6 +172,9 @@ extern void pa_asm_output_aligned_local (FILE *, const char *,\n \t\t\t\t\t unsigned HOST_WIDE_INT,\n \t\t\t\t\t unsigned int);\n extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n+extern bool pa_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n+\t\t\t\t\t enum reg_class);\n+extern bool pa_modes_tieable_p (enum machine_mode, enum machine_mode);\n \n extern const int magic_milli[];\n extern int shadd_constant_p (int);"}, {"sha": "b1f3a0036532b1cce85b2ad829761a6016119840", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 104, "deletions": 10, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -5687,12 +5687,49 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n   if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)\n     regno = true_regnum (x);\n \n-  /* Handle out of range displacement for integer mode loads/stores of\n-     FP registers.  */\n-  if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n-       && GET_MODE_CLASS (mode) == MODE_INT\n-       && FP_REG_CLASS_P (class))\n-      || (class == SHIFT_REGS && (regno <= 0 || regno >= 32)))\n+  /* In order to allow 14-bit displacements in integer loads and stores,\n+     we need to prevent reload from generating out of range integer mode\n+     loads and stores to the floating point registers.  Previously, we\n+     used to call for a secondary reload and have emit_move_sequence()\n+     fix the instruction sequence.  However, reload occasionally wouldn't\n+     generate the reload and we would end up with an invalid REG+D memory\n+     address.  So, now we use an intermediate general register for most\n+     memory loads and stores.  */\n+  if ((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n+      && GET_MODE_CLASS (mode) == MODE_INT\n+      && FP_REG_CLASS_P (class))\n+    {\n+      /* Reload passes (mem:SI (reg/f:DI 30 %r30) when it wants to check\n+\t the secondary reload needed for a pseudo.  It never passes a\n+\t REG+D address.  */\n+      if (GET_CODE (x) == MEM)\n+\t{\n+\t  x = XEXP (x, 0);\n+\n+\t  /* We don't need an intermediate for indexed and LO_SUM DLT\n+\t     memory addresses.  When INT14_OK_STRICT is true, it might\n+\t     appear that we could directly allow register indirect\n+\t     memory addresses.  However, this doesn't work because we\n+\t     don't support SUBREGs in floating-point register copies\n+\t     and reload doesn't tell us when it's going to use a SUBREG.  */\n+\t  if (IS_INDEX_ADDR_P (x)\n+\t      || IS_LO_SUM_DLT_ADDR_P (x))\n+\t    return NO_REGS;\n+\n+\t  /* Otherwise, we need an intermediate general register.  */\n+\t  return GENERAL_REGS;\n+\t}\n+\n+      /* Request a secondary reload with a general scratch register\n+\t for everthing else.  ??? Could symbolic operands be handled\n+\t directly when generating non-pic PA 2.0 code?  */\n+      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n+      return NO_REGS;\n+    }\n+\n+  /* We need a secondary register (GPR) for copies between the SAR\n+     and anything other than a general register.  */\n+  if (class == SHIFT_REGS && (regno <= 0 || regno >= 32))\n     {\n       sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n       return NO_REGS;\n@@ -5701,16 +5738,15 @@ pa_secondary_reload (bool in_p, rtx x, enum reg_class class,\n   /* A SAR<->FP register copy requires a secondary register (GPR) as\n      well as secondary memory.  */\n   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-      && ((REGNO_REG_CLASS (regno) == SHIFT_REGS && FP_REG_CLASS_P (class))\n-\t  || (class == SHIFT_REGS\n-\t      && FP_REG_CLASS_P (REGNO_REG_CLASS (regno)))))\n+      && (REGNO_REG_CLASS (regno) == SHIFT_REGS\n+      && FP_REG_CLASS_P (class)))\n     {\n       sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];\n       return NO_REGS;\n     }\n \n   /* Secondary reloads of symbolic operands require %r1 as a scratch\n-     register when we're generating PIC code and the operand isn't\n+     register when we're generating PIC code and when the operand isn't\n      readonly.  */\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n@@ -9570,4 +9606,62 @@ pa_hpux_file_end (void)\n }\n #endif\n \n+/* Return true if a change from mode FROM to mode TO for a register\n+   in register class CLASS is invalid.  */\n+\n+bool\n+pa_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+\t\t\t     enum reg_class class)\n+{\n+  if (from == to)\n+    return false;\n+\n+  /* Reject changes to/from complex and vector modes.  */\n+  if (COMPLEX_MODE_P (from) || VECTOR_MODE_P (from)\n+      || COMPLEX_MODE_P (to) || VECTOR_MODE_P (to))\n+    return true;\n+      \n+  if (GET_MODE_SIZE (from) == GET_MODE_SIZE (to))\n+    return false;\n+\n+  /* There is no way to load QImode or HImode values directly from\n+     memory.  SImode loads to the FP registers are not zero extended.\n+     On the 64-bit target, this conflicts with the definition of\n+     LOAD_EXTEND_OP.  Thus, we can't allow changing between modes\n+     with different sizes in the floating-point registers.  */\n+  if (MAYBE_FP_REG_CLASS_P (class))\n+    return true;\n+\n+  /* HARD_REGNO_MODE_OK places modes with sizes larger than a word\n+     in specific sets of registers.  Thus, we cannot allow changing\n+     to a larger mode when it's larger than a word.  */\n+  if (GET_MODE_SIZE (to) > UNITS_PER_WORD\n+      && GET_MODE_SIZE (to) > GET_MODE_SIZE (from))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Returns TRUE if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be FALSE for correct output.\n+   \n+   We should return FALSE for QImode and HImode because these modes\n+   are not ok in the floating-point registers.  However, this prevents\n+   tieing these modes to SImode and DImode in the general registers.\n+   So, this isn't a good idea.  We rely on HARD_REGNO_MODE_OK and\n+   CANNOT_CHANGE_MODE_CLASS to prevent these modes from being used\n+   in the floating-point registers.  */\n+\n+bool\n+pa_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+{\n+  /* Don't tie modes in different classes.  */\n+  if (GET_MODE_CLASS (mode1) != GET_MODE_CLASS (mode2))\n+    return false;\n+\n+  return true;\n+}\n+\n #include \"gt-pa.h\""}, {"sha": "f8cf9d2f4e9f52e515ad7e1267f9a29bd2a193e8", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -349,7 +349,7 @@ typedef struct machine_function GTY(())\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+  pa_modes_tieable_p (MODE1, MODE2)\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -497,17 +497,6 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n #define MAYBE_FP_REG_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), FP_REGS)\n \n-/* On the PA it is not possible to directly move data between\n-   GENERAL_REGS and FP_REGS.  On the 32-bit port, we use the\n-   location at SP-16.  We don't expose this location in the RTL to\n-   avoid scheduling related problems.  For example, the store and\n-   load could be separated by a call to a pure or const function\n-   which has no frame and uses SP-16.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n-  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n-   && (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\t\\\n-       || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1)))\n-\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1116,6 +1105,24 @@ extern int may_call_alloca;\n    && REG_OK_FOR_BASE_P (XEXP (OP, 0))\t\t\t\\\n    && GET_CODE (XEXP (OP, 1)) == UNSPEC)\n \n+/* Nonzero if 14-bit offsets can be used for all loads and stores.\n+   This is not possible when generating PA 1.x code as floating point\n+   loads and stores only support 5-bit offsets.  Note that we do not\n+   forbid the use of 14-bit offsets in GO_IF_LEGITIMATE_ADDRESS.\n+   Instead, we use pa_secondary_reload() to reload integer mode\n+   REG+D memory addresses used in floating point loads and stores.\n+\n+   FIXME: the ELF32 linker clobbers the LSB of the FP register number\n+   in PA 2.0 floating-point insns with long displacements.  This is\n+   because R_PARISC_DPREL14WR and other relocations like it are not\n+   yet supported by GNU ld.  For now, we reject long displacements\n+   on this target.  */\n+\n+#define INT14_OK_STRICT \\\n+  (TARGET_SOFT_FLOAT                                                   \\\n+   || TARGET_DISABLE_FPREGS                                            \\\n+   || (TARGET_PA_20 && !TARGET_ELF32))\n+\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -1134,16 +1141,18 @@ extern int may_call_alloca;\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-(REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+  (REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-(REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+  (REGNO (X) && (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n \n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n@@ -1195,11 +1204,7 @@ extern int may_call_alloca;\n \n    We treat a SYMBOL_REF as legitimate if it is part of the current\n    function's constant-pool, because such addresses can actually be\n-   output as REG+SMALLINT. \n-\n-   Note we only allow 5-bit immediates for access to a constant address;\n-   doing so avoids losing for loading/storing a FP register at an address\n-   which will not fit in 5 bits.  */\n+   output as REG+SMALLINT.  */\n \n #define VAL_5_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x10 < 0x20)\n #define INT_5_BITS(X) VAL_5_BITS_P (INTVAL (X))\n@@ -1227,15 +1232,17 @@ extern int may_call_alloca;\n   ((TARGET_64BIT && (MODE) == DImode)\t\t\t\t\t\\\n    || (MODE) == SImode\t\t\t\t\t\t\t\\\n    || (MODE) == HImode\t\t\t\t\t\t\t\\\n-   || (!TARGET_SOFT_FLOAT && ((MODE) == DFmode || (MODE) == SFmode)))\n+   || (MODE) == SFmode\t\t\t\t\t\t\t\\\n+   || (MODE) == DFmode)\n \n /* These are the modes that we allow for unscaled indexing.  */\n #define MODE_OK_FOR_UNSCALED_INDEXING_P(MODE) \\\n   ((TARGET_64BIT && (MODE) == DImode)\t\t\t\t\t\\\n    || (MODE) == SImode\t\t\t\t\t\t\t\\\n    || (MODE) == HImode\t\t\t\t\t\t\t\\\n    || (MODE) == QImode\t\t\t\t\t\t\t\\\n-   || (!TARGET_SOFT_FLOAT && ((MODE) == DFmode || (MODE) == SFmode)))\n+   || (MODE) == SFmode\t\t\t\t\t\t\t\\\n+   || (MODE) == DFmode)\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1269,20 +1276,10 @@ extern int may_call_alloca;\n \t\t\t   || (INTVAL (index) % 8) == 0))\t\t\\\n \t\t   /* Similarly, the base register for SFmode/DFmode\t\\\n \t\t      loads and stores with long displacements must\t\\\n-\t\t      be aligned.\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t\t      FIXME: the ELF32 linker clobbers the LSB of\t\\\n-\t\t      the FP register number in PA 2.0 floating-point\t\\\n-\t\t      insns with long displacements.  This is because\t\\\n-\t\t      R_PARISC_DPREL14WR and other relocations like\t\\\n-\t\t      it are not supported.  For now, we reject long\t\\\n-\t\t      displacements on this target.  */\t\t\t\\\n+\t\t      be aligned.  */\t\t\t\t\t\\\n \t\t   || (((MODE) == SFmode || (MODE) == DFmode)\t\t\\\n-\t\t       && (TARGET_SOFT_FLOAT\t\t\t\t\\\n-\t\t\t   || (TARGET_PA_20\t\t\t\t\\\n-\t\t\t       && !TARGET_ELF32\t\t\t\t\\\n-\t\t\t       && (INTVAL (index)\t\t\t\\\n-\t\t\t\t   % GET_MODE_SIZE (MODE)) == 0)))))\t\\\n+\t\t       && INT14_OK_STRICT\t\t\t\t\\\n+\t\t       && (INTVAL (index) % GET_MODE_SIZE (MODE)) == 0))) \\\n \t       || INT_5_BITS (index)))\t\t\t\t\t\\\n \tgoto ADDR;\t\t\t\t\t\t\t\\\n       if (!TARGET_DISABLE_INDEXING\t\t\t\t\t\\\n@@ -1382,7 +1379,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n   rtx new, temp = NULL_RTX;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   mask = (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t  ? (TARGET_PA_20 && !TARGET_ELF32 ? 0x3fff : 0x1f) : 0x3fff);\t\\\n+\t  ? (INT14_OK_STRICT ? 0x3fff : 0x1f) : 0x3fff);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (optimize && GET_CODE (AD) == PLUS)\t\t\t\t\\\n     temp = simplify_binary_operation (PLUS, Pmode,\t\t\t\\\n@@ -1404,9 +1401,10 @@ do { \t\t\t\t\t\t\t\t\t\\\n \tnewoffset = offset & ~mask;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       /* Ensure that long displacements are aligned.  */\t\t\\\n-      if (!VAL_5_BITS_P (newoffset)\t\t\t\t\t\\\n-\t  && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n-\tnewoffset &= ~(GET_MODE_SIZE (MODE) -1);\t\t\t\\\n+      if (mask == 0x3fff\t\t\t\t\t\t\\\n+\t  && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+\t      || (TARGET_64BIT && (MODE) == DImode)))\t\t\t\\\n+\tnewoffset &= ~(GET_MODE_SIZE (MODE) - 1);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (newoffset != 0 && VAL_14_BITS_P (newoffset))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\"}, {"sha": "9487afac5d31b5596714b4612371b479f5c4148d", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 2, "deletions": 100, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -3181,62 +3181,13 @@\n     DONE;\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\"\n-\t \t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f,?r,?*f\")\n-\t(match_operand:HI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM,*f,r\"))]\n-  \"(register_operand (operands[0], HImode)\n-    || reg_or_0_operand (operands[1], HImode))\n-   && !TARGET_SOFT_FLOAT\n-   && !TARGET_64BIT\"\n-  \"@\n-   copy %1,%0\n-   ldi %1,%0\n-   ldil L'%1,%0\n-   {zdepi|depwi,z} %Z1,%0\n-   ldh%M1 %1,%0\n-   sth%M0 %r1,%0\n-   mtsar %r1\n-   {mfctl|mfctl,w} %sar,%0\n-   fcpy,sgl %f1,%0\n-   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n-   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move,fpstore_load,store_fpload\")\n-   (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,8\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\"\n-\t \t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n-\t(match_operand:HI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n-  \"(register_operand (operands[0], HImode)\n-    || reg_or_0_operand (operands[1], HImode))\n-   && !TARGET_SOFT_FLOAT\n-   && TARGET_64BIT\"\n-  \"@\n-   copy %1,%0\n-   ldi %1,%0\n-   ldil L'%1,%0\n-   {zdepi|depwi,z} %Z1,%0\n-   ldh%M1 %1,%0\n-   sth%M0 %r1,%0\n-   mtsar %r1\n-   {mfctl|mfctl,w} %sar,%0\n-   fcpy,sgl %f1,%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move\")\n-   (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"move_dest_operand\"\n \t \t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:HI 1 \"move_src_operand\"\n \t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n   \"(register_operand (operands[0], HImode)\n-    || reg_or_0_operand (operands[1], HImode))\n-   && TARGET_SOFT_FLOAT\"\n+    || reg_or_0_operand (operands[1], HImode))\"\n   \"@\n    copy %1,%0\n    ldi %1,%0\n@@ -3354,62 +3305,13 @@\n     DONE;\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\"\n-\t\t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f,?r,?*f\")\n-\t(match_operand:QI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM,*f,r\"))]\n-  \"(register_operand (operands[0], QImode)\n-    || reg_or_0_operand (operands[1], QImode))\n-   && !TARGET_SOFT_FLOAT\n-   && !TARGET_64BIT\"\n-  \"@\n-   copy %1,%0\n-   ldi %1,%0\n-   ldil L'%1,%0\n-   {zdepi|depwi,z} %Z1,%0\n-   ldb%M1 %1,%0\n-   stb%M0 %r1,%0\n-   mtsar %r1\n-   {mfctl|mfctl,w} %%sar,%0\n-   fcpy,sgl %f1,%0\n-   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n-   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move,fpstore_load,store_fpload\")\n-   (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,8\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\"\n-\t\t\t  \"=r,r,r,r,r,Q,!*q,!r,!*f\")\n-\t(match_operand:QI 1 \"move_src_operand\"\n-\t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q,!*fM\"))]\n-  \"(register_operand (operands[0], QImode)\n-    || reg_or_0_operand (operands[1], QImode))\n-   && !TARGET_SOFT_FLOAT\n-   && TARGET_64BIT\"\n-  \"@\n-   copy %1,%0\n-   ldi %1,%0\n-   ldil L'%1,%0\n-   {zdepi|depwi,z} %Z1,%0\n-   ldb%M1 %1,%0\n-   stb%M0 %r1,%0\n-   mtsar %r1\n-   {mfctl|mfctl,w} %%sar,%0\n-   fcpy,sgl %f1,%0\"\n-  [(set_attr \"type\" \"move,move,move,shift,load,store,move,move,move\")\n-   (set_attr \"pa_combine_type\" \"addmove\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4\")])\n-\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"move_dest_operand\"\n \t\t\t  \"=r,r,r,r,r,Q,!*q,!r\")\n \t(match_operand:QI 1 \"move_src_operand\"\n \t\t\t  \"r,J,N,K,RQ,rM,!rM,!*q\"))]\n   \"(register_operand (operands[0], QImode)\n-    || reg_or_0_operand (operands[1], QImode))\n-   && TARGET_SOFT_FLOAT\"\n+    || reg_or_0_operand (operands[1], QImode))\"\n   \"@\n    copy %1,%0\n    ldi %1,%0"}, {"sha": "89cbb9b7552131d935b4d9d0b43cf3984566aad4", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -172,8 +172,7 @@\n #define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n   ((MODE) == SFmode || (MODE) == DFmode\t\t\t\t\t\\\n    || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n-   || (MODE) == QImode || (MODE) == HImode || (MODE) == SImode\t\t\\\n-   || (TARGET_PA_11 && (MODE) == DImode))\n+   || (MODE) == SImode || (TARGET_PA_11 && (MODE) == DImode))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n \n@@ -288,6 +287,11 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n \n+/* Defines invalid mode changes.  */\n+\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  pa_cannot_change_mode_class (FROM, TO, CLASS)\n+\n /* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */"}, {"sha": "828265f23b83cc83b97392e6a3d80c0d53f116b6", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6982c5d4c822b89dcfa6b5554505997ab183e39b/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=6982c5d4c822b89dcfa6b5554505997ab183e39b", "patch": "@@ -156,8 +156,7 @@ along with GCC; see the file COPYING3.  If not see\n #define VALID_FP_MODE_P(MODE)\t\t\t\t\t\t\\\n   ((MODE) == SFmode || (MODE) == DFmode\t\t\t\t\t\\\n    || (MODE) == SCmode || (MODE) == DCmode\t\t\t\t\\\n-   || (MODE) == QImode || (MODE) == HImode || (MODE) == SImode\t\t\\\n-   || (MODE) == DImode)\n+   || (MODE) == SImode || (MODE) == DImode)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n@@ -242,17 +241,10 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n   {0x00000000, 0x10000000},\t/* SHIFT_REGS */\t\t\\\n   {0xfffffffe, 0x1fffffff}}\t/* ALL_REGS */\n \n-/* Defines invalid mode changes.\n+/* Defines invalid mode changes.  */\n \n-   SImode loads to floating-point registers are not zero-extended.\n-   The definition for LOAD_EXTEND_OP specifies that integer loads\n-   narrower than BITS_PER_WORD will be zero-extended.  As a result,\n-   we inhibit changes from SImode unless they are to a mode that is\n-   identical in size.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\\n-  ((FROM) == SImode && GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)       \\\n-   ? reg_classes_intersect_p (CLASS, FP_REGS) : 0)\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n+  pa_cannot_change_mode_class (FROM, TO, CLASS)\n \n /* Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression"}]}