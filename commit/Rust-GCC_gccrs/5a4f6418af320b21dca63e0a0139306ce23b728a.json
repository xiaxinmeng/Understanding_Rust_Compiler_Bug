{"sha": "5a4f6418af320b21dca63e0a0139306ce23b728a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE0ZjY0MThhZjMyMGIyMWRjYTYzZTBhMDEzOTMwNmNlMjNiNzI4YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1999-08-25T17:50:53Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1999-08-25T17:50:53Z"}, "message": "lists.c (unused_insn_list, [...]): New file for maintaining various types of lists.\n\n\nWed Aug 25 13:41:47 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n\n\t* lists.c (unused_insn_list, unused_expr_list): New file for\n\tmaintaining various types of lists. New statics for maintaining a\n\tcache of available INSN_LIST and EXPR_LIST nodes.\n\t(free_list): Static function for freeing a list of INSN/EXPR nodes.\n\t(alloc_INSN_LIST): Function to get a free INSN_LIST node.\n\t(alloc_EXPR_LIST): Function to get a free EXPR_LIST node.\n\t(init_EXPR_INSN_LIST_cache): Initialize the cache lists.\n\t(free_EXPR_LIST_list): Free an entire list of EXPR_LIST nodes.\n\t(free_INSN_LIST_list): Free an entire list of INSN_LIST nodes.\n\t(free_EXPR_LIST_node): Free an individual EXPR_LIST node.\n\t(free_INSN_LIST_node): Free an individual INSN_LIST node.\n\t* haifa-sched.c (unused_insn_list, unused_expr_list): Moved to flow.c\n\t(free_list, alloc_INSN_LIST, alloc_EXPR_LIST): Moved to flow.c\n\t(remove_dependence, free_pending_lists): Use new global routines.\n\t(flush_pending_lists, sched_analyze_insn): Use new global routines.\n\t(sched_analyze, compute_block_backward_dependences): Use new routines.\n\t(sched_analyze_1, sched_analyze_2): Use new routines.\n\t(schedule_insns): Use new global routines.\n\t* rtl.h (init_EXPR_INSN_LIST_cache, free_EXPR_LIST_list): Add function\n\tprototypes.\n\t(free_INSN_LIST_list, free_EXPR_LIST_node): Add prototypes.\n\t(free_INSN_LIST_node, alloc_INSN_LIST, alloc_EXPR_LIST): Add function\n\tprototypes.\n\t* toplev.c (rest_of_compilation): Initialize node cache.\n\t* Makefile.in (OBJS): Add lists.o to list of object files.\n\t(lists.o): Add dependancies.\n\nFrom-SVN: r28864", "tree": {"sha": "86584c27da4bb36103f3b8996d2188499bab6044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86584c27da4bb36103f3b8996d2188499bab6044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a4f6418af320b21dca63e0a0139306ce23b728a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4f6418af320b21dca63e0a0139306ce23b728a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4f6418af320b21dca63e0a0139306ce23b728a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4f6418af320b21dca63e0a0139306ce23b728a/comments", "author": null, "committer": null, "parents": [{"sha": "b54480a7e6ff4cf13e5c6464a1efa5fa151e732a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54480a7e6ff4cf13e5c6464a1efa5fa151e732a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54480a7e6ff4cf13e5c6464a1efa5fa151e732a"}], "stats": {"total": 344, "additions": 219, "deletions": 125}, "files": [{"sha": "3e39ae7c08c5946b19da55c6077bef8fd40449ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -1,3 +1,32 @@\n+Wed Aug 25 13:41:47 EDT 1999  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* lists.c (unused_insn_list, unused_expr_list): New file for\n+\tmaintaining various types of lists. New statics for maintaining a \n+\tcache of available INSN_LIST and EXPR_LIST nodes.\n+\t(free_list): Static function for freeing a list of INSN/EXPR nodes.\n+\t(alloc_INSN_LIST): Function to get a free INSN_LIST node.\n+\t(alloc_EXPR_LIST): Function to get a free EXPR_LIST node.\n+\t(init_EXPR_INSN_LIST_cache): Initialize the cache lists.\n+\t(free_EXPR_LIST_list): Free an entire list of EXPR_LIST nodes.\n+\t(free_INSN_LIST_list): Free an entire list of INSN_LIST nodes.\n+\t(free_EXPR_LIST_node): Free an individual EXPR_LIST node.\n+\t(free_INSN_LIST_node): Free an individual INSN_LIST node.\n+\t* haifa-sched.c (unused_insn_list, unused_expr_list): Moved to flow.c\n+\t(free_list, alloc_INSN_LIST, alloc_EXPR_LIST): Moved to flow.c\n+\t(remove_dependence, free_pending_lists): Use new global routines.\n+\t(flush_pending_lists, sched_analyze_insn): Use new global routines.\n+\t(sched_analyze, compute_block_backward_dependences): Use new routines.\n+\t(sched_analyze_1, sched_analyze_2): Use new routines.\n+\t(schedule_insns): Use new global routines.\n+\t* rtl.h (init_EXPR_INSN_LIST_cache, free_EXPR_LIST_list): Add function\n+\tprototypes.\n+\t(free_INSN_LIST_list, free_EXPR_LIST_node): Add prototypes.\n+\t(free_INSN_LIST_node, alloc_INSN_LIST, alloc_EXPR_LIST): Add function\n+\tprototypes.\n+\t* toplev.c (rest_of_compilation): Initialize node cache.\n+\t* Makefile.in (OBJS): Add lists.o to list of object files.\n+\t(lists.o): Add dependancies.\n+\n Wed Aug 25 17:31:56 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/v850/v850.md: Fix compile time warning messages."}, {"sha": "2fcffc2d925619b577995c6bcda1c65bcf4dacf0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -667,7 +667,7 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  insn-peep.o reorg.o haifa-sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n- mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o\n+ mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o lists.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1581,6 +1581,7 @@ reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) recog.h \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n    function.h\n dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h\n+lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "42f44b7cad6e73e7b019db060c3fa3208c8e866d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 29, "deletions": 124, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -766,82 +766,6 @@ static void schedule_region PROTO ((int));\n \f\n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n-/* Helper functions for instruction scheduling.  */\n-\n-/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */\n-static rtx unused_insn_list;\n-\n-/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n-static rtx unused_expr_list;\n-\n-static void free_list PROTO ((rtx *, rtx *));\n-static rtx alloc_INSN_LIST PROTO ((rtx, rtx));\n-static rtx alloc_EXPR_LIST PROTO ((int, rtx, rtx));\n-\n-static void\n-free_list (listp, unused_listp)\n-     rtx *listp, *unused_listp;\n-{\n-  register rtx link, prev_link;\n-\n-  if (*listp == 0)\n-    return;\n-\n-  prev_link = *listp;\n-  link = XEXP (prev_link, 1);\n-\n-  while (link)\n-    {\n-      prev_link = link;\n-      link = XEXP (link, 1);\n-    }\n-\n-  XEXP (prev_link, 1) = *unused_listp;\n-  *unused_listp = *listp;\n-  *listp = 0;\n-}\n-\n-static rtx\n-alloc_INSN_LIST (val, next)\n-     rtx val, next;\n-{\n-  rtx r;\n-\n-  if (unused_insn_list)\n-    {\n-      r = unused_insn_list;\n-      unused_insn_list = XEXP (r, 1);\n-      XEXP (r, 0) = val;\n-      XEXP (r, 1) = next;\n-      PUT_REG_NOTE_KIND (r, VOIDmode);\n-    }\n-  else\n-    r = gen_rtx_INSN_LIST (VOIDmode, val, next);\n-\n-  return r;\n-}\n-\n-static rtx\n-alloc_EXPR_LIST (kind, val, next)\n-     int kind;\n-     rtx val, next;\n-{\n-  rtx r;\n-\n-  if (unused_expr_list)\n-    {\n-      r = unused_expr_list;\n-      unused_expr_list = XEXP (r, 1);\n-      XEXP (r, 0) = val;\n-      XEXP (r, 1) = next;\n-      PUT_REG_NOTE_KIND (r, kind);\n-    }\n-  else\n-    r = gen_rtx_EXPR_LIST (kind, val, next);\n-\n-  return r;\n-}\n-\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n    of dependence that this link represents.  */\n@@ -949,9 +873,7 @@ remove_dependence (insn, elem)\n \t    XEXP (prev, 1) = next;\n \t  else\n \t    LOG_LINKS (insn) = next;\n-\n-\t  XEXP (link, 1) = unused_insn_list;\n-\t  unused_insn_list = link;\n+\t  free_INSN_LIST_node (link);\n \n \t  found = 1;\n \t}\n@@ -3226,10 +3148,10 @@ free_pending_lists ()\n {\n   if (current_nr_blocks <= 1)\n     {\n-      free_list (&pending_read_insns, &unused_insn_list);\n-      free_list (&pending_write_insns, &unused_insn_list);\n-      free_list (&pending_read_mems, &unused_expr_list);\n-      free_list (&pending_write_mems, &unused_expr_list);\n+      free_INSN_LIST_list (&pending_read_insns);\n+      free_INSN_LIST_list (&pending_write_insns);\n+      free_EXPR_LIST_list (&pending_read_mems);\n+      free_EXPR_LIST_list (&pending_write_mems);\n     }\n   else\n     {\n@@ -3238,10 +3160,10 @@ free_pending_lists ()\n \n       for (bb = 0; bb < current_nr_blocks; bb++)\n \t{\n-\t  free_list (&bb_pending_read_insns[bb], &unused_insn_list);\n-\t  free_list (&bb_pending_write_insns[bb], &unused_insn_list);\n-\t  free_list (&bb_pending_read_mems[bb], &unused_expr_list);\n-\t  free_list (&bb_pending_write_mems[bb], &unused_expr_list);\n+\t  free_INSN_LIST_list (&bb_pending_read_insns[bb]);\n+\t  free_INSN_LIST_list (&bb_pending_write_insns[bb]);\n+\t  free_EXPR_LIST_list (&bb_pending_read_mems[bb]);\n+\t  free_EXPR_LIST_list (&bb_pending_write_mems[bb]);\n \t}\n     }\n }\n@@ -3284,35 +3206,31 @@ flush_pending_lists (insn, only_write)\n \n       link = pending_read_insns;\n       pending_read_insns = XEXP (pending_read_insns, 1);\n-      XEXP (link, 1) = unused_insn_list;\n-      unused_insn_list = link;\n+      free_INSN_LIST_node (link);\n \n       link = pending_read_mems;\n       pending_read_mems = XEXP (pending_read_mems, 1);\n-      XEXP (link, 1) = unused_expr_list;\n-      unused_expr_list = link;\n+      free_EXPR_LIST_node (link);\n     }\n   while (pending_write_insns)\n     {\n       add_dependence (insn, XEXP (pending_write_insns, 0), REG_DEP_ANTI);\n \n       link = pending_write_insns;\n       pending_write_insns = XEXP (pending_write_insns, 1);\n-      XEXP (link, 1) = unused_insn_list;\n-      unused_insn_list = link;\n+      free_INSN_LIST_node (link);\n \n       link = pending_write_mems;\n       pending_write_mems = XEXP (pending_write_mems, 1);\n-      XEXP (link, 1) = unused_expr_list;\n-      unused_expr_list = link;\n+      free_EXPR_LIST_node (link);\n     }\n   pending_lists_length = 0;\n \n   /* last_pending_memory_flush is now a list of insns */\n   for (u = last_pending_memory_flush; u; u = XEXP (u, 1))\n     add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n-  free_list (&last_pending_memory_flush, &unused_insn_list);\n+  free_INSN_LIST_list (&last_pending_memory_flush);\n   last_pending_memory_flush = alloc_INSN_LIST (insn, NULL_RTX);\n }\n \n@@ -3379,7 +3297,7 @@ sched_analyze_1 (x, insn)\n \t\t but sets must be ordered with respect to a pending clobber. */\n \t      if (code == SET)\n \t\t{\n-\t\t  free_list (&reg_last_uses[regno + i], &unused_insn_list);\n+\t\t  free_INSN_LIST_list (&reg_last_uses[regno + i]);\n \t          for (u = reg_last_clobbers[regno + i]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t          SET_REGNO_REG_SET (reg_pending_sets, regno + i);\n@@ -3406,7 +3324,7 @@ sched_analyze_1 (x, insn)\n \n \t  if (code == SET)\n \t    {\n-\t      free_list (&reg_last_uses[regno], &unused_insn_list);\n+\t      free_INSN_LIST_list (&reg_last_uses[regno]);\n \t      for (u = reg_last_clobbers[regno]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t      SET_REGNO_REG_SET (reg_pending_sets, regno);\n@@ -3672,7 +3590,7 @@ sched_analyze_2 (x, insn)\n \t      {\n \t\tfor (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\tfree_list (&reg_last_uses[i], &unused_insn_list);\n+\t\tfree_INSN_LIST_list (&reg_last_uses[i]);\n \n \t\tfor (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n@@ -3805,7 +3723,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \t      rtx u;\n \t      for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      free_list (&reg_last_uses[i], &unused_insn_list);\n+\t      free_INSN_LIST_list (&reg_last_uses[i]);\n \n \t      for (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), 0);\n@@ -3825,9 +3743,8 @@ sched_analyze_insn (x, insn, loop_notes)\n      subsequent sets will be output dependant on it.  */\n   EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i,\n \t\t\t     {\n-\t\t\t       free_list (&reg_last_sets[i], &unused_insn_list);\n-\t\t\t       free_list (&reg_last_clobbers[i],\n-\t\t\t\t\t  &unused_insn_list);\n+\t\t\t       free_INSN_LIST_list (&reg_last_sets[i]);\n+\t\t\t       free_INSN_LIST_list (&reg_last_clobbers[i]);\n \t\t\t       reg_last_sets[i]\n \t\t\t\t = alloc_INSN_LIST (insn, NULL_RTX);\n \t\t\t     });\n@@ -3843,7 +3760,7 @@ sched_analyze_insn (x, insn, loop_notes)\n     {\n       for (i = 0; i < maxreg; i++)\n \t{\n-\t  free_list (&reg_last_sets[i], &unused_insn_list);\n+\t  free_INSN_LIST_list (&reg_last_sets[i]);\n \t  reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n \n@@ -3937,7 +3854,7 @@ sched_analyze (head, tail)\n \t\t{\n \t\t  for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\t  free_list (&reg_last_uses[i], &unused_insn_list);\n+\t\t  free_INSN_LIST_list (&reg_last_uses[i]);\n \n \t\t  for (u = reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), 0);\n@@ -3995,7 +3912,7 @@ sched_analyze (head, tail)\n \t     function call) on all hard register clobberage.  */\n \n \t  /* last_function_call is now a list of insns */\n-\t  free_list(&last_function_call, &unused_insn_list);\n+\t  free_INSN_LIST_list(&last_function_call);\n \t  last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n \t}\n \n@@ -7455,18 +7372,18 @@ compute_block_backward_dependences (bb)\n   /* Free up the INSN_LISTs \n \n      Note this loop is executed max_reg * nr_regions times.  It's first \n-     implementation accounted for over 90% of the calls to free_list.\n-     The list was empty for the vast majority of those calls.  On the PA,\n-     not calling free_list in those cases improves -O2 compile times by\n+     implementation accounted for over 90% of the calls to free_INSN_LIST_list.\n+     The list was empty for the vast majority of those calls.  On the PA, not \n+     calling free_INSN_LIST_list in those cases improves -O2 compile times by\n      3-5% on average.  */\n   for (b = 0; b < max_reg; ++b)\n     {\n       if (reg_last_clobbers[b])\n-\tfree_list (&reg_last_clobbers[b], &unused_insn_list);\n+\tfree_INSN_LIST_list (&reg_last_clobbers[b]);\n       if (reg_last_sets[b])\n-\tfree_list (&reg_last_sets[b], &unused_insn_list);\n+\tfree_INSN_LIST_list (&reg_last_sets[b]);\n       if (reg_last_uses[b])\n-\tfree_list (&reg_last_uses[b], &unused_insn_list);\n+\tfree_INSN_LIST_list (&reg_last_uses[b]);\n     }\n \n   /* Assert that we won't need bb_reg_last_* for this block anymore.  */\n@@ -7823,18 +7740,6 @@ schedule_insns (dump_file)\n   nr_inter = 0;\n   nr_spec = 0;\n \n-  /* Initialize the unused_*_lists.  We can't use the ones left over from\n-     the previous function, because gcc has freed that memory.  We can use\n-     the ones left over from the first sched pass in the second pass however,\n-     so only clear them on the first sched pass.  The first pass is before\n-     reload if flag_schedule_insns is set, otherwise it is afterwards.  */\n-\n-  if (reload_completed == 0 || !flag_schedule_insns)\n-    {\n-      unused_insn_list = 0;\n-      unused_expr_list = 0;\n-    }\n-\n   /* initialize issue_rate */\n   issue_rate = ISSUE_RATE;\n "}, {"sha": "331b9538b3d9479cba2ba5fe7e4f59f52d537970", "filename": "gcc/lists.c", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -0,0 +1,150 @@\n+/* List management for the GNU C-Compiler expander.\n+   Copyright (C) 1987, 88, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"toplev.h\"\n+#include \"rtl.h\"\n+\n+/* Functions for maintaining cache-able lists of EXPR_LIST and INSN_LISTs.  */\n+\n+/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */\n+static rtx unused_insn_list;\n+\n+/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */\n+static rtx unused_expr_list;\n+\n+\n+/* This function will free an entire list of either EXPR_LIST or INSN_LIST\n+   nodes. This is to be used only only lists that consist exclusively of\n+   nodes of one type only.  This is only called by free_EXPR_LIST_list\n+   and free_INSN_LIST_list.  */\n+static void\n+free_list (listp, unused_listp)\n+     rtx *listp, *unused_listp;\n+{\n+  register rtx link, prev_link;\n+\n+  prev_link = *listp;\n+  link = XEXP (prev_link, 1);\n+\n+  while (link)\n+    {\n+      prev_link = link;\n+      link = XEXP (link, 1);\n+    }\n+\n+  XEXP (prev_link, 1) = *unused_listp;\n+  *unused_listp = *listp;\n+  *listp = 0;\n+}\n+\n+/* This call is used in place of a gen_rtx_INSN_LIST. If there is a cached\n+   node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST \n+   is made.  */\n+rtx\n+alloc_INSN_LIST (val, next)\n+     rtx val, next;\n+{\n+  rtx r;\n+\n+  if (unused_insn_list)\n+    {\n+      r = unused_insn_list;\n+      unused_insn_list = XEXP (r, 1);\n+      XEXP (r, 0) = val;\n+      XEXP (r, 1) = next;\n+      PUT_REG_NOTE_KIND (r, VOIDmode);\n+    }\n+  else\n+    r = gen_rtx_INSN_LIST (VOIDmode, val, next);\n+\n+  return r;\n+}\n+\n+/* This call is used in place of a gen_rtx_EXPR_LIST. If there is a cached\n+   node available, we'll use it, otherwise a call to gen_rtx_EXPR_LIST \n+   is made.  */\n+rtx\n+alloc_EXPR_LIST (kind, val, next)\n+     int kind;\n+     rtx val, next;\n+{\n+  rtx r;\n+\n+  if (unused_expr_list)\n+    {\n+      r = unused_expr_list;\n+      unused_expr_list = XEXP (r, 1);\n+      XEXP (r, 0) = val;\n+      XEXP (r, 1) = next;\n+      PUT_REG_NOTE_KIND (r, kind);\n+    }\n+  else\n+    r = gen_rtx_EXPR_LIST (kind, val, next);\n+\n+  return r;\n+}\n+\n+/* This function will initialize the EXPR_LIST and INSN_LIST caches.  */\n+void \n+init_EXPR_INSN_LIST_cache ()\n+{\n+  unused_expr_list = NULL;\n+  unused_insn_list = NULL;\n+}\n+\n+/* This function will free up an entire list of EXPR_LIST nodes.  */\n+void \n+free_EXPR_LIST_list (listp)\n+     rtx *listp;\n+{\n+  if (*listp == 0)\n+    return;\n+  free_list (listp, &unused_expr_list);\n+}\n+\n+/* This function will free up an entire list of INSN_LIST nodes.  */\n+void \n+free_INSN_LIST_list (listp)\n+     rtx *listp;\n+{\n+  if (*listp == 0)\n+    return;\n+  free_list (listp, &unused_insn_list);\n+}\n+\n+/* This function will free up an individual EXPR_LIST node.  */\n+void \n+free_EXPR_LIST_node (ptr)\n+     rtx ptr;\n+{\n+  XEXP (ptr, 1) = unused_expr_list;\n+  unused_expr_list = ptr;\n+}\n+\n+/* This function will free up an individual INSN_LIST node.  */\n+void \n+free_INSN_LIST_node (ptr)\n+     rtx ptr;\n+{\n+  XEXP (ptr, 1) = unused_insn_list;\n+  unused_insn_list = ptr;\n+}"}, {"sha": "3c8a1924eb530e61d66fbc72183ec6a359045cf5", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -1022,6 +1022,13 @@ extern void remove_node_from_expr_list\tPROTO((rtx, rtx *));\n /* flow.c */\n \n extern rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n+void init_EXPR_INSN_LIST_cache\t\tPROTO((void));\n+void free_EXPR_LIST_list \t\tPROTO((rtx *));\n+void free_INSN_LIST_list \t\tPROTO((rtx *));\n+void free_EXPR_LIST_node \t\tPROTO((rtx));\n+void free_INSN_LIST_node \t\tPROTO((rtx));\n+rtx alloc_INSN_LIST\t\t\tPROTO((rtx, rtx));\n+rtx alloc_EXPR_LIST\t\t\tPROTO((int, rtx, rtx));\n \n /* regclass.c */\n "}, {"sha": "19b983332483cf1d8af7ce1e39a55cc4a46f4193", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a4f6418af320b21dca63e0a0139306ce23b728a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5a4f6418af320b21dca63e0a0139306ce23b728a", "patch": "@@ -3821,6 +3821,8 @@ rest_of_compilation (decl)\n \n   unshare_all_rtl (insns);\n \n+  init_EXPR_INSN_LIST_cache ();\n+\n #ifdef SETJMP_VIA_SAVE_AREA\n   /* This must be performed before virutal register instantiation.  */\n   if (current_function_calls_alloca)"}]}