{"sha": "fcac74a177b6c86bf70320aae7145f3b79e54739", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNhYzc0YTE3N2I2Yzg2YmY3MDMyMGFhZTcxNDVmM2I3OWU1NDczOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-18T10:25:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-18T10:25:42Z"}, "message": "tree-data-ref.h (find_data_references_in_loop): Declare.\n\n2013-03-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-data-ref.h (find_data_references_in_loop): Declare.\n\t* tree-data-ref.c (get_references_in_stmt): Use a stack\n\tvector pre-allocated in the callers.\n\t(find_data_references_in_stmt): Adjust.\n\t(graphite_find_data_references_in_stmt): Likewise.\n\t(create_rdg_vertices): Likewise.\n\t(find_data_references_in_loop): Export.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n\tCompute dependences here...\n\t(vect_analyze_data_refs): ...not here.  When we encounter\n\ta non-vectorizable data reference in basic-block vectorization\n\ttruncate the data reference vector.  Do not bother to\n\tfixup data-dependence information for gather loads.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Check the number\n\tof data references, as reported.\n\nFrom-SVN: r196775", "tree": {"sha": "d1488179bfed051c219f22ecde86646c070342c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1488179bfed051c219f22ecde86646c070342c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcac74a177b6c86bf70320aae7145f3b79e54739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcac74a177b6c86bf70320aae7145f3b79e54739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcac74a177b6c86bf70320aae7145f3b79e54739", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcac74a177b6c86bf70320aae7145f3b79e54739/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad6fdc197621e1f48d72df91f021c187949ba6c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6fdc197621e1f48d72df91f021c187949ba6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6fdc197621e1f48d72df91f021c187949ba6c2"}], "stats": {"total": 214, "additions": 73, "deletions": 141}, "files": [{"sha": "4d9203f06a489e5c35d102cbe965e5980ae1259f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcac74a177b6c86bf70320aae7145f3b79e54739", "patch": "@@ -1,3 +1,21 @@\n+2013-03-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-data-ref.h (find_data_references_in_loop): Declare.\n+\t* tree-data-ref.c (get_references_in_stmt): Use a stack\n+\tvector pre-allocated in the callers.\n+\t(find_data_references_in_stmt): Adjust.\n+\t(graphite_find_data_references_in_stmt): Likewise.\n+\t(create_rdg_vertices): Likewise.\n+\t(find_data_references_in_loop): Export.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):\n+\tCompute dependences here...\n+\t(vect_analyze_data_refs): ...not here.  When we encounter\n+\ta non-vectorizable data reference in basic-block vectorization\n+\ttruncate the data reference vector.  Do not bother to\n+\tfixup data-dependence information for gather loads.\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Check the number\n+\tof data references, as reported.\n+\n 2013-03-18  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/3713"}, {"sha": "a387d8202e6851376691fb5c527c2f42e09bb49b", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=fcac74a177b6c86bf70320aae7145f3b79e54739", "patch": "@@ -4257,27 +4257,25 @@ compute_all_dependences (vec<data_reference_p> datarefs,\n \n typedef struct data_ref_loc_d\n {\n-    /* Position of the memory reference.  */\n-    tree *pos;\n+  /* Position of the memory reference.  */\n+  tree *pos;\n \n-      /* True if the memory reference is read.  */\n-      bool is_read;\n+  /* True if the memory reference is read.  */\n+  bool is_read;\n } data_ref_loc;\n \n \n /* Stores the locations of memory references in STMT to REFERENCES.  Returns\n    true if STMT clobbers memory, false otherwise.  */\n \n static bool\n-get_references_in_stmt (gimple stmt, vec<data_ref_loc> *references)\n+get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_stack> *references)\n {\n   bool clobbers_memory = false;\n   data_ref_loc ref;\n   tree *op0, *op1;\n   enum gimple_code stmt_code = gimple_code (stmt);\n \n-  references->create (0);\n-\n   /* ASM_EXPR and CALL_EXPR may embed arbitrary side effects.\n      As we cannot model data-references to not spelled out\n      accesses give up if they may occur.  */\n@@ -4348,11 +4346,12 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n-  vec<data_ref_loc> references;\n+  vec<data_ref_loc, va_stack> references;\n   data_ref_loc *ref;\n   bool ret = true;\n   data_reference_p dr;\n \n+  vec_stack_alloc (data_ref_loc, references, 2);\n   if (get_references_in_stmt (stmt, &references))\n     {\n       references.release ();\n@@ -4381,11 +4380,12 @@ graphite_find_data_references_in_stmt (loop_p nest, loop_p loop, gimple stmt,\n \t\t\t\t       vec<data_reference_p> *datarefs)\n {\n   unsigned i;\n-  vec<data_ref_loc> references;\n+  vec<data_ref_loc, va_stack> references;\n   data_ref_loc *ref;\n   bool ret = true;\n   data_reference_p dr;\n \n+  vec_stack_alloc (data_ref_loc, references, 2);\n   if (get_references_in_stmt (stmt, &references))\n     {\n       references.release ();\n@@ -4437,7 +4437,7 @@ find_data_references_in_bb (struct loop *loop, basic_block bb,\n    TODO: This function should be made smarter so that it can handle address\n    arithmetic as if they were array accesses, etc.  */\n \n-static tree\n+tree\n find_data_references_in_loop (struct loop *loop,\n \t\t\t      vec<data_reference_p> *datarefs)\n {\n@@ -5005,7 +5005,7 @@ create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop)\n \n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n-      vec<data_ref_loc> references;\n+      vec<data_ref_loc, va_stack> references;\n       data_ref_loc *ref;\n       struct vertex *v = &(rdg->vertices[i]);\n \n@@ -5020,6 +5020,7 @@ create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop)\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tcontinue;\n \n+      vec_stack_alloc (data_ref_loc, references, 2);\n       get_references_in_stmt (stmt, &references);\n       FOR_EACH_VEC_ELT (references, j, ref)\n \t{"}, {"sha": "c5d3e86c0d1c00f0eb0085b2f468f4434968f15c", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=fcac74a177b6c86bf70320aae7145f3b79e54739", "patch": "@@ -382,6 +382,7 @@ extern bool find_data_references_in_stmt (struct loop *, gimple,\n \t\t\t\t\t  vec<data_reference_p> *);\n extern bool graphite_find_data_references_in_stmt (loop_p, loop_p, gimple,\n \t\t\t\t\t\t   vec<data_reference_p> *);\n+tree find_data_references_in_loop (struct loop *, vec<data_reference_p> *);\n struct data_reference *create_data_ref (loop_p, loop_p, tree, gimple, bool);\n extern bool find_loop_nest (struct loop *, vec<loop_p> *);\n extern struct data_dependence_relation *initialize_data_dependence_relation"}, {"sha": "49216f4c67043d47d203fb57c5e9d3bf8ca5a1e5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 41, "deletions": 127, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=fcac74a177b6c86bf70320aae7145f3b79e54739", "patch": "@@ -798,9 +798,21 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_dependences ===\");\n   if (loop_vinfo)\n-    ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+    {\n+      if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n+\t\t\t\t    &LOOP_VINFO_DDRS (loop_vinfo),\n+\t\t\t\t    LOOP_VINFO_LOOP_NEST (loop_vinfo), true))\n+\treturn false;\n+      ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+    }\n   else\n-    ddrs = BB_VINFO_DDRS (bb_vinfo);\n+    {\n+      if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n+\t\t\t\t    &BB_VINFO_DDRS (bb_vinfo),\n+\t\t\t\t    vNULL, true))\n+\treturn false;\n+      ddrs = BB_VINFO_DDRS (bb_vinfo);\n+    }\n \n   FOR_EACH_VEC_ELT (ddrs, i, ddr)\n     if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n@@ -2941,7 +2953,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   vec<data_reference_p> datarefs;\n   struct data_reference *dr;\n   tree scalar_type;\n-  bool res, stop_bb_analysis = false;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2950,13 +2961,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   if (loop_vinfo)\n     {\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      res = compute_data_dependences_for_loop\n-\t(loop, true,\n-\t &LOOP_VINFO_LOOP_NEST (loop_vinfo),\n-\t &LOOP_VINFO_DATAREFS (loop_vinfo),\n-\t &LOOP_VINFO_DDRS (loop_vinfo));\n-\n-      if (!res)\n+      if (!find_loop_nest (loop, &LOOP_VINFO_LOOP_NEST (loop_vinfo))\n+\t  || find_data_references_in_loop\n+\t       (loop, &LOOP_VINFO_DATAREFS (loop_vinfo)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n@@ -2987,17 +2994,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      break;\n \t    }\n \t}\n-      if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n-\t\t\t\t    &BB_VINFO_DDRS (bb_vinfo),\n-\t\t\t\t    vNULL, true))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                             \"not vectorized: basic block contains function\"\n-                             \" calls or data references that cannot be\"\n-                             \" analyzed\");\n-\t  return false;\n-\t}\n \n       datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n     }\n@@ -3024,12 +3020,6 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n \n-      if (stop_bb_analysis)\n-        {\n-          STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-          continue;\n-        }\n-\n       /* Check that analysis of the data-ref succeeded.  */\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n \t  || !DR_STEP (dr))\n@@ -3070,11 +3060,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t}\n \n \t      if (bb_vinfo)\n-\t\t{\n-\t\t  STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-\t\t  stop_bb_analysis = true;\n-\t\t  continue;\n-\t\t}\n+\t\tbreak;\n \n \t      return false;\n \t    }\n@@ -3088,11 +3074,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                              \"constant\");\n \n           if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n \t  if (gather)\n \t    free_data_ref (dr);\n@@ -3109,11 +3091,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             }\n \n           if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n           return false;\n         }\n@@ -3129,11 +3107,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             }\n \n           if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n \t  if (gather)\n \t    free_data_ref (dr);\n@@ -3152,11 +3126,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             }\n \n           if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n \t  if (gather)\n \t    free_data_ref (dr);\n@@ -3177,11 +3147,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    }\n \n \t  if (bb_vinfo)\n-\t    {\n-\t      STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-\t      stop_bb_analysis = true;\n-\t      continue;\n-\t    }\n+\t    break;\n \n \t  if (gather)\n \t    free_data_ref (dr);\n@@ -3316,11 +3282,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             }\n \n           if (bb_vinfo)\n-            {\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n \t  if (gather)\n \t    free_data_ref (dr);\n@@ -3346,12 +3308,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n             }\n \n           if (bb_vinfo)\n-            {\n-              /* Mark the statement as not vectorizable.  */\n-              STMT_VINFO_VECTORIZABLE (stmt_info) = false;\n-              stop_bb_analysis = true;\n-              continue;\n-            }\n+\t    break;\n \n \t  if (gather)\n \t    {\n@@ -3369,14 +3326,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (gather)\n \t{\n-\t  unsigned int j, k, n;\n-\t  struct data_reference *olddr\n-\t    = datarefs[i];\n-\t  vec<ddr_p> ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n-\t  struct data_dependence_relation *ddr, *newddr;\n-\t  bool bad = false;\n \t  tree off;\n-\t  vec<loop_p> nest = LOOP_VINFO_LOOP_NEST (loop_vinfo);\n \n \t  gather = 0 != vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL);\n \t  if (gather\n@@ -3396,59 +3346,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      return false;\n \t    }\n \n-\t  n = datarefs.length () - 1;\n-\t  for (j = 0, k = i - 1; j < i; j++)\n-\t    {\n-\t      ddr = ddrs[k];\n-\t      gcc_assert (DDR_B (ddr) == olddr);\n-\t      newddr = initialize_data_dependence_relation (DDR_A (ddr), dr,\n-\t\t\t\t\t\t\t    nest);\n-\t      ddrs[k] = newddr;\n-\t      free_dependence_relation (ddr);\n-\t      if (!bad\n-\t\t  && DR_IS_WRITE (DDR_A (newddr))\n-\t\t  && DDR_ARE_DEPENDENT (newddr) != chrec_known)\n-\t\tbad = true;\n-\t      k += --n;\n-\t    }\n-\n-\t  k++;\n-\t  n = k + datarefs.length () - i - 1;\n-\t  for (; k < n; k++)\n-\t    {\n-\t      ddr = ddrs[k];\n-\t      gcc_assert (DDR_A (ddr) == olddr);\n-\t      newddr = initialize_data_dependence_relation (dr, DDR_B (ddr),\n-\t\t\t\t\t\t\t    nest);\n-\t      ddrs[k] = newddr;\n-\t      free_dependence_relation (ddr);\n-\t      if (!bad\n-\t\t  && DR_IS_WRITE (DDR_B (newddr))\n-\t\t  && DDR_ARE_DEPENDENT (newddr) != chrec_known)\n-\t\tbad = true;\n-\t    }\n-\n-\t  k = ddrs.length ()\n-\t      - datarefs.length () + i;\n-\t  ddr = ddrs[k];\n-\t  gcc_assert (DDR_A (ddr) == olddr && DDR_B (ddr) == olddr);\n-\t  newddr = initialize_data_dependence_relation (dr, dr, nest);\n-\t  ddrs[k] = newddr;\n-\t  free_dependence_relation (ddr);\n \t  datarefs[i] = dr;\n-\n-\t  if (bad)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                   \"not vectorized: data dependence conflict\"\n-                                   \" prevents gather load\");\n-\t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n \t  STMT_VINFO_GATHER_P (stmt_info) = true;\n \t}\n       else if (loop_vinfo\n@@ -3472,6 +3370,22 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t}\n     }\n \n+  /* If we stopped analysis at the first dataref we could not analyze\n+     when trying to vectorize a basic-block mark the rest of the datarefs\n+     as not vectorizable and truncate the vector of datarefs.  That\n+     avoids spending useless time in analyzing their dependence.  */\n+  if (i != datarefs.length ())\n+    {\n+      gcc_assert (bb_vinfo != NULL);\n+      for (unsigned j = i; j < datarefs.length (); ++j)\n+\t{\n+\t  data_reference_p dr = datarefs[j];\n+          STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n+\t  free_data_ref (dr);\n+\t}\n+      datarefs.truncate (i);\n+    }\n+\n   return true;\n }\n "}, {"sha": "8567eac0df2e2dfb3820e64a013e19cfb9e18ece", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcac74a177b6c86bf70320aae7145f3b79e54739/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=fcac74a177b6c86bf70320aae7145f3b79e54739", "patch": "@@ -2078,7 +2078,6 @@ static bb_vec_info\n vect_slp_analyze_bb_1 (basic_block bb)\n {\n   bb_vec_info bb_vinfo;\n-  vec<ddr_p> ddrs;\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n   int i;\n@@ -2100,8 +2099,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  ddrs = BB_VINFO_DDRS (bb_vinfo);\n-  if (!ddrs.length ())\n+  if (BB_VINFO_DATAREFS (bb_vinfo).length () < 2)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}]}