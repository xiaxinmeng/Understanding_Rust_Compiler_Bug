{"sha": "cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjNzZlYzRkMDYzY2U1YzdiODBkYjRhMzQ2NmY3OTc0YjBhNTU0Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-11-16T22:22:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-11-16T22:22:13Z"}, "message": "re PR target/46470 (\"add    $0x8,%rsp\" no longer optimized to pop)\n\nPR target/46470\n        * recog.c (peep2_attempt): Convert frame-related info when possible.\n        (peep2_fill_buffer): Allow frame-related insns into the buffer.\n        (peephole2_optimize): Allow peep2_attempt to fail.\n\nFrom-SVN: r166829", "tree": {"sha": "c6179635fcded3194ea1eb8e22feeaca3c2bb332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6179635fcded3194ea1eb8e22feeaca3c2bb332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/comments", "author": null, "committer": null, "parents": [{"sha": "885c9b5d3a53c531fca622b4a3b0ef03df92daed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/885c9b5d3a53c531fca622b4a3b0ef03df92daed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/885c9b5d3a53c531fca622b4a3b0ef03df92daed"}], "stats": {"total": 126, "additions": 108, "deletions": 18}, "files": [{"sha": "50f93830b4911ae77c1593343a50a01d60a3e56d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "patch": "@@ -1,3 +1,10 @@\n+2010-11-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/46470\n+\t* recog.c (peep2_attempt): Convert frame-related info when possible.\n+\t(peep2_fill_buffer): Allow frame-related insns into the buffer.\n+\t(peephole2_optimize): Allow peep2_attempt to fail.\n+\n 2010-11-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR rtl-optimization/46315"}, {"sha": "b140c0e17ddb98c83a23fb0d67512a84e8292bf1", "filename": "gcc/recog.c", "status": "modified", "additions": 92, "deletions": 18, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "patch": "@@ -3134,22 +3134,99 @@ peep2_reinit_state (regset live)\n \n /* While scanning basic block BB, we found a match of length MATCH_LEN,\n    starting at INSN.  Perform the replacement, removing the old insns and\n-   replacing them with ATTEMPT.  Returns the last insn emitted.  */\n+   replacing them with ATTEMPT.  Returns the last insn emitted, or NULL\n+   if the replacement is rejected.  */\n \n static rtx\n peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n {\n   int i;\n   rtx last, note, before_try, x;\n+  rtx old_insn, new_insn;\n   bool was_call = false;\n \n+  /* If we are splittind an RTX_FRAME_RELATED_P insn, do not allow it to\n+     match more than one insn, or to be split into more than one insn.  */\n+  old_insn = peep2_insn_data[peep2_current].insn;\n+  if (RTX_FRAME_RELATED_P (old_insn))\n+    {\n+      bool any_note = false;\n+\n+      if (match_len != 0)\n+\treturn NULL;\n+\n+      /* Look for one \"active\" insn.  I.e. ignore any \"clobber\" insns that\n+\t may be in the stream for the purpose of register allocation.  */\n+      if (active_insn_p (attempt))\n+\tnew_insn = attempt;\n+      else\n+\tnew_insn = next_active_insn (attempt);\n+      if (next_active_insn (new_insn))\n+\treturn NULL;\n+\n+      /* We have a 1-1 replacement.  Copy over any frame-related info.  */\n+      RTX_FRAME_RELATED_P (new_insn) = 1;\n+\n+      /* Allow the backend to fill in a note during the split.  */\n+      for (note = REG_NOTES (new_insn); note ; note = XEXP (note, 1))\n+\tswitch (REG_NOTE_KIND (note))\n+\t  {\n+\t  case REG_FRAME_RELATED_EXPR:\n+\t  case REG_CFA_DEF_CFA:\n+\t  case REG_CFA_ADJUST_CFA:\n+\t  case REG_CFA_OFFSET:\n+\t  case REG_CFA_REGISTER:\n+\t  case REG_CFA_EXPRESSION:\n+\t  case REG_CFA_RESTORE:\n+\t  case REG_CFA_SET_VDRAP:\n+\t    any_note = true;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+      /* If the backend didn't supply a note, copy one over.  */\n+      if (!any_note)\n+        for (note = REG_NOTES (old_insn); note ; note = XEXP (note, 1))\n+\t  switch (REG_NOTE_KIND (note))\n+\t    {\n+\t    case REG_FRAME_RELATED_EXPR:\n+\t    case REG_CFA_DEF_CFA:\n+\t    case REG_CFA_ADJUST_CFA:\n+\t    case REG_CFA_OFFSET:\n+\t    case REG_CFA_REGISTER:\n+\t    case REG_CFA_EXPRESSION:\n+\t    case REG_CFA_RESTORE:\n+\t    case REG_CFA_SET_VDRAP:\n+\t      add_reg_note (new_insn, REG_NOTE_KIND (note), XEXP (note, 0));\n+\t      any_note = true;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\n+      /* If there still isn't a note, make sure the unwind info sees the\n+\t same expression as before the split.  */\n+      if (!any_note)\n+\t{\n+\t  rtx old_set, new_set;\n+\n+\t  /* The old insn had better have been simple, or annotated.  */\n+\t  old_set = single_set (old_insn);\n+\t  gcc_assert (old_set != NULL);\n+\n+\t  new_set = single_set (new_insn);\n+\t  if (!new_set || !rtx_equal_p (new_set, old_set))\n+\t    add_reg_note (new_insn, REG_FRAME_RELATED_EXPR, old_set);\n+\t}\n+    }\n+\n   /* If we are splitting a CALL_INSN, look for the CALL_INSN\n      in SEQ and copy our CALL_INSN_FUNCTION_USAGE and other\n      cfg-related call notes.  */\n   for (i = 0; i <= match_len; ++i)\n     {\n       int j;\n-      rtx old_insn, new_insn, note;\n \n       j = peep2_buf_position (peep2_current + i);\n       old_insn = peep2_insn_data[j].insn;\n@@ -3322,18 +3399,14 @@ peep2_fill_buffer (basic_block bb, rtx insn, regset live)\n   if (peep2_current_count == MAX_INSNS_PER_PEEP2)\n     return false;\n \n-  /* If an insn has RTX_FRAME_RELATED_P set, peephole substitution would lose\n-     the REG_FRAME_RELATED_EXPR that is attached.  */\n+  /* If an insn has RTX_FRAME_RELATED_P set, do not allow it to be matched with\n+     any other pattern, lest it change the semantics of the frame info.  */\n   if (RTX_FRAME_RELATED_P (insn))\n     {\n       /* Let the buffer drain first.  */\n       if (peep2_current_count > 0)\n \treturn false;\n-      /* Step over the insn then return true without adding the insn\n-\t to the buffer; this will cause us to process the next\n-\t insn.  */\n-      df_simulate_one_insn_forwards (bb, insn, live);\n-      return true;\n+      /* Now the insn will be the only thing in the buffer.  */\n     }\n \n   pos = peep2_buf_position (peep2_current + peep2_current_count);\n@@ -3412,16 +3485,17 @@ peephole2_optimize (void)\n \t  attempt = peephole2_insns (PATTERN (head), head, &match_len);\n \t  if (attempt != NULL)\n \t    {\n-\t      rtx last;\n-\t      last = peep2_attempt (bb, head, match_len, attempt);\n-\t      peep2_update_life (bb, match_len, last, PREV_INSN (attempt));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If no match, advance the buffer by one insn.  */\n-\t      peep2_current = peep2_buf_position (peep2_current + 1);\n-\t      peep2_current_count--;\n+\t      rtx last = peep2_attempt (bb, head, match_len, attempt);\n+\t      if (last)\n+\t\t{\n+\t\t  peep2_update_life (bb, match_len, last, PREV_INSN (attempt));\n+\t\t  continue;\n+\t\t}\n \t    }\n+\n+\t  /* No match: advance the buffer by one insn.  */\n+\t  peep2_current = peep2_buf_position (peep2_current + 1);\n+\t  peep2_current_count--;\n \t}\n     }\n "}, {"sha": "eacba4b413136a0a76b832bf364a882b61121fc6", "filename": "gcc/testsuite/gcc.target/i386/pr46470.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46470.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfc76ec4d063ce5c7b80db4a3466f7974b0a554b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46470.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr46470.c?ref=cfc76ec4d063ce5c7b80db4a3466f7974b0a554b", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fomit-frame-pointer -fasynchronous-unwind-tables\" } */\n+/* { dg-options \"-Os -fomit-frame-pointer -mpreferred-stack-boundary=3 -fasynchronous-unwind-tables\" { target ilp32 } } */\n+\n+void f();\n+void g() { f(); f(); }\n+\n+/* Both stack allocate and deallocate should be converted to push/pop.  */\n+/* { dg-final { scan-assembler-not \"sp\" } } */"}]}