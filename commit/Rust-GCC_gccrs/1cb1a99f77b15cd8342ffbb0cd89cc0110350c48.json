{"sha": "1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiMWE5OWY3N2IxNWNkODM0MmZmYmIwY2Q4OWNjMDExMDM1MGM0OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-03T17:22:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-03T17:22:58Z"}, "message": "cgraph.h (cgraph_node_set_def, [...]): Move out of GTY; replace hash by pointer map.\n\n\n\t* cgraph.h (cgraph_node_set_def, varpool_node_set_def): Move out of GTY;\n\treplace hash by pointer map.\n\t(cgraph_node_set_element_def, cgraph_node_set_element,\n\tconst_cgraph_node_set_element, varpool_node_set_element_def,\n\tvarpool_node_set_element, const_varpool_node_set_element): Remove.\n\t(free_cgraph_node_set, free_varpool_node_set): New function.\n\t(cgraph_node_set_size, varpool_node_set_size): Use vector size.\n\t* tree-emutls.c: Free varpool node set.\n\t* ipa-utils.c (cgraph_node_set_new, cgraph_node_set_add,\n\tcgraph_node_set_remove, cgraph_node_set_find, dump_cgraph_node_set,\n\tdebug_cgraph_node_set, free_cgraph_node_set, varpool_node_set_new,\n\tvarpool_node_set_add, varpool_node_set_remove, varpool_node_set_find,\n\tdump_varpool_node_set, free_varpool_node_set, debug_varpool_node_set):\n\tMove here from ipa.c; implement using pointer_map\n\t* ipa.c (cgraph_node_set_new, cgraph_node_set_add,\n\tcgraph_node_set_remove, cgraph_node_set_find, dump_cgraph_node_set,\n\tdebug_cgraph_node_set, varpool_node_set_new,\n\tvarpool_node_set_add, varpool_node_set_remove, varpool_node_set_find,\n\tdump_varpool_node_set, debug_varpool_node_set):\n\tMove to ipa-uitls.c.\n\t* lto/lto.c (ltrans_partition_def): Remove GTY annotations.\n\t(ltrans_partitions): Move to heap.\n\t(new_partition): Update.\n\t(free_ltrans_partitions): New function.\n\t(lto_wpa_write_files): Use it.\n\t* passes.c (ipa_write_summaries): Update.\n\nFrom-SVN: r173334", "tree": {"sha": "29d6574c5d8892da7a62fdb54c7eabbacb56e4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29d6574c5d8892da7a62fdb54c7eabbacb56e4b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/comments", "author": null, "committer": null, "parents": [{"sha": "b445518d112c0cd481b15df83fbef474cf4058d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b445518d112c0cd481b15df83fbef474cf4058d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b445518d112c0cd481b15df83fbef474cf4058d6"}], "stats": {"total": 677, "additions": 324, "deletions": 353}, "files": [{"sha": "f824ed6e4fa34d2180895131471610a89a59da90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -1,3 +1,27 @@\n+2011-05-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (cgraph_node_set_def, varpool_node_set_def): Move out of GTY;\n+\treplace hash by pointer map.\n+\t(cgraph_node_set_element_def, cgraph_node_set_element,\n+\tconst_cgraph_node_set_element, varpool_node_set_element_def,\n+\tvarpool_node_set_element, const_varpool_node_set_element): Remove.\n+\t(free_cgraph_node_set, free_varpool_node_set): New function.\n+\t(cgraph_node_set_size, varpool_node_set_size): Use vector size.\n+\t* tree-emutls.c: Free varpool node set.\n+\t* ipa-utils.c (cgraph_node_set_new, cgraph_node_set_add,\n+\tcgraph_node_set_remove, cgraph_node_set_find, dump_cgraph_node_set,\n+\tdebug_cgraph_node_set, free_cgraph_node_set, varpool_node_set_new,\n+\tvarpool_node_set_add, varpool_node_set_remove, varpool_node_set_find,\n+\tdump_varpool_node_set, free_varpool_node_set, debug_varpool_node_set):\n+\tMove here from ipa.c; implement using pointer_map\n+\t* ipa.c (cgraph_node_set_new, cgraph_node_set_add,\n+\tcgraph_node_set_remove, cgraph_node_set_find, dump_cgraph_node_set,\n+\tdebug_cgraph_node_set, varpool_node_set_new,\n+\tvarpool_node_set_add, varpool_node_set_remove, varpool_node_set_find,\n+\tdump_varpool_node_set, debug_varpool_node_set):\n+\tMove to ipa-uitls.c.\n+\t* passes.c (ipa_write_summaries): Update.\n+\n 2011-05-03  Stuart Henderson  <shenders@gcc.gnu.org>\n \n         From Mike Frysinger:"}, {"sha": "35d1a9d791c421790259aa3ac754e092a7a12f81", "filename": "gcc/cgraph.h", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -256,10 +256,10 @@ DEF_VEC_ALLOC_P(cgraph_node_ptr,gc);\n \n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n    can appear in multiple sets.  */\n-struct GTY(()) cgraph_node_set_def\n+struct cgraph_node_set_def\n {\n-  htab_t GTY((param_is (struct cgraph_node_set_element_def))) hashtab;\n-  VEC(cgraph_node_ptr, gc) *nodes;\n+  struct pointer_map_t *map;\n+  VEC(cgraph_node_ptr, heap) *nodes;\n };\n \n typedef struct varpool_node *varpool_node_ptr;\n@@ -270,10 +270,10 @@ DEF_VEC_ALLOC_P(varpool_node_ptr,gc);\n \n /* A varpool node set is a collection of varpool nodes.  A varpool node\n    can appear in multiple sets.  */\n-struct GTY(()) varpool_node_set_def\n+struct varpool_node_set_def\n {\n-  htab_t GTY((param_is (struct varpool_node_set_element_def))) hashtab;\n-  VEC(varpool_node_ptr, gc) *nodes;\n+  struct pointer_map_t * map;\n+  VEC(varpool_node_ptr, heap) *nodes;\n };\n \n typedef struct cgraph_node_set_def *cgraph_node_set;\n@@ -288,35 +288,13 @@ DEF_VEC_P(varpool_node_set);\n DEF_VEC_ALLOC_P(varpool_node_set,gc);\n DEF_VEC_ALLOC_P(varpool_node_set,heap);\n \n-/* A cgraph node set element contains an index in the vector of nodes in\n-   the set.  */\n-struct GTY(()) cgraph_node_set_element_def\n-{\n-  struct cgraph_node *node;\n-  HOST_WIDE_INT index;\n-};\n-\n-typedef struct cgraph_node_set_element_def *cgraph_node_set_element;\n-typedef const struct cgraph_node_set_element_def *const_cgraph_node_set_element;\n-\n /* Iterator structure for cgraph node sets.  */\n typedef struct\n {\n   cgraph_node_set set;\n   unsigned index;\n } cgraph_node_set_iterator;\n \n-/* A varpool node set element contains an index in the vector of nodes in\n-   the set.  */\n-struct GTY(()) varpool_node_set_element_def\n-{\n-  struct varpool_node *node;\n-  HOST_WIDE_INT index;\n-};\n-\n-typedef struct varpool_node_set_element_def *varpool_node_set_element;\n-typedef const struct varpool_node_set_element_def *const_varpool_node_set_element;\n-\n /* Iterator structure for varpool node sets.  */\n typedef struct\n {\n@@ -632,6 +610,7 @@ void cgraph_node_set_add (cgraph_node_set, struct cgraph_node *);\n void cgraph_node_set_remove (cgraph_node_set, struct cgraph_node *);\n void dump_cgraph_node_set (FILE *, cgraph_node_set);\n void debug_cgraph_node_set (cgraph_node_set);\n+void free_cgraph_node_set (cgraph_node_set);\n \n varpool_node_set varpool_node_set_new (void);\n varpool_node_set_iterator varpool_node_set_find (varpool_node_set,\n@@ -640,6 +619,7 @@ void varpool_node_set_add (varpool_node_set, struct varpool_node *);\n void varpool_node_set_remove (varpool_node_set, struct varpool_node *);\n void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n+void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n bool cgraph_comdat_can_be_unshared_p (struct cgraph_node *);\n \n@@ -763,7 +743,7 @@ cgraph_node_in_set_p (struct cgraph_node *node, cgraph_node_set set)\n static inline size_t\n cgraph_node_set_size (cgraph_node_set set)\n {\n-  return htab_elements (set->hashtab);\n+  return VEC_length (cgraph_node_ptr, set->nodes);\n }\n \n /* Return true if iterator VSI points to nothing.  */\n@@ -811,7 +791,7 @@ varpool_node_in_set_p (struct varpool_node *node, varpool_node_set set)\n static inline size_t\n varpool_node_set_size (varpool_node_set set)\n {\n-  return htab_elements (set->hashtab);\n+  return VEC_length (varpool_node_ptr, set->nodes);\n }\n \n /* Uniquize all constants that appear in memory."}, {"sha": "de4f4b6e107b033d14a18dfe10123d23fd5fa9ea", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -324,3 +324,260 @@ get_base_var (tree t)\n   return t;\n }\n \n+\n+/* Create a new cgraph node set.  */\n+\n+cgraph_node_set\n+cgraph_node_set_new (void)\n+{\n+  cgraph_node_set new_node_set;\n+\n+  new_node_set = XCNEW (struct cgraph_node_set_def);\n+  new_node_set->map = pointer_map_create ();\n+  new_node_set->nodes = NULL;\n+  return new_node_set;\n+}\n+\n+\n+/* Add cgraph_node NODE to cgraph_node_set SET.  */\n+\n+void\n+cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot;\n+\n+  slot = pointer_map_insert (set->map, node);\n+\n+  if (*slot)\n+    {\n+      int index = (size_t) *slot - 1;\n+      gcc_checking_assert ((VEC_index (cgraph_node_ptr, set->nodes, index)\n+\t\t           == node));\n+      return;\n+    }\n+\n+  *slot = (void *)(size_t) (VEC_length (cgraph_node_ptr, set->nodes) + 1);\n+\n+  /* Insert into node vector.  */\n+  VEC_safe_push (cgraph_node_ptr, heap, set->nodes, node);\n+}\n+\n+\n+/* Remove cgraph_node NODE from cgraph_node_set SET.  */\n+\n+void\n+cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot, **last_slot;\n+  int index;\n+  struct cgraph_node *last_node;\n+\n+  slot = pointer_map_contains (set->map, node);\n+  if (slot == NULL || !*slot)\n+    return;\n+\n+  index = (size_t) *slot - 1;\n+  gcc_checking_assert (VEC_index (cgraph_node_ptr, set->nodes, index)\n+\t      \t       == node);\n+\n+  /* Remove from vector. We do this by swapping node with the last element\n+     of the vector.  */\n+  last_node = VEC_pop (cgraph_node_ptr, set->nodes);\n+  if (last_node != node)\n+    {\n+      last_slot = pointer_map_contains (set->map, last_node);\n+      gcc_checking_assert (last_slot && *last_slot);\n+      *last_slot = (void *)(size_t) (index + 1);\n+\n+      /* Move the last element to the original spot of NODE.  */\n+      VEC_replace (cgraph_node_ptr, set->nodes, index, last_node);\n+    }\n+\n+  /* Remove element from hash table.  */\n+  *slot = NULL;\n+}\n+\n+\n+/* Find NODE in SET and return an iterator to it if found.  A null iterator\n+   is returned if NODE is not in SET.  */\n+\n+cgraph_node_set_iterator\n+cgraph_node_set_find (cgraph_node_set set, struct cgraph_node *node)\n+{\n+  void **slot;\n+  cgraph_node_set_iterator csi;\n+\n+  slot = pointer_map_contains (set->map, node);\n+  if (slot == NULL || !*slot)\n+    csi.index = (unsigned) ~0;\n+  else\n+    csi.index = (size_t)*slot - 1;\n+  csi.set = set;\n+\n+  return csi;\n+}\n+\n+\n+/* Dump content of SET to file F.  */\n+\n+void\n+dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n+{\n+  cgraph_node_set_iterator iter;\n+\n+  for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n+    {\n+      struct cgraph_node *node = csi_node (iter);\n+      fprintf (f, \" %s/%i\", cgraph_node_name (node), node->uid);\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+\n+/* Dump content of SET to stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_cgraph_node_set (cgraph_node_set set)\n+{\n+  dump_cgraph_node_set (stderr, set);\n+}\n+\n+\n+/* Free varpool node set.  */\n+\n+void\n+free_cgraph_node_set (cgraph_node_set set)\n+{\n+  VEC_free (cgraph_node_ptr, heap, set->nodes);\n+  pointer_map_destroy (set->map);\n+  free (set);\n+}\n+\n+\n+/* Create a new varpool node set.  */\n+\n+varpool_node_set\n+varpool_node_set_new (void)\n+{\n+  varpool_node_set new_node_set;\n+\n+  new_node_set = XCNEW (struct varpool_node_set_def);\n+  new_node_set->map = pointer_map_create ();\n+  new_node_set->nodes = NULL;\n+  return new_node_set;\n+}\n+\n+\n+/* Add varpool_node NODE to varpool_node_set SET.  */\n+\n+void\n+varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot;\n+\n+  slot = pointer_map_insert (set->map, node);\n+\n+  if (*slot)\n+    {\n+      int index = (size_t) *slot - 1;\n+      gcc_checking_assert ((VEC_index (varpool_node_ptr, set->nodes, index)\n+\t\t           == node));\n+      return;\n+    }\n+\n+  *slot = (void *)(size_t) (VEC_length (varpool_node_ptr, set->nodes) + 1);\n+\n+  /* Insert into node vector.  */\n+  VEC_safe_push (varpool_node_ptr, heap, set->nodes, node);\n+}\n+\n+\n+/* Remove varpool_node NODE from varpool_node_set SET.  */\n+\n+void\n+varpool_node_set_remove (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot, **last_slot;\n+  int index;\n+  struct varpool_node *last_node;\n+\n+  slot = pointer_map_contains (set->map, node);\n+  if (slot == NULL || !*slot)\n+    return;\n+\n+  index = (size_t) *slot - 1;\n+  gcc_checking_assert (VEC_index (varpool_node_ptr, set->nodes, index)\n+\t      \t       == node);\n+\n+  /* Remove from vector. We do this by swapping node with the last element\n+     of the vector.  */\n+  last_node = VEC_pop (varpool_node_ptr, set->nodes);\n+  if (last_node != node)\n+    {\n+      last_slot = pointer_map_contains (set->map, last_node);\n+      gcc_checking_assert (last_slot && *last_slot);\n+      *last_slot = (void *)(size_t) (index + 1);\n+\n+      /* Move the last element to the original spot of NODE.  */\n+      VEC_replace (varpool_node_ptr, set->nodes, index, last_node);\n+    }\n+\n+  /* Remove element from hash table.  */\n+  *slot = NULL;\n+}\n+\n+\n+/* Find NODE in SET and return an iterator to it if found.  A null iterator\n+   is returned if NODE is not in SET.  */\n+\n+varpool_node_set_iterator\n+varpool_node_set_find (varpool_node_set set, struct varpool_node *node)\n+{\n+  void **slot;\n+  varpool_node_set_iterator vsi;\n+\n+  slot = pointer_map_contains (set->map, node);\n+  if (slot == NULL || !*slot)\n+    vsi.index = (unsigned) ~0;\n+  else\n+    vsi.index = (size_t)*slot - 1;\n+  vsi.set = set;\n+\n+  return vsi;\n+}\n+\n+\n+/* Dump content of SET to file F.  */\n+\n+void\n+dump_varpool_node_set (FILE *f, varpool_node_set set)\n+{\n+  varpool_node_set_iterator iter;\n+\n+  for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n+    {\n+      struct varpool_node *node = vsi_node (iter);\n+      fprintf (f, \" %s\", varpool_node_name (node));\n+    }\n+  fprintf (f, \"\\n\");\n+}\n+\n+\n+/* Free varpool node set.  */\n+\n+void\n+free_varpool_node_set (varpool_node_set set)\n+{\n+  VEC_free (varpool_node_ptr, heap, set->nodes);\n+  pointer_map_destroy (set->map);\n+  free (set);\n+}\n+\n+\n+/* Dump content of SET to stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_varpool_node_set (varpool_node_set set)\n+{\n+  dump_varpool_node_set (stderr, set);\n+}"}, {"sha": "8f1122b01f6fb4af9b0ffb1ef9f1bc8efe19672f", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -1047,320 +1047,6 @@ struct ipa_opt_pass_d pass_ipa_whole_program_visibility =\n  NULL,\t\t\t\t\t/* variable_transform */\n };\n \n-/* Hash a cgraph node set element.  */\n-\n-static hashval_t\n-hash_cgraph_node_set_element (const void *p)\n-{\n-  const_cgraph_node_set_element element = (const_cgraph_node_set_element) p;\n-  return htab_hash_pointer (element->node);\n-}\n-\n-/* Compare two cgraph node set elements.  */\n-\n-static int\n-eq_cgraph_node_set_element (const void *p1, const void *p2)\n-{\n-  const_cgraph_node_set_element e1 = (const_cgraph_node_set_element) p1;\n-  const_cgraph_node_set_element e2 = (const_cgraph_node_set_element) p2;\n-\n-  return e1->node == e2->node;\n-}\n-\n-/* Create a new cgraph node set.  */\n-\n-cgraph_node_set\n-cgraph_node_set_new (void)\n-{\n-  cgraph_node_set new_node_set;\n-\n-  new_node_set = ggc_alloc_cgraph_node_set_def ();\n-  new_node_set->hashtab = htab_create_ggc (10,\n-\t\t\t\t\t   hash_cgraph_node_set_element,\n-\t\t\t\t\t   eq_cgraph_node_set_element,\n-\t\t\t\t\t   NULL);\n-  new_node_set->nodes = NULL;\n-  return new_node_set;\n-}\n-\n-/* Add cgraph_node NODE to cgraph_node_set SET.  */\n-\n-void\n-cgraph_node_set_add (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  void **slot;\n-  cgraph_node_set_element element;\n-  struct cgraph_node_set_element_def dummy;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, INSERT);\n-\n-  if (*slot != HTAB_EMPTY_ENTRY)\n-    {\n-      element = (cgraph_node_set_element) *slot;\n-      gcc_assert (node == element->node\n-\t\t  && (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n-\t\t      == node));\n-      return;\n-    }\n-\n-  /* Insert node into hash table.  */\n-  element = ggc_alloc_cgraph_node_set_element_def ();\n-  element->node = node;\n-  element->index = VEC_length (cgraph_node_ptr, set->nodes);\n-  *slot = element;\n-\n-  /* Insert into node vector.  */\n-  VEC_safe_push (cgraph_node_ptr, gc, set->nodes, node);\n-}\n-\n-/* Remove cgraph_node NODE from cgraph_node_set SET.  */\n-\n-void\n-cgraph_node_set_remove (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  void **slot, **last_slot;\n-  cgraph_node_set_element element, last_element;\n-  struct cgraph_node *last_node;\n-  struct cgraph_node_set_element_def dummy;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-  if (slot == NULL)\n-    return;\n-\n-  element = (cgraph_node_set_element) *slot;\n-  gcc_assert (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n-\t      == node);\n-\n-  /* Remove from vector. We do this by swapping node with the last element\n-     of the vector.  */\n-  last_node = VEC_pop (cgraph_node_ptr, set->nodes);\n-  if (last_node != node)\n-    {\n-      dummy.node = last_node;\n-      last_slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-      last_element = (cgraph_node_set_element) *last_slot;\n-      gcc_assert (last_element);\n-\n-      /* Move the last element to the original spot of NODE.  */\n-      last_element->index = element->index;\n-      VEC_replace (cgraph_node_ptr, set->nodes, last_element->index,\n-\t\t   last_node);\n-    }\n-\n-  /* Remove element from hash table.  */\n-  htab_clear_slot (set->hashtab, slot);\n-  ggc_free (element);\n-}\n-\n-/* Find NODE in SET and return an iterator to it if found.  A null iterator\n-   is returned if NODE is not in SET.  */\n-\n-cgraph_node_set_iterator\n-cgraph_node_set_find (cgraph_node_set set, struct cgraph_node *node)\n-{\n-  void **slot;\n-  struct cgraph_node_set_element_def dummy;\n-  cgraph_node_set_element element;\n-  cgraph_node_set_iterator csi;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-  if (slot == NULL)\n-    csi.index = (unsigned) ~0;\n-  else\n-    {\n-      element = (cgraph_node_set_element) *slot;\n-      gcc_assert (VEC_index (cgraph_node_ptr, set->nodes, element->index)\n-\t\t  == node);\n-      csi.index = element->index;\n-    }\n-  csi.set = set;\n-\n-  return csi;\n-}\n-\n-/* Dump content of SET to file F.  */\n-\n-void\n-dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n-{\n-  cgraph_node_set_iterator iter;\n-\n-  for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n-    {\n-      struct cgraph_node *node = csi_node (iter);\n-      fprintf (f, \" %s/%i\", cgraph_node_name (node), node->uid);\n-    }\n-  fprintf (f, \"\\n\");\n-}\n-\n-/* Dump content of SET to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_cgraph_node_set (cgraph_node_set set)\n-{\n-  dump_cgraph_node_set (stderr, set);\n-}\n-\n-/* Hash a varpool node set element.  */\n-\n-static hashval_t\n-hash_varpool_node_set_element (const void *p)\n-{\n-  const_varpool_node_set_element element = (const_varpool_node_set_element) p;\n-  return htab_hash_pointer (element->node);\n-}\n-\n-/* Compare two varpool node set elements.  */\n-\n-static int\n-eq_varpool_node_set_element (const void *p1, const void *p2)\n-{\n-  const_varpool_node_set_element e1 = (const_varpool_node_set_element) p1;\n-  const_varpool_node_set_element e2 = (const_varpool_node_set_element) p2;\n-\n-  return e1->node == e2->node;\n-}\n-\n-/* Create a new varpool node set.  */\n-\n-varpool_node_set\n-varpool_node_set_new (void)\n-{\n-  varpool_node_set new_node_set;\n-\n-  new_node_set = ggc_alloc_varpool_node_set_def ();\n-  new_node_set->hashtab = htab_create_ggc (10,\n-\t\t\t\t\t   hash_varpool_node_set_element,\n-\t\t\t\t\t   eq_varpool_node_set_element,\n-\t\t\t\t\t   NULL);\n-  new_node_set->nodes = NULL;\n-  return new_node_set;\n-}\n-\n-/* Add varpool_node NODE to varpool_node_set SET.  */\n-\n-void\n-varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n-{\n-  void **slot;\n-  varpool_node_set_element element;\n-  struct varpool_node_set_element_def dummy;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, INSERT);\n-\n-  if (*slot != HTAB_EMPTY_ENTRY)\n-    {\n-      element = (varpool_node_set_element) *slot;\n-      gcc_assert (node == element->node\n-\t\t  && (VEC_index (varpool_node_ptr, set->nodes, element->index)\n-\t\t      == node));\n-      return;\n-    }\n-\n-  /* Insert node into hash table.  */\n-  element = ggc_alloc_varpool_node_set_element_def ();\n-  element->node = node;\n-  element->index = VEC_length (varpool_node_ptr, set->nodes);\n-  *slot = element;\n-\n-  /* Insert into node vector.  */\n-  VEC_safe_push (varpool_node_ptr, gc, set->nodes, node);\n-}\n-\n-/* Remove varpool_node NODE from varpool_node_set SET.  */\n-\n-void\n-varpool_node_set_remove (varpool_node_set set, struct varpool_node *node)\n-{\n-  void **slot, **last_slot;\n-  varpool_node_set_element element, last_element;\n-  struct varpool_node *last_node;\n-  struct varpool_node_set_element_def dummy;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-  if (slot == NULL)\n-    return;\n-\n-  element = (varpool_node_set_element) *slot;\n-  gcc_assert (VEC_index (varpool_node_ptr, set->nodes, element->index)\n-\t      == node);\n-\n-  /* Remove from vector. We do this by swapping node with the last element\n-     of the vector.  */\n-  last_node = VEC_pop (varpool_node_ptr, set->nodes);\n-  if (last_node != node)\n-    {\n-      dummy.node = last_node;\n-      last_slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-      last_element = (varpool_node_set_element) *last_slot;\n-      gcc_assert (last_element);\n-\n-      /* Move the last element to the original spot of NODE.  */\n-      last_element->index = element->index;\n-      VEC_replace (varpool_node_ptr, set->nodes, last_element->index,\n-\t\t   last_node);\n-    }\n-\n-  /* Remove element from hash table.  */\n-  htab_clear_slot (set->hashtab, slot);\n-  ggc_free (element);\n-}\n-\n-/* Find NODE in SET and return an iterator to it if found.  A null iterator\n-   is returned if NODE is not in SET.  */\n-\n-varpool_node_set_iterator\n-varpool_node_set_find (varpool_node_set set, struct varpool_node *node)\n-{\n-  void **slot;\n-  struct varpool_node_set_element_def dummy;\n-  varpool_node_set_element element;\n-  varpool_node_set_iterator vsi;\n-\n-  dummy.node = node;\n-  slot = htab_find_slot (set->hashtab, &dummy, NO_INSERT);\n-  if (slot == NULL)\n-    vsi.index = (unsigned) ~0;\n-  else\n-    {\n-      element = (varpool_node_set_element) *slot;\n-      gcc_assert (VEC_index (varpool_node_ptr, set->nodes, element->index)\n-\t\t  == node);\n-      vsi.index = element->index;\n-    }\n-  vsi.set = set;\n-\n-  return vsi;\n-}\n-\n-/* Dump content of SET to file F.  */\n-\n-void\n-dump_varpool_node_set (FILE *f, varpool_node_set set)\n-{\n-  varpool_node_set_iterator iter;\n-\n-  for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n-    {\n-      struct varpool_node *node = vsi_node (iter);\n-      fprintf (f, \" %s\", varpool_node_name (node));\n-    }\n-  fprintf (f, \"\\n\");\n-}\n-\n-/* Dump content of SET to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_varpool_node_set (varpool_node_set set)\n-{\n-  dump_varpool_node_set (stderr, set);\n-}\n-\n \n /* Simple ipa profile pass propagating frequencies across the callgraph.  */\n "}, {"sha": "dea5f64808001a07df6f8fcb56020141c8018565", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -1,3 +1,11 @@\n+2011-05-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (ltrans_partition_def): Remove GTY annotations.\n+\t(ltrans_partitions): Move to heap.\n+\t(new_partition): Update.\n+\t(free_ltrans_partitions): New function.\n+\t(lto_wpa_write_files): Use it.\n+\n 2011-04-29  Martin Jambor  <mjambor@suse.cz>\n \n \t* lto.c: Include ipa-utils.h."}, {"sha": "9407a172395ac20a8ec640db3f6fdd15dfe627e5", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -1127,19 +1127,19 @@ free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n \n /* Structure describing ltrans partitions.  */\n \n-struct GTY (()) ltrans_partition_def\n+struct ltrans_partition_def\n {\n   cgraph_node_set cgraph_set;\n   varpool_node_set varpool_set;\n-  const char * GTY ((skip)) name;\n+  const char * name;\n   int insns;\n };\n \n typedef struct ltrans_partition_def *ltrans_partition;\n DEF_VEC_P(ltrans_partition);\n-DEF_VEC_ALLOC_P(ltrans_partition,gc);\n+DEF_VEC_ALLOC_P(ltrans_partition,heap);\n \n-static GTY (()) VEC(ltrans_partition, gc) *ltrans_partitions;\n+static VEC(ltrans_partition, heap) *ltrans_partitions;\n \n static void add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node);\n static void add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode);\n@@ -1148,15 +1148,29 @@ static void add_varpool_node_to_partition (ltrans_partition part, struct varpool\n static ltrans_partition\n new_partition (const char *name)\n {\n-  ltrans_partition part = ggc_alloc_ltrans_partition_def ();\n+  ltrans_partition part = XCNEW (struct ltrans_partition_def);\n   part->cgraph_set = cgraph_node_set_new ();\n   part->varpool_set = varpool_node_set_new ();\n   part->name = name;\n   part->insns = 0;\n-  VEC_safe_push (ltrans_partition, gc, ltrans_partitions, part);\n+  VEC_safe_push (ltrans_partition, heap, ltrans_partitions, part);\n   return part;\n }\n \n+/* Free memory used by ltrans datastructures.  */\n+static void\n+free_ltrans_partitions ()\n+{\n+  unsigned int idx;\n+  ltrans_partition part;\n+  for (idx = 0; VEC_iterate (ltrans_partition, ltrans_partitions, idx, part); idx++)\n+    {\n+      free_cgraph_node_set (part->cgraph-set);\n+      free (part);\n+    }\n+  VEC_free (latrans_partition, heap, ltrans_partitions);\n+}\n+\n /* See all references that go to comdat objects and bring them into partition too.  */\n static void\n add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n@@ -1977,6 +1991,8 @@ lto_wpa_write_files (void)\n   if (fclose (ltrans_output_list_stream))\n     fatal_error (\"closing LTRANS output list %s: %m\", ltrans_output_list);\n \n+  free_ltrans_partitions();\n+\n   timevar_pop (TV_WHOPR_WPA_IO);\n }\n "}, {"sha": "38b38cd7cbaa3b2e4fdd9a64784a577e90f8f6db", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -1729,8 +1729,8 @@ ipa_write_summaries (void)\n   ipa_write_summaries_1 (set, vset);\n \n   free (order);\n-  ggc_free (set);\n-  ggc_free (vset);\n+  free_cgraph_node_set (set);\n+  free_varpool_node_set (vset);\n }\n \n /* Same as execute_pass_list but assume that subpasses of IPA passes"}, {"sha": "11240477b97f65d193813580b35ba59faffc50e3", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb1a99f77b15cd8342ffbb0cd89cc0110350c48/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=1cb1a99f77b15cd8342ffbb0cd89cc0110350c48", "patch": "@@ -781,7 +781,7 @@ ipa_lower_emutls (void)\n \n   VEC_free (varpool_node_ptr, heap, control_vars);\n   VEC_free (tree, heap, access_vars);\n-  tls_vars = NULL;\n+  free_varpool_node_set (tls_vars);\n \n   return TODO_dump_func | TODO_ggc_collect | TODO_verify_all;\n }"}]}