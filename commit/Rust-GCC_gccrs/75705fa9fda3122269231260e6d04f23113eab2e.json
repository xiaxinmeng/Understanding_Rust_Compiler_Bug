{"sha": "75705fa9fda3122269231260e6d04f23113eab2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU3MDVmYTlmZGEzMTIyMjY5MjMxMjYwZTZkMDRmMjMxMTNlYWIyZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-05-21T22:21:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-05-21T22:21:40Z"}, "message": "re PR target/85657 (Make __ibm128 a separate type, even if long double uses the IBM double-double format)\n\n[gcc]\n2018-05-21  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR target/85657\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Do not\n\tdefine __ibm128 as long double.\n\t* config/rs6000/rs6000.c (rs6000_init_builtins): Always create\n\t__ibm128 as a distinct type.\n\t(init_float128_ieee): Fix up conversions between IFmode and IEEE\n\t128-bit types to use the correct functions.\n\t(rs6000_expand_float128_convert): Use explicit FLOAT_EXTEND to\n\tconvert between 128-bit floating point types that have different\n\tmodes but the same representation, instead of using gen_lowpart to\n\tmakean alias.\n\t* config/rs6000/rs6000.md (IFKF): New iterator for IFmode and\n\tKFmode.\n\t(IFKF_reg): New attributes to give the register constraints for\n\tIFmode and KFmode.\n\t(extend<mode>tf2_internal): New insns to mark an explicit\n\tconversion between 128-bit floating point types that have a\n\tdifferent mode but share the same representation.\n\n[gcc/testsuite]\n2018-05-21  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR target/85657\n\t* gcc.target/powerpc/pr85657-1.c: New test for converting between\n\t__float128, __ibm128, and long double.\n\t* gcc.target/powerpc/pr85657-2.c: Likewise.\n\t* gcc.target/powerpc/pr85657-3.c: Likewise.\n\t* g++.dg/pr85667.C: New test to make sure __ibm128 is\n\timplementated as a separate type internally, and is not just an\n\talias for long double.\n\nFrom-SVN: r260489", "tree": {"sha": "e847eef6a8e4e654c76a0e5bb9a3c8ec90c49aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e847eef6a8e4e654c76a0e5bb9a3c8ec90c49aad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75705fa9fda3122269231260e6d04f23113eab2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75705fa9fda3122269231260e6d04f23113eab2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75705fa9fda3122269231260e6d04f23113eab2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75705fa9fda3122269231260e6d04f23113eab2e/comments", "author": null, "committer": null, "parents": [{"sha": "9c8c7338585ca99db181ce0d1a63654f97beeed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8c7338585ca99db181ce0d1a63654f97beeed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8c7338585ca99db181ce0d1a63654f97beeed0"}], "stats": {"total": 381, "additions": 355, "deletions": 26}, "files": [{"sha": "6aad0d55d6f5ab55c1409f53e988eb693c854eaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -1,3 +1,24 @@\n+2018-05-21  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\tPR target/85657\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Do not\n+\tdefine __ibm128 as long double.\n+\t* config/rs6000/rs6000.c (rs6000_init_builtins): Always create\n+\t__ibm128 as a distinct type.\n+\t(init_float128_ieee): Fix up conversions between IFmode and IEEE\n+\t128-bit types to use the correct functions.\n+\t(rs6000_expand_float128_convert): Use explicit FLOAT_EXTEND to\n+\tconvert between 128-bit floating point types that have different\n+\tmodes but the same representation, instead of using gen_lowpart to\n+\tmakean alias.\n+\t* config/rs6000/rs6000.md (IFKF): New iterator for IFmode and\n+\tKFmode.\n+\t(IFKF_reg): New attributes to give the register constraints for\n+\tIFmode and KFmode.\n+\t(extend<mode>tf2_internal): New insns to mark an explicit\n+\tconversion between 128-bit floating point types that have a\n+\tdifferent mode but share the same representation.\n+\n 2018-05-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/85814"}, {"sha": "6cf5537d7ca59f37d520074e2eea0c48d9320c1e", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -608,8 +608,6 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__RSQRTEF__\");\n   if (TARGET_FLOAT128_TYPE)\n     builtin_define (\"__FLOAT128_TYPE__\");\n-  if (TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (TFmode))\n-    builtin_define (\"__ibm128=long double\");\n #ifdef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB\n   builtin_define (\"__BUILTIN_CPU_SUPPORTS__\");\n #endif"}, {"sha": "26d58fc4c289eebe9122096fa61adcea31026ce1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -16347,35 +16347,28 @@ rs6000_init_builtins (void)\n      floating point, we need make sure the type is non-zero or else self-test\n      fails during bootstrap.\n \n-     We don't register a built-in type for __ibm128 if the type is the same as\n-     long double.  Instead we add a #define for __ibm128 in\n-     rs6000_cpu_cpp_builtins to long double.\n+     Always create __ibm128 as a separate type, even if the current long double\n+     format is IBM extended double.\n \n      For IEEE 128-bit floating point, always create the type __ieee128.  If the\n      user used -mfloat128, rs6000-c.c will create a define from __float128 to\n      __ieee128.  */\n-  if (TARGET_LONG_DOUBLE_128 && FLOAT128_IEEE_P (TFmode))\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       ibm128_float_type_node = make_node (REAL_TYPE);\n       TYPE_PRECISION (ibm128_float_type_node) = 128;\n       SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n       layout_type (ibm128_float_type_node);\n-\n       lang_hooks.types.register_builtin_type (ibm128_float_type_node,\n \t\t\t\t\t      \"__ibm128\");\n-    }\n-  else\n-    ibm128_float_type_node = long_double_type_node;\n \n-  if (TARGET_FLOAT128_TYPE)\n-    {\n       ieee128_float_type_node = float128_type_node;\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__ieee128\");\n     }\n \n   else\n-    ieee128_float_type_node = long_double_type_node;\n+    ieee128_float_type_node = ibm128_float_type_node = long_double_type_node;\n \n   /* Initialize the modes for builtin_function_type, mapping a machine mode to\n      tree type node.  */\n@@ -17865,13 +17858,13 @@ init_float128_ieee (machine_mode mode)\n       set_conv_libfunc (trunc_optab, SFmode, mode, \"__trunckfsf2\");\n       set_conv_libfunc (trunc_optab, DFmode, mode, \"__trunckfdf2\");\n \n-      set_conv_libfunc (sext_optab, mode, IFmode, \"__extendtfkf2\");\n+      set_conv_libfunc (sext_optab, mode, IFmode, \"__trunctfkf2\");\n       if (mode != TFmode && FLOAT128_IBM_P (TFmode))\n-\tset_conv_libfunc (sext_optab, mode, TFmode, \"__extendtfkf2\");\n+\tset_conv_libfunc (sext_optab, mode, TFmode, \"__trunctfkf2\");\n \n-      set_conv_libfunc (trunc_optab, IFmode, mode, \"__trunckftf2\");\n+      set_conv_libfunc (trunc_optab, IFmode, mode, \"__extendkftf2\");\n       if (mode != TFmode && FLOAT128_IBM_P (TFmode))\n-\tset_conv_libfunc (trunc_optab, TFmode, mode, \"__trunckftf2\");\n+\tset_conv_libfunc (trunc_optab, TFmode, mode, \"__extendkftf2\");\n \n       set_conv_libfunc (sext_optab, mode, SDmode, \"__dpd_extendsdkf2\");\n       set_conv_libfunc (sext_optab, mode, DDmode, \"__dpd_extendddkf2\");\n@@ -21700,9 +21693,9 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   else\n     gcc_unreachable ();\n \n-  /* Handle conversion between TFmode/KFmode.  */\n+  /* Handle conversion between TFmode/KFmode/IFmode.  */\n   if (do_move)\n-    emit_move_insn (dest, gen_lowpart (dest_mode, src));\n+    emit_insn (gen_rtx_SET (dest, gen_rtx_FLOAT_EXTEND (dest_mode, src)));\n \n   /* Handle conversion if we have hardware support.  */\n   else if (TARGET_FLOAT128_HW && hw_convert)\n@@ -32128,14 +32121,11 @@ rs6000_mangle_type (const_tree type)\n       if (type == ieee128_float_type_node)\n \treturn \"U10__float128\";\n \n-      if (TARGET_LONG_DOUBLE_128)\n-\t{\n-\t  if (type == long_double_type_node)\n-\t    return (TARGET_IEEEQUAD) ? \"U10__float128\" : \"g\";\n+      if (type == ibm128_float_type_node)\n+\treturn \"u8__ibm128\";\n \n-\t  if (type == ibm128_float_type_node)\n-\t    return \"g\";\n-\t}\n+      if (TARGET_LONG_DOUBLE_128 && type == long_double_type_node)\n+\treturn (TARGET_IEEEQUAD) ? \"U10__float128\" : \"g\";\n     }\n \n   /* Mangle IBM extended float long double as `g' (__float128) on"}, {"sha": "68c0f3af4108c8848086aa48dd03c6cea240a3a8", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -422,6 +422,12 @@\n ; Iterator for 128-bit VSX types for pack/unpack\n (define_mode_iterator FMOVE128_VSX [V1TI KF])\n \n+; Iterators for converting to/from TFmode\n+(define_mode_iterator IFKF [IF KF])\n+\n+; Constraints for moving IF/KFmode.\n+(define_mode_attr IFKF_reg [(IF \"d\") (KF \"wa\")])\n+\n ; Whether a floating point move is ok, don't allow SD without hardware FP\n (define_mode_attr fmove_ok [(SF \"\")\n \t\t\t    (DF \"\")\n@@ -8188,6 +8194,32 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*extend<mode>tf2_internal\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=<IFKF_reg>\")\n+\t(float_extend:TF\n+\t (match_operand:IFKF 1 \"gpc_reg_operand\" \"<IFKF_reg>\")))]\n+   \"TARGET_FLOAT128_TYPE\n+    && FLOAT128_IBM_P (TFmode) == FLOAT128_IBM_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+{\n+  operands[2] = gen_rtx_REG (TFmode, REGNO (operands[1]));\n+})\n+\n+(define_insn_and_split \"*extendtf<mode>2_internal\"\n+  [(set (match_operand:IFKF 0 \"gpc_reg_operand\" \"=<IFKF_reg>\")\n+\t(float_extend:IFKF\n+\t (match_operand:TF 1 \"gpc_reg_operand\" \"<IFKF_reg>\")))]\n+   \"TARGET_FLOAT128_TYPE\n+    && FLOAT128_IBM_P (TFmode) == FLOAT128_IBM_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))]\n+{\n+  operands[2] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\n+})\n+\n \f\n ;; Reload helper functions used by rs6000_secondary_reload.  The patterns all\n ;; must have 3 arguments, and scratch register constraint must be a single"}, {"sha": "a115f968dc455b31f4050703d9143e4843daca3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -1,3 +1,14 @@\n+2018-05-21  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\tPR target/85657\n+\t* gcc.target/powerpc/pr85657-1.c: New test for converting between\n+\t__float128, __ibm128, and long double.\n+\t* gcc.target/powerpc/pr85657-2.c: Likewise.\n+\t* gcc.target/powerpc/pr85657-3.c: Likewise.\n+\t* g++.dg/pr85667.C: New test to make sure __ibm128 is\n+\timplementated as a separate type internally, and is not just an\n+\talias for long double.\n+\n 2018-05-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/85814"}, {"sha": "6b81bc2284fdf65c5ad85550decbcadae8c5b07c", "filename": "gcc/testsuite/g++.dg/pr85657.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile { target { powerpc*-*-linux* } } }\n+// { dg-require-effective-target ppc_float128_sw }\n+// { dg-options \"-mvsx -mfloat128 -O2 -mabi=ibmlongdouble -Wno-psabi\" }\n+\n+// PR 85657\n+// Check that __ibm128 and long double are represented as different types, even\n+// if long double is currently using the same representation as __ibm128.\n+\n+template <class __T> inline bool\n+iszero (__T __val)\n+{\n+  return __val == 0;\n+}\n+\n+int\n+use_template (void)\n+{\n+  long double ld = 0.0;\n+  __ibm128 ibm = 0.0;\n+\n+#ifdef _ARCH_PWR7\n+  __asm__ (\" # %x0, %x1\" : \"+d\" (ld), \"+d\" (ibm));\n+#endif\n+\n+  return iszero (ld) + iszero (ibm);\n+}\n+\n+class foo {\n+public:\n+  foo () {}\n+  ~foo () {}\n+  inline bool iszero (long double ld) { return ld == 0.0; }\n+  inline bool iszero (__ibm128 i128) { return i128 == 0.0; }\n+} st;\n+\n+int\n+use_class (void)\n+{\n+  long double ld = 0.0;\n+  __ibm128 ibm = 0.0;\n+\n+#ifdef _ARCH_PWR7\n+  __asm__ (\" # %x0, %x1\" : \"+d\" (ld), \"+d\" (ibm));\n+#endif\n+\n+  return st.iszero (ld) + st.iszero (ibm);\n+}"}, {"sha": "3337d06332d63f3afe46efefaab63151fa578bec", "filename": "gcc/testsuite/gcc.target/powerpc/pr85657-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-1.c?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mvsx -mfloat128 -O2 -mabi=ibmlongdouble -Wno-psabi\" } */\n+\n+// PR 85657 -- make sure conversions work between each of the 128-bit floating\n+// point types.\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ibm128_to_float128 (__ibm128 a)\n+{\n+  return (__float128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ldouble_to_float128 (long double a)\n+{\n+  return (__float128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+float128_to_ibm128 (__float128 a)\n+{\n+  return (__ibm128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+ldouble_to_ibm128 (long double a)\n+{\n+  return (__ibm128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+ibm128_to_ldouble (__ibm128 a)\n+{\n+  return (long double)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+float128_to_ldouble (__float128 a)\n+{\n+  return (long double)a;\n+}\n+\n+#ifdef TEST\n+#include <stdio.h>\n+\n+volatile __float128 f128 = 1.2Q;\n+volatile __ibm128 i128 = (__ibm128)3.4L;\n+volatile long double ld = 5.6L;\n+\n+int\n+main (void)\n+{\n+  printf (\"f128 (1.2) = %g (ld), %g (ibm128)\\n\",\n+\t  (double) float128_to_ldouble (f128),\n+\t  (double) float128_to_ibm128 (f128));\n+\n+  printf (\"i128 (3.4) = %g (ld), %g (float128)\\n\",\n+\t  (double) ibm128_to_ldouble (i128),\n+\t  (double) ibm128_to_float128 (i128));\n+\n+  printf (\"long double (5.6) = %g (ibm128), %g (float128)\\n\",\n+\t  (double) ldouble_to_ibm128 (ld),\n+\t  (double) ldouble_to_float128 (ld));\n+\n+  return 0;\n+}\n+#endif"}, {"sha": "33113da8f8582806a22caf5ecdca0705eb173b00", "filename": "gcc/testsuite/gcc.target/powerpc/pr85657-2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-2.c?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-options \"-mvsx -mfloat128 -O2 -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+// PR 85657 -- make sure conversions work between each of the 128-bit floating\n+// point types.\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ibm128_to_float128 (__ibm128 a)\n+{\n+  return (__float128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ldouble_to_float128 (long double a)\n+{\n+  return (__float128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+float128_to_ibm128 (__float128 a)\n+{\n+  return (__ibm128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+ldouble_to_ibm128 (long double a)\n+{\n+  return (__ibm128)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+ibm128_to_ldouble (__ibm128 a)\n+{\n+  return (long double)a;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+float128_to_ldouble (__float128 a)\n+{\n+  return (long double)a;\n+}\n+\n+#ifdef TEST\n+#include <stdio.h>\n+\n+volatile __float128 f128 = 1.2Q;\n+volatile __ibm128 i128 = (__ibm128)3.4L;\n+volatile long double ld = 5.6L;\n+\n+int\n+main (void)\n+{\n+  printf (\"f128 (1.2) = %g (ld), %g (ibm128)\\n\",\n+\t  (double) float128_to_ldouble (f128),\n+\t  (double) float128_to_ibm128 (f128));\n+\n+  printf (\"i128 (3.4) = %g (ld), %g (float128)\\n\",\n+\t  (double) ibm128_to_ldouble (i128),\n+\t  (double) ibm128_to_float128 (i128));\n+\n+  printf (\"long double (5.6) = %g (ibm128), %g (float128)\\n\",\n+\t  (double) ldouble_to_ibm128 (ld),\n+\t  (double) ldouble_to_float128 (ld));\n+\n+  return 0;\n+}\n+#endif"}, {"sha": "1d2e69d6341ba8b53f2a89dce7eaa05e8403492f", "filename": "gcc/testsuite/gcc.target/powerpc/pr85657-3.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75705fa9fda3122269231260e6d04f23113eab2e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr85657-3.c?ref=75705fa9fda3122269231260e6d04f23113eab2e", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+/* PR 85657 -- make __ibm128 a full type.  */\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ibm128_to_float128 (__ibm128 a)\n+{\n+  return (__float128)a + 1.0q;\n+}\n+\n+__attribute__ ((__noinline__))\n+__float128\n+ldouble_to_float128 (long double a)\n+{\n+  return (__float128)a + 1.0q;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+float128_to_ibm128 (__float128 a)\n+{\n+  return (__ibm128)a + (__ibm128)1.0;\n+}\n+\n+__attribute__ ((__noinline__))\n+__ibm128\n+ldouble_to_ibm128 (long double a)\n+{\n+  return (__ibm128)a + (__ibm128)1.0;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+ibm128_to_ldouble (__ibm128 a)\n+{\n+  return (long double)a + 1.0L;\n+}\n+\n+__attribute__ ((__noinline__))\n+long double\n+float128_to_ldouble (__float128 a)\n+{\n+  return (long double)a + 1.0L;\n+}\n+\n+volatile __float128  f128 = 1.25Q;\n+volatile __ibm128    i128 = (__ibm128)3.5L;\n+volatile long double ld   = 4.75L;\n+\n+volatile double f128_p1 = 2.25;\n+volatile double i128_p1 = 4.5;\n+volatile double ld_p1   = 5.75;\n+\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  if (((double) float128_to_ldouble (f128)) != f128_p1)\n+    abort ();\n+\n+  if (((double) float128_to_ibm128 (f128)) != f128_p1)\n+    abort ();\n+\n+  if (((double) ibm128_to_ldouble (i128)) != i128_p1)\n+    abort ();\n+\n+  if (((double) ibm128_to_float128 (i128)) != i128_p1)\n+    abort ();\n+\n+  if (((double) ldouble_to_ibm128 (ld)) != ld_p1)\n+    abort ();\n+\n+  if (((double) ldouble_to_float128 (ld)) != ld_p1)\n+    abort ();\n+\n+  return 0;\n+}"}]}