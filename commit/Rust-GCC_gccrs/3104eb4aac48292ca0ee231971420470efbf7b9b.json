{"sha": "3104eb4aac48292ca0ee231971420470efbf7b9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwNGViNGFhYzQ4MjkyY2EwZWUyMzE5NzE0MjA0NzBlZmJmN2I5Yg==", "commit": {"author": {"name": "Joel Brobecker", "email": "brobecker@adacore.com", "date": "2005-07-04T13:26:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T13:26:28Z"}, "message": "a-tags.adb (Type_Specific_Data): Define Tags_Table as a small array.\n\n2005-07-04  Joel Brobecker  <brobecker@adacore.com>\n\n\t* a-tags.adb (Type_Specific_Data): Define Tags_Table as a small array.\n\tThis prevents us from hitting a limitation during the debug info\n\tgeneration when using stabs.\n\t(Prims_Ptr): Likewise.\n\nFrom-SVN: r101574", "tree": {"sha": "57a7a476eecfc37f98fe243baec319c33fd8c794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a7a476eecfc37f98fe243baec319c33fd8c794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3104eb4aac48292ca0ee231971420470efbf7b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3104eb4aac48292ca0ee231971420470efbf7b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3104eb4aac48292ca0ee231971420470efbf7b9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3104eb4aac48292ca0ee231971420470efbf7b9b/comments", "author": {"login": "brobecke", "id": 11981700, "node_id": "MDQ6VXNlcjExOTgxNzAw", "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brobecke", "html_url": "https://github.com/brobecke", "followers_url": "https://api.github.com/users/brobecke/followers", "following_url": "https://api.github.com/users/brobecke/following{/other_user}", "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}", "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions", "organizations_url": "https://api.github.com/users/brobecke/orgs", "repos_url": "https://api.github.com/users/brobecke/repos", "events_url": "https://api.github.com/users/brobecke/events{/privacy}", "received_events_url": "https://api.github.com/users/brobecke/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b87520cd051656e14f59112793d66c259ffd4f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87520cd051656e14f59112793d66c259ffd4f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87520cd051656e14f59112793d66c259ffd4f52"}], "stats": {"total": 95, "additions": 59, "deletions": 36}, "files": [{"sha": "56eaff9b9c9d93c474ace30dfe8efb6a24ac4bbe", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3104eb4aac48292ca0ee231971420470efbf7b9b/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3104eb4aac48292ca0ee231971420470efbf7b9b/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=3104eb4aac48292ca0ee231971420470efbf7b9b", "patch": "@@ -80,61 +80,84 @@ package body Ada.Tags is\n \n    type Type_Specific_Data is record\n       Idepth            : Natural;\n+      --  Inheritance Depth Level: Used to implement the membership test\n+      --  associated with single inheritance of tagged types in constant-time.\n+      --  In addition it also indicates the size of the first table stored in\n+      --  the Tags_Table component (see comment below).\n+\n       Access_Level      : Natural;\n+      --  Accessibility level required to give support to Ada 2005 nested type\n+      --  extensions. This feature allows safe nested type extensions by\n+      --  shifting the accessibility checks to certain operations, rather than\n+      --  being enforced at the type declaration. In particular, by performing\n+      --  run-time accessibility checks on class-wide allocators, class-wide\n+      --  function return, and class-wide stream I/O, the danger of objects\n+      --  outliving their type declaration can be eliminated (Ada 2005: AI-344)\n+\n       Expanded_Name     : Cstring_Ptr;\n       External_Tag      : Cstring_Ptr;\n       HT_Link           : Tag;\n+      --  Components used to give support to the Ada.Tags subprograms described\n+      --  in ARM 3.9\n+\n       Remotely_Callable : Boolean;\n+      --  Used to check ARM E.4 (18)\n+\n       RC_Offset         : SSE.Storage_Offset;\n+      --  Controller Offset: Used to give support to tagged controlled objects\n+      --  (see Get_Deep_Controller at s-finimp)\n+\n       Num_Interfaces    : Natural;\n-      Tags_Table        : Tag_Table (Natural);\n+      --  Number of abstract interface types implemented by the tagged type.\n+      --  The value Idepth+Num_Interfaces indicates the end of the second table\n+      --  stored in the Tags_Table component. It is used to implement the\n+      --  membership test associated with interfaces (Ada 2005:AI-251)\n \n+      Tags_Table : Tag_Table (0 .. 1);\n       --  The size of the Tags_Table array actually depends on the tagged type\n       --  to which it applies. The compiler ensures that has enough space to\n       --  store all the entries of the two tables phisically stored there: the\n       --  \"table of ancestor tags\" and the \"table of interface tags\". For this\n       --  purpose we are using the same mechanism as for the Prims_Ptr array in\n-      --  the Dispatch_Table record. See comments below for more details.\n-\n+      --  the Dispatch_Table record. See comments below on Prims_Ptr for\n+      --  further details.\n    end record;\n \n    type Dispatch_Table is record\n       --  Offset_To_Top : Natural;\n-      --  Typeinfo_Ptr  : System.Address; -- Currently TSD is also here???\n-      Prims_Ptr : Address_Array (Positive);\n+      --  Typeinfo_Ptr  : System.Address;\n+\n+      --  According to the C++ ABI the components Offset_To_Top and\n+      --  Typeinfo_Ptr are stored just \"before\" the dispatch table (that is,\n+      --  the Prims_Ptr table), and they are referenced with negative offsets\n+      --  referring to the base of the dispatch table. The _Tag (or the\n+      --  VTable_Ptr in C++ terminology) must point to the base of the virtual\n+      --  table, just after these components, to point to the Prims_Ptr table.\n+      --  For this purpose the expander generates a Prims_Ptr table that has\n+      --  enough space for these additional components, and generates code that\n+      --  displaces the _Tag to point after these components.\n+\n+      Prims_Ptr : Address_Array (1 .. 1);\n+      --  The size of the Prims_Ptr array actually depends on the tagged type\n+      --  to which it applies. For each tagged type, the expander computes the\n+      --  actual array size, allocates the Dispatch_Table record accordingly,\n+      --  and generates code that displaces the base of the record after the\n+      --  Typeinfo_Ptr component. For this reason the first two components have\n+      --  been commented in the previous declaration. The access to these\n+      --  components is done by means of local functions.\n+      --\n+      --  To avoid the use of discriminants to define the actual size of the\n+      --  dispatch table, we used to declare the tag as a pointer to a record\n+      --  that contains an arbitrary array of addresses, using Positive as its\n+      --  index. This ensures that there are never range checks when accessing\n+      --  the dispatch table, but it prevents GDB from displaying tagged types\n+      --  properly. A better approach is to declare this record type as holding\n+      --  small number of addresses, and to explicitly suppress checks on it.\n+      --\n+      --  Note that in both cases, this type is never allocated, and serves\n+      --  only to declare the corresponding access type.\n    end record;\n \n-   --  Note on the commented out fields of the Dispatch_Table\n-   --\n-   --  According to the C++ ABI the components Offset_To_Top and Typeinfo_Ptr\n-   --  are stored just \"before\" the dispatch table (that is, the Prims_Ptr\n-   --  table), and they are referenced with negative offsets referring to the\n-   --  base of the dispatch table. The _Tag (or the VTable_Ptr in C++ termi-\n-   --  nology) must point to the base of the virtual table, just after these\n-   --  components, to point to the Prims_Ptr table. For this purpose the\n-   --  expander generates a Prims_Ptr table that has enough space for these\n-   --  additional components, and generates code that displaces the _Tag to\n-   --  point after these components.\n-\n-   --  The size of the Prims_Ptr array actually depends on the tagged type to\n-   --  which it applies. For each tagged type, the expander computes the\n-   --  actual array size, allocates the Dispatch_Table record accordingly, and\n-   --  generates code that displaces the base of the record after the\n-   --  Typeinfo_Ptr component. For this reason the first two components have\n-   --  been commented in the previous declaration. The access to these\n-   --  components is done by means of local functions.\n-   --\n-   --  To avoid the use of discriminants to define the actual size of the\n-   --  dispatch table, we used to declare the tag as a pointer to a record\n-   --  that contains an arbitrary array of addresses, using Positive as its\n-   --  index. This ensures that there are never range checks when accessing\n-   --  the dispatch table, but it prevents GDB from displaying tagged types\n-   --  properly. A better approach is to declare this record type as holding a\n-   --  small number of addresses, and to explicitly suppress checks on it.\n-   --\n-   --  Note that in both cases, this type is never allocated, and serves only\n-   --  to declare the corresponding access type.\n-\n    ---------------------------------------------\n    -- Unchecked Conversions for String Fields --\n    ---------------------------------------------"}]}