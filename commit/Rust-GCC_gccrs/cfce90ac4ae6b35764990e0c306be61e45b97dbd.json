{"sha": "cfce90ac4ae6b35764990e0c306be61e45b97dbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZjZTkwYWM0YWU2YjM1NzY0OTkwZTBjMzA2YmU2MWU0NWI5N2RiZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-03-15T03:24:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-03-15T03:24:11Z"}, "message": "re PR target/60525 (ICE: in final_scan_insn, at final.c:2952)\n\nPR target/60525\n\n\t* config/i386/i386.md (floathi<X87MODEF>2): Delete expander; rename\n\tdefine_insn from *floathi<X87MODEF>2_i387; allow nonimmediate_operand.\n\t(*floathi<X87MODEF>2_i387_with_temp): Remove.\n\t(floathi splitters): Remove.\n\t(float<SWI48x>xf2): New pattern.\n\t(float<SWI48><MODEF>2): Rename from float<SWI48x><X87MODEF>2.  Drop\n\tcode that tried to handle DImode for 32-bit, but which was excluded\n\tby the pattern's condition.  Drop allocation of stack temporary.\n\t(*floatsi<MODEF>2_vector_mixed_with_temp): Remove.\n\t(*float<SWI48><MODEF>2_mixed_with_temp): Remove.\n\t(*float<SWI48><MODEF>2_mixed_interunit): Remove.\n\t(*float<SWI48><MODEF>2_mixed_nointerunit): Remove.\n\t(*floatsi<MODEF>2_vector_sse_with_temp): Remove.\n\t(*float<SWI48><MODEF>2_sse_with_temp): Remove.\n\t(*float<SWI48><MODEF>2_sse_interunit): Remove.\n\t(*float<SWI48><MODEF>2_sse_nointerunit): Remove.\n\t(*float<SWI48x><X87MODEF>2_i387_with_temp): Remove.\n\t(*float<SWI48x><X87MODEF>2_i387): Remove.\n\t(all float _with_temp splitters): Remove.\n\t(*float<SWI48x><MODEF>2_i387): New pattern.\n\t(*float<SWI48><MODEF>2_sse): New pattern.\n\t(float TARGET_USE_VECTOR_CONVERTS splitters): Merge them.\n\t(float TARGET_SSE_PARTIAL_REG_DEPENDENCY splitters): Merge them.\n\nFrom-SVN: r208587", "tree": {"sha": "99fea90c6c773a026a3079e06baf16bd3784b71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99fea90c6c773a026a3079e06baf16bd3784b71d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfce90ac4ae6b35764990e0c306be61e45b97dbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfce90ac4ae6b35764990e0c306be61e45b97dbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfce90ac4ae6b35764990e0c306be61e45b97dbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfce90ac4ae6b35764990e0c306be61e45b97dbd/comments", "author": null, "committer": null, "parents": [{"sha": "47b5d284dd6aa3281f79d973e3194ab9d6990a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b5d284dd6aa3281f79d973e3194ab9d6990a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b5d284dd6aa3281f79d973e3194ab9d6990a45"}], "stats": {"total": 470, "additions": 84, "deletions": 386}, "files": [{"sha": "8fc1f4c5c475c4d602f17cb0ac75894f912b55a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce90ac4ae6b35764990e0c306be61e45b97dbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce90ac4ae6b35764990e0c306be61e45b97dbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfce90ac4ae6b35764990e0c306be61e45b97dbd", "patch": "@@ -1,3 +1,30 @@\n+2014-03-14  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/60525\n+\t* config/i386/i386.md (floathi<X87MODEF>2): Delete expander; rename\n+\tdefine_insn from *floathi<X87MODEF>2_i387; allow nonimmediate_operand.\n+\t(*floathi<X87MODEF>2_i387_with_temp): Remove.\n+\t(floathi splitters): Remove.\n+\t(float<SWI48x>xf2): New pattern.\n+\t(float<SWI48><MODEF>2): Rename from float<SWI48x><X87MODEF>2.  Drop\n+\tcode that tried to handle DImode for 32-bit, but which was excluded\n+\tby the pattern's condition.  Drop allocation of stack temporary.\n+\t(*floatsi<MODEF>2_vector_mixed_with_temp): Remove.\n+\t(*float<SWI48><MODEF>2_mixed_with_temp): Remove.\n+\t(*float<SWI48><MODEF>2_mixed_interunit): Remove.\n+\t(*float<SWI48><MODEF>2_mixed_nointerunit): Remove.\n+\t(*floatsi<MODEF>2_vector_sse_with_temp): Remove.\n+\t(*float<SWI48><MODEF>2_sse_with_temp): Remove.\n+\t(*float<SWI48><MODEF>2_sse_interunit): Remove.\n+\t(*float<SWI48><MODEF>2_sse_nointerunit): Remove.\n+\t(*float<SWI48x><X87MODEF>2_i387_with_temp): Remove.\n+\t(*float<SWI48x><X87MODEF>2_i387): Remove.\n+\t(all float _with_temp splitters): Remove.\n+\t(*float<SWI48x><MODEF>2_i387): New pattern.\n+\t(*float<SWI48><MODEF>2_sse): New pattern.\n+\t(float TARGET_USE_VECTOR_CONVERTS splitters): Merge them.\n+\t(float TARGET_SSE_PARTIAL_REG_DEPENDENCY splitters): Merge them.\n+\n 2014-03-14  Jakub Jelinek  <jakub@redhat.com>\n \t    Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "a824e78d3946849b595f18c4b9c8a683b3fb5672", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 57, "deletions": 386, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfce90ac4ae6b35764990e0c306be61e45b97dbd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfce90ac4ae6b35764990e0c306be61e45b97dbd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cfce90ac4ae6b35764990e0c306be61e45b97dbd", "patch": "@@ -4653,36 +4653,12 @@\n ;; Conversion between fixed point and floating point.\n \n ;; Even though we only accept memory inputs, the backend _really_\n-;; wants to be able to do this between registers.\n+;; wants to be able to do this between registers.  Thankfully, LRA\n+;; will fix this up for us during register allocation.\n \n-(define_expand \"floathi<mode>2\"\n-  [(parallel [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t\t   (float:X87MODEF\n-\t\t     (match_operand:HI 1 \"nonimmediate_operand\")))\n-              (clobber (match_dup 2))])]\n-  \"TARGET_80387\n-   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\"\n-{\n-  operands[2] = assign_386_stack_local (HImode, SLOT_TEMP);\n-})\n-\n-(define_insn \"*floathi<mode>2_i387_with_temp\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f,f\")\n-\t(float:X87MODEF (match_operand:HI 1 \"nonimmediate_operand\" \"m,?r\")))\n-  (clobber (match_operand:HI 2 \"memory_operand\" \"=X,m\"))]\n-  \"TARGET_80387\n-   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\"\n-  \"#\"\n-  [(set_attr \"type\" \"fmov,multi\")\n-   (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"unit\" \"*,i387\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*floathi<mode>2_i387\"\n+(define_insn \"floathi<mode>2\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f\")\n-\t(float:X87MODEF (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+\t(float:X87MODEF (match_operand:HI 1 \"nonimmediate_operand\" \"m\")))]\n   \"TARGET_80387\n    && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n        || TARGET_MIX_SSE_I387)\"\n@@ -4691,134 +4667,54 @@\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_split\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF (match_operand:HI 1 \"register_operand\")))\n-   (clobber (match_operand:HI 2 \"memory_operand\"))]\n-  \"TARGET_80387\n-   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-       || TARGET_MIX_SSE_I387)\n-   && reload_completed\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (float:X87MODEF (match_dup 2)))])\n-\n-(define_split\n-  [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t(float:X87MODEF (match_operand:HI 1 \"memory_operand\")))\n-   (clobber (match_operand:HI 2 \"memory_operand\"))]\n-   \"TARGET_80387\n-    && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-        || TARGET_MIX_SSE_I387)\n-    && reload_completed\"\n-  [(set (match_dup 0) (float:X87MODEF (match_dup 1)))])\n+(define_insn \"float<SWI48x:mode>xf2\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(float:XF (match_operand:SWI48x 1 \"nonimmediate_operand\" \"m\")))]\n+  \"TARGET_80387\"\n+  \"fild%Z1\\t%1\"\n+  [(set_attr \"type\" \"fmov\")\n+   (set_attr \"mode\" \"XF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n \n-(define_expand \"float<SWI48x:mode><X87MODEF:mode>2\"\n-  [(parallel [(set (match_operand:X87MODEF 0 \"register_operand\")\n-\t\t   (float:X87MODEF\n-\t\t     (match_operand:SWI48x 1 \"nonimmediate_operand\")))\n-              (clobber (match_dup 2))])]\n-  \"TARGET_80387\n-   || ((<SWI48x:MODE>mode != DImode || TARGET_64BIT)\n-       && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\"\n+(define_expand \"float<SWI48:mode><MODEF:mode>2\"\n+  [(set (match_operand:MODEF 0 \"register_operand\")\n+\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n+  \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\"\n {\n-  bool native_int = TARGET_64BIT || <SWI48x:MODE>mode != DImode;\n-\n-  if (!(native_int\n-\t&& SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\n-      && !X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode))\n+  if (!(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n+      && !X87_ENABLE_FLOAT (<MODEF:MODE>mode, <SWI48:MODE>mode))\n     {\n       rtx reg = gen_reg_rtx (XFmode);\n       rtx (*insn)(rtx, rtx);\n \n-      emit_insn (gen_float<SWI48x:mode>xf2 (reg, operands[1]));\n+      emit_insn (gen_float<SWI48:mode>xf2 (reg, operands[1]));\n \n-      if (<X87MODEF:MODE>mode == SFmode)\n+      if (<MODEF:MODE>mode == SFmode)\n \tinsn = gen_truncxfsf2;\n-      else if (<X87MODEF:MODE>mode == DFmode)\n+      else if (<MODEF:MODE>mode == DFmode)\n \tinsn = gen_truncxfdf2;\n       else\n \tgcc_unreachable ();\n \n       emit_insn (insn (operands[0], reg));\n       DONE;\n     }\n-\n-  /* Avoid store forwarding (partial memory) stall penalty\n-     by passing DImode value through XMM registers.  */\n-  if (!native_int\n-      && TARGET_80387 && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_TO_VEC\n-      && optimize_function_for_speed_p (cfun))\n-    {\n-      operands[2] = assign_386_stack_local (<SWI48x:MODE>mode, SLOT_TEMP);\n-      emit_insn (gen_floatdi<X87MODEF:mode>2_i387_with_xmm (operands[0],\n-\t\t\t\t\t\t\t    operands[1],\n-\t\t\t\t\t\t\t    operands[2]));\n-      DONE;\n-    }\n-\n-  /* Notice when we'd convert directly from general registers.  */\n-  if (native_int\n-      && (TARGET_MIX_SSE_I387 || TARGET_SSE_MATH)\n-      && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode)\n-      && (TARGET_INTER_UNIT_CONVERSIONS\n-          || optimize_function_for_size_p (cfun)))\n-    {\n-      emit_insn (gen_rtx_SET\n-                 (VOIDmode, operands[0],\n-                  gen_rtx_FLOAT (<X87MODEF:MODE>mode, operands[1])));\n-      DONE;\n-    }\n-\n-  operands[2] = assign_386_stack_local (<SWI48x:MODE>mode, SLOT_TEMP);\n })\n \n-(define_insn \"*floatsi<mode>2_vector_mixed_with_temp\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x,x,x\")\n-\t(float:MODEF\n-\t  (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r,r,m,!x\")))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"=X,m,m,X,m\"))]\n-  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"fmov,multi,sseicvt,sseicvt,sseicvt\")\n-   (set_attr \"mode\" \"<MODE>,<MODE>,<MODE>,<MODE>,<ssevecmode>\")\n-   (set_attr \"unit\" \"*,i387,*,*,*\")\n-   (set_attr \"athlon_decode\" \"*,*,double,direct,double\")\n-   (set_attr \"amdfam10_decode\" \"*,*,vector,double,double\")\n-   (set_attr \"bdver1_decode\" \"*,*,double,direct,double\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_with_temp\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x,x\")\n-\t(float:MODEF\n-\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"m,?r,r,m\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\" \"=X,m,m,X\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\"\n-  \"#\"\n-  [(set_attr \"type\" \"fmov,multi,sseicvt,sseicvt\")\n+(define_insn \"*float<SWI48x:mode><MODEF:mode>2_i387\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f\")\n+\t(float:MODEF (match_operand:SWI48x 1 \"nonimmediate_operand\" \"m\")))]\n+  \"TARGET_80387 && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\"\n+  \"fild%Z1\\t%1\"\n+  [(set_attr \"type\" \"fmov\")\n    (set_attr \"mode\" \"<MODEF:MODE>\")\n-   (set_attr \"unit\" \"*,i387,*,*\")\n-   (set_attr \"athlon_decode\" \"*,*,double,direct\")\n-   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n-   (set_attr \"bdver1_decode\" \"*,*,double,direct\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n-   && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (float:MODEF (match_dup 2)))])\n-\n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_interunit\"\n+(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x,x\")\n \t(float:MODEF\n \t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"m,r,m\")))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n-   && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n+  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\"\n   \"@\n    fild%Z1\\t%1\n    %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\n@@ -4836,93 +4732,27 @@\n    (set_attr \"athlon_decode\" \"*,double,direct\")\n    (set_attr \"amdfam10_decode\" \"*,vector,double\")\n    (set_attr \"bdver1_decode\" \"*,double,direct\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_mixed_nointerunit\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n-\t(float:MODEF\n-\t  (match_operand:SWI48 1 \"memory_operand\" \"m,m\")))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_MIX_SSE_I387\n-   && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n-  \"@\n-   fild%Z1\\t%1\n-   %vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n-  [(set_attr \"type\" \"fmov,sseicvt\")\n-   (set_attr \"prefix\" \"orig,maybe_vex\")\n-   (set_attr \"mode\" \"<MODEF:MODE>\")\n-   (set (attr \"prefix_rex\")\n-     (if_then_else\n-       (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n-       (const_string \"1\")\n-       (const_string \"*\")))\n-   (set_attr \"athlon_decode\" \"*,direct\")\n-   (set_attr \"amdfam10_decode\" \"*,double\")\n-   (set_attr \"bdver1_decode\" \"*,direct\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*floatsi<mode>2_vector_sse_with_temp\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,x\")\n-\t(float:MODEF\n-\t  (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,!x\")))\n-   (clobber (match_operand:SI 2 \"memory_operand\" \"=m,X,m\"))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\"\n-  \"#\"\n-  [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"mode\" \"<MODE>,<MODE>,<ssevecmode>\")\n-   (set_attr \"athlon_decode\" \"double,direct,double\")\n-   (set_attr \"amdfam10_decode\" \"vector,double,double\")\n-   (set_attr \"bdver1_decode\" \"double,direct,double\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SI 1 \"register_operand\")))\n-   (clobber (match_operand:SI 2 \"memory_operand\"))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(const_int 0)]\n-{\n-  rtx op1 = operands[1];\n-\n-  operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  if (GET_CODE (op1) == SUBREG)\n-    op1 = SUBREG_REG (op1);\n-\n-  if (GENERAL_REG_P (op1) && TARGET_INTER_UNIT_MOVES_TO_VEC)\n-    {\n-      operands[4] = simplify_gen_subreg (V4SImode, operands[0], <MODE>mode, 0);\n-      emit_insn (gen_sse2_loadld (operands[4],\n-\t\t\t\t  CONST0_RTX (V4SImode), operands[1]));\n-    }\n-  /* We can ignore possible trapping value in the\n-     high part of SSE register for non-trapping math. */\n-  else if (SSE_REG_P (op1) && !flag_trapping_math)\n-    operands[4] = simplify_gen_subreg (V4SImode, operands[1], SImode, 0);\n-  else\n-    {\n-      operands[4] = simplify_gen_subreg (V4SImode, operands[0], <MODE>mode, 0);\n-      emit_move_insn (operands[2], operands[1]);\n-      emit_insn (gen_sse2_loadld (operands[4],\n-\t\t\t\t  CONST0_RTX (V4SImode), operands[2]));\n-    }\n-  if (<ssevecmode>mode == V4SFmode)\n-    emit_insn (gen_floatv4siv4sf2 (operands[3], operands[4]));\n-  else\n-    emit_insn (gen_sse2_cvtdq2pd (operands[3], operands[4]));\n-  DONE;\n-})\n+   (set_attr \"fp_int_src\" \"true\")\n+   (set (attr \"enabled\")\n+     (cond [(eq_attr \"alternative\" \"0\")\n+              (symbol_ref \"TARGET_MIX_SSE_I387\")\n+            (eq_attr \"alternative\" \"1\")\n+              (symbol_ref \"TARGET_INTER_UNIT_CONVERSIONS\n+                           || optimize_function_for_size_p (cfun)\")\n+           ]\n+           (symbol_ref \"true\")))\n+   ])\n \n+;; Try TARGET_USE_VECTOR_CONVERTS, but not so hard as to require extra memory\n+;; slots when !TARGET_INTER_UNIT_MOVES_TO_VEC disables the general_regs\n+;; alternative in sse2_loadld.\n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SI 1 \"memory_operand\")))\n-   (clobber (match_operand:SI 2 \"memory_operand\"))]\n+\t(float:MODEF (match_operand:SI 1 \"nonimmediate_operand\")))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\n    && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\"\n+   && reload_completed && SSE_REG_P (operands[0])\n+   && (MEM_P (operands[1]) || TARGET_INTER_UNIT_MOVES_TO_VEC)\"\n   [(const_int 0)]\n {\n   operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n@@ -4931,194 +4761,35 @@\n \n   emit_insn (gen_sse2_loadld (operands[4],\n \t\t\t      CONST0_RTX (V4SImode), operands[1]));\n-  if (<ssevecmode>mode == V4SFmode)\n-    emit_insn (gen_floatv4siv4sf2 (operands[3], operands[4]));\n-  else\n-    emit_insn (gen_sse2_cvtdq2pd (operands[3], operands[4]));\n-  DONE;\n-})\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SI 1 \"memory_operand\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_USE_VECTOR_CONVERTS && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(const_int 0)]\n-{\n-  operands[3] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  operands[4] = simplify_gen_subreg (V4SImode, operands[0], <MODE>mode, 0);\n-\n-  emit_insn (gen_sse2_loadld (operands[4],\n-\t\t\t      CONST0_RTX (V4SImode), operands[1]));\n   if (<ssevecmode>mode == V4SFmode)\n     emit_insn (gen_floatv4siv4sf2 (operands[3], operands[4]));\n   else\n     emit_insn (gen_sse2_cvtdq2pd (operands[3], operands[4]));\n   DONE;\n })\n \n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_with_temp\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n-\t(float:MODEF\n-\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"r,m\")))\n-  (clobber (match_operand:SWI48 2 \"memory_operand\" \"=m,X\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\"\n-  \"#\"\n-  [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"mode\" \"<MODEF:MODE>\")\n-   (set_attr \"athlon_decode\" \"double,direct\")\n-   (set_attr \"amdfam10_decode\" \"vector,double\")\n-   (set_attr \"bdver1_decode\" \"double,direct\")\n-   (set_attr \"btver2_decode\" \"double,double\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_interunit\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n-\t(float:MODEF\n-\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"r,m\")))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n-  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n-  [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"<MODEF:MODE>\")\n-   (set (attr \"prefix_rex\")\n-     (if_then_else\n-       (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n-       (const_string \"1\")\n-       (const_string \"*\")))\n-   (set_attr \"athlon_decode\" \"double,direct\")\n-   (set_attr \"amdfam10_decode\" \"vector,double\")\n-   (set_attr \"bdver1_decode\" \"double,direct\")\n-   (set_attr \"btver2_decode\" \"double,double\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && (TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0) (float:MODEF (match_dup 1)))])\n-\n-(define_insn \"*float<SWI48:mode><MODEF:mode>2_sse_nointerunit\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(float:MODEF\n-\t  (match_operand:SWI48 1 \"memory_operand\" \"m\")))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\"\n-  \"%vcvtsi2<MODEF:ssemodesuffix><SWI48:rex64suffix>\\t{%1, %d0|%d0, %1}\"\n-  [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"<MODEF:MODE>\")\n-   (set (attr \"prefix_rex\")\n-     (if_then_else\n-       (and (eq_attr \"prefix\" \"maybe_vex\")\n-\t    (match_test \"<SWI48:MODE>mode == DImode\"))\n-       (const_string \"1\")\n-       (const_string \"*\")))\n-   (set_attr \"athlon_decode\" \"direct\")\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"bdver1_decode\" \"direct\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SWI48 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48 2 \"memory_operand\"))]\n-  \"SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH\n-   && !(TARGET_INTER_UNIT_CONVERSIONS || optimize_function_for_size_p (cfun))\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (float:MODEF (match_dup 2)))])\n-\n-(define_insn \"*float<SWI48x:mode><X87MODEF:mode>2_i387_with_temp\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f,f\")\n-\t(float:X87MODEF\n-\t  (match_operand:SWI48x 1 \"nonimmediate_operand\" \"m,?r\")))\n-  (clobber (match_operand:SWI48x 2 \"memory_operand\" \"=X,m\"))]\n-  \"TARGET_80387\n-   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode)\"\n-  \"@\n-   fild%Z1\\t%1\n-   #\"\n-  [(set_attr \"type\" \"fmov,multi\")\n-   (set_attr \"mode\" \"<X87MODEF:MODE>\")\n-   (set_attr \"unit\" \"*,i387\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_insn \"*float<SWI48x:mode><X87MODEF:mode>2_i387\"\n-  [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f\")\n-\t(float:X87MODEF\n-\t  (match_operand:SWI48x 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_80387\n-   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode)\"\n-  \"fild%Z1\\t%1\"\n-  [(set_attr \"type\" \"fmov\")\n-   (set_attr \"mode\" \"<X87MODEF:MODE>\")\n-   (set_attr \"fp_int_src\" \"true\")])\n-\n-(define_split\n-  [(set (match_operand:X87MODEF 0 \"fp_register_operand\")\n-\t(float:X87MODEF (match_operand:SWI48x 1 \"register_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"TARGET_80387\n-   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode)\n-   && reload_completed\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (float:X87MODEF (match_dup 2)))])\n-\n-(define_split\n-  [(set (match_operand:X87MODEF 0 \"fp_register_operand\")\n-\t(float:X87MODEF (match_operand:SWI48x 1 \"memory_operand\")))\n-   (clobber (match_operand:SWI48x 2 \"memory_operand\"))]\n-  \"TARGET_80387\n-   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SWI48x:MODE>mode)\n-   && reload_completed\"\n-  [(set (match_dup 0) (float:X87MODEF (match_dup 1)))])\n-\n ;; Avoid partial SSE register dependency stalls\n-\n (define_split\n   [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:SI 1 \"nonimmediate_operand\")))]\n+\t(float:MODEF (match_operand:SWI48 1 \"nonimmediate_operand\")))]\n   \"TARGET_SSE2 && TARGET_SSE_MATH\n    && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n    && optimize_function_for_speed_p (cfun)\n    && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(vec_merge:<ssevecmode>\n-\t  (vec_duplicate:<ssevecmode>\n-\t    (float:MODEF (match_dup 1)))\n-\t  (match_dup 0)\n-\t  (const_int 1)))]\n+  [(const_int 0)]\n {\n-  operands[0] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  emit_move_insn (operands[0], CONST0_RTX (<ssevecmode>mode));\n-})\n+  const enum machine_mode vmode = <MODEF:ssevecmode>mode;\n+  const enum machine_mode mode = <MODEF:MODE>mode;\n+  rtx t, op0 = simplify_gen_subreg (vmode, operands[0], mode, 0);\n \n-(define_split\n-  [(set (match_operand:MODEF 0 \"register_operand\")\n-\t(float:MODEF (match_operand:DI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_64BIT && TARGET_SSE2 && TARGET_SSE_MATH\n-   && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n-   && optimize_function_for_speed_p (cfun)\n-   && reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(vec_merge:<ssevecmode>\n-\t  (vec_duplicate:<ssevecmode>\n-\t    (float:MODEF (match_dup 1)))\n-\t  (match_dup 0)\n-\t  (const_int 1)))]\n-{\n-  operands[0] = simplify_gen_subreg (<ssevecmode>mode, operands[0],\n-\t\t\t\t     <MODE>mode, 0);\n-  emit_move_insn (operands[0], CONST0_RTX (<ssevecmode>mode));\n+  emit_move_insn (op0, CONST0_RTX (vmode));\n+\n+  t = gen_rtx_FLOAT (mode, operands[1]);\n+  t = gen_rtx_VEC_DUPLICATE (vmode, t);\n+  t = gen_rtx_VEC_MERGE (vmode, t, op0, const1_rtx);\n+  emit_insn (gen_rtx_SET (VOIDmode, op0, t));\n+  DONE;\n })\n \n ;; Break partial reg stall for cvtsd2ss."}]}