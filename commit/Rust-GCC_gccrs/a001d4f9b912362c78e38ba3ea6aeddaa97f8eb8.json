{"sha": "a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAwMWQ0ZjliOTEyMzYyYzc4ZTM4YmEzZWE2YWVkZGFhOTdmOGViOA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-11-29T02:02:45Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-11-29T02:02:45Z"}, "message": "combine: Make code after a new trap unreachable (PR78342)\n\nCombine can turn a conditional trap into an unconditional trap.  If it\ndoes that it should make the code after it unreachable (an unconditional\ntrap should be the last insn in its bb, and that bb has no successors).\n\nThis patch seems to work.  It is hard to be sure, this is very hard to\ntrigger.  Quite a few other passes look like they need something similar\nas well, but I don't see anything else handling it yet either.\n\n\n\tPR rtl-optimization/78342\n\t* combine.c: Include \"cfghooks.h\".\n\t(try_combine): If we create an unconditional trap, break the basic\n\tblock in two just after it, and remove the edge between; also, set\n\tthe *new_direct_jump_p flag so that cleanup_cfg is run.\n\nFrom-SVN: r242947", "tree": {"sha": "7b6b165d26dcdfd5c1a1f4557a6d779abf95ca84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b6b165d26dcdfd5c1a1f4557a6d779abf95ca84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48cf0e51e9cd4a78488dc216ed6f190df4c5b481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48cf0e51e9cd4a78488dc216ed6f190df4c5b481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48cf0e51e9cd4a78488dc216ed6f190df4c5b481"}], "stats": {"total": 28, "additions": 28, "deletions": 0}, "files": [{"sha": "07bcc26b5b62b1aa7607f8da1395e19c9851c86e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "patch": "@@ -1,3 +1,11 @@\n+2016-11-28  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\tPR rtl-optimization/78342\n+\t* combine.c: Include \"cfghooks.h\".\n+\t(try_combine): If we create an unconditional trap, break the basic\n+\tblock in two just after it, and remove the edge between; also, set\n+\tthe *new_direct_jump_p flag so that cleanup_cfg is run.\n+\n 2016-11-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* simplify-rtx.c (simplify_truncation): Handle truncate of zero_extract"}, {"sha": "41f69daf7f3bbe715701640b174296fd15b4ac30", "filename": "gcc/combine.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a001d4f9b912362c78e38ba3ea6aeddaa97f8eb8", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"cfghooks.h\"\n #include \"predict.h\"\n #include \"df.h\"\n #include \"memmodel.h\"\n@@ -4620,6 +4621,25 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       update_cfg_for_uncondjump (undobuf.other_insn);\n     }\n \n+  if (GET_CODE (PATTERN (i3)) == TRAP_IF\n+      && XEXP (PATTERN (i3), 0) == const1_rtx)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (i3);\n+      gcc_assert (bb);\n+      remove_edge (split_block (bb, i3));\n+      *new_direct_jump_p = 1;\n+    }\n+\n+  if (undobuf.other_insn\n+      && GET_CODE (PATTERN (undobuf.other_insn)) == TRAP_IF\n+      && XEXP (PATTERN (undobuf.other_insn), 0) == const1_rtx)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (undobuf.other_insn);\n+      gcc_assert (bb);\n+      remove_edge (split_block (bb, undobuf.other_insn));\n+      *new_direct_jump_p = 1;\n+    }\n+\n   /* A noop might also need cleaning up of CFG, if it comes from the\n      simplification of a jump.  */\n   if (JUMP_P (i3)"}]}