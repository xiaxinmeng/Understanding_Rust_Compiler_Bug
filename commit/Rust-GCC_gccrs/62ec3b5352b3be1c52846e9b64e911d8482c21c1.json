{"sha": "62ec3b5352b3be1c52846e9b64e911d8482c21c1", "node_id": "C_kwDOANBUbNoAKDYyZWMzYjUzNTJiM2JlMWM1Mjg0NmU5YjY0ZTkxMWQ4NDgyYzIxYzE", "commit": {"author": {"name": "chenglulu", "email": "chenglulu@loongson.cn", "date": "2021-11-27T06:58:21Z"}, "committer": {"name": "Chenghua Xu", "email": "paul.hua.gm@gmail.com", "date": "2022-03-29T09:43:34Z"}, "message": "LoongArch Port: Machine description C files and .h files.\n\n2022-03-29  Chenghua Xu  <xuchenghua@loongson.cn>\n\t    Lulu Cheng  <chenglulu@loongson.cn>\n\ngcc/ChangeLog:\n\n\t* config/host-linux.cc: Add LoongArch support.\n\t* config/loongarch/loongarch-protos.h: New file.\n\t* config/loongarch/loongarch-tune.h: Likewise.\n\t* config/loongarch/loongarch.cc: Likewise.\n\t* config/loongarch/loongarch.h: Likewise.", "tree": {"sha": "92f70cf1bc769ba7941d364d8dc0a7f791ee98cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92f70cf1bc769ba7941d364d8dc0a7f791ee98cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62ec3b5352b3be1c52846e9b64e911d8482c21c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ec3b5352b3be1c52846e9b64e911d8482c21c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ec3b5352b3be1c52846e9b64e911d8482c21c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ec3b5352b3be1c52846e9b64e911d8482c21c1/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChenghuaXu", "id": 87753117, "node_id": "MDQ6VXNlcjg3NzUzMTE3", "avatar_url": "https://avatars.githubusercontent.com/u/87753117?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChenghuaXu", "html_url": "https://github.com/ChenghuaXu", "followers_url": "https://api.github.com/users/ChenghuaXu/followers", "following_url": "https://api.github.com/users/ChenghuaXu/following{/other_user}", "gists_url": "https://api.github.com/users/ChenghuaXu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChenghuaXu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChenghuaXu/subscriptions", "organizations_url": "https://api.github.com/users/ChenghuaXu/orgs", "repos_url": "https://api.github.com/users/ChenghuaXu/repos", "events_url": "https://api.github.com/users/ChenghuaXu/events{/privacy}", "received_events_url": "https://api.github.com/users/ChenghuaXu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcaf571cf9bcdac5911ebd7919493798554c34d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcaf571cf9bcdac5911ebd7919493798554c34d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcaf571cf9bcdac5911ebd7919493798554c34d4"}], "stats": {"total": 7316, "additions": 7316, "deletions": 0}, "files": [{"sha": "817d3c0870cd61cacbfa3d65cd8e3a434cefb918", "filename": "gcc/config/host-linux.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Fhost-linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Fhost-linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-linux.cc?ref=62ec3b5352b3be1c52846e9b64e911d8482c21c1", "patch": "@@ -98,6 +98,8 @@\n # define TRY_EMPTY_VM_SPACE\t0x60000000\n #elif defined(__riscv) && defined (__LP64__)\n # define TRY_EMPTY_VM_SPACE\t0x1000000000\n+#elif defined(__loongarch__) && defined(__LP64__)\n+# define TRY_EMPTY_VM_SPACE\t0x8000000000\n #else\n # define TRY_EMPTY_VM_SPACE\t0\n #endif"}, {"sha": "2144c2421ed434a5a161cc12305d959727771f09", "filename": "gcc/config/loongarch/loongarch-protos.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h?ref=62ec3b5352b3be1c52846e9b64e911d8482c21c1", "patch": "@@ -0,0 +1,172 @@\n+/* Prototypes of target machine for GNU compiler.  LoongArch version.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LOONGARCH_PROTOS_H\n+#define GCC_LOONGARCH_PROTOS_H\n+\n+/* Classifies a SYMBOL_REF, LABEL_REF or UNSPEC address.\n+\n+   SYMBOL_GOT_DISP\n+       The symbol's value will be loaded directly from the GOT.\n+\n+   SYMBOL_TLS\n+       A thread-local symbol.\n+\n+   SYMBOL_TLSGD\n+   SYMBOL_TLSLDM\n+       UNSPEC wrappers around SYMBOL_TLS, corresponding to the\n+       thread-local storage relocation operators.\n+   */\n+enum loongarch_symbol_type {\n+  SYMBOL_GOT_DISP,\n+  SYMBOL_TLS,\n+  SYMBOL_TLSGD,\n+  SYMBOL_TLSLDM,\n+};\n+#define NUM_SYMBOL_TYPES (SYMBOL_TLSLDM + 1)\n+\n+/* Routines implemented in loongarch.c.  */\n+extern rtx loongarch_emit_move (rtx, rtx);\n+extern HOST_WIDE_INT loongarch_initial_elimination_offset (int, int);\n+extern void loongarch_expand_prologue (void);\n+extern void loongarch_expand_epilogue (bool);\n+extern bool loongarch_can_use_return_insn (void);\n+\f\n+extern bool loongarch_symbolic_constant_p (rtx, enum loongarch_symbol_type *);\n+extern int loongarch_regno_mode_ok_for_base_p (int, machine_mode, bool);\n+extern int loongarch_address_insns (rtx, machine_mode, bool);\n+extern int loongarch_const_insns (rtx);\n+extern int loongarch_split_const_insns (rtx);\n+extern int loongarch_split_128bit_const_insns (rtx);\n+extern int loongarch_load_store_insns (rtx, rtx_insn *);\n+extern int loongarch_idiv_insns (machine_mode);\n+#ifdef RTX_CODE\n+extern void loongarch_emit_binary (enum rtx_code, rtx, rtx, rtx);\n+#endif\n+extern bool loongarch_split_symbol (rtx, rtx, machine_mode, rtx *);\n+extern rtx loongarch_unspec_address (rtx, enum loongarch_symbol_type);\n+extern rtx loongarch_strip_unspec_address (rtx);\n+extern void loongarch_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);\n+extern bool loongarch_legitimize_move (machine_mode, rtx, rtx);\n+extern rtx loongarch_legitimize_call_address (rtx);\n+\n+extern rtx loongarch_subword (rtx, bool);\n+extern bool loongarch_split_move_p (rtx, rtx);\n+extern void loongarch_split_move (rtx, rtx, rtx);\n+extern bool loongarch_split_move_insn_p (rtx, rtx);\n+extern void loongarch_split_move_insn (rtx, rtx, rtx);\n+extern const char *loongarch_output_move (rtx, rtx);\n+extern bool loongarch_cfun_has_cprestore_slot_p (void);\n+#ifdef RTX_CODE\n+extern void loongarch_expand_scc (rtx *);\n+extern void loongarch_expand_conditional_branch (rtx *);\n+extern void loongarch_expand_conditional_move (rtx *);\n+extern void loongarch_expand_conditional_trap (rtx);\n+#endif\n+extern void loongarch_set_return_address (rtx, rtx);\n+extern bool loongarch_move_by_pieces_p (unsigned HOST_WIDE_INT, unsigned int);\n+extern bool loongarch_expand_block_move (rtx, rtx, rtx);\n+extern bool loongarch_do_optimize_block_move_p (void);\n+\n+extern bool loongarch_expand_ext_as_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t\t    HOST_WIDE_INT, bool);\n+extern bool loongarch_expand_ins_as_unaligned_store (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t\t     HOST_WIDE_INT);\n+extern HOST_WIDE_INT loongarch_debugger_offset (rtx, HOST_WIDE_INT);\n+\n+extern void loongarch_output_external (FILE *, tree, const char *);\n+extern void loongarch_output_ascii (FILE *, const char *, size_t);\n+extern bool loongarch_small_data_pattern_p (rtx);\n+extern rtx loongarch_rewrite_small_data (rtx);\n+extern rtx loongarch_return_addr (int, rtx);\n+\n+extern enum reg_class loongarch_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t\tmachine_mode,\n+\t\t\t\t\t\t\trtx, bool);\n+extern int loongarch_class_max_nregs (enum reg_class, machine_mode);\n+\n+extern machine_mode loongarch_hard_regno_caller_save_mode (unsigned int,\n+\t\t\t\t\t\t\t   unsigned int,\n+\t\t\t\t\t\t\t   machine_mode);\n+extern int loongarch_adjust_insn_length (rtx_insn *, int);\n+extern const char *loongarch_output_conditional_branch (rtx_insn *, rtx *,\n+\t\t\t\t\t\t\tconst char *,\n+\t\t\t\t\t\t\tconst char *);\n+extern const char *loongarch_output_order_conditional_branch (rtx_insn *,\n+\t\t\t\t\t\t\t      rtx *,\n+\t\t\t\t\t\t\t      bool);\n+extern const char *loongarch_output_equal_conditional_branch (rtx_insn *,\n+\t\t\t\t\t\t\t      rtx *,\n+\t\t\t\t\t\t\t      bool);\n+extern const char *loongarch_output_division (const char *, rtx *);\n+extern const char *loongarch_output_probe_stack_range (rtx, rtx, rtx);\n+extern bool loongarch_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern int loongarch_dspalu_bypass_p (rtx, rtx);\n+extern rtx loongarch_prefetch_cookie (rtx, rtx);\n+\n+extern bool loongarch_global_symbol_p (const_rtx);\n+extern bool loongarch_global_symbol_noweak_p (const_rtx);\n+extern bool loongarch_weak_symbol_p (const_rtx);\n+extern bool loongarch_symbol_binds_local_p (const_rtx);\n+\n+extern const char *current_section_name (void);\n+extern unsigned int current_section_flags (void);\n+extern bool loongarch_use_ins_ext_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+\n+union loongarch_gen_fn_ptrs\n+{\n+  rtx (*fn_8) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  rtx (*fn_7) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  rtx (*fn_6) (rtx, rtx, rtx, rtx, rtx, rtx);\n+  rtx (*fn_5) (rtx, rtx, rtx, rtx, rtx);\n+  rtx (*fn_4) (rtx, rtx, rtx, rtx);\n+};\n+\n+extern void loongarch_expand_atomic_qihi (union loongarch_gen_fn_ptrs,\n+\t\t\t\t\t  rtx, rtx, rtx, rtx, rtx);\n+\n+extern bool loongarch_signed_immediate_p (unsigned HOST_WIDE_INT, int, int);\n+extern bool loongarch_unsigned_immediate_p (unsigned HOST_WIDE_INT, int, int);\n+extern bool loongarch_12bit_offset_address_p (rtx, machine_mode);\n+extern bool loongarch_14bit_shifted_offset_address_p (rtx, machine_mode);\n+extern bool loongarch_base_index_address_p (rtx, machine_mode);\n+extern rtx loongarch_expand_thread_pointer (rtx);\n+\n+extern bool loongarch_eh_uses (unsigned int);\n+extern bool loongarch_epilogue_uses (unsigned int);\n+extern bool loongarch_load_store_bonding_p (rtx *, machine_mode, bool);\n+extern bool loongarch_split_symbol_type (enum loongarch_symbol_type);\n+\n+typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);\n+\n+extern void loongarch_register_frame_header_opt (void);\n+\n+/* Routines implemented in loongarch-c.c.  */\n+void loongarch_cpu_cpp_builtins (cpp_reader *);\n+\n+extern void loongarch_init_builtins (void);\n+extern void loongarch_atomic_assign_expand_fenv (tree *, tree *, tree *);\n+extern tree loongarch_builtin_decl (unsigned int, bool);\n+extern rtx loongarch_expand_builtin (tree, rtx, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t\t\t     machine_mode, int);\n+extern tree loongarch_build_builtin_va_list (void);\n+\n+#endif /* ! GCC_LOONGARCH_PROTOS_H */"}, {"sha": "6f3530f5c02d39e012c977f9f971d25bd6b196f9", "filename": "gcc/config/loongarch/loongarch-tune.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch-tune.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch-tune.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-tune.h?ref=62ec3b5352b3be1c52846e9b64e911d8482c21c1", "patch": "@@ -0,0 +1,50 @@\n+/* Definitions for microarchitecture-related data structures.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LOONGARCH_TUNE_H\n+#define LOONGARCH_TUNE_H\n+\n+/* RTX costs of various operations on the different architectures.  */\n+struct loongarch_rtx_cost_data\n+{\n+  unsigned short fp_add;\n+  unsigned short fp_mult_sf;\n+  unsigned short fp_mult_df;\n+  unsigned short fp_div_sf;\n+  unsigned short fp_div_df;\n+  unsigned short int_mult_si;\n+  unsigned short int_mult_di;\n+  unsigned short int_div_si;\n+  unsigned short int_div_di;\n+  unsigned short branch_cost;\n+  unsigned short memory_latency;\n+};\n+\n+/* Costs to use when optimizing for size.  */\n+extern const struct loongarch_rtx_cost_data loongarch_rtx_cost_optimize_size;\n+\n+/* Cache size record of known processor models.  */\n+struct loongarch_cache {\n+    int l1d_line_size;  /* bytes */\n+    int l1d_size;       /* KiB */\n+    int l2d_size;       /* kiB */\n+};\n+\n+#endif /* LOONGARCH_TUNE_H */"}, {"sha": "6e24111a79d390174d4b5756576e6b482ec1bb86", "filename": "gcc/config/loongarch/loongarch.cc", "status": "added", "additions": 5945, "deletions": 0, "changes": 5945, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=62ec3b5352b3be1c52846e9b64e911d8482c21c1"}, {"sha": "4d107a42209427c3b9f461054f1e0927a8e5cbee", "filename": "gcc/config/loongarch/loongarch.h", "status": "added", "additions": 1147, "deletions": 0, "changes": 1147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ec3b5352b3be1c52846e9b64e911d8482c21c1/gcc%2Fconfig%2Floongarch%2Floongarch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.h?ref=62ec3b5352b3be1c52846e9b64e911d8482c21c1", "patch": "@@ -0,0 +1,1147 @@\n+/* Definitions of target machine for GNU compiler.  LoongArch version.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+   Based on MIPS and RISC-V target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* LoongArch external variables defined in loongarch.cc.  */\n+\n+#include \"config/loongarch/loongarch-opts.h\"\n+\n+/* Macros to silence warnings about numbers being signed in traditional\n+   C and unsigned in ISO C when compiled on 32-bit hosts.  */\n+\n+#define BITMASK_HIGH (((unsigned long) 1) << 31) /* 0x80000000  */\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* Target CPU builtins.  */\n+#define TARGET_CPU_CPP_BUILTINS() loongarch_cpu_cpp_builtins (pfile)\n+\n+/* Default target_flags if no switches are specified.  */\n+\n+#ifdef IN_LIBGCC2\n+#undef TARGET_64BIT\n+/* Make this compile time constant for libgcc2.  */\n+#ifdef __loongarch64\n+#define TARGET_64BIT 1\n+#else\n+#define TARGET_64BIT 0\n+#endif\n+#endif /* IN_LIBGCC2  */\n+\n+#define TARGET_LIBGCC_SDATA_SECTION \".sdata\"\n+\n+/* Driver native functions for SPEC processing in the GCC driver.  */\n+#include \"loongarch-driver.h\"\n+\n+/* This definition replaces the formerly used 'm' constraint with a\n+   different constraint letter in order to avoid changing semantics of\n+   the 'm' constraint when accepting new address formats in\n+   TARGET_LEGITIMATE_ADDRESS_P.  The constraint letter defined here\n+   must not be used in insn definitions or inline assemblies.  */\n+#define TARGET_MEM_CONSTRAINT 'w'\n+\n+/* Tell collect what flags to pass to nm.  */\n+#ifndef NM_FLAGS\n+#define NM_FLAGS \"-Bn\"\n+#endif\n+\n+/* SUBTARGET_ASM_SPEC is always passed to the assembler.  It may be\n+   overridden by subtargets.  */\n+\n+#ifndef SUBTARGET_ASM_SPEC\n+#define SUBTARGET_ASM_SPEC \"\"\n+#endif\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{mabi=*} %{subtarget_asm_spec}\"\n+\n+/* Extra switches sometimes passed to the linker.  */\n+\n+#ifndef LINK_SPEC\n+#define LINK_SPEC \"\"\n+#endif /* LINK_SPEC defined  */\n+\n+/* Specs for the compiler proper.  */\n+\n+/* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n+\n+#undef CC1_SPEC\n+#define CC1_SPEC \"\\\n+%{G*} \\\n+%(subtarget_cc1_spec)\"\n+\n+/* Preprocessor specs.  */\n+\n+/* SUBTARGET_CPP_SPEC is passed to the preprocessor.  It may be\n+   overridden by subtargets.  */\n+#ifndef SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \"\"\n+#endif\n+\n+#define CPP_SPEC \"%(subtarget_cpp_spec)\"\n+\n+/* This macro defines names of additional specifications to put in the specs\n+   that can be used in various specifications like CC1_SPEC.  Its definition\n+   is an initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   specification name, and a string constant that used by the GCC driver\n+   program.\n+\n+   Do not define this macro if it does not need to do anything.  */\n+\n+#define EXTRA_SPECS \\\n+  {\"subtarget_cc1_spec\", SUBTARGET_CC1_SPEC}, \\\n+  {\"subtarget_cpp_spec\", SUBTARGET_CPP_SPEC}, \\\n+  {\"subtarget_asm_spec\", SUBTARGET_ASM_SPEC},\n+\n+/* Registers may have a prefix which can be ignored when matching\n+   user asm and register definitions.  */\n+#ifndef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"$\"\n+#endif\n+\n+/* Local compiler-generated symbols must have a prefix that the assembler\n+   understands.  */\n+\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+/* By default on the loongarch, external symbols do not have an underscore\n+   prepended.  */\n+\n+#define USER_LABEL_PREFIX \"\"\n+\n+#ifndef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#endif\n+\n+/* The size of DWARF addresses should be the same as the size of symbols\n+   in the target file format.  */\n+#define DWARF2_ADDR_SIZE (TARGET_64BIT ? 8 : 4)\n+\n+/* By default, turn on GDB extensions.  */\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+/* By default, produce dwarf version 2 format debugging output in response\n+   to the \u2018-g\u2019 option.  */\n+#define DWARF2_DEBUGGING_INFO 1\n+\n+/* The mapping from gcc register number to DWARF 2 CFA column number.  */\n+#define DWARF_FRAME_REGNUM(REGNO) loongarch_dwarf_regno[REGNO]\n+\n+/* The DWARF 2 CFA column which tracks the return address.  */\n+#define DWARF_FRAME_RETURN_COLUMN RETURN_ADDR_REGNUM\n+\n+/* Before the prologue, RA lives in r1.  */\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  ((N) < (4) ? (N) + GP_ARG_FIRST : INVALID_REGNUM)\n+\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, GP_ARG_FIRST + 4)\n+\n+#define EH_USES(N) loongarch_eh_uses (N)\n+\n+/* Offsets recorded in opcodes are a multiple of this alignment factor.\n+   The default for this in 64-bit mode is 8, which causes problems with\n+   SFmode register saves.  */\n+#define DWARF_CIE_DATA_ALIGNMENT -4\n+\n+/* Target machine storage layout.  */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define MAX_BITS_PER_WORD 64\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#ifndef IN_LIBGCC2\n+#define MIN_UNITS_PER_WORD 4\n+#endif\n+\n+/* For LARCH, width of a floating point register.  */\n+#define UNITS_PER_FPREG (TARGET_DOUBLE_FLOAT ? 8 : 4)\n+\n+/* The largest size of value that can be held in floating-point\n+   registers and moved with a single instruction.  */\n+#define UNITS_PER_HWFPVALUE \\\n+  (TARGET_SOFT_FLOAT ? 0 : UNITS_PER_FPREG)\n+\n+/* The largest size of value that can be held in floating-point\n+   registers.  */\n+#define UNITS_PER_FPVALUE \\\n+  (TARGET_SOFT_FLOAT ? 0 \\\n+   : TARGET_SINGLE_FLOAT ? UNITS_PER_FPREG \\\n+\t\t\t : LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)\n+\n+/* The number of bytes in a double.  */\n+#define UNITS_PER_DOUBLE (TYPE_PRECISION (double_type_node) / BITS_PER_UNIT)\n+\n+/* Set the sizes of the core types.  */\n+#define SHORT_TYPE_SIZE 16\n+#define INT_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE (TARGET_64BIT ? 128 : 64)\n+\n+/* Define the sizes of fixed-point types.  */\n+#define SHORT_FRACT_TYPE_SIZE 8\n+#define FRACT_TYPE_SIZE 16\n+#define LONG_FRACT_TYPE_SIZE 32\n+#define LONG_LONG_FRACT_TYPE_SIZE 64\n+\n+#define SHORT_ACCUM_TYPE_SIZE 16\n+#define ACCUM_TYPE_SIZE 32\n+#define LONG_ACCUM_TYPE_SIZE 64\n+#define LONG_LONG_ACCUM_TYPE_SIZE (TARGET_64BIT ? 128 : 64)\n+\n+/* long double is not a fixed mode, but the idea is that, if we\n+   support long double, we also want a 128-bit integer type.  */\n+#define MAX_FIXED_MODE_SIZE LONG_DOUBLE_TYPE_SIZE\n+\n+/* Width in bits of a pointer.  */\n+#ifndef POINTER_SIZE\n+#define POINTER_SIZE (TARGET_64BIT ? 64 : 32)\n+#endif\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY BITS_PER_WORD\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Number of bits which any structure or union's size must be a multiple of.\n+   Each structure or union's size is rounded up to a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* There is no point aligning anything to a rounder boundary than\n+   LONG_DOUBLE_TYPE_SIZE.  */\n+#define BIGGEST_ALIGNMENT (LONG_DOUBLE_TYPE_SIZE)\n+\n+/* All accesses must be aligned.  */\n+#define STRICT_ALIGNMENT (TARGET_STRICT_ALIGN)\n+\n+/* Define this if you wish to imitate the way many other C compilers\n+   handle alignment of bitfields and the structures that contain\n+   them.\n+\n+   The behavior is that the type written for a bit-field (`int',\n+   `short', or other integer type) imposes an alignment for the\n+   entire structure, as if the structure really did contain an\n+   ordinary field of that type.  In addition, the bit-field is placed\n+   within the structure so that it would fit within such a field,\n+   not crossing a boundary for it.\n+\n+   Thus, on most machines, a bit-field whose type is written as `int'\n+   would not cross a four-byte boundary, and would force four-byte\n+   alignment for the whole structure.  (The alignment used may not\n+   be four bytes; it is controlled by the other alignment\n+   parameters.)\n+\n+   If the macro is defined, its definition should be a C expression;\n+   a nonzero value for the expression enables this behavior.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* If defined, a C expression to compute the alignment for a static\n+   variable.  TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.\n+\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  Another is to\n+   cause character arrays to be word-aligned so that `strcpy' calls\n+   that copy constants to character arrays can be done inline.  */\n+\n+#undef DATA_ALIGNMENT\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* We need this for the same reason as DATA_ALIGNMENT, namely to cause\n+   character arrays to be word-aligned so that `strcpy' calls that copy\n+   constants to character arrays can be done inline, and 'strcmp' can be\n+   optimised to use word loads.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) DATA_ALIGNMENT (TYPE, ALIGN)\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS 1\n+\n+/* When in 64-bit mode, move insns will sign extend SImode and FCCmode\n+   moves.  All other references are zero extended.  */\n+#define LOAD_EXTEND_OP(MODE) \\\n+  (TARGET_64BIT && ((MODE) == SImode || (MODE) == FCCmode) ? SIGN_EXTEND \\\n+\t\t\t\t\t\t\t   : ZERO_EXTEND)\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT \\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    { \\\n+      if ((MODE) == SImode) \\\n+\t(UNSIGNEDP) = 0; \\\n+      (MODE) = Pmode; \\\n+    }\n+\n+/* Pmode is always the same as ptr_mode, but not always the same as word_mode.\n+   Extensions of pointers to word_mode must be signed.  */\n+#define POINTERS_EXTEND_UNSIGNED false\n+\n+/* Define if loading short immediate values into registers sign extends.  */\n+#define SHORT_IMMEDIATES_SIGN_EXTEND 1\n+\n+/* The clz.{w/d} instructions have the natural values at 0.  */\n+\n+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \\\n+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE), 2)\n+\n+/* Standard register usage.  */\n+\n+/* Number of hardware registers.  We have:\n+\n+   - 32 integer registers\n+   - 32 floating point registers\n+   - 8 condition code registers\n+   - 2 fake registers:\n+\t- ARG_POINTER_REGNUM\n+\t- FRAME_POINTER_REGNUM\n+*/\n+\n+#define FIRST_PSEUDO_REGISTER 74\n+\n+/* zero, tp, sp and x are fixed.  */\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{ /* General registers.  */\t\t\t\t\t\t\\\n+  1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Floating-point registers.  */\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Others.  */\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1}\n+\n+/* The call RTLs themselves clobber ra.  */\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{ /* General registers.  */\t\t\t\t\t\t\\\n+  1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Floating-point registers.  */\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* Others.  */\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* Internal macros to classify a register number as to whether it's a\n+   general purpose register, a floating point register, or a status\n+   register.  */\n+\n+#define GP_REG_FIRST 0\n+#define GP_REG_LAST 31\n+#define GP_REG_NUM (GP_REG_LAST - GP_REG_FIRST + 1)\n+\n+#define FP_REG_FIRST 32\n+#define FP_REG_LAST 63\n+#define FP_REG_NUM (FP_REG_LAST - FP_REG_FIRST + 1)\n+\n+/* The DWARF 2 CFA column which tracks the return address from a\n+   signal handler context.  This means that to maintain backwards\n+   compatibility, no hard register can be assigned this column if it\n+   would need to be handled by the DWARF unwinder.  */\n+#define DWARF_ALT_FRAME_RETURN_COLUMN 72\n+\n+#define FCC_REG_FIRST 64\n+#define FCC_REG_LAST 71\n+#define FCC_REG_NUM (FCC_REG_LAST - FCC_REG_FIRST + 1)\n+\n+#define GP_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define FP_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n+#define FCC_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - FCC_REG_FIRST) < FCC_REG_NUM)\n+\n+#define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n+\n+/* Select a register mode required for caller save of hard regno REGNO.  */\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n+  loongarch_hard_regno_caller_save_mode (REGNO, NREGS, MODE)\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM (GP_REG_FIRST + 3)\n+\n+/* These two registers don't really exist: they get eliminated to either\n+   the stack or hard frame pointer.  */\n+#define ARG_POINTER_REGNUM 72\n+#define FRAME_POINTER_REGNUM 73\n+\n+#define HARD_FRAME_POINTER_REGNUM (GP_REG_FIRST + 22)\n+\n+#define HARD_FRAME_POINTER_IS_FRAME_POINTER 0\n+#define HARD_FRAME_POINTER_IS_ARG_POINTER 0\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 20) /* $t8  */\n+\n+#define GP_TEMP_FIRST (GP_REG_FIRST + 12)\n+#define LARCH_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST + 1)\n+#define LARCH_PROLOGUE_TEMP2_REGNUM (GP_TEMP_FIRST)\n+#define LARCH_PROLOGUE_TEMP3_REGNUM (GP_TEMP_FIRST + 2)\n+#define LARCH_EPILOGUE_TEMP_REGNUM (GP_TEMP_FIRST)\n+\n+#define CALLEE_SAVED_REG_NUMBER(REGNO) \\\n+  ((REGNO) >= 22 && (REGNO) <= 31 ? (REGNO) - 22 : -1)\n+\n+#define LARCH_PROLOGUE_TEMP(MODE) \\\n+  gen_rtx_REG (MODE, LARCH_PROLOGUE_TEMP_REGNUM)\n+#define LARCH_PROLOGUE_TEMP2(MODE) \\\n+  gen_rtx_REG (MODE, LARCH_PROLOGUE_TEMP2_REGNUM)\n+#define LARCH_PROLOGUE_TEMP3(MODE) \\\n+  gen_rtx_REG (MODE, LARCH_PROLOGUE_TEMP3_REGNUM)\n+#define LARCH_EPILOGUE_TEMP(MODE) \\\n+  gen_rtx_REG (MODE, LARCH_EPILOGUE_TEMP_REGNUM)\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+#define NO_FUNCTION_CSE 1\n+\n+#define THREAD_POINTER_REGNUM (GP_REG_FIRST + 2)\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+enum reg_class\n+{\n+  NO_REGS,\t  /* no registers in set  */\n+  SIBCALL_REGS,\t  /* registers used by indirect sibcalls  */\n+  JIRL_REGS,\t  /* registers used by indirect calls  */\n+  CSR_REGS,\t  /* integer registers except for $r0 and $r1 for lcsr.  */\n+  GR_REGS,\t  /* integer registers  */\n+  FP_REGS,\t  /* floating point registers  */\n+  FCC_REGS,\t  /* status registers (fp status)  */\n+  FRAME_REGS,\t  /* arg pointer and frame pointer  */\n+  ALL_REGS,\t  /* all registers  */\n+  LIM_REG_CLASSES /* max value + 1  */\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define GENERAL_REGS GR_REGS\n+\n+/* An initializer containing the names of the register classes as C\n+   string constants.  These names are used in writing some of the\n+   debugging dumps.  */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"SIBCALL_REGS\",\t\t\t\t\t\t\t\\\n+  \"JIRL_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"CSR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FCC_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FRAME_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* An initializer containing the contents of the register classes,\n+   as integers which are bit masks.  The Nth integer specifies the\n+   contents of class N.  The way the integer MASK is interpreted is\n+   that register R is in the class if `MASK & (1 << R)' is 1.\n+\n+   When the machine has more than 32 registers, an integer does not\n+   suffice.  Then the integers are replaced by sub-initializers,\n+   braced groupings containing several integers.  Each\n+   sub-initializer must be suitable as an initializer for the type\n+   `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS  */\t\t\\\n+  { 0x001ff000, 0x00000000, 0x00000000 },\t/* SIBCALL_REGS  */\t\\\n+  { 0xff9ffff0, 0x00000000, 0x00000000 },\t/* JIRL_REGS  */\t\\\n+  { 0xfffffffc, 0x00000000, 0x00000000 },\t/* CSR_REGS  */\t\t\\\n+  { 0xffffffff, 0x00000000, 0x00000000 },\t/* GR_REGS  */\t\t\\\n+  { 0x00000000, 0xffffffff, 0x00000000 },\t/* FP_REGS  */\t\t\\\n+  { 0x00000000, 0x00000000, 0x000000ff },\t/* FCC_REGS  */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000300 },\t/* FRAME_REGS  */\t\\\n+  { 0xffffffff, 0xffffffff, 0x000003ff }\t/* ALL_REGS  */\t\t\\\n+}\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more that one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register.  */\n+\n+#define REGNO_REG_CLASS(REGNO) loongarch_regno_to_class[(REGNO)]\n+\n+/* A macro whose definition is the name of the class to which a\n+   valid base register must belong.  A base register is one used in\n+   an address which is the register value plus a displacement.  */\n+\n+#define BASE_REG_CLASS (GR_REGS)\n+\n+/* A macro whose definition is the name of the class to which a\n+   valid index register must belong.  An index register is one used\n+   in an address where its value is either multiplied by a scale\n+   factor or added to another register (as well as added to a\n+   displacement).  */\n+\n+#define INDEX_REG_CLASS GR_REGS\n+\n+/* We generally want to put call-clobbered registers ahead of\n+   call-saved ones.  (IRA expects this.)  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n+{ /* Call-clobbered GPRs.  */\t\t\t\t\t\t\\\n+  12, 13, 14, 15, 16, 17, 18, 19, 20, 4, 5, 6, 7, 8, 9, 10, 11, 1,\t\\\n+  /* Call-saved GPRs.  */\t\t\t\t\t\t\\\n+  23, 24, 25, 26, 27, 28, 29, 30, 31,\t\t\t\t\t\\\n+  /* GPRs that can never be exposed to the register allocator.  */\t\\\n+  0, 2, 3, 21, 22, \t\t\t\t\t\t\t\\\n+  /* Call-clobbered FPRs.  */\t\t\t\t\t\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49, 50, 51,52, 53, 54, 55, \t\t\t\t\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t\t\t\t\t\\\n+  /* None of the remaining classes have defined call-saved\t\t\\\n+     registers.  */\t\t\t\t\t\t\t\\\n+  64, 65, 66, 67, 68, 69, 70, 71, 72, 73}\n+\n+#define IMM_BITS 12\n+#define IMM_REACH (1LL << IMM_BITS)\n+\n+/* True if VALUE is an unsigned 6-bit number.  */\n+\n+#define UIMM6_OPERAND(VALUE) (((VALUE) & ~(unsigned HOST_WIDE_INT) 0x3f) == 0)\n+\n+/* True if VALUE is a signed 10-bit number.  */\n+\n+#define IMM10_OPERAND(VALUE) ((unsigned HOST_WIDE_INT) (VALUE) + 0x200 < 0x400)\n+\n+/* True if VALUE is a signed 12-bit number.  */\n+\n+#define IMM12_OPERAND(VALUE) \\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + IMM_REACH / 2 < IMM_REACH)\n+\n+/* True if VALUE is a signed 16-bit number.  */\n+\n+#define IMM16_OPERAND(VALUE) \\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + 0x8000 < 0x10000)\n+\n+/* True if VALUE is an unsigned 12-bit number.  */\n+\n+#define IMM12_OPERAND_UNSIGNED(VALUE) \\\n+  (((VALUE) & ~(unsigned HOST_WIDE_INT) (IMM_REACH - 1)) == 0)\n+\n+/* True if VALUE can be loaded into a register using LU12I.  */\n+\n+#define LU12I_OPERAND(VALUE) \\\n+  (((VALUE) | ((1UL << 31) - IMM_REACH)) == ((1UL << 31) - IMM_REACH) \\\n+   || ((VALUE) | ((1UL << 31) - IMM_REACH)) + IMM_REACH == 0)\n+\n+/* True if VALUE can be loaded into a register using LU32I.  */\n+\n+#define LU32I_OPERAND(VALUE) \\\n+  (((VALUE) | (((1ULL << 19) - 1) << 32)) == (((1ULL << 19) - 1) << 32) \\\n+   || ((VALUE) | (((1ULL << 19) - 1) << 32)) + (1ULL << 32) == 0)\n+\n+/* True if VALUE can be loaded into a register using LU52I.  */\n+\n+#define LU52I_OPERAND(VALUE) (((VALUE) | (0xfffULL << 52)) == (0xfffULL << 52))\n+\n+/* Return a value X with the low 12 bits clear, and such that\n+   VALUE - X is a signed 12-bit value.  */\n+\n+#define CONST_HIGH_PART(VALUE) (((VALUE) + (IMM_REACH / 2)) & ~(IMM_REACH - 1))\n+\n+#define CONST_LOW_PART(VALUE) ((VALUE) - CONST_HIGH_PART (VALUE))\n+\n+#define IMM12_INT(X) IMM12_OPERAND (INTVAL (X))\n+#define IMM12_INT_UNSIGNED(X) IMM12_OPERAND_UNSIGNED (INTVAL (X))\n+#define LU12I_INT(X) LU12I_OPERAND (INTVAL (X))\n+#define LU32I_INT(X) LU32I_OPERAND (INTVAL (X))\n+#define LU52I_INT(X) LU52I_OPERAND (INTVAL (X))\n+#define LARCH_U12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))\n+#define LARCH_9BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -256, 255))\n+#define LARCH_16BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -32768, 32767))\n+#define LARCH_SHIFT_2_OFFSET_P(OFFSET) (((OFFSET) & 0x3) == 0)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) loongarch_class_max_nregs (CLASS, MODE)\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+#define RETURN_ADDR_RTX loongarch_return_addr\n+\n+/* Similarly, don't use the least-significant bit to tell pointers to\n+   code from vtable index.  */\n+\n+#define TARGET_PTRMEMFUNC_VBIT_LOCATION ptrmemfunc_vbit_in_delta\n+\n+#define ELIMINABLE_REGS \\\n+  { \\\n+    {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n+    {ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}, \\\n+    {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n+    {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}, \\\n+  }\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  (OFFSET) = loongarch_initial_elimination_offset ((FROM), (TO))\n+\n+/* Allocate stack space for arguments at the beginning of each function.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* The argument pointer always points to the first argument.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define REG_PARM_STACK_SPACE(FNDECL) 0\n+\n+/* Define this if it is the responsibility of the caller to\n+   allocate the area reserved for arguments passed in registers.\n+   If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n+   of this macro is to determine whether the space is included in\n+   `crtl->outgoing_args_size'.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+\n+#define STACK_BOUNDARY (TARGET_ABI_LP64 ? 128 : 64)\n+\n+/* Symbolic macros for the registers used to return integer and floating\n+   point values.  */\n+\n+#define GP_RETURN (GP_REG_FIRST + 4)\n+#define FP_RETURN ((TARGET_SOFT_FLOAT) ? GP_RETURN : (FP_REG_FIRST + 0))\n+\n+#define MAX_ARGS_IN_REGISTERS 8\n+\n+/* Symbolic macros for the first/last argument registers.  */\n+\n+#define GP_ARG_FIRST (GP_REG_FIRST + 4)\n+#define GP_ARG_LAST (GP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n+#define FP_ARG_FIRST (FP_REG_FIRST + 0)\n+#define FP_ARG_LAST (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   We have no FP argument registers when soft-float.  */\n+\n+/* Accept arguments in a0-a7, and in fa0-fa7 if permitted by the ABI.  */\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  (IN_RANGE ((N), GP_ARG_FIRST, GP_ARG_LAST) \\\n+   || (UNITS_PER_FP_ARG && IN_RANGE ((N), FP_ARG_FIRST, FP_ARG_LAST)))\n+\n+typedef struct {\n+  /* Number of integer registers used so far, up to MAX_ARGS_IN_REGISTERS.  */\n+  unsigned int num_gprs;\n+\n+  /* Number of floating-point registers used so far, likewise.  */\n+  unsigned int num_fprs;\n+\n+} CUMULATIVE_ARGS;\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+  memset (&(CUM), 0, sizeof (CUM))\n+\n+#define EPILOGUE_USES(REGNO) loongarch_epilogue_uses (REGNO)\n+\n+/* Treat LOC as a byte offset from the stack pointer and round it up\n+   to the next fully-aligned offset.  */\n+#define LARCH_STACK_ALIGN(LOC) \\\n+  (TARGET_ABI_LP64 ? ROUND_UP ((LOC), 16) : ROUND_UP ((LOC), 8))\n+\n+#define MCOUNT_NAME \"_mcount\"\n+\n+/* Emit rtl for profiling.  Output assembler code to FILE\n+   to call \"_mcount\" for profiling a function entry.  */\n+#define PROFILE_HOOK(LABEL) \\\n+  { \\\n+    rtx fun, ra; \\\n+    ra = get_hard_reg_initial_val (Pmode, RETURN_ADDR_REGNUM); \\\n+    fun = gen_rtx_SYMBOL_REF (Pmode, MCOUNT_NAME); \\\n+    emit_library_call (fun, LCT_NORMAL, VOIDmode, ra, Pmode); \\\n+  }\n+\n+/* All the work done in PROFILE_HOOK, but still required.  */\n+#define FUNCTION_PROFILER(STREAM, LABELNO) do { } while (0)\n+\n+#define NO_PROFILE_COUNTERS 1\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Trampolines are a block of code followed by two pointers.  */\n+\n+#define TRAMPOLINE_CODE_SIZE 16\n+#define TRAMPOLINE_SIZE \\\n+  ((Pmode == SImode) ? TRAMPOLINE_CODE_SIZE \\\n+\t\t     : (TRAMPOLINE_CODE_SIZE + POINTER_SIZE * 2))\n+#define TRAMPOLINE_ALIGNMENT POINTER_SIZE\n+\n+/* loongarch_trampoline_init calls this library function to flush\n+   program and data caches.  */\n+\n+#ifndef CACHE_FLUSH_FUNC\n+#define CACHE_FLUSH_FUNC \"_flush_cache\"\n+#endif\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  loongarch_regno_mode_ok_for_base_p (REGNO, VOIDmode, 1)\n+\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) \\\n+  loongarch_regno_mode_ok_for_base_p (REGNO, MODE, 1)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Check for constness inline but use loongarch_legitimate_address_p\n+   to check whether a constant really is an address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) (CONSTANT_P (X) && memory_address_p (SImode, X))\n+\n+/* This handles the magic '..CURRENT_FUNCTION' symbol, which means\n+   'the start of the function that this code is output in'.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+  do \\\n+    { \\\n+      if (strcmp (NAME, \"..CURRENT_FUNCTION\") == 0) \\\n+\tasm_fprintf ((FILE), \"%U%s\", \\\n+\t\t     XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n+      else \\\n+\tasm_fprintf ((FILE), \"%U%s\", (NAME)); \\\n+    } \\\n+  while (0)\n+\n+#define CASE_VECTOR_MODE Pmode\n+\n+#define CASE_VECTOR_SHORTEN_MODE(MIN, MAX, BODY) Pmode\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#ifndef DEFAULT_SIGNED_CHAR\n+#define DEFAULT_SIGNED_CHAR 1\n+#endif\n+\n+/* The SPARC port says:\n+   The maximum number of bytes that a single instruction\n+   can move quickly between memory and registers or between\n+   two memory locations.  */\n+#define MOVE_MAX UNITS_PER_WORD\n+#define MAX_MOVE_MAX 8\n+\n+/* The SPARC port says:\n+   Nonzero if access to memory by bytes is slow and undesirable.\n+   For RISC chips, it means that access to memory by bytes is no\n+   better than access by words when possible, so grab a whole word\n+   and maybe make use of that.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Standard LoongArch integer shifts truncate the shift amount to the\n+   width of the shifted operand.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+\n+#ifndef Pmode\n+#define Pmode (TARGET_64BIT ? DImode : SImode)\n+#endif\n+\n+/* Give call MEMs SImode since it is the \"most permissive\" mode\n+   for both 32-bit and 64-bit targets.  */\n+\n+#define FUNCTION_MODE SImode\n+\n+/* We allocate $fcc registers by hand and can't cope with moves of\n+   CCmode registers to and from pseudos (or memory).  */\n+#define AVOID_CCMODE_COPIES\n+\n+/* A C expression for the cost of a branch instruction.  A value of\n+   1 is the default; other values are interpreted relative to that.  */\n+\n+#define BRANCH_COST(speed_p, predictable_p) loongarch_branch_cost\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n+\n+/* Return the asm template for a conditional branch instruction.\n+   OPCODE is the opcode's mnemonic and OPERANDS is the asm template for\n+   its operands.  */\n+#define LARCH_BRANCH(OPCODE, OPERANDS) OPCODE \"\\t\" OPERANDS\n+\n+/* Control the assembler format that we output.  */\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#ifndef ASM_APP_ON\n+#define ASM_APP_ON \" #APP\\n\"\n+#endif\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#ifndef ASM_APP_OFF\n+#define ASM_APP_OFF \" #NO_APP\\n\"\n+#endif\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t  \\\n+{ \"$r0\",   \"$r1\",   \"$r2\",   \"$r3\",   \"$r4\",   \"$r5\",   \"$r6\",   \"$r7\",   \\\n+  \"$r8\",   \"$r9\",   \"$r10\",  \"$r11\",  \"$r12\",  \"$r13\",  \"$r14\",  \"$r15\",  \\\n+  \"$r16\",  \"$r17\",  \"$r18\",  \"$r19\",  \"$r20\",  \"$r21\",  \"$r22\",  \"$r23\",  \\\n+  \"$r24\",  \"$r25\",  \"$r26\",  \"$r27\",  \"$r28\",  \"$r29\",  \"$r30\",  \"$r31\",  \\\n+  \"$f0\",  \"$f1\",  \"$f2\",  \"$f3\",  \"$f4\",  \"$f5\",  \"$f6\",  \"$f7\",\t  \\\n+  \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t  \\\n+  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t  \\\n+  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t  \\\n+  \"$fcc0\",\"$fcc1\",\"$fcc2\",\"$fcc3\",\"$fcc4\",\"$fcc5\",\"$fcc6\",\"$fcc7\",\t  \\\n+  \"$arg\", \"$frame\"}\n+\n+/* This macro defines additional names for hard registers.  */\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"zero\",\t 0 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"ra\",\t 1 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"tp\",\t 2 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"sp\",\t 3 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a0\",\t 4 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a1\",\t 5 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a2\",\t 6 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a3\",\t 7 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a4\",\t 8 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a5\",\t 9 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a6\",\t10 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"a7\",\t11 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t0\",\t12 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t1\",\t13 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t2\",\t14 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t3\",\t15 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t4\",\t16 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t5\",\t17 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t6\",\t18 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t7\",\t19 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"t8\",\t20 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"x\",\t21 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"fp\",\t22 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s0\",\t23 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s1\",\t24 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s2\",\t25 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s3\",\t26 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s4\",\t27 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s5\",\t28 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s6\",\t29 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s7\",\t30 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"s8\",\t31 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"v0\",\t 4 + GP_REG_FIRST },\t\t\t\t\t\\\n+  { \"v1\",\t 5 + GP_REG_FIRST }\t\t\t\t\t\\\n+}\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n+\n+/* This says how to output an external.  It would be possible not to\n+   output anything and let undefined symbol become external.  However\n+   the assembler uses length information on externals to allocate in\n+   data/sdata bss/sbss, thereby saving exec time.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL\n+#define ASM_OUTPUT_EXTERNAL(STREAM, DECL, NAME) \\\n+  loongarch_output_external (STREAM, DECL, NAME)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \\\n+  sprintf ((LABEL), \"*%s%s%ld\", (LOCAL_LABEL_PREFIX), (PREFIX), (long) (NUM))\n+\n+/* Print debug labels as \"foo = .\" rather than \"foo:\" because they should\n+   represent a byte pointer rather than an ISA-encoded address.  This is\n+   particularly important for code like:\n+\n+\t$LFBxxx = .\n+\t\t.cfi_startproc\n+\t\t...\n+\t\t.section .gcc_except_table,...\n+\t\t...\n+\t\t.uleb128 foo-$LFBxxx\n+\n+   The .uleb128 requies $LFBxxx to match the FDE start address, which is\n+   likewise a byte pointer rather than an ISA-encoded address.\n+\n+   At the time of writing, this hook is not used for the function end\n+   label:\n+\n+\t$LFExxx:\n+\t\t.end foo\n+\n+   */\n+\n+#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \\\n+  fprintf (FILE, \"%s%s%d = .\\n\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+  fprintf (STREAM, \"\\t%s\\t%sL%d\\n\", ptr_mode == DImode ? \".dword\" : \".word\", \\\n+\t   LOCAL_LABEL_PREFIX, VALUE)\n+\n+/* This is how to output an element of a case-vector.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL) \\\n+  do \\\n+    { \\\n+      fprintf (STREAM, \"\\t%s\\t%sL%d-%sL%d\\n\", \\\n+\t       ptr_mode == DImode ? \".dword\" : \".word\", LOCAL_LABEL_PREFIX, \\\n+\t       VALUE, LOCAL_LABEL_PREFIX, REL); \\\n+    } \\\n+  while (0)\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG) fprintf (STREAM, \"\\t.align\\t%d\\n\", (LOG))\n+\n+/* \"nop\" instruction 54525952 (andi $r0,$r0,0) is\n+   used for padding.  */\n+#define ASM_OUTPUT_ALIGN_WITH_NOP(STREAM, LOG) \\\n+  fprintf (STREAM, \"\\t.align\\t%d,54525952,4\\n\", (LOG))\n+\n+/* This is how to output an assembler line to advance the location\n+   counter by SIZE bytes.  */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(STREAM, SIZE) \\\n+  fprintf (STREAM, \"\\t.space\\t\" HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\", (SIZE))\n+\n+/* This is how to output a string.  */\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII loongarch_output_ascii\n+\n+/* Define the strings to put out for each section in the object file.  */\n+#define TEXT_SECTION_ASM_OP \"\\t.text\" /* instructions  */\n+#define DATA_SECTION_ASM_OP \"\\t.data\" /* large data  */\n+\n+#undef READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP \"\\t.section\\t.rodata\" /* read-only data */\n+\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)\t\\\n+  do \\\n+    { \\\n+      fprintf (STREAM, \"\\t%s\\t%s,%s,-8\\n\\t%s\\t%s,%s,0\\n\", \\\n+\t       TARGET_64BIT ? \"addi.d\" : \"addi.w\", \\\n+\t       reg_names[STACK_POINTER_REGNUM], \\\n+\t       reg_names[STACK_POINTER_REGNUM], \\\n+\t       TARGET_64BIT ? \"st.d\" : \"st.w\", reg_names[REGNO], \\\n+\t       reg_names[STACK_POINTER_REGNUM]); \\\n+    } \\\n+  while (0)\n+\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO) \\\n+  do \\\n+    { \\\n+      fprintf (STREAM, \"\\t%s\\t%s,%s,0\\n\\t%s\\t%s,%s,8\\n\", \\\n+\t       TARGET_64BIT ? \"ld.d\" : \"ld.w\", reg_names[REGNO], \\\n+\t       reg_names[STACK_POINTER_REGNUM], \\\n+\t       TARGET_64BIT ? \"addi.d\" : \"addi.w\", \\\n+\t       reg_names[STACK_POINTER_REGNUM], \\\n+\t       reg_names[STACK_POINTER_REGNUM]); \\\n+    } \\\n+  while (0)\n+\n+/* How to start an assembler comment.\n+   The leading space is important (the loongarch native assembler requires it).\n+ */\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \" #\"\n+#endif\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE (POINTER_SIZE == 64 ? \"long unsigned int\" : \"unsigned int\")\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n+\n+/* The maximum number of bytes that can be copied by one iteration of\n+   a cpymemsi loop; see loongarch_block_move_loop.  */\n+#define LARCH_MAX_MOVE_BYTES_PER_LOOP_ITER (UNITS_PER_WORD * 4)\n+\n+/* The maximum number of bytes that can be copied by a straight-line\n+   implementation of cpymemsi; see loongarch_block_move_straight.  We want\n+   to make sure that any loop-based implementation will iterate at\n+   least twice.  */\n+#define LARCH_MAX_MOVE_BYTES_STRAIGHT (LARCH_MAX_MOVE_BYTES_PER_LOOP_ITER * 2)\n+\n+/* The base cost of a memcpy call, for MOVE_RATIO and friends.  These\n+   values were determined experimentally by benchmarking with CSiBE.\n+*/\n+#define LARCH_CALL_RATIO 8\n+\n+/* Any loop-based implementation of cpymemsi will have at least\n+   LARCH_MAX_MOVE_BYTES_STRAIGHT / UNITS_PER_WORD memory-to-memory\n+   moves, so allow individual copies of fewer elements.\n+\n+   When cpymemsi is not available, use a value approximating\n+   the length of a memcpy call sequence, so that move_by_pieces\n+   will generate inline code if it is shorter than a function call.\n+   Since move_by_pieces_ninsns counts memory-to-memory moves, but\n+   we'll have to generate a load/store pair for each, halve the\n+   value of LARCH_CALL_RATIO to take that into account.  */\n+\n+#define MOVE_RATIO(speed) \\\n+  (HAVE_cpymemsi \\\n+   ? LARCH_MAX_MOVE_BYTES_PER_LOOP_ITER / UNITS_PER_WORD \\\n+   : CLEAR_RATIO (speed) / 2)\n+\n+/* For CLEAR_RATIO, when optimizing for size, give a better estimate\n+   of the length of a memset call, but use the default otherwise.  */\n+\n+#define CLEAR_RATIO(speed) ((speed) ? 15 : LARCH_CALL_RATIO)\n+\n+/* This is similar to CLEAR_RATIO, but for a non-zero constant, so when\n+   optimizing for size adjust the ratio to account for the overhead of\n+   loading the constant and replicating it across the word.  */\n+\n+#define SET_RATIO(speed) ((speed) ? 15 : LARCH_CALL_RATIO - 2)\n+\n+#ifndef USED_FOR_TARGET\n+extern const enum reg_class loongarch_regno_to_class[];\n+extern int loongarch_dwarf_regno[];\n+\n+/* Information about a function's frame layout.  */\n+struct GTY (()) loongarch_frame_info\n+{\n+  /* The size of the frame in bytes.  */\n+  HOST_WIDE_INT total_size;\n+\n+  /* Bit X is set if the function saves or restores GPR X.  */\n+  unsigned int mask;\n+\n+  /* Likewise FPR X.  */\n+  unsigned int fmask;\n+\n+  /* How much the GPR save/restore routines adjust sp (or 0 if unused).  */\n+  unsigned save_libcall_adjustment;\n+\n+  /* Offsets of fixed-point and floating-point save areas from frame\n+     bottom.  */\n+  HOST_WIDE_INT gp_sp_offset;\n+  HOST_WIDE_INT fp_sp_offset;\n+\n+  /* Offset of virtual frame pointer from stack pointer/frame bottom.  */\n+  HOST_WIDE_INT frame_pointer_offset;\n+\n+  /* Offset of hard frame pointer from stack pointer/frame bottom.  */\n+  HOST_WIDE_INT hard_frame_pointer_offset;\n+\n+  /* The offset of arg_pointer_rtx from the bottom of the frame.  */\n+  HOST_WIDE_INT arg_pointer_offset;\n+};\n+\n+struct GTY (()) machine_function\n+{\n+  /* The next floating-point condition-code register to allocate\n+     for 8CC targets, relative to FCC_REG_FIRST.  */\n+  unsigned int next_fcc;\n+\n+  /* The number of extra stack bytes taken up by register varargs.\n+     This area is allocated by the callee at the very top of the frame.  */\n+  int varargs_size;\n+\n+  /* The current frame information, calculated by loongarch_compute_frame_info.\n+   */\n+  struct loongarch_frame_info frame;\n+};\n+#endif\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \\\n+  (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_absptr)\n+\n+/* Do emit .note.GNU-stack by default.  */\n+#ifndef NEED_INDICATE_EXEC_STACK\n+#define NEED_INDICATE_EXEC_STACK 1\n+#endif\n+\n+/* The `Q' extension is not yet supported.  */\n+/* TODO: according to march.  */\n+#define UNITS_PER_FP_REG (TARGET_DOUBLE_FLOAT ? 8 : 4)\n+\n+/* The largest type that can be passed in floating-point registers.  */\n+/* TODO: according to mabi.  */\n+#define UNITS_PER_FP_ARG  \\\n+  (TARGET_HARD_FLOAT ? (TARGET_DOUBLE_FLOAT ? 8 : 4) : 0)\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN || (N) == FP_RETURN)"}]}