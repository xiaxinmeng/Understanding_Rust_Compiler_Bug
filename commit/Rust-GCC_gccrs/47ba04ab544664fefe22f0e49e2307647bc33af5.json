{"sha": "47ba04ab544664fefe22f0e49e2307647bc33af5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiYTA0YWI1NDQ2NjRmZWZlMjJmMGU0OWUyMzA3NjQ3YmMzM2FmNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-22T02:59:24Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-22T02:59:24Z"}, "message": "Avoid crash when M structure free just before thread exit.\n\nFrom-SVN: r169121", "tree": {"sha": "58887361507ba23f1681fa01255148350d978908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58887361507ba23f1681fa01255148350d978908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ba04ab544664fefe22f0e49e2307647bc33af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ba04ab544664fefe22f0e49e2307647bc33af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ba04ab544664fefe22f0e49e2307647bc33af5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ba04ab544664fefe22f0e49e2307647bc33af5/comments", "author": null, "committer": null, "parents": [{"sha": "039868965d6679379f1b87b7336986605229430b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039868965d6679379f1b87b7336986605229430b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039868965d6679379f1b87b7336986605229430b"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "8c2de2877cf0936862dab99b33e1895112d0b094", "filename": "libgo/runtime/go-go.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ba04ab544664fefe22f0e49e2307647bc33af5/libgo%2Fruntime%2Fgo-go.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ba04ab544664fefe22f0e49e2307647bc33af5/libgo%2Fruntime%2Fgo-go.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-go.c?ref=47ba04ab544664fefe22f0e49e2307647bc33af5", "patch": "@@ -94,6 +94,13 @@ remove_current_thread (void)\n \n   runtime_MCache_ReleaseAll (mcache);\n \n+  /* As soon as we release this look, a GC could run.  Since this\n+     thread is no longer on the list, the GC will not find our M\n+     structure, so it could get freed at any time.  That means that\n+     any code from here to thread exit must not assume that the m is\n+     valid.  */\n+  m = NULL;\n+\n   i = pthread_mutex_unlock (&__go_thread_ids_lock);\n   __go_assert (i == 0);\n "}, {"sha": "c4e7f6c72e04841b07f711d7e7e6661d954803c0", "filename": "libgo/runtime/thread.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ba04ab544664fefe22f0e49e2307647bc33af5/libgo%2Fruntime%2Fthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ba04ab544664fefe22f0e49e2307647bc33af5/libgo%2Fruntime%2Fthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread.c?ref=47ba04ab544664fefe22f0e49e2307647bc33af5", "patch": "@@ -38,9 +38,11 @@ runtime_lock_full(Lock *l)\n void\n runtime_lock(Lock *l)\n {\n-\tif(m->locks < 0)\n-\t\truntime_throw(\"lock count\");\n-\tm->locks++;\n+\tif(m != nil) {\n+\t\tif(m->locks < 0)\n+\t\t\truntime_throw(\"lock count\");\n+\t\tm->locks++;\n+\t}\n \n \tif(runtime_xadd(&l->key, 1) > 1)\t// someone else has it; wait\n \t\truntime_lock_full(l);\n@@ -58,9 +60,11 @@ runtime_unlock_full(Lock *l)\n void\n runtime_unlock(Lock *l)\n {\n-\tm->locks--;\n-\tif(m->locks < 0)\n-\t\truntime_throw(\"lock count\");\n+\tif(m != nil) {\n+\t\tm->locks--;\n+\t\tif(m->locks < 0)\n+\t\t\truntime_throw(\"lock count\");\n+\t}\n \n \tif(runtime_xadd(&l->key, -1) > 0)\t// someone else is waiting\n \t\truntime_unlock_full(l);"}]}