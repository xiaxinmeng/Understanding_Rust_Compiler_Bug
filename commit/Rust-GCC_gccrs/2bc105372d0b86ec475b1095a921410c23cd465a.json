{"sha": "2bc105372d0b86ec475b1095a921410c23cd465a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJjMTA1MzcyZDBiODZlYzQ3NWIxMDk1YTkyMTQxMGMyM2NkNDY1YQ==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-08-01T02:52:30Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-08-01T02:52:30Z"}, "message": "Convert tree-ssa-dom to inchash\n\ngcc/:\n\n2014-07-31  Andi Kleen  <ak@linux.intel.com>\n\n\t* tree-ssa-dom.c (iterative_hash_exprs_commutative):\n\tRename to inchash:add_expr_commutative. Convert to inchash.\n\t(iterative_hash_hashable_expr): Rename to\n\tinchash:add_hashable_expr. Convert to inchash.\n\t(avail_expr_hash): Dito.\n\nFrom-SVN: r213398", "tree": {"sha": "431289a6ad31e311e2e6d9828944f898a33674a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/431289a6ad31e311e2e6d9828944f898a33674a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bc105372d0b86ec475b1095a921410c23cd465a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc105372d0b86ec475b1095a921410c23cd465a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc105372d0b86ec475b1095a921410c23cd465a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc105372d0b86ec475b1095a921410c23cd465a/comments", "author": null, "committer": null, "parents": [{"sha": "d313d45fe1f4eb419affc4f29c5ea32608f1e5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d313d45fe1f4eb419affc4f29c5ea32608f1e5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d313d45fe1f4eb419affc4f29c5ea32608f1e5e3"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "2f68593cfd698052894fda998ab571e38ba6a336", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc105372d0b86ec475b1095a921410c23cd465a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc105372d0b86ec475b1095a921410c23cd465a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bc105372d0b86ec475b1095a921410c23cd465a", "patch": "@@ -1,3 +1,11 @@\n+2014-07-31  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* tree-ssa-dom.c (iterative_hash_exprs_commutative):\n+\tRename to inchash:add_expr_commutative. Convert to inchash.\n+\t(iterative_hash_hashable_expr): Rename to\n+\tinchash:add_hashable_expr. Convert to inchash.\n+\t(avail_expr_hash): Dito.\n+\n 2014-07-31  Andi Kleen  <ak@linux.intel.com>\n \n \t* ipa-devirt.c (polymorphic_call_target_hasher::hash):"}, {"sha": "fec386e3152bcf69c65a7af77ca932cb4d3a7a35", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc105372d0b86ec475b1095a921410c23cd465a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc105372d0b86ec475b1095a921410c23cd465a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=2bc105372d0b86ec475b1095a921410c23cd465a", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-dom.h\"\n+#include \"inchash.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -557,80 +558,77 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n }\n \n /* Generate a hash value for a pair of expressions.  This can be used\n-   iteratively by passing a previous result as the VAL argument.\n+   iteratively by passing a previous result in HSTATE.\n \n    The same hash value is always returned for a given pair of expressions,\n    regardless of the order in which they are presented.  This is useful in\n    hashing the operands of commutative functions.  */\n \n-static hashval_t\n-iterative_hash_exprs_commutative (const_tree t1,\n-                                  const_tree t2, hashval_t val)\n+namespace inchash\n {\n-  hashval_t one = iterative_hash_expr (t1, 0);\n-  hashval_t two = iterative_hash_expr (t2, 0);\n-  hashval_t t;\n \n-  if (one > two)\n-    t = one, one = two, two = t;\n-  val = iterative_hash_hashval_t (one, val);\n-  val = iterative_hash_hashval_t (two, val);\n+static void\n+add_expr_commutative (const_tree t1, const_tree t2, hash &hstate)\n+{\n+  hash one, two;\n \n-  return val;\n+  inchash::add_expr (t1, one);\n+  inchash::add_expr (t2, two);\n+  hstate.add_commutative (one, two);\n }\n \n /* Compute a hash value for a hashable_expr value EXPR and a\n    previously accumulated hash value VAL.  If two hashable_expr\n    values compare equal with hashable_expr_equal_p, they must\n    hash to the same value, given an identical value of VAL.\n-   The logic is intended to follow iterative_hash_expr in tree.c.  */\n+   The logic is intended to follow inchash::add_expr in tree.c.  */\n \n-static hashval_t\n-iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n+static void\n+add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n {\n   switch (expr->kind)\n     {\n     case EXPR_SINGLE:\n-      val = iterative_hash_expr (expr->ops.single.rhs, val);\n+      inchash::add_expr (expr->ops.single.rhs, hstate);\n       break;\n \n     case EXPR_UNARY:\n-      val = iterative_hash_object (expr->ops.unary.op, val);\n+      hstate.add_object (expr->ops.unary.op);\n \n       /* Make sure to include signedness in the hash computation.\n          Don't hash the type, that can lead to having nodes which\n          compare equal according to operand_equal_p, but which\n          have different hash codes.  */\n       if (CONVERT_EXPR_CODE_P (expr->ops.unary.op)\n           || expr->ops.unary.op == NON_LVALUE_EXPR)\n-        val += TYPE_UNSIGNED (expr->type);\n+        hstate.add_int (TYPE_UNSIGNED (expr->type));\n \n-      val = iterative_hash_expr (expr->ops.unary.opnd, val);\n+      inchash::add_expr (expr->ops.unary.opnd, hstate);\n       break;\n \n     case EXPR_BINARY:\n-      val = iterative_hash_object (expr->ops.binary.op, val);\n+      hstate.add_object (expr->ops.binary.op);\n       if (commutative_tree_code (expr->ops.binary.op))\n-\tval = iterative_hash_exprs_commutative (expr->ops.binary.opnd0,\n-\t\t\t\t\t\texpr->ops.binary.opnd1, val);\n+\tinchash::add_expr_commutative (expr->ops.binary.opnd0,\n+\t\t\t\t\t  expr->ops.binary.opnd1, hstate);\n       else\n         {\n-          val = iterative_hash_expr (expr->ops.binary.opnd0, val);\n-          val = iterative_hash_expr (expr->ops.binary.opnd1, val);\n+          inchash::add_expr (expr->ops.binary.opnd0, hstate);\n+          inchash::add_expr (expr->ops.binary.opnd1, hstate);\n         }\n       break;\n \n     case EXPR_TERNARY:\n-      val = iterative_hash_object (expr->ops.ternary.op, val);\n+      hstate.add_object (expr->ops.ternary.op);\n       if (commutative_ternary_tree_code (expr->ops.ternary.op))\n-\tval = iterative_hash_exprs_commutative (expr->ops.ternary.opnd0,\n-\t\t\t\t\t\texpr->ops.ternary.opnd1, val);\n+\tinchash::add_expr_commutative (expr->ops.ternary.opnd0,\n+\t\t\t\t\t  expr->ops.ternary.opnd1, hstate);\n       else\n         {\n-          val = iterative_hash_expr (expr->ops.ternary.opnd0, val);\n-          val = iterative_hash_expr (expr->ops.ternary.opnd1, val);\n+          inchash::add_expr (expr->ops.ternary.opnd0, hstate);\n+          inchash::add_expr (expr->ops.ternary.opnd1, hstate);\n         }\n-      val = iterative_hash_expr (expr->ops.ternary.opnd2, val);\n+      inchash::add_expr (expr->ops.ternary.opnd2, hstate);\n       break;\n \n     case EXPR_CALL:\n@@ -639,15 +637,14 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n         enum tree_code code = CALL_EXPR;\n         gimple fn_from;\n \n-        val = iterative_hash_object (code, val);\n+        hstate.add_object (code);\n         fn_from = expr->ops.call.fn_from;\n         if (gimple_call_internal_p (fn_from))\n-          val = iterative_hash_hashval_t\n-            ((hashval_t) gimple_call_internal_fn (fn_from), val);\n+          hstate.merge_hash ((hashval_t) gimple_call_internal_fn (fn_from));\n         else\n-          val = iterative_hash_expr (gimple_call_fn (fn_from), val);\n+          inchash::add_expr (gimple_call_fn (fn_from), hstate);\n         for (i = 0; i < expr->ops.call.nargs; i++)\n-          val = iterative_hash_expr (expr->ops.call.args[i], val);\n+          inchash::add_expr (expr->ops.call.args[i], hstate);\n       }\n       break;\n \n@@ -656,15 +653,15 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n         size_t i;\n \n         for (i = 0; i < expr->ops.phi.nargs; i++)\n-          val = iterative_hash_expr (expr->ops.phi.args[i], val);\n+          inchash::add_expr (expr->ops.phi.args[i], hstate);\n       }\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n+}\n \n-  return val;\n }\n \n /* Print a diagnostic dump of an expression hash table entry.  */\n@@ -2599,24 +2596,24 @@ avail_expr_hash (const void *p)\n   gimple stmt = ((const struct expr_hash_elt *)p)->stmt;\n   const struct hashable_expr *expr = &((const struct expr_hash_elt *)p)->expr;\n   tree vuse;\n-  hashval_t val = 0;\n+  inchash::hash hstate;\n \n-  val = iterative_hash_hashable_expr (expr, val);\n+  inchash::add_hashable_expr (expr, hstate);\n \n   /* If the hash table entry is not associated with a statement, then we\n      can just hash the expression and not worry about virtual operands\n      and such.  */\n   if (!stmt)\n-    return val;\n+    return hstate.end ();\n \n   /* Add the SSA version numbers of the vuse operand.  This is important\n      because compound variables like arrays are not renamed in the\n      operands.  Rather, the rename is done on the virtual variable\n      representing all the elements of the array.  */\n   if ((vuse = gimple_vuse (stmt)))\n-    val = iterative_hash_expr (vuse, val);\n+    inchash::add_expr (vuse, hstate);\n \n-  return val;\n+  return hstate.end ();\n }\n \n /* PHI-ONLY copy and constant propagation.  This pass is meant to clean"}]}