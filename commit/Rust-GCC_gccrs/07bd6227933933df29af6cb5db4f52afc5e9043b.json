{"sha": "07bd6227933933df29af6cb5db4f52afc5e9043b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiZDYyMjc5MzM5MzNkZjI5YWY2Y2I1ZGI0ZjUyYWZjNWU5MDQzYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-10-28T19:03:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-10-28T19:03:05Z"}, "message": "tree-ssa-operands.c (add_vars_for_offset): Clean and speed up.\n\n2007-10-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-operands.c (add_vars_for_offset): Clean and speed up.\n\t(add_vars_for_bitmap): Do not recurse further.  Only add vars\n\tfor pointed-to SFTs.\n\t(add_virtual_operand): Re-instantiate loop to add operands for\n\taliases.  Recurse into MPTs.\n\t(get_indirect_ref_operands): If we fall back to use a pointers\n\tSMT, make sure to not prune based on the access offset and size.\n\nFrom-SVN: r129702", "tree": {"sha": "dda74442edb40af0c50e67b12a86268365c4eeb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dda74442edb40af0c50e67b12a86268365c4eeb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07bd6227933933df29af6cb5db4f52afc5e9043b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bd6227933933df29af6cb5db4f52afc5e9043b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07bd6227933933df29af6cb5db4f52afc5e9043b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bd6227933933df29af6cb5db4f52afc5e9043b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5cb41805708de9784dd9ce6dfc88c0cd4f87af93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb41805708de9784dd9ce6dfc88c0cd4f87af93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cb41805708de9784dd9ce6dfc88c0cd4f87af93"}], "stats": {"total": 115, "additions": 69, "deletions": 46}, "files": [{"sha": "cf2b27d0461ec72be3173f1a5da0eb924b0fe871", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bd6227933933df29af6cb5db4f52afc5e9043b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bd6227933933df29af6cb5db4f52afc5e9043b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07bd6227933933df29af6cb5db4f52afc5e9043b", "patch": "@@ -1,3 +1,13 @@\n+2007-10-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-operands.c (add_vars_for_offset): Clean and speed up.\n+\t(add_vars_for_bitmap): Do not recurse further.  Only add vars\n+\tfor pointed-to SFTs.\n+\t(add_virtual_operand): Re-instantiate loop to add operands for\n+\taliases.  Recurse into MPTs.\n+\t(get_indirect_ref_operands): If we fall back to use a pointers\n+\tSMT, make sure to not prune based on the access offset and size.\n+\n 2007-10-28  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR tree-opt/33589"}, {"sha": "d5d3cbea5340a4671c7ac68c00f6d26468da4c31", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bd6227933933df29af6cb5db4f52afc5e9043b/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bd6227933933df29af6cb5db4f52afc5e9043b/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=07bd6227933933df29af6cb5db4f52afc5e9043b", "patch": "@@ -1392,23 +1392,27 @@ static bool\n add_vars_for_offset (tree full_ref, tree var, HOST_WIDE_INT offset,\n \t\t     HOST_WIDE_INT size, bool is_call_site, bool is_def)\n {\n+  bool added = false;\n+  subvar_t sv;\n+  unsigned int i;\n+  tree subvar;\n+\n+\n   /* Call-clobbered tags may have non-call-clobbered\n      symbols in their alias sets.  Ignore them if we are\n      adding VOPs for a call site.  */\n   if (is_call_site && !is_call_clobbered (var))\n     return false;\n \n-  /* For offset 0, we already have the right variable.  If there is no\n-     full_ref, this is not a place we care about (All component\n-     related accesses that go through pointers will have full_ref not\n-     NULL).\n-     Any var for which we didn't create SFT's can't be\n-     distinguished.  */\n-  if (!full_ref || (offset == 0 && size != -1)\n-      || (TREE_CODE (var) != STRUCT_FIELD_TAG\n-\t  && (!var_can_have_subvars (var) || !get_subvars_for_var (var))))\n-    {\n-      if (!access_can_touch_variable (full_ref, var, offset, size))\n+  /* For SFTs we have to consider all subvariables of the parent var.  */\n+  if (TREE_CODE (var) != STRUCT_FIELD_TAG)\n+    {\n+      /* If we do not know the full reference tree or if the access is\n+\t unspecified [0, -1], we cannot prune it.  Otherwise try doing\n+\t so using access_can_touch_variable.  */\n+      if (full_ref\n+\t  && !(offset == 0 && size == -1)\n+\t  && !access_can_touch_variable (full_ref, var, offset, size))\n \treturn false;\n \n       if (is_def)\n@@ -1417,40 +1421,33 @@ add_vars_for_offset (tree full_ref, tree var, HOST_WIDE_INT offset,\n \tappend_vuse (var);\n       return true;\n     }\n-  else if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n-    {      \n-      bool added = false;\n-      subvar_t sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n-      unsigned int i;\n-      tree subvar;\n \n-      for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n+  sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n+  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n+    {\n+      /* Once we hit the end of the parts that could touch,\n+\t stop looking.  */\n+      if (size != -1\n+\t  && SFT_OFFSET (var) + offset + size <= SFT_OFFSET (subvar))\n+\tbreak;\n+      if (overlap_subvar (SFT_OFFSET (var) + offset, size, subvar, NULL))\n \t{\n-\t  /* Once we hit the end of the parts that could touch,\n-\t     stop looking.  */\n-\t  if (size != -1\n-\t      && SFT_OFFSET (var) + offset + size <= SFT_OFFSET (subvar))\n-\t    break;\n-\t  if (overlap_subvar (SFT_OFFSET (var) + offset, size, subvar, NULL))\n-\t    {\n-\t      added = true;\n-\t      if (is_def)\n-\t\tappend_vdef (subvar);\n-\t      else\n-\t\tappend_vuse (subvar);\n-\t    }\n+\t  added = true;\n+\t  if (is_def)\n+\t    append_vdef (subvar);\n+\t  else\n+\t    append_vuse (subvar);\n \t}\n-      return added;\n     }\n-  \n-  return false;\n+  return added;\n }\n \n-/* Add all aliases from ALIASES as virtual operands for the access\n-   FULL_REF at OFFSET and size SIZE.  IS_CALL_SITE is true if the\n-   stmt of the reference is a call.  IS_DEF is true if we should add\n-   VDEF virtual operands, otherwise we'll add VUSEs.  *NONE_ADDED\n-   is set to false once the first virtual operand was added.  */\n+/* Consider all SFTs in ALIASES as points-to location and add virtual\n+   operands for the SFT parent var for the access FULL_REF at OFFSET\n+   and size SIZE.  IS_CALL_SITE is true if the stmt of the reference is\n+   a call.  IS_DEF is true if we should add VDEF virtual operands,\n+   otherwise we'll add VUSEs.  *NONE_ADDED is set to false once the first\n+   virtual operand was added.  */\n \n static void\n add_vars_for_bitmap (bitmap aliases, tree full_ref,\n@@ -1464,10 +1461,9 @@ add_vars_for_bitmap (bitmap aliases, tree full_ref,\n     {\n       tree al = referenced_var (i);\n \n-      if (TREE_CODE (al) == MEMORY_PARTITION_TAG)\n-\tadd_vars_for_bitmap (MPT_SYMBOLS (al), full_ref,\n-\t\t\t     offset, size, is_call_site, is_def, none_added);\n-      else\n+      gcc_assert (TREE_CODE (al) != MEMORY_PARTITION_TAG);\n+\n+      if (TREE_CODE (al) == STRUCT_FIELD_TAG)\n \t*none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n \t\t\t\t\t     is_call_site, is_def);\n     }\n@@ -1535,14 +1531,28 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n     }\n   else\n     {\n+      bitmap_iterator bi;\n+      unsigned int i;\n       bool none_added = true;\n       \n       /* The variable is aliased.  Add its aliases to the virtual\n \t operands.  */\n       gcc_assert (!bitmap_empty_p (aliases));\n \n-      add_vars_for_bitmap (aliases, full_ref, offset, size,\n-\t\t\t   is_call_site, flags & opf_def, &none_added);\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n+\t{\n+\t  tree al = referenced_var (i);\n+\n+\t  /* We have to consider SFTs inside MPTs as possible pointed-to\n+\t     location as well because even if aliases does not contain\n+\t     a single SFT, the SFTs inside the MPT may be incomplete in\n+\t     that not all aliased subvars have to be in this MPT, too.  */\n+\t  if (TREE_CODE (al) == MEMORY_PARTITION_TAG)\n+\t    add_vars_for_bitmap (MPT_SYMBOLS (al), full_ref, offset, size,\n+\t\t\t\t is_call_site, flags & opf_def, &none_added);\n+\t  none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n+\t\t\t\t\t      is_call_site, flags & opf_def);\n+\t}\n \n       if (flags & opf_def)\n \t{\n@@ -1680,9 +1690,12 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n \t    ptr = SSA_NAME_VAR (ptr);\n \t  v_ann = var_ann (ptr);\n \n+\t  /* If we don't know what this pointer points to then we have\n+\t     to make sure to not prune virtual operands based on offset\n+\t     and size.  */\n \t  if (v_ann->symbol_mem_tag)\n \t    add_virtual_operand (v_ann->symbol_mem_tag, s_ann, flags,\n-\t\t\t\t full_ref, offset, size, false);\n+\t\t\t\t full_ref, 0, -1, false);\n \n \t  /* Aliasing information is missing; mark statement as\n \t     volatile so we won't optimize it out too actively.  */"}]}