{"sha": "d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhOWU3YzUwYzhiMmU4OTdhMWRmZDgyOGY0Mzg3ZDI4NDgxYmQzMQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2009-09-15T20:12:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-09-15T20:12:18Z"}, "message": "re PR target/41175 (-Os generates significantly larger code)\n\n\tPR target/41175\n\tPR target/40677\n\t* config/rs6000/rs6000.c (no_global_regs_above): Fix precedence\n\tproblem.\n\t(SAVRES_NOINLINE_GPRS_SAVES_LR, SAVRES_NOINLINE_FPRS_SAVES_LR,\n\tSAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR): New strategy bits.\n\t(rs6000_savres_strategy): Always save FP registers inline if the\n\ttarget doesn't support hardware double-precision.  Set the above\n\tbits in return value when needed.\n\t(rs6000_savres_routine_sym): Fix computation for cache selector.\n\tMark the generated symbol as a function.  Rename exitp argument to\n\tlr.  Move code for determining the name of the symbol...\n\t(rs6000_savres_routine_name): ...here.  New function.  Add cases for\n\tgetting the names right on AIX and 64-bit Linux.\n\t(savres_routine_name): New variable.\n\t(rs6000_make_savres_rtx): Rename exitp argument to lr.  Don't assert\n\tlr isn't set when savep.  Use r12 resp. r1 instead of r11 depending\n\ton what the target routine uses as a base register.  If savep && lr\n\tdescribe saving of r0 into memory slot.\n\t(rs6000_emit_prologue): Correct use of call_used_regs.  Fix out of\n\tline calls for AIX ABI.\n\t(rs6000_output_function_prologue): Use rs6000_savres_routine_name to\n\tdetermine FP save/restore functions.\n\t(rs6000_emit_stack_reset): Handle savres if sp_offset != 0 and\n\tframe_reg_rtx != sp_reg_rtx.  Use gen_add3_insn instead of\n\tgen_addsi3.\n\t(rs6000_emit_epilogue): Adjust computation of restore_lr.\n\tDuplicate restoration of LR and execute the appropriate one\n\tdepending on whether GPRs are being restored inline.  Set r11 from\n\toffsetted frame_reg_rtx instead of sp_reg_rtx; if frame_reg_rtx is\n\tr11, adjust sp_offset.  Use gen_add3_insn instead of gen_addsi3.\n\tFix out of line calls for AIX ABI.\n\t* config/rs6000/rs6000.md (*return_and_restore_fpregs_aix_<mode>):\n\tNew insn.\n\t* config/rs6000/spe.md (*save_gpregs_spe): Use explicit match for\n\tregister 11.\n\t(*restore_gpregs_spe): Likewise.\n\t(*return_and_restore_gpregs_spe): Likewise.\n\t* config/rs6000/linux64.h (SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX):\n\tDefine to empty string unconditionally.\n\t* config/rs6000/sysv4.h (SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX):\n\tDefine to empty string unconditionally.\n\t(GP_SAVE_INLINE, FP_SAVE_INLINE): Handle TARGET_64BIT the same as\n\t!TARGET_64BIT.\n\n\t* gcc.target/powerpc/pr41175.c: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r151729", "tree": {"sha": "a84df7bde0c5ff1655a8977c33d2322032e68bcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a84df7bde0c5ff1655a8977c33d2322032e68bcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/comments", "author": null, "committer": null, "parents": [{"sha": "c7d68c96b4b27b46e26414dc0f47cde3be7d0a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7d68c96b4b27b46e26414dc0f47cde3be7d0a71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7d68c96b4b27b46e26414dc0f47cde3be7d0a71"}], "stats": {"total": 892, "additions": 789, "deletions": 103}, "files": [{"sha": "8afcfd8f66ab77b0227ff100ca84502537c4a929", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -1,3 +1,51 @@\n+2009-09-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/41175\n+\tPR target/40677\n+\t* config/rs6000/rs6000.c (no_global_regs_above): Fix precedence\n+\tproblem.\n+\t(SAVRES_NOINLINE_GPRS_SAVES_LR, SAVRES_NOINLINE_FPRS_SAVES_LR,\n+\tSAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR): New strategy bits.\n+\t(rs6000_savres_strategy): Always save FP registers inline if the\n+\ttarget doesn't support hardware double-precision.  Set the above\n+\tbits in return value when needed.\n+\t(rs6000_savres_routine_sym): Fix computation for cache selector.\n+\tMark the generated symbol as a function.  Rename exitp argument to\n+\tlr.  Move code for determining the name of the symbol...\n+\t(rs6000_savres_routine_name): ...here.  New function.  Add cases for\n+\tgetting the names right on AIX and 64-bit Linux.\n+\t(savres_routine_name): New variable.\n+\t(rs6000_make_savres_rtx): Rename exitp argument to lr.  Don't assert\n+\tlr isn't set when savep.  Use r12 resp. r1 instead of r11 depending\n+\ton what the target routine uses as a base register.  If savep && lr\n+\tdescribe saving of r0 into memory slot.\n+\t(rs6000_emit_prologue): Correct use of call_used_regs.  Fix out of\n+\tline calls for AIX ABI.\n+\t(rs6000_output_function_prologue): Use rs6000_savres_routine_name to\n+\tdetermine FP save/restore functions.\n+\t(rs6000_emit_stack_reset): Handle savres if sp_offset != 0 and\n+\tframe_reg_rtx != sp_reg_rtx.  Use gen_add3_insn instead of\n+\tgen_addsi3.\n+\t(rs6000_emit_epilogue): Adjust computation of restore_lr.\n+\tDuplicate restoration of LR and execute the appropriate one\n+\tdepending on whether GPRs are being restored inline.  Set r11 from\n+\toffsetted frame_reg_rtx instead of sp_reg_rtx; if frame_reg_rtx is\n+\tr11, adjust sp_offset.  Use gen_add3_insn instead of gen_addsi3.\n+\tFix out of line calls for AIX ABI.\n+\t* config/rs6000/rs6000.md (*return_and_restore_fpregs_aix_<mode>):\n+\tNew insn.\n+\t* config/rs6000/spe.md (*save_gpregs_spe): Use explicit match for\n+\tregister 11.\n+\t(*restore_gpregs_spe): Likewise.\n+\t(*return_and_restore_gpregs_spe): Likewise.\n+\t* config/rs6000/linux64.h (SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX):\n+\tDefine to empty string unconditionally.\n+\t* config/rs6000/sysv4.h (SAVE_FP_SUFFIX, RESTORE_FP_SUFFIX):\n+\tDefine to empty string unconditionally.\n+\t(GP_SAVE_INLINE, FP_SAVE_INLINE): Handle TARGET_64BIT the same as\n+\t!TARGET_64BIT.\n+\n 2009-09-15  Jan Hubicka  <jh@suse.cz>\n \n \t* doc/invoke.texi (inline-insns-auto): Drop from 60 to 50."}, {"sha": "37148c6aec67fc480f745ea551cae80196b62f43", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -437,11 +437,11 @@ extern int dot_symbols;\n #undef  SAVE_FP_PREFIX\n #define SAVE_FP_PREFIX (TARGET_64BIT ? \"._savef\" : \"_savefpr_\")\n #undef  SAVE_FP_SUFFIX\n-#define SAVE_FP_SUFFIX (TARGET_64BIT ? \"\" : \"_l\")\n+#define SAVE_FP_SUFFIX \"\"\n #undef  RESTORE_FP_PREFIX\n #define RESTORE_FP_PREFIX (TARGET_64BIT ? \"._restf\" : \"_restfpr_\")\n #undef  RESTORE_FP_SUFFIX\n-#define RESTORE_FP_SUFFIX (TARGET_64BIT ? \"\" : \"_l\")\n+#define RESTORE_FP_SUFFIX \"\"\n \n /* Dwarf2 debugging.  */\n #undef  PREFERRED_DEBUGGING_TYPE"}, {"sha": "564b54073226e76c82866ec0a661b19158752b4c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 245, "deletions": 85, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -18033,7 +18033,8 @@ static bool\n no_global_regs_above (int first, bool gpr)\n {\n   int i;\n-  for (i = first; i < gpr ? 32 : 64 ; i++)\n+  int last = gpr ? 32 : 64;\n+  for (i = first; i < last; i++)\n     if (global_regs[i])\n       return false;\n   return true;\n@@ -18050,54 +18051,136 @@ no_global_regs_above (int first, bool gpr)\n \n static GTY(()) rtx savres_routine_syms[N_SAVRES_REGISTERS][8];\n \n-/* Return the symbol for an out-of-line register save/restore routine.\n+/* Temporary holding space for an out-of-line register save/restore\n+   routine name.  */\n+static char savres_routine_name[30];\n+\n+/* Return the name for an out-of-line register save/restore routine.\n+   We are saving/restoring GPRs if GPR is true.  */\n+\n+static char *\n+rs6000_savres_routine_name (rs6000_stack_t *info, int regno,\n+\t\t\t    bool savep, bool gpr, bool lr)\n+{\n+  const char *prefix = \"\";\n+  const char *suffix = \"\";\n+\n+  /* Different targets are supposed to define\n+     {SAVE,RESTORE}_FP_{PREFIX,SUFFIX} with the idea that the needed\n+     routine name could be defined with:\n+\n+     sprintf (name, \"%s%d%s\", SAVE_FP_PREFIX, regno, SAVE_FP_SUFFIX)\n+\n+     This is a nice idea in practice, but in reality, things are\n+     complicated in several ways:\n+\n+     - ELF targets have save/restore routines for GPRs.\n+\n+     - SPE targets use different prefixes for 32/64-bit registers, and\n+       neither of them fit neatly in the FOO_{PREFIX,SUFFIX} regimen.\n+\n+     - PPC64 ELF targets have routines for save/restore of GPRs that\n+       differ in what they do with the link register, so having a set\n+       prefix doesn't work.  (We only use one of the save routines at\n+       the moment, though.)\n+\n+     - PPC32 elf targets have \"exit\" versions of the restore routines\n+       that restore the link register and can save some extra space.\n+       These require an extra suffix.  (There are also \"tail\" versions\n+       of the restore routines and \"GOT\" versions of the save routines,\n+       but we don't generate those at present.  Same problems apply,\n+       though.)\n+\n+     We deal with all this by synthesizing our own prefix/suffix and\n+     using that for the simple sprintf call shown above.  */\n+  if (TARGET_SPE)\n+    {\n+      /* No floating point saves on the SPE.  */\n+      gcc_assert (gpr);\n+\n+      if (savep)\n+\tprefix = info->spe_64bit_regs_used ? \"_save64gpr_\" : \"_save32gpr_\";\n+      else\n+\tprefix = info->spe_64bit_regs_used ? \"_rest64gpr_\" : \"_rest32gpr_\";\n+\n+      if (lr)\n+\tsuffix = \"_x\";\n+    }\n+  else if (DEFAULT_ABI == ABI_V4)\n+    {\n+      if (TARGET_64BIT)\n+\tgoto aix_names;\n+\n+      if (gpr)\n+\tprefix = savep ? \"_savegpr_\" : \"_restgpr_\";\n+      else\n+\tprefix = savep ? \"_savefpr_\" : \"_restfpr_\";\n+\n+      if (lr)\n+\tsuffix = \"_x\";\n+    }\n+  else if (DEFAULT_ABI == ABI_AIX)\n+    {\n+#ifndef POWERPC_LINUX\n+      /* No out-of-line save/restore routines for GPRs on AIX.  */\n+      gcc_assert (!TARGET_AIX || !gpr);\n+#endif\n+\n+    aix_names:\n+      if (gpr)\n+\tprefix = (savep\n+\t\t  ? (lr ? \"_savegpr0_\" : \"_savegpr1_\")\n+\t\t  : (lr ? \"_restgpr0_\" : \"_restgpr1_\"));\n+#ifdef POWERPC_LINUX\n+      else if (lr)\n+\tprefix = (savep ? \"_savefpr_\" : \"_restfpr_\");\n+#endif\n+      else\n+\t{\n+\t  prefix = savep ? SAVE_FP_PREFIX : RESTORE_FP_PREFIX;\n+\t  suffix = savep ? SAVE_FP_SUFFIX : RESTORE_FP_SUFFIX;\n+\t}\n+    }\n+  else if (DEFAULT_ABI == ABI_DARWIN)\n+    sorry (\"Out-of-line save/restore routines not supported on Darwin\");\n+\n+  sprintf (savres_routine_name, \"%s%d%s\", prefix, regno, suffix);\n+\n+  return savres_routine_name;\n+}\n+\n+/* Return an RTL SYMBOL_REF for an out-of-line register save/restore routine.\n    We are saving/restoring GPRs if GPR is true.  */\n \n static rtx\n-rs6000_savres_routine_sym (rs6000_stack_t *info, bool savep, bool gpr, bool exitp)\n+rs6000_savres_routine_sym (rs6000_stack_t *info, bool savep,\n+\t\t\t   bool gpr, bool lr)\n {\n   int regno = gpr ? info->first_gp_reg_save : (info->first_fp_reg_save - 32);\n   rtx sym;\n   int select = ((savep ? 1 : 0) << 2\n-\t\t| (gpr\n-\t\t   /* On the SPE, we never have any FPRs, but we do have\n-\t\t      32/64-bit versions of the routines.  */\n-\t\t   ? (TARGET_SPE_ABI && info->spe_64bit_regs_used ? 1 : 0)\n-\t\t   : 0) << 1\n-\t\t| (exitp ? 1: 0));\n+\t\t| ((TARGET_SPE_ABI\n+\t\t    /* On the SPE, we never have any FPRs, but we do have\n+\t\t       32/64-bit versions of the routines.  */\n+\t\t    ? (info->spe_64bit_regs_used ? 1 : 0)\n+\t\t    : (gpr ? 1 : 0)) << 1)\n+\t\t| (lr ? 1: 0));\n \n   /* Don't generate bogus routine names.  */\n-  gcc_assert (FIRST_SAVRES_REGISTER <= regno && regno <= LAST_SAVRES_REGISTER);\n+  gcc_assert (FIRST_SAVRES_REGISTER <= regno\n+\t      && regno <= LAST_SAVRES_REGISTER);\n \n   sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select];\n \n   if (sym == NULL)\n     {\n-      char name[30];\n-      const char *action;\n-      const char *regkind;\n-      const char *exit_suffix;\n-\n-      action = savep ? \"save\" : \"rest\";\n+      char *name;\n \n-      /* SPE has slightly different names for its routines depending on\n-\t whether we are saving 32-bit or 64-bit registers.  */\n-      if (TARGET_SPE_ABI)\n-\t{\n-\t  /* No floating point saves on the SPE.  */\n-\t  gcc_assert (gpr);\n-\n-\t  regkind = info->spe_64bit_regs_used ? \"64gpr\" : \"32gpr\";\n-\t}\n-      else\n-\tregkind = gpr ? \"gpr\" : \"fpr\";\n-\n-      exit_suffix = exitp ? \"_x\" : \"\";\n-\n-      sprintf (name, \"_%s%s_%d%s\", action, regkind, regno, exit_suffix);\n+      name = rs6000_savres_routine_name (info, regno, savep, gpr, lr);\n \n       sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select]\n \t= gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+      SYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_FUNCTION;\n     }\n \n   return sym;\n@@ -18124,8 +18207,11 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n   if (frame_reg_rtx != sp_reg_rtx)\n     {\n       if (sp_offset != 0)\n-\treturn emit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,\n-\t\t\t\t      GEN_INT (sp_offset)));\n+\t{\n+\t  rtx dest_reg = savres ? gen_rtx_REG (Pmode, 11) : sp_reg_rtx;\n+\t  return emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx,\n+\t\t\t\t\t   GEN_INT (sp_offset)));\n+\t}\n       else if (!savres)\n \treturn emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n     }\n@@ -18154,7 +18240,7 @@ static rtx\n rs6000_make_savres_rtx (rs6000_stack_t *info,\n \t\t\trtx frame_reg_rtx, int save_area_offset,\n \t\t\tenum machine_mode reg_mode,\n-\t\t\tbool savep, bool gpr, bool exitp)\n+\t\t\tbool savep, bool gpr, bool lr)\n {\n   int i;\n   int offset, start_reg, end_reg, n_regs;\n@@ -18168,20 +18254,21 @@ rs6000_make_savres_rtx (rs6000_stack_t *info,\n \t       : info->first_fp_reg_save);\n   end_reg = gpr ? 32 : 64;\n   n_regs = end_reg - start_reg;\n-  p = rtvec_alloc ((exitp ? 4 : 3) + n_regs);\n+  p = rtvec_alloc ((lr ? 4 : 3) + n_regs);\n \n-  /* If we're saving registers, then we should never say we're exiting.\t */\n-  gcc_assert ((savep && !exitp) || !savep);\n-\n-  if (exitp)\n+  if (!savep && lr)\n     RTVEC_ELT (p, offset++) = gen_rtx_RETURN (VOIDmode);\n \n   RTVEC_ELT (p, offset++)\n     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 65));\n \n-  sym = rs6000_savres_routine_sym (info, savep, gpr, exitp);\n+  sym = rs6000_savres_routine_sym (info, savep, gpr, lr);\n   RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n-  RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 11));\n+  RTVEC_ELT (p, offset++)\n+    = gen_rtx_USE (VOIDmode,\n+\t\t   gen_rtx_REG (Pmode, DEFAULT_ABI != ABI_AIX ? 11\n+\t\t\t\t       : gpr && !lr ? 12\n+\t\t\t\t       : 1));\n \n   for (i = 0; i < end_reg - start_reg; i++)\n     {\n@@ -18196,6 +18283,16 @@ rs6000_make_savres_rtx (rs6000_stack_t *info,\n \t\t\t\t\t       savep ? reg : mem);\n     }\n \n+  if (savep && lr)\n+    {\n+      rtx addr, reg, mem;\n+      reg = gen_rtx_REG (Pmode, 0);\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t   GEN_INT (info->lr_save_offset));\n+      mem = gen_frame_mem (Pmode, addr);\n+      RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode, mem, reg);\n+    }\n+\n   return gen_rtx_PARALLEL (VOIDmode, p);\n }\n \n@@ -18216,7 +18313,10 @@ rs6000_reg_live_or_pic_offset_p (int reg)\n enum {\n   SAVRES_MULTIPLE = 0x1,\n   SAVRES_INLINE_FPRS = 0x2,\n-  SAVRES_INLINE_GPRS = 0x4\n+  SAVRES_INLINE_GPRS = 0x4,\n+  SAVRES_NOINLINE_GPRS_SAVES_LR = 0x8,\n+  SAVRES_NOINLINE_FPRS_SAVES_LR = 0x10,\n+  SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR = 0x20\n };\n \n /* Determine the strategy for savings/restoring registers.  */\n@@ -18231,6 +18331,7 @@ rs6000_savres_strategy (rs6000_stack_t *info, bool savep,\n   bool savres_gprs_inline;\n   bool noclobber_global_gprs\n     = no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true);\n+  int strategy;\n \n   using_multiple_p = (TARGET_MULTIPLE && ! TARGET_POWERPC64\n \t\t      && (!TARGET_SPE_ABI\n@@ -18250,6 +18351,10 @@ rs6000_savres_strategy (rs6000_stack_t *info, bool savep,\n \t\t\t|| info->first_fp_reg_save == 64\n \t\t\t|| !no_global_regs_above (info->first_fp_reg_save,\n \t\t\t\t\t\t  /*gpr=*/false)\n+\t\t\t/* The out-of-line FP routines use\n+\t\t\t   double-precision stores; we can't use those\n+\t\t\t   routines if we don't have such stores.  */\n+\t\t\t|| (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT)\n \t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save));\n   savres_gprs_inline = (common\n \t\t\t/* Saving CR interferes with the exit routines\n@@ -18287,9 +18392,22 @@ rs6000_savres_strategy (rs6000_stack_t *info, bool savep,\n \tsavres_gprs_inline = savres_gprs_inline || using_multiple_p;\n     }\n \n-  return (using_multiple_p\n-\t  | (savres_fprs_inline << 1)\n-\t  | (savres_gprs_inline << 2));\n+  strategy = (using_multiple_p\n+\t      | (savres_fprs_inline << 1)\n+\t      | (savres_gprs_inline << 2));\n+#ifdef POWERPC_LINUX\n+  if (TARGET_64BIT)\n+    {\n+      if (!savres_fprs_inline)\n+\tstrategy |= SAVRES_NOINLINE_FPRS_SAVES_LR;\n+      else if (!savres_gprs_inline && info->first_fp_reg_save == 64)\n+\tstrategy |= SAVRES_NOINLINE_GPRS_SAVES_LR;\n+    }\n+#else\n+  if (TARGET_AIX && !savres_fprs_inline)\n+    strategy |= SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR;\n+#endif\n+  return strategy;\n }\n \n /* Emit function prologue as insns.  */\n@@ -18311,7 +18429,7 @@ rs6000_emit_prologue (void)\n   int using_store_multiple;\n   int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n                               && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n-                              && !call_used_regs[STATIC_CHAIN_REGNUM]);\n+\t\t\t      && call_used_regs[STATIC_CHAIN_REGNUM]);\n   HOST_WIDE_INT sp_offset = 0;\n \n   if (TARGET_FIX_AND_CONTINUE)\n@@ -18496,24 +18614,30 @@ rs6000_emit_prologue (void)\n \t\t\t     gen_rtx_REG (Pmode, LR_REGNO));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+      if (!(strategy & (SAVRES_NOINLINE_GPRS_SAVES_LR\n+\t\t\t| SAVRES_NOINLINE_FPRS_SAVES_LR)))\n+\t{\n+\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n-      reg = gen_rtx_REG (Pmode, 0);\n-      mem = gen_rtx_MEM (Pmode, addr);\n-      /* This should not be of rs6000_sr_alias_set, because of\n-\t __builtin_return_address.  */\n+\t  reg = gen_rtx_REG (Pmode, 0);\n+\t  mem = gen_rtx_MEM (Pmode, addr);\n+\t  /* This should not be of rs6000_sr_alias_set, because of\n+\t     __builtin_return_address.  */\n \n-      insn = emit_move_insn (mem, reg);\n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+\t  insn = emit_move_insn (mem, reg);\n+\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t\tNULL_RTX, NULL_RTX);\n+\t}\n     }\n \n-  /* If we need to save CR, put it into r12.  */\n+  /* If we need to save CR, put it into r12 or r11.  */\n   if (!WORLD_SAVE_P (info) && info->cr_save_p && frame_reg_rtx != frame_ptr_rtx)\n     {\n       rtx set;\n \n-      cr_save_rtx = gen_rtx_REG (SImode, 12);\n+      cr_save_rtx\n+\t= gen_rtx_REG (SImode, DEFAULT_ABI == ABI_AIX && !saving_GPRs_inline\n+\t\t       ? 11 : 12);\n       insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       /* Now, there's no way that dwarf2out_frame_debug_expr is going\n@@ -18550,7 +18674,9 @@ rs6000_emit_prologue (void)\n \t\t\t\t    info->fp_save_offset + sp_offset,\n \t\t\t\t    DFmode,\n \t\t\t\t    /*savep=*/true, /*gpr=*/false,\n-\t\t\t\t    /*exitp=*/false);\n+\t\t\t\t    /*lr=*/(strategy\n+\t\t\t\t\t    & SAVRES_NOINLINE_FPRS_SAVES_LR)\n+\t\t\t\t\t   != 0);\n       insn = emit_insn (par);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n@@ -18646,7 +18772,7 @@ rs6000_emit_prologue (void)\n \t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n \t\t\t\t\t0, reg_mode,\n \t\t\t\t\t/*savep=*/true, /*gpr=*/true,\n-\t\t\t\t\t/*exitp=*/false);\n+\t\t\t\t\t/*lr=*/false);\n \t  insn = emit_insn (par);\n \t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t\tNULL_RTX, NULL_RTX);\n@@ -18661,23 +18787,23 @@ rs6000_emit_prologue (void)\n     {\n       rtx par;\n \n-      /* Need to adjust r11 if we saved any FPRs.  */\n+      /* Need to adjust r11 (r12) if we saved any FPRs.  */\n       if (info->first_fp_reg_save != 64)\n         {\n-          rtx r11 = gen_rtx_REG (reg_mode, 11);\n-          rtx offset = GEN_INT (info->total_size\n+\t  rtx dest_reg = gen_rtx_REG (reg_mode, DEFAULT_ABI == ABI_AIX\n+\t\t\t\t      ? 12 : 11);\n+\t  rtx offset = GEN_INT (sp_offset\n                                 + (-8 * (64-info->first_fp_reg_save)));\n-          rtx ptr_reg = (sp_reg_rtx == frame_reg_rtx\n-                         ? sp_reg_rtx : r11);\n-\n-\t  emit_insn (gen_add3_insn (r11, ptr_reg, offset));\n+\t  emit_insn (gen_add3_insn (dest_reg, frame_reg_rtx, offset));\n         }\n \n       par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n \t\t\t\t    info->gp_save_offset + sp_offset,\n \t\t\t\t    reg_mode,\n \t\t\t\t    /*savep=*/true, /*gpr=*/true,\n-\t\t\t\t    /*exitp=*/false);\n+\t\t\t\t    /*lr=*/(strategy\n+\t\t\t\t\t    & SAVRES_NOINLINE_GPRS_SAVES_LR)\n+\t\t\t\t\t   != 0);\n       insn = emit_insn (par);\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n@@ -18954,9 +19080,18 @@ rs6000_output_function_prologue (FILE *file,\n      fp values.  */\n   if (info->first_fp_reg_save < 64\n       && !FP_SAVE_INLINE (info->first_fp_reg_save))\n-    fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n-\t     SAVE_FP_PREFIX, info->first_fp_reg_save - 32, SAVE_FP_SUFFIX,\n-\t     RESTORE_FP_PREFIX, info->first_fp_reg_save - 32, RESTORE_FP_SUFFIX);\n+    {\n+      char *name;\n+      int regno = info->first_fp_reg_save - 32;\n+\n+      name = rs6000_savres_routine_name (info, regno, /*savep=*/true,\n+\t\t\t\t\t /*gpr=*/false, /*lr=*/false);\n+      fprintf (file, \"\\t.extern %s\\n\", name);\n+\n+      name = rs6000_savres_routine_name (info, regno, /*savep=*/false,\n+\t\t\t\t\t /*gpr=*/false, /*lr=*/true);\n+      fprintf (file, \"\\t.extern %s\\n\", name);\n+    }\n \n   /* Write .extern for AIX common mode routines, if needed.  */\n   if (! TARGET_POWER && ! TARGET_POWERPC && ! common_mode_defined)\n@@ -19082,6 +19217,7 @@ rs6000_emit_epilogue (int sibcall)\n   rtx frame_reg_rtx = sp_reg_rtx;\n   rtx cfa_restores = NULL_RTX;\n   rtx insn;\n+  rtx cr_save_reg = NULL_RTX;\n   enum machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n   int i;\n@@ -19115,8 +19251,10 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t || (cfun->calls_alloca\n \t\t\t\t     && !frame_pointer_needed));\n   restore_lr = (info->lr_save_p\n-\t\t&& restoring_GPRs_inline\n-\t\t&& restoring_FPRs_inline);\n+\t\t&& (restoring_FPRs_inline\n+\t\t    || (strategy & SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR))\n+\t\t&& (restoring_GPRs_inline\n+\t\t    || info->first_fp_reg_save < 64));\n \n   if (WORLD_SAVE_P (info))\n     {\n@@ -19403,7 +19541,7 @@ rs6000_emit_epilogue (int sibcall)\n \n   /* Get the old lr if we saved it.  If we are restoring registers\n      out-of-line, then the out-of-line routines can do this for us.  */\n-  if (restore_lr)\n+  if (restore_lr && restoring_GPRs_inline)\n     {\n       rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n \t\t\t\t      info->lr_save_offset + sp_offset);\n@@ -19418,12 +19556,17 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t       GEN_INT (info->cr_save_offset + sp_offset));\n       rtx mem = gen_frame_mem (SImode, addr);\n \n-      emit_move_insn (gen_rtx_REG (SImode, 12), mem);\n+      cr_save_reg = gen_rtx_REG (SImode,\n+\t\t\t\t DEFAULT_ABI == ABI_AIX\n+\t\t\t\t && !restoring_GPRs_inline\n+\t\t\t\t && info->first_fp_reg_save < 64\n+\t\t\t\t ? 11 : 12);\n+      emit_move_insn (cr_save_reg, mem);\n     }\n \n   /* Set LR here to try to overlap restores below.  LR is always saved\n      above incoming stack, so it never needs REG_CFA_RESTORE.  */\n-  if (restore_lr)\n+  if (restore_lr && restoring_GPRs_inline)\n     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n \t\t    gen_rtx_REG (Pmode, 0));\n \n@@ -19540,7 +19683,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  par = rs6000_make_savres_rtx (info, gen_rtx_REG (Pmode, 11),\n \t\t\t\t\t0, reg_mode,\n \t\t\t\t\t/*savep=*/false, /*gpr=*/true,\n-\t\t\t\t\t/*exitp=*/true);\n+\t\t\t\t\t/*lr=*/true);\n \t  emit_jump_insn (par);\n \t  /* We don't want anybody else emitting things after we jumped\n \t     back.  */\n@@ -19558,21 +19701,25 @@ rs6000_emit_epilogue (int sibcall)\n \trs6000_emit_stack_reset (info, sp_reg_rtx, frame_reg_rtx,\n \t\t\t\t sp_offset, can_use_exit);\n       else\n-\temit_insn (gen_addsi3 (gen_rtx_REG (Pmode, 11),\n-\t\t\t       sp_reg_rtx,\n-\t\t\t       GEN_INT (sp_offset - info->fp_size)));\n+\t{\n+\t  emit_insn (gen_add3_insn (gen_rtx_REG (Pmode, DEFAULT_ABI == ABI_AIX\n+\t\t\t\t\t\t\t? 12 : 11),\n+\t\t\t\t    frame_reg_rtx,\n+\t\t\t\t    GEN_INT (sp_offset - info->fp_size)));\n+\t  if (REGNO (frame_reg_rtx) == 11)\n+\t    sp_offset += info->fp_size;\n+\t}\n \n       par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n \t\t\t\t    info->gp_save_offset, reg_mode,\n \t\t\t\t    /*savep=*/false, /*gpr=*/true,\n-\t\t\t\t    /*exitp=*/can_use_exit);\n+\t\t\t\t    /*lr=*/can_use_exit);\n \n       if (can_use_exit)\n \t{\n \t  if (info->cr_save_p)\n \t    {\n-\t      rs6000_restore_saved_cr (gen_rtx_REG (SImode, 12),\n-\t\t\t\t       using_mtcr_multiple);\n+\t      rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n \t      if (DEFAULT_ABI == ABI_V4)\n \t\tcfa_restores\n \t\t  = alloc_reg_note (REG_CFA_RESTORE,\n@@ -19659,6 +19806,16 @@ rs6000_emit_epilogue (int sibcall)\n           }\n     }\n \n+  if (restore_lr && !restoring_GPRs_inline)\n+    {\n+      rtx mem = gen_frame_mem_offset (Pmode, frame_reg_rtx,\n+\t\t\t\t     info->lr_save_offset + sp_offset);\n+\n+      emit_move_insn (gen_rtx_REG (Pmode, 0), mem);\n+      emit_move_insn (gen_rtx_REG (Pmode, LR_REGNO),\n+\t\t      gen_rtx_REG (Pmode, 0));\n+    }\n+\n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n@@ -19685,7 +19842,7 @@ rs6000_emit_epilogue (int sibcall)\n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)\n     {\n-      rs6000_restore_saved_cr (gen_rtx_REG (SImode, 12), using_mtcr_multiple);\n+      rs6000_restore_saved_cr (cr_save_reg, using_mtcr_multiple);\n       if (DEFAULT_ABI == ABI_V4)\n \tcfa_restores\n \t  = alloc_reg_note (REG_CFA_RESTORE, gen_rtx_REG (SImode, CR2_REGNO),\n@@ -19716,13 +19873,14 @@ rs6000_emit_epilogue (int sibcall)\n   if (!sibcall)\n     {\n       rtvec p;\n+      bool lr = (strategy & SAVRES_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n       if (! restoring_FPRs_inline)\n \tp = rtvec_alloc (4 + 64 - info->first_fp_reg_save);\n       else\n \tp = rtvec_alloc (2);\n \n       RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n-      RTVEC_ELT (p, 1) = (restoring_FPRs_inline\n+      RTVEC_ELT (p, 1) = ((restoring_FPRs_inline || !lr)\n \t\t\t  ? gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 65))\n \t\t\t  : gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t\t     gen_rtx_REG (Pmode, 65)));\n@@ -19737,10 +19895,12 @@ rs6000_emit_epilogue (int sibcall)\n \t  sym = rs6000_savres_routine_sym (info,\n \t\t\t\t\t   /*savep=*/false,\n \t\t\t\t\t   /*gpr=*/false,\n-\t\t\t\t\t   /*exitp=*/true);\n+\t\t\t\t\t   /*lr=*/lr);\n \t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode, sym);\n \t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (Pmode, 11));\n+\t\t\t\t\t  gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t       DEFAULT_ABI == ABI_AIX\n+\t\t\t\t\t\t       ? 1 : 11));\n \t  for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \t    {\n \t      rtx addr, mem;"}, {"sha": "97a128bf69e136da679c9517bb4515af8faa20f9", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -15436,6 +15436,19 @@\n  [(set_attr \"type\" \"branch\")\n   (set_attr \"length\" \"4\")])\n \n+(define_insn \"*return_and_restore_fpregs_aix_<mode>\"\n+ [(match_parallel 0 \"any_parallel_operand\"\n+\t\t  [(return)\n+\t\t   (use (match_operand:P 1 \"register_operand\" \"l\"))\n+\t\t   (use (match_operand:P 2 \"symbol_ref_operand\" \"s\"))\n+\t\t   (use (match_operand:P 3 \"gpc_reg_operand\" \"r\"))\n+\t\t   (set (match_operand:DF 4 \"gpc_reg_operand\" \"=d\")\n+\t\t\t(match_operand:DF 5 \"memory_operand\" \"m\"))])]\n+ \"\"\n+ \"b %z2\"\n+ [(set_attr \"type\" \"branch\")\n+  (set_attr \"length\" \"4\")])\n+\n ; This is used in compiling the unwind routines.\n (define_expand \"eh_return\"\n   [(use (match_operand 0 \"general_operand\" \"\"))]"}, {"sha": "ee608b973842e29241ec43521d0e7009c5f7a608", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -3156,9 +3156,9 @@\n   [(match_parallel 0 \"any_parallel_operand\"\n \t\t   [(clobber (reg:P 65))\n \t\t    (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t\t    (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n-\t\t    (set (match_operand:V2SI 3 \"memory_operand\" \"=m\")\n-\t\t\t (match_operand:V2SI 4 \"gpc_reg_operand\" \"r\"))])]\n+\t\t    (use (reg:P 11))\n+\t\t    (set (match_operand:V2SI 2 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:V2SI 3 \"gpc_reg_operand\" \"r\"))])]\n   \"TARGET_SPE_ABI\"\n   \"bl %z1\"\n   [(set_attr \"type\" \"branch\")\n@@ -3168,9 +3168,9 @@\n  [(match_parallel 0 \"any_parallel_operand\"\n \t\t  [(clobber (reg:P 65))\n \t\t   (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t\t   (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n-\t\t   (set (match_operand:V2SI 3 \"gpc_reg_operand\" \"=r\")\n-\t\t\t(match_operand:V2SI 4 \"memory_operand\" \"m\"))])]\n+\t\t   (use (reg:P 11))\n+\t\t   (set (match_operand:V2SI 2 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:V2SI 3 \"memory_operand\" \"m\"))])]\n  \"TARGET_SPE_ABI\"\n  \"bl %z1\"\n  [(set_attr \"type\" \"branch\")\n@@ -3181,9 +3181,9 @@\n \t\t  [(return)\n \t\t   (clobber (reg:P 65))\n \t\t   (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n-\t\t   (use (match_operand:P 2 \"gpc_reg_operand\" \"r\"))\n-\t\t   (set (match_operand:V2SI 3 \"gpc_reg_operand\" \"=r\")\n-\t\t\t(match_operand:V2SI 4 \"memory_operand\" \"m\"))])]\n+\t\t   (use (reg:P 11))\n+\t\t   (set (match_operand:V2SI 2 \"gpc_reg_operand\" \"=r\")\n+\t\t\t(match_operand:V2SI 3 \"memory_operand\" \"m\"))])]\n  \"TARGET_SPE_ABI\"\n  \"b %z1\"\n  [(set_attr \"type\" \"branch\")"}, {"sha": "5377b474da573bb16d86a39126a03d5946de1033", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -272,27 +272,25 @@ do {\t\t\t\t\t\t\t\t\t\\\n #endif\n \n /* Define cutoff for using external functions to save floating point.\n-   Currently on 64-bit V.4, always use inline stores.  When optimizing\n-   for size on 32-bit targets, use external functions when\n-   profitable.  */\n-#define FP_SAVE_INLINE(FIRST_REG) (optimize_size && !TARGET_64BIT\t\\\n+   When optimizing for size, use external functions when profitable.  */\n+#define FP_SAVE_INLINE(FIRST_REG) (optimize_size\t\t\t\\\n \t\t\t\t   ? ((FIRST_REG) == 62\t\t\t\\\n \t\t\t\t      || (FIRST_REG) == 63)\t\t\\\n \t\t\t\t   : (FIRST_REG) < 64)\n /* And similarly for general purpose registers.  */\n #define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32\t\\\n-\t\t\t\t   && (TARGET_64BIT || !optimize_size))\n+\t\t\t\t   && !optimize_size)\n \n /* Put jump tables in read-only memory, rather than in .text.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 0\n \n /* Prefix and suffix to use to saving floating point.  */\n #define\tSAVE_FP_PREFIX \"_savefpr_\"\n-#define SAVE_FP_SUFFIX (TARGET_64BIT ? \"_l\" : \"\")\n+#define SAVE_FP_SUFFIX \"\"\n \n /* Prefix and suffix to use to restoring floating point.  */\n #define\tRESTORE_FP_PREFIX \"_restfpr_\"\n-#define RESTORE_FP_SUFFIX (TARGET_64BIT ? \"_l\" : \"\")\n+#define RESTORE_FP_SUFFIX \"\"\n \n /* Type used for ptrdiff_t, as a string used in a declaration.  */\n #define PTRDIFF_TYPE \"int\""}, {"sha": "794404d7651213cc36253a1223c4ec11a64e9767", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -1,3 +1,9 @@\n+2009-09-15  Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/41175\n+\t* gcc.target/powerpc/pr41175.c: New test.\n+\n 2009-09-14  Richard Henderson  <rth@redhat.com>\n \n \t* c-c++-common/asmgoto-1.c, c-c++-common/asmgoto-2.c,"}, {"sha": "2f0137962c53ac8bc4f7a134e7370d1a90dba0f6", "filename": "gcc/testsuite/gcc.target/powerpc/pr41175.c", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr41175.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7a9e7c50c8b2e897a1dfd828f4387d28481bd31/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr41175.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr41175.c?ref=d7a9e7c50c8b2e897a1dfd828f4387d28481bd31", "patch": "@@ -0,0 +1,461 @@\n+/* PR target/41175 */\n+/* { dg-do run } */\n+/* { dg-options \"-Os\" } */\n+\n+#define X2(n) X1(n##0) X1(n##1)\n+#define X4(n) X2(n##0) X2(n##1)\n+#define X8(n) X4(n##0) X4(n##1)\n+\n+#ifndef __SPE__\n+#define FLOAT_REG_CONSTRAINT \"f\"\n+#else\n+#define FLOAT_REG_CONSTRAINT \"r\"\n+#endif\n+\n+volatile int ll;\n+\n+__attribute__((noinline)) void\n+foo (void)\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+bar (char *p)\n+{\n+  asm volatile (\"\" : : \"r\" (p) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f1 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+  foo ();\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f2 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+  char *pp = __builtin_alloca (ll);\n+  bar (pp);\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f3 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+}\n+\n+#ifndef __NO_FPRS__\n+__attribute__((noinline)) void\n+f4 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X4(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X4(d) \"=m\" (mem) : : \"memory\");\n+  foo ();\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X4(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f5 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X4(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X4(d) \"=m\" (mem) : : \"memory\");\n+  char *pp = __builtin_alloca (ll);\n+  bar (pp);\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X4(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f6 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X4(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X4(d) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X4(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f7 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X2(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X2(d) \"=m\" (mem) : : \"memory\");\n+  foo ();\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X2(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f8 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X2(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X2(d) \"=m\" (mem) : : \"memory\");\n+  char *pp = __builtin_alloca (ll);\n+  bar (pp);\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X2(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f9 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X8(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X2(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X2(d) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X2(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f10 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X4(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X1(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X4(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X1(d) \"=m\" (mem) : : \"memory\");\n+  foo ();\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X4(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X1(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f11 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X4(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X1(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X4(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X1(d) \"=m\" (mem) : : \"memory\");\n+  char *pp = __builtin_alloca (ll);\n+  bar (pp);\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X4(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X1(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f12 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X4(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X1(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X4(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X1(d) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X4(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X1(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f13 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X2(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X8(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X2(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X8(d) \"=m\" (mem) : : \"memory\");\n+  foo ();\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X2(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X8(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f14 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X2(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X8(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X2(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X8(d) \"=m\" (mem) : : \"memory\");\n+  char *pp = __builtin_alloca (ll);\n+  bar (pp);\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X2(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X8(d) \"m\" (mem) : \"memory\");\n+}\n+\n+__attribute__((noinline)) void\n+f15 (void)\n+{\n+  int mem;\n+#undef X1\n+#define X1(n) int gpr##n = 0;\n+  X8(a) X8(b) X2(c)\n+#undef X1\n+#define X1(n) double fpr##n = 0.0;\n+  X8(d)\n+#undef X1\n+#define X1(n) \"+r\" (gpr##n),\n+  asm volatile (\"\" : X8(a) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X8(b) \"=m\" (mem) : : \"memory\");\n+  asm volatile (\"\" : X2(c) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"+\" FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : X8(d) \"=m\" (mem) : : \"memory\");\n+#undef X1\n+#define X1(n) \"r\" (gpr##n),\n+  asm volatile (\"\" : : X8(a) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X8(b) \"m\" (mem) : \"memory\");\n+  asm volatile (\"\" : : X2(c) \"m\" (mem) : \"memory\");\n+#undef X1\n+#define X1(n) FLOAT_REG_CONSTRAINT (fpr##n),\n+  asm volatile (\"\" : : X8(d) \"m\" (mem) : \"memory\");\n+}\n+#endif\n+\n+int\n+main ()\n+{\n+  ll = 60;\n+  f1 ();\n+  f2 ();\n+  f3 ();\n+#ifndef __NO_FPRS__\n+  f4 ();\n+  f5 ();\n+  f6 ();\n+  f7 ();\n+  f8 ();\n+  f9 ();\n+  f10 ();\n+  f11 ();\n+  f12 ();\n+  f13 ();\n+  f14 ();\n+  f15 ();\n+#endif\n+  return 0;\n+}"}]}