{"sha": "50b009c5daef92bc60fc26fcc4c495e117667387", "node_id": "C_kwDOANBUbNoAKDUwYjAwOWM1ZGFlZjkyYmM2MGZjMjZmY2M0YzQ5NWUxMTc2NjczODc", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-05-10T14:00:53Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-05-10T14:04:30Z"}, "message": "libiberty: stop using PTR macro\n\ninclude/ChangeLog:\n\n\t* hashtab.h (HTAB_EMPTY_ENTRY): Use void * instead PTR.\n\t(HTAB_DELETED_ENTRY): Likewise.\n\nlibiberty/ChangeLog:\n\n\t* alloca.c (C_alloca): Use void * instead PTR.\n\t* calloc.c (malloc): Likewise.\n\t(bzero): Likewise.\n\t(calloc): Likewise.\n\t* hashtab.c (find_empty_slot_for_expand): Likewise.\n\t(eq_pointer): Likewise.\n\t(htab_create_alloc_ex): Likewise.\n\t(htab_create_typed_alloc): Likewise.\n\t(htab_set_functions_ex): Likewise.\n\t(htab_delete): Likewise.\n\t(htab_empty): Likewise.\n\t(htab_expand): Likewise.\n\t(htab_find_with_hash): Likewise.\n\t(htab_find): Likewise.\n\t(htab_find_slot_with_hash): Likewise.\n\t(htab_find_slot): Likewise.\n\t(htab_remove_elt): Likewise.\n\t(htab_remove_elt_with_hash): Likewise.\n\t(htab_clear_slot): Likewise.\n\t(htab_traverse_noresize): Likewise.\n\t(htab_traverse): Likewise.\n\t(htab_hash_string): Likewise.\n\t(iterative_hash): Likewise.\n\t(hash_pointer): Likewise.\n\t* memchr.c (memchr): Likewise.\n\t* memcmp.c (memcmp): Likewise.\n\t* memcpy.c (memcpy): Likewise.\n\t* memmove.c (memmove): Likewise.\n\t* mempcpy.c (memcpy): Likewise.\n\t(mempcpy): Likewise.\n\t* memset.c (memset): Likewise.\n\t* objalloc.c (malloc): Likewise.\n\t(free): Likewise.\n\t(objalloc_create): Likewise.\n\t(_objalloc_alloc): Likewise.\n\t(objalloc_free_block): Likewise.\n\t* random.c (PTR): Likewise.\n\t(void): Likewise.\n\t(initstate): Likewise.\n\t(setstate): Likewise.\n\t* regex.c: Likewise.\n\t* spaces.c (malloc): Likewise.\n\t(free): Likewise.\n\t* stpcpy.c (memcpy): Likewise.\n\t* strdup.c (malloc): Likewise.\n\t(memcpy): Likewise.\n\t* strerror.c (malloc): Likewise.\n\t(memset): Likewise.\n\t* strndup.c (malloc): Likewise.\n\t(memcpy): Likewise.\n\t* strsignal.c (malloc): Likewise.\n\t(memset): Likewise.\n\t* vasprintf.c (malloc): Likewise.\n\t* vprintf-support.c: Likewise.\n\t* xatexit.c (malloc): Likewise.\n\t* xmalloc.c (xmalloc): Likewise.\n\t(xcalloc): Likewise.\n\t(xrealloc): Likewise.\n\t* xmemdup.c (xmemdup): Likewise.", "tree": {"sha": "bb5537637562b9fa5e5b35be905f7b8faac0c94c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb5537637562b9fa5e5b35be905f7b8faac0c94c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50b009c5daef92bc60fc26fcc4c495e117667387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b009c5daef92bc60fc26fcc4c495e117667387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b009c5daef92bc60fc26fcc4c495e117667387", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b009c5daef92bc60fc26fcc4c495e117667387/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ddd44b58649d1d1e932c1e95dc00d654733c1fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddd44b58649d1d1e932c1e95dc00d654733c1fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ddd44b58649d1d1e932c1e95dc00d654733c1fc"}], "stats": {"total": 234, "additions": 117, "deletions": 117}, "files": [{"sha": "e74d2226e08aa19e2d4d074e0ec101de9796ed3b", "filename": "include/hashtab.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -79,12 +79,12 @@ typedef void (*htab_free_with_arg) (void *, void *);\n \n /* This macro defines reserved value for empty table entry.  */\n \n-#define HTAB_EMPTY_ENTRY    ((PTR) 0)\n+#define HTAB_EMPTY_ENTRY    ((void *) 0)\n \n /* This macro defines reserved value for table entry which contained\n    a deleted element. */\n \n-#define HTAB_DELETED_ENTRY  ((PTR) 1)\n+#define HTAB_DELETED_ENTRY  ((void *) 1)\n \n /* Hash tables are of the following type.  The structure\n    (implementation) of this type is not needed for using the hash"}, {"sha": "b75f7560f9456131ad7d27ebdda2a1170f87675e", "filename": "libiberty/alloca.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Falloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Falloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Falloca.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -158,7 +158,7 @@ static header *last_alloca_header = NULL;\t/* -> last alloca header.  */\n \n /* @undocumented C_alloca */\n \n-PTR\n+void *\n C_alloca (size_t size)\n {\n   auto char probe;\t\t/* Probes stack depth: */\n@@ -181,7 +181,7 @@ C_alloca (size_t size)\n \t{\n \t  register header *np = hp->h.next;\n \n-\t  free ((PTR) hp);\t/* Collect garbage.  */\n+\t  free ((void *) hp);\t/* Collect garbage.  */\n \n \t  hp = np;\t\t/* -> next header.  */\n \t}\n@@ -210,7 +210,7 @@ C_alloca (size_t size)\n \n     /* User storage begins just after header.  */\n \n-    return (PTR) ((char *) new_storage + sizeof (header));\n+    return (void *) ((char *) new_storage + sizeof (header));\n   }\n }\n "}, {"sha": "c7d97a6e362d510c6c3ae3207951af6916394680", "filename": "libiberty/calloc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fcalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fcalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcalloc.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -16,13 +16,13 @@ Uses @code{malloc} to allocate storage for @var{nelem} objects of\n #include <stddef.h>\n \n /* For systems with larger pointers than ints, this must be declared.  */\n-PTR malloc (size_t);\n-void bzero (PTR, size_t);\n+void *malloc (size_t);\n+void bzero (void *, size_t);\n \n-PTR\n+void *\n calloc (size_t nelem, size_t elsize)\n {\n-  register PTR ptr;  \n+  register void *ptr;\n \n   if (nelem == 0 || elsize == 0)\n     nelem = elsize = 1;"}, {"sha": "f7621cd47e554a71175db70441d45f9d692ee5b5", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -73,7 +73,7 @@ static hashval_t htab_mod_m2 (hashval_t, htab_t);\n static hashval_t hash_pointer (const void *);\n static int eq_pointer (const void *, const void *);\n static int htab_expand (htab_t);\n-static PTR *find_empty_slot_for_expand (htab_t, hashval_t);\n+static void **find_empty_slot_for_expand (htab_t, hashval_t);\n \n /* At some point, we could make these be NULL, and modify the\n    hash-table routines to handle NULL specially; that would avoid\n@@ -196,7 +196,7 @@ higher_prime_index (unsigned long n)\n /* Returns non-zero if P1 and P2 are equal.  */\n \n static int\n-eq_pointer (const PTR p1, const PTR p2)\n+eq_pointer (const void *p1, const void *p2)\n {\n   return p1 == p2;\n }\n@@ -304,7 +304,7 @@ htab_create_alloc_ex (size_t size, htab_hash hash_f, htab_eq eq_f,\n   result = (htab_t) (*alloc_f) (alloc_arg, 1, sizeof (struct htab));\n   if (result == NULL)\n     return NULL;\n-  result->entries = (PTR *) (*alloc_f) (alloc_arg, size, sizeof (PTR));\n+  result->entries = (void **) (*alloc_f) (alloc_arg, size, sizeof (void *));\n   if (result->entries == NULL)\n     {\n       if (free_f != NULL)\n@@ -357,7 +357,7 @@ htab_create_typed_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n   result = (htab_t) (*alloc_tab_f) (1, sizeof (struct htab));\n   if (result == NULL)\n     return NULL;\n-  result->entries = (PTR *) (*alloc_f) (size, sizeof (PTR));\n+  result->entries = (void **) (*alloc_f) (size, sizeof (void *));\n   if (result->entries == NULL)\n     {\n       if (free_f != NULL)\n@@ -379,7 +379,7 @@ htab_create_typed_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n \n void\n htab_set_functions_ex (htab_t htab, htab_hash hash_f, htab_eq eq_f,\n-                       htab_del del_f, PTR alloc_arg,\n+                       htab_del del_f, void *alloc_arg,\n                        htab_alloc_with_arg alloc_f, htab_free_with_arg free_f)\n {\n   htab->hash_f = hash_f;\n@@ -412,7 +412,7 @@ void\n htab_delete (htab_t htab)\n {\n   size_t size = htab_size (htab);\n-  PTR *entries = htab->entries;\n+  void **entries = htab->entries;\n   int i;\n \n   if (htab->del_f)\n@@ -438,7 +438,7 @@ void\n htab_empty (htab_t htab)\n {\n   size_t size = htab_size (htab);\n-  PTR *entries = htab->entries;\n+  void **entries = htab->entries;\n   int i;\n \n   if (htab->del_f)\n@@ -447,25 +447,25 @@ htab_empty (htab_t htab)\n \t(*htab->del_f) (entries[i]);\n \n   /* Instead of clearing megabyte, downsize the table.  */\n-  if (size > 1024*1024 / sizeof (PTR))\n+  if (size > 1024*1024 / sizeof (void *))\n     {\n-      int nindex = higher_prime_index (1024 / sizeof (PTR));\n+      int nindex = higher_prime_index (1024 / sizeof (void *));\n       int nsize = prime_tab[nindex].prime;\n \n       if (htab->free_f != NULL)\n \t(*htab->free_f) (htab->entries);\n       else if (htab->free_with_arg_f != NULL)\n \t(*htab->free_with_arg_f) (htab->alloc_arg, htab->entries);\n       if (htab->alloc_with_arg_f != NULL)\n-\thtab->entries = (PTR *) (*htab->alloc_with_arg_f) (htab->alloc_arg, nsize,\n-\t\t\t\t\t\t           sizeof (PTR *));\n+\thtab->entries = (void **) (*htab->alloc_with_arg_f) (htab->alloc_arg, nsize,\n+\t\t\t\t\t\t           sizeof (void **));\n       else\n-\thtab->entries = (PTR *) (*htab->alloc_f) (nsize, sizeof (PTR *));\n+\thtab->entries = (void **) (*htab->alloc_f) (nsize, sizeof (void **));\n      htab->size = nsize;\n      htab->size_prime_index = nindex;\n     }\n   else\n-    memset (entries, 0, size * sizeof (PTR));\n+    memset (entries, 0, size * sizeof (void *));\n   htab->n_deleted = 0;\n   htab->n_elements = 0;\n }\n@@ -477,12 +477,12 @@ htab_empty (htab_t htab)\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-static PTR *\n+static void **\n find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n {\n   hashval_t index = htab_mod (hash, htab);\n   size_t size = htab_size (htab);\n-  PTR *slot = htab->entries + index;\n+  void **slot = htab->entries + index;\n   hashval_t hash2;\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n@@ -516,10 +516,10 @@ find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n static int\n htab_expand (htab_t htab)\n {\n-  PTR *oentries;\n-  PTR *olimit;\n-  PTR *p;\n-  PTR *nentries;\n+  void **oentries;\n+  void **olimit;\n+  void **p;\n+  void **nentries;\n   size_t nsize, osize, elts;\n   unsigned int oindex, nindex;\n \n@@ -543,10 +543,10 @@ htab_expand (htab_t htab)\n     }\n \n   if (htab->alloc_with_arg_f != NULL)\n-    nentries = (PTR *) (*htab->alloc_with_arg_f) (htab->alloc_arg, nsize,\n-\t\t\t\t\t\t  sizeof (PTR *));\n+    nentries = (void **) (*htab->alloc_with_arg_f) (htab->alloc_arg, nsize,\n+\t\t\t\t\t\t  sizeof (void **));\n   else\n-    nentries = (PTR *) (*htab->alloc_f) (nsize, sizeof (PTR *));\n+    nentries = (void **) (*htab->alloc_f) (nsize, sizeof (void **));\n   if (nentries == NULL)\n     return 0;\n   htab->entries = nentries;\n@@ -558,11 +558,11 @@ htab_expand (htab_t htab)\n   p = oentries;\n   do\n     {\n-      PTR x = *p;\n+      void *x = *p;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n \t{\n-\t  PTR *q = find_empty_slot_for_expand (htab, (*htab->hash_f) (x));\n+\t  void **q = find_empty_slot_for_expand (htab, (*htab->hash_f) (x));\n \n \t  *q = x;\n \t}\n@@ -581,12 +581,12 @@ htab_expand (htab_t htab)\n /* This function searches for a hash table entry equal to the given\n    element.  It cannot be used to insert or delete an element.  */\n \n-PTR\n-htab_find_with_hash (htab_t htab, const PTR element, hashval_t hash)\n+void *\n+htab_find_with_hash (htab_t htab, const void *element, hashval_t hash)\n {\n   hashval_t index, hash2;\n   size_t size;\n-  PTR entry;\n+  void *entry;\n \n   htab->searches++;\n   size = htab_size (htab);\n@@ -615,8 +615,8 @@ htab_find_with_hash (htab_t htab, const PTR element, hashval_t hash)\n /* Like htab_find_slot_with_hash, but compute the hash value from the\n    element.  */\n \n-PTR\n-htab_find (htab_t htab, const PTR element)\n+void *\n+htab_find (htab_t htab, const void *element)\n {\n   return htab_find_with_hash (htab, element, (*htab->hash_f) (element));\n }\n@@ -629,14 +629,14 @@ htab_find (htab_t htab, const PTR element)\n    slot.  When inserting an entry, NULL may be returned if memory\n    allocation fails.  */\n \n-PTR *\n-htab_find_slot_with_hash (htab_t htab, const PTR element,\n+void **\n+htab_find_slot_with_hash (htab_t htab, const void *element,\n                           hashval_t hash, enum insert_option insert)\n {\n-  PTR *first_deleted_slot;\n+  void **first_deleted_slot;\n   hashval_t index, hash2;\n   size_t size;\n-  PTR entry;\n+  void *entry;\n \n   size = htab_size (htab);\n   if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n@@ -697,8 +697,8 @@ htab_find_slot_with_hash (htab_t htab, const PTR element,\n /* Like htab_find_slot_with_hash, but compute the hash value from the\n    element.  */\n \n-PTR *\n-htab_find_slot (htab_t htab, const PTR element, enum insert_option insert)\n+void **\n+htab_find_slot (htab_t htab, const void *element, enum insert_option insert)\n {\n   return htab_find_slot_with_hash (htab, element, (*htab->hash_f) (element),\n \t\t\t\t   insert);\n@@ -709,7 +709,7 @@ htab_find_slot (htab_t htab, const PTR element, enum insert_option insert)\n    element in the hash table, this function does nothing.  */\n \n void\n-htab_remove_elt (htab_t htab, const PTR element)\n+htab_remove_elt (htab_t htab, const void *element)\n {\n   htab_remove_elt_with_hash (htab, element, (*htab->hash_f) (element));\n }\n@@ -720,9 +720,9 @@ htab_remove_elt (htab_t htab, const PTR element)\n    function does nothing.  */\n \n void\n-htab_remove_elt_with_hash (htab_t htab, const PTR element, hashval_t hash)\n+htab_remove_elt_with_hash (htab_t htab, const void *element, hashval_t hash)\n {\n-  PTR *slot;\n+  void **slot;\n \n   slot = htab_find_slot_with_hash (htab, element, hash, NO_INSERT);\n   if (slot == NULL)\n@@ -740,7 +740,7 @@ htab_remove_elt_with_hash (htab_t htab, const PTR element, hashval_t hash)\n    again.  */\n \n void\n-htab_clear_slot (htab_t htab, PTR *slot)\n+htab_clear_slot (htab_t htab, void **slot)\n {\n   if (slot < htab->entries || slot >= htab->entries + htab_size (htab)\n       || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n@@ -759,17 +759,17 @@ htab_clear_slot (htab_t htab, PTR *slot)\n    argument.  */\n \n void\n-htab_traverse_noresize (htab_t htab, htab_trav callback, PTR info)\n+htab_traverse_noresize (htab_t htab, htab_trav callback, void *info)\n {\n-  PTR *slot;\n-  PTR *limit;\n+  void **slot;\n+  void **limit;\n   \n   slot = htab->entries;\n   limit = slot + htab_size (htab);\n \n   do\n     {\n-      PTR x = *slot;\n+      void *x = *slot;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n \tif (!(*callback) (slot, info))\n@@ -782,7 +782,7 @@ htab_traverse_noresize (htab_t htab, htab_trav callback, PTR info)\n    too empty to improve effectivity of subsequent calls.  */\n \n void\n-htab_traverse (htab_t htab, htab_trav callback, PTR info)\n+htab_traverse (htab_t htab, htab_trav callback, void *info)\n {\n   size_t size = htab_size (htab);\n   if (htab_elements (htab) * 8 < size && size > 32)\n@@ -829,7 +829,7 @@ htab_collisions (htab_t htab)\n    function they just started using for Perl's hashes.  */\n \n hashval_t\n-htab_hash_string (const PTR p)\n+htab_hash_string (const void *p)\n {\n   const unsigned char *str = (const unsigned char *) p;\n   hashval_t r = 0;\n@@ -926,7 +926,7 @@ acceptable.  Do NOT use for cryptographic purposes.\n */\n \n hashval_t\n-iterative_hash (const PTR k_in /* the key */,\n+iterative_hash (const void *k_in /* the key */,\n                 register size_t  length /* the length of the key */,\n                 register hashval_t initval /* the previous hash, or\n                                               an arbitrary value */)\n@@ -990,7 +990,7 @@ iterative_hash (const PTR k_in /* the key */,\n /* Returns a hash code for pointer P. Simplified version of evahash */\n \n static hashval_t\n-hash_pointer (const PTR p)\n+hash_pointer (const void *p)\n {\n   intptr_t v = (intptr_t) p;\n   unsigned a, b, c;"}, {"sha": "7551b140b59e78055e81a0e71283fbc3cc477ff9", "filename": "libiberty/memchr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemchr.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -18,15 +18,15 @@ returned.\n #include <ansidecl.h>\n #include <stddef.h>\n \n-PTR\n-memchr (register const PTR src_void, int c, size_t length)\n+void *\n+memchr (register const void *src_void, int c, size_t length)\n {\n   const unsigned char *src = (const unsigned char *)src_void;\n   \n   while (length-- > 0)\n   {\n     if (*src == c)\n-     return (PTR)src;\n+     return (void *)src;\n     src++;\n   }\n   return NULL;"}, {"sha": "5b1af020e6cc95841f8aad4d76059b6c886c08a6", "filename": "libiberty/memcmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemcmp.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -20,7 +20,7 @@ as if comparing unsigned char arrays.\n #include <stddef.h>\n \n int\n-memcmp (const PTR str1, const PTR str2, size_t count)\n+memcmp (const void *str1, const void *str2, size_t count)\n {\n   register const unsigned char *s1 = (const unsigned char*)str1;\n   register const unsigned char *s2 = (const unsigned char*)str2;"}, {"sha": "c627fa4ee9ea67a2b0b4201028d2cfd59c97d2a6", "filename": "libiberty/memcpy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemcpy.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -18,8 +18,8 @@ Copies @var{length} bytes from memory region @var{in} to region\n \n void bcopy (const void*, void*, size_t);\n \n-PTR\n-memcpy (PTR out, const PTR in, size_t length)\n+void *\n+memcpy (void *out, const void *in, size_t length)\n {\n     bcopy(in, out, length);\n     return out;"}, {"sha": "8c92d6b9c2104622056aa167706e074db532c3a7", "filename": "libiberty/memmove.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemmove.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -18,8 +18,8 @@ Copies @var{count} bytes from memory area @var{from} to memory area\n \n void bcopy (const void*, void*, size_t);\n \n-PTR\n-memmove (PTR s1, const PTR s2, size_t n)\n+void *\n+memmove (void *s1, const void *s2, size_t n)\n {\n   bcopy (s2, s1, n);\n   return s1;"}, {"sha": "94f0872d8d054bb87827badb9d4323f5b66f687b", "filename": "libiberty/mempcpy.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmempcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmempcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmempcpy.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -33,10 +33,10 @@ Copies @var{length} bytes from memory region @var{in} to region\n #include <ansidecl.h>\n #include <stddef.h>\n \n-extern PTR memcpy (PTR, const PTR, size_t);\n+extern void *memcpy (void *, const void *, size_t);\n \n-PTR\n-mempcpy (PTR dst, const PTR src, size_t len)\n+void *\n+mempcpy (void *dst, const void *src, size_t len)\n {\n   return (char *) memcpy (dst, src, len) + len;\n }"}, {"sha": "084e5dc01584390d212ec915c50e2b404f1cffe0", "filename": "libiberty/memset.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemset.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -16,8 +16,8 @@ Sets the first @var{count} bytes of @var{s} to the constant byte\n #include <ansidecl.h>\n #include <stddef.h>\n \n-PTR\n-memset (PTR dest, register int val, register size_t len)\n+void *\n+memset (void *dest, register int val, register size_t len)\n {\n   register unsigned char *ptr = (unsigned char*)dest;\n   while (len-- > 0)"}, {"sha": "3f8c5f7ab278b86f00f84a981eb1d16a01d628ff", "filename": "libiberty/objalloc.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fobjalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fobjalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fobjalloc.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -37,8 +37,8 @@ Boston, MA 02110-1301, USA.  */\n #include <stdlib.h>\n #else\n /* For systems with larger pointers than ints, this must be declared.  */\n-extern PTR malloc (size_t);\n-extern void free (PTR);\n+extern void *malloc (size_t);\n+extern void free (void *);\n #endif\n \n #endif\n@@ -92,7 +92,7 @@ objalloc_create (void)\n   if (ret == NULL)\n     return NULL;\n \n-  ret->chunks = (PTR) malloc (CHUNK_SIZE);\n+  ret->chunks = (void *) malloc (CHUNK_SIZE);\n   if (ret->chunks == NULL)\n     {\n       free (ret);\n@@ -111,7 +111,7 @@ objalloc_create (void)\n \n /* Allocate space from an objalloc structure.  */\n \n-PTR\n+void *\n _objalloc_alloc (struct objalloc *o, unsigned long original_len)\n {\n   unsigned long len = original_len;\n@@ -132,7 +132,7 @@ _objalloc_alloc (struct objalloc *o, unsigned long original_len)\n     {\n       o->current_ptr += len;\n       o->current_space -= len;\n-      return (PTR) (o->current_ptr - len);\n+      return (void *) (o->current_ptr - len);\n     }\n \n   if (len >= BIG_REQUEST)\n@@ -148,9 +148,9 @@ _objalloc_alloc (struct objalloc *o, unsigned long original_len)\n       chunk->next = (struct objalloc_chunk *) o->chunks;\n       chunk->current_ptr = o->current_ptr;\n \n-      o->chunks = (PTR) chunk;\n+      o->chunks = (void *) chunk;\n \n-      return (PTR) (ret + CHUNK_HEADER_SIZE);\n+      return (void *) (ret + CHUNK_HEADER_SIZE);\n     }\n   else\n     {\n@@ -165,7 +165,7 @@ _objalloc_alloc (struct objalloc *o, unsigned long original_len)\n       o->current_ptr = (char *) chunk + CHUNK_HEADER_SIZE;\n       o->current_space = CHUNK_SIZE - CHUNK_HEADER_SIZE;\n \n-      o->chunks = (PTR) chunk;\n+      o->chunks = (void *) chunk;\n \n       return objalloc_alloc (o, len);\n     }\n@@ -195,7 +195,7 @@ objalloc_free (struct objalloc *o)\n    recently allocated blocks.  */\n \n void\n-objalloc_free_block (struct objalloc *o, PTR block)\n+objalloc_free_block (struct objalloc *o, void *block)\n {\n   struct objalloc_chunk *p, *small;\n   char *b = (char *) block;\n@@ -257,7 +257,7 @@ objalloc_free_block (struct objalloc *o, PTR block)\n \n       if (first == NULL)\n \tfirst = p;\n-      o->chunks = (PTR) first;\n+      o->chunks = (void *) first;\n \n       /* Now start allocating from this small block again.  */\n       o->current_ptr = b;\n@@ -287,7 +287,7 @@ objalloc_free_block (struct objalloc *o, PTR block)\n \t  q = next;\n \t}\n \n-      o->chunks = (PTR) p;\n+      o->chunks = (void *) p;\n \n       while (p->current_ptr != NULL)\n \tp = p->next;"}, {"sha": "be8819dd6b8b2de7e3c030281f401430e985e787", "filename": "libiberty/random.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frandom.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -68,12 +68,12 @@ control over the state of the random number generator.\n #define\tLONG_MAX   ((long)(ULONG_MAX >> 1))   /* 0x7FFFFFFF for 32-bits*/\n \n #ifdef __STDC__\n-#  define PTR void *\n+#  define void *void *\n #  ifndef NULL\n #    define NULL (void *) 0\n #  endif\n #else\n-#  define PTR char *\n+#  define void *char *\n #  ifndef NULL\n #    define NULL (void *) 0\n #  endif\n@@ -254,10 +254,10 @@ srandom (unsigned int x)\n    Note: The first thing we do is save the current state, if any, just like\n    setstate so that it doesn't matter when initstate is called.\n    Returns a pointer to the old state.  */\n-PTR\n-initstate (unsigned int seed, PTR arg_state, unsigned long n)\n+void *\n+initstate (unsigned int seed, void *arg_state, unsigned long n)\n {\n-  PTR ostate = (PTR) &state[-1];\n+  void *ostate = (void *) &state[-1];\n \n   if (rand_type == TYPE_0)\n     state[-1] = rand_type;\n@@ -320,13 +320,13 @@ initstate (unsigned int seed, PTR arg_state, unsigned long n)\n    same state as the current state\n    Returns a pointer to the old state information.  */\n \n-PTR\n-setstate (PTR arg_state)\n+void *\n+setstate (void *arg_state)\n {\n   register long int *new_state = (long int *) arg_state;\n   register int type = new_state[0] % MAX_TYPES;\n   register int rear = new_state[0] / MAX_TYPES;\n-  PTR ostate = (PTR) &state[-1];\n+  void *ostate = (void *) &state[-1];\n \n   if (rand_type == TYPE_0)\n     state[-1] = rand_type;"}, {"sha": "c1738c989abae096f5ae5a4dbccda34e8978eb2f", "filename": "libiberty/regex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fregex.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -384,8 +384,8 @@ typedef unsigned long int uintptr_t;\n # endif /* not using relocating allocator */\n \n \n-/* True if `size1' is non-NULL and PTR is pointing anywhere inside\n-   `string1' or just past its end.  This works if PTR is NULL, which is\n+/* True if `size1' is non-NULL and void *is pointing anywhere inside\n+   `string1' or just past its end.  This works if void *is NULL, which is\n    a good thing.  */\n # define FIRST_STRING_P(ptr) \t\t\t\t\t\\\n   (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)\n@@ -5256,7 +5256,7 @@ PREFIX(re_search_2) (struct re_pattern_buffer *bufp, const char *string1,\n }\n \n #ifdef WCHAR\n-/* This converts PTR, a pointer into one of the search wchar_t strings\n+/* This converts void *, a pointer into one of the search wchar_t strings\n    `string1' and `string2' into an multibyte string offset from the\n    beginning of that string. We use mbs_offset to optimize.\n    See convert_mbs_to_wcs.  */\n@@ -5266,7 +5266,7 @@ PREFIX(re_search_2) (struct re_pattern_buffer *bufp, const char *string1,\n    : ((regoff_t)((mbs_offset2 != NULL? mbs_offset2[(ptr)-string2] : 0)\t\\\n \t\t + csize1)))\n #else /* BYTE */\n-/* This converts PTR, a pointer into one of the search strings `string1'\n+/* This converts void *, a pointer into one of the search strings `string1'\n    and `string2' into an offset from the beginning of that string.  */\n # define POINTER_TO_OFFSET(ptr)\t\t\t\\\n   (FIRST_STRING_P (ptr)\t\t\t\t\\"}, {"sha": "2b6971c4b933b37beeacfc89e9372312db19239e", "filename": "libiberty/spaces.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fspaces.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fspaces.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fspaces.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -40,8 +40,8 @@ valid until at least the next call.\n #include <unixlib.h>\n #else\n /* For systems with larger pointers than ints, these must be declared.  */\n-extern PTR malloc (size_t);\n-extern void free (PTR);\n+extern void *malloc (size_t);\n+extern void free (void *);\n #endif\n \n const char *"}, {"sha": "2d3eb4c71cdaa144364fa5e1564090604cff4d8b", "filename": "libiberty/stpcpy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstpcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstpcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstpcpy.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -33,7 +33,7 @@ Copies the string @var{src} into @var{dst}.  Returns a pointer to\n #include <stddef.h>\n \n extern size_t strlen (const char *);\n-extern PTR memcpy (PTR, const PTR, size_t);\n+extern void *memcpy (void *, const void *, size_t);\n \n char *\n stpcpy (char *dst, const char *src)"}, {"sha": "8a4188eadfbcdf487fac3d28a56e5296d2548087", "filename": "libiberty/strdup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrdup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrdup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrdup.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -13,8 +13,8 @@ Returns a pointer to a copy of @var{s} in memory obtained from\n #include <stddef.h>\n \n extern size_t\tstrlen (const char*);\n-extern PTR\tmalloc (size_t);\n-extern PTR\tmemcpy (PTR, const PTR, size_t);\n+extern void *malloc (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n \n char *\n strdup(const char *s)"}, {"sha": "07db71698d9ebeeb9c8ac9e249cae07ae0cdd611", "filename": "libiberty/strerror.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrerror.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -30,13 +30,13 @@\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #else\n-extern PTR malloc ();\n+extern void *malloc ();\n #endif\n \n #ifdef HAVE_STRING_H\n #include <string.h>\n #else\n-extern PTR memset ();\n+extern void *memset ();\n #endif\n \n #ifndef MAX"}, {"sha": "cfbb381ad0d985fe8492c57b0440cfecb7b3668b", "filename": "libiberty/strndup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrndup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrndup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrndup.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -34,8 +34,8 @@ memory was available.  The result is always NUL terminated.\n #include <stddef.h>\n \n extern size_t\tstrnlen (const char *s, size_t maxlen);\n-extern PTR\tmalloc (size_t);\n-extern PTR\tmemcpy (PTR, const PTR, size_t);\n+extern void *malloc (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n \n char *\n strndup (const char *s, size_t n)"}, {"sha": "36b41f17e1232e171c1c1c8e2266fe1d0f549b9b", "filename": "libiberty/strsignal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrsignal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fstrsignal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrsignal.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -26,13 +26,13 @@\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #else\n-extern PTR malloc ();\n+extern void *malloc ();\n #endif\n \n #ifdef HAVE_STRING_H\n #include <string.h>\n #else\n-extern PTR memset ();\n+extern void *memset ();\n #endif\n \n /* Undefine the macro we used to hide the definition of sys_siglist"}, {"sha": "c8c0152865b206394bc2334d816bc29fcfe3c307", "filename": "libiberty/vasprintf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fvasprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fvasprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fvasprintf.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -33,7 +33,7 @@ Floor, Boston, MA 02110-1301, USA.  */\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #else\n-extern PTR malloc ();\n+extern void *malloc ();\n #endif\n #include \"libiberty.h\"\n #include \"vprintf-support.h\""}, {"sha": "92aedce1edd09c9ad35a70454a913fbb26870613", "filename": "libiberty/vprintf-support.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fvprintf-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fvprintf-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fvprintf-support.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -49,7 +49,7 @@ libiberty_vprintf_buffer_size (const char *format, va_list args)\n #ifdef va_copy\n   va_copy (ap, args);\n #else\n-  memcpy ((PTR) &ap, (PTR) &args, sizeof (va_list));\n+  memcpy ((void *) &ap, (void *) &args, sizeof (va_list));\n #endif\n \n   while (*p != '\\0')"}, {"sha": "8a985cab4bc752b2df8cf4283d894aa720778d0f", "filename": "libiberty/xatexit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxatexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxatexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxatexit.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -37,7 +37,7 @@ failure.  If you use @code{xatexit} to register functions, you must use\n #include <unixlib.h>\n #else\n /* For systems with larger pointers than ints, this must be declared.  */\n-PTR malloc (size_t);\n+void *malloc (size_t);\n #endif\n \n static void xatexit_cleanup (void);"}, {"sha": "3cc4cea37c35f63f7ca5d723c3c35177ea0223a6", "filename": "libiberty/xmalloc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxmalloc.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -139,10 +139,10 @@ xmalloc_failed (size_t size)\n   xexit (1);\n }  \n \n-PTR\n+void *\n xmalloc (size_t size)\n {\n-  PTR newmem;\n+  void *newmem;\n \n   if (size == 0)\n     size = 1;\n@@ -153,10 +153,10 @@ xmalloc (size_t size)\n   return (newmem);\n }\n \n-PTR\n+void *\n xcalloc (size_t nelem, size_t elsize)\n {\n-  PTR newmem;\n+  void *newmem;\n \n   if (nelem == 0 || elsize == 0)\n     nelem = elsize = 1;\n@@ -168,10 +168,10 @@ xcalloc (size_t nelem, size_t elsize)\n   return (newmem);\n }\n \n-PTR\n-xrealloc (PTR oldmem, size_t size)\n+void *\n+xrealloc (void *oldmem, size_t size)\n {\n-  PTR newmem;\n+  void *newmem;\n \n   if (size == 0)\n     size = 1;"}, {"sha": "f2ed41f9b4d9c659dbec0eb7c84df9f77ffe6d65", "filename": "libiberty/xmemdup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxmemdup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50b009c5daef92bc60fc26fcc4c495e117667387/libiberty%2Fxmemdup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fxmemdup.c?ref=50b009c5daef92bc60fc26fcc4c495e117667387", "patch": "@@ -31,11 +31,11 @@ allocated, the remaining memory is zeroed.\n # endif\n #endif\n \n-PTR\n-xmemdup (const PTR input, size_t copy_size, size_t alloc_size)\n+void *\n+xmemdup (const void *input, size_t copy_size, size_t alloc_size)\n {\n-  PTR output = xmalloc (alloc_size);\n+  void *output = xmalloc (alloc_size);\n   if (alloc_size > copy_size)\n     memset ((char *) output + copy_size, 0, alloc_size - copy_size);\n-  return (PTR) memcpy (output, input, copy_size);\n+  return (void *) memcpy (output, input, copy_size);\n }"}]}