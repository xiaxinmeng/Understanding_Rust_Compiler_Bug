{"sha": "fd66407104b2133f0e55deb84db787c692a21948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2NjQwNzEwNGIyMTMzZjBlNTVkZWI4NGRiNzg3YzY5MmEyMTk0OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-03-03T11:44:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-09T08:09:06Z"}, "message": "[Ada] Implement AI12-0028: Import of variadic C functions\n\n2020-06-09  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Freeze_Subprogram): Deal with convention C_Family.\n\t* freeze.adb (Freeze_Profile): Likewise.  Add missing guard.\n\t* sem_mech.adb (Set_Mechanisms): Likewise.\n\t* lib-xref.adb (Output_Import_Export_Info): Ditto for C_Variadic.\n\t* repinfo.adb (List_Subprogram_Info): Likewise.\n\t* sem_prag.adb (Set_Convention_From_Pragma): Move main checks for\n\tStdcall to...\n\t(Process_Convention): ...here.  Add checks for C_Variadic.\n\t* snames.ads-tmpl: Add Name_C_Variadic_0 .. Name_C_Variadic_16.\n\tUse consistent format for subtype declarations.\n\t(Convention_Id): Add Convention_C_Variadic_0 .. C_Variadic_16\n\tand move Convention_CPP up.\n\t(Convention_C_Family): New subtype of Convention_Id.\n\t(Convention_C_Variadic): Likewise.\n\t(Foreign_Convention): Use explicit upper bound.\n\tAdd pragma Inline for Is_Configuration_Pragma_Name,\n\tIs_Function_Attribute_Name, Is_Internal_Attribute_Name\n\tand Is_Procedure_Attribute_Name.\n\t* snames.adb-tmpl (Get_Convention_Id): Deal with Name_Variadic_n.\n\t(Get_Convention_Name): Deal with Convention_Variadic_n.\n\t* types.h (Convention_Id): New typedef.\n\t* xsnamest.adb (Name2): New variable.\n\t(Is_Conv): New pattern.\n\t(Get_Subt1): Likewise.\n\t(Get_Subt2): Likewise.\n\tOutput subtypes of Convention_Id into the C header file.", "tree": {"sha": "628e3735093268193368896af1156e6831f4cb18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/628e3735093268193368896af1156e6831f4cb18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd66407104b2133f0e55deb84db787c692a21948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd66407104b2133f0e55deb84db787c692a21948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd66407104b2133f0e55deb84db787c692a21948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd66407104b2133f0e55deb84db787c692a21948/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d6f6e08e69209d3df5b49b738c08ce3e921bf44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6f6e08e69209d3df5b49b738c08ce3e921bf44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6f6e08e69209d3df5b49b738c08ce3e921bf44"}], "stats": {"total": 385, "additions": 278, "deletions": 107}, "files": [{"sha": "5a0cbf46c95e2e7bef84bbda1ce9f5bcd7ce5c72", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -7716,8 +7716,7 @@ package body Exp_Ch6 is\n             --  Build_Inherit_Prims takes care of initializing these slots.\n \n             elsif Is_Imported (Subp)\n-               and then (Convention (Subp) = Convention_CPP\n-                           or else Convention (Subp) = Convention_C)\n+               and then Convention (Subp) in Convention_C_Family\n             then\n                null;\n "}, {"sha": "d562b1e93455ff73091b6b6d9fcf797651787cb9", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -3674,9 +3674,7 @@ package body Freeze is\n \n             if Warn_On_Export_Import\n               and then Comes_From_Source (E)\n-              and then (Convention (E) = Convention_C\n-                          or else\n-                        Convention (E) = Convention_CPP)\n+              and then Convention (E) in Convention_C_Family\n               and then (Is_Imported (E) or else Is_Exported (E))\n               and then Convention (E) /= Convention (Formal)\n               and then not Has_Warnings_Off (E)\n@@ -3823,9 +3821,8 @@ package body Freeze is\n             --  Check suspicious return type for C function\n \n             if Warn_On_Export_Import\n-              and then (Convention (E) = Convention_C\n-                          or else\n-                        Convention (E) = Convention_CPP)\n+              and then Comes_From_Source (E)\n+              and then Convention (E) in Convention_C_Family\n               and then (Is_Imported (E) or else Is_Exported (E))\n             then\n                --  Check suspicious return of fat C pointer"}, {"sha": "2c313ea7bd40f7e614ef791896a362e76fa42cf9", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -1652,7 +1652,7 @@ package body Lib.Xref is\n       begin\n          --  Generate language name from convention\n \n-         if Conv  = Convention_C then\n+         if Conv = Convention_C or else Conv in Convention_C_Variadic then\n             Language_Name := Name_C;\n \n          elsif Conv = Convention_CPP then"}, {"sha": "322b5f9574fd441c8d5b3dd3d3ec7b73d719cecd", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -1935,6 +1935,21 @@ package body Repinfo is\n          when Convention_C =>\n             Write_Str (\"C\");\n \n+         when Convention_C_Variadic =>\n+            declare\n+               N : Nat :=\n+                 Convention_Id'Pos (Convention (Ent)) -\n+                   Convention_Id'Pos (Convention_C_Variadic_0);\n+            begin\n+               Write_Str (\"C_Variadic_\");\n+               if N >= 10 then\n+                  Write_Char ('1');\n+                  N := N - 10;\n+               end if;\n+               pragma Assert (N < 10);\n+               Write_Char (Character'Val (Character'Pos ('0') + N));\n+            end;\n+\n          when Convention_COBOL =>\n             Write_Str (\"COBOL\");\n "}, {"sha": "0c6c822ca632a36dc6dffc706ba8d83de8614660", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -181,11 +181,10 @@ package body Sem_Mech is\n                -- C --\n                -------\n \n-               --  Note: Assembler, C++, Stdcall also use C conventions\n+               --  Note: Assembler and Stdcall also use C conventions\n \n                when Convention_Assembler\n-                  | Convention_C\n-                  | Convention_CPP\n+                  | Convention_C_Family\n                   | Convention_Stdcall\n                =>\n                   --  The following values are passed by copy"}, {"sha": "666b54deed9f982f32bae28c980b67e286c24432", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 120, "deletions": 55, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -7957,59 +7957,24 @@ package body Sem_Prag is\n                Error_Pragma_Arg\n                  (\"cannot change convention for overridden dispatching \"\n                   & \"operation\", Arg1);\n-            end if;\n-\n-            --  Special checks for Convention_Stdcall\n-\n-            if C = Convention_Stdcall then\n-\n-               --  A dispatching call is not allowed. A dispatching subprogram\n-               --  cannot be used to interface to the Win32 API, so in fact\n-               --  this check does not impose any effective restriction.\n-\n-               if Is_Dispatching_Operation (E) then\n-                  Error_Msg_Sloc := Sloc (E);\n-\n-                  --  Note: make this unconditional so that if there is more\n-                  --  than one call to which the pragma applies, we get a\n-                  --  message for each call. Also don't use Error_Pragma,\n-                  --  so that we get multiple messages.\n-\n-                  Error_Msg_N\n-                    (\"dispatching subprogram# cannot use Stdcall convention!\",\n-                     Arg1);\n-\n-               --  Several allowed cases\n-\n-               elsif Is_Subprogram_Or_Generic_Subprogram (E)\n \n-                 --  A variable is OK\n+            --  Special check for convention Stdcall: a dispatching call is not\n+            --  allowed. A dispatching subprogram cannot be used to interface\n+            --  to the Win32 API, so this check actually does not impose any\n+            --  effective restriction.\n \n-                 or else Ekind (E) = E_Variable\n-\n-                 --  A component as well. The entity does not have its Ekind\n-                 --  set until the enclosing record declaration is fully\n-                 --  analyzed.\n-\n-                 or else Nkind (Parent (E)) = N_Component_Declaration\n-\n-                 --  An access to subprogram is also allowed\n-\n-                 or else\n-                   (Is_Access_Type (E)\n-                     and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n-\n-                 --  Allow internal call to set convention of subprogram type\n-\n-                 or else Ekind (E) = E_Subprogram_Type\n-               then\n-                  null;\n+            elsif Is_Dispatching_Operation (E)\n+              and then C = Convention_Stdcall\n+            then\n+               --  Note: make this unconditional so that if there is more\n+               --  than one call to which the pragma applies, we get a\n+               --  message for each call. Also don't use Error_Pragma,\n+               --  so that we get multiple messages.\n \n-               else\n-                  Error_Pragma_Arg\n-                    (\"second argument of pragma% must be subprogram (type)\",\n-                     Arg2);\n-               end if;\n+               Error_Msg_Sloc := Sloc (E);\n+               Error_Msg_N\n+                 (\"dispatching subprogram# cannot use Stdcall convention!\",\n+                  Get_Pragma_Arg (Arg1));\n             end if;\n \n             --  Set the convention\n@@ -8113,6 +8078,7 @@ package body Sem_Prag is\n          E         : Entity_Id;\n          E1        : Entity_Id;\n          Id        : Node_Id;\n+         Subp      : Entity_Id;\n \n       --  Start of processing for Process_Convention\n \n@@ -8284,13 +8250,114 @@ package body Sem_Prag is\n                Error_Pragma_Arg\n                  (\"second argument of pragma% must be a subprogram\", Arg2);\n             end if;\n+\n+         --  Special checks for C_Variadic_n\n+\n+         elsif C in Convention_C_Variadic then\n+\n+            --  Several allowed cases\n+\n+            if Is_Subprogram_Or_Generic_Subprogram (E) then\n+               Subp := E;\n+\n+            --  An access to subprogram is also allowed\n+\n+            elsif Is_Access_Type (E)\n+              and then Ekind (Designated_Type (E)) = E_Subprogram_Type\n+            then\n+               Subp := Designated_Type (E);\n+\n+            --  Allow internal call to set convention of subprogram type\n+\n+            elsif Ekind (E) = E_Subprogram_Type then\n+               Subp := E;\n+\n+            else\n+               Error_Pragma_Arg\n+                 (\"argument of pragma% must be subprogram or access type\",\n+                  Arg2);\n+               Subp := Empty;\n+            end if;\n+\n+            --  ISO C requires a named parameter before the ellipsis, so a\n+            --  variadic C function taking 0 fixed parameter cannot exist.\n+\n+            if C = Convention_C_Variadic_0 then\n+\n+               Error_Msg_N\n+                 (\"??C_Variadic_0 cannot be used for an 'I'S'O C function\",\n+                  Get_Pragma_Arg (Arg2));\n+\n+            --  Now check the number of parameters of the subprogram\n+\n+            elsif Present (Subp) then\n+               declare\n+                  Minimum : constant Nat :=\n+                    Convention_Id'Pos (C) -\n+                      Convention_Id'Pos (Convention_C_Variadic_0);\n+\n+                  Count  : Nat;\n+                  Formal : Entity_Id;\n+\n+               begin\n+                  Count := 0;\n+                  Formal := First_Formal (Subp);\n+                  while Present (Formal) loop\n+                     Count := Count + 1;\n+                     Next_Formal (Formal);\n+                  end loop;\n+\n+                  if Count < Minimum then\n+                     Error_Msg_Uint_1 := UI_From_Int (Minimum);\n+                     Error_Pragma_Arg\n+                       (\"argument of pragma% must have at least\"\n+                        & \"^ parameters\", Arg2);\n+                  end if;\n+               end;\n+            end if;\n+\n+         --  Special checks for Stdcall\n+\n+         elsif C = Convention_Stdcall then\n+\n+            --  Several allowed cases\n+\n+            if Is_Subprogram_Or_Generic_Subprogram (E)\n+\n+              --  A variable is OK\n+\n+              or else Ekind (E) = E_Variable\n+\n+              --  A component as well. The entity does not have its Ekind\n+              --  set until the enclosing record declaration is fully\n+              --  analyzed.\n+\n+              or else Nkind (Parent (E)) = N_Component_Declaration\n+\n+              --  An access to subprogram is also allowed\n+\n+              or else\n+                (Is_Access_Type (E)\n+                  and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n+\n+              --  Allow internal call to set convention of subprogram type\n+\n+              or else Ekind (E) = E_Subprogram_Type\n+            then\n+               null;\n+\n+            else\n+               Error_Pragma_Arg\n+                 (\"argument of pragma% must be subprogram or access type\",\n+                  Arg2);\n+            end if;\n          end if;\n \n+         Set_Convention_From_Pragma (E);\n+\n          --  Deal with non-subprogram cases\n \n          if not Is_Subprogram_Or_Generic_Subprogram (E) then\n-            Set_Convention_From_Pragma (E);\n-\n             if Is_Type (E) then\n \n                --  The pragma must apply to a first subtype, but it can also\n@@ -8318,9 +8385,6 @@ package body Sem_Prag is\n          --  compilation unit.\n \n          else\n-            Comp_Unit := Get_Source_Unit (E);\n-            Set_Convention_From_Pragma (E);\n-\n             --  Treat a pragma Import as an implicit body, and pragma import\n             --  as implicit reference (for navigation in GNAT Studio).\n \n@@ -8365,6 +8429,7 @@ package body Sem_Prag is\n             --  Otherwise Loop through the homonyms of the pragma argument's\n             --  entity, an apply convention to those in the current scope.\n \n+            Comp_Unit := Get_Source_Unit (E);\n             E1 := Ent;\n \n             loop"}, {"sha": "ce9c63d94e0298bc96ccb7c1a223606c4ac4c9ae", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -155,6 +155,23 @@ package body Snames is\n                                               Convention_Ada_Pass_By_Reference;\n          when Name_Assembler             => return Convention_Assembler;\n          when Name_C                     => return Convention_C;\n+         when Name_C_Variadic_0          => return Convention_C_Variadic_0;\n+         when Name_C_Variadic_1          => return Convention_C_Variadic_1;\n+         when Name_C_Variadic_2          => return Convention_C_Variadic_2;\n+         when Name_C_Variadic_3          => return Convention_C_Variadic_3;\n+         when Name_C_Variadic_4          => return Convention_C_Variadic_4;\n+         when Name_C_Variadic_5          => return Convention_C_Variadic_5;\n+         when Name_C_Variadic_6          => return Convention_C_Variadic_6;\n+         when Name_C_Variadic_7          => return Convention_C_Variadic_7;\n+         when Name_C_Variadic_8          => return Convention_C_Variadic_8;\n+         when Name_C_Variadic_9          => return Convention_C_Variadic_9;\n+         when Name_C_Variadic_10         => return Convention_C_Variadic_10;\n+         when Name_C_Variadic_11         => return Convention_C_Variadic_11;\n+         when Name_C_Variadic_12         => return Convention_C_Variadic_12;\n+         when Name_C_Variadic_13         => return Convention_C_Variadic_13;\n+         when Name_C_Variadic_14         => return Convention_C_Variadic_14;\n+         when Name_C_Variadic_15         => return Convention_C_Variadic_15;\n+         when Name_C_Variadic_16         => return Convention_C_Variadic_16;\n          when Name_COBOL                 => return Convention_COBOL;\n          when Name_CPP                   => return Convention_CPP;\n          when Name_Fortran               => return Convention_Fortran;\n@@ -189,6 +206,23 @@ package body Snames is\n             return Name_Ada_Pass_By_Reference;\n          when Convention_Assembler             => return Name_Assembler;\n          when Convention_C                     => return Name_C;\n+         when Convention_C_Variadic_0          => return Name_C_Variadic_0;\n+         when Convention_C_Variadic_1          => return Name_C_Variadic_1;\n+         when Convention_C_Variadic_2          => return Name_C_Variadic_2;\n+         when Convention_C_Variadic_3          => return Name_C_Variadic_3;\n+         when Convention_C_Variadic_4          => return Name_C_Variadic_4;\n+         when Convention_C_Variadic_5          => return Name_C_Variadic_5;\n+         when Convention_C_Variadic_6          => return Name_C_Variadic_6;\n+         when Convention_C_Variadic_7          => return Name_C_Variadic_7;\n+         when Convention_C_Variadic_8          => return Name_C_Variadic_8;\n+         when Convention_C_Variadic_9          => return Name_C_Variadic_9;\n+         when Convention_C_Variadic_10         => return Name_C_Variadic_10;\n+         when Convention_C_Variadic_11         => return Name_C_Variadic_11;\n+         when Convention_C_Variadic_12         => return Name_C_Variadic_12;\n+         when Convention_C_Variadic_13         => return Name_C_Variadic_13;\n+         when Convention_C_Variadic_14         => return Name_C_Variadic_14;\n+         when Convention_C_Variadic_15         => return Name_C_Variadic_15;\n+         when Convention_C_Variadic_16         => return Name_C_Variadic_16;\n          when Convention_COBOL                 => return Name_COBOL;\n          when Convention_CPP                   => return Name_CPP;\n          when Convention_Entry                 => return Name_Entry;\n@@ -425,9 +459,9 @@ package body Snames is\n       return N in First_Locking_Policy_Name .. Last_Locking_Policy_Name;\n    end Is_Locking_Policy_Name;\n \n-   -------------------------------------\n-   -- Is_Partition_Elaboration_Policy --\n-   -------------------------------------\n+   ------------------------------------------\n+   -- Is_Partition_Elaboration_Policy_Name --\n+   ------------------------------------------\n \n    function Is_Partition_Elaboration_Policy_Name\n      (N : Name_Id) return Boolean"}, {"sha": "0f39a975cd45045ded66efb517481090fa507af3", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -705,6 +705,23 @@ package Snames is\n    Name_Ada_Pass_By_Copy               : constant Name_Id := N + $;\n    Name_Ada_Pass_By_Reference          : constant Name_Id := N + $;\n    Name_Assembler                      : constant Name_Id := N + $;\n+   Name_C_Variadic_0                   : constant Name_Id := N + $;\n+   Name_C_Variadic_1                   : constant Name_Id := N + $;\n+   Name_C_Variadic_2                   : constant Name_Id := N + $;\n+   Name_C_Variadic_3                   : constant Name_Id := N + $;\n+   Name_C_Variadic_4                   : constant Name_Id := N + $;\n+   Name_C_Variadic_5                   : constant Name_Id := N + $;\n+   Name_C_Variadic_6                   : constant Name_Id := N + $;\n+   Name_C_Variadic_7                   : constant Name_Id := N + $;\n+   Name_C_Variadic_8                   : constant Name_Id := N + $;\n+   Name_C_Variadic_9                   : constant Name_Id := N + $;\n+   Name_C_Variadic_10                  : constant Name_Id := N + $;\n+   Name_C_Variadic_11                  : constant Name_Id := N + $;\n+   Name_C_Variadic_12                  : constant Name_Id := N + $;\n+   Name_C_Variadic_13                  : constant Name_Id := N + $;\n+   Name_C_Variadic_14                  : constant Name_Id := N + $;\n+   Name_C_Variadic_15                  : constant Name_Id := N + $;\n+   Name_C_Variadic_16                  : constant Name_Id := N + $;\n    Name_COBOL                          : constant Name_Id := N + $;\n    Name_CPP                            : constant Name_Id := N + $;\n    Name_Fortran                        : constant Name_Id := N + $;\n@@ -713,6 +730,9 @@ package Snames is\n    Name_Stubbed                        : constant Name_Id := N + $;\n    Last_Convention_Name                : constant Name_Id := N + $;\n \n+   subtype Name_C_Variadic is Name_Id\n+     range Name_C_Variadic_0 .. Name_C_Variadic_16;\n+\n    --  The following names are preset as synonyms for Assembler\n \n    Name_Asm                            : constant Name_Id := N + $;\n@@ -1166,14 +1186,14 @@ package Snames is\n    Name_Unsigned_32                    : constant Name_Id := N + $; -- GNAT\n    Name_Unsigned_64                    : constant Name_Id := N + $; -- GNAT\n \n-   subtype Scalar_Id is Name_Id range\n-     Name_Short_Float .. Name_Unsigned_64;\n+   subtype Scalar_Id is Name_Id\n+     range Name_Short_Float .. Name_Unsigned_64;\n \n-   subtype Float_Scalar_Id is Name_Id range\n-     Name_Short_Float .. Name_Long_Long_Float;\n+   subtype Float_Scalar_Id is Name_Id\n+     range Name_Short_Float .. Name_Long_Long_Float;\n \n-   subtype Integer_Scalar_Id is Name_Id range\n-     Name_Signed_8 .. Name_Unsigned_64;\n+   subtype Integer_Scalar_Id is Name_Id\n+     range Name_Signed_8 .. Name_Unsigned_64;\n \n    --  Names of recognized checks for pragma Suppress\n \n@@ -1314,8 +1334,8 @@ package Snames is\n    Name_Tagged                           : constant Name_Id := N + $;\n    Last_95_Reserved_Word                 : constant Name_Id := N + $;\n \n-   subtype Ada_95_Reserved_Words is\n-     Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n+   subtype Ada_95_Reserved_Words is Name_Id\n+     range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n@@ -1526,17 +1546,17 @@ package Snames is\n    Name_Synchronized                     : constant Name_Id := N + $;\n    Last_2005_Reserved_Word               : constant Name_Id := N + $;\n \n-   subtype Ada_2005_Reserved_Words is\n-     Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n+   subtype Ada_2005_Reserved_Words is Name_Id\n+     range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Ada 2012 reserved words\n \n    First_2012_Reserved_Word              : constant Name_Id := N + $;\n    Name_Some                             : constant Name_Id := N + $;\n    Last_2012_Reserved_Word               : constant Name_Id := N + $;\n \n-   subtype Ada_2012_Reserved_Words is\n-     Name_Id range First_2012_Reserved_Word .. Last_2012_Reserved_Word;\n+   subtype Ada_2012_Reserved_Words is Name_Id\n+     range First_2012_Reserved_Word .. Last_2012_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n@@ -1546,11 +1566,11 @@ package Snames is\n    -- Subtypes Defining Name Categories --\n    ---------------------------------------\n \n-   subtype Any_Operator_Name is Name_Id range\n-     First_Operator_Name .. Last_Operator_Name;\n+   subtype Any_Operator_Name is Name_Id\n+     range First_Operator_Name .. Last_Operator_Name;\n \n-   subtype Configuration_Pragma_Names is Name_Id range\n-     First_Pragma_Name .. Last_Configuration_Pragma_Name;\n+   subtype Configuration_Pragma_Names is Name_Id\n+     range First_Pragma_Name .. Last_Configuration_Pragma_Name;\n \n    ------------------------------\n    -- Attribute ID Definitions --\n@@ -1755,8 +1775,8 @@ package Snames is\n       Attribute_Dispatching_Domain,\n       Attribute_Interrupt_Priority);\n \n-   subtype Internal_Attribute_Id is Attribute_Id range\n-     Attribute_CPU .. Attribute_Interrupt_Priority;\n+   subtype Internal_Attribute_Id is Attribute_Id\n+     range Attribute_CPU .. Attribute_Interrupt_Priority;\n \n    type Attribute_Class_Array is array (Attribute_Id) of Boolean;\n    --  Type used to build attribute classification flag arrays\n@@ -1784,12 +1804,29 @@ package Snames is\n \n       --  The remaining conventions are foreign language conventions\n \n-      Convention_Assembler,  --  also Asm, Assembly\n-      Convention_C,          --  also Default, External\n-      Convention_COBOL,\n+      Convention_Assembler,      --  also Asm, Assembly\n+      Convention_C,              --  also Default, External\n+      Convention_C_Variadic_0,\n+      Convention_C_Variadic_1,\n+      Convention_C_Variadic_2,\n+      Convention_C_Variadic_3,\n+      Convention_C_Variadic_4,\n+      Convention_C_Variadic_5,\n+      Convention_C_Variadic_6,\n+      Convention_C_Variadic_7,\n+      Convention_C_Variadic_8,\n+      Convention_C_Variadic_9,\n+      Convention_C_Variadic_10,\n+      Convention_C_Variadic_11,\n+      Convention_C_Variadic_12,\n+      Convention_C_Variadic_13,\n+      Convention_C_Variadic_14,\n+      Convention_C_Variadic_15,\n+      Convention_C_Variadic_16,\n       Convention_CPP,\n+      Convention_COBOL,\n       Convention_Fortran,\n-      Convention_Stdcall);   --  also DLL, Win32\n+      Convention_Stdcall);       --  also DLL, Win32\n \n       --  Note: Convention C_Pass_By_Copy is allowed only for record types\n       --  (where it is treated like C except that the appropriate flag is set\n@@ -1799,8 +1836,14 @@ package Snames is\n    for Convention_Id'Size use 8;\n    --  Plenty of space for expansion\n \n-   subtype Foreign_Convention is\n-     Convention_Id range Convention_Assembler .. Convention_Id'Last;\n+   subtype Convention_C_Family is Convention_Id\n+     range Convention_C .. Convention_CPP;\n+\n+   subtype Convention_C_Variadic is Convention_Id\n+     range Convention_C_Variadic_0 .. Convention_C_Variadic_16;\n+\n+   subtype Foreign_Convention is Convention_Id\n+     range Convention_Assembler .. Convention_Stdcall;\n \n    -----------------------------------\n    -- Locking Policy ID Definitions --\n@@ -2226,13 +2269,17 @@ package Snames is\n \n private\n    pragma Inline (Is_Attribute_Name);\n+   pragma Inline (Is_Configuration_Pragma_Name);\n    pragma Inline (Is_Entity_Attribute_Name);\n-   pragma Inline (Is_Type_Attribute_Name);\n+   pragma Inline (Is_Function_Attribute_Name);\n+   pragma Inline (Is_Internal_Attribute_Name);\n    pragma Inline (Is_Locking_Policy_Name);\n    pragma Inline (Is_Partition_Elaboration_Policy_Name);\n    pragma Inline (Is_Operator_Symbol_Name);\n-   pragma Inline (Is_Queuing_Policy_Name);\n    pragma Inline (Is_Pragma_Name);\n+   pragma Inline (Is_Procedure_Attribute_Name);\n+   pragma Inline (Is_Queuing_Policy_Name);\n    pragma Inline (Is_Task_Dispatching_Policy_Name);\n+   pragma Inline (Is_Type_Attribute_Name);\n \n end Snames;"}, {"sha": "e7eeae0b4ca90d4917e4226da2b8660a9c941e56", "filename": "gcc/ada/types.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -139,10 +139,13 @@ typedef Text_Ptr Source_Ptr;\n /* Used for Sloc in all nodes in the representation of package Standard.  */\n #define Standard_Location -2\n \n-/* Instance identifiers */\n+/* Convention identifiers.  */\n+typedef Byte Convention_Id;\n+\n+/* Instance identifiers.  */\n typedef Nat Instance_Id;\n \n-/* Type used for union of all possible ID values covering all ranges */\n+/* Type used for union of all possible ID values covering all ranges.  */\n typedef int Union_Id;\n \n /* Range definitions for Tree Data:  */"}, {"sha": "834d3c4655c33aeb175c08e15454dd3f630f4e6d", "filename": "gcc/ada/xsnamest.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fxsnamest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd66407104b2133f0e55deb84db787c692a21948/gcc%2Fada%2Fxsnamest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxsnamest.adb?ref=fd66407104b2133f0e55deb84db787c692a21948", "patch": "@@ -58,6 +58,7 @@ procedure XSnamesT is\n    Line  : VString := Nul;\n    Name0 : VString := Nul;\n    Name1 : VString := Nul;\n+   Name2 : VString := Nul;\n    Oval  : VString := Nul;\n    Restl : VString := Nul;\n \n@@ -69,6 +70,7 @@ procedure XSnamesT is\n    Get_Name : constant Pattern := \"Name_\" & Rest * Name1;\n    Chk_Low  : constant Pattern := Pos (0) & Any (Lower_Set) & Rest & Pos (1);\n    Findu    : constant Pattern := Span ('u') * A;\n+   Is_Conv  : constant Pattern := \"Convention_\" & Rest;\n \n    Val : Natural;\n \n@@ -98,12 +100,18 @@ procedure XSnamesT is\n \n    --  Patterns used in the spec file\n \n-   Get_Attr : constant Pattern := Span (' ') & \"Attribute_\"\n-                                  & Break (\",)\") * Name1;\n-   Get_Conv : constant Pattern := Span (' ') & \"Convention_\"\n-                                  & Break (\",)\") * Name1;\n-   Get_Prag : constant Pattern := Span (' ') & \"Pragma_\"\n-                                  & Break (\",)\") * Name1;\n+   Get_Attr  : constant Pattern := Span (' ') & \"Attribute_\"\n+                                   & Break (\",)\") * Name1;\n+   Get_Conv  : constant Pattern := Span (' ') & \"Convention_\"\n+                                   & Break (\",)\") * Name1;\n+   Get_Prag  : constant Pattern := Span (' ') & \"Pragma_\"\n+                                   & Break (\",)\") * Name1;\n+   Get_Subt1 : constant Pattern := Span (' ') & \"subtype \"\n+                                   & Break (' ') * Name1\n+                                   & \" is \" & Rest * Name2;\n+   Get_Subt2 : constant Pattern := Span (' ') & \"range \"\n+                                   & Break (' ') * Name1\n+                                   & \" .. \" & Break (\";\") * Name2;\n \n    type Header_Symbol_Counter is array (Header_Symbol) of Natural;\n    Header_Counter : Header_Symbol_Counter := (0, 0, 0, 0, 0);\n@@ -143,7 +151,6 @@ procedure XSnamesT is\n \n       if Header_Current_Symbol /= S then\n          declare\n-            Name2 : VString;\n             Pat : constant Pattern := \"#define  \"\n                                        & Header_Prefix (S).all\n                                        & Break (' ') * Name2;\n@@ -227,6 +234,11 @@ begin\n             Output_Header_Line (Conv);\n          elsif Match (Line, Get_Prag) then\n             Output_Header_Line (Prag);\n+         elsif Match (Line, Get_Subt1) and then Match (Name2, Is_Conv) then\n+            New_Line (OutH);\n+            Put_Line (OutH, \"SUBTYPE (\" & Name1 & \", \" & Name2 & \", \");\n+         elsif Match (Line, Get_Subt2) and then Match (Name1, Is_Conv) then\n+            Put_Line (OutH, \"   \" & Name1 & \", \" & Name2 & ')');\n          end if;\n       else\n "}]}