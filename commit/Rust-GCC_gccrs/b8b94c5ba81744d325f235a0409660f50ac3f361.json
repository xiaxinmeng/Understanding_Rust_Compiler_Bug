{"sha": "b8b94c5ba81744d325f235a0409660f50ac3f361", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhiOTRjNWJhODE3NDRkMzI1ZjIzNWEwNDA5NjYwZjUwYWMzZjM2MQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-09-23T11:58:15Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-09-23T11:58:15Z"}, "message": "re PR c++/17596 (expression parser is too slow, should be rewritten)\n\n2004-09-23  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR c++/17596\n\n\t* parser.c (cp_parser_token_tree_map_node,\n\tcp_parser_pm_expression, cp_parser_additive_expression,\n\tcp_parser_multiplicative_expression, cp_parser_shift_expression,\n\tcp_parser_relational_expression, cp_parser_equality_expression,\n\tcp_parser_and_expression, cp_parser_exclusive_or_expression,\n\tcp_parser_inclusive_or_expression,\n\tcp_parser_logical_and_expression,\n\tcp_parser_logical_or_expression): Removed.\n\t(enum cp_parser_prec, struct cp_parser_token_tree_map_node,\n\tbinops, binops_by_token): New.\n\t(cp_parser_assignment_expression): Use cp_parser_binary_expression.\n\t(cp_parser_new): Initialize binops_by_token.\n\t(cp_parser_binary_expression): Rewritten.\n\t(N_CP_TTYPES): New.\n\nFrom-SVN: r87942", "tree": {"sha": "2c56f1a1653b9a207d3f5077600a12d7209d11ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c56f1a1653b9a207d3f5077600a12d7209d11ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8b94c5ba81744d325f235a0409660f50ac3f361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b94c5ba81744d325f235a0409660f50ac3f361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b94c5ba81744d325f235a0409660f50ac3f361", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b94c5ba81744d325f235a0409660f50ac3f361/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8921359e5d926d16a2cc476b52e5f91f33fc7120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8921359e5d926d16a2cc476b52e5f91f33fc7120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8921359e5d926d16a2cc476b52e5f91f33fc7120"}], "stats": {"total": 539, "additions": 227, "deletions": 312}, "files": [{"sha": "f5340eea333c587951da22beec7acf325747b7df", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b94c5ba81744d325f235a0409660f50ac3f361/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b94c5ba81744d325f235a0409660f50ac3f361/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b8b94c5ba81744d325f235a0409660f50ac3f361", "patch": "@@ -1,3 +1,22 @@\n+2004-09-23  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR c++/17596\n+\n+\t* parser.c (cp_parser_token_tree_map_node,\n+\tcp_parser_pm_expression, cp_parser_additive_expression,\n+\tcp_parser_multiplicative_expression, cp_parser_shift_expression,\n+\tcp_parser_relational_expression, cp_parser_equality_expression,\n+\tcp_parser_and_expression, cp_parser_exclusive_or_expression,\n+\tcp_parser_inclusive_or_expression,\n+\tcp_parser_logical_and_expression,\n+\tcp_parser_logical_or_expression): Removed.\n+\t(enum cp_parser_prec, struct cp_parser_token_tree_map_node,\n+\tbinops, binops_by_token): New.\n+\t(cp_parser_assignment_expression): Use cp_parser_binary_expression.\n+\t(cp_parser_new): Initialize binops_by_token.\n+\t(cp_parser_binary_expression): Rewritten.\n+\t(N_CP_TTYPES): New.\n+\n 2004-09-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* parser.c: Fix a comment typo."}, {"sha": "05d5b6d5c6613620e5d839efa50e65a4aaa90615", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 208, "deletions": 312, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b94c5ba81744d325f235a0409660f50ac3f361/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b94c5ba81744d325f235a0409660f50ac3f361/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b8b94c5ba81744d325f235a0409660f50ac3f361", "patch": "@@ -203,7 +203,10 @@ static cp_token_cache *cp_token_cache_new\n /* A token type for tokens that are not tokens at all; these are used\n    to represent slots in the array where there used to be a token\n    that has now been deleted. */\n-#define CPP_PURGED (CPP_NESTED_NAME_SPECIFIER + 1)\n+#define CPP_PURGED ((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))\n+\n+/* The number of token types, including C++-specific ones.  */\n+#define N_CP_TTYPES ((int) (CPP_PURGED + 1))\n \n /* Variables.  */\n \n@@ -1038,18 +1041,11 @@ make_parameter_declarator (cp_decl_specifier_seq *decl_specifiers,\n    Future Improvements\n    -------------------\n \n-   The performance of the parser could probably be improved\n-   substantially.  Some possible improvements include:\n-\n-     - The expression parser recurses through the various levels of\n-       precedence as specified in the grammar, rather than using an\n-       operator-precedence technique.  Therefore, parsing a simple\n-       identifier requires multiple recursive calls.\n-\n-     - We could often eliminate the need to parse tentatively by\n-       looking ahead a little bit.  In some places, this approach\n-       might not entirely eliminate the need to parse tentatively, but\n-       it might still speed up the average case.  */\n+   The performance of the parser could probably be improved substantially.\n+   We could often eliminate the need to parse tentatively by looking ahead\n+   a little bit.  In some places, this approach might not entirely eliminate\n+   the need to parse tentatively, but it might still speed up the average\n+   case.  */\n \n /* Flags that are passed to some parsing functions.  These values can\n    be bitwise-ored together.  */\n@@ -1077,20 +1073,39 @@ typedef enum cp_parser_declarator_kind\n   CP_PARSER_DECLARATOR_EITHER\n } cp_parser_declarator_kind;\n \n-/* A mapping from a token type to a corresponding tree node type.  */\n+/* The precedence values used to parse binary expressions.  The minimum value\n+   of PREC must be 1, because zero is reserved to quickly discriminate\n+   binary operators from other tokens.  */\n \n-typedef struct cp_parser_token_tree_map_node\n+enum cp_parser_prec\n {\n-  /* The token type.  */\n-  ENUM_BITFIELD (cpp_ttype) token_type : 8;\n-  /* The corresponding tree code.  */\n-  ENUM_BITFIELD (tree_code) tree_type : 8;\n-} cp_parser_token_tree_map_node;\n+  PREC_NOT_OPERATOR,\n+  PREC_LOGICAL_OR_EXPRESSION,\n+  PREC_LOGICAL_AND_EXPRESSION,\n+  PREC_INCLUSIVE_OR_EXPRESSION,\n+  PREC_EXCLUSIVE_OR_EXPRESSION,\n+  PREC_AND_EXPRESSION,\n+  PREC_RELATIONAL_EXPRESSION,\n+  PREC_EQUALITY_EXPRESSION,\n+  PREC_SHIFT_EXPRESSION,\n+  PREC_ADDITIVE_EXPRESSION,\n+  PREC_MULTIPLICATIVE_EXPRESSION,\n+  PREC_PM_EXPRESSION,\n+  NUM_PREC_VALUES = PREC_PM_EXPRESSION\n+};\n \n-/* A complete map consists of several ordinary entries, followed by a\n-   terminator.  The terminating entry has a token_type of CPP_EOF.  */\n+/* A mapping from a token type to a corresponding tree node type, with a\n+   precedence value.  */\n \n-typedef cp_parser_token_tree_map_node cp_parser_token_tree_map[];\n+typedef struct cp_parser_binary_operations_map_node\n+{\n+  /* The token type.  */\n+  enum cpp_ttype token_type;\n+  /* The corresponding tree code.  */\n+  enum tree_code tree_type;\n+  /* The precedence of this operator.  */\n+  enum cp_parser_prec prec;\n+} cp_parser_binary_operations_map_node;\n \n /* The status of a tentative parse.  */\n \n@@ -1105,8 +1120,17 @@ typedef enum cp_parser_status_kind\n   CP_PARSER_STATUS_KIND_COMMITTED\n } cp_parser_status_kind;\n \n-/* Context that is saved and restored when parsing tentatively.  */\n+typedef struct cp_parser_expression_stack_entry\n+{\n+  tree lhs;\n+  enum tree_code tree_type;\n+  int prec;\n+} cp_parser_expression_stack_entry;\n+\n+typedef struct cp_parser_expression_stack_entry\n+  cp_parser_expression_stack[NUM_PREC_VALUES];\n \n+/* Context that is saved and restored when parsing tentatively.  */\n typedef struct cp_parser_context GTY (())\n {\n   /* If this is a tentative parsing context, the status of the\n@@ -1117,6 +1141,7 @@ typedef struct cp_parser_context GTY (())\n      scope given by OBJECT_TYPE (the type of `x' or `*x') and also in\n      the context of the containing expression.  */\n   tree object_type;\n+\n   /* The next parsing context in the stack.  */\n   struct cp_parser_context *next;\n } cp_parser_context;\n@@ -1132,6 +1157,50 @@ static cp_parser_context *cp_parser_context_new\n \n static GTY((deletable)) cp_parser_context* cp_parser_context_free_list;\n \n+/* The operator-precedence table used by cp_parser_binary_expression.\n+   Transformed into an associative array (binops_by_token) by\n+   cp_parser_new.  */\n+\n+static const cp_parser_binary_operations_map_node binops[] = {\n+  { CPP_DEREF_STAR, MEMBER_REF, PREC_PM_EXPRESSION },\n+  { CPP_DOT_STAR, DOTSTAR_EXPR, PREC_PM_EXPRESSION },\n+\n+  { CPP_MULT, MULT_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },\n+  { CPP_DIV, TRUNC_DIV_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },\n+  { CPP_MOD, TRUNC_MOD_EXPR, PREC_MULTIPLICATIVE_EXPRESSION },\n+\n+  { CPP_PLUS, PLUS_EXPR, PREC_ADDITIVE_EXPRESSION },\n+  { CPP_MINUS, MINUS_EXPR, PREC_ADDITIVE_EXPRESSION },\n+\n+  { CPP_LSHIFT, LSHIFT_EXPR, PREC_SHIFT_EXPRESSION },\n+  { CPP_RSHIFT, RSHIFT_EXPR, PREC_SHIFT_EXPRESSION },\n+\n+  { CPP_LESS, LT_EXPR, PREC_RELATIONAL_EXPRESSION },\n+  { CPP_GREATER, GT_EXPR, PREC_RELATIONAL_EXPRESSION },\n+  { CPP_LESS_EQ, LE_EXPR, PREC_RELATIONAL_EXPRESSION },\n+  { CPP_GREATER_EQ, GE_EXPR, PREC_RELATIONAL_EXPRESSION },\n+  { CPP_MIN, MIN_EXPR, PREC_RELATIONAL_EXPRESSION },\n+  { CPP_MAX, MAX_EXPR, PREC_RELATIONAL_EXPRESSION },\n+\n+  { CPP_EQ_EQ, EQ_EXPR, PREC_EQUALITY_EXPRESSION },\n+  { CPP_NOT_EQ, NE_EXPR, PREC_EQUALITY_EXPRESSION },\n+\n+  { CPP_AND, BIT_AND_EXPR, PREC_AND_EXPRESSION },\n+\n+  { CPP_XOR, BIT_XOR_EXPR, PREC_EXCLUSIVE_OR_EXPRESSION },\n+\n+  { CPP_OR, BIT_IOR_EXPR, PREC_INCLUSIVE_OR_EXPRESSION },\n+\n+  { CPP_AND_AND, TRUTH_ANDIF_EXPR, PREC_LOGICAL_AND_EXPRESSION },\n+\n+  { CPP_OR_OR, TRUTH_ORIF_EXPR, PREC_LOGICAL_OR_EXPRESSION }\n+};\n+\n+/* The same as binops, but initialized by cp_parser_new so that\n+   binops_by_token[N].token_type == N.  Used in cp_parser_binary_expression\n+   for speed.  */\n+static cp_parser_binary_operations_map_node binops_by_token[N_CP_TTYPES];\n+\n /* Constructors and destructors.  */\n \n /* Construct a new context.  The context below this one on the stack\n@@ -1152,6 +1221,7 @@ cp_parser_context_new (cp_parser_context* next)\n     }\n   else\n     context = GGC_CNEW (cp_parser_context);\n+\n   /* No errors have occurred yet in this context.  */\n   context->status = CP_PARSER_STATUS_KIND_NO_ERROR;\n   /* If this is not the bottomost context, copy information that we\n@@ -1377,27 +1447,7 @@ static tree cp_parser_delete_expression\n   (cp_parser *);\n static tree cp_parser_cast_expression\n   (cp_parser *, bool);\n-static tree cp_parser_pm_expression\n-  (cp_parser *);\n-static tree cp_parser_multiplicative_expression\n-  (cp_parser *);\n-static tree cp_parser_additive_expression\n-  (cp_parser *);\n-static tree cp_parser_shift_expression\n-  (cp_parser *);\n-static tree cp_parser_relational_expression\n-  (cp_parser *);\n-static tree cp_parser_equality_expression\n-  (cp_parser *);\n-static tree cp_parser_and_expression\n-  (cp_parser *);\n-static tree cp_parser_exclusive_or_expression\n-  (cp_parser *);\n-static tree cp_parser_inclusive_or_expression\n-  (cp_parser *);\n-static tree cp_parser_logical_and_expression\n-  (cp_parser *);\n-static tree cp_parser_logical_or_expression\n+static tree cp_parser_binary_expression\n   (cp_parser *);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n@@ -1651,8 +1701,6 @@ static bool cp_parser_check_template_parameters\n   (cp_parser *, unsigned);\n static tree cp_parser_simple_cast_expression\n   (cp_parser *);\n-static tree cp_parser_binary_expression\n-  (cp_parser *, const cp_parser_token_tree_map, cp_parser_expression_fn);\n static tree cp_parser_global_scope_opt\n   (cp_parser *, bool);\n static bool cp_parser_constructor_declarator_p\n@@ -2340,11 +2388,17 @@ cp_parser_new (void)\n {\n   cp_parser *parser;\n   cp_lexer *lexer;\n+  unsigned i;\n \n   /* cp_lexer_new_main is called before calling ggc_alloc because\n      cp_lexer_new_main might load a PCH file.  */\n   lexer = cp_lexer_new_main ();\n \n+  /* Initialize the binops_by_token so that we can get the tree\n+     directly from the token.  */\n+  for (i = 0; i < sizeof (binops) / sizeof (binops[0]); i++)\n+    binops_by_token[binops[i].token_type] = binops[i];\n+\n   parser = GGC_CNEW (cp_parser);\n   parser->lexer = lexer;\n   parser->context = cp_parser_context_new (NULL);\n@@ -5161,263 +5215,178 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n   return cp_parser_unary_expression (parser, address_p);\n }\n \n-/* Parse a pm-expression.\n+/* Parse a binary expression of the general form:\n \n    pm-expression:\n      cast-expression\n      pm-expression .* cast-expression\n      pm-expression ->* cast-expression\n \n-     Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_pm_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_DEREF_STAR, MEMBER_REF },\n-    { CPP_DOT_STAR, DOTSTAR_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser, map,\n-\t\t\t\t      cp_parser_simple_cast_expression);\n-}\n-\n-/* Parse a multiplicative-expression.\n-\n    multiplicative-expression:\n      pm-expression\n      multiplicative-expression * pm-expression\n      multiplicative-expression / pm-expression\n      multiplicative-expression % pm-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_multiplicative_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_MULT, MULT_EXPR },\n-    { CPP_DIV, TRUNC_DIV_EXPR },\n-    { CPP_MOD, TRUNC_MOD_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_pm_expression);\n-}\n-\n-/* Parse an additive-expression.\n-\n    additive-expression:\n      multiplicative-expression\n      additive-expression + multiplicative-expression\n      additive-expression - multiplicative-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_additive_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_PLUS, PLUS_EXPR },\n-    { CPP_MINUS, MINUS_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_multiplicative_expression);\n-}\n-\n-/* Parse a shift-expression.\n-\n    shift-expression:\n      additive-expression\n      shift-expression << additive-expression\n      shift-expression >> additive-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_shift_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_LSHIFT, LSHIFT_EXPR },\n-    { CPP_RSHIFT, RSHIFT_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_additive_expression);\n-}\n-\n-/* Parse a relational-expression.\n-\n    relational-expression:\n      shift-expression\n      relational-expression < shift-expression\n      relational-expression > shift-expression\n      relational-expression <= shift-expression\n      relational-expression >= shift-expression\n \n-   GNU Extension:\n-\n+  GNU Extension:\n+  \n    relational-expression:\n      relational-expression <? shift-expression\n      relational-expression >? shift-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_relational_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_LESS, LT_EXPR },\n-    { CPP_GREATER, GT_EXPR },\n-    { CPP_LESS_EQ, LE_EXPR },\n-    { CPP_GREATER_EQ, GE_EXPR },\n-    { CPP_MIN, MIN_EXPR },\n-    { CPP_MAX, MAX_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_shift_expression);\n-}\n-\n-/* Parse an equality-expression.\n-\n    equality-expression:\n      relational-expression\n      equality-expression == relational-expression\n      equality-expression != relational-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_equality_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_EQ_EQ, EQ_EXPR },\n-    { CPP_NOT_EQ, NE_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_relational_expression);\n-}\n-\n-/* Parse an and-expression.\n-\n    and-expression:\n      equality-expression\n      and-expression & equality-expression\n \n-   Returns a representation of the expression.  */\n-\n-static tree\n-cp_parser_and_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_AND, BIT_AND_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_equality_expression);\n-}\n-\n-/* Parse an exclusive-or-expression.\n-\n    exclusive-or-expression:\n      and-expression\n      exclusive-or-expression ^ and-expression\n \n-   Returns a representation of the expression.  */\n+   inclusive-or-expression:\n+     exclusive-or-expression\n+     inclusive-or-expression | exclusive-or-expression\n \n-static tree\n-cp_parser_exclusive_or_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_XOR, BIT_XOR_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n+   logical-and-expression:\n+     inclusive-or-expression\n+     logical-and-expression && inclusive-or-expression\n \n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_and_expression);\n-}\n+   logical-or-expression:\n+     logical-and-expression\n+     logical-or-expression || logical-and-expression\n \n+   All these are implemented with a single function like:\n \n-/* Parse an inclusive-or-expression.\n+   binary-expression:\n+     simple-cast-expression\n+     binary-expression <token> binary-expression\n \n-   inclusive-or-expression:\n-     exclusive-or-expression\n-     inclusive-or-expression | exclusive-or-expression\n+   The binops_by_token map is used to get the tree codes for each <token> type.\n+   binary-expressions are associated according to a precedence table.  */\n \n-   Returns a representation of the expression.  */\n+#define TOKEN_PRECEDENCE(token) \\\n+  ((token->type == CPP_GREATER && !parser->greater_than_is_operator_p) \\\n+   ? PREC_NOT_OPERATOR \\\n+   : binops_by_token[token->type].prec)\n \n static tree\n-cp_parser_inclusive_or_expression (cp_parser* parser)\n+cp_parser_binary_expression (cp_parser* parser)\n {\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_OR, BIT_IOR_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n-\n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_exclusive_or_expression);\n-}\n+  cp_parser_expression_stack stack;\n+  cp_parser_expression_stack_entry *sp = &stack[0];\n+  tree lhs, rhs;\n+  cp_token *token;\n+  enum tree_code tree_type;\n+  enum cp_parser_prec prec = PREC_NOT_OPERATOR, new_prec, lookahead_prec;\n+  bool overloaded_p;\n \n-/* Parse a logical-and-expression.\n+  /* Parse the first expression.  */\n+  lhs = cp_parser_simple_cast_expression (parser);\n \n-   logical-and-expression:\n-     inclusive-or-expression\n-     logical-and-expression && inclusive-or-expression\n+  for (;;)\n+    {\n+      /* Get an operator token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      new_prec = TOKEN_PRECEDENCE (token);\n+\n+      /* Popping an entry off the stack means we completed a subexpression:\n+         - either we found a token which is not an operator (`>' where it is not\n+           an operator, or prec == PREC_NOT_OPERATOR), in which case popping\n+           will happen repeatedly;\n+         - or, we found an operator which has lower priority.  This is the case \n+           where the recursive descent *ascends*, as in `3 * 4 + 5' after\n+           parsing `3 * 4'. */\n+      if (new_prec <= prec)\n+        {\n+          if (sp == stack)\n+\t    break;\n+          else\n+\t    goto pop;\n+        }\n \n-   Returns a representation of the expression.  */\n+     get_rhs:\n+      tree_type = binops_by_token[token->type].tree_type;\n \n-static tree\n-cp_parser_logical_and_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_AND_AND, TRUTH_ANDIF_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n+      /* We used the operator token. */\n+      cp_lexer_consume_token (parser->lexer);\n \n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_inclusive_or_expression);\n-}\n+      /* Extract another operand.  It may be the RHS of this expression\n+         or the LHS of a new, higher priority expression.  */\n+      rhs = cp_parser_simple_cast_expression (parser);\n \n-/* Parse a logical-or-expression.\n+      /* Get another operator token.  Look up its precedence to avoid\n+         building a useless (immediately popped) stack entry for common\n+         cases such as 3 + 4 + 5 or 3 * 4 + 5.   */\n+      token = cp_lexer_peek_token (parser->lexer);\n+      lookahead_prec = TOKEN_PRECEDENCE (token);\n+      if (lookahead_prec > new_prec)\n+        {\n+          /* ... and prepare to parse the RHS of the new, higher priority\n+             expression.  */\n+          sp->prec = prec;\n+          sp->tree_type = tree_type;\n+          sp->lhs = lhs;\n+          sp++;\n+          lhs = rhs;\n+          prec = new_prec;\n+          new_prec = lookahead_prec;\n+          goto get_rhs;\n+\n+         pop:\n+          /* If the stack is not empty, we have parsed into LHS the right side\n+\t     (`4' in the example above) of an expression we had suspended.\n+\t     We can use the information on the stack to recover the LHS (`3') \n+\t     from the stack together with the tree code (`MULT_EXPR'), and\n+\t     the precedence of the higher level subexpression\n+\t     (`PREC_ADDITIVE_EXPRESSION').  TOKEN is the CPP_PLUS token,\n+\t     which will be used to actually build the additive expression.  */\n+          --sp;\n+\t  prec = sp->prec;\n+          tree_type = sp->tree_type;\n+          rhs = lhs;\n+          lhs = sp->lhs;\n+        }\n \n-   logical-or-expression:\n-     logical-and-expression\n-     logical-or-expression || logical-and-expression\n+      overloaded_p = false;\n+      lhs = build_x_binary_op (tree_type, lhs, rhs, &overloaded_p);\n \n-   Returns a representation of the expression.  */\n+      /* If the binary operator required the use of an overloaded operator,\n+         then this expression cannot be an integral constant-expression.\n+         An overloaded operator can be used even if both operands are\n+         otherwise permissible in an integral constant-expression if at\n+         least one of the operands is of enumeration type.  */\n \n-static tree\n-cp_parser_logical_or_expression (cp_parser* parser)\n-{\n-  static const cp_parser_token_tree_map map = {\n-    { CPP_OR_OR, TRUTH_ORIF_EXPR },\n-    { CPP_EOF, ERROR_MARK }\n-  };\n+      if (overloaded_p\n+          && (cp_parser_non_integral_constant_expression \n+              (parser, \"calls to overloaded operators\")))\n+        return error_mark_node;\n+    }\n \n-  return cp_parser_binary_expression (parser,\n-\t\t\t\t      map,\n-\t\t\t\t      cp_parser_logical_and_expression);\n+  return lhs;\n }\n \n+\n /* Parse the `? expression : assignment-expression' part of a\n    conditional-expression.  The LOGICAL_OR_EXPR is the\n    logical-or-expression that started the conditional-expression.\n@@ -5480,8 +5449,8 @@ cp_parser_assignment_expression (cp_parser* parser)\n      logical-or-expression.  */\n   else\n     {\n-      /* Parse the logical-or-expression.  */\n-      expr = cp_parser_logical_or_expression (parser);\n+      /* Parse the binary expressions (logical-or-expression).  */\n+      expr = cp_parser_binary_expression (parser);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n@@ -14411,79 +14380,6 @@ cp_parser_check_template_parameters (cp_parser* parser,\n   return false;\n }\n \n-/* Parse a binary-expression of the general form:\n-\n-   binary-expression:\n-     <expr>\n-     binary-expression <token> <expr>\n-\n-   The TOKEN_TREE_MAP maps <token> types to <expr> codes.  FN is used\n-   to parser the <expr>s.  If the first production is used, then the\n-   value returned by FN is returned directly.  Otherwise, a node with\n-   the indicated EXPR_TYPE is returned, with operands corresponding to\n-   the two sub-expressions.  */\n-\n-static tree\n-cp_parser_binary_expression (cp_parser* parser,\n-                             const cp_parser_token_tree_map token_tree_map,\n-                             cp_parser_expression_fn fn)\n-{\n-  tree lhs;\n-\n-  /* Parse the first expression.  */\n-  lhs = (*fn) (parser);\n-  /* Now, look for more expressions.  */\n-  while (true)\n-    {\n-      cp_token *token;\n-      const cp_parser_token_tree_map_node *map_node;\n-      tree rhs;\n-\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If the token is `>', and that's not an operator at the\n-\t moment, then we're done.  */\n-      if (token->type == CPP_GREATER\n-\t  && !parser->greater_than_is_operator_p)\n-\tbreak;\n-      /* If we find one of the tokens we want, build the corresponding\n-\t tree representation.  */\n-      for (map_node = token_tree_map;\n-\t   map_node->token_type != CPP_EOF;\n-\t   ++map_node)\n-\tif (map_node->token_type == token->type)\n-\t  {\n-\t    /* Assume that an overloaded operator will not be used.  */\n-\t    bool overloaded_p = false;\n-\n-\t    /* Consume the operator token.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t    /* Parse the right-hand side of the expression.  */\n-\t    rhs = (*fn) (parser);\n-\t    /* Build the binary tree node.  */\n-\t    lhs = build_x_binary_op (map_node->tree_type, lhs, rhs,\n-\t\t\t\t     &overloaded_p);\n-\t    /* If the binary operator required the use of an\n-\t       overloaded operator, then this expression cannot be an\n-\t       integral constant-expression.  An overloaded operator\n-\t       can be used even if both operands are otherwise\n-\t       permissible in an integral constant-expression if at\n-\t       least one of the operands is of enumeration type.  */\n-\t    if (overloaded_p\n-\t\t&& (cp_parser_non_integral_constant_expression\n-\t\t    (parser, \"calls to overloaded operators\")))\n-\t      lhs = error_mark_node;\n-\t    break;\n-\t  }\n-\n-      /* If the token wasn't one of the ones we want, we're done.  */\n-      if (map_node->token_type == CPP_EOF)\n-\tbreak;\n-    }\n-\n-  return lhs;\n-}\n-\n /* Parse an optional `::' token indicating that the following name is\n    from the global namespace.  If so, PARSER->SCOPE is set to the\n    GLOBAL_NAMESPACE. Otherwise, PARSER->SCOPE is set to NULL_TREE,"}]}