{"sha": "072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcyMjY5ZDg1NzU5MWQ5ZGM5ZTI2YjNiOGY5Y2JiZTc2OTVmYzI0Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-21T16:03:02Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-21T16:03:02Z"}, "message": "tree-cfg.c (thread_jumps): Move a part of it to ...\n\n\t* tree-cfg.c (thread_jumps): Move a part of it to ...\n\t(thread_jumps_from_bb): ... here.\n\nFrom-SVN: r89380", "tree": {"sha": "e115dc1c204a281c80f4ad29f83f54a5877f12de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e115dc1c204a281c80f4ad29f83f54a5877f12de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072269d857591d9dc9e26b3b8f9cbbe7695fc24c/comments", "author": null, "committer": null, "parents": [{"sha": "5303e3d7d7c52c62996c487f6d8c498bbd3a4053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5303e3d7d7c52c62996c487f6d8c498bbd3a4053", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5303e3d7d7c52c62996c487f6d8c498bbd3a4053"}], "stats": {"total": 347, "additions": 184, "deletions": 163}, "files": [{"sha": "f04bff45e933f68709131d0df53731909315da16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/072269d857591d9dc9e26b3b8f9cbbe7695fc24c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/072269d857591d9dc9e26b3b8f9cbbe7695fc24c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "patch": "@@ -1,3 +1,8 @@\n+2004-10-21  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-cfg.c (thread_jumps): Move a part of it to ...\n+\t(thread_jumps_from_bb): ... here.\n+\n 2004-10-21  David Edelsohn  <edelsohn@gnu.org>\n \n \t* dbxout.c (DBX_FINISH_SYMBOL): Add asm_out_file argument."}, {"sha": "3c4cd713146e51ee16d465aaa1d85608971b04ae", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 179, "deletions": 163, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/072269d857591d9dc9e26b3b8f9cbbe7695fc24c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/072269d857591d9dc9e26b3b8f9cbbe7695fc24c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=072269d857591d9dc9e26b3b8f9cbbe7695fc24c", "patch": "@@ -3759,6 +3759,174 @@ tree_forwarder_block_p (basic_block bb)\n   return true;\n }\n \n+/* Thread jumps from BB.  */\n+\n+static bool\n+thread_jumps_from_bb (basic_block bb)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  bool retval = false;\n+\n+  /* Examine each of our block's successors to see if it is\n+     forwardable.  */\n+  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+    {\n+      int freq;\n+      gcov_type count;\n+      edge last, old;\n+      basic_block dest, tmp, curr, old_dest;\n+      tree phi;\n+      int arg;\n+\n+      /* If the edge is abnormal or its destination is not\n+\t forwardable, then there's nothing to do.  */\n+      if ((e->flags & EDGE_ABNORMAL)\n+\t  || !bb_ann (e->dest)->forwardable)\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      count = e->count;\n+      freq = EDGE_FREQUENCY (e);\n+\n+      /* Now walk through as many forwarder blocks as possible to find\n+\t the ultimate destination we want to thread our jump to.  */\n+      last = EDGE_SUCC (e->dest, 0);\n+      bb_ann (e->dest)->forwardable = 0;\n+      for (dest = EDGE_SUCC (e->dest, 0)->dest;\n+\t   bb_ann (dest)->forwardable;\n+\t   last = EDGE_SUCC (dest, 0),\n+\t     dest = EDGE_SUCC (dest, 0)->dest)\n+\tbb_ann (dest)->forwardable = 0;\n+\n+      /* Reset the forwardable marks to 1.  */\n+      for (tmp = e->dest;\n+\t   tmp != dest;\n+\t   tmp = EDGE_SUCC (tmp, 0)->dest)\n+\tbb_ann (tmp)->forwardable = 1;\n+\n+      if (dest == e->dest)\n+\t{\n+\t  ei_next (&ei);\n+\t  continue;\n+\t}\n+\n+      old = find_edge (bb, dest);\n+      if (old)\n+\t{\n+\t  /* If there already is an edge, check whether the values in\n+\t     phi nodes differ.  */\n+\t  if (!phi_alternatives_equal (dest, last, old))\n+\t    {\n+\t      /* The previous block is forwarder.  Redirect our jump\n+\t\t to that target instead since we know it has no PHI\n+\t\t nodes that will need updating.  */\n+\t      dest = last->src;\n+\n+\t      /* That might mean that no forwarding at all is\n+\t\t possible.  */\n+\t      if (dest == e->dest)\n+\t\t{\n+\t\t  ei_next (&ei);\n+\t\t  continue;\n+\t\t}\n+\n+\t      old = find_edge (bb, dest);\n+\t    }\n+\t}\n+\n+      /* Perform the redirection.  */\n+      retval = true;\n+      old_dest = e->dest;\n+      e = redirect_edge_and_branch (e, dest);\n+\n+      /* Update the profile.  */\n+      if (profile_status != PROFILE_ABSENT)\n+\tfor (curr = old_dest;\n+\t     curr != dest;\n+\t     curr = EDGE_SUCC (curr, 0)->dest)\n+\t  {\n+\t    curr->frequency -= freq;\n+\t    if (curr->frequency < 0)\n+\t      curr->frequency = 0;\n+\t    curr->count -= count;\n+\t    if (curr->count < 0)\n+\t      curr->count = 0;\n+\t    EDGE_SUCC (curr, 0)->count -= count;\n+\t    if (EDGE_SUCC (curr, 0)->count < 0)\n+\t      EDGE_SUCC (curr, 0)->count = 0;\n+\t  }\n+\n+      if (!old)\n+\t{\n+\t  /* Update PHI nodes.  We know that the new argument should\n+\t     have the same value as the argument associated with LAST.\n+\t     Otherwise we would have changed our target block\n+\t     above.  */\n+\t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t    {\n+\t      arg = phi_arg_from_edge (phi, last);\n+\t      gcc_assert (arg >= 0);\n+\t      add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n+\t    }\n+\t}\n+\n+      /* Remove the unreachable blocks (observe that if all blocks\n+\t were reachable before, only those in the path we threaded\n+\t over and did not have any predecessor outside of the path\n+\t become unreachable).  */\n+      for (; old_dest != dest; old_dest = tmp)\n+\t{\n+\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n+\n+\t  if (EDGE_COUNT (old_dest->preds) > 0)\n+\t    break;\n+\n+\t  delete_basic_block (old_dest);\n+\t}\n+\n+      /* Update the dominators.  */\n+      if (dom_info_available_p (CDI_DOMINATORS))\n+\t{\n+\t  /* If the dominator of the destination was in the\n+\t     path, set its dominator to the start of the\n+\t     redirected edge.  */\n+\t  if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n+\t    set_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n+\n+\t  /* Now proceed like if we forwarded just over one edge at a\n+\t     time.  Algorithm for forwarding edge S --> A over\n+\t     edge A --> B then is\n+\n+\t     if (idom (B) == A\n+\t         && !dominated_by (S, B))\n+\t       idom (B) = idom (A);\n+\t     recount_idom (A);  */\n+\n+\t  for (; old_dest != dest; old_dest = tmp)\n+\t    {\n+\t      basic_block dom;\n+\n+\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n+\n+\t      if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n+\t\t  && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n+\t\t{\n+\t\t  dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n+\t\t  set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n+\t\t}\n+\n+\t      dom = recount_dominator (CDI_DOMINATORS, old_dest);\n+\t      set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n+\t    }\n+\t}\n+    }\n+\n+  return retval;\n+}\n+\n \n /* Thread jumps over empty statements.\n \n@@ -3768,14 +3936,11 @@ tree_forwarder_block_p (basic_block bb)\n    As a precondition, we require that all basic blocks be reachable.\n    That is, there should be no opportunities left for\n    delete_unreachable_blocks.  */\n-   \n+\n static bool\n thread_jumps (void)\n {\n-  edge e, last, old;\n-  basic_block bb, dest, tmp, old_dest, curr, dom;\n-    tree phi;\n-  int arg;\n+  basic_block bb;\n   bool retval = false;\n   bool rerun;\n \n@@ -3787,171 +3952,22 @@ thread_jumps (void)\n       rerun = false;\n       FOR_EACH_BB (bb)\n \t{\n-\t  edge_iterator ei;\n-\t  bool this_jump_threaded = false;\n-\n \t  /* Don't waste time on forwarders.  */\n \t  if (bb_ann (bb)->forwardable)\n \t    continue;\n \n-\t  /* Examine each of our block's successors to see if it is\n-\t     forwardable.  */\n-\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t  if (thread_jumps_from_bb (bb))\n \t    {\n-\t      int freq;\n-\t      gcov_type count;\n-\n-\t      /* If the edge is abnormal or its destination is not\n-\t\t forwardable, then there's nothing to do.  */\n-\t      if ((e->flags & EDGE_ABNORMAL)\n-\t\t  || !bb_ann (e->dest)->forwardable)\n-\t\t{\n-\t\t  ei_next (&ei);\n-\t\t  continue;\n-\t\t}\n-\n-\t      count = e->count;\n-\t      freq = EDGE_FREQUENCY (e);\n-\n-\t      /* Now walk through as many forwarder blocks as possible to\n-\t\t find the ultimate destination we want to thread our jump\n-\t\t to.  */\n-\t      last = EDGE_SUCC (e->dest, 0);\n-\t      bb_ann (e->dest)->forwardable = 0;\n-\t      for (dest = EDGE_SUCC (e->dest, 0)->dest;\n-\t\t   bb_ann (dest)->forwardable;\n-\t\t   last = EDGE_SUCC (dest, 0),\n-\t\t     dest = EDGE_SUCC (dest, 0)->dest)\n-\t\tbb_ann (dest)->forwardable = 0;\n-\n-\t      /* Reset the forwardable marks to 1.  */\n-\t      for (tmp = e->dest;\n-\t\t   tmp != dest;\n-\t\t   tmp = EDGE_SUCC (tmp, 0)->dest)\n-\t\tbb_ann (tmp)->forwardable = 1;\n-\n-\t      if (dest == e->dest)\n-\t\t{\n-\t\t  ei_next (&ei);\n-\t\t  continue;\n-\t\t}\n-\t      \n-\t      old = find_edge (bb, dest);\n-\t      if (old)\n-\t\t{\n-\t\t  /* If there already is an edge, check whether the values\n-\t\t     in phi nodes differ.  */\n-\t\t  if (!phi_alternatives_equal (dest, last, old))\n-\t\t    {\n-\t\t      /* The previous block is forwarder.  Redirect our jump\n-\t\t\t to that target instead since we know it has no PHI\n-\t\t\t nodes that will need updating.  */\n-\t\t      dest = last->src;\n-\t  \n-\t\t      /* That might mean that no forwarding at all is\n-\t\t\t possible.  */\n-\t\t      if (dest == e->dest)\n-\t\t\t{\n-\t\t\t  ei_next (&ei);\n-\t\t\t  continue;\n-\t\t\t}\n-\n-\t\t      old = find_edge (bb, dest);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Perform the redirection.  */\n-\t      retval = this_jump_threaded = true;\n-\t      old_dest = e->dest;\n-\t      e = redirect_edge_and_branch (e, dest);\n-\n-\t      /* Update the profile.  */\n-\t      if (profile_status != PROFILE_ABSENT)\n-\t\tfor (curr = old_dest;\n-\t\t     curr != dest;\n-\t\t     curr = EDGE_SUCC (curr, 0)->dest)\n-\t\t  {\n-\t\t    curr->frequency -= freq;\n-\t\t    if (curr->frequency < 0)\n-\t\t      curr->frequency = 0;\n-\t\t    curr->count -= count;\n-\t\t    if (curr->count < 0)\n-\t\t      curr->count = 0;\n-\t\t    EDGE_SUCC (curr, 0)->count -= count;\n-\t\t    if (EDGE_SUCC (curr, 0)->count < 0)\n-\t\t      EDGE_SUCC (curr, 0)->count = 0;\n-\t\t  }\n-\n-\t      if (!old)\n-\t\t{\n-\t\t  /* Update PHI nodes.  We know that the new argument\n-\t\t     should have the same value as the argument\n-\t\t     associated with LAST.  Otherwise we would have\n-\t\t     changed our target block above.  */\n-\t\t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n-\t\t    {\n-\t\t      arg = phi_arg_from_edge (phi, last);\n-\t\t      gcc_assert (arg >= 0);\n-\t\t      add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Remove the unreachable blocks (observe that if all blocks\n-\t\t were reachable before, only those in the path we threaded\n-\t\t over and did not have any predecessor outside of the path\n-\t\t become unreachable).  */\n-\t      for (; old_dest != dest; old_dest = tmp)\n-\t\t{\n-\t\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n-\n-\t\t  if (EDGE_COUNT (old_dest->preds) > 0)\n-\t\t    break;\n-\n-\t\t  delete_basic_block (old_dest);\n-\t\t}\n-\n-\t      /* Update the dominators.  */\n-\t      if (dom_info_available_p (CDI_DOMINATORS))\n-\t\t{\n-\t\t  /* If the dominator of the destination was in the\n-\t\t     path, set its dominator to the start of the\n-\t\t     redirected edge.  */\n-\t\t  if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n-\t\t    set_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n-\n-\t\t  /* Now proceed like if we forwarded just over one\n-\t\t     edge at a time.  Algorithm for forwarding edge\n-\t\t     S --> A over edge A --> B then is\n-\n-\t\t     if (idom (B) == A\n-\t\t         && !dominated_by (S, B))\n-\t\t       idom (B) = idom (A);\n-\t\t     recount_idom (A);  */\n-\n-\t\t  for (; old_dest != dest; old_dest = tmp)\n-\t\t    {\n-\t\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n-\n-\t\t      if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n-\t\t\t  && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n-\t\t\t{\n-\t\t\t  dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n-\t\t\t  set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n-\t\t\t}\n+\t      retval = true;\n \n-\t\t      dom = recount_dominator (CDI_DOMINATORS, old_dest);\n-\t\t      set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n-\t\t    }\n-\t\t}\n+\t      /* If we succeeded in threading a jump at BB, update the\n+\t\t forwardable mark as BB may have become a new\n+\t\t forwarder block.  This could happen if we have a\n+\t\t useless \"if\" statement whose two arms eventually\n+\t\t merge without any intervening statements.  */\n+\t      if (tree_forwarder_block_p (bb))\n+\t\tbb_ann (bb)->forwardable = rerun = true;\n \t    }\n-\n-\t  /* If we succeeded in threading a jump at BB, update the\n-\t     forwardable mark as BB may have become a new forwarder\n-\t     block.  This could happen if we have a useless \"if\"\n-\t     statement whose two arms eventually merge without any\n-\t     intervening statements.  */\n-\t  if (this_jump_threaded && tree_forwarder_block_p (bb))\n-\t    bb_ann (bb)->forwardable = rerun = true;\n \t}\n     }\n   while (rerun);"}]}