{"sha": "6cc4833a49bcde8810c49d65445fc416073fd0fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjNDgzM2E0OWJjZGU4ODEwYzQ5ZDY1NDQ1ZmM0MTYwNzNmZDBmZQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2011-10-18T10:49:44Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2011-10-18T10:49:44Z"}, "message": "gcc/\n    * config/arm/arm.c (arm_block_move_unaligned_straight)\n    (arm_adjust_block_mem, arm_block_move_unaligned_loop)\n    (arm_movmemqi_unaligned): New.\n    (arm_gen_movmemqi): Support unaligned block copies.\n\n    gcc/testsuite/\n    * lib/target-supports.exp (check_effective_target_arm_unaligned):\n    New.\n    * gcc.target/arm/unaligned-memcpy-1.c: New.\n    * gcc.target/arm/unaligned-memcpy-2.c: New.\n    * gcc.target/arm/unaligned-memcpy-3.c: New.\n    * gcc.target/arm/unaligned-memcpy-4.c: New.\n\nFrom-SVN: r180131", "tree": {"sha": "ee98c701ff812e6ab4319af6068e5ecb52e41380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee98c701ff812e6ab4319af6068e5ecb52e41380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cc4833a49bcde8810c49d65445fc416073fd0fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc4833a49bcde8810c49d65445fc416073fd0fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cc4833a49bcde8810c49d65445fc416073fd0fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc4833a49bcde8810c49d65445fc416073fd0fe/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00820a2a60b1624af0bb093f4b7c93ea62113b3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00820a2a60b1624af0bb093f4b7c93ea62113b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00820a2a60b1624af0bb093f4b7c93ea62113b3c"}], "stats": {"total": 444, "additions": 442, "deletions": 2}, "files": [{"sha": "2968fb0de5e1c7727b63d35b02d125f93cd563a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -1,3 +1,10 @@\n+2011-10-18  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_block_move_unaligned_straight)\n+\t(arm_adjust_block_mem, arm_block_move_unaligned_loop)\n+\t(arm_movmemqi_unaligned): New.\n+\t(arm_gen_movmemqi): Support unaligned block copies.\n+\n 2011-10-18  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* doc/md.texi (vec_widen_ushiftl_hi, vec_widen_ushiftl_lo,"}, {"sha": "f1ada6f9a7386dca53e59b350fbe0e1118788ad3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 336, "deletions": 2, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -10766,6 +10766,335 @@ gen_const_stm_seq (rtx *operands, int nops)\n   return true;\n }\n \n+/* Copy a block of memory using plain ldr/str/ldrh/strh instructions, to permit\n+   unaligned copies on processors which support unaligned semantics for those\n+   instructions.  INTERLEAVE_FACTOR can be used to attempt to hide load latency\n+   (using more registers) by doing e.g. load/load/store/store for a factor of 2.\n+   An interleave factor of 1 (the minimum) will perform no interleaving. \n+   Load/store multiple are used for aligned addresses where possible.  */\n+\n+static void\n+arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,\n+\t\t\t\t   HOST_WIDE_INT length,\n+\t\t\t\t   unsigned int interleave_factor)\n+{\n+  rtx *regs = XALLOCAVEC (rtx, interleave_factor);\n+  int *regnos = XALLOCAVEC (int, interleave_factor);\n+  HOST_WIDE_INT block_size_bytes = interleave_factor * UNITS_PER_WORD;\n+  HOST_WIDE_INT i, j;\n+  HOST_WIDE_INT remaining = length, words;\n+  rtx halfword_tmp = NULL, byte_tmp = NULL;\n+  rtx dst, src;\n+  bool src_aligned = MEM_ALIGN (srcbase) >= BITS_PER_WORD;\n+  bool dst_aligned = MEM_ALIGN (dstbase) >= BITS_PER_WORD;\n+  HOST_WIDE_INT srcoffset, dstoffset;\n+  HOST_WIDE_INT src_autoinc, dst_autoinc;\n+  rtx mem, addr;\n+  \n+  gcc_assert (1 <= interleave_factor && interleave_factor <= 4);\n+  \n+  /* Use hard registers if we have aligned source or destination so we can use\n+     load/store multiple with contiguous registers.  */\n+  if (dst_aligned || src_aligned)\n+    for (i = 0; i < interleave_factor; i++)\n+      regs[i] = gen_rtx_REG (SImode, i);\n+  else\n+    for (i = 0; i < interleave_factor; i++)\n+      regs[i] = gen_reg_rtx (SImode);\n+\n+  dst = copy_addr_to_reg (XEXP (dstbase, 0));\n+  src = copy_addr_to_reg (XEXP (srcbase, 0));\n+\n+  srcoffset = dstoffset = 0;\n+  \n+  /* Calls to arm_gen_load_multiple and arm_gen_store_multiple update SRC/DST.\n+     For copying the last bytes we want to subtract this offset again.  */\n+  src_autoinc = dst_autoinc = 0;\n+\n+  for (i = 0; i < interleave_factor; i++)\n+    regnos[i] = i;\n+\n+  /* Copy BLOCK_SIZE_BYTES chunks.  */\n+\n+  for (i = 0; i + block_size_bytes <= length; i += block_size_bytes)\n+    {\n+      /* Load words.  */\n+      if (src_aligned && interleave_factor > 1)\n+\t{\n+\t  emit_insn (arm_gen_load_multiple (regnos, interleave_factor, src,\n+\t\t\t\t\t    TRUE, srcbase, &srcoffset));\n+\t  src_autoinc += UNITS_PER_WORD * interleave_factor;\n+\t}\n+      else\n+\t{\n+\t  for (j = 0; j < interleave_factor; j++)\n+\t    {\n+\t      addr = plus_constant (src, srcoffset + j * UNITS_PER_WORD\n+\t\t\t\t\t - src_autoinc);\n+\t      mem = adjust_automodify_address (srcbase, SImode, addr,\n+\t\t\t\t\t       srcoffset + j * UNITS_PER_WORD);\n+\t      emit_insn (gen_unaligned_loadsi (regs[j], mem));\n+\t    }\n+\t  srcoffset += block_size_bytes;\n+\t}\n+\n+      /* Store words.  */\n+      if (dst_aligned && interleave_factor > 1)\n+\t{\n+\t  emit_insn (arm_gen_store_multiple (regnos, interleave_factor, dst,\n+\t\t\t\t\t     TRUE, dstbase, &dstoffset));\n+\t  dst_autoinc += UNITS_PER_WORD * interleave_factor;\n+\t}\n+      else\n+\t{\n+\t  for (j = 0; j < interleave_factor; j++)\n+\t    {\n+\t      addr = plus_constant (dst, dstoffset + j * UNITS_PER_WORD\n+\t\t\t\t\t - dst_autoinc);\n+\t      mem = adjust_automodify_address (dstbase, SImode, addr,\n+\t\t\t\t\t       dstoffset + j * UNITS_PER_WORD);\n+\t      emit_insn (gen_unaligned_storesi (mem, regs[j]));\n+\t    }\n+\t  dstoffset += block_size_bytes;\n+\t}\n+\n+      remaining -= block_size_bytes;\n+    }\n+  \n+  /* Copy any whole words left (note these aren't interleaved with any\n+     subsequent halfword/byte load/stores in the interests of simplicity).  */\n+  \n+  words = remaining / UNITS_PER_WORD;\n+\n+  gcc_assert (words < interleave_factor);\n+  \n+  if (src_aligned && words > 1)\n+    {\n+      emit_insn (arm_gen_load_multiple (regnos, words, src, TRUE, srcbase,\n+\t\t\t\t\t&srcoffset));\n+      src_autoinc += UNITS_PER_WORD * words;\n+    }\n+  else\n+    {\n+      for (j = 0; j < words; j++)\n+\t{\n+\t  addr = plus_constant (src,\n+\t\t\t\tsrcoffset + j * UNITS_PER_WORD - src_autoinc);\n+\t  mem = adjust_automodify_address (srcbase, SImode, addr,\n+\t\t\t\t\t   srcoffset + j * UNITS_PER_WORD);\n+\t  emit_insn (gen_unaligned_loadsi (regs[j], mem));\n+\t}\n+      srcoffset += words * UNITS_PER_WORD;\n+    }\n+\n+  if (dst_aligned && words > 1)\n+    {\n+      emit_insn (arm_gen_store_multiple (regnos, words, dst, TRUE, dstbase,\n+\t\t\t\t\t &dstoffset));\n+      dst_autoinc += words * UNITS_PER_WORD;\n+    }\n+  else\n+    {\n+      for (j = 0; j < words; j++)\n+\t{\n+\t  addr = plus_constant (dst,\n+\t\t\t\tdstoffset + j * UNITS_PER_WORD - dst_autoinc);\n+\t  mem = adjust_automodify_address (dstbase, SImode, addr,\n+\t\t\t\t\t   dstoffset + j * UNITS_PER_WORD);\n+\t  emit_insn (gen_unaligned_storesi (mem, regs[j]));\n+\t}\n+      dstoffset += words * UNITS_PER_WORD;\n+    }\n+\n+  remaining -= words * UNITS_PER_WORD;\n+  \n+  gcc_assert (remaining < 4);\n+  \n+  /* Copy a halfword if necessary.  */\n+  \n+  if (remaining >= 2)\n+    {\n+      halfword_tmp = gen_reg_rtx (SImode);\n+\n+      addr = plus_constant (src, srcoffset - src_autoinc);\n+      mem = adjust_automodify_address (srcbase, HImode, addr, srcoffset);\n+      emit_insn (gen_unaligned_loadhiu (halfword_tmp, mem));\n+\n+      /* Either write out immediately, or delay until we've loaded the last\n+\t byte, depending on interleave factor.  */\n+      if (interleave_factor == 1)\n+\t{\n+\t  addr = plus_constant (dst, dstoffset - dst_autoinc);\n+\t  mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);\n+\t  emit_insn (gen_unaligned_storehi (mem,\n+\t\t       gen_lowpart (HImode, halfword_tmp)));\n+\t  halfword_tmp = NULL;\n+\t  dstoffset += 2;\n+\t}\n+\n+      remaining -= 2;\n+      srcoffset += 2;\n+    }\n+  \n+  gcc_assert (remaining < 2);\n+  \n+  /* Copy last byte.  */\n+  \n+  if ((remaining & 1) != 0)\n+    {\n+      byte_tmp = gen_reg_rtx (SImode);\n+\n+      addr = plus_constant (src, srcoffset - src_autoinc);\n+      mem = adjust_automodify_address (srcbase, QImode, addr, srcoffset);\n+      emit_move_insn (gen_lowpart (QImode, byte_tmp), mem);\n+\n+      if (interleave_factor == 1)\n+\t{\n+\t  addr = plus_constant (dst, dstoffset - dst_autoinc);\n+\t  mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);\n+\t  emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));\n+\t  byte_tmp = NULL;\n+\t  dstoffset++;\n+\t}\n+\n+      remaining--;\n+      srcoffset++;\n+    }\n+  \n+  /* Store last halfword if we haven't done so already.  */\n+  \n+  if (halfword_tmp)\n+    {\n+      addr = plus_constant (dst, dstoffset - dst_autoinc);\n+      mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);\n+      emit_insn (gen_unaligned_storehi (mem,\n+\t\t   gen_lowpart (HImode, halfword_tmp)));\n+      dstoffset += 2;\n+    }\n+\n+  /* Likewise for last byte.  */\n+\n+  if (byte_tmp)\n+    {\n+      addr = plus_constant (dst, dstoffset - dst_autoinc);\n+      mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);\n+      emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));\n+      dstoffset++;\n+    }\n+  \n+  gcc_assert (remaining == 0 && srcoffset == dstoffset);\n+}\n+\n+/* From mips_adjust_block_mem:\n+\n+   Helper function for doing a loop-based block operation on memory\n+   reference MEM.  Each iteration of the loop will operate on LENGTH\n+   bytes of MEM.\n+\n+   Create a new base register for use within the loop and point it to\n+   the start of MEM.  Create a new memory reference that uses this\n+   register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */\n+\n+static void\n+arm_adjust_block_mem (rtx mem, HOST_WIDE_INT length, rtx *loop_reg,\n+\t\t      rtx *loop_mem)\n+{\n+  *loop_reg = copy_addr_to_reg (XEXP (mem, 0));\n+  \n+  /* Although the new mem does not refer to a known location,\n+     it does keep up to LENGTH bytes of alignment.  */\n+  *loop_mem = change_address (mem, BLKmode, *loop_reg);\n+  set_mem_align (*loop_mem, MIN (MEM_ALIGN (mem), length * BITS_PER_UNIT));\n+}\n+\n+/* From mips_block_move_loop:\n+\n+   Move LENGTH bytes from SRC to DEST using a loop that moves BYTES_PER_ITER\n+   bytes at a time.  LENGTH must be at least BYTES_PER_ITER.  Assume that\n+   the memory regions do not overlap.  */\n+\n+static void\n+arm_block_move_unaligned_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n+\t\t\t       unsigned int interleave_factor,\n+\t\t\t       HOST_WIDE_INT bytes_per_iter)\n+{\n+  rtx label, src_reg, dest_reg, final_src, test;\n+  HOST_WIDE_INT leftover;\n+  \n+  leftover = length % bytes_per_iter;\n+  length -= leftover;\n+  \n+  /* Create registers and memory references for use within the loop.  */\n+  arm_adjust_block_mem (src, bytes_per_iter, &src_reg, &src);\n+  arm_adjust_block_mem (dest, bytes_per_iter, &dest_reg, &dest);\n+  \n+  /* Calculate the value that SRC_REG should have after the last iteration of\n+     the loop.  */\n+  final_src = expand_simple_binop (Pmode, PLUS, src_reg, GEN_INT (length),\n+\t\t\t\t   0, 0, OPTAB_WIDEN);\n+\n+  /* Emit the start of the loop.  */\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  \n+  /* Emit the loop body.  */\n+  arm_block_move_unaligned_straight (dest, src, bytes_per_iter,\n+\t\t\t\t     interleave_factor);\n+\n+  /* Move on to the next block.  */\n+  emit_move_insn (src_reg, plus_constant (src_reg, bytes_per_iter));\n+  emit_move_insn (dest_reg, plus_constant (dest_reg, bytes_per_iter));\n+  \n+  /* Emit the loop condition.  */\n+  test = gen_rtx_NE (VOIDmode, src_reg, final_src);\n+  emit_jump_insn (gen_cbranchsi4 (test, src_reg, final_src, label));\n+  \n+  /* Mop up any left-over bytes.  */\n+  if (leftover)\n+    arm_block_move_unaligned_straight (dest, src, leftover, interleave_factor);\n+}\n+\n+/* Emit a block move when either the source or destination is unaligned (not\n+   aligned to a four-byte boundary).  This may need further tuning depending on\n+   core type, optimize_size setting, etc.  */\n+\n+static int\n+arm_movmemqi_unaligned (rtx *operands)\n+{\n+  HOST_WIDE_INT length = INTVAL (operands[2]);\n+  \n+  if (optimize_size)\n+    {\n+      bool src_aligned = MEM_ALIGN (operands[1]) >= BITS_PER_WORD;\n+      bool dst_aligned = MEM_ALIGN (operands[0]) >= BITS_PER_WORD;\n+      /* Inlined memcpy using ldr/str/ldrh/strh can be quite big: try to limit\n+\t size of code if optimizing for size.  We'll use ldm/stm if src_aligned\n+\t or dst_aligned though: allow more interleaving in those cases since the\n+\t resulting code can be smaller.  */\n+      unsigned int interleave_factor = (src_aligned || dst_aligned) ? 2 : 1;\n+      HOST_WIDE_INT bytes_per_iter = (src_aligned || dst_aligned) ? 8 : 4;\n+      \n+      if (length > 12)\n+\tarm_block_move_unaligned_loop (operands[0], operands[1], length,\n+\t\t\t\t       interleave_factor, bytes_per_iter);\n+      else\n+\tarm_block_move_unaligned_straight (operands[0], operands[1], length,\n+\t\t\t\t\t   interleave_factor);\n+    }\n+  else\n+    {\n+      /* Note that the loop created by arm_block_move_unaligned_loop may be\n+\t subject to loop unrolling, which makes tuning this condition a little\n+\t redundant.  */\n+      if (length > 32)\n+\tarm_block_move_unaligned_loop (operands[0], operands[1], length, 4, 16);\n+      else\n+\tarm_block_move_unaligned_straight (operands[0], operands[1], length, 4);\n+    }\n+  \n+  return 1;\n+}\n+\n int\n arm_gen_movmemqi (rtx *operands)\n {\n@@ -10778,8 +11107,13 @@ arm_gen_movmemqi (rtx *operands)\n \n   if (GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT\n-      || INTVAL (operands[2]) > 64\n-      || INTVAL (operands[3]) & 3)\n+      || INTVAL (operands[2]) > 64)\n+    return 0;\n+\n+  if (unaligned_access && (INTVAL (operands[3]) & 3) != 0)\n+    return arm_movmemqi_unaligned (operands);\n+\n+  if (INTVAL (operands[3]) & 3)\n     return 0;\n \n   dstbase = operands[0];"}, {"sha": "3216bfcb47a5eb3f451e840bf71a9eb1e0fc0566", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -1,3 +1,11 @@\n+2011-10-18  Julian Brown  <julian@codesourcery.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_arm_unaligned): New.\n+\t* gcc.target/arm/unaligned-memcpy-1.c: New.\n+\t* gcc.target/arm/unaligned-memcpy-2.c: New.\n+\t* gcc.target/arm/unaligned-memcpy-3.c: New.\n+\t* gcc.target/arm/unaligned-memcpy-4.c: New.\n+\n 2011-10-18  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47023"}, {"sha": "c4f564042252b85cccb87c848b35d909afa9d65d", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-1.c?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_unaligned } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+\n+void unknown_alignment (char *dest, char *src)\n+{\n+  memcpy (dest, src, 15);\n+}\n+\n+/* We should see three unaligned word loads and store pairs, one unaligned\n+   ldrh/strh pair, and an ldrb/strb pair.  Sanity check that.  */\n+\n+/* { dg-final { scan-assembler-times \"@ unaligned\" 8 } } */\n+/* { dg-final { scan-assembler-times \"ldrh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrb\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strb\" 1 } } */"}, {"sha": "c7d24c9c5c3ebb4866f28707a08017f82c717319", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_unaligned } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+\n+char dest[16];\n+\n+void aligned_dest (char *src)\n+{\n+  memcpy (dest, src, 15);\n+}\n+\n+/* Expect a multi-word store for the main part of the copy, but subword\n+   loads/stores for the remainder.  */\n+\n+/* { dg-final { scan-assembler-times \"stmia\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrb\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strb\" 1 } } */"}, {"sha": "5f0413738c55e412e5f99f30cbfbbef22a63492e", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_unaligned } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+\n+char src[16];\n+\n+void aligned_src (char *dest)\n+{\n+  memcpy (dest, src, 15);\n+}\n+\n+/* Expect a multi-word load for the main part of the copy, but subword\n+   loads/stores for the remainder.  */\n+\n+/* { dg-final { scan-assembler-times \"ldmia\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrb\" 1 } } */\n+/* { dg-final { scan-assembler-times \"strb\" 1 } } */"}, {"sha": "99957086e7e561194cdcc2ab50161df5f708fe56", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_unaligned } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+\n+char src[16];\n+char dest[16];\n+\n+void aligned_both (void)\n+{\n+  memcpy (dest, src, 15);\n+}\n+\n+/* We know both src and dest to be aligned: expect multiword loads/stores.  */\n+\n+/* { dg-final { scan-assembler-times \"ldmia\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stmia\" 1 } } */"}, {"sha": "f19c3c566c66f32ac0e09c6bdb332f920d17d6bf", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc4833a49bcde8810c49d65445fc416073fd0fe/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=6cc4833a49bcde8810c49d65445fc416073fd0fe", "patch": "@@ -1973,6 +1973,18 @@ proc check_effective_target_arm_dsp { } {\n     }]\n }\n \n+# Return 1 if this is an ARM target that supports unaligned word/halfword\n+# load/store instructions.\n+\n+proc check_effective_target_arm_unaligned { } {\n+    return [check_no_compiler_messages arm_unaligned assembly {\n+\t#ifndef __ARM_FEATURE_UNALIGNED\n+\t#error no unaligned support\n+\t#endif\n+\tint i;\n+    }]\n+}\n+\n # Add the options needed for NEON.  We need either -mfloat-abi=softfp\n # or -mfloat-abi=hard, but if one is already specified by the\n # multilib, use it.  Similarly, if a -mfpu option already enables"}]}