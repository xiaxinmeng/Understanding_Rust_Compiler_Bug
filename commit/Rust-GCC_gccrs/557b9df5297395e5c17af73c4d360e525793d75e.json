{"sha": "557b9df5297395e5c17af73c4d360e525793d75e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU3YjlkZjUyOTczOTVlNWMxN2FmNzNjNGQzNjBlNTI1NzkzZDc1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-07-15T20:31:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-07-15T20:31:27Z"}, "message": "ia64-protos.h (ia64_move_ok): Prototype.\n\n        * config/ia64/ia64-protos.h (ia64_move_ok): Prototype.\n        * config/ia64/ia64.c (ia64_move_ok): New function.\n        * config/ia64/ia64.md (movqi, movqi_internal): Use it.\n        (movhi, movsi, movdi, movsf, movdf, movxf): Likewise.\n\nFrom-SVN: r35054", "tree": {"sha": "eafb4fe2031b44b7904a4123223f90fd1b418d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eafb4fe2031b44b7904a4123223f90fd1b418d97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/557b9df5297395e5c17af73c4d360e525793d75e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b9df5297395e5c17af73c4d360e525793d75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557b9df5297395e5c17af73c4d360e525793d75e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557b9df5297395e5c17af73c4d360e525793d75e/comments", "author": null, "committer": null, "parents": [{"sha": "d4c4ae6f2f2d677ae919dd5df22512f627ecaf81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4c4ae6f2f2d677ae919dd5df22512f627ecaf81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4c4ae6f2f2d677ae919dd5df22512f627ecaf81"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "5fc1ba10a09db60e94828e2498e127dac6a518a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=557b9df5297395e5c17af73c4d360e525793d75e", "patch": "@@ -1,3 +1,10 @@\n+2000-07-15  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64-protos.h (ia64_move_ok): Prototype.\n+\t* config/ia64/ia64.c (ia64_move_ok): New function.\n+\t* config/ia64/ia64.md (movqi, movqi_internal): Use it.\n+\t(movhi, movsi, movdi, movsf, movdf, movxf): Likewise.\n+\n 2000-07-15  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpphash.c (save_expansion): Clear PREV_WHITE on tokens"}, {"sha": "e918420aa3fcbdd86ad3df979f4b03bfe99a2666", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=557b9df5297395e5c17af73c4d360e525793d75e", "patch": "@@ -50,6 +50,7 @@ extern int normal_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int adjusted_comparison_operator PARAMS((rtx, enum machine_mode));\n extern int call_multiple_values_operation PARAMS((rtx, enum machine_mode));\n extern int predicate_operator PARAMS((rtx, enum machine_mode));\n+extern int ia64_move_ok PARAMS((rtx, rtx));\n \n extern void ia64_expand_fetch_and_op PARAMS ((enum fetchop_code,\n \t\t\t\t\t      enum machine_mode, rtx []));"}, {"sha": "c88f1a94753466be6bcf9d90f48fc6fa524ee293", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=557b9df5297395e5c17af73c4d360e525793d75e", "patch": "@@ -542,6 +542,30 @@ predicate_operator (op, mode)\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && (code == EQ || code == NE));\n }\n+\n+/* Return 1 if the operands of a move are ok.  */\n+\n+int\n+ia64_move_ok (dst, src)\n+     rtx dst, src;\n+{\n+  /* If we're under init_recog_no_volatile, we'll not be able to use\n+     memory_operand.  So check the code directly and don't worry about\n+     the validity of the underlying address, which should have been\n+     checked elsewhere anyway.  */\n+  if (GET_CODE (dst) != MEM)\n+    return 1;\n+  if (GET_CODE (src) == MEM)\n+    return 0;\n+  if (register_operand (src, VOIDmode))\n+    return 1;\n+\n+  /* Otherwise, this must be a constant, and that either 0 or 0.0 or 1.0.  */\n+  if (INTEGRAL_MODE_P (GET_MODE (dst)))\n+    return src == const0_rtx;\n+  else\n+    return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);\n+}\n \f\n /* Begin the assembly file.  */\n "}, {"sha": "9c90de16e8b2aae039a380e4650e6afe578c01a2", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557b9df5297395e5c17af73c4d360e525793d75e/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=557b9df5297395e5c17af73c4d360e525793d75e", "patch": "@@ -172,16 +172,14 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (QImode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (QImode, operands[1]);\n }\")\n \n (define_insn \"*movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n \t(match_operand:QI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n-  \"! memory_operand (operands[0], QImode)\n-   || ! memory_operand (operands[1], QImode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n    addl %0 = %1, r0\n@@ -199,16 +197,14 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (HImode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (HImode, operands[1]);\n }\")\n \n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r, m, r,*f,*f\")\n \t(match_operand:HI 1 \"move_operand\"         \"rO,J,m,rO,*f,rO,*f\"))]\n-  \"! memory_operand (operands[0], HImode)\n-   || !memory_operand (operands[1], HImode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n    mov %0 = %r1\n    addl %0 = %1, r0\n@@ -226,16 +222,14 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n }\")\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r, m, r,*f,*f\")\n \t(match_operand:SI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f\"))]\n-  \"! memory_operand (operands[0], SImode)\n-   || ! memory_operand (operands[1], SImode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %r1\n   addl %0 = %1, r0\n@@ -301,16 +295,14 @@\n     }\n \n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (DImode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n }\")\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r, m,r,*f,*f,*f,Q, r,*b\")\n \t(match_operand:DI 1 \"move_operand\"         \"rO,J,i,m,rO,*f,rO,*f,Q,*f,*b,rO\"))]\n-  \"! memory_operand (operands[0], DImode)\n-   || ! memory_operand (operands[1], DImode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %r1\n   addl %0 = %1, r0\n@@ -401,16 +393,14 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (SFmode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (SFmode, operands[1]);\n }\")\n \n (define_insn \"*movsf_internal\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:SF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n-  \"! memory_operand (operands[0], SFmode)\n-   || ! memory_operand (operands[1], SFmode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n   ldfs %0 = %1%P1\n@@ -429,16 +419,14 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (DFmode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (DFmode, operands[1]);\n }\")\n \n (define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f, Q,*r, f,*r,*r, m\")\n \t(match_operand:DF 1 \"general_operand\"      \"fG,Q,fG,fG,*r,*r, m,*r\"))]\n-  \"! memory_operand (operands[0], DFmode)\n-   || ! memory_operand (operands[1], DFmode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n   ldfd %0 = %1%P1\n@@ -457,17 +445,15 @@\n   \"\n {\n   if (! reload_in_progress && ! reload_completed\n-      && GET_CODE (operands[0]) == MEM\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_mode_reg (XFmode, operands[1]);\n+      && ! ia64_move_ok (operands[0], operands[1]))\n+    operands[1] = force_reg (XFmode, operands[1]);\n }\")\n \n ;; ??? There's no easy way to mind volatile acquire/release semantics.\n (define_insn \"*movxf_internal\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,f, m\")\n \t(match_operand:XF 1 \"general_operand\"      \"fG,m,fG\"))]\n-  \"! memory_operand (operands[0], XFmode)\n-   || ! memory_operand (operands[1], XFmode)\"\n+  \"ia64_move_ok (operands[0], operands[1])\"\n   \"@\n   mov %0 = %F1\n   ldfe %0 = %1%P1"}]}