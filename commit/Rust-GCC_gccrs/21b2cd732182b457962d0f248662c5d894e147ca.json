{"sha": "21b2cd732182b457962d0f248662c5d894e147ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiMmNkNzMyMTgyYjQ1Nzk2MmQwZjI0ODY2MmM1ZDg5NGUxNDdjYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-04-12T01:39:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-12T01:39:00Z"}, "message": "reg-stack.c: Update comment, include varray.h.\n\n        * reg-stack.c: Update comment, include varray.h.\n        (stack_regs_mentioned_data): New global variable.\n        (check_stack_regs_mentioned): New function.\n        (stack_regs_mentioned): New function.\n        (reg_to_stack): Initialize and free stack_regs_mentioned_data,\n        use stack_regs_mentioned.\n        (record_asm_reg_life): Change insn type cache for changed insn.\n        (record_reg_life): Do not change the insn mode.\n        (emit_pop_insn): Likewise.\n        (emit_swap_insn): Likewise.\n        (move_for_stack_reg): Likewise.\n        (stack_reg_life_analysis): Use stack_regs_mentioned.\n        (emit_swap_insn): Likewise.\n        (subst_stack_regs): Likewise.\n        (convert_regs): Likewise.\n        * jump.c (find_cross_jump): Use stack_regs_mentioned.\n        * rtl.h (stack_regs_mentioned): Declare.\n\nFrom-SVN: r26360", "tree": {"sha": "b1abeb01e48cccbcff7900a7efb77f510d276733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1abeb01e48cccbcff7900a7efb77f510d276733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b2cd732182b457962d0f248662c5d894e147ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b2cd732182b457962d0f248662c5d894e147ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b2cd732182b457962d0f248662c5d894e147ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b2cd732182b457962d0f248662c5d894e147ca/comments", "author": null, "committer": null, "parents": [{"sha": "6b1d78bf509804015999f36eb34ff78608aaf40d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b1d78bf509804015999f36eb34ff78608aaf40d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b1d78bf509804015999f36eb34ff78608aaf40d"}], "stats": {"total": 122, "additions": 98, "deletions": 24}, "files": [{"sha": "2494b89e25fd55ad9ed717047428c06b2ac90f9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21b2cd732182b457962d0f248662c5d894e147ca", "patch": "@@ -1,3 +1,23 @@\n+Mon Apr 12 02:37:02 1999  Jan Hubicka <hubicka@freesoft.cz>\n+\n+\t* reg-stack.c: Update comment, include varray.h.\n+\t(stack_regs_mentioned_data): New global variable.\n+\t(check_stack_regs_mentioned): New function.\n+\t(stack_regs_mentioned): New function.\n+\t(reg_to_stack): Initialize and free stack_regs_mentioned_data,\n+\tuse stack_regs_mentioned.\n+\t(record_asm_reg_life): Change insn type cache for changed insn.\n+\t(record_reg_life): Do not change the insn mode.\n+\t(emit_pop_insn): Likewise.\n+\t(emit_swap_insn): Likewise.\n+\t(move_for_stack_reg): Likewise.\n+\t(stack_reg_life_analysis): Use stack_regs_mentioned.\n+\t(emit_swap_insn): Likewise.\n+\t(subst_stack_regs): Likewise.\n+\t(convert_regs): Likewise.\n+\t* jump.c (find_cross_jump): Use stack_regs_mentioned.\n+\t* rtl.h (stack_regs_mentioned): Declare.\n+\n Mon Apr 12 00:57:10 1999 Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr> \n \n \t* integrate.c (INTEGRATE_THRESHOLD): Sync it with the comment."}, {"sha": "f961acca270b83c70c39a4044d5317efe655069a", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=21b2cd732182b457962d0f248662c5d894e147ca", "patch": "@@ -2867,7 +2867,7 @@ find_cross_jump (e1, e2, minimum, f1, f2)\n \t indicates whether or not the insn contains any stack-like\n \t regs.  */\n \n-      if (!lose && cross_jump_death_matters && GET_MODE (i1) == QImode)\n+      if (!lose && cross_jump_death_matters && stack_regs_mentioned (i1))\n \t{\n \t  /* If register stack conversion has already been done, then\n \t     death notes must also be compared before it is certain that"}, {"sha": "f843b17752ee35a99b8d3116d8612f3f5a25b8c3", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 73, "deletions": 23, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=21b2cd732182b457962d0f248662c5d894e147ca", "patch": "@@ -74,13 +74,6 @@ Boston, MA 02111-1307, USA.  */\n    deleted and recreated from scratch.  REG_DEAD is never created for a\n    SET_DEST, only REG_UNUSED.\n \n-   Before life analysis, the mode of each insn is set based on whether\n-   or not any stack registers are mentioned within that insn.  VOIDmode\n-   means that no regs are mentioned anyway, and QImode means that at\n-   least one pattern within the insn mentions stack registers.  This\n-   information is valid until after reg_to_stack returns, and is used\n-   from jump_optimize.\n-\n    * asm_operands:\n \n    There are several rules on the usage of stack-like regs in\n@@ -168,6 +161,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"varray.h\"\n \n #ifdef STACK_REGS\n \n@@ -219,6 +213,14 @@ static HARD_REG_SET *block_out_reg_set;\n    add insns within a block.  */\n static int *block_number;\n \n+/* We use this array to cache info about insns, because otherwise we\n+   spend too much time in stack_regs_mentioned_p. \n+\n+   Indexed by insn UIDs.  A value of zero is uninitialized, one indicates\n+   the insn uses stack registers, two indicates the insn does not use\n+   stack registers.  */\n+static varray_type stack_regs_mentioned_data;\n+\n /* This is the register file for all register after conversion */\n static rtx\n   FP_mode_reg[LAST_STACK_REG+1-FIRST_STACK_REG][(int) MAX_MACHINE_MODE];\n@@ -283,6 +285,52 @@ static void goto_block_pat\t\tPROTO((rtx, stack, rtx));\n static void convert_regs\t\tPROTO((void));\n static void print_blocks\t\tPROTO((FILE *, rtx, rtx));\n static void dump_stack_info\t\tPROTO((FILE *));\n+static int check_stack_regs_mentioned\tPROTO((rtx insn));\n+\f\n+/* Initialize stack_regs_mentioned_data for INSN (growing the virtual array\n+   if needed.  Return nonzero if INSN mentions stacked registers.  */\n+\n+static int\n+check_stack_regs_mentioned (insn)\n+     rtx insn;\n+{\n+  unsigned int uid = INSN_UID (insn);\n+  if (uid >= VARRAY_SIZE (stack_regs_mentioned_data))\n+    {\n+      unsigned int size = VARRAY_SIZE (stack_regs_mentioned_data);\n+\n+      /* Allocate some extra size to avoid too many reallocs, but\n+\t do not grow exponentially.  */\n+      size = uid + uid / 20;\n+      VARRAY_GROW (stack_regs_mentioned_data, size);\n+    }\n+  if (stack_regs_mentioned_p (PATTERN (insn)))\n+    {\n+      VARRAY_CHAR (stack_regs_mentioned_data, uid) = 1;\n+      return 1;\n+    }\n+  else\n+    VARRAY_CHAR (stack_regs_mentioned_data, uid) = 2;\n+  return 0;\n+}\n+\n+/* Return nonzero if INSN mentions stacked registers, else return\n+   zero.  */\n+\n+int\n+stack_regs_mentioned (insn)\n+     rtx insn;\n+{\n+  unsigned int uid;\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    return 0;\n+  uid = INSN_UID (insn);\n+  if (uid >= VARRAY_SIZE (stack_regs_mentioned_data)\n+      || ! VARRAY_CHAR (stack_regs_mentioned_data, uid))\n+    return (check_stack_regs_mentioned (insn));\n+  return VARRAY_CHAR (stack_regs_mentioned_data, uid) == 1;\n+}\n+\n \f\n /* Mark all registers needed for this pattern.  */\n \n@@ -412,6 +460,10 @@ reg_to_stack (first, file)\n   enum machine_mode mode;\n   HARD_REG_SET stackentry;\n \n+  max_uid = get_max_uid ();\n+  VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n+\t\t    \"stack_regs_mentioned cache\");\n+\n   CLEAR_HARD_REG_SET (stackentry);\n \n    {\n@@ -472,7 +524,7 @@ reg_to_stack (first, file)\n \t    && stack_regs_mentioned_p (PATTERN (insn)))\n \t  {\n \t    stack_reg_seen = 1;\n-\t    PUT_MODE (insn, QImode);\n+\t    VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 1;\n \n \t    /* Note any register passing parameters.  */\n \n@@ -482,7 +534,7 @@ reg_to_stack (first, file)\n \t\t\t\t   &stackentry, 1);\n \t  }\n \telse\n-\t  PUT_MODE (insn, VOIDmode);\n+\t  VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n \n \tif (code == CODE_LABEL)\n \t  LABEL_REFS (insn) = insn; /* delete old chain */\n@@ -496,7 +548,10 @@ reg_to_stack (first, file)\n      anything to convert.  */\n \n   if (! stack_reg_seen)\n-    return;\n+    {\n+      VARRAY_FREE (stack_regs_mentioned_data);\n+      return;\n+    }\n \n   /* If there are stack registers, there must be at least one block.  */\n \n@@ -532,6 +587,8 @@ reg_to_stack (first, file)\n \n   if (optimize)\n     jump_optimize (first, 2, 0, 0);\n+\n+  VARRAY_FREE (stack_regs_mentioned_data);\n }\n \f\n /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the\n@@ -661,7 +718,7 @@ record_asm_reg_life (insn, regstack)\n       malformed_asm = 1;\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-      PUT_MODE (insn, VOIDmode);\n+      VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n       return;\n     }\n \n@@ -794,7 +851,7 @@ record_asm_reg_life (insn, regstack)\n     {\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-      PUT_MODE (insn, VOIDmode);\n+      VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n       return;\n     }\n \n@@ -1022,7 +1079,6 @@ record_reg_life (insn, block, regstack)\n \t        pat = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, DFmode),\n \t\t\t\t   CONST0_RTX (DFmode));\n \t        init = emit_insn_after (pat, insn);\n-\t        PUT_MODE (init, QImode);\n \n \t        CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n \n@@ -1232,7 +1288,7 @@ stack_reg_life_analysis (first, stackentry)\n \t     everything dies.  But otherwise don't process unless there\n \t     are some stack regs present.  */\n \n-\t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n+\t  if (stack_regs_mentioned (insn) || GET_CODE (insn) == CALL_INSN)\n \t    record_reg_life (insn, block, &regstack);\n \n \t} while (insn != block_begin[block]);\n@@ -1318,7 +1374,6 @@ stack_reg_life_analysis (first, stackentry)\n \tinit_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG(reg, DFmode),\n \t\t\t\tCONST0_RTX (DFmode));\n \tblock_begin[0] = emit_insn_after (init_rtx, first);\n-\tPUT_MODE (block_begin[0], QImode);\n \n \tCLEAR_HARD_REG_BIT (block_stack_in[0].reg_set, reg);\n       }\n@@ -1444,8 +1499,6 @@ emit_pop_insn (insn, regstack, reg, when)\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n   pop_insn = (*when) (pop_rtx, insn);\n-  /* ??? This used to be VOIDmode, but that seems wrong.  */\n-  PUT_MODE (pop_insn, QImode);\n \n   REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n \t\t\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode),\n@@ -1496,7 +1549,7 @@ emit_swap_insn (insn, regstack, reg)\n   /* Find the previous insn involving stack regs, but don't go past\n      any labels, calls or jumps.  */\n   i1 = prev_nonnote_insn (insn);\n-  while (i1 && GET_CODE (i1) == INSN && GET_MODE (i1) != QImode)\n+  while (i1 && GET_CODE (i1) == INSN && !stack_regs_mentioned (i1))\n     i1 = prev_nonnote_insn (i1);\n \n   if (i1)\n@@ -1534,8 +1587,6 @@ emit_swap_insn (insn, regstack, reg)\n   swap_rtx = gen_swapdf (FP_MODE_REG (hard_regno, DFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n   swap_insn = emit_insn_after (swap_rtx, i1);\n-  /* ??? This used to be VOIDmode, but that seems wrong.  */\n-  PUT_MODE (swap_insn, QImode);\n }\n \f\n /* Handle a move to or from a stack register in PAT, which is in INSN.\n@@ -1652,7 +1703,6 @@ move_for_stack_reg (insn, regstack, pat)\n \n \t  push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n \t  push_insn = emit_insn_before (push_rtx, insn);\n-\t  PUT_MODE (push_insn, QImode);\n \t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, top_stack_reg,\n \t\t\t\t\t\tREG_NOTES (insn));\n \t}\n@@ -2469,7 +2519,7 @@ subst_stack_regs (insn, regstack)\n      we must check each pattern in a parallel here.  A call_value_pop could\n      fail otherwise.  */\n \n-  if (GET_MODE (insn) == QImode)\n+  if (stack_regs_mentioned (insn))\n     {\n       int n_operands = asm_noperands (PATTERN (insn));\n       if (n_operands >= 0)\n@@ -2791,7 +2841,7 @@ convert_regs ()\n \t     mentioned or if it's a CALL_INSN (register passing of\n \t     floating point values).  */\n \n-\t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n+\t  if (stack_regs_mentioned (insn) || GET_CODE (insn) == CALL_INSN)\n \t    subst_stack_regs (insn, &regstack);\n \n \t} while (insn != block_end[block]);"}, {"sha": "ef6440ca38bd2d2c7550cf8e516d018939034950", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b2cd732182b457962d0f248662c5d894e147ca/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=21b2cd732182b457962d0f248662c5d894e147ca", "patch": "@@ -1623,4 +1623,8 @@ extern void record_base_value\t\tPROTO ((int, rtx, int));\n extern void record_alias_subset         PROTO ((int, int));\n extern rtx addr_side_effect_eval\tPROTO ((rtx, int, int));\n \n+#ifdef STACK_REGS\n+extern int stack_regs_mentioned\t\tPROTO((rtx insn));\n+#endif\n+\n #endif /* _RTL_H */"}]}