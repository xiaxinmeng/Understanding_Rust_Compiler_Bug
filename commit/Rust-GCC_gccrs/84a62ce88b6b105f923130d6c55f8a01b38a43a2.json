{"sha": "84a62ce88b6b105f923130d6c55f8a01b38a43a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRhNjJjZTg4YjZiMTA1ZjkyMzEzMGQ2YzU1ZjhhMDFiMzhhNDNhMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T12:55:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T12:55:47Z"}, "message": "[multiple changes]\n\n2016-10-12  Bob Duff  <duff@adacore.com>\n\n\t* xref_lib.adb: Use renamings-of-slices to ensure\n\tthat all references to Tables are properly bounds checked (when\n\tchecks are turned on).\n\t* g-dyntab.ads, g-dyntab.adb: Default-initialize the array\n\tcomponents, so we don't get uninitialized pointers in case\n\tof Tables containing access types.  Misc cleanup of the code\n\tand comments.\n\n2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Type_Key): Implement\n\tfunctionality of attribute, to provide a reasonably unique key\n\tfor a given type and detect any changes in the semantics of the\n\ttype or any of its subcomponents from version to version.\n\n2016-10-12  Bob Duff  <duff@adacore.com>\n\n\t* sem_case.adb (Check_Choice_Set): Separate\n\tchecking for duplicates out into a separate pass from checking\n\tfull coverage, because the check for duplicates does not depend\n\ton predicates. Therefore, we shouldn't do it separately for the\n\tpredicate vs. no-predicate case; we should share code. The code\n\tfor the predicate case was wrong.\n\nFrom-SVN: r241039", "tree": {"sha": "36d46793b238d2977d192ab258de44bd34eaf953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d46793b238d2977d192ab258de44bd34eaf953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84a62ce88b6b105f923130d6c55f8a01b38a43a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a62ce88b6b105f923130d6c55f8a01b38a43a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a62ce88b6b105f923130d6c55f8a01b38a43a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a62ce88b6b105f923130d6c55f8a01b38a43a2/comments", "author": null, "committer": null, "parents": [{"sha": "6e8323274a29065a1eecdf19001484ad2958d45a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8323274a29065a1eecdf19001484ad2958d45a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e8323274a29065a1eecdf19001484ad2958d45a"}], "stats": {"total": 925, "additions": 563, "deletions": 362}, "files": [{"sha": "101ea652c0c5e48eaf046f7f3778ebbe1cfbb5d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -1,3 +1,29 @@\n+2016-10-12  Bob Duff  <duff@adacore.com>\n+\n+\t* xref_lib.adb: Use renamings-of-slices to ensure\n+\tthat all references to Tables are properly bounds checked (when\n+\tchecks are turned on).\n+\t* g-dyntab.ads, g-dyntab.adb: Default-initialize the array\n+\tcomponents, so we don't get uninitialized pointers in case\n+\tof Tables containing access types.  Misc cleanup of the code\n+\tand comments.\n+\n+2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Type_Key): Implement\n+\tfunctionality of attribute, to provide a reasonably unique key\n+\tfor a given type and detect any changes in the semantics of the\n+\ttype or any of its subcomponents from version to version.\n+\n+2016-10-12  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_case.adb (Check_Choice_Set): Separate\n+\tchecking for duplicates out into a separate pass from checking\n+\tfull coverage, because the check for duplicates does not depend\n+\ton predicates. Therefore, we shouldn't do it separately for the\n+\tpredicate vs. no-predicate case; we should share code. The code\n+\tfor the predicate case was wrong.\n+\n 2016-10-12  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* init.c: Make sure to call finit on x86_64-vx7 to reinitialize"}, {"sha": "a74697dffbaaed984c74dcd3298a83801d721c54", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 186, "deletions": 186, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2014, AdaCore                     --\n+--                     Copyright (C) 2000-2016, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,45 +32,33 @@\n pragma Compiler_Unit_Warning;\n \n with GNAT.Heap_Sort_G;\n-with System;        use System;\n-with System.Memory; use System.Memory;\n \n-with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n \n package body GNAT.Dynamic_Tables is\n \n-   Min : constant Integer := Integer (Table_Low_Bound);\n-   --  Subscript of the minimum entry in the currently allocated table\n+   Empty : constant Table_Ptr :=\n+             Empty_Table_Array_Ptr_To_Table_Ptr (Empty_Table_Array'Access);\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Reallocate (T : in out Instance);\n-   --  Reallocate the existing table according to the current value stored\n-   --  in Max. Works correctly to do an initial allocation if the table\n-   --  is currently null.\n-\n-   pragma Warnings (Off);\n-   --  These unchecked conversions are in fact safe, since they never\n-   --  generate improperly aliased pointer values.\n-\n-   function To_Address is new Ada.Unchecked_Conversion (Table_Ptr, Address);\n-   function To_Pointer is new Ada.Unchecked_Conversion (Address, Table_Ptr);\n-\n-   pragma Warnings (On);\n+   procedure Grow (T : in out Instance; New_Last : Table_Count_Type);\n+   --  This is called when we are about to set the value of Last to a value\n+   --  that is larger than Last_Allocated. This reallocates the table to the\n+   --  larger size, as indicated by New_Last. At the time this is called,\n+   --  T.P.Last is still the old value.\n \n    --------------\n    -- Allocate --\n    --------------\n \n    procedure Allocate (T : in out Instance; Num : Integer := 1) is\n    begin\n-      T.P.Last_Val := T.P.Last_Val + Num;\n+      --  Note that Num can be negative\n \n-      if T.P.Last_Val > T.P.Max then\n-         Reallocate (T);\n-      end if;\n+      Set_Last (T, T.P.Last + Table_Index_Type'Base (Num));\n    end Allocate;\n \n    ------------\n@@ -79,7 +67,7 @@ package body GNAT.Dynamic_Tables is\n \n    procedure Append (T : in out Instance; New_Val : Table_Component_Type) is\n    begin\n-      Set_Item (T, Table_Index_Type (T.P.Last_Val + 1), New_Val);\n+      Set_Item (T, T.P.Last + 1, New_Val);\n    end Append;\n \n    ----------------\n@@ -99,17 +87,26 @@ package body GNAT.Dynamic_Tables is\n \n    procedure Decrement_Last (T : in out Instance) is\n    begin\n-      T.P.Last_Val := T.P.Last_Val - 1;\n+      Allocate (T, -1);\n    end Decrement_Last;\n \n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First return Table_Index_Type is\n+   begin\n+      return Table_Low_Bound;\n+   end First;\n+\n    --------------\n    -- For_Each --\n    --------------\n \n    procedure For_Each (Table : Instance) is\n       Quit : Boolean := False;\n    begin\n-      for Index in Table_Low_Bound .. Table_Index_Type (Table.P.Last_Val) loop\n+      for Index in Table_Low_Bound .. Table.P.Last loop\n          Action (Index, Table.Table (Index), Quit);\n          exit when Quit;\n       end loop;\n@@ -120,234 +117,238 @@ package body GNAT.Dynamic_Tables is\n    ----------\n \n    procedure Free (T : in out Instance) is\n+      subtype Alloc_Type is Table_Type (First .. T.P.Last_Allocated);\n+      type Alloc_Ptr is access all Alloc_Type;\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Alloc_Type, Alloc_Ptr);\n+      function To_Alloc_Ptr is\n+        new Ada.Unchecked_Conversion (Table_Ptr, Alloc_Ptr);\n+\n+      Temp : Alloc_Ptr := To_Alloc_Ptr (T.Table);\n+\n    begin\n-      Free (To_Address (T.Table));\n-      T.Table := null;\n-      T.P.Length := 0;\n+      if T.Table = Empty then\n+         pragma Assert (T.P.Last_Allocated = First - 1);\n+         pragma Assert (T.P.Last = First - 1);\n+         null;\n+      else\n+         Free (Temp);\n+         T.Table := Empty;\n+         T.P.Last_Allocated := First - 1;\n+         T.P.Last := First - 1;\n+      end if;\n    end Free;\n \n+   ----------\n+   -- Grow --\n+   ----------\n+\n+   procedure Grow (T : in out Instance; New_Last : Table_Count_Type) is\n+\n+      --  Note: Type Alloc_Ptr below needs to be declared locally so we know\n+      --  the bounds. That means that the collection is local, so is finalized\n+      --  when leaving Grow. That's why this package doesn't support controlled\n+      --  types; the table elements would be finalized prematurely. An Ada\n+      --  implementation would also be within its rights to reclaim the\n+      --  storage. Fortunately, GNAT doesn't do that.\n+\n+      pragma Assert (not T.Locked);\n+      pragma Assert (New_Last > T.P.Last_Allocated);\n+\n+      subtype Table_Length_Type is Table_Index_Type'Base\n+        range 0 .. Table_Index_Type'Base'Last;\n+\n+      Old_Last_Allocated   : constant Table_Count_Type  := T.P.Last_Allocated;\n+      Old_Allocated_Length : constant Table_Length_Type :=\n+                               Old_Last_Allocated - First + 1;\n+\n+      New_Length : constant Table_Length_Type := New_Last - First + 1;\n+      New_Allocated_Length : Table_Length_Type;\n+\n+   begin\n+      if T.Table = Empty then\n+         New_Allocated_Length := Table_Length_Type (Table_Initial);\n+      else\n+         New_Allocated_Length :=\n+           Table_Length_Type\n+             (Long_Long_Integer (Old_Allocated_Length) *\n+               (100 + Long_Long_Integer (Table_Increment)) / 100);\n+      end if;\n+\n+      --  Make sure it really did grow\n+\n+      if New_Allocated_Length <= Old_Allocated_Length then\n+         New_Allocated_Length := Old_Allocated_Length + 10;\n+      end if;\n+\n+      if New_Allocated_Length <= New_Length then\n+         New_Allocated_Length := New_Length + 10;\n+      end if;\n+\n+      pragma Assert (New_Allocated_Length > Old_Allocated_Length);\n+      pragma Assert (New_Allocated_Length > New_Length);\n+\n+      T.P.Last_Allocated := First + New_Allocated_Length - 1;\n+\n+      declare\n+         subtype Old_Alloc_Type is Table_Type (First .. Old_Last_Allocated);\n+         type Old_Alloc_Ptr is access all Old_Alloc_Type;\n+\n+         procedure Free is\n+           new Ada.Unchecked_Deallocation (Old_Alloc_Type, Old_Alloc_Ptr);\n+         function To_Old_Alloc_Ptr is\n+           new Ada.Unchecked_Conversion (Table_Ptr, Old_Alloc_Ptr);\n+\n+         subtype Alloc_Type is\n+           Table_Type (First .. First + New_Allocated_Length - 1);\n+         type Alloc_Ptr is access all Alloc_Type;\n+\n+         function To_Table_Ptr is\n+           new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n+\n+         Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n+         New_Table : constant Alloc_Ptr := new Alloc_Type;\n+\n+      begin\n+         if T.Table /= Empty then\n+            New_Table (First .. T.P.Last) := Old_Table (First .. T.P.Last);\n+            Free (Old_Table);\n+         end if;\n+\n+         T.Table := To_Table_Ptr (New_Table);\n+      end;\n+\n+      pragma Assert (New_Last <= T.P.Last_Allocated);\n+      pragma Assert (T.Table /= null);\n+      pragma Assert (T.Table /= Empty);\n+   end Grow;\n+\n    --------------------\n    -- Increment_Last --\n    --------------------\n \n    procedure Increment_Last (T : in out Instance) is\n    begin\n-      T.P.Last_Val := T.P.Last_Val + 1;\n-\n-      if T.P.Last_Val > T.P.Max then\n-         Reallocate (T);\n-      end if;\n+      Allocate (T, 1);\n    end Increment_Last;\n \n    ----------\n    -- Init --\n    ----------\n \n    procedure Init (T : in out Instance) is\n-      Old_Length : constant Integer := T.P.Length;\n-\n    begin\n-      T.P.Last_Val := Min - 1;\n-      T.P.Max      := Min + Table_Initial - 1;\n-      T.P.Length   := T.P.Max - Min + 1;\n-\n-      --  If table is same size as before (happens when table is never\n-      --  expanded which is a common case), then simply reuse it. Note\n-      --  that this also means that an explicit Init call right after\n-      --  the implicit one in the package body is harmless.\n-\n-      if Old_Length = T.P.Length then\n-         return;\n-\n-      --  Otherwise we can use Reallocate to get a table of the right size.\n-      --  Note that Reallocate works fine to allocate a table of the right\n-      --  initial size when it is first allocated.\n-\n-      else\n-         Reallocate (T);\n-      end if;\n+      Free (T);\n    end Init;\n \n    ----------\n    -- Last --\n    ----------\n \n-   function Last (T : Instance) return Table_Index_Type is\n+   function Last (T : Instance) return Table_Count_Type is\n    begin\n-      return Table_Index_Type (T.P.Last_Val);\n+      return T.P.Last;\n    end Last;\n \n-   ----------------\n-   -- Reallocate --\n-   ----------------\n-\n-   procedure Reallocate (T : in out Instance) is\n-      New_Length : Integer;\n-      New_Size   : size_t;\n+   -------------\n+   -- Release --\n+   -------------\n \n+   procedure Release (T : in out Instance) is\n+      pragma Assert (not T.Locked);\n+      Old_Last_Allocated : constant Table_Count_Type := T.P.Last_Allocated;\n    begin\n-      if T.P.Max < T.P.Last_Val then\n-\n-         --  Now increment table length until it is sufficiently large. Use\n-         --  the increment value or 10, which ever is larger (the reason\n-         --  for the use of 10 here is to ensure that the table does really\n-         --  increase in size (which would not be the case for a table of\n-         --  length 10 increased by 3% for instance). Do the intermediate\n-         --  calculation in Long_Long_Integer to avoid overflow.\n-\n-         while T.P.Max < T.P.Last_Val loop\n-            New_Length :=\n-              Integer\n-                (Long_Long_Integer (T.P.Length) *\n-                  (100 + Long_Long_Integer (Table_Increment)) / 100);\n-\n-            if New_Length > T.P.Length then\n-               T.P.Length := New_Length;\n-            else\n-               T.P.Length := T.P.Length + 10;\n-            end if;\n-\n-            T.P.Max := Min + T.P.Length - 1;\n-         end loop;\n-      end if;\n+      if T.P.Last /= T.P.Last_Allocated then\n+         pragma Assert (T.P.Last < T.P.Last_Allocated);\n+         pragma Assert (T.Table /= Empty);\n \n-      New_Size :=\n-        size_t ((T.P.Max - Min + 1) *\n-                (Table_Type'Component_Size / Storage_Unit));\n+         declare\n+            subtype Old_Alloc_Type is Table_Type (First .. Old_Last_Allocated);\n+            type Old_Alloc_Ptr is access all Old_Alloc_Type;\n \n-      if T.Table = null then\n-         T.Table := To_Pointer (Alloc (New_Size));\n+            procedure Free is\n+              new Ada.Unchecked_Deallocation (Old_Alloc_Type, Old_Alloc_Ptr);\n+            function To_Old_Alloc_Ptr is\n+              new Ada.Unchecked_Conversion (Table_Ptr, Old_Alloc_Ptr);\n \n-      elsif New_Size > 0 then\n-         T.Table :=\n-           To_Pointer (Realloc (Ptr  => To_Address (T.Table),\n-                                Size => New_Size));\n-      end if;\n+            subtype Alloc_Type is\n+              Table_Type (First .. First + T.P.Last - 1);\n+            type Alloc_Ptr is access all Alloc_Type;\n \n-      if T.P.Length /= 0 and then T.Table = null then\n-         raise Storage_Error;\n-      end if;\n-   end Reallocate;\n+            function To_Table_Ptr is\n+              new Ada.Unchecked_Conversion (Alloc_Ptr, Table_Ptr);\n \n-   -------------\n-   -- Release --\n-   -------------\n+            Old_Table : Old_Alloc_Ptr := To_Old_Alloc_Ptr (T.Table);\n+            New_Table : constant Alloc_Ptr := new Alloc_Type'(Old_Table.all);\n+         begin\n+            T.P.Last_Allocated := T.P.Last;\n+            Free (Old_Table);\n+            T.Table := To_Table_Ptr (New_Table);\n+         end;\n+      end if;\n \n-   procedure Release (T : in out Instance) is\n-   begin\n-      T.P.Length := T.P.Last_Val - Integer (Table_Low_Bound) + 1;\n-      T.P.Max    := T.P.Last_Val;\n-      Reallocate (T);\n+      pragma Assert (T.P.Last = T.P.Last_Allocated);\n    end Release;\n \n    --------------\n    -- Set_Item --\n    --------------\n \n    procedure Set_Item\n-      (T     : in out Instance;\n-       Index : Table_Index_Type;\n-       Item  : Table_Component_Type)\n+     (T     : in out Instance;\n+      Index : Valid_Table_Index_Type;\n+      Item  : Table_Component_Type)\n    is\n-      --  If Item is a value within the current allocation, and we are going to\n-      --  reallocate, then we must preserve an intermediate copy here before\n-      --  calling Increment_Last. Otherwise, if Table_Component_Type is passed\n-      --  by reference, we are going to end up copying from storage that might\n-      --  have been deallocated from Increment_Last calling Reallocate.\n-\n-      subtype Allocated_Table_T is\n-        Table_Type (T.Table'First .. Table_Index_Type (T.P.Max + 1));\n-      --  A constrained table subtype one element larger than the currently\n-      --  allocated table.\n-\n-      Allocated_Table_Address : constant System.Address :=\n-                                  T.Table.all'Address;\n-      --  Used for address clause below (we can't use non-static expression\n-      --  Table.all'Address directly in the clause because some older versions\n-      --  of the compiler do not allow it).\n-\n-      Allocated_Table : Allocated_Table_T;\n-      pragma Import (Ada, Allocated_Table);\n-      pragma Suppress (Range_Check, On => Allocated_Table);\n-      for Allocated_Table'Address use Allocated_Table_Address;\n-      --  Allocated_Table represents the currently allocated array, plus one\n-      --  element (the supplementary element is used to have a convenient way\n-      --  to the address just past the end of the current allocation). Range\n-      --  checks are suppressed because this unit uses direct calls to\n-      --  System.Memory for allocation, and this can yield misaligned storage\n-      --  (and we cannot rely on the bootstrap compiler supporting specifically\n-      --  disabling alignment checks, so we need to suppress all range checks).\n-      --  It is safe to suppress this check here because we know that a\n-      --  (possibly misaligned) object of that type does actually exist at that\n-      --  address.\n-      --  ??? We should really improve the allocation circuitry here to\n-      --  guarantee proper alignment.\n-\n-      Need_Realloc : constant Boolean := Integer (Index) > T.P.Max;\n-      --  True if this operation requires storage reallocation (which may\n-      --  involve moving table contents around).\n-\n+      Item_Copy : constant Table_Component_Type := Item;\n    begin\n-      --  If we're going to reallocate, check whether Item references an\n-      --  element of the currently allocated table.\n-\n-      if Need_Realloc\n-        and then Allocated_Table'Address <= Item'Address\n-        and then Item'Address <\n-                   Allocated_Table (Table_Index_Type (T.P.Max + 1))'Address\n-      then\n-         --  If so, save a copy on the stack because Increment_Last will\n-         --  reallocate storage and might deallocate the current table.\n+      --  If Set_Last is going to reallocate the table, we make a copy of Item,\n+      --  in case the call was \"Set_Item (T, X, T.Table (Y));\", and Item is\n+      --  passed by reference. Without the copy, we would deallocate the array\n+      --  containing Item, leaving a dangling pointer.\n \n+      if Index > T.P.Last_Allocated then\n          declare\n             Item_Copy : constant Table_Component_Type := Item;\n          begin\n             Set_Last (T, Index);\n             T.Table (Index) := Item_Copy;\n          end;\n \n-      else\n-         --  Here we know that either we won't reallocate (case of Index < Max)\n-         --  or that Item is not in the currently allocated table.\n-\n-         if Integer (Index) > T.P.Last_Val then\n-            Set_Last (T, Index);\n-         end if;\n+         return;\n+      end if;\n \n-         T.Table (Index) := Item;\n+      if Index > T.P.Last then\n+         Set_Last (T, Index);\n       end if;\n+\n+      T.Table (Index) := Item_Copy;\n    end Set_Item;\n \n    --------------\n    -- Set_Last --\n    --------------\n \n-   procedure Set_Last (T : in out Instance; New_Val : Table_Index_Type) is\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Count_Type) is\n+      pragma Assert (not T.Locked);\n    begin\n-      if Integer (New_Val) < T.P.Last_Val then\n-         T.P.Last_Val := Integer (New_Val);\n-\n-      else\n-         T.P.Last_Val := Integer (New_Val);\n-\n-         if T.P.Last_Val > T.P.Max then\n-            Reallocate (T);\n-         end if;\n+      if New_Val > T.P.Last_Allocated then\n+         Grow (T, New_Val);\n       end if;\n+\n+      T.P.Last := New_Val;\n    end Set_Last;\n \n    ----------------\n    -- Sort_Table --\n    ----------------\n \n    procedure Sort_Table (Table : in out Instance) is\n-\n       Temp : Table_Component_Type;\n       --  A temporary position to simulate index 0\n \n       --  Local subprograms\n \n-      function Index_Of (Idx : Natural) return Table_Index_Type;\n+      function Index_Of (Idx : Natural) return Table_Index_Type'Base;\n       --  Return index of Idx'th element of table\n \n       function Lower_Than (Op1, Op2 : Natural) return Boolean;\n@@ -362,11 +363,11 @@ package body GNAT.Dynamic_Tables is\n       -- Index_Of --\n       --------------\n \n-      function Index_Of (Idx : Natural) return Table_Index_Type is\n+      function Index_Of (Idx : Natural) return Table_Index_Type'Base is\n          J : constant Integer'Base :=\n-               Table_Index_Type'Pos (First) + Idx - 1;\n+               Table_Index_Type'Base'Pos (First) + Idx - 1;\n       begin\n-         return Table_Index_Type'Val (J);\n+         return Table_Index_Type'Base'Val (J);\n       end Index_Of;\n \n       ----------\n@@ -401,8 +402,7 @@ package body GNAT.Dynamic_Tables is\n \n          else\n             return\n-              Lt (Table.Table (Index_Of (Op1)),\n-                   Table.Table (Index_Of (Op2)));\n+              Lt (Table.Table (Index_Of (Op1)), Table.Table (Index_Of (Op2)));\n          end if;\n       end Lower_Than;\n "}, {"sha": "eb7181565dbbe6f9911c09a3060da7a8be0380c7", "filename": "gcc/ada/g-dyntab.ads", "status": "modified", "additions": 99, "deletions": 73, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fg-dyntab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fg-dyntab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.ads?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2015, AdaCore                     --\n+--                     Copyright (C) 2000-2016, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,40 +41,49 @@\n --  instances of the table, while an instantiation of GNAT.Table creates a\n --  single instance of the table type.\n \n---  Note that this interface should remain synchronized with those in\n---  GNAT.Table and the GNAT compiler source unit Table to keep as much\n---  coherency as possible between these three related units.\n+--  Note that these three interfaces should remain synchronized to keep as much\n+--  coherency as possible among these three related units:\n+--\n+--     GNAT.Dynamic_Tables\n+--     GNAT.Table\n+--     Table (the compiler unit)\n \n pragma Compiler_Unit_Warning;\n \n+with Ada.Unchecked_Conversion;\n+\n generic\n    type Table_Component_Type is private;\n    type Table_Index_Type     is range <>;\n \n    Table_Low_Bound : Table_Index_Type;\n-   Table_Initial   : Positive;\n-   Table_Increment : Natural;\n+   Table_Initial   : Positive := 8;\n+   Table_Increment : Natural := 100;\n \n package GNAT.Dynamic_Tables is\n \n-   --  Table_Component_Type and Table_Index_Type specify the type of the\n-   --  array, Table_Low_Bound is the lower bound. Table_Index_Type must be an\n-   --  integer type. The effect is roughly to declare:\n+   --  Table_Component_Type and Table_Index_Type specify the type of the array,\n+   --  Table_Low_Bound is the lower bound. The effect is roughly to declare:\n \n    --    Table : array (Table_Low_Bound .. <>) of Table_Component_Type;\n \n-   --    Note: since the upper bound can be one less than the lower\n-   --    bound for an empty array, the table index type must be able\n-   --    to cover this range, e.g. if the lower bound is 1, then the\n-   --    Table_Index_Type should be Natural rather than Positive.\n+   --  The lower bound of Table_Index_Type is ignored.\n+\n+   pragma Assert (Table_Low_Bound /= Table_Index_Type'Base'First);\n+\n+   function First return Table_Index_Type;\n+   pragma Inline (First);\n+   --  Export First as synonym for Table_Low_Bound (parallel with use of Last)\n \n-   --  Table_Component_Type may be any Ada type, except that controlled\n-   --  types are not supported. Note however that default initialization\n-   --  will NOT occur for array components.\n+   subtype Valid_Table_Index_Type is Table_Index_Type'Base\n+     range Table_Low_Bound .. Table_Index_Type'Base'Last;\n+   subtype Table_Count_Type is Table_Index_Type'Base\n+     range Table_Low_Bound - 1 .. Table_Index_Type'Base'Last;\n \n-   --  The Table_Initial values controls the allocation of the table when\n-   --  it is first allocated, either by default, or by an explicit Init\n-   --  call.\n+   --  Table_Component_Type must not be a type with controlled parts.\n+\n+   --  The Table_Initial value controls the allocation of the table when\n+   --  it is first allocated.\n \n    --  The Table_Increment value controls the amount of increase, if the\n    --  table has to be increased in size. The value given is a percentage\n@@ -90,115 +99,132 @@ package GNAT.Dynamic_Tables is\n    --  to take the access of a table element, use Unrestricted_Access.\n \n    type Table_Type is\n-     array (Table_Index_Type range <>) of Table_Component_Type;\n+     array (Valid_Table_Index_Type range <>) of Table_Component_Type;\n    subtype Big_Table_Type is\n-     Table_Type (Table_Low_Bound .. Table_Index_Type'Last);\n+     Table_Type (Table_Low_Bound .. Valid_Table_Index_Type'Last);\n    --  We work with pointers to a bogus array type that is constrained with\n    --  the maximum possible range bound. This means that the pointer is a thin\n    --  pointer, which is more efficient. Since subscript checks in any case\n    --  must be on the logical, rather than physical bounds, safety is not\n-   --  compromised by this approach. These types should not be used by the\n-   --  client.\n+   --  compromised by this approach.\n+\n+   --  To get subscript checking, rename a slice of the Table, like this:\n+\n+   --     Table : Table_Type renames T.Table (First .. Last (T));\n+\n+   --  and the refer to components of Table.\n \n    type Table_Ptr is access all Big_Table_Type;\n    for Table_Ptr'Storage_Size use 0;\n-   --  The table is actually represented as a pointer to allow reallocation.\n-   --  This type should not be used by the client.\n+   --  The table is actually represented as a pointer to allow reallocation\n \n    type Table_Private is private;\n    --  Table private data that is not exported in Instance\n \n+   --  Private use only:\n+   subtype Empty_Table_Array_Type is\n+     Table_Type (Table_Low_Bound .. Table_Low_Bound - 1);\n+   type Empty_Table_Array_Ptr is access all Empty_Table_Array_Type;\n+   Empty_Table_Array : aliased Empty_Table_Array_Type;\n+   function Empty_Table_Array_Ptr_To_Table_Ptr is\n+     new Ada.Unchecked_Conversion (Empty_Table_Array_Ptr, Table_Ptr);\n+   --  End private use only. The above are used to initialize Table to point to\n+   --  an empty array.\n+\n    type Instance is record\n-      Table : aliased Table_Ptr := null;\n-   --  The table itself. The lower bound is the value of Low_Bound.\n-   --  Logically the upper bound is the current value of Last (although\n-   --  the actual size of the allocated table may be larger than this).\n-   --  The program may only access and modify Table entries in the\n-   --  range First .. Last.\n+      Table : aliased Table_Ptr :=\n+                Empty_Table_Array_Ptr_To_Table_Ptr (Empty_Table_Array'Access);\n+      --  The table itself. The lower bound is the value of First. Logically\n+      --  the upper bound is the current value of Last (although the actual\n+      --  size of the allocated table may be larger than this). The program may\n+      --  only access and modify Table entries in the range First .. Last.\n+      --\n+      --  It's a good idea to access this via a renaming of a slice, in order\n+      --  to ensure bounds checking, as in:\n+      --\n+      --     Tab : Table_Type renames X.Table (First .. X.Last);\n+\n+      Locked : Boolean := False;\n+      --  Table expansion is permitted only if this switch is set to False. A\n+      --  client may set Locked to True, in which case any attempt to expand\n+      --  the table will cause an assertion failure. Note that while a table\n+      --  is locked, its address in memory remains fixed and unchanging.\n \n       P : Table_Private;\n    end record;\n \n    procedure Init (T : in out Instance);\n-   --  This procedure allocates a new table of size Initial (freeing any\n-   --  previously allocated larger table). Init must be called before using\n-   --  the table. Init is convenient in reestablishing a table for new use.\n+   --  Reinitializes the table to empty. There is no need to call this before\n+   --  using a table; tables default to empty.\n \n-   function Last (T : Instance) return Table_Index_Type;\n+   function Last (T : Instance) return Table_Count_Type;\n    pragma Inline (Last);\n-   --  Returns the current value of the last used entry in the table,\n-   --  which can then be used as a subscript for Table. Note that the\n-   --  only way to modify Last is to call the Set_Last procedure. Last\n-   --  must always be used to determine the logically last entry.\n+   --  Returns the current value of the last used entry in the table, which can\n+   --  then be used as a subscript for Table.\n \n    procedure Release (T : in out Instance);\n    --  Storage is allocated in chunks according to the values given in the\n-   --  Initial and Increment parameters. A call to Release releases all\n-   --  storage that is allocated, but is not logically part of the current\n+   --  Table_Initial and Table_Increment parameters. A call to Release releases\n+   --  all storage that is allocated, but is not logically part of the current\n    --  array value. Current array values are not affected by this call.\n \n    procedure Free (T : in out Instance);\n-   --  Free all allocated memory for the table. A call to init is required\n-   --  before any use of this table after calling Free.\n+   --  Same as Init\n \n-   First : constant Table_Index_Type := Table_Low_Bound;\n-   --  Export First as synonym for Low_Bound (parallel with use of Last)\n-\n-   procedure Set_Last (T : in out Instance; New_Val : Table_Index_Type);\n+   procedure Set_Last (T : in out Instance; New_Val : Table_Count_Type);\n    pragma Inline (Set_Last);\n-   --  This procedure sets Last to the indicated value. If necessary the\n-   --  table is reallocated to accommodate the new value (i.e. on return\n-   --  the allocated table has an upper bound of at least Last). If\n-   --  Set_Last reduces the size of the table, then logically entries are\n-   --  removed from the table. If Set_Last increases the size of the\n-   --  table, then new entries are logically added to the table.\n+   --  This procedure sets Last to the indicated value. If necessary the table\n+   --  is reallocated to accommodate the new value (i.e. on return the\n+   --  allocated table has an upper bound of at least Last). If Set_Last\n+   --  reduces the size of the table, then logically entries are removed from\n+   --  the table. If Set_Last increases the size of the table, then new entries\n+   --  are logically added to the table.\n \n    procedure Increment_Last (T : in out Instance);\n    pragma Inline (Increment_Last);\n-   --  Adds 1 to Last (same as Set_Last (Last + 1)\n+   --  Adds 1 to Last (same as Set_Last (Last + 1))\n \n    procedure Decrement_Last (T : in out Instance);\n    pragma Inline (Decrement_Last);\n-   --  Subtracts 1 from Last (same as Set_Last (Last - 1)\n+   --  Subtracts 1 from Last (same as Set_Last (Last - 1))\n \n    procedure Append (T : in out Instance; New_Val : Table_Component_Type);\n    pragma Inline (Append);\n+   --  Appends New_Val onto the end of the table\n    --  Equivalent to:\n    --    Increment_Last (T);\n    --    T.Table (T.Last) := New_Val;\n-   --  i.e. the table size is increased by one, and the given new item\n-   --  stored in the newly created table element.\n \n    procedure Append_All (T : in out Instance; New_Vals : Table_Type);\n    --  Appends all components of New_Vals\n \n    procedure Set_Item\n      (T     : in out Instance;\n-      Index : Table_Index_Type;\n+      Index : Valid_Table_Index_Type;\n       Item  : Table_Component_Type);\n    pragma Inline (Set_Item);\n-   --  Put Item in the table at position Index. The table is expanded if\n-   --  current table length is less than Index and in that case Last is set to\n-   --  Index. Item will replace any value already present in the table at this\n-   --  position.\n+   --  Put Item in the table at position Index. If Index points to an existing\n+   --  item (i.e. it is in the range First .. Last (T)), the item is replaced.\n+   --  Otherwise (i.e. Index > Last (T), the table is expanded, and Last is set\n+   --  to Index.\n \n    procedure Allocate (T : in out Instance; Num : Integer := 1);\n    pragma Inline (Allocate);\n    --  Adds Num to Last\n \n    generic\n      with procedure Action\n-       (Index : Table_Index_Type;\n+       (Index : Valid_Table_Index_Type;\n         Item  : Table_Component_Type;\n         Quit  : in out Boolean) is <>;\n    procedure For_Each (Table : Instance);\n-   --  Calls procedure Action for each component of the table Table, or until\n-   --  one of these calls set Quit to True.\n+   --  Calls procedure Action for each component of the table, or until one of\n+   --  these calls set Quit to True.\n \n    generic\n      with function Lt (Comp1, Comp2 : Table_Component_Type) return Boolean;\n    procedure Sort_Table (Table : in out Instance);\n-   --  This procedure sorts the components of table Table into ascending\n+   --  This procedure sorts the components of the table into ascending\n    --  order making calls to Lt to do required comparisons, and using\n    --  assignments to move components around. The Lt function returns True\n    --  if Comp1 is less than Comp2 (in the sense of the desired sort), and\n@@ -208,16 +234,16 @@ package GNAT.Dynamic_Tables is\n    --  in the table is not preserved).\n \n private\n+\n    type Table_Private is record\n-      Max : Integer;\n-      --  Subscript of the maximum entry in the currently allocated table\n+      Last_Allocated : Table_Count_Type := Table_Low_Bound - 1;\n+      --  Subscript of the maximum entry in the currently allocated table.\n+      --  Initial value ensures that we initially allocate the table.\n \n-      Length : Integer := 0;\n-      --  Number of entries in currently allocated table. The value of zero\n-      --  ensures that we initially allocate the table.\n+      Last : Table_Count_Type := Table_Low_Bound - 1;\n+      --  Current value of Last function\n \n-      Last_Val : Integer;\n-      --  Current value of Last\n+      --  Invariant: Last <= Last_Allocated\n    end record;\n \n end GNAT.Dynamic_Tables;"}, {"sha": "4e00e17a76299827da5a69cbc460ffaadafae9f1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 126, "deletions": 20, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -68,6 +68,7 @@ with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with System;\n+with System.CRC32; use System.CRC32;\n with Stringt;  use Stringt;\n with Style;\n with Stylesw;  use Stylesw;\n@@ -6139,37 +6140,142 @@ package body Sem_Attr is\n          Check_E0;\n          Check_Type;\n \n-         --  This processing belongs in Eval_Attribute ???\n-\n          declare\n-            function Type_Key return String_Id;\n-            --  A very preliminary implementation. For now, a signature\n-            --  consists of only the type name. This is clearly incomplete\n-            --  (e.g., adding a new field to a record type should change the\n-            --  type's Type_Key attribute).\n+            Full_Name  : constant String_Id :=\n+              Fully_Qualified_Name_String (Entity (P));\n+\n+            Deref      : Boolean;\n+            --  To simplify the handling of mutually recursive types, follow\n+            --  a single dereference link in a composite type.\n+\n+            CRC        : CRC32;\n+            --  The computed signature for the type.\n+\n+            procedure Compute_Type_Key (T : Entity_Id);\n+            --  Create a CRC integer from the declaration of the type, For\n+            --  a composite type, fold in the representation of its components\n+            --  in recursive fashion. We use directly the source representation\n+            --  of the types involved.\n \n             --------------\n             -- Type_Key --\n             --------------\n \n-            function Type_Key return String_Id is\n-               Full_Name : constant String_Id :=\n-                             Fully_Qualified_Name_String (Entity (P));\n+            procedure Compute_Type_Key (T : Entity_Id)  is\n+               SFI          : Source_File_Index;\n+               Buffer       : Source_Buffer_Ptr;\n+               P_Min, P_Max : Source_Ptr;\n+               Rep          : Node_Id;\n \n-            begin\n-               --  Copy all characters in Full_Name but the trailing NUL\n+               procedure Process_One_Declaration;\n+               --  Update CRC with the characters of one type declaration,\n+               --  or a representation pragma that applies to the type.\n \n-               Start_String;\n-               for J in 1 .. String_Length (Full_Name) - 1 loop\n-                  Store_String_Char (Get_String_Char (Full_Name, Pos (J)));\n-               end loop;\n+               -----------------------------\n+               -- Process_One_Declaration --\n+               -----------------------------\n+\n+               procedure Process_One_Declaration is\n+                  Ptr : Source_Ptr;\n+\n+               begin\n+                  Ptr := P_Min;\n+\n+                  --  Scan type declaration, skipping blanks,\n+\n+                  while Ptr <= P_Max loop\n+                     if Buffer (Ptr) /= ' ' then\n+                        System.CRC32.Update (CRC, Buffer (Ptr));\n+                     end if;\n+\n+                     Ptr := Ptr + 1;\n+                  end loop;\n+               end Process_One_Declaration;\n+\n+            begin  --  Start of processing for Compute_Type_Key\n+\n+               if Is_Itype (T) then\n+                  return;\n+               end if;\n+\n+               Sloc_Range (Enclosing_Declaration (T), P_Min, P_Max);\n+               SFI        := Get_Source_File_Index (P_Min);\n+               Buffer     := Source_Text (SFI);\n+\n+               Process_One_Declaration;\n+\n+               --  Recurse on relevant component types.\n+\n+               if Is_Array_Type (T) then\n+                  Compute_Type_Key (Component_Type (T));\n+\n+               elsif Is_Access_Type (T) then\n+                  if not Deref then\n+                     Deref := True;\n+                     Compute_Type_Key (Designated_Type (T));\n+                  end if;\n \n-               Store_String_Chars (\"'Type_Key\");\n-               return End_String;\n-            end Type_Key;\n+               elsif Is_Derived_Type (T) then\n+                  Compute_Type_Key (Etype  (T));\n+\n+               elsif Is_Record_Type (T) then\n+                  declare\n+                     Comp : Entity_Id;\n+                  begin\n+                     Comp := First_Component (T);\n+                     while Present (Comp) loop\n+                        Compute_Type_Key (Etype (Comp));\n+\n+                        Next_Component (Comp);\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               --  Fold in representation aspects for the type, which\n+               --  appear in the same source buffer.\n+\n+               Rep := First_Rep_Item (T);\n+\n+               while Present (Rep) loop\n+                  if Comes_From_Source (Rep) then\n+                     Sloc_Range (Rep, P_Min, P_Max);\n+                     Process_One_Declaration;\n+                  end if;\n+\n+                  Rep := Next_Rep_Item (Rep);\n+               end loop;\n+            end Compute_Type_Key;\n \n          begin\n-            Rewrite (N, Make_String_Literal (Loc, Type_Key));\n+            Start_String;\n+            Deref := False;\n+\n+            --  Copy all characters in Full_Name but the trailing NUL\n+\n+            for J in 1 .. String_Length (Full_Name) - 1 loop\n+               Store_String_Char (Get_String_Char (Full_Name, Pos (J)));\n+            end loop;\n+\n+            --  For standard type return the name of the type. as there is\n+            --  no explicit source declaration to use. Otherwise compute\n+            --  CRC and convert it to string one character at a time. so as\n+            --  not to use Image within the compiler.\n+\n+            if Scope (Entity (P)) /= Standard_Standard then\n+               Initialize (CRC);\n+               Compute_Type_Key (Entity (P));\n+\n+               if not Is_Frozen (Entity (P)) then\n+                  Error_Msg_N (\"premature usage of Type_Key?\", N);\n+               end if;\n+\n+               while CRC > 0 loop\n+                  Store_String_Char (Character'Val (48 + (CRC rem 10)));\n+                  CRC := CRC / 10;\n+               end loop;\n+            end if;\n+\n+            Rewrite (N, Make_String_Literal (Loc, End_String));\n          end;\n \n          Analyze_And_Resolve (N, Standard_String);"}, {"sha": "7415b0c89d5716a1d6df0b49a8346118e8c119b4", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 103, "deletions": 69, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -114,10 +114,12 @@ package body Sem_Case is\n       Others_Present : Boolean;\n       Case_Node      : Node_Id)\n    is\n-      Predicate_Error : Boolean;\n+      Predicate_Error : Boolean := False;\n       --  Flag to prevent cascaded errors when a static predicate is known to\n       --  be violated by one choice.\n \n+      Num_Choices : constant Nat := Choice_Table'Last;\n+\n       procedure Check_Against_Predicate\n         (Pred    : in out Node_Id;\n          Choice  : Choice_Bounds;\n@@ -130,6 +132,10 @@ package body Sem_Case is\n       --  choice that covered a predicate set. Error denotes whether the check\n       --  found an illegal intersection.\n \n+      procedure Check_Duplicates;\n+      --  Check for duplicate choices, and call Dup_Choice is there are any\n+      --  such errors. Note that predicates are irrelevant here.\n+\n       procedure Dup_Choice (Lo, Hi : Uint; C : Node_Id);\n       --  Post message \"duplication of choice value(s) bla bla at xx\". Message\n       --  is posted at location C. Caller sets Error_Msg_Sloc for xx.\n@@ -236,8 +242,7 @@ package body Sem_Case is\n             Val : Uint) return Boolean\n          is\n          begin\n-            return\n-              Val = Lo or else Val = Hi or else (Lo < Val and then Val < Hi);\n+            return Lo <= Val and then Val <= Hi;\n          end Inside_Range;\n \n          --  Local variables\n@@ -276,14 +281,12 @@ package body Sem_Case is\n             return;\n          end if;\n \n-         --  Step 1: Detect duplicate choices\n-\n-         if Inside_Range (Choice_Lo, Choice_Hi, Prev_Lo) then\n-            Dup_Choice (Prev_Lo, UI_Min (Prev_Hi, Choice_Hi), LocN);\n-            Error := True;\n+         --  Step 1: Ignore duplicate choices, other than to set the flag,\n+         --  because these were already detected by Check_Duplicates.\n \n-         elsif Inside_Range (Choice_Lo, Choice_Hi, Prev_Hi) then\n-            Dup_Choice (UI_Max (Choice_Lo, Prev_Lo), Prev_Hi, LocN);\n+         if Inside_Range (Choice_Lo, Choice_Hi, Prev_Lo)\n+           or else  Inside_Range (Choice_Lo, Choice_Hi, Prev_Hi)\n+         then\n             Error := True;\n \n          --  Step 2: Detect full coverage\n@@ -447,6 +450,59 @@ package body Sem_Case is\n          end if;\n       end Check_Against_Predicate;\n \n+      ----------------------\n+      -- Check_Duplicates --\n+      ----------------------\n+\n+      procedure Check_Duplicates is\n+         Prev_Hi : Uint := Expr_Value (Choice_Table (1).Hi);\n+      begin\n+         for Outer_Index in 2 .. Num_Choices loop\n+            declare\n+               Choice_Lo : constant Uint :=\n+                 Expr_Value (Choice_Table (Outer_Index).Lo);\n+               Choice_Hi : constant Uint :=\n+                 Expr_Value (Choice_Table (Outer_Index).Hi);\n+            begin\n+               if Choice_Lo <= Prev_Hi then\n+                  --  Choices overlap; this is an error\n+\n+                  declare\n+                     Choice : constant Node_Id :=\n+                       Choice_Table (Outer_Index).Node;\n+                     Prev_Choice : Node_Id;\n+                  begin\n+                     --  Find first previous choice that overlaps\n+\n+                     for Inner_Index in 1 .. Outer_Index - 1 loop\n+                        if Choice_Lo <=\n+                             Expr_Value (Choice_Table (Inner_Index).Hi)\n+                        then\n+                           Prev_Choice := Choice_Table (Inner_Index).Node;\n+                           exit;\n+                        end if;\n+                     end loop;\n+\n+                     if Sloc (Prev_Choice) <= Sloc (Choice) then\n+                        Error_Msg_Sloc := Sloc (Prev_Choice);\n+                        Dup_Choice\n+                          (Choice_Lo, UI_Min (Choice_Hi, Prev_Hi), Choice);\n+                     else\n+                        Error_Msg_Sloc := Sloc (Choice);\n+                        Dup_Choice\n+                          (Choice_Lo, UI_Min (Choice_Hi, Prev_Hi),\n+                           Prev_Choice);\n+                     end if;\n+                  end;\n+               end if;\n+\n+               if Choice_Hi > Prev_Hi then\n+                  Prev_Hi := Choice_Hi;\n+               end if;\n+            end;\n+         end loop;\n+      end Check_Duplicates;\n+\n       ----------------\n       -- Dup_Choice --\n       ----------------\n@@ -709,17 +765,13 @@ package body Sem_Case is\n \n       Bounds_Hi     : constant Node_Id := Type_High_Bound (Bounds_Type);\n       Bounds_Lo     : constant Node_Id := Type_Low_Bound  (Bounds_Type);\n-      Num_Choices   : constant Nat     := Choice_Table'Last;\n       Has_Predicate : constant Boolean :=\n                         Is_OK_Static_Subtype (Bounds_Type)\n                           and then Has_Static_Predicate (Bounds_Type);\n \n-      Choice      : Node_Id;\n       Choice_Hi   : Uint;\n       Choice_Lo   : Uint;\n-      Error       : Boolean;\n       Pred        : Node_Id;\n-      Prev_Choice : Node_Id;\n       Prev_Lo     : Uint;\n       Prev_Hi     : Uint;\n \n@@ -735,8 +787,6 @@ package body Sem_Case is\n          return;\n       end if;\n \n-      Predicate_Error := False;\n-\n       --  Choice_Table must start at 0 which is an unused location used by the\n       --  sorting algorithm. However the first valid position for a discrete\n       --  choice is 1.\n@@ -756,16 +806,22 @@ package body Sem_Case is\n \n       Sorting.Sort (Positive (Choice_Table'Last));\n \n-      --  The type covered by the list of choices is actually a static subtype\n-      --  subject to a static predicate. The predicate defines subsets of legal\n-      --  values and requires finer grained analysis.\n+      --  First check for duplicates. This involved the choices; predicates, if\n+      --  any, are irrelevant.\n+\n+      Check_Duplicates;\n+\n+      --  Then check for overlaps\n+\n+      --  If the subtype has a static predicate, the predicate defines subsets\n+      --  of legal values and requires finer grained analysis.\n \n       --  Note that in GNAT the predicate is considered static if the predicate\n       --  expression is static, independently of whether the aspect mentions\n       --  Static explicitly.\n \n       if Has_Predicate then\n-         Pred    := First (Static_Discrete_Predicate (Bounds_Type));\n+         Pred := First (Static_Discrete_Predicate (Bounds_Type));\n \n          --  Make initial value smaller than 'First of type, so that first\n          --  range comparison succeeds. This applies both to integer types\n@@ -774,28 +830,30 @@ package body Sem_Case is\n          Prev_Lo := Expr_Value (Type_Low_Bound (Bounds_Type)) - 1;\n          Prev_Hi := Prev_Lo;\n \n-         Error   := False;\n-\n-         for Index in 1 .. Num_Choices loop\n-            Check_Against_Predicate\n-              (Pred    => Pred,\n-               Choice  => Choice_Table (Index),\n-               Prev_Lo => Prev_Lo,\n-               Prev_Hi => Prev_Hi,\n-               Error   => Error);\n-\n-            --  The analysis detected an illegal intersection between a choice\n-            --  and a static predicate set. Do not examine other choices unless\n-            --  all errors are requested.\n-\n-            if Error then\n-               Predicate_Error := True;\n-\n-               if not All_Errors_Mode then\n-                  return;\n+         declare\n+            Error : Boolean := False;\n+         begin\n+            for Index in 1 .. Num_Choices loop\n+               Check_Against_Predicate\n+                 (Pred    => Pred,\n+                  Choice  => Choice_Table (Index),\n+                  Prev_Lo => Prev_Lo,\n+                  Prev_Hi => Prev_Hi,\n+                  Error   => Error);\n+\n+               --  The analysis detected an illegal intersection between a\n+               --  choice and a static predicate set. Do not examine other\n+               --  choices unless all errors are requested.\n+\n+               if Error then\n+                  Predicate_Error := True;\n+\n+                  if not All_Errors_Mode then\n+                     return;\n+                  end if;\n                end if;\n-            end if;\n-         end loop;\n+            end loop;\n+         end;\n \n          if Predicate_Error then\n             return;\n@@ -826,35 +884,11 @@ package body Sem_Case is\n             end if;\n          end if;\n \n-         for Outer_Index in 2 .. Num_Choices loop\n-            Choice_Lo := Expr_Value (Choice_Table (Outer_Index).Lo);\n-            Choice_Hi := Expr_Value (Choice_Table (Outer_Index).Hi);\n-\n-            if Choice_Lo <= Prev_Hi then\n-               Choice := Choice_Table (Outer_Index).Node;\n-\n-               --  Find first previous choice that overlaps\n-\n-               for Inner_Index in 1 .. Outer_Index - 1 loop\n-                  if Choice_Lo <=\n-                       Expr_Value (Choice_Table (Inner_Index).Hi)\n-                  then\n-                     Prev_Choice := Choice_Table (Inner_Index).Node;\n-                     exit;\n-                  end if;\n-               end loop;\n-\n-               if Sloc (Prev_Choice) <= Sloc (Choice) then\n-                  Error_Msg_Sloc := Sloc (Prev_Choice);\n-                  Dup_Choice\n-                    (Choice_Lo, UI_Min (Choice_Hi, Prev_Hi), Choice);\n-               else\n-                  Error_Msg_Sloc := Sloc (Choice);\n-                  Dup_Choice\n-                    (Choice_Lo, UI_Min (Choice_Hi, Prev_Hi), Prev_Choice);\n-               end if;\n+         for Index in 2 .. Num_Choices loop\n+            Choice_Lo := Expr_Value (Choice_Table (Index).Lo);\n+            Choice_Hi := Expr_Value (Choice_Table (Index).Hi);\n \n-            elsif not Others_Present and then Choice_Lo /= Prev_Hi + 1 then\n+            if Choice_Lo > Prev_Hi + 1 and then not Others_Present then\n                Missing_Choice (Prev_Hi + 1, Choice_Lo - 1);\n             end if;\n "}, {"sha": "c43c575354ece76350d687119e939fdc9f1a0083", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a62ce88b6b105f923130d6c55f8a01b38a43a2/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=84a62ce88b6b105f923130d6c55f8a01b38a43a2", "patch": "@@ -401,8 +401,9 @@ package body Xref_Lib is\n      (File : ALI_File;\n       Num  : Positive) return File_Reference\n    is\n+      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n    begin\n-      return File.Dep.Table (Num);\n+      return Table (Num);\n    end File_Name;\n \n    --------------------\n@@ -642,10 +643,15 @@ package body Xref_Lib is\n                Token := Gnatchop_Name + 1;\n             end if;\n \n-            File.Dep.Table (Num_Dependencies) := Add_To_Xref_File\n-              (Ali (File_Start .. File_End),\n-               Gnatchop_File => Ali (Token .. Ptr - 1),\n-               Gnatchop_Offset => Gnatchop_Offset);\n+            declare\n+               Table : Table_Type renames\n+                 File.Dep.Table (1 .. Last (File.Dep));\n+            begin\n+               Table (Num_Dependencies) := Add_To_Xref_File\n+                 (Ali (File_Start .. File_End),\n+                  Gnatchop_File => Ali (Token .. Ptr - 1),\n+                  Gnatchop_Offset => Gnatchop_Offset);\n+            end;\n \n          elsif W_Lines and then Ali (Ptr) = 'W' then\n \n@@ -854,6 +860,8 @@ package body Xref_Lib is\n          Ptr := Ptr + 1;\n       end Skip_To_Matching_Closing_Bracket;\n \n+      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n+\n    --  Start of processing for Parse_Identifier_Info\n \n    begin\n@@ -976,9 +984,9 @@ package body Xref_Lib is\n                   --  We don't have a unit number specified, so we set P_Eun to\n                   --  the current unit.\n \n-                  for K in Dependencies_Tables.First .. Last (File.Dep) loop\n+                  for K in Table'Range loop\n                      P_Eun := K;\n-                     exit when File.Dep.Table (K) = File_Ref;\n+                     exit when Table (K) = File_Ref;\n                   end loop;\n                end if;\n \n@@ -1011,7 +1019,7 @@ package body Xref_Lib is\n                            Symbol,\n                            P_Line,\n                            P_Column,\n-                           File.Dep.Table (P_Eun));\n+                           Table (P_Eun));\n                      end if;\n                   end;\n                end if;\n@@ -1029,7 +1037,7 @@ package body Xref_Lib is\n                      Add_Entity\n                        (Pattern,\n                         Get_Symbol_Name (P_Eun, P_Line, P_Column)\n-                        & ':' & Get_Gnatchop_File (File.Dep.Table (P_Eun))\n+                        & ':' & Get_Gnatchop_File (Table (P_Eun))\n                         & ':' & Get_Line (Get_Parent (Decl_Ref))\n                         & ':' & Get_Column (Get_Parent (Decl_Ref)),\n                         False);\n@@ -1080,11 +1088,10 @@ package body Xref_Lib is\n \n       if Wide_Search then\n          declare\n-            File_Ref : File_Reference;\n-            pragma Unreferenced (File_Ref);\n             File_Name : constant String := Get_Gnatchop_File (File.X_File);\n+            Ignored : File_Reference;\n          begin\n-            File_Ref := Add_To_Xref_File (ALI_File_Name (File_Name), False);\n+            Ignored := Add_To_Xref_File (ALI_File_Name (File_Name), False);\n          end;\n       end if;\n \n@@ -1252,6 +1259,8 @@ package body Xref_Lib is\n       Ptr     : Positive renames File.Current_Line;\n       File_Nr : Natural;\n \n+      Table : Table_Type renames File.Dep.Table (1 .. Last (File.Dep));\n+\n    begin\n       while Ali (Ptr) = 'X' loop\n \n@@ -1267,8 +1276,8 @@ package body Xref_Lib is\n \n          --  If the referenced file is unknown, we simply ignore it\n \n-         if File_Nr in Dependencies_Tables.First .. Last (File.Dep) then\n-            File.X_File := File.Dep.Table (File_Nr);\n+         if File_Nr in Table'Range then\n+            File.X_File := Table (File_Nr);\n          else\n             File.X_File := Empty_File;\n          end if;"}]}