{"sha": "3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2ZjhmZTFiYzRjNjA4NTkxMTNiY2E3OTcwYjBiOGRiNTZlYjQ0Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-03T23:04:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-03T23:04:23Z"}, "message": "compiler: permit inlining references to global variables\n    \n    This requires tracking all references to unexported variables, so that\n    we can make them global symbols in the object file, and can export\n    them so that other compilations can see the right definition for their\n    own inline bodies.\n    \n    This introduces a syntax for referencing names defined in other\n    packages: a <pNN> prefix, where NN is the package index.  This will\n    need to be added to gccgoimporter, but I didn't do it yet since it\n    isn't yet possible to create an object for which gccgoimporter will\n    see a <pNN> prefix.\n    \n    This increases the number of inlinable functions in the standard\n    library from 181 to 215, adding functions like context.Background.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/177920\n\nFrom-SVN: r271891", "tree": {"sha": "1686da7767547bc1f870d738b861f924b8e50645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1686da7767547bc1f870d738b861f924b8e50645"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/comments", "author": null, "committer": null, "parents": [{"sha": "a920eb0cb08da30f4d7d4345f42067fdf8ce7b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a920eb0cb08da30f4d7d4345f42067fdf8ce7b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a920eb0cb08da30f4d7d4345f42067fdf8ce7b9b"}], "stats": {"total": 569, "additions": 482, "deletions": 87}, "files": [{"sha": "43df2f7a5de3900dc1888ba38d16a5e1e907f899", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -1,4 +1,4 @@\n-95784e8eec75cfeb2363fb22b51085380e564af9\n+37a47e4691b4602dd167f82c64a6569019584a80\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "108fdac22e57b3c8d2540f2c6ebe355189240900", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 149, "deletions": 14, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -11,6 +11,7 @@\n \n #include \"gogo.h\"\n #include \"types.h\"\n+#include \"expressions.h\"\n #include \"statements.h\"\n #include \"export.h\"\n \n@@ -89,13 +90,88 @@ typedef Unordered_map_hash(const Type*, int, Type_hash_alias_identical,\n \n static Type_refs type_refs;\n \n+// A traversal class to collect functions and global variables\n+// referenced by inlined functions.\n+\n+class Collect_references_from_inline : public Traverse\n+{\n+ public:\n+  Collect_references_from_inline(Unordered_set(Named_object*)* exports,\n+\t\t\t\t std::vector<Named_object*>* check_inline_refs)\n+    : Traverse(traverse_expressions),\n+      exports_(exports), check_inline_refs_(check_inline_refs)\n+  { }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The set of named objects to export.\n+  Unordered_set(Named_object*)* exports_;\n+  // Functions we are exporting with inline bodies that need to be checked.\n+  std::vector<Named_object*>* check_inline_refs_;\n+};\n+\n+int\n+Collect_references_from_inline::expression(Expression** pexpr)\n+{\n+  const Expression* expr = *pexpr;\n+\n+  const Var_expression* ve = expr->var_expression();\n+  if (ve != NULL)\n+    {\n+      Named_object* no = ve->named_object();\n+      if (no->is_variable() && no->var_value()->is_global())\n+\t{\n+\t  this->exports_->insert(no);\n+\t  no->var_value()->set_is_referenced_by_inline();\n+\t}\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  const Func_expression* fe = expr->func_expression();\n+  if (fe != NULL)\n+    {\n+      Named_object* no = fe->named_object();\n+      std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n+\tthis->exports_->insert(no);\n+\n+      if (no->is_function())\n+\tno->func_value()->set_is_referenced_by_inline();\n+\n+      // If ins.second is false then this object was already in\n+      // exports_, in which case it was already added to\n+      // check_inline_refs_ the first time we added it to exports_, so\n+      // we don't need to add it again.\n+      if (ins.second\n+\t  && no->is_function()\n+\t  && no->func_value()->export_for_inlining())\n+\tthis->check_inline_refs_->push_back(no);\n+\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // A functor to sort Named_object pointers by name.\n \n struct Sort_bindings\n {\n   bool\n   operator()(const Named_object* n1, const Named_object* n2) const\n-  { return n1->name() < n2->name(); }\n+  {\n+    if (n1->package() != n2->package())\n+      {\n+\tif (n1->package() == NULL)\n+\t  return true;\n+\tif (n2->package() == NULL)\n+\t  return false;\n+\treturn n1->package()->pkgpath() < n2->package()->pkgpath();\n+      }\n+\n+    return n1->name() < n2->name();\n+  }\n };\n \n // Return true if we should export NO.\n@@ -153,17 +229,26 @@ Export::export_globals(const std::string& package_name,\n   if (saw_errors())\n     return;\n \n-  // Export the symbols in sorted order.  That will reduce cases where\n-  // irrelevant changes to the source code affect the exported\n-  // interface.\n-  std::vector<Named_object*> exports;\n-  exports.reserve(bindings->size_definitions());\n+  // EXPORTS is the set of objects to export.  CHECK_INLINE_REFS is a\n+  // list of exported function with inline bodies that need to be\n+  // checked for references to other objects.  Every function on\n+  // CHECK_INLINE_REFS is also on EXPORTS.\n+  Unordered_set(Named_object*) exports;\n+  std::vector<Named_object*> check_inline_refs;\n \n   for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n        p != bindings->end_definitions();\n        ++p)\n-    if (should_export(*p))\n-      exports.push_back(*p);\n+    {\n+      if (should_export(*p))\n+\t{\n+\t  exports.insert(*p);\n+\n+\t  if ((*p)->is_function()\n+\t      && (*p)->func_value()->export_for_inlining())\n+\t    check_inline_refs.push_back(*p);\n+\t}\n+    }\n \n   for (Bindings::const_declarations_iterator p =\n \t bindings->begin_declarations();\n@@ -174,15 +259,47 @@ Export::export_globals(const std::string& package_name,\n       // supporting C code.  We do not export type declarations.\n       if (p->second->is_function_declaration()\n \t  && should_export(p->second))\n-\texports.push_back(p->second);\n+\texports.insert(p->second);\n+    }\n+\n+  // Look through the bodies of the functions in CHECK_INLINE_REFS to\n+  // find other names we may need to export, to satisfy those\n+  // references.  Use CHECKED to skip checking function bodies more\n+  // than once.\n+  Unordered_set(Named_object*) checked;\n+  Collect_references_from_inline refs(&exports, &check_inline_refs);\n+  while (!check_inline_refs.empty())\n+    {\n+      Named_object* no = check_inline_refs.back();\n+      check_inline_refs.pop_back();\n+      std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n+\tchecked.insert(no);\n+      if (ins.second)\n+\t{\n+\t  // This traversal may add new objects to EXPORTS and new\n+\t  // functions to CHECK_INLINE_REFS.\n+\t  no->func_value()->block()->traverse(&refs);\n+\t}\n     }\n \n-  std::sort(exports.begin(), exports.end(), Sort_bindings());\n+  // Export the symbols in sorted order.  That will reduce cases where\n+  // irrelevant changes to the source code affect the exported\n+  // interface.\n+  std::vector<Named_object*> sorted_exports;\n+  sorted_exports.reserve(exports.size());\n+\n+  for (Unordered_set(Named_object*)::const_iterator p = exports.begin();\n+       p != exports.end();\n+       ++p)\n+    sorted_exports.push_back(*p);\n+\n+  std::sort(sorted_exports.begin(), sorted_exports.end(), Sort_bindings());\n \n   // Assign indexes to all exported types and types referenced by\n   // exported types, and collect all packages mentioned.\n   Unordered_set(const Package*) type_imports;\n-  int unexported_type_index = this->prepare_types(&exports, &type_imports);\n+  int unexported_type_index = this->prepare_types(&sorted_exports,\n+\t\t\t\t\t\t  &type_imports);\n \n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n@@ -223,8 +340,8 @@ Export::export_globals(const std::string& package_name,\n   this->write_types(unexported_type_index);\n \n   // Write out the non-type export data.\n-  for (std::vector<Named_object*>::const_iterator p = exports.begin();\n-       p != exports.end();\n+  for (std::vector<Named_object*>::const_iterator p = sorted_exports.begin();\n+       p != sorted_exports.end();\n        ++p)\n     {\n       if (!(*p)->is_type())\n@@ -591,6 +708,7 @@ Export::write_imports(const std::map<std::string, Package*>& imports,\n \n   std::sort(sorted_imports.begin(), sorted_imports.end(), import_compare);\n \n+  int package_index = 1;\n   for (std::vector<std::pair<std::string, Package*> >::const_iterator p =\n \t sorted_imports.begin();\n        p != sorted_imports.end();\n@@ -604,7 +722,8 @@ Export::write_imports(const std::map<std::string, Package*>& imports,\n       this->write_string(p->first);\n       this->write_c_string(\"\\\"\\n\");\n \n-      this->packages_.insert(p->second);\n+      this->packages_[p->second] = package_index;\n+      package_index++;\n     }\n \n   // Write out a separate list of indirectly imported packages.\n@@ -631,6 +750,9 @@ Export::write_imports(const std::map<std::string, Package*>& imports,\n       this->write_c_string(\" \");\n       this->write_string((*p)->pkgpath());\n       this->write_c_string(\"\\n\");\n+\n+      this->packages_[*p] = package_index;\n+      package_index++;\n     }\n }\n \n@@ -983,6 +1105,19 @@ Export::write_unsigned(unsigned value)\n   this->write_c_string(buf);\n }\n \n+// Return the index of a package.\n+\n+int\n+Export::package_index(const Package* pkg) const\n+{\n+  Unordered_map(const Package *, int)::const_iterator p =\n+    this->packages_.find(pkg);\n+  go_assert(p != this->packages_.end());\n+  int index = p->second;\n+  go_assert(index != 0);\n+  return index;\n+}\n+\n // Return the index of a type.\n \n int"}, {"sha": "e3932d48130136ee3b0b5805b0e0fe6396050fec", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -201,6 +201,10 @@ class Export : public String_dump\n   void\n   write_unsigned(unsigned);\n \n+  // Return the index of a package.\n+  int\n+  package_index(const Package* p) const;\n+\n  private:\n   Export(const Export&);\n   Export& operator=(const Export&);\n@@ -255,7 +259,7 @@ class Export : public String_dump\n   // Index number of next type.\n   int type_index_;\n   // Packages we have written out.\n-  Unordered_set(const Package*) packages_;\n+  Unordered_map(const Package*, int) packages_;\n };\n \n // An export streamer that puts the export stream in a named section.\n@@ -354,6 +358,11 @@ class Export_function_body : public String_dump\n   decrement_indent()\n   { --this->indent_; }\n \n+  // Return the index of a package.\n+  int\n+  package_index(const Package* p) const\n+  { return this->exp_->package_index(p); }\n+\n   // Return a reference to the completed body.\n   const std::string&\n   body() const"}, {"sha": "6aca5f86ec773df49f88834055e19d6bcb23d915", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -87,6 +87,27 @@ Expression::do_export(Export_function_body*) const\n   go_unreachable();\n }\n \n+// Write a name to the export data.\n+\n+void\n+Expression::export_name(Export_function_body* efb, const Named_object* no)\n+{\n+  if (no->package() != NULL)\n+    {\n+      char buf[50];\n+      snprintf(buf, sizeof buf, \"<p%d>\", efb->package_index(no->package()));\n+      efb->write_c_string(buf);\n+    }\n+\n+  if (!Gogo::is_hidden_name(no->name()))\n+    efb->write_string(no->name());\n+  else\n+    {\n+      efb->write_c_string(\".\");\n+      efb->write_string(Gogo::unpack_hidden_name(no->name()));\n+    }\n+}\n+\n // Give an error saying that the value of the expression is not used.\n \n void\n@@ -842,29 +863,16 @@ Var_expression::do_address_taken(bool escapes)\n     }\n }\n \n-// The cost to inline a variable reference.  We currently only support\n-// references to parameters and local variables.\n-\n-int\n-Var_expression::do_inlining_cost() const\n-{\n-  if (this->variable_->is_variable())\n-    {\n-      if (!this->variable_->var_value()->is_global())\n-\treturn 1;\n-    }\n-  else if (this->variable_->is_result_variable())\n-    return 1;\n-\n-  return 0x100000;\n-}\n-\n // Export a reference to a variable.\n \n void\n Var_expression::do_export(Export_function_body* efb) const\n {\n-  efb->write_string(Gogo::unpack_hidden_name(this->variable_->name()));\n+  Named_object* no = this->variable_;\n+  if (no->is_result_variable() || !no->var_value()->is_global())\n+    efb->write_string(Gogo::unpack_hidden_name(no->name()));\n+  else\n+    Expression::export_name(efb, no);\n }\n \n // Get the backend representation for a reference to a variable.\n@@ -17535,26 +17543,55 @@ Expression::import_expression(Import_expression* imp, Location loc)\n     }\n   if (ifb->saw_error())\n     return Expression::make_error(loc);\n-  std::string id = ifb->read_identifier();\n-  if (id.empty())\n+  return Expression::import_identifier(ifb, loc);\n+}\n+\n+// Import an identifier in an expression.  This is a reference to a\n+// variable or function.\n+\n+Expression*\n+Expression::import_identifier(Import_function_body* ifb, Location loc)\n+{\n+  std::string id;\n+  Package* pkg;\n+  bool is_exported;\n+  if (!Import::read_qualified_identifier(ifb, &id, &pkg, &is_exported))\n     {\n       if (!ifb->saw_error())\n-\tgo_error_at(imp->location(),\n-\t\t    \"import error: expected identifier at %lu\",\n+\tgo_error_at(ifb->location(),\n+\t\t    \"import error for %qs: bad qualified identifier at %lu\",\n+\t\t    ifb->name().c_str(),\n \t\t    static_cast<unsigned long>(ifb->off()));\n       ifb->set_saw_error();\n       return Expression::make_error(loc);\n     }\n-  Named_object* var = ifb->block()->bindings()->lookup(id);\n-  if (var == NULL)\n+\n+  Named_object* no = NULL;\n+  if (pkg == NULL && is_exported)\n+    no = ifb->block()->bindings()->lookup(id);\n+  if (no == NULL)\n+    {\n+      const Package* ipkg = pkg;\n+      if (ipkg == NULL)\n+\tipkg = ifb->function()->package();\n+      if (!is_exported)\n+\tid = '.' + ipkg->pkgpath() + '.' + id;\n+      no = ipkg->bindings()->lookup(id);\n+    }\n+  if (no == NULL)\n+    no = ifb->gogo()->lookup_global(id.c_str());\n+\n+  if (no == NULL)\n     {\n       if (!ifb->saw_error())\n-\tgo_error_at(imp->location(), \"import error: lookup of %qs failed\",\n-\t\t    id.c_str());\n+\tgo_error_at(ifb->location(),\n+\t\t    \"import error for %qs: lookup of %qs failed\",\n+\t\t    ifb->name().c_str(), id.c_str());\n       ifb->set_saw_error();\n       return Expression::make_error(loc);\n     }\n-  return Expression::make_var_reference(var, loc);\n+\n+  return Expression::make_var_reference(no, loc);\n }\n \n // Class Expression_list."}, {"sha": "e17e8dc0c7f5723113cd0a71fa1b491dc94cebd6", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -1201,6 +1201,10 @@ class Expression\n   void\n   report_error(const char*);\n \n+  // Write a name to export data.\n+  static void\n+  export_name(Export_function_body* efb, const Named_object*);\n+\n   // Child class implements dumping to a dump context.\n   virtual void\n   do_dump_expression(Ast_dump_context*) const = 0;\n@@ -1246,6 +1250,9 @@ class Expression\n   static Expression*\n   convert_interface_to_type(Type*, Expression*, Location);\n \n+  static Expression*\n+  import_identifier(Import_function_body*, Location);\n+\n   // The expression classification.\n   Expression_classification classification_;\n   // The location in the input file.\n@@ -1410,7 +1417,8 @@ class Var_expression : public Expression\n   { return this; }\n \n   int\n-  do_inlining_cost() const;\n+  do_inlining_cost() const\n+  { return 1; }\n \n   void\n   do_export(Export_function_body*) const;"}, {"sha": "b97367ca066de25189e6c8862dda480c1d1450a2", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -5182,7 +5182,7 @@ Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n     calls_recover_(false), is_recover_thunk_(false), has_recover_thunk_(false),\n     calls_defer_retaddr_(false), is_type_specific_function_(false),\n     in_unique_section_(false), export_for_inlining_(false),\n-    is_inline_only_(false)\n+    is_inline_only_(false), is_referenced_by_inline_(false)\n {\n }\n \n@@ -5534,20 +5534,20 @@ Function::defer_stack(Location location)\n // Export the function.\n \n void\n-Function::export_func(Export* exp, const std::string& name) const\n+Function::export_func(Export* exp, const Named_object* no) const\n {\n   Block* block = NULL;\n   if (this->export_for_inlining())\n     block = this->block_;\n-  Function::export_func_with_type(exp, name, this->type_, this->results_,\n+  Function::export_func_with_type(exp, no, this->type_, this->results_,\n \t\t\t\t  this->is_method() && this->nointerface(),\n \t\t\t\t  block, this->location_);\n }\n \n // Export a function with a type.\n \n void\n-Function::export_func_with_type(Export* exp, const std::string& name,\n+Function::export_func_with_type(Export* exp, const Named_object* no,\n \t\t\t\tconst Function_type* fntype,\n \t\t\t\tFunction::Results* result_vars,\n \t\t\t\tbool nointerface, Block* block, Location loc)\n@@ -5571,7 +5571,21 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n       exp->write_c_string(\") \");\n     }\n \n-  exp->write_string(name);\n+  if (no->package() != NULL && !fntype->is_method())\n+    {\n+      char buf[50];\n+      snprintf(buf, sizeof buf, \"<p%d>\", exp->package_index(no->package()));\n+      exp->write_c_string(buf);\n+    }\n+\n+  const std::string& name(no->name());\n+  if (!Gogo::is_hidden_name(name))\n+    exp->write_string(name);\n+  else\n+    {\n+      exp->write_c_string(\".\");\n+      exp->write_string(Gogo::unpack_hidden_name(name));\n+    }\n \n   exp->write_c_string(\" (\");\n   const Typed_identifier_list* parameters = fntype->parameters();\n@@ -5677,8 +5691,9 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n \n // Import a function.\n \n-void\n+bool\n Function::import_func(Import* imp, std::string* pname,\n+\t\t      Package** ppkg, bool* pis_exported,\n \t\t      Typed_identifier** preceiver,\n \t\t      Typed_identifier_list** pparameters,\n \t\t      Typed_identifier_list** presults,\n@@ -5711,7 +5726,13 @@ Function::import_func(Import* imp, std::string* pname,\n       imp->require_c_string(\") \");\n     }\n \n-  *pname = imp->read_identifier();\n+  if (!Import::read_qualified_identifier(imp, pname, ppkg, pis_exported))\n+    {\n+      go_error_at(imp->location(),\n+\t\t  \"import error at %d: bad function name in export data\",\n+\t\t  imp->pos());\n+      return false;\n+    }\n \n   Typed_identifier_list* parameters;\n   *is_varargs = false;\n@@ -5812,11 +5833,13 @@ Function::import_func(Import* imp, std::string* pname,\n \t{\n \t  go_error_at(imp->location(), \"invalid inline function length %s\",\n \t\t      lenstr.c_str());\n-\t  return;\n+\t  return false;\n \t}\n \n       *body = imp->read(static_cast<size_t>(llen));\n     }\n+\n+  return true;\n }\n \n // Get the backend representation.\n@@ -5829,7 +5852,10 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n       unsigned int flags = 0;\n       bool is_init_fn = false;\n       if (no->package() != NULL)\n-        ;\n+\t{\n+\t  // Functions defined in other packages must be visible.\n+\t  flags |= Backend::function_is_visible;\n+\t}\n       else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n         ;\n       else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n@@ -5877,6 +5903,11 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n       else\n \tasm_name = gogo->function_asm_name(no->name(), no->package(), rtype);\n \n+      // If an inline body refers to this function, then it\n+      // needs to be visible in the symbol table.\n+      if (this->is_referenced_by_inline_)\n+\tflags |= Backend::function_is_visible;\n+\n       // If a function calls the predeclared recover function, we\n       // can't inline it, because recover behaves differently in a\n       // function passed directly to defer.  If this is a recover\n@@ -7015,7 +7046,8 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n     type_from_init_tuple_(false), type_from_range_index_(false),\n     type_from_range_value_(false), type_from_chan_element_(false),\n     is_type_switch_var_(false), determined_type_(false),\n-    in_unique_section_(false), toplevel_decl_(NULL)\n+    in_unique_section_(false), is_referenced_by_inline_(false),\n+    toplevel_decl_(NULL)\n {\n   go_assert(type != NULL || init != NULL);\n   go_assert(!is_parameter || init == NULL);\n@@ -7497,27 +7529,49 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n // Export the variable\n \n void\n-Variable::export_var(Export* exp, const std::string& name) const\n+Variable::export_var(Export* exp, const Named_object* no) const\n {\n   go_assert(this->is_global_);\n   exp->write_c_string(\"var \");\n-  exp->write_string(name);\n+  if (no->package() != NULL)\n+    {\n+      char buf[50];\n+      snprintf(buf, sizeof buf, \"<p%d>\", exp->package_index(no->package()));\n+      exp->write_c_string(buf);\n+    }\n+\n+  if (!Gogo::is_hidden_name(no->name()))\n+    exp->write_string(no->name());\n+  else\n+    {\n+      exp->write_c_string(\".\");\n+      exp->write_string(Gogo::unpack_hidden_name(no->name()));\n+    }\n+\n   exp->write_c_string(\" \");\n   exp->write_type(this->type());\n   exp->write_c_string(\"\\n\");\n }\n \n // Import a variable.\n \n-void\n-Variable::import_var(Import* imp, std::string* pname, Type** ptype)\n+bool\n+Variable::import_var(Import* imp, std::string* pname, Package** ppkg,\n+\t\t     bool* pis_exported, Type** ptype)\n {\n   imp->require_c_string(\"var \");\n-  *pname = imp->read_identifier();\n+  if (!Import::read_qualified_identifier(imp, pname, ppkg, pis_exported))\n+    {\n+      go_error_at(imp->location(),\n+\t\t  \"import error at %d: bad variable name in export data\",\n+\t\t  imp->pos());\n+      return false;\n+    }\n   imp->require_c_string(\" \");\n   *ptype = imp->read_type();\n   imp->require_semicolon_if_old_version();\n   imp->require_c_string(\"\\n\");\n+  return true;\n }\n \n // Convert a variable to the backend representation.\n@@ -7568,6 +7622,18 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t\t  && var_name == \"runtime.writeBarrier\")\n \t\tis_hidden = false;\n \n+\t      // If an inline body refers to this variable, then it\n+\t      // needs to be visible in the symbol table.\n+\t      if (this->is_referenced_by_inline_)\n+\t\tis_hidden = false;\n+\n+\t      // If this variable is in a different package, then it\n+\t      // can't be treated as a hidden symbol.  This case can\n+\t      // arise when an inlined function refers to a\n+\t      // package-scope unexported variable.\n+\t      if (package != NULL)\n+\t\tis_hidden = false;\n+\n \t      bvar = backend->global_variable(var_name,\n \t\t\t\t\t      asm_name,\n \t\t\t\t\t      btype,\n@@ -8145,19 +8211,19 @@ Named_object::export_named_object(Export* exp) const\n       break;\n \n     case NAMED_OBJECT_FUNC_DECLARATION:\n-      this->func_declaration_value()->export_func(exp, this->name_);\n+      this->func_declaration_value()->export_func(exp, this);\n       break;\n \n     case NAMED_OBJECT_VAR:\n-      this->var_value()->export_var(exp, this->name_);\n+      this->var_value()->export_var(exp, this);\n       break;\n \n     case NAMED_OBJECT_RESULT_VAR:\n     case NAMED_OBJECT_SINK:\n       go_unreachable();\n \n     case NAMED_OBJECT_FUNC:\n-      this->func_value()->export_func(exp, this->name_);\n+      this->func_value()->export_func(exp, this);\n       break;\n     }\n }"}, {"sha": "5b77d6d9327ef92e76cc11b8a83ba00b7181e632", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -1486,6 +1486,11 @@ class Function\n   set_is_inline_only()\n   { this->is_inline_only_ = true; }\n \n+  // Mark the function as referenced by an inline body.\n+  void\n+  set_is_referenced_by_inline()\n+  { this->is_referenced_by_inline_ = true; }\n+\n   // Swap with another function.  Used only for the thunk which calls\n   // recover.\n   void\n@@ -1538,17 +1543,18 @@ class Function\n \n   // Export the function.\n   void\n-  export_func(Export*, const std::string& name) const;\n+  export_func(Export*, const Named_object*) const;\n \n   // Export a function with a type.\n   static void\n-  export_func_with_type(Export*, const std::string& name,\n+  export_func_with_type(Export*, const Named_object*,\n \t\t\tconst Function_type*, Results*, bool nointerface,\n \t\t\tBlock* block, Location);\n \n-  // Import a function.\n-  static void\n-  import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+  // Import a function.  Reports whether the import succeeded.\n+  static bool\n+  import_func(Import*, std::string* pname, Package** pkg,\n+\t      bool* is_exported, Typed_identifier** receiver,\n \t      Typed_identifier_list** pparameters,\n \t      Typed_identifier_list** presults, bool* is_varargs,\n \t      bool* nointerface, std::string* body);\n@@ -1628,6 +1634,9 @@ class Function\n   // True if this function is inline only: if it should not be emitted\n   // if it is not inlined.\n   bool is_inline_only_ : 1;\n+  // True if this function is referenced from an inlined body that\n+  // will be put into the export data.\n+  bool is_referenced_by_inline_ : 1;\n };\n \n // A snapshot of the current binding state.\n@@ -1768,9 +1777,9 @@ class Function_declaration\n \n   // Export a function declaration.\n   void\n-  export_func(Export* exp, const std::string& name) const\n+  export_func(Export* exp, const Named_object* no) const\n   {\n-    Function::export_func_with_type(exp, name, this->fntype_, NULL,\n+    Function::export_func_with_type(exp, no, this->fntype_, NULL,\n \t\t\t\t    this->is_method() && this->nointerface(),\n \t\t\t\t    NULL, this->location_);\n   }\n@@ -2022,6 +2031,14 @@ class Variable\n     this->in_unique_section_ = true;\n   }\n \n+  // Mark the variable as referenced by an inline body.\n+  void\n+  set_is_referenced_by_inline()\n+  {\n+    go_assert(this->is_global_);\n+    this->is_referenced_by_inline_ = true;\n+  }\n+\n   // Return the top-level declaration for this variable.\n   Statement*\n   toplevel_decl()\n@@ -2062,11 +2079,12 @@ class Variable\n \n   // Export the variable.\n   void\n-  export_var(Export*, const std::string& name) const;\n+  export_var(Export*, const Named_object*) const;\n \n-  // Import a variable.\n-  static void\n-  import_var(Import*, std::string* pname, Type** ptype);\n+  // Import a variable.  Reports whether the import succeeded.\n+  static bool\n+  import_var(Import*, std::string* pname, Package** pkg, bool* is_exported,\n+\t     Type** ptype);\n \n  private:\n   // The type of a tuple.\n@@ -2133,6 +2151,9 @@ class Variable\n   // True if this variable should be put in a unique section.  This is\n   // used for field tracking.\n   bool in_unique_section_ : 1;\n+  // True if this variable is referenced from an inlined body that\n+  // will be put into the export data.\n+  bool is_referenced_by_inline_ : 1;\n   // The top-level declaration for this variable. Only used for local\n   // variables. Must be a Temporary_statement if not NULL.\n   Statement* toplevel_decl_;"}, {"sha": "ff92b8248d6c02bbf1909094bcb81ea8dc0a34ce", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 84, "deletions": 13, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -288,8 +288,8 @@ Import::find_object_export_data(const std::string& filename,\n \n Import::Import(Stream* stream, Location location)\n   : gogo_(NULL), stream_(stream), location_(location), package_(NULL),\n-    add_to_globals_(false), type_data_(), type_pos_(0), type_offsets_(),\n-    builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n+    add_to_globals_(false), packages_(), type_data_(), type_pos_(0),\n+    type_offsets_(), builtin_types_((- SMALLEST_BUILTIN_CODE) + 1),\n     types_(), version_(EXPORT_FORMAT_UNKNOWN)\n {\n }\n@@ -487,6 +487,8 @@ Import::read_one_import()\n   Package* p = this->gogo_->register_package(pkgpath, \"\",\n \t\t\t\t\t     Linemap::unknown_location());\n   p->set_package_name(package_name, this->location());\n+\n+  this->packages_.push_back(p);\n }\n \n // Read an indirectimport line.\n@@ -503,6 +505,8 @@ Import::read_one_indirect_import()\n   Package* p = this->gogo_->register_package(pkgpath, \"\",\n \t\t\t\t\t     Linemap::unknown_location());\n   p->set_package_name(package_name, this->location());\n+\n+  this->packages_.push_back(p);\n }\n \n // Read the list of import control functions and/or init graph.\n@@ -721,12 +725,19 @@ void\n Import::import_var()\n {\n   std::string name;\n+  Package* vpkg;\n+  bool is_exported;\n   Type* type;\n-  Variable::import_var(this, &name, &type);\n+  if (!Variable::import_var(this, &name, &vpkg, &is_exported, &type))\n+    return;\n+  if (vpkg == NULL)\n+    vpkg = this->package_;\n+  if (!is_exported)\n+    name = '.' + vpkg->pkgpath() + '.' + name;\n   Variable* var = new Variable(type, NULL, true, false, false,\n \t\t\t       this->location_);\n   Named_object* no;\n-  no = this->package_->add_variable(name, var);\n+  no = vpkg->add_variable(name, var);\n   if (this->add_to_globals_)\n     this->gogo_->add_dot_import_object(no);\n }\n@@ -735,18 +746,26 @@ Import::import_var()\n // THIS->PACKAGE_, but it will be different for a method associated\n // with a type defined in a different package.\n \n-Named_object*\n+void\n Import::import_func(Package* package)\n {\n   std::string name;\n+  Package* fpkg;\n+  bool is_exported;\n   Typed_identifier* receiver;\n   Typed_identifier_list* parameters;\n   Typed_identifier_list* results;\n   bool is_varargs;\n   bool nointerface;\n   std::string body;\n-  Function::import_func(this, &name, &receiver, &parameters, &results,\n-\t\t\t&is_varargs, &nointerface, &body);\n+  if (!Function::import_func(this, &name, &fpkg, &is_exported, &receiver,\n+\t\t\t     &parameters, &results, &is_varargs, &nointerface,\n+\t\t\t     &body))\n+    return;\n+  if (fpkg == NULL)\n+    fpkg = package;\n+  if (!is_exported)\n+    name = '.' + fpkg->pkgpath() + '.' + name;\n   Function_type *fntype = Type::make_function_type(receiver, parameters,\n \t\t\t\t\t\t   results, this->location_);\n   if (is_varargs)\n@@ -768,21 +787,21 @@ Import::import_func(Package* package)\n \trtype = rtype->points_to();\n \n       if (rtype->is_error_type())\n-\treturn NULL;\n+\treturn;\n       else if (rtype->named_type() != NULL)\n-\tno = rtype->named_type()->add_method_declaration(name, package, fntype,\n+\tno = rtype->named_type()->add_method_declaration(name, fpkg, fntype,\n \t\t\t\t\t\t\t loc);\n       else if (rtype->forward_declaration_type() != NULL)\n \tno = rtype->forward_declaration_type()->add_method_declaration(name,\n-\t\t\t\t\t\t\t\t       package,\n+\t\t\t\t\t\t\t\t       fpkg,\n \t\t\t\t\t\t\t\t       fntype,\n \t\t\t\t\t\t\t\t       loc);\n       else\n \tgo_unreachable();\n     }\n   else\n     {\n-      no = package->add_function_declaration(name, fntype, loc);\n+      no = fpkg->add_function_declaration(name, fntype, loc);\n       if (this->add_to_globals_)\n \tthis->gogo_->add_dot_import_object(no);\n     }\n@@ -791,8 +810,6 @@ Import::import_func(Package* package)\n     no->func_declaration_value()->set_nointerface();\n   if (!body.empty() && !no->func_declaration_value()->has_imported_body())\n     no->func_declaration_value()->set_imported_body(this, body);\n-\n-  return no;\n }\n \n // Read a type definition and initialize the entry in this->types_.\n@@ -1233,6 +1250,60 @@ Import::read_identifier()\n   return ret;\n }\n \n+// Read a possibly qualified identifier from IMP.  The qualification\n+// is <pID>, where ID is a package number.  If the name has a leading\n+// '.', it is not exported; otherwise, it is.  Set *NAME, *PKG and\n+// *IS_EXPORTED.  Reports whether the read succeeded.\n+\n+bool\n+Import::read_qualified_identifier(Import_expression* imp, std::string* name,\n+\t\t\t\t  Package** pkg, bool* is_exported)\n+{\n+  *pkg = NULL;\n+  if (imp->match_c_string(\"<p\"))\n+    {\n+      imp->advance(2);\n+      char buf[50];\n+      char *pbuf = &buf[0];\n+      while (true)\n+\t{\n+\t  int next = imp->peek_char();\n+\t  if (next == -1 || static_cast<size_t>(pbuf - buf) >= sizeof buf - 1)\n+\t    return false;\n+\t  if (next == '>')\n+\t    {\n+\t      imp->advance(1);\n+\t      break;\n+\t    }\n+\t  *pbuf = static_cast<char>(next);\n+\t  ++pbuf;\n+\t  imp->advance(1);\n+\t}\n+\n+      *pbuf = '\\0';\n+      char *end;\n+      long index = strtol(buf, &end, 10);\n+      if (*end != '\\0'\n+\t  || index <= 0\n+\t  || static_cast<size_t>(index) > imp->max_package_index())\n+\treturn false;\n+\n+      *pkg = imp->package_at_index(index);\n+      go_assert(*pkg != NULL);\n+    }\n+\n+  *is_exported = true;\n+  if (imp->match_c_string(\".\"))\n+    {\n+      imp->advance(1);\n+      *is_exported = false;\n+    }\n+\n+  *name = imp->read_identifier();\n+\n+  return !name->empty();\n+}\n+\n // Read a name from the stream.\n \n std::string"}, {"sha": "ab30aed0ae5ea51ac5ee5bd4787304e6c09a583d", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6f8fe1bc4c60859113bca7970b0b8db56eb442/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=3e6f8fe1bc4c60859113bca7970b0b8db56eb442", "patch": "@@ -72,6 +72,14 @@ class Import_expression\n   virtual Type*\n   read_type() = 0;\n \n+  // Return the maximum valid package index.\n+  virtual size_t\n+  max_package_index() const = 0;\n+\n+  // Return the package for a package index.\n+  virtual Package*\n+  package_at_index(int index) = 0;\n+\n   // Return the version number of the export data we're reading.\n   virtual Export_data_version\n   version() const = 0;\n@@ -257,6 +265,11 @@ class Import : public Import_expression\n   advance(size_t skip)\n   { this->stream_->advance(skip); }\n \n+  // Stream position, for error reporting.\n+  int\n+  pos()\n+  { return this->stream_->pos(); }\n+\n   // Return the version number of the export data we're reading.\n   Export_data_version\n   version() const { return this->version_; }\n@@ -279,6 +292,18 @@ class Import : public Import_expression\n   std::string\n   read_name();\n \n+  // Return the maximum valid package index.  This is the size of\n+  // packages_ because we will subtract 1 in package_at_index.\n+  size_t\n+  max_package_index() const\n+  { return this->packages_.size(); }\n+\n+  // Return the package at an index.  (We subtract 1 because package\n+  // index 0 is not used.)\n+  Package*\n+  package_at_index(int index)\n+  { return this->packages_.at(index - 1); }\n+\n   // Read a type.\n   Type*\n   read_type();\n@@ -304,6 +329,12 @@ class Import : public Import_expression\n   ifb()\n   { return NULL; }\n \n+  // Read a qualified identifier from an Import_expression.  Sets\n+  // *NAME, *PKG, and *IS_EXPORTED, and reports whether it succeeded.\n+  static bool\n+  read_qualified_identifier(Import_expression*, std::string* name,\n+\t\t\t    Package** pkg, bool* is_exported);\n+\n  private:\n   static Stream*\n   try_package_in_directory(const std::string&, Location);\n@@ -360,7 +391,7 @@ class Import : public Import_expression\n   import_var();\n \n   // Import a function.\n-  Named_object*\n+  void\n   import_func(Package*);\n \n   // Parse a type definition.\n@@ -401,6 +432,8 @@ class Import : public Import_expression\n   // Whether to add new objects to the global scope, rather than to a\n   // package scope.\n   bool add_to_globals_;\n+  // Mapping from package index to package.\n+  std::vector<Package*> packages_;\n   // All type data.\n   std::string type_data_;\n   // Position of type data in the stream.\n@@ -567,6 +600,11 @@ class Import_function_body : public Import_expression\n   location() const\n   { return this->imp_->location(); }\n \n+  // The function we are importing.\n+  Named_object*\n+  function() const\n+  { return this->named_object_; }\n+\n   // A reference to the body we are reading.\n   const std::string&\n   body() const\n@@ -662,6 +700,16 @@ class Import_function_body : public Import_expression\n   ifb()\n   { return this; }\n \n+  // Return the maximum valid package index.\n+  size_t\n+  max_package_index() const\n+  { return this->imp_->max_package_index(); }\n+\n+  // Return the package at an index.\n+  Package*\n+  package_at_index(int index)\n+  { return this->imp_->package_at_index(index); }\n+\n   // Return whether we have seen an error.\n   bool\n   saw_error() const"}]}