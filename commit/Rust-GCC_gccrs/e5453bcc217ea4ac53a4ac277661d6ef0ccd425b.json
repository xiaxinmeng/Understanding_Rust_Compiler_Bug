{"sha": "e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "node_id": "C_kwDOANBUbNoAKGU1NDUzYmNjMjE3ZWE0YWM1M2E0YWMyNzc2NjFkNmVmMGNjZDQyNWI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-04-08T11:13:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-04-08T12:18:31Z"}, "message": "tree-optimization/105198 - wrong code with predictive commoning\n\nWhen predictive commoning looks for a looparound PHI it tries\nto match the entry value definition (a load) up with the appropriate\nmember of the chain.  But it fails to consider stmts clobbering\nthe very same memory location inbetween the load and loop entry.\n\nIn theory we could be more clever on must aliases that would be\nalso picked up from a load (so not exactly stmt_kills_ref_p) and\nuse the stored value from that if it is an exact match.  But we\ncurrently have no way to propagate this information inside predcom.\n\n2022-04-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/105198\n\t* tree-predcom.cc (find_looparound_phi): Check whether\n\tthe found memory location of the entry value is clobbered\n\tinbetween the value we want to use and loop entry.\n\n\t* gcc.dg/torture/pr105198.c: New testcase.", "tree": {"sha": "456c81a41536808736967a76f8de280ca0fb1589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/456c81a41536808736967a76f8de280ca0fb1589"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04ecadbeae51ac56f1a104b4858b6463b24dfaa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ecadbeae51ac56f1a104b4858b6463b24dfaa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ecadbeae51ac56f1a104b4858b6463b24dfaa2"}], "stats": {"total": 64, "additions": 59, "deletions": 5}, "files": [{"sha": "91f92afc163c9b690e87b3c2d5e24a04345430a2", "filename": "gcc/testsuite/gcc.dg/torture/pr105198.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105198.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105198.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105198.c?ref=e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fno-tree-pre -fpredictive-commoning\" } */\n+\n+static  __attribute__ ((noipa)) void\n+next_set(int *x, int n, int k)\n+{\n+  int j = k - 1;\n+  int tmp = x[j]++;\n+  while (j > 0)\n+    {\n+      if (x[j] < n - (k - 1 -j))\n+        break;\n+      j--;\n+      x[j]++;\n+      tmp = x[j];\n+    }\n+  if (tmp != 2 || j != 1 || x[0] != 0 || x[1] != 2 || x[2] != 5)\n+    __builtin_abort ();\n+}\n+\n+int main()\n+{\n+  int x[3] = {0, 1, 4};\n+  next_set(x, 5, 3);\n+  return 0;\n+}"}, {"sha": "fb457250bbd36dca0171e39505046e0a5aca5063", "filename": "gcc/tree-predcom.cc", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b/gcc%2Ftree-predcom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5453bcc217ea4ac53a4ac277661d6ef0ccd425b/gcc%2Ftree-predcom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.cc?ref=e5453bcc217ea4ac53a4ac277661d6ef0ccd425b", "patch": "@@ -1377,7 +1377,6 @@ gphi *\n pcom_worker::find_looparound_phi (dref ref, dref root)\n {\n   tree name, init, init_ref;\n-  gphi *phi = NULL;\n   gimple *init_stmt;\n   edge latch = loop_latch_edge (m_loop);\n   struct data_reference init_dr;\n@@ -1395,14 +1394,19 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   if (!name)\n     return NULL;\n \n+  tree entry_vuse = NULL_TREE;\n+  gphi *phi = NULL;\n   for (psi = gsi_start_phis (m_loop->header); !gsi_end_p (psi); gsi_next (&psi))\n     {\n-      phi = psi.phi ();\n-      if (PHI_ARG_DEF_FROM_EDGE (phi, latch) == name)\n+      gphi *p = psi.phi ();\n+      if (PHI_ARG_DEF_FROM_EDGE (p, latch) == name)\n+\tphi = p;\n+      else if (virtual_operand_p (gimple_phi_result (p)))\n+\tentry_vuse = PHI_ARG_DEF_FROM_EDGE (p, loop_preheader_edge (m_loop));\n+      if (phi && entry_vuse)\n \tbreak;\n     }\n-\n-  if (gsi_end_p (psi))\n+  if (!phi || !entry_vuse)\n     return NULL;\n \n   init = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (m_loop));\n@@ -1430,6 +1434,30 @@ pcom_worker::find_looparound_phi (dref ref, dref root)\n   if (!valid_initializer_p (&init_dr, ref->distance + 1, root->ref))\n     return NULL;\n \n+  /* Make sure nothing clobbers the location we re-use the initial value\n+     from.  */\n+  if (entry_vuse != gimple_vuse (init_stmt))\n+    {\n+      ao_ref ref;\n+      ao_ref_init (&ref, init_ref);\n+      unsigned limit = param_sccvn_max_alias_queries_per_access;\n+      tree vdef = entry_vuse;\n+      do\n+\t{\n+\t  gimple *def = SSA_NAME_DEF_STMT (vdef);\n+\t  if (limit-- == 0 || gimple_code (def) == GIMPLE_PHI)\n+\t    return NULL;\n+\t  if (stmt_may_clobber_ref_p_1 (def, &ref))\n+\t    /* When the stmt is an assign to init_ref we could in theory\n+\t       use its RHS for the initial value of the looparound PHI\n+\t       we replace in prepare_initializers_chain, but we have\n+\t       no convenient place to store this info at the moment.  */\n+\t    return NULL;\n+\t  vdef = gimple_vuse (def);\n+\t}\n+      while (vdef != gimple_vuse (init_stmt));\n+    }\n+\n   return phi;\n }\n "}]}