{"sha": "18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhY2ZiZTE4ZjNkZmM3NzFiNDhmNjA2ZWY0N2VhODI5MWVlNWMzOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-17T20:08:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-17T20:08:42Z"}, "message": "compiler: Rework handling of imported anonymous builtin types again.\n\nFrom-SVN: r203795", "tree": {"sha": "a651123e45a1824c09512d06c425ec5c4c069614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a651123e45a1824c09512d06c425ec5c4c069614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18acfbe18f3dfc771b48f606ef47ea8291ee5c39/comments", "author": null, "committer": null, "parents": [{"sha": "3170766c285515b59943651c79860d39b5f771ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3170766c285515b59943651c79860d39b5f771ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3170766c285515b59943651c79860d39b5f771ca"}], "stats": {"total": 87, "additions": 50, "deletions": 37}, "files": [{"sha": "f0d58e5ed358611ab8a4eee7e977b768892b2eda", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18acfbe18f3dfc771b48f606ef47ea8291ee5c39/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18acfbe18f3dfc771b48f606ef47ea8291ee5c39/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "patch": "@@ -4208,7 +4208,8 @@ Struct_field::is_field_name(const std::string& name) const\n \n       // This is a horrible hack caused by the fact that we don't pack\n       // the names of builtin types.  FIXME.\n-      if (nt != NULL\n+      if (!this->is_imported_\n+\t  && nt != NULL\n \t  && nt->is_builtin()\n \t  && nt->name() == Gogo::unpack_hidden_name(name))\n \treturn true;\n@@ -4217,6 +4218,36 @@ Struct_field::is_field_name(const std::string& name) const\n     }\n }\n \n+// Return whether this field is an unexported field named NAME.\n+\n+bool\n+Struct_field::is_unexported_field_name(Gogo* gogo,\n+\t\t\t\t       const std::string& name) const\n+{\n+  const std::string& field_name(this->field_name());\n+  if (Gogo::is_hidden_name(field_name)\n+      && name == Gogo::unpack_hidden_name(field_name)\n+      && gogo->pack_hidden_name(name, false) != field_name)\n+    return true;\n+\n+  // Check for the name of a builtin type.  This is like the test in\n+  // is_field_name, only there we return false if this->is_imported_,\n+  // and here we return true.\n+  if (this->is_imported_ && this->is_anonymous())\n+    {\n+      Type* t = this->typed_identifier_.type();\n+      if (t->points_to() != NULL)\n+\tt = t->points_to();\n+      Named_type* nt = t->named_type();\n+      if (nt != NULL\n+\t  && nt->is_builtin()\n+\t  && nt->name() == Gogo::unpack_hidden_name(name))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n // Return whether this field is an embedded built-in type.\n \n bool\n@@ -4649,13 +4680,8 @@ Struct_type::is_unexported_local_field(Gogo* gogo,\n       for (Struct_field_list::const_iterator pf = fields->begin();\n \t   pf != fields->end();\n \t   ++pf)\n-\t{\n-\t  const std::string& field_name(pf->field_name());\n-\t  if (Gogo::is_hidden_name(field_name)\n-\t      && name == Gogo::unpack_hidden_name(field_name)\n-\t      && gogo->pack_hidden_name(name, false) != field_name)\n-\t    return true;\n-\t}\n+\tif (pf->is_unexported_field_name(gogo, name))\n+\t  return true;\n     }\n   return false;\n }\n@@ -5257,34 +5283,8 @@ Struct_type::do_import(Import* imp)\n \t    }\n \t  Type* ftype = imp->read_type();\n \n-\t  // We don't pack the names of builtin types.  In\n-\t  // Struct_field::is_field_name we cope with a hack.  Now we\n-\t  // need another hack so that we don't accidentally think\n-\t  // that an embedded builtin type is accessible from another\n-\t  // package (we know that all the builtin types are not\n-\t  // exported).\n-\t  // This is called during parsing, before anything is\n-\t  // lowered, so we have to be careful to avoid dereferencing\n-\t  // an unknown type name.\n-\t  if (name.empty())\n-\t    {\n-\t      Type *t = ftype;\n-\t      if (t->classification() == Type::TYPE_POINTER)\n-\t\t{\n-\t\t  // Very ugly.\n-\t\t  Pointer_type* ptype = static_cast<Pointer_type*>(t);\n-\t\t  t = ptype->points_to();\n-\t\t}\n-\t      std::string tname;\n-\t      if (t->forward_declaration_type() != NULL)\n-\t\ttname = t->forward_declaration_type()->name();\n-\t      else if (t->named_type() != NULL)\n-\t\ttname = t->named_type()->name();\n-\t      if (!tname.empty() && tname[0] >= 'a' && tname[0] <= 'z')\n-\t\tname = '.' + imp->package()->pkgpath() + '.' + tname;\n-\t    }\n-\n \t  Struct_field sf(Typed_identifier(name, ftype, imp->location()));\n+\t  sf.set_is_imported();\n \n \t  if (imp->peek_char() == ' ')\n \t    {\n@@ -9324,7 +9324,9 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n       else\n \t{\n \t  bool is_unexported;\n-\t  if (!Gogo::is_hidden_name(name))\n+\t  // The test for 'a' and 'z' is to handle builtin names,\n+\t  // which are not hidden.\n+\t  if (!Gogo::is_hidden_name(name) && (name[0] < 'a' || name[0] > 'z'))\n \t    is_unexported = false;\n \t  else\n \t    {"}, {"sha": "12a7c8579b26a47834e8b43f7274b706b6536ccf", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18acfbe18f3dfc771b48f606ef47ea8291ee5c39/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18acfbe18f3dfc771b48f606ef47ea8291ee5c39/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=18acfbe18f3dfc771b48f606ef47ea8291ee5c39", "patch": "@@ -1924,7 +1924,7 @@ class Struct_field\n {\n  public:\n   explicit Struct_field(const Typed_identifier& typed_identifier)\n-    : typed_identifier_(typed_identifier), tag_(NULL)\n+    : typed_identifier_(typed_identifier), tag_(NULL), is_imported_(false)\n   { }\n \n   // The field name.\n@@ -1935,6 +1935,10 @@ class Struct_field\n   bool\n   is_field_name(const std::string& name) const;\n \n+  // Return whether this struct field is an unexported field named NAME.\n+  bool\n+  is_unexported_field_name(Gogo*, const std::string& name) const;\n+\n   // Return whether this struct field is an embedded built-in type.\n   bool\n   is_embedded_builtin(Gogo*) const;\n@@ -1972,6 +1976,11 @@ class Struct_field\n   set_tag(const std::string& tag)\n   { this->tag_ = new std::string(tag); }\n \n+  // Record that this field is defined in an imported struct.\n+  void\n+  set_is_imported()\n+  { this->is_imported_ = true; }\n+\n   // Set the type.  This is only used in error cases.\n   void\n   set_type(Type* type)\n@@ -1982,6 +1991,8 @@ class Struct_field\n   Typed_identifier typed_identifier_;\n   // The field tag.  This is NULL if the field has no tag.\n   std::string* tag_;\n+  // Whether this field is defined in an imported struct.\n+  bool is_imported_;\n };\n \n // A list of struct fields."}]}