{"sha": "60741f92b64bde43514e8a89f67045d347f7194c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA3NDFmOTJiNjRiZGU0MzUxNGU4YTg5ZjY3MDQ1ZDM0N2Y3MTk0Yw==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-10-09T22:23:52Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-10-09T22:23:52Z"}, "message": "howto.html: Tweak markup and value type.\n\n2001-10-09  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/html/17_intro/howto.html:  Tweak markup and value type.\n\t* docs/html/27_io/howto.html:  Tweak markup, describe setbuf() for\n\tnonzero arguments, add new note on threading.\n\t* docs/html/faq/index.html:  Update.\n\t* docs/html/faq/index.txt:  Regenerate.\n\nFrom-SVN: r46130", "tree": {"sha": "ecde98f60589352b14c694e361ac63ac253338a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecde98f60589352b14c694e361ac63ac253338a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60741f92b64bde43514e8a89f67045d347f7194c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60741f92b64bde43514e8a89f67045d347f7194c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60741f92b64bde43514e8a89f67045d347f7194c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60741f92b64bde43514e8a89f67045d347f7194c/comments", "author": null, "committer": null, "parents": [{"sha": "481aae6fc28e120cb63598f572ea40d6ecb18743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/481aae6fc28e120cb63598f572ea40d6ecb18743", "html_url": "https://github.com/Rust-GCC/gccrs/commit/481aae6fc28e120cb63598f572ea40d6ecb18743"}], "stats": {"total": 124, "additions": 110, "deletions": 14}, "files": [{"sha": "1397e0f21fca31eca6b9d1b52bd63102e1445ba1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=60741f92b64bde43514e8a89f67045d347f7194c", "patch": "@@ -1,3 +1,11 @@\n+2001-10-09  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/html/17_intro/howto.html:  Tweak markup and value type.\n+\t* docs/html/27_io/howto.html:  Tweak markup, describe setbuf() for\n+\tnonzero arguments, add new note on threading.\n+\t* docs/html/faq/index.html:  Update.\n+\t* docs/html/faq/index.txt:  Regenerate.\n+\n 2001-10-09  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/configopts.html:  More HTML->XHTML and lowercasing of tags."}, {"sha": "27e1a5f663b231004a2e482b2aafc98bbf325a4a", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=60741f92b64bde43514e8a89f67045d347f7194c", "patch": "@@ -93,8 +93,7 @@ <h2><a name=\"3\">Thread-safety</a></h2>\n       Here is one possible example displaying the forcing of the malloc-based\n       allocator over the typically higher-speed default allocator:\n       <pre>\n-      std::list &lt;void*, std::malloc_alloc&gt;  my_malloc_based_list;\n-      </pre>\n+      std::list &lt;my_type, std::malloc_alloc&gt;  my_malloc_based_list;</pre>\n    </p>\n    <p>A recent journal article has described &quot;atomic integer\n       operations,&quot; which would allow us to, well, perform updates"}, {"sha": "c4342a3c4d1feeccce3d79340acac9555d86c984", "filename": "libstdc++-v3/docs/html/27_io/howto.html", "status": "modified", "additions": 97, "deletions": 7, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F27_io%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F27_io%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F27_io%2Fhowto.html?ref=60741f92b64bde43514e8a89f67045d347f7194c", "patch": "@@ -29,6 +29,7 @@ <h1>Contents</h1>\n    <li><a href=\"#6\">Deriving a stream buffer</a>\n    <li><a href=\"#7\">More on binary I/O</a>\n    <li><a href=\"#8\">Pathetic performance?  Ditch C.</a>\n+   <li><a href=\"#9\">Threads and I/O</a>\n </ul>\n \n <hr>\n@@ -59,7 +60,7 @@ <h2><a name=\"1\">Copying a file</a></h2>\n    </p>\n    <p>Seriously, go do it.  Get surprised, then come back.  It's worth it.\n    </p>\n-   <HR WIDTH=\"60%\">\n+   <hr width=\"60%\">\n    <p>The thing to remember is that the <code>basic_[io]stream</code> classes\n       handle formatting, nothing else.  In particular, they break up on\n       whitespace.  The actual reading, writing, and storing of data is\n@@ -170,11 +171,14 @@ <h2><a name=\"2\">The buffering is screwing up my program!</a></h2>\n       <code>streambuf</code> does not specify any actions for its own \n       <code>setbuf()</code>-ish functions; the classes derived from\n       <code>streambuf</code> each define behavior that &quot;makes \n-      sense&quot; for that class:  an argument of (0,0) turns off\n-      buffering for <code>filebuf</code> but has undefined behavior for\n-      its sibling <code>stringbuf</code>, and specifying anything other\n-      than (0,0) has varying effects.  Other user-defined class derived\n-      from streambuf can do whatever they want.\n+      sense&quot; for that class:  an argument of (0,0) turns off buffering\n+      for <code>filebuf</code> but has undefined behavior for its sibling\n+      <code>stringbuf</code>, and specifying anything other than (0,0) has\n+      varying effects.  Other user-defined class derived from streambuf can\n+      do whatever they want.  (For <code>filebuf</code> and arguments for\n+      <code>(p,s)</code> other than zeros, libstdc++ does what you'd expect:\n+      the first <code>s</code> bytes of <code>p</code> are used as a buffer,\n+      which you must allocate and deallocate.)\n    </p>\n    <p>A last reminder:  there are usually more buffers involved than\n       just those at the language/library level.  Kernel buffers, disk\n@@ -453,10 +457,96 @@ <h2><a name=\"8\">Pathetic performance?  Ditch C.</a></h2>\n       buffered.\n    </p>\n \n+<hr>\n+<h2><a name=\"9\">Threads and I/O</a></h2>\n+   <p>I'll assume that you have already read the\n+      <a href=\"../17_intro/howto.html#3\">general notes on library threads</a>,\n+      and the\n+      <a href=\"../23_containers/howto.html#3\">notes on threaded container\n+      access</a> (you might not think of an I/O stream as a container, but\n+      the points made there also hold here).  If you have not read them,\n+      please do so first.\n+   </p>\n+   <p>This gets a bit tricky.  Please read carefully, and bear with me.\n+   </p>\n+   <h3>Structure</h3>\n+   <p>As described <a href=\"../explanations.html#cstdio\">here</a>, a wrapper\n+      type called <code>__basic_file</code> provides our abstraction layer\n+      for the <code>std::filebuf</code> classes.  Nearly all decisions dealing\n+      with actual input and output must be made in <code>__basic_file</code>.\n+   </p>\n+   <p>A generic locking mechanism is somewhat in place at the filebuf layer,\n+      but is not used in the current code.  Providing locking at any higher\n+      level is akin to providing locking within containers, and is not done\n+      for the same reasons (see the links above).\n+   </p>\n+   <h3>The defaults for 3.0.x</h3>\n+   <p>The __basic_file type is simply a collection of small wrappers around\n+      the C stdio layer (again, see the link under Structure).  We do no\n+      locking ourselves, but simply pass through to calls to <code>fopen</code>,\n+      <code>fwrite</code>, and so forth.\n+   </p>\n+   <p>So, for 3.0, the question of &quot;is multithreading safe for I/O&quot; \n+      must be answered with, &quot;is your platform's C library threadsafe\n+      for I/O?&quot;  Some are by default, some are not; many offer multiple\n+      implementations of the C library with varying tradeoffs of threadsafety\n+      and efficiency.  You, the programmer, are always required to take care\n+      with multiple threads.\n+   </p>\n+   <p>(As an example, the POSIX standard requires that C stdio FILE*\n+       operations are atomic.  POSIX-conforming C libraries (e.g, on Solaris\n+       and GNU/Linux) have an internal mutex to serialize operations on\n+       FILE*s.  However, you still need to not do stupid things like calling\n+       <code>fclose(fs)</code> in one thread followed by an access of\n+       <code>fs</code> in another.)\n+   </p>\n+   <p>So, if your platform's C library is threadsafe, then your\n+      <code>fstream</code> I/O operations will be threadsafe at the lowest\n+      level.  For higher-level operations, such as manipulating the data\n+      contained in the stream formatting classes (e.g., setting up callbacks\n+      inside an <code>std::ofstream</code>), you need to guard such accesses\n+      like any other critical shared resource.\n+   </p>\n+   <h3>The future</h3>\n+   <p>As already mentioned <a href=\"../explanations.html#cstdio\">here</a>, a\n+      second choice is available for I/O implementations:  libio.  This is\n+      disabled by default, and in fact will not currently work due to other\n+      issues.  It will be revisited, however.\n+   </p>\n+   <p>The libio code is a subset of the guts of the GNU libc (glibc) I/O\n+      implementation.  When libio is in use, the <code>__basic_file</code>\n+      type is basically derived from FILE.  (The real situation is more\n+      complex than that... it's derived from an internal type used to\n+      implement FILE.  See libio/libioP.h to see scary things done with\n+      vtbls.)  The result is that there is no &quot;layer&quot; of C stdio\n+      to go through; the filebuf makes calls directly into the same\n+      functions used to implement <code>fread</code>, <code>fwrite</code>,\n+      and so forth, using internal data structures.  (And when I say\n+      &quot;makes calls directly,&quot; I mean the function is literally\n+      replaced by a jump into an internal function.  Fast but frightening.\n+      *grin*)\n+   </p>\n+   <p>Also, the libio internal locks are used.  This requires pulling in\n+      large chunks of glibc, such as a pthreads implementation, and is one\n+      of the issues preventing widespread use of libio as the libstdc++\n+      cstdio implementation.\n+   </p>\n+   <p>But we plan to make this work, at least as an option if not a future\n+      default.  Platforms running a copy of glibc with a recent-enough\n+      version will see calls from libstdc++ directly into the glibc already\n+      installed.  For other platforms, a copy of the libio subsection will\n+      be built and included in libstdc++.\n+   </p>\n+   <h3>Alternatives</h3>\n+   <p>Don't forget that other cstdio implemenations are possible.  You could\n+      easily write one to perform your own forms of locking, to solve your\n+      &quot;interesting&quot; problems.\n+   </p>\n+\n \n <!-- ####################################################### -->\n \n-<hr><br><br><br><br><br><br><br><br>\n+<hr>\n <p class=\"fineprint\"><em>\n See <a href=\"../17_intro/license.html\">license.html</a> for copying conditions.\n Comments and suggestions are welcome, and may be sent to"}, {"sha": "0b711973a8d0025499c77230a0512a8d6b386e0e", "filename": "libstdc++-v3/docs/html/faq/index.html", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html?ref=60741f92b64bde43514e8a89f67045d347f7194c", "patch": "@@ -686,9 +686,8 @@ <h2><a name=\"5_5\">5.5 [removed]</a></h2>\n \n <hr>\n    <h2><a name=\"5_6\">5.6 Is libstdc++-v3 thread-safe?</a></h2>\n-      <p>Quick answer:  no, as of 2.92 (eleventh snapshot), the\n-         library is not appropriate for multithreaded access.  The\n-         string class is MT-safe.\n+      <p>Quick answer:  no, as of 3.0, most of the library is not\n+         safe for multithreaded access.  The string class is MT-safe.\n       </p>\n       <p>This is assuming that your idea of &quot;multithreaded&quot;\n          is the same as ours...  The general question of multithreading"}, {"sha": "fcf84c8cd83f9eced2164df65de563d3576c70f4", "filename": "libstdc++-v3/docs/html/faq/index.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60741f92b64bde43514e8a89f67045d347f7194c/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt?ref=60741f92b64bde43514e8a89f67045d347f7194c", "patch": "@@ -548,8 +548,8 @@ http://clisp.cons.org/~haible/gccinclude-glibc-2.2-compat.diff\n \n 5.6 Is libstdc++-v3 thread-safe?\n \n-   Quick  answer:  no, as of 2.92 (eleventh snapshot), the library is not\n-   appropriate for multithreaded access. The string class is MT-safe.\n+   Quick  answer:  no,  as  of  3.0,  most of the library is not safe for\n+   multithreaded access. The string class is MT-safe.\n \n    This  is  assuming  that  your  idea of \"multithreaded\" is the same as\n    ours...  The  general  question  of multithreading and libstdc++-v3 is"}]}