{"sha": "a7180f707a9154ba5c40caa8d5b805f7848dadd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcxODBmNzA3YTkxNTRiYTVjNDBjYWE4ZDViODA1Zjc4NDhkYWRkNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-06-26T22:47:37Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-06-26T22:47:37Z"}, "message": "Add MMX and SSE registers to i386 machine description\n\nFrom-SVN: r34721", "tree": {"sha": "b812819a24fd857501335c511c9013e9963573dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b812819a24fd857501335c511c9013e9963573dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7180f707a9154ba5c40caa8d5b805f7848dadd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7180f707a9154ba5c40caa8d5b805f7848dadd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7180f707a9154ba5c40caa8d5b805f7848dadd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7180f707a9154ba5c40caa8d5b805f7848dadd6/comments", "author": null, "committer": null, "parents": [{"sha": "5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5397b1559a09f05f41f99e7f20f670ffc7b2d38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5397b1559a09f05f41f99e7f20f670ffc7b2d38e"}], "stats": {"total": 550, "additions": 408, "deletions": 142}, "files": [{"sha": "453d64c23c0e32f6c226ab413404bc4faf48674b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -1,3 +1,54 @@\n+2000-06-27  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\tAdd MMX and SSE registers to i386 machine description.\n+\t* i386-protos.h (ix86_constant_alignment, ix86_data_alignment,\n+\tix86_local_alignment): Declare.\n+\n+\t* i386.h (TARGET_MMX, TARGET_SSE): New.\n+\t(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS,\n+\tREG_ALLOC_ORDER, HARD_REGNO_NREGS, HARD_REGNO_MODE_OK,\n+\tREG_CLASS_NAMES, REG_CLASS_CONTENTS,REG_CLASS_FROM_LETTER,\n+\tenum reg_class, HI_REGISTER_NAMES): Added MMX/SSE registers.\n+\t(FIRST_SSE_REG, LAST_SSE_REG, SSE_REGNO_P): New.\n+\t(FIRST_MMX_REG, LAST_MMX_REG, MMX_REGNO_P, MMX_REG_P): New macros.\n+\t(RETURN_IN_MEMORY): Handle MMX/SSE.\n+\t(REG_PARM_STACK_SPACE): Added so the first three TImode parameters\n+\talso get stack space.\n+\t(MUST_PASS_IN_STACK): Added TImode to the default definition.\n+\t(CUMULATIVE_ARGS): Added sse_nregs, sse_regno and sse_words.\n+\t(MMX_REGISTER_NAMES): New.\n+\t(ALIGN_MODE_128): New macro.\n+\t(CONSTANT_ALIGNMENT): Code moved out-of-line; just call the function.\n+\t(DATA_ALIGNMENT): Likewise.\n+\t(LOCAL_ALIGNMENT): Likewise.\n+\t(CONDITIONAL_REGISTER_USAGE): Make MMX/SSE regs fixed if not\n+\tTARGET_MMX/TARGET_SSE.\n+\t(VALID_SSE_REG_MODE, VALID_MMX_REG_MODE): New macros.\n+\t(REG_CLASS_FROM_LETTER): 'y' for MMX regs.\n+\t(SECONDARY_MEMORY_NEEDED): Be conservative about copying between\n+\tSSE/MMX regs and something else.\n+\t(CLASS_MAX_NREGS): 1 for SSE and MMX regs.\n+\t(REGISTER_MOVE_COST): 10 if trying to move between MMX and SSE regs,\n+\t3 if moving between MMX regs and something else.\n+\n+\t* i386.c (reg_class): Add SSE_REGS, MMX_REGS.\n+\t(regclass_map): Add MMX/SSE registers.\n+\t(print_operand): Add code to print XMMWORD as appropriate.\n+\t(ix86_split_movdi): Abort for MMX regs.\n+\t(init_cumulative_args): Also allow SSE_REGS\n+\t(function_arg_advance, function_arg): Likewise\n+\t(print_reg): Support 'm'.  Add case for TImode.\n+\t(override_options): TARGET_SSE implies TARGET_MMX.\n+\t(ix86_constant_alignment, ix86_data_alignment, ix86_local_alignment):\n+\tNew functions.\n+\n+\t* config/i386/unix.h (VALUE_REGNO): VECTOR_MODE values go to\n+\tFIRST_SSE_REG.\n+\t* config/i386/ptx4-i.h (RETURN_IN_MEMORY): Return MMX values in\n+\tmemory.\n+\t* config/i386/sysv4.h (RETURN_IN_MEMORY): Likewise.\n+\t* config/i386/i386elf.h (RETURN_IN_MEMORY): Likewise.\n+\n 2000-06-26  Geoff Keating  <geoffk@cygnus.com>\n \n \t* ssa.c (struct rename_set_data): Change the name of field"}, {"sha": "65e3df908eff4f868fea58bf2fc2e51474afd087", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -135,6 +135,10 @@ extern int ix86_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n extern int ix86_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n extern int ix86_comp_type_attributes PARAMS ((tree, tree));\n extern int ix86_return_pops_args PARAMS ((tree, tree, int));\n+\n+extern int ix86_data_alignment PARAMS ((tree, int));\n+extern int ix86_local_alignment PARAMS ((tree, int));\n+extern int ix86_constant_alignment PARAMS ((tree, int));\n #endif\n \n "}, {"sha": "0eb9d95303beec7a04693b9d05b820272bda34c6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -247,7 +247,11 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* arg pointer */\n   NON_Q_REGS,\n   /* flags, fpsr, dirflag, frame */\n-  NO_REGS, NO_REGS, NO_REGS, NON_Q_REGS\n+  NO_REGS, NO_REGS, NO_REGS, NON_Q_REGS,\n+  SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS,\n+  SSE_REGS, SSE_REGS,\n+  MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS, MMX_REGS,\n+  MMX_REGS, MMX_REGS\n };\n \n /* The \"default\" register map.  */\n@@ -257,6 +261,8 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   0, 2, 1, 3, 6, 7, 4, 5,\t\t/* general regs */\n   12, 13, 14, 15, 16, 17, 18, 19,\t/* fp regs */\n   -1, -1, -1, -1,\t\t\t/* arg, flags, fpsr, dir */\n+  21, 22, 23, 24, 25, 26, 27, 28,\t/* SSE */\n+  29, 30, 31, 32, 33, 34, 35, 36,       /* MMX */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -318,6 +324,8 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   0, 2, 1, 3, 6, 7, 5, 4,\t\t/* general regs */\n   11, 12, 13, 14, 15, 16, 17, 18,\t/* fp regs */\n   -1, 9, -1, -1,\t\t\t/* arg, flags, fpsr, dir */\n+  21, 22, 23, 24, 25, 26, 27, 28,\t/* SSE registers */\n+  29, 30, 31, 32, 33, 34, 35, 36,\t/* MMX registers */\n };\n \n \n@@ -625,6 +633,11 @@ override_options ()\n   /* If we're planning on using `loop', use it.  */\n   if (TARGET_USE_LOOP && optimize)\n     flag_branch_on_count_reg = 1;\n+\n+  /* It makes no sense to ask for just SSE builtins, so MMX is also turned\n+     on by -msse.  */\n+  if (TARGET_SSE)\n+    target_flags |= MASK_MMX;\n }\n \f\n /* A C statement (sans semicolon) to choose the order in which to\n@@ -3092,11 +3105,16 @@ print_reg (x, code, file)\n     code = 3;\n   else if (code == 'h')\n     code = 0;\n+  else if (code == 'm' || MMX_REG_P (x))\n+    code = 5;\n   else\n     code = GET_MODE_SIZE (GET_MODE (x));\n \n   switch (code)\n     {\n+    case 5:\n+      fputs (hi_reg_name[REGNO (x)], file);\n+      break;\n     case 3:\n       if (STACK_TOP_P (x))\n \t{\n@@ -3110,6 +3128,7 @@ print_reg (x, code, file)\n       if (! FP_REG_P (x))\n \tputc ('e', file);\n       /* FALLTHRU */\n+    case 16:\n     case 2:\n       fputs (hi_reg_name[REGNO (x)], file);\n       break;\n@@ -3139,7 +3158,8 @@ print_reg (x, code, file)\n    w --  likewise, print the HImode name of the register.\n    k --  likewise, print the SImode name of the register.\n    h --  print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n-   y --  print \"st(0)\" instead of \"st\" as a register.  */\n+   y --  print \"st(0)\" instead of \"st\" as a register.\n+   m --  print \"st(n)\" as an mmx register.  */\n \n void\n print_operand (file, x, code)\n@@ -3243,6 +3263,7 @@ print_operand (file, x, code)\n \tcase 'k':\n \tcase 'h':\n \tcase 'y':\n+\tcase 'm':\n \tcase 'X':\n \tcase 'P':\n \t  break;\n@@ -3297,6 +3318,7 @@ print_operand (file, x, code)\n \t    case 4: size = \"DWORD\"; break;\n \t    case 8: size = \"QWORD\"; break;\n \t    case 12: size = \"XWORD\"; break;\n+\t    case 16: size = \"XMMWORD\"; break;\n \t    default:\n \t      abort ();\n \t    }\n@@ -5440,6 +5462,8 @@ ix86_split_to_parts (operand, parts, mode)\n {\n   int size = GET_MODE_SIZE (mode) / 4;\n \n+  if (GET_CODE (operand) == REG && MMX_REGNO_P (REGNO (operand)))\n+    abort ();\n   if (size < 2 || size > 3)\n     abort ();\n \n@@ -6863,3 +6887,128 @@ ix86_variable_issue (dump, sched_verbose, insn, can_issue_more)\n       return --ix86_sched_data.ppro.issued_this_cycle;\n     }\n }\n+\f\n+/* Compute the alignment given to a constant that is being placed in memory.\n+   EXP is the constant and ALIGN is the alignment that the object would\n+   ordinarily have.\n+   The value of this function is used instead of that alignment to align\n+   the object.  */\n+\n+int\n+ix86_constant_alignment (exp, align)\n+     tree exp;\n+     int align;\n+{\n+  if (TREE_CODE (exp) == REAL_CST)\n+    {\n+      if (TYPE_MODE (TREE_TYPE (exp)) == DFmode && align < 64)\n+\treturn 64;\n+      else if (ALIGN_MODE_128 (TYPE_MODE (TREE_TYPE (exp))) && align < 128)\n+\treturn 128;\n+    }\n+  else if (TREE_CODE (exp) == STRING_CST && TREE_STRING_LENGTH (exp) >= 31\n+\t   && align < 256)\n+    return 256;\n+\n+  return align;\n+}\n+\n+/* Compute the alignment for a static variable.\n+   TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this function is used\n+   instead of that alignment to align the object.  */\n+\n+int\n+ix86_data_alignment (type, align)\n+     tree type;\n+     int align;\n+{\n+  if (AGGREGATE_TYPE_P (type)\n+       && TYPE_SIZE (type)\n+       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+       && (TREE_INT_CST_LOW (TYPE_SIZE (type)) >= 256\n+\t   || TREE_INT_CST_HIGH (TYPE_SIZE (type))) && align < 256)\n+    return 256;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (TYPE_MODE (TREE_TYPE (type)) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (TYPE_MODE (TREE_TYPE (type))) && align < 128)\n+\treturn 128;\n+    }\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      \n+      if (TYPE_MODE (type) == DCmode && align < 64)\n+\treturn 64;\n+      if (TYPE_MODE (type) == XCmode && align < 128)\n+\treturn 128;\n+    }\n+  else if ((TREE_CODE (type) == RECORD_TYPE\n+\t    || TREE_CODE (type) == UNION_TYPE\n+\t    || TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t   && TYPE_FIELDS (type))\n+    {\n+      if (DECL_MODE (TYPE_FIELDS (type)) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (DECL_MODE (TYPE_FIELDS (type))) && align < 128)\n+\treturn 128;\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == VECTOR_TYPE\n+\t   || TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      if (TYPE_MODE (type) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (TYPE_MODE (type)) && align < 128)\n+\treturn 128;\n+    }\n+\n+  return align;\n+}\n+\n+/* Compute the alignment for a local variable.\n+   TYPE is the data type, and ALIGN is the alignment that\n+   the object would ordinarily have.  The value of this macro is used\n+   instead of that alignment to align the object.  */\n+\n+int\n+ix86_local_alignment (type, align)\n+     tree type;\n+     int align;\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (TYPE_MODE (TREE_TYPE (type)) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (TYPE_MODE (TREE_TYPE (type))) && align < 128)\n+\treturn 128;\n+    }\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      if (TYPE_MODE (type) == DCmode && align < 64)\n+\treturn 64;\n+      if (TYPE_MODE (type) == XCmode && align < 128)\n+\treturn 128;\n+    }\n+  else if ((TREE_CODE (type) == RECORD_TYPE\n+\t    || TREE_CODE (type) == UNION_TYPE\n+\t    || TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t   && TYPE_FIELDS (type))\n+    {\n+      if (DECL_MODE (TYPE_FIELDS (type)) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (DECL_MODE (TYPE_FIELDS (type))) && align < 128)\n+\treturn 128;\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == VECTOR_TYPE\n+\t   || TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      \n+      if (TYPE_MODE (type) == DFmode && align < 64)\n+\treturn 64;\n+      if (ALIGN_MODE_128 (TYPE_MODE (type)) && align < 128)\n+\treturn 128;\n+    }\n+  return align;\n+}"}, {"sha": "6deddc00f33adcff6aa0823a2e5bbd0d84b8f99d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 193, "deletions": 136, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -102,6 +102,8 @@ extern int target_flags;\n #define MASK_INLINE_ALL_STROPS\t0x00002000\t/* Inline stringops in all cases */\n #define MASK_NO_PUSH_ARGS\t0x00004000\t/* Use push instructions */\n #define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n+#define MASK_MMX\t\t0x00010000\t/* Support MMX regs/builtins */\n+#define MASK_SSE\t\t0x00020000\t/* Support SSE regs/builtins */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -218,6 +220,9 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n \n #define ASSEMBLER_DIALECT ((target_flags & MASK_INTEL_SYNTAX) != 0)\n \n+#define TARGET_SSE ((target_flags & MASK_SSE) != 0)\n+#define TARGET_MMX ((target_flags & MASK_MMX) != 0)\n+\n #define TARGET_SWITCHES\t\t\t\t\t\t\t      \\\n { { \"80387\",\t\t\t MASK_80387, \"Use hardware fp\" },\t      \\\n   { \"no-80387\",\t\t\t-MASK_80387, \"Do not use hardware fp\" },      \\\n@@ -280,6 +285,11 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n     \"Use push instructions to save outgoing arguments\" },\t\t      \\\n   { \"no-accumulate-outgoing-args\",-MASK_ACCUMULATE_OUTGOING_ARGS,\t      \\\n     \"Do not use push instructions to save outgoing arguments\" },\t      \\\n+  { \"mmx\",\t\t\t MASK_MMX, \"Support MMX builtins\" },          \\\n+  { \"no-mmx\",\t\t\t-MASK_MMX, \"Do not support MMX builtins\" },   \\\n+  { \"sse\",\t\t\t MASK_SSE, \"Support MMX and SSE builtins\" },  \\\n+  { \"no-sse\",\t\t\t-MASK_SSE,\t\t\t\t      \\\n+    \"Do not support MMX and SSE builtins\" },\t\t\t\t      \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n   { \"\", TARGET_DEFAULT, 0 }}\n \n@@ -497,6 +507,11 @@ extern int ix86_arch;\n \n #define BIGGEST_ALIGNMENT 128\n \n+/* Decide whether a variable of mode MODE must be 128 bit aligned.  */\n+#define ALIGN_MODE_128(MODE) \\\n+ ((MODE) == XFmode || ((MODE) == TImode) || (MODE) == V4SFmode\t\\\n+  || (MODE) == V4SImode)\n+\n /* The published ABIs say that doubles should be aligned on word\n    boundaries, so lower the aligment for structure fields unless\n    -malign-double is set.  */\n@@ -509,7 +524,7 @@ extern int ix86_arch;\n #endif\n \n /* If defined, a C expression to compute the alignment given to a\n-   constant that is being placed in memory.  CONSTANT is the constant\n+   constant that is being placed in memory.  EXP is the constant\n    and ALIGN is the alignment that the object would ordinarily have.\n    The value of this macro is used instead of that alignment to align\n    the object.\n@@ -520,18 +535,7 @@ extern int ix86_arch;\n    constants to be word aligned so that `strcpy' calls that copy\n    constants can be done inline.  */\n \n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n-  (TREE_CODE (EXP) == REAL_CST\t\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TREE_TYPE (EXP)) == DFmode && (ALIGN) < 64)\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TREE_TYPE (EXP)) == XFmode && (ALIGN) < 128)\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : TREE_CODE (EXP) == STRING_CST\t\t\t\t\t\\\n-    ? ((TREE_STRING_LENGTH (EXP) >= 31 && (ALIGN) < 256)\t\t\\\n-\t? 256\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : (ALIGN))\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN) ix86_constant_alignment (EXP, ALIGN)\n \n /* If defined, a C expression to compute the alignment for a static\n    variable.  TYPE is the data type, and ALIGN is the alignment that\n@@ -545,41 +549,7 @@ extern int ix86_arch;\n    cause character arrays to be word-aligned so that `strcpy' calls\n    that copy constants to character arrays can be done inline.  */\n \n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n-  ((AGGREGATE_TYPE_P (TYPE)\t\t\t\t\t\t\\\n-    && TYPE_SIZE (TYPE)\t\t\t\t\t\t\t\\\n-    && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\t\\\n-    && (TREE_INT_CST_LOW (TYPE_SIZE (TYPE)) >= 256\t\t\t\\\n-\t|| TREE_INT_CST_HIGH (TYPE_SIZE (TYPE))) && (ALIGN) < 256)\t\\\n-    ? 256\t\t\t\t\t\t\t\t\\\n-    : TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TREE_TYPE (TYPE)) == DFmode && (ALIGN) < 64)\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TREE_TYPE (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : TREE_CODE (TYPE) == COMPLEX_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TYPE) == DCmode && (ALIGN) < 64)\t\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TYPE) == XCmode && (ALIGN) < 128)\t\t\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : ((TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\t\t\\\n-\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n-\t|| TREE_CODE (TYPE) == QUAL_UNION_TYPE)\t\t\t\t\\\n-\t&& TYPE_FIELDS (TYPE))\t\t\t\t\t\t\\\n-    ? ((DECL_MODE (TYPE_FIELDS (TYPE)) == DFmode && (ALIGN) < 64)\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-\t: (DECL_MODE (TYPE_FIELDS (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : TREE_CODE (TYPE) == REAL_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TYPE) == DFmode && (ALIGN) < 64)\t\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TYPE) == XFmode && (ALIGN) < 128)\t\t\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : (ALIGN))\n+#define DATA_ALIGNMENT(TYPE, ALIGN) ix86_data_alignment (TYPE, ALIGN)\n \n /* If defined, a C expression to compute the alignment for a local\n    variable.  TYPE is the data type, and ALIGN is the alignment that\n@@ -591,35 +561,7 @@ extern int ix86_arch;\n    One use of this macro is to increase alignment of medium-size\n    data to make it all fit in fewer cache lines.  */\n \n-#define LOCAL_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TREE_TYPE (TYPE)) == DFmode && (ALIGN) < 64)\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TREE_TYPE (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : TREE_CODE (TYPE) == COMPLEX_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TYPE) == DCmode && (ALIGN) < 64)\t\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TYPE) == XCmode && (ALIGN) < 128)\t\t\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : ((TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\t\t\\\n-\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n-\t|| TREE_CODE (TYPE) == QUAL_UNION_TYPE)\t\t\t\t\\\n-\t&& TYPE_FIELDS (TYPE))\t\t\t\t\t\t\\\n-    ? ((DECL_MODE (TYPE_FIELDS (TYPE)) == DFmode && (ALIGN) < 64)\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-\t: (DECL_MODE (TYPE_FIELDS (TYPE)) == XFmode && (ALIGN) < 128)\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : TREE_CODE (TYPE) == REAL_TYPE\t\t\t\t\t\\\n-    ? ((TYPE_MODE (TYPE) == DFmode && (ALIGN) < 64)\t\t\t\\\n-\t? 64\t\t\t\t\t\t\t\t\\\n-   \t: (TYPE_MODE (TYPE) == XFmode && (ALIGN) < 128)\t\t\t\\\n-\t? 128\t\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\t\t\t\t\t\t\t\\\n-    : (ALIGN))\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment (TYPE, ALIGN)\n \n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -666,7 +608,7 @@ extern int ix86_arch;\n    eliminated during reloading in favor of either the stack or frame\n    pointer. */\n \n-#define FIRST_PSEUDO_REGISTER 21\n+#define FIRST_PSEUDO_REGISTER 37\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -676,11 +618,15 @@ extern int ix86_arch;\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer. */\n-#define FIXED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n-{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0,   0,  \\\n-/*frame\t\t\t\t\t\t\t\t\t    */ \\\n-   1}\n+#define FIXED_REGISTERS\t\t\t\t\t\t\\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,\t\\\n+/*arg,flags,fpsr,dir,frame*/\t\t\t\t\t\\\n+    1,    0,   0,  0,    1,\t\t\t\t\t\\\n+/*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n+     0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n+/*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n+     0,   0,   0,   0,   0,   0,   0,   0}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -689,11 +635,15 @@ extern int ix86_arch;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#define CALL_USED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n-{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1,   1,  \\\n-/*frame\t\t\t\t\t\t\t\t\t    */ \\\n-   1}\n+#define CALL_USED_REGISTERS\t\t\t\t\t\\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,\t\\\n+/*arg,flags,fpsr,dir,frame*/\t\t\t\t\t\\\n+     1,   1,   1,  1,    1,\t\t\t\t\t\\\n+/*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n+     1,   1,   1,   1,   1,  1,    1,   1,\t\t\t\\\n+/*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n+     1,   1,   1,   1,   1,   1,   1,   1}\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -714,11 +664,15 @@ extern int ix86_arch;\n    functions, and a slightly slower compiler.  Users complained about the code\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n-#define REG_ALLOC_ORDER \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,cc,fpsr, dir*/ \\\n-{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18,  19,  \\\n-/*frame\t\t\t\t\t\t\t\t\t */ \\\n-  20}\n+#define REG_ALLOC_ORDER \t\t\t\t\t\\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n+{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15,\t\\\n+/*,arg,cc,fpsr,dir,frame*/\t\t\t\t\t\\\n+     16,17, 18, 19,   20,\t\t\t\t\t\\\n+/*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n+    21,  22,  23,  24,  25,  26,  27,  28,\t\t\t\\\n+/*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n+    29,  30,  31,  32,  33,  34,  35,  36 }\n \n /* A C statement (sans semicolon) to choose the order in which to\n    allocate hard registers for pseudo-registers local to a basic\n@@ -736,22 +690,36 @@ extern int ix86_arch;\n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (! TARGET_80387 && ! TARGET_FLOAT_RETURNS_IN_80387) \\\n-      { \t\t\t\t\t\t\\\n-\tint i; \t\t\t\t\t\t\\\n-\tHARD_REG_SET x;\t\t\t\t\t\\\n-        COPY_HARD_REG_SET (x, reg_class_contents[(int)FLOAT_REGS]); \\\n-        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\\\n-         if (TEST_HARD_REG_BIT (x, i)) \t\t\t\\\n-\t  fixed_regs[i] = call_used_regs[i] = 1; \t\\\n-      }\t\t\t\t\t\t\t\\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_MMX)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint i;\t\t\t\t\t\t\t\t\\\n+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n+          if (TEST_HARD_REG_BIT (reg_class_contents[(int)MMX_REGS], i))\t\\\n+\t    fixed_regs[i] = call_used_regs[i] = 1;\t\t \t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_SSE)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint i;\t\t\t\t\t\t\t\t\\\n+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n+          if (TEST_HARD_REG_BIT (reg_class_contents[(int)SSE_REGS], i))\t\\\n+\t    fixed_regs[i] = call_used_regs[i] = 1;\t\t \t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (! TARGET_80387 && ! TARGET_FLOAT_RETURNS_IN_80387)\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint i;\t\t\t\t\t\t\t\t\\\n+\tHARD_REG_SET x;\t\t\t\t\t\t\t\\\n+        COPY_HARD_REG_SET (x, reg_class_contents[(int)FLOAT_REGS]);\t\\\n+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n+          if (TEST_HARD_REG_BIT (x, i)) \t\t\t\t\\\n+\t    fixed_regs[i] = call_used_regs[i] = 1;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -765,9 +733,20 @@ extern int ix86_arch;\n    */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (FP_REGNO_P (REGNO) ? 1 \\\n+  (FP_REGNO_P (REGNO) || SSE_REGNO_P (REGNO) || MMX_REGNO_P (REGNO) ? 1 \\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n+#define VALID_SSE_REG_MODE(MODE) \\\n+    ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode)\n+\n+#define VALID_MMX_REG_MODE(MODE) \\\n+    ((MODE) == DImode || (MODE) == V8QImode || (MODE) == V4HImode \\\n+     || (MODE) == V2SImode || (MODE) == SImode)\n+\n+#define VECTOR_MODE_SUPPORTED_P(MODE)\t\t\t\t\t\\\n+    (VALID_SSE_REG_MODE (MODE) && TARGET_SSE ? 1\t\t\t\\\n+     : VALID_MMX_REG_MODE (MODE) && TARGET_MMX ? 1 : 0)\n+\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n@@ -781,6 +760,10 @@ extern int ix86_arch;\n    ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n        || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n       && GET_MODE_UNIT_SIZE (MODE) <= (LONG_DOUBLE_TYPE_SIZE == 96 ? 12 : 8))\\\n+   : SSE_REGNO_P (REGNO) ? VALID_SSE_REG_MODE (MODE)\t\t\\\n+   : MMX_REGNO_P (REGNO) ? VALID_MMX_REG_MODE (MODE)\t\t\\\n+   /* Only SSE and MMX regs can hold vector modes.  */\t\t\\\n+   : VECTOR_MODE_P (MODE) || (MODE) == TImode ? 0\t\t\\\n    : (REGNO) < 4 ? 1\t\t\t\t\t\t\\\n    /* Other regs cannot do byte accesses.  */\t\t\t\\\n    : (MODE) != QImode ? 1\t\t\t\t\t\\\n@@ -831,6 +814,12 @@ extern int ix86_arch;\n #define FPSR_REG 18\n #define DIRFLAG_REG 19\n \n+#define FIRST_SSE_REG (FRAME_POINTER_REGNUM + 1)\n+#define LAST_SSE_REG  (FIRST_SSE_REG + 7)\n+ \n+#define FIRST_MMX_REG  (LAST_SSE_REG + 1)\n+#define LAST_MMX_REG   (FIRST_MMX_REG + 7)\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n@@ -873,8 +862,11 @@ extern int ix86_arch;\n    should always be returned in memory.  You should instead use\n    `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n \n-#define RETURN_IN_MEMORY(TYPE) \\\n-  ((TYPE_MODE (TYPE) == BLKmode) || int_size_in_bytes (TYPE) > 12)\n+#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\t\\\n+  ((TYPE_MODE (TYPE) == BLKmode)\t\t\t\t\t\t\\\n+   || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8)\t\\\n+   || (int_size_in_bytes (TYPE) > 12 && TYPE_MODE (TYPE) != TImode\t\t\\\n+       && ! VECTOR_MODE_P (TYPE_MODE (TYPE))))\n \n \f\n /* Define the classes of registers for register constraints in the\n@@ -914,6 +906,8 @@ enum reg_class\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n   FLOAT_REGS,\n+  SSE_REGS,\n+  MMX_REGS,\n   FLOAT_INT_REGS,\t\t/* FLOAT_REGS and GENERAL_REGS.  */\n   ALL_REGS, LIM_REG_CLASSES\n };\n@@ -936,26 +930,31 @@ enum reg_class\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n    \"FLOAT_REGS\",\t\t\t\\\n+   \"SSE_REGS\",\t\t\t\t\\\n+   \"MMX_REGS\",\t\t\t\t\\\n    \"FLOAT_INT_REGS\",\t\t\t\\\n    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n-{      {0},\t\t\t\t\t\t\t\\\n-     {0x1}, {0x2}, {0x4}, {0x8},/* AREG, DREG, CREG, BREG */\t\\\n-    {0x10},   {0x20},\t\t/* SIREG, DIREG */\t\t\\\n-     {0x3},\t\t\t/* AD_REGS */\t\t\t\\\n-     {0xf},\t\t\t/* Q_REGS */\t\t\t\\\n-{0x1100f0},\t\t\t/* NON_Q_REGS */\t\t\\\n-    {0x7f},\t\t\t/* INDEX_REGS */\t\t\\\n-{0x1100ff},\t\t\t/* GENERAL_REGS */\t\t\\\n-  {0x0100}, {0x0200},\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n-  {0xff00},\t\t\t/* FLOAT_REGS */\t\t\\\n-{0x11ffff},\t\t\t/* FLOAT_INT_REGS */\t\t\\\n-{0x17ffff}\t\t\t\t\t\t\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{     { 0x00,  0x0 },\t\t\t\t\t\t\t\\\n+      { 0x01,  0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n+      { 0x04,  0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n+      { 0x10,  0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n+      { 0x03,  0x0 },\t\t\t/* AD_REGS */\t\t\t\\\n+      { 0x0f,  0x0 },\t\t\t/* Q_REGS */\t\t\t\\\n+  { 0x1100f0,  0x0 },\t\t\t/* NON_Q_REGS */\t\t\\\n+      { 0x7f,  0x0 },\t\t\t/* INDEX_REGS */\t\t\\\n+  { 0x1100ff,  0x0 },\t\t\t/* GENERAL_REGS */\t\t\\\n+     { 0x100,  0x0 }, { 0x0200, 0x0 },\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n+    { 0xff00,  0x0 },\t\t\t/* FLOAT_REGS */\t\t\\\n+{ 0x1fe00000,  0x0 },\t\t\t/* SSE_REGS */\t\t\t\\\n+{ 0xe0000000, 0x1f },\t\t\t/* MMX_REGS */\t\t\t\\\n+   { 0x1ffff,  0x0 },\t\t\t/* FLOAT_INT_REGS */\t\t\\\n+{ 0xffffffff, 0x1f }\t\t\t\t\t\t\t\\\n }\n \n /* The same information, inverted:\n@@ -978,6 +977,11 @@ enum reg_class\n \n #define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))\n #define FP_REGNO_P(n) ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG)\n+\n+#define SSE_REGNO_P(n) ((n) >= FIRST_SSE_REG && (n) <= LAST_SSE_REG)\n+\n+#define MMX_REGNO_P(n) ((n) >= FIRST_MMX_REG && (n) <= LAST_MMX_REG)\n+#define MMX_REG_P(xop) (REG_P (xop) && MMX_REGNO_P (REGNO (xop)))\n   \n #define STACK_REG_P(xop) (REG_P (xop) &&\t\t       \t\\\n \t\t\t  REGNO (xop) >= FIRST_STACK_REG &&\t\\\n@@ -1013,6 +1017,8 @@ enum reg_class\n    (C) == 'b' ? BREG :\t\t\t\t\t\t\\\n    (C) == 'c' ? CREG :\t\t\t\t\t\t\\\n    (C) == 'd' ? DREG :\t\t\t\t\t\t\\\n+   (C) == 'x' ? SSE_REGS :\t\t\t\t\t\\\n+   (C) == 'y' ? MMX_REGS :\t\t\t\t\t\\\n    (C) == 'A' ? AD_REGS :\t\t\t\t\t\\\n    (C) == 'D' ? DIREG :\t\t\t\t\t\t\\\n    (C) == 'S' ? SIREG : NO_REGS)\n@@ -1079,9 +1085,11 @@ enum reg_class\n \n /* If we are copying between general and FP registers, we need a memory\n    location.  */\n-\n+/* The same is true for SSE and MMX registers.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n-  (FLOAT_CLASS_P (CLASS1) != FLOAT_CLASS_P (CLASS2))\n+  (FLOAT_CLASS_P (CLASS1) != FLOAT_CLASS_P (CLASS2) \\\n+   || ((CLASS1 == SSE_REGS) != (CLASS2 == SSE_REGS)) \\\n+   || ((CLASS1 == MMX_REGS) != (CLASS2 == MMX_REGS) && (MODE) != SImode))\n \n /* QImode spills from non-QI registers need a scratch.  This does not\n    happen often -- the only example so far requires an uninitialized \n@@ -1094,9 +1102,10 @@ enum reg_class\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 80386, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- (FLOAT_CLASS_P (CLASS) ? 1 :\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+ (FLOAT_CLASS_P (CLASS) || (CLASS) == SSE_REGS || (CLASS) == MMX_REGS\t\\\n+  ? 1\t\t\t\t\t\t\t\t\t\\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* A C expression whose value is nonzero if pseudos that have been\n    assigned to registers of class CLASS would likely be spilled\n@@ -1178,6 +1187,34 @@ enum reg_class\n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n \n+/* Define this macro if functions should assume that stack space has been\n+   allocated for arguments even when their values are passed in registers.\n+\n+   The value of this macro is the size, in bytes, of the area reserved for\n+   arguments passed in registers for the function represented by FNDECL.\n+\n+   This space can be allocated by the caller, or be a part of the\n+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says\n+   which.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) 0\n+\n+/* Define as a C expression that evaluates to nonzero if we do not know how\n+   to pass TYPE solely in registers.  The file expr.h defines a\n+   definition that is usually appropriate, refer to expr.h for additional\n+   documentation. If `REG_PARM_STACK_SPACE' is defined, the argument will be\n+   computed in the stack and then loaded into a register.  */\n+#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n+       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n+       || ((MODE) == TImode)\t\t\t\t\\\n+       || ((MODE) == BLKmode \t\t\t\t\\\n+\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n+\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n+\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n+\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n+\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n+\n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),\n@@ -1231,6 +1268,9 @@ typedef struct ix86_args {\n   int words;\t\t\t/* # words passed so far */\n   int nregs;\t\t\t/* # registers available for passing */\n   int regno;\t\t\t/* next available register number */\n+  int sse_words;\t\t/* # sse words passed so far */\n+  int sse_nregs;\t\t/* # sse registers available for passing */\n+  int sse_regno;\t\t/* next available sse register number */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2060,11 +2100,15 @@ while (0)\n    arbitary high cost.\n  */\n \n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\t\\\n-  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\t\\\n-   ? (MEMORY_MOVE_COST (DFmode, CLASS1, 0)\t\t\t\t\\\n-     + MEMORY_MOVE_COST (DFmode, CLASS2, 1))\t\t\t\t\\\n-   : (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)) ? 10 : 2)\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n+  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\\\n+   ? (MEMORY_MOVE_COST (DFmode, CLASS1, 0)\t\t\t\\\n+     + MEMORY_MOVE_COST (DFmode, CLASS2, 1))\t\t\t\\\n+   : (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)) ? 10\t\\\n+   : ((CLASS1) == MMX_REGS && (CLASS2) == SSE_REGS) ? 10\t\\\n+   : ((CLASS1) == SSE_REGS && (CLASS2) == MMX_REGS) ? 10\t\\\n+   : ((CLASS1) == MMX_REGS) != ((CLASS2) == MMX_REGS) ? 3\t\\\n+   : 2)\n \n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n@@ -2239,6 +2283,14 @@ while (0)\n  \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n  \"flags\",\"fpsr\", \"dirflag\", \"frame\" }\n \n+#undef  HI_REGISTER_NAMES\t\t\t\t\t\t\n+#define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n+{\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n+ \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n+ \"flags\",\"fpsr\", \"dirflag\", \"frame\",\t\t\t\t\t\\\n+ \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\",\t\t\\\n+ \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"\t}\n+\n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n /* Table of additional register names to use in user input.  */\n@@ -2247,7 +2299,9 @@ while (0)\n { { \"eax\", 0 }, { \"edx\", 1 }, { \"ecx\", 2 }, { \"ebx\", 3 },\t\\\n   { \"esi\", 4 }, { \"edi\", 5 }, { \"ebp\", 6 }, { \"esp\", 7 },\t\\\n   { \"al\", 0 }, { \"dl\", 1 }, { \"cl\", 2 }, { \"bl\", 3 },\t\t\\\n-  { \"ah\", 0 }, { \"dh\", 1 }, { \"ch\", 2 }, { \"bh\", 3 } }\n+  { \"ah\", 0 }, { \"dh\", 1 }, { \"ch\", 2 }, { \"bh\", 3 },\t\t\\\n+  { \"mm0\", 8},  { \"mm1\", 9},  { \"mm2\", 10}, { \"mm3\", 11},\t\\\n+  { \"mm4\", 12}, { \"mm5\", 13}, { \"mm6\", 14}, { \"mm7\", 15} }\n \n /* Note we are omitting these since currently I don't know how\n to get gcc to use these, since they want the same but different\n@@ -2267,6 +2321,9 @@ number as al, and ax.\n #define QI_HIGH_REGISTER_NAMES \\\n {\"ah\", \"dh\", \"ch\", \"bh\", }\n \n+#define MMX_REGISTER_NAMES \\\n+{0,0,0,0,0,0,0,0,\"mm0\",\"mm1\",\"mm2\",\"mm3\",\"mm4\",\"mm5\",\"mm6\",\"mm7\"}\n+\n /* How to renumber registers for dbx and gdb.  */\n \n #define DBX_REGISTER_NUMBER(n)  dbx_register_map[n]"}, {"sha": "9ba9ea9b1e54826024d0a09d0511c8c7edc0b326", "filename": "gcc/config/i386/i386elf.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fi386elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386elf.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -39,7 +39,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #undef RETURN_IN_MEMORY\n #define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode)\n+  (TYPE_MODE (TYPE) == BLKmode \\\n+   || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8))\n \n /* This used to define X86, but james@bigtex.cactus.org says that\n    is supposed to be defined optionally by user programs--not by default.  */"}, {"sha": "c7bf8f85d23d8876ce1f75c189721705b0170c03", "filename": "gcc/config/i386/ptx4-i.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fptx4-i.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -34,7 +34,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef RETURN_IN_MEMORY\n #define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode)\n+  (TYPE_MODE (TYPE) == BLKmode \\\n+   || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8))\n \n /* Define which macros to predefine.  _SEQUENT_ is our extension.  */\n /* This used to define X86, but james@bigtex.cactus.org says that"}, {"sha": "2c0d0188a1b035f345f935548cd4b410a49f0df9", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -32,7 +32,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef RETURN_IN_MEMORY\n #define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode)\n+  (TYPE_MODE (TYPE) == BLKmode \\\n+   || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8))\n \n /* Define which macros to predefine.  __svr4__ is our extension.  */\n /* This used to define X86, but james@bigtex.cactus.org says that"}, {"sha": "21fac84f6e74f047f848be5153df1230128e6f7c", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7180f707a9154ba5c40caa8d5b805f7848dadd6/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=a7180f707a9154ba5c40caa8d5b805f7848dadd6", "patch": "@@ -73,7 +73,9 @@ Boston, MA 02111-1307, USA.  */\n \n #define VALUE_REGNO(MODE) \\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-   && TARGET_FLOAT_RETURNS_IN_80387 ? FIRST_FLOAT_REG : 0)\n+   && TARGET_FLOAT_RETURNS_IN_80387 ? FIRST_FLOAT_REG\t\t\\\n+   : (MODE) == TImode || VECTOR_MODE_P (MODE) ? FIRST_SSE_REG\t\\\n+   : 0)\n \n /* 1 if N is a possible register number for a function value. */\n "}]}