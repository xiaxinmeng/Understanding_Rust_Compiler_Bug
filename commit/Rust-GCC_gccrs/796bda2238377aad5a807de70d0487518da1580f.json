{"sha": "796bda2238377aad5a807de70d0487518da1580f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk2YmRhMjIzODM3N2FhZDVhODA3ZGU3MGQwNDg3NTE4ZGExNTgwZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-15T17:11:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-15T17:11:00Z"}, "message": "invoke.texi (max-early-inliner-iterations): New flag.\n\n\n\t* doc/invoke.texi (max-early-inliner-iterations): New flag.\n\t* ipa-inline.c (enum inlining_mode): New INLINE_SIZE_NORECURSIVE.\n\t(try_inline): Fix return value.\n\t(cgraph_decide_inlining_incrementally): Honor new value.\n\t(cgraph_early_inlining): Handle indirect inlining.\n\t* params.def (PARAM_EARLY_INLINER_MAX_ITERATIONS): New.\n\n\t* testsuite/gcc.dg/tree-ssa/inline-3.c: New testcase\n\nFrom-SVN: r147587", "tree": {"sha": "2497e05beec85606936132146b62b04ea933c0e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2497e05beec85606936132146b62b04ea933c0e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/796bda2238377aad5a807de70d0487518da1580f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796bda2238377aad5a807de70d0487518da1580f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/796bda2238377aad5a807de70d0487518da1580f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/796bda2238377aad5a807de70d0487518da1580f/comments", "author": null, "committer": null, "parents": [{"sha": "d88e5c37254630f5b3e1638aa2910bfd1e0fd030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88e5c37254630f5b3e1638aa2910bfd1e0fd030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88e5c37254630f5b3e1638aa2910bfd1e0fd030"}], "stats": {"total": 199, "additions": 133, "deletions": 66}, "files": [{"sha": "fa3be0d76e7caf545f0a13e322295c2dded737b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -1,3 +1,12 @@\n+2009-05-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* doc/invoke.texi (max-early-inliner-iterations): New flag.\n+\t* ipa-inline.c (enum inlining_mode): New INLINE_SIZE_NORECURSIVE.\n+\t(try_inline): Fix return value.\n+\t(cgraph_decide_inlining_incrementally): Honor new value.\n+\t(cgraph_early_inlining): Handle indirect inlining.\n+\t* params.def (PARAM_EARLY_INLINER_MAX_ITERATIONS): New.\n+\n 2009-05-15  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (struct cgraph_node): Add finalized_by_frotnend flag."}, {"sha": "89d9b69bba67abaeb6f6abe93aa2a345b78ec3d7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -7485,6 +7485,12 @@ whose probability exceeds given threshold (in percents).  The default value is\n Specify growth that early inliner can make.  In effect it increases amount of\n inlining for code having large abstraction penalty.  The default value is 12.\n \n+@item max-early-inliner-iterations\n+@itemx max-early-inliner-iterations\n+Limit of iterations of early inliner.  This basically bounds number of nested\n+indirect calls early inliner can resolve.  Deeper chains are still handled by\n+late inlining.\n+\n @item min-vect-loop-bound\n The minimum number of iterations under which a loop will not get vectorized\n when @option{-ftree-vectorize} is used.  The number of iterations after"}, {"sha": "c8cb498109b75872df53e39514ff5491050cb1aa", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 77, "deletions": 66, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -152,6 +152,7 @@ along with GCC; see the file COPYING3.  If not see\n enum inlining_mode {\n   INLINE_NONE = 0,\n   INLINE_ALWAYS_INLINE,\n+  INLINE_SIZE_NORECURSIVE,\n   INLINE_SIZE,\n   INLINE_ALL\n };\n@@ -1269,6 +1270,7 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n   struct cgraph_node *callee = e->callee;\n   enum inlining_mode callee_mode = (enum inlining_mode) (size_t) callee->aux;\n   bool always_inline = e->callee->local.disregard_inline_limits;\n+  bool inlined = false;\n \n   /* We've hit cycle?  */\n   if (callee_mode)\n@@ -1323,9 +1325,10 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n \n       if (mode == INLINE_ALL || always_inline)\n \tcgraph_decide_inlining_incrementally (e->callee, mode, depth + 1);\n+      inlined = true;\n     }\n   callee->aux = (void *)(size_t) callee_mode;\n-  return true;\n+  return inlined;\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n@@ -1348,7 +1351,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \n   old_mode = (enum inlining_mode) (size_t)node->aux;\n \n-  if (mode != INLINE_ALWAYS_INLINE\n+  if (mode != INLINE_ALWAYS_INLINE && mode != INLINE_SIZE_NORECURSIVE\n       && lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n     {\n       if (dump_file)\n@@ -1362,69 +1365,70 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n   node->aux = (void *)(size_t) mode;\n \n   /* First of all look for always inline functions.  */\n-  for (e = node->callees; e; e = e->next_callee)\n-    {\n-      if (!e->callee->local.disregard_inline_limits\n-\t  && (mode != INLINE_ALL || !e->callee->local.inlinable))\n-\tcontinue;\n-      if (gimple_call_cannot_inline_p (e->call_stmt))\n-\tcontinue;\n-      /* When the edge is already inlined, we just need to recurse into\n-\t it in order to fully flatten the leaves.  */\n-      if (!e->inline_failed && mode == INLINE_ALL)\n-\t{\n-          inlined |= try_inline (e, mode, depth);\n-\t  continue;\n-\t}\n-      if (dump_file)\n-\t{\n-\t  indent_to (dump_file, depth);\n-\t  fprintf (dump_file,\n-\t\t   \"Considering to always inline inline candidate %s.\\n\",\n-\t\t   cgraph_node_name (e->callee));\n-\t}\n-      if (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      indent_to (dump_file, depth);\n-\t      fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n-\t    }\n-\t  continue;\n-\t}\n-      if (!tree_can_inline_p (node->decl, e->callee->decl))\n-\t{\n-\t  gimple_call_set_cannot_inline (e->call_stmt, true);\n-\t  if (dump_file)\n-\t    {\n-\t      indent_to (dump_file, depth);\n-\t      fprintf (dump_file,\n-\t\t       \"Not inlining: Target specific option mismatch.\\n\");\n-\t    }\n-\t  continue;\n-\t}\n-      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      indent_to (dump_file, depth);\n-\t      fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n-\t    }\n+  if (mode != INLINE_SIZE_NORECURSIVE)\n+    for (e = node->callees; e; e = e->next_callee)\n+      {\n+\tif (!e->callee->local.disregard_inline_limits\n+\t    && (mode != INLINE_ALL || !e->callee->local.inlinable))\n \t  continue;\n-\t}\n-      if (!e->callee->analyzed && !e->callee->inline_decl)\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      indent_to (dump_file, depth);\n-\t      fprintf (dump_file,\n-\t\t       \"Not inlining: Function body no longer available.\\n\");\n-\t    }\n+\tif (gimple_call_cannot_inline_p (e->call_stmt))\n \t  continue;\n-\t}\n-      inlined |= try_inline (e, mode, depth);\n-    }\n+\t/* When the edge is already inlined, we just need to recurse into\n+\t   it in order to fully flatten the leaves.  */\n+\tif (!e->inline_failed && mode == INLINE_ALL)\n+\t  {\n+\t    inlined |= try_inline (e, mode, depth);\n+\t    continue;\n+\t  }\n+\tif (dump_file)\n+\t  {\n+\t    indent_to (dump_file, depth);\n+\t    fprintf (dump_file,\n+\t\t     \"Considering to always inline inline candidate %s.\\n\",\n+\t\t     cgraph_node_name (e->callee));\n+\t  }\n+\tif (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file, \"Not inlining: recursive call.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (!tree_can_inline_p (node->decl, e->callee->decl))\n+\t  {\n+\t    gimple_call_set_cannot_inline (e->call_stmt, true);\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: Target specific option mismatch.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t    != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (!e->callee->analyzed && !e->callee->inline_decl)\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: Function body no longer available.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n+\tinlined |= try_inline (e, mode, depth);\n+      }\n \n   /* Now do the automatic inlining.  */\n   if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE)\n@@ -1459,7 +1463,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t/* When the function body would grow and inlining the function won't\n \t   eliminate the need for offline copy of the function, don't inline.\n \t */\n-\tif ((mode == INLINE_SIZE\n+\tif (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n \t     || (!flag_inline_functions\n \t\t && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n \t    && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n@@ -1531,15 +1535,22 @@ cgraph_early_inlining (void)\n {\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n   unsigned int todo = 0;\n+  int iterations = 0;\n \n   if (sorrycount || errorcount)\n     return 0;\n-  if (cgraph_decide_inlining_incrementally (node, INLINE_SIZE, 0))\n+  while (cgraph_decide_inlining_incrementally (node,\n+  \t\t\t\t\t       iterations\n+\t\t\t\t\t       ? INLINE_SIZE_NORECURSIVE : INLINE_SIZE, 0)\n+\t && iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS))\n     {\n       timevar_push (TV_INTEGRATION);\n-      todo = optimize_inline_calls (current_function_decl);\n+      todo |= optimize_inline_calls (current_function_decl);\n+      iterations++;\n       timevar_pop (TV_INTEGRATION);\n     }\n+  if (dump_file)\n+    fprintf (dump_file, \"Iterations: %i\\n\", iterations);\n   cfun->always_inline_functions_inlined = true;\n   return todo;\n }"}, {"sha": "9b5db87d7eba210bdd04cf6014d20790f0b5690c", "filename": "gcc/params.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -139,6 +139,14 @@ DEFPARAM (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY,\n \t  \"Inline recursively only when the probability of call being executed exceeds the parameter\",\n \t  10, 0, 0)\n \n+/* Limit of iterations of early inliner.  This basically bounds number of\n+   nested indirect calls early inliner can resolve.  Deeper chains are still\n+   handled by late inlining.  */\n+DEFPARAM (PARAM_EARLY_INLINER_MAX_ITERATIONS,\n+\t  \"max-early-inliner-iterations\",\n+\t  \"The maximum number of nested indirect inlining performed by early inliner\",\n+\t  10, 0, 0)\n+\n /* Limit the number of expansions created by the variable expansion\n    optimization to avoid register pressure.  */\n DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,"}, {"sha": "f1ff5d5c100497a1137635b6ccf4d3ce5a59fe4d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -1,3 +1,7 @@\n+2009-05-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* testsuite/gcc.dg/tree-ssa/inline-3.c: New testcase\n+\n 2009-05-15  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.target/i386/align-main-1.c (check): Mark noinline."}, {"sha": "5132aa3d69eaef8a80845d3db21dde9dc3667251", "filename": "gcc/testsuite/gcc.dg/tree-ssa/inline-3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/796bda2238377aad5a807de70d0487518da1580f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/796bda2238377aad5a807de70d0487518da1580f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Finline-3.c?ref=796bda2238377aad5a807de70d0487518da1580f", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-einline2\" } */\n+extern void inlined ();\n+void inline_me_too (void);\n+void inline_through_me (void (*ptr)(void));\n+void\n+inline_me (void)\n+{\n+  inlined();\n+}\n+\n+void main(void)\n+{\n+  inline_through_me (inline_me);\n+  inline_through_me (inline_me_too);\n+}\n+void\n+inline_through_me (void (*ptr)(void))\n+{\n+  ptr();\n+}\n+\n+void\n+inline_me_too (void)\n+{\n+  inlined();\n+}\n+/* { dg-final { scan-tree-dump-times \"Inlining inline_me \" 1 \"einline2\"} } */\n+/* { dg-final { scan-tree-dump-times \"Inlining inline_me_too \" 1 \"einline2\"} } */"}]}