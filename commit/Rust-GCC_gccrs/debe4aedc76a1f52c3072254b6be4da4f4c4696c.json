{"sha": "debe4aedc76a1f52c3072254b6be4da4f4c4696c", "node_id": "C_kwDOANBUbNoAKGRlYmU0YWVkYzc2YTFmNTJjMzA3MjI1NGI2YmU0ZGE0ZjRjNDY5NmM", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-13T18:20:31Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:28Z"}, "message": "rust-constexpr.cc: port over potential_constant_expression_1()", "tree": {"sha": "87d1a8c0c30643cbc28b9bf85f47b542f948bdcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87d1a8c0c30643cbc28b9bf85f47b542f948bdcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/debe4aedc76a1f52c3072254b6be4da4f4c4696c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debe4aedc76a1f52c3072254b6be4da4f4c4696c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debe4aedc76a1f52c3072254b6be4da4f4c4696c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debe4aedc76a1f52c3072254b6be4da4f4c4696c/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "533effe0f3f49c144df3e1a918f422d2982d21bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533effe0f3f49c144df3e1a918f422d2982d21bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533effe0f3f49c144df3e1a918f422d2982d21bf"}], "stats": {"total": 1662, "additions": 1646, "deletions": 16}, "files": [{"sha": "5ac12d2ec6a2797b5b7baedcdd8bf84da2eeb6da", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 1328, "deletions": 14, "changes": 1342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=debe4aedc76a1f52c3072254b6be4da4f4c4696c", "patch": "@@ -33,6 +33,7 @@\n #include \"rust-target.h\"\n #include \"function.h\"\n #include \"builtins.h\"\n+#include \"diagnostic.h\"\n \n #define VERIFY_CONSTANT(X)                                                     \\\n   do                                                                           \\\n@@ -75,13 +76,17 @@ static HOST_WIDE_INT\n find_array_ctor_elt (tree ary, tree dindex, bool insert = false);\n static int\n array_index_cmp (tree key, tree index);\n+static bool\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n+\t\t\t\t tsubst_flags_t flags, tree *jump_target);\n+bool\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n+\t\t\t\t tsubst_flags_t flags);\n inline tree\n get_nth_callarg (tree t, int n);\n tree\n unshare_constructor (tree t MEM_STAT_DECL);\n void\n-explain_invalid_constexpr_fn (tree fun);\n-void\n maybe_save_constexpr_fundef (tree fun);\n \n struct constexpr_global_ctx\n@@ -334,10 +339,6 @@ uid_sensitive_constexpr_evaluation_checker::evaluation_restricted_p () const\n \n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n-static tree\n-constexp_expression (const constexpr_ctx *, tree, bool, bool *, bool *,\n-\t\t     tree * = NULL);\n-\n /* Compute a hash value for a constexpr call representation.  */\n \n inline hashval_t\n@@ -1586,6 +1587,10 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t  return eval_constant_expression (ctx, r, lval, non_constant_p,\n \t\t\t\t\t   overflow_p);\n \t}\n+      else\n+\tr = DECL_VALUE_EXPR (t);\n+      return eval_constant_expression (ctx, r, lval, non_constant_p,\n+\t\t\t\t       overflow_p);\n \n     case PARM_DECL:\n       if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n@@ -1680,7 +1685,7 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\terror (\"temporary of non-literal type %qT in a \"\n \t\t       \"constant expression\",\n \t\t       type);\n-\t\t// explain_non_literal_class (type);\n+\t\texplain_non_literal_class (type);\n \t      }\n \t    *non_constant_p = true;\n \t    break;\n@@ -1815,7 +1820,7 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-\n+      /* FALLTHROUGH.  */\n     case MODIFY_EXPR:\n       r = eval_store_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n@@ -3267,6 +3272,281 @@ eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   return result;\n }\n \n+/* Subroutine of build_data_member_initialization.  MEMBER is a COMPONENT_REF\n+   for a member of an anonymous aggregate, INIT is the initializer for that\n+   member, and VEC_OUTER is the vector of constructor elements for the class\n+   whose constructor we are processing.  Add the initializer to the vector\n+   and return true to indicate success.  */\n+\n+static bool\n+build_anon_member_initialization (tree member, tree init,\n+\t\t\t\t  vec<constructor_elt, va_gc> **vec_outer)\n+{\n+  /* MEMBER presents the relevant fields from the inside out, but we need\n+     to build up the initializer from the outside in so that we can reuse\n+     previously built CONSTRUCTORs if this is, say, the second field in an\n+     anonymous struct.  So we use a vec as a stack.  */\n+  auto_vec<tree, 2> fields;\n+  do\n+    {\n+      fields.safe_push (TREE_OPERAND (member, 1));\n+      member = TREE_OPERAND (member, 0);\n+    }\n+  while (ANON_AGGR_TYPE_P (TREE_TYPE (member))\n+\t && TREE_CODE (member) == COMPONENT_REF);\n+\n+  /* VEC has the constructor elements vector for the context of FIELD.\n+     If FIELD is an anonymous aggregate, we will push inside it.  */\n+  vec<constructor_elt, va_gc> **vec = vec_outer;\n+  tree field;\n+  while (field = fields.pop (), ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+    {\n+      tree ctor;\n+      /* If there is already an outer constructor entry for the anonymous\n+\t aggregate FIELD, use it; otherwise, insert one.  */\n+      if (vec_safe_is_empty (*vec) || (*vec)->last ().index != field)\n+\t{\n+\t  ctor = build_constructor (TREE_TYPE (field), NULL);\n+\t  CONSTRUCTOR_APPEND_ELT (*vec, field, ctor);\n+\t}\n+      else\n+\tctor = (*vec)->last ().value;\n+      vec = &CONSTRUCTOR_ELTS (ctor);\n+    }\n+\n+  /* Now we're at the innermost field, the one that isn't an anonymous\n+     aggregate.  Add its initializer to the CONSTRUCTOR and we're done.  */\n+  gcc_assert (fields.is_empty ());\n+  CONSTRUCTOR_APPEND_ELT (*vec, field, init);\n+\n+  return true;\n+}\n+\n+/* V is a vector of constructor elements built up for the base and member\n+   initializers of a constructor for TYPE.  They need to be in increasing\n+   offset order, which they might not be yet if TYPE has a primary base\n+   which is not first in the base-clause or a vptr and at least one base\n+   all of which are non-primary.  */\n+\n+static vec<constructor_elt, va_gc> *\n+sort_constexpr_mem_initializers (tree type, vec<constructor_elt, va_gc> *v)\n+{\n+  tree pri = CLASSTYPE_PRIMARY_BINFO (type);\n+  tree field_type;\n+  unsigned i;\n+  constructor_elt *ce;\n+\n+  if (pri)\n+    field_type = BINFO_TYPE (pri);\n+  else if (TYPE_CONTAINS_VPTR_P (type))\n+    field_type = vtbl_ptr_type_node;\n+  else\n+    return v;\n+\n+  /* Find the element for the primary base or vptr and move it to the\n+     beginning of the vec.  */\n+  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+    if (TREE_TYPE (ce->index) == field_type)\n+      break;\n+\n+  if (i > 0 && i < vec_safe_length (v))\n+    {\n+      vec<constructor_elt, va_gc> &vref = *v;\n+      constructor_elt elt = vref[i];\n+      for (; i > 0; --i)\n+\tvref[i] = vref[i - 1];\n+      vref[0] = elt;\n+    }\n+\n+  return v;\n+}\n+\n+/* Subroutine of  build_constexpr_constructor_member_initializers.\n+   The expression tree T represents a data member initialization\n+   in a (constexpr) constructor definition.  Build a pairing of\n+   the data member with its initializer, and prepend that pair\n+   to the existing initialization pair INITS.  */\n+\n+static bool\n+build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n+{\n+  tree member, init;\n+  if (TREE_CODE (t) == CLEANUP_POINT_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == EXPR_STMT)\n+    t = TREE_OPERAND (t, 0);\n+  if (t == error_mark_node)\n+    return false;\n+  if (TREE_CODE (t) == STATEMENT_LIST)\n+    {\n+      for (tree stmt : tsi_range (t))\n+\tif (!build_data_member_initialization (stmt, vec))\n+\t  return false;\n+      return true;\n+    }\n+  if (TREE_CODE (t) == CONVERT_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == INIT_EXPR\n+      /* vptr initialization shows up as a MODIFY_EXPR.  In C++14 we only\n+\t use what this function builds for cx_check_missing_mem_inits, and\n+\t assignment in the ctor body doesn't count.  */\n+      || (TREE_CODE (t) == MODIFY_EXPR))\n+    {\n+      member = TREE_OPERAND (t, 0);\n+      // Faisal: not sure if we need to port over break_out_target_exprs\n+      // if not, then not sure how to handle init in this case\n+      // init = break_out_target_exprs (TREE_OPERAND (t, 1));\n+    }\n+  else if (TREE_CODE (t) == CALL_EXPR)\n+    {\n+      tree fn = get_callee_fndecl (t);\n+      if (!fn || !DECL_CONSTRUCTOR_P (fn))\n+\t/* We're only interested in calls to subobject constructors.  */\n+\treturn true;\n+      member = CALL_EXPR_ARG (t, 0);\n+      /* We don't use build_cplus_new here because it complains about\n+\t abstract bases.  Leaving the call unwrapped means that it has the\n+\t wrong type, but cxx_eval_constant_expression doesn't care.  */\n+      // Faisal: not sure if we need to port over break_out_target_exprs\n+      // if not, then not sure how to handle init in this case\n+      // init = break_out_target_exprs (t);\n+    }\n+  else if (TREE_CODE (t) == BIND_EXPR)\n+    return build_data_member_initialization (BIND_EXPR_BODY (t), vec);\n+  else\n+    /* Don't add anything else to the CONSTRUCTOR.  */\n+    return true;\n+  if (INDIRECT_REF_P (member))\n+    member = TREE_OPERAND (member, 0);\n+  if (TREE_CODE (member) == NOP_EXPR)\n+    {\n+      tree op = member;\n+      STRIP_NOPS (op);\n+      if (TREE_CODE (op) == ADDR_EXPR)\n+\t{\n+\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p (\n+\t    TREE_TYPE (TREE_TYPE (op)), TREE_TYPE (TREE_TYPE (member))));\n+\t  /* Initializing a cv-qualified member; we need to look through\n+\t     the const_cast.  */\n+\t  member = op;\n+\t}\n+      else if (op == current_class_ptr\n+\t       && (same_type_ignoring_top_level_qualifiers_p (\n+\t\t TREE_TYPE (TREE_TYPE (member)), current_class_type)))\n+\t/* Delegating constructor.  */\n+\tmember = op;\n+      else\n+\t{\n+\t  /* This is an initializer for an empty base; keep it for now so\n+\t     we can check it in cxx_eval_bare_aggregate.  */\n+\t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (member))));\n+\t}\n+    }\n+  if (TREE_CODE (member) == ADDR_EXPR)\n+    member = TREE_OPERAND (member, 0);\n+  if (TREE_CODE (member) == COMPONENT_REF)\n+    {\n+      tree aggr = TREE_OPERAND (member, 0);\n+      if (TREE_CODE (aggr) == VAR_DECL)\n+\t/* Initializing a local variable, don't add anything.  */\n+\treturn true;\n+      if (TREE_CODE (aggr) != COMPONENT_REF)\n+\t/* Normal member initialization.  */\n+\tmember = TREE_OPERAND (member, 1);\n+      else if (ANON_AGGR_TYPE_P (TREE_TYPE (aggr)))\n+\t/* Initializing a member of an anonymous union.  */\n+\treturn build_anon_member_initialization (member, init, vec);\n+      else\n+\t/* We're initializing a vtable pointer in a base.  Leave it as\n+\t   COMPONENT_REF so we remember the path to get to the vfield.  */\n+\tgcc_assert (TREE_TYPE (member) == vtbl_ptr_type_node);\n+    }\n+\n+  /* Value-initialization can produce multiple initializers for the\n+     same field; use the last one.  */\n+  if (!vec_safe_is_empty (*vec) && (*vec)->last ().index == member)\n+    (*vec)->last ().value = init;\n+  else\n+    CONSTRUCTOR_APPEND_ELT (*vec, member, init);\n+  return true;\n+}\n+\n+/* Build compile-time evalable representations of member-initializer list\n+   for a constexpr constructor.  */\n+\n+static tree\n+build_constexpr_constructor_member_initializers (tree type, tree body)\n+{\n+  vec<constructor_elt, va_gc> *vec = NULL;\n+  bool ok = true;\n+  while (true)\n+    switch (TREE_CODE (body))\n+      {\n+      case STATEMENT_LIST:\n+\tfor (tree stmt : tsi_range (body))\n+\t  {\n+\t    body = stmt;\n+\t    if (TREE_CODE (body) == BIND_EXPR)\n+\t      break;\n+\t  }\n+\tbreak;\n+\n+      case BIND_EXPR:\n+\tbody = BIND_EXPR_BODY (body);\n+\tgoto found;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+found:\n+\n+  if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n+    {\n+      body = TREE_OPERAND (body, 0);\n+      if (TREE_CODE (body) == EXPR_STMT)\n+\tbody = TREE_OPERAND (body, 0);\n+      if (TREE_CODE (body) == INIT_EXPR\n+\t  && (same_type_ignoring_top_level_qualifiers_p (\n+\t    TREE_TYPE (TREE_OPERAND (body, 0)), current_class_type)))\n+\t{\n+\t  /* Trivial copy.  */\n+\t  return TREE_OPERAND (body, 1);\n+\t}\n+      ok = build_data_member_initialization (body, &vec);\n+    }\n+  else if (TREE_CODE (body) == STATEMENT_LIST)\n+    {\n+      for (tree stmt : tsi_range (body))\n+\t{\n+\t  ok = build_data_member_initialization (stmt, &vec);\n+\t  if (!ok)\n+\t    break;\n+\t}\n+    }\n+  else if (EXPR_P (body))\n+    ok = build_data_member_initialization (body, &vec);\n+  else\n+    gcc_assert (errorcount > 0);\n+  if (ok)\n+    {\n+      if (vec_safe_length (vec) > 0)\n+\t{\n+\t  /* In a delegating constructor, return the target.  */\n+\t  constructor_elt *ce = &(*vec)[0];\n+\t  if (ce->index == current_class_ptr)\n+\t    {\n+\t      body = ce->value;\n+\t      vec_free (vec);\n+\t      return body;\n+\t    }\n+\t}\n+      vec = sort_constexpr_mem_initializers (type, vec);\n+      return build_constructor (type, vec);\n+    }\n+  else\n+    return error_mark_node;\n+}\n+\n // Subroutine of check_constexpr_fundef.  BODY is the body of a function\n // declared to be constexpr, or a sub-statement thereof.  Returns the\n // return value if suitable, error_mark_node for a statement not allowed in\n@@ -4655,8 +4935,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n bool\n is_static_init_expression (tree t)\n {\n-  // return potential_constant_expression_1 (t, false, false, true, tf_none);\n-  // faisal: just return false for now to make it compile\n+  return potential_constant_expression_1 (t, false, false, true, tf_none);\n }\n \n /* Like potential_constant_expression, but don't consider possible constexpr\n@@ -4669,8 +4948,7 @@ is_static_init_expression (tree t)\n bool\n is_constant_expression (tree t)\n {\n-  // return potential_constant_expression_1 (t, false, true, true, tf_none);\n-  // faisal: just return false for now to make it compile\n+  return potential_constant_expression_1 (t, false, true, true, tf_none);\n }\n \n /* Returns true if T is a potential static initializer expression that is not\n@@ -4810,11 +5088,1047 @@ maybe_constant_value (tree t, tree decl, bool manifestly_const_eval)\n bool\n potential_constant_expression (tree t)\n {\n-  // return potential_constant_expression_1 (t, false, true, false, tf_none);\n-  // Faisal: return false until we port above call to make the code compile\n+  return potential_constant_expression_1 (t, false, true, false, tf_none);\n+}\n+\n+/* Data structure for passing data from potential_constant_expression_1\n+   to check_for_return_continue via cp_walk_tree.  */\n+struct check_for_return_continue_data\n+{\n+  hash_set<tree> *pset;\n+  tree continue_stmt;\n+  tree break_stmt;\n+};\n+\n+/* Helper function for potential_constant_expression_1 SWITCH_STMT handling,\n+   called through cp_walk_tree.  Return the first RETURN_EXPR found, or note\n+   the first CONTINUE_STMT and/or BREAK_STMT if RETURN_EXPR is not found.  */\n+static tree\n+check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp, s, b;\n+  check_for_return_continue_data *d = (check_for_return_continue_data *) data;\n+  switch (TREE_CODE (t))\n+    {\n+    case RETURN_EXPR:\n+      return t;\n+\n+    case CONTINUE_STMT:\n+      if (d->continue_stmt == NULL_TREE)\n+\td->continue_stmt = t;\n+      break;\n+\n+    case BREAK_STMT:\n+      if (d->break_stmt == NULL_TREE)\n+\td->break_stmt = t;\n+      break;\n+\n+#define RECUR(x)                                                               \\\n+  if (tree r = rs_walk_tree (&x, check_for_return_continue, data, d->pset))    \\\n+  return r\n+\n+      /* For loops, walk subtrees manually, so that continue stmts found\n+\t inside of the bodies of the loops are ignored.  */\n+\n+    case WHILE_STMT:\n+      *walk_subtrees = 0;\n+      RECUR (WHILE_COND (t));\n+      s = d->continue_stmt;\n+      b = d->break_stmt;\n+      RECUR (WHILE_BODY (t));\n+      d->continue_stmt = s;\n+      d->break_stmt = b;\n+      break;\n+\n+    case FOR_STMT:\n+      *walk_subtrees = 0;\n+      RECUR (FOR_INIT_STMT (t));\n+      RECUR (FOR_COND (t));\n+      RECUR (FOR_EXPR (t));\n+      s = d->continue_stmt;\n+      b = d->break_stmt;\n+      RECUR (FOR_BODY (t));\n+      d->continue_stmt = s;\n+      d->break_stmt = b;\n+      break;\n+\n+    case RANGE_FOR_STMT:\n+      *walk_subtrees = 0;\n+      RECUR (RANGE_FOR_EXPR (t));\n+      s = d->continue_stmt;\n+      b = d->break_stmt;\n+      RECUR (RANGE_FOR_BODY (t));\n+      d->continue_stmt = s;\n+      d->break_stmt = b;\n+      break;\n+\n+    case SWITCH_STMT:\n+      *walk_subtrees = 0;\n+      RECUR (SWITCH_STMT_COND (t));\n+      b = d->break_stmt;\n+      RECUR (SWITCH_STMT_BODY (t));\n+      d->break_stmt = b;\n+      break;\n+#undef RECUR\n+\n+    case STATEMENT_LIST:\n+    case CONSTRUCTOR:\n+      break;\n+\n+    default:\n+      if (!EXPR_P (t))\n+\t*walk_subtrees = 0;\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the namespace that contains DECL, whether directly or\n+   indirectly.  */\n+\n+tree\n+decl_namespace_context (tree decl)\n+{\n+  while (1)\n+    {\n+      if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\treturn decl;\n+      else if (TYPE_P (decl))\n+\tdecl = CP_DECL_CONTEXT (TYPE_MAIN_DECL (decl));\n+      else\n+\tdecl = CP_DECL_CONTEXT (decl);\n+    }\n+}\n+\n+/* Returns true if DECL is in the std namespace.  */\n+\n+bool\n+decl_in_std_namespace_p (tree decl)\n+{\n+  while (decl)\n+    {\n+      decl = decl_namespace_context (decl);\n+      if (DECL_NAMESPACE_STD_P (decl))\n+\treturn true;\n+      /* Allow inline namespaces inside of std namespace, e.g. with\n+\t --enable-symvers=gnu-versioned-namespace std::forward would be\n+\t actually std::_8::forward.  */\n+      if (!DECL_NAMESPACE_INLINE_P (decl))\n+\treturn false;\n+      decl = CP_DECL_CONTEXT (decl);\n+    }\n   return false;\n }\n \n+/* Return true if FNDECL is std::construct_at.  */\n+\n+static inline bool\n+is_std_construct_at (tree fndecl)\n+{\n+  if (!decl_in_std_namespace_p (fndecl))\n+    return false;\n+\n+  tree name = DECL_NAME (fndecl);\n+  return name && id_equal (name, \"construct_at\");\n+}\n+\n+/* Return true if FNDECL is __dynamic_cast.  */\n+\n+static inline bool\n+cxx_dynamic_cast_fn_p (tree fndecl)\n+{\n+  return (id_equal (DECL_NAME (fndecl), \"__dynamic_cast\")\n+\t  && CP_DECL_CONTEXT (fndecl) == global_namespace);\n+}\n+\n+/* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */\n+\n+static inline bool\n+is_std_allocator_allocate (tree fndecl)\n+{\n+  tree name = DECL_NAME (fndecl);\n+  if (name == NULL_TREE\n+      || !(id_equal (name, \"allocate\") || id_equal (name, \"deallocate\")))\n+    return false;\n+\n+  tree ctx = DECL_CONTEXT (fndecl);\n+  if (ctx == NULL_TREE || !CLASS_TYPE_P (ctx) || !TYPE_MAIN_DECL (ctx))\n+    return false;\n+\n+  tree decl = TYPE_MAIN_DECL (ctx);\n+  name = DECL_NAME (decl);\n+  if (name == NULL_TREE || !id_equal (name, \"allocator\"))\n+    return false;\n+\n+  return decl_in_std_namespace_p (decl);\n+}\n+\n+/* Overload for the above taking constexpr_call*.  */\n+\n+static inline bool\n+is_std_allocator_allocate (const constexpr_call *call)\n+{\n+  return (call && call->fundef\n+\t  && is_std_allocator_allocate (call->fundef->decl));\n+}\n+\n+/* Return true if T denotes a potentially constant expression.  Issue\n+   diagnostic as appropriate under control of FLAGS.  If WANT_RVAL is true,\n+   an lvalue-rvalue conversion is implied.  If NOW is true, we want to\n+   consider the expression in the current context, independent of constexpr\n+   substitution.\n+\n+   C++0x [expr.const] used to say\n+\n+   6 An expression is a potential constant expression if it is\n+     a constant expression where all occurrences of function\n+     parameters are replaced by arbitrary constant expressions\n+     of the appropriate type.\n+\n+   2  A conditional expression is a constant expression unless it\n+      involves one of the following as a potentially evaluated\n+      subexpression (3.2), but subexpressions of logical AND (5.14),\n+      logical OR (5.15), and conditional (5.16) operations that are\n+      not evaluated are not considered.   */\n+\n+static bool\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n+\t\t\t\t tsubst_flags_t flags, tree *jump_target)\n+{\n+#define RECUR(T, RV)                                                           \\\n+  potential_constant_expression_1 ((T), (RV), strict, now, flags, jump_target)\n+\n+  enum\n+  {\n+    any = false,\n+    rval = true\n+  };\n+  int i;\n+  tree tmp;\n+\n+  if (t == error_mark_node)\n+    return false;\n+  if (t == NULL_TREE)\n+    return true;\n+  location_t loc = rs_expr_loc_or_input_loc (t);\n+\n+  if (*jump_target)\n+    /* If we are jumping, ignore everything.  This is simpler than the\n+       cxx_eval_constant_expression handling because we only need to be\n+       conservatively correct, and we don't necessarily have a constant value\n+       available, so we don't bother with switch tracking.  */\n+    return true;\n+\n+  if (TREE_THIS_VOLATILE (t) && want_rval)\n+    {\n+      if (flags & tf_error)\n+\terror_at (loc,\n+\t\t  \"lvalue-to-rvalue conversion of a volatile lvalue \"\n+\t\t  \"%qE with type %qT\",\n+\t\t  t, TREE_TYPE (t));\n+      return false;\n+    }\n+  if (CONSTANT_CLASS_P (t))\n+    return true;\n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPED)\n+      && TREE_TYPE (t) == error_mark_node)\n+    return false;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case FUNCTION_DECL:\n+    case OVERLOAD:\n+    case LABEL_DECL:\n+    case CASE_LABEL_EXPR:\n+    case PREDICT_EXPR:\n+    case CONST_DECL:\n+    case IDENTIFIER_NODE:\n+      /* We can see a FIELD_DECL in a pointer-to-member expression.  */\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+    case PLACEHOLDER_EXPR:\n+    case STATIC_ASSERT:\n+      return true;\n+\n+    case RETURN_EXPR:\n+      if (!RECUR (TREE_OPERAND (t, 0), any))\n+\treturn false;\n+      /* FALLTHROUGH */\n+\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      *jump_target = t;\n+      return true;\n+\n+    case PARM_DECL:\n+      if (now && want_rval)\n+\t{\n+\t  tree type = TREE_TYPE (t);\n+\t  if (is_really_empty_class (type, /*ignore_vptr*/ false))\n+\t    /* An empty class has no data to read.  */\n+\t    return true;\n+\t  if (flags & tf_error)\n+\t    error (\"%qE is not a constant expression\", t);\n+\t  return false;\n+\t}\n+      return true;\n+\n+    case CALL_EXPR:\n+      /* -- an invocation of a function other than a constexpr function\n+\t    or a constexpr constructor.  */\n+      {\n+\ttree fun = get_function_named_in_call (t);\n+\tconst int nargs = call_expr_nargs (t);\n+\ti = 0;\n+\n+\tif (fun == NULL_TREE)\n+\t  {\n+\t    /* Reset to allow the function to continue past the end\n+\t       of the block below.  Otherwise return early.  */\n+\t    bool bail = true;\n+\n+\t    if (TREE_CODE (t) == CALL_EXPR && CALL_EXPR_FN (t) == NULL_TREE)\n+\t      switch (CALL_EXPR_IFN (t))\n+\t\t{\n+\t\t/* These should be ignored, they are optimized away from\n+\t\t   constexpr functions.  */\n+\t\tcase IFN_UBSAN_NULL:\n+\t\tcase IFN_UBSAN_BOUNDS:\n+\t\tcase IFN_UBSAN_VPTR:\n+\t\tcase IFN_FALLTHROUGH:\n+\t\t  return true;\n+\n+\t\tcase IFN_ADD_OVERFLOW:\n+\t\tcase IFN_SUB_OVERFLOW:\n+\t\tcase IFN_MUL_OVERFLOW:\n+\t\tcase IFN_LAUNDER:\n+\t\tcase IFN_VEC_CONVERT:\n+\t\t  bail = false;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t    if (bail)\n+\t      {\n+\t\t/* fold_call_expr can't do anything with IFN calls.  */\n+\t\tif (flags & tf_error)\n+\t\t  error_at (loc, \"call to internal function %qE\", t);\n+\t\treturn false;\n+\t      }\n+\t  }\n+\n+\tif (fun && is_overloaded_fn (fun))\n+\t  {\n+\t    if (TREE_CODE (fun) == FUNCTION_DECL)\n+\t      {\n+\t\tif (builtin_valid_in_constant_expr_p (fun))\n+\t\t  return true;\n+\t\tif (!maybe_constexpr_fn (fun)\n+\t\t    /* Allow any built-in function; if the expansion\n+\t\t       isn't constant, we'll deal with that then.  */\n+\t\t    && !fndecl_built_in_p (fun)\n+\t\t    /* In C++20, replaceable global allocation functions\n+\t\t       are constant expressions.  */\n+\t\t    && (/* !cxx_replaceable_global_alloc_fn (fun)\n+\t\t\t||*/ TREE_CODE (t) != CALL_EXPR\n+\t\t\t|| (!CALL_FROM_NEW_OR_DELETE_P (t)\n+\t\t\t    && (current_function_decl == NULL_TREE\n+\t\t\t\t/*|| !is_std_allocator_allocate(current_function_decl)*/)))\n+\t\t    /* Allow placement new in std::construct_at.  */\n+\t\t    && (/*!cxx_placement_new_fn (fun)\n+\t\t\t||*/ TREE_CODE (t) != CALL_EXPR\n+\t\t\t|| current_function_decl == NULL_TREE\n+\t\t\t/*|| !is_std_construct_at (current_function_decl)*/)\n+\t\t  /*  && !cxx_dynamic_cast_fn_p (fun)*/)\n+\t\t  {\n+\t\t    if (flags & tf_error)\n+\t\t      {\n+\t\t\terror_at (loc, \"call to non-%<constexpr%> function %qD\",\n+\t\t\t\t  fun);\n+\t\t\texplain_invalid_constexpr_fn (fun);\n+\t\t      }\n+\t\t    return false;\n+\t\t  }\n+\t\t/* A call to a non-static member function takes the address\n+\t\t   of the object as the first argument.  But in a constant\n+\t\t   expression the address will be folded away, so look\n+\t\t   through it now.  */\n+\t\tif (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun)\n+\t\t    && !DECL_CONSTRUCTOR_P (fun))\n+\t\t  {\n+\t\t    tree x = get_nth_callarg (t, 0);\n+\n+\t\t    /* Don't require an immediately constant value, as\n+\t\t       constexpr substitution might not use the value.  */\n+\t\t    bool sub_now = false;\n+\t\t    if (!potential_constant_expression_1 (x, rval, strict,\n+\t\t\t\t\t\t\t  sub_now, flags,\n+\t\t\t\t\t\t\t  jump_target))\n+\t\t      return false;\n+\t\t    i = 1;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (!RECUR (fun, true))\n+\t\t  return false;\n+\t\tfun = get_first_fn (fun);\n+\t      }\n+\t    fun = DECL_ORIGIN (fun);\n+\t  }\n+\telse if (fun)\n+\t  {\n+\t    if (RECUR (fun, rval))\n+\t      /* Might end up being a constant function pointer.  */;\n+\t    else\n+\t      return false;\n+\t  }\n+\tfor (; i < nargs; ++i)\n+\t  {\n+\t    tree x = get_nth_callarg (t, i);\n+\t    /* In a template, reference arguments haven't been converted to\n+\t       REFERENCE_TYPE and we might not even know if the parameter\n+\t       is a reference, so accept lvalue constants too.  */\n+\t    bool rv = rval;\n+\t    /* Don't require an immediately constant value, as constexpr\n+\t       substitution might not use the value of the argument.  */\n+\t    bool sub_now = false;\n+\t    if (!potential_constant_expression_1 (x, rv, strict, sub_now, flags,\n+\t\t\t\t\t\t  jump_target))\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+\n+    case NON_LVALUE_EXPR:\n+      /* -- an lvalue-to-rvalue conversion (4.1) unless it is applied to\n+\t    -- an lvalue of integral type that refers to a non-volatile\n+\t       const variable or static data member initialized with\n+\t       constant expressions, or\n+\n+\t    -- an lvalue of literal type that refers to non-volatile\n+\t       object defined with constexpr, or that refers to a\n+\t       sub-object of such an object;  */\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n+    case VAR_DECL:\n+      if (DECL_HAS_VALUE_EXPR_P (t))\n+\t{\n+\t  return RECUR (DECL_VALUE_EXPR (t), rval);\n+\t}\n+      if (want_rval && !var_in_maybe_constexpr_fn (t)\n+\t  && !decl_maybe_constant_var_p (t)\n+\t  && (strict || !RS_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (t))\n+\t      || (DECL_INITIAL (t)\n+\t\t  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (t)))\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (t))\n+\t  && !is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/ false))\n+\t{\n+\t  if (flags & tf_error)\n+\t    non_const_var_error (loc, t);\n+\t  return false;\n+\t}\n+      return true;\n+\n+    case NOP_EXPR:\n+      if (REINTERPRET_CAST_P (t))\n+\t{\n+\t  if (flags & tf_error)\n+\t    error_at (loc, \"%<reinterpret_cast%> is not a constant expression\");\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+    case CONVERT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      /* -- a reinterpret_cast.  FIXME not implemented, and this rule\n+\t may change to something more specific to type-punning (DR 1312).  */\n+      {\n+\ttree from = TREE_OPERAND (t, 0);\n+\tif (location_wrapper_p (t))\n+\t  return (RECUR (from, want_rval));\n+\tif (INDIRECT_TYPE_P (TREE_TYPE (t)))\n+\t  {\n+\t    STRIP_ANY_LOCATION_WRAPPER (from);\n+\t    if (TREE_CODE (from) == INTEGER_CST && !integer_zerop (from))\n+\t      {\n+\t\tif (flags & tf_error)\n+\t\t  error_at (loc,\n+\t\t\t    \"%<reinterpret_cast%> from integer to pointer\");\n+\t\treturn false;\n+\t      }\n+\t  }\n+\treturn (RECUR (from, TREE_CODE (t) != VIEW_CONVERT_EXPR));\n+      }\n+\n+    case ADDR_EXPR:\n+      /* -- a unary operator & that is applied to an lvalue that\n+\t    designates an object with thread or automatic storage\n+\t    duration;  */\n+      t = TREE_OPERAND (t, 0);\n+\n+      if (TREE_CODE (t) == OFFSET_REF && PTRMEM_OK_P (t))\n+\t/* A pointer-to-member constant.  */\n+\treturn true;\n+\n+    handle_addr_expr:\n+#if 0\n+      /* FIXME adjust when issue 1197 is fully resolved.  For now don't do\n+         any checking here, as we might dereference the pointer later.  If\n+         we remove this code, also remove check_automatic_or_tls.  */\n+      i = check_automatic_or_tls (t);\n+      if (i == ck_ok)\n+\treturn true;\n+      if (i == ck_bad)\n+        {\n+          if (flags & tf_error)\n+            error (\"address-of an object %qE with thread local or \"\n+                   \"automatic storage is not a constant expression\", t);\n+          return false;\n+        }\n+#endif\n+      return RECUR (t, any);\n+\n+    case COMPONENT_REF:\n+      /* -- a class member access unless its postfix-expression is\n+\t    of literal type or of pointer to literal type.  */\n+      /* This test would be redundant, as it follows from the\n+\t postfix-expression being a potential constant expression.  */\n+      if (type_unknown_p (t))\n+\treturn true;\n+      if (is_overloaded_fn (t))\n+\t/* In a template, a COMPONENT_REF of a function expresses ob.fn(),\n+\t   which uses ob as an lvalue.  */\n+\twant_rval = false;\n+      gcc_fallthrough ();\n+\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case BIT_FIELD_REF:\n+      return RECUR (TREE_OPERAND (t, 0), want_rval);\n+\n+      case INDIRECT_REF: {\n+\ttree x = TREE_OPERAND (t, 0);\n+\tSTRIP_NOPS (x);\n+\treturn RECUR (x, rval);\n+      }\n+\n+    case STATEMENT_LIST:\n+      for (tree stmt : tsi_range (t))\n+\tif (!RECUR (stmt, any))\n+\t  return false;\n+      return true;\n+\n+    case MODIFY_EXPR:\n+      if (!RECUR (TREE_OPERAND (t, 0), any))\n+\treturn false;\n+      /* Just ignore clobbers.  */\n+      if (TREE_CLOBBER_P (TREE_OPERAND (t, 1)))\n+\treturn true;\n+      if (!RECUR (TREE_OPERAND (t, 1), rval))\n+\treturn false;\n+      return true;\n+\n+    case FOR_STMT:\n+      if (!RECUR (FOR_INIT_STMT (t), any))\n+\treturn false;\n+      tmp = FOR_COND (t);\n+      if (!RECUR (tmp, rval))\n+\treturn false;\n+      if (tmp)\n+\t{\n+\t  tmp = cxx_eval_outermost_constant_expr (tmp, true);\n+\t  /* If we couldn't evaluate the condition, it might not ever be\n+\t     true.  */\n+\t  if (!integer_onep (tmp))\n+\t    {\n+\t      /* Before returning true, check if the for body can contain\n+\t\t a return.  */\n+\t      hash_set<tree> pset;\n+\t      check_for_return_continue_data data\n+\t\t= {&pset, NULL_TREE, NULL_TREE};\n+\t      if (tree ret_expr\n+\t\t  = rs_walk_tree (&FOR_BODY (t), check_for_return_continue,\n+\t\t\t\t  &data, &pset))\n+\t\t*jump_target = ret_expr;\n+\t      return true;\n+\t    }\n+\t}\n+      if (!RECUR (FOR_EXPR (t), any))\n+\treturn false;\n+      if (!RECUR (FOR_BODY (t), any))\n+\treturn false;\n+      if (breaks (jump_target) || continues (jump_target))\n+\t*jump_target = NULL_TREE;\n+      return true;\n+\n+    case WHILE_STMT:\n+      tmp = WHILE_COND (t);\n+      if (!RECUR (tmp, rval))\n+\treturn false;\n+\n+      tmp = cxx_eval_outermost_constant_expr (tmp, true);\n+      /* If we couldn't evaluate the condition, it might not ever be true.  */\n+      if (!integer_onep (tmp))\n+\t{\n+\t  /* Before returning true, check if the while body can contain\n+\t     a return.  */\n+\t  hash_set<tree> pset;\n+\t  check_for_return_continue_data data = {&pset, NULL_TREE, NULL_TREE};\n+\t  if (tree ret_expr\n+\t      = rs_walk_tree (&WHILE_BODY (t), check_for_return_continue, &data,\n+\t\t\t      &pset))\n+\t    *jump_target = ret_expr;\n+\t  return true;\n+\t}\n+      if (!RECUR (WHILE_BODY (t), any))\n+\treturn false;\n+      if (breaks (jump_target) || continues (jump_target))\n+\t*jump_target = NULL_TREE;\n+      return true;\n+\n+    case SWITCH_STMT:\n+      if (!RECUR (SWITCH_STMT_COND (t), rval))\n+\treturn false;\n+      /* FIXME we don't check SWITCH_STMT_BODY currently, because even\n+\t unreachable labels would be checked and it is enough if there is\n+\t a single switch cond value for which it is a valid constant\n+\t expression.  We need to check if there are any RETURN_EXPRs\n+\t or CONTINUE_STMTs inside of the body though, as in that case\n+\t we need to set *jump_target.  */\n+      else\n+\t{\n+\t  hash_set<tree> pset;\n+\t  check_for_return_continue_data data = {&pset, NULL_TREE, NULL_TREE};\n+\t  if (tree ret_expr\n+\t      = rs_walk_tree (&SWITCH_STMT_BODY (t), check_for_return_continue,\n+\t\t\t      &data, &pset))\n+\t    /* The switch might return.  */\n+\t    *jump_target = ret_expr;\n+\t  else if (data.continue_stmt)\n+\t    /* The switch can't return, but might continue.  */\n+\t    *jump_target = data.continue_stmt;\n+\t}\n+      return true;\n+\n+    case DYNAMIC_CAST_EXPR:\n+    case PSEUDO_DTOR_EXPR:\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+    case THROW_EXPR:\n+    case OMP_PARALLEL:\n+    case OMP_TASK:\n+    case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n+    case OMP_TASKLOOP:\n+    case OMP_LOOP:\n+    case OMP_TEAMS:\n+    case OMP_TARGET_DATA:\n+    case OMP_TARGET:\n+    case OMP_SECTIONS:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+    case OMP_SINGLE:\n+    case OMP_SECTION:\n+    case OMP_MASTER:\n+    case OMP_MASKED:\n+    case OMP_TASKGROUP:\n+    case OMP_TARGET_UPDATE:\n+    case OMP_TARGET_ENTER_DATA:\n+    case OMP_TARGET_EXIT_DATA:\n+    case OMP_ATOMIC:\n+    case OMP_ATOMIC_READ:\n+    case OMP_ATOMIC_CAPTURE_OLD:\n+    case OMP_ATOMIC_CAPTURE_NEW:\n+    case OMP_DEPOBJ:\n+    case OACC_PARALLEL:\n+    case OACC_KERNELS:\n+    case OACC_SERIAL:\n+    case OACC_DATA:\n+    case OACC_HOST_DATA:\n+    case OACC_LOOP:\n+    case OACC_CACHE:\n+    case OACC_DECLARE:\n+    case OACC_ENTER_DATA:\n+    case OACC_EXIT_DATA:\n+    case OACC_UPDATE:\n+      /* GCC internal stuff.  */\n+    case VA_ARG_EXPR:\n+    case TRANSACTION_EXPR:\n+    case AT_ENCODE_EXPR:\n+\n+      if (flags & tf_error)\n+\terror_at (loc, \"expression %qE is not a constant expression\", t);\n+      return false;\n+\n+    case ASM_EXPR:\n+      if (flags & tf_error)\n+\tinline_asm_in_constexpr_error (loc);\n+      return false;\n+\n+    case OBJ_TYPE_REF:\n+      return true;\n+\n+    case POINTER_DIFF_EXPR:\n+    case MINUS_EXPR:\n+      want_rval = true;\n+      goto binary;\n+\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case SPACESHIP_EXPR:\n+      want_rval = true;\n+      goto binary;\n+\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      goto unary;\n+\n+    case BIT_NOT_EXPR:\n+      /* A destructor.  */\n+      if (TYPE_P (TREE_OPERAND (t, 0)))\n+\treturn true;\n+      /* fall through.  */\n+\n+    case CONJ_EXPR:\n+    case SAVE_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case ABSU_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+    case UNARY_PLUS_EXPR:\n+    case UNARY_LEFT_FOLD_EXPR:\n+    case UNARY_RIGHT_FOLD_EXPR:\n+    unary:\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n+    case BIND_EXPR:\n+      return RECUR (BIND_EXPR_BODY (t), want_rval);\n+\n+    case CLEANUP_POINT_EXPR:\n+    case EXPR_STMT:\n+    case PAREN_EXPR:\n+    case NON_DEPENDENT_EXPR:\n+      /* For convenience.  */\n+    case LOOP_EXPR:\n+    case EXIT_EXPR:\n+      return RECUR (TREE_OPERAND (t, 0), want_rval);\n+\n+    case DECL_EXPR:\n+      tmp = DECL_EXPR_DECL (t);\n+      if (VAR_P (tmp) && !DECL_ARTIFICIAL (tmp))\n+\t{\n+\t  if (RS_DECL_THREAD_LOCAL_P (tmp))\n+\t    {\n+\t      if (flags & tf_error)\n+\t\terror_at (DECL_SOURCE_LOCATION (tmp),\n+\t\t\t  \"%qD declared \"\n+\t\t\t  \"%<thread_local%> in %<constexpr%> context\",\n+\t\t\t  tmp);\n+\t      return false;\n+\t    }\n+\t  else if (TREE_STATIC (tmp))\n+\t    {\n+\t      if (flags & tf_error)\n+\t\terror_at (DECL_SOURCE_LOCATION (tmp),\n+\t\t\t  \"%qD declared \"\n+\t\t\t  \"%<static%> in %<constexpr%> context\",\n+\t\t\t  tmp);\n+\t      return false;\n+\t    }\n+\t  else if (!check_for_uninitialized_const_var (\n+\t\t     tmp, /*constexpr_context_p=*/true, flags))\n+\t    return false;\n+\t}\n+      return RECUR (tmp, want_rval);\n+\n+    case TRY_FINALLY_EXPR:\n+      return (RECUR (TREE_OPERAND (t, 0), want_rval)\n+\t      && RECUR (TREE_OPERAND (t, 1), any));\n+\n+    case SCOPE_REF:\n+      return RECUR (TREE_OPERAND (t, 1), want_rval);\n+\n+    case TARGET_EXPR:\n+      if (!TARGET_EXPR_DIRECT_INIT_P (t) && !literal_type_p (TREE_TYPE (t)))\n+\t{\n+\t  if (flags & tf_error)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      error_at (loc,\n+\t\t\t\"temporary of non-literal type %qT in a \"\n+\t\t\t\"constant expression\",\n+\t\t\tTREE_TYPE (t));\n+\t      explain_non_literal_class (TREE_TYPE (t));\n+\t    }\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+    case INIT_EXPR:\n+      return RECUR (TREE_OPERAND (t, 1), rval);\n+\n+      case CONSTRUCTOR: {\n+\tvec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n+\tconstructor_elt *ce;\n+\tfor (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+\t  if (!RECUR (ce->value, want_rval))\n+\t    return false;\n+\treturn true;\n+      }\n+\n+      case TREE_LIST: {\n+\tgcc_assert (TREE_PURPOSE (t) == NULL_TREE || DECL_P (TREE_PURPOSE (t)));\n+\tif (!RECUR (TREE_VALUE (t), want_rval))\n+\t  return false;\n+\tif (TREE_CHAIN (t) == NULL_TREE)\n+\t  return true;\n+\treturn RECUR (TREE_CHAIN (t), want_rval);\n+      }\n+\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+      case ROUND_MOD_EXPR: {\n+\ttree denom = TREE_OPERAND (t, 1);\n+\tif (!RECUR (denom, rval))\n+\t  return false;\n+\t/* We can't call cxx_eval_outermost_constant_expr on an expression\n+\t   that hasn't been through instantiate_non_dependent_expr yet.  */\n+\tdenom = cxx_eval_outermost_constant_expr (denom, true);\n+\tif (integer_zerop (denom))\n+\t  {\n+\t    if (flags & tf_error)\n+\t      error (\"division by zero is not a constant expression\");\n+\t    return false;\n+\t  }\n+\telse\n+\t  {\n+\t    want_rval = true;\n+\t    return RECUR (TREE_OPERAND (t, 0), want_rval);\n+\t  }\n+      }\n+\n+      case COMPOUND_EXPR: {\n+\t/* check_return_expr sometimes wraps a TARGET_EXPR in a\n+\t   COMPOUND_EXPR; don't get confused.  */\n+\ttree op0 = TREE_OPERAND (t, 0);\n+\ttree op1 = TREE_OPERAND (t, 1);\n+\tSTRIP_NOPS (op1);\n+\tif (TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n+\t  return RECUR (op0, want_rval);\n+\telse\n+\t  goto binary;\n+      }\n+\n+      /* If the first operand is the non-short-circuit constant, look at\n+\t the second operand; otherwise we only care about the first one for\n+\t potentiality.  */\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      tmp = boolean_true_node;\n+      goto truth;\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      tmp = boolean_false_node;\n+      truth : {\n+\ttree op0 = TREE_OPERAND (t, 0);\n+\ttree op1 = TREE_OPERAND (t, 1);\n+\tif (!RECUR (op0, rval))\n+\t  return false;\n+\tif (!(flags & tf_error) && RECUR (op1, rval))\n+\t  /* When quiet, try to avoid expensive trial evaluation by first\n+\t     checking potentiality of the second operand.  */\n+\t  return true;\n+\top0 = cxx_eval_outermost_constant_expr (op0, true);\n+\tif (tree_int_cst_equal (op0, tmp))\n+\t  return (flags & tf_error) ? RECUR (op1, rval) : false;\n+\telse\n+\t  return true;\n+      }\n+\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case RANGE_EXPR:\n+    case COMPLEX_EXPR:\n+      want_rval = true;\n+      /* Fall through.  */\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n+    case MEM_REF:\n+    case BINARY_LEFT_FOLD_EXPR:\n+    case BINARY_RIGHT_FOLD_EXPR:\n+    binary:\n+      for (i = 0; i < 2; ++i)\n+\tif (!RECUR (TREE_OPERAND (t, i), want_rval))\n+\t  return false;\n+      return true;\n+\n+    case VEC_PERM_EXPR:\n+      for (i = 0; i < 3; ++i)\n+\tif (!RECUR (TREE_OPERAND (t, i), true))\n+\t  return false;\n+      return true;\n+\n+    case COND_EXPR:\n+      if (COND_EXPR_IS_VEC_DELETE (t))\n+\t{\n+\t  if (flags & tf_error)\n+\t    error_at (loc, \"%<delete[]%> is not a constant expression\");\n+\t  return false;\n+\t}\n+      /* Fall through.  */\n+    case IF_STMT:\n+    case VEC_COND_EXPR:\n+      /* If the condition is a known constant, we know which of the legs we\n+\t care about; otherwise we only require that the condition and\n+\t either of the legs be potentially constant.  */\n+      tmp = TREE_OPERAND (t, 0);\n+      if (!RECUR (tmp, rval))\n+\treturn false;\n+\n+      tmp = cxx_eval_outermost_constant_expr (tmp, true);\n+      /* potential_constant_expression* isn't told if it is called for\n+\t manifestly_const_eval or not, so for consteval if always\n+\t process both branches as if the condition is not a known\n+\t constant.  */\n+      if (TREE_CODE (t) != IF_STMT || !IF_STMT_CONSTEVAL_P (t))\n+\t{\n+\t  if (integer_zerop (tmp))\n+\t    return RECUR (TREE_OPERAND (t, 2), want_rval);\n+\t  else if (TREE_CODE (tmp) == INTEGER_CST)\n+\t    return RECUR (TREE_OPERAND (t, 1), want_rval);\n+\t}\n+      tmp = *jump_target;\n+      for (i = 1; i < 3; ++i)\n+\t{\n+\t  tree this_jump_target = tmp;\n+\t  if (potential_constant_expression_1 (TREE_OPERAND (t, i), want_rval,\n+\t\t\t\t\t       strict, now, tf_none,\n+\t\t\t\t\t       &this_jump_target))\n+\t    {\n+\t      if (returns (&this_jump_target))\n+\t\t*jump_target = this_jump_target;\n+\t      else if (!returns (jump_target))\n+\t\t{\n+\t\t  if (breaks (&this_jump_target)\n+\t\t      || continues (&this_jump_target))\n+\t\t    *jump_target = this_jump_target;\n+\t\t  if (i == 1)\n+\t\t    {\n+\t\t      /* If the then branch is potentially constant, but\n+\t\t\t does not return, check if the else branch\n+\t\t\t couldn't return, break or continue.  */\n+\t\t      hash_set<tree> pset;\n+\t\t      check_for_return_continue_data data\n+\t\t\t= {&pset, NULL_TREE, NULL_TREE};\n+\t\t      if (tree ret_expr\n+\t\t\t  = rs_walk_tree (&TREE_OPERAND (t, 2),\n+\t\t\t\t\t  check_for_return_continue, &data,\n+\t\t\t\t\t  &pset))\n+\t\t\t*jump_target = ret_expr;\n+\t\t      else if (*jump_target == NULL_TREE)\n+\t\t\t{\n+\t\t\t  if (data.continue_stmt)\n+\t\t\t    *jump_target = data.continue_stmt;\n+\t\t\t  else if (data.break_stmt)\n+\t\t\t    *jump_target = data.break_stmt;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      return true;\n+\t    }\n+\t}\n+      if (flags & tf_error)\n+\terror_at (loc, \"expression %qE is not a constant expression\", t);\n+      return false;\n+\n+    case TYPE_DECL:\n+      /* We can see these in statement-expressions.  */\n+      return true;\n+\n+    case LABEL_EXPR:\n+      t = LABEL_EXPR_LABEL (t);\n+      if (DECL_ARTIFICIAL (t))\n+\treturn true;\n+      else if (flags & tf_error)\n+\terror_at (loc, \"label definition in %<constexpr%> function only \"\n+\t\t       \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\");\n+      return false;\n+\n+    case ANNOTATE_EXPR:\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n+    case BIT_CAST_EXPR:\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n+    default:\n+      sorry (\"unexpected AST of kind %s\", get_tree_code_name (TREE_CODE (t)));\n+      gcc_unreachable ();\n+      return false;\n+    }\n+#undef RECUR\n+}\n+\n+bool\n+potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n+\t\t\t\t tsubst_flags_t flags)\n+{\n+  if (flags & tf_error)\n+    {\n+      /* Check potentiality quietly first, as that could be performed more\n+\t efficiently in some cases (currently only for TRUTH_*_EXPR).  If\n+\t that fails, replay the check noisily to give errors.  */\n+      flags &= ~tf_error;\n+      if (potential_constant_expression_1 (t, want_rval, strict, now, flags))\n+\treturn true;\n+      flags |= tf_error;\n+    }\n+\n+  tree target = NULL_TREE;\n+  return potential_constant_expression_1 (t, want_rval, strict, now, flags,\n+\t\t\t\t\t  &target);\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}, {"sha": "fc32c7c1c708a4d5ad79f5b3f1ddf13ece4f4cf2", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=debe4aedc76a1f52c3072254b6be4da4f4c4696c", "patch": "@@ -1678,6 +1678,8 @@ fields_linear_search (tree klass, tree name, bool want_type)\n       if (!want_type || DECL_DECLARES_TYPE_P (decl))\n \treturn decl;\n     }\n+\n+  return NULL_TREE;\n }\n \n // forked from gcc/cp/except.cc canonnothrow_spec_pical_eh_spec\n@@ -4587,7 +4589,6 @@ lvalue_kind (const_tree ref)\n       return clk_none;\n \n     default:\n-    default_:\n       if (!TREE_TYPE (ref))\n \treturn clk_none;\n       if (CLASS_TYPE_P (TREE_TYPE (ref))\n@@ -6033,4 +6034,116 @@ cp_fold_rvalue (tree x)\n   return cp_fold_maybe_rvalue (x, true);\n }\n \n+/* Returns true iff class T has a constexpr destructor or has an\n+   implicitly declared destructor that we can't tell if it's constexpr\n+   without forcing a lazy declaration (which might cause undesired\n+   instantiations).  */\n+\n+static bool\n+type_maybe_constexpr_destructor (tree t)\n+{\n+  /* Until C++20, only trivial destruction is constexpr.  */\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (t))\n+    return true;\n+\n+  if (CLASS_TYPE_P (t) && CLASSTYPE_LAZY_DESTRUCTOR (t))\n+    /* Assume it's constexpr.  */\n+    return true;\n+  tree fn = CLASSTYPE_DESTRUCTOR (t);\n+  return (fn && Compile::maybe_constexpr_fn (fn));\n+}\n+\n+/* T is a non-literal type used in a context which requires a constant\n+   expression.  Explain why it isn't literal.  */\n+\n+void\n+explain_non_literal_class (tree t)\n+{\n+  static hash_set<tree> *diagnosed;\n+\n+  if (!CLASS_TYPE_P (t))\n+    return;\n+  t = TYPE_MAIN_VARIANT (t);\n+\n+  if (diagnosed == NULL)\n+    diagnosed = new hash_set<tree>;\n+  if (diagnosed->add (t))\n+    /* Already explained.  */\n+    return;\n+\n+  auto_diagnostic_group d;\n+  inform (UNKNOWN_LOCATION, \"%q+T is not literal because:\", t);\n+  if (LAMBDA_TYPE_P (t))\n+    inform (UNKNOWN_LOCATION,\n+\t    \"  %qT is a closure type, which is only literal in \"\n+\t    \"C++17 and later\",\n+\t    t);\n+  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n+\t   && !type_maybe_constexpr_destructor (t))\n+    inform (UNKNOWN_LOCATION, \"  %q+T does not have %<constexpr%> destructor\",\n+\t    t);\n+  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+    inform (UNKNOWN_LOCATION, \"  %q+T has a non-trivial destructor\", t);\n+  else if (CLASSTYPE_NON_AGGREGATE (t) && !TYPE_HAS_TRIVIAL_DFLT (t)\n+\t   && !LAMBDA_TYPE_P (t) && !TYPE_HAS_CONSTEXPR_CTOR (t))\n+    {\n+      inform (UNKNOWN_LOCATION,\n+\t      \"  %q+T is not an aggregate, does not have a trivial \"\n+\t      \"default constructor, and has no %<constexpr%> constructor that \"\n+\t      \"is not a copy or move constructor\",\n+\t      t);\n+      if (type_has_non_user_provided_default_constructor (t))\n+\t/* Note that we can't simply call locate_ctor because when the\n+\t   constructor is deleted it just returns NULL_TREE.  */\n+\tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t)); iter; ++iter)\n+\t  {\n+\t    tree fn = *iter;\n+\t    tree parms = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\n+\t    parms = skip_artificial_parms_for (fn, parms);\n+\n+\t    if (sufficient_parms_p (parms))\n+\t      {\n+\t\tCompile::explain_invalid_constexpr_fn (fn);\n+\t\tbreak;\n+\t      }\n+\t  }\n+    }\n+  else\n+    {\n+      tree binfo, base_binfo, field;\n+      int i;\n+      for (binfo = TYPE_BINFO (t), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t{\n+\t  tree basetype = TREE_TYPE (base_binfo);\n+\t  if (!CLASSTYPE_LITERAL_P (basetype))\n+\t    {\n+\t      inform (UNKNOWN_LOCATION,\n+\t\t      \"  base class %qT of %q+T is non-literal\", basetype, t);\n+\t      explain_non_literal_class (basetype);\n+\t      return;\n+\t    }\n+\t}\n+      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+\t{\n+\t  tree ftype;\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\t  ftype = TREE_TYPE (field);\n+\t  if (!Compile::literal_type_p (ftype))\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"  non-static data member %qD has non-literal type\",\n+\t\t      field);\n+\t      if (CLASS_TYPE_P (ftype))\n+\t\texplain_non_literal_class (ftype);\n+\t    }\n+\t  if (RS_TYPE_VOLATILE_P (ftype))\n+\t    inform (DECL_SOURCE_LOCATION (field),\n+\t\t    \"  non-static data member %qD has volatile type\", field);\n+\t}\n+    }\n+}\n+\n } // namespace Rust"}, {"sha": "2466efc33093b411f7001ee321da1074aea3d180", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 204, "deletions": 1, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debe4aedc76a1f52c3072254b6be4da4f4c4696c/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=debe4aedc76a1f52c3072254b6be4da4f4c4696c", "patch": "@@ -1347,7 +1347,7 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define ENUM_UNDERLYING_TYPE(TYPE) TREE_TYPE (ENUMERAL_TYPE_CHECK (TYPE))\n \n /* Nonzero if this type is volatile-qualified.  */\n-#define CP_TYPE_VOLATILE_P(NODE)                                               \\\n+#define RS_TYPE_VOLATILE_P(NODE)                                               \\\n   ((rs_type_quals (NODE) & TYPE_QUAL_VOLATILE) != 0)\n \n /* Nonzero means that this type is either complete or being defined, so we\n@@ -1366,6 +1366,169 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n   (DECL_NAME (NODE) != NULL_TREE && MAIN_NAME_P (DECL_NAME (NODE))             \\\n    && flag_hosted)\n \n+/* Nonzero if the variable was declared to be thread-local.\n+   We need a special C++ version of this test because the middle-end\n+   DECL_THREAD_LOCAL_P uses the symtab, so we can't use it for\n+   templates.  */\n+#define RS_DECL_THREAD_LOCAL_P(NODE) (TREE_LANG_FLAG_0 (VAR_DECL_CHECK (NODE)))\n+\n+#define COND_EXPR_IS_VEC_DELETE(NODE) TREE_LANG_FLAG_0 (COND_EXPR_CHECK (NODE))\n+\n+/* RANGE_FOR_STMT accessors. These give access to the declarator,\n+   expression, body, and scope of the statement, respectively.  */\n+#define RANGE_FOR_DECL(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 0)\n+#define RANGE_FOR_EXPR(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 1)\n+#define RANGE_FOR_BODY(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 2)\n+#define RANGE_FOR_SCOPE(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 3)\n+#define RANGE_FOR_UNROLL(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 4)\n+#define RANGE_FOR_INIT_STMT(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 5)\n+#define RANGE_FOR_IVDEP(NODE) TREE_LANG_FLAG_6 (RANGE_FOR_STMT_CHECK (NODE))\n+\n+#define CP_DECL_CONTEXT(NODE)                                                  \\\n+  (!DECL_FILE_SCOPE_P (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n+#define CP_TYPE_CONTEXT(NODE)                                                  \\\n+  (!TYPE_FILE_SCOPE_P (NODE) ? TYPE_CONTEXT (NODE) : global_namespace)\n+#define FROB_CONTEXT(NODE)                                                     \\\n+  ((NODE) == global_namespace ? DECL_CONTEXT (NODE) : (NODE))\n+\n+/* Nonzero if NODE is the std namespace.  */\n+#define DECL_NAMESPACE_STD_P(NODE) ((NODE) == std_node)\n+\n+/* Whether the namepace is an inline namespace.  */\n+#define DECL_NAMESPACE_INLINE_P(NODE)                                          \\\n+  TREE_LANG_FLAG_0 (NAMESPACE_DECL_CHECK (NODE))\n+\n+#define CP_DECL_CONTEXT(NODE)                                                  \\\n+  (!DECL_FILE_SCOPE_P (NODE) ? DECL_CONTEXT (NODE) : global_namespace)\n+\n+/* Based off of TYPE_UNNAMED_P.  */\n+#define LAMBDA_TYPE_P(NODE)                                                    \\\n+  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_LINKAGE_IDENTIFIER (NODE)           \\\n+   && IDENTIFIER_LAMBDA_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n+\n+/* Macros to make error reporting functions' lives easier.  */\n+#define TYPE_LINKAGE_IDENTIFIER(NODE)                                          \\\n+  (TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (NODE)))\n+\n+/* Identifiers used for lambda types are almost anonymous.  Use this\n+   spare flag to distinguish them (they also have the anonymous flag).  */\n+#define IDENTIFIER_LAMBDA_P(NODE)                                              \\\n+  (IDENTIFIER_NODE_CHECK (NODE)->base.protected_flag)\n+\n+/* If NODE, a FUNCTION_DECL, is a C++11 inheriting constructor, then this\n+   is the constructor it inherits from.  */\n+#define DECL_INHERITED_CTOR(NODE)                                              \\\n+  (DECL_DECLARES_FUNCTION_P (NODE) && DECL_CONSTRUCTOR_P (NODE)                \\\n+     ? LANG_DECL_FN_CHECK (NODE)->context                                      \\\n+     : NULL_TREE)\n+\n+/* True if the class type TYPE is a literal type.  */\n+#define CLASSTYPE_LITERAL_P(TYPE) (LANG_TYPE_CLASS_CHECK (TYPE)->is_literal)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL or TEMPLATE_DECL)\n+   is a destructor.  */\n+#define DECL_DESTRUCTOR_P(NODE) DECL_CXX_DESTRUCTOR_P (NODE)\n+\n+/* Nonzero if TYPE has a trivial destructor.  From [class.dtor]:\n+\n+     A destructor is trivial if it is an implicitly declared\n+     destructor and if:\n+\n+       - all of the direct base classes of its class have trivial\n+\t destructors,\n+\n+       - for all of the non-static data members of its class that are\n+\t of class type (or array thereof), each such class has a\n+\t trivial destructor.  */\n+#define TYPE_HAS_TRIVIAL_DESTRUCTOR(NODE)                                      \\\n+  (!TYPE_HAS_NONTRIVIAL_DESTRUCTOR (NODE))\n+\n+/* Nonzero means that NODE (a class type) has a destructor -- but that\n+   it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_DESTRUCTOR(NODE)                                        \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_destructor)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a complete\n+   object.  */\n+#define DECL_COMPLETE_CONSTRUCTOR_P(NODE)                                      \\\n+  (DECL_NAME (NODE) == complete_ctor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a base\n+   object.  */\n+#define DECL_BASE_CONSTRUCTOR_P(NODE) (DECL_NAME (NODE) == base_ctor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor, but not either the\n+   specialized in-charge constructor or the specialized not-in-charge\n+   constructor.  */\n+#define DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P(NODE)                               \\\n+  (DECL_NAME (NODE) == ctor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a copy constructor.  */\n+#define DECL_COPY_CONSTRUCTOR_P(NODE)                                          \\\n+  (DECL_CONSTRUCTOR_P (NODE) && copy_fn_p (NODE) > 0)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a move constructor.  */\n+#define DECL_MOVE_CONSTRUCTOR_P(NODE)                                          \\\n+  (DECL_CONSTRUCTOR_P (NODE) && move_fn_p (NODE))\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor, but not the\n+   specialized in-charge constructor, in-charge deleting constructor,\n+   or the base destructor.  */\n+#define DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P(NODE)                                \\\n+  (DECL_NAME (NODE) == dtor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n+   object.  */\n+#define DECL_COMPLETE_DESTRUCTOR_P(NODE)                                       \\\n+  (DECL_NAME (NODE) == complete_dtor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a base\n+   object.  */\n+#define DECL_BASE_DESTRUCTOR_P(NODE) (DECL_NAME (NODE) == base_dtor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n+   object that deletes the object after it has been destroyed.  */\n+#define DECL_DELETING_DESTRUCTOR_P(NODE)                                       \\\n+  (DECL_NAME (NODE) == deleting_dtor_identifier)\n+\n+/* Nonzero if either DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P or\n+   DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P is true of NODE.  */\n+#define DECL_MAYBE_IN_CHARGE_CDTOR_P(NODE)                                     \\\n+  (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (NODE)                                   \\\n+   || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (NODE))\n+\n+/* Nonzero if NODE (a _DECL) is a cloned constructor or\n+   destructor.  */\n+#define DECL_CLONED_FUNCTION_P(NODE)                                           \\\n+  (DECL_NAME (NODE) && IDENTIFIER_CDTOR_P (DECL_NAME (NODE))                   \\\n+   && !DECL_MAYBE_IN_CHARGE_CDTOR_P (NODE))\n+\n+/* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n+   cloned.  */\n+#define DECL_CLONED_FUNCTION(NODE)                                             \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))->u.fn.u5.cloned_function)\n+\n+/* Nonzero means that an object of this type cannot be initialized using\n+   an initializer list.  */\n+#define CLASSTYPE_NON_AGGREGATE(NODE)                                          \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_aggregate)\n+#define TYPE_NON_AGGREGATE_CLASS(NODE)                                         \\\n+  (CLASS_TYPE_P (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n+\n+/* Nonzero for class type means that the default constructor is trivial.  */\n+#define TYPE_HAS_TRIVIAL_DFLT(NODE)                                            \\\n+  (TYPE_HAS_DEFAULT_CONSTRUCTOR (NODE) && !TYPE_HAS_COMPLEX_DFLT (NODE))\n+\n+/* Nonzero if this class has a constexpr constructor other than a copy/move\n+   constructor.  Note that a class can have constexpr constructors for\n+   static initialization even if it isn't a literal class.  */\n+#define TYPE_HAS_CONSTEXPR_CTOR(NODE)                                          \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_constexpr_ctor)\n+\n+/* Nonzero if there is no trivial default constructor for this class.  */\n+#define TYPE_HAS_COMPLEX_DFLT(NODE)                                            \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->has_complex_dflt)\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -1532,6 +1695,33 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+/* The various kinds of special functions.  If you add to this list,\n+   you should update special_function_p as well.  */\n+enum special_function_kind\n+{\n+  sfk_none = 0, /* Not a special function.  This enumeral\n+\t\t   must have value zero; see\n+\t\t   special_function_p.  */\n+  /* The following are ordered, for use by member synthesis fns.  */\n+  sfk_destructor,\t      /* A destructor.  */\n+  sfk_constructor,\t      /* A constructor.  */\n+  sfk_inheriting_constructor, /* An inheriting constructor */\n+  sfk_copy_constructor,\t      /* A copy constructor.  */\n+  sfk_move_constructor,\t      /* A move constructor.  */\n+  sfk_copy_assignment,\t      /* A copy assignment operator.  */\n+  sfk_move_assignment,\t      /* A move assignment operator.  */\n+  /* The following are unordered.  */\n+  sfk_complete_destructor, /* A destructor for complete objects.  */\n+  sfk_base_destructor,\t   /* A destructor for base subobjects.  */\n+  sfk_deleting_destructor, /* A destructor for complete objects that\n+\t\t\t      deletes the object after it has been\n+\t\t\t      destroyed.  */\n+  sfk_conversion,\t   /* A conversion operator.  */\n+  sfk_deduction_guide,\t   /* A class template deduction guide.  */\n+  sfk_comparison,\t   /* A comparison operator (e.g. ==, <, <=>).  */\n+  sfk_virtual_destructor   /* Used by member synthesis fns.  */\n+};\n+\n /* Places where an lvalue, or modifiable lvalue, may be required.\n    Used to select diagnostic messages in lvalue_error and\n    readonly_error.  */\n@@ -2922,6 +3112,10 @@ extern void lvalue_error (location_t, enum lvalue_use);\n extern tree\n cp_fold_maybe_rvalue (tree, bool);\n \n+extern tree get_first_fn (tree) ATTRIBUTE_PURE;\n+\n+extern void explain_non_literal_class (tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -3147,7 +3341,16 @@ namespace Compile {\n extern tree\n maybe_constant_init (tree, tree = NULL_TREE, bool = false);\n \n+extern void\n+explain_invalid_constexpr_fn (tree fun);\n+\n extern bool potential_constant_expression (tree);\n+\n+extern bool\n+literal_type_p (tree t);\n+\n+extern bool\n+maybe_constexpr_fn (tree t);\n }\n \n } // namespace Rust"}]}