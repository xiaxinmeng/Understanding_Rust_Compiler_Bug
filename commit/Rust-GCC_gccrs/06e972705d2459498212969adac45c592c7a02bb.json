{"sha": "06e972705d2459498212969adac45c592c7a02bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlOTcyNzA1ZDI0NTk0OTgyMTI5NjlhZGFjNDVjNTkyYzdhMDJiYg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2018-02-14T12:33:37Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2018-02-14T12:33:37Z"}, "message": "re PR target/83831 ([RX] Unused bclr,bnot,bset insns)\n\ngcc/\n\tPR target/83831\n\t* config/rx/rx-protos.h (rx_reg_dead_or_unused_after_insn,\n\trx_copy_reg_dead_or_unused_notes, rx_fuse_in_memory_bitop): New\n\tdeclarations.\n\t(set_of_reg): New struct.\n\t(rx_find_set_of_reg, rx_find_use_of_reg): New functions.\n\t* config/rx/rx.c (rx_reg_dead_or_unused_after_insn,\n\trx_copy_reg_dead_or_unused_notes, rx_fuse_in_memory_bitop): New\n\tfunctions.\n\t* config/rx/rx.md (andsi3, iorsi3, xorsi3): Convert to insn_and_split.\n\tSplit into bitclr, bitset, bitinvert patterns if appropriate.\n\t(*bitset, *bitinvert, *bitclr): Convert to named insn_and_split and\n\tuse rx_fuse_in_memory_bitop.\n\t(*bitset_in_memory, *bitinvert_in_memory, *bitclr_in_memory): Convert\n\tto named insn, correct maximum insn length.\n\ngcc/testsuite/\n\tPR target/83831\n\t* gcc.target/rx/pr83831.c: New tests.\n\nFrom-SVN: r257655", "tree": {"sha": "c3a5987c8817bdf9a6c1352ffa17c07cecf511c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a5987c8817bdf9a6c1352ffa17c07cecf511c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06e972705d2459498212969adac45c592c7a02bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06e972705d2459498212969adac45c592c7a02bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06e972705d2459498212969adac45c592c7a02bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06e972705d2459498212969adac45c592c7a02bb/comments", "author": null, "committer": null, "parents": [{"sha": "d1fe6124618d472815cf46d9a8cf23e7d4a49cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1fe6124618d472815cf46d9a8cf23e7d4a49cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1fe6124618d472815cf46d9a8cf23e7d4a49cbe"}], "stats": {"total": 400, "additions": 377, "deletions": 23}, "files": [{"sha": "22589babaa6a3dd29dca8136176998af114f1458", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -1,3 +1,21 @@\n+2018-02-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/83831\n+\t* config/rx/rx-protos.h (rx_reg_dead_or_unused_after_insn,\n+\trx_copy_reg_dead_or_unused_notes, rx_fuse_in_memory_bitop): New\n+\tdeclarations.\n+\t(set_of_reg): New struct.\n+\t(rx_find_set_of_reg, rx_find_use_of_reg): New functions.\n+\t* config/rx/rx.c (rx_reg_dead_or_unused_after_insn,\n+\trx_copy_reg_dead_or_unused_notes, rx_fuse_in_memory_bitop): New\n+\tfunctions.\n+\t* config/rx/rx.md (andsi3, iorsi3, xorsi3): Convert to insn_and_split.\n+\tSplit into bitclr, bitset, bitinvert patterns if appropriate.\n+\t(*bitset, *bitinvert, *bitclr): Convert to named insn_and_split and\n+\tuse rx_fuse_in_memory_bitop.\n+\t(*bitset_in_memory, *bitinvert_in_memory, *bitclr_in_memory): Convert\n+\tto named insn, correct maximum insn length.\n+\n 2018-02-14  Jozef Lawrynowicz <jozefl.gcc@gmail.com>\n \n \tPR target/79242"}, {"sha": "0bb885d2da138aeb747e048e98806f4b49213b1a", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -63,6 +63,112 @@ extern void\t\trx_notice_update_cc (rtx, rtx);\n extern void\t\trx_split_cbranch (machine_mode, enum rtx_code,\n \t\t\t\t\t  rtx, rtx, rtx);\n extern machine_mode\trx_select_cc_mode (enum rtx_code, rtx, rtx);\n+\n+extern bool rx_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno);\n+extern void rx_copy_reg_dead_or_unused_notes (rtx reg, const rtx_insn* src,\n+\t\t\t\t\t      rtx_insn* dst);\n+\n+extern bool rx_fuse_in_memory_bitop (rtx* operands, rtx_insn* curr_insn,\n+\t\t\t\t     rtx (*gen_insn)(rtx, rtx));\n+\n+/* Result value of rx_find_set_of_reg.  */\n+struct set_of_reg\n+{\n+  /* The insn where sh_find_set_of_reg stopped looking.\n+     Can be NULL_RTX if the end of the insn list was reached.  */\n+  rtx_insn* insn;\n+\n+  /* The set rtx of the specified reg if found, NULL_RTX otherwise.  */\n+  const_rtx set_rtx;\n+\n+  /* The set source rtx of the specified reg if found, NULL_RTX otherwise.\n+     Usually, this is the most interesting return value.  */\n+  rtx set_src;\n+};\n+\n+/* FIXME: Copy-pasta from SH.  Move to rtl.h.\n+   Given a reg rtx and a start insn, try to find the insn that sets\n+   the specified reg by using the specified insn stepping function,\n+   such as 'prev_nonnote_nondebug_insn_bb'.  When the insn is found,\n+   try to extract the rtx of the reg set.  */\n+template <typename F> inline set_of_reg\n+rx_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc,\n+\t\t    bool ignore_reg_reg_copies = false)\n+{\n+  set_of_reg result;\n+  result.insn = insn;\n+  result.set_rtx = NULL_RTX;\n+  result.set_src = NULL_RTX;\n+\n+  if (!REG_P (reg) || insn == NULL_RTX)\n+    return result;\n+\n+  for (rtx_insn* i = stepfunc (insn); i != NULL_RTX; i = stepfunc (i))\n+    {\n+      if (BARRIER_P (i))\n+\tbreak;\n+      if (!INSN_P (i) || DEBUG_INSN_P (i))\n+\t  continue;\n+      if (reg_set_p (reg, i))\n+\t{\n+\t  if (CALL_P (i))\n+\t    break;\n+\n+\t  result.insn = i;\n+\t  result.set_rtx = set_of (reg, i);\n+\n+\t  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)\n+\t    break;\n+\n+\t  result.set_src = XEXP (result.set_rtx, 1);\n+\n+\t  if (ignore_reg_reg_copies && REG_P (result.set_src))\n+\t    {\n+\t      reg = result.set_src;\n+\t      continue;\n+\t    }\n+\t  if (ignore_reg_reg_copies && SUBREG_P (result.set_src)\n+\t      && REG_P (SUBREG_REG (result.set_src)))\n+\t    {\n+\t      reg = SUBREG_REG (result.set_src);\n+\t      continue;\n+\t    }\n+\n+\t  break;\n+\t}\n+    }\n+\n+  /* If the searched reg is found inside a (mem (post_inc:SI (reg))), set_of\n+     will return NULL and set_rtx will be NULL.\n+     In this case report a 'not found'.  result.insn will always be non-null\n+     at this point, so no need to check it.  */\n+  if (result.set_src != NULL && result.set_rtx == NULL)\n+    result.set_src = NULL;\n+\n+  return result;\n+}\n+\n+/* FIXME: Move to rtlh.h.  */\n+template <typename F> inline rtx_insn*\n+rx_find_use_of_reg (rtx reg, rtx_insn* insn, F stepfunc)\n+{\n+  if (!REG_P (reg) || insn == NULL_RTX)\n+    return NULL;\n+\n+  for (rtx_insn* i = stepfunc (insn); i != NULL_RTX; i = stepfunc (i))\n+    {\n+      if (BARRIER_P (i))\n+\tbreak;\n+      if (!INSN_P (i) || DEBUG_INSN_P (i))\n+\tcontinue;\n+      if (reg_overlap_mentioned_p (reg, PATTERN (i))\n+\t  || (CALL_P (i) && find_reg_fusage (i, USE, reg)))\n+\treturn i;\n+    }\n+\n+  return NULL;\n+}\n+\n #endif\n \n #endif /* GCC_RX_PROTOS_H */"}, {"sha": "0eaf418cd719d75c7b21f35ac98870c15ee157a6", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -3439,6 +3439,88 @@ rx_atomic_sequence::~rx_atomic_sequence (void)\n     emit_insn (gen_mvtc (GEN_INT (CTRLREG_PSW), m_prev_psw_reg));\n }\n \n+/* Given an insn and a reg number, tell whether the reg dies or is unused\n+   after the insn.  */\n+bool\n+rx_reg_dead_or_unused_after_insn (const rtx_insn* i, int regno)\n+{\n+  return find_regno_note (i, REG_DEAD, regno) != NULL\n+\t || find_regno_note (i, REG_UNUSED, regno) != NULL;\n+}\n+\n+/* Copy dead and unused notes from SRC to DST for the specified REGNO.  */\n+void\n+rx_copy_reg_dead_or_unused_notes (rtx reg, const rtx_insn* src, rtx_insn* dst)\n+{\n+  int regno = REGNO (SUBREG_P (reg) ? SUBREG_REG (reg) : reg);\n+\n+  if (rtx note = find_regno_note (src, REG_DEAD, regno))\n+    add_shallow_copy_of_reg_note (dst, note);\n+\n+  if (rtx note = find_regno_note (src, REG_UNUSED, regno))\n+    add_shallow_copy_of_reg_note (dst, note);\n+}\n+\n+/* Try to fuse the current bit-operation insn with the surrounding memory load\n+   and store.  */\n+bool\n+rx_fuse_in_memory_bitop (rtx* operands, rtx_insn* curr_insn,\n+\t\t\t rtx (*gen_insn)(rtx, rtx))\n+{\n+  rtx op2_reg = SUBREG_P (operands[2]) ? SUBREG_REG (operands[2]) : operands[2];\n+\n+  set_of_reg op2_def = rx_find_set_of_reg (op2_reg, curr_insn,\n+\t\t\t\t\t   prev_nonnote_nondebug_insn_bb);\n+  if (op2_def.set_src == NULL_RTX\n+      || !MEM_P (op2_def.set_src)\n+      || GET_MODE (op2_def.set_src) != QImode\n+      || !rx_is_restricted_memory_address (XEXP (op2_def.set_src, 0),\n+\t\t\t\t\t   GET_MODE (op2_def.set_src))\n+      || reg_used_between_p (operands[2], op2_def.insn, curr_insn)\n+      || !rx_reg_dead_or_unused_after_insn (curr_insn, REGNO (op2_reg))\n+    )\n+    return false;\n+\n+  /* The register operand originates from a memory load and the memory load\n+     could be fused with the bitop insn.\n+     Look for the following memory store with the same memory operand.  */\n+  rtx mem = op2_def.set_src;\n+\n+  /* If the memory is an auto-mod address, it can't be fused.  */\n+  if (GET_CODE (XEXP (mem, 0)) == POST_INC\n+      || GET_CODE (XEXP (mem, 0)) == PRE_INC\n+      || GET_CODE (XEXP (mem, 0)) == POST_DEC\n+      || GET_CODE (XEXP (mem, 0)) == PRE_DEC)\n+    return false;\n+\n+  rtx_insn* op0_use = rx_find_use_of_reg (operands[0], curr_insn,\n+\t\t\t\t\t  next_nonnote_nondebug_insn_bb);\n+  if (op0_use == NULL\n+      || !(GET_CODE (PATTERN (op0_use)) == SET\n+\t   && RX_REG_P (XEXP (PATTERN (op0_use), 1))\n+\t   && reg_overlap_mentioned_p (operands[0], XEXP (PATTERN (op0_use), 1))\n+\t   && rtx_equal_p (mem, XEXP (PATTERN (op0_use), 0)))\n+      || !rx_reg_dead_or_unused_after_insn (op0_use, REGNO (operands[0]))\n+      || reg_set_between_p (operands[2], curr_insn, op0_use))\n+    return false;\n+\n+  /* If the load-modify-store operation is fused it could potentially modify\n+     load/store ordering if there are other memory accesses between the load\n+     and the store for this insn.  If there are volatile mems between the load\n+     and store it's better not to change the ordering.  If there is a call\n+     between the load and store, it's also not safe to fuse it.  */\n+  for (rtx_insn* i = next_nonnote_nondebug_insn_bb (op2_def.insn);\n+       i != NULL && i != op0_use;\n+       i = next_nonnote_nondebug_insn_bb (i))\n+    if (volatile_insn_p (PATTERN (i)) || CALL_P (i))\n+      return false;\n+\n+  emit_insn (gen_insn (mem, operands[1]));\n+  set_insn_deleted (op2_def.insn);\n+  set_insn_deleted (op0_use);\n+  return true;\n+}\n+\n /* Implement TARGET_HARD_REGNO_NREGS.  */\n \n static unsigned int"}, {"sha": "116d4d4a93988e056d085230f66cb2960f3d20bb", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 89, "deletions": 23, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -1094,7 +1094,7 @@\n   DONE;\n })\n \n-(define_insn \"andsi3\"\n+(define_insn_and_split \"andsi3\"\n   [(set (match_operand:SI         0 \"register_operand\"  \"=r,r,r,r,r,r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,0,0,0,r,r,0\")\n \t\t(match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))\n@@ -1110,6 +1110,21 @@\n   and\\t%1, %0\n   and\\t%2, %1, %0\n   and\\t%Q2, %0\"\n+  \"&& RX_REG_P (operands[1]) && CONST_INT_P (operands[2])\n+   && pow2p_hwi (~UINTVAL (operands[2]))\"\n+ [(const_int 0)]\n+{\n+  /* For negated single bit constants use the bclr insn for smaller code.  */\n+\n+  if (!rx_reg_dead_or_unused_after_insn (curr_insn, CC_REG))\n+    FAIL;\n+\n+  rx_copy_reg_dead_or_unused_notes (operands[1], curr_insn,\n+    emit_insn (gen_bitclr (operands[0],\n+\t\t\t   GEN_INT (exact_log2 (~UINTVAL (operands[2]))),\n+\t\t\t   operands[1])));\n+  DONE;\n+}\n   [(set_attr \"timings\" \"11,11,11,11,11,11,11,11,33\")\n    (set_attr \"length\" \"2,2,3,4,5,6,2,5,5\")]\n )\n@@ -1383,7 +1398,7 @@\n   [(set_attr \"length\" \"2,3\")]\n )\n \n-(define_insn \"iorsi3\"\n+(define_insn_and_split \"iorsi3\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r,r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,r,r,0\")\n \t        (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,Sint08,Sint16,Sint24,i,0,r,Q\")))\n@@ -1399,6 +1414,21 @@\n   or\\t%1, %0\n   or\\t%2, %1, %0\n   or\\t%Q2, %0\"\n+  \"&& RX_REG_P (operands[1]) && CONST_INT_P (operands[2])\n+   && pow2p_hwi (UINTVAL (operands[2]))\"\n+  [(const_int 0)]\n+{\n+  /* For single bit constants use the bset insn for smaller code.  */\n+\n+  if (!rx_reg_dead_or_unused_after_insn (curr_insn, CC_REG))\n+    FAIL;\n+\n+  rx_copy_reg_dead_or_unused_notes (operands[1], curr_insn,\n+    emit_insn (gen_bitset (operands[0],\n+\t\t\t   GEN_INT (exact_log2 (UINTVAL (operands[2]))),\n+\t\t\t   operands[1])));\n+  DONE;\n+}\n   [(set_attr \"timings\" \"11,11,11,11,11,11,11,11,33\")\n    (set_attr \"length\"  \"2,2,3,4,5,6,2,3,5\")]\n )\n@@ -1704,14 +1734,29 @@\n   DONE;\n })\n \n-(define_insn \"xorsi3\"\n+(define_insn_and_split \"xorsi3\"\n   [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n \t        (match_operand:SI 2 \"rx_source_operand\"\n \t\t\t\t  \"r,Sint08,Sint16,Sint24,i,Q\")))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"xor\\t%Q2, %0\"\n+  \"&& RX_REG_P (operands[1]) && CONST_INT_P (operands[2])\n+   && pow2p_hwi (UINTVAL (operands[2]))\"\n+  [(const_int 0)]\n+{\n+  /* For single bit constants use the bnot insn for smaller code.  */\n+\n+  if (!rx_reg_dead_or_unused_after_insn (curr_insn, CC_REG))\n+    FAIL;\n+\n+  rx_copy_reg_dead_or_unused_notes (operands[1], curr_insn,\n+    emit_insn (gen_bitinvert (operands[0],\n+\t\t\t      GEN_INT (exact_log2 (UINTVAL (operands[2]))),\n+\t\t\t      operands[1])));\n+  DONE;\n+}\n   [(set_attr \"timings\" \"11,11,11,11,11,33\")\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n@@ -1960,50 +2005,63 @@\n \f\n ;; Bit manipulation instructions.\n \n-;; ??? The *_in_memory patterns will not be matched without further help.\n-;; At one time we had the insv expander generate them, but I suspect that\n-;; in general we get better performance by exposing the register load to\n-;; the optimizers.\n-;;\n-;; An alternate solution would be to re-organize these patterns such\n-;; that allow both register and memory operands.  This would allow the\n-;; register allocator to spill and not load the register operand.  This\n-;; would be possible only for operations for which we have a constant\n-;; bit offset, so that we can adjust the address by ofs/8 and replace\n-;; the offset in the insn by ofs%8.\n-\n-(define_insn \"*bitset\"\n+;; The *_in_memory patterns will not be matched automatically, not even with\n+;; combiner bridge patterns.  Especially when the memory operands have a\n+;; displacement, the resulting patterns look too complex.\n+;; Instead we manually look around the matched insn to see if there is a\n+;; preceeding memory load and a following memory store of the modified register\n+;; which can be fused into the single *_in_memory insn.\n+;; Do that before register allocation, as it can eliminate one temporary\n+;; register that needs to be allocated.\n+\n+(define_insn_and_split \"bitset\"\n   [(set (match_operand:SI                    0 \"register_operand\" \"=r\")\n \t(ior:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"rx_shift_operand\" \"ri\"))\n \t\t(match_operand:SI            2 \"register_operand\" \"0\")))]\n   \"\"\n   \"bset\\t%1, %0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  if (rx_fuse_in_memory_bitop (operands, curr_insn, &gen_bitset_in_memory))\n+    DONE;\n+  else\n+    FAIL;\n+}\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"*bitset_in_memory\"\n+(define_insn \"bitset_in_memory\"\n   [(set (match_operand:QI                    0 \"rx_restricted_mem_operand\" \"+Q\")\n \t(ior:QI (ashift:QI (const_int 1)\n \t\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"ri\"))\n \t\t(match_dup 0)))]\n   \"\"\n   \"bset\\t%1, %0.B\"\n-  [(set_attr \"length\" \"3\")\n+  [(set_attr \"length\" \"5\")\n    (set_attr \"timings\" \"33\")]\n )\n \n-(define_insn \"*bitinvert\"\n+(define_insn_and_split \"bitinvert\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(xor:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"rx_shift_operand\" \"ri\"))\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n   \"\"\n   \"bnot\\t%1, %0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  if (rx_fuse_in_memory_bitop (operands, curr_insn, &gen_bitinvert_in_memory))\n+    DONE;\n+  else\n+    FAIL;\n+}\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"*bitinvert_in_memory\"\n+(define_insn \"bitinvert_in_memory\"\n   [(set (match_operand:QI 0 \"rx_restricted_mem_operand\" \"+Q\")\n \t(xor:QI (ashift:QI (const_int 1)\n \t\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"ri\"))\n@@ -2014,7 +2072,7 @@\n    (set_attr \"timings\" \"33\")]\n )\n \n-(define_insn \"*bitclr\"\n+(define_insn_and_split \"bitclr\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(and:SI (not:SI\n \t\t  (ashift:SI\n@@ -2023,10 +2081,18 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n   \"\"\n   \"bclr\\t%1, %0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  if (rx_fuse_in_memory_bitop (operands, curr_insn, &gen_bitclr_in_memory))\n+    DONE;\n+  else\n+    FAIL;\n+}\n   [(set_attr \"length\" \"3\")]\n )\n \n-(define_insn \"*bitclr_in_memory\"\n+(define_insn \"bitclr_in_memory\"\n   [(set (match_operand:QI 0 \"rx_restricted_mem_operand\" \"+Q\")\n \t(and:QI (not:QI\n \t\t  (ashift:QI\n@@ -2035,7 +2101,7 @@\n \t\t(match_dup 0)))]\n   \"\"\n   \"bclr\\t%1, %0.B\"\n-  [(set_attr \"length\" \"3\")\n+  [(set_attr \"length\" \"5\")\n    (set_attr \"timings\" \"33\")]\n )\n "}, {"sha": "776542aa5fa0e41c68e1409ee093c6c949eeecd1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -1,3 +1,8 @@\n+2018-02-14  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/83831\n+\t* gcc.target/rx/pr83831.c: New tests.\n+\n 2018-02-14  Jozef Lawrynowicz <jozefl.gcc@gmail.com>\n \n \tPR target/79242"}, {"sha": "1bd1e2b429bff9a687ed058eaeb4f65516d6963f", "filename": "gcc/testsuite/gcc.target/rx/pr83831.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06e972705d2459498212969adac45c592c7a02bb/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpr83831.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06e972705d2459498212969adac45c592c7a02bb/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpr83831.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpr83831.c?ref=06e972705d2459498212969adac45c592c7a02bb", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" }  */\n+/* { dg-final { scan-assembler-times \"bclr\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"bset\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"bnot\" 6 } }  */\n+\n+void\n+test_0 (char* x, unsigned int y)\n+{\n+  /* Expect 4x bclr here.  */\n+  x[0] &= 0xFE;\n+  x[1] = y & ~(1 << 1);\n+  x[2] &= 0xFE;\n+  x[65000] &= 0xFE;\n+}\n+\n+unsigned int\n+test_1 (unsigned int x, unsigned int y)\n+{\n+  /* Expect 1x bclr here.  */\n+  return x & ~(1 << y);\n+}\n+\n+unsigned int\n+test_2 (unsigned int x)\n+{\n+  /* Expect 1x bclr here.  */\n+  return x & ~(1 << 1);\n+}\n+\n+void\n+test_3 (char* x, unsigned int y)\n+{\n+  /* Expect 4x bset here.  */\n+  x[0] |= 0x10;\n+  x[1] = y | (1 << 1);\n+  x[2] |= 0x10;\n+  x[65000] |= 0x10;\n+}\n+\n+unsigned int\n+test_4 (unsigned int x, unsigned int y)\n+{\n+  /* Expect 1x bset here.  */\n+  return x | (1 << y);\n+}\n+\n+unsigned int\n+test_5 (unsigned int x)\n+{\n+  /* Expect 1x bset here.  */\n+  return x | (1 << 8);\n+}\n+\n+void\n+test_6 (char* x, unsigned int y)\n+{\n+  /* Expect 4x bnot here.  */\n+  x[0] ^= 0x10;\n+  x[1] = y ^ (1 << 1);\n+  x[2] ^= 0x10;\n+  x[65000] ^= 0x10;\n+}\n+\n+unsigned int\n+test_7 (unsigned int x, unsigned int y)\n+{\n+  /* Expect 1x bnot here.  */\n+  return x ^ (1 << y);\n+}\n+\n+unsigned int\n+test_8 (unsigned int x)\n+{\n+  /* Expect 1x bnot here.  */\n+  return x ^ (1 << 8);\n+}"}]}