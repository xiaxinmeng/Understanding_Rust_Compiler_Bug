{"sha": "f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRhYTM4NDgyY2Q3Mzc0ZTdmZDZlMGZmOTY4ZjZjODRlMDgyM2EwYQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2009-05-18T12:33:55Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2009-05-18T12:33:55Z"}, "message": "2064.md: Remove trailing whitespaces.\n\n2009-05-18  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/2064.md: Remove trailing whitespaces.\n\t* config/s390/2084.md: Likewise.\n\t* config/s390/constraints.md: Likewise.\n\t* config/s390/fixdfdi.h: Likewise.\n\t* config/s390/libgcc-glibc.ver: Likewise.\n\t* config/s390/s390-modes.def: Likewise.\n\t* config/s390/s390-protos.h: Likewise.\n\t* config/s390/s390.c: Likewise.\n\t* config/s390/s390.h: Likewise.\n\t* config/s390/s390.md: Likewise.\n\t* config/s390/tpf-unwind.h: Likewise.\n\nFrom-SVN: r147660", "tree": {"sha": "25cbc8aae17c531d404a03cf11e901223f0aaa39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25cbc8aae17c531d404a03cf11e901223f0aaa39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/comments", "author": null, "committer": null, "parents": [{"sha": "bfa31dad8a7ae5febc3a03fe6004d589019b77b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa31dad8a7ae5febc3a03fe6004d589019b77b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa31dad8a7ae5febc3a03fe6004d589019b77b2"}], "stats": {"total": 618, "additions": 316, "deletions": 302}, "files": [{"sha": "b769bcc1dd40d748f88bc93ccac8467cf91b92ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -1,3 +1,17 @@\n+2009-05-18  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/2064.md: Remove trailing whitespaces.\n+\t* config/s390/2084.md: Likewise.\n+\t* config/s390/constraints.md: Likewise.\n+\t* config/s390/fixdfdi.h: Likewise.\n+\t* config/s390/libgcc-glibc.ver: Likewise.\n+\t* config/s390/s390-modes.def: Likewise.\n+\t* config/s390/s390-protos.h: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/s390/s390.h: Likewise.\n+\t* config/s390/s390.md: Likewise.\n+\t* config/s390/tpf-unwind.h: Likewise.\n+\n 2009-05-18  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* config/m68k/m68k.c (m68k_legitimize_address): Fix typo in signature."}, {"sha": "143978334a31a42418e2d09e4df06d40fc2bd6f7", "filename": "gcc/config/s390/2064.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2F2064.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2F2064.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2064.md?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -21,22 +21,22 @@\n \n ;;\n ;; References:\n-;;   The microarchitecture of the IBM eServer z900 processor. \n+;;   The microarchitecture of the IBM eServer z900 processor.\n ;;   E.M. Schwarz et al.\n ;;   IBM Journal of Research and Development Vol. 46 No 4/5, 2002.\n-;; \n+;;\n ;;            z900 (cpu 2064) pipeline\n-;;     \n+;;\n ;;                 dec\n ;;              --> | <---\n ;;  LA bypass  |  agen    |\n-;;             |    |     | \n+;;             |    |     |\n ;;              --- c1    |  Load bypass\n-;;                  |     | \n+;;                  |     |\n ;;                  c2----\n ;;                  |\n-;;                  e1 \n-;;                  | \n+;;                  e1\n+;;                  |\n ;;                  wr\n \n ;; This scheduler description is also used for the g5 and g6.\n@@ -46,12 +46,12 @@\n (define_cpu_unit \"z_wr\"   \"z_ipu\")\n \n \n-(define_insn_reservation \"z_la\" 1 \n+(define_insn_reservation \"z_la\" 1\n   (and (eq_attr \"cpu\" \"z900,g5,g6\")\n        (eq_attr \"type\" \"la\"))\n   \"z_e1,z_wr\")\n \n-(define_insn_reservation \"z_larl\" 1 \n+(define_insn_reservation \"z_larl\" 1\n   (and (eq_attr \"cpu\" \"z900,g5,g6\")\n        (eq_attr \"type\" \"larl\"))\n   \"z_e1,z_wr\")\n@@ -101,32 +101,32 @@\n   \"z_e1,z_wr\")\n \n ;;\n-;; s390_agen_dep_p returns 1, if a register is set in the \n+;; s390_agen_dep_p returns 1, if a register is set in the\n ;; first insn and used in the dependent insn to form a address.\n ;;\n \n ;;\n ;; If an instruction uses a register to address memory, it needs\n ;; to be set 5 cycles in advance.\n-;; \n+;;\n \n-(define_bypass 5 \"z_int,z_agen\" \n+(define_bypass 5 \"z_int,z_agen\"\n \t       \"z_agen,z_la,z_call,z_load,z_store\" \"s390_agen_dep_p\")\n \n ;;\n-;; A load type instruction uses a bypass to feed the result back\t\n-;; to the address generation pipeline stage. \n+;; A load type instruction uses a bypass to feed the result back\n+;; to the address generation pipeline stage.\n ;;\n \n-(define_bypass 3 \"z_load\"    \n+(define_bypass 3 \"z_load\"\n \t         \"z_agen,z_la,z_call,z_load,z_store\" \"s390_agen_dep_p\")\n \n ;;\n-;; A load address type instruction uses a bypass to feed the \n-;; result back to the address generation pipeline stage. \n+;; A load address type instruction uses a bypass to feed the\n+;; result back to the address generation pipeline stage.\n ;;\n \n-(define_bypass 2 \"z_larl,z_la\" \n+(define_bypass 2 \"z_larl,z_la\"\n \t         \"z_agen,z_la,z_call,z_load,z_store\" \"s390_agen_dep_p\")\n \n "}, {"sha": "38669c23a97c7c641d1c4480c16064450a1abd8d", "filename": "gcc/config/s390/2084.md", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2F2084.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2F2084.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2084.md?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -76,38 +76,38 @@\n (define_insn_reservation \"x_lr\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"lr\"))\n-  \"x-e1-st,x-wr-st\") \n+  \"x-e1-st,x-wr-st\")\n \n-(define_insn_reservation \"x_la\" 1 \n+(define_insn_reservation \"x_la\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"la\"))\n-  \"x-e1-st,x-wr-st\") \n+  \"x-e1-st,x-wr-st\")\n \n-(define_insn_reservation \"x_larl\" 1 \n+(define_insn_reservation \"x_larl\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"larl\"))\n-  \"x-e1-st,x-wr-st\") \n+  \"x-e1-st,x-wr-st\")\n \n-(define_insn_reservation \"x_load\" 1 \n+(define_insn_reservation \"x_load\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"load\"))\n-  \"x-e1-st+x-mem,x-wr-st\") \n+  \"x-e1-st+x-mem,x-wr-st\")\n \n-(define_insn_reservation \"x_store\" 1 \n+(define_insn_reservation \"x_store\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"store\"))\n-  \"x-e1-st+x_store_tok,x-wr-st\") \n+  \"x-e1-st+x_store_tok,x-wr-st\")\n \n-(define_insn_reservation \"x_branch\" 1 \n+(define_insn_reservation \"x_branch\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"branch\"))\n-  \"x_e1_r,x_wr_r\") \n+  \"x_e1_r,x_wr_r\")\n \n-(define_insn_reservation \"x_call\" 5 \n+(define_insn_reservation \"x_call\" 5\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"jsr\"))\n   \"x-e1-np*5,x-wr-np\")\n- \n+\n (define_insn_reservation \"x_mul_hi\" 2\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"imulhi\"))\n@@ -123,162 +123,162 @@\n        (eq_attr \"type\" \"idiv\"))\n   \"x-e1-np*10,x-wr-np\")\n \n-(define_insn_reservation \"x_sem\" 17 \n+(define_insn_reservation \"x_sem\" 17\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"sem\"))\n-  \"x-e1-np+x-mem,x-e1-np*16,x-wr-st\") \n+  \"x-e1-np+x-mem,x-e1-np*16,x-wr-st\")\n \n ;;\n ;; Multicycle insns\n ;;\n \n-(define_insn_reservation \"x_cs\" 1 \n+(define_insn_reservation \"x_cs\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"cs\"))\n-  \"x-e1-np,x-wr-np\") \n+  \"x-e1-np,x-wr-np\")\n \n-(define_insn_reservation \"x_vs\" 1 \n+(define_insn_reservation \"x_vs\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"vs\"))\n-  \"x-e1-np*10,x-wr-np\") \n+  \"x-e1-np*10,x-wr-np\")\n \n-(define_insn_reservation \"x_stm\" 1 \n+(define_insn_reservation \"x_stm\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"stm\"))\n-  \"(x-e1-np+x_store_tok)*10,x-wr-np\") \n+  \"(x-e1-np+x_store_tok)*10,x-wr-np\")\n \n-(define_insn_reservation \"x_lm\" 1 \n+(define_insn_reservation \"x_lm\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"lm\"))\n-  \"x-e1-np*10,x-wr-np\") \n+  \"x-e1-np*10,x-wr-np\")\n \n-(define_insn_reservation \"x_other\" 1 \n+(define_insn_reservation \"x_other\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"other\"))\n-  \"x-e1-np,x-wr-np\") \n+  \"x-e1-np,x-wr-np\")\n \n ;;\n ;; Floating point insns\n ;;\n \n-(define_insn_reservation \"x_fsimptf\" 7 \n+(define_insn_reservation \"x_fsimptf\" 7\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fsimptf\"))\n-  \"x_e1_t*2,x-wr-fp\") \n+  \"x_e1_t*2,x-wr-fp\")\n \n-(define_insn_reservation \"x_fsimpdf\" 6 \n+(define_insn_reservation \"x_fsimpdf\" 6\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fsimpdf,fmuldf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n-(define_insn_reservation \"x_fsimpsf\" 6 \n+(define_insn_reservation \"x_fsimpsf\" 6\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fsimpsf,fmulsf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n \n (define_insn_reservation \"x_fmultf\" 33\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fmultf\"))\n-  \"x_e1_t*27,x-wr-fp\") \n+  \"x_e1_t*27,x-wr-fp\")\n \n \n (define_insn_reservation \"x_fdivtf\" 82\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fdivtf,fsqrttf\"))\n-  \"x_e1_t*76,x-wr-fp\") \n+  \"x_e1_t*76,x-wr-fp\")\n \n (define_insn_reservation \"x_fdivdf\" 36\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fdivdf,fsqrtdf\"))\n-  \"x_e1_t*30,x-wr-fp\") \n+  \"x_e1_t*30,x-wr-fp\")\n \n-(define_insn_reservation \"x_fdivsf\" 36 \n+(define_insn_reservation \"x_fdivsf\" 36\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fdivsf,fsqrtsf\"))\n-  \"x_e1_t*30,x-wr-fp\") \n+  \"x_e1_t*30,x-wr-fp\")\n \n \n-(define_insn_reservation \"x_floadtf\" 6 \n+(define_insn_reservation \"x_floadtf\" 6\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"floadtf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n-(define_insn_reservation \"x_floaddf\" 6 \n+(define_insn_reservation \"x_floaddf\" 6\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"floaddf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n-(define_insn_reservation \"x_floadsf\" 6 \n+(define_insn_reservation \"x_floadsf\" 6\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"floadsf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n \n-(define_insn_reservation \"x_fstoredf\" 1 \n+(define_insn_reservation \"x_fstoredf\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fstoredf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n-(define_insn_reservation \"x_fstoresf\" 1 \n+(define_insn_reservation \"x_fstoresf\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"fstoresf\"))\n-  \"x_e1_t,x-wr-fp\") \n+  \"x_e1_t,x-wr-fp\")\n \n \n (define_insn_reservation \"x_ftrunctf\" 16\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"ftrunctf\"))\n-  \"x_e1_t*10,x-wr-fp\") \n+  \"x_e1_t*10,x-wr-fp\")\n \n (define_insn_reservation \"x_ftruncdf\" 11\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"ftruncdf\"))\n-  \"x_e1_t*5,x-wr-fp\") \n+  \"x_e1_t*5,x-wr-fp\")\n \n \n-(define_insn_reservation \"x_ftoi\" 1 \n+(define_insn_reservation \"x_ftoi\" 1\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"ftoi\"))\n-  \"x_e1_t*3,x-wr-fp\") \n+  \"x_e1_t*3,x-wr-fp\")\n \n-(define_insn_reservation \"x_itof\" 7 \n+(define_insn_reservation \"x_itof\" 7\n   (and (eq_attr \"cpu\" \"z990,z9_109\")\n        (eq_attr \"type\" \"itoftf,itofdf,itofsf\"))\n-  \"x_e1_t*3,x-wr-fp\") \n+  \"x_e1_t*3,x-wr-fp\")\n \n (define_bypass 1 \"x_fsimpdf\" \"x_fstoredf\")\n \n (define_bypass 1 \"x_fsimpsf\" \"x_fstoresf\")\n \n (define_bypass 1 \"x_floaddf\" \"x_fsimpdf,x_fstoredf,x_floaddf\")\n-\t         \n+\n (define_bypass 1 \"x_floadsf\" \"x_fsimpsf,x_fstoresf,x_floadsf\")\n \n ;;\n-;; s390_agen_dep_p returns 1, if a register is set in the \n+;; s390_agen_dep_p returns 1, if a register is set in the\n ;; first insn and used in the dependent insn to form a address.\n ;;\n \n ;;\n ;; If an instruction uses a register to address memory, it needs\n ;; to be set 5 cycles in advance.\n-;; \n+;;\n \n-(define_bypass 5 \"x_int,x_agen,x_lr\" \n+(define_bypass 5 \"x_int,x_agen,x_lr\"\n                  \"x_agen,x_la,x_branch,x_call,x_load,x_store,x_cs,x_stm,x_lm,x_other\"\n \t         \"s390_agen_dep_p\")\n \n-(define_bypass 9 \"x_int,x_agen,x_lr\" \n+(define_bypass 9 \"x_int,x_agen,x_lr\"\n                  \"x_floadtf, x_floaddf, x_floadsf, x_fstoredf, x_fstoresf,\\\n \t\t  x_fsimpdf, x_fsimpsf, x_fdivdf, x_fdivsf\"\n \t         \"s390_agen_dep_p\")\n ;;\n-;; A load type instruction uses a bypass to feed the result back\t\n-;; to the address generation pipeline stage. \n+;; A load type instruction uses a bypass to feed the result back\n+;; to the address generation pipeline stage.\n ;;\n \n-(define_bypass 4 \"x_load\"    \n+(define_bypass 4 \"x_load\"\n                  \"x_agen,x_la,x_branch,x_call,x_load,x_store,x_cs,x_stm,x_lm,x_other\"\n \t         \"s390_agen_dep_p\")\n \n@@ -288,11 +288,11 @@\n \t         \"s390_agen_dep_p\")\n \n ;;\n-;; A load address type instruction uses a bypass to feed the \n-;; result back to the address generation pipeline stage. \n+;; A load address type instruction uses a bypass to feed the\n+;; result back to the address generation pipeline stage.\n ;;\n \n-(define_bypass 3 \"x_larl,x_la\" \n+(define_bypass 3 \"x_larl,x_la\"\n                  \"x_agen,x_la,x_branch,x_call,x_load,x_store,x_cs,x_stm,x_lm,x_other\"\n \t         \"s390_agen_dep_p\")\n "}, {"sha": "8fec7e124a63aff755c422ace2aa41ec2b6c3f75", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -76,27 +76,27 @@\n ;;  Register constraints.\n ;;\n \n-(define_register_constraint \"a\" \n+(define_register_constraint \"a\"\n   \"ADDR_REGS\"\n   \"Any address register from 1 to 15.\")\n \n \n-(define_register_constraint \"c\" \n+(define_register_constraint \"c\"\n   \"CC_REGS\"\n   \"Condition code register 33\")\n \n \n-(define_register_constraint \"d\" \n+(define_register_constraint \"d\"\n   \"GENERAL_REGS\"\n   \"Any register from 0 to 15\")\n \n \n-(define_register_constraint \"f\" \n+(define_register_constraint \"f\"\n   \"FP_REGS\"\n   \"Floating point registers\")\n \n \n-(define_register_constraint \"t\" \n+(define_register_constraint \"t\"\n   \"ACCESS_REGS\"\n   \"@internal\n    Access registers 36 and 37\")\n@@ -187,9 +187,9 @@\n ;;         is specified instead of a part number, the constraint matches\n ;;         if there is any single part with non-default value.\n ;;\n-;; The following patterns define only those constraints that are actually \n-;; used in s390.md.  If you need an additional one, simply add it in the \n-;; obvious way.  Function s390_N_constraint_str is ready to handle all \n+;; The following patterns define only those constraints that are actually\n+;; used in s390.md.  If you need an additional one, simply add it in the\n+;; obvious way.  Function s390_N_constraint_str is ready to handle all\n ;; combinations.\n ;;\n \n@@ -409,53 +409,53 @@ constraint.\"\n                || s390_mem_constraint (\\\"T\\\", op)\"))\n \n (define_memory_constraint \"AQ\"\n-  \"@internal \n+  \"@internal\n    Offsettable memory reference without index register and with short displacement\"\n   (match_test \"s390_mem_constraint (\\\"AQ\\\", op)\"))\n \n \n (define_memory_constraint \"AR\"\n-  \"@internal \n+  \"@internal\n    Offsettable memory reference with index register and short displacement\"\n   (match_test \"s390_mem_constraint (\\\"AR\\\", op)\"))\n \n \n (define_memory_constraint \"AS\"\n-  \"@internal \n+  \"@internal\n    Offsettable memory reference without index register but with long displacement\"\n   (match_test \"s390_mem_constraint (\\\"AS\\\", op)\"))\n \n \n (define_memory_constraint \"AT\"\n-  \"@internal \n+  \"@internal\n    Offsettable memory reference with index register and long displacement\"\n   (match_test \"s390_mem_constraint (\\\"AT\\\", op)\"))\n \n \n \n (define_constraint \"BQ\"\n-  \"@internal \n-   Memory reference without index register and with short \n+  \"@internal\n+   Memory reference without index register and with short\n    displacement that does *not* refer to a literal pool entry.\"\n   (match_test \"s390_mem_constraint (\\\"BQ\\\", op)\"))\n \n \n (define_constraint \"BR\"\n-  \"@internal \n+  \"@internal\n    Memory reference with index register and short displacement that\n    does *not* refer to a literal pool entry. \"\n   (match_test \"s390_mem_constraint (\\\"BR\\\", op)\"))\n \n \n (define_constraint \"BS\"\n-  \"@internal \n+  \"@internal\n    Memory reference without index register but with long displacement\n    that does *not* refer to a literal pool entry. \"\n   (match_test \"s390_mem_constraint (\\\"BS\\\", op)\"))\n \n \n (define_constraint \"BT\"\n-  \"@internal \n+  \"@internal\n    Memory reference with index register and long displacement that\n    does *not* refer to a literal pool entry. \"\n   (match_test \"s390_mem_constraint (\\\"BT\\\", op)\"))"}, {"sha": "ddddf3a7c9cd065ed1b1bad054392e97890eaa88", "filename": "gcc/config/s390/fixdfdi.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -63,12 +63,12 @@ __fixunstfdi (long double a1)\n     if (!EXPD (dl1) || SIGND(dl1))\n       return 0;\n \n-    /* The exponent - considered the binary point at the right end of \n+    /* The exponent - considered the binary point at the right end of\n        the mantissa.  */\n     exp = EXPD (dl1) - EXPONENT_BIAS - MANTISSA_BITS;\n \n     /* number < 1: If the mantissa would need to be right-shifted more bits than\n-       its size (plus the implied one bit on the left) the result would be \n+       its size (plus the implied one bit on the left) the result would be\n        zero.  */\n     if (exp <= -PRECISION)\n       return 0;\n@@ -238,7 +238,7 @@ __fixunsdfdi (double a1)\n     /* shift down until exp < 12 or l = 0 */\n     if (exp > 0)\n       l <<= exp;\n-    else \n+    else\n       l >>= -exp;\n \n     return l;\n@@ -313,7 +313,7 @@ __fixdfdi (double a1)\n     /* shift down until exp < 12 or l = 0 */\n     if (exp > 0)\n       l <<= exp;\n-    else \n+    else\n       l >>= -exp;\n \n     return (SIGND (dl1) ? -l : l);\n@@ -381,7 +381,7 @@ __fixunssfdi (float a1)\n \n     if (exp > 0)\n       l <<= exp;\n-    else \n+    else\n       l >>= -exp;\n \n     return l;\n@@ -452,7 +452,7 @@ __fixsfdi (float a1)\n \n     if (exp > 0)\n       l <<= exp;\n-    else \n+    else\n       l >>= -exp;\n \n     return (SIGN (fl1) ? -l : l);"}, {"sha": "6fc52e40d78282e5720964ed52f6cd07be53a5f1", "filename": "gcc/config/s390/libgcc-glibc.ver", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flibgcc-glibc.ver?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -23,7 +23,7 @@\n # to defer implementation of these routines to libgcc.so via DT_AUXILIARY.\n \n # Note that we cannot use the default libgcc-glibc.ver file on s390x,\n-# because GLIBC_2.0 does not exist on this architecture, as the first \n+# because GLIBC_2.0 does not exist on this architecture, as the first\n # ever glibc release on the platform was GLIBC_2.2.\n \n %ifndef __s390x__"}, {"sha": "be2bf6ea798288fecbae2626b28604746e6c0ee7", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -45,8 +45,8 @@ Signed compares\n \n CCS:  EQ          LT           GT          UNORDERED  (LTGFR, LTGR, LTR, ICM/Y,\n                                                        LTDBR, LTDR, LTEBR, LTER,\n-                                                       CG/R, C/R/Y, CGHI, CHI, \n-                                                       CDB/R, CD/R, CEB/R, CE/R, \n+                                                       CG/R, C/R/Y, CGHI, CHI,\n+                                                       CDB/R, CD/R, CEB/R, CE/R,\n                                                        ADB/R, AEB/R, SDB/R, SEB/R,\n                                                        SRAG, SRA, SRDA)\n CCSR: EQ          GT           LT          UNORDERED  (CGF/R, CH/Y)\n@@ -60,7 +60,7 @@ CCAN: EQ          LT           GT          GT         (AGHI, AHI)\n Condition codes of unsigned adds and subs\n \n CCL:  EQ          NE           EQ          NE         (ALGF/R, ALG/R, AL/R/Y,\n-                                                       ALCG/R, ALC/R, \n+                                                       ALCG/R, ALC/R,\n                                                        SLGF/R, SLG/R, SL/R/Y,\n                                                        SLBG/R, SLB/R)\n CCL1: GEU         GEU          LTU         LTU        (ALG/R, AL/R/Y)\n@@ -69,14 +69,14 @@ CCL3: EQ          LTU          EQ          GTU        (SLG/R, SL/R/Y)\n \n Test under mask checks\n \n-CCT:  EQ          NE           NE          NE         (ICM/Y, TML, CG/R, CGHI, \n+CCT:  EQ          NE           NE          NE         (ICM/Y, TML, CG/R, CGHI,\n                                                        C/R/Y, CHI, NG/R, N/R/Y,\n                                                        OG/R, O/R/Y, XG/R, X/R/Y)\n CCT1: NE          EQ           NE          NE         (TMH, TML)\n CCT2: NE          NE           EQ          NE         (TMH, TML)\n CCT3: NE          NE           NE          EQ         (TMH, TML)\n \n-CCA and CCT modes are request only modes. These modes are never returned by \n+CCA and CCT modes are request only modes. These modes are never returned by\n s390_select_cc_mode. They are only intended to match other modes.\n \n Requested mode            -> Destination CC register mode\n@@ -89,11 +89,11 @@ CCA                       -> CCAP, CCAN\n \n CCAP, CCAN\n \n-The CC obtained from add instruction usually can't be used for comparisons \n+The CC obtained from add instruction usually can't be used for comparisons\n because its coupling with overflow flag. In case of an overflow the\n less than/greater than data are lost. Nevertheless a comparison can be done\n whenever immediate values are involved because they are known at compile time.\n-If you know whether the used constant is positive or negative you can predict \n+If you know whether the used constant is positive or negative you can predict\n the sign of the result even in case of an overflow.\n \n \n@@ -103,7 +103,7 @@ If bits of an integer masked with an AND instruction are checked, the test under\n mask instructions turn out to be very handy for a set of special cases.\n The simple cases are checks whether all masked bits are zero or ones:\n \n-  int a; \n+  int a;\n   if ((a & (16 + 128)) == 0)          -> CCT/CCZ\n   if ((a & (16 + 128)) == 16 + 128)   -> CCT3\n \n@@ -120,15 +120,15 @@ CCSR, CCUR\n \n There are several instructions comparing 32 bit with 64-bit unsigned/signed\n values. Such instructions can be considered to have a builtin zero/sign_extend.\n-The problem is that in the RTL (to be canonical) the zero/sign extended operand \n-has to be the first one but the machine instructions like it the other way \n-around. The following both modes can be considered as CCS and CCU modes with \n+The problem is that in the RTL (to be canonical) the zero/sign extended operand\n+has to be the first one but the machine instructions like it the other way\n+around. The following both modes can be considered as CCS and CCU modes with\n exchanged operands.\n \n \n CCL1, CCL2\n \n-These modes represent the result of overflow checks. \n+These modes represent the result of overflow checks.\n \n if (a + b < a) -> CCL1 state of the carry bit   (CC2 | CC3)\n if (a - b > a) -> CCL2 state of the borrow bit  (CC0 | CC1)\n@@ -142,7 +142,7 @@ CCL3\n \n A logical subtract instruction sets the borrow bit in case of an overflow.\n The resulting condition code of those instructions is represented by the\n-CCL3 mode. Together with the CCU mode this mode is used for jumpless \n+CCL3 mode. Together with the CCU mode this mode is used for jumpless\n implementations of several if-constructs - see s390_expand_addcc for more\n details.\n \n@@ -152,7 +152,7 @@ The compare and swap instructions sets the condition code to 0/1 if the\n operands were equal/unequal. The CCZ1 mode ensures the result can be\n effectively placed into a register.\n \n-*/   \n+*/\n \n \n CC_MODE (CCZ);"}, {"sha": "2329138cf1f563198e12995104de6e42a935c104", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \n \n-/* Prototypes of functions used for constraint evaluation in \n+/* Prototypes of functions used for constraint evaluation in\n    constraints.c.  */\n \n extern int s390_mem_constraint (const char *str, rtx op);\n@@ -92,7 +92,7 @@ extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx, rtx);\n-extern void s390_expand_atomic (enum machine_mode, enum rtx_code, \n+extern void s390_expand_atomic (enum machine_mode, enum rtx_code,\n \t\t\t\trtx, rtx, rtx, bool);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);"}, {"sha": "d5c3c22a93cfcbe290a07c73ba200f233cc5c8e5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 150, "deletions": 150, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Define the specific costs for a given cpu.  */\n \n-struct processor_costs \n+struct processor_costs\n {\n   /* multiplication */\n   const int m;        /* cost of an M instruction.  */\n@@ -94,7 +94,7 @@ struct processor_costs\n const struct processor_costs *s390_cost;\n \n static const\n-struct processor_costs z900_cost = \n+struct processor_costs z900_cost =\n {\n   COSTS_N_INSNS (5),     /* M     */\n   COSTS_N_INSNS (10),    /* MGHI  */\n@@ -126,7 +126,7 @@ struct processor_costs z900_cost =\n };\n \n static const\n-struct processor_costs z990_cost = \n+struct processor_costs z990_cost =\n {\n   COSTS_N_INSNS (4),     /* M     */\n   COSTS_N_INSNS (2),     /* MGHI  */\n@@ -158,7 +158,7 @@ struct processor_costs z990_cost =\n };\n \n static const\n-struct processor_costs z9_109_cost = \n+struct processor_costs z9_109_cost =\n {\n   COSTS_N_INSNS (4),     /* M     */\n   COSTS_N_INSNS (2),     /* MGHI  */\n@@ -252,7 +252,7 @@ HOST_WIDE_INT s390_warn_framesize = 0;\n HOST_WIDE_INT s390_stack_size = 0;\n HOST_WIDE_INT s390_stack_guard = 0;\n \n-/* The following structure is embedded in the machine \n+/* The following structure is embedded in the machine\n    specific part of struct function.  */\n \n struct GTY (()) s390_frame_layout\n@@ -275,8 +275,8 @@ struct GTY (()) s390_frame_layout\n   int last_save_gpr;\n   int last_restore_gpr;\n \n-  /* Bits standing for floating point registers. Set, if the \n-     respective register has to be saved. Starting with reg 16 (f0) \n+  /* Bits standing for floating point registers. Set, if the\n+     respective register has to be saved. Starting with reg 16 (f0)\n      at the rightmost bit.\n      Bit 15 -  8  7  6  5  4  3  2  1  0\n      fpr 15 -  8  7  5  3  1  6  4  2  0\n@@ -400,7 +400,7 @@ s390_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n     case CCZ1mode:\n       if (m2 == CCZmode)\n \treturn m1;\n-      \n+\n       return VOIDmode;\n \n     default:\n@@ -510,7 +510,7 @@ s390_tm_ccmode (rtx op1, rtx op2, bool mixed)\n   if (INTVAL (op2) == 0)\n     return CCTmode;\n \n-  /* Selected bits all one: CC3. \n+  /* Selected bits all one: CC3.\n      e.g.: int a; if ((a & (16 + 128)) == 16 + 128) */\n   if (INTVAL (op2) == INTVAL (op1))\n     return CCT3mode;\n@@ -582,7 +582,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n       case GT:\n \t/* The only overflow condition of NEG and ABS happens when\n \t   -INT_MAX is used as parameter, which stays negative. So\n-\t   we have an overflow from a positive value to a negative. \n+\t   we have an overflow from a positive value to a negative.\n \t   Using CCAP mode the resulting cc can be used for comparisons.  */\n \tif ((GET_CODE (op0) == NEG || GET_CODE (op0) == ABS)\n \t    && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n@@ -591,7 +591,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n  \t/* If constants are involved in an add instruction it is possible to use\n  \t   the resulting cc for comparisons with zero. Knowing the sign of the\n \t   constant the overflow behavior gets predictable. e.g.:\n- \t     int a, b; if ((b = a + c) > 0)  \n+ \t     int a, b; if ((b = a + c) > 0)\n  \t   with c as a constant value: c < 0 -> CCAN and c >= 0 -> CCAP  */\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t    && CONST_OK_FOR_K (INTVAL (XEXP (op0, 1))))\n@@ -714,7 +714,7 @@ s390_canonicalize_comparison (enum rtx_code *code, rtx *op0, rtx *op1)\n       && GET_CODE (*op1) == CONST_INT\n       && INTVAL (*op1) == 0xffff\n       && SCALAR_INT_MODE_P (GET_MODE (*op0))\n-      && (nonzero_bits (*op0, GET_MODE (*op0)) \n+      && (nonzero_bits (*op0, GET_MODE (*op0))\n \t  & ~(unsigned HOST_WIDE_INT) 0xffff) == 0)\n     {\n       *op0 = gen_lowpart (HImode, *op0);\n@@ -822,7 +822,7 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n       emit_insn (gen_rtx_SET (VOIDmode, cc, gen_rtx_COMPARE (mode, op0, op1)));\n     }\n \n-  return gen_rtx_fmt_ee (code, VOIDmode, cc, const0_rtx); \n+  return gen_rtx_fmt_ee (code, VOIDmode, cc, const0_rtx);\n }\n \n /* Emit a SImode compare and swap instruction setting MEM to NEW_RTX if OLD\n@@ -1296,9 +1296,9 @@ s390_overlap_p (rtx mem1, rtx mem2, HOST_WIDE_INT size)\n \n   /* This overlapping check is used by peepholes merging memory block operations.\n      Overlapping operations would otherwise be recognized by the S/390 hardware\n-     and would fall back to a slower implementation. Allowing overlapping \n+     and would fall back to a slower implementation. Allowing overlapping\n      operations would lead to slow code but not to wrong code. Therefore we are\n-     somewhat optimistic if we cannot prove that the memory blocks are \n+     somewhat optimistic if we cannot prove that the memory blocks are\n      overlapping.\n      That's why we return false here although this may accept operations on\n      overlapping memory areas.  */\n@@ -1621,7 +1621,7 @@ override_options (void)\n \terror (\"stack size must not be greater than 64k\");\n     }\n   else if (s390_stack_guard)\n-    error (\"-mstack-guard implies use of -mstack-size\"); \n+    error (\"-mstack-guard implies use of -mstack-size\");\n \n #ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n   if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))\n@@ -1804,7 +1804,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t  {\n \t  case UNSPEC_LTREF:\n \t    if (!disp)\n-\t      disp = gen_rtx_UNSPEC (Pmode, \n+\t      disp = gen_rtx_UNSPEC (Pmode,\n \t\t\t\t     gen_rtvec (1, XVECEXP (base, 0, 0)),\n \t\t\t\t     UNSPEC_LTREL_OFFSET);\n \t    else\n@@ -1824,8 +1824,8 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    return false;\n \t  }\n \n-      if (!REG_P (base) \n-\t  || (GET_MODE (base) != SImode \n+      if (!REG_P (base)\n+\t  || (GET_MODE (base) != SImode\n \t      && GET_MODE (base) != Pmode))\n \treturn false;\n \n@@ -1852,7 +1852,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t  {\n \t  case UNSPEC_LTREF:\n \t    if (!disp)\n-\t      disp = gen_rtx_UNSPEC (Pmode, \n+\t      disp = gen_rtx_UNSPEC (Pmode,\n \t\t\t\t     gen_rtvec (1, XVECEXP (indx, 0, 0)),\n \t\t\t\t     UNSPEC_LTREL_OFFSET);\n \t    else\n@@ -1872,7 +1872,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    return false;\n \t  }\n \n-      if (!REG_P (indx) \n+      if (!REG_P (indx)\n \t  || (GET_MODE (indx) != SImode\n \t      && GET_MODE (indx) != Pmode))\n \treturn false;\n@@ -1904,21 +1904,21 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n   /* Validate displacement.  */\n   if (!disp)\n     {\n-      /* If virtual registers are involved, the displacement will change later \n-\t anyway as the virtual registers get eliminated.  This could make a \n-\t valid displacement invalid, but it is more likely to make an invalid \n-\t displacement valid, because we sometimes access the register save area \n+      /* If virtual registers are involved, the displacement will change later\n+\t anyway as the virtual registers get eliminated.  This could make a\n+\t valid displacement invalid, but it is more likely to make an invalid\n+\t displacement valid, because we sometimes access the register save area\n \t via negative offsets to one of those registers.\n \t Thus we don't check the displacement for validity here.  If after\n \t elimination the displacement turns out to be invalid after all,\n \t this is fixed up by reload in any case.  */\n-      if (base != arg_pointer_rtx \n-\t  && indx != arg_pointer_rtx \n-\t  && base != return_address_pointer_rtx \n+      if (base != arg_pointer_rtx\n+\t  && indx != arg_pointer_rtx\n+\t  && base != return_address_pointer_rtx\n \t  && indx != return_address_pointer_rtx\n-\t  && base != frame_pointer_rtx \n+\t  && base != frame_pointer_rtx\n \t  && indx != frame_pointer_rtx\n-\t  && base != virtual_stack_vars_rtx \n+\t  && base != virtual_stack_vars_rtx\n \t  && indx != virtual_stack_vars_rtx)\n \tif (!DISP_IN_RANGE (offset))\n \t  return false;\n@@ -2271,8 +2271,8 @@ s390_float_const_zero_p (rtx value)\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n-   scanned.  In either case, *TOTAL contains the cost result.  \n-   CODE contains GET_CODE (x), OUTER_CODE contains the code \n+   scanned.  In either case, *TOTAL contains the cost result.\n+   CODE contains GET_CODE (x), OUTER_CODE contains the code\n    of the superexpression of x.  */\n \n static bool\n@@ -2323,7 +2323,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total,\n       *total = COSTS_N_INSNS (1);\n       return false;\n \n-    case MULT:      \n+    case MULT:\n       switch (GET_MODE (x))\n \t{\n \tcase SImode:\n@@ -3104,11 +3104,11 @@ s390_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n     }\n   else\n     {\n-      if (ad.base \n+      if (ad.base\n \t  && !(REGNO (ad.base) >= FIRST_PSEUDO_REGISTER\n \t       || REGNO_REG_CLASS (REGNO (ad.base)) == ADDR_REGS))\n \treturn false;\n-      \n+\n       if (ad.indx\n \t  && !(REGNO (ad.indx) >= FIRST_PSEUDO_REGISTER\n \t       || REGNO_REG_CLASS (REGNO (ad.indx)) == ADDR_REGS))\n@@ -3354,7 +3354,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n                     gcc_unreachable ();\n                 }\n \t    }\n-\t  else \n+\t  else\n \t    gcc_assert (GET_CODE (addr) == PLUS);\n \t}\n       if (GET_CODE (addr) == PLUS)\n@@ -3743,7 +3743,7 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \treturn x;\n     }\n   else if (GET_CODE (x) == PLUS\n-\t   && (TLS_SYMBOLIC_CONST (XEXP (x, 0)) \n+\t   && (TLS_SYMBOLIC_CONST (XEXP (x, 0))\n \t       || TLS_SYMBOLIC_CONST (XEXP (x, 1))))\n     {\n       return x;\n@@ -3822,7 +3822,7 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n    MODE is the mode of the enclosing MEM.  OPNUM is the operand number\n    and TYPE is the reload type of the current reload.  */\n \n-rtx \n+rtx\n legitimize_reload_address (rtx ad, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   int opnum, int type)\n {\n@@ -3854,7 +3854,7 @@ legitimize_reload_address (rtx ad, enum machine_mode mode ATTRIBUTE_UNUSED,\n       new_rtx = gen_rtx_PLUS (Pmode, tem, GEN_INT (lower));\n \n       push_reload (XEXP (tem, 1), 0, &XEXP (tem, 1), 0,\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, \n+\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n       return new_rtx;\n     }\n@@ -3952,7 +3952,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n     return;\n \n   gcc_assert (GET_CODE (val) == CONST_INT || GET_MODE (val) == QImode);\n-  \n+\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) > 0 && INTVAL (len) <= 257)\n     {\n       if (val == const0_rtx && INTVAL (len) <= 256)\n@@ -3961,7 +3961,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t{\n \t  /* Initialize memory by storing the first byte.  */\n \t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n-\t  \n+\n \t  if (INTVAL (len) > 1)\n \t    {\n \t      /* Initiate 1 byte overlap move.\n@@ -3972,7 +3972,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \t      rtx dstp1 = adjust_address (dst, VOIDmode, 1);\n \t      set_mem_size (dst, const1_rtx);\n \n-\t      emit_insn (gen_movmem_short (dstp1, dst, \n+\t      emit_insn (gen_movmem_short (dstp1, dst,\n \t\t\t\t\t   GEN_INT (INTVAL (len) - 2)));\n \t    }\n \t}\n@@ -4018,7 +4018,7 @@ s390_expand_setmem (rtx dst, rtx len, rtx val)\n \n \t  /* Initialize memory by storing the first byte.  */\n \t  emit_move_insn (adjust_address (dst, QImode, 0), val);\n-\t  \n+\n \t  /* If count is 1 we are done.  */\n \t  emit_cmp_and_jump_insns (count, const1_rtx,\n \t\t\t\t   EQ, NULL_RTX, mode, 1, end_label);\n@@ -4268,9 +4268,9 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n \t}\n \n       p = rtvec_alloc (2);\n-      RTVEC_ELT (p, 0) = \n+      RTVEC_ELT (p, 0) =\n         gen_rtx_SET (VOIDmode, dst, op_res);\n-      RTVEC_ELT (p, 1) = \n+      RTVEC_ELT (p, 1) =\n \tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n \n@@ -4329,15 +4329,15 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n       if (!register_operand (src, GET_MODE (dst)))\n \tsrc = force_reg (GET_MODE (dst), src);\n \n-      op_res = gen_rtx_MINUS (GET_MODE (dst), \n-\t\t\t      gen_rtx_MINUS (GET_MODE (dst), src, const0_rtx), \n-\t\t\t      gen_rtx_fmt_ee (cmp_code, GET_MODE (dst), \n-\t\t\t\t\t      gen_rtx_REG (cc_mode, CC_REGNUM), \n+      op_res = gen_rtx_MINUS (GET_MODE (dst),\n+\t\t\t      gen_rtx_MINUS (GET_MODE (dst), src, const0_rtx),\n+\t\t\t      gen_rtx_fmt_ee (cmp_code, GET_MODE (dst),\n+\t\t\t\t\t      gen_rtx_REG (cc_mode, CC_REGNUM),\n \t\t\t\t\t      const0_rtx));\n       p = rtvec_alloc (2);\n-      RTVEC_ELT (p, 0) = \n+      RTVEC_ELT (p, 0) =\n         gen_rtx_SET (VOIDmode, dst, op_res);\n-      RTVEC_ELT (p, 1) = \n+      RTVEC_ELT (p, 1) =\n \tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n \n@@ -4397,7 +4397,7 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \t  set_mem_size (dest, GEN_INT (size));\n \t  s390_expand_movmem (dest, src_mem, GEN_INT (size));\n \t}\n-\t  \n+\n       /* (set (ze (mem)) (reg)).  */\n       else if (register_operand (src, word_mode))\n \t{\n@@ -4410,7 +4410,7 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \t      int stcmh_width = bitsize - GET_MODE_BITSIZE (SImode);\n \t      int size = stcmh_width / BITS_PER_UNIT;\n \n-\t      emit_move_insn (adjust_address (dest, SImode, size), \n+\t      emit_move_insn (adjust_address (dest, SImode, size),\n \t\t\t      gen_lowpart (SImode, src));\n \t      set_mem_size (dest, GEN_INT (size));\n \t      emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, GEN_INT\n@@ -4427,7 +4427,7 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \n   /* (set (ze (reg)) (const_int)).  */\n   if (TARGET_ZARCH\n-      && register_operand (dest, word_mode) \n+      && register_operand (dest, word_mode)\n       && (bitpos % 16) == 0\n       && (bitsize % 16) == 0\n       && const_int_operand (src, VOIDmode))\n@@ -4447,9 +4447,9 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n \n \t  putsize = GET_MODE_BITSIZE (putmode);\n \t  regpos -= putsize;\n-\t  emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest, \n+\t  emit_move_insn (gen_rtx_ZERO_EXTRACT (word_mode, dest,\n \t\t\t\t\t\tGEN_INT (putsize),\n-\t\t\t\t\t\tGEN_INT (regpos)), \n+\t\t\t\t\t\tGEN_INT (regpos)),\n \t\t\t  gen_int_mode (val, putmode));\n \t  val >>= putsize;\n \t}\n@@ -4468,16 +4468,16 @@ s390_expand_mask_and_shift (rtx val, enum machine_mode mode, rtx count)\n {\n   val = expand_simple_binop (SImode, AND, val, GEN_INT (GET_MODE_MASK (mode)),\n \t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n-  return expand_simple_binop (SImode, ASHIFT, val, count, \n+  return expand_simple_binop (SImode, ASHIFT, val, count,\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n }\n \n /* Structure to hold the initial parameters for a compare_and_swap operation\n-   in HImode and QImode.  */ \n+   in HImode and QImode.  */\n \n struct alignment_context\n {\n-  rtx memsi;\t  /* SI aligned memory location.  */ \n+  rtx memsi;\t  /* SI aligned memory location.  */\n   rtx shift;\t  /* Bit offset with regard to lsb.  */\n   rtx modemask;\t  /* Mask of the HQImode shifted by SHIFT bits.  */\n   rtx modemaski;  /* ~modemask */\n@@ -4529,7 +4529,7 @@ init_alignment_context (struct alignment_context *ac, rtx mem,\n   ac->shift = expand_simple_binop (SImode, MULT, ac->shift, GEN_INT (BITS_PER_UNIT),\n \t\t\t\t  NULL_RTX, 1, OPTAB_DIRECT);\n   /* Calculate masks.  */\n-  ac->modemask = expand_simple_binop (SImode, ASHIFT, \n+  ac->modemask = expand_simple_binop (SImode, ASHIFT,\n \t\t\t\t     GEN_INT (GET_MODE_MASK (mode)), ac->shift,\n \t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n   ac->modemaski = expand_simple_unop (SImode, NOT, ac->modemask, NULL_RTX, 1);\n@@ -4567,9 +4567,9 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n \n   /* Start CS loop.  */\n   emit_label (csloop);\n-  /* val = \"<mem>00..0<mem>\" \n+  /* val = \"<mem>00..0<mem>\"\n    * cmp = \"00..0<cmp>00..0\"\n-   * new = \"00..0<new>00..0\" \n+   * new = \"00..0<new>00..0\"\n    */\n \n   /* Patch cmp and new with val at correct position.  */\n@@ -4595,17 +4595,17 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n \t\t\t\t\t\t     cmpv, newv));\n \n   /* Check for changes outside mode.  */\n-  resv = expand_simple_binop (SImode, AND, res, ac.modemaski, \n+  resv = expand_simple_binop (SImode, AND, res, ac.modemaski,\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n-  cc = s390_emit_compare (NE, resv, val); \n+  cc = s390_emit_compare (NE, resv, val);\n   emit_move_insn (val, resv);\n   /* Loop internal if so.  */\n   s390_emit_jump (csloop, cc);\n \n   emit_label (csend);\n-  \n+\n   /* Return the correct part of the bitfield.  */\n-  convert_move (target, expand_simple_binop (SImode, LSHIFTRT, res, ac.shift, \n+  convert_move (target, expand_simple_binop (SImode, LSHIFTRT, res, ac.shift,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT), 1);\n }\n \n@@ -4659,7 +4659,7 @@ s390_expand_atomic (enum machine_mode mode, enum rtx_code code,\n       val = expand_simple_binop (SImode, AND, val, ac.modemask,\n \t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n       /* FALLTHRU */\n-    case SET: \n+    case SET:\n       if (ac.aligned && MEM_P (val))\n \tstore_bit_field (new_rtx, GET_MODE_BITSIZE (mode), 0, SImode, val);\n       else\n@@ -5511,8 +5511,8 @@ s390_split_branches (void)\n }\n \n \n-/* Find an annotated literal pool symbol referenced in RTX X, \n-   and store it at REF.  Will abort if X contains references to \n+/* Find an annotated literal pool symbol referenced in RTX X,\n+   and store it at REF.  Will abort if X contains references to\n    more than one such pool symbol; multiple references to the same\n    symbol are allowed, however.\n \n@@ -5545,7 +5545,7 @@ find_constant_pool_ref (rtx x, rtx *ref)\n \n       if (*ref == NULL_RTX)\n \t*ref = sym;\n-      else \n+      else\n \tgcc_assert (*ref == sym);\n \n       return;\n@@ -5566,7 +5566,7 @@ find_constant_pool_ref (rtx x, rtx *ref)\n     }\n }\n \n-/* Replace every reference to the annotated literal pool \n+/* Replace every reference to the annotated literal pool\n    symbol REF in X by its base plus OFFSET.  */\n \n static void\n@@ -6511,7 +6511,7 @@ s390_chunkify_start (void)\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n     {\n-      rtx new_insn = gen_reload_base (cfun->machine->base_reg, \n+      rtx new_insn = gen_reload_base (cfun->machine->base_reg,\n \t\t\t\t      curr_pool->label);\n       rtx insn = curr_pool->first_insn;\n       INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n@@ -6526,7 +6526,7 @@ s390_chunkify_start (void)\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n \tif (pool)\n \t  {\n-\t    rtx new_insn = gen_reload_base (cfun->machine->base_reg, \n+\t    rtx new_insn = gen_reload_base (cfun->machine->base_reg,\n \t\t\t\t\t    pool->label);\n \t    INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n \t  }\n@@ -6763,7 +6763,7 @@ find_unused_clobbered_reg (void)\n }\n \n \n-/* Helper function for s390_regs_ever_clobbered.  Sets the fields in DATA for all \n+/* Helper function for s390_regs_ever_clobbered.  Sets the fields in DATA for all\n    clobbered hard regs in SETREG.  */\n \n static void\n@@ -6821,8 +6821,8 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n      deal with this automatically.  */\n   if (crtl->calls_eh_return || cfun->machine->has_landing_pad_p)\n     for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM ; i++)\n-      if (crtl->calls_eh_return \n-\t  || (cfun->machine->has_landing_pad_p \n+      if (crtl->calls_eh_return\n+\t  || (cfun->machine->has_landing_pad_p\n \t      && df_regs_ever_live_p (EH_RETURN_DATA_REGNO (i))))\n \tregs_ever_clobbered[EH_RETURN_DATA_REGNO (i)] = 1;\n \n@@ -6841,16 +6841,16 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n \t{\n \t  if (INSN_P (cur_insn))\n \t    note_stores (PATTERN (cur_insn),\n-\t\t\t s390_reg_clobbered_rtx, \n+\t\t\t s390_reg_clobbered_rtx,\n \t\t\t regs_ever_clobbered);\n \t}\n     }\n }\n \n-/* Determine the frame area which actually has to be accessed \n-   in the function epilogue. The values are stored at the \n+/* Determine the frame area which actually has to be accessed\n+   in the function epilogue. The values are stored at the\n    given pointers AREA_BOTTOM (address of the lowest used stack\n-   address) and AREA_TOP (address of the first item which does \n+   address) and AREA_TOP (address of the first item which does\n    not belong to the stack frame).  */\n \n static void\n@@ -6884,7 +6884,7 @@ s390_frame_area (int *area_bottom, int *area_top)\n \t  b = MIN (b, cfun_frame_layout.f4_offset + (i - 2) * 8);\n \t  t = MAX (t, cfun_frame_layout.f4_offset + (i - 1) * 8);\n \t}\n-  \n+\n   *area_bottom = b;\n   *area_top = t;\n }\n@@ -6923,10 +6923,10 @@ s390_register_info (int clobbered_regs[])\n     clobbered_regs[HARD_FRAME_POINTER_REGNUM] = 1;\n \n   if (flag_pic)\n-    clobbered_regs[PIC_OFFSET_TABLE_REGNUM] \n+    clobbered_regs[PIC_OFFSET_TABLE_REGNUM]\n       |= df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n \n-  clobbered_regs[BASE_REGNUM] \n+  clobbered_regs[BASE_REGNUM]\n     |= (cfun->machine->base_reg\n         && REGNO (cfun->machine->base_reg) == BASE_REGNUM);\n \n@@ -6969,16 +6969,16 @@ s390_register_info (int clobbered_regs[])\n       cfun_frame_layout.first_save_gpr_slot = i;\n       cfun_frame_layout.last_save_gpr_slot = j;\n \n-      for (i = cfun_frame_layout.first_save_gpr_slot; \n-\t   i < cfun_frame_layout.last_save_gpr_slot + 1; \n+      for (i = cfun_frame_layout.first_save_gpr_slot;\n+\t   i < cfun_frame_layout.last_save_gpr_slot + 1;\n \t   i++)\n \tif (clobbered_regs[i])\n \t  break;\n \n       for (j = cfun_frame_layout.last_save_gpr_slot; j > i; j--)\n \tif (clobbered_regs[j])\n \t  break;\n-      \n+\n       if (i == cfun_frame_layout.last_save_gpr_slot + 1)\n \t{\n \t  /* Nothing to save/restore.  */\n@@ -7058,7 +7058,7 @@ s390_frame_info (void)\n   cfun_frame_layout.frame_size = get_frame_size ();\n   if (!TARGET_64BIT && cfun_frame_layout.frame_size > 0x7fff0000)\n     fatal_error (\"total size of local variables exceeds architecture limit\");\n-  \n+\n   if (!TARGET_PACKED_STACK)\n     {\n       cfun_frame_layout.backchain_offset = 0;\n@@ -7072,46 +7072,46 @@ s390_frame_info (void)\n     {\n       cfun_frame_layout.backchain_offset = (STACK_POINTER_OFFSET\n \t\t\t\t\t    - UNITS_PER_WORD);\n-      cfun_frame_layout.gprs_offset \n-\t= (cfun_frame_layout.backchain_offset \n+      cfun_frame_layout.gprs_offset\n+\t= (cfun_frame_layout.backchain_offset\n \t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr_slot + 1)\n \t   * UNITS_PER_WORD);\n-\t  \n+\n       if (TARGET_64BIT)\n \t{\n-\t  cfun_frame_layout.f4_offset \n+\t  cfun_frame_layout.f4_offset\n \t    = (cfun_frame_layout.gprs_offset\n \t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n-\t  \n-\t  cfun_frame_layout.f0_offset \n-\t    = (cfun_frame_layout.f4_offset \n+\n+\t  cfun_frame_layout.f0_offset\n+\t    = (cfun_frame_layout.f4_offset\n \t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n \t}\n       else\n \t{\n \t  /* On 31 bit we have to care about alignment of the\n \t     floating point regs to provide fastest access.  */\n-\t  cfun_frame_layout.f0_offset \n-\t    = ((cfun_frame_layout.gprs_offset \n+\t  cfun_frame_layout.f0_offset\n+\t    = ((cfun_frame_layout.gprs_offset\n \t\t& ~(STACK_BOUNDARY / BITS_PER_UNIT - 1))\n \t       - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n-\t  \n-\t  cfun_frame_layout.f4_offset \n+\n+\t  cfun_frame_layout.f4_offset\n \t    = (cfun_frame_layout.f0_offset\n \t       - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n \t}\n     }\n   else /* no backchain */\n     {\n-      cfun_frame_layout.f4_offset \n+      cfun_frame_layout.f4_offset\n \t= (STACK_POINTER_OFFSET\n \t   - 8 * (cfun_fpr_bit_p (2) + cfun_fpr_bit_p (3)));\n-      \n-      cfun_frame_layout.f0_offset \n+\n+      cfun_frame_layout.f0_offset\n \t= (cfun_frame_layout.f4_offset\n \t   - 8 * (cfun_fpr_bit_p (0) + cfun_fpr_bit_p (1)));\n-      \n-      cfun_frame_layout.gprs_offset \n+\n+      cfun_frame_layout.gprs_offset\n \t= cfun_frame_layout.f0_offset - cfun_gprs_save_area_size;\n     }\n \n@@ -7132,7 +7132,7 @@ s390_frame_info (void)\n       if (TARGET_BACKCHAIN)\n \tcfun_frame_layout.frame_size += UNITS_PER_WORD;\n \n-      /* No alignment trouble here because f8-f15 are only saved under \n+      /* No alignment trouble here because f8-f15 are only saved under\n \t 64 bit.  */\n       cfun_frame_layout.f8_offset = (MIN (MIN (cfun_frame_layout.f0_offset,\n \t\t\t\t\t       cfun_frame_layout.f4_offset),\n@@ -7144,9 +7144,9 @@ s390_frame_info (void)\n       for (i = 0; i < 8; i++)\n \tif (cfun_fpr_bit_p (i))\n \t  cfun_frame_layout.frame_size += 8;\n-      \n+\n       cfun_frame_layout.frame_size += cfun_gprs_save_area_size;\n-      \n+\n       /* If under 31 bit an odd number of gprs has to be saved we have to adjust\n \t the frame size to sustain 8 byte alignment of stack frames.  */\n       cfun_frame_layout.frame_size = ((cfun_frame_layout.frame_size +\n@@ -7213,11 +7213,11 @@ s390_update_frame_layout (void)\n \n   s390_register_info (clobbered_regs);\n \n-  df_set_regs_ever_live (BASE_REGNUM, \n+  df_set_regs_ever_live (BASE_REGNUM,\n \t\t\t clobbered_regs[BASE_REGNUM] ? true : false);\n-  df_set_regs_ever_live (RETURN_REGNUM, \n+  df_set_regs_ever_live (RETURN_REGNUM,\n \t\t\t clobbered_regs[RETURN_REGNUM] ? true : false);\n-  df_set_regs_ever_live (STACK_POINTER_REGNUM, \n+  df_set_regs_ever_live (STACK_POINTER_REGNUM,\n \t\t\t clobbered_regs[STACK_POINTER_REGNUM] ? true : false);\n \n   if (cfun->machine->base_reg)\n@@ -7249,10 +7249,10 @@ s390_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n     case GENERAL_REGS:\n       if (REGNO_PAIR_OK (regno, mode))\n \t{\n-\t  if (TARGET_64BIT \n+\t  if (TARGET_64BIT\n \t      || (mode != TFmode && mode != TCmode && mode != TDmode))\n \t    return true;\n-\t}\t  \n+\t}\n       break;\n     case CC_REGS:\n       if (GET_MODE_CLASS (mode) == MODE_CC)\n@@ -7268,7 +7268,7 @@ s390_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n     default:\n       return false;\n     }\n-  \n+\n   return false;\n }\n \n@@ -7365,7 +7365,7 @@ s390_initial_elimination_offset (int from, int to)\n   switch (from)\n     {\n     case FRAME_POINTER_REGNUM:\n-      offset = (get_frame_size() \n+      offset = (get_frame_size()\n \t\t+ STACK_POINTER_OFFSET\n \t\t+ crtl->outgoing_args_size);\n       break;\n@@ -7460,7 +7460,7 @@ save_gprs (rtx base, int offset, int first, int last)\n     for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n       {\n \trtx mem = XEXP (XVECEXP (PATTERN (insn), 0, i), 0);\n-\t\n+\n \tif (first + i <= 6)\n \t  set_mem_alias_set (mem, get_varargs_alias_set ());\n       }\n@@ -7624,8 +7624,8 @@ s390_emit_prologue (void)\n   /* Choose best register to use for temp use within prologue.\n      See below for why TPF must use the register 1.  */\n \n-  if (!has_hard_reg_initial_val (Pmode, RETURN_REGNUM) \n-      && !current_function_is_leaf \n+  if (!has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n+      && !current_function_is_leaf\n       && !TARGET_TPF_PROFILING)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   else\n@@ -7634,11 +7634,11 @@ s390_emit_prologue (void)\n   /* Save call saved gprs.  */\n   if (cfun_frame_layout.first_save_gpr != -1)\n     {\n-      insn = save_gprs (stack_pointer_rtx, \n-\t\t\tcfun_frame_layout.gprs_offset + \n-\t\t\tUNITS_PER_WORD * (cfun_frame_layout.first_save_gpr \n+      insn = save_gprs (stack_pointer_rtx,\n+\t\t\tcfun_frame_layout.gprs_offset +\n+\t\t\tUNITS_PER_WORD * (cfun_frame_layout.first_save_gpr\n \t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n-\t\t\tcfun_frame_layout.first_save_gpr, \n+\t\t\tcfun_frame_layout.first_save_gpr,\n \t\t\tcfun_frame_layout.last_save_gpr);\n       emit_insn (insn);\n     }\n@@ -7691,14 +7691,14 @@ s390_emit_prologue (void)\n \tif (cfun_fpr_bit_p (i))\n \t  {\n \t    insn = save_fpr (stack_pointer_rtx, offset, i + 16);\n-\t    \t       \n+\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    offset -= 8;\n \t  }\n       if (offset >= cfun_frame_layout.f8_offset)\n \tnext_fpr = i + 16;\n     }\n-  \n+\n   if (!TARGET_PACKED_STACK)\n     next_fpr = cfun_save_high_fprs_p ? 31 : 0;\n \n@@ -7750,9 +7750,9 @@ s390_emit_prologue (void)\n \t    }\n   \t}\n \n-      if (s390_warn_framesize > 0 \n+      if (s390_warn_framesize > 0\n \t  && cfun_frame_layout.frame_size >= s390_warn_framesize)\n-\twarning (0, \"frame size of %qs is \" HOST_WIDE_INT_PRINT_DEC \" bytes\", \n+\twarning (0, \"frame size of %qs is \" HOST_WIDE_INT_PRINT_DEC \" bytes\",\n \t\t current_function_name (), cfun_frame_layout.frame_size);\n \n       if (s390_warn_dynamicstack_p && cfun->calls_alloca)\n@@ -7767,7 +7767,7 @@ s390_emit_prologue (void)\n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n \t  insn = gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx, \n+\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t\t\t    frame_off));\n \t  insn = emit_insn (insn);\n \t}\n@@ -7792,11 +7792,11 @@ s390_emit_prologue (void)\n       if (TARGET_BACKCHAIN)\n \t{\n \t  if (cfun_frame_layout.backchain_offset)\n-\t    addr = gen_rtx_MEM (Pmode, \n-\t\t\t\tplus_constant (stack_pointer_rtx, \n+\t    addr = gen_rtx_MEM (Pmode,\n+\t\t\t\tplus_constant (stack_pointer_rtx,\n \t\t\t\t  cfun_frame_layout.backchain_offset));\n \t  else\n-\t    addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);  \n+\t    addr = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n \t  set_mem_alias_set (addr, get_frame_alias_set ());\n \t  insn = emit_insn (gen_move_insn (addr, temp_reg));\n \t}\n@@ -7821,7 +7821,7 @@ s390_emit_prologue (void)\n \t moved below the use of the stack slots.  */\n       s390_emit_stack_tie ();\n \n-      insn = emit_insn (gen_add2_insn (temp_reg, \n+      insn = emit_insn (gen_add2_insn (temp_reg,\n \t\t\t\t       GEN_INT (cfun_frame_layout.f8_offset)));\n \n       offset = 0;\n@@ -7833,7 +7833,7 @@ s390_emit_prologue (void)\n \t\t\t\t      cfun_frame_layout.frame_size\n \t\t\t\t      + cfun_frame_layout.f8_offset\n \t\t\t\t      + offset);\n-\t    \n+\n \t    insn = save_fpr (temp_reg, offset, i);\n \t    offset += 8;\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n@@ -7904,7 +7904,7 @@ s390_emit_epilogue (bool sibcall)\n \n   /* Check whether to use frame or stack pointer for restore.  */\n \n-  frame_pointer = (frame_pointer_needed \n+  frame_pointer = (frame_pointer_needed\n \t\t   ? hard_frame_pointer_rtx : stack_pointer_rtx);\n \n   s390_frame_area (&area_bottom, &area_top);\n@@ -7962,7 +7962,7 @@ s390_emit_epilogue (bool sibcall)\n \t\t}\n \t    }\n \t}\n-\t      \n+\n     }\n   else\n     {\n@@ -7978,7 +7978,7 @@ s390_emit_epilogue (bool sibcall)\n \t  else if (!TARGET_PACKED_STACK)\n \t    next_offset += 8;\n \t}\n-      \n+\n     }\n \n   /* Return register.  */\n@@ -8010,7 +8010,7 @@ s390_emit_epilogue (bool sibcall)\n \t  if (global_regs[i])\n \t    {\n \t      addr = plus_constant (frame_pointer,\n-\t\t\t\t    offset + cfun_frame_layout.gprs_offset \n+\t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (i - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n@@ -8035,7 +8035,7 @@ s390_emit_epilogue (bool sibcall)\n \n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n-\t\t\t\t    + (RETURN_REGNUM \n+\t\t\t\t    + (RETURN_REGNUM\n \t\t\t\t       - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n@@ -8046,7 +8046,7 @@ s390_emit_epilogue (bool sibcall)\n \n       insn = restore_gprs (frame_pointer,\n \t\t\t   offset + cfun_frame_layout.gprs_offset\n-\t\t\t   + (cfun_frame_layout.first_restore_gpr \n+\t\t\t   + (cfun_frame_layout.first_restore_gpr\n \t\t\t      - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t   * UNITS_PER_WORD,\n \t\t\t   cfun_frame_layout.first_restore_gpr,\n@@ -8456,7 +8456,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n       t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n \t          size_int (-RETURN_REGNUM * UNITS_PER_WORD));\n-  \n+\n       t = build2 (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -8488,7 +8488,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n    } */\n \n static tree\n-s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p, \n+s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t\t      gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav;\n@@ -8588,9 +8588,9 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   t = build3 (COND_EXPR, void_type_node, t, u, NULL_TREE);\n   gimplify_and_add (t, pre_p);\n \n-  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, \n+  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav,\n \t      size_int (sav_ofs));\n-  u = build2 (MULT_EXPR, TREE_TYPE (reg), reg, \n+  u = build2 (MULT_EXPR, TREE_TYPE (reg), reg,\n \t      fold_convert (TREE_TYPE (reg), size_int (sav_scale)));\n   t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, fold_convert (sizetype, u));\n \n@@ -8605,14 +8605,14 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \n   t = ovf;\n   if (size < UNITS_PER_WORD)\n-    t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, \n+    t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t,\n \t\tsize_int (UNITS_PER_WORD - size));\n \n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n   gimplify_assign (addr, t, pre_p);\n \n-  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, \n+  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t,\n \t      size_int (size));\n   gimplify_assign (ovf, t, pre_p);\n \n@@ -9268,7 +9268,7 @@ s390_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n {\n   *p1 = CC_REGNUM;\n   *p2 = INVALID_REGNUM;\n- \n+\n   return true;\n }\n \n@@ -9434,10 +9434,10 @@ s390_optimize_prologue (void)\n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n \n-  if (cfun_frame_layout.first_save_gpr <= BASE_REGNUM \n+  if (cfun_frame_layout.first_save_gpr <= BASE_REGNUM\n       && cfun_frame_layout.last_save_gpr >= BASE_REGNUM\n-      && (TARGET_CPU_ZARCH \n-          || (cfun_frame_layout.first_save_gpr <= RETURN_REGNUM \n+      && (TARGET_CPU_ZARCH\n+          || (cfun_frame_layout.first_save_gpr <= RETURN_REGNUM\n               && cfun_frame_layout.last_save_gpr >= RETURN_REGNUM)))\n     return;\n \n@@ -9477,9 +9477,9 @@ s390_optimize_prologue (void)\n \n \t  if (cfun_frame_layout.first_save_gpr != -1)\n \t    {\n-\t      new_insn \t= save_gprs (base, \n+\t      new_insn \t= save_gprs (base,\n \t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t    - first) * UNITS_PER_WORD, \n+\t\t\t\t\t    - first) * UNITS_PER_WORD,\n \t\t\t\t     cfun_frame_layout.first_save_gpr,\n \t\t\t\t     cfun_frame_layout.last_save_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);\n@@ -9538,9 +9538,9 @@ s390_optimize_prologue (void)\n \n \t  if (cfun_frame_layout.first_restore_gpr != -1)\n \t    {\n-\t      new_insn = restore_gprs (base, \n+\t      new_insn = restore_gprs (base,\n \t\t\t\t       off + (cfun_frame_layout.first_restore_gpr\n-\t\t\t\t\t      - first) * UNITS_PER_WORD, \n+\t\t\t\t\t      - first) * UNITS_PER_WORD,\n \t\t\t\t       cfun_frame_layout.first_restore_gpr,\n \t\t\t\t       cfun_frame_layout.last_restore_gpr);\n \t      new_insn = emit_insn_before (new_insn, insn);"}, {"sha": "f34b7f225671ac3e1eabc3c8b6921c914dfcea2c", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -180,7 +180,7 @@ extern int s390_arch_flags;\n #define S390_TDC_POSITIVE_NORMALIZED_DFP_NUMBER   (1 << 7)\n #define S390_TDC_NEGATIVE_NORMALIZED_DFP_NUMBER   (1 << 6)\n \n-/* For signbit, the BFP-DFP-difference makes no difference. */ \n+/* For signbit, the BFP-DFP-difference makes no difference. */\n #define S390_TDC_SIGNBIT_SET (S390_TDC_NEGATIVE_ZERO \\\n                           | S390_TDC_NEGATIVE_NORMALIZED_BFP_NUMBER \\\n                           | S390_TDC_NEGATIVE_DENORMALIZED_BFP_NUMBER\\\n@@ -298,10 +298,10 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    correspond to actual hardware:\n    Reg 32: Argument pointer\n    Reg 33: Condition code\n-   Reg 34: Frame pointer  \n+   Reg 34: Frame pointer\n    Reg 35: Return address pointer\n \n-   Registers 36 and 37 are mapped to access registers \n+   Registers 36 and 37 are mapped to access registers\n    0 and 1, used to implement thread-local storage.  */\n \n #define FIRST_PSEUDO_REGISTER 38\n@@ -455,7 +455,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n enum reg_class\n {\n   NO_REGS, CC_REGS, ADDR_REGS, GENERAL_REGS, ACCESS_REGS,\n-  ADDR_CC_REGS, GENERAL_CC_REGS, \n+  ADDR_CC_REGS, GENERAL_CC_REGS,\n   FP_REGS, ADDR_FP_REGS, GENERAL_FP_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n };\n@@ -575,7 +575,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    the argument area.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n \n-/* Defining this macro makes __builtin_frame_address(0) and \n+/* Defining this macro makes __builtin_frame_address(0) and\n    __builtin_return_address(0) work with -fomit-frame-pointer.  */\n #define INITIAL_FRAME_ADDRESS_RTX                                             \\\n   (plus_constant (arg_pointer_rtx, -STACK_POINTER_OFFSET))\n@@ -615,7 +615,7 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 6 : INVALID_REGNUM)\n #define EH_RETURN_HANDLER_RTX gen_rtx_MEM (Pmode, return_address_pointer_rtx)\n-       \n+\n /* Select a format to encode pointers in exception handling data.  */\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL)\t\t\t    \\\n   (flag_pic\t\t\t\t\t\t\t\t    \\\n@@ -807,7 +807,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define SLOW_BYTE_ACCESS 1\n \n /* An integer expression for the size in bits of the largest integer machine\n-   mode that should actually be used.  We allow pairs of registers.  */ \n+   mode that should actually be used.  We allow pairs of registers.  */\n #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TARGET_64BIT ? TImode : DImode)\n \n /* The maximum number of bytes that a single instruction can move quickly"}, {"sha": "17c36887e49996ea57968d266074fdaa4c199286", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -37,7 +37,7 @@\n ;;     %N: print the second word of a DImode operand.\n ;;     %M: print the second word of a TImode operand.\n ;;     %Y: print shift count operand.\n-;;  \n+;;\n ;;     %b: print integer X as if it's an unsigned byte.\n ;;     %c: print integer X as if it's an signed byte.\n ;;     %x: print integer X as if it's an unsigned halfword.\n@@ -154,7 +154,7 @@\n    (RETURN_REGNUM\t\t14)\n    ; Condition code register.\n    (CC_REGNUM\t\t\t33)\n-   ; Thread local storage pointer register. \n+   ; Thread local storage pointer register.\n    (TP_REGNUM\t\t\t36)\n   ])\n \n@@ -220,7 +220,7 @@\n ;;   reg: Instruction does not use the agen unit\n \n (define_attr \"atype\" \"agen,reg\"\n-  (if_then_else (eq_attr \"op_type\" \"E,RR,RI,RRE\")  \n+  (if_then_else (eq_attr \"op_type\" \"E,RR,RI,RRE\")\n \t\t(const_string \"reg\")\n \t\t(const_string \"agen\")))\n \n@@ -319,7 +319,7 @@\n \n ;; These mode iterators allow floating point patterns to be generated from the\n ;; same template.\n-(define_mode_iterator FP_ALL [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\") \n+(define_mode_iterator FP_ALL [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")\n                               (SD \"TARGET_HARD_DFP\")])\n (define_mode_iterator FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n (define_mode_iterator FPALL [TF DF SF TD DD SD])\n@@ -360,15 +360,15 @@\n \n ;; This iterator and attribute allow to combine most atomic operations.\n (define_code_iterator ATOMIC [and ior xor plus minus mult])\n-(define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n+(define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\")\n \t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n \n-;; In FP templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in \n+;; In FP templates, a string like \"lt<de>br\" will expand to \"ltxbr\" in\n ;; TF/TDmode, \"ltdbr\" in DF/DDmode, and \"ltebr\" in SF/SDmode.\n (define_mode_attr xde [(TF \"x\") (DF \"d\") (SF \"e\") (TD \"x\") (DD \"d\") (SD \"e\")])\n \n-;; In FP templates, a <dee> in \"m<dee><bt>r\" will expand to \"mx<bt>r\" in \n-;; TF/TDmode, \"md<bt>r\" in DF/DDmode, \"mee<bt>r\" in SFmode and \"me<bt>r in \n+;; In FP templates, a <dee> in \"m<dee><bt>r\" will expand to \"mx<bt>r\" in\n+;; TF/TDmode, \"md<bt>r\" in DF/DDmode, \"mee<bt>r\" in SFmode and \"me<bt>r in\n ;; SDmode.\n (define_mode_attr xdee [(TF \"x\") (DF \"d\") (SF \"ee\") (TD \"x\") (DD \"d\") (SD \"e\")])\n \n@@ -382,14 +382,14 @@\n ;; dfp variants in a single insn definition.\n \n ;; This attribute is used to set op_type accordingly.\n-(define_mode_attr RRer [(TF \"RRE\") (DF \"RRE\") (SF \"RRE\") (TD \"RRR\") \n+(define_mode_attr RRer [(TF \"RRE\") (DF \"RRE\") (SF \"RRE\") (TD \"RRR\")\n                         (DD \"RRR\") (SD \"RRR\")])\n \n-;; This attribute is used in the operand constraint list in order to have the \n+;; This attribute is used in the operand constraint list in order to have the\n ;; first and the second operand match for bfp modes.\n (define_mode_attr f0 [(TF \"0\") (DF \"0\") (SF \"0\") (TD \"f\") (DD \"f\") (DD \"f\")])\n \n-;; This attribute is used in the operand list of the instruction to have an \n+;; This attribute is used in the operand list of the instruction to have an\n ;; additional operand for the dfp instructions.\n (define_mode_attr op1 [(TF \"\") (DF \"\") (SF \"\")\n                        (TD \"%1,\") (DD \"%1,\") (SD \"%1,\")])"}, {"sha": "33fd5f5c8c544f97d8528640e0637e95175e5054", "filename": "gcc/config/s390/tpf-unwind.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h?ref=f4aa38482cd7374e7fd6e0ff968f6c84e0823a0a", "patch": "@@ -46,7 +46,7 @@ __isPATrange (void *addr)\n /* TPF return address offset from start of stack frame.  */\n #define TPFRA_OFFSET 168\n \n-/* Exceptions macro defined for TPF so that functions without \n+/* Exceptions macro defined for TPF so that functions without\n    dwarf frame information can be used with exceptions.  */\n #define MD_FALLBACK_FRAME_STATE_FOR s390_fallback_frame_state\n \n@@ -165,20 +165,20 @@ __tpf_eh_return (void *target)\n \n       /* Begin looping through stack frames.  Stop if invalid\n          code information is retrieved or if a match between the\n-         current stack frame iteration shared object's address \n+         current stack frame iteration shared object's address\n          matches that of the target, calculated above.  */\n       do\n         {\n           /* Get return address based on our stackptr iterator.  */\n-          current = (void *) *((unsigned long int *) \n+          current = (void *) *((unsigned long int *)\n                       (stackptr+RA_OFFSET));\n \n           /* Is it a Pat Stub?  */\n-          if (__isPATrange (current)) \n+          if (__isPATrange (current))\n             {\n-              /* Yes it was, get real return address \n+              /* Yes it was, get real return address\n                  in TPF stack area.  */\n-              current = (void *) *((unsigned long int *) \n+              current = (void *) *((unsigned long int *)\n                           (stackptr+TPFRA_OFFSET));\n               is_a_stub = 1;\n             }\n@@ -198,7 +198,7 @@ __tpf_eh_return (void *target)\n                /* Yes! They are in the same module.\n                   Force copy of TPF private stack area to\n                   destination stack frame TPF private area. */\n-               destination_frame = (void *) *((unsigned long int *) \n+               destination_frame = (void *) *((unsigned long int *)\n                    (*PREVIOUS_STACK_PTR() + R15_OFFSET));\n \n                /* Copy TPF linkage area from current frame to\n@@ -209,24 +209,24 @@ __tpf_eh_return (void *target)\n                /* Now overlay the\n                   real target address into the TPF stack area of\n                   the target frame we are jumping to.  */\n-               *((unsigned long int *) (destination_frame + \n+               *((unsigned long int *) (destination_frame +\n                    TPFRA_OFFSET)) = (unsigned long int) target;\n \n                /* Before returning the desired pat stub address to\n-                  the exception handling unwinder so that it can \n-                  actually do the \"leap\" shift out the low order \n+                  the exception handling unwinder so that it can\n+                  actually do the \"leap\" shift out the low order\n                   bit designated to determine if we are in 64BIT mode.\n                   This is necessary for CTOA stubs.\n-                  Otherwise we leap one byte past where we want to \n+                  Otherwise we leap one byte past where we want to\n                   go to in the TPF pat stub linkage code.  */\n-               shifter = *((unsigned long int *) \n+               shifter = *((unsigned long int *)\n                      (stackptr + RA_OFFSET));\n \n                shifter &= ~1ul;\n \n                /* Store Pat Stub Address in destination Stack Frame.  */\n                *((unsigned long int *) (destination_frame +\n-                   RA_OFFSET)) = shifter;               \n+                   RA_OFFSET)) = shifter;\n \n                /* Re-adjust pat stub address to go to correct place\n                   in linkage.  */"}]}