{"sha": "c001c39bbbd67012dc85d861be94c41a67ee7063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwMWMzOWJiYmQ2NzAxMmRjODVkODYxYmU5NGM0MWE2N2VlNzA2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-19T10:24:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-19T10:24:56Z"}, "message": "cgraph.c (NPREDECESORC, [...]): Kill.\n\n\t* cgraph.c (NPREDECESORC, SET_NPREDECESORS): Kill.\n\t(cgraph_expand_function): Rewrite.\n\n\t* gcc.dg/funcorder.c: New test.\n\nFrom-SVN: r63098", "tree": {"sha": "c7d690d5f5278e78050af52ff4cb43db39d2106c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7d690d5f5278e78050af52ff4cb43db39d2106c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c001c39bbbd67012dc85d861be94c41a67ee7063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c001c39bbbd67012dc85d861be94c41a67ee7063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c001c39bbbd67012dc85d861be94c41a67ee7063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c001c39bbbd67012dc85d861be94c41a67ee7063/comments", "author": null, "committer": null, "parents": [{"sha": "8d928fb1404300cdd23a636fd0d7ce70773d4f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d928fb1404300cdd23a636fd0d7ce70773d4f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d928fb1404300cdd23a636fd0d7ce70773d4f53"}], "stats": {"total": 138, "additions": 99, "deletions": 39}, "files": [{"sha": "34696c61235eb8078da5ba2577aa4f0fd3ff05b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c001c39bbbd67012dc85d861be94c41a67ee7063", "patch": "@@ -1,3 +1,8 @@\n+Tue Feb 18 23:50:59 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (NPREDECESORC, SET_NPREDECESORS): Kill.\n+\t(cgraph_expand_function): Rewrite.\n+\n 2003-02-18  Matt Austern <austern@apple.com>\n \t* toplev.c, langhooks.c, langhooks-def.h: Move\n \twrite_global_declarations from toplev.c to langhooks.c. "}, {"sha": "f1fffcac4215d0ee3ca592f128174e7dd8fac2c7", "filename": "gcc/cgraph.c", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c001c39bbbd67012dc85d861be94c41a67ee7063", "patch": "@@ -420,11 +420,6 @@ cgraph_finalize_compilation_unit ()\n   ggc_collect ();\n }\n \n-/* Expand all functions that must be output.  */\n-\n-#define NPREDECESORS(node) ((size_t) (node)->aux)\n-#define SET_NPREDECESORS(node, n) ((node)->aux = (void *) (size_t) (n))\n-\n /* Figure out what functions we want to assemble.  */\n \n static void\n@@ -476,56 +471,75 @@ cgraph_expand_function (node)\n static void\n cgraph_expand_functions ()\n {\n-  struct cgraph_node *node;\n+  struct cgraph_node *node, *node2;\n   struct cgraph_node **stack =\n     xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  struct cgraph_node **order =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n   int stack_size = 0;\n-  struct cgraph_edge *edge;\n+  int order_pos = 0;\n+  struct cgraph_edge *edge, last;\n+  int i;\n \n   cgraph_mark_functions_to_output ();\n \n+  /*  We have to deal with cycles nicely, so use depth first traversal\n+      algorithm.  Ignore the fact that some functions won't need to be output\n+      and put them into order as well, so we get dependencies right trought inlined\n+      functions.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->output)\n+    if (node->output && !node->aux)\n       {\n-\tint n = 0;\n-\tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  if (edge->callee->output)\n-\t    n++;\n-\tSET_NPREDECESORS (node, n);\n-\tif (n == 0)\n-\t  stack[stack_size++] = node;\n+\tnode2 = node;\n+\tif (!node->callers)\n+\t  node->aux = &last;\n+\telse\n+\t  node->aux = node->callers;\n+\twhile (node2)\n+\t  {\n+\t    while (node2->aux != &last)\n+\t      {\n+\t\tedge = node2->aux;\n+\t\tif (edge->next_caller)\n+\t\t  node2->aux = edge->next_caller;\n+\t\telse\n+\t\t  node2->aux = &last;\n+\t\tif (!edge->caller->aux)\n+\t\t  {\n+\t\t    if (!edge->caller->callers)\n+\t\t      edge->caller->aux = &last;\n+\t\t    else\n+\t\t      edge->caller->aux = edge->caller->callers;\n+\t\t    stack[stack_size++] = node2;\n+\t\t    node2 = edge->caller;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if (node2->aux == &last)\n+\t      {\n+\t\torder[order_pos++] = node2;\n+\t\tif (stack_size)\n+\t\t  node2 = stack[--stack_size];\n+\t\telse\n+\t\t  node2 = NULL;\n+\t      }\n+\t  }\n       }\n-  while (1)\n+  for (i = order_pos - 1; i >=0; i--)\n     {\n-      struct cgraph_node *minnode;\n-      while (stack_size)\n+      node = order[i];\n+      if (node->output)\n \t{\n-\t  node = stack[--stack_size];\n-\t  node->output = 0;\n-\n-\t  for (edge = node->callers; edge; edge = edge->next_caller)\n-\t    if (edge->caller->output)\n-\t      {\n-\t        SET_NPREDECESORS (edge->caller,\n-\t\t    \t\t  NPREDECESORS (edge->caller) - 1);\n-\t\tif (!NPREDECESORS (edge->caller))\n-\t\t  stack[stack_size++] = edge->caller;\n-\t      }\n \t  if (!node->reachable)\n \t    abort ();\n+\t  node->output = 0;\n \t  cgraph_expand_function (node);\n \t}\n-      minnode = NULL;\n-      /* We found cycle.  Break it and try again.  */\n-      for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->output\n-\t    && (!minnode\n-\t        || NPREDECESORS (minnode) > NPREDECESORS (node)))\n-\t  minnode = node;\n-      if (!minnode)\n-\treturn;\n-      stack[stack_size++] = minnode;\n     }\n+  free (stack);\n+  free (order);\n }\n \n /* Perform simple optimizations based on callgraph.  */"}, {"sha": "0c352aec172a483f862b3f4c4bf80c8d3fce025c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c001c39bbbd67012dc85d861be94c41a67ee7063", "patch": "@@ -1,3 +1,7 @@\n+Tue Feb 18 23:28:53 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/funcorder.c: New test.\n+\n 2003-02-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcc.c-torture/execute/20030218-1.c: New."}, {"sha": "0dec72c7d02b7a40cf40c55afaa3b7f3b921241b", "filename": "gcc/testsuite/gcc.dg/funcorder.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Ftestsuite%2Fgcc.dg%2Ffuncorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c001c39bbbd67012dc85d861be94c41a67ee7063/gcc%2Ftestsuite%2Fgcc.dg%2Ffuncorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffuncorder.c?ref=c001c39bbbd67012dc85d861be94c41a67ee7063", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funit-at-a-time\" } */\n+/* { dg-final { scan-assembler-not \"link_error\" } } */\n+/*  In unit-at-time the functions should be assembled in order\n+    e q t main, so we realize that they are pure.  */\n+ \n+static int mem;\n+static int e(void) __attribute__ ((noinline));\n+static int q(void) __attribute__ ((noinline));\n+static int t(void) __attribute__ ((noinline));\n+main()\n+{\n+\treturn t();\n+}\n+static t()\n+{\n+\tint r,e;\n+\tif (mem)\n+\t\tt();\n+\te=mem;\n+\tr=q();\n+\tif (e!=mem)\n+\t\tlink_error();\n+\treturn r;\n+}\n+static int e()\n+{\n+\treturn 0;\n+}\n+static int q()\n+{\n+\tint t=mem,r;\n+\tr=e();\n+\tif (t!=mem)\n+\t\tlink_error();\n+\treturn r;\n+}"}]}