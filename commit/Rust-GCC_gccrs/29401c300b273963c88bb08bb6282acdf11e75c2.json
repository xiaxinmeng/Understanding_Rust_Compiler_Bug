{"sha": "29401c300b273963c88bb08bb6282acdf11e75c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0MDFjMzAwYjI3Mzk2M2M4OGJiMDhiYjYyODJhY2RmMTFlNzVjMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-22T20:37:20Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-22T20:37:20Z"}, "message": "cpperror.c (print_location): Don't show _Pragma.\n\n\t* cpperror.c (print_location): Don't show _Pragma.\n\t* cppfiles.c (_cpp_pop_file_buffer): Handle -include file pushing\n\tand file change callback generation here.\n\t(stack_include_file): Update use of cpp_push_buffer.\n\t* cpphash.h (_cpp_pop_file_buffer): Update prototype.\n\t(struct cpp_buffer): Remove type, pfile members.\n\t* cppinit.c (cpp_handle_option): Use free_chain.\n\t* cpplex.c (_cpp_lex_token): Don't do -include file pushing here.\n\t(skip_escaped_newlines, get_effective_char, lex_percent): Take\n\ta cpp_reader rather than a cpp_buffer.\n\t(skip_escaped_newlines, get_effective_char, skip_block_comment,\n\tskip_line_comment, parse_string, lex_percent, lex_dot,\n\t_cpp_lex_token): Update accordingly.\n\t* cpplib.c (_cpp_pop_buffer): Don't do file change callback\n\tgeneration here.\n\t(cpp_push_buffer): Update prototype.\n\t(run_directive): Update use of cpp_push_buffer.\n\t(_cpp_do__Pragma, cpp_define, cpp_define_builtin, cpp_undef,\n\thandle_assertion): Update use of run_directive.\n\t* cpplib.h (enum cpp_buffer_type): Remove.\n\t(cpp_push_buffer): Update prototype.\n\t* fix-header.c (read_scan_file): Update.\n\nFrom-SVN: r45112", "tree": {"sha": "5d1c57d7edd200e5b5467bf355348a54e5238af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d1c57d7edd200e5b5467bf355348a54e5238af3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29401c300b273963c88bb08bb6282acdf11e75c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29401c300b273963c88bb08bb6282acdf11e75c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29401c300b273963c88bb08bb6282acdf11e75c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29401c300b273963c88bb08bb6282acdf11e75c2/comments", "author": null, "committer": null, "parents": [{"sha": "8060c8ee523a6016589157d25ff9e82adc4ebb0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8060c8ee523a6016589157d25ff9e82adc4ebb0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8060c8ee523a6016589157d25ff9e82adc4ebb0c"}], "stats": {"total": 235, "additions": 118, "deletions": 117}, "files": [{"sha": "ffc804daacdf2fb986c4b7acb65905dde42b3a7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -1,3 +1,28 @@\n+2001-08-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpperror.c (print_location): Don't show _Pragma.\n+\t* cppfiles.c (_cpp_pop_file_buffer): Handle -include file pushing\n+\tand file change callback generation here.\n+\t(stack_include_file): Update use of cpp_push_buffer.\n+\t* cpphash.h (_cpp_pop_file_buffer): Update prototype.\n+\t(struct cpp_buffer): Remove type, pfile members.\n+\t* cppinit.c (cpp_handle_option): Use free_chain.\n+\t* cpplex.c (_cpp_lex_token): Don't do -include file pushing here.\n+\t(skip_escaped_newlines, get_effective_char, lex_percent): Take\n+\ta cpp_reader rather than a cpp_buffer.\n+\t(skip_escaped_newlines, get_effective_char, skip_block_comment,\n+\tskip_line_comment, parse_string, lex_percent, lex_dot,\n+\t_cpp_lex_token): Update accordingly.\n+\t* cpplib.c (_cpp_pop_buffer): Don't do file change callback\n+\tgeneration here.\n+\t(cpp_push_buffer): Update prototype.\n+\t(run_directive): Update use of cpp_push_buffer.\n+\t(_cpp_do__Pragma, cpp_define, cpp_define_builtin, cpp_undef,\n+\thandle_assertion): Update use of run_directive.\n+\t* cpplib.h (enum cpp_buffer_type): Remove.\n+\t(cpp_push_buffer): Update prototype.\n+\t* fix-header.c (read_scan_file): Update.\n+\n 2001-08-22  Matt Kraai  <kraai@alumni.carnegiemellon.edu>\n \n \t* gcc.c (struct prefix_list): Change prefix to const char *."}, {"sha": "3dbf534affd7d677e91a3c19f88b27dcf2292ef3", "filename": "gcc/cpperror.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -69,8 +69,6 @@ print_location (pfile, pos)\n       else\n \tfprintf (stderr, \"%s:%u:%u:\", map->to_file, line, col);\n \n-      if (buffer->type == BUF_PRAGMA)\n-\tfprintf (stderr, \"_Pragma:\");\n       fputc (' ', stderr);\n     }\n }"}, {"sha": "5b8f9076b39c7409df5b48b67789b1339ead11fd", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -317,7 +317,8 @@ stack_include_file (pfile, inc)\n     inc->include_count++;\n \n   /* Push a buffer.  */\n-  fp = cpp_push_buffer (pfile, inc->buffer, inc->st.st_size, BUF_FILE, 0);\n+  fp = cpp_push_buffer (pfile, inc->buffer, inc->st.st_size,\n+\t\t\t/* from_stage3 */ CPP_OPTION (pfile, preprocessed), 0);\n   fp->inc = inc;\n   fp->inc->refcnt++;\n \n@@ -720,14 +721,12 @@ _cpp_read_file (pfile, fname)\n }\n \n /* Do appropriate cleanup when a file buffer is popped off the input\n-   stack.  */\n+   stack.  Push the next -include file, if any remain.  */\n void\n-_cpp_pop_file_buffer (pfile, buf)\n+_cpp_pop_file_buffer (pfile, inc)\n      cpp_reader *pfile;\n-     cpp_buffer *buf;\n+     struct include_file *inc;\n {\n-  struct include_file *inc = buf->inc;\n-\n   /* Record the inclusion-preventing macro, which could be NULL\n      meaning no controlling macro.  */\n   if (pfile->mi_valid && inc->cmacro == NULL)\n@@ -739,6 +738,16 @@ _cpp_pop_file_buffer (pfile, buf)\n   inc->refcnt--;\n   if (inc->refcnt == 0 && DO_NOT_REREAD (inc))\n     purge_cache (inc);\n+\n+  /* Don't generate a callback for popping the main file.  */\n+  if (pfile->buffer)\n+    {\n+      _cpp_do_file_change (pfile, LC_LEAVE, 0, 0, 0);\n+\n+      /* Finally, push the next -included file, if any.  */\n+      if (!pfile->buffer->prev)\n+\t_cpp_push_next_buffer (pfile);\n+    }\n }\n \n /* Returns the first place in the include chain to start searching for\n@@ -772,8 +781,7 @@ search_from (pfile, type)\n       if (dlen)\n \t{\n \t  /* We don't guarantee NAME is null-terminated.  This saves\n-\t     allocating and freeing memory, and duplicating it when faking\n-\t     buffers in cpp_push_buffer.  Drop a trailing '/'.  */\n+\t     allocating and freeing memory.  Drop a trailing '/'.  */\n \t  buffer->dir.name = buffer->inc->name;\n \t  if (dlen > 1)\n \t    dlen--;"}, {"sha": "a31368396ef72061461dc258702f52c39666e9e1", "filename": "gcc/cpphash.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -171,13 +171,12 @@ struct cpp_buffer\n   cppchar_t read_ahead;\t\t/* read ahead character */\n   cppchar_t extra_char;\t\t/* extra read-ahead for long tokens.  */\n \n-  struct cpp_reader *pfile;\t/* Owns this buffer.  */\n   struct cpp_buffer *prev;\n \n-  const unsigned char *buf;\t /* entire buffer */\n+  const unsigned char *buf;\t /* Entire buffer.  */\n \n-  /* Pointer into the include table.  Used for include_next and\n-     to record control macros. */\n+  /* Pointer into the include table; non-NULL if this is a file\n+     buffer.  Used for include_next and to record control macros.  */\n   struct include_file *inc;\n \n   /* Value of if_stack at start of this file.\n@@ -214,9 +213,6 @@ struct cpp_buffer\n      token from the enclosing buffer is returned.  */\n   bool return_at_eof;\n \n-  /* Buffer type.  */\n-  ENUM_BITFIELD (cpp_buffer_type) type : 8;\n-\n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n   struct search_path dir;\n@@ -391,7 +387,8 @@ extern int _cpp_compare_file_date       PARAMS ((cpp_reader *,\n extern void _cpp_report_missing_guards\tPARAMS ((cpp_reader *));\n extern void _cpp_init_includes\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_includes\tPARAMS ((cpp_reader *));\n-extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *, cpp_buffer *));\n+extern void _cpp_pop_file_buffer\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t struct include_file *));\n \n /* In cppexp.c */\n extern int _cpp_parse_expr\t\tPARAMS ((cpp_reader *));"}, {"sha": "9e5fa8e5fd9def5f2ee8c0967750e245d92d1806", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -1546,15 +1546,7 @@ cpp_handle_option (pfile, argc, argv)\n \n \t      if (arg[1] == '\\0')\n \t\t{\n-\t\t  struct pending_option *o1, *o2;\n-\n-\t\t  o1 = pend->directive_head;\n-\t\t  while (o1)\n-\t\t    {\n-\t\t      o2 = o1->next;\n-\t\t      free (o1);\n-\t\t      o1 = o2;\n-\t\t    }\n+\t\t  free_chain (pend->directive_head);\n \t\t  pend->directive_head = NULL;\n \t\t  pend->directive_tail = NULL;\n \t\t}"}, {"sha": "03bd85516cc4b7fc605884a3b2ea276d5e92dbef", "filename": "gcc/cpplex.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -81,8 +81,8 @@ const struct token_spelling token_spellings [N_TTYPES] = {TTYPE_TABLE };\n #define TOKEN_NAME(token) (token_spellings[(token)->type].name)\n \n static cppchar_t handle_newline PARAMS ((cpp_reader *, cppchar_t));\n-static cppchar_t skip_escaped_newlines PARAMS ((cpp_buffer *, cppchar_t));\n-static cppchar_t get_effective_char PARAMS ((cpp_buffer *));\n+static cppchar_t skip_escaped_newlines PARAMS ((cpp_reader *, cppchar_t));\n+static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n \n static int skip_block_comment PARAMS ((cpp_reader *));\n static int skip_line_comment PARAMS ((cpp_reader *));\n@@ -95,7 +95,7 @@ static void parse_string PARAMS ((cpp_reader *, cpp_token *, cppchar_t));\n static void unterminated PARAMS ((cpp_reader *, int));\n static int trigraph_ok PARAMS ((cpp_reader *, cppchar_t));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n-static void lex_percent PARAMS ((cpp_buffer *, cpp_token *));\n+static void lex_percent PARAMS ((cpp_reader *, cpp_token *));\n static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n@@ -205,10 +205,12 @@ trigraph_ok (pfile, from_char)\n    been placed in buffer->read_ahead.  This routine performs\n    preprocessing stages 1 and 2 of the ISO C standard.  */\n static cppchar_t\n-skip_escaped_newlines (buffer, next)\n-     cpp_buffer *buffer;\n+skip_escaped_newlines (pfile, next)\n+     cpp_reader *pfile;\n      cppchar_t next;\n {\n+  cpp_buffer *buffer = pfile->buffer;\n+\n   /* Only do this if we apply stages 1 and 2.  */\n   if (!buffer->from_stage3)\n     {\n@@ -233,7 +235,7 @@ skip_escaped_newlines (buffer, next)\n \n \t      next1 = *buffer->cur++;\n \t      if (!_cpp_trigraph_map[next1]\n-\t\t  || !trigraph_ok (buffer->pfile, next1))\n+\t\t  || !trigraph_ok (pfile, next1))\n \t\t{\n \t\t  RESTORE_STATE ();\n \t\t  break;\n@@ -263,13 +265,12 @@ skip_escaped_newlines (buffer, next)\n \t      break;\n \t    }\n \n-\t  if (space && !buffer->pfile->state.lexing_comment)\n-\t    cpp_warning (buffer->pfile,\n-\t\t\t \"backslash and newline separated by space\");\n+\t  if (space && !pfile->state.lexing_comment)\n+\t    cpp_warning (pfile, \"backslash and newline separated by space\");\n \n-\t  next = handle_newline (buffer->pfile, next1);\n+\t  next = handle_newline (pfile, next1);\n \t  if (next == EOF)\n-\t    cpp_pedwarn (buffer->pfile, \"backslash-newline at end of file\");\n+\t    cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n \t}\n       while (next == '\\\\' || next == '?');\n     }\n@@ -282,9 +283,10 @@ skip_escaped_newlines (buffer, next)\n    an arbitrary string of escaped newlines.  The common case of no\n    trigraphs or escaped newlines falls through quickly.  */\n static cppchar_t\n-get_effective_char (buffer)\n-     cpp_buffer *buffer;\n+get_effective_char (pfile)\n+     cpp_reader *pfile;\n {\n+  cpp_buffer *buffer = pfile->buffer;\n   cppchar_t next = EOF;\n \n   if (buffer->cur < buffer->rlimit)\n@@ -296,7 +298,7 @@ get_effective_char (buffer)\n \t UCNs, which, depending upon lexer state, we will handle in\n \t the future.  */\n       if (next == '?' || next == '\\\\')\n-\tnext = skip_escaped_newlines (buffer, next);\n+\tnext = skip_escaped_newlines (pfile, next);\n     }\n \n   buffer->read_ahead = next;\n@@ -322,7 +324,7 @@ skip_block_comment (pfile)\n       /* FIXME: For speed, create a new character class of characters\n \t of interest inside block comments.  */\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (buffer, c);\n+\tc = skip_escaped_newlines (pfile, c);\n \n       /* People like decorating comments with '*', so check for '/'\n \t instead for efficiency.  */\n@@ -383,7 +385,7 @@ skip_line_comment (pfile)\n \n       c = *buffer->cur++;\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (buffer, c);\n+\tc = skip_escaped_newlines (pfile, c);\n     }\n   while (!is_vspace (c));\n \n@@ -502,7 +504,7 @@ parse_identifier (pfile, c)\n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n \tbreak;\n-      c = skip_escaped_newlines (buffer, c);\n+      c = skip_escaped_newlines (pfile, c);\n     }\n   while (is_idchar (c));\n \n@@ -584,7 +586,7 @@ parse_number (pfile, number, c, leading_period)\n       /* Potential escaped newline?  */\n       if (c != '?' && c != '\\\\')\n \tbreak;\n-      c = skip_escaped_newlines (buffer, c);\n+      c = skip_escaped_newlines (pfile, c);\n     }\n   while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n@@ -680,7 +682,7 @@ parse_string (pfile, token, terminator)\n \n       /* Handle trigraphs, escaped newlines etc.  */\n       if (c == '?' || c == '\\\\')\n-\tc = skip_escaped_newlines (buffer, c);\n+\tc = skip_escaped_newlines (pfile, c);\n \n       if (c == terminator && unescaped_terminator_p (pfile, dest))\n \t{\n@@ -764,16 +766,17 @@ save_comment (pfile, token, from)\n /* Subroutine of lex_token to handle '%'.  A little tricky, since we\n    want to avoid stepping back when lexing %:%X.  */\n static void\n-lex_percent (buffer, result)\n-     cpp_buffer *buffer;\n+lex_percent (pfile, result)\n+     cpp_reader *pfile;\n      cpp_token *result;\n {\n+  cpp_buffer *buffer= pfile->buffer;\n   cppchar_t c;\n \n   result->type = CPP_MOD;\n   /* Parsing %:%X could leave an extra character.  */\n   if (buffer->extra_char == EOF)\n-    c = get_effective_char (buffer);\n+    c = get_effective_char (pfile);\n   else\n     {\n       c = buffer->read_ahead = buffer->extra_char;\n@@ -782,15 +785,15 @@ lex_percent (buffer, result)\n \n   if (c == '=')\n     ACCEPT_CHAR (CPP_MOD_EQ);\n-  else if (CPP_OPTION (buffer->pfile, digraphs))\n+  else if (CPP_OPTION (pfile, digraphs))\n     {\n       if (c == ':')\n \t{\n \t  result->flags |= DIGRAPH;\n \t  ACCEPT_CHAR (CPP_HASH);\n-\t  if (get_effective_char (buffer) == '%')\n+\t  if (get_effective_char (pfile) == '%')\n \t    {\n-\t      buffer->extra_char = get_effective_char (buffer);\n+\t      buffer->extra_char = get_effective_char (pfile);\n \t      if (buffer->extra_char == ':')\n \t\t{\n \t\t  buffer->extra_char = EOF;\n@@ -822,7 +825,7 @@ lex_dot (pfile, result)\n \n   /* Parsing ..X could leave an extra character.  */\n   if (buffer->extra_char == EOF)\n-    c = get_effective_char (buffer);\n+    c = get_effective_char (pfile);\n   else\n     {\n       c = buffer->read_ahead = buffer->extra_char;\n@@ -840,7 +843,7 @@ lex_dot (pfile, result)\n       result->type = CPP_DOT;\n       if (c == '.')\n \t{\n-\t  buffer->extra_char = get_effective_char (buffer);\n+\t  buffer->extra_char = get_effective_char (pfile);\n \t  if (buffer->extra_char == '.')\n \t    {\n \t      buffer->extra_char = EOF;\n@@ -914,9 +917,6 @@ _cpp_lex_token (pfile, result)\n \t      unsigned char stop = buffer->return_at_eof;\n \n \t      _cpp_pop_buffer (pfile);\n-\t      /* Push the next -included file, if any.  */\n-\t      if (!pfile->buffer->prev)\n-\t\t_cpp_push_next_buffer (pfile);\n \t      if (!stop)\n \t\tgoto next_token;\n \t    }\n@@ -963,7 +963,7 @@ _cpp_lex_token (pfile, result)\n       {\n \tunsigned int line = pfile->line;\n \n-\tc = skip_escaped_newlines (buffer, c);\n+\tc = skip_escaped_newlines (pfile, c);\n \tif (line != pfile->line)\n \t  /* We had at least one escaped newline of some sort, and the\n \t     next character is in buffer->read_ahead.  Update the\n@@ -1034,7 +1034,7 @@ _cpp_lex_token (pfile, result)\n       /* A potential block or line comment.  */\n       comment_start = buffer->cur;\n       result->type = CPP_DIV;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_DIV_EQ);\n       if (c != '/' && c != '*')\n@@ -1091,19 +1091,19 @@ _cpp_lex_token (pfile, result)\n \t}\n \n       result->type = CPP_LESS;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_LESS_EQ);\n       else if (c == '<')\n \t{\n \t  ACCEPT_CHAR (CPP_LSHIFT);\n-\t  if (get_effective_char (buffer) == '=')\n+\t  if (get_effective_char (pfile) == '=')\n \t    ACCEPT_CHAR (CPP_LSHIFT_EQ);\n \t}\n       else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n \t{\n \t  ACCEPT_CHAR (CPP_MIN);\n-\t  if (get_effective_char (buffer) == '=')\n+\t  if (get_effective_char (pfile) == '=')\n \t    ACCEPT_CHAR (CPP_MIN_EQ);\n \t}\n       else if (c == ':' && CPP_OPTION (pfile, digraphs))\n@@ -1120,25 +1120,25 @@ _cpp_lex_token (pfile, result)\n \n     case '>':\n       result->type = CPP_GREATER;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_GREATER_EQ);\n       else if (c == '>')\n \t{\n \t  ACCEPT_CHAR (CPP_RSHIFT);\n-\t  if (get_effective_char (buffer) == '=')\n+\t  if (get_effective_char (pfile) == '=')\n \t    ACCEPT_CHAR (CPP_RSHIFT_EQ);\n \t}\n       else if (c == '?' && CPP_OPTION (pfile, cplusplus))\n \t{\n \t  ACCEPT_CHAR (CPP_MAX);\n-\t  if (get_effective_char (buffer) == '=')\n+\t  if (get_effective_char (pfile) == '=')\n \t    ACCEPT_CHAR (CPP_MAX_EQ);\n \t}\n       break;\n \n     case '%':\n-      lex_percent (buffer, result);\n+      lex_percent (pfile, result);\n       if (result->type == CPP_HASH)\n \tgoto do_hash;\n       break;\n@@ -1149,7 +1149,7 @@ _cpp_lex_token (pfile, result)\n \n     case '+':\n       result->type = CPP_PLUS;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_PLUS_EQ);\n       else if (c == '+')\n@@ -1158,12 +1158,12 @@ _cpp_lex_token (pfile, result)\n \n     case '-':\n       result->type = CPP_MINUS;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '>')\n \t{\n \t  ACCEPT_CHAR (CPP_DEREF);\n \t  if (CPP_OPTION (pfile, cplusplus)\n-\t      && get_effective_char (buffer) == '*')\n+\t      && get_effective_char (pfile) == '*')\n \t    ACCEPT_CHAR (CPP_DEREF_STAR);\n \t}\n       else if (c == '=')\n@@ -1174,25 +1174,25 @@ _cpp_lex_token (pfile, result)\n \n     case '*':\n       result->type = CPP_MULT;\n-      if (get_effective_char (buffer) == '=')\n+      if (get_effective_char (pfile) == '=')\n \tACCEPT_CHAR (CPP_MULT_EQ);\n       break;\n \n     case '=':\n       result->type = CPP_EQ;\n-      if (get_effective_char (buffer) == '=')\n+      if (get_effective_char (pfile) == '=')\n \tACCEPT_CHAR (CPP_EQ_EQ);\n       break;\n \n     case '!':\n       result->type = CPP_NOT;\n-      if (get_effective_char (buffer) == '=')\n+      if (get_effective_char (pfile) == '=')\n \tACCEPT_CHAR (CPP_NOT_EQ);\n       break;\n \n     case '&':\n       result->type = CPP_AND;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_AND_EQ);\n       else if (c == '&')\n@@ -1207,7 +1207,7 @@ _cpp_lex_token (pfile, result)\n \t  buffer->extra_char = EOF;\n \t}\n       else\n-\tc = get_effective_char (buffer);\n+\tc = get_effective_char (pfile);\n \n       if (c == '#')\n \t{\n@@ -1247,7 +1247,7 @@ _cpp_lex_token (pfile, result)\n \n     case '|':\n       result->type = CPP_OR;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == '=')\n \tACCEPT_CHAR (CPP_OR_EQ);\n       else if (c == '|')\n@@ -1256,13 +1256,13 @@ _cpp_lex_token (pfile, result)\n \n     case '^':\n       result->type = CPP_XOR;\n-      if (get_effective_char (buffer) == '=')\n+      if (get_effective_char (pfile) == '=')\n \tACCEPT_CHAR (CPP_XOR_EQ);\n       break;\n \n     case ':':\n       result->type = CPP_COLON;\n-      c = get_effective_char (buffer);\n+      c = get_effective_char (pfile);\n       if (c == ':' && CPP_OPTION (pfile, cplusplus))\n \tACCEPT_CHAR (CPP_SCOPE);\n       else if (c == '>' && CPP_OPTION (pfile, digraphs))"}, {"sha": "0a02c15845eaa6bb528cdae6407bfb48b208bcc4", "filename": "gcc/cpplib.c", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -83,7 +83,6 @@ static void check_eol\t\tPARAMS ((cpp_reader *));\n static void start_directive\tPARAMS ((cpp_reader *));\n static void end_directive\tPARAMS ((cpp_reader *, int));\n static void run_directive\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t enum cpp_buffer_type,\n \t\t\t\t\t const char *, size_t));\n static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n static int  parse_include\tPARAMS ((cpp_reader *, cpp_token *));\n@@ -394,16 +393,14 @@ _cpp_handle_directive (pfile, indented)\n /* Directive handler wrapper used by the command line option\n    processor.  */\n static void\n-run_directive (pfile, dir_no, type, buf, count)\n+run_directive (pfile, dir_no, buf, count)\n      cpp_reader *pfile;\n      int dir_no;\n-     enum cpp_buffer_type type;\n      const char *buf;\n      size_t count;\n {\n-  cpp_buffer *buffer;\n-\n-  buffer = cpp_push_buffer (pfile, (const U_CHAR *) buf, count, type, 1);\n+  cpp_push_buffer (pfile, (const U_CHAR *) buf, count,\n+\t\t   /* from_stage3 */ true, 1);\n   start_directive (pfile);\n   pfile->state.prevent_expansion++;\n   pfile->directive = &dtable[dir_no];\n@@ -1160,7 +1157,7 @@ _cpp_do__Pragma (pfile)\n   else\n     {\n       buffer = destringize (&string.val.str, &len);\n-      run_directive (pfile, T_PRAGMA, BUF_PRAGMA, (char *) buffer, len);\n+      run_directive (pfile, T_PRAGMA, (char *) buffer, len);\n       free ((PTR) buffer);\n       pfile->lexer_pos = orig_pos;\n       pfile->line = pfile->lexer_pos.line;\n@@ -1627,7 +1624,7 @@ cpp_define (pfile, str)\n       buf[count++] = '1';\n     }\n \n-  run_directive (pfile, T_DEFINE, BUF_CL_OPTION, buf, count);\n+  run_directive (pfile, T_DEFINE, buf, count);\n }\n \n /* Slight variant of the above for use by initialize_builtins.  */\n@@ -1636,7 +1633,7 @@ _cpp_define_builtin (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  run_directive (pfile, T_DEFINE, BUF_BUILTIN, str, strlen (str));\n+  run_directive (pfile, T_DEFINE, str, strlen (str));\n }\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n@@ -1645,7 +1642,7 @@ cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n      const char *macro;\n {\n-  run_directive (pfile, T_UNDEF, BUF_CL_OPTION, macro, strlen (macro));\n+  run_directive (pfile, T_UNDEF, macro, strlen (macro));\n }\n \n /* Process the string STR as if it appeared as the body of a #assert.  */\n@@ -1688,7 +1685,7 @@ handle_assertion (pfile, str, type)\n       str = buf;\n     }\n \n-  run_directive (pfile, type, BUF_CL_OPTION, str, count);\n+  run_directive (pfile, type, str, count);\n }\n \n /* The number of errors for a given reader.  */\n@@ -1736,11 +1733,11 @@ cpp_set_callbacks (pfile, cb)\n    doesn't fail.  It does not generate a file change call back; that\n    is the responsibility of the caller.  */\n cpp_buffer *\n-cpp_push_buffer (pfile, buffer, len, type, return_at_eof)\n+cpp_push_buffer (pfile, buffer, len, from_stage3, return_at_eof)\n      cpp_reader *pfile;\n      const U_CHAR *buffer;\n      size_t len;\n-     enum cpp_buffer_type type;\n+     int from_stage3;\n      int return_at_eof;\n {\n   cpp_buffer *new = xobnew (&pfile->buffer_ob, cpp_buffer);\n@@ -1754,14 +1751,8 @@ cpp_push_buffer (pfile, buffer, len, type, return_at_eof)\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;\n-\n-  /* Preprocessed files, builtins, _Pragma and command line\n-     options don't do trigraph and escaped newline processing.  */\n-  new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n-\n-  new->type = type;\n+  new->from_stage3 = from_stage3;\n   new->prev = pfile->buffer;\n-  new->pfile = pfile;\n   new->return_at_eof = return_at_eof;\n \n   pfile->buffer = new;\n@@ -1785,26 +1776,20 @@ _cpp_pop_buffer (pfile)\n     cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-  /* Update the reader's buffer before _cpp_do_file_change.  */\n-  pfile->buffer = buffer->prev;\n-\n-  if (buffer->type == BUF_FILE)\n-    {\n-      /* Callbacks are not generated for popping the main file.  */\n-      if (buffer->prev)\n-\t_cpp_do_file_change (pfile, LC_LEAVE, 0, 0, 0);\n-\n-      _cpp_pop_file_buffer (pfile, buffer);\n-    }\n-\n-  obstack_free (&pfile->buffer_ob, buffer);\n-\n   /* The output line can fall out of sync if we missed the final\n      newline from the previous buffer, for example because of an\n      unterminated comment.  Similarly, skipping needs to be cleared in\n      case of a missing #endif.  */\n   pfile->lexer_pos.output_line = pfile->line;\n   pfile->state.skipping = 0;\n+\n+  /* Update the reader's buffer before _cpp_do_file_change.  */\n+  pfile->buffer = buffer->prev;\n+\n+  if (buffer->inc)\n+    _cpp_pop_file_buffer (pfile, buffer->inc);\n+\n+  obstack_free (&pfile->buffer_ob, buffer);\n }\n \n void"}, {"sha": "8c495736aa9f9e34c8d5bcc038a3965912e8addc", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -405,10 +405,6 @@ struct cpp_callbacks\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n-/* Where does this buffer come from?  A source file, a builtin macro,\n-   a command-line option, or a _Pragma operator.  */\n-enum cpp_buffer_type {BUF_FILE, BUF_BUILTIN, BUF_CL_OPTION, BUF_PRAGMA};\n-\n /* The structure of a node in the hash table.  The hash table has\n    entries for all identifiers: either macros defined by #define\n    commands (type NT_MACRO), assertions created with #assert\n@@ -541,7 +537,7 @@ extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    const unsigned char *, size_t,\n-\t\t\t\t\t    enum cpp_buffer_type, int));\n+\t\t\t\t\t    int, int));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n /* N.B. The error-message-printer prototypes have not been nicely"}, {"sha": "068cc692c6ee4084ef6252e18c4c98347877c1d9", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29401c300b273963c88bb08bb6282acdf11e75c2/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=29401c300b273963c88bb08bb6282acdf11e75c2", "patch": "@@ -658,7 +658,7 @@ read_scan_file (in_fname, argc, argv)\n \n       /* Scan the macro expansion of \"getchar();\".  */\n       cpp_push_buffer (scan_in, getchar_call, sizeof(getchar_call) - 1,\n-\t\t       BUF_BUILTIN, 1);\n+\t\t       /* from_stage3 */ true, 1);\n       for (;;)\n \t{\n \t  cpp_token t;"}]}