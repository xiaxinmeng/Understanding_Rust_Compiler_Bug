{"sha": "9e423e6db21b75a78fb1d636673bfaed94fc979f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0MjNlNmRiMjFiNzVhNzhmYjFkNjM2NjczYmZhZWQ5NGZjOTc5Zg==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-05-21T19:12:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-21T19:12:20Z"}, "message": "acconfig.h (HAVE_GAS_MAX_SKIP_P2ALIGN): New tag.\n\n\t* acconfig.h (HAVE_GAS_MAX_SKIP_P2ALIGN): New tag.\n\t* configure.in: Check for it.\n\t* i386/gas.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Use it.\n\t* final.c (uid_align, uid_shuid, label_align): Make static.\n\t(label_align): Change type to struct label_alignment pointer.\n\t(LABEL_TO_ALIGNMENT, shorten_branches): Update due to type change.\n\t(LABEL_TO_MAX_SKIP): Define.\n\t(LABEL_ALIGN_MAX_SKIP, LOOP_ALIGN_MAX_SKIP,\n\tLABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Provide defaults.\n\t(shorten_branches): Record the maximum bytes to skip when\n\taligning a label.\n\t(final_scan_insn): Use the maximum bytes to skip when aligning a label\n\tif ASM_OUTPUT_MAX_SKIP_ALIGN is available.\n\t* i386.h (LOOP_ALIGN_MAX_SKIP,\n\tLABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Define.\n\t* i386.c (override_options): i386_align_jumps and i386_align_loops\n\tdefault to 4 if ASM_OUTPUT_MAX_SKIP_ALIGN is available.\n\t* invoke.texi: Document new i386 align-loops and align-jumps behavior.\n\nFrom-SVN: r19933", "tree": {"sha": "dd9220c69002dd9a1d5f1820be3e18c2112c0bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd9220c69002dd9a1d5f1820be3e18c2112c0bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e423e6db21b75a78fb1d636673bfaed94fc979f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e423e6db21b75a78fb1d636673bfaed94fc979f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e423e6db21b75a78fb1d636673bfaed94fc979f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e423e6db21b75a78fb1d636673bfaed94fc979f/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1cc75298013d24ac5fab9a9408089ae5532f080a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cc75298013d24ac5fab9a9408089ae5532f080a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cc75298013d24ac5fab9a9408089ae5532f080a"}], "stats": {"total": 218, "additions": 203, "deletions": 15}, "files": [{"sha": "ba56e08602c5c9868f61f37c1d39d0cced195701", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -1,3 +1,24 @@\n+Wed May 20 23:44:28 EDT 1998  John Wehle  (john@feith.com)\n+\n+\t* acconfig.h (HAVE_GAS_MAX_SKIP_P2ALIGN): New tag.\n+\t* configure.in: Check for it.\n+\t* i386/gas.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Use it.\n+\t* final.c (uid_align, uid_shuid, label_align): Make static.\n+\t(label_align): Change type to struct label_alignment pointer.\n+\t(LABEL_TO_ALIGNMENT, shorten_branches): Update due to type change.\n+\t(LABEL_TO_MAX_SKIP): Define.\n+\t(LABEL_ALIGN_MAX_SKIP, LOOP_ALIGN_MAX_SKIP,\n+\tLABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Provide defaults.\n+\t(shorten_branches): Record the maximum bytes to skip when\n+\taligning a label.\n+\t(final_scan_insn): Use the maximum bytes to skip when aligning a label\n+\tif ASM_OUTPUT_MAX_SKIP_ALIGN is available.\n+\t* i386.h (LOOP_ALIGN_MAX_SKIP,\n+\tLABEL_ALIGN_AFTER_BARRIER_MAX_SKIP): Define.\n+\t* i386.c (override_options): i386_align_jumps and i386_align_loops\n+\tdefault to 4 if ASM_OUTPUT_MAX_SKIP_ALIGN is available.\n+\t* invoke.texi: Document new i386 align-loops and align-jumps behavior.\n+\n 1998-05-21  Mark Mitchell  <mmitchell@usa.net>\n \n \t* cplus-dem.c (do_type): Handle volatile qualification."}, {"sha": "904b7e44750f9d7dc138f82f5224bfbe4e09b597", "filename": "gcc/acconfig.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Facconfig.h?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -10,6 +10,10 @@\n /* Define if your compiler understands volatile.  */\n #undef HAVE_VOLATILE\n \n+/* Define if your assembler supports specifying the maximum number\n+   of bytes to skip when using the GAS .p2align command. */\n+#undef HAVE_GAS_MAX_SKIP_P2ALIGN\n+\n /* Define if you have a working <inttypes.h> header file.  */\n #undef HAVE_INTTYPES_H\n "}, {"sha": "38cc36db108994b330be6d27eb2bd37446fa1ed8", "filename": "gcc/config.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -11,6 +11,10 @@\n /* Define if your compiler understands volatile.  */\n #undef HAVE_VOLATILE\n \n+/* Define if your assembler supports specifying the maximum number\n+   of bytes to skip when using the GAS .p2align command. */\n+#undef HAVE_GAS_MAX_SKIP_P2ALIGN\n+\n /* Define if you have a working <inttypes.h> header file.  */\n #undef HAVE_INTTYPES_H\n "}, {"sha": "2da338a6518fe4baeb7ceafb0868e27441014081", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -85,6 +85,19 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n   if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n #endif\n+\n+/* A C statement to output to the stdio stream FILE an assembler\n+   command to advance the location counter to a multiple of 1<<LOG\n+   bytes if it is within MAX_SKIP bytes.\n+\n+   This is used to align code labels according to Intel recommendations.  */\n+\n+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN\n+#  define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP) \\\n+     if ((LOG)!=0) \\\n+       if ((MAX_SKIP)==0) fprintf ((FILE), \"\\t.p2align %d\\n\", (LOG)); \\\n+       else fprintf ((FILE), \"\\t.p2align %d,,%d\\n\", (LOG), (MAX_SKIP))\n+#endif\n \f\n /* A C statement or statements which output an assembler instruction\n    opcode to the stdio stream STREAM.  The macro-operand PTR is a"}, {"sha": "da08da1ff8af765e03370c98602fd91e1e29f6ef", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -332,7 +332,11 @@ override_options ()\n \t       i386_align_loops, MAX_CODE_ALIGN);\n     }\n   else\n+#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n+    i386_align_loops = 4;\n+#else\n     i386_align_loops = 2;\n+#endif\n \n   /* Validate -malign-jumps= value, or provide default.  */\n   if (i386_align_jumps_string)\n@@ -343,7 +347,11 @@ override_options ()\n \t       i386_align_jumps, MAX_CODE_ALIGN);\n     }\n   else\n+#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n+    i386_align_jumps = 4;\n+#else\n     i386_align_jumps = def_align;\n+#endif\n \n   /* Validate -malign-functions= value, or provide default. */\n   if (i386_align_funcs_string)"}, {"sha": "759e5c12a56b0a8cd71c4ab3c8f01fe2a129d7d3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -506,11 +506,13 @@ extern int ix86_arch;\n \n /* Align loop starts for optimal branching.  */\n #define LOOP_ALIGN(LABEL) (i386_align_loops)\n+#define LOOP_ALIGN_MAX_SKIP (i386_align_loops_string ? 0 : 7)\n \n /* This is how to align an instruction for optimal branching.\n    On i486 we'll get better performance by aligning on a\n    cache line (i.e. 16 byte) boundary.  */\n #define LABEL_ALIGN_AFTER_BARRIER(LABEL) (i386_align_jumps)\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (i386_align_jumps_string ? 0 : 7)\n \n \f\n /* Standard register usage.  */"}, {"sha": "23757416b8e470dc1405c392103e346b7d8cbda9", "filename": "gcc/configure", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -5070,6 +5070,53 @@ if [ -f ../ld/Makefile ]; then\n #\tfi\n fi\n \n+# Figure out what assembler alignment features are present.\n+echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n+echo \"configure:5076: checking assembler alignment features\" >&5\n+gcc_cv_as=\n+gcc_cv_as_alignment_features=\n+if [ -x as$host_exeext ]; then\n+\t# Build using assembler in the current directory.\n+\tgcc_cv_as=./as$host_exeext\n+elif [ -f $srcdir/../gas/configure.in ]; then\n+\t# Single tree build which includes gas.\n+\tfor f in $srcdir/../gas/configure.in $srcdir/../gas/Makefile.in\n+\tdo\n+\t\tgcc_cv_gas_version=`grep '^VERSION=[0-9]*\\.[0-9]*' $f`\n+\t\tif [ x$gcc_cv_gas_version != x ]; then\n+\t\t\tbreak\n+\t\tfi\n+\tdone\n+\tgcc_cv_gas_major_version=`expr \"$gcc_cv_gas_version\" : \"VERSION=\\([0-9]*\\)\"`\n+\tgcc_cv_gas_minor_version=`expr \"$gcc_cv_gas_version\" : \"VERSION=[0-9]*\\.\\([0-9]*\\)\"`\n+\t# Gas version 2.8 and later support specifying the maximum\n+\t# bytes to skip when using .p2align.\n+\tif [ \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 8 -o \"$gcc_cv_gas_major_version\" -gt 2 ]; then\n+\t\tgcc_cv_as_alignment_features=\".p2align including maximum skip\"\n+\t\tcat >> confdefs.h <<\\EOF\n+#define HAVE_GAS_MAX_SKIP_P2ALIGN 1\n+EOF\n+\n+\tfi\n+elif [ x$host = x$target ]; then\n+\t# Native build.\n+\tgcc_cv_as=as$host_exeext\n+fi\n+if [ x$gcc_cv_as != x ]; then\n+\t# Check if specifying the maximum bytes to skip when\n+\t# using .p2align is supported.\n+\techo \".p2align 4,,7\" > conftest.s\n+\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_alignment_features=\".p2align including maximum skip\"\n+\t\tcat >> confdefs.h <<\\EOF\n+#define HAVE_GAS_MAX_SKIP_P2ALIGN 1\n+EOF\n+\n+\tfi\n+\trm -f conftest.s conftest.o\n+fi\n+echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n+\n # Figure out what language subdirectories are present.\n subdirs=\n for lang in ${srcdir}/*/config-lang.in .."}, {"sha": "bb6b46c773e14d243808d39b6be3f7ae72164afe", "filename": "gcc/configure.in", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -3226,6 +3226,46 @@ if [[ -f ../ld/Makefile ]]; then\n #\tfi\n fi\n \n+# Figure out what assembler alignment features are present.\n+AC_MSG_CHECKING(assembler alignment features)\n+gcc_cv_as=\n+gcc_cv_as_alignment_features=\n+if [[ -x as$host_exeext ]]; then\n+\t# Build using assembler in the current directory.\n+\tgcc_cv_as=./as$host_exeext\n+elif [[ -f $srcdir/../gas/configure.in ]]; then\n+\t# Single tree build which includes gas.\n+\tfor f in $srcdir/../gas/configure.in $srcdir/../gas/Makefile.in\n+\tdo\n+\t\tgcc_cv_gas_version=`grep '^VERSION=[[0-9]]*\\.[[0-9]]*' $f`\n+\t\tif [[ x$gcc_cv_gas_version != x ]]; then\n+\t\t\tbreak\n+\t\tfi\n+\tdone\n+\tgcc_cv_gas_major_version=`expr \"$gcc_cv_gas_version\" : \"VERSION=\\([[0-9]]*\\)\"`\n+\tgcc_cv_gas_minor_version=`expr \"$gcc_cv_gas_version\" : \"VERSION=[[0-9]]*\\.\\([[0-9]]*\\)\"`\n+\t# Gas version 2.8 and later support specifying the maximum\n+\t# bytes to skip when using .p2align.\n+\tif [[ \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 8 -o \"$gcc_cv_gas_major_version\" -gt 2 ]]; then\n+\t\tgcc_cv_as_alignment_features=\".p2align including maximum skip\"\n+\t\tAC_DEFINE(HAVE_GAS_MAX_SKIP_P2ALIGN)\n+\tfi\n+elif [[ x$host = x$target ]]; then\n+\t# Native build.\n+\tgcc_cv_as=as$host_exeext\n+fi\n+if [[ x$gcc_cv_as != x ]]; then\n+\t# Check if specifying the maximum bytes to skip when\n+\t# using .p2align is supported.\n+\techo \".p2align 4,,7\" > conftest.s\n+\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_alignment_features=\".p2align including maximum skip\"\n+\t\tAC_DEFINE(HAVE_GAS_MAX_SKIP_P2ALIGN)\n+\tfi\n+\trm -f conftest.s conftest.o\n+fi\n+AC_MSG_RESULT($gcc_cv_as_alignment_features)\n+\n # Figure out what language subdirectories are present.\n subdirs=\n for lang in ${srcdir}/*/config-lang.in .."}, {"sha": "f6f6670f17456fcf473e47a54715f1789b2167b0", "filename": "gcc/final.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -649,9 +649,14 @@ int insn_current_align;\n    for each insn we'll call the alignment chain of this insn in the following\n    comments.  */\n \n-rtx *uid_align;\n-int *uid_shuid;\n-short *label_align;\n+struct label_alignment {\n+  short alignment;\n+  short max_skip;\n+};\n+\n+static rtx *uid_align;\n+static int *uid_shuid;\n+static struct label_alignment *label_align;\n \n /* Indicate that branch shortening hasn't yet been done.  */\n \n@@ -794,14 +799,26 @@ get_attr_length (insn)\n #define LABEL_ALIGN(LABEL) 0\n #endif\n \n+#ifndef LABEL_ALIGN_MAX_SKIP\n+#define LABEL_ALIGN_MAX_SKIP 0\n+#endif\n+\n #ifndef LOOP_ALIGN\n #define LOOP_ALIGN(LABEL) 0\n #endif\n \n+#ifndef LOOP_ALIGN_MAX_SKIP\n+#define LOOP_ALIGN_MAX_SKIP 0\n+#endif\n+\n #ifndef LABEL_ALIGN_AFTER_BARRIER\n #define LABEL_ALIGN_AFTER_BARRIER(LABEL) 0\n #endif\n \n+#ifndef LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP 0\n+#endif\n+\n #ifndef ADDR_VEC_ALIGN\n int\n final_addr_vec_align (addr_vec)\n@@ -826,7 +843,10 @@ final_addr_vec_align (addr_vec)\n static int min_labelno, max_labelno;\n \n #define LABEL_TO_ALIGNMENT(LABEL) \\\n-  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n+  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].alignment)\n+\n+#define LABEL_TO_MAX_SKIP(LABEL) \\\n+  (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].max_skip)\n \n /* For the benefit of port specific code do this also as a function.  */\n int\n@@ -962,6 +982,7 @@ shorten_branches (first)\n   int max_uid;\n   int i;\n   int max_log;\n+  int max_skip;\n #ifdef HAVE_ATTR_length\n #define MAX_CODE_ALIGN 16\n   rtx seq;\n@@ -1001,10 +1022,10 @@ shorten_branches (first)\n \n   max_labelno = max_label_num ();\n   min_labelno = get_first_label_num ();\n-  label_align\n-    = (short*) xmalloc ((max_labelno - min_labelno + 1) * sizeof (short));\n-  bzero ((char *) label_align,\n-\t (max_labelno - min_labelno + 1) * sizeof (short));\n+  label_align = (struct label_alignment *) xmalloc (\n+    (max_labelno - min_labelno + 1) * sizeof (struct label_alignment));\n+  bzero (label_align,\n+    (max_labelno - min_labelno + 1) * sizeof (struct label_alignment));\n \n   uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n \n@@ -1014,7 +1035,10 @@ shorten_branches (first)\n      impose on the next CODE_LABEL (or the current one if we are processing\n      the CODE_LABEL itself).  */\n      \n-  for (max_log = 0, insn = get_insns (), i = 1; insn; insn = NEXT_INSN (insn))\n+  max_log = 0;\n+  max_skip = 0;\n+\n+  for (insn = get_insns (), i = 1; insn; insn = NEXT_INSN (insn))\n     {\n       int log;\n \n@@ -1033,7 +1057,10 @@ shorten_branches (first)\n \n \t  log = LABEL_ALIGN (insn);\n \t  if (max_log < log)\n-\t    max_log = log;\n+\t    {\n+\t      max_log = log;\n+\t      max_skip = LABEL_ALIGN_MAX_SKIP;\n+\t    }\n \t  next = NEXT_INSN (insn);\n /* ADDR_VECs only take room if read-only data goes into the text section.  */\n #if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n@@ -1045,12 +1072,17 @@ shorten_branches (first)\n \t\t{\n \t\t  log = ADDR_VEC_ALIGN (next);\n \t\t  if (max_log < log)\n-\t\t    max_log = log;\n+\t\t    {\n+\t\t      max_log = log;\n+\t\t      max_skip = LABEL_ALIGN_MAX_SKIP;\n+\t\t    }\n \t\t}\n \t    }\n #endif\n \t  LABEL_TO_ALIGNMENT (insn) = max_log;\n+\t  LABEL_TO_MAX_SKIP (insn) = max_skip;\n \t  max_log = 0;\n+\t  max_skip = 0;\n \t}\n       else if (GET_CODE (insn) == BARRIER)\n \t{\n@@ -1062,7 +1094,10 @@ shorten_branches (first)\n \t      {\n \t\tlog = LABEL_ALIGN_AFTER_BARRIER (insn);\n \t\tif (max_log < log)\n-\t\t  max_log = log;\n+\t\t  {\n+\t\t    max_log = log;\n+\t\t    max_skip = LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP;\n+\t\t  }\n \t\tbreak;\n \t      }\n \t}\n@@ -1078,7 +1113,10 @@ shorten_branches (first)\n \t      {\n \t\tlog = LOOP_ALIGN (insn);\n \t\tif (max_log < log)\n-\t\t  max_log = log;\n+\t\t  {\n+\t\t    max_log = log;\n+\t\t    max_skip = LOOP_ALIGN_MAX_SKIP;\n+\t\t  }\n \t\tbreak;\n \t      }\n \t}\n@@ -2222,9 +2260,14 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       if (CODE_LABEL_NUMBER (insn) <= max_labelno)\n \t{\n \t  int align = LABEL_TO_ALIGNMENT (insn);\n+\t  int max_skip = LABEL_TO_MAX_SKIP (insn);\n \n \t  if (align && NEXT_INSN (insn))\n+#ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n+\t    ASM_OUTPUT_MAX_SKIP_ALIGN (file, align, max_skip);\n+#else\n \t    ASM_OUTPUT_ALIGN (file, align);\n+#endif\n \t}\n       CC_STATUS_INIT;\n       if (prescan > 0)"}, {"sha": "4d1a413717d61ad395990ba688039f3bf69ba32e", "filename": "gcc/invoke.texi", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e423e6db21b75a78fb1d636673bfaed94fc979f/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=9e423e6db21b75a78fb1d636673bfaed94fc979f", "patch": "@@ -4905,12 +4905,18 @@ startup modules.\n \n @item -malign-loops=@var{num}\n Align loops to a 2 raised to a @var{num} byte boundary.  If\n-@samp{-malign-loops} is not specified, the default is 2.\n+@samp{-malign-loops} is not specified, the default is 2 unless\n+gas 2.8 (or later) is being used in which case the default is\n+to align the loop on a 16 byte boundary if it is less than 8\n+bytes away.\n \n @item -malign-jumps=@var{num}\n Align instructions that are only jumped to to a 2 raised to a @var{num}\n byte boundary.  If @samp{-malign-jumps} is not specified, the default is\n-2 if optimizing for a 386, and 4 if optimizing for a 486.\n+2 if optimizing for a 386, and 4 if optimizing for a 486 unless\n+gas 2.8 (or later) is being used in which case the default is\n+to align the instruction on a 16 byte boundary if it is less\n+than 8 bytes away.\n \n @item -malign-functions=@var{num}\n Align the start of functions to a 2 raised to @var{num} byte boundary."}]}