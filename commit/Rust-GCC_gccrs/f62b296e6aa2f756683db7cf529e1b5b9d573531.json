{"sha": "f62b296e6aa2f756683db7cf529e1b5b9d573531", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyYjI5NmU2YWEyZjc1NjY4M2RiN2NmNTI5ZTFiNWI5ZDU3MzUzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-04T09:08:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-04T09:08:20Z"}, "message": "[multiple changes]\n\n2012-10-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Set_CPP_Constructors_Old): Removed.\n\t(Set_CPP_Constructors): Code cleanup.\n\n2012-10-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.adb (Is_Ancestor_Unit): Make global, for use elsewhere.\n\t(Install_Private_with_Clauses): if clause is private and limited,\n\tdo not install the limited view if the library unit is an ancestor\n\tof the unit being compiled.  This unusual configuration occurs\n\twhen compiling a unit DDP, when an ancestor P of DDP has a\n\tprivate limited with clause on a descendant of P that is itself\n\tan ancestor of DDP.\n\nFrom-SVN: r192069", "tree": {"sha": "5625fdeb83839dbcd6f7cc69ecdd60705223358b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5625fdeb83839dbcd6f7cc69ecdd60705223358b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f62b296e6aa2f756683db7cf529e1b5b9d573531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62b296e6aa2f756683db7cf529e1b5b9d573531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62b296e6aa2f756683db7cf529e1b5b9d573531", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62b296e6aa2f756683db7cf529e1b5b9d573531/comments", "author": null, "committer": null, "parents": [{"sha": "4bb43ffbb8be3e43a559e218f422a10fda465f1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb43ffbb8be3e43a559e218f422a10fda465f1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb43ffbb8be3e43a559e218f422a10fda465f1d"}], "stats": {"total": 593, "additions": 256, "deletions": 337}, "files": [{"sha": "bb4f042b923c4535a1951fb90351c29f1b607b95", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f62b296e6aa2f756683db7cf529e1b5b9d573531", "patch": "@@ -1,3 +1,18 @@\n+2012-10-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Set_CPP_Constructors_Old): Removed.\n+\t(Set_CPP_Constructors): Code cleanup.\n+\n+2012-10-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch10.adb (Is_Ancestor_Unit): Make global, for use elsewhere.\n+\t(Install_Private_with_Clauses): if clause is private and limited,\n+\tdo not install the limited view if the library unit is an ancestor\n+\tof the unit being compiled.  This unusual configuration occurs\n+\twhen compiling a unit DDP, when an ancestor P of DDP has a\n+\tprivate limited with clause on a descendant of P that is itself\n+\tan ancestor of DDP.\n+\n 2012-10-04  Vincent Celier  <celier@adacore.com>\n \n \t* prj-proc.adb (Process_Package_Declaration): Use project"}, {"sha": "9b5cb5716ea69a77b96b4d6030ebf0ec2ca11480", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 210, "deletions": 315, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f62b296e6aa2f756683db7cf529e1b5b9d573531", "patch": "@@ -8447,152 +8447,49 @@ package body Exp_Disp is\n \n    procedure Set_CPP_Constructors (Typ : Entity_Id) is\n \n-      procedure Set_CPP_Constructors_Old (Typ : Entity_Id);\n-      --  For backward compatibility this routine handles CPP constructors\n-      --  of non-tagged types.\n-\n-      procedure Set_CPP_Constructors_Old (Typ : Entity_Id) is\n-         Loc   : Source_Ptr;\n-         Init  : Entity_Id;\n-         E     : Entity_Id;\n-         Found : Boolean := False;\n-         P     : Node_Id;\n-         Parms : List_Id;\n+      function Gen_Parameters_Profile (E : Entity_Id) return List_Id;\n+      --  Duplicate the parameters profile of the imported C++ constructor\n+      --  adding an access to the object as an additional parameter.\n \n-         Covers_Default_Constructor : Entity_Id := Empty;\n+      function Gen_Parameters_Profile (E : Entity_Id) return List_Id is\n+         Loc   : constant Source_Ptr := Sloc (E);\n+         Parms : List_Id;\n+         P     : Node_Id;\n \n       begin\n-         --  Look for the constructor entities\n-\n-         E := Next_Entity (Typ);\n-         while Present (E) loop\n-            if Ekind (E) = E_Function\n-              and then Is_Constructor (E)\n-            then\n-               --  Create the init procedure\n-\n-               Found := True;\n-               Loc   := Sloc (E);\n-               Init  := Make_Defining_Identifier (Loc,\n-                          Make_Init_Proc_Name (Typ));\n-               Parms :=\n-                 New_List (\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier =>\n-                       Make_Defining_Identifier (Loc, Name_X),\n-                     Parameter_Type =>\n-                       New_Reference_To (Typ, Loc)));\n-\n-               if Present (Parameter_Specifications (Parent (E))) then\n-                  P := First (Parameter_Specifications (Parent (E)));\n-                  while Present (P) loop\n-                     Append_To (Parms,\n-                       Make_Parameter_Specification (Loc,\n-                         Defining_Identifier =>\n-                           Make_Defining_Identifier (Loc,\n-                             Chars (Defining_Identifier (P))),\n-                         Parameter_Type =>\n-                           New_Copy_Tree (Parameter_Type (P)),\n-                         Expression => New_Copy_Tree (Expression (P))));\n-                     Next (P);\n-                  end loop;\n-               end if;\n-\n-               Discard_Node (\n-                 Make_Subprogram_Declaration (Loc,\n-                   Make_Procedure_Specification (Loc,\n-                     Defining_Unit_Name => Init,\n-                     Parameter_Specifications => Parms)));\n-\n-               Set_Init_Proc (Typ, Init);\n-               Set_Is_Imported    (Init);\n-               Set_Is_Constructor (Init);\n-               Set_Interface_Name (Init, Interface_Name (E));\n-               Set_Convention     (Init, Convention_CPP);\n-               Set_Is_Public      (Init);\n-               Set_Has_Completion (Init);\n-\n-               --  If this constructor has parameters and all its parameters\n-               --  have defaults then it covers the default constructor. The\n-               --  semantic analyzer ensures that only one constructor with\n-               --  defaults covers the default constructor.\n-\n-               if Present (Parameter_Specifications (Parent (E)))\n-                 and then Needs_No_Actuals (E)\n-               then\n-                  Covers_Default_Constructor := Init;\n-               end if;\n-            end if;\n-\n-            Next_Entity (E);\n-         end loop;\n-\n-         --  If there are no constructors, mark the type as abstract since we\n-         --  won't be able to declare objects of that type.\n-\n-         if not Found then\n-            Set_Is_Abstract_Type (Typ);\n+         Parms :=\n+           New_List (\n+             Make_Parameter_Specification (Loc,\n+               Defining_Identifier =>\n+                 Make_Defining_Identifier (Loc, Name_uInit),\n+               Parameter_Type      => New_Reference_To (Typ, Loc)));\n+\n+         if Present (Parameter_Specifications (Parent (E))) then\n+            P := First (Parameter_Specifications (Parent (E)));\n+            while Present (P) loop\n+               Append_To (Parms,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc,\n+                       Chars => Chars (Defining_Identifier (P))),\n+                   Parameter_Type      => New_Copy_Tree (Parameter_Type (P)),\n+                   Expression          => New_Copy_Tree (Expression (P))));\n+               Next (P);\n+            end loop;\n          end if;\n \n-         --  Handle constructor that has all its parameters with defaults and\n-         --  hence it covers the default constructor. We generate a wrapper IP\n-         --  which calls the covering constructor.\n-\n-         if Present (Covers_Default_Constructor) then\n-            declare\n-               Body_Stmts        : List_Id;\n-               Wrapper_Id        : Entity_Id;\n-               Wrapper_Body_Node : Node_Id;\n-            begin\n-               Loc := Sloc (Covers_Default_Constructor);\n-\n-               Body_Stmts := New_List (\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (Covers_Default_Constructor, Loc),\n-                   Parameter_Associations => New_List (\n-                     Make_Identifier (Loc, Name_uInit))));\n-\n-               Wrapper_Id := Make_Defining_Identifier (Loc,\n-                 Make_Init_Proc_Name (Typ));\n-\n-               Wrapper_Body_Node :=\n-                 Make_Subprogram_Body (Loc,\n-                   Specification =>\n-                     Make_Procedure_Specification (Loc,\n-                       Defining_Unit_Name => Wrapper_Id,\n-                       Parameter_Specifications => New_List (\n-                         Make_Parameter_Specification (Loc,\n-                           Defining_Identifier =>\n-                             Make_Defining_Identifier (Loc, Name_uInit),\n-                           Parameter_Type =>\n-                             New_Reference_To (Typ, Loc)))),\n-                   Declarations => No_List,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => Body_Stmts,\n-                       Exception_Handlers => No_List));\n-\n-               Discard_Node (Wrapper_Body_Node);\n-               Set_Init_Proc (Typ, Wrapper_Id);\n-            end;\n-         end if;\n-      end Set_CPP_Constructors_Old;\n+         return Parms;\n+      end Gen_Parameters_Profile;\n \n       --  Local variables\n \n-      Loc   : Source_Ptr;\n-      E     : Entity_Id;\n-      Found : Boolean := False;\n-      P     : Node_Id;\n-      Parms : List_Id;\n-\n-      Constructor_Decl_Node : Node_Id;\n-      Constructor_Id        : Entity_Id;\n-      Wrapper_Id            : Entity_Id;\n-      Wrapper_Body_Node     : Node_Id;\n-      Actuals               : List_Id;\n-      Body_Stmts            : List_Id;\n-      Init_Tags_List        : List_Id;\n+      Loc     : Source_Ptr;\n+      E       : Entity_Id;\n+      Found   : Boolean := False;\n+      IP      : Entity_Id;\n+      IP_Body : Node_Id;\n+      P       : Node_Id;\n+      Parms   : List_Id;\n \n       Covers_Default_Constructor : Entity_Id := Empty;\n \n@@ -8601,22 +8498,6 @@ package body Exp_Disp is\n    begin\n       pragma Assert (Is_CPP_Class (Typ));\n \n-      --  For backward compatibility the compiler accepts C++ classes\n-      --  imported through non-tagged record types. In such case the\n-      --  wrapper of the C++ constructor is useless because the _tag\n-      --  component is not available.\n-\n-      --  Example:\n-      --     type Root is limited record ...\n-      --     pragma Import (CPP, Root);\n-      --     function New_Root return Root;\n-      --     pragma CPP_Constructor (New_Root, ... );\n-\n-      if not Is_Tagged_Type (Typ) then\n-         Set_CPP_Constructors_Old (Typ);\n-         return;\n-      end if;\n-\n       --  Look for the constructor entities\n \n       E := Next_Entity (Typ);\n@@ -8626,156 +8507,167 @@ package body Exp_Disp is\n          then\n             Found := True;\n             Loc   := Sloc (E);\n+            Parms := Gen_Parameters_Profile (E);\n+            IP    :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => Make_Init_Proc_Name (Typ));\n+\n+            --  Case 1: Constructor of non-tagged type\n+\n+            --  If the C++ class has no virtual methods then the matching Ada\n+            --  type is a non-tagged record type. In such case there is no need\n+            --  to generate a wrapper of the C++ constructor because the _tag\n+            --  component is not available.\n+\n+            if not Is_Tagged_Type (Typ) then\n+               Discard_Node\n+                 (Make_Subprogram_Declaration (Loc,\n+                    Specification =>\n+                      Make_Procedure_Specification (Loc,\n+                        Defining_Unit_Name       => IP,\n+                        Parameter_Specifications => Parms)));\n+\n+               Set_Init_Proc (Typ, IP);\n+               Set_Is_Imported    (IP);\n+               Set_Is_Constructor (IP);\n+               Set_Interface_Name (IP, Interface_Name (E));\n+               Set_Convention     (IP, Convention_CPP);\n+               Set_Is_Public      (IP);\n+               Set_Has_Completion (IP);\n+\n+            --  Case 2: Constructor of a tagged type\n+\n+            --  In this case we generate the IP as a wrapper of the the\n+            --  C++ constructor because IP must also save copy of the _tag\n+            --  generated in the C++ side. The copy of the _tag is used by\n+            --  Build_CPP_Init_Procedure to elaborate derivations of C++ types.\n \n-            --  Generate the declaration of the imported C++ constructor\n-\n-            Parms :=\n-              New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_uInit),\n-                  Parameter_Type =>\n-                    New_Reference_To (Typ, Loc)));\n-\n-            if Present (Parameter_Specifications (Parent (E))) then\n-               P := First (Parameter_Specifications (Parent (E)));\n-               while Present (P) loop\n-                  Append_To (Parms,\n-                    Make_Parameter_Specification (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars (Defining_Identifier (P))),\n-                      Parameter_Type => New_Copy_Tree (Parameter_Type (P))));\n-                  Next (P);\n-               end loop;\n-            end if;\n-\n-            Constructor_Id := Make_Temporary (Loc, 'P');\n+            --  Generate:\n+            --     procedure IP (_init : Typ; ...) is\n+            --        procedure ConstructorP (_init : Typ; ...);\n+            --        pragma Import (ConstructorP);\n+            --     begin\n+            --        ConstructorP (_init, ...);\n+            --        if Typ._tag = null then\n+            --           Typ._tag := _init._tag;\n+            --        end if;\n+            --     end IP;\n \n-            Constructor_Decl_Node :=\n-              Make_Subprogram_Declaration (Loc,\n-                Make_Procedure_Specification (Loc,\n-                  Defining_Unit_Name => Constructor_Id,\n-                  Parameter_Specifications => Parms));\n+            else\n+               declare\n+                  Body_Stmts            : constant List_Id := New_List;\n+                  Constructor_Id        : Entity_Id;\n+                  Constructor_Decl_Node : Node_Id;\n+                  Init_Tags_List        : List_Id;\n \n-            Set_Is_Imported    (Constructor_Id);\n-            Set_Is_Constructor (Constructor_Id);\n-            Set_Interface_Name (Constructor_Id, Interface_Name (E));\n-            Set_Convention     (Constructor_Id, Convention_CPP);\n-            Set_Is_Public      (Constructor_Id);\n-            Set_Has_Completion (Constructor_Id);\n+               begin\n+                  Constructor_Id := Make_Temporary (Loc, 'P');\n \n-            --  Build the wrapper of this constructor\n+                  Constructor_Decl_Node :=\n+                    Make_Subprogram_Declaration (Loc,\n+                      Make_Procedure_Specification (Loc,\n+                        Defining_Unit_Name => Constructor_Id,\n+                        Parameter_Specifications => Parms));\n \n-            Parms :=\n-              New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier =>\n-                    Make_Defining_Identifier (Loc, Name_uInit),\n-                  Parameter_Type =>\n-                    New_Reference_To (Typ, Loc)));\n-\n-            if Present (Parameter_Specifications (Parent (E))) then\n-               P := First (Parameter_Specifications (Parent (E)));\n-               while Present (P) loop\n-                  Append_To (Parms,\n-                    Make_Parameter_Specification (Loc,\n-                      Defining_Identifier =>\n-                        Make_Defining_Identifier (Loc,\n-                          Chars (Defining_Identifier (P))),\n-                      Parameter_Type      =>\n-                        New_Copy_Tree (Parameter_Type (P)),\n-                      Expression          => New_Copy_Tree (Expression (P))));\n-                  Next (P);\n-               end loop;\n-            end if;\n+                  Set_Is_Imported    (Constructor_Id);\n+                  Set_Is_Constructor (Constructor_Id);\n+                  Set_Interface_Name (Constructor_Id, Interface_Name (E));\n+                  Set_Convention     (Constructor_Id, Convention_CPP);\n+                  Set_Is_Public      (Constructor_Id);\n+                  Set_Has_Completion (Constructor_Id);\n \n-            Body_Stmts := New_List;\n+                  --  Build the init procedure as a wrapper of this constructor\n \n-            --  Invoke the C++ constructor\n+                  Parms := Gen_Parameters_Profile (E);\n \n-            Actuals := New_List;\n+                  --  Invoke the C++ constructor\n \n-            P := First (Parms);\n-            while Present (P) loop\n-               Append_To (Actuals,\n-                 New_Reference_To (Defining_Identifier (P), Loc));\n-               Next (P);\n-            end loop;\n+                  declare\n+                     Actuals : constant List_Id := New_List;\n \n-            Append_To (Body_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (Constructor_Id, Loc),\n-                Parameter_Associations => Actuals));\n-\n-            --  Initialize copies of C++ primary and secondary tags\n-\n-            Init_Tags_List := New_List;\n-\n-            declare\n-               Tag_Elmt : Elmt_Id;\n-               Tag_Comp : Node_Id;\n-\n-            begin\n-               Tag_Elmt := First_Elmt (Access_Disp_Table (Typ));\n-               Tag_Comp := First_Tag_Component (Typ);\n+                  begin\n+                     P := First (Parms);\n+                     while Present (P) loop\n+                        Append_To (Actuals,\n+                          New_Reference_To (Defining_Identifier (P), Loc));\n+                        Next (P);\n+                     end loop;\n \n-               while Present (Tag_Elmt)\n-                 and then Is_Tag (Node (Tag_Elmt))\n-               loop\n-                  --  Skip the following assertion with primary tags because\n-                  --  Related_Type is not set on primary tag components\n+                     Append_To (Body_Stmts,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name => New_Reference_To (Constructor_Id, Loc),\n+                         Parameter_Associations => Actuals));\n+                  end;\n \n-                  pragma Assert (Tag_Comp = First_Tag_Component (Typ)\n-                    or else Related_Type (Node (Tag_Elmt))\n-                              = Related_Type (Tag_Comp));\n+                  --  Initialize copies of C++ primary and secondary tags\n \n-                  Append_To (Init_Tags_List,\n-                    Make_Assignment_Statement (Loc,\n-                      Name =>\n-                        New_Reference_To (Node (Tag_Elmt), Loc),\n-                      Expression =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix        =>\n-                            Make_Identifier (Loc, Name_uInit),\n-                          Selector_Name =>\n-                            New_Reference_To (Tag_Comp, Loc))));\n+                  Init_Tags_List := New_List;\n \n-                     Tag_Comp := Next_Tag_Component (Tag_Comp);\n-                  Next_Elmt (Tag_Elmt);\n-               end loop;\n-            end;\n+                  declare\n+                     Tag_Elmt : Elmt_Id;\n+                     Tag_Comp : Node_Id;\n \n-            Append_To (Body_Stmts,\n-              Make_If_Statement (Loc,\n-                Condition =>\n-                  Make_Op_Eq (Loc,\n-                    Left_Opnd =>\n-                      New_Reference_To\n-                        (Node (First_Elmt (Access_Disp_Table (Typ))),\n-                         Loc),\n-                    Right_Opnd =>\n-                      Unchecked_Convert_To (RTE (RE_Tag),\n-                        New_Reference_To (RTE (RE_Null_Address), Loc))),\n-                Then_Statements => Init_Tags_List));\n+                  begin\n+                     Tag_Elmt := First_Elmt (Access_Disp_Table (Typ));\n+                     Tag_Comp := First_Tag_Component (Typ);\n \n-            Wrapper_Id := Make_Defining_Identifier (Loc,\n-                            Make_Init_Proc_Name (Typ));\n+                     while Present (Tag_Elmt)\n+                       and then Is_Tag (Node (Tag_Elmt))\n+                     loop\n+                        --  Skip the following assertion with primary tags\n+                        --  because Related_Type is not set on primary tag\n+                        --  components\n+\n+                        pragma Assert\n+                          (Tag_Comp = First_Tag_Component (Typ)\n+                             or else Related_Type (Node (Tag_Elmt))\n+                                       = Related_Type (Tag_Comp));\n+\n+                        Append_To (Init_Tags_List,\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              New_Reference_To (Node (Tag_Elmt), Loc),\n+                            Expression =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix        =>\n+                                  Make_Identifier (Loc, Name_uInit),\n+                                Selector_Name =>\n+                                  New_Reference_To (Tag_Comp, Loc))));\n \n-            Wrapper_Body_Node :=\n-              Make_Subprogram_Body (Loc,\n-                Specification =>\n-                  Make_Procedure_Specification (Loc,\n-                    Defining_Unit_Name => Wrapper_Id,\n-                    Parameter_Specifications => Parms),\n-                Declarations => New_List (Constructor_Decl_Node),\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => Body_Stmts,\n-                    Exception_Handlers => No_List));\n+                        Tag_Comp := Next_Tag_Component (Tag_Comp);\n+                        Next_Elmt (Tag_Elmt);\n+                     end loop;\n+                  end;\n \n-            Discard_Node (Wrapper_Body_Node);\n-            Set_Init_Proc (Typ, Wrapper_Id);\n+                  Append_To (Body_Stmts,\n+                    Make_If_Statement (Loc,\n+                      Condition =>\n+                        Make_Op_Eq (Loc,\n+                          Left_Opnd =>\n+                            New_Reference_To\n+                              (Node (First_Elmt (Access_Disp_Table (Typ))),\n+                               Loc),\n+                          Right_Opnd =>\n+                            Unchecked_Convert_To (RTE (RE_Tag),\n+                              New_Reference_To (RTE (RE_Null_Address), Loc))),\n+                      Then_Statements => Init_Tags_List));\n+\n+                  IP_Body :=\n+                    Make_Subprogram_Body (Loc,\n+                      Specification =>\n+                        Make_Procedure_Specification (Loc,\n+                          Defining_Unit_Name => IP,\n+                          Parameter_Specifications => Parms),\n+                      Declarations => New_List (Constructor_Decl_Node),\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                          Statements => Body_Stmts,\n+                          Exception_Handlers => No_List));\n+\n+                  Discard_Node (IP_Body);\n+                  Set_Init_Proc (Typ, IP);\n+               end;\n+            end if;\n \n             --  If this constructor has parameters and all its parameters\n             --  have defaults then it covers the default constructor. The\n@@ -8785,7 +8677,7 @@ package body Exp_Disp is\n             if Present (Parameter_Specifications (Parent (E)))\n               and then Needs_No_Actuals (E)\n             then\n-               Covers_Default_Constructor := Wrapper_Id;\n+               Covers_Default_Constructor := IP;\n             end if;\n          end if;\n \n@@ -8804,39 +8696,42 @@ package body Exp_Disp is\n       --  which calls the covering constructor.\n \n       if Present (Covers_Default_Constructor) then\n-         Loc := Sloc (Covers_Default_Constructor);\n+         declare\n+            Body_Stmts : List_Id;\n \n-         Body_Stmts := New_List (\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Reference_To (Covers_Default_Constructor, Loc),\n-             Parameter_Associations => New_List (\n-               Make_Identifier (Loc, Name_uInit))));\n+         begin\n+            Loc := Sloc (Covers_Default_Constructor);\n \n-         Wrapper_Id :=\n-           Make_Defining_Identifier (Loc, Make_Init_Proc_Name (Typ));\n+            Body_Stmts := New_List (\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Reference_To (Covers_Default_Constructor, Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Identifier (Loc, Name_uInit))));\n \n-         Wrapper_Body_Node :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name       => Wrapper_Id,\n-                 Parameter_Specifications => New_List (\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier =>\n-                       Make_Defining_Identifier (Loc, Name_uInit),\n-                     Parameter_Type      =>\n-                       New_Reference_To (Typ, Loc)))),\n-\n-             Declarations               => No_List,\n+            IP := Make_Defining_Identifier (Loc, Make_Init_Proc_Name (Typ));\n \n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements         => Body_Stmts,\n-                 Exception_Handlers => No_List));\n+            IP_Body :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              =>\n+                  Make_Procedure_Specification (Loc,\n+                    Defining_Unit_Name       => IP,\n+                    Parameter_Specifications => New_List (\n+                      Make_Parameter_Specification (Loc,\n+                        Defining_Identifier =>\n+                          Make_Defining_Identifier (Loc, Name_uInit),\n+                        Parameter_Type      => New_Reference_To (Typ, Loc)))),\n \n-         Discard_Node (Wrapper_Body_Node);\n-         Set_Init_Proc (Typ, Wrapper_Id);\n+                Declarations               => No_List,\n+\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements         => Body_Stmts,\n+                    Exception_Handlers => No_List));\n+\n+            Discard_Node (IP_Body);\n+            Set_Init_Proc (Typ, IP);\n+         end;\n       end if;\n \n       --  If the CPP type has constructors then it must import also the default"}, {"sha": "0a90eb2e80ad148a1cef1d647f6847abf7baca1e", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f62b296e6aa2f756683db7cf529e1b5b9d573531/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=f62b296e6aa2f756683db7cf529e1b5b9d573531", "patch": "@@ -164,6 +164,11 @@ package body Sem_Ch10 is\n    --  an enclosing scope. Iterate over context to find child units of U_Name\n    --  or of some ancestor of it.\n \n+   function Is_Ancestor_Unit (U1 : Node_Id; U2 : Node_Id) return Boolean;\n+   --  When compiling a unit Q descended from some parent unit P, a limited\n+   --  with_clause in the context of P that names some other ancestor of Q\n+   --  must not be installed because the ancestor is immediately visible.\n+\n    function Is_Child_Spec (Lib_Unit : Node_Id) return Boolean;\n    --  Lib_Unit is a library unit which may be a spec or a body. Is_Child_Spec\n    --  returns True if Lib_Unit is a library spec which is a child spec, i.e.\n@@ -3521,11 +3526,6 @@ package body Sem_Ch10 is\n       --  units. The shadow entities are created when the inserted clause is\n       --  analyzed. Implements Ada 2005 (AI-50217).\n \n-      function Is_Ancestor_Unit (U1 : Node_Id; U2 : Node_Id) return Boolean;\n-      --  When compiling a unit Q descended from some parent unit P, a limited\n-      --  with_clause in the context of P that names some other ancestor of Q\n-      --  must not be installed because the ancestor is immediately visible.\n-\n       ---------------------\n       -- Check_Renamings --\n       ---------------------\n@@ -3794,22 +3794,6 @@ package body Sem_Ch10 is\n          end if;\n       end Expand_Limited_With_Clause;\n \n-      ----------------------\n-      -- Is_Ancestor_Unit --\n-      ----------------------\n-\n-      function Is_Ancestor_Unit (U1 : Node_Id; U2 : Node_Id) return Boolean is\n-         E1 : constant Entity_Id := Defining_Entity (Unit (U1));\n-         E2 : Entity_Id;\n-      begin\n-         if Nkind_In (Unit (U2), N_Package_Body, N_Subprogram_Body) then\n-            E2 := Defining_Entity (Unit (Library_Unit (U2)));\n-            return Is_Ancestor_Package (E1, E2);\n-         else\n-            return False;\n-         end if;\n-      end Is_Ancestor_Unit;\n-\n    --  Start of processing for Install_Limited_Context_Clauses\n \n    begin\n@@ -4061,8 +4045,17 @@ package body Sem_Ch10 is\n             if Nkind (Item) = N_With_Clause\n               and then Private_Present (Item)\n             then\n+               --  If the unit is an ancestor of the current one, it is the\n+               --  case of a private limited with clause on a child unit, and\n+               --  the compilation of one of its descendants, In that case the\n+               --  limited view is errelevant.\n+\n                if Limited_Present (Item) then\n-                  if not Limited_View_Installed (Item) then\n+                  if not Limited_View_Installed (Item)\n+                    and then\n+                      not Is_Ancestor_Unit (Library_Unit (Item),\n+                                            Cunit (Current_Sem_Unit))\n+                  then\n                      Install_Limited_Withed_Unit (Item);\n                   end if;\n                else\n@@ -5269,6 +5262,22 @@ package body Sem_Ch10 is\n             (C_Unit, Cunit_Entity (Get_Source_Unit (Non_Limited_View (T))));\n    end Is_Legal_Shadow_Entity_In_Body;\n \n+   ----------------------\n+   -- Is_Ancestor_Unit --\n+   ----------------------\n+\n+   function Is_Ancestor_Unit (U1 : Node_Id; U2 : Node_Id) return Boolean is\n+      E1 : constant Entity_Id := Defining_Entity (Unit (U1));\n+      E2 : Entity_Id;\n+   begin\n+      if Nkind_In (Unit (U2), N_Package_Body, N_Subprogram_Body) then\n+         E2 := Defining_Entity (Unit (Library_Unit (U2)));\n+         return Is_Ancestor_Package (E1, E2);\n+      else\n+         return False;\n+      end if;\n+   end Is_Ancestor_Unit;\n+\n    -----------------------\n    -- Load_Needed_Body --\n    -----------------------"}]}