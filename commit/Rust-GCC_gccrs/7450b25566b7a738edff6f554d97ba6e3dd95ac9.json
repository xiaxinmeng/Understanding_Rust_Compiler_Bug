{"sha": "7450b25566b7a738edff6f554d97ba6e3dd95ac9", "node_id": "C_kwDOANBUbNoAKDc0NTBiMjU1NjZiN2E3MzhlZGZmNmY1NTRkOTdiYTZlM2RkOTVhYzk", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:05Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:57:32Z"}, "message": "ipa-cp: Write transformation summaries of all functions\n\nIPA-CP transformation summary streaming code currently won't stream\nout transformations necessary for clones which are only necessary for\nmaterialization of other clones (such as an IPA-CP clone which is then\ncloned again by IPA-SRA).  However, a follow-up patch for bettor\nreconciling IPA-SRA and IPA-CP modifications requires to have that\ninformation at its disposal and so this one reworks the streaming to\nwrite out all non-empty transformation summaries.\n\nIn order not to stream transformation summaies into partitions where\nthe node itself nor any of its clones are materialized, I had to make\nsure that clones also get encode_body flag in the encoder (so that it\ncould be tested) and therefore in turn lto_output understands it needs\nto skip clones.\n\nThis should actually mean less streaming in typical case because\npreviously we streamed three zeros for all nodes in a partition with\nno useful information associated with them.  Currently we don't stream\nanything for those.\n\nWhen reworking the streaming, I also simplified it a little a\nconverted it writing to nicer C++ vector iterations.\n\ngcc/ChangeLog:\n\n2022-11-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.cc (useful_ipcp_transformation_info_p): New function.\n\t(write_ipcp_transformation_info): Added a parameter, simplified\n\tgiven that is known not to be NULL.\n\t(ipcp_write_transformation_summaries): Write out all useful\n\ttransformation summaries.\n\t(read_ipcp_transformation_info): Simplify given that some info\n\twill be read.\n\t(read_replacements_section): Remove assert.\n\t* lto-cgraph.cc (add_node_to): Also set encode_body for clones.\n\t* lto-streamer-out.cc (lto_output): Do not output virtual clones.", "tree": {"sha": "8140aea2b342acd0897579bdb46c263679bd1ad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8140aea2b342acd0897579bdb46c263679bd1ad0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7450b25566b7a738edff6f554d97ba6e3dd95ac9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEWwACgkQv2PBvD+k\nNUAqag//Yqhew0VfaPg7BBc3wY8RutPwkV/VWzgSs9o7K2+LWxuKOsdUN9ApFllW\nlHVKfcDQgPC0R10UX8e7lfObSlDfdVgLXzjmVYUbtq06XhbfBBXwbPbhrQniqvzE\nCLldV9myouyAgm77LcWEsDudFcmBNfyjbLC0EFxdVr6svcMw+2hwGeQ6YhVusf1n\njoMMUUjvmhR3Arncme2RSUwSASrZZuvACZhEJ4yQnLvEl8ZbULZzturAwDdV1WpE\nBiR2GbwaZNY82HB0/MJzeaEsplFLx0CerR2XozSBoyWsLFoOc6P+ZEp1wJ4tJTSO\nq7JBJqj7h+XoxSfYqaIHIKXFI3RvCrrVRb19E710ljJZy5drS+P7ZFAm/VCanOso\nVTUtRfFHxXTgmu/Nse+DNPk/CbNM+p3paTC1eIaRhWZh68WoOsiXPFCv46Ncr2Qa\naY7DCRjnRhPSr+51k7wkmJ7Zz57309+BWYf80//HdGuzmRhbl93fZ+iwWFUDR0N2\nX+iZYHRcBgUJYgjGW8sGezDBAtZNmgMtB/Llg3ye/yJwJ/zvEgKT1lAoikjymXJy\nHRp4J7GxWFZwiNKwVMEh9UEtUZ9kuh28//G8V0KXB+TuIqZ04FzH7iMPWc6SnIFq\nQfYDu9jCHpSTBDpryFeR/E8fWarOiZHcSLbdXGTXXuU8qf0GcdI=\n=K0UC\n-----END PGP SIGNATURE-----", "payload": "tree 8140aea2b342acd0897579bdb46c263679bd1ad0\nparent 37c2d99f3f569350ebc0de43c10374b90086b832\nauthor Martin Jambor <mjambor@suse.cz> 1670974385 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975852 +0100\n\nipa-cp: Write transformation summaries of all functions\n\nIPA-CP transformation summary streaming code currently won't stream\nout transformations necessary for clones which are only necessary for\nmaterialization of other clones (such as an IPA-CP clone which is then\ncloned again by IPA-SRA).  However, a follow-up patch for bettor\nreconciling IPA-SRA and IPA-CP modifications requires to have that\ninformation at its disposal and so this one reworks the streaming to\nwrite out all non-empty transformation summaries.\n\nIn order not to stream transformation summaies into partitions where\nthe node itself nor any of its clones are materialized, I had to make\nsure that clones also get encode_body flag in the encoder (so that it\ncould be tested) and therefore in turn lto_output understands it needs\nto skip clones.\n\nThis should actually mean less streaming in typical case because\npreviously we streamed three zeros for all nodes in a partition with\nno useful information associated with them.  Currently we don't stream\nanything for those.\n\nWhen reworking the streaming, I also simplified it a little a\nconverted it writing to nicer C++ vector iterations.\n\ngcc/ChangeLog:\n\n2022-11-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.cc (useful_ipcp_transformation_info_p): New function.\n\t(write_ipcp_transformation_info): Added a parameter, simplified\n\tgiven that is known not to be NULL.\n\t(ipcp_write_transformation_summaries): Write out all useful\n\ttransformation summaries.\n\t(read_ipcp_transformation_info): Simplify given that some info\n\twill be read.\n\t(read_replacements_section): Remove assert.\n\t* lto-cgraph.cc (add_node_to): Also set encode_body for clones.\n\t* lto-streamer-out.cc (lto_output): Do not output virtual clones.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7450b25566b7a738edff6f554d97ba6e3dd95ac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7450b25566b7a738edff6f554d97ba6e3dd95ac9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7450b25566b7a738edff6f554d97ba6e3dd95ac9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37c2d99f3f569350ebc0de43c10374b90086b832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c2d99f3f569350ebc0de43c10374b90086b832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37c2d99f3f569350ebc0de43c10374b90086b832"}], "stats": {"total": 148, "additions": 71, "deletions": 77}, "files": [{"sha": "fcadf64ead780e20586f6628b1099a49bd4c2f01", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 68, "deletions": 75, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=7450b25566b7a738edff6f554d97ba6e3dd95ac9", "patch": "@@ -5279,80 +5279,72 @@ ipa_prop_read_jump_functions (void)\n     }\n }\n \n-void\n-write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n+/* Return true if the IPA-CP transformation summary TS is non-NULL and contains\n+   useful info.  */\n+static bool\n+useful_ipcp_transformation_info_p (ipcp_transformation *ts)\n {\n-  int node_ref;\n-  unsigned int count = 0;\n-  lto_symtab_encoder_t encoder;\n+  if (!ts)\n+    return false;\n+  if (!vec_safe_is_empty (ts->m_agg_values)\n+      || !vec_safe_is_empty (ts->bits)\n+      || !vec_safe_is_empty (ts->m_vr))\n+    return true;\n+  return false;\n+}\n \n-  encoder = ob->decl_state->symtab_node_encoder;\n-  node_ref = lto_symtab_encoder_encode (encoder, node);\n+/* Write into OB IPA-CP transfromation summary TS describing NODE.  */\n+\n+void\n+write_ipcp_transformation_info (output_block *ob, cgraph_node *node,\n+\t\t\t\tipcp_transformation *ts)\n+{\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n+  int node_ref = lto_symtab_encoder_encode (encoder, node);\n   streamer_write_uhwi (ob, node_ref);\n \n-  ipcp_transformation *ts = ipcp_get_transformation_summary (node);\n-  if (ts && !vec_safe_is_empty (ts->m_agg_values))\n+  streamer_write_uhwi (ob, vec_safe_length (ts->m_agg_values));\n+  for (const ipa_argagg_value &av : ts->m_agg_values)\n     {\n-      streamer_write_uhwi (ob, ts->m_agg_values->length ());\n-      for (const ipa_argagg_value &av : ts->m_agg_values)\n-\t{\n-\t  struct bitpack_d bp;\n+      struct bitpack_d bp;\n \n-\t  stream_write_tree (ob, av.value, true);\n-\t  streamer_write_uhwi (ob, av.unit_offset);\n-\t  streamer_write_uhwi (ob, av.index);\n+      stream_write_tree (ob, av.value, true);\n+      streamer_write_uhwi (ob, av.unit_offset);\n+      streamer_write_uhwi (ob, av.index);\n \n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, av.by_ref, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t}\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, av.by_ref, 1);\n+      streamer_write_bitpack (&bp);\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n \n-  if (ts && vec_safe_length (ts->m_vr) > 0)\n+  streamer_write_uhwi (ob, vec_safe_length (ts->m_vr));\n+  for (const ipa_vr &parm_vr : ts->m_vr)\n     {\n-      count = ts->m_vr->length ();\n-      streamer_write_uhwi (ob, count);\n-      for (unsigned i = 0; i < count; ++i)\n+      struct bitpack_d bp;\n+      bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, parm_vr.known, 1);\n+      streamer_write_bitpack (&bp);\n+      if (parm_vr.known)\n \t{\n-\t  struct bitpack_d bp;\n-\t  ipa_vr *parm_vr = &(*ts->m_vr)[i];\n-\t  bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, parm_vr->known, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (parm_vr->known)\n-\t    {\n-\t      streamer_write_enum (ob->main_stream, value_rang_type,\n-\t\t\t\t   VR_LAST, parm_vr->type);\n-\t      streamer_write_wide_int (ob, parm_vr->min);\n-\t      streamer_write_wide_int (ob, parm_vr->max);\n-\t    }\n+\t  streamer_write_enum (ob->main_stream, value_rang_type,\n+\t\t\t       VR_LAST, parm_vr.type);\n+\t  streamer_write_wide_int (ob, parm_vr.min);\n+\t  streamer_write_wide_int (ob, parm_vr.max);\n \t}\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n \n-  if (ts && vec_safe_length (ts->bits) > 0)\n+  streamer_write_uhwi (ob, vec_safe_length (ts->bits));\n+  for (const ipa_bits *bits_jfunc : ts->bits)\n     {\n-      count = ts->bits->length ();\n-      streamer_write_uhwi (ob, count);\n-\n-      for (unsigned i = 0; i < count; ++i)\n+      struct bitpack_d bp = bitpack_create (ob->main_stream);\n+      bp_pack_value (&bp, !!bits_jfunc, 1);\n+      streamer_write_bitpack (&bp);\n+      if (bits_jfunc)\n \t{\n-\t  const ipa_bits *bits_jfunc = (*ts->bits)[i];\n-\t  struct bitpack_d bp = bitpack_create (ob->main_stream);\n-\t  bp_pack_value (&bp, !!bits_jfunc, 1);\n-\t  streamer_write_bitpack (&bp);\n-\t  if (bits_jfunc)\n-\t    {\n-\t      streamer_write_widest_int (ob, bits_jfunc->value);\n-\t      streamer_write_widest_int (ob, bits_jfunc->mask);\n-\t    }\n+\t  streamer_write_widest_int (ob, bits_jfunc->value);\n+\t  streamer_write_widest_int (ob, bits_jfunc->mask);\n \t}\n     }\n-  else\n-    streamer_write_uhwi (ob, 0);\n }\n \n /* Stream in the aggregate value replacement chain for NODE from IB.  */\n@@ -5362,12 +5354,12 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n \t\t\t       data_in *data_in)\n {\n   unsigned int count, i;\n+  ipcp_transformation_initialize ();\n+  ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n \n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->m_agg_values, count, true);\n       for (i = 0; i <count; i++)\n \t{\n@@ -5385,8 +5377,6 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->m_vr, count, true);\n       for (i = 0; i < count; i++)\n \t{\n@@ -5407,10 +5397,7 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n   count = streamer_read_uhwi (ib);\n   if (count > 0)\n     {\n-      ipcp_transformation_initialize ();\n-      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n       vec_safe_grow_cleared (ts->bits, count, true);\n-\n       for (i = 0; i < count; i++)\n \t{\n \t  struct bitpack_d bp = streamer_read_bitpack (ib);\n@@ -5432,31 +5419,38 @@ read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n void\n ipcp_write_transformation_summaries (void)\n {\n-  struct cgraph_node *node;\n   struct output_block *ob;\n   unsigned int count = 0;\n-  lto_symtab_encoder_iterator lsei;\n   lto_symtab_encoder_t encoder;\n \n   ob = create_output_block (LTO_section_ipcp_transform);\n   encoder = ob->decl_state->symtab_node_encoder;\n   ob->symbol = NULL;\n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n+\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ())\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+      if (!cnode)\n+\tcontinue;\n+      ipcp_transformation *ts = ipcp_get_transformation_summary (cnode);\n+      if (useful_ipcp_transformation_info_p (ts)\n+\t  && lto_symtab_encoder_encode_body_p (encoder, cnode))\n \tcount++;\n     }\n \n   streamer_write_uhwi (ob, count);\n \n-  for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n-       lsei_next_function_in_partition (&lsei))\n+  for (int i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ())\n-\twrite_ipcp_transformation_info (ob, node);\n+      symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n+      if (!cnode)\n+\tcontinue;\n+      ipcp_transformation *ts = ipcp_get_transformation_summary (cnode);\n+      if (useful_ipcp_transformation_info_p (ts)\n+\t  && lto_symtab_encoder_encode_body_p (encoder, cnode))\n+\twrite_ipcp_transformation_info (ob, cnode, ts);\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n   produce_asm (ob, NULL);\n@@ -5497,7 +5491,6 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n       encoder = file_data->symtab_node_encoder;\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n-      gcc_assert (node->definition);\n       read_ipcp_transformation_info (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,"}, {"sha": "11079b0f0f0b6ac54094612aea0e28778119e94b", "filename": "gcc/lto-cgraph.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Flto-cgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Flto-cgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.cc?ref=7450b25566b7a738edff6f554d97ba6e3dd95ac9", "patch": "@@ -797,7 +797,7 @@ add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n {\n   if (node->clone_of)\n     add_node_to (encoder, node->clone_of, include_body);\n-  else if (include_body)\n+  if (include_body)\n     lto_set_symtab_encoder_encode_body (encoder, node);\n   lto_symtab_encoder_encode (encoder, node);\n }"}, {"sha": "08f75b092041dab8a4aa8ced193c6c76e5e8c866", "filename": "gcc/lto-streamer-out.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Flto-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7450b25566b7a738edff6f554d97ba6e3dd95ac9/gcc%2Flto-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.cc?ref=7450b25566b7a738edff6f554d97ba6e3dd95ac9", "patch": "@@ -2752,7 +2752,8 @@ lto_output (void)\n \tcontinue;\n       if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t{\n-\t  if (lto_symtab_encoder_encode_body_p (encoder, node))\n+\t  if (lto_symtab_encoder_encode_body_p (encoder, node)\n+\t      && !node->clone_of)\n \t    symbols_to_copy.safe_push (node);\n \t}\n       else if (varpool_node *node = dyn_cast <varpool_node *> (snode))"}]}