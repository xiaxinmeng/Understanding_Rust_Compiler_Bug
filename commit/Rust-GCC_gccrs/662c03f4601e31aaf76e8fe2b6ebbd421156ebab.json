{"sha": "662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYyYzAzZjQ2MDFlMzFhYWY3NmU4ZmUyYjZlYmJkNDIxMTU2ZWJhYg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-05-04T10:08:09Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-05-04T10:08:09Z"}, "message": "mn10300.c: Include cfgloop.h.\n\n\t* config/mn10300/mn10300.c: Include cfgloop.h.\n\t(DUMP): New macro.\n\t(mn10300_insert_setlb_lcc): New function.  Inserts a SETLB and a\n\tLcc or a FLcc insn into the instruction stream.\n\t(mn10300_block_contains_call): New function.  Returns true if the\n\tgiven basic block contains a CALL insn.\n\t(mn10300_loop_contains_call_insn): New function.  Returns true if\n\tthe given loop contains a CALL insn.\n\t(mn10300_scan_for_setlb_lcc): New function.  Finds opportunities\n\tto use the SETLB and Lcc or FLcc insns.\n\t(mn10300_reorg): Invoke mn10300_scan_for_setlb_lcc when optimizing.\n\t(TARGET_FLAGS): Add MASK_ALLOW_SETLB.\n\t* config/mn10300/mn10300.opt (msetlb): New option.  Used to\n\tdisable the SETLB optimization.\n\t* config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Add\n\t__SETLB__ or __NO_SETLB__.\n\t* config/mn10300/mn10300.md (UNSPEC_SETLB): New constant.\n\t(movsf_internal): Handle MDR register.\n\t(cmpsi): Make visible.\n\t(setlb): New pattern.\n\t(Lcc): New pattern.\n\t(FLcc): New pattern.\n\nFrom-SVN: r173362", "tree": {"sha": "41bfd3b991272c5c78b2f4b0ce1140c65e909919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41bfd3b991272c5c78b2f4b0ce1140c65e909919"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "843b691524dbbb03fdcc541d2cfadb9f5ed84342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/843b691524dbbb03fdcc541d2cfadb9f5ed84342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/843b691524dbbb03fdcc541d2cfadb9f5ed84342"}], "stats": {"total": 261, "additions": 256, "deletions": 5}, "files": [{"sha": "6f30c3113acf706471fb0188049b983463a1e79f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "patch": "@@ -1,3 +1,28 @@\n+2011-05-04  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.c: Include cfgloop.h.\n+\t(DUMP): New macro.\n+\t(mn10300_insert_setlb_lcc): New function.  Inserts a SETLB and a\n+\tLcc or a FLcc insn into the instruction stream.\n+\t(mn10300_block_contains_call): New function.  Returns true if the\n+\tgiven basic block contains a CALL insn.\n+\t(mn10300_loop_contains_call_insn): New function.  Returns true if\n+\tthe given loop contains a CALL insn.\n+\t(mn10300_scan_for_setlb_lcc): New function.  Finds opportunities\n+\tto use the SETLB and Lcc or FLcc insns.\n+\t(mn10300_reorg): Invoke mn10300_scan_for_setlb_lcc when optimizing.\n+\t(TARGET_FLAGS): Add MASK_ALLOW_SETLB.\n+\t* config/mn10300/mn10300.opt (msetlb): New option.  Used to\n+\tdisable the SETLB optimization.\n+\t* config/mn10300/mn10300.h (TARGET_CPU_CPP_BUILTINS): Add\n+\t__SETLB__ or __NO_SETLB__.\n+\t* config/mn10300/mn10300.md (UNSPEC_SETLB): New constant.\n+\t(movsf_internal): Handle MDR register.\n+\t(cmpsi): Make visible.\n+\t(setlb): New pattern.\n+\t(Lcc): New pattern.\n+\t(FLcc): New pattern.\n+\n 2011-05-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/48860"}, {"sha": "53714673ac8faa60f42312bcaf5f1eb8c3cfb164", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 180, "deletions": 2, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "patch": "@@ -45,6 +45,7 @@\n #include \"target-def.h\"\n #include \"df.h\"\n #include \"opts.h\"\n+#include \"cfgloop.h\"\n \n /* This is used in the am33_2.0-linux-gnu port, in which global symbol\n    names are not prefixed by underscores, to tell whether to prefix a\n@@ -3129,11 +3130,188 @@ mn10300_bundle_liw (void)\n     }\n }\n \n+#define DUMP(reason, insn)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (dump_file)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  fprintf (dump_file, reason \"\\n\");\t\\\n+\t  if (insn != NULL_RTX)\t\t\t\\\n+\t    print_rtl_single (dump_file, insn);\t\\\n+\t  fprintf(dump_file, \"\\n\");\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Replace the BRANCH insn with a Lcc insn that goes to LABEL.\n+   Insert a SETLB insn just before LABEL.  */\n+\n+static void\n+mn10300_insert_setlb_lcc (rtx label, rtx branch)\n+{\n+  rtx lcc, comparison, cmp_reg;\n+\n+  if (LABEL_NUSES (label) > 1)\n+    {\n+      rtx insn;\n+\n+      /* This label is used both as an entry point to the loop\n+\t and as a loop-back point for the loop.  We need to separate\n+\t these two functions so that the SETLB happens upon entry,\n+\t but the loop-back does not go to the SETLB instruction.  */\n+      DUMP (\"Inserting SETLB insn after:\", label);\n+      insn = emit_insn_after (gen_setlb (), label);\n+      label = gen_label_rtx ();\n+      emit_label_after (label, insn);\n+      DUMP (\"Created new loop-back label:\", label);\n+    }\n+  else\n+    {\n+      DUMP (\"Inserting SETLB insn before:\", label);\n+      emit_insn_before (gen_setlb (), label);\n+    }\n+\n+  comparison = XEXP (SET_SRC (PATTERN (branch)), 0);\n+  cmp_reg = XEXP (comparison, 0);\n+  gcc_assert (REG_P (cmp_reg));\n+\n+  /* If the comparison has not already been split out of the branch\n+     then do so now.  */\n+  gcc_assert (REGNO (cmp_reg) == CC_REG);\n+\n+  if (GET_MODE (cmp_reg) == CC_FLOATmode)\n+    lcc = gen_FLcc (comparison, label);\n+  else\n+    lcc = gen_Lcc (comparison, label);    \n+\n+  lcc = emit_jump_insn_before (lcc, branch);\n+  mark_jump_label (XVECEXP (PATTERN (lcc), 0, 0), lcc, 0);\n+  DUMP (\"Replacing branch insn...\", branch);\n+  DUMP (\"... with Lcc insn:\", lcc);  \n+  delete_insn (branch);\n+}\n+\n+static bool\n+mn10300_block_contains_call (struct basic_block_def * block)\n+{\n+  rtx insn;\n+\n+  FOR_BB_INSNS (block, insn)\n+    if (CALL_P (insn))\n+      return true;\n+\n+  return false;\n+}\n+\n+static bool\n+mn10300_loop_contains_call_insn (loop_p loop)\n+{\n+  basic_block * bbs;\n+  bool result = false;\n+  unsigned int i;\n+\n+  bbs = get_loop_body (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    if (mn10300_block_contains_call (bbs[i]))\n+      {\n+\tresult = true;\n+\tbreak;\n+      }\n+\n+  free (bbs);\n+  return result;\n+}\n+\n+static void\n+mn10300_scan_for_setlb_lcc (void)\n+{\n+  struct loops loops;\n+  loop_iterator liter;\n+  loop_p loop;\n+\n+  DUMP (\"Looking for loops that can use the SETLB insn\", NULL_RTX);\n+\n+  df_analyze ();\n+  compute_bb_for_insn ();\n+\n+  /* Find the loops.  */\n+  if (flow_loops_find (& loops) < 1)\n+    DUMP (\"No loops found\", NULL_RTX);\n+  current_loops = & loops;\n+\n+  /* FIXME: For now we only investigate innermost loops.  In practice however\n+     if an inner loop is not suitable for use with the SETLB/Lcc insns, it may\n+     be the case that its parent loop is suitable.  Thus we should check all\n+     loops, but work from the innermost outwards.  */\n+  FOR_EACH_LOOP (liter, loop, LI_ONLY_INNERMOST)\n+    {\n+      const char * reason = NULL;\n+\n+      /* Check to see if we can modify this loop.  If we cannot\n+\t then set 'reason' to describe why it could not be done.  */\n+      if (loop->latch == NULL)\n+\treason = \"it contains multiple latches\";\n+      else if (loop->header != loop->latch)\n+\t/* FIXME: We could handle loops that span multiple blocks,\n+\t   but this requires a lot more work tracking down the branches\n+\t   that need altering, so for now keep things simple.  */\n+\treason = \"the loop spans multiple blocks\";\n+      else if (mn10300_loop_contains_call_insn (loop))\n+\treason = \"it contains CALL insns\";\n+      else\n+\t{\n+\t  rtx branch = BB_END (loop->latch);\n+\n+\t  gcc_assert (JUMP_P (branch));\n+\t  if (single_set (branch) == NULL_RTX || ! any_condjump_p (branch))\n+\t    /* We cannot optimize tablejumps and the like.  */\n+\t    /* FIXME: We could handle unconditional jumps.  */\n+\t    reason = \"it is not a simple loop\";\n+\t  else\n+\t    {\n+\t      rtx label;\n+\n+\t      if (dump_file)\n+\t\tflow_loop_dump (loop, dump_file, NULL, 0);\n+\n+\t      label = BB_HEAD (loop->header);\n+\t      gcc_assert (LABEL_P (label));\n+\n+\t      mn10300_insert_setlb_lcc (label, branch);\n+\t    }\n+\t}\n+\n+      if (dump_file && reason != NULL)\n+\tfprintf (dump_file, \"Loop starting with insn %d is not suitable because %s\\n\",\n+\t\t INSN_UID (BB_HEAD (loop->header)),\n+\t\t reason);\n+    }\n+\n+#if 0 /* FIXME: We should free the storage we allocated, but\n+\t for some unknown reason this leads to seg-faults.  */\n+  FOR_EACH_LOOP (liter, loop, 0)\n+    free_simple_loop_desc (loop);\n+\n+  flow_loops_free (current_loops);\n+#endif\n+\n+  current_loops = NULL;\n+\n+  df_finish_pass (false);  \n+\n+  DUMP (\"SETLB scan complete\", NULL_RTX);\n+}\n+\n static void\n mn10300_reorg (void)\n {\n-  if (TARGET_AM33)\n+  /* These are optimizations, so only run them if optimizing.  */\n+  if (TARGET_AM33 && (optimize > 0 || optimize_size))\n     {\n+      if (TARGET_ALLOW_SETLB)\n+\tmn10300_scan_for_setlb_lcc ();\n+\n       if (TARGET_ALLOW_LIW)\n \tmn10300_bundle_liw ();\n     }\n@@ -3171,7 +3349,7 @@ mn10300_reorg (void)\n #define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA mn10300_asm_output_addr_const_extra\n \n #undef  TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0 | MASK_ALLOW_LIW\n+#define TARGET_DEFAULT_TARGET_FLAGS MASK_MULT_BUG | MASK_PTR_A0D0 | MASK_ALLOW_LIW | MASK_ALLOW_SETLB\n #undef  TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION mn10300_handle_option\n #undef  TARGET_OPTION_OVERRIDE"}, {"sha": "a15615653b5cc59c3e503091b3e88b79d6fbfcad", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "patch": "@@ -54,6 +54,8 @@\n       builtin_define (TARGET_ALLOW_LIW ?\t\\\n \t\t      \"__LIW__\" : \"__NO_LIW__\");\\\n \t\t\t\t\t\t\\\n+      builtin_define (TARGET_ALLOW_SETLB  ?\t\\\n+\t\t      \"__SETLB__\" : \"__NO_SETLB__\");\\\n     }\t\t\t\t\t\t\\\n   while (0)\n "}, {"sha": "81e4a4153d8009d037e9e778cf36fbf37f0660dc", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "patch": "@@ -42,6 +42,8 @@\n \n   ;; This is used to encode LIW patterns.\n   (UNSPEC_LIW\t\t8)\n+  ;; This is for the low overhead loop instructions.\n+  (UNSPEC_SETLB         9)\n ])\n \n (include \"predicates.md\")\n@@ -501,8 +503,8 @@\n })\n \n (define_insn \"*movsf_internal\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rf,r,f,r,f,r,f,r,m,f,Q\")\n-\t(match_operand:SF 1 \"general_operand\"\t   \"  0,F,F,r,f,f,r,m,r,Q,f\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rf,r,f,r,f,r,f,r,m,f,Q,z,d\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \"  0,F,F,r,f,f,r,m,r,Q,f,d,z\"))]\n   \"TARGET_AM33_2\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n@@ -515,6 +517,8 @@\n     case 3:\n     case 7:\n     case 8:\n+    case 11:\n+    case 12:\n       return \"mov %1,%0\";\n     case 2:\n     case 4:\n@@ -547,6 +551,8 @@\n \t\t\t\t(const_int 13) (const_int 24))\n \t\t  (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t(const_int 13) (const_int 24))\n+\t\t  (const_int 22)\n+\t\t  (const_int 22)\n \t\t ])]\n )\n \n@@ -1385,7 +1391,7 @@\n   DONE;\n })\n \n-(define_insn \"*cmpsi\"\n+(define_insn \"cmpsi\"\n   [(set (reg CC_REG)\n \t(compare (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n \t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,O,i\")))]\n@@ -2162,3 +2168,39 @@\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n \t\t\t\t       (const_int 13) (const_int 12)))]\n )\n+\n+;; Note - in theory the doloop patterns could be used here to express\n+;; the SETLB and Lcc instructions.  In practice this does not work because\n+;; the acceptable forms of the doloop patterns do not include UNSPECs\n+;; and without them gcc's basic block reordering code can duplicate the\n+;; doloop_end pattern, leading to bogus multiple decrements of the loop\n+;; counter. \n+\n+(define_insn \"setlb\"\n+  [(unspec [(const_int 0)] UNSPEC_SETLB)]\n+  \"TARGET_AM33 && TARGET_ALLOW_SETLB\"\n+  \"setlb\"\n+)\n+\n+(define_insn \"Lcc\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t      [(reg:CC CC_REG) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (unspec [(const_int 1)] UNSPEC_SETLB)]\n+  \"TARGET_AM33 && TARGET_ALLOW_SETLB\"\n+  \"L%b0 # loop back to: %1\"\n+)\n+\n+(define_insn \"FLcc\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t      [(reg:CC_FLOAT CC_REG) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (unspec [(const_int 2)] UNSPEC_SETLB)]\n+  \"TARGET_AM33_2 && TARGET_ALLOW_SETLB\"\n+  \"FL%b0 # loop back to: %1\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 44) (const_int 11)))]\n+)"}, {"sha": "ba67582f4f299555df2e70983b5987715619c811", "filename": "gcc/config/mn10300/mn10300.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/662c03f4601e31aaf76e8fe2b6ebbd421156ebab/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.opt?ref=662c03f4601e31aaf76e8fe2b6ebbd421156ebab", "patch": "@@ -61,3 +61,7 @@ Return pointers in both a0 and d0\n mliw\n Target Report Mask(ALLOW_LIW)\n Allow gcc to generate LIW instructions\n+\n+msetlb\n+Target Report Mask(ALLOW_SETLB)\n+Allow gcc to generate the SETLB and Lcc instructions"}]}