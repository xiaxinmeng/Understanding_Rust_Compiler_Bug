{"sha": "5b1a76105bb377230a838ddeb0c94d384b33e97b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIxYTc2MTA1YmIzNzcyMzBhODM4ZGRlYjBjOTRkMzg0YjMzZTk3Yg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-01-23T20:38:59Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-01-23T20:38:59Z"}, "message": "locale_facets.h (num_get::_M_extract_int): Change prototype.\n\n\n2002-01-23  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/locale_facets.h (num_get::_M_extract_int): Change\n\tprototype.\n\t* include/bits/locale_facets.tcc (num_get::_M_extract_int): Remove\n\t__max_digits checks, adjust arguments.\n\t(num_get::do_get(*)): Changeup.\n\nFrom-SVN: r49154", "tree": {"sha": "32e4a8cd167eee5531574ad1aac0f854ca3f390f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e4a8cd167eee5531574ad1aac0f854ca3f390f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b1a76105bb377230a838ddeb0c94d384b33e97b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1a76105bb377230a838ddeb0c94d384b33e97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b1a76105bb377230a838ddeb0c94d384b33e97b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1a76105bb377230a838ddeb0c94d384b33e97b/comments", "author": null, "committer": null, "parents": [{"sha": "033509daea7672c110fbe3ad80b445623deb0848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/033509daea7672c110fbe3ad80b445623deb0848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/033509daea7672c110fbe3ad80b445623deb0848"}], "stats": {"total": 146, "additions": 57, "deletions": 89}, "files": [{"sha": "1399d3f817789dd83e5b61048ef611445dfc5e6d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5b1a76105bb377230a838ddeb0c94d384b33e97b", "patch": "@@ -1,3 +1,11 @@\n+2002-01-23  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/locale_facets.h (num_get::_M_extract_int): Change\n+\tprototype.\n+\t* include/bits/locale_facets.tcc (num_get::_M_extract_int): Remove\n+\t__max_digits checks, adjust arguments.\n+\t(num_get::do_get(*)): Changeup.\n+\n 2002-01-23  Loren Rittle <ljrittle@acm.org>\n \n         * config/locale/c_locale_generic.cc: Fix typename usage."}, {"sha": "052b1bd1f21980a3c23123c871205fc78aab85bf", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=5b1a76105bb377230a838ddeb0c94d384b33e97b", "patch": "@@ -648,7 +648,7 @@ namespace std\n \n       iter_type \n       _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n-\t\t     char* __xtrc, int __max, int& __base) const;\n+\t\t     string& __xtrc, int& __base) const;\n \n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;"}, {"sha": "b466a7d8b8d3c67c38c1f7d1114e7f8b71d10c50", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 48, "deletions": 88, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b1a76105bb377230a838ddeb0c94d384b33e97b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=5b1a76105bb377230a838ddeb0c94d384b33e97b", "patch": "@@ -28,7 +28,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-// Warning: this file is not meant for user inclusion.  Use <locale>.\n+// Warning: this file is not meant for user inclusion. Use <locale>.\n \n #ifndef _CPP_BITS_LOCFACETS_TCC\n #define _CPP_BITS_LOCFACETS_TCC 1\n@@ -223,8 +223,7 @@ namespace std\n     _InIter\n     num_get<_CharT, _InIter>::\n     _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n-\t\t   ios_base::iostate& __err, char* __xtrc, int __max, \n-\t\t   int& __base) const\n+\t\t   ios_base::iostate& __err, string& __xtrc, int& __base) const\n     {\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n@@ -239,13 +238,14 @@ namespace std\n       else\n \t__base = 10;\n \n-     // Check first for sign.\n+     // First check for sign.\n       int __pos = 0;\n       char_type  __c = *__beg;\n       if ((__c == __ctype.widen('+') || __c == __ctype.widen('-'))\n \t  && __beg != __end)\n \t{\n-\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t  __xtrc += __ctype.narrow(__c, char());\n+\t  ++__pos;\n \t  __c = *(++__beg);\n \t}\n \n@@ -263,12 +263,14 @@ namespace std\n \t    }\n \t  if (__found_zero)\n \t    {\n-\t      __xtrc[__pos++] = _S_atoms[_M_zero];\n+\t      __xtrc += _S_atoms[_M_zero];\n+\t      ++__pos;\n \t      if (__basefield == 0)\n \t\t{\t      \n \t\t  if ((__c == __x || __c == __X) && __beg != __end)\n \t\t    {\n-\t\t      __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t      __xtrc += __ctype.narrow(__c, char());\n+\t\t      ++__pos;\n \t\t      __c = *(++__beg);\n \t\t      __base = 16;\n \t\t    }\n@@ -281,11 +283,13 @@ namespace std\n \t{\n \t  if (__c == __zero && __beg != __end)\n \t    {\n-\t      __xtrc[__pos++] = _S_atoms[_M_zero];\n+\t      __xtrc += _S_atoms[_M_zero];\n+\t      ++__pos;\n \t      __c = *(++__beg); \n \t      if  ((__c == __x || __c == __X) && __beg != __end)\n \t\t{\n-\t\t  __xtrc[__pos++] = __ctype.narrow(__c, char());\n+\t\t  __xtrc += __ctype.narrow(__c, char());\n+\t\t  ++__pos;\n \t\t  __c = *(++__beg);\n \t\t}\n \t    }\n@@ -299,19 +303,6 @@ namespace std\n       else\n \t__len = __base;\n \n-      // Figure out the maximum number of digits that can be extracted\n-      // for the given type, using the determined base.\n-      int __max_digits;\n-      if (__base == 16)\n-\t__max_digits = static_cast<int>(ceil(__max * _S_scale_hex));\n-      else if (__base == 8)\n-\t__max_digits = static_cast<int>(ceil(__max * _S_scale_oct));\n-      else\n-\t__max_digits = __max;\n-\n-      // Add in what's already been extracted.\n-      __max_digits += __pos;\n-\n       // Extract.\n       char_type __watoms[_M_size];\n       __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);\n@@ -320,7 +311,7 @@ namespace std\n       bool __check_grouping = __grouping.size() && __base == 10;\n       int __sep_pos = 0;\n       const char_type __sep = __np.thousands_sep();\n-      while (__beg != __end && __pos <= __max_digits)\n+      while (__beg != __end)\n         {\n \t  typedef char_traits<_CharT> \t__traits_type;\n           const char_type* __p = __traits_type::find(__watoms, __len,  __c);\n@@ -329,7 +320,8 @@ namespace std\n           if (__p && __c)\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n-\t      __xtrc[__pos++] = _S_atoms[__p - __watoms];\n+\t      __xtrc += _S_atoms[__p - __watoms];\n+\t      ++__pos;\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n@@ -354,10 +346,6 @@ namespace std\n \t    break;\n         }\n \n-      // If one more than the maximum number of digits is extracted.\n-      if (__pos > __max_digits)\n-\t__err |= ios_base::failbit;\n-\n       // Digit grouping is checked. If grouping and found_grouping don't\n       // match, then get very very upset, and set failbit.\n       if (__check_grouping && __found_grouping.size())\n@@ -368,8 +356,8 @@ namespace std\n \t    __err |= ios_base::failbit;\n         }\n \n-      // Finish up\n-      __xtrc[__pos] = char();\n+      // Finish up.\n+      __xtrc += char();\n       if (__beg == __end)\n         __err |= ios_base::eofbit;\n       return __beg;\n@@ -388,20 +376,16 @@ namespace std\n         {\n           // NB: We can't just call do_get(long) here, as it might\n           // refer to a derived class.\n-\n-          // Assuming leading zeros eliminated, thus the size of 32 for\n-          // integral types\n-          char __xtrc[32];\n+          string __xtrc;\n           int __base;\n \t  // According to 18.2.1.2.9, digits10 is \"Number of base 10 digits\n \t  // that can be represented without change\" so we have to add 1 to it\n \t  // in order to obtain the max number of digits. The same for the\n \t  // other do_get for integral types below.\n-          __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t\t numeric_limits<bool>::digits10 + 1, __base);\n+          __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n \t  unsigned long __ul; \n-\t  __convert_to_v(__xtrc, __ul, __err, _S_c_locale, __base);\n+\t  __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);\n \t  if (!(__err & ios_base::failbit) && __ul <= 1)\n \t    __v = __ul;\n \t  else \n@@ -453,13 +437,10 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, long& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<long>::digits10 + 1, __base);\n-      __convert_to_v(__xtrc, __v, __err, _S_c_locale, __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);\n       return __beg;\n     }\n \n@@ -469,16 +450,13 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, unsigned short& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<unsigned short>::digits10 + 1,\n-\t\t\t     __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n       unsigned long __ul;\n-      __convert_to_v(__xtrc, __ul, __err, _S_c_locale, __base);\n-      if (!(__err & ios_base::failbit) && __ul <= USHRT_MAX)\n+      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);\n+      if (!(__err & ios_base::failbit) \n+\t  && __ul <= numeric_limits<unsigned short>::max())\n \t__v = static_cast<unsigned short>(__ul);\n       else \n \t__err |= ios_base::failbit;\n@@ -491,16 +469,13 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, unsigned int& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<unsigned int>::digits10 + 1,\n-\t\t\t     __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n       unsigned long __ul;\n-      __convert_to_v(__xtrc, __ul, __err, _S_c_locale, __base);\n-      if (!(__err & ios_base::failbit) && __ul <= UINT_MAX)\n+      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);\n+      if (!(__err & ios_base::failbit) \n+\t  && __ul <= numeric_limits<unsigned int>::max())\n \t__v = static_cast<unsigned int>(__ul);\n       else \n \t__err |= ios_base::failbit;\n@@ -513,14 +488,10 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, unsigned long& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<unsigned long>::digits10 + 1,\n-\t\t\t     __base);\n-      __convert_to_v(__xtrc, __v, __err, _S_c_locale, __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);\n       return __beg;\n     }\n \n@@ -531,13 +502,10 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, long long& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<long long>::digits10 + 1, __base);\n-      __convert_to_v(__xtrc, __v, __err, _S_c_locale, __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);\n       return __beg;\n     }\n \n@@ -547,14 +515,10 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, unsigned long long& __v) const\n     {\n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc,\n-\t\t\t     numeric_limits<unsigned long long>::digits10 + 1,\n-\t\t\t     __base);\n-      __convert_to_v(__xtrc, __v, __err, _S_c_locale, __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n+      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);\n       return __beg;\n     }\n #endif\n@@ -611,19 +575,15 @@ namespace std\n                              | ios_base::uppercase | ios_base::internal);\n       __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n \n-      // Assuming leading zeros eliminated, thus the size of 32 for\n-      // integral types.\n-      char __xtrc[32];\n+      string __xtrc;\n       int __base;\n-      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, \n-\t\t\t     numeric_limits<unsigned long>::digits10 + 1,\n-\t\t\t     __base);\n+      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n       // Reset from hex formatted input\n       __io.flags(__fmt);\n \n       unsigned long __ul;\n-      __convert_to_v(__xtrc, __ul, __err, _S_c_locale, __base);\n+      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);\n       if (!(__err & ios_base::failbit))\n \t__v = reinterpret_cast<void*>(__ul);\n       else \n@@ -1892,13 +1852,13 @@ namespace std\n   // Convert string to numeric value of type T and store results.  \n   // NB: This is specialized for all required types, there is no\n   // generic definition.\n-  template <typename _T>\n+  template<typename _T>\n     void\n     __convert_to_v(const char* __in, _T& __out, ios_base::iostate& __err, \n \t\t   const __c_locale& __cloc, int __base = 10);\n \n   // Convert numeric value of type T to string and return length of string.\n-  template <typename _T>\n+  template<typename _T>\n     int\n     __convert_from_v(char* __out, const char* __fmt, _T __v, \n \t\t     const __c_locale&, int __prec = -1)"}]}