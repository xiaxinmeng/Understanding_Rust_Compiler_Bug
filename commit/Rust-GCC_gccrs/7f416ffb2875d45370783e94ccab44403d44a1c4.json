{"sha": "7f416ffb2875d45370783e94ccab44403d44a1c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0MTZmZmIyODc1ZDQ1MzcwNzgzZTk0Y2NhYjQ0NDAzZDQ0YTFjNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-12-07T13:31:41Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-12-07T13:31:41Z"}, "message": "Preparation for PR rtl-optimization/20070 / part1\n\n2005-12-07  J\"orn Rennecke <joern.rennecke@st.com>\n\n\tPreparation for PR rtl-optimization/20070 / part1\n\t* basic-block.h (insns_match_p, flow_find_cross_jump): Declare.\n\t* cfgcleanup.c (condjump_equiv_p): New function, broken out of\n\toutgoing_edges_match.\n\t(outgoing_edges_match): Use condjump_equiv_p.\n\t(merge_memattrs, insns_match_p, flow_find_cross_jump): Move from here\n\tinto..\n\t* struct-equiv.c: New file.\n\t(death_notes_match_p) New function, broken out of insns_match_p.\n\t* Makefile.in (OBJS-common): Add struct-equiv.o.\n\t(struct-equiv.o): New target.\n\nFrom-SVN: r108164", "tree": {"sha": "80bd82f1f8f7ac2b40e3ef750c31f109ba0b3cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80bd82f1f8f7ac2b40e3ef750c31f109ba0b3cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f416ffb2875d45370783e94ccab44403d44a1c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f416ffb2875d45370783e94ccab44403d44a1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f416ffb2875d45370783e94ccab44403d44a1c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f416ffb2875d45370783e94ccab44403d44a1c4/comments", "author": null, "committer": null, "parents": [{"sha": "0e230dfa1d6ff966fcaa34648d00e2274de480ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e230dfa1d6ff966fcaa34648d00e2274de480ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e230dfa1d6ff966fcaa34648d00e2274de480ee"}], "stats": {"total": 872, "additions": 473, "deletions": 399}, "files": [{"sha": "0999e219aaa0ab59b83e77549ebea929209a7ab6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f416ffb2875d45370783e94ccab44403d44a1c4", "patch": "@@ -1,3 +1,17 @@\n+2005-12-07  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPreparation for PR rtl-optimization/20070 / part1\n+\t* basic-block.h (insns_match_p, flow_find_cross_jump): Declare.\n+\t* cfgcleanup.c (condjump_equiv_p): New function, broken out of\n+\toutgoing_edges_match.\n+\t(outgoing_edges_match): Use condjump_equiv_p.\n+\t(merge_memattrs, insns_match_p, flow_find_cross_jump): Move from here\n+\tinto..\n+\t* struct-equiv.c: New file.\n+\t(death_notes_match_p) New function, broken out of insns_match_p.\n+\t* Makefile.in (OBJS-common): Add struct-equiv.o.\n+\t(struct-equiv.o): New target.\n+\n 2005-12-07  Richard Sandiford  <richard@codesourcery.com>\n \n \t* coretypes.h: Revert previous change."}, {"sha": "1b76e921b4a98d14d49963d488f51b419b45b18d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7f416ffb2875d45370783e94ccab44403d44a1c4", "patch": "@@ -985,7 +985,7 @@ OBJS-common = \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n  simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o\t\t   \\\n- targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o\t\t   \\\n+ struct-equiv.o targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o    \t\t\t   \\\n@@ -2361,6 +2361,10 @@ cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) \\\n    $(OBSTACK_H) output.h\n+struct-equiv.o : struct-equiv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(RTL_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n+   insn-config.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n+   $(REGS_H) $(EMIT_RTL_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    output.h intl.h"}, {"sha": "9a88e8d3c0cde52847e55cb643acdb772cca7f6d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7f416ffb2875d45370783e94ccab44403d44a1c4", "patch": "@@ -991,4 +991,8 @@ extern basic_block get_bb_copy (basic_block);\n \n #include \"cfghooks.h\"\n \n+/* In struct-equiv.c */\n+extern bool insns_match_p (int, rtx, rtx);\n+extern int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "c8824ffb3288fcff03981a307ba172b7a9607444", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 88, "deletions": 398, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=7f416ffb2875d45370783e94ccab44403d44a1c4", "patch": "@@ -61,8 +61,6 @@ static bool first_pass;\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n-static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n-static bool insns_match_p (int, rtx, rtx);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -74,7 +72,6 @@ static bool mark_effect (rtx, bitmap);\n static void notice_new_block (basic_block);\n static void update_forwarder_flag (basic_block);\n static int mentions_nonequal_regs (rtx *, void *);\n-static void merge_memattrs (rtx, rtx);\n \f\n /* Set flags for newly created block.  */\n \n@@ -881,319 +878,109 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n   return NULL;\n }\n \f\n-\n-/* Removes the memory attributes of MEM expression\n-   if they are not equal.  */\n-\n-void\n-merge_memattrs (rtx x, rtx y)\n-{\n-  int i;\n-  int j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  if (x == y)\n-    return;\n-  if (x == 0 || y == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-\n-  if (code != GET_CODE (y))\n-    return;\n-\n-  if (GET_MODE (x) != GET_MODE (y))\n-    return;\n-\n-  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))\n-    {\n-      if (! MEM_ATTRS (x))\n-\tMEM_ATTRS (y) = 0;\n-      else if (! MEM_ATTRS (y))\n-\tMEM_ATTRS (x) = 0;\n-      else \n-\t{\n-\t  rtx mem_size;\n-\n-\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n-\t    {\n-\t      set_mem_alias_set (x, 0);\n-\t      set_mem_alias_set (y, 0);\n-\t    }\n-\t  \n-\t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n-\t    {\n-\t      set_mem_expr (x, 0);\n-\t      set_mem_expr (y, 0);\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n-\t    }\n-\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n-\t    {\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n-\t    }\n-\t \n-\t  if (!MEM_SIZE (x))\n-\t    mem_size = NULL_RTX;\n-\t  else if (!MEM_SIZE (y))\n-\t    mem_size = NULL_RTX;\n-\t  else\n-\t    mem_size = GEN_INT (MAX (INTVAL (MEM_SIZE (x)),\n-\t\t\t\t     INTVAL (MEM_SIZE (y))));\n-\t  set_mem_size (x, mem_size);\n-\t  set_mem_size (y, mem_size);\n-\n-\t  set_mem_align (x, MIN (MEM_ALIGN (x), MEM_ALIGN (y)));\n-\t  set_mem_align (y, MEM_ALIGN (x));\n-\t}\n-    }\n-  \n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return;\n-\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    merge_memattrs (XVECEXP (x, i, j), XVECEXP (y, i, j));\n-\n-\t  break;\n-\n-\tcase 'e':\n-\t  merge_memattrs (XEXP (x, i), XEXP (y, i));\n-\t}\n-    }\n-  return;\n-}\n-\n-\n-/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n-\n+/* Return true iff the condbranches at the end of BB1 and BB2 match.  */\n static bool\n-insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n+condjump_equiv_p (basic_block bb1, basic_block bb2)\n {\n-  rtx p1, p2;\n-\n-  /* Verify that I1 and I2 are equivalent.  */\n-  if (GET_CODE (i1) != GET_CODE (i2))\n+  edge b1, f1, b2, f2;\n+  bool reverse, match;\n+  rtx set1, set2, cond1, cond2;\n+  enum rtx_code code1, code2;\n+\n+\n+  b1 = BRANCH_EDGE (bb1);\n+  b2 = BRANCH_EDGE (bb2);\n+  f1 = FALLTHRU_EDGE (bb1);\n+  f2 = FALLTHRU_EDGE (bb2);\n+\n+  /* Get around possible forwarders on fallthru edges.  Other cases\n+     should be optimized out already.  */\n+  if (FORWARDER_BLOCK_P (f1->dest))\n+    f1 = single_succ_edge (f1->dest);\n+\n+  if (FORWARDER_BLOCK_P (f2->dest))\n+    f2 = single_succ_edge (f2->dest);\n+\n+  /* To simplify use of this function, return false if there are\n+     unneeded forwarder blocks.  These will get eliminated later\n+     during cleanup_cfg.  */\n+  if (FORWARDER_BLOCK_P (f1->dest)\n+      || FORWARDER_BLOCK_P (f2->dest)\n+      || FORWARDER_BLOCK_P (b1->dest)\n+      || FORWARDER_BLOCK_P (b2->dest))\n     return false;\n \n-  p1 = PATTERN (i1);\n-  p2 = PATTERN (i2);\n-\n-  if (GET_CODE (p1) != GET_CODE (p2))\n+  if (f1->dest == f2->dest && b1->dest == b2->dest)\n+    reverse = false;\n+  else if (f1->dest == b2->dest && b1->dest == f2->dest)\n+    reverse = true;\n+  else\n     return false;\n \n-  /* If this is a CALL_INSN, compare register usage information.\n-     If we don't check this on stack register machines, the two\n-     CALL_INSNs might be merged leaving reg-stack.c with mismatching\n-     numbers of stack registers in the same basic block.\n-     If we don't check this on machines with delay slots, a delay slot may\n-     be filled that clobbers a parameter expected by the subroutine.\n+  set1 = pc_set (BB_END (bb1));\n+  set2 = pc_set (BB_END (bb2));\n+  if ((XEXP (SET_SRC (set1), 1) == pc_rtx)\n+      != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n+    reverse = !reverse;\n \n-     ??? We take the simple route for now and assume that if they're\n-     equal, they were constructed identically.  */\n+  cond1 = XEXP (SET_SRC (set1), 0);\n+  cond2 = XEXP (SET_SRC (set2), 0);\n+  code1 = GET_CODE (cond1);\n+  if (reverse)\n+    code2 = reversed_comparison_code (cond2, BB_END (bb2));\n+  else\n+    code2 = GET_CODE (cond2);\n \n-  if (CALL_P (i1)\n-      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t        CALL_INSN_FUNCTION_USAGE (i2))\n-\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n+  if (code2 == UNKNOWN)\n     return false;\n \n-#ifdef STACK_REGS\n-  /* If cross_jump_death_matters is not 0, the insn's mode\n-     indicates whether or not the insn contains any stack-like\n-     regs.  */\n-\n-  if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n+  /* Verify codes and operands match.  */\n+  match = ((code1 == code2\n+            && rtx_renumbered_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n+            && rtx_renumbered_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n+           || (code1 == swap_condition (code2)\n+               && rtx_renumbered_equal_p (XEXP (cond1, 1),\n+                                          XEXP (cond2, 0))\n+               && rtx_renumbered_equal_p (XEXP (cond1, 0),\n+                                          XEXP (cond2, 1))));\n+\n+  /* If we return true, we will join the blocks.  Which means that\n+     we will only have one branch prediction bit to work with.  Thus\n+     we require the existing branches to have probabilities that are\n+     roughly similar.  */\n+  if (match\n+      && !optimize_size\n+      && maybe_hot_bb_p (bb1)\n+      && maybe_hot_bb_p (bb2))\n     {\n-      /* If register stack conversion has already been done, then\n-         death notes must also be compared before it is certain that\n-         the two instruction streams match.  */\n-\n-      rtx note;\n-      HARD_REG_SET i1_regset, i2_regset;\n-\n-      CLEAR_HARD_REG_SET (i1_regset);\n-      CLEAR_HARD_REG_SET (i2_regset);\n+      int prob2;\n \n-      for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n-\t  SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n-\n-      for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n-\t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n-\n-      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n-\n-      return false;\n-\n-    done:\n-      ;\n-    }\n-#endif\n-\n-  if (reload_completed\n-      ? rtx_renumbered_equal_p (p1, p2) : rtx_equal_p (p1, p2))\n-    return true;\n-\n-  /* Do not do EQUIV substitution after reload.  First, we're undoing the\n-     work of reload_cse.  Second, we may be undoing the work of the post-\n-     reload splitting pass.  */\n-  /* ??? Possibly add a new phase switch variable that can be used by\n-     targets to disallow the troublesome insns after splitting.  */\n-  if (!reload_completed)\n-    {\n-      /* The following code helps take care of G++ cleanups.  */\n-      rtx equiv1 = find_reg_equal_equiv_note (i1);\n-      rtx equiv2 = find_reg_equal_equiv_note (i2);\n-\n-      if (equiv1 && equiv2\n-\t  /* If the equivalences are not to a constant, they may\n-\t     reference pseudos that no longer exist, so we can't\n-\t     use them.  */\n-\t  && (! reload_completed\n-\t      || (CONSTANT_P (XEXP (equiv1, 0))\n-\t\t  && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))))\n-\t{\n-\t  rtx s1 = single_set (i1);\n-\t  rtx s2 = single_set (i2);\n-\t  if (s1 != 0 && s2 != 0\n-\t      && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n-\t    {\n-\t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n-\t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n-\t      if (! rtx_renumbered_equal_p (p1, p2))\n-\t\tcancel_changes (0);\n-\t      else if (apply_change_group ())\n-\t\treturn true;\n-\t    }\n-\t}\n-    }\n-\n-  return false;\n-}\n-\f\n-/* Look through the insns at the end of BB1 and BB2 and find the longest\n-   sequence that are equivalent.  Store the first insns for that sequence\n-   in *F1 and *F2 and return the sequence length.\n-\n-   To simplify callers of this function, if the blocks match exactly,\n-   store the head of the blocks in *F1 and *F2.  */\n-\n-static int\n-flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n-\t\t      basic_block bb2, rtx *f1, rtx *f2)\n-{\n-  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n-  int ninsns = 0;\n-\n-  /* Skip simple jumps at the end of the blocks.  Complex jumps still\n-     need to be compared for equivalence, which we'll do below.  */\n-\n-  i1 = BB_END (bb1);\n-  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n-  if (onlyjump_p (i1)\n-      || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n-    {\n-      last1 = i1;\n-      i1 = PREV_INSN (i1);\n-    }\n-\n-  i2 = BB_END (bb2);\n-  if (onlyjump_p (i2)\n-      || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n-    {\n-      last2 = i2;\n-      /* Count everything except for unconditional jump as insn.  */\n-      if (!simplejump_p (i2) && !returnjump_p (i2) && last1)\n-\tninsns++;\n-      i2 = PREV_INSN (i2);\n-    }\n-\n-  while (true)\n-    {\n-      /* Ignore notes.  */\n-      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n-\ti1 = PREV_INSN (i1);\n-\n-      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n-\ti2 = PREV_INSN (i2);\n-\n-      if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n-\tbreak;\n-\n-      if (!insns_match_p (mode, i1, i2))\n-\tbreak;\n-\n-      merge_memattrs (i1, i2);\n-\n-      /* Don't begin a cross-jump with a NOTE insn.  */\n-      if (INSN_P (i1))\n-\t{\n-\t  /* If the merged insns have different REG_EQUAL notes, then\n-\t     remove them.  */\n-\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n-\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n-\n-\t  if (equiv1 && !equiv2)\n-\t    remove_note (i1, equiv1);\n-\t  else if (!equiv1 && equiv2)\n-\t    remove_note (i2, equiv2);\n-\t  else if (equiv1 && equiv2\n-\t\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n-\t    {\n-\t      remove_note (i1, equiv1);\n-\t      remove_note (i2, equiv2);\n-\t    }\n-\n-\t  afterlast1 = last1, afterlast2 = last2;\n-\t  last1 = i1, last2 = i2;\n-\t  ninsns++;\n-\t}\n-\n-      i1 = PREV_INSN (i1);\n-      i2 = PREV_INSN (i2);\n+      if (b1->dest == b2->dest)\n+        prob2 = b2->probability;\n+      else\n+        /* Do not use f2 probability as f2 may be forwarded.  */\n+        prob2 = REG_BR_PROB_BASE - b2->probability;\n+\n+      /* Fail if the difference in probabilities is greater than 50%.\n+         This rules out two well-predicted branches with opposite\n+         outcomes.  */\n+      if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n+        {\n+          if (dump_file)\n+            fprintf (dump_file,\n+                     \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n+                     bb1->index, bb2->index, b1->probability, prob2);\n+\n+          return false;\n+        }\n     }\n \n-#ifdef HAVE_cc0\n-  /* Don't allow the insn after a compare to be shared by\n-     cross-jumping unless the compare is also shared.  */\n-  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n-    last1 = afterlast1, last2 = afterlast2, ninsns--;\n-#endif\n-\n-  /* Include preceding notes and labels in the cross-jump.  One,\n-     this may bring us to the head of the blocks as requested above.\n-     Two, it keeps line number notes as matched as may be.  */\n-  if (ninsns)\n-    {\n-      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n-\tlast1 = PREV_INSN (last1);\n-\n-      if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n-\tlast1 = PREV_INSN (last1);\n-\n-      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n-\tlast2 = PREV_INSN (last2);\n+  if (dump_file && match)\n+    fprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n+             bb1->index, bb2->index);\n \n-      if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n-\tlast2 = PREV_INSN (last2);\n-\n-      *f1 = last1;\n-      *f2 = last2;\n-    }\n-\n-  return ninsns;\n+  return match;\n }\n-\n /* Return true iff outgoing edges of BB1 and BB2 match, together with\n    the branch instruction.  This means that if we commonize the control\n    flow before end of the basic block, the semantic remains unchanged.\n@@ -1224,108 +1011,11 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       && any_condjump_p (BB_END (bb1))\n       && onlyjump_p (BB_END (bb1)))\n     {\n-      edge b1, f1, b2, f2;\n-      bool reverse, match;\n-      rtx set1, set2, cond1, cond2;\n-      enum rtx_code code1, code2;\n-\n       if (EDGE_COUNT (bb2->succs) != 2\n \t  || !any_condjump_p (BB_END (bb2))\n \t  || !onlyjump_p (BB_END (bb2)))\n \treturn false;\n-\n-      b1 = BRANCH_EDGE (bb1);\n-      b2 = BRANCH_EDGE (bb2);\n-      f1 = FALLTHRU_EDGE (bb1);\n-      f2 = FALLTHRU_EDGE (bb2);\n-\n-      /* Get around possible forwarders on fallthru edges.  Other cases\n-         should be optimized out already.  */\n-      if (FORWARDER_BLOCK_P (f1->dest))\n-\tf1 = single_succ_edge (f1->dest);\n-\n-      if (FORWARDER_BLOCK_P (f2->dest))\n-\tf2 = single_succ_edge (f2->dest);\n-\n-      /* To simplify use of this function, return false if there are\n-\t unneeded forwarder blocks.  These will get eliminated later\n-\t during cleanup_cfg.  */\n-      if (FORWARDER_BLOCK_P (f1->dest)\n-\t  || FORWARDER_BLOCK_P (f2->dest)\n-\t  || FORWARDER_BLOCK_P (b1->dest)\n-\t  || FORWARDER_BLOCK_P (b2->dest))\n-\treturn false;\n-\n-      if (f1->dest == f2->dest && b1->dest == b2->dest)\n-\treverse = false;\n-      else if (f1->dest == b2->dest && b1->dest == f2->dest)\n-\treverse = true;\n-      else\n-\treturn false;\n-\n-      set1 = pc_set (BB_END (bb1));\n-      set2 = pc_set (BB_END (bb2));\n-      if ((XEXP (SET_SRC (set1), 1) == pc_rtx)\n-\t  != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n-\treverse = !reverse;\n-\n-      cond1 = XEXP (SET_SRC (set1), 0);\n-      cond2 = XEXP (SET_SRC (set2), 0);\n-      code1 = GET_CODE (cond1);\n-      if (reverse)\n-\tcode2 = reversed_comparison_code (cond2, BB_END (bb2));\n-      else\n-\tcode2 = GET_CODE (cond2);\n-\n-      if (code2 == UNKNOWN)\n-\treturn false;\n-\n-      /* Verify codes and operands match.  */\n-      match = ((code1 == code2\n-\t\t&& rtx_renumbered_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n-\t\t&& rtx_renumbered_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n-\t       || (code1 == swap_condition (code2)\n-\t\t   && rtx_renumbered_equal_p (XEXP (cond1, 1),\n-\t\t\t\t\t      XEXP (cond2, 0))\n-\t\t   && rtx_renumbered_equal_p (XEXP (cond1, 0),\n-\t\t\t\t\t      XEXP (cond2, 1))));\n-\n-      /* If we return true, we will join the blocks.  Which means that\n-\t we will only have one branch prediction bit to work with.  Thus\n-\t we require the existing branches to have probabilities that are\n-\t roughly similar.  */\n-      if (match\n-\t  && !optimize_size\n-\t  && maybe_hot_bb_p (bb1)\n-\t  && maybe_hot_bb_p (bb2))\n-\t{\n-\t  int prob2;\n-\n-\t  if (b1->dest == b2->dest)\n-\t    prob2 = b2->probability;\n-\t  else\n-\t    /* Do not use f2 probability as f2 may be forwarded.  */\n-\t    prob2 = REG_BR_PROB_BASE - b2->probability;\n-\n-\t  /* Fail if the difference in probabilities is greater than 50%.\n-\t     This rules out two well-predicted branches with opposite\n-\t     outcomes.  */\n-\t  if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n-\t\t\t bb1->index, bb2->index, b1->probability, prob2);\n-\n-\t      return false;\n-\t    }\n-\t}\n-\n-      if (dump_file && match)\n-\tfprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n-\t\t bb1->index, bb2->index);\n-\n-      return match;\n+      return condjump_equiv_p (bb1, bb2);\n     }\n \n   /* Generic case - we are seeing a computed jump, table jump or trapping"}, {"sha": "0ba1b9d06bc1996c5ac588dcafdfea5a2ddd37a1", "filename": "gcc/struct-equiv.c", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f416ffb2875d45370783e94ccab44403d44a1c4/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=7f416ffb2875d45370783e94ccab44403d44a1c4", "patch": "@@ -0,0 +1,362 @@\n+/* Control flow optimization code for GNU compiler.\n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This file contains helper functions for Cross jumping (tail merging).  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"output.h\"\n+#include \"insn-config.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"emit-rtl.h\"\n+\n+static void merge_memattrs (rtx, rtx);\n+\n+\f\n+\n+/* Removes the memory attributes of MEM expression\n+   if they are not equal.  */\n+\n+void\n+merge_memattrs (rtx x, rtx y)\n+{\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  if (x == y)\n+    return;\n+  if (x == 0 || y == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  if (code != GET_CODE (y))\n+    return;\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return;\n+\n+  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))\n+    {\n+      if (! MEM_ATTRS (x))\n+\tMEM_ATTRS (y) = 0;\n+      else if (! MEM_ATTRS (y))\n+\tMEM_ATTRS (x) = 0;\n+      else \n+\t{\n+\t  rtx mem_size;\n+\n+\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n+\t    {\n+\t      set_mem_alias_set (x, 0);\n+\t      set_mem_alias_set (y, 0);\n+\t    }\n+\t  \n+\t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n+\t    {\n+\t      set_mem_expr (x, 0);\n+\t      set_mem_expr (y, 0);\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n+\t    {\n+\t      set_mem_offset (x, 0);\n+\t      set_mem_offset (y, 0);\n+\t    }\n+\t \n+\t  if (!MEM_SIZE (x))\n+\t    mem_size = NULL_RTX;\n+\t  else if (!MEM_SIZE (y))\n+\t    mem_size = NULL_RTX;\n+\t  else\n+\t    mem_size = GEN_INT (MAX (INTVAL (MEM_SIZE (x)),\n+\t\t\t\t     INTVAL (MEM_SIZE (y))));\n+\t  set_mem_size (x, mem_size);\n+\t  set_mem_size (y, mem_size);\n+\n+\t  set_mem_align (x, MIN (MEM_ALIGN (x), MEM_ALIGN (y)));\n+\t  set_mem_align (y, MEM_ALIGN (x));\n+\t}\n+    }\n+  \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    merge_memattrs (XVECEXP (x, i, j), XVECEXP (y, i, j));\n+\n+\t  break;\n+\n+\tcase 'e':\n+\t  merge_memattrs (XEXP (x, i), XEXP (y, i));\n+\t}\n+    }\n+  return;\n+}\n+\n+/* Check if the set of REG_DEAD notes attached to I1 and I2 allows us to\n+   go ahead with merging I1 and I2, which otherwise look fine.  */\n+static bool\n+death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n+\t\t     int mode ATTRIBUTE_UNUSED)\n+{\n+#ifdef STACK_REGS\n+  /* If cross_jump_death_matters is not 0, the insn's mode\n+     indicates whether or not the insn contains any stack-like\n+     regs.  */\n+\n+  if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n+    {\n+      /* If register stack conversion has already been done, then\n+         death notes must also be compared before it is certain that\n+         the two instruction streams match.  */\n+\n+      rtx note;\n+      HARD_REG_SET i1_regset, i2_regset;\n+\n+      CLEAR_HARD_REG_SET (i1_regset);\n+      CLEAR_HARD_REG_SET (i2_regset);\n+\n+      for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n+\n+      for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n+\t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n+\n+      GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n+\n+      return false;\n+\n+    done:\n+      ;\n+    }\n+#endif\n+  return true;\n+}\n+\n+/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n+\n+bool\n+insns_match_p (int mode, rtx i1, rtx i2)\n+{\n+  rtx p1, p2;\n+\n+  /* Verify that I1 and I2 are equivalent.  */\n+  if (GET_CODE (i1) != GET_CODE (i2))\n+    return false;\n+\n+  p1 = PATTERN (i1);\n+  p2 = PATTERN (i2);\n+\n+  if (GET_CODE (p1) != GET_CODE (p2))\n+    return false;\n+\n+  /* If this is a CALL_INSN, compare register usage information.\n+     If we don't check this on stack register machines, the two\n+     CALL_INSNs might be merged leaving reg-stack.c with mismatching\n+     numbers of stack registers in the same basic block.\n+     If we don't check this on machines with delay slots, a delay slot may\n+     be filled that clobbers a parameter expected by the subroutine.\n+\n+     ??? We take the simple route for now and assume that if they're\n+     equal, they were constructed identically.  */\n+\n+  if (CALL_P (i1)\n+      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t        CALL_INSN_FUNCTION_USAGE (i2))\n+\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n+    return false;\n+\n+  if (!death_notes_match_p (i1, i2, mode))\n+    return false;\n+\n+  if (reload_completed\n+      ? rtx_renumbered_equal_p (p1, p2) : rtx_equal_p (p1, p2))\n+    return true;\n+\n+  /* Do not do EQUIV substitution after reload.  First, we're undoing the\n+     work of reload_cse.  Second, we may be undoing the work of the post-\n+     reload splitting pass.  */\n+  /* ??? Possibly add a new phase switch variable that can be used by\n+     targets to disallow the troublesome insns after splitting.  */\n+  if (!reload_completed)\n+    {\n+      /* The following code helps take care of G++ cleanups.  */\n+      rtx equiv1 = find_reg_equal_equiv_note (i1);\n+      rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+      if (equiv1 && equiv2\n+\t  /* If the equivalences are not to a constant, they may\n+\t     reference pseudos that no longer exist, so we can't\n+\t     use them.  */\n+\t  && (! reload_completed\n+\t      || (CONSTANT_P (XEXP (equiv1, 0))\n+\t\t  && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))))\n+\t{\n+\t  rtx s1 = single_set (i1);\n+\t  rtx s2 = single_set (i2);\n+\t  if (s1 != 0 && s2 != 0\n+\t      && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n+\t    {\n+\t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n+\t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n+\t      if (! rtx_renumbered_equal_p (p1, p2))\n+\t\tcancel_changes (0);\n+\t      else if (apply_change_group ())\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\f\n+/* Look through the insns at the end of BB1 and BB2 and find the longest\n+   sequence that are equivalent.  Store the first insns for that sequence\n+   in *F1 and *F2 and return the sequence length.\n+\n+   To simplify callers of this function, if the blocks match exactly,\n+   store the head of the blocks in *F1 and *F2.  */\n+\n+int\n+flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n+\t\t      basic_block bb2, rtx *f1, rtx *f2)\n+{\n+  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n+  int ninsns = 0;\n+\n+  /* Skip simple jumps at the end of the blocks.  Complex jumps still\n+     need to be compared for equivalence, which we'll do below.  */\n+\n+  i1 = BB_END (bb1);\n+  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n+  if (onlyjump_p (i1)\n+      || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n+    {\n+      last1 = i1;\n+      i1 = PREV_INSN (i1);\n+    }\n+\n+  i2 = BB_END (bb2);\n+  if (onlyjump_p (i2)\n+      || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n+    {\n+      last2 = i2;\n+      /* Count everything except for unconditional jump as insn.  */\n+      if (!simplejump_p (i2) && !returnjump_p (i2) && last1)\n+\tninsns++;\n+      i2 = PREV_INSN (i2);\n+    }\n+\n+  while (true)\n+    {\n+      /* Ignore notes.  */\n+      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n+\ti1 = PREV_INSN (i1);\n+\n+      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n+\ti2 = PREV_INSN (i2);\n+\n+      if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n+\tbreak;\n+\n+      if (!insns_match_p (mode, i1, i2))\n+\tbreak;\n+\n+      merge_memattrs (i1, i2);\n+\n+      /* Don't begin a cross-jump with a NOTE insn.  */\n+      if (INSN_P (i1))\n+\t{\n+\t  /* If the merged insns have different REG_EQUAL notes, then\n+\t     remove them.  */\n+\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n+\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n+\n+\t  if (equiv1 && !equiv2)\n+\t    remove_note (i1, equiv1);\n+\t  else if (!equiv1 && equiv2)\n+\t    remove_note (i2, equiv2);\n+\t  else if (equiv1 && equiv2\n+\t\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n+\t    {\n+\t      remove_note (i1, equiv1);\n+\t      remove_note (i2, equiv2);\n+\t    }\n+\n+\t  afterlast1 = last1, afterlast2 = last2;\n+\t  last1 = i1, last2 = i2;\n+\t  ninsns++;\n+\t}\n+\n+      i1 = PREV_INSN (i1);\n+      i2 = PREV_INSN (i2);\n+    }\n+\n+#ifdef HAVE_cc0\n+  /* Don't allow the insn after a compare to be shared by\n+     cross-jumping unless the compare is also shared.  */\n+  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n+    last1 = afterlast1, last2 = afterlast2, ninsns--;\n+#endif\n+\n+  /* Include preceding notes and labels in the cross-jump.  One,\n+     this may bring us to the head of the blocks as requested above.\n+     Two, it keeps line number notes as matched as may be.  */\n+  if (ninsns)\n+    {\n+      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n+\tlast1 = PREV_INSN (last1);\n+\n+      if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n+\tlast1 = PREV_INSN (last1);\n+\n+      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n+\tlast2 = PREV_INSN (last2);\n+\n+      if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n+\tlast2 = PREV_INSN (last2);\n+\n+      *f1 = last1;\n+      *f2 = last2;\n+    }\n+\n+  return ninsns;\n+}"}]}