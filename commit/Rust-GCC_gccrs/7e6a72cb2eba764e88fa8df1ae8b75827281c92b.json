{"sha": "7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U2YTcyY2IyZWJhNzY0ZTg4ZmE4ZGYxYWU4Yjc1ODI3MjgxYzkyYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-13T20:03:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-13T20:03:55Z"}, "message": "c++: Formatting fixups & some simplifications.\n\nA bunch of minor reformatting, simplifications or change to checking_asserts.\n\n\t* pt.c (spec_hash_table): New typedef.\n\t(decl_specializations, type_specializations): Use it.\n\t(retrieve_specialization): Likewise.\n\t(register_specialization): Remove unnecessary casts.\n\t(push_template_decl_real): Reformat.\n\t(instantiate_class_template_1): Use more RAII.\n\t(make_argument_pack): Simplify.\n\t(instantiate_template_1): Use gcc_checking_assert for expensive\n\tasserts.\n\t(instantiate_decl): Likewise.\n\t(resolve_typename_type): Reformat comment.\n\t* semantics.c (struct deferred_access): Remove unnecessary GTY on\n\tmember.\n\t(begin_class_definition): Fix formatting.", "tree": {"sha": "4fc01dfe914068f961cae83c14abbfe904da8f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fc01dfe914068f961cae83c14abbfe904da8f15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b04445d4a809eaf0460fd4f1f35b1a7d458c8c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b04445d4a809eaf0460fd4f1f35b1a7d458c8c72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b04445d4a809eaf0460fd4f1f35b1a7d458c8c72"}], "stats": {"total": 105, "additions": 60, "deletions": 45}, "files": [{"sha": "b75025f389baf6e292f5c5a4416bf098adbc6190", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "patch": "@@ -1,3 +1,21 @@\n+2020-05-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tFormatting fixups & some simplifications.\n+\t* pt.c (spec_hash_table): New typedef.\n+\t(decl_specializations, type_specializations): Use it.\n+\t(retrieve_specialization): Likewise.\n+\t(register_specialization): Remove unnecessary casts.\n+\t(push_template_decl_real): Reformat.\n+\t(instantiate_class_template_1): Use more RAII.\n+\t(make_argument_pack): Simplify.\n+\t(instantiate_template_1): Use gcc_checking_assert for expensive\n+\tasserts.\n+\t(instantiate_decl): Likewise.\n+\t(resolve_typename_type): Reformat comment.\n+\t* semantics.c (struct deferred_access): Remove unnecessary GTY on\n+\tmember.\n+\t(begin_class_definition): Fix formatting.\n+\n 2020-05-13  Jason Merrill  <jason@redhat.com>\n \n \t* call.c, class.c, constexpr.c, constraint.cc, decl.c, init.c,"}, {"sha": "a732ced2d8d81778be10410e83b177a4e8c37df9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "patch": "@@ -48,9 +48,9 @@ along with GCC; see the file COPYING3.  If not see\n    returning an int.  */\n typedef int (*tree_fn_t) (tree, void*);\n \n-/* The PENDING_TEMPLATES is a TREE_LIST of templates whose\n-   instantiations have been deferred, either because their definitions\n-   were not yet available, or because we were putting off doing the work.  */\n+/* The PENDING_TEMPLATES is a list of templates whose instantiations\n+   have been deferred, either because their definitions were not yet\n+   available, or because we were putting off doing the work.  */\n struct GTY ((chain_next (\"%h.next\"))) pending_template\n {\n   struct pending_template *next;\n@@ -116,9 +116,10 @@ struct spec_hasher : ggc_ptr_hash<spec_entry>\n   static bool equal (spec_entry *, spec_entry *);\n };\n \n-static GTY (()) hash_table<spec_hasher> *decl_specializations;\n-\n-static GTY (()) hash_table<spec_hasher> *type_specializations;\n+/* The general template is not in these tables.  */\n+typedef hash_table<spec_hasher> spec_hash_table;\n+static GTY (()) spec_hash_table *decl_specializations;\n+static GTY (()) spec_hash_table *type_specializations;\n \n /* Contains canonical template parameter types. The vector is indexed by\n    the TEMPLATE_TYPE_IDX of the template parameter. Each element is a\n@@ -1278,7 +1279,7 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n     {\n       spec_entry *found;\n       spec_entry elt;\n-      hash_table<spec_hasher> *specializations;\n+      spec_hash_table *specializations;\n \n       elt.tmpl = tmpl;\n       elt.args = args;\n@@ -1573,10 +1574,9 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n       if (hash == 0)\n \thash = spec_hasher::hash (&elt);\n \n-      slot =\n-\tdecl_specializations->find_slot_with_hash (&elt, hash, INSERT);\n+      slot = decl_specializations->find_slot_with_hash (&elt, hash, INSERT);\n       if (*slot)\n-\tfn = ((spec_entry *) *slot)->spec;\n+\tfn = (*slot)->spec;\n       else\n \tfn = NULL_TREE;\n     }\n@@ -4474,7 +4474,7 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n       TEMPLATE_PARM_PARAMETER_PACK (tpi)\n \t= TEMPLATE_PARM_PARAMETER_PACK (index);\n \n-\t/* Template template parameters need this.  */\n+      /* Template template parameters need this.  */\n       tree inner = decl;\n       if (TREE_CODE (decl) == TEMPLATE_DECL)\n \t{\n@@ -5705,8 +5705,7 @@ push_template_decl_real (tree decl, bool is_friend)\n          template <typename T> friend void A<T>::f();\n        is not primary.  */\n     is_primary = false;\n-  else if (TREE_CODE (decl) == TYPE_DECL\n-\t   && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n+  else if (TREE_CODE (decl) == TYPE_DECL && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n     is_primary = false;\n   else\n     is_primary = template_parm_scope_p ();\n@@ -5845,8 +5844,7 @@ push_template_decl_real (tree decl, bool is_friend)\n   if (!ctx\n       || TREE_CODE (ctx) == FUNCTION_DECL\n       || (CLASS_TYPE_P (ctx) && TYPE_BEING_DEFINED (ctx))\n-      || (TREE_CODE (decl) == TYPE_DECL\n-\t  && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n+      || (TREE_CODE (decl) == TYPE_DECL && LAMBDA_TYPE_P (TREE_TYPE (decl)))\n       || (is_friend && !DECL_TEMPLATE_INFO (decl)))\n     {\n       if (DECL_LANG_SPECIFIC (decl)\n@@ -11752,13 +11750,10 @@ instantiate_class_template_1 (tree type)\n \t\tcontinue;\n \n \t      /* Build new CLASSTYPE_NESTED_UTDS.  */\n+\t      bool class_template_p = (TREE_CODE (t) != ENUMERAL_TYPE\n+\t\t\t\t       && TYPE_LANG_SPECIFIC (t)\n+\t\t\t\t       && CLASSTYPE_IS_TEMPLATE (t));\n \n-\t      tree newtag;\n-\t      bool class_template_p;\n-\n-\t      class_template_p = (TREE_CODE (t) != ENUMERAL_TYPE\n-\t\t\t\t  && TYPE_LANG_SPECIFIC (t)\n-\t\t\t\t  && CLASSTYPE_IS_TEMPLATE (t));\n \t      /* If the member is a class template, then -- even after\n \t\t substitution -- there may be dependent types in the\n \t\t template argument list for the class.  We increment\n@@ -11767,7 +11762,7 @@ instantiate_class_template_1 (tree type)\n \t\t when outside of a template.  */\n \t      if (class_template_p)\n \t\t++processing_template_decl;\n-\t      newtag = tsubst (t, args, tf_error, NULL_TREE);\n+\t      tree newtag = tsubst (t, args, tf_error, NULL_TREE);\n \t      if (class_template_p)\n \t\t--processing_template_decl;\n \t      if (newtag == error_mark_node)\n@@ -11834,6 +11829,7 @@ instantiate_class_template_1 (tree type)\n \t\t  tree vec = NULL_TREE;\n \t\t  int len = 1;\n \n+\t\t  gcc_checking_assert (TREE_CODE (t) != CONST_DECL);\n \t\t  /* The file and line for this declaration, to\n \t\t     assist in error message reporting.  Since we\n \t\t     called push_tinst_level above, we don't need to\n@@ -13067,8 +13063,8 @@ static tree\n make_argument_pack (tree vec)\n {\n   tree pack;\n-  tree elt = TREE_VEC_ELT (vec, 0);\n-  if (TYPE_P (elt))\n+\n+  if (TYPE_P (TREE_VEC_ELT (vec, 0)))\n     pack = cxx_make_type (TYPE_ARGUMENT_PACK);\n   else\n     {\n@@ -20714,10 +20710,11 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n      but it doesn't seem to be on the hot path.  */\n   spec = retrieve_specialization (gen_tmpl, targ_ptr, 0);\n \n-  gcc_assert (tmpl == gen_tmpl\n-\t      || ((fndecl = retrieve_specialization (tmpl, orig_args, 0))\n-\t\t  == spec)\n-\t      || fndecl == NULL_TREE);\n+  gcc_checking_assert (tmpl == gen_tmpl\n+\t\t       || ((fndecl\n+\t\t\t    = retrieve_specialization (tmpl, orig_args, 0))\n+\t\t\t   == spec)\n+\t\t       || fndecl == NULL_TREE);\n \n   if (spec != NULL_TREE)\n     {\n@@ -22794,7 +22791,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n               TREE_CONSTANT (result) = 1;\n             }\n           else\n-            result = cxx_make_type (TYPE_ARGUMENT_PACK);\n+\t    result = cxx_make_type (TYPE_ARGUMENT_PACK);\n \n           SET_ARGUMENT_PACK_ARGS (result, new_args);\n \n@@ -25422,13 +25419,14 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n   gen_tmpl = most_general_template (tmpl);\n   gen_args = DECL_TI_ARGS (d);\n \n-  if (tmpl != gen_tmpl)\n-    /* We should already have the extra args.  */\n-    gcc_assert (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (gen_tmpl))\n-\t\t== TMPL_ARGS_DEPTH (gen_args));\n+  /* We should already have the extra args.  */\n+  gcc_checking_assert (tmpl == gen_tmpl\n+\t\t       || (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (gen_tmpl))\n+\t\t\t   == TMPL_ARGS_DEPTH (gen_args)));\n   /* And what's in the hash table should match D.  */\n-  gcc_assert ((spec = retrieve_specialization (gen_tmpl, gen_args, 0)) == d\n-\t      || spec == NULL_TREE);\n+  gcc_checking_assert ((spec = retrieve_specialization (gen_tmpl, gen_args, 0))\n+\t\t       == d\n+\t\t       || spec == NULL_TREE);\n \n   /* This needs to happen before any tsubsting.  */\n   if (! push_tinst_level (d))\n@@ -27462,12 +27460,12 @@ resolve_typename_type (tree type, bool only_current_p)\n   gcc_checking_assert (uses_template_parms (scope));\n \n   /* Usually the non-qualified identifier of a TYPENAME_TYPE is\n-     TYPE_IDENTIFIER (type). But when 'type' is a typedef variant of\n-     a TYPENAME_TYPE node, then TYPE_NAME (type) is set to the TYPE_DECL representing\n-     the typedef. In that case TYPE_IDENTIFIER (type) is not the non-qualified\n-     identifier  of the TYPENAME_TYPE anymore.\n-     So by getting the TYPE_IDENTIFIER of the _main declaration_ of the\n-     TYPENAME_TYPE instead, we avoid messing up with a possible\n+     TYPE_IDENTIFIER (type). But when 'type' is a typedef variant of a\n+     TYPENAME_TYPE node, then TYPE_NAME (type) is set to the TYPE_DECL\n+     representing the typedef. In that case TYPE_IDENTIFIER (type) is\n+     not the non-qualified identifier of the TYPENAME_TYPE anymore.\n+     So by getting the TYPE_IDENTIFIER of the _main declaration_ of\n+     the TYPENAME_TYPE instead, we avoid messing up with a possible\n      typedef variant case.  */\n   name = TYPE_IDENTIFIER (TYPE_MAIN_VARIANT (type));\n \n@@ -27816,7 +27814,7 @@ finish_concept_definition (cp_expr id, tree init)\n       return error_mark_node;\n     }\n \n-  /* Initially build the concept declaration; it's type is bool.  */\n+  /* Initially build the concept declaration; its type is bool.  */\n   tree decl = build_lang_decl_loc (loc, CONCEPT_DECL, *id, boolean_type_node);\n   DECL_CONTEXT (decl) = current_scope ();\n   DECL_INITIAL (decl) = init;"}, {"sha": "d90816eabc94ef1c2f636ae69c4a008c6da28e80", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e6a72cb2eba764e88fa8df1ae8b75827281c92b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7e6a72cb2eba764e88fa8df1ae8b75827281c92b", "patch": "@@ -127,11 +127,10 @@ struct GTY(()) deferred_access {\n        A::B* A::f() { return 0; }\n \n      is valid, even though `A::B' is not generally accessible.  */\n-  vec<deferred_access_check, va_gc> * GTY(()) deferred_access_checks;\n+  vec<deferred_access_check, va_gc> *deferred_access_checks;\n \n   /* The current mode of access checks.  */\n   enum deferring_kind deferring_access_checks_kind;\n-\n };\n \n /* Data for deferred access checking.  */\n@@ -3216,7 +3215,7 @@ begin_class_definition (tree t)\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n \t(t, finfo->interface_unknown);\n     }\n-  reset_specialization();\n+  reset_specialization ();\n \n   /* Make a declaration for this class in its own scope.  */\n   build_self_reference ();"}]}