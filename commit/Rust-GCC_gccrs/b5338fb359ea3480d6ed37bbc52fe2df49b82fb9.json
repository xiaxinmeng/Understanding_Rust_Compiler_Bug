{"sha": "b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzMzhmYjM1OWVhMzQ4MGQ2ZWQzN2JiYzUyZmUyZGY0OWI4MmZiOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-22T16:47:22Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-22T16:47:22Z"}, "message": "PR middle-end/88226 - missing warning on fprintf, fputs, and puts with an unterminated array\n\ngcc/ChangeLog:\n\n\tPR middle-end/88226\n\t* builtins.c (check_nul_terminated_array): New function.\n\t(fold_builtin_0): Remove declaration.\n\t(fold_builtin_1): Same.\n\t(fold_builtin_2): Same.\n\t(fold_builtin_3): Same.\n\t(fold_builtin_strpbrk): Add argument.\n\t(fold_builtin_strspn): Same.\n\t(fold_builtin_strcspn): Same.\n\t(expand_builtin_strcat): Call it.  Remove unused argument.\n\t(expand_builtin_stpncpy): Same.\n\t(expand_builtin_strncat): Same.\n\t(expand_builtin_strncpy): Same.  Adjust indentation.\n\t(expand_builtin_strcmp): Same.\n\t(expand_builtin_strncmp): Same.\n\t(expand_builtin_fork_or_exec): Same.\n\t(expand_builtin): Handle more built-ins.\n\t(fold_builtin_2): Add argument.\n\t(fold_builtin_n): Make static.  Add argument.\n\t(fold_call_expr): Pass new argument to fold_builtin_n and fold_builtin_2.\n\t(fold_builtin_call_array): Pass new argument to fold_builtin_n.\n\t(fold_builtin_strpbrk): Add argument.  Call check_nul_terminated_array.\n\t(fold_call_stmt): Pass new argument to fold_builtin_n.\n\t* builtins.h: Correct a comment.\n\t* gimple-fold.c (gimple_fold_builtin_strchr): Call\n\tcheck_nul_terminated_array.\n\t* tree-ssa-strlen.c (handle_builtin_strlen): Call\n\tcheck_nul_terminated_array.\n\t(handle_builtin_strchr): Same.\n\t(handle_builtin_string_cmp): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/88226\n\t* gcc.dg/Wstringop-overflow-22.c: New test.\n\t* gcc.dg/tree-ssa/builtin-fprintf-warn-1.c: Remove xfails.\n\nFrom-SVN: r278623", "tree": {"sha": "2216f90a2e8eee2cdeb3d613c5d53dc9e791f4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2216f90a2e8eee2cdeb3d613c5d53dc9e791f4a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86b0eb81837f4912d3f10bcfad35086cc54a1841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b0eb81837f4912d3f10bcfad35086cc54a1841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b0eb81837f4912d3f10bcfad35086cc54a1841"}], "stats": {"total": 772, "additions": 612, "deletions": 160}, "files": [{"sha": "f042116fa4de8c81ffe405e578b931a79f71e7b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -6,6 +6,39 @@\n \t(LDS_SIZE): Redefine using above.\n \t(gcn_expand_prologue): Initialize m0 with LDS_SIZE-1.\n \n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/88226\n+\t* builtins.c (check_nul_terminated_array): New function.\n+\t(fold_builtin_0): Remove declaration.\n+\t(fold_builtin_1): Same.\n+\t(fold_builtin_2): Same.\n+\t(fold_builtin_3): Same.\n+\t(fold_builtin_strpbrk): Add argument.\n+\t(fold_builtin_strspn): Same.\n+\t(fold_builtin_strcspn): Same.\n+\t(expand_builtin_strcat): Call it.  Remove unused argument.\n+\t(expand_builtin_stpncpy): Same.\n+\t(expand_builtin_strncat): Same.\n+\t(expand_builtin_strncpy): Same.  Adjust indentation.\n+\t(expand_builtin_strcmp): Same.\n+\t(expand_builtin_strncmp): Same.\n+\t(expand_builtin_fork_or_exec): Same.\n+\t(expand_builtin): Handle more built-ins.\n+\t(fold_builtin_2): Add argument.\n+\t(fold_builtin_n): Make static.  Add argument.\n+\t(fold_call_expr): Pass new argument to fold_builtin_n and fold_builtin_2.\n+\t(fold_builtin_call_array): Pass new argument to fold_builtin_n.\n+\t(fold_builtin_strpbrk): Add argument.  Call check_nul_terminated_array.\n+\t(fold_call_stmt): Pass new argument to fold_builtin_n.\n+\t* builtins.h: Correct a comment.\n+\t* gimple-fold.c (gimple_fold_builtin_strchr): Call\n+\tcheck_nul_terminated_array.\n+\t* tree-ssa-strlen.c (handle_builtin_strlen): Call\n+\tcheck_nul_terminated_array.\n+\t(handle_builtin_strchr): Same.\n+\t(handle_builtin_string_cmp): Same.\n+\n 2019-11-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/92501"}, {"sha": "f8cd4b44fa8912d581208571a2f8f3325ca82c0c", "filename": "gcc/builtins.c", "status": "modified", "additions": 275, "deletions": 145, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -131,7 +131,7 @@ static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n static rtx expand_builtin_memmove (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, memop_ret);\n-static rtx expand_builtin_strcat (tree, rtx);\n+static rtx expand_builtin_strcat (tree);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n@@ -166,15 +166,11 @@ static tree fold_builtin_fabs (location_t, tree, tree);\n static tree fold_builtin_abs (location_t, tree, tree);\n static tree fold_builtin_unordered_cmp (location_t, tree, tree, tree, enum tree_code,\n \t\t\t\t\tenum tree_code);\n-static tree fold_builtin_0 (location_t, tree);\n-static tree fold_builtin_1 (location_t, tree, tree);\n-static tree fold_builtin_2 (location_t, tree, tree, tree);\n-static tree fold_builtin_3 (location_t, tree, tree, tree, tree);\n static tree fold_builtin_varargs (location_t, tree, tree*, int);\n \n-static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n-static tree fold_builtin_strspn (location_t, tree, tree);\n-static tree fold_builtin_strcspn (location_t, tree, tree);\n+static tree fold_builtin_strpbrk (location_t, tree, tree, tree, tree);\n+static tree fold_builtin_strspn (location_t, tree, tree, tree);\n+static tree fold_builtin_strcspn (location_t, tree, tree, tree);\n \n static rtx expand_builtin_object_size (tree);\n static rtx expand_builtin_memory_chk (tree, rtx, machine_mode,\n@@ -564,6 +560,51 @@ warn_string_no_nul (location_t loc, const char *fn, tree arg, tree decl)\n     }\n }\n \n+/* For a call EXPR (which may be null) that expects a string argument\n+   and SRC as the argument, returns false if SRC is a character array\n+   with no terminating NUL.  When nonnull, BOUND is the number of\n+   characters in which to expect the terminating NUL.\n+   When EXPR is nonnull also issues a warning.  */\n+\n+bool\n+check_nul_terminated_array (tree expr, tree src, tree bound /* = NULL_TREE */)\n+{\n+  tree size;\n+  bool exact;\n+  tree nonstr = unterminated_array (src, &size, &exact);\n+  if (!nonstr)\n+    return true;\n+\n+  /* NONSTR refers to the non-nul terminated constant array and SIZE\n+     is the constant size of the array in bytes.  EXACT is true when\n+     SIZE is exact.  */\n+\n+  if (bound)\n+    {\n+      wide_int min, max;\n+      if (TREE_CODE (bound) == INTEGER_CST)\n+\tmin = max = wi::to_wide (bound);\n+      else\n+\t{\n+\t  value_range_kind rng = get_range_info (bound, &min, &max);\n+\t  if (rng != VR_RANGE)\n+\t    return true;\n+\t}\n+\n+      if (wi::leu_p (min, wi::to_wide (size)))\n+\treturn true;\n+    }\n+\n+  if (expr && !TREE_NO_WARNING (expr))\n+    {\n+      tree fndecl = get_callee_fndecl (expr);\n+      const char *fname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+      warn_string_no_nul (EXPR_LOCATION (expr), fname, src, nonstr);\n+    }\n+\n+  return false;\n+}\n+\n /* If EXP refers to an unterminated constant character array return\n    the declaration of the object of which the array is a member or\n    element and if SIZE is not null, set *SIZE to the size of\n@@ -4024,7 +4065,7 @@ expand_movstr (tree dest, tree src, rtx target, memop_ret retmode)\n    to the library function.  */\n \n static rtx\n-expand_builtin_strcat (tree exp, rtx)\n+expand_builtin_strcat (tree exp)\n {\n   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n       || !warn_stringop_overflow)\n@@ -4033,6 +4074,10 @@ expand_builtin_strcat (tree exp, rtx)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree src = CALL_EXPR_ARG (exp, 1);\n \n+  /* Detect unterminated source (only).  */\n+  if (!check_nul_terminated_array (exp, src))\n+    return NULL_RTX;\n+\n   /* There is no way here to determine the length of the string in\n      the destination to which the SRC string is being appended so\n      just diagnose cases when the souce string is longer than\n@@ -4228,6 +4273,8 @@ expand_builtin_stpncpy (tree exp, rtx)\n \n   /* The exact number of bytes to write (not the maximum).  */\n   tree len = CALL_EXPR_ARG (exp, 2);\n+  if (!check_nul_terminated_array (exp, src, len))\n+    return NULL_RTX;\n \n   /* The size of the destination object.  */\n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n@@ -4330,6 +4377,11 @@ expand_builtin_strncat (tree exp, rtx)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   /* The upper bound on the number of bytes to write.  */\n   tree maxread = CALL_EXPR_ARG (exp, 2);\n+\n+  /* Detect unterminated source (only).  */\n+  if (!check_nul_terminated_array (exp, src, maxread))\n+    return NULL_RTX;\n+\n   /* The length of the source sequence.  */\n   tree slen = c_strlen (src, 1);\n \n@@ -4391,59 +4443,63 @@ expand_builtin_strncpy (tree exp, rtx target)\n {\n   location_t loc = EXPR_LOCATION (exp);\n \n-  if (validate_arglist (exp,\n- \t\t\tPOINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree dest = CALL_EXPR_ARG (exp, 0);\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      /* The number of bytes to write (not the maximum).  */\n-      tree len = CALL_EXPR_ARG (exp, 2);\n-      /* The length of the source sequence.  */\n-      tree slen = c_strlen (src, 1);\n+  if (!validate_arglist (exp,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  /* The number of bytes to write (not the maximum).  */\n+  tree len = CALL_EXPR_ARG (exp, 2);\n \n-      if (warn_stringop_overflow)\n-\t{\n-\t  tree destsize = compute_objsize (dest,\n-\t\t\t\t\t   warn_stringop_overflow - 1);\n+  if (!check_nul_terminated_array (exp, src, len))\n+    return NULL_RTX;\n \n-\t  /* The number of bytes to write is LEN but check_access will also\n-\t     check SLEN if LEN's value isn't known.  */\n-\t  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src,\n-\t\t\tdestsize);\n-\t}\n+  /* The length of the source sequence.  */\n+  tree slen = c_strlen (src, 1);\n \n-      /* We must be passed a constant len and src parameter.  */\n-      if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))\n-\treturn NULL_RTX;\n+  if (warn_stringop_overflow)\n+    {\n+      tree destsize = compute_objsize (dest,\n+\t\t\t\t       warn_stringop_overflow - 1);\n \n-      slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n+      /* The number of bytes to write is LEN but check_access will also\n+\t check SLEN if LEN's value isn't known.  */\n+      check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src,\n+\t\t    destsize);\n+    }\n \n-      /* We're required to pad with trailing zeros if the requested\n-\t len is greater than strlen(s2)+1.  In that case try to\n-\t use store_by_pieces, if it fails, punt.  */\n-      if (tree_int_cst_lt (slen, len))\n-\t{\n-\t  unsigned int dest_align = get_pointer_alignment (dest);\n-\t  const char *p = c_getstr (src);\n-\t  rtx dest_mem;\n-\n-\t  if (!p || dest_align == 0 || !tree_fits_uhwi_p (len)\n-\t      || !can_store_by_pieces (tree_to_uhwi (len),\n-\t\t\t\t       builtin_strncpy_read_str,\n-\t\t\t\t       CONST_CAST (char *, p),\n-\t\t\t\t       dest_align, false))\n-\t    return NULL_RTX;\n+  /* We must be passed a constant len and src parameter.  */\n+  if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))\n+    return NULL_RTX;\n \n-\t  dest_mem = get_memory_rtx (dest, len);\n-\t  store_by_pieces (dest_mem, tree_to_uhwi (len),\n-\t\t\t   builtin_strncpy_read_str,\n-\t\t\t   CONST_CAST (char *, p), dest_align, false,\n-\t\t\t   RETURN_BEGIN);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), target);\n-\t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n-\t  return dest_mem;\n-\t}\n+  slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n+\n+  /* We're required to pad with trailing zeros if the requested\n+     len is greater than strlen(s2)+1.  In that case try to\n+     use store_by_pieces, if it fails, punt.  */\n+  if (tree_int_cst_lt (slen, len))\n+    {\n+      unsigned int dest_align = get_pointer_alignment (dest);\n+      const char *p = c_getstr (src);\n+      rtx dest_mem;\n+\n+      if (!p || dest_align == 0 || !tree_fits_uhwi_p (len)\n+\t  || !can_store_by_pieces (tree_to_uhwi (len),\n+\t\t\t\t   builtin_strncpy_read_str,\n+\t\t\t\t   CONST_CAST (char *, p),\n+\t\t\t\t   dest_align, false))\n+\treturn NULL_RTX;\n+\n+      dest_mem = get_memory_rtx (dest, len);\n+      store_by_pieces (dest_mem, tree_to_uhwi (len),\n+\t\t       builtin_strncpy_read_str,\n+\t\t       CONST_CAST (char *, p), dest_align, false,\n+\t\t       RETURN_BEGIN);\n+      dest_mem = force_operand (XEXP (dest_mem, 0), target);\n+      dest_mem = convert_memory_address (ptr_mode, dest_mem);\n+      return dest_mem;\n     }\n+\n   return NULL_RTX;\n }\n \n@@ -4822,6 +4878,13 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree arg2 = CALL_EXPR_ARG (exp, 1);\n+\n+  if (!check_nul_terminated_array (exp, arg1)\n+      || !check_nul_terminated_array (exp, arg2))\n+    return NULL_RTX;\n+\n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n   result = inline_expand_builtin_string_cmp (exp, target);\n@@ -4833,9 +4896,6 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   if (cmpstr_icode == CODE_FOR_nothing && cmpstrn_icode == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  tree arg1 = CALL_EXPR_ARG (exp, 0);\n-  tree arg2 = CALL_EXPR_ARG (exp, 1);\n-\n   unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n   unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n \n@@ -4941,6 +5001,14 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree arg2 = CALL_EXPR_ARG (exp, 1);\n+  tree arg3 = CALL_EXPR_ARG (exp, 2);\n+\n+  if (!check_nul_terminated_array (exp, arg1, arg3)\n+      || !check_nul_terminated_array (exp, arg2, arg3))\n+    return NULL_RTX;\n+\n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n   result = inline_expand_builtin_string_cmp (exp, target);\n@@ -4956,10 +5024,6 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n   tree len;\n \n-  tree arg1 = CALL_EXPR_ARG (exp, 0);\n-  tree arg2 = CALL_EXPR_ARG (exp, 1);\n-  tree arg3 = CALL_EXPR_ARG (exp, 2);\n-\n   unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n   unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n \n@@ -5954,6 +6018,26 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n   tree id, decl;\n   tree call;\n \n+  if (DECL_FUNCTION_CODE (fn) != BUILT_IN_FORK)\n+    {\n+      /* Detect unterminated path.  */\n+      if (!check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0)))\n+\treturn NULL_RTX;\n+\n+      /* Also detect unterminated first argument.  */\n+      switch (DECL_FUNCTION_CODE (fn))\n+\t{\n+\tcase BUILT_IN_EXECL:\n+\tcase BUILT_IN_EXECLE:\n+\tcase BUILT_IN_EXECLP:\n+\t  if (!check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0)))\n+\t    return NULL_RTX;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+\n   /* If we are not profiling, just call the function.  */\n   if (!profile_arc_flag)\n     return NULL_RTX;\n@@ -7604,11 +7688,49 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       break;\n \n     case BUILT_IN_STRCAT:\n-      target = expand_builtin_strcat (exp, target);\n+      target = expand_builtin_strcat (exp);\n       if (target)\n \treturn target;\n       break;\n \n+    case BUILT_IN_GETTEXT:\n+    case BUILT_IN_PUTS:\n+    case BUILT_IN_PUTS_UNLOCKED:\n+    case BUILT_IN_STRDUP:\n+      if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n+\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+      break;\n+\n+    case BUILT_IN_INDEX:\n+    case BUILT_IN_RINDEX:\n+    case BUILT_IN_STRCHR:\n+    case BUILT_IN_STRRCHR:\n+      if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+      break;\n+\n+    case BUILT_IN_FPUTS:\n+    case BUILT_IN_FPUTS_UNLOCKED:\n+      if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+\tcheck_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+      break;\n+\n+    case BUILT_IN_STRNDUP:\n+      if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+\tcheck_nul_terminated_array (exp,\n+\t\t\t\t    CALL_EXPR_ARG (exp, 0),\n+\t\t\t\t    CALL_EXPR_ARG (exp, 1));\n+      break;\n+\n+    case BUILT_IN_STRCASECMP:\n+    case BUILT_IN_STRSTR:\n+      if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+\t{\n+\t  check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 0));\n+\t  check_nul_terminated_array (exp, CALL_EXPR_ARG (exp, 1));\n+\t}\n+      break;\n+\n     case BUILT_IN_STRCPY:\n       target = expand_builtin_strcpy (exp, target);\n       if (target)\n@@ -9671,11 +9793,12 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n \n }\n \n-/* Fold a call to built-in function FNDECL with 2 arguments, ARG0 and ARG1.\n-   This function returns NULL_TREE if no simplification was possible.  */\n+/* Folds a call EXPR (which may be null) to built-in function FNDECL\n+   with 2 arguments, ARG0 and ARG1.  This function returns NULL_TREE\n+   if no simplification was possible.  */\n \n static tree\n-fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n+fold_builtin_2 (location_t loc, tree expr, tree fndecl, tree arg0, tree arg1)\n {\n   tree type = TREE_TYPE (TREE_TYPE (fndecl));\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -9703,13 +9826,13 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n       return fold_builtin_modf (loc, arg0, arg1, type);\n \n     case BUILT_IN_STRSPN:\n-      return fold_builtin_strspn (loc, arg0, arg1);\n+      return fold_builtin_strspn (loc, expr, arg0, arg1);\n \n     case BUILT_IN_STRCSPN:\n-      return fold_builtin_strcspn (loc, arg0, arg1);\n+      return fold_builtin_strcspn (loc, expr, arg0, arg1);\n \n     case BUILT_IN_STRPBRK:\n-      return fold_builtin_strpbrk (loc, arg0, arg1, type);\n+      return fold_builtin_strpbrk (loc, expr, arg0, arg1, type);\n \n     case BUILT_IN_EXPECT:\n       return fold_builtin_expect (loc, arg0, arg1, NULL_TREE, NULL_TREE);\n@@ -9827,13 +9950,14 @@ fold_builtin_3 (location_t loc, tree fndecl,\n   return NULL_TREE;\n }\n \n-/* Fold a call to built-in function FNDECL.  ARGS is an array of NARGS\n-   arguments.  IGNORE is true if the result of the\n-   function call is ignored.  This function returns NULL_TREE if no\n-   simplification was possible.  */\n+/* Folds a call EXPR (which may be null) to built-in function FNDECL.\n+   ARGS is an array of NARGS arguments.  IGNORE is true if the result\n+   of the function call is ignored.  This function returns NULL_TREE\n+   if no simplification was possible.  */\n \n-tree\n-fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool)\n+static tree\n+fold_builtin_n (location_t loc, tree expr, tree fndecl, tree *args,\n+\t\tint nargs, bool)\n {\n   tree ret = NULL_TREE;\n \n@@ -9846,7 +9970,7 @@ fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool)\n       ret = fold_builtin_1 (loc, fndecl, args[0]);\n       break;\n     case 2:\n-      ret = fold_builtin_2 (loc, fndecl, args[0], args[1]);\n+      ret = fold_builtin_2 (loc, expr, fndecl, args[0], args[1]);\n       break;\n     case 3:\n       ret = fold_builtin_3 (loc, fndecl, args[0], args[1], args[2]);\n@@ -9944,7 +10068,7 @@ fold_call_expr (location_t loc, tree exp, bool ignore)\n       else\n \t{\n \t  tree *args = CALL_EXPR_ARGP (exp);\n-\t  ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n+\t  ret = fold_builtin_n (loc, exp, fndecl, args, nargs, ignore);\n \t  if (ret)\n \t    return ret;\n \t}\n@@ -9982,7 +10106,7 @@ fold_builtin_call_array (location_t loc, tree,\n       if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n \treturn targetm.fold_builtin (fndecl, n, argarray, false);\n       else\n-\treturn fold_builtin_n (loc, fndecl, argarray, n, false);\n+\treturn fold_builtin_n (loc, NULL_TREE, fndecl, argarray, n, false);\n     }\n \n   return NULL_TREE;\n@@ -10134,51 +10258,53 @@ readonly_data_expr (tree exp)\n    form of the builtin function call.  */\n \n static tree\n-fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n+fold_builtin_strpbrk (location_t loc, tree expr, tree s1, tree s2, tree type)\n {\n   if (!validate_arg (s1, POINTER_TYPE)\n       || !validate_arg (s2, POINTER_TYPE))\n     return NULL_TREE;\n-  else\n-    {\n-      tree fn;\n-      const char *p1, *p2;\n \n-      p2 = c_getstr (s2);\n-      if (p2 == NULL)\n-\treturn NULL_TREE;\n+  if (!check_nul_terminated_array (expr, s1)\n+      || !check_nul_terminated_array (expr, s2))\n+    return NULL_TREE;\n \n-      p1 = c_getstr (s1);\n-      if (p1 != NULL)\n-\t{\n-\t  const char *r = strpbrk (p1, p2);\n-\t  tree tem;\n+  tree fn;\n+  const char *p1, *p2;\n \n-\t  if (r == NULL)\n-\t    return build_int_cst (TREE_TYPE (s1), 0);\n+  p2 = c_getstr (s2);\n+  if (p2 == NULL)\n+    return NULL_TREE;\n \n-\t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build_pointer_plus_hwi_loc (loc, s1, r - p1);\n-\t  return fold_convert_loc (loc, type, tem);\n-\t}\n+  p1 = c_getstr (s1);\n+  if (p1 != NULL)\n+    {\n+      const char *r = strpbrk (p1, p2);\n+      tree tem;\n \n-      if (p2[0] == '\\0')\n-\t/* strpbrk(x, \"\") == NULL.\n-\t   Evaluate and ignore s1 in case it had side-effects.  */\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, s1);\n+      if (r == NULL)\n+\treturn build_int_cst (TREE_TYPE (s1), 0);\n \n-      if (p2[1] != '\\0')\n-\treturn NULL_TREE;  /* Really call strpbrk.  */\n+      /* Return an offset into the constant string argument.  */\n+      tem = fold_build_pointer_plus_hwi_loc (loc, s1, r - p1);\n+      return fold_convert_loc (loc, type, tem);\n+    }\n \n-      fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n-      if (!fn)\n-\treturn NULL_TREE;\n+  if (p2[0] == '\\0')\n+    /* strpbrk(x, \"\") == NULL.\n+       Evaluate and ignore s1 in case it had side-effects.  */\n+    return omit_one_operand_loc (loc, type, integer_zero_node, s1);\n \n-      /* New argument list transforming strpbrk(s1, s2) to\n-\t strchr(s1, s2[0]).  */\n-      return build_call_expr_loc (loc, fn, 2, s1,\n-\t\t\t\t  build_int_cst (integer_type_node, p2[0]));\n-    }\n+  if (p2[1] != '\\0')\n+    return NULL_TREE;  /* Really call strpbrk.  */\n+\n+  fn = builtin_decl_implicit (BUILT_IN_STRCHR);\n+  if (!fn)\n+    return NULL_TREE;\n+\n+  /* New argument list transforming strpbrk(s1, s2) to\n+     strchr(s1, s2[0]).  */\n+  return build_call_expr_loc (loc, fn, 2, s1,\n+\t\t\t      build_int_cst (integer_type_node, p2[0]));\n }\n \n /* Simplify a call to the strspn builtin.  S1 and S2 are the arguments\n@@ -10200,23 +10326,25 @@ fold_builtin_strpbrk (location_t loc, tree s1, tree s2, tree type)\n    form of the builtin function call.  */\n \n static tree\n-fold_builtin_strspn (location_t loc, tree s1, tree s2)\n+fold_builtin_strspn (location_t loc, tree expr, tree s1, tree s2)\n {\n   if (!validate_arg (s1, POINTER_TYPE)\n       || !validate_arg (s2, POINTER_TYPE))\n     return NULL_TREE;\n-  else\n-    {\n-      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n \n-      /* If either argument is \"\", return NULL_TREE.  */\n-      if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n-\t/* Evaluate and ignore both arguments in case either one has\n-\t   side-effects.  */\n-\treturn omit_two_operands_loc (loc, size_type_node, size_zero_node,\n+  if (!check_nul_terminated_array (expr, s1)\n+      || !check_nul_terminated_array (expr, s2))\n+    return NULL_TREE;\n+\n+  const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n+\n+  /* If either argument is \"\", return NULL_TREE.  */\n+  if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n+    /* Evaluate and ignore both arguments in case either one has\n+       side-effects.  */\n+    return omit_two_operands_loc (loc, size_type_node, size_zero_node,\n \t\t\t\t  s1, s2);\n-      return NULL_TREE;\n-    }\n+  return NULL_TREE;\n }\n \n /* Simplify a call to the strcspn builtin.  S1 and S2 are the arguments\n@@ -10238,38 +10366,40 @@ fold_builtin_strspn (location_t loc, tree s1, tree s2)\n    form of the builtin function call.  */\n \n static tree\n-fold_builtin_strcspn (location_t loc, tree s1, tree s2)\n+fold_builtin_strcspn (location_t loc, tree expr, tree s1, tree s2)\n {\n   if (!validate_arg (s1, POINTER_TYPE)\n       || !validate_arg (s2, POINTER_TYPE))\n     return NULL_TREE;\n-  else\n+\n+  if (!check_nul_terminated_array (expr, s1)\n+      || !check_nul_terminated_array (expr, s2))\n+    return NULL_TREE;\n+\n+  /* If the first argument is \"\", return NULL_TREE.  */\n+  const char *p1 = c_getstr (s1);\n+  if (p1 && *p1 == '\\0')\n     {\n-      /* If the first argument is \"\", return NULL_TREE.  */\n-      const char *p1 = c_getstr (s1);\n-      if (p1 && *p1 == '\\0')\n-\t{\n-\t  /* Evaluate and ignore argument s2 in case it has\n-\t     side-effects.  */\n-\t  return omit_one_operand_loc (loc, size_type_node,\n+      /* Evaluate and ignore argument s2 in case it has\n+\t side-effects.  */\n+      return omit_one_operand_loc (loc, size_type_node,\n \t\t\t\t   size_zero_node, s2);\n-\t}\n+    }\n \n-      /* If the second argument is \"\", return __builtin_strlen(s1).  */\n-      const char *p2 = c_getstr (s2);\n-      if (p2 && *p2 == '\\0')\n-\t{\n-\t  tree fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n+  /* If the second argument is \"\", return __builtin_strlen(s1).  */\n+  const char *p2 = c_getstr (s2);\n+  if (p2 && *p2 == '\\0')\n+    {\n+      tree fn = builtin_decl_implicit (BUILT_IN_STRLEN);\n \n-\t  /* If the replacement _DECL isn't initialized, don't do the\n-\t     transformation.  */\n-\t  if (!fn)\n-\t    return NULL_TREE;\n+      /* If the replacement _DECL isn't initialized, don't do the\n+\t transformation.  */\n+      if (!fn)\n+\treturn NULL_TREE;\n \n-\t  return build_call_expr_loc (loc, fn, 1, s1);\n-\t}\n-      return NULL_TREE;\n+      return build_call_expr_loc (loc, fn, 1, s1);\n     }\n+  return NULL_TREE;\n }\n \n /* Fold the next_arg or va_start call EXP. Returns true if there was an error\n@@ -11112,7 +11242,7 @@ fold_call_stmt (gcall *stmt, bool ignore)\n         }\n       else\n \t{\n-\t  ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n+\t  ret = fold_builtin_n (loc, NULL_TREE, fndecl, args, nargs, ignore);\n \t  if (ret)\n \t    {\n \t      /* Propagate location information from original call to"}, {"sha": "d9e27ca16aa0b2a9391e824bdcbb49d4d47cc2e6", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -91,7 +91,7 @@ struct c_strlen_data\n   tree minlen;\n   tree maxlen;\n   tree maxbound;\n-  /* When non-null, NONSTR refers to the declaration known to store\n+  /* When non-null, DECL refers to the declaration known to store\n      an unterminated constant character array, as in:\n      const char s[] = { 'a', 'b', 'c' };\n      It is used to diagnose uses of such arrays in functions such as\n@@ -125,7 +125,6 @@ extern tree fold_builtin_expect (location_t, tree, tree, tree, tree);\n extern bool avoid_folding_inline_builtin (tree);\n extern tree fold_call_expr (location_t, tree, bool);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n-extern tree fold_builtin_n (location_t, tree, tree *, int, bool);\n extern bool validate_gimple_arglist (const gcall *, ...);\n extern rtx default_expand_builtin (tree, rtx, rtx, machine_mode, int);\n extern bool fold_builtin_next_arg (tree, bool);\n@@ -148,6 +147,7 @@ extern bool target_char_cst_p (tree t, char *p);\n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);\n \n+bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n extern void warn_string_no_nul (location_t, const char *, tree, tree);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);"}, {"sha": "fadc422aed8fa95e89d74c2239a52bdea7e76a0e", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -1899,6 +1899,11 @@ gimple_fold_builtin_strchr (gimple_stmt_iterator *gsi, bool is_strrchr)\n   if (!gimple_call_lhs (stmt))\n     return false;\n \n+  /* Avoid folding if the first argument is not a nul-terminated array.\n+     Defer warning until later.  */\n+  if (!check_nul_terminated_array (NULL_TREE, str))\n+    return false;\n+\n   if ((p = c_getstr (str)) && target_char_cst_p (c, &ch))\n     {\n       const char *p1 = is_strrchr ? strrchr (p, ch) : strchr (p, ch);\n@@ -1973,18 +1978,23 @@ static bool\n gimple_fold_builtin_strstr (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n+  if (!gimple_call_lhs (stmt))\n+    return false;\n+\n   tree haystack = gimple_call_arg (stmt, 0);\n   tree needle = gimple_call_arg (stmt, 1);\n-  const char *p, *q;\n \n-  if (!gimple_call_lhs (stmt))\n+  /* Avoid folding if either argument is not a nul-terminated array.\n+     Defer warning until later.  */\n+  if (!check_nul_terminated_array (NULL_TREE, haystack)\n+      || !check_nul_terminated_array (NULL_TREE, needle))\n     return false;\n \n-  q = c_getstr (needle);\n+  const char *q = c_getstr (needle);\n   if (q == NULL)\n     return false;\n \n-  if ((p = c_getstr (haystack)))\n+  if (const char *p = c_getstr (haystack))\n     {\n       const char *r = strstr (p, q);\n "}, {"sha": "96c0f899bce722ea563c89d12c32e75b4b588733", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -1,3 +1,9 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/88226\n+\t* gcc.dg/Wstringop-overflow-22.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-fprintf-warn-1.c: Remove xfails.\n+\n 2019-11-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/92501"}, {"sha": "a81ab99d72451f86d88c934a964f4f863495dba4", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-22.c", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -0,0 +1,263 @@\n+/* { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+\n+#define NULL (void*)0\n+\n+const char a[] = { 'a', 'b', 'c', 'd' };\n+const char b[] = { 'a', '\\0', 'c', '\\0', 'e' };\n+\n+#define CONCAT(a, b) a ## b\n+#define CAT(a, b)    CONCAT (a, b)\n+\n+typedef struct FILE FILE;\n+extern FILE *fp;\n+\n+extern char *d;\n+extern const char *s;\n+extern int n;\n+\n+#define T(func, ...)\t\t\t\t\t\t\\\n+  __attribute__ ((noipa)) void\t\t\t\t\t\\\n+  CAT (test_ ## func, __LINE__) (void)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    sink (0, __builtin_ ## func (__VA_ARGS__), d, s, n);\t\\\n+  } typedef void dummy_type\n+\n+void sink (void*, ...);\n+\n+\n+// Exercise string functions.\n+T (index, a, 'x');          // { dg-warning \"missing terminating nul\" \"index\" }\n+T (index, a, *s);           // { dg-warning \"missing terminating nul\" \"index\" }\n+\n+T (index, b, '0');\n+T (index, b + 1, '1');\n+T (index, b + 2, '2');\n+T (index, b + 3, '3');\n+T (index, b + 4, '4');      // { dg-warning \"missing terminating nul\" \"index\" }\n+\n+T (rindex, a, 'x');         // { dg-warning \"missing terminating nul\" \"rindex\" }\n+T (rindex, a, *s);          // { dg-warning \"missing terminating nul\" \"rindex\" }\n+\n+T (rindex, b, '0');\n+T (rindex, b + 1, '1');\n+T (rindex, b + 2, '2');\n+T (rindex, b + 3, '3');\n+T (rindex, b + 4, '4');     // { dg-warning \"missing terminating nul\" \"rindex\" }\n+\n+T (stpcpy, d, a);           // { dg-warning \"missing terminating nul\" \"stpcpy\" }\n+\n+T (stpncpy, d, a, 4);\n+T (stpncpy, d, a, 5);       // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+T (stpncpy, d, a, n);\n+\n+T (stpncpy, d, a + n, 4);\n+T (stpncpy, d, a + n, 5);   // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+\n+T (stpncpy, d, b, 4);\n+T (stpncpy, d, b, 5);\n+T (stpncpy, d, b, n);\n+\n+T (stpncpy, d, b + 1, 4);\n+T (stpncpy, d, b + 1, 5);\n+T (stpncpy, d, b + 1, n);\n+\n+T (stpncpy, d, b + 3, 4);\n+T (stpncpy, d, b + 3, 5);\n+T (stpncpy, d, b + 3, n);\n+\n+T (stpncpy, d, b + 4, 1);\n+T (stpncpy, d, b + 4, 2);   // { dg-warning \"missing terminating nul\" \"stpncpy\" }\n+T (stpncpy, d, b + 4, n);\n+/* The following might be worth warning about since it's only safe with\n+   n < 4.  */\n+T (stpncpy, d, b + n, 5);\n+\n+T (strcasecmp, a, \"ab\");    // { dg-warning \"missing terminating nul\" \"strcasecmp\" }\n+T (strcasecmp, a, s);       // { dg-warning \"missing terminating nul\" \"strcasecmp\" }\n+T (strcasecmp, a, b);       // { dg-warning \"missing terminating nul\" \"strcasecmp\" }\n+T (strcasecmp, b, b + 1);\n+T (strcasecmp, b, b + 2);\n+T (strcasecmp, b, b + 3);\n+T (strcasecmp, b, b + 4);   // { dg-warning \"missing terminating nul\" \"strcasecmp\" }\n+\n+T (strcat, d, a);           // { dg-warning \"missing terminating nul\" \"strcat\" }\n+\n+T (strncat, d, a, 4);\n+T (strncat, d, a, 5);       // { dg-warning \"missing terminating nul\" \"strncat\" }\n+T (strncat, d, a, n);\n+\n+T (strncat, d, b, n);\n+T (strncat, d, b + 1, n);\n+T (strncat, d, b + 2, n);\n+T (strncat, d, b + 3, n);\n+T (strncat, d, b + 4, 0);\n+T (strncat, d, b + 4, 1);\n+T (strncat, d, b + 4, 2);   // { dg-warning \"missing terminating nul\" \"strncat\" }\n+/* The following should probably trigger a warning since it's only safe\n+   when n < 2, makes little sense with n == 0, and not much more with\n+   n == 1.  */\n+T (strncat, d, b + 4, n);   // { dg-warning \"missing terminating nul\" \"strncat\" { xfail *-*-* } }\n+\n+T (strchr, a, 'x');         // { dg-warning \"missing terminating nul\" \"strchr\" }\n+T (strchr, a, *s);          // { dg-warning \"missing terminating nul\" \"strchr\" }\n+\n+T (strcmp, a, \"ab\");        // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+T (strcmp, \"bc\", a);        // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+T (strcmp, a, s);           // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+T (strcmp, s, a);           // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+\n+T (strcmp, a, b);           // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+/* Even though most likely safe in reality because b[1] is nul,\n+   the following is strictly undefined because a is not a string.\n+   The warning is not issued because GCC folds the call to (int)*a.  */\n+T (strcmp, a, b + 1);       // { dg-warning \"missing terminating nul\" \"bug\" { xfail *-*-* } }\n+\n+T (strncmp, a, \"ab\", 4);\n+T (strncmp, \"bc\", a, 4);\n+T (strncmp, a, a, 4);\n+T (strncmp, a, s, 4);\n+T (strncmp, s, a, 4);\n+\n+/* The warning below is not issued because GCC folds strncmp calls with\n+   the same arguments to zero before it checks for the missing nul.  */\n+T (strncmp, a, a, 5);       // { dg-warning \"missing terminating nul\" \"pr92624\" { xfail *-*-*} }\n+T (strncmp, a, s, 5);       // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+T (strncmp, s, a, 5);       // { dg-warning \"missing terminating nul\" \"strcmp\" }\n+\n+T (strcpy, d, a);           // { dg-warning \"missing terminating nul\" \"strcpy\" }\n+\n+T (strcspn, a, s);          // { dg-warning \"missing terminating nul\" \"strcspn\" }\n+T (strcspn, s, a);          // { dg-warning \"missing terminating nul\" \"strcspn\" }\n+\n+T (strspn, a, s);           // { dg-warning \"missing terminating nul\" \"strcspn\" }\n+T (strspn, s, a);           // { dg-warning \"missing terminating nul\" \"strcspn\" }\n+\n+T (strdup, a);              // { dg-warning \"missing terminating nul\" \"strdup\" }\n+\n+T (strndup, a, 4);\n+T (strndup, a, 5);          // { dg-warning \"missing terminating nul\" \"strndup\" }\n+T (strndup, b + 3, 2);\n+T (strndup, b + 4, 1);\n+T (strndup, b + 4, 2);      // { dg-warning \"missing terminating nul\" \"strndup\" }\n+\n+T (strlen, a);              // { dg-warning \"missing terminating nul\" \"strlen\" }\n+\n+T (strnlen, a, 4);\n+T (strnlen, a, 5);          // { dg-warning \"specified bound 5 exceeds the size 4 of unterminated array\" \"strnlen\" }\n+T (strnlen, a, n);\n+\n+T (strpbrk, s, a);          // { dg-warning \"missing terminating nul\" \"strpbrk\" }\n+\n+T (strrchr, a, 'x');        // { dg-warning \"missing terminating nul\" \"strrchr\" }\n+T (strrchr, a, *s);         // { dg-warning \"missing terminating nul\" \"strrchr\" }\n+\n+T (strstr, a, \"cde\");       // { dg-warning \"missing terminating nul\" \"strstr\" }\n+T (strstr, a, s);           // { dg-warning \"missing terminating nul\" \"strstr\" }\n+\n+\n+// Exercise a few string checking functions.\n+T (__stpcpy_chk, d, a, -1);           // { dg-warning \"missing terminating nul\" \"stpcpy\" }\n+\n+\n+T (__stpncpy_chk, d, a, 4, -1);\n+T (__stpncpy_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, a, n, -1);\n+\n+T (__stpncpy_chk, d, a + n, 4, -1);\n+T (__stpncpy_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+\n+T (__stpncpy_chk, d, b, 4, -1);\n+T (__stpncpy_chk, d, b, 5, -1);\n+T (__stpncpy_chk, d, b, n, -1);\n+\n+T (__stpncpy_chk, d, b + 1, 4, -1);\n+T (__stpncpy_chk, d, b + 1, 5, -1);\n+T (__stpncpy_chk, d, b + 1, n, -1);\n+\n+T (__stpncpy_chk, d, b + 3, 4, -1);\n+T (__stpncpy_chk, d, b + 3, 5, -1);\n+T (__stpncpy_chk, d, b + 3, n, -1);\n+\n+T (__stpncpy_chk, d, b + 4, 1, -1);\n+T (__stpncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"stpncpy_chk\" }\n+T (__stpncpy_chk, d, b + 4, n, -1);\n+\n+\n+T (__strncat_chk, d, a, 4, -1);\n+T (__strncat_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+T (__strncat_chk, d, a, n, -1);\n+\n+T (__strncat_chk, d, a + n, 4, -1);\n+T (__strncat_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+\n+T (__strncat_chk, d, b, 4, -1);\n+T (__strncat_chk, d, b, 5, -1);\n+T (__strncat_chk, d, b, n, -1);\n+\n+T (__strncat_chk, d, b + 1, 4, -1);\n+T (__strncat_chk, d, b + 1, 5, -1);\n+T (__strncat_chk, d, b + 1, n, -1);\n+\n+T (__strncat_chk, d, b + 3, 4, -1);\n+T (__strncat_chk, d, b + 3, 5, -1);\n+T (__strncat_chk, d, b + 3, n, -1);\n+\n+T (__strncat_chk, d, b + 4, 1, -1);\n+T (__strncat_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"strncat_chk\" }\n+T (__strncat_chk, d, b + 4, n, -1);\n+\n+\n+T (__strncpy_chk, d, a, 4, -1);\n+T (__strncpy_chk, d, a, 5, -1);       // { dg-warning \"missing terminating nul\" \"strncpy_chk\" }\n+T (__strncpy_chk, d, a, n, -1);\n+\n+T (__strncpy_chk, d, a + n, 4, -1);\n+T (__strncpy_chk, d, a + n, 5, -1);   // { dg-warning \"missing terminating nul\" \"strncpy_chk\" }\n+\n+T (__strncpy_chk, d, b, 4, -1);\n+T (__strncpy_chk, d, b, 5, -1);\n+T (__strncpy_chk, d, b, n, -1);\n+\n+T (__strncpy_chk, d, b + 1, 4, -1);\n+T (__strncpy_chk, d, b + 1, 5, -1);\n+T (__strncpy_chk, d, b + 1, n, -1);\n+\n+T (__strncpy_chk, d, b + 3, 4, -1);\n+T (__strncpy_chk, d, b + 3, 5, -1);\n+T (__strncpy_chk, d, b + 3, n, -1);\n+\n+T (__strncpy_chk, d, b + 4, 1, -1);\n+T (__strncpy_chk, d, b + 4, 2, -1);   // { dg-warning \"missing terminating nul\" \"strncpy\" }\n+T (__strncpy_chk, d, b + 4, n, -1);\n+\n+\n+// Exercise some stdio functions.\n+T (printf, a);              // { dg-warning \"unterminated format string\" \"printf\" }\n+T (printf, \"%s\", a);        // { dg-warning \"not a nul-terminated string\" \"printf\" }\n+T (sprintf, d, \"%s\", a);    // { dg-warning \"not a nul-terminated string\" \"sprintf\" }\n+T (snprintf, d, n, \"%s\", a);    // { dg-warning \"not a nul-terminated string\" \"sprintf\" }\n+\n+T (__sprintf_chk, d, 0, -1, \"%s\", a);      // { dg-warning \"not a nul-terminated string\" \"sprintf\" }\n+T (__snprintf_chk, d, n, 0, -1, \"%s\", a);  // { dg-warning \"not a nul-terminated string\" \"sprintf\" }\n+\n+T (fputs, a, fp);           // { dg-warning \"missing terminating nul\" \"fputs\" }\n+T (fputs_unlocked, a, fp);  // { dg-warning \"missing terminating nul\" \"fputs_unlocked\" }\n+T (puts, a);                // { dg-warning \"missing terminating nul\" \"puts\" }\n+T (puts_unlocked, a);       // { dg-warning \"missing terminating nul\" \"puts_unlocked\" }\n+\n+\n+\n+// Exerise exec functions.\n+T (execl, a, s, NULL);      // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execl, a, s, NULL);      // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execle, a, s, NULL, NULL);   // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execlp, a, s, NULL);     // { dg-warning \"missing terminating nul\" \"execl\" }\n+\n+T (execv, a, &d);           // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execve, a, &d, &d);      // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execvp, a, &d);          // { dg-warning \"missing terminating nul\" \"execl\" }\n+\n+T (gettext, a);             // { dg-warning \"missing terminating nul\" \"gettext\" }\n+\n+T (strfmon, d, n, a);       // { dg-warning \"unterminated format string\" \"strfmon\" }"}, {"sha": "0b06c0da00da741d0ecfe6c8f82ebfa1ddc368c1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-warn-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-warn-1.c?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -84,8 +84,8 @@ void test_fprintf_s_const (int width)\n   if (nulptr)\n     T (\"%s\", nulptr);\n \n-  T (\"%s\", &chr_no_nul);          /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr88226\" { xfail *-*-* } } */\n-  T (\"%s\", arr_no_nul);           /* { dg-warning \".%s. directive argument is not a nul-terminated string\" \"pr88226\" { xfail *-*-* } } */\n+  T (\"%s\", &chr_no_nul);          /* { dg-warning \".%s. directive argument is not a nul-terminated string|argument missing terminating nul\" } */\n+  T (\"%s\", arr_no_nul);           /* { dg-warning \".%s. directive argument is not a nul-terminated string|argument missing terminating nul\" } */\n \n   /* Verify that output in excess of INT_MAX bytes is diagnosed even\n      when the size of the destination object is unknown.  */\n@@ -117,7 +117,7 @@ void test_fprintf_ls_const (int width)\n     T (\"%ls\", nulptr);\n \n   T (\"%ls\", &wchr_no_nul);        /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" } */\n-  T (\"%ls\", warr_no_nul);         /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr88211\" { xfail *-*-* } } */\n+  T (\"%ls\", warr_no_nul);         /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" \"pr88226\" { xfail *-*-* } } */\n \n   /* Verify that output in excess of INT_MAX bytes is diagnosed even\n      when the size of the destination object is unknown.  */"}, {"sha": "06fa99eb5ac79d698982c2abad6e5b8f6f6a682c", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5338fb359ea3480d6ed37bbc52fe2df49b82fb9/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=b5338fb359ea3480d6ed37bbc52fe2df49b82fb9", "patch": "@@ -1946,8 +1946,6 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n static void\n handle_builtin_strchr (gimple_stmt_iterator *gsi)\n {\n-  int idx;\n-  tree src;\n   gimple *stmt = gsi_stmt (*gsi);\n   tree lhs = gimple_call_lhs (stmt);\n \n@@ -1957,8 +1955,14 @@ handle_builtin_strchr (gimple_stmt_iterator *gsi)\n   if (!integer_zerop (gimple_call_arg (stmt, 1)))\n     return;\n \n-  src = gimple_call_arg (stmt, 0);\n-  idx = get_stridx (src);\n+  tree src = gimple_call_arg (stmt, 0);\n+\n+  /* Avoid folding if the first argument is not a nul-terminated array.\n+     Defer warning until later.  */\n+  if (!check_nul_terminated_array (NULL_TREE, src))\n+    return;\n+\n+  int idx = get_stridx (src);\n   if (idx)\n     {\n       strinfo *si = NULL;\n@@ -3794,11 +3798,11 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n \n   /* For strncmp set to the the value of the third argument if known.  */\n   HOST_WIDE_INT bound = -1;\n-\n+  tree len = NULL_TREE;\n   /* Extract the strncmp bound.  */\n   if (gimple_call_num_args (stmt) == 3)\n     {\n-      tree len = gimple_call_arg (stmt, 2);\n+      len = gimple_call_arg (stmt, 2);\n       if (tree_fits_shwi_p (len))\n         bound = tree_to_shwi (len);\n \n@@ -3807,6 +3811,12 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n \treturn false;\n     }\n \n+  /* Avoid folding if either argument is not a nul-terminated array.\n+     Defer warning until later.  */\n+  if (!check_nul_terminated_array (NULL_TREE, arg1, len)\n+      || !check_nul_terminated_array (NULL_TREE, arg2, len))\n+    return false;\n+\n   {\n     /* Set to the length of one argument (or its complement if it's\n        the lower bound of a range) and the size of the array storing"}]}