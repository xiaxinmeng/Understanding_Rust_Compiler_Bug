{"sha": "3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YzZjIxMjQzYmM2YjM0NDY5NTBiMWQ4YTAwZTc3MzlkOWE3ZjdkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-03-09T18:55:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-03-09T18:55:27Z"}, "message": "i386.h (FIRST_PSEUDO_REGISTER): Set to 53.\n\n\t* i386.h (FIRST_PSEUDO_REGISTER): Set to 53.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ONES): Add extended ones.\n\t(CONDITIONAL_REGISTER_USAGE): Set proper values according to TARGET_64BIT.\n\t(FIRST_REX_INT_REG, LAST_REX_INT_REG, FIRST_REX_SSE_REG, LAST_REX_SSE_REG):\n\tdefine.\n\t(enum reg_class): Add 'LEGACY_REGS'\n\t(REG_CLASS_CONTENTS): Likewise; add extended registers.\n\t(SSE_REGNO_P): Recognize extended registers.\n\t(ANY_QI_REG_P, REX_INT_REGNO_P, REX_INT_REG_P): New.\n\t(REG_CLASS_FROM_LETTER): Add 'R' and 'Q'.\n\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P, REG_OK_FOR_BASE_NONSTRICT_P):\n\t Recognize REX registers.\n\t(REG_OK_FOR_STRREG_NONSTRICT_P, REG_OK_FOR_STRREG_STRICT_P,\n\t REG_OK_FOR_STRREG_P): Remove.\n\t(HI_REGISTER_NAMES): Add extended registers.\n\t(ADDITIONAL_REGISTER_NAMES): Likewise.\n\t(QI_REGISTER_NAMES): Add 8bit extended registers.\n\t(DEBUG_REG): Support extended registers.\n\t* i386.c (regclass_map): Add extended registers.\n\t(dbx_register-map): Likewise.\n\t(svr4_dbx_register_map): Likewise.\n\t(print_reg): Support extended registers.\n\t(print_operand): Support 64bit operands.\n\nFrom-SVN: r40348", "tree": {"sha": "85588963d1b507f26df9c41e313ad13ae3d3fd28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85588963d1b507f26df9c41e313ad13ae3d3fd28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/comments", "author": null, "committer": null, "parents": [{"sha": "65d9c0ab20ab897d1d850444b6306409c756bcff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d9c0ab20ab897d1d850444b6306409c756bcff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d9c0ab20ab897d1d850444b6306409c756bcff"}], "stats": {"total": 276, "additions": 215, "deletions": 61}, "files": [{"sha": "d21a92461bec76d3180b50a3f352a8b16c9e764b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "patch": "@@ -1,3 +1,29 @@\n+Fri Mar  9 19:52:52 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (FIRST_PSEUDO_REGISTER): Set to 53.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ONES): Add extended ones.\n+\t(CONDITIONAL_REGISTER_USAGE): Set proper values according to TARGET_64BIT.\n+\t(FIRST_REX_INT_REG, LAST_REX_INT_REG, FIRST_REX_SSE_REG, LAST_REX_SSE_REG):\n+\tdefine.\n+\t(enum reg_class): Add 'LEGACY_REGS'\n+\t(REG_CLASS_CONTENTS): Likewise; add extended registers.\n+\t(SSE_REGNO_P): Recognize extended registers.\n+\t(ANY_QI_REG_P, REX_INT_REGNO_P, REX_INT_REG_P): New.\n+\t(REG_CLASS_FROM_LETTER): Add 'R' and 'Q'.\n+\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P, REG_OK_FOR_BASE_NONSTRICT_P):\n+\t Recognize REX registers.\n+\t(REG_OK_FOR_STRREG_NONSTRICT_P, REG_OK_FOR_STRREG_STRICT_P,\n+\t REG_OK_FOR_STRREG_P): Remove.\n+\t(HI_REGISTER_NAMES): Add extended registers.\n+\t(ADDITIONAL_REGISTER_NAMES): Likewise.\n+\t(QI_REGISTER_NAMES): Add 8bit extended registers.\n+\t(DEBUG_REG): Support extended registers.\n+\t* i386.c (regclass_map): Add extended registers.\n+\t(dbx_register-map): Likewise.\n+\t(svr4_dbx_register_map): Likewise.\n+\t(print_reg): Support extended registers.\n+\t(print_operand): Support 64bit operands.\n+\n Fri Mar  9 19:37:46 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Set to 128bit for x86_64"}, {"sha": "b5ecd7f79c4ec9eee9631e0c8a0e056674fed160", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "patch": "@@ -411,9 +411,11 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n {\n   0, 2, 1, 3, 6, 7, 5, 4,\t\t/* general regs */\n   11, 12, 13, 14, 15, 16, 17, 18,\t/* fp regs */\n-  -1, 9, -1, -1,\t\t\t/* arg, flags, fpsr, dir */\n+  -1, 9, -1, -1, -1,\t\t\t/* arg, flags, fpsr, dir, frame */\n   21, 22, 23, 24, 25, 26, 27, 28,\t/* SSE registers */\n   29, 30, 31, 32, 33, 34, 35, 36,\t/* MMX registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extemded integer registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extemded SSE registers */\n };\n \n /* Test and compare insns in i386.md store the information needed to\n@@ -3315,6 +3317,8 @@ print_reg (x, code, file)\n     code = 1;\n   else if (code == 'k')\n     code = 4;\n+  else if (code == 'q')\n+    code = 8;\n   else if (code == 'y')\n     code = 3;\n   else if (code == 'h')\n@@ -3324,6 +3328,33 @@ print_reg (x, code, file)\n   else\n     code = GET_MODE_SIZE (GET_MODE (x));\n \n+  /* Irritatingly, AMD extended registers use different naming convention\n+     from the normal registers.  */\n+  if (REX_INT_REG_P (x))\n+    {\n+      switch (code)\n+\t{\n+\t  case 5:\n+\t    error (\"Extended registers have no high halves\\n\");\n+\t    break;\n+\t  case 1:\n+\t    fprintf (file, \"r%ib\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    break;\n+\t  case 2:\n+\t    fprintf (file, \"r%iw\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    break;\n+\t  case 4:\n+\t    fprintf (file, \"r%id\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    break;\n+\t  case 8:\n+\t    fprintf (file, \"r%i\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    break;\n+\t  default:\n+\t    error (\"Unsupported operand size for extended register.\\n\");\n+\t    break;\n+\t}\n+      return;\n+    }\n   switch (code)\n     {\n     case 5:\n@@ -3336,11 +3367,11 @@ print_reg (x, code, file)\n \t  break;\n \t}\n       /* FALLTHRU */\n-    case 4:\n     case 8:\n+    case 4:\n     case 12:\n       if (! ANY_FP_REG_P (x))\n-\tputc ('e', file);\n+\tputc (code == 8 ? 'r' : 'e', file);\n       /* FALLTHRU */\n     case 16:\n     case 2:\n@@ -3372,6 +3403,7 @@ print_reg (x, code, file)\n \t%b0 would print %al if operands[0] is reg 0.\n    w --  likewise, print the HImode name of the register.\n    k --  likewise, print the SImode name of the register.\n+   q --  likewise, print the DImode name of the register.\n    h --  print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n    y --  print \"st(0)\" instead of \"st\" as a register.\n    m --  print \"st(n)\" as an mmx register.\n@@ -3495,6 +3527,7 @@ print_operand (file, x, code)\n \tcase 'b':\n \tcase 'w':\n \tcase 'k':\n+\tcase 'q':\n \tcase 'h':\n \tcase 'y':\n \tcase 'm':"}, {"sha": "1d06c985979ef138c4ac573f85c8dc6af6956bc2", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 153, "deletions": 58, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3f3f21243bc6b3446950b1d8a00e7739d9a7f7d5", "patch": "@@ -696,7 +696,7 @@ extern int ix86_arch;\n    eliminated during reloading in favor of either the stack or frame\n    pointer. */\n \n-#define FIRST_PSEUDO_REGISTER 37\n+#define FIRST_PSEUDO_REGISTER 53\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -705,33 +705,51 @@ extern int ix86_arch;\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n-   On the 80386, the stack pointer is such, as is the arg pointer. */\n+   On the 80386, the stack pointer is such, as is the arg pointer.\n+ \n+   The value is an mask - bit 1 is set for fixed registers\n+   for 32bit target, while 2 is set for fixed registers for 64bit.\n+   Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n+ */\n #define FIXED_REGISTERS\t\t\t\t\t\t\\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n-{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,\t\\\n+{  0, 0, 0, 0, 0, 0, 0, 3, 0,  0,  0,  0,  0,  0,  0,  0,\t\\\n /*arg,flags,fpsr,dir,frame*/\t\t\t\t\t\\\n-    1,    1,   1,  1,    1,\t\t\t\t\t\\\n+    3,    3,   3,  3,    3,\t\t\t\t\t\\\n /*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n      0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n /*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n-     0,   0,   0,   0,   0,   0,   0,   0}\n+     0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n+/*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n+     1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n+/*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n+     1,   1,    1,    1,    1,    1,    1,    1}\n+ \n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-\n+   Aside from that, you can include as many other registers as you like. \n+ \n+   The value is an mask - bit 1 is set for call used\n+   for 32bit target, while 2 is set for call used for 64bit.\n+   Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n+*/\n #define CALL_USED_REGISTERS\t\t\t\t\t\\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7*/\t\\\n-{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,\t\\\n+{  3, 3, 3, 0, 2, 2, 0, 3, 3,  3,  3,  3,  3,  3,  3,  3,\t\\\n /*arg,flags,fpsr,dir,frame*/\t\t\t\t\t\\\n-     1,   1,   1,  1,    1,\t\t\t\t\t\\\n+     3,   3,   3,  3,    3,\t\t\t\t\t\\\n /*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n-     1,   1,   1,   1,   1,  1,    1,   1,\t\t\t\\\n+     3,   3,   3,   3,   3,  3,    3,   3,\t\t\t\\\n /*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n-     1,   1,   1,   1,   1,   1,   1,   1}\n+     3,   3,   3,   3,   3,   3,   3,   3,\t\t\t\\\n+/*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n+     3,   3,   3,   3,   1,   1,   1,   1,\t\t\t\\\n+/*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n+     3,   3,    3,    3,    3,    3,    3,    3}\t\t\\\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -753,20 +771,35 @@ extern int ix86_arch;\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n #define REG_ALLOC_ORDER \t\t\t\t\t\\\n-/*ax,dx,cx,bx,si,di,bp,sp*/\t\t\t\t\t\\\n-{  0, 1, 2, 3, 4, 5, 6, 7,\t\t\t\t\t\\\n-/*,arg,cc,fpsr,dir,frame*/\t\t\t\t\t\\\n-     16,17, 18, 19,   20,\t\t\t\t\t\\\n+/*ax,dx,cx,*/\t\t\t\t\t\t\t\\\n+{  0, 1, 2,\t\t\t\t\t\t\t\\\n+/* bx,si,di,bp,sp,*/\t\t\t\t\t\t\\\n+   3, 4, 5, 6, 7,\t\t\t\t\t\t\\\n+/*r8,r9,r10,r11,*/\t\t\t\t\t\t\\\n+  37,38, 39, 40,\t\t\t\t\t\t\\\n+/*r12,r15,r14,r13*/\t\t\t\t\t\t\\\n+  41, 44, 43, 42,\t\t\t\t\t\t\\\n /*xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7*/\t\t\t\\\n     21,  22,  23,  24,  25,  26,  27,  28,\t\t\t\\\n+/*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n+    45,  46,   47,   48,   49,   50,   51,   52,\t\t\\\n /*st,st1,st2,st3,st4,st5,st6,st7*/\t\t\t\t\\\n    8,  9, 10, 11, 12, 13, 14, 15,\t\t\t\t\\\n+/*,arg,cc,fpsr,dir,frame*/\t\t\t\t\t\\\n+     16,17, 18, 19,   20,\t\t\t\t\t\\\n /*mmx0,mmx1,mmx2,mmx3,mmx4,mmx5,mmx6,mmx7*/\t\t\t\\\n     29,  30,  31,  32,  33,  34,  35,  36 }\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        fixed_regs[i] = (fixed_regs[i] & (TARGET_64BIT ? 2 : 1)) != 0;\t\\\n+        call_used_regs[i] = (call_used_regs[i]\t\t\t\t\\\n+\t\t\t     & (TARGET_64BIT ? 2 : 1)) != 0;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n     if (flag_pic)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n@@ -897,6 +930,12 @@ extern int ix86_arch;\n #define FIRST_MMX_REG  (LAST_SSE_REG + 1)\n #define LAST_MMX_REG   (FIRST_MMX_REG + 7)\n \n+#define FIRST_REX_INT_REG  (LAST_MMX_REG + 1)\n+#define LAST_REX_INT_REG   (FIRST_REX_INT_REG + 7)\n+\n+#define FIRST_REX_SSE_REG  (LAST_REX_INT_REG + 1)\n+#define LAST_REX_SSE_REG   (FIRST_REX_SSE_REG + 7)\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n@@ -989,7 +1028,8 @@ enum reg_class\n   Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n   NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esp */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n-  GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n+  LEGACY_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n+  GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp %r8 - %r15*/\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n   FLOAT_REGS,\n   SSE_REGS,\n@@ -1023,6 +1063,7 @@ enum reg_class\n    \"AD_REGS\",\t\t\t\t\\\n    \"Q_REGS\", \"NON_Q_REGS\",\t\t\\\n    \"INDEX_REGS\",\t\t\t\\\n+   \"LEGACY_REGS\",\t\t\t\\\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n    \"FLOAT_REGS\",\t\t\t\\\n@@ -1041,26 +1082,27 @@ enum reg_class\n    of length N_REG_CLASSES.  */\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n-{     { 0x00,  0x0 },\t\t\t\t\t\t\t\\\n-      { 0x01,  0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n-      { 0x04,  0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n-      { 0x10,  0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n-      { 0x03,  0x0 },\t\t\t/* AD_REGS */\t\t\t\\\n-      { 0x0f,  0x0 },\t\t\t/* Q_REGS */\t\t\t\\\n-  { 0x1100f0,  0x0 },\t\t\t/* NON_Q_REGS */\t\t\\\n-      { 0x7f,  0x0 },\t\t\t/* INDEX_REGS */\t\t\\\n-  { 0x1100ff,  0x0 },\t\t\t/* GENERAL_REGS */\t\t\\\n-     { 0x100,  0x0 }, { 0x0200, 0x0 },\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n-    { 0xff00,  0x0 },\t\t\t/* FLOAT_REGS */\t\t\\\n-{ 0x1fe00000,  0x0 },\t\t\t/* SSE_REGS */\t\t\t\\\n-{ 0xe0000000, 0x1f },\t\t\t/* MMX_REGS */\t\t\t\\\n-{ 0x1fe00100,  0x0 },\t\t\t/* FP_TOP_SSE_REG */\t\t\\\n-{ 0x1fe00200,  0x0 },\t\t\t/* FP_SECOND_SSE_REG */\t\t\\\n-{ 0x1fe0ff00,  0x0 },\t\t\t/* FLOAT_SSE_REGS */\t\t\\\n-   { 0x1ffff,  0x0 },\t\t\t/* FLOAT_INT_REGS */\t\t\\\n-{ 0x1fe100ff,  0x0 },\t\t\t/* INT_SSE_REGS */\t\t\\\n-{ 0x1fe1ffff,  0x0 },\t\t\t/* FLOAT_INT_SSE_REGS */\t\\\n-{ 0xffffffff, 0x1f }\t\t\t\t\t\t\t\\\n+{     { 0x00,     0x0 },\t\t\t\t\t\t\\\n+      { 0x01,     0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n+      { 0x04,     0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n+      { 0x10,     0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n+      { 0x03,     0x0 },\t\t/* AD_REGS */\t\t\t\\\n+      { 0x0f,     0x0 },\t\t/* Q_REGS */\t\t\t\\\n+  { 0x1100f0,  0x1fe0 },\t\t/* NON_Q_REGS */\t\t\\\n+      { 0x7f,  0x1fe0 },\t\t/* INDEX_REGS */\t\t\\\n+  { 0x1100ff,  0x0 },\t\t\t/* LEGACY_REGS */\t\t\\\n+  { 0x1100ff,  0x1fe0 },\t\t/* GENERAL_REGS */\t\t\\\n+     { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\\\n+    { 0xff00,     0x0 },\t\t/* FLOAT_REGS */\t\t\\\n+{ 0x1fe00000,0x1fe000 },\t\t/* SSE_REGS */\t\t\t\\\n+{ 0xe0000000,    0x1f },\t\t/* MMX_REGS */\t\t\t\\\n+{ 0x1fe00100,0x1fe000 },\t\t/* FP_TOP_SSE_REG */\t\t\\\n+{ 0x1fe00200,0x1fe000 },\t\t/* FP_SECOND_SSE_REG */\t\t\\\n+{ 0x1fe0ff00,0x1fe000 },\t\t/* FLOAT_SSE_REGS */\t\t\\\n+   { 0x1ffff,  0x1fe0 },\t\t/* FLOAT_INT_REGS */\t\t\\\n+{ 0x1fe100ff,0x1fffe0 },\t\t/* INT_SSE_REGS */\t\t\\\n+{ 0x1fe1ffff,0x1fffe0 },\t\t/* FLOAT_INT_SSE_REGS */\t\\\n+{ 0xffffffff,0x1fffff }\t\t\t\t\t\t\t\\\n }\n \n /* The same information, inverted:\n@@ -1078,15 +1120,32 @@ enum reg_class\n \n #define QI_REG_P(X) \\\n   (REG_P (X) && REGNO (X) < 4)\n+\n+#define GENERAL_REGNO_P(n) \\\n+  ((n) < 8 || REX_INT_REGNO_P (n))\n+\n+#define GENERAL_REG_P(X) \\\n+  (REG_P (X) && GENERAL_REG_REGNO_P (X))\n+\n+#define ANY_QI_REG_P(X) (TARGET_64BIT ? GENERAL_REG_P(X) : QI_REG_P (X))\n+\n #define NON_QI_REG_P(X) \\\n   (REG_P (X) && REGNO (X) >= 4 && REGNO (X) < FIRST_PSEUDO_REGISTER)\n \n+#define REX_INT_REGNO_P(n) ((n) >= FIRST_REX_INT_REG && (n) <= LAST_REX_INT_REG)\n+#define REX_INT_REG_P(X) (REG_P (X) && REX_INT_REGNO_P (REGNO (X)))\n+\n #define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))\n #define FP_REGNO_P(n) ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG)\n #define ANY_FP_REG_P(X) (REG_P (X) && ANY_FP_REGNO_P (REGNO (X)))\n #define ANY_FP_REGNO_P(n) (FP_REGNO_P (n) || SSE_REGNO_P (n))\n \n-#define SSE_REGNO_P(n) ((n) >= FIRST_SSE_REG && (n) <= LAST_SSE_REG)\n+#define SSE_REGNO_P(n) \\\n+  (((n) >= FIRST_SSE_REG && (n) <= LAST_SSE_REG) \\\n+   || ((n) >= FIRST_REX_SSE_REG && (n) <= LAST_REX_SSE_REG))\n+\n+#define SSE_REGNO(n) \\\n+  ((n) < 8 ? FIRST_SSE_REG + (n) : FIRST_REX_SSE_REG + (n) - 8)\n #define SSE_REG_P(n) (REG_P (n) && SSE_REGNO_P (REGNO (n)))\n \n #define SSE_FLOAT_MODE_P(m) \\\n@@ -1120,7 +1179,9 @@ enum reg_class\n \n #define REG_CLASS_FROM_LETTER(C)\t\\\n   ((C) == 'r' ? GENERAL_REGS :\t\t\t\t\t\\\n-   (C) == 'q' ? Q_REGS :\t\t\t\t\t\\\n+   (C) == 'R' ? LEGACY_REGS :\t\t\t\t\t\\\n+   (C) == 'q' ? TARGET_64BIT ? GENERAL_REGS : Q_REGS :\t\t\\\n+   (C) == 'Q' ? Q_REGS :\t\t\t\t\t\\\n    (C) == 'f' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n \t\t ? FLOAT_REGS\t\t\t\t\t\\\n \t\t : NO_REGS) :\t\t\t\t\t\\\n@@ -1663,14 +1724,22 @@ pop{l} %0\"\t\t\t\t\t\t\t\\\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n \n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  ((REGNO) < STACK_POINTER_REGNUM \\\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n+  ((REGNO) < STACK_POINTER_REGNUM \t\t\t\t\t\\\n+   || (REGNO >= FIRST_REX_INT_REG\t\t\t\t\t\\\n+       && (REGNO) <= LAST_REX_INT_REG)\t\t\t\t\t\\\n+   || ((unsigned) reg_renumber[REGNO] >= FIRST_REX_INT_REG\t\t\\\n+       && (unsigned) reg_renumber[REGNO] <= LAST_REX_INT_REG)\t\t\\\n    || (unsigned) reg_renumber[REGNO] < STACK_POINTER_REGNUM)\n \n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-  ((REGNO) <= STACK_POINTER_REGNUM \\\n-   || (REGNO) == ARG_POINTER_REGNUM \\\n-   || (REGNO) == FRAME_POINTER_REGNUM \\\n+#define REGNO_OK_FOR_BASE_P(REGNO) \t\t\t\t\t\\\n+  ((REGNO) <= STACK_POINTER_REGNUM \t\t\t\t\t\\\n+   || (REGNO) == ARG_POINTER_REGNUM \t\t\t\t\t\\\n+   || (REGNO) == FRAME_POINTER_REGNUM \t\t\t\t\t\\\n+   || (REGNO >= FIRST_REX_INT_REG\t\t\t\t\t\\\n+       && (REGNO) <= LAST_REX_INT_REG)\t\t\t\t\t\\\n+   || ((unsigned) reg_renumber[REGNO] >= FIRST_REX_INT_REG\t\t\\\n+       && (unsigned) reg_renumber[REGNO] <= LAST_REX_INT_REG)\t\t\\\n    || (unsigned) reg_renumber[REGNO] <= STACK_POINTER_REGNUM)\n \n #define REGNO_OK_FOR_SIREG_P(REGNO) ((REGNO) == 4 || reg_renumber[REGNO] == 4)\n@@ -1693,32 +1762,29 @@ pop{l} %0\"\t\t\t\t\t\t\t\\\n /* Non strict versions, pseudos are ok */\n #define REG_OK_FOR_INDEX_NONSTRICT_P(X)\t\t\t\t\t\\\n   (REGNO (X) < STACK_POINTER_REGNUM\t\t\t\t\t\\\n+   || (REGNO (X) >= FIRST_REX_INT_REG\t\t\t\t\t\\\n+       && REGNO (X) <= LAST_REX_INT_REG)\t\t\t\t\\\n    || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n #define REG_OK_FOR_BASE_NONSTRICT_P(X)\t\t\t\t\t\\\n   (REGNO (X) <= STACK_POINTER_REGNUM\t\t\t\t\t\\\n    || REGNO (X) == ARG_POINTER_REGNUM\t\t\t\t\t\\\n-   || REGNO (X) == FRAME_POINTER_REGNUM \\\n+   || REGNO (X) == FRAME_POINTER_REGNUM \t\t\t\t\\\n+   || (REGNO (X) >= FIRST_REX_INT_REG\t\t\t\t\t\\\n+       && REGNO (X) <= LAST_REX_INT_REG)\t\t\t\t\\\n    || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n-#define REG_OK_FOR_STRREG_NONSTRICT_P(X)\t\t\t\t\\\n-  (REGNO (X) == 4 || REGNO (X) == 5 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n /* Strict versions, hard registers only */\n #define REG_OK_FOR_INDEX_STRICT_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n #define REG_OK_FOR_BASE_STRICT_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define REG_OK_FOR_STRREG_STRICT_P(X)\t\t\t\t\t\\\n-  (REGNO_OK_FOR_DIREG_P (REGNO (X)) || REGNO_OK_FOR_SIREG_P (REGNO (X)))\n \n #ifndef REG_OK_STRICT\n #define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n #define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n-#define REG_OK_FOR_STRREG_P(X) REG_OK_FOR_STRREG_NONSTRICT_P(X)\n \n #else\n #define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n #define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n-#define REG_OK_FOR_STRREG_P(X) REG_OK_FOR_STRREG_STRICT_P(X)\n #endif\n \n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -2614,7 +2680,9 @@ while (0)\n  \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n  \"flags\",\"fpsr\", \"dirflag\", \"frame\",\t\t\t\t\t\\\n  \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\",\t\t\\\n- \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"\t}\n+ \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\"\t,\t\t\\\n+ \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\t\\\n+ \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\"}\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n@@ -2623,6 +2691,8 @@ while (0)\n #define ADDITIONAL_REGISTER_NAMES \\\n { { \"eax\", 0 }, { \"edx\", 1 }, { \"ecx\", 2 }, { \"ebx\", 3 },\t\\\n   { \"esi\", 4 }, { \"edi\", 5 }, { \"ebp\", 6 }, { \"esp\", 7 },\t\\\n+  { \"rax\", 0 }, { \"rdx\", 1 }, { \"rcx\", 2 }, { \"rbx\", 3 },\t\\\n+  { \"rsi\", 4 }, { \"rdi\", 5 }, { \"rbp\", 6 }, { \"rsp\", 7 },\t\\\n   { \"al\", 0 }, { \"dl\", 1 }, { \"cl\", 2 }, { \"bl\", 3 },\t\t\\\n   { \"ah\", 0 }, { \"dh\", 1 }, { \"ch\", 2 }, { \"bh\", 3 },\t\t\\\n   { \"mm0\", 8},  { \"mm1\", 9},  { \"mm2\", 10}, { \"mm3\", 11},\t\\\n@@ -2633,12 +2703,8 @@ to get gcc to use these, since they want the same but different\n number as al, and ax.\n */\n \n-/* note the last four are not really qi_registers, but\n-   the md will have to never output movb into one of them\n-   only a movw .  There is no movb into the last four regs */\n-\n #define QI_REGISTER_NAMES \\\n-{\"al\", \"dl\", \"cl\", \"bl\", \"si\", \"di\", \"bp\", \"sp\",}\n+{\"al\", \"dl\", \"cl\", \"bl\", \"sil\", \"dil\", \"bpl\", \"spl\",}\n \n /* These parallel the array above, and can be used to access bits 8:15\n    of regs 0 through 3. */\n@@ -2817,6 +2883,7 @@ do { long l;\t\t\t\t\t\t\\\n    If CODE is 'w', pretend the mode is HImode.\n    If CODE is 'b', pretend the mode is QImode.\n    If CODE is 'k', pretend the mode is SImode.\n+   If CODE is 'd', pretend the mode is DImode.\n    If CODE is 'h', pretend the reg is the `high' byte register.\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op. */\n \n@@ -2852,8 +2919,36 @@ do { long l;\t\t\t\t\t\t\\\n \t { fputs (\"st(0)\", FILE); break; }\t\t\\\n        if (FP_REG_P (X))\t\t\t\t\\\n \t { fputs (hi_name[REGNO(X)], FILE); break; }\t\\\n+       if (REX_INT_REG_P (X))\t\t\t\t\\\n+\t {\t\t\t\t\t\t\\\n+\t   switch (GET_MODE_SIZE (GET_MODE (X)))\t\\\n+\t     {\t\t\t\t\t\t\\\n+\t     default:\t\t\t\t\t\\\n+\t     case 8:\t\t\t\t\t\\\n+\t       fprintf (FILE, \"r%i\", REGNO (X)\t\t\\\n+\t\t\t- FIRST_REX_INT_REG + 8);\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     case 4:\t\t\t\t\t\\\n+\t       fprintf (FILE, \"r%id\", REGNO (X)\t\t\\\n+\t\t\t- FIRST_REX_INT_REG + 8);\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     case 2:\t\t\t\t\t\\\n+\t       fprintf (FILE, \"r%iw\", REGNO (X)\t\t\\\n+\t\t\t- FIRST_REX_INT_REG + 8);\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     case 1:\t\t\t\t\t\\\n+\t       fprintf (FILE, \"r%ib\", REGNO (X)\t\t\\\n+\t\t\t- FIRST_REX_INT_REG + 8);\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     }\t\t\t\t\t\t\\\n+\t   break;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\\\n        switch (GET_MODE_SIZE (GET_MODE (X)))\t\t\\\n \t {\t\t\t\t\t\t\\\n+\t case 8:\t\t\t\t\t\\\n+\t   fputs (\"r\", FILE);\t\t\t\t\\\n+\t   fputs (hi_name[REGNO (X)], FILE);\t\t\\\n+\t   break;\t\t\t\t\t\\\n \t default:\t\t\t\t\t\\\n \t   fputs (\"e\", FILE);\t\t\t\t\\\n \t case 2:\t\t\t\t\t\\"}]}