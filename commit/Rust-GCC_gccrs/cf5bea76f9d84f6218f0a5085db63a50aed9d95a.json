{"sha": "cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "node_id": "C_kwDOANBUbNoAKGNmNWJlYTc2ZjlkODRmNjIxOGYwYTUwODVkYjYzYTUwYWVkOWQ5NWE", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-03-14T12:31:18Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T08:55:45Z"}, "message": "Convert range-op.* to vrange.\n\nThis patch provides the infrastructure to make range-ops type agnostic.\n\nFirst, the range_op_handler function has been replaced with an object\nof the same name.  It's coded in such a way to minimize changes to the\ncode base, and to encapsulate the dispatch code.\n\nInstead of:\n\n\trange_operator *op = range_op_handler (code, type);\n\tif (op)\n\t  op->fold_range (...);\n\nWe now do:\n\trange_op_handler op (code, type);\n\tif (op)\n\t  op->fold_range (...);\n\nI've folded gimple_range_handler into the range_op_handler class,\nsince it's also a query into the range operators.\n\nInstead of:\n\n\trange_operator *handler = gimple_range_handler (stmt);\n\nWe now do:\n\n\trange_op_handler handler (stmt);\n\nThis all has the added benefit of moving all the dispatch code into an\nindependent class and avoid polluting range_operator (which we'll\nfurther split later when frange and prange come live).\n\nThere's this annoying \"using\" keyword that's been added to each\noperator due to hiding rules in C++.  The issue is that we will have\ndifferent virtual versions of fold_range() for each combination of\noperands.  For example:\n\n\t// Traditional binary op on irange's.\n\tfold_range (irange &lhs, const irange &op1, const irange &op2);\n\t// For POINTER_DIFF_EXPR:\n\tfold_range (irange &lhs, const prange &op1, const prange &op2);\n\t// Cast from irange to prange.\n\tfold_range (prange &lhs, const irange &op1, const irange &op2);\n\nOverloading virtuals when there are multiple same named methods causes\nhidden virtuals warnings from -Woverloaded-virtual, thus the using\nkeyword.  An alternative would be to have different names:\nfold_range_III, fold_range_IPP, fold_range_PII, but that's uglier\nstill.\n\nTested on x86-64 & ppc64le Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-edge.cc (gimple_outgoing_range_stmt_p): Adjust for\n\tvrange and convert range_op_handler function calls to use the\n\tidentically named object.\n\t* gimple-range-fold.cc (gimple_range_operand1): Same.\n\t(gimple_range_operand2): Same.\n\t(fold_using_range::fold_stmt): Same.\n\t(fold_using_range::range_of_range_op): Same.\n\t(fold_using_range::range_of_builtin_ubsan_call): Same.\n\t(fold_using_range::relation_fold_and_or): Same.\n\t(fur_source::register_outgoing_edges): Same.\n\t* gimple-range-fold.h (gimple_range_handler): Remove.\n\t* gimple-range-gori.cc (gimple_range_calc_op1): Adjust for vrange.\n\t(gimple_range_calc_op2): Same.\n\t(range_def_chain::get_def_chain): Same.\n\t(gori_compute::compute_operand_range): Same.\n\t(gori_compute::condexpr_adjust): Same.\n\t* gimple-range.cc (gimple_ranger::prefill_name): Same.\n\t(gimple_ranger::prefill_stmt_dependencies): Same.\n\t* range-op.cc (get_bool_state): Same.\n\t(class operator_equal): Add using clause.\n\t(class operator_not_equal): Same.\n\t(class operator_lt): Same.\n\t(class operator_le): Same.\n\t(class operator_gt): Same.\n\t(class operator_ge): Same.\n\t(class operator_plus): Same.\n\t(class operator_minus): Same.\n\t(class operator_mult): Same.\n\t(class operator_exact_divide): Same.\n\t(class operator_lshift): Same.\n\t(class operator_rshift): Same.\n\t(class operator_cast): Same.\n\t(class operator_logical_and): Same.\n\t(class operator_bitwise_and): Same.\n\t(class operator_logical_or): Same.\n\t(class operator_bitwise_or): Same.\n\t(class operator_bitwise_xor): Same.\n\t(class operator_trunc_mod): Same.\n\t(class operator_logical_not): Same.\n\t(class operator_bitwise_not): Same.\n\t(class operator_cst): Same.\n\t(class operator_identity): Same.\n\t(class operator_unknown): Same.\n\t(class operator_abs): Same.\n\t(class operator_negate): Same.\n\t(class operator_addr_expr): Same.\n\t(class pointer_or_operator): Same.\n\t(operator_plus::op1_range): Adjust for vrange.\n\t(operator_minus::op1_range): Same.\n\t(operator_mult::op1_range): Same.\n\t(operator_cast::op1_range): Same.\n\t(operator_bitwise_not::fold_range): Same.\n\t(operator_negate::fold_range): Same.\n\t(range_op_handler): Rename to...\n\t(get_handler): ...this.\n\t(range_op_handler::range_op_handler): New.\n\t(range_op_handler::fold_range): New.\n\t(range_op_handler::op1_range): New.\n\t(range_op_handler::op2_range): New.\n\t(range_op_handler::lhs_op1_relation): New.\n\t(range_op_handler::lhs_op2_relation): New.\n\t(range_op_handler::op1_op2_relation): New.\n\t(range_cast): Adjust for vrange.\n\t* range-op.h (range_op_handler): Remove function.\n\t(range_cast): Adjust for vrange.\n\t(class range_op_handler): New.\n\t(get_bool_state): Adjust for vrange.\n\t(empty_range_varying): Same.\n\t(relop_early_resolve): Same.\n\t* tree-data-ref.cc (compute_distributive_range): Same.\n\t* tree-vrp.cc (get_range_op_handler): Remove.\n\t(range_fold_binary_symbolics_p): Use range_op_handler class\n\tinstead of get_range_op_handler.\n\t(range_fold_unary_symbolics_p): Same.\n\t(range_fold_binary_expr): Same.\n\t(range_fold_unary_expr): Same.\n\t* value-query.cc (range_query::get_tree_range): Adjust for vrange.", "tree": {"sha": "2470e9411d6fa9eb157d518d206ce414e869c951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2470e9411d6fa9eb157d518d206ce414e869c951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c8e96dd02383baec4c15665985da3caadaaa5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c8e96dd02383baec4c15665985da3caadaaa5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c8e96dd02383baec4c15665985da3caadaaa5e"}], "stats": {"total": 427, "additions": 303, "deletions": 124}, "files": [{"sha": "5bbe23ae03d9cb0b759a98a15384a815aa6fbf88", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -42,7 +42,7 @@ gimple_outgoing_range_stmt_p (basic_block bb)\n   if (!gsi_end_p (gsi))\n     {\n       gimple *s = gsi_stmt (gsi);\n-      if (is_a<gcond *> (s) && gimple_range_handler (s))\n+      if (is_a<gcond *> (s) && range_op_handler (s))\n \treturn gsi_stmt (gsi);\n       gswitch *sw = dyn_cast<gswitch *> (s);\n       if (sw && irange::supports_type_p (TREE_TYPE (gimple_switch_index (sw))))"}, {"sha": "c53d2863d5e7d2199e12f7bcad46bb8e92d36dfd", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -482,7 +482,7 @@ gimple_range_base_of_assignment (const gimple *stmt)\n tree\n gimple_range_operand1 (const gimple *stmt)\n {\n-  gcc_checking_assert (gimple_range_handler (stmt));\n+  gcc_checking_assert (range_op_handler (stmt));\n \n   switch (gimple_code (stmt))\n     {\n@@ -515,7 +515,7 @@ gimple_range_operand1 (const gimple *stmt)\n tree\n gimple_range_operand2 (const gimple *stmt)\n {\n-  gcc_checking_assert (gimple_range_handler (stmt));\n+  gcc_checking_assert (range_op_handler (stmt));\n \n   switch (gimple_code (stmt))\n     {\n@@ -551,7 +551,7 @@ fold_using_range::fold_stmt (irange &r, gimple *s, fur_source &src, tree name)\n       && gimple_assign_rhs_code (s) == ADDR_EXPR)\n     return range_of_address (r, s, src);\n \n-  if (gimple_range_handler (s))\n+  if (range_op_handler (s))\n     res = range_of_range_op (r, s, src);\n   else if (is_a<gphi *>(s))\n     res = range_of_phi (r, as_a<gphi *> (s), src);\n@@ -593,7 +593,7 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n   tree type = gimple_range_type (s);\n   if (!type)\n     return false;\n-  range_operator *handler = gimple_range_handler (s);\n+  range_op_handler handler (s);\n   gcc_checking_assert (handler);\n \n   tree lhs = gimple_get_lhs (s);\n@@ -606,13 +606,13 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t{\n \t  // Fold range, and register any dependency if available.\n \t  int_range<2> r2 (type);\n-\t  handler->fold_range (r, type, range1, r2);\n+\t  handler.fold_range (r, type, range1, r2);\n \t  if (lhs && gimple_range_ssa_p (op1))\n \t    {\n \t      if (src.gori ())\n \t\tsrc.gori ()->register_dependency (lhs, op1);\n \t      relation_kind rel;\n-\t      rel = handler->lhs_op1_relation (r, range1, range1);\n+\t      rel = handler.lhs_op1_relation (r, range1, range1);\n \t      if (rel != VREL_VARYING)\n \t\tsrc.register_relation (s, rel, lhs, op1);\n \t    }\n@@ -629,7 +629,7 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t      fputc ('\\n', dump_file);\n \t    }\n \t  // Fold range, and register any dependency if available.\n-\t  handler->fold_range (r, type, range1, range2, rel);\n+\t  handler.fold_range (r, type, range1, range2, rel);\n \t  relation_fold_and_or (r, s, src);\n \t  if (lhs)\n \t    {\n@@ -640,13 +640,13 @@ fold_using_range::range_of_range_op (irange &r, gimple *s, fur_source &src)\n \t\t}\n \t      if (gimple_range_ssa_p (op1))\n \t\t{\n-\t\t  rel = handler->lhs_op1_relation (r, range1, range2, rel);\n+\t\t  rel = handler.lhs_op1_relation (r, range1, range2, rel);\n \t\t  if (rel != VREL_VARYING)\n \t\t    src.register_relation (s, rel, lhs, op1);\n \t\t}\n \t      if (gimple_range_ssa_p (op2))\n \t\t{\n-\t\t  rel= handler->lhs_op2_relation (r, range1, range2, rel);\n+\t\t  rel= handler.lhs_op2_relation (r, range1, range2, rel);\n \t\t  if (rel != VREL_VARYING)\n \t\t    src.register_relation (s, rel, lhs, op2);\n \t\t}\n@@ -921,7 +921,7 @@ fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n   gcc_checking_assert (code == PLUS_EXPR || code == MINUS_EXPR\n \t\t       || code == MULT_EXPR);\n   tree type = gimple_range_type (call);\n-  range_operator *op = range_op_handler (code, type);\n+  range_op_handler op (code, type);\n   gcc_checking_assert (op);\n   int_range_max ir0, ir1;\n   tree arg0 = gimple_call_arg (call, 0);\n@@ -935,7 +935,7 @@ fold_using_range::range_of_builtin_ubsan_call (irange &r, gcall *call,\n   // Pretend the arithmetic is wrapping.  If there is any overflow,\n   // we'll complain, but will actually do wrapping operation.\n   flag_wrapv = 1;\n-  op->fold_range (r, type, ir0, ir1, relation);\n+  op.fold_range (r, type, ir0, ir1, relation);\n   flag_wrapv = saved_flag_wrapv;\n \n   // If for both arguments vrp_valueize returned non-NULL, this should\n@@ -1391,17 +1391,17 @@ fold_using_range::relation_fold_and_or (irange& lhs_range, gimple *s,\n   else if (ssa1_dep1 != ssa2_dep2 || ssa1_dep2 != ssa2_dep1)\n     return;\n \n-  range_operator *handler1 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa1));\n-  range_operator *handler2 = gimple_range_handler (SSA_NAME_DEF_STMT (ssa2));\n+  range_op_handler handler1 (SSA_NAME_DEF_STMT (ssa1));\n+  range_op_handler handler2 (SSA_NAME_DEF_STMT (ssa2));\n \n   // If either handler is not present, no relation is found.\n   if (!handler1 || !handler2)\n     return;\n \n   int_range<2> bool_one (boolean_true_node, boolean_true_node);\n \n-  relation_kind relation1 = handler1->op1_op2_relation (bool_one);\n-  relation_kind relation2 = handler2->op1_op2_relation (bool_one);\n+  relation_kind relation1 = handler1.op1_op2_relation (bool_one);\n+  relation_kind relation2 = handler2.op1_op2_relation (bool_one);\n   if (relation1 == VREL_VARYING || relation2 == VREL_VARYING)\n     return;\n \n@@ -1441,7 +1441,6 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n   int_range_max r;\n   int_range<2> e0_range, e1_range;\n   tree name;\n-  range_operator *handler;\n   basic_block bb = gimple_bb (s);\n \n   if (e0)\n@@ -1472,17 +1471,17 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n   tree ssa2 = gimple_range_ssa_p (gimple_range_operand2 (s));\n   if (ssa1 && ssa2)\n     {\n-      handler = gimple_range_handler (s);\n+      range_op_handler handler (s);\n       gcc_checking_assert (handler);\n       if (e0)\n \t{\n-\t  relation_kind relation = handler->op1_op2_relation (e0_range);\n+\t  relation_kind relation = handler.op1_op2_relation (e0_range);\n \t  if (relation != VREL_VARYING)\n \t    register_relation (e0, relation, ssa1, ssa2);\n \t}\n       if (e1)\n \t{\n-\t  relation_kind relation = handler->op1_op2_relation (e1_range);\n+\t  relation_kind relation = handler.op1_op2_relation (e1_range);\n \t  if (relation != VREL_VARYING)\n \t    register_relation (e1, relation, ssa1, ssa2);\n \t}\n@@ -1501,7 +1500,7 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n       if (TREE_CODE (TREE_TYPE (name)) != BOOLEAN_TYPE)\n \tcontinue;\n       gimple *stmt = SSA_NAME_DEF_STMT (name);\n-      handler = gimple_range_handler (stmt);\n+      range_op_handler handler (stmt);\n       if (!handler)\n \tcontinue;\n       tree ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n@@ -1511,14 +1510,14 @@ fur_source::register_outgoing_edges (gcond *s, irange &lhs_range, edge e0, edge\n \t  if (e0 && gori ()->outgoing_edge_range_p (r, e0, name, *m_query)\n \t      && r.singleton_p ())\n \t    {\n-\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      relation_kind relation = handler.op1_op2_relation (r);\n \t      if (relation != VREL_VARYING)\n \t\tregister_relation (e0, relation, ssa1, ssa2);\n \t    }\n \t  if (e1 && gori ()->outgoing_edge_range_p (r, e1, name, *m_query)\n \t      && r.singleton_p ())\n \t    {\n-\t      relation_kind relation = handler->op1_op2_relation (r);\n+\t      relation_kind relation = handler.op1_op2_relation (r);\n \t      if (relation != VREL_VARYING)\n \t\tregister_relation (e1, relation, ssa1, ssa2);\n \t    }"}, {"sha": "4b5d4b6e0b8b832d4ccefa637efceef48a8a81db", "filename": "gcc/gimple-range-fold.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.h?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -41,21 +41,6 @@ bool fold_range (irange &r, gimple *s, irange &r1);\n bool fold_range (irange &r, gimple *s, irange &r1, irange &r2);\n bool fold_range (irange &r, gimple *s, unsigned num_elements, irange *vector);\n \n-// Return the range_operator pointer for this statement.  This routine\n-// can also be used to gate whether a routine is range-ops enabled.\n-\n-static inline range_operator *\n-gimple_range_handler (const gimple *s)\n-{\n-  if (const gassign *ass = dyn_cast<const gassign *> (s))\n-    return range_op_handler (gimple_assign_rhs_code (ass),\n-\t\t\t     TREE_TYPE (gimple_assign_lhs (ass)));\n-  if (const gcond *cond = dyn_cast<const gcond *> (s))\n-    return range_op_handler (gimple_cond_code (cond),\n-\t\t\t     TREE_TYPE (gimple_cond_lhs (cond)));\n-  return NULL;\n-}\n-\n // Return the type of range which statement S calculates.  If the type is\n // unsupported or no type can be determined, return NULL_TREE.\n "}, {"sha": "72032132cac1575298482676f2693adef27b9ff0", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -44,9 +44,9 @@ gimple_range_calc_op1 (irange &r, const gimple *stmt, const irange &lhs_range)\n   // Unary operations require the type of the first operand in the\n   // second range position.\n   tree type = TREE_TYPE (gimple_range_operand1 (stmt));\n-  int_range<2> type_range (type);\n-  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n-\t\t\t\t\t\t type_range);\n+  Value_Range type_range (type);\n+  type_range.set_varying (type);\n+  return range_op_handler (stmt).op1_range (r, type, lhs_range, type_range);\n }\n \n // Calculate what we can determine of the range of this statement's\n@@ -72,12 +72,12 @@ gimple_range_calc_op1 (irange &r, const gimple *stmt,\n       // This is sometimes invoked on single operand stmts.\n       if (gimple_num_ops (stmt) < 3)\n \treturn false;\n-      int_range<2> trange (TREE_TYPE (gimple_range_operand2 (stmt)));\n-      return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n-\t\t\t\t\t\t     trange);\n+      tree op2_type = TREE_TYPE (gimple_range_operand2 (stmt));\n+      Value_Range trange (op2_type);\n+      trange.set_varying (op2_type);\n+      return range_op_handler (stmt).op1_range (r, type, lhs_range, trange);\n     }\n-  return gimple_range_handler (stmt)->op1_range (r, type, lhs_range,\n-\t\t\t\t\t\t op2_range);\n+  return range_op_handler (stmt).op1_range (r, type, lhs_range, op2_range);\n }\n \n // Calculate what we can determine of the range of this statement's\n@@ -97,12 +97,13 @@ gimple_range_calc_op2 (irange &r, const gimple *stmt,\n   // If op1 is undefined, solve as if it is varying.\n   if (op1_range.undefined_p ())\n     {\n-      int_range<2> trange (TREE_TYPE (gimple_range_operand1 (stmt)));\n-      return gimple_range_handler (stmt)->op2_range (r, type, lhs_range,\n-\t\t\t\t\t\t     trange);\n+      tree op1_type = TREE_TYPE (gimple_range_operand1 (stmt));\n+      Value_Range trange (op1_type);\n+      trange.set_varying (op1_type);\n+      return range_op_handler (stmt).op2_range (r, type, lhs_range, trange);\n     }\n-  return gimple_range_handler (stmt)->op2_range (r, type, lhs_range,\n-\t\t\t\t\t\t op1_range);\n+  return range_op_handler (stmt).op2_range (r, type, lhs_range,\n+\t\t\t\t\t    op1_range);\n }\n \n // Return TRUE if GS is a logical && or || expression.\n@@ -346,7 +347,7 @@ range_def_chain::get_def_chain (tree name)\n     }\n \n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n-  if (gimple_range_handler (stmt))\n+  if (range_op_handler (stmt))\n     {\n       ssa1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n       ssa2 = gimple_range_ssa_p (gimple_range_operand2 (stmt));\n@@ -707,7 +708,7 @@ gori_compute::compute_operand_range (irange &r, gimple *stmt,\n   if (is_a<gswitch *> (stmt))\n     return compute_operand_range_switch (r, as_a<gswitch *> (stmt), lhs, name,\n \t\t\t\t\t src);\n-  if (!gimple_range_handler (stmt))\n+  if (!range_op_handler (stmt))\n     return false;\n \n   tree op1 = gimple_range_ssa_p (gimple_range_operand1 (stmt));\n@@ -1328,7 +1329,7 @@ gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n   tree type = TREE_TYPE (gimple_assign_rhs1 (cond_def));\n   if (!range_compatible_p (type, TREE_TYPE (gimple_assign_rhs2 (cond_def))))\n     return false;\n-  range_operator *hand = range_op_handler (gimple_assign_rhs_code (cond_def), type);\n+  range_op_handler hand (gimple_assign_rhs_code (cond_def), type);\n   if (!hand)\n     return false;\n \n@@ -1351,18 +1352,18 @@ gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n   // the op1 or op2 routines based on its location.\n   if (c1)\n     {\n-      if (!hand->op1_range (cond_false, type, m_bool_zero, cr))\n+      if (!hand.op1_range (cond_false, type, m_bool_zero, cr))\n \treturn false;\n-      if (!hand->op1_range (cond_true, type, m_bool_one, cr))\n+      if (!hand.op1_range (cond_true, type, m_bool_one, cr))\n \treturn false;\n       cond_false.intersect (cl);\n       cond_true.intersect (cl);\n     }\n   else\n     {\n-      if (!hand->op2_range (cond_false, type, m_bool_zero, cl))\n+      if (!hand.op2_range (cond_false, type, m_bool_zero, cl))\n \treturn false;\n-      if (!hand->op2_range (cond_true, type, m_bool_one, cl))\n+      if (!hand.op2_range (cond_true, type, m_bool_one, cl))\n \treturn false;\n       cond_false.intersect (cr);\n       cond_true.intersect (cr);"}, {"sha": "0a99787fc75f7d14cde67aec67123f613eab2c03", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -339,7 +339,7 @@ gimple_ranger::prefill_name (irange &r, tree name)\n   if (!gimple_range_ssa_p (name))\n     return;\n   gimple *stmt = SSA_NAME_DEF_STMT (name);\n-  if (!gimple_range_handler (stmt) && !is_a<gphi *> (stmt))\n+  if (!range_op_handler (stmt) && !is_a<gphi *> (stmt))\n     return;\n \n   bool current;\n@@ -363,7 +363,7 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n   gcc_checking_assert (stmt && gimple_bb (stmt));\n \n   // Only pre-process range-ops and phis.\n-  if (!gimple_range_handler (stmt) && !is_a<gphi *> (stmt))\n+  if (!range_op_handler (stmt) && !is_a<gphi *> (stmt))\n     return;\n \n   // Mark where on the stack we are starting.\n@@ -419,7 +419,7 @@ gimple_ranger::prefill_stmt_dependencies (tree ssa)\n \t}\n       else\n \t{\n-\t  gcc_checking_assert (gimple_range_handler (stmt));\n+\t  gcc_checking_assert (range_op_handler (stmt));\n \t  tree op = gimple_range_operand2 (stmt);\n \t  if (op)\n \t    prefill_name (r, op);"}, {"sha": "028b4b7237c68c8a8ff7cb192a8c8f28ac796bbb", "filename": "gcc/range-op.cc", "status": "modified", "additions": 191, "deletions": 24, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -420,7 +420,7 @@ create_possibly_reversed_range (irange &r, tree type,\n // return the equivalent range for TYPE in R; if FALSE/TRUE, do nothing.\n \n bool_range_state\n-get_bool_state (irange &r, const irange &lhs, tree val_type)\n+get_bool_state (vrange &r, const vrange &lhs, tree val_type)\n {\n   // If there is no result, then this is unexecutable.\n   if (lhs.undefined_p ())\n@@ -446,6 +446,9 @@ get_bool_state (irange &r, const irange &lhs, tree val_type)\n \n class operator_equal : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -562,6 +565,9 @@ operator_equal::op2_range (irange &r, tree type,\n \n class operator_not_equal : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -738,6 +744,9 @@ build_ge (irange &r, tree type, const wide_int &val)\n \n class operator_lt :  public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -846,6 +855,9 @@ operator_lt::op2_range (irange &r, tree type,\n \n class operator_le :  public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -954,6 +966,9 @@ operator_le::op2_range (irange &r, tree type,\n \n class operator_gt :  public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -1061,6 +1076,9 @@ operator_gt::op2_range (irange &r, tree type,\n \n class operator_ge :  public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -1169,6 +1187,10 @@ operator_ge::op2_range (irange &r, tree type,\n \n class operator_plus : public range_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n+  using range_operator::lhs_op1_relation;\n+  using range_operator::lhs_op2_relation;\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n@@ -1286,7 +1308,7 @@ operator_plus::op1_range (irange &r, tree type,\n \t\t\t  const irange &op2,\n \t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op2);\n+  return range_op_handler (MINUS_EXPR, type).fold_range (r, type, lhs, op2);\n }\n \n bool\n@@ -1295,12 +1317,15 @@ operator_plus::op2_range (irange &r, tree type,\n \t\t\t  const irange &op1,\n \t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op1);\n+  return range_op_handler (MINUS_EXPR, type).fold_range (r, type, lhs, op1);\n }\n \n \n class operator_minus : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n@@ -1445,7 +1470,7 @@ operator_minus::op1_range (irange &r, tree type,\n \t\t\t   const irange &op2,\n \t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n-  return range_op_handler (PLUS_EXPR, type)->fold_range (r, type, lhs, op2);\n+  return range_op_handler (PLUS_EXPR, type).fold_range (r, type, lhs, op2);\n }\n \n bool\n@@ -1597,6 +1622,8 @@ cross_product_operator::wi_cross_product (irange &r, tree type,\n \n class operator_mult : public cross_product_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n@@ -1629,8 +1656,8 @@ operator_mult::op1_range (irange &r, tree type,\n     return false;\n \n   if (op2.singleton_p (&offset) && !integer_zerop (offset))\n-    return range_op_handler (TRUNC_DIV_EXPR, type)->fold_range (r, type,\n-\t\t\t\t\t\t\t\tlhs, op2);\n+    return range_op_handler (TRUNC_DIV_EXPR, type).fold_range (r, type,\n+\t\t\t\t\t\t\t       lhs, op2);\n   return false;\n }\n \n@@ -1857,6 +1884,7 @@ operator_div op_ceil_div (CEIL_DIV_EXPR);\n \n class operator_exact_divide : public operator_div\n {\n+  using range_operator::op1_range;\n public:\n   operator_exact_divide () : operator_div (TRUNC_DIV_EXPR) { }\n   virtual bool op1_range (irange &r, tree type,\n@@ -1881,13 +1909,15 @@ operator_exact_divide::op1_range (irange &r, tree type,\n   // If op2 is a multiple of 2, we would be able to set some non-zero bits.\n   if (op2.singleton_p (&offset)\n       && !integer_zerop (offset))\n-    return range_op_handler (MULT_EXPR, type)->fold_range (r, type, lhs, op2);\n+    return range_op_handler (MULT_EXPR, type).fold_range (r, type, lhs, op2);\n   return false;\n }\n \n \n class operator_lshift : public cross_product_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n@@ -1909,6 +1939,9 @@ class operator_lshift : public cross_product_operator\n \n class operator_rshift : public cross_product_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::lhs_op1_relation;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -2248,6 +2281,8 @@ operator_rshift::wi_fold (irange &r, tree type,\n \n class operator_cast: public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -2417,10 +2452,9 @@ operator_cast::op1_range (irange &r, tree type,\n \t  // Add this to the unsigned LHS range(s).\n \t  int_range_max lim_range (type, lim, lim);\n \t  int_range_max lhs_neg;\n-\t  range_op_handler (PLUS_EXPR, type)->fold_range (lhs_neg,\n-\t\t\t\t\t\t\t  type,\n-\t\t\t\t\t\t\t  converted_lhs,\n-\t\t\t\t\t\t\t  lim_range);\n+\t  range_op_handler (PLUS_EXPR, type).fold_range (lhs_neg, type,\n+\t\t\t\t\t\t\t converted_lhs,\n+\t\t\t\t\t\t\t lim_range);\n \t  // lhs_neg now has all the negative versions of the LHS.\n \t  // Now union in all the values from SIGNED MIN (0x80000) to\n \t  // lim-1 in order to fill in all the ranges with the upper\n@@ -2469,6 +2503,9 @@ operator_cast::op1_range (irange &r, tree type,\n \n class operator_logical_and : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n@@ -2542,6 +2579,9 @@ operator_logical_and::op2_range (irange &r, tree type,\n \n class operator_bitwise_and : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n@@ -2988,6 +3028,9 @@ operator_bitwise_and::op2_range (irange &r, tree type,\n \n class operator_logical_or : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n@@ -3051,6 +3094,8 @@ operator_logical_or::op2_range (irange &r, tree type,\n \n class operator_bitwise_or : public range_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n@@ -3155,6 +3200,8 @@ operator_bitwise_or::op2_range (irange &r, tree type,\n \n class operator_bitwise_xor : public range_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n@@ -3296,6 +3343,8 @@ operator_bitwise_xor::op2_range (irange &r, tree type,\n \n class operator_trunc_mod : public range_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n@@ -3432,6 +3481,8 @@ operator_trunc_mod::op2_range (irange &r, tree type,\n \n class operator_logical_not : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n@@ -3487,6 +3538,8 @@ operator_logical_not::op1_range (irange &r,\n \n class operator_bitwise_not : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &lh,\n@@ -3513,8 +3566,7 @@ operator_bitwise_not::fold_range (irange &r, tree type,\n   // ~X is simply -1 - X.\n   int_range<1> minusone (type, wi::minus_one (TYPE_PRECISION (type)),\n \t\t\t wi::minus_one (TYPE_PRECISION (type)));\n-  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, minusone,\n-\t\t\t\t\t\t\t  lh);\n+  return range_op_handler (MINUS_EXPR, type).fold_range (r, type, minusone, lh);\n }\n \n bool\n@@ -3533,6 +3585,7 @@ operator_bitwise_not::op1_range (irange &r, tree type,\n \n class operator_cst : public range_operator\n {\n+  using range_operator::fold_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -3553,6 +3606,9 @@ operator_cst::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \n class operator_identity : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n+  using range_operator::lhs_op1_relation;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -3605,6 +3661,7 @@ operator_identity::op1_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \n class operator_unknown : public range_operator\n {\n+  using range_operator::fold_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -3625,6 +3682,7 @@ operator_unknown::fold_range (irange &r, tree type,\n \n class operator_abs : public range_operator\n {\n+  using range_operator::op1_range;\n  public:\n   virtual void wi_fold (irange &r, tree type,\n \t\t        const wide_int &lh_lb,\n@@ -3790,6 +3848,8 @@ operator_absu::wi_fold (irange &r, tree type,\n \n class operator_negate : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n  public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -3810,9 +3870,8 @@ operator_negate::fold_range (irange &r, tree type,\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n   // -X is simply 0 - X.\n-  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type,\n-\t\t\t\t\t\t\t  range_zero (type),\n-\t\t\t\t\t\t\t  lh);\n+  return range_op_handler (MINUS_EXPR, type).fold_range (r, type,\n+\t\t\t\t\t\t\t range_zero (type), lh);\n }\n \n bool\n@@ -3828,6 +3887,8 @@ operator_negate::op1_range (irange &r, tree type,\n \n class operator_addr_expr : public range_operator\n {\n+  using range_operator::fold_range;\n+  using range_operator::op1_range;\n public:\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n@@ -3978,6 +4039,8 @@ pointer_and_operator::wi_fold (irange &r, tree type,\n \n class pointer_or_operator : public range_operator\n {\n+  using range_operator::op1_range;\n+  using range_operator::op2_range;\n public:\n   virtual bool op1_range (irange &r, tree type,\n \t\t\t  const irange &lhs,\n@@ -4139,8 +4202,8 @@ pointer_table::pointer_table ()\n \n // The tables are hidden and accessed via a simple extern function.\n \n-range_operator *\n-range_op_handler (enum tree_code code, tree type)\n+static inline range_operator *\n+get_handler (enum tree_code code, tree type)\n {\n   // First check if there is a pointer specialization.\n   if (POINTER_TYPE_P (type))\n@@ -4150,16 +4213,120 @@ range_op_handler (enum tree_code code, tree type)\n   return NULL;\n }\n \n+range_op_handler::range_op_handler (tree_code code, tree type)\n+{\n+  m_op = get_handler (code, type);\n+}\n+\n+range_op_handler::range_op_handler (const gimple *s)\n+{\n+  if (const gassign *ass = dyn_cast<const gassign *> (s))\n+    {\n+      enum tree_code code = gimple_assign_rhs_code (ass);\n+      // The LHS of a comparison is always an int, so we must look at\n+      // the operands.\n+      if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\tm_op = get_handler (code, TREE_TYPE (gimple_assign_rhs1 (ass)));\n+      else\n+\tm_op = get_handler (code, TREE_TYPE (gimple_assign_lhs (ass)));\n+    }\n+  else if (const gcond *cond = dyn_cast<const gcond *> (s))\n+    m_op = get_handler (gimple_cond_code (cond),\n+\t\t\tTREE_TYPE (gimple_cond_lhs (cond)));\n+  else\n+    m_op = NULL;\n+}\n+\n+bool\n+range_op_handler::fold_range (vrange &r, tree type,\n+\t\t\t      const vrange &lh,\n+\t\t\t      const vrange &rh,\n+\t\t\t      relation_kind rel) const\n+{\n+  if (is_a <irange> (lh))\n+    return m_op->fold_range (as_a <irange> (r), type,\n+\t\t\t     as_a <irange> (lh),\n+\t\t\t     as_a <irange> (rh), rel);\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+bool\n+range_op_handler::op1_range (vrange &r, tree type,\n+\t\t\t     const vrange &lhs,\n+\t\t\t     const vrange &op2,\n+\t\t\t     relation_kind rel) const\n+{\n+  if (is_a <irange> (r))\n+    return m_op->op1_range (as_a <irange> (r), type,\n+\t\t\t    as_a <irange> (lhs),\n+\t\t\t    as_a <irange> (op2), rel);\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+bool\n+range_op_handler::op2_range (vrange &r, tree type,\n+\t\t\t     const vrange &lhs,\n+\t\t\t     const vrange &op1,\n+\t\t\t     relation_kind rel) const\n+{\n+  if (is_a <irange> (r))\n+    return m_op->op2_range (as_a <irange> (r), type,\n+\t\t\t    as_a <irange> (lhs),\n+\t\t\t    as_a <irange> (op1), rel);\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+relation_kind\n+range_op_handler::lhs_op1_relation (const vrange &lhs,\n+\t\t\t\t    const vrange &op1,\n+\t\t\t\t    const vrange &op2,\n+\t\t\t\t    relation_kind rel) const\n+{\n+  if (is_a <irange> (op1))\n+    return m_op->lhs_op1_relation (as_a <irange> (lhs),\n+\t\t\t\t   as_a <irange> (op1), as_a <irange> (op2), rel);\n+  gcc_unreachable ();\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_op_handler::lhs_op2_relation (const vrange &lhs,\n+\t\t\t\t    const vrange &op1,\n+\t\t\t\t    const vrange &op2,\n+\t\t\t\t    relation_kind rel) const\n+{\n+  if (is_a <irange> (op1))\n+    return m_op->lhs_op2_relation (as_a <irange> (lhs),\n+\t\t\t\t   as_a <irange> (op1), as_a <irange> (op2), rel);\n+  gcc_unreachable ();\n+  return VREL_VARYING;\n+}\n+\n+relation_kind\n+range_op_handler::op1_op2_relation (const vrange &lhs) const\n+{\n+  return m_op->op1_op2_relation (as_a <irange> (lhs));\n+}\n+\n // Cast the range in R to TYPE.\n \n-void\n-range_cast (irange &r, tree type)\n+bool\n+range_cast (vrange &r, tree type)\n {\n-  int_range_max tmp = r;\n-  range_operator *op = range_op_handler (CONVERT_EXPR, type);\n+  Value_Range tmp (r);\n+  Value_Range varying (type);\n+  varying.set_varying (type);\n+  range_op_handler op (CONVERT_EXPR, type);\n   // Call op_convert, if it fails, the result is varying.\n-  if (!op->fold_range (r, type, tmp, int_range<1> (type)))\n-    r.set_varying (type);\n+  if (!op || !op.fold_range (r, type, tmp, varying))\n+    {\n+      r.set_varying (type);\n+      return false;\n+    }\n+  return true;\n }\n \n #if CHECKING_P"}, {"sha": "262c796180d32ff68019e9875cd453b0b959bb8c", "filename": "gcc/range-op.h", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -108,8 +108,39 @@ class range_operator\n \t\t\t const wide_int &rh_ub) const;\n };\n \n-extern range_operator *range_op_handler (enum tree_code code, tree type);\n-extern void range_cast (irange &, tree type);\n+class range_op_handler\n+{\n+public:\n+  range_op_handler (enum tree_code code, tree type);\n+  range_op_handler (const gimple *s);\n+  operator bool () const { return m_op; }\n+\n+  bool fold_range (vrange &r, tree type,\n+\t\t   const vrange &lh,\n+\t\t   const vrange &rh,\n+\t\t   relation_kind rel = VREL_VARYING) const;\n+  bool op1_range (vrange &r, tree type,\n+\t\t  const vrange &lhs,\n+\t\t  const vrange &op2,\n+\t\t  relation_kind rel = VREL_VARYING) const;\n+  bool op2_range (vrange &r, tree type,\n+\t\t  const vrange &lhs,\n+\t\t  const vrange &op1,\n+\t\t  relation_kind rel = VREL_VARYING) const;\n+  relation_kind lhs_op1_relation (const vrange &lhs,\n+\t\t\t\t  const vrange &op1,\n+\t\t\t\t  const vrange &op2,\n+\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  relation_kind lhs_op2_relation (const vrange &lhs,\n+\t\t\t\t  const vrange &op1,\n+\t\t\t\t  const vrange &op2,\n+\t\t\t\t  relation_kind = VREL_VARYING) const;\n+  relation_kind op1_op2_relation (const vrange &lhs) const;\n+private:\n+  range_operator *m_op;\n+};\n+\n+extern bool range_cast (vrange &, tree type);\n extern void wi_set_zero_nonzero_bits (tree type,\n \t\t\t\t      const wide_int &, const wide_int &,\n \t\t\t\t      wide_int &maybe_nonzero,\n@@ -124,16 +155,16 @@ relation_kind gt_op1_op2_relation (const irange &lhs);\n relation_kind ge_op1_op2_relation (const irange &lhs);\n \n enum bool_range_state { BRS_FALSE, BRS_TRUE, BRS_EMPTY, BRS_FULL };\n-bool_range_state get_bool_state (irange &r, const irange &lhs, tree val_type);\n+bool_range_state get_bool_state (vrange &r, const vrange &lhs, tree val_type);\n \n // If the range of either op1 or op2 is undefined, set the result to\n // varying and return TRUE.  If the caller truely cares about a result,\n // they should pass in a varying if it has an undefined that it wants\n // treated as a varying.\n \n inline bool\n-empty_range_varying (irange &r, tree type,\n-\t\t     const irange &op1, const irange & op2)\n+empty_range_varying (vrange &r, tree type,\n+\t\t     const vrange &op1, const vrange & op2)\n {\n   if (op1.undefined_p () || op2.undefined_p ())\n     {\n@@ -150,8 +181,8 @@ empty_range_varying (irange &r, tree type,\n // return false.\n \n inline bool\n-relop_early_resolve (irange &r, tree type, const irange &op1,\n-\t\t     const irange &op2, relation_kind rel,\n+relop_early_resolve (irange &r, tree type, const vrange &op1,\n+\t\t     const vrange &op2, relation_kind rel,\n \t\t     relation_kind my_rel)\n {\n   // If known relation is a complete subset of this relation, always true."}, {"sha": "ae05fe74b95ca4f9c692f61822273f5855e374fa", "filename": "gcc/tree-data-ref.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Ftree-data-ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Ftree-data-ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -593,8 +593,8 @@ compute_distributive_range (tree type, value_range &op0_range,\n   gcc_assert (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_TRAPS (type));\n   if (result_range)\n     {\n-      range_operator *op = range_op_handler (code, type);\n-      op->fold_range (*result_range, type, op0_range, op1_range);\n+      range_op_handler op (code, type);\n+      op.fold_range (*result_range, type, op0_range, op1_range);\n     }\n \n   /* The distributive property guarantees that if TYPE is no narrower\n@@ -639,10 +639,10 @@ compute_distributive_range (tree type, value_range &op0_range,\n   range_cast (op0_range, ssizetype);\n   range_cast (op1_range, ssizetype);\n   value_range wide_range;\n-  range_operator *op = range_op_handler (code, ssizetype);\n+  range_op_handler op (code, ssizetype);\n   bool saved_flag_wrapv = flag_wrapv;\n   flag_wrapv = 1;\n-  op->fold_range (wide_range, ssizetype, op0_range, op1_range);\n+  op.fold_range (wide_range, ssizetype, op0_range, op1_range);\n   flag_wrapv = saved_flag_wrapv;\n   if (wide_range.num_pairs () != 1 || !range_int_cst_p (&wide_range))\n     return false;"}, {"sha": "74277617b66919d1f14c353920abc0bea4a6c8d2", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -924,20 +924,6 @@ extract_range_from_plus_minus_expr (value_range *vr,\n     vr->set (min, max, kind);\n }\n \n-/* Return the range-ops handler for CODE and EXPR_TYPE.  If no\n-   suitable operator is found, return NULL and set VR to VARYING.  */\n-\n-static const range_operator *\n-get_range_op_handler (value_range *vr,\n-\t\t      enum tree_code code,\n-\t\t      tree expr_type)\n-{\n-  const range_operator *op = range_op_handler (code, expr_type);\n-  if (!op)\n-    vr->set_varying (expr_type);\n-  return op;\n-}\n-\n /* If the types passed are supported, return TRUE, otherwise set VR to\n    VARYING and return FALSE.  */\n \n@@ -1005,10 +991,12 @@ range_fold_binary_symbolics_p (value_range *vr,\n \t\t\t\t\t\t&vr0, &vr1);\n \t  return true;\n \t}\n-      const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+      range_op_handler op (code, expr_type);\n+      if (!op)\n+\tvr->set_varying (expr_type);\n       vr0.normalize_symbolics ();\n       vr1.normalize_symbolics ();\n-      return op->fold_range (*vr, expr_type, vr0, vr1);\n+      return op.fold_range (*vr, expr_type, vr0, vr1);\n     }\n   return false;\n }\n@@ -1040,10 +1028,12 @@ range_fold_unary_symbolics_p (value_range *vr,\n \t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &minusone, vr0);\n \t  return true;\n \t}\n-      const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+      range_op_handler op (code, expr_type);\n+      if (!op)\n+\tvr->set_varying (expr_type);\n       value_range vr0_cst (*vr0);\n       vr0_cst.normalize_symbolics ();\n-      return op->fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n+      return op.fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n     }\n   return false;\n }\n@@ -1060,9 +1050,12 @@ range_fold_binary_expr (value_range *vr,\n   if (!supported_types_p (vr, expr_type)\n       || !defined_ranges_p (vr, vr0_, vr1_))\n     return;\n-  const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+  range_op_handler op (code, expr_type);\n   if (!op)\n-    return;\n+    {\n+      vr->set_varying (expr_type);\n+      return;\n+    }\n \n   if (range_fold_binary_symbolics_p (vr, code, expr_type, vr0_, vr1_))\n     return;\n@@ -1075,7 +1068,7 @@ range_fold_binary_expr (value_range *vr,\n     vr1.set_varying (expr_type);\n   vr0.normalize_addresses ();\n   vr1.normalize_addresses ();\n-  op->fold_range (*vr, expr_type, vr0, vr1);\n+  op.fold_range (*vr, expr_type, vr0, vr1);\n }\n \n /* Perform a unary operation on a range.  */\n@@ -1089,16 +1082,19 @@ range_fold_unary_expr (value_range *vr,\n   if (!supported_types_p (vr, expr_type, vr0_type)\n       || !defined_ranges_p (vr, vr0))\n     return;\n-  const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+  range_op_handler op (code, expr_type);\n   if (!op)\n-    return;\n+    {\n+      vr->set_varying (expr_type);\n+      return;\n+    }\n \n   if (range_fold_unary_symbolics_p (vr, code, expr_type, vr0))\n     return;\n \n   value_range vr0_cst (*vr0);\n   vr0_cst.normalize_addresses ();\n-  op->fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n+  op.fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n }\n \n /* If the range of values taken by OP can be inferred after STMT executes,"}, {"sha": "31e56eeae53662724741dfe476a7cd6f10cebf58", "filename": "gcc/value-query.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5bea76f9d84f6218f0a5085db63a50aed9d95a/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "patch": "@@ -234,27 +234,27 @@ range_query::get_tree_range (irange &r, tree expr, gimple *stmt)\n     }\n   if (BINARY_CLASS_P (expr))\n     {\n-      range_operator *op = range_op_handler (TREE_CODE (expr), type);\n+      range_op_handler op (TREE_CODE (expr), type);\n       if (op)\n \t{\n \t  int_range_max r0, r1;\n \t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n \t  range_of_expr (r1, TREE_OPERAND (expr, 1), stmt);\n-\t  op->fold_range (r, type, r0, r1);\n+\t  op.fold_range (r, type, r0, r1);\n \t}\n       else\n \tr.set_varying (type);\n       return true;\n     }\n   if (UNARY_CLASS_P (expr))\n     {\n-      range_operator *op = range_op_handler (TREE_CODE (expr), type);\n+      range_op_handler op (TREE_CODE (expr), type);\n       tree op0_type = TREE_TYPE (TREE_OPERAND (expr, 0));\n       if (op && irange::supports_type_p (op0_type))\n \t{\n \t  int_range_max r0;\n \t  range_of_expr (r0, TREE_OPERAND (expr, 0), stmt);\n-\t  op->fold_range (r, type, r0, int_range<1> (type));\n+\t  op.fold_range (r, type, r0, int_range<1> (type));\n \t}\n       else\n \tr.set_varying (type);"}]}