{"sha": "f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlkNmNlNzM0ZGI2MmFiN2ZmOGFiNDgyNmE5MzEzYmY0MTdlMGE4MQ==", "commit": {"author": {"name": "Bill Seurer", "email": "seurer@linux.vnet.ibm.com", "date": "2016-05-25T21:55:22Z"}, "committer": {"name": "Bill Seurer", "email": "seurer@gcc.gnu.org", "date": "2016-05-25T21:55:22Z"}, "message": "This patch adds support for the vec_cmpne altivec builtins from the Power...\n\nThis patch adds support for the vec_cmpne altivec builtins from the Power\nArchitecture 64-Bit ELF V2 ABI OpenPOWER ABI for Linux Supplement (16 July\n2015 Version 1.1). There are many of the builtins that are missing and this\nis part of a series of patches to add them.\n\nThere aren't instructions for vec_cmpne so the output code is built from other\nbuilt-ins that do have instructions which in this case is the following.\n\nvec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb), vec_cmpeq (va, vb))\n\nThe new test cases are executable tests which verify that the generated\ncode produces expected values. C macros were used so that the same\ntest case could be used for both the signed and unsigned versions of various\nbasic types. A separate executable test case is used for the long long versions\nof vec_cmpne because of some differences in loading and storing the vectors.\n\n[gcc]\n\n2016-05-25  Bill Seurer  <seurer@linux.vnet.ibm.com>\n\n\t* config/rs6000/altivec.h (vec_cmpne): Add #define for vec_cmpne.\n\t* config/rs6000/rs6000-builtin.def (vec_cmpne): Add vec_cmpne as a\n\tspecial case builtin.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Add\n\tcode for ALTIVEC_BUILTIN_VEC_CMPNE.\n\t* config/rs6000/rs6000.c (altivec_init_builtins): Add definition\n\tfor __builtin_vec_cmpne.\n\n[gcc/testsuite]\n\n2016-05-25  Bill Seurer  <seurer@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-cmpne.c: New test.\n\t* gcc.target/powerpc/vec-cmpne-long.c: New test.\n\nFrom-SVN: r236753", "tree": {"sha": "cc8807a5da2fac8a9e243f796efdbc3f54a77195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc8807a5da2fac8a9e243f796efdbc3f54a77195"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/comments", "author": {"login": "BillSeurer", "id": 8561221, "node_id": "MDQ6VXNlcjg1NjEyMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8561221?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BillSeurer", "html_url": "https://github.com/BillSeurer", "followers_url": "https://api.github.com/users/BillSeurer/followers", "following_url": "https://api.github.com/users/BillSeurer/following{/other_user}", "gists_url": "https://api.github.com/users/BillSeurer/gists{/gist_id}", "starred_url": "https://api.github.com/users/BillSeurer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BillSeurer/subscriptions", "organizations_url": "https://api.github.com/users/BillSeurer/orgs", "repos_url": "https://api.github.com/users/BillSeurer/repos", "events_url": "https://api.github.com/users/BillSeurer/events{/privacy}", "received_events_url": "https://api.github.com/users/BillSeurer/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a88a7b22c9d0df1068bdc92522ea805d0edf676f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a88a7b22c9d0df1068bdc92522ea805d0edf676f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a88a7b22c9d0df1068bdc92522ea805d0edf676f"}], "stats": {"total": 306, "additions": 306, "deletions": 0}, "files": [{"sha": "27eeee4189eb8f182e6d71aeb04e5a532b6ced1b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -1,3 +1,13 @@\n+2016-05-25  Bill Seurer  <seurer@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/altivec.h (vec_cmpne): Add #define for vec_cmpne.\n+\t* config/rs6000/rs6000-builtin.def (vec_cmpne): Add vec_cmpne as a\n+\tspecial case builtin.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Add\n+\tcode for ALTIVEC_BUILTIN_VEC_CMPNE.\n+\t* config/rs6000/rs6000.c (altivec_init_builtins): Add definition\n+\tfor __builtin_vec_cmpne.\n+\n 2016-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-phiopt.c (factor_out_conditional_conversion): Remove"}, {"sha": "7289cd596b4939ed0e553b7695eeb396d0990216", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -196,6 +196,7 @@\n #define vec_andc __builtin_vec_andc\n #define vec_avg __builtin_vec_avg\n #define vec_cmpeq __builtin_vec_cmpeq\n+#define vec_cmpne __builtin_vec_cmpne\n #define vec_cmpgt __builtin_vec_cmpgt\n #define vec_ctf __builtin_vec_ctf\n #define vec_dst __builtin_vec_dst"}, {"sha": "177b8aef353080ba8dc43c34255f297629266353", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -1282,6 +1282,7 @@ BU_ALTIVEC_OVERLOAD_P (VCMPGE_P,   \"vcmpge_p\")\n /* Overloaded Altivec builtins that are handled as special cases.  */\n BU_ALTIVEC_OVERLOAD_X (ADDE,\t   \"adde\")\n BU_ALTIVEC_OVERLOAD_X (ADDEC,\t   \"addec\")\n+BU_ALTIVEC_OVERLOAD_X (CMPNE,\t   \"cmpne\")\n BU_ALTIVEC_OVERLOAD_X (CTF,\t   \"ctf\")\n BU_ALTIVEC_OVERLOAD_X (CTS,\t   \"cts\")\n BU_ALTIVEC_OVERLOAD_X (CTU,\t   \"ctu\")"}, {"sha": "eb1539cf73a09278b81278da267255e638ad059e", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -4675,6 +4675,65 @@ assignment for unaligned loads and stores\");\n     warning (OPT_Wdeprecated, \"vec_lvsr is deprecated for little endian; use \\\n assignment for unaligned loads and stores\");\n \n+\n+  if (fcode == ALTIVEC_BUILTIN_VEC_CMPNE)\n+    {\n+      /* vec_cmpne needs to be special cased because there are no instructions\n+\t for it (prior to power 9).  */\n+      if (nargs != 2)\n+\t{\n+\t  error (\"vec_cmpne only accepts 2 arguments\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+\n+      /* Both arguments must be vectors and the types must match.  */\n+      if (arg0_type != arg1_type)\n+\tgoto bad;\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+\n+      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t{\n+\t  /* vec_cmpneq (va, vb) == vec_nor (vec_cmpeq (va, vb),\n+\t\t\t\t\t     vec_cmpeq (va, vb)).  */\n+\t  /* Note:  vec_nand also works but opt changes vec_nand's to vec_nor's\n+\t     anyway.  */\n+\t  case QImode:\n+\t  case HImode:\n+\t  case SImode:\n+\t  case DImode:\n+\t  case TImode:\n+ \t  case SFmode:\n+\t  case DFmode:\n+\t   {\n+\t      /* call = vec_cmpeq (va, vb)\n+\t\t result = vec_nor (call, call).  */\n+\t      vec<tree, va_gc> *params = make_tree_vector ();\n+\t      vec_safe_push (params, arg0);\n+\t      vec_safe_push (params, arg1);\n+\t      tree call = altivec_resolve_overloaded_builtin\n+\t\t(loc, rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_CMPEQ], params);\n+ \t      /* Use save_expr to ensure that operands used more than once\n+\t\t that may have side effects (like calls) are only evaluated\n+\t\t once.  */\n+\t      call = save_expr (call);\n+\t      params = make_tree_vector ();\n+\t      vec_safe_push (params, call);\n+\t      vec_safe_push (params, call);\n+\t      return altivec_resolve_overloaded_builtin\n+\t\t(loc, rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_NOR], params);\n+\t    }\n+\t  /* Other types are errors.  */\n+\t  default:\n+\t    goto bad;\n+\t}\n+    }\n+\n   if (fcode == ALTIVEC_BUILTIN_VEC_ADDE)\n     {\n       /* vec_adde needs to be special cased because there is no instruction"}, {"sha": "af897053d9cd5c01dc1cd7350ace948ccf39b064", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -16293,6 +16293,10 @@ altivec_init_builtins (void)\n     = build_function_type_list (opaque_V4SI_type_node,\n \t\t\t\topaque_V4SI_type_node, opaque_V4SI_type_node,\n \t\t\t\topaque_V4SI_type_node, NULL_TREE);\n+  tree opaque_ftype_opaque_opaque\n+    = build_function_type_list (opaque_V4SI_type_node,\n+\t\t\t\topaque_V4SI_type_node, opaque_V4SI_type_node,\n+\t\t\t\tNULL_TREE);\n   tree int_ftype_int_opaque_opaque\n     = build_function_type_list (integer_type_node,\n                                 integer_type_node, opaque_V4SI_type_node,\n@@ -16567,6 +16571,8 @@ altivec_init_builtins (void)\n \t\tALTIVEC_BUILTIN_VEC_ADDE);\n   def_builtin (\"__builtin_vec_addec\", opaque_ftype_opaque_opaque_opaque,\n \t\tALTIVEC_BUILTIN_VEC_ADDEC);\n+  def_builtin (\"__builtin_vec_cmpne\", opaque_ftype_opaque_opaque,\n+\t\tALTIVEC_BUILTIN_VEC_CMPNE);\n \n   /* Cell builtins.  */\n   def_builtin (\"__builtin_altivec_lvlx\",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVLX);"}, {"sha": "30b5d2576b48db78d1aee9235ef0a9c538fbb9cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -1,3 +1,8 @@\n+2016-05-25  Bill Seurer  <seurer@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-cmpne.c: New test.\n+\t* gcc.target/powerpc/vec-cmpne-long.c: New test.\n+\n 2016-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt55.ad[sb]: New test."}, {"sha": "bf5866af15357382a6873582c058005544a62c37", "filename": "gcc/testsuite/gcc.target/powerpc/vec-cmpne-long.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne-long.c?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run { target { powerpc64*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -mpower8-vector -O3\" } */\n+\n+/* Test that the vec_cmpne builtin works as expected for long long\n+   and double vectors.  */\n+\n+#include \"altivec.h\"\n+\n+#define N 4096\n+\n+void abort ();\n+\n+#define define_test_functions(VBTYPE, RTYPE, STYPE, NAME) \\\n+\\\n+RTYPE result_ne_##NAME[N] __attribute__((aligned(16))); \\\n+RTYPE result_eq_##NAME[N] __attribute__((aligned(16))); \\\n+STYPE operand1_##NAME[N] __attribute__((aligned(16))); \\\n+STYPE operand2_##NAME[N] __attribute__((aligned(16))); \\\n+RTYPE expected_##NAME[N] __attribute__((aligned(16))); \\\n+\\\n+__attribute__((noinline)) void vector_tests_##NAME () \\\n+{ \\\n+  vector STYPE v1_##NAME, v2_##NAME; \\\n+  vector bool VBTYPE tmp_##NAME; \\\n+  int i; \\\n+  for (i = 0; i < N; i+=16/sizeof (STYPE)) \\\n+    { \\\n+      /* result_ne = operand1!=operand2.  */ \\\n+      v1_##NAME = (vector STYPE) { operand1_##NAME[i], \\\n+\t\t\t\t\t operand1_##NAME[i+1] }; \\\n+      v2_##NAME = (vector STYPE) { operand2_##NAME[i], \\\n+\t\t\t\t\t operand2_##NAME[i+1] }; \\\n+\\\n+      tmp_##NAME = vec_cmpeq (v1_##NAME, v2_##NAME); \\\n+      result_eq_##NAME[i] = tmp_##NAME[0]; \\\n+      result_eq_##NAME[i+1] = tmp_##NAME[1]; \\\n+\\\n+      tmp_##NAME = vec_cmpne (v1_##NAME, v2_##NAME); \\\n+      result_ne_##NAME[i] = tmp_##NAME[0]; \\\n+      result_ne_##NAME[i+1] = tmp_##NAME[1]; \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void init_##NAME () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      result_ne_##NAME[i] = 7; \\\n+      result_eq_##NAME[i] = 15; \\\n+      if (i%3 == 0) \\\n+\t{ \\\n+\t  /* op1 < op2.  */ \\\n+\t  operand1_##NAME[i] = 1; \\\n+\t  operand2_##NAME[i] = 2; \\\n+\t} \\\n+      else if (i%3 == 1) \\\n+\t{ \\\n+\t  /* op1 > op2.  */ \\\n+\t  operand1_##NAME[i] = 2; \\\n+\t  operand2_##NAME[i] = 1; \\\n+\t} \\\n+      else if (i%3 == 2) \\\n+\t{ \\\n+\t  /* op1 == op2.  */ \\\n+\t  operand1_##NAME[i] = 3; \\\n+\t  operand2_##NAME[i] = 3; \\\n+\t} \\\n+      /* For vector comparisons: \"For each element of the result_ne, the \\\n+\t  value of each bit is 1 if the corresponding elements of ARG1 and \\\n+\t  ARG2 are equal.\" {or whatever the comparison is} \"Otherwise, the \\\n+\t  value of each bit is 0.\"  */ \\\n+    expected_##NAME[i] = -1 * (RTYPE)(operand1_##NAME[i] != operand2_##NAME[i]); \\\n+  } \\\n+} \\\n+\\\n+__attribute__((noinline)) void verify_results_##NAME () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      if ( ((result_ne_##NAME[i] != expected_##NAME[i]) || \\\n+\t    (result_ne_##NAME[i] == result_eq_##NAME[i]))) \\\n+\tabort (); \\\n+    } \\\n+}\n+\n+\n+#define execute_test_functions(VBTYPE, RTYPE, STYPE, NAME) \\\n+{ \\\n+  init_##NAME (); \\\n+  vector_tests_##NAME (); \\\n+  verify_results_##NAME (); \\\n+}\n+\n+\n+define_test_functions (long long, signed long long, signed long long, si);\n+define_test_functions (long long, signed long long, double, dd);\n+\n+int main ()\n+{\n+  execute_test_functions (long long, signed long long, signed long long, si);\n+  execute_test_functions (long long, signed long long, double, dd);\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "abde91662e32d12385042cb1b0b974f201e44291", "filename": "gcc/testsuite/gcc.target/powerpc/vec-cmpne.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9d6ce734db62ab7ff8ab4826a9313bf417e0a81/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-cmpne.c?ref=f9d6ce734db62ab7ff8ab4826a9313bf417e0a81", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do run { target { powerpc64*-*-* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O3\" } */\n+\n+/* Test that the vec_cmpne builtin works as expected.  */\n+\n+#include \"altivec.h\"\n+\n+#define N 4096\n+\n+void abort ();\n+\n+#define define_test_functions(VBTYPE, RTYPE, STYPE, NAME) \\\n+\\\n+RTYPE result_ne_##NAME[N] __attribute__((aligned(16))); \\\n+RTYPE result_eq_##NAME[N] __attribute__((aligned(16))); \\\n+STYPE operand1_##NAME[N] __attribute__((aligned(16))); \\\n+STYPE operand2_##NAME[N] __attribute__((aligned(16))); \\\n+RTYPE expected_##NAME[N] __attribute__((aligned(16))); \\\n+\\\n+__attribute__((noinline)) void vector_tests_##NAME () \\\n+{ \\\n+  vector STYPE v1_##NAME, v2_##NAME; \\\n+  vector bool VBTYPE tmp_##NAME; \\\n+  int i; \\\n+  for (i = 0; i < N; i+=16/sizeof (STYPE)) \\\n+    { \\\n+      /* result_ne = operand1!=operand2.  */ \\\n+      v1_##NAME = vec_vsx_ld (0, (const vector STYPE*)&operand1_##NAME[i]); \\\n+      v2_##NAME = vec_vsx_ld (0, (const vector STYPE*)&operand2_##NAME[i]); \\\n+\\\n+      tmp_##NAME = vec_cmpeq (v1_##NAME, v2_##NAME); \\\n+      vec_vsx_st (tmp_##NAME, 0, &result_eq_##NAME[i]); \\\n+\\\n+      tmp_##NAME = vec_cmpne (v1_##NAME, v2_##NAME); \\\n+      vec_vsx_st (tmp_##NAME, 0, &result_ne_##NAME[i]); \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void init_##NAME () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      result_ne_##NAME[i] = 7; \\\n+      result_eq_##NAME[i] = 15; \\\n+      if (i%3 == 0) \\\n+\t{ \\\n+\t  /* op1 < op2.  */ \\\n+\t  operand1_##NAME[i] = 1; \\\n+\t  operand2_##NAME[i] = 2; \\\n+\t} \\\n+      else if (i%3 == 1) \\\n+\t{ \\\n+\t  /* op1 > op2.  */ \\\n+\t  operand1_##NAME[i] = 2; \\\n+\t  operand2_##NAME[i] = 1; \\\n+\t} \\\n+      else if (i%3 == 2) \\\n+\t{ \\\n+\t  /* op1 == op2.  */ \\\n+\t  operand1_##NAME[i] = 3; \\\n+\t  operand2_##NAME[i] = 3; \\\n+\t} \\\n+      /* For vector comparisons: \"For each element of the result_ne, the \\\n+\t  value of each bit is 1 if the corresponding elements of ARG1 and \\\n+\t  ARG2 are equal.\" {or whatever the comparison is} \"Otherwise, the \\\n+\t  value of each bit is 0.\"  */ \\\n+    expected_##NAME[i] = -1 * (RTYPE)(operand1_##NAME[i] != operand2_##NAME[i]); \\\n+  } \\\n+} \\\n+\\\n+__attribute__((noinline)) void verify_results_##NAME () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      if ( ((result_ne_##NAME[i] != expected_##NAME[i]) || \\\n+\t    (result_ne_##NAME[i] == result_eq_##NAME[i]))) \\\n+\tabort (); \\\n+    } \\\n+}\n+\n+\n+#define execute_test_functions(VBTYPE, RTYPE, STYPE, NAME) \\\n+{ \\\n+  init_##NAME (); \\\n+  vector_tests_##NAME (); \\\n+  verify_results_##NAME (); \\\n+}\n+\n+\n+define_test_functions (int, signed int, signed int, si);\n+define_test_functions (int, unsigned int, unsigned int, ui);\n+define_test_functions (short, signed short, signed short, ss);\n+define_test_functions (short, unsigned short, unsigned short, us);\n+define_test_functions (char, signed char, signed char, sc);\n+define_test_functions (char, unsigned char, unsigned char, uc);\n+define_test_functions (int, signed int, float, ff);\n+\n+int main ()\n+{\n+  execute_test_functions (int, signed int, signed int, si);\n+  execute_test_functions (int, unsigned int, unsigned int, ui);\n+  execute_test_functions (short, signed short, signed short, ss);\n+  execute_test_functions (short, unsigned short, unsigned short, us);\n+  execute_test_functions (char, signed char, signed char, sc);\n+  execute_test_functions (char, unsigned char, unsigned char, uc);\n+  execute_test_functions (int, signed int, float, ff);\n+\n+  return 0;\n+}\n+\n+"}]}