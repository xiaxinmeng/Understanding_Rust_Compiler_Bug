{"sha": "7cc8342c7785ce983d7fc742aaeab84e16d485c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjODM0MmM3Nzg1Y2U5ODNkN2ZjNzQyYWFlYWI4NGUxNmQ0ODVjOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T07:49:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T07:49:20Z"}, "message": "stmt.c (expand_return): Remove always true predicate.\n\n        * stmt.c (expand_return): Remove always true predicate.\n        (expand_decl_cleanup_no_eh): Remove dead code.\n\nFrom-SVN: r40916", "tree": {"sha": "2bbdc312bf1536c721506ddcad553adbab43e68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bbdc312bf1536c721506ddcad553adbab43e68c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc8342c7785ce983d7fc742aaeab84e16d485c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc8342c7785ce983d7fc742aaeab84e16d485c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc8342c7785ce983d7fc742aaeab84e16d485c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc8342c7785ce983d7fc742aaeab84e16d485c8/comments", "author": null, "committer": null, "parents": [{"sha": "ca3c102896ff2472f8c712651f6249de04ba10c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3c102896ff2472f8c712651f6249de04ba10c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3c102896ff2472f8c712651f6249de04ba10c0"}], "stats": {"total": 47, "additions": 8, "deletions": 39}, "files": [{"sha": "eca76ca6024f836e0fbcf3f7947779e14f0c6163", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc8342c7785ce983d7fc742aaeab84e16d485c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc8342c7785ce983d7fc742aaeab84e16d485c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cc8342c7785ce983d7fc742aaeab84e16d485c8", "patch": "@@ -1,5 +1,8 @@\n 2001-03-27  Richard Henderson  <rth@redhat.com>\n \n+\t* stmt.c (expand_return): Remove always true predicate.\n+\t(expand_decl_cleanup_no_eh): Remove dead code.\n+\n \t* sched-deps.c (sched_analyze_insn): Consolidate scheduling\n \tbarrier code.  Add a scheduling barrier if a non-call insn\n \tcan throw internally."}, {"sha": "743f81734290ba8ea037666e9aa08444c34734df", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc8342c7785ce983d7fc742aaeab84e16d485c8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc8342c7785ce983d7fc742aaeab84e16d485c8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=7cc8342c7785ce983d7fc742aaeab84e16d485c8", "patch": "@@ -2922,7 +2922,6 @@ expand_return (retval)\n   rtx result_rtl;\n   register rtx val = 0;\n   tree retval_rhs;\n-  int cleanups;\n \n   /* If function wants no value, give it none.  */\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n@@ -2933,17 +2932,6 @@ expand_return (retval)\n       return;\n     }\n \n-  /* Are any cleanups needed?  E.g. C++ destructors to be run?  */\n-  /* This is not sufficient.  We also need to watch for cleanups of the\n-     expression we are about to expand.  Unfortunately, we cannot know\n-     if it has cleanups until we expand it, and we want to change how we\n-     expand it depending upon if we need cleanups.  We can't win.  */\n-#if 0\n-  cleanups = any_pending_cleanups (1);\n-#else\n-  cleanups = 1;\n-#endif\n-\n   if (retval == error_mark_node)\n     {\n       /* Treat this like a return of no value from a function that\n@@ -2962,9 +2950,7 @@ expand_return (retval)\n   else\n     retval_rhs = NULL_TREE;\n \n-  /* Only use `last_insn' if there are cleanups which must be run.  */\n-  if (cleanups || cleanup_label != 0)\n-    last_insn = get_last_insn ();\n+  last_insn = get_last_insn ();\n \n   /* Distribute return down conditional expr if either of the sides\n      may involve tail recursion (see test below).  This enhances the number\n@@ -3108,11 +3094,10 @@ expand_return (retval)\n \n       expand_value_return (result_reg);\n     }\n-  else if (cleanups\n-      && retval_rhs != 0\n-      && !VOID_TYPE_P (TREE_TYPE (retval_rhs))\n-      && (GET_CODE (result_rtl) == REG\n-\t  || (GET_CODE (result_rtl) == PARALLEL)))\n+  else if (retval_rhs != 0\n+\t   && !VOID_TYPE_P (TREE_TYPE (retval_rhs))\n+\t   && (GET_CODE (result_rtl) == REG\n+\t       || (GET_CODE (result_rtl) == PARALLEL)))\n     {\n       /* Calculate the return value into a temporary (usually a pseudo\n          reg).  */\n@@ -4122,25 +4107,6 @@ expand_decl_cleanup (decl, cleanup)\n   return 1;\n }\n \n-/* Like expand_decl_cleanup, but suppress generating an exception handler\n-   to perform the cleanup.  */\n-\n-#if 0\n-int\n-expand_decl_cleanup_no_eh (decl, cleanup)\n-     tree decl, cleanup;\n-{\n-  int save_eh = using_eh_for_cleanups_p;\n-  int result;\n-\n-  using_eh_for_cleanups_p = 0;\n-  result = expand_decl_cleanup (decl, cleanup);\n-  using_eh_for_cleanups_p = save_eh;\n-\n-  return result;\n-}\n-#endif\n-\n /* Arrange for the top element of the dynamic cleanup chain to be\n    popped if we exit the current binding contour.  DECL is the\n    associated declaration, if any, otherwise NULL_TREE.  If the"}]}