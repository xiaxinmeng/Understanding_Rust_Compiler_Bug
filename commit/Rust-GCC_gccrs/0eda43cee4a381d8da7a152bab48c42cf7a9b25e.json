{"sha": "0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVkYTQzY2VlNGEzODFkOGRhN2ExNTJiYWI0OGM0MmNmN2E5YjI1ZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.stanford.edu", "date": "2000-12-15T04:48:39Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-12-15T04:48:39Z"}, "message": "cppfiles.c (hack_vms_include_specification): Delete function (not used since 1998).\n\n\t* cppfiles.c (hack_vms_include_specification): Delete function\n\t(not used since 1998).\n\nFrom-SVN: r38268", "tree": {"sha": "03ce17bf0fb0e4cdc6334a3b6188a710947a2a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03ce17bf0fb0e4cdc6334a3b6188a710947a2a16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eda43cee4a381d8da7a152bab48c42cf7a9b25e/comments", "author": null, "committer": null, "parents": [{"sha": "4cf37b4a689bd8f97c03247ce0872d1a121e00eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf37b4a689bd8f97c03247ce0872d1a121e00eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf37b4a689bd8f97c03247ce0872d1a121e00eb"}], "stats": {"total": 285, "additions": 5, "deletions": 280}, "files": [{"sha": "a52343aaf834bb9d6ccbba9e05279555c8740040", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eda43cee4a381d8da7a152bab48c42cf7a9b25e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eda43cee4a381d8da7a152bab48c42cf7a9b25e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "patch": "@@ -1,3 +1,8 @@\n+2000-12-14  Zack Weinberg  <zack@wolery.stanford.edu>\n+\n+\t* cppfiles.c (hack_vms_include_specification): Delete function\n+\t(not used since 1998).\n+\n Fri Dec 15 03:37:51 2000  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* haifa-sched.c (sched_init): Don't put a note in front of any BARRIER."}, {"sha": "28bdfd0db4a7b0a2be0543d4ae036903857bff24", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eda43cee4a381d8da7a152bab48c42cf7a9b25e/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eda43cee4a381d8da7a152bab48c42cf7a9b25e/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=0eda43cee4a381d8da7a152bab48c42cf7a9b25e", "patch": "@@ -107,10 +107,6 @@ static void purge_cache \tPARAMS ((struct include_file *));\n static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n \n-#if 0\n-static void hack_vms_include_specification PARAMS ((char *));\n-#endif\n-\n /* We use a splay tree to store information about all the include\n    files seen in this compilation.  The key of each tree node is the\n    physical path to the file.  The value is 0 if the file does not\n@@ -1170,279 +1166,3 @@ _cpp_simplify_pathname (path)\n \n     return;\n }\n-\n-/* It is not clear when this should be used if at all, so I've\n-   disabled it until someone who understands VMS can look at it. */\n-#if 0\n-\n-/* Under VMS we need to fix up the \"include\" specification filename.\n-\n-   Rules for possible conversions\n-\n-\tfullname\t\ttried paths\n-\n-\tname\t\t\tname\n-\t./dir/name\t\t[.dir]name\n-\t/dir/name\t\tdir:name\n-\t/name\t\t\t[000000]name, name\n-\tdir/name\t\tdir:[000000]name, dir:name, dir/name\n-\tdir1/dir2/name\t\tdir1:[dir2]name, dir1:[000000.dir2]name\n-\tpath:/name\t\tpath:[000000]name, path:name\n-\tpath:/dir/name\t\tpath:[000000.dir]name, path:[dir]name\n-\tpath:dir/name\t\tpath:[dir]name\n-\t[path]:[dir]name\t[path.dir]name\n-\tpath/[dir]name\t\t[path.dir]name\n-\n-   The path:/name input is constructed when expanding <> includes. */\n-\n-\n-static void\n-hack_vms_include_specification (fullname)\n-     char *fullname;\n-{\n-  register char *basename, *unixname, *local_ptr, *first_slash;\n-  int f, check_filename_before_returning, must_revert;\n-  char Local[512];\n-\n-  check_filename_before_returning = 0;\n-  must_revert = 0;\n-  /* See if we can find a 1st slash. If not, there's no path information.  */\n-  first_slash = strchr (fullname, '/');\n-  if (first_slash == 0)\n-    return 0;\t\t\t\t/* Nothing to do!!! */\n-\n-  /* construct device spec if none given.  */\n-\n-  if (strchr (fullname, ':') == 0)\n-    {\n-\n-      /* If fullname has a slash, take it as device spec.  */\n-\n-      if (first_slash == fullname)\n-\t{\n-\t  first_slash = strchr (fullname + 1, '/');\t/* 2nd slash ? */\n-\t  if (first_slash)\n-\t    *first_slash = ':';\t\t\t\t/* make device spec  */\n-\t  for (basename = fullname; *basename != 0; basename++)\n-\t    *basename = *(basename+1);\t\t\t/* remove leading slash  */\n-\t}\n-      else if ((first_slash[-1] != '.')\t\t/* keep ':/', './' */\n-\t    && (first_slash[-1] != ':')\n-\t    && (first_slash[-1] != ']'))\t/* or a vms path  */\n-\t{\n-\t  *first_slash = ':';\n-\t}\n-      else if ((first_slash[1] == '[')\t\t/* skip './' in './[dir'  */\n-\t    && (first_slash[-1] == '.'))\n-\tfullname += 2;\n-    }\n-\n-  /* Get part after first ':' (basename[-1] == ':')\n-     or last '/' (basename[-1] == '/').  */\n-\n-  basename = base_name (fullname);\n-\n-  local_ptr = Local;\t\t\t/* initialize */\n-\n-  /* We are trying to do a number of things here.  First of all, we are\n-     trying to hammer the filenames into a standard format, such that later\n-     processing can handle them.\n-     \n-     If the file name contains something like [dir.], then it recognizes this\n-     as a root, and strips the \".]\".  Later processing will add whatever is\n-     needed to get things working properly.\n-     \n-     If no device is specified, then the first directory name is taken to be\n-     a device name (or a rooted logical).  */\n-\n-  /* Point to the UNIX filename part (which needs to be fixed!)\n-     but skip vms path information.\n-     [basename != fullname since first_slash != 0].  */\n-\n-  if ((basename[-1] == ':')\t\t/* vms path spec.  */\n-      || (basename[-1] == ']')\n-      || (basename[-1] == '>'))\n-    unixname = basename;\n-  else\n-    unixname = fullname;\n-\n-  if (*unixname == '/')\n-    unixname++;\n-\n-  /* If the directory spec is not rooted, we can just copy\n-     the UNIX filename part and we are done.  */\n-\n-  if (((basename - fullname) > 1)\n-     && (  (basename[-1] == ']')\n-        || (basename[-1] == '>')))\n-    {\n-      if (basename[-2] != '.')\n-\t{\n-\n-\t/* The VMS part ends in a `]', and the preceding character is not a `.'.\n-\t   -> PATH]:/name (basename = '/name', unixname = 'name')\n-\t   We strip the `]', and then splice the two parts of the name in the\n-\t   usual way.  Given the default locations for include files,\n-\t   we will only use this code if the user specifies alternate locations\n-\t   with the /include (-I) switch on the command line.  */\n-\n-\t  basename -= 1;\t/* Strip \"]\" */\n-\t  unixname--;\t\t/* backspace */\n-\t}\n-      else\n-\t{\n-\n-\t/* The VMS part has a \".]\" at the end, and this will not do.  Later\n-\t   processing will add a second directory spec, and this would be a syntax\n-\t   error.  Thus we strip the \".]\", and thus merge the directory specs.\n-\t   We also backspace unixname, so that it points to a '/'.  This inhibits the\n-\t   generation of the 000000 root directory spec (which does not belong here\n-\t   in this case).  */\n-\n-\t  basename -= 2;\t/* Strip \".]\" */\n-\t  unixname--;\t\t/* backspace */\n-\t}\n-    }\n-\n-  else\n-\n-    {\n-\n-      /* We drop in here if there is no VMS style directory specification yet.\n-         If there is no device specification either, we make the first dir a\n-         device and try that.  If we do not do this, then we will be essentially\n-         searching the users default directory (as if they did a #include \"asdf.h\").\n-        \n-         Then all we need to do is to push a '[' into the output string. Later\n-         processing will fill this in, and close the bracket.  */\n-\n-      if ((unixname != fullname)\t/* vms path spec found.  */\n-\t && (basename[-1] != ':'))\n-\t*local_ptr++ = ':';\t\t/* dev not in spec.  take first dir */\n-\n-      *local_ptr++ = '[';\t\t/* Open the directory specification */\n-    }\n-\n-    if (unixname == fullname)\t\t/* no vms dir spec.  */\n-      {\n-\tmust_revert = 1;\n-\tif ((first_slash != 0)\t\t/* unix dir spec.  */\n-\t    && (*unixname != '/')\t/* not beginning with '/'  */\n-\t    && (*unixname != '.'))\t/* or './' or '../'  */\n-\t  *local_ptr++ = '.';\t\t/* dir is local !  */\n-      }\n-\n-  /* at this point we assume that we have the device spec, and (at least\n-     the opening \"[\" for a directory specification.  We may have directories\n-     specified already.\n-\n-     If there are no other slashes then the filename will be\n-     in the \"root\" directory.  Otherwise, we need to add\n-     directory specifications.  */\n-\n-  if (strchr (unixname, '/') == 0)\n-    {\n-      /* if no directories specified yet and none are following.  */\n-      if (local_ptr[-1] == '[')\n-\t{\n-\t  /* Just add \"000000]\" as the directory string */\n-\t  strcpy (local_ptr, \"000000]\");\n-\t  local_ptr += strlen (local_ptr);\n-\t  check_filename_before_returning = 1; /* we might need to fool with this later */\n-\t}\n-    }\n-  else\n-    {\n-\n-      /* As long as there are still subdirectories to add, do them.  */\n-      while (strchr (unixname, '/') != 0)\n-\t{\n-\t  /* If this token is \".\" we can ignore it\n-\t       if it's not at the beginning of a path.  */\n-\t  if ((unixname[0] == '.') && (unixname[1] == '/'))\n-\t    {\n-\t      /* remove it at beginning of path.  */\n-\t      if (  ((unixname == fullname)\t\t/* no device spec  */\n-\t\t    && (fullname+2 != basename))\t/* starts with ./ */\n-\t\t\t\t\t\t\t/* or  */\n-\t\t || ((basename[-1] == ':')\t\t/* device spec  */\n-\t\t    && (unixname-1 == basename)))\t/* and ./ afterwards  */\n-\t\t*local_ptr++ = '.';\t\t \t/* make '[.' start of path.  */\n-\t      unixname += 2;\n-\t      continue;\n-\t    }\n-\n-\t  /* Add a subdirectory spec. Do not duplicate \".\" */\n-\t  if (  local_ptr[-1] != '.'\n-\t     && local_ptr[-1] != '['\n-\t     && local_ptr[-1] != '<')\n-\t    *local_ptr++ = '.';\n-\n-\t  /* If this is \"..\" then the spec becomes \"-\" */\n-\t  if (  (unixname[0] == '.')\n-\t     && (unixname[1] == '.')\n-\t     && (unixname[2] == '/'))\n-\t    {\n-\t      /* Add \"-\" and skip the \"..\" */\n-\t      if ((local_ptr[-1] == '.')\n-\t\t  && (local_ptr[-2] == '['))\n-\t\tlocal_ptr--;\t\t\t/* prevent [.-  */\n-\t      *local_ptr++ = '-';\n-\t      unixname += 3;\n-\t      continue;\n-\t    }\n-\n-\t  /* Copy the subdirectory */\n-\t  while (*unixname != '/')\n-\t    *local_ptr++= *unixname++;\n-\n-\t  unixname++;\t\t\t/* Skip the \"/\" */\n-\t}\n-\n-      /* Close the directory specification */\n-      if (local_ptr[-1] == '.')\t\t/* no trailing periods */\n-\tlocal_ptr--;\n-\n-      if (local_ptr[-1] == '[')\t\t/* no dir needed */\n-\tlocal_ptr--;\n-      else\n-\t*local_ptr++ = ']';\n-    }\n-\n-  /* Now add the filename.  */\n-\n-  while (*unixname)\n-    *local_ptr++ = *unixname++;\n-  *local_ptr = 0;\n-\n-  /* Now append it to the original VMS spec.  */\n-\n-  strcpy ((must_revert==1)?fullname:basename, Local);\n-\n-  /* If we put a [000000] in the filename, try to open it first. If this fails,\n-     remove the [000000], and return that name.  This provides flexibility\n-     to the user in that they can use both rooted and non-rooted logical names\n-     to point to the location of the file.  */\n-\n-  if (check_filename_before_returning)\n-    {\n-      f = open (fullname, O_RDONLY|O_NONBLOCK);\n-      if (f >= 0)\n-\t{\n-\t  /* The file name is OK as it is, so return it as is.  */\n-\t  close (f);\n-\t  return 1;\n-\t}\n-\n-      /* The filename did not work.  Try to remove the [000000] from the name,\n-\t and return it.  */\n-\n-      basename = strchr (fullname, '[');\n-      local_ptr = strchr (fullname, ']') + 1;\n-      strcpy (basename, local_ptr);\t\t/* this gets rid of it */\n-\n-    }\n-\n-  return 1;\n-}\n-#endif\t/* VMS */"}]}