{"sha": "7c4acac3a0798a62340897eae76da5037467135e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0YWNhYzNhMDc5OGE2MjM0MDg5N2VhZTc2ZGE1MDM3NDY3MTM1ZQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-11-04T14:35:45Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-11-04T14:35:45Z"}, "message": "trans-expr.c (gfc_trans_assignment_1): Character kind conversion may create a loop variant temporary, too.\n\ngcc/fortran/ChangeLog:\n\n2017-11-04  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* trans-expr.c (gfc_trans_assignment_1): Character kind conversion may\n\tcreate a loop variant temporary, too.\n\t* trans-intrinsic.c (conv_caf_send): Treat char arrays as arrays and\n\tnot as scalars.\n\t* trans.c (get_array_span): Take the character kind into account when\n\tdoing pointer arithmetic.\n\ngcc/testsuite/ChangeLog:\n\n2017-11-04  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray/send_char_array_1.f90: New test.\n\nFrom-SVN: r254407", "tree": {"sha": "2f811bb90155e0c76c2a98b08976dad434ff5674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f811bb90155e0c76c2a98b08976dad434ff5674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4acac3a0798a62340897eae76da5037467135e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4acac3a0798a62340897eae76da5037467135e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4acac3a0798a62340897eae76da5037467135e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4acac3a0798a62340897eae76da5037467135e/comments", "author": null, "committer": null, "parents": [{"sha": "0260e27840e7de9b5ade7c323ee61cca61e5631f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0260e27840e7de9b5ade7c323ee61cca61e5631f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0260e27840e7de9b5ade7c323ee61cca61e5631f"}], "stats": {"total": 106, "additions": 95, "deletions": 11}, "files": [{"sha": "40c1100833fa711754e23d41e0723a7136c3512c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -1,3 +1,12 @@\n+2017-11-04  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* trans-expr.c (gfc_trans_assignment_1): Character kind conversion may\n+\tcreate a loop variant temporary, too.\n+\t* trans-intrinsic.c (conv_caf_send): Treat char arrays as arrays and\n+\tnot as scalars.\n+\t* trans.c (get_array_span): Take the character kind into account when\n+\tdoing pointer arithmetic.\n+\n 2017-11-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/29600"}, {"sha": "57b62a6b0c00b82b2c0f5c1b514f17a24de908d3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -10084,12 +10084,16 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n      NOTE: This relies on having the exact dependence of the length type\n      parameter available to the caller; gfortran saves it in the .mod files.\n      NOTE ALSO: The concatenation operation generates a temporary pointer,\n-     whose allocation must go to the innermost loop.  */\n+     whose allocation must go to the innermost loop.\n+     NOTE ALSO (2): A character conversion may generate a temporary, too.  */\n   if (flag_realloc_lhs\n       && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred\n       && !(lss != gfc_ss_terminator\n-\t   && expr2->expr_type == EXPR_OP\n-\t   && expr2->value.op.op == INTRINSIC_CONCAT))\n+\t   && ((expr2->expr_type == EXPR_OP\n+\t\t&& expr2->value.op.op == INTRINSIC_CONCAT)\n+\t       || (expr2->expr_type == EXPR_FUNCTION\n+\t\t   && expr2->value.function.isym != NULL\n+\t\t   && expr2->value.function.isym->id == GFC_ISYM_CONVERSION))))\n     gfc_add_block_to_block (&block, &rse.pre);\n \n   /* Nullify the allocatable components corresponding to those of the lhs"}, {"sha": "b0f0ab21891e4dcc5d59b9dda84585042b0b01f9", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -1871,12 +1871,21 @@ conv_caf_send (gfc_code *code) {\n   gfc_init_se (&lhs_se, NULL);\n   if (lhs_expr->rank == 0)\n     {\n-      symbol_attribute attr;\n-      gfc_clear_attr (&attr);\n-      gfc_conv_expr (&lhs_se, lhs_expr);\n-      lhs_type = TREE_TYPE (lhs_se.expr);\n-      lhs_se.expr = gfc_conv_scalar_to_descriptor (&lhs_se, lhs_se.expr, attr);\n-      lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n+      if (lhs_expr->ts.type == BT_CHARACTER && lhs_expr->ts.deferred)\n+\t{\n+\t  lhs_se.expr = gfc_get_tree_for_caf_expr (lhs_expr);\n+\t  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n+\t}\n+      else\n+\t{\n+\t  symbol_attribute attr;\n+\t  gfc_clear_attr (&attr);\n+\t  gfc_conv_expr (&lhs_se, lhs_expr);\n+\t  lhs_type = TREE_TYPE (lhs_se.expr);\n+\t  lhs_se.expr = gfc_conv_scalar_to_descriptor (&lhs_se, lhs_se.expr,\n+\t\t\t\t\t\t       attr);\n+\t  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n+\t}\n     }\n   else if ((lhs_caf_attr.alloc_comp || lhs_caf_attr.pointer_comp)\n \t   && lhs_caf_attr.codimension)"}, {"sha": "411530884de058877d4ffbe7b4e0355df13aec99", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -320,8 +320,12 @@ get_array_span (tree type, tree decl)\n \t  || DECL_CONTEXT (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n \t\t\t\t\t== DECL_CONTEXT (decl)))\n     {\n-      span = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-      span = fold_convert (gfc_array_index_type, span);\n+      span = fold_convert (gfc_array_index_type,\n+\t\t\t   TYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n+      span = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t  fold_convert (gfc_array_index_type,\n+\t\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (type))),\n+\t\t\t  span);\n     }\n   /* Likewise for class array or pointer array references.  */\n   else if (TREE_CODE (decl) == FIELD_DECL"}, {"sha": "854d957170086b7412aa256673f0f98ac7323de9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -1,3 +1,7 @@\n+2017-11-04  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray/send_char_array_1.f90: New test.\n+\n 2017-11-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/70330"}, {"sha": "800a8acc34c4202b959d41249c52ba03f5156771", "filename": "gcc/testsuite/gfortran.dg/coarray/send_char_array_1.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_char_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4acac3a0798a62340897eae76da5037467135e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_char_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_char_array_1.f90?ref=7c4acac3a0798a62340897eae76da5037467135e", "patch": "@@ -0,0 +1,54 @@\n+!{ dg-do run }\n+ \n+program send_convert_char_array\n+\n+  implicit none\n+\n+  character(kind=1, len=:), allocatable, codimension[:] :: co_str_k1_scal\n+  character(kind=1, len=:), allocatable :: str_k1_scal\n+  character(kind=4, len=:), allocatable, codimension[:] :: co_str_k4_scal\n+  character(kind=4, len=:), allocatable :: str_k4_scal\n+\n+  character(kind=1, len=:), allocatable, codimension[:] :: co_str_k1_arr(:)\n+  character(kind=1, len=:), allocatable :: str_k1_arr(:)\n+  character(kind=4, len=:), allocatable, codimension[:] :: co_str_k4_arr(:)\n+  character(kind=4, len=:), allocatable :: str_k4_arr(:)\n+\n+  allocate(str_k1_scal, SOURCE='abcdefghij')\n+  allocate(str_k4_scal, SOURCE=4_'abcdefghij')\n+  allocate(character(len=20)::co_str_k1_scal[*]) ! allocate syncs here\n+  allocate(character(kind=4, len=20)::co_str_k4_scal[*]) ! allocate syncs here\n+\n+  allocate(str_k1_arr, SOURCE=['abc', 'EFG', 'klm', 'NOP'])\n+  allocate(str_k4_arr, SOURCE=[4_'abc', 4_'EFG', 4_'klm', 4_'NOP'])\n+  allocate(character(len=5)::co_str_k1_arr(4)[*])\n+  allocate(character(kind=4, len=5)::co_str_k4_arr(4)[*])\n+\n+  ! First check send/copy to self\n+  co_str_k1_scal[1] = str_k1_scal\n+  if (co_str_k1_scal /= str_k1_scal // '          ') call abort()\n+\n+  co_str_k4_scal[1] = str_k4_scal\n+  if (co_str_k4_scal /= str_k4_scal // 4_'          ') call abort()\n+\n+  co_str_k4_scal[1] = str_k1_scal\n+  if (co_str_k4_scal /= str_k4_scal // 4_'          ') call abort()\n+\n+  co_str_k1_scal[1] = str_k4_scal\n+  if (co_str_k1_scal /= str_k1_scal // '          ') call abort()\n+\n+  co_str_k1_arr(:)[1] = str_k1_arr\n+  if (any(co_str_k1_arr /= ['abc  ', 'EFG  ', 'klm  ', 'NOP  '])) call abort()\n+ \n+  co_str_k4_arr(:)[1] = [4_'abc', 4_'EFG', 4_'klm', 4_'NOP']! str_k4_arr\n+  if (any(co_str_k4_arr /= [4_'abc  ', 4_'EFG  ', 4_'klm  ', 4_'NOP  '])) call abort()\n+\n+  co_str_k4_arr(:)[1] = str_k1_arr\n+  if (any(co_str_k4_arr /= [ 4_'abc  ', 4_'EFG  ', 4_'klm  ', 4_'NOP  '])) call abort()\n+\n+  co_str_k1_arr(:)[1] = str_k4_arr\n+  if (any(co_str_k1_arr /= ['abc  ', 'EFG  ', 'klm  ', 'NOP  '])) call abort()\n+\n+end program send_convert_char_array\n+\n+! vim:ts=2:sts=2:sw=2:"}]}