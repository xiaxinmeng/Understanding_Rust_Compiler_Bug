{"sha": "ed3de62ac949c92ad41ef6de7cc926fbb2a510ce", "node_id": "C_kwDOANBUbNoAKGVkM2RlNjJhYzk0OWM5MmFkNDFlZjZkZTdjYzkyNmZiYjJhNTEwY2U", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-10-29T11:45:41Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-10-29T11:45:41Z"}, "message": "middle-end: Update the Arm complex numbers auto-vec detection to the new format of the SLP tree.\n\nThe layout of the SLP tree has changed in GCC 12 which\nbroke the detection of complex FMA and FMS.\n\nThis patch updates the detection to the new tree shape\nand by necessity merges the complex MUL and FMA detection\ninto one.\n\nThis does not yet address the wrong code-gen PR which I\nwill fix in a different patch as that needs backporting.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102977\n\t* tree-vect-slp-patterns.c (vect_match_call_p): Remove.\n\t(vect_detect_pair_op): Add crosslane check.\n\t(vect_match_call_complex_mla): Remove.\n\t(class complex_mul_pattern): Update comment.\n\t(complex_mul_pattern::matches): Update detection.\n\t(class complex_fma_pattern): Remove.\n\t(complex_fma_pattern::matches): Remove.\n\t(complex_fma_pattern::recognize): Remove.\n\t(complex_fma_pattern::build): Remove.\n\t(class complex_fms_pattern):  Update comment.\n\t(complex_fms_pattern::matches): Remove.\n\t(complex_operations_pattern::recognize): Remove complex_fma_pattern", "tree": {"sha": "40140a219dc8aa15d6b0f6fc5ffb21b5b68dfb7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40140a219dc8aa15d6b0f6fc5ffb21b5b68dfb7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ba6a819de6f4aacf9d69725f64496d20edd5a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ba6a819de6f4aacf9d69725f64496d20edd5a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ba6a819de6f4aacf9d69725f64496d20edd5a1"}], "stats": {"total": 367, "additions": 124, "deletions": 243}, "files": [{"sha": "99dea82aba91a333500bb5ff35bf30b6416c09ca", "filename": "gcc/tree-vect-slp-patterns.c", "status": "modified", "additions": 124, "deletions": 243, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce/gcc%2Ftree-vect-slp-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3de62ac949c92ad41ef6de7cc926fbb2a510ce/gcc%2Ftree-vect-slp-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.c?ref=ed3de62ac949c92ad41ef6de7cc926fbb2a510ce", "patch": "@@ -306,24 +306,6 @@ vect_match_expression_p (slp_tree node, tree_code code)\n   return true;\n }\n \n-/* Checks to see if the expression represented by NODE is a call to the internal\n-   function FN.  */\n-\n-static inline bool\n-vect_match_call_p (slp_tree node, internal_fn fn)\n-{\n-  if (!node\n-      || !SLP_TREE_REPRESENTATIVE (node))\n-    return false;\n-\n-  gimple* expr = STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (node));\n-  if (!expr\n-      || !gimple_call_internal_p (expr, fn))\n-    return false;\n-\n-   return true;\n-}\n-\n /* Check if the given lane permute in PERMUTES matches an alternating sequence\n    of {even odd even odd ...}.  This to account for unrolled loops.  Further\n    mode there resulting permute must be linear.   */\n@@ -389,6 +371,16 @@ vect_detect_pair_op (slp_tree node1, slp_tree node2, lane_permutation_t &lanes,\n \n   if (result != CMPLX_NONE && ops != NULL)\n     {\n+      if (two_operands)\n+\t{\n+\t  auto l0node = SLP_TREE_CHILDREN (node1);\n+\t  auto l1node = SLP_TREE_CHILDREN (node2);\n+\n+\t  /* Check if the tree is connected as we expect it.  */\n+\t  if (!((l0node[0] == l1node[0] && l0node[1] == l1node[1])\n+\t      || (l0node[0] == l1node[1] && l0node[1] == l1node[0])))\n+\t    return CMPLX_NONE;\n+\t}\n       ops->safe_push (node1);\n       ops->safe_push (node2);\n     }\n@@ -717,27 +709,6 @@ complex_add_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n  * complex_mul_pattern\n  ******************************************************************************/\n \n-/* Helper function of that looks for a match in the CHILDth child of NODE.  The\n-   child used is stored in RES.\n-\n-   If the match is successful then ARGS will contain the operands matched\n-   and the complex_operation_t type is returned.  If match is not successful\n-   then CMPLX_NONE is returned and ARGS is left unmodified.  */\n-\n-static inline complex_operation_t\n-vect_match_call_complex_mla (slp_tree node, unsigned child,\n-\t\t\t     vec<slp_tree> *args = NULL, slp_tree *res = NULL)\n-{\n-  gcc_assert (child < SLP_TREE_CHILDREN (node).length ());\n-\n-  slp_tree data = SLP_TREE_CHILDREN (node)[child];\n-\n-  if (res)\n-    *res = data;\n-\n-  return vect_detect_pair_op (data, false, args);\n-}\n-\n /* Check to see if either of the trees in ARGS are a NEGATE_EXPR.  If the first\n    child (args[0]) is a NEGATE_EXPR then NEG_FIRST_P is set to TRUE.\n \n@@ -945,9 +916,10 @@ class complex_mul_pattern : public complex_pattern\n \n };\n \n-/* Pattern matcher for trying to match complex multiply pattern in SLP tree\n-   If the operation matches then IFN is set to the operation it matched\n-   and the arguments to the two replacement statements are put in m_ops.\n+/* Pattern matcher for trying to match complex multiply and complex multiply\n+   and accumulate pattern in SLP tree.  If the operation matches then IFN\n+   is set to the operation it matched and the arguments to the two\n+   replacement statements are put in m_ops.\n \n    If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n \n@@ -972,19 +944,43 @@ complex_mul_pattern::matches (complex_operation_t op,\n   if (op != MINUS_PLUS)\n     return IFN_LAST;\n \n-  slp_tree root = *node;\n-  /* First two nodes must be a multiply.  */\n-  auto_vec<slp_tree> muls;\n-  if (vect_match_call_complex_mla (root, 0) != MULT_MULT\n-      || vect_match_call_complex_mla (root, 1, &muls) != MULT_MULT)\n+  auto childs = *ops;\n+  auto l0node = SLP_TREE_CHILDREN (childs[0]);\n+  auto l1node = SLP_TREE_CHILDREN (childs[1]);\n+\n+  bool mul0 = vect_match_expression_p (l0node[0], MULT_EXPR);\n+  bool mul1 = vect_match_expression_p (l0node[1], MULT_EXPR);\n+  if (!mul0 && !mul1)\n     return IFN_LAST;\n \n   /* Now operand2+4 may lead to another expression.  */\n   auto_vec<slp_tree> left_op, right_op;\n-  left_op.safe_splice (SLP_TREE_CHILDREN (muls[0]));\n-  right_op.safe_splice (SLP_TREE_CHILDREN (muls[1]));\n+  slp_tree add0 = NULL;\n+\n+  /* Check if we may be a multiply add.  */\n+  if (!mul0\n+      && vect_match_expression_p (l0node[0], PLUS_EXPR))\n+    {\n+      auto vals = SLP_TREE_CHILDREN (l0node[0]);\n+      /* Check if it's a multiply, otherwise no idea what this is.  */\n+      if (!vect_match_expression_p (vals[1], MULT_EXPR))\n+\treturn IFN_LAST;\n+\n+      /* Check if the ADD is linear, otherwise it's not valid complex FMA.  */\n+      if (linear_loads_p (perm_cache, vals[0]) != PERM_EVENODD)\n+\treturn IFN_LAST;\n \n-  if (linear_loads_p (perm_cache, left_op[1]) == PERM_ODDEVEN)\n+      left_op.safe_splice (SLP_TREE_CHILDREN (vals[1]));\n+      add0 = vals[0];\n+    }\n+  else\n+    left_op.safe_splice (SLP_TREE_CHILDREN (l0node[0]));\n+\n+  right_op.safe_splice (SLP_TREE_CHILDREN (l0node[1]));\n+\n+  if (left_op.length () != 2\n+      || right_op.length () != 2\n+      || linear_loads_p (perm_cache, left_op[1]) == PERM_ODDEVEN)\n     return IFN_LAST;\n \n   bool neg_first = false;\n@@ -998,23 +994,32 @@ complex_mul_pattern::matches (complex_operation_t op,\n       if (!vect_validate_multiplication (perm_cache, left_op, PERM_EVENEVEN)\n \t  || vect_normalize_conj_loc (left_op))\n \treturn IFN_LAST;\n-      ifn = IFN_COMPLEX_MUL;\n+      if (!mul0)\n+\tifn = IFN_COMPLEX_FMA;\n+      else\n+\tifn = IFN_COMPLEX_MUL;\n     }\n-  else if (is_neg)\n+  else\n     {\n       if (!vect_validate_multiplication (perm_cache, left_op, right_op,\n \t\t\t\t\t neg_first, &conj_first_operand,\n \t\t\t\t\t false))\n \treturn IFN_LAST;\n \n-      ifn = IFN_COMPLEX_MUL_CONJ;\n+      if(!mul0)\n+\tifn = IFN_COMPLEX_FMA_CONJ;\n+      else\n+\tifn = IFN_COMPLEX_MUL_CONJ;\n     }\n \n   if (!vect_pattern_validate_optab (ifn, *node))\n     return IFN_LAST;\n \n   ops->truncate (0);\n-  ops->create (3);\n+  ops->create (add0 ? 4 : 3);\n+\n+  if (add0)\n+    ops->quick_push (add0);\n \n   complex_perm_kinds_t kind = linear_loads_p (perm_cache, left_op[0]);\n   if (kind == PERM_EVENODD)\n@@ -1070,170 +1075,55 @@ complex_mul_pattern::build (vec_info *vinfo)\n {\n   slp_tree node;\n   unsigned i;\n-  slp_tree newnode\n-    = vect_build_combine_node (this->m_ops[0], this->m_ops[1], *this->m_node);\n-  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n-\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n-    vect_free_slp_tree (node);\n-\n-  /* First re-arrange the children.  */\n-  SLP_TREE_CHILDREN (*this->m_node).reserve_exact (2);\n-  SLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[2];\n-  SLP_TREE_CHILDREN (*this->m_node)[1] = newnode;\n+  switch (this->m_ifn)\n+  {\n+    case IFN_COMPLEX_MUL:\n+    case IFN_COMPLEX_MUL_CONJ:\n+      {\n+\tslp_tree newnode\n+\t  = vect_build_combine_node (this->m_ops[0], this->m_ops[1],\n+\t\t\t\t     *this->m_node);\n+\tSLP_TREE_REF_COUNT (this->m_ops[2])++;\n+\n+\tFOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n+\t  vect_free_slp_tree (node);\n+\n+\t/* First re-arrange the children.  */\n+\tSLP_TREE_CHILDREN (*this->m_node).reserve_exact (2);\n+\tSLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[2];\n+\tSLP_TREE_CHILDREN (*this->m_node)[1] = newnode;\n+\tbreak;\n+      }\n+    case IFN_COMPLEX_FMA:\n+    case IFN_COMPLEX_FMA_CONJ:\n+      {\n+\tSLP_TREE_REF_COUNT (this->m_ops[0])++;\n+\tslp_tree newnode\n+\t  = vect_build_combine_node (this->m_ops[1], this->m_ops[2],\n+\t\t\t\t     *this->m_node);\n+\tSLP_TREE_REF_COUNT (this->m_ops[3])++;\n+\n+\tFOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (*this->m_node), i, node)\n+\t  vect_free_slp_tree (node);\n+\n+\t/* First re-arrange the children.  */\n+\tSLP_TREE_CHILDREN (*this->m_node).safe_grow (3);\n+\tSLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[0];\n+\tSLP_TREE_CHILDREN (*this->m_node)[1] = this->m_ops[3];\n+\tSLP_TREE_CHILDREN (*this->m_node)[2] = newnode;\n+\n+\t/* Tell the builder to expect an extra argument.  */\n+\tthis->m_num_args++;\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+  }\n \n   /* And then rewrite the node itself.  */\n   complex_pattern::build (vinfo);\n }\n \n-/*******************************************************************************\n- * complex_fma_pattern class\n- ******************************************************************************/\n-\n-class complex_fma_pattern : public complex_pattern\n-{\n-  protected:\n-    complex_fma_pattern (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n-      : complex_pattern (node, m_ops, ifn)\n-    {\n-      this->m_num_args = 3;\n-    }\n-\n-  public:\n-    void build (vec_info *);\n-    static internal_fn\n-    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n-\t     vec<slp_tree> *);\n-\n-    static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n-\n-    static vect_pattern*\n-    mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n-    {\n-      return new complex_fma_pattern (node, m_ops, ifn);\n-    }\n-};\n-\n-/* Pattern matcher for trying to match complex multiply and accumulate\n-   and multiply and subtract patterns in SLP tree.\n-   If the operation matches then IFN is set to the operation it matched and\n-   the arguments to the two replacement statements are put in m_ops.\n-\n-   If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n-\n-   This function matches the patterns shaped as:\n-\n-   double ax = (b[i+1] * a[i]) + (b[i] * a[i]);\n-   double bx = (a[i+1] * b[i]) - (a[i+1] * b[i+1]);\n-\n-   c[i] = c[i] - ax;\n-   c[i+1] = c[i+1] + bx;\n-\n-   If a match occurred then TRUE is returned, else FALSE.  The match is\n-   performed after COMPLEX_MUL which would have done the majority of the work.\n-   This function merely matches an ADD with a COMPLEX_MUL IFN.  The initial\n-   match is expected to be in OP1 and the initial match operands in args0.  */\n-\n-internal_fn\n-complex_fma_pattern::matches (complex_operation_t op,\n-\t\t\t      slp_tree_to_load_perm_map_t * /* perm_cache */,\n-\t\t\t      slp_tree *ref_node, vec<slp_tree> *ops)\n-{\n-  internal_fn ifn = IFN_LAST;\n-\n-  /* Find the two components.  We match Complex MUL first which reduces the\n-     amount of work this pattern has to do.  After that we just match the\n-     head node and we're done.:\n-\n-     * FMA: + +.\n-\n-     We need to ignore the two_operands nodes that may also match.\n-     For that we can check if they have any scalar statements and also\n-     check that it's not a permute node as we're looking for a normal\n-     PLUS_EXPR operation.  */\n-  if (op != CMPLX_NONE)\n-    return IFN_LAST;\n-\n-  /* Find the two components.  We match Complex MUL first which reduces the\n-     amount of work this pattern has to do.  After that we just match the\n-     head node and we're done.:\n-\n-   * FMA: + + on a non-two_operands node.  */\n-  slp_tree vnode = *ref_node;\n-  if (SLP_TREE_LANE_PERMUTATION (vnode).exists ()\n-      || !SLP_TREE_CHILDREN (vnode).exists ()\n-      || !vect_match_expression_p (vnode, PLUS_EXPR))\n-    return IFN_LAST;\n-\n-  slp_tree node = SLP_TREE_CHILDREN (vnode)[1];\n-\n-  if (vect_match_call_p (node, IFN_COMPLEX_MUL))\n-    ifn = IFN_COMPLEX_FMA;\n-  else if (vect_match_call_p (node, IFN_COMPLEX_MUL_CONJ))\n-    ifn = IFN_COMPLEX_FMA_CONJ;\n-  else\n-    return IFN_LAST;\n-\n-  if (!vect_pattern_validate_optab (ifn, vnode))\n-    return IFN_LAST;\n-\n-  ops->truncate (0);\n-  ops->create (3);\n-\n-  if (ifn == IFN_COMPLEX_FMA)\n-    {\n-      ops->quick_push (SLP_TREE_CHILDREN (vnode)[0]);\n-      ops->quick_push (SLP_TREE_CHILDREN (node)[1]);\n-      ops->quick_push (SLP_TREE_CHILDREN (node)[0]);\n-    }\n-  else\n-    {\n-      ops->quick_push (SLP_TREE_CHILDREN (vnode)[0]);\n-      ops->quick_push (SLP_TREE_CHILDREN (node)[0]);\n-      ops->quick_push (SLP_TREE_CHILDREN (node)[1]);\n-    }\n-\n-  return ifn;\n-}\n-\n-/* Attempt to recognize a complex mul pattern.  */\n-\n-vect_pattern*\n-complex_fma_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n-\t\t\t\tslp_tree *node)\n-{\n-  auto_vec<slp_tree> ops;\n-  complex_operation_t op\n-    = vect_detect_pair_op (*node, true, &ops);\n-  internal_fn ifn\n-    = complex_fma_pattern::matches (op, perm_cache, node, &ops);\n-  if (ifn == IFN_LAST)\n-    return NULL;\n-\n-  return new complex_fma_pattern (node, &ops, ifn);\n-}\n-\n-/* Perform a replacement of the detected complex mul pattern with the new\n-   instruction sequences.  */\n-\n-void\n-complex_fma_pattern::build (vec_info *vinfo)\n-{\n-  slp_tree node = SLP_TREE_CHILDREN (*this->m_node)[1];\n-\n-  SLP_TREE_CHILDREN (*this->m_node).release ();\n-  SLP_TREE_CHILDREN (*this->m_node).create (3);\n-  SLP_TREE_CHILDREN (*this->m_node).safe_splice (this->m_ops);\n-\n-  SLP_TREE_REF_COUNT (this->m_ops[1])++;\n-  SLP_TREE_REF_COUNT (this->m_ops[2])++;\n-\n-  vect_free_slp_tree (node);\n-\n-  complex_pattern::build (vinfo);\n-}\n-\n /*******************************************************************************\n  * complex_fms_pattern class\n  ******************************************************************************/\n@@ -1264,10 +1154,10 @@ class complex_fms_pattern : public complex_pattern\n };\n \n \n-/* Pattern matcher for trying to match complex multiply and accumulate\n-   and multiply and subtract patterns in SLP tree.\n-   If the operation matches then IFN is set to the operation it matched and\n-   the arguments to the two replacement statements are put in m_ops.\n+/* Pattern matcher for trying to match complex multiply and subtract pattern\n+   in SLP tree.  If the operation matches then IFN is set to the operation\n+   it matched and the arguments to the two replacement statements are put in\n+   m_ops.\n \n    If no match is found then IFN is set to IFN_LAST and m_ops is unchanged.\n \n@@ -1289,38 +1179,33 @@ complex_fms_pattern::matches (complex_operation_t op,\n {\n   internal_fn ifn = IFN_LAST;\n \n-  /* Find the two components.  We match Complex MUL first which reduces the\n-     amount of work this pattern has to do.  After that we just match the\n-     head node and we're done.:\n-\n-     * FMS: - +.  */\n-  slp_tree child = NULL;\n-\n   /* We need to ignore the two_operands nodes that may also match,\n      for that we can check if they have any scalar statements and also\n      check that it's not a permute node as we're looking for a normal\n-     PLUS_EXPR operation.  */\n-  if (op != PLUS_MINUS)\n+     MINUS_EXPR operation.  */\n+  if (op != CMPLX_NONE)\n     return IFN_LAST;\n \n-  child = SLP_TREE_CHILDREN ((*ops)[1])[1];\n-  if (vect_detect_pair_op (child) != MINUS_PLUS)\n+  slp_tree root = *ref_node;\n+  if (!vect_match_expression_p (root, MINUS_EXPR))\n     return IFN_LAST;\n \n-  /* First two nodes must be a multiply.  */\n-  auto_vec<slp_tree> muls;\n-  if (vect_match_call_complex_mla (child, 0) != MULT_MULT\n-      || vect_match_call_complex_mla (child, 1, &muls) != MULT_MULT)\n+  auto nodes = SLP_TREE_CHILDREN (root);\n+  if (!vect_match_expression_p (nodes[1], MULT_EXPR)\n+      || vect_detect_pair_op (nodes[0]) != PLUS_MINUS)\n     return IFN_LAST;\n \n+  auto childs = SLP_TREE_CHILDREN (nodes[0]);\n+  auto l0node = SLP_TREE_CHILDREN (childs[0]);\n+  auto l1node = SLP_TREE_CHILDREN (childs[1]);\n+\n   /* Now operand2+4 may lead to another expression.  */\n   auto_vec<slp_tree> left_op, right_op;\n-  left_op.safe_splice (SLP_TREE_CHILDREN (muls[0]));\n-  right_op.safe_splice (SLP_TREE_CHILDREN (muls[1]));\n+  left_op.safe_splice (SLP_TREE_CHILDREN (l0node[1]));\n+  right_op.safe_splice (SLP_TREE_CHILDREN (nodes[1]));\n \n   bool is_neg = vect_normalize_conj_loc (left_op);\n \n-  child = SLP_TREE_CHILDREN ((*ops)[1])[0];\n   bool conj_first_operand = false;\n   if (!vect_validate_multiplication (perm_cache, right_op, left_op, false,\n \t\t\t\t     &conj_first_operand, true))\n@@ -1340,28 +1225,28 @@ complex_fms_pattern::matches (complex_operation_t op,\n   complex_perm_kinds_t kind = linear_loads_p (perm_cache, right_op[0]);\n   if (kind == PERM_EVENODD)\n     {\n-      ops->quick_push (child);\n+      ops->quick_push (l0node[0]);\n       ops->quick_push (right_op[0]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (left_op[1]);\n     }\n   else if (kind == PERM_TOP)\n     {\n-      ops->quick_push (child);\n+      ops->quick_push (l0node[0]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (right_op[0]);\n       ops->quick_push (left_op[0]);\n     }\n   else if (kind == PERM_EVENEVEN && !is_neg)\n     {\n-      ops->quick_push (child);\n+      ops->quick_push (l0node[0]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (right_op[0]);\n       ops->quick_push (left_op[0]);\n     }\n   else\n     {\n-      ops->quick_push (child);\n+      ops->quick_push (l0node[0]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (right_op[0]);\n       ops->quick_push (left_op[1]);\n@@ -1473,10 +1358,6 @@ complex_operations_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n   if (ifn != IFN_LAST)\n     return complex_mul_pattern::mkInstance (node, &ops, ifn);\n \n-  ifn  = complex_fma_pattern::matches (op, perm_cache, node, &ops);\n-  if (ifn != IFN_LAST)\n-    return complex_fma_pattern::mkInstance (node, &ops, ifn);\n-\n   ifn  = complex_add_pattern::matches (op, perm_cache, node, &ops);\n   if (ifn != IFN_LAST)\n     return complex_add_pattern::mkInstance (node, &ops, ifn);"}]}