{"sha": "ac47786e993ddb3c50545230d13f57df891c0562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0Nzc4NmU5OTNkZGIzYzUwNTQ1MjMwZDEzZjU3ZGY4OTFjMDU2Mg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-08-20T12:48:59Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-08-20T12:48:59Z"}, "message": "vec.h (FOR_EACH_VEC_ELT): Define.\n\ngcc/\n\t* vec.h (FOR_EACH_VEC_ELT): Define.\n\t* c-decl.c: Use it.\n\t* cfgloop.c: Likewise.\n\t* cfgloopmanip.c: Likewise.\n\t* cgraph.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* combine.c: Likewise.\n\t* config/bfin/bfin.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* df-scan.c: Likewise.\n\t* dominance.c: Likewise.\n\t* dse.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* except.c: Likewise.\n\t* expr.c: Likewise.\n\t* function.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattr.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* graphite-blocking.c: Likewise.\n\t* graphite-clast-to-gimple.c: Likewise.\n\t* graphite-dependences.c: Likewise.\n\t* graphite-interchange.c: Likewise.\n\t* graphite-poly.c: Likewise.\n\t* graphite-scop-detection.c: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* graphite.c: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* ifcvt.c: Likewise.\n\t* implicit-zee.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa.c: Likewise.\n\t* ira-build.c: Likewise.\n\t* ira-color.c: Likewise.\n\t* ira-emit.c: Likewise.\n\t* lambda-code.c: Likewise.\n\t* loop-invariant.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* lower-subreg.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* lto-opts.c: Likewise.\n\t* lto-streamer-in.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* lto-streamer.c: Likewise.\n\t* lto-symtab.c: Likewise.\n\t* matrix-reorg.c: Likewise.\n\t* opts.c: Likewise.\n\t* predict.c: Likewise.\n\t* print-tree.c: Likewise.\n\t* sdbout.c: Likewise.\n\t* sel-sched-dump.c: Likewise.\n\t* sel-sched-ir.c: Likewise.\n\t* sel-sched.c: Likewise.\n\t* sese.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* tree-cfgcleanup.c: Likewise.\n\t* tree-chrec.c: Likewise.\n\t* tree-data-ref.c: Likewise.\n\t* tree-emutls.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-into-ssa.c: Likewise.\n\t* tree-loop-distribution.c: Likewise.\n\t* tree-loop-linear.c: Likewise.\n\t* tree-mudflap.c: Likewise.\n\t* tree-outof-ssa.c: Likewise.\n\t* tree-parloops.c: Likewise.\n\t* tree-predcom.c: Likewise.\n\t* tree-pretty-print.c: Likewise.\n\t* tree-scalar-evolution.c: Likewise.\n\t* tree-ssa-live.c: Likewise.\n\t* tree-ssa-loop-im.c: Likewise.\n\t* tree-ssa-loop-ivcanon.c: Likewise.\n\t* tree-ssa-loop-ivopts.c: Likewise.\n\t* tree-ssa-loop-manip.c: Likewise.\n\t* tree-ssa-loop-niter.c: Likewise.\n\t* tree-ssa-loop-prefetch.c: Likewise.\n\t* tree-ssa-phiprop.c: Likewise.\n\t* tree-ssa-pre.c: Likewise.\n\t* tree-ssa-reassoc.c: Likewise.\n\t* tree-ssa-sccvn.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-ssa.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vrp.c: Likewise.\n\t* tree.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* var-tracking.c: Likewise.\n\t* varasm.c: Likewise.\n\t* vmsdbgout.c: Likewise.\n\ngcc/ada/\n\t* gcc-interface/decl.c: Use FOR_EACH_VEC_ELT.\n\t* gcc-interface/trans.c: Likewise.\n\t* gcc-interface/utils.c: Likewise.\n\ngcc/c-family/\n\t* c-common.c: Use FOR_EACH_VEC_ELT.\n\t* c-gimplify.c: Likewise.\n\t* c-pragma.c: Likewise.\n\ngcc/cp/\n\t* call.c: Use FOR_EACH_VEC_ELT.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* decl2.c: Likewise.\n\t* error.c: Likewise.\n\t* except.c: Likewise.\n\t* mangle.c: Likewise.\n\t* method.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* repo.c: Likewise.\n\t* semantics.c: Likewise.\n\t* typeck2.c: Likewise.\n\ngcc/fortran/\n\t* trans-openmp.c: Use FOR_EACH_VEC_ELT.\n\ngcc/java/\n\t* class.c: Use FOR_EACH_VEC_ELT.\n\t* expr.c: Likewise.\n\t* jcf-parse.c: Likewise.\n\t* resource.c: Likewise.\n\ngcc/lto/\n\t* lto.c: Use FOR_EACH_VEC_ELT.\n\nFrom-SVN: r163401", "tree": {"sha": "7983da0de4d80a3a7b43caa30ccd5dc36d8bf25e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7983da0de4d80a3a7b43caa30ccd5dc36d8bf25e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac47786e993ddb3c50545230d13f57df891c0562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac47786e993ddb3c50545230d13f57df891c0562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac47786e993ddb3c50545230d13f57df891c0562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac47786e993ddb3c50545230d13f57df891c0562/comments", "author": null, "committer": null, "parents": [{"sha": "8f0fe813790d58066714c8f38f4916925c83517d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0fe813790d58066714c8f38f4916925c83517d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0fe813790d58066714c8f38f4916925c83517d"}], "stats": {"total": 1619, "additions": 829, "deletions": 790}, "files": [{"sha": "c525cad471950a38b129a2da14a96c372056d824", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,105 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* vec.h (FOR_EACH_VEC_ELT): Define.\n+\t* c-decl.c: Use it.\n+\t* cfgloop.c: Likewise.\n+\t* cfgloopmanip.c: Likewise.\n+\t* cgraph.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* config/bfin/bfin.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* df-scan.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* dse.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* except.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattr.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* graphite-blocking.c: Likewise.\n+\t* graphite-clast-to-gimple.c: Likewise.\n+\t* graphite-dependences.c: Likewise.\n+\t* graphite-interchange.c: Likewise.\n+\t* graphite-poly.c: Likewise.\n+\t* graphite-scop-detection.c: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* graphite.c: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* ifcvt.c: Likewise.\n+\t* implicit-zee.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa.c: Likewise.\n+\t* ira-build.c: Likewise.\n+\t* ira-color.c: Likewise.\n+\t* ira-emit.c: Likewise.\n+\t* lambda-code.c: Likewise.\n+\t* loop-invariant.c: Likewise.\n+\t* loop-unroll.c: Likewise.\n+\t* lower-subreg.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* lto-opts.c: Likewise.\n+\t* lto-streamer-in.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* lto-streamer.c: Likewise.\n+\t* lto-symtab.c: Likewise.\n+\t* matrix-reorg.c: Likewise.\n+\t* opts.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* print-tree.c: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* sel-sched-dump.c: Likewise.\n+\t* sel-sched-ir.c: Likewise.\n+\t* sel-sched.c: Likewise.\n+\t* sese.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* tree-cfg.c: Likewise.\n+\t* tree-cfgcleanup.c: Likewise.\n+\t* tree-chrec.c: Likewise.\n+\t* tree-data-ref.c: Likewise.\n+\t* tree-emutls.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-into-ssa.c: Likewise.\n+\t* tree-loop-distribution.c: Likewise.\n+\t* tree-loop-linear.c: Likewise.\n+\t* tree-mudflap.c: Likewise.\n+\t* tree-outof-ssa.c: Likewise.\n+\t* tree-parloops.c: Likewise.\n+\t* tree-predcom.c: Likewise.\n+\t* tree-pretty-print.c: Likewise.\n+\t* tree-scalar-evolution.c: Likewise.\n+\t* tree-ssa-live.c: Likewise.\n+\t* tree-ssa-loop-im.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Likewise.\n+\t* tree-ssa-loop-ivopts.c: Likewise.\n+\t* tree-ssa-loop-manip.c: Likewise.\n+\t* tree-ssa-loop-niter.c: Likewise.\n+\t* tree-ssa-loop-prefetch.c: Likewise.\n+\t* tree-ssa-phiprop.c: Likewise.\n+\t* tree-ssa-pre.c: Likewise.\n+\t* tree-ssa-reassoc.c: Likewise.\n+\t* tree-ssa-sccvn.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-ssa.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-loop-manip.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vrp.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* var-tracking.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* vmsdbgout.c: Likewise.\n+\n 2010-08-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/tm.texi.in (PIC_OFFSET_TABLE_REG_CALL_CLOBBERED): Document to"}, {"sha": "ad734d1e61a83e508c7b43570aa7b93ff8cc533a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,9 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/decl.c: Use FOR_EACH_VEC_ELT.\n+\t* gcc-interface/trans.c: Likewise.\n+\t* gcc-interface/utils.c: Likewise.\n+\n 2010-08-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tracebak.c (i386): Use GCC unwinder on Linux with GCC > 4.5."}, {"sha": "2e68eaadf267fc2d4ede13e35faa57a26afa94ac", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -4966,7 +4966,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  unsigned int i;\n \t  tree t;\n \n-\t  for (i = 0; VEC_iterate (tree, defer_finalize_list, i, t); i++)\n+\t  FOR_EACH_VEC_ELT (tree, defer_finalize_list, i, t)\n \t    rest_of_type_decl_compilation_no_defer (t);\n \n \t  VEC_free (tree, heap, defer_finalize_list);"}, {"sha": "d32639aeee54a48d3ed150c28fd643be2c36123f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1603,7 +1603,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t   and the dimension in the cache and create a new one on failure.  */\n \tif (!optimize && Present (gnat_param))\n \t  {\n-\t    for (i = 0; VEC_iterate (parm_attr, f_parm_attr_cache, i, pa); i++)\n+\t    FOR_EACH_VEC_ELT (parm_attr, f_parm_attr_cache, i, pa)\n \t      if (pa->id == gnat_param && pa->dim == Dimension)\n \t\tbreak;\n \n@@ -2521,7 +2521,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n       start_stmt_group ();\n \n-      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)\n+      FOR_EACH_VEC_ELT (parm_attr, cache, i, pa)\n \t{\n \t  if (pa->first)\n \t    add_stmt_with_node (pa->first, gnat_node);"}, {"sha": "cef72322e1b0d0cc5fb6bfa71cbd216f234b666d", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1690,7 +1690,7 @@ invalidate_global_renaming_pointers (void)\n   unsigned int i;\n   tree iter;\n \n-  for (i = 0; VEC_iterate(tree, global_renaming_pointers, i, iter); i++)\n+  FOR_EACH_VEC_ELT (tree, global_renaming_pointers, i, iter)\n     SET_DECL_RENAMED_OBJECT (iter, NULL_TREE);\n \n   VEC_free (tree, gc, global_renaming_pointers);\n@@ -4661,7 +4661,7 @@ builtin_decl_for (tree name)\n   unsigned i;\n   tree decl;\n \n-  for (i = 0; VEC_iterate(tree, builtin_decls, i, decl); i++)\n+  FOR_EACH_VEC_ELT (tree, builtin_decls, i, decl)\n     if (DECL_NAME (decl) == name)\n       return decl;\n "}, {"sha": "10600c80074f064f03573dfab77c72c9ab51d072", "filename": "gcc/c-decl.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -999,9 +999,7 @@ update_label_decls (struct c_scope *scope)\n \n \t      /* Update the bindings of any goto statements associated\n \t\t with this label.  */\n-\t      for (ix = 0;\n-\t\t   VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n-\t\t   ++ix)\n+\t      FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n \t\tupdate_spot_bindings (scope, &g->goto_bindings);\n \t    }\n \t}\n@@ -1352,9 +1350,7 @@ c_bindings_start_stmt_expr (struct c_spot_bindings* switch_bindings)\n \t    continue;\n \t  label_vars = b->u.label;\n \t  ++label_vars->label_bindings.stmt_exprs;\n-\t  for (ix = 0;\n-\t       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n-\t       ++ix)\n+\t  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n \t    ++g->goto_bindings.stmt_exprs;\n \t}\n     }\n@@ -1392,9 +1388,7 @@ c_bindings_end_stmt_expr (struct c_spot_bindings *switch_bindings)\n \t      label_vars->label_bindings.left_stmt_expr = true;\n \t      label_vars->label_bindings.stmt_exprs = 0;\n \t    }\n-\t  for (ix = 0;\n-\t       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n-\t       ++ix)\n+\t  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n \t    {\n \t      --g->goto_bindings.stmt_exprs;\n \t      if (g->goto_bindings.stmt_exprs < 0)\n@@ -3120,7 +3114,7 @@ lookup_label_for_goto (location_t loc, tree name)\n        ...\n        goto lab;\n      Issue a warning or error.  */\n-  for (ix = 0; VEC_iterate (tree, label_vars->decls_in_scope, ix, decl); ++ix)\n+  FOR_EACH_VEC_ELT (tree, label_vars->decls_in_scope, ix, decl)\n     warn_about_goto (loc, label, decl);\n \n   if (label_vars->label_bindings.left_stmt_expr)\n@@ -3172,9 +3166,7 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n   unsigned int ix;\n   struct c_goto_bindings *g;\n \n-  for (ix = 0;\n-       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n-       ++ix)\n+  FOR_EACH_VEC_ELT (c_goto_bindings_p, label_vars->gotos, ix, g)\n     {\n       struct c_binding *b;\n       struct c_scope *scope;\n@@ -6788,7 +6780,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n      because the flag is used to issue visibility warnings, and we\n      only want to issue those warnings if the type is referenced\n      outside of the struct declaration.  */\n-  for (ix = 0; VEC_iterate (tree, struct_parse_info->struct_types, ix, x); ++ix)\n+  FOR_EACH_VEC_ELT (tree, struct_parse_info->struct_types, ix, x)\n     C_TYPE_DEFINED_IN_STRUCT (x) = 1;\n \n   /* The TYPEDEFS_SEEN field of STRUCT_PARSE_INFO is a list of\n@@ -6804,9 +6796,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n \t a pointer_set because identifiers are interned.  */\n       struct pointer_set_t *tset = pointer_set_create ();\n \n-      for (ix = 0;\n-\t   VEC_iterate (tree, struct_parse_info->typedefs_seen, ix, x);\n-\t   ++ix)\n+      FOR_EACH_VEC_ELT (tree, struct_parse_info->typedefs_seen, ix, x)\n \tpointer_set_insert (tset, DECL_NAME (x));\n \n       for (x = fieldlist; x != NULL_TREE; x = DECL_CHAIN (x))\n@@ -6827,9 +6817,7 @@ warn_cxx_compat_finish_struct (tree fieldlist)\n \n   /* For each field which has a binding and which was not defined in\n      an enclosing struct, clear the in_struct field.  */\n-  for (ix = 0;\n-       VEC_iterate (c_binding_ptr, struct_parse_info->fields, ix, b);\n-       ++ix)\n+  FOR_EACH_VEC_ELT (c_binding_ptr, struct_parse_info->fields, ix, b)\n     b->in_struct = 0;\n }\n \n@@ -8090,7 +8078,7 @@ store_parm_decls (void)\n     tree t;\n     int i;\n \n-    for (i = 0; VEC_iterate (tree, pending_sizes, i, t); i++)\n+    FOR_EACH_VEC_ELT (tree, pending_sizes, i, t)\n       add_stmt (t);\n   }\n "}, {"sha": "072aad4d4ca21e867427140ffec987abaef3f388", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,9 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* c-common.c: Use FOR_EACH_VEC_ELT.\n+\t* c-gimplify.c: Likewise.\n+\t* c-pragma.c: Likewise.\n+\n 2010-08-16  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c.opt (MDX): Change back to MD.  Mark NoDriverArg instead of"}, {"sha": "e2c5d28d08e301e2a75202efe5b038d49eff9d61", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -9300,7 +9300,7 @@ make_tree_vector_copy (const VEC(tree,gc) *orig)\n \n   ret = make_tree_vector ();\n   VEC_reserve (tree, gc, ret, VEC_length (tree, orig));\n-  for (ix = 0; VEC_iterate (tree, orig, ix, t); ++ix)\n+  FOR_EACH_VEC_ELT (tree, orig, ix, t)\n     VEC_quick_push (tree, ret, t);\n   return ret;\n }"}, {"sha": "f8a2ab4bce222410c8407bd84bce80846a4c359e", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -112,7 +112,7 @@ add_block_to_enclosing (tree block)\n   gimple bind;\n   VEC(gimple, heap) *stack = gimple_bind_expr_stack ();\n \n-  for (i = 0; VEC_iterate (gimple, stack, i, bind); i++)\n+  FOR_EACH_VEC_ELT (gimple, stack, i, bind)\n     if (gimple_bind_block (bind))\n       break;\n "}, {"sha": "6aaa2f7535f3f9b293581cf79356528e6dcdc2de", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -306,7 +306,7 @@ maybe_apply_pragma_weak (tree decl)\n \n   id = DECL_ASSEMBLER_NAME (decl);\n \n-  for (i = 0; VEC_iterate (pending_weak, pending_weaks, i, pe); i++)\n+  FOR_EACH_VEC_ELT (pending_weak, pending_weaks, i, pe)\n     if (id == pe->name)\n       {\n \tapply_pragma_weak (decl, pe->value);\n@@ -324,7 +324,7 @@ maybe_apply_pending_pragma_weaks (void)\n   int i;\n   pending_weak *pe;\n \n-  for (i = 0; VEC_iterate (pending_weak, pending_weaks, i, pe); i++)\n+  FOR_EACH_VEC_ELT (pending_weak, pending_weaks, i, pe)\n     {\n       alias_id = pe->name;\n       id = pe->value;\n@@ -486,9 +486,7 @@ add_to_renaming_pragma_list (tree oldname, tree newname)\n   unsigned ix;\n   pending_redefinition *p;\n \n-  for (ix = 0;\n-       VEC_iterate (pending_redefinition, pending_redefine_extname, ix, p);\n-       ix++)\n+  FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n     if (oldname == p->oldname)\n       {\n \tif (p->newname != newname)\n@@ -553,9 +551,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \t\t   \"conflict with previous rename\");\n \n       /* Take any pending redefine_extname off the list.  */\n-      for (ix = 0;\n-\t   VEC_iterate (pending_redefinition, pending_redefine_extname, ix, p);\n-\t   ix++)\n+      FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n \tif (DECL_NAME (decl) == p->oldname)\n \t  {\n \t    /* Only warn if there is a conflict.  */\n@@ -571,9 +567,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n     }\n \n   /* Find out if we have a pending #pragma redefine_extname.  */\n-  for (ix = 0;\n-       VEC_iterate (pending_redefinition, pending_redefine_extname, ix, p);\n-       ix++)\n+  FOR_EACH_VEC_ELT (pending_redefinition, pending_redefine_extname, ix, p)\n     if (DECL_NAME (decl) == p->oldname)\n       {\n \ttree newname = p->newname;"}, {"sha": "c242756e848c57843775b34dbbc0c64a31379c72", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -130,7 +130,7 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n     {\n       fprintf (file, \"multiple latches:\");\n       latches = get_loop_latch_edges (loop);\n-      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, latches, i, e)\n \tfprintf (file, \" %d\", e->src->index);\n       VEC_free (edge, heap, latches);\n       fprintf (file, \"\\n\");\n@@ -209,7 +209,7 @@ flow_loops_free (struct loops *loops)\n       loop_p loop;\n \n       /* Free the loop descriptors.  */\n-      for (i = 0; VEC_iterate (loop_p, loops->larray, i, loop); i++)\n+      FOR_EACH_VEC_ELT (loop_p, loops->larray, i, loop)\n \t{\n \t  if (!loop)\n \t    continue;\n@@ -286,7 +286,7 @@ establish_preds (struct loop *loop, struct loop *father)\n \n   VEC_truncate (loop_p, loop->superloops, 0);\n   VEC_reserve (loop_p, gc, loop->superloops, depth);\n-  for (i = 0; VEC_iterate (loop_p, father->superloops, i, ploop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, father->superloops, i, ploop)\n     VEC_quick_push (loop_p, loop->superloops, ploop);\n   VEC_quick_push (loop_p, loop->superloops, father);\n \n@@ -530,7 +530,7 @@ find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n   edge e, me = NULL;\n   gcov_type mcount = 0, tcount = 0;\n \n-  for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, latches, i, e)\n     {\n       if (e->count > mcount)\n \t{\n@@ -579,7 +579,7 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, h\n       latch = e;\n \n   /* Verify that it dominates all the latch edges.  */\n-  for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, latches, i, e)\n     if (!dominated_by_p (CDI_DOMINATORS, e->src, latch->src))\n       return NULL;\n \n@@ -598,7 +598,7 @@ find_subloop_latch_edge_by_ivs (struct loop *loop ATTRIBUTE_UNUSED, VEC (edge, h\n       if (!bb || !flow_bb_inside_loop_p (loop, bb))\n \tcontinue;\n \n-      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, latches, i, e)\n \tif (e != latch\n \t    && PHI_ARG_DEF_FROM_EDGE (phi, e) == lop)\n \t  return NULL;\n@@ -696,7 +696,7 @@ merge_latch_edges (struct loop *loop)\n \tfprintf (dump_file, \"Merged latch edges of loop %d\\n\", loop->num);\n \n       mfb_reis_set = pointer_set_create ();\n-      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, latches, i, e)\n \tpointer_set_insert (mfb_reis_set, e);\n       latch = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n \t\t\t\t    NULL);\n@@ -1192,7 +1192,7 @@ add_bb_to_loop (basic_block bb, struct loop *loop)\n   bb->loop_father = loop;\n   bb->loop_depth = loop_depth (loop);\n   loop->num_nodes++;\n-  for (i = 0; VEC_iterate (loop_p, loop->superloops, i, ploop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, loop->superloops, i, ploop)\n     ploop->num_nodes++;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1217,7 +1217,7 @@ remove_bb_from_loops (basic_block bb)\n \n   gcc_assert (loop != NULL);\n   loop->num_nodes--;\n-  for (i = 0; VEC_iterate (loop_p, loop->superloops, i, ploop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, loop->superloops, i, ploop)\n     ploop->num_nodes--;\n   bb->loop_father = NULL;\n   bb->loop_depth = 0;"}, {"sha": "4363cc51f64062d7bcd3fb52424f313e8975a228", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -130,7 +130,7 @@ fix_loop_placement (struct loop *loop)\n   struct loop *father = current_loops->tree_root, *act;\n   bool ret = false;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, e)\n     {\n       act = find_common_loop (loop, e->dest->loop_father);\n       if (flow_loop_nested_p (father, act))\n@@ -146,7 +146,7 @@ fix_loop_placement (struct loop *loop)\n \n       /* The exit edges of LOOP no longer exits its original immediate\n \t superloops; remove them from the appropriate exit lists.  */\n-      for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, exits, i, e)\n \trescan_loop_exit (e, false, false);\n \n       ret = true;\n@@ -1271,7 +1271,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       bb->aux = 0;\n \n       dom_bbs = get_dominated_by (CDI_DOMINATORS, bb);\n-      for (j = 0; VEC_iterate (basic_block, dom_bbs, j, dominated); j++)\n+      FOR_EACH_VEC_ELT (basic_block, dom_bbs, j, dominated)\n \t{\n \t  if (flow_bb_inside_loop_p (loop, dominated))\n \t    continue;"}, {"sha": "32ad190135b296f236924ef53247027c3ec90298", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2149,7 +2149,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n \tn->count = 0;\n     }\n \n-  for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n+  FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n     {\n       /* Redirect calls to the old version node to point to its new\n \t version.  */\n@@ -2272,7 +2272,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   DECL_WEAK (new_node->decl) = 0;\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n-  for (i = 0; VEC_iterate (ipa_replace_map_p, tree_map, i, map); i++)\n+  FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n     {\n       tree var = map->new_tree;\n "}, {"sha": "4ef63a2d350766e2fa2a3a4bb5d4c9089b30e2c0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2160,7 +2160,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n \t\t\t  CGRAPH_FREQ_BASE,\n \t\t\t  e->loop_nest, true);\n-   for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n+   FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n      {\n        /* Redirect calls to the old version node to point to its new\n \t  version.  */"}, {"sha": "1f8e97007ee67ed17e8f2a8edfccaf006bd6553c", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1417,7 +1417,7 @@ init_reg_last (void)\n   unsigned int i;\n   reg_stat_type *p;\n \n-  for (i = 0; VEC_iterate (reg_stat_type, reg_stat, i, p); ++i)\n+  FOR_EACH_VEC_ELT (reg_stat_type, reg_stat, i, p)\n     memset (p, 0, offsetof (reg_stat_type, sign_bit_copies));\n }\n \f"}, {"sha": "d0a13969f8d6239efdb161a0e7bb937418f2d5e9", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -3795,12 +3795,12 @@ bfin_dump_loops (loop_info loops)\n       fprintf (dump_file, \"{head:%d, depth:%d}\", loop->head->index, loop->depth);\n \n       fprintf (dump_file, \" blocks: [ \");\n-      for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n+      FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, b)\n \tfprintf (dump_file, \"%d \", b->index);\n       fprintf (dump_file, \"] \");\n \n       fprintf (dump_file, \" inner loops: [ \");\n-      for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, i); ix++)\n+      FOR_EACH_VEC_ELT (loop_info, loop->loops, ix, i)\n \tfprintf (dump_file, \"%d \", i->loop_no);\n       fprintf (dump_file, \"]\\n\");\n     }\n@@ -3826,7 +3826,7 @@ bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n   unsigned ix;\n   basic_block bb;\n \n-  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+  FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, bb)\n     {\n       rtx insn;\n \n@@ -3902,7 +3902,7 @@ bfin_optimize_loop (loop_info loop)\n   /* Every loop contains in its list of inner loops every loop nested inside\n      it, even if there are intermediate loops.  This works because we're doing\n      a depth-first search here and never visit a loop more than once.  */\n-  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n+  FOR_EACH_VEC_ELT (loop_info, loop->loops, ix, inner)\n     {\n       bfin_optimize_loop (inner);\n \n@@ -4052,7 +4052,7 @@ bfin_optimize_loop (loop_info loop)\n   reg_lb0 = gen_rtx_REG (SImode, REG_LB0);\n   reg_lb1 = gen_rtx_REG (SImode, REG_LB1);\n \n-  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+  FOR_EACH_VEC_ELT (basic_block, loop->blocks, ix, bb)\n     {\n       rtx insn;\n \n@@ -4433,7 +4433,7 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n   if (!loop->bad)\n     {\n       int pass, retry;\n-      for (dwork = 0; VEC_iterate (basic_block, loop->blocks, dwork, bb); dwork++)\n+      FOR_EACH_VEC_ELT (basic_block, loop->blocks, dwork, bb)\n \t{\n \t  edge e;\n \t  edge_iterator ei;"}, {"sha": "24732199312493bcf8f4c5ef28de9ea4234fbb9c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -4021,9 +4021,7 @@ mips_multi_write (void)\n   struct mips_multi_member *member;\n   unsigned int i;\n \n-  for (i = 0;\n-       VEC_iterate (mips_multi_member, mips_multi_members, i, member);\n-       i++)\n+  FOR_EACH_VEC_ELT (mips_multi_member, mips_multi_members, i, member)\n     if (member->is_label_p)\n       fprintf (asm_out_file, \"%s\\n\", member->format);\n     else"}, {"sha": "89e0127a479fc83a17f24165c39854c4b1a768ee", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -24602,7 +24602,7 @@ no_previous_def (tree function_name)\n   branch_island *bi;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (branch_island, branch_islands, ix, bi); ix++)\n+  FOR_EACH_VEC_ELT (branch_island, branch_islands, ix, bi)\n     if (function_name == bi->function_name)\n       return 0;\n   return 1;\n@@ -24617,7 +24617,7 @@ get_prev_label (tree function_name)\n   branch_island *bi;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (branch_island, branch_islands, ix, bi); ix++)\n+  FOR_EACH_VEC_ELT (branch_island, branch_islands, ix, bi)\n     if (function_name == bi->function_name)\n       return bi->label_name;\n   return NULL_TREE;"}, {"sha": "719658db523e47f6ecb4fae7f52b5016ef24909d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,20 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* call.c: Use FOR_EACH_VEC_ELT.\n+\t* class.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* error.c: Likewise.\n+\t* except.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* method.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* repo.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2010-08-19  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (reference_related_p): Check for error_mark_node."}, {"sha": "36f5a556af5be47c40b7093ca71a55a81e4094f9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -3161,7 +3161,7 @@ resolve_args (VEC(tree,gc) *args)\n   unsigned int ix;\n   tree arg;\n \n-  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n     {\n       if (error_operand_p (arg))\n \treturn NULL;\n@@ -5423,7 +5423,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n     }\n \n   /* Detect recursion.  */\n-  for (i = 0; VEC_iterate (tree, default_arg_context, i, t); ++i)\n+  FOR_EACH_VEC_ELT (tree, default_arg_context, i, t)\n     if (t == fn)\n       {\n \terror (\"recursive evaluation of default argument for %q#D\", fn);\n@@ -5620,7 +5620,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  ++nargs;\n \t  alcarray = XALLOCAVEC (tree, nargs);\n \t  alcarray[0] = first_arg;\n-\t  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+\t  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n \t    alcarray[ix + 1] = arg;\n \t  argarray = alcarray;\n \t}"}, {"sha": "35b6db13c1f181b1812c700aca241fe0db55d1a1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2048,7 +2048,7 @@ get_vcall_index (tree fn, tree type)\n   tree_pair_p p;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (tree_pair_s, indices, ix, p); ix++)\n+  FOR_EACH_VEC_ELT (tree_pair_s, indices, ix, p)\n     if ((DECL_DESTRUCTOR_P (fn) && DECL_DESTRUCTOR_P (p->purpose))\n \t|| same_signature_p (fn, p->purpose))\n       return p->value;\n@@ -8125,7 +8125,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n      signature as FN, then we do not need a second vcall offset.\n      Check the list of functions already present in the derived\n      class vtable.  */\n-  for (i = 0; VEC_iterate (tree, vid->fns, i, derived_entry); ++i)\n+  FOR_EACH_VEC_ELT (tree, vid->fns, i, derived_entry)\n     {\n       if (same_signature_p (derived_entry, orig_fn)\n \t  /* We only use one vcall offset for virtual destructors,"}, {"sha": "6465658f5de2a54f42c91cdf4d0033c0202ba7ac", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -720,9 +720,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* Remove declarations for any `for' variables from inner scopes\n      that we kept around.  */\n-  for (ix = VEC_length (tree, current_binding_level->dead_vars_from_for) - 1;\n-       VEC_iterate (tree, current_binding_level->dead_vars_from_for, ix, decl);\n-       ix--)\n+  FOR_EACH_VEC_ELT_REVERSE (tree, current_binding_level->dead_vars_from_for,\n+\t\t\t    ix, decl)\n     pop_binding (DECL_NAME (decl), decl);\n \n   /* Restore the IDENTIFIER_TYPE_VALUEs.  */\n@@ -731,11 +730,9 @@ poplevel (int keep, int reverse, int functionbody)\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n \n   /* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */\n-  for (ix = VEC_length (cp_label_binding,\n-\t\t\tcurrent_binding_level->shadowed_labels) - 1;\n-       VEC_iterate (cp_label_binding, current_binding_level->shadowed_labels,\n-\t\t    ix, label_bind);\n-       ix--)\n+  FOR_EACH_VEC_ELT_REVERSE (cp_label_binding,\n+\t\t\t    current_binding_level->shadowed_labels,\n+\t\t\t    ix, label_bind)\n     pop_local_label (label_bind->label, label_bind->prev_value);\n \n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n@@ -2712,7 +2709,7 @@ check_goto (tree decl)\n       identified = true;\n     }\n \n-  for (ix = 0; VEC_iterate (tree, ent->bad_decls, ix, bad); ix++)\n+  FOR_EACH_VEC_ELT (tree, ent->bad_decls, ix, bad)\n     {\n       int u = decl_jump_unsafe (bad);\n \n@@ -4598,9 +4595,7 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n \t  VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (initializer);\n \t  constructor_elt *ce;\n \t  HOST_WIDE_INT i;\n-\t  for (i = 0; \n-\t       VEC_iterate (constructor_elt, v, i, ce);\n-\t       ++i) \n+\t  FOR_EACH_VEC_ELT (constructor_elt, v, i, ce)\n \t    if (!check_array_designated_initializer (ce))\n \t      failure = 1;\n \t}\n@@ -12837,7 +12832,7 @@ finish_function (int flags)\n       unsigned int i;\n       tree decl;\n \n-      for (i = 0; VEC_iterate (tree, deferred_mark_used_calls, i, decl); i++)\n+      FOR_EACH_VEC_ELT (tree, deferred_mark_used_calls, i, decl)\n \tmark_used (decl);\n       VEC_free (tree, gc, deferred_mark_used_calls);\n     }"}, {"sha": "f2330554a145668e1ed335f4363b29ba1249b16e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -3300,7 +3300,7 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \n   /* Call the static storage duration function with appropriate\n      arguments.  */\n-  for (i = 0; VEC_iterate (tree, ssdf_decls, i, fndecl); ++i)\n+  FOR_EACH_VEC_ELT (tree, ssdf_decls, i, fndecl)\n     {\n       /* Calls to pure or const functions will expand to nothing.  */\n       if (! (flags_from_decl_or_type (fndecl) & (ECF_CONST | ECF_PURE)))\n@@ -3742,7 +3742,7 @@ cp_write_global_declarations (void)\n       /* Go through the set of inline functions whose bodies have not\n \t been emitted yet.  If out-of-line copies of these functions\n \t are required, emit them.  */\n-      for (i = 0; VEC_iterate (tree, deferred_fns, i, decl); ++i)\n+      FOR_EACH_VEC_ELT (tree, deferred_fns, i, decl)\n \t{\n \t  /* Does it need synthesizing?  */\n \t  if (DECL_DEFAULTED_FN (decl) && ! DECL_INITIAL (decl)\n@@ -3844,7 +3844,7 @@ cp_write_global_declarations (void)\n \treconsider = true;\n \n       /* Static data members are just like namespace-scope globals.  */\n-      for (i = 0; VEC_iterate (tree, pending_statics, i, decl); ++i)\n+      FOR_EACH_VEC_ELT (tree, pending_statics, i, decl)\n \t{\n \t  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl)\n \t      /* Don't write it out if we haven't seen a definition.  */\n@@ -3866,7 +3866,7 @@ cp_write_global_declarations (void)\n   while (reconsider);\n \n   /* All used inline functions must have a definition at this point.  */\n-  for (i = 0; VEC_iterate (tree, deferred_fns, i, decl); ++i)\n+  FOR_EACH_VEC_ELT (tree, deferred_fns, i, decl)\n     {\n       if (/* Check online inline functions that were actually used.  */\n \t  DECL_ODR_USED (decl) && DECL_DECLARED_INLINE_P (decl)\n@@ -3888,7 +3888,7 @@ cp_write_global_declarations (void)\n     }\n \n   /* So must decls that use a type with no linkage.  */\n-  for (i = 0; VEC_iterate (tree, no_linkage_decls, i, decl); ++i)\n+  FOR_EACH_VEC_ELT (tree, no_linkage_decls, i, decl)\n     if (!decl_defined_p (decl))\n       no_linkage_error (decl);\n "}, {"sha": "2bcc35bcc3fc8374bb0c6a0d7a28b297060aebbf", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -304,7 +304,7 @@ dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n       parms = TREE_CHAIN (parms);\n     }\n \n-  for (i = 0; VEC_iterate (tree, typenames, i, t); ++i)\n+  FOR_EACH_VEC_ELT (tree, typenames, i, t)\n     {\n       if (need_comma)\n \tpp_separate_with_comma (cxx_pp);"}, {"sha": "351e685a68702279d902e4d512ae069cec507d50", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1104,9 +1104,7 @@ perform_deferred_noexcept_checks (void)\n   int i;\n   pending_noexcept *p;\n   location_t saved_loc = input_location;\n-  for (i = 0;\n-       VEC_iterate (pending_noexcept, pending_noexcept_checks, i, p);\n-       ++i)\n+  FOR_EACH_VEC_ELT (pending_noexcept, pending_noexcept_checks, i, p)\n     {\n       input_location = p->loc;\n       maybe_noexcept_warning (p->fn);"}, {"sha": "03e28374810e043ebd10cc3f972ad947a3e193de", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -307,7 +307,7 @@ dump_substitution_candidates (void)\n   tree el;\n \n   fprintf (stderr, \"  ++ substitutions  \");\n-  for (i = 0; VEC_iterate (tree, G.substitutions, i, el); ++i)\n+  FOR_EACH_VEC_ELT (tree, G.substitutions, i, el)\n     {\n       const char *name = \"???\";\n \n@@ -387,7 +387,7 @@ add_substitution (tree node)\n     int i;\n     tree candidate;\n \n-    for (i = 0; VEC_iterate (tree, G.substitutions, i, candidate); i++)\n+    FOR_EACH_VEC_ELT (tree, G.substitutions, i, candidate)\n       {\n \tgcc_assert (!(DECL_P (node) && node == candidate));\n \tgcc_assert (!(TYPE_P (node) && TYPE_P (candidate)"}, {"sha": "359e71d1b32c9a3a2985ce453822fa92c447b6af", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1204,7 +1204,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       if (diag)\n \tmsg = (\"virtual base %qT does not have a move constructor \"\n \t       \"or trivial copy constructor\");\n-      for (i = 0; VEC_iterate (tree, vbases, i, base_binfo); ++i)\n+      FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n \t{\n \t  if (copy_arg_p)\n \t    argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);"}, {"sha": "af6cef4122902ed7366b6da77f5e0af8c07d7e84", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -327,9 +327,7 @@ new_class_binding (tree name, tree value, tree type, cxx_scope *scope)\n \t  /* Fixup the current bindings, as they might have moved.  */\n \t  size_t i;\n \n-\t  for (i = 0;\n-\t       VEC_iterate (cp_class_binding, scope->class_shadowed, i, cb);\n-\t       i++)\n+\t  FOR_EACH_VEC_ELT (cp_class_binding, scope->class_shadowed, i, cb)\n \t    {\n \t      cxx_binding **b;\n \t      b = &IDENTIFIER_BINDING (cb->identifier);\n@@ -1687,9 +1685,7 @@ print_binding_level (struct cp_binding_level* lvl)\n       size_t i;\n       cp_class_binding *b;\n       fprintf (stderr, \" class-shadowed:\");\n-      for (i = 0;\n-\t   VEC_iterate(cp_class_binding, lvl->class_shadowed, i, b);\n-\t   ++i)\n+      FOR_EACH_VEC_ELT (cp_class_binding, lvl->class_shadowed, i, b)\n \tfprintf (stderr, \" %s \", IDENTIFIER_POINTER (b->identifier));\n       fprintf (stderr, \"\\n\");\n     }\n@@ -2644,9 +2640,7 @@ poplevel_class (void)\n   /* Remove the bindings for all of the class-level declarations.  */\n   if (level->class_shadowed)\n     {\n-      for (i = 0;\n-\t   VEC_iterate (cp_class_binding, level->class_shadowed, i, cb);\n-\t   ++i)\n+      FOR_EACH_VEC_ELT (cp_class_binding, level->class_shadowed, i, cb)\n \tIDENTIFIER_BINDING (cb->identifier) = cb->base.previous;\n       ggc_free (level->class_shadowed);\n       level->class_shadowed = NULL;\n@@ -4048,7 +4042,7 @@ tree_vec_contains (VEC(tree,gc)* vec, tree target)\n {\n   unsigned int i;\n   tree elt;\n-  for (i = 0; VEC_iterate(tree,vec,i,elt); ++i)\n+  FOR_EACH_VEC_ELT (tree,vec,i,elt)\n     if (elt == target)\n       return true;\n   return false;\n@@ -5001,7 +4995,7 @@ arg_assoc_args_vec (struct arg_lookup *k, VEC(tree,gc) *args)\n   unsigned int ix;\n   tree arg;\n \n-  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n     if (arg_assoc (k, arg))\n       return true;\n   return false;\n@@ -5484,7 +5478,7 @@ push_to_top_level (void)\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n \n-  for (i = 0; VEC_iterate (cxx_saved_binding, s->old_bindings, i, sb); ++i)\n+  FOR_EACH_VEC_ELT (cxx_saved_binding, s->old_bindings, i, sb)\n     IDENTIFIER_MARKED (sb->identifier) = 0;\n \n   s->prev = scope_chain;\n@@ -5521,7 +5515,7 @@ pop_from_top_level (void)\n   current_lang_base = 0;\n \n   scope_chain = s->prev;\n-  for (i = 0; VEC_iterate (cxx_saved_binding, s->old_bindings, i, saved); ++i)\n+  FOR_EACH_VEC_ELT (cxx_saved_binding, s->old_bindings, i, saved)\n     {\n       tree id = saved->identifier;\n "}, {"sha": "6c4fe1de63ba0649e4ba7a7da14e96c4a6b998ac", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -11187,14 +11187,10 @@ cp_parser_template_id (cp_parser *parser,\n       access_check = check_value->checks;\n       if (access_check)\n \t{\n-\t  for (i = 0 ;\n-\t       VEC_iterate (deferred_access_check, access_check, i, chk) ;\n-\t       ++i)\n-\t    {\n-\t      perform_or_defer_access_check (chk->binfo,\n-\t\t\t\t\t     chk->decl,\n-\t\t\t\t\t     chk->diag_decl);\n-\t    }\n+\t  FOR_EACH_VEC_ELT (deferred_access_check, access_check, i, chk)\n+\t    perform_or_defer_access_check (chk->binfo,\n+\t\t\t\t\t   chk->decl,\n+\t\t\t\t\t   chk->diag_decl);\n \t}\n       /* Return the stored value.  */\n       return check_value->value;\n@@ -16319,10 +16315,8 @@ cp_parser_class_specifier (cp_parser* parser)\n \t    };\n \n \t */\n-      for (ix = 0;\n-\t   VEC_iterate (cp_default_arg_entry, unparsed_funs_with_default_args,\n-\t\t\tix, e);\n-\t   ix++)\n+      FOR_EACH_VEC_ELT (cp_default_arg_entry, unparsed_funs_with_default_args,\n+\t\t\tix, e)\n \t{\n \t  fn = e->decl;\n \t  /* If there are default arguments that have not yet been processed,\n@@ -16345,9 +16339,7 @@ cp_parser_class_specifier (cp_parser* parser)\n \tpop_scope (pushed_scope);\n       VEC_truncate (cp_default_arg_entry, unparsed_funs_with_default_args, 0);\n       /* Now parse the body of the functions.  */\n-      for (ix = 0;\n-\t   VEC_iterate (tree, unparsed_funs_with_definitions, ix, fn);\n-\t   ix++)\n+      FOR_EACH_VEC_ELT (tree, unparsed_funs_with_definitions, ix, fn)\n \tcp_parser_late_parsing_for_member (parser, fn);\n       VEC_truncate (tree, unparsed_funs_with_definitions, 0);\n     }\n@@ -20469,14 +20461,10 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n   checks = check_value->checks;\n   if (checks)\n     {\n-      for (i = 0 ;\n-\t   VEC_iterate (deferred_access_check, checks, i, chk) ;\n-\t   ++i)\n-\t{\n-\t  perform_or_defer_access_check (chk->binfo,\n-\t\t\t\t\t chk->decl,\n-\t\t\t\t\t chk->diag_decl);\n-\t}\n+      FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n+\tperform_or_defer_access_check (chk->binfo,\n+\t\t\t\t       chk->decl,\n+\t\t\t\t       chk->diag_decl);\n     }\n   /* Set the scope from the stored value.  */\n   parser->scope = check_value->value;"}, {"sha": "759e22f66791971ce31bf867900e58714a98a59f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -7735,11 +7735,9 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n     return;\n \n   saved_location = input_location;\n-  for (i = 0;\n-       VEC_iterate (qualified_typedef_usage_t,\n+  FOR_EACH_VEC_ELT (qualified_typedef_usage_t,\n \t\t    get_types_needing_access_check (tmpl),\n-\t\t    i, iter);\n-\t++i)\n+\t\t    i, iter)\n     {\n       tree type_decl = iter->typedef_decl;\n       tree type_scope = iter->context;\n@@ -12799,7 +12797,7 @@ tsubst_copy_and_build (tree t,\n \n \tn = VEC_copy (constructor_elt, gc, CONSTRUCTOR_ELTS (t));\n         newlen = VEC_length (constructor_elt, n);\n-\tfor (idx = 0; VEC_iterate (constructor_elt, n, idx, ce); idx++)\n+\tFOR_EACH_VEC_ELT (constructor_elt, n, idx, ce)\n \t  {\n \t    if (ce->index && process_index_p)\n \t      ce->index = RECUR (ce->index);\n@@ -12833,8 +12831,7 @@ tsubst_copy_and_build (tree t,\n             VEC(constructor_elt,gc) *old_n = n;\n \n             n = VEC_alloc (constructor_elt, gc, newlen);\n-            for (idx = 0; VEC_iterate (constructor_elt, old_n, idx, ce); \n-                 idx++)\n+            FOR_EACH_VEC_ELT (constructor_elt, old_n, idx, ce)\n               {\n                 if (TREE_CODE (ce->value) == TREE_VEC)\n                   {\n@@ -17923,7 +17920,7 @@ any_type_dependent_arguments_p (const VEC(tree,gc) *args)\n   unsigned int i;\n   tree arg;\n \n-  for (i = 0; VEC_iterate (tree, args, i, arg); ++i)\n+  FOR_EACH_VEC_ELT (tree, args, i, arg)\n     {\n       if (type_dependent_expression_p (arg))\n \treturn true;\n@@ -18359,7 +18356,7 @@ make_args_non_dependent (VEC(tree,gc) *args)\n   unsigned int ix;\n   tree arg;\n \n-  for (ix = 0; VEC_iterate (tree, args, ix, arg); ++ix)\n+  FOR_EACH_VEC_ELT (tree, args, ix, arg)\n     {\n       tree newarg = build_non_dependent_expr (arg);\n       if (newarg != arg)\n@@ -18662,11 +18659,9 @@ append_type_to_template_for_access_check (tree templ,\n   gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n \n   /* Make sure we don't append the type to the template twice.  */\n-  for (i = 0;\n-       VEC_iterate (qualified_typedef_usage_t,\n+  FOR_EACH_VEC_ELT (qualified_typedef_usage_t,\n \t\t    get_types_needing_access_check (templ),\n-\t\t    i, iter);\n-       ++i)\n+\t\t    i, iter)\n     if (iter->typedef_decl == type_decl && scope == iter->context)\n       return;\n "}, {"sha": "22d58af0f84abc035ee4b45ec0d4b09b3ccab239", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -267,9 +267,7 @@ finish_repo (void)\n       fprintf (repo_file, \"\\n\");\n     }\n \n-  for (ix = VEC_length (tree, pending_repo) - 1;\n-       VEC_iterate (tree, pending_repo, ix, val);\n-       ix--)\n+  FOR_EACH_VEC_ELT_REVERSE (tree, pending_repo, ix, val)\n     {\n       tree name = DECL_ASSEMBLER_NAME (val);\n       char type = IDENTIFIER_REPO_CHOSEN (name) ? 'C' : 'O';"}, {"sha": "0afa8f994ea4eb7f60646d937f966488c0400f3f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -232,14 +232,10 @@ pop_to_parent_deferring_access_checks (void)\n \t  int i, j;\n \t  deferred_access_check *chk, *probe;\n \n-\t  for (i = 0 ;\n-\t       VEC_iterate (deferred_access_check, checks, i, chk) ;\n-\t       ++i)\n+\t  FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n \t    {\n-\t      for (j = 0 ;\n-\t\t   VEC_iterate (deferred_access_check,\n-\t\t\t\tptr->deferred_access_checks, j, probe) ;\n-\t\t   ++j)\n+\t      FOR_EACH_VEC_ELT (deferred_access_check,\n+\t\t\t\tptr->deferred_access_checks, j, probe)\n \t\t{\n \t\t  if (probe->binfo == chk->binfo &&\n \t\t      probe->decl == chk->decl &&\n@@ -268,7 +264,7 @@ perform_access_checks (VEC (deferred_access_check,gc)* checks)\n   if (!checks)\n     return;\n \n-  for (i = 0 ; VEC_iterate (deferred_access_check, checks, i, chk) ; ++i)\n+  FOR_EACH_VEC_ELT (deferred_access_check, checks, i, chk)\n     enforce_access (chk->binfo, chk->decl, chk->diag_decl);\n }\n \n@@ -323,10 +319,8 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl)\n     }\n \n   /* See if we are already going to perform this check.  */\n-  for (i = 0 ;\n-       VEC_iterate (deferred_access_check,\n-\t\t    ptr->deferred_access_checks, i, chk) ;\n-       ++i)\n+  FOR_EACH_VEC_ELT  (deferred_access_check,\n+\t\t     ptr->deferred_access_checks, i, chk)\n     {\n       if (chk->decl == decl && chk->binfo == binfo &&\n \t  chk->diag_decl == diag_decl)"}, {"sha": "b9c027a68cf9909503ecf14739b25ad51f4183de", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -412,7 +412,7 @@ abstract_virtuals_error (tree decl, tree type)\n \t      \"  because the following virtual functions are pure within %qT:\",\n \t      type);\n \n-      for (ix = 0; VEC_iterate (tree, pure, ix, fn); ix++)\n+      FOR_EACH_VEC_ELT (tree, pure, ix, fn)\n \tinform (input_location, \"\\t%+#D\", fn);\n       /* Now truncate the vector.  This leaves it non-null, so we know\n \t there are pure virtuals, but empty so we don't list them out\n@@ -1035,7 +1035,7 @@ process_init_constructor_array (tree type, tree init)\n   if (!unbounded && VEC_length (constructor_elt, v)  > len)\n     error (\"too many initializers for %qT\", type);\n \n-  for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n+  FOR_EACH_VEC_ELT (constructor_elt, v, i, ce)\n     {\n       if (ce->index)\n \t{"}, {"sha": "d43a4bf59aac8e19788cd61914c882f9515167ee", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2504,7 +2504,7 @@ output_used_types (void)\n       qsort (VEC_address (tree, types), VEC_length (tree, types),\n \t     sizeof (tree), output_types_sort);\n \n-      for (i = 0; VEC_iterate (tree, types, i, type); i++)\n+      FOR_EACH_VEC_ELT (tree, types, i, type)\n \tdebug_queue_symbol (type);\n \n       VEC_free (tree, heap, types);"}, {"sha": "ddd2387b2001e30fcc7d18f94e39e6f4d51ffc91", "filename": "gcc/df-scan.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1180,15 +1180,13 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n   df_ref ref;\n   struct df_mw_hardreg *mw;\n \n-  for (ix = 0; VEC_iterate (df_ref, collection_rec->def_vec, ix, ref); ++ix)\n+  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, ix, ref)\n     df_free_ref (ref);\n-  for (ix = 0; VEC_iterate (df_ref, collection_rec->use_vec, ix, ref); ++ix)\n+  FOR_EACH_VEC_ELT (df_ref, collection_rec->use_vec, ix, ref)\n     df_free_ref (ref);\n-  for (ix = 0; VEC_iterate (df_ref, collection_rec->eq_use_vec, ix, ref); ++ix)\n+  FOR_EACH_VEC_ELT (df_ref, collection_rec->eq_use_vec, ix, ref)\n     df_free_ref (ref);\n-  for (ix = 0;\n-       VEC_iterate (df_mw_hardreg_ptr, collection_rec->mw_vec, ix, mw);\n-       ++ix)\n+  FOR_EACH_VEC_ELT (df_mw_hardreg_ptr, collection_rec->mw_vec, ix, mw)\n     pool_free (problem_data->mw_reg_pool, mw);\n \n   VEC_free (df_ref, stack, collection_rec->def_vec);\n@@ -2664,7 +2662,7 @@ df_install_refs (basic_block bb,\n       if (add_to_table && df->analyze_subset)\n \tadd_to_table = bitmap_bit_p (df->blocks_to_analyze, bb->index);\n \n-      for (ix = 0; VEC_iterate (df_ref, old_vec, ix, this_ref); ++ix)\n+      FOR_EACH_VEC_ELT (df_ref, old_vec, ix, this_ref)\n \t{\n \t  new_vec[ix] = this_ref;\n \t  df_install_ref (this_ref, reg_info[DF_REF_REGNO (this_ref)],\n@@ -3398,7 +3396,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n   unsigned int ix;\n   df_ref ref;\n \n-  for (ix = 0; VEC_iterate (df_ref, collection_rec->def_vec, ix, ref); ++ix)\n+  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, ix, ref)\n     {\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_CONDITIONAL))\n         {\n@@ -3446,7 +3444,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n   /* Do not generate clobbers for registers that are the result of the\n      call.  This causes ordering problems in the chain building code\n      depending on which def is seen first.  */\n-  for (i = 0; VEC_iterate (df_ref, collection_rec->def_vec, i, def); ++i)\n+  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, i, def)\n     bitmap_set_bit (&defs_generated, DF_REF_REGNO (def));\n \n   /* Record the registers used to pass arguments, and explicitly\n@@ -4382,7 +4380,7 @@ df_refs_verify (VEC(df_ref,stack) *new_rec, df_ref *old_rec,\n   unsigned int ix;\n   df_ref new_ref;\n \n-  for (ix = 0; VEC_iterate (df_ref, new_rec, ix, new_ref); ++ix)\n+  FOR_EACH_VEC_ELT (df_ref, new_rec, ix, new_ref)\n     {\n       if (*old_rec == NULL || !df_ref_equal_p (new_ref, *old_rec))\n \t{\n@@ -4421,7 +4419,7 @@ df_mws_verify (VEC(df_mw_hardreg_ptr,stack) *new_rec,\n   unsigned int ix;\n   struct df_mw_hardreg *new_reg;\n \n-  for (ix = 0; VEC_iterate (df_mw_hardreg_ptr, new_rec, ix, new_reg); ++ix)\n+  FOR_EACH_VEC_ELT (df_mw_hardreg_ptr, new_rec, ix, new_reg)\n     {\n       if (*old_rec == NULL || !df_mw_equal_p (new_reg, *old_rec))\n \t{"}, {"sha": "b0b97c6b6ec740438f3d45f213391c89acae24a4", "filename": "gcc/dominance.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1198,7 +1198,7 @@ determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n   for (i = nc - 1; i >= 0; i--)\n     {\n       dom = NULL;\n-      for (si = 0; VEC_iterate (int, sccs[i], si, a); si++)\n+      FOR_EACH_VEC_ELT (int, sccs[i], si, a)\n \t{\n \t  bb = VEC_index (basic_block, bbs, a);\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1211,7 +1211,7 @@ determine_dominators_for_sons (struct graph *g, VEC (basic_block, heap) *bbs,\n \t}\n \n       gcc_assert (dom != NULL);\n-      for (si = 0; VEC_iterate (int, sccs[i], si, a); si++)\n+      FOR_EACH_VEC_ELT (int, sccs[i], si, a)\n \t{\n \t  bb = VEC_index (basic_block, bbs, a);\n \t  set_immediate_dominator (CDI_DOMINATORS, bb, dom);\n@@ -1314,7 +1314,7 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n \t conservatively correct, setting the dominators using the\n \t heuristics in prune_bbs_to_update_dominators could\n \t create cycles in the dominance \"tree\", and cause ICE.  */\n-      for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+      FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n \tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n     }\n \n@@ -1334,7 +1334,7 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n \n   /* Construct the graph G.  */\n   map = pointer_map_create ();\n-  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n     {\n       /* If the dominance tree is conservatively correct, split it now.  */\n       if (conservative)\n@@ -1346,7 +1346,7 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n   g = new_graph (n + 1);\n   for (y = 0; y < g->n_vertices; y++)\n     g->vertices[y].data = BITMAP_ALLOC (NULL);\n-  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n \t{"}, {"sha": "5dd7bd68bb6b07eef207549ec2bd1d98528c4ca5", "filename": "gcc/dse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2772,7 +2772,7 @@ dse_step2_init (void)\n   unsigned int i;\n   group_info_t group;\n \n-  for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n     {\n       /* For all non stack related bases, we only consider a store to\n \t be deletable if there are two or more stores for that\n@@ -2824,7 +2824,7 @@ dse_step2_nospill (void)\n      unused.  */\n   current_position = 1;\n \n-  for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n     {\n       bitmap_iterator bi;\n       unsigned int j;\n@@ -3067,7 +3067,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n   /* If this insn reads the frame, kill all the frame related stores.  */\n   if (insn_info->frame_read)\n     {\n-      for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n \tif (group->process_globally && group->frame_related)\n \t  {\n \t    if (kill)\n@@ -3078,7 +3078,7 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \n   while (read_info)\n     {\n-      for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n \t{\n \t  if (group->process_globally)\n \t    {\n@@ -3259,7 +3259,7 @@ dse_step3_exit_block_scan (bb_info_t bb_info)\n       unsigned int i;\n       group_info_t group;\n \n-      for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n \t{\n \t  if (group->process_globally && group->frame_related)\n \t    bitmap_ior_into (bb_info->gen, group->group_kill);\n@@ -3341,7 +3341,7 @@ dse_step3 (bool for_spills)\n \t      group_info_t group;\n \n \t      all_ones = BITMAP_ALLOC (NULL);\n-\t      for (j = 0; VEC_iterate (group_info_t, rtx_group_vec, j, group); j++)\n+\t      FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, j, group)\n \t\tbitmap_ior_into (all_ones, group->group_kill);\n \t    }\n \t  if (!bb_info->out)\n@@ -3743,7 +3743,7 @@ dse_step7 (bool global_done)\n   group_info_t group;\n   basic_block bb;\n \n-  for (i = 0; VEC_iterate (group_info_t, rtx_group_vec, i, group); i++)\n+  FOR_EACH_VEC_ELT (group_info_t, rtx_group_vec, i, group)\n     {\n       free (group->offset_map_n);\n       free (group->offset_map_p);"}, {"sha": "d63aec578fb1dc8962d99cccf7fd04af2793afbe", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -7560,7 +7560,7 @@ get_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n   if (! die)\n     return NULL;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (a->dw_attr == attr_kind)\n       return a;\n     else if (a->dw_attr == DW_AT_specification\n@@ -7689,7 +7689,7 @@ remove_AT (dw_die_ref die, enum dwarf_attribute attr_kind)\n   if (! die)\n     return;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (a->dw_attr == attr_kind)\n       {\n \tif (AT_class (a) == dw_val_class_str)\n@@ -8277,7 +8277,7 @@ print_die (dw_die_ref die, FILE *outfile)\n       fprintf (outfile, \"\\n\");\n     }\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       print_spaces (outfile);\n       fprintf (outfile, \"  %s: \", dwarf_attr_name (a->dw_attr));\n@@ -8556,7 +8556,7 @@ die_checksum (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n \n   CHECKSUM (die->die_tag);\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     attr_checksum (a, ctx, mark);\n \n   FOR_EACH_CHILD (die, c, die_checksum (c, ctx, mark));\n@@ -8869,7 +8869,7 @@ collect_checksum_attributes (struct checksum_attributes *attrs, dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       switch (a->dw_attr)\n         {\n@@ -9303,7 +9303,7 @@ same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n       != VEC_length (dw_attr_node, die2->die_attr))\n     return 0;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die1->die_attr, ix, a1); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die1->die_attr, ix, a1)\n     if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n       return 0;\n \n@@ -9664,7 +9664,7 @@ is_declaration_die (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (a->dw_attr == DW_AT_declaration)\n       return 1;\n \n@@ -9735,7 +9735,7 @@ clone_die (dw_die_ref die)\n   clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     add_dwarf_attr (clone, a);\n \n   return clone;\n@@ -9776,7 +9776,7 @@ clone_as_declaration (dw_die_ref die)\n   clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       /* We don't want to copy over all attributes.\n          For example we don't want DW_AT_byte_size because otherwise we will no\n@@ -9833,7 +9833,7 @@ copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n \n       remove_AT (die, DW_AT_specification);\n \n-      for (ix = 0; VEC_iterate (dw_attr_node, decl->die_attr, ix, a); ix++)\n+      FOR_EACH_VEC_ELT (dw_attr_node, decl->die_attr, ix, a)\n         {\n           if (a->dw_attr != DW_AT_name\n               && a->dw_attr != DW_AT_declaration\n@@ -10129,7 +10129,7 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       if (AT_class (a) == dw_val_class_die_ref)\n         {\n@@ -10248,7 +10248,7 @@ output_location_lists (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n       output_loc_list (AT_loc_list (a));\n \n@@ -10271,7 +10271,7 @@ build_abbrev_table (dw_die_ref die)\n \n   /* Scan the DIE references, and mark as external any that refer to\n      DIEs from other CUs (i.e. those which are not marked).  */\n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref\n \t&& AT_ref (a)->die_mark == 0)\n       {\n@@ -10295,7 +10295,7 @@ build_abbrev_table (dw_die_ref die)\n \t  != VEC_length (dw_attr_node, die->die_attr))\n \tcontinue;\n \n-      for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, die_a); ix++)\n+      FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, die_a)\n \t{\n \t  abbrev_a = VEC_index (dw_attr_node, abbrev->die_attr, ix);\n \t  if ((abbrev_a->dw_attr != die_a->dw_attr)\n@@ -10359,7 +10359,7 @@ size_of_die (dw_die_ref die)\n   unsigned ix;\n \n   size += size_of_uleb128 (die->die_abbrev);\n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       switch (AT_class (a))\n \t{\n@@ -10531,7 +10531,7 @@ unmark_all_dies (dw_die_ref die)\n \n   FOR_EACH_CHILD (die, c, unmark_all_dies (c));\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref)\n       unmark_all_dies (AT_ref (a));\n }\n@@ -10547,7 +10547,7 @@ size_of_pubnames (VEC (pubname_entry, gc) * names)\n   pubname_ref p;\n \n   size = DWARF_PUBNAMES_HEADER_SIZE;\n-  for (i = 0; VEC_iterate (pubname_entry, names, i, p); i++)\n+  FOR_EACH_VEC_ELT (pubname_entry, names, i, p)\n     if (names != pubtype_table\n \t|| p->die->die_offset != 0\n \t|| !flag_eliminate_unused_debug_types)\n@@ -10905,7 +10905,7 @@ output_die (dw_die_ref die)\n \t\t\t       (unsigned long)die->die_offset,\n \t\t\t       dwarf_tag_name (die->die_tag));\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       const char *name = dwarf_attr_name (a->dw_attr);\n \n@@ -11371,7 +11371,7 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, next_die_offset,\n \t\t       \"Compilation Unit Length\");\n \n-  for (i = 0; VEC_iterate (pubname_entry, names, i, pub); i++)\n+  FOR_EACH_VEC_ELT (pubname_entry, names, i, pub)\n     {\n       /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n       if (names == pubname_table)\n@@ -12318,7 +12318,7 @@ size_of_dcall_table (void)\n   size = 2 + DWARF_OFFSET_SIZE + 1;\n \n   /* Each entry:  code label + DIE offset.  */\n-  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, p); i++)\n+  FOR_EACH_VEC_ELT (dcall_entry, dcall_table, i, p)\n     {\n       gcc_assert (p->targ_die != NULL);\n       /* Insert a \"from\" entry when the point-of-call DIE offset changes.  */\n@@ -12360,7 +12360,7 @@ output_dcall_table (void)\n \t\t\t \"Offset of Compilation Unit Info\");\n   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n \n-  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, p); i++)\n+  FOR_EACH_VEC_ELT (dcall_entry, dcall_table, i, p)\n     {\n       /* Insert a \"from\" entry when the point-of-call DIE offset changes.  */\n       if (p->poc_decl != last_poc_decl)\n@@ -12394,7 +12394,7 @@ size_of_vcall_table (void)\n   size = 2 + 1;\n \n   /* Each entry:  code label + vtable slot index.  */\n-  for (i = 0; VEC_iterate (vcall_entry, vcall_table, i, p); i++)\n+  FOR_EACH_VEC_ELT (vcall_entry, vcall_table, i, p)\n     size += DWARF_OFFSET_SIZE + size_of_uleb128 (p->vtable_slot);\n \n   return size;\n@@ -12419,7 +12419,7 @@ output_vcall_table (void)\n   dw2_asm_output_data (2, 4, \"Version number\");\n   dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Pointer Size (in bytes)\");\n \n-  for (i = 0; VEC_iterate (vcall_entry, vcall_table, i, p); i++)\n+  FOR_EACH_VEC_ELT (vcall_entry, vcall_table, i, p)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (poc_label, \"LPOC\", p->poc_label_num);\n       dw2_asm_output_addr (DWARF_OFFSET_SIZE, poc_label, \"Point of call\");\n@@ -16713,9 +16713,7 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n \n \t  min_index = tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0);\n \t  memset (array, '\\0', size);\n-\t  for (cnt = 0;\n-\t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce);\n-\t       cnt++)\n+\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce)\n \t    {\n \t      tree val = ce->value;\n \t      tree index = ce->index;\n@@ -16761,9 +16759,7 @@ native_encode_initializer (tree init, unsigned char *array, int size)\n \t  if (TREE_CODE (type) == RECORD_TYPE)\n \t    field = TYPE_FIELDS (type);\n \n-\t  for (cnt = 0;\n-\t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce);\n-\t       cnt++, field = field ? DECL_CHAIN (field) : 0)\n+\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (init), cnt, ce)\n \t    {\n \t      tree val = ce->value;\n \t      int pos, fieldsize;\n@@ -21121,9 +21117,7 @@ gen_remaining_tmpl_value_param_die_attribute (void)\n       unsigned i;\n       die_arg_entry *e;\n \n-      for (i = 0;\n-           VEC_iterate (die_arg_entry, tmpl_value_parm_die_table, i, e);\n-           i++)\n+      FOR_EACH_VEC_ELT (die_arg_entry, tmpl_value_parm_die_table, i, e)\n \ttree_add_const_value_attribute (e->die, e->arg);\n     }\n }\n@@ -21733,7 +21727,7 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     {\n       if (a->dw_attr_val.val_class == dw_val_class_die_ref)\n \t{\n@@ -21918,7 +21912,7 @@ prune_unused_types_update_strings (dw_die_ref die)\n   dw_attr_ref a;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_str)\n       {\n \tstruct indirect_string_node *s = a->dw_attr_val.v.val_str;\n@@ -22025,13 +22019,13 @@ prune_unused_types (void)\n \n   /* Also set the mark on nodes referenced from the\n      pubname_table or arange_table.  */\n-  for (i = 0; VEC_iterate (pubname_entry, pubname_table, i, pub); i++)\n+  FOR_EACH_VEC_ELT (pubname_entry, pubname_table, i, pub)\n     prune_unused_types_mark (pub->die, 1);\n   for (i = 0; i < arange_table_in_use; i++)\n     prune_unused_types_mark (arange_table[i], 1);\n \n   /* Mark nodes referenced from the direct call table.  */\n-  for (i = 0; VEC_iterate (dcall_entry, dcall_table, i, dcall); i++)\n+  FOR_EACH_VEC_ELT (dcall_entry, dcall_table, i, dcall)\n     prune_unused_types_mark (dcall->targ_die, 1);\n \n   /* Get rid of nodes that aren't marked; and update the string counts.  */\n@@ -22190,7 +22184,7 @@ resolve_addr (dw_die_ref die)\n   dw_loc_list_ref *curr;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     switch (AT_class (a))\n       {\n       case dw_val_class_loc_list:"}, {"sha": "0df1996124b06fa9783d97b076d932f9db525129", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -3057,7 +3057,7 @@ output_one_function_exception_table (const char * ARG_UNUSED (fnname),\n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n   {\n     uchar uc;\n-    for (i = 0; VEC_iterate (uchar, crtl->eh.action_record_data, i, uc); ++i)\n+    FOR_EACH_VEC_ELT (uchar, crtl->eh.action_record_data, i, uc)\n       dw2_asm_output_data (1, uc, i ? NULL : \"Action record table\");\n   }\n "}, {"sha": "5793f9d158126cff88553644519b06dc2fe4eb13", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -6599,9 +6599,7 @@ safe_from_p (const_rtx x, tree exp, int top_p)\n \t  constructor_elt *ce;\n \t  unsigned HOST_WIDE_INT idx;\n \n-\t  for (idx = 0;\n-\t       VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (exp), idx, ce);\n-\t       idx++)\n+\t  FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (exp), idx, ce)\n \t    if ((ce->index != NULL_TREE && !safe_from_p (x, ce->index, 0))\n \t\t|| !safe_from_p (x, ce->value, 0))\n \t      return 0;"}, {"sha": "b5330ae6938d1b729df166fe82c41780515397b5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,7 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* trans-openmp.c: Use FOR_EACH_VEC_ELT.\n+\n 2010-08-19  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/29785"}, {"sha": "14e3e2f22363e9c6d95676e2c702f7bfc1d8fe83", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1357,7 +1357,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n   gfc_start_block (&body);\n \n-  for (ix = 0; VEC_iterate (dovar_init, inits, ix, di); ix++)\n+  FOR_EACH_VEC_ELT (dovar_init, inits, ix, di)\n     gfc_add_modify (&body, di->var, di->init);\n   VEC_free (dovar_init, heap, inits);\n "}, {"sha": "66f95828d37349450c34fe46a60bf14c130cad9f", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2171,7 +2171,7 @@ split_complex_args (VEC(tree, heap) **args)\n   unsigned i;\n   tree p;\n \n-  for (i = 0; VEC_iterate (tree, *args, i, p); ++i)\n+  FOR_EACH_VEC_ELT (tree, *args, i, p)\n     {\n       tree type = TREE_TYPE (p);\n       if (TREE_CODE (type) == COMPLEX_TYPE\n@@ -3295,7 +3295,7 @@ assign_parms (tree fndecl)\n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n \n-  for (i = 0; VEC_iterate (tree, fnargs, i, parm); ++i)\n+  FOR_EACH_VEC_ELT (tree, fnargs, i, parm)\n     {\n       struct assign_parm_data_one data;\n \n@@ -3523,7 +3523,7 @@ gimplify_parameters (void)\n   assign_parms_initialize_all (&all);\n   fnargs = assign_parms_augmented_arg_list (&all);\n \n-  for (i = 0; VEC_iterate (tree, fnargs, i, parm); ++i)\n+  FOR_EACH_VEC_ELT (tree, fnargs, i, parm)\n     {\n       struct assign_parm_data_one data;\n "}, {"sha": "775c7e1412723d0def45ef8a8ecd59b36a50ce27", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -4413,9 +4413,7 @@ hoist_code (void)\n \n   /* Walk over each basic block looking for potentially hoistable\n      expressions, nothing gets hoisted from the entry block.  */\n-  for (dom_tree_walk_index = 0;\n-       VEC_iterate (basic_block, dom_tree_walk, dom_tree_walk_index, bb);\n-       dom_tree_walk_index++)\n+  FOR_EACH_VEC_ELT (basic_block, dom_tree_walk, dom_tree_walk_index, bb)\n     {\n       domby = get_dominated_to_depth (CDI_DOMINATORS, bb, MAX_HOIST_DEPTH);\n \n@@ -4468,7 +4466,7 @@ hoist_code (void)\n \t      /* We've found a potentially hoistable expression, now\n \t\t we look at every block BB dominates to see if it\n \t\t computes the expression.  */\n-\t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n+\t      FOR_EACH_VEC_ELT (basic_block, domby, j, dominated)\n \t\t{\n \t\t  int max_distance;\n \n@@ -4552,9 +4550,7 @@ hoist_code (void)\n \n \t      /* Walk through occurences of I'th expressions we want\n \t\t to hoist to BB and make the transformations.  */\n-\t      for (j = 0;\n-\t\t   VEC_iterate (occr_t, occrs_to_hoist, j, occr);\n-\t\t   j++)\n+\t      FOR_EACH_VEC_ELT (occr_t, occrs_to_hoist, j, occr)\n \t\t{\n \t\t  rtx insn;\n \t\t  rtx set;"}, {"sha": "acb3a382588e37ecb348c918920e956f3e17ebf8", "filename": "gcc/genattr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -142,13 +142,13 @@ find_tune_attr (rtx exp)\n       if (strcmp (XSTR (exp, 0), \"alternative\") == 0)\n \treturn false;\n \n-      for (i = 0; VEC_iterate (rtx, const_attrs, i, attr); i++)\n+      FOR_EACH_VEC_ELT (rtx, const_attrs, i, attr)\n \tif (strcmp (XSTR (attr, 0), XSTR (exp, 0)) == 0)\n \t  {\n \t    unsigned int j;\n \t    rtx resv;\n \n-\t    for (j = 0; VEC_iterate (rtx, reservations, j, resv); j++)\n+\t    FOR_EACH_VEC_ELT (rtx, reservations, j, resv)\n \t      if (! check_tune_attr (XSTR (attr, 0), XEXP (resv, 2)))\n \t\treturn false;\n \t    return true;"}, {"sha": "cb1b64576a028b13a4eb0c6c6c6a8af691cbde3c", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -168,7 +168,7 @@ ggc_mark_roots (void)\n       for (i = 0; i < rti->nelt; i++)\n \t(*rti->cb) (*(void **)((char *)rti->base + rti->stride * i));\n \n-  for (i = 0; VEC_iterate (const_ggc_root_tab_t, extra_root_vec, i, rtp); i++)\n+  FOR_EACH_VEC_ELT (const_ggc_root_tab_t, extra_root_vec, i, rtp)\n     {\n       for (rti = rtp; rti->base != NULL; rti++)\n         for (i = 0; i < rti->nelt; i++)\n@@ -183,7 +183,7 @@ ggc_mark_roots (void)\n   for (ct = gt_ggc_cache_rtab; *ct; ct++)\n     ggc_scan_cache_tab (*ct);\n \n-  for (i = 0; VEC_iterate (const_ggc_cache_tab_t, extra_cache_vec, i, ctp); i++)\n+  FOR_EACH_VEC_ELT (const_ggc_cache_tab_t, extra_cache_vec, i, ctp)\n     ggc_scan_cache_tab (ctp);\n \n   if (! ggc_protect_identifiers)"}, {"sha": "32d07f0cc84502ae7d8c9e44098496b5de7ab5c6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -3328,7 +3328,7 @@ gimplify_init_ctor_preeval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       constructor_elt *ce;\n       VEC(constructor_elt,gc) *v = CONSTRUCTOR_ELTS (*expr_p);\n \n-      for (ix = 0; VEC_iterate (constructor_elt, v, ix, ce); ix++)\n+      FOR_EACH_VEC_ELT (constructor_elt, v, ix, ce)\n \tgimplify_init_ctor_preeval (&ce->value, pre_p, post_p, data);\n \n       return;\n@@ -3957,7 +3957,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t/* Vector types use CONSTRUCTOR all the way through gimple\n \t  compilation as a general initializer.  */\n-\tfor (ix = 0; VEC_iterate (constructor_elt, elts, ix, ce); ix++)\n+\tFOR_EACH_VEC_ELT (constructor_elt, elts, ix, ce)\n \t  {\n \t    enum gimplify_status tret;\n \t    tret = gimplify_expr (&ce->value, pre_p, post_p, is_gimple_val,\n@@ -6918,14 +6918,11 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  if (fallback == fb_none)\n \t    {\n \t      unsigned HOST_WIDE_INT ix;\n-\t      constructor_elt *ce;\n+\t      tree val;\n \t      tree temp = NULL_TREE;\n-\t      for (ix = 0;\n-\t\t   VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (*expr_p),\n-\t\t\t\tix, ce);\n-\t\t   ix++)\n-\t\tif (TREE_SIDE_EFFECTS (ce->value))\n-\t\t  append_to_statement_list (ce->value, &temp);\n+\t      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (*expr_p), ix, val)\n+\t\tif (TREE_SIDE_EFFECTS (val))\n+\t\t  append_to_statement_list (val, &temp);\n \n \t      *expr_p = temp;\n \t      ret = temp ? GS_OK : GS_ALL_DONE;"}, {"sha": "5108ed069bc91da4a6634cf6a82b75ffb079eabf", "filename": "gcc/graphite-blocking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -212,7 +212,7 @@ lst_do_strip_mine_loop (lst_p lst, int depth)\n     {\n       bool res = false;\n \n-      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+      FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n \tres |= lst_do_strip_mine_loop (l, depth);\n \n       return res;\n@@ -239,7 +239,7 @@ lst_do_strip_mine (lst_p lst)\n       || !LST_LOOP_P (lst))\n     return false;\n \n-  for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n     res |= lst_do_strip_mine (l);\n \n   depth = lst_depth (lst);"}, {"sha": "3f26ad3aaec6320c19b9eab3edcabc9791ce7ba7", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1224,7 +1224,7 @@ build_cloog_prog (scop_p scop, CloogProgram *prog,\n   cloog_program_set_nb_scattdims (prog, nbs);\n   initialize_cloog_names (scop, prog);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       CloogStatement *stmt;\n       CloogBlock *block;"}, {"sha": "6296bfc2f3d176ab6da687a14d820b336640db0d", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -585,7 +585,7 @@ reduction_dr_1 (poly_bb_p pbb1, poly_dr_p pdr1, poly_dr_p pdr2)\n   int i;\n   poly_dr_p pdr;\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr); i++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr)\n     if (PDR_TYPE (pdr) == PDR_WRITE)\n       break;\n \n@@ -722,8 +722,8 @@ graphite_legal_transform_bb (poly_bb_p pbb1, poly_bb_p pbb2)\n   if (reduction_ddr_p (pbb1, pbb2))\n     return true;\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n-    for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr1)\n+    FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), j, pdr2)\n       if (!graphite_legal_transform_dr (pdr1, pdr2))\n \treturn false;\n \n@@ -741,8 +741,8 @@ graphite_legal_transform (scop_p scop)\n \n   timevar_push (TV_GRAPHITE_DATA_DEPS);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n-    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n+    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n       if (!graphite_legal_transform_bb (pbb1, pbb2))\n \t{\n \t  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n@@ -803,8 +803,8 @@ dependency_between_pbbs_p (poly_bb_p pbb1, poly_bb_p pbb2, int level)\n \n   timevar_push (TV_GRAPHITE_DATA_DEPS);\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), i, pdr1); i++)\n-    for (j = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), j, pdr2); j++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr1)\n+    FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), j, pdr2)\n       if (graphite_carried_dependence_level_k (pdr1, pdr2, level))\n \t{\n \t  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n@@ -825,11 +825,11 @@ dot_original_deps_stmt_1 (FILE *file, scop_p scop)\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n-    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n+    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n       {\n-\tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n-\t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n+\t  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n \t    if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n \t      {\n \t\tfprintf (file, \"OS%d -> OS%d\\n\",\n@@ -850,11 +850,11 @@ dot_transformed_deps_stmt_1 (FILE *file, scop_p scop)\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n-    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n+    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n       {\n-\tfor (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n-\t  for (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n+\t  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n \t    {\n \t      poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n \n@@ -898,10 +898,10 @@ dot_original_deps (FILE *file, scop_p scop)\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n-    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n-      for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n-\tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n+    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n \t  if (!pddr_is_empty (dependence_polyhedron (pdr1, pdr2, 1, true)))\n \t    fprintf (file, \"OS%d_D%d -> OS%d_D%d\\n\",\n \t\t     pbb_index (pbb1), PDR_ID (pdr1),\n@@ -918,10 +918,10 @@ dot_transformed_deps (FILE *file, scop_p scop)\n   poly_bb_p pbb1, pbb2;\n   poly_dr_p pdr1, pdr2;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb1); i++)\n-    for (j = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), j, pbb2); j++)\n-      for (k = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb1), k, pdr1); k++)\n-\tfor (l = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb2), l, pdr2); l++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n+    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n \t  {\n \t    poly_ddr_p pddr = dependence_polyhedron (pdr1, pdr2, 1, false);\n "}, {"sha": "83027d36b213fa2fe4d32d91766d8e28dc66e082", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -349,11 +349,11 @@ memory_strides_in_loop_1 (lst_p loop, graphite_dim_t depth, mpz_t strides)\n   mpz_init (s);\n   mpz_init (n);\n \n-  for (j = 0; VEC_iterate (lst_p, LST_SEQ (loop), j, l); j++)\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (loop), j, l)\n     if (LST_LOOP_P (l))\n       memory_strides_in_loop_1 (l, depth, strides);\n     else\n-      for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (LST_PBB (l)), i, pdr); i++)\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (LST_PBB (l)), i, pdr)\n \t{\n \t  pdr_stride_in_loop (s, depth, pdr);\n \t  mpz_set_si (n, PDR_NB_REFS (pdr));\n@@ -526,7 +526,7 @@ lst_apply_interchange (lst_p lst, int depth1, int depth2)\n       int i;\n       lst_p l;\n \n-      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+      FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n \tlst_apply_interchange (l, depth1, depth2);\n     }\n   else\n@@ -672,7 +672,7 @@ lst_interchange_select_inner (scop_p scop, lst_p outer_father, int outer,\n \n   loop1 = VEC_index (lst_p, LST_SEQ (outer_father), outer);\n \n-  for (inner = 0; VEC_iterate (lst_p, LST_SEQ (inner_father), inner, loop2); inner++)\n+  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (inner_father), inner, loop2)\n     if (LST_LOOP_P (loop2)\n \t&& (lst_try_interchange_loops (scop, loop1, loop2)\n \t    || lst_interchange_select_inner (scop, outer_father, outer, loop2)))\n@@ -708,7 +708,7 @@ lst_interchange_select_outer (scop_p scop, lst_p loop, int outer)\n     }\n \n   if (LST_LOOP_P (loop))\n-    for (i = 0; VEC_iterate (lst_p, LST_SEQ (loop), i, l); i++)\n+    FOR_EACH_VEC_ELT (lst_p, LST_SEQ (loop), i, l)\n       if (LST_LOOP_P (l))\n \tres |= lst_interchange_select_outer (scop, l, i);\n "}, {"sha": "ae6ad4451ae5f0cc063303888598774ff656da6b", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -62,7 +62,7 @@ scop_max_loop_depth (scop_p scop)\n   poly_bb_p pbb;\n   int max_nb_loops = 0;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       int nb_loops = pbb_dim_iter_domain (pbb);\n       if (max_nb_loops < nb_loops)\n@@ -127,10 +127,10 @@ unify_scattering_dimensions (scop_p scop)\n   poly_bb_p pbb;\n   graphite_dim_t max_scattering = 0;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     max_scattering = MAX (pbb_nb_scattering_transform (pbb), max_scattering);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     extend_scattering (pbb, max_scattering);\n \n   return max_scattering;\n@@ -221,7 +221,7 @@ print_scattering_functions (FILE *file, scop_p scop, int verbosity)\n   int i;\n   poly_bb_p pbb;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     print_scattering_function (file, pbb, verbosity);\n }\n \n@@ -234,7 +234,7 @@ print_iteration_domains (FILE *file, scop_p scop, int verbosity)\n   int i;\n   poly_bb_p pbb;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     print_iteration_domain (file, pbb, verbosity);\n }\n \n@@ -342,8 +342,8 @@ pbb_remove_duplicate_pdrs (poly_bb_p pbb)\n   unsigned n = VEC_length (poly_dr_p, PBB_DRS (pbb));\n   VEC (poly_dr_p, heap) *collapsed = VEC_alloc (poly_dr_p, heap, n);\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr1); i++)\n-    for (j = 0; VEC_iterate (poly_dr_p, collapsed, j, pdr2); j++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr1)\n+    FOR_EACH_VEC_ELT (poly_dr_p, collapsed, j, pdr2)\n       if (!can_collapse_pdrs (pdr1, pdr2))\n \tVEC_quick_push (poly_dr_p, collapsed, pdr1);\n \n@@ -422,7 +422,7 @@ free_poly_bb (poly_bb_p pbb)\n     poly_scattering_free (PBB_ORIGINAL (pbb));\n \n   if (PBB_DRS (pbb))\n-    for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+    FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr)\n       free_poly_dr (pdr);\n \n   VEC_free (poly_dr_p, heap, PBB_DRS (pbb));\n@@ -533,7 +533,7 @@ free_scop (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     free_poly_bb (pbb);\n \n   VEC_free (poly_bb_p, heap, SCOP_BBS (scop));\n@@ -600,7 +600,7 @@ dump_gbb_cases (FILE *file, gimple_bb_p gbb)\n \n   fprintf (file, \"# cases bb_%d (\\n\", GBB_BB (gbb)->index);\n \n-  for (i = 0; VEC_iterate (gimple, cases, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, cases, i, stmt)\n     {\n       fprintf (file, \"# \");\n       print_gimple_stmt (file, stmt, 0, 0);\n@@ -627,7 +627,7 @@ dump_gbb_conditions (FILE *file, gimple_bb_p gbb)\n \n   fprintf (file, \"# conditions bb_%d (\\n\", GBB_BB (gbb)->index);\n \n-  for (i = 0; VEC_iterate (gimple, conditions, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, conditions, i, stmt)\n     {\n       fprintf (file, \"# \");\n       print_gimple_stmt (file, stmt, 0, 0);\n@@ -662,7 +662,7 @@ print_pdrs (FILE *file, poly_bb_p pbb, int verbosity)\n     fprintf (file, \"# Access informations are provided\\n\");\n   fprintf (file, \"1\\n\");\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr)\n     if (PDR_TYPE (pdr) == PDR_READ)\n       nb_reads++;\n     else\n@@ -675,7 +675,7 @@ print_pdrs (FILE *file, poly_bb_p pbb, int verbosity)\n     fprintf (file, \"# Read access informations\\n\");\n   fprintf (file, \"%d\\n\", nb_reads);\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr)\n     if (PDR_TYPE (pdr) == PDR_READ)\n       print_pdr (file, pdr, verbosity);\n \n@@ -689,7 +689,7 @@ print_pdrs (FILE *file, poly_bb_p pbb, int verbosity)\n     fprintf (file, \"# Write access informations\\n\");\n   fprintf (file, \"%d\\n\", nb_writes);\n \n-  for (i = 0; VEC_iterate (poly_dr_p, PBB_DRS (pbb), i, pdr); i++)\n+  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr)\n     if (PDR_TYPE (pdr) != PDR_READ)\n       print_pdr (file, pdr, verbosity);\n \n@@ -784,7 +784,7 @@ print_scop_params (FILE *file, scop_p scop, int verbosity)\n       fprintf (file, \"0\\n\");\n     }\n \n-  for (i = 0; VEC_iterate (tree, SESE_PARAMS (SCOP_REGION (scop)), i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, SESE_PARAMS (SCOP_REGION (scop)), i, t)\n     {\n       print_generic_expr (file, t, 0);\n       fprintf (file, \" \");\n@@ -841,7 +841,7 @@ print_scop (FILE *file, scop_p scop, int verbosity)\n \n   fprintf (file, \"%d\\n\",VEC_length (poly_bb_p, SCOP_BBS (scop)));\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     print_pbb (file, pbb, verbosity);\n \n   if (verbosity > 1)\n@@ -880,7 +880,7 @@ print_cloog (FILE *file, scop_p scop, int verbosity)\n \n   fprintf (file, \"%d\\n\", VEC_length (poly_bb_p, SCOP_BBS (scop)));\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       if (verbosity > 1)\n \tfprintf (file, \"# pbb_%d (\\n\", pbb_index (pbb));\n@@ -909,7 +909,7 @@ print_cloog (FILE *file, scop_p scop, int verbosity)\n   fprintf (file, \"%d\\n\", VEC_length (poly_bb_p, SCOP_BBS (scop)));\n   unify_scattering_dimensions (scop);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       if (!PBB_TRANSFORMED (pbb)\n \t  || !(PBB_TRANSFORMED_SCATTERING (pbb)\n@@ -1214,7 +1214,7 @@ print_lst (FILE *file, lst_p lst, int indent)\n       else\n \tfprintf (file, \"#(root\");\n \n-      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+      FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n \tprint_lst (file, l, indent + 2);\n \n       fprintf (file, \")\");\n@@ -1255,7 +1255,7 @@ dot_lst_1 (FILE *file, lst_p lst)\n \t\t lst_depth (lst),\n \t\t lst_dewey_number (lst));\n \n-      for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+      FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n \tdot_lst_1 (file, l);\n     }\n "}, {"sha": "e2847b88be5c35a01bf051d99c55993116c70aaa", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -148,7 +148,7 @@ move_sd_regions (VEC (sd_region, heap) **source,\n   sd_region *s;\n   int i;\n \n-  for (i = 0; VEC_iterate (sd_region, *source, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, *source, i, s)\n     VEC_safe_push (sd_region, heap, *target, s);\n \n   VEC_free (sd_region, heap, *source);\n@@ -284,7 +284,7 @@ stmt_has_simple_data_refs_p (loop_p outermost_loop, gimple stmt)\n \n   graphite_find_data_references_in_stmt (outermost_loop, stmt, &drs);\n \n-  for (j = 0; VEC_iterate (data_reference_p, drs, j, dr); j++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, j, dr)\n     for (i = 0; i < DR_NUM_DIMENSIONS (dr); i++)\n       if (!graphite_can_represent_scev (DR_ACCESS_FN (dr, i), loop))\n \t{\n@@ -552,7 +552,7 @@ scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n \t\t  - The exit destinations are dominated by another bb inside\n \t\t    the loop.\n \t\t  - The loop dominates bbs, that are not exit destinations.  */\n-        for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+        FOR_EACH_VEC_ELT (edge, exits, i, e)\n           if (e->src->loop_father == loop\n \t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src))\n \t    {\n@@ -590,7 +590,7 @@ scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n \n \t/* First check the successors of BB, and check if it is\n \t   possible to join the different branches.  */\n-\tfor (i = 0; VEC_iterate (edge, bb->succs, i, e); i++)\n+\tFOR_EACH_VEC_ELT (edge, bb->succs, i, e)\n \t  {\n \t    /* Ignore loop exits.  They will be handled after the loop\n \t       body.  */\n@@ -676,7 +676,7 @@ scopdet_basic_block_info (basic_block bb, loop_p outermost_loop,\n \t/* Scan remaining bbs dominated by BB.  */\n \tdominated = get_dominated_by (CDI_DOMINATORS, bb);\n \n-\tfor (i = 0; VEC_iterate (basic_block, dominated, i, dom_bb); i++)\n+\tFOR_EACH_VEC_ELT (basic_block, dominated, i, dom_bb)\n \t  {\n \t    /* Ignore loop exits: they will be handled after the loop body.  */\n \t    if (loop_depth (find_common_loop (loop, dom_bb->loop_father))\n@@ -990,7 +990,7 @@ unmark_exit_edges (VEC (sd_region, heap) *regions)\n   edge e;\n   edge_iterator ei;\n \n-  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, regions, i, s)\n     FOR_EACH_EDGE (e, ei, s->exit->preds)\n       e->aux = NULL;\n }\n@@ -1007,7 +1007,7 @@ mark_exit_edges (VEC (sd_region, heap) *regions)\n   edge e;\n   edge_iterator ei;\n \n-  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, regions, i, s)\n     FOR_EACH_EDGE (e, ei, s->exit->preds)\n       if (bb_in_sd_region (e->src, s))\n \te->aux = s;\n@@ -1021,12 +1021,12 @@ create_sese_edges (VEC (sd_region, heap) *regions)\n   int i;\n   sd_region *s;\n \n-  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, regions, i, s)\n     create_single_entry_edge (s);\n \n   mark_exit_edges (regions);\n \n-  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, regions, i, s)\n     /* Don't handle multiple edges exiting the function.  */\n     if (!find_single_exit_edge (s)\n \t&& s->exit != EXIT_BLOCK_PTR)\n@@ -1052,7 +1052,7 @@ build_graphite_scops (VEC (sd_region, heap) *regions,\n   int i;\n   sd_region *s;\n \n-  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+  FOR_EACH_VEC_ELT (sd_region, regions, i, s)\n     {\n       edge entry = find_single_entry_edge (s);\n       edge exit = find_single_exit_edge (s);\n@@ -1070,7 +1070,7 @@ build_graphite_scops (VEC (sd_region, heap) *regions,\n \t  int j;\n \t  sd_region *s2;\n \n-\t  for (j = 0; VEC_iterate (sd_region, regions, j, s2); j++)\n+\t  FOR_EACH_VEC_ELT (sd_region, regions, j, s2)\n \t    if (s != s2)\n \t      gcc_assert (!bb_in_sd_region (s->entry, s2));\n \t}\n@@ -1159,7 +1159,7 @@ print_graphite_statistics (FILE* file, VEC (scop_p, heap) *scops)\n   int i;\n   scop_p scop;\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     print_graphite_scop_statistics (file, scop);\n }\n \n@@ -1191,14 +1191,14 @@ limit_scops (VEC (scop_p, heap) **scops)\n   int i;\n   scop_p scop;\n \n-  for (i = 0; VEC_iterate (scop_p, *scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, *scops, i, scop)\n     {\n       int j;\n       loop_p loop;\n       sese region = SCOP_REGION (scop);\n       build_sese_loop_nests (region);\n \n-      for (j = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), j, loop); j++)\n+      FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), j, loop)\n         if (!loop_in_sese_p (loop_outer (loop), region)\n \t    && single_exit (loop))\n           {\n@@ -1380,7 +1380,7 @@ dot_all_scops_1 (FILE *file, VEC (scop_p, heap) *scops)\n       fprintf (file, \"CELLSPACING=\\\"0\\\">\\n\");\n \n       /* Select color for SCoP.  */\n-      for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+      FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n \t{\n \t  sese region = SCOP_REGION (scop);\n \t  if (bb_in_sese_p (bb, region)"}, {"sha": "0fd6120ced031d8931063093c9dd55658621857a", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -278,7 +278,7 @@ free_data_refs_aux (VEC (data_reference_p, heap) *datarefs)\n   unsigned int i;\n   struct data_reference *dr;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     if (dr->aux)\n       {\n \tbase_alias_pair *bap = (base_alias_pair *)(dr->aux);\n@@ -312,7 +312,7 @@ remove_gbbs_in_scop (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     free_gimple_bb (PBB_BLACK_BOX (pbb));\n }\n \n@@ -324,7 +324,7 @@ free_scops (VEC (scop_p, heap) *scops)\n   int i;\n   scop_p scop;\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     {\n       remove_gbbs_in_scop (scop);\n       free_sese (SCOP_REGION (scop));\n@@ -434,7 +434,7 @@ build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb, sbitmap reductio\n       int i;\n       basic_block dom_bb;\n \n-      for (i = 0; VEC_iterate (basic_block, dom, i, dom_bb); i++)\n+      FOR_EACH_VEC_ELT (basic_block, dom, i, dom_bb)\n \tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n \t  {\n \t    build_scop_bbs_1 (scop, visited, dom_bb, reductions);\n@@ -616,7 +616,7 @@ build_scop_scattering (scop_p scop)\n   ppl_assign_Coefficient_from_mpz_t (c, v);\n   ppl_Linear_Expression_add_to_coefficient (static_schedule, 0, c);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n       ppl_Linear_Expression_t common;\n@@ -741,7 +741,7 @@ parameter_index_in_region_1 (tree name, sese region)\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n \n-  for (i = 0; VEC_iterate (tree, SESE_PARAMS (region), i, p); i++)\n+  FOR_EACH_VEC_ELT (tree, SESE_PARAMS (region), i, p)\n     if (p == name)\n       return i;\n \n@@ -955,12 +955,12 @@ find_params_in_bb (sese region, gimple_bb_p gbb)\n   mpz_set_si (one, 1);\n \n   /* Find parameters in the access functions of data references.  */\n-  for (i = 0; VEC_iterate (data_reference_p, GBB_DATA_REFS (gbb), i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, GBB_DATA_REFS (gbb), i, dr)\n     for (j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n       scan_tree_for_params (region, DR_ACCESS_FN (dr, j), NULL, one);\n \n   /* Find parameters in conditional statements.  */\n-  for (i = 0; VEC_iterate (gimple, GBB_CONDITIONS (gbb), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, GBB_CONDITIONS (gbb), i, stmt)\n     {\n       tree lhs = scalar_evolution_in_region (region, loop,\n \t\t\t\t\t     gimple_cond_lhs (stmt));\n@@ -990,7 +990,7 @@ find_scop_parameters (scop_p scop)\n   mpz_set_si (one, 1);\n \n   /* Find the parameters used in the loop bounds.  */\n-  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), i, loop)\n     {\n       tree nb_iters = number_of_latch_executions (loop);\n \n@@ -1004,7 +1004,7 @@ find_scop_parameters (scop_p scop)\n   mpz_clear (one);\n \n   /* Find the parameters used in data accesses.  */\n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n \n   scop_set_nb_params (scop, sese_nb_params (region));\n@@ -1335,7 +1335,7 @@ add_conditions_to_domain (poly_bb_p pbb)\n   if (VEC_empty (gimple, GBB_CONDITIONS (gbb)))\n     return;\n \n-  for (i = 0; VEC_iterate (gimple, GBB_CONDITIONS (gbb), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, GBB_CONDITIONS (gbb), i, stmt)\n     switch (gimple_code (stmt))\n       {\n       case GIMPLE_COND:\n@@ -1490,7 +1490,7 @@ add_conditions_to_constraints (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     add_conditions_to_domain (pbb);\n }\n \n@@ -1586,11 +1586,11 @@ build_scop_iteration_domain (scop_p scop)\n \n   ppl_new_C_Polyhedron_from_space_dimension (&ph, scop_nb_params (scop), 0);\n \n-  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), i, loop)\n     if (!loop_in_sese_p (loop_outer (loop), region))\n       build_loop_iteration_domains (scop, loop, ph, 0, domains);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     if (domains[gbb_loop (PBB_BLACK_BOX (pbb))->num])\n       ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n \t(&PBB_DOMAIN (pbb), (ppl_const_Pointset_Powerset_C_Polyhedron_t)\n@@ -1788,7 +1788,7 @@ write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n   if (num_vertex == 0)\n     return true;\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_may_alias_p (dr1, dr2))\n \tedge_num++;\n@@ -1800,7 +1800,7 @@ write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n \n   fprintf (file, \"p edge %d %d\\n\", num_vertex, edge_num);\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_may_alias_p (dr1, dr2))\n \tfprintf (file, \"e %d %d\\n\", i + 1, j + 1);\n@@ -1827,10 +1827,10 @@ write_alias_graph_to_ascii_dot (FILE *file, char *comment,\n     fprintf (file, \"c %s\\n\", comment);\n \n   /* First print all the vertices.  */\n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     fprintf (file, \"n%d;\\n\", i);\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_may_alias_p (dr1, dr2))\n \tfprintf (file, \"n%d n%d\\n\", i, j);\n@@ -1856,7 +1856,7 @@ write_alias_graph_to_ascii_ecc (FILE *file, char *comment,\n   if (comment)\n     fprintf (file, \"c %s\\n\", comment);\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_may_alias_p (dr1, dr2))\n \tfprintf (file, \"%d %d\\n\", i, j);\n@@ -1892,7 +1892,7 @@ build_alias_set_optimal_p (VEC (data_reference_p, heap) *drs)\n   int this_component_is_clique;\n   int all_components_are_cliques = 1;\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i+1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_may_alias_p (dr1, dr2))\n \t{\n@@ -1972,7 +1972,7 @@ build_base_obj_set_for_drs (VEC (data_reference_p, heap) *drs)\n   int i, j;\n   int *queue;\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n       if (dr_same_base_object_p (dr1, dr2))\n \t{\n@@ -2010,7 +2010,7 @@ build_pbb_drs (poly_bb_p pbb)\n   data_reference_p dr;\n   VEC (data_reference_p, heap) *gbb_drs = GBB_DATA_REFS (PBB_BLACK_BOX (pbb));\n \n-  for (j = 0; VEC_iterate (data_reference_p, gbb_drs, j, dr); j++)\n+  FOR_EACH_VEC_ELT (data_reference_p, gbb_drs, j, dr)\n     build_poly_dr (dr, pbb);\n }\n \n@@ -2060,12 +2060,12 @@ build_scop_drs (scop_p scop)\n   data_reference_p dr;\n   VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 3);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     for (j = 0; VEC_iterate (data_reference_p,\n \t\t\t     GBB_DATA_REFS (PBB_BLACK_BOX (pbb)), j, dr); j++)\n       VEC_safe_push (data_reference_p, heap, drs, dr);\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr)\n     dr->aux = XNEW (base_alias_pair);\n \n   if (!build_alias_set_optimal_p (drs))\n@@ -2083,7 +2083,7 @@ build_scop_drs (scop_p scop)\n \n   VEC_free (data_reference_p, heap, drs);\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     build_pbb_drs (pbb);\n }\n \n@@ -2549,7 +2549,7 @@ nb_pbbs_in_loops (scop_p scop)\n   poly_bb_p pbb;\n   int res = 0;\n \n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), SCOP_REGION (scop)))\n       res++;\n \n@@ -2862,7 +2862,7 @@ remove_phi (gimple phi)\n \t}\n     }\n \n-  for (i = 0; VEC_iterate (gimple, update, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, update, i, stmt)\n     update_stmt (stmt);\n \n   VEC_free (gimple, heap, update);\n@@ -2890,7 +2890,7 @@ translate_scalar_reduction_to_array (VEC (gimple, heap) *in,\n   gimple loop_phi;\n   tree red = NULL_TREE;\n \n-  for (i = 0; VEC_iterate (gimple, in, i, loop_phi); i++)\n+  FOR_EACH_VEC_ELT (gimple, in, i, loop_phi)\n     {\n       gimple close_phi = VEC_index (gimple, out, i);\n "}, {"sha": "6b083d1258173a6257f58f8caa3b0490894a38ef", "filename": "gcc/graphite.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -192,7 +192,7 @@ print_graphite_statistics (FILE* file, VEC (scop_p, heap) *scops)\n \n   scop_p scop;\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     print_graphite_scop_statistics (file, scop);\n }\n \n@@ -279,12 +279,12 @@ graphite_transform_loops (void)\n   reductions = sbitmap_alloc (last_basic_block * 2);\n   sbitmap_zero (reductions);\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       rewrite_commutative_reductions_out_of_ssa (SCOP_REGION (scop),\n \t\t\t\t\t\t reductions);\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n \trewrite_reductions_out_of_ssa (scop);\n@@ -294,11 +294,11 @@ graphite_transform_loops (void)\n \n   sbitmap_free (reductions);\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       build_poly_scop (scop);\n \n-  for (i = 0; VEC_iterate (scop_p, scops, i, scop); i++)\n+  FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (POLY_SCOP_P (scop)\n \t&& apply_poly_transforms (scop)\n \t&& gloog (scop, bb_pbb_mapping))"}, {"sha": "278768547a81cb8392db733feb2f8885b0345f35", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -5093,7 +5093,7 @@ calc_priorities (rtx_vec_t roots)\n   int i;\n   rtx insn;\n \n-  for (i = 0; VEC_iterate (rtx, roots, i, insn); i++)\n+  FOR_EACH_VEC_ELT (rtx, roots, i, insn)\n     priority (insn);\n }\n \n@@ -5321,7 +5321,7 @@ sched_scan (const struct sched_scan_info_def *ssi,\n \t  unsigned i;\n \t  basic_block x;\n \n-\t  for (i = 0; VEC_iterate (basic_block, bbs, i, x); i++)\n+\t  FOR_EACH_VEC_ELT (basic_block, bbs, i, x)\n \t    init_bb (x);\n \t}\n \n@@ -5336,7 +5336,7 @@ sched_scan (const struct sched_scan_info_def *ssi,\n       unsigned i;\n       basic_block x;\n \n-      for (i = 0; VEC_iterate (basic_block, bbs, i, x); i++)\n+      FOR_EACH_VEC_ELT (basic_block, bbs, i, x)\n \tinit_insns_in_bb (x);\n     }\n \n@@ -5348,7 +5348,7 @@ sched_scan (const struct sched_scan_info_def *ssi,\n       unsigned i;\n       rtx x;\n \n-      for (i = 0; VEC_iterate (rtx, insns, i, x); i++)\n+      FOR_EACH_VEC_ELT (rtx, insns, i, x)\n \tinit_insn (x);\n     }\n \n@@ -5478,7 +5478,7 @@ haifa_finish_h_i_d (void)\n   haifa_insn_data_t data;\n   struct reg_use_data *use, *next;\n \n-  for (i = 0; VEC_iterate (haifa_insn_data_def, h_i_d, i, data); i++)\n+  FOR_EACH_VEC_ELT (haifa_insn_data_def, h_i_d, i, data)\n     {\n       if (data->reg_pressure != NULL)\n \tfree (data->reg_pressure);"}, {"sha": "9ac4b13caa757f2c4e8c1b935ab73ba1471365ca", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2760,7 +2760,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n      source register does not change after the assignment.  Also count\n      the number of registers set in only one of the blocks.  */\n   c = 0;\n-  for (i = 0; VEC_iterate (int, then_regs, i, reg); i++)\n+  FOR_EACH_VEC_ELT (int, then_regs, i, reg)\n     {\n       if (!then_vals[reg] && !else_vals[reg])\n \tcontinue;\n@@ -2781,7 +2781,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n     }\n \n   /* Finish off c for MAX_CONDITIONAL_EXECUTE.  */\n-  for (i = 0; VEC_iterate (int, else_regs, i, reg); ++i)\n+  FOR_EACH_VEC_ELT (int, else_regs, i, reg)\n     if (!then_vals[reg])\n       ++c;\n "}, {"sha": "a96dadd3035cf8418d9c489fb6cace79a3f37bb8", "filename": "gcc/implicit-zee.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fimplicit-zee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fimplicit-zee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fimplicit-zee.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -727,7 +727,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n      in this vector.  */\n \n   vec = VEC_alloc (rtx, heap, 8);\n-  for (defs_ix = 0; VEC_iterate (rtx, defs_list, defs_ix, def_insn); defs_ix++)\n+  FOR_EACH_VEC_ELT (rtx, defs_list, defs_ix, def_insn)\n     {\n       merge_code = get_insn_status (def_insn);\n       gcc_assert (merge_code == MERGE_NOT_ATTEMPTED);\n@@ -746,7 +746,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n \n   if (merge_successful)\n     {\n-      for (i = 0; VEC_iterate (rtx, copies_list, i, def_insn); i++)\n+      FOR_EACH_VEC_ELT (rtx, copies_list, i, def_insn)\n         {\n           if (transform_ifelse (def_insn))\n             {\n@@ -773,7 +773,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n           if (dump_file)\n             fprintf (dump_file, \"All merges were successful ....\\n\");\n \n-          for (i = 0; VEC_iterate (rtx, vec, i, def_insn); i++)\n+          FOR_EACH_VEC_ELT (rtx, vec, i, def_insn)\n             {\n               set_insn_status (def_insn, MERGE_SUCCESS);\n             }\n@@ -791,7 +791,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n \n           if (dump_file)\n             {\n-              for (i = 0; VEC_iterate (rtx, vec, i, def_insn); i++)\n+              FOR_EACH_VEC_ELT (rtx, vec, i, def_insn)\n                 {\n                   fprintf (dump_file, \" Ummergable definitions : \\n\");\n                   print_rtl_single (dump_file, def_insn);\n@@ -916,7 +916,7 @@ find_and_remove_ze (void)\n \n   zeinsn_list = find_removable_zero_extends ();\n \n-  for (ix = 0; VEC_iterate (rtx, zeinsn_list, ix, curr_insn); ix++)\n+  FOR_EACH_VEC_ELT (rtx, zeinsn_list, ix, curr_insn)\n     {\n       num_ze_opportunities++;\n       /* Try to combine the zero-extends with the definition here.  */\n@@ -937,7 +937,7 @@ find_and_remove_ze (void)\n     }\n \n   /* Delete all useless zero extensions here in one sweep.  */\n-  for (ix = 0; VEC_iterate (rtx, zeinsn_del_list, ix, curr_insn); ix++)\n+  FOR_EACH_VEC_ELT (rtx, zeinsn_del_list, ix, curr_insn)\n     delete_insn (curr_insn);\n \n   free (is_insn_merge_attempted);"}, {"sha": "83fdeaed09f526941591f7234ac8b7466ec306d5", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1672,9 +1672,7 @@ ipa_free_all_edge_args (void)\n   int i;\n   struct ipa_edge_args *args;\n \n-  for (i = 0;\n-       VEC_iterate (ipa_edge_args_t, ipa_edge_args_vector, i, args);\n-       i++)\n+  FOR_EACH_VEC_ELT (ipa_edge_args_t, ipa_edge_args_vector, i, args)\n     ipa_free_edge_args_substructures (args);\n \n   VEC_free (ipa_edge_args_t, gc, ipa_edge_args_vector);\n@@ -1701,9 +1699,7 @@ ipa_free_all_node_params (void)\n   int i;\n   struct ipa_node_params *info;\n \n-  for (i = 0;\n-       VEC_iterate (ipa_node_params_t, ipa_node_params_vector, i, info);\n-       i++)\n+  FOR_EACH_VEC_ELT (ipa_node_params_t, ipa_node_params_vector, i, info)\n     ipa_free_node_params_substructures (info);\n \n   VEC_free (ipa_node_params_t, heap, ipa_node_params_vector);"}, {"sha": "d787a66c1c2e9fa5ca30163304bb15aed64dde31", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -556,7 +556,7 @@ finalize_new_vars_creation (void **slot, void *data ATTRIBUTE_UNUSED)\n   unsigned i;\n   tree var;\n \n-  for (i = 0; VEC_iterate (tree, n_var->new_vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, n_var->new_vars, i, var)\n     finalize_var_creation (var);\n   return 1;\n }\n@@ -570,7 +570,7 @@ find_var_in_new_vars_vec (new_var var, tree new_type)\n   tree n_var;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (tree, var->new_vars, i, n_var); i++)\n+  FOR_EACH_VEC_ELT (tree, var->new_vars, i, n_var)\n     {\n       tree type = strip_type(get_type_of_var (n_var));\n       gcc_assert (type);\n@@ -786,7 +786,7 @@ is_part_of_malloc (gimple stmt, tree fn_decl)\n       alloc_site_t *call;\n       unsigned i;\n \n-      for (i = 0; VEC_iterate (alloc_site_t, fallocs->allocs, i, call); i++)\n+      FOR_EACH_VEC_ELT (alloc_site_t, fallocs->allocs, i, call)\n \tif (call->stmt == stmt\n \t    || get_final_alloc_stmt (call->stmt) == stmt)\n \t  return true;\n@@ -1065,7 +1065,7 @@ find_structure (tree type)\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     if (is_equal_types (str->decl, type))\n       return i;\n \n@@ -1259,7 +1259,7 @@ create_new_stmts_for_cond_expr (gimple stmt)\n   arg = integer_zerop (arg0) ? arg1 : arg0;\n   pos = integer_zerop (arg0) ? 1 : 0;\n \n-  for (i = 0; VEC_iterate (tree, str->new_types, i, type); i++)\n+  FOR_EACH_VEC_ELT (tree, str->new_types, i, type)\n     {\n       tree new_arg;\n \n@@ -1313,7 +1313,7 @@ create_general_new_stmt (struct access_site *acc, tree new_type)\n       gimple_set_vdef (new_stmt, NULL_TREE);\n     }\n \n-  for (i = 0; VEC_iterate (tree, acc->vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, acc->vars, i, var)\n     {\n       tree new_var = find_new_var_of_type (var, new_type);\n       tree lhs, rhs = NULL_TREE;\n@@ -1366,7 +1366,7 @@ create_new_stmts_for_general_acc (struct access_site *acc, d_str str)\n   gimple stmt = acc->stmt;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (tree, str->new_types, i, type); i++)\n+  FOR_EACH_VEC_ELT (tree, str->new_types, i, type)\n     {\n       gimple new_stmt;\n \n@@ -1475,7 +1475,7 @@ update_varpool_with_new_var (void **slot, void *data ATTRIBUTE_UNUSED)\n   tree var;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (tree, n_var->new_vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, n_var->new_vars, i, var)\n     insert_global_to_varpool (var);\n   return 1;\n }\n@@ -1566,7 +1566,7 @@ add_unsuitable_type (VEC (tree, heap) **unsuitable_types, tree type)\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  for (i = 0; VEC_iterate (tree, *unsuitable_types, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, *unsuitable_types, i, t)\n     if (is_equal_types (t, type))\n       break;\n \n@@ -2088,7 +2088,7 @@ dump_acc (void **slot, void *data ATTRIBUTE_UNUSED)\n     print_gimple_stmt (dump_file, acc->stmt, 0, 0);\n   fprintf(dump_file, \" : \");\n \n-  for (i = 0; VEC_iterate (tree, acc->vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, acc->vars, i, var)\n     {\n       print_generic_expr (dump_file, var, 0);\n       fprintf(dump_file, \", \");\n@@ -2155,7 +2155,7 @@ create_new_accesses_in_bb (basic_block bb)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     create_new_accs_for_struct (str, bb);\n }\n \n@@ -2168,7 +2168,7 @@ create_new_alloc_sites (fallocs_t m_data, tree context)\n   alloc_site_t *call;\n   unsigned j;\n \n-  for (j = 0; VEC_iterate (alloc_site_t, m_data->allocs, j, call); j++)\n+  FOR_EACH_VEC_ELT (alloc_site_t, m_data->allocs, j, call)\n     {\n       gimple stmt = call->stmt;\n       d_str str = call->str;\n@@ -2187,7 +2187,7 @@ create_new_alloc_sites (fallocs_t m_data, tree context)\n \t}\n \n       /* Generate an allocation sites for each new structure type.  */\n-      for (i = 0; VEC_iterate (tree, str->new_types, i, type); i++)\n+      FOR_EACH_VEC_ELT (tree, str->new_types, i, type)\n \t{\n \t  gimple new_malloc_stmt = NULL;\n \t  gimple last_stmt_tmp = NULL;\n@@ -2646,7 +2646,7 @@ free_structures (void)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     free_data_struct (str);\n \n   VEC_free (structure, heap, structures);\n@@ -2874,7 +2874,7 @@ exclude_escaping_types_1 (VEC (tree, heap) **unsuitable_types)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     check_type_escape (str, unsuitable_types);\n }\n \n@@ -3355,8 +3355,8 @@ remove_unsuitable_types (VEC (tree, heap) *unsuitable_types)\n   tree type;\n   unsigned i, j;\n \n-  for (j = 0; VEC_iterate (tree, unsuitable_types, j, type); j++)\n-    for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (tree, unsuitable_types, j, type)\n+    FOR_EACH_VEC_ELT (structure, structures, i, str)\n       if (is_equal_types (str->decl, type))\n \t{\n \t  remove_structure (i);\n@@ -3375,7 +3375,7 @@ exclude_types_with_bit_fields (VEC (tree, heap) **unsuitable_types)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     check_bitfields (str, unsuitable_types);\n }\n \n@@ -3406,7 +3406,7 @@ analyze_struct_form (VEC (tree, heap) **unsuitable_types)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     check_struct_form (str, unsuitable_types);\n }\n \n@@ -3580,7 +3580,7 @@ dump_accesses (void)\n   if (!dump_file)\n     return;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     dump_accs (str);\n }\n \n@@ -3618,7 +3618,7 @@ exclude_alloc_and_field_accs (struct cgraph_node *node)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     exclude_alloc_and_field_accs_1 (str, node);\n }\n \n@@ -3783,7 +3783,7 @@ dump_new_types (void)\n   fprintf (dump_file, \"\\nThe following are the new types generated by\"\n \t   \" this optimization:\\n\");\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     {\n       if (dump_file)\n \t{\n@@ -3792,7 +3792,7 @@ dump_new_types (void)\n \t  fprintf (dump_file, \"\\nthe number of new types is %d\\n\",\n \t\t   VEC_length (tree, str->new_types));\n \t}\n-      for (j = 0; VEC_iterate (tree, str->new_types, j, type); j++)\n+      FOR_EACH_VEC_ELT (tree, str->new_types, j, type)\n \tdump_struct_type (type, 2, 0);\n     }\n }\n@@ -3806,7 +3806,7 @@ create_new_types (void)\n   unsigned i;\n   int str_num = 0;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     create_new_type (str, &str_num);\n }\n \n@@ -3911,7 +3911,7 @@ exclude_cold_structs (void)\n   d_str str;\n \n   /* We summarize counts of fields of a structure into the structure count.  */\n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     sum_counts (str, &hottest);\n \n   /* Remove cold structures from structures vector.  */\n@@ -3940,7 +3940,7 @@ peel_structs (void)\n   d_str str;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (structure, structures, i, str); i++)\n+  FOR_EACH_VEC_ELT (structure, structures, i, str)\n     peel_hot_fields (str);\n }\n "}, {"sha": "be5c4a31e922bd79337c96cd8b072bf09d30a195", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -658,7 +658,7 @@ function_and_variable_visibility (bool whole_program)\n   alias_pair *p;\n \n   /* Discover aliased nodes.  */\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     {\n       if (dump_file)\n        fprintf (dump_file, \"Alias %s->%s\","}, {"sha": "00ddcb70ceb00775ec935d702b3bbf290560c80a", "filename": "gcc/ira-build.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -127,7 +127,7 @@ create_loop_tree_nodes (bool loops_p)\n \t\t    ira_allocate (sizeof (struct ira_loop_tree_node)\n \t\t\t\t  * VEC_length (loop_p, ira_loops.larray)));\n   max_regno = max_reg_num ();\n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     {\n       if (loop != ira_loops.tree_root)\n \t{\n@@ -145,7 +145,7 @@ create_loop_tree_nodes (bool loops_p)\n \t  if (skip_p)\n \t    continue;\n \t  edges = get_loop_exit_edges (loop);\n-\t  for (j = 0; VEC_iterate (edge, edges, j, e); j++)\n+\t  FOR_EACH_VEC_ELT (edge, edges, j, e)\n \t    if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n \t      {\n \t\tskip_p = true;\n@@ -176,7 +176,7 @@ more_one_region_p (void)\n   unsigned int i;\n   loop_p loop;\n \n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     if (ira_loop_nodes[i].regno_allocno_map != NULL\n \t&& ira_loop_tree_root != &ira_loop_nodes[i])\n       return true;\n@@ -206,7 +206,7 @@ finish_loop_tree_nodes (void)\n   unsigned int i;\n   loop_p loop;\n \n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     finish_loop_tree_node (&ira_loop_nodes[i]);\n   ira_free (ira_loop_nodes);\n   for (i = 0; i < (unsigned int) last_basic_block_before_change; i++)\n@@ -309,7 +309,7 @@ form_loop_tree (void)\n   /* We can not use loop/bb node access macros because of potential\n      checking and because the nodes are not initialized enough\n      yet.  */\n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n      if (ira_loop_nodes[i].regno_allocno_map != NULL)\n        {\n \t ira_loop_nodes[i].children = NULL;\n@@ -355,7 +355,7 @@ rebuild_regno_allocno_maps (void)\n   ira_allocno_iterator ai;\n \n   max_regno = max_reg_num ();\n-  for (l = 0; VEC_iterate (loop_p, ira_loops.larray, l, loop); l++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, l, loop)\n     if (ira_loop_nodes[l].regno_allocno_map != NULL)\n       {\n \tira_free (ira_loop_nodes[l].regno_allocno_map);\n@@ -1615,7 +1615,7 @@ create_loop_tree_node_allocnos (ira_loop_tree_node_t loop_node)\n \t  create_loop_allocnos (e);\n \n       edges = get_loop_exit_edges (loop_node->loop);\n-      for (i = 0; VEC_iterate (edge, edges, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, edges, i, e)\n \tcreate_loop_allocnos (e);\n       VEC_free (edge, heap, edges);\n     }\n@@ -1875,7 +1875,7 @@ mark_all_loops_for_removal (void)\n   int i;\n   loop_p loop;\n \n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     if (ira_loop_nodes[i].regno_allocno_map != NULL)\n       {\n \tif (ira_loop_nodes[i].parent == NULL)"}, {"sha": "8360735f92d92cb715f76f2b6059cce9bda1f724", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1113,7 +1113,7 @@ ira_loop_edge_freq (ira_loop_tree_node_t loop_node, int regno, bool exit_p)\n   else\n     {\n       edges = get_loop_exit_edges (loop_node->loop);\n-      for (i = 0; VEC_iterate (edge, edges, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, edges, i, e)\n \tif (regno < 0\n \t    || (bitmap_bit_p (DF_LR_OUT (e->src), regno)\n \t\t&& bitmap_bit_p (DF_LR_IN (e->dest), regno)))"}, {"sha": "7221e444b0d1ac1b239f91a38749a4c8af8c4375", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -323,7 +323,7 @@ setup_entered_from_non_parent_p (void)\n   unsigned int i;\n   loop_p loop;\n \n-  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+  FOR_EACH_VEC_ELT (loop_p, ira_loops.larray, i, loop)\n     if (ira_loop_nodes[i].regno_allocno_map != NULL)\n       ira_loop_nodes[i].entered_from_non_parent_p\n \t= entered_from_non_parent_p (&ira_loop_nodes[i]);"}, {"sha": "d45aa33c7b31465c1338aea8a63d61e5e19641f0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,10 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* class.c: Use FOR_EACH_VEC_ELT.\n+\t* expr.c: Likewise.\n+\t* jcf-parse.c: Likewise.\n+\t* resource.c: Likewise.\n+\n 2010-08-16  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lang.opt (MD_, MMD_, version): Mark RejectDriver."}, {"sha": "ece261b8dd310e1a96cbbfcdc73a8e7a06379201", "filename": "gcc/java/class.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1544,9 +1544,7 @@ make_method_value (tree mdecl)\n \te = VEC_index (constructor_elt, v, idx--);\n \te->value = null_pointer_node;\n \n-\tfor (ix = 0;\n-\t     VEC_iterate (tree, DECL_FUNCTION_THROWS (mdecl), ix, t);\n-\t     ix++)\n+\tFOR_EACH_VEC_ELT (tree, DECL_FUNCTION_THROWS (mdecl), ix, t)\n \t  {\n \t    tree sig = DECL_NAME (TYPE_NAME (t));\n \t    tree utf8\n@@ -2762,7 +2760,7 @@ emit_indirect_register_classes (tree *list_p)\n \t\t\t   VAR_DECL, get_identifier (\"_Jv_CLS\"),\n \t\t\t   class_array_type);\n   tree reg_class_list;\n-  for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n+  FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n     {\n       t = fold_convert (ptr_type_node, build_static_class_ref (klass));\n       CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, t);\n@@ -2834,7 +2832,7 @@ emit_register_classes (tree *list_p)\n #endif\n       assemble_align (POINTER_SIZE);\n \n-      for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n+      FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n \t{\n \t  t = build_fold_addr_expr (klass);\n \t  output_constant (t, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE);\n@@ -2852,7 +2850,7 @@ emit_register_classes (tree *list_p)\n       DECL_EXTERNAL (t) = 1;\n       register_class_fn = t;\n \n-      for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n+      FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n \t{\n \t  t = build_fold_addr_expr (klass);\n \t  t = build_call_expr (register_class_fn, 1, t);\n@@ -2928,7 +2926,7 @@ emit_symbol_table (tree name, tree the_table,\n     return the_table;\n \n   /* Build a list of _Jv_MethodSymbols for each entry in otable_methods. */\n-  for (index = 0; VEC_iterate (method_entry, decl_table, index, e); index++)\n+  FOR_EACH_VEC_ELT (method_entry, decl_table, index, e)\n     CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t    build_symbol_entry (e->method, e->special));\n "}, {"sha": "9f9667fa88ae55155e37246fefd51a92409fc1bd", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2296,7 +2296,7 @@ get_symbol_table_index (tree t, tree special,\n   method_entry *e;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (method_entry, *symbol_table, i, e); i++)\n+  FOR_EACH_VEC_ELT (method_entry, *symbol_table, i, e)\n     if (t == e->method && special == e->special)\n       goto done;\n "}, {"sha": "cb486ae111ebc154365829964ef75e2ac20051fd", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1683,7 +1683,7 @@ predefined_filename_p (tree node)\n   unsigned ix;\n   tree f;\n \n-  for (ix = 0; VEC_iterate (tree, predefined_filenames, ix, f); ix++)\n+  FOR_EACH_VEC_ELT (tree, predefined_filenames, ix, f)\n     if (f == node)\n       return 1;\n \n@@ -1869,7 +1869,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n     }\n \n   current_jcf = main_jcf;\n-  for (ix = 0; VEC_iterate (tree, current_file_list, ix, node); ix++)\n+  FOR_EACH_VEC_ELT (tree, current_file_list, ix, node)\n     {\n       unsigned char magic_string[4];\n       char *real_path;\n@@ -1956,7 +1956,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t}\n     }\n \n-  for (ix = 0; VEC_iterate (tree, current_file_list, ix, node); ix++)\n+  FOR_EACH_VEC_ELT (tree, current_file_list, ix, node)\n     {\n       input_location = DECL_SOURCE_LOCATION (node);\n       if (CLASS_FILE_P (node))"}, {"sha": "f954024fde199dab53db7797345556db5a72a14b", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -107,7 +107,7 @@ write_resource_constructor (tree *list_p)\n   register_resource_fn = t;\n \n   /* Write out entries in the same order in which they were defined.  */\n-  for (ix = 0; VEC_iterate (tree, resources, ix, decl); ix++)\n+  FOR_EACH_VEC_ELT (tree, resources, ix, decl)\n     {\n       t = build_fold_addr_expr (decl);\n       t = build_call_expr (register_resource_fn, 1, t);"}, {"sha": "6236235f0d0243b2c982e545e8c47f7f800f9a4a", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1167,7 +1167,7 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n       {\n \ttree iv, invar;\n \tsize_t i;\n-\tfor (i = 0; VEC_iterate (tree, outerinductionvars, i, iv); i++)\n+\tFOR_EACH_VEC_ELT (tree, outerinductionvars, i, iv)\n \t  if (iv != NULL)\n \t    {\n \t      if (SSA_NAME_VAR (iv) == SSA_NAME_VAR (expr))\n@@ -1181,7 +1181,7 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n \t\t  LLE_DENOMINATOR (lle) = 1;\n \t\t}\n \t    }\n-\tfor (i = 0; VEC_iterate (tree, invariants, i, invar); i++)\n+\tFOR_EACH_VEC_ELT (tree, invariants, i, invar)\n \t  if (invar != NULL)\n \t    {\n \t      if (SSA_NAME_VAR (invar) == SSA_NAME_VAR (expr))\n@@ -1542,7 +1542,7 @@ gcc_loopnest_to_lambda_loopnest (struct loop *loop_nest,\n \n   ret = lambda_loopnest_new (depth, 2 * depth, lambda_obstack);\n \n-  for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n+  FOR_EACH_VEC_ELT (lambda_loop, loops, i, newloop)\n     LN_LOOPS (ret)[i] = newloop;\n \n  fail:\n@@ -1837,7 +1837,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n   /* Rewrite uses of the old ivs so that they are now specified in terms of\n      the new ivs.  */\n \n-  for (i = 0; VEC_iterate (tree, old_ivs, i, oldiv); i++)\n+  FOR_EACH_VEC_ELT (tree, old_ivs, i, oldiv)\n     {\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n@@ -2641,7 +2641,7 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   distres = lambda_vector_new (nb_loops);\n \n   /* For each distance vector in the dependence graph.  */\n-  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n     {\n       /* Don't care about relations for which we know that there is no\n \t dependence, nor about read-read (aka. output-dependences):\n@@ -2710,7 +2710,7 @@ lambda_collect_parameters (VEC (data_reference_p, heap) *datarefs,\n   struct pointer_set_t *parameter_set = pointer_set_create ();\n   data_reference_p data_reference;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, data_reference); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, data_reference)\n     for (j = 0; j < DR_NUM_DIMENSIONS (data_reference); j++)\n       lambda_collect_parameters_from_af (DR_ACCESS_FN (data_reference, j),\n \t\t\t\t\t parameter_set, parameters);\n@@ -2862,7 +2862,7 @@ lambda_compute_access_matrices (VEC (data_reference_p, heap) *datarefs,\n   data_reference_p dataref;\n   unsigned ix;\n \n-  for (ix = 0; VEC_iterate (data_reference_p, datarefs, ix, dataref); ix++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, ix, dataref)\n     if (!build_access_matrix (dataref, parameters, nest, lambda_obstack))\n       return false;\n "}, {"sha": "77fd4aef6f1e2efec32affe43cb68594dd73f59d", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -536,7 +536,7 @@ merge_identical_invariants (void)\n   htab_t eq = htab_create (VEC_length (invariant_p, invariants),\n \t\t\t   hash_invariant_expr, eq_invariant_expr, free);\n \n-  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+  FOR_EACH_VEC_ELT (invariant_p, invariants, i, inv)\n     find_identical_invariants (eq, inv);\n \n   htab_delete (eq);\n@@ -1254,7 +1254,7 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n   int i, gain = 0, again;\n   unsigned aregs_needed[N_REG_CLASSES], invno;\n \n-  for (invno = 0; VEC_iterate (invariant_p, invariants, invno, inv); invno++)\n+  FOR_EACH_VEC_ELT (invariant_p, invariants, invno, inv)\n     {\n       if (inv->move)\n \tcontinue;\n@@ -1508,11 +1508,11 @@ move_invariants (struct loop *loop)\n   struct invariant *inv;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+  FOR_EACH_VEC_ELT (invariant_p, invariants, i, inv)\n     move_invariant_reg (loop, i);\n   if (flag_ira_loop_pressure && resize_reg_info ())\n     {\n-      for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+      FOR_EACH_VEC_ELT (invariant_p, invariants, i, inv)\n \tif (inv->reg != NULL_RTX)\n \t  {\n \t    if (inv->orig_regno >= 0)\n@@ -1561,7 +1561,7 @@ free_inv_motion_data (void)\n \t}\n     }\n \n-  for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+  FOR_EACH_VEC_ELT (invariant_p, invariants, i, inv)\n     {\n       BITMAP_FREE (inv->depends_on);\n       free (inv);"}, {"sha": "47bfa05e1fa1080e7e97f8c3bc0c61101b3d0a0a", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -501,7 +501,7 @@ peel_loop_completely (struct loop *loop)\n  \t}\n \n       /* Remove the exit edges.  */\n-      for (i = 0; VEC_iterate (edge, remove_edges, i, ein); i++)\n+      FOR_EACH_VEC_ELT (edge, remove_edges, i, ein)\n \tremove_path (ein);\n       VEC_free (edge, heap, remove_edges);\n     }\n@@ -789,7 +789,7 @@ unroll_loop_constant_iterations (struct loop *loop)\n   desc->niter_expr = GEN_INT (desc->niter);\n \n   /* Remove the edges.  */\n-  for (i = 0; VEC_iterate (edge, remove_edges, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, remove_edges, i, e)\n     remove_path (e);\n   VEC_free (edge, heap, remove_edges);\n \n@@ -992,7 +992,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n       basic_block bb;\n \n       ldom = get_dominated_by (CDI_DOMINATORS, body[i]);\n-      for (j = 0; VEC_iterate (basic_block, ldom, j, bb); j++)\n+      FOR_EACH_VEC_ELT (basic_block, ldom, j, bb)\n \tif (!flow_bb_inside_loop_p (loop, bb))\n \t  VEC_safe_push (basic_block, heap, dom_bbs, bb);\n \n@@ -1161,7 +1161,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n     }\n \n   /* Remove the edges.  */\n-  for (i = 0; VEC_iterate (edge, remove_edges, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, remove_edges, i, e)\n     remove_path (e);\n   VEC_free (edge, heap, remove_edges);\n \n@@ -2124,7 +2124,7 @@ insert_var_expansion_initialization (struct var_to_expand *ve,\n \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS)\n-    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n+    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n       {\n \tif (honor_signed_zero_p)\n \t  zero_init = simplify_gen_unary (NEG, mode, CONST0_RTX (mode), mode);\n@@ -2134,7 +2134,7 @@ insert_var_expansion_initialization (struct var_to_expand *ve,\n         emit_move_insn (var, zero_init);\n       }\n   else if (ve->op == MULT)\n-    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n+    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n       {\n         zero_init =  CONST1_RTX (GET_MODE (var));\n         emit_move_insn (var, zero_init);\n@@ -2166,13 +2166,13 @@ combine_var_copies_in_loop_exit (struct var_to_expand *ve, basic_block place)\n \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS)\n-    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n+    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n       {\n         sum = simplify_gen_binary (PLUS, GET_MODE (ve->reg),\n                                    var, sum);\n       }\n   else if (ve->op == MULT)\n-    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n+    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n       {\n         sum = simplify_gen_binary (MULT, GET_MODE (ve->reg),\n                                    var, sum);"}, {"sha": "0569c05a06041037ba6a6944f6d1c9d29e4793c3", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1312,7 +1312,7 @@ decompose_multiword_subregs (void)\n     unsigned int i;\n     bitmap b;\n \n-    for (i = 0; VEC_iterate (bitmap, reg_copy_graph, i, b); ++i)\n+    FOR_EACH_VEC_ELT (bitmap, reg_copy_graph, i, b)\n       if (b)\n \tBITMAP_FREE (b);\n   }"}, {"sha": "9bd0f70d0e7be2098ec590717ddb20ce79afccac", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1268,7 +1268,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n       len = lto_input_uleb128 (ib);\n     }\n \n-  for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n+  FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n     {\n       int ref = (int) (intptr_t) node->global.inlined_to;\n \n@@ -1307,7 +1307,7 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n \t\t     input_varpool_node (file_data, ib));\n       len--;\n     }\n-  for (i = 0; VEC_iterate (varpool_node_ptr, varpool, i, node); i++)\n+  FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n     {\n       int ref = (int) (intptr_t) node->same_comdat_group;\n \n@@ -1481,7 +1481,7 @@ output_node_opt_summary (struct output_block *ob,\n     lto_output_uleb128_stream (ob->main_stream, index);\n   lto_output_uleb128_stream (ob->main_stream,\n \t\t             VEC_length (ipa_replace_map_p, node->clone.tree_map));\n-  for (i = 0; VEC_iterate (ipa_replace_map_p, node->clone.tree_map, i, map); i++)\n+  FOR_EACH_VEC_ELT (ipa_replace_map_p, node->clone.tree_map, i, map)\n     {\n       int parm_num;\n       tree parm;"}, {"sha": "3666b17fc94024b15473da69482821050991d2bb", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -128,7 +128,7 @@ clear_options (VEC(opt_t, heap) **opts_p)\n   int i;\n   opt_t *o;\n \n-  for (i = 0; VEC_iterate (opt_t, *opts_p, i, o); i++)\n+  FOR_EACH_VEC_ELT (opt_t, *opts_p, i, o)\n     free (o->arg);\n \n   VEC_free (opt_t, heap, *opts_p);\n@@ -278,7 +278,7 @@ output_options (struct lto_output_stream *stream)\n \n   output_data_stream (stream, &length, sizeof (length));\n \n-  for (i = 0; VEC_iterate (opt_t, opts, i, o); i++)\n+  FOR_EACH_VEC_ELT (opt_t, opts, i, o)\n     {\n       output_data_stream (stream, &o->type, sizeof (o->type));\n       output_data_stream (stream, &o->code, sizeof (o->code));\n@@ -397,7 +397,7 @@ lto_reissue_options (void)\n   int i;\n   opt_t *o;\n \n-  for (i = 0; VEC_iterate (opt_t, opts, i, o); i++)\n+  FOR_EACH_VEC_ELT (opt_t, opts, i, o)\n     {\n       const struct cl_option *option = &cl_options[o->code];\n "}, {"sha": "9ee15108fae477033a5170a9012b3c1184c5d103", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -539,7 +539,7 @@ fixup_eh_region_pointers (struct function *fn, HOST_WIDE_INT root_region)\n \n   /* Convert all the index numbers stored in pointer fields into\n      pointers to the corresponding slots in the EH region array.  */\n-  for (i = 0; VEC_iterate (eh_region, eh_array, i, r); i++)\n+  FOR_EACH_VEC_ELT (eh_region, eh_array, i, r)\n     {\n       /* The array may contain NULL regions.  */\n       if (r == NULL)\n@@ -554,7 +554,7 @@ fixup_eh_region_pointers (struct function *fn, HOST_WIDE_INT root_region)\n \n   /* Convert all the index numbers stored in pointer fields into\n      pointers to the corresponding slots in the EH landing pad array.  */\n-  for (i = 0; VEC_iterate (eh_landing_pad, lp_array, i, lp); i++)\n+  FOR_EACH_VEC_ELT (eh_landing_pad, lp_array, i, lp)\n     {\n       /* The array may contain NULL landing pads.  */\n       if (lp == NULL)"}, {"sha": "e00fd865e507acdcfd2cde386f00ee2bb3851bd3", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1042,7 +1042,7 @@ lto_output_ts_block_tree_pointers (struct output_block *ob, tree expr,\n   lto_output_chain (ob, BLOCK_VARS (expr), ref_p);\n \n   output_uleb128 (ob, VEC_length (tree, BLOCK_NONLOCALIZED_VARS (expr)));\n-  for (i = 0; VEC_iterate (tree, BLOCK_NONLOCALIZED_VARS (expr), i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, BLOCK_NONLOCALIZED_VARS (expr), i, t)\n     lto_output_tree_or_ref (ob, t, ref_p);\n \n   lto_output_tree_or_ref (ob, BLOCK_SUPERCONTEXT (expr), ref_p);\n@@ -1067,7 +1067,7 @@ lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n   /* Note that the number of BINFO slots has already been emitted in\n      EXPR's header (see lto_output_tree_header) because this length\n      is needed to build the empty BINFO node on the reader side.  */\n-  for (i = 0; VEC_iterate (tree, BINFO_BASE_BINFOS (expr), i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (expr), i, t)\n     lto_output_tree_or_ref (ob, t, ref_p);\n   output_zero (ob);\n \n@@ -1077,7 +1077,7 @@ lto_output_ts_binfo_tree_pointers (struct output_block *ob, tree expr,\n   lto_output_tree_or_ref (ob, BINFO_VPTR_FIELD (expr), ref_p);\n \n   output_uleb128 (ob, VEC_length (tree, BINFO_BASE_ACCESSES (expr)));\n-  for (i = 0; VEC_iterate (tree, BINFO_BASE_ACCESSES (expr), i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, BINFO_BASE_ACCESSES (expr), i, t)\n     lto_output_tree_or_ref (ob, t, ref_p);\n \n   lto_output_tree_or_ref (ob, BINFO_INHERITANCE_CHAIN (expr), ref_p);\n@@ -1508,34 +1508,32 @@ output_eh_regions (struct output_block *ob, struct function *fn)\n \n       /* Emit all the EH regions in the region array.  */\n       output_sleb128 (ob, VEC_length (eh_region, fn->eh->region_array));\n-      for (i = 0; VEC_iterate (eh_region, fn->eh->region_array, i, eh); i++)\n+      FOR_EACH_VEC_ELT (eh_region, fn->eh->region_array, i, eh)\n \toutput_eh_region (ob, eh);\n \n       /* Emit all landing pads.  */\n       output_sleb128 (ob, VEC_length (eh_landing_pad, fn->eh->lp_array));\n-      for (i = 0; VEC_iterate (eh_landing_pad, fn->eh->lp_array, i, lp); i++)\n+      FOR_EACH_VEC_ELT (eh_landing_pad, fn->eh->lp_array, i, lp)\n \toutput_eh_lp (ob, lp);\n \n       /* Emit all the runtime type data.  */\n       output_sleb128 (ob, VEC_length (tree, fn->eh->ttype_data));\n-      for (i = 0; VEC_iterate (tree, fn->eh->ttype_data, i, ttype); i++)\n+      FOR_EACH_VEC_ELT (tree, fn->eh->ttype_data, i, ttype)\n \tlto_output_tree_ref (ob, ttype);\n \n       /* Emit the table of action chains.  */\n       if (targetm.arm_eabi_unwinder)\n \t{\n \t  tree t;\n \t  output_sleb128 (ob, VEC_length (tree, fn->eh->ehspec_data.arm_eabi));\n-\t  for (i = 0;\n-\t       VEC_iterate (tree, fn->eh->ehspec_data.arm_eabi, i, t);\n-\t       i++)\n+\t  FOR_EACH_VEC_ELT (tree, fn->eh->ehspec_data.arm_eabi, i, t)\n \t    lto_output_tree_ref (ob, t);\n \t}\n       else\n \t{\n \t  uchar c;\n \t  output_sleb128 (ob, VEC_length (uchar, fn->eh->ehspec_data.other));\n-\t  for (i = 0; VEC_iterate (uchar, fn->eh->ehspec_data.other, i, c); i++)\n+\t  FOR_EACH_VEC_ELT (uchar, fn->eh->ehspec_data.other, i, c)\n \t    lto_output_1_stream (ob->main_stream, c);\n \t}\n     }\n@@ -1908,7 +1906,7 @@ output_function (struct cgraph_node *node)\n \n   /* Output all the local variables in the function.  */\n   output_sleb128 (ob, VEC_length (tree, fn->local_decls));\n-  for (i = 0; VEC_iterate (tree, fn->local_decls, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, fn->local_decls, i, t)\n     lto_output_tree_ref (ob, t);\n \n   /* Output the head of the arguments list.  */\n@@ -2013,7 +2011,7 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   output_zero (ob);\n \n   /* Emit the alias pairs for the nodes in SET.  */\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     {\n       if (output_alias_pair_p (p, set, vset))\n \t{\n@@ -2446,7 +2444,7 @@ produce_symtab (struct output_block *ob,\n     }\n \n   /* Write all aliases.  */\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     if (output_alias_pair_p (p, set, vset))\n       write_symbol (cache, &stream, p->decl, seen, true);\n "}, {"sha": "2b3d1724fe7487aa4db3b2ef08487056eb3861ce", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -643,7 +643,7 @@ lto_streamer_cache_create (void)\n      unnecessarily.  */\n   common_nodes = lto_get_common_nodes ();\n \n-  for (i = 0; VEC_iterate (tree, common_nodes, i, node); i++)\n+  FOR_EACH_VEC_ELT (tree, common_nodes, i, node)\n     preload_common_node (cache, node);\n \n   VEC_free(tree, heap, common_nodes);"}, {"sha": "bdfbd7d67a2ba447ef4480f2fbcf3bc8a57541de", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -601,7 +601,7 @@ lto_symtab_merge_decls_2 (void **slot)\n     return;\n \n   /* Diagnose all mismatched re-declarations.  */\n-  for (i = 0; VEC_iterate (tree, mismatches, i, decl); ++i)\n+  FOR_EACH_VEC_ELT (tree, mismatches, i, decl)\n     {\n       if (!gimple_types_compatible_p (TREE_TYPE (prevailing->decl),\n \t\t\t\t      TREE_TYPE (decl), GTC_DIAG))"}, {"sha": "d2bb78e0799911e44dd592430e58d940d16db405", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1,3 +1,7 @@\n+2010-08-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* lto.c: Use FOR_EACH_VEC_ELT.\n+\n 2010-07-27  Andi Kleen <ak@linux.intel.com>\n \n \t* Make-lang.in (lto.o): Add dependency to splay-tree.h"}, {"sha": "84a6e28e1a1b6fc74f9ede09c309f1a550962a32", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1063,7 +1063,7 @@ lto_wpa_write_files (void)\n      compiled by LTRANS.  After this loop, only those sets that\n      contain callgraph nodes from more than one file will need to be\n      compiled by LTRANS.  */\n-  for (i = 0; VEC_iterate (ltrans_partition, ltrans_partitions, i, part); i++)\n+  FOR_EACH_VEC_ELT (ltrans_partition, ltrans_partitions, i, part)\n     lto_stats.num_output_cgraph_nodes += VEC_length (cgraph_node_ptr,\n \t\t\t\t\t\t     part->cgraph_set->nodes);\n \n@@ -1592,7 +1592,7 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n       htab_traverse (file->function_decl_states, lto_fixup_state_aux, &data);\n     }\n \n-  for (i = 0; VEC_iterate (tree, lto_global_var_decls, i, decl); i++)\n+  FOR_EACH_VEC_ELT (tree, lto_global_var_decls, i, decl)\n     {\n       tree saved_decl = decl;\n       walk_tree (&decl, lto_fixup_tree, &data, NULL);\n@@ -1892,7 +1892,7 @@ materialize_cgraph (void)\n   set_cfun (NULL);\n \n   /* Inform the middle end about the global variables we have seen.  */\n-  for (i = 0; VEC_iterate (tree, lto_global_var_decls, i, decl); i++)\n+  FOR_EACH_VEC_ELT (tree, lto_global_var_decls, i, decl)\n     rest_of_decl_compilation (decl, 1, 0);\n \n   if (!quiet_flag)"}, {"sha": "3789af0a0d91a8669170b8d1acf42672c3e8dd55", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -890,9 +890,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n     {\n       if (mi->access_l)\n \t{\n-\t  for (i = 0;\n-\t       VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n-\t       i++)\n+\t  FOR_EACH_VEC_ELT (access_site_info_p, mi->access_l, i, acc_info)\n \t    free (acc_info);\n \t  VEC_free (access_site_info_p, heap, mi->access_l);\n "}, {"sha": "d1f956889a92c4bfbadea1dfa3ba774e23b893f1", "filename": "gcc/opts.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -592,14 +592,10 @@ flag_instrument_functions_exclude_p (tree fndecl)\n       char *s;\n \n       name = lang_hooks.decl_printable_name (fndecl, 0);\n-      for (i = 0;\n-\t   VEC_iterate (char_p, flag_instrument_functions_exclude_functions,\n-\t\t\ti, s);\n-\t   ++i)\n-\t{\n-\t  if (strstr (name, s) != NULL)\n-\t    return true;\n-\t}\n+      FOR_EACH_VEC_ELT (char_p, flag_instrument_functions_exclude_functions,\n+\t\t\ti, s)\n+\tif (strstr (name, s) != NULL)\n+\t  return true;\n     }\n \n   if (VEC_length (char_p, flag_instrument_functions_exclude_files) > 0)\n@@ -609,13 +605,9 @@ flag_instrument_functions_exclude_p (tree fndecl)\n       char *s;\n \n       name = DECL_SOURCE_FILE (fndecl);\n-      for (i = 0;\n-\t   VEC_iterate (char_p, flag_instrument_functions_exclude_files, i, s);\n-\t   ++i)\n-\t{\n-\t  if (strstr (name, s) != NULL)\n-\t    return true;\n-\t}\n+      FOR_EACH_VEC_ELT (char_p, flag_instrument_functions_exclude_files, i, s)\n+\tif (strstr (name, s) != NULL)\n+\t  return true;\n     }\n \n   return false;"}, {"sha": "1b61ee47322dd4432d5bf19ec2bca46dd1f5011f", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -942,7 +942,7 @@ predict_loops (void)\n       exits = get_loop_exit_edges (loop);\n       n_exits = VEC_length (edge, exits);\n \n-      for (j = 0; VEC_iterate (edge, exits, j, ex); j++)\n+      FOR_EACH_VEC_ELT (edge, exits, j, ex)\n \t{\n \t  tree niter = NULL;\n \t  HOST_WIDE_INT nitercst;"}, {"sha": "5ca762eecf203c7080306265eaf7fa67cac9a6cd", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1009,7 +1009,7 @@ print_vec_tree (FILE *file, const char *prefix, VEC(tree,gc) *vec, int indent)\n   fprintf (file, \"%s <VEC\", prefix);\n   dump_addr (file, \" \", vec);\n \n-  for (ix = 0; VEC_iterate (tree, vec, ix, elt); ++ix)\n+  FOR_EACH_VEC_ELT (tree, vec, ix, elt)\n     {\n       char temp[10];\n       sprintf (temp, \"elt %d\", ix);"}, {"sha": "5d2896c40624b5d1d1f275105c51367b565fc92c", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1484,7 +1484,7 @@ sdbout_finish (const char *main_filename ATTRIBUTE_UNUSED)\n   size_t i;\n   tree decl;\n \n-  for (i = 0; VEC_iterate (tree, deferred_global_decls, i, decl); i++)\n+  FOR_EACH_VEC_ELT (tree, deferred_global_decls, i, decl)\n     sdbout_symbol (decl, 0);\n }\n "}, {"sha": "af76b5b6c547f0f6558269a1edee3926aa1ddca4", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -467,7 +467,7 @@ dump_insn_vector (rtx_vec_t succs)\n   int i;\n   rtx succ;\n \n-  for (i = 0; VEC_iterate (rtx, succs, i, succ); i++)\n+  FOR_EACH_VEC_ELT (rtx, succs, i, succ)\n     if (succ)\n       dump_insn (succ);\n     else"}, {"sha": "f23b7cf8d983f61bce76b35d74e8b9aeaf6e3ed4", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -5822,7 +5822,7 @@ make_region_from_loop_preheader (VEC(basic_block, heap) **loop_blocks)\n \n   new_rgn_number = sel_create_new_region ();\n \n-  for (i = 0; VEC_iterate (basic_block, *loop_blocks, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, *loop_blocks, i, bb)\n     {\n       gcc_assert (new_rgn_number >= 0);\n \n@@ -6167,7 +6167,7 @@ sel_remove_loop_preheader (void)\n         {\n           /* If all preheader blocks are empty - dont create new empty region.\n              Instead, remove them completely.  */\n-          for (i = 0; VEC_iterate (basic_block, preheader_blocks, i, bb); i++)\n+          FOR_EACH_VEC_ELT (basic_block, preheader_blocks, i, bb)\n             {\n               edge e;\n               edge_iterator ei;"}, {"sha": "0f02c0c9618493f7697c06373ef1dc400119b1aa", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2736,7 +2736,7 @@ compute_av_set_at_bb_end (insn_t insn, ilist_t p, int ws)\n   /* Add insn to to the tail of current path.  */\n   ilist_add (&p, insn);\n \n-  for (is = 0; VEC_iterate (rtx, sinfo->succs_ok, is, succ); is++)\n+  FOR_EACH_VEC_ELT (rtx, sinfo->succs_ok, is, succ)\n     {\n       av_set_t succ_set;\n \n@@ -2790,7 +2790,7 @@ compute_av_set_at_bb_end (insn_t insn, ilist_t p, int ws)\n   /* Check liveness restrictions via hard way when there are more than\n      two successors.  */\n   if (sinfo->succs_ok_n > 2)\n-    for (is = 0; VEC_iterate (rtx, sinfo->succs_ok, is, succ); is++)\n+    FOR_EACH_VEC_ELT (rtx, sinfo->succs_ok, is, succ)\n       {\n         basic_block succ_bb = BLOCK_FOR_INSN (succ);\n \n@@ -2801,7 +2801,7 @@ compute_av_set_at_bb_end (insn_t insn, ilist_t p, int ws)\n \n   /* Finally, check liveness restrictions on paths leaving the region.  */\n   if (sinfo->all_succs_n > sinfo->succs_ok_n)\n-    for (is = 0; VEC_iterate (rtx, sinfo->succs_other, is, succ); is++)\n+    FOR_EACH_VEC_ELT (rtx, sinfo->succs_other, is, succ)\n       mark_unavailable_targets\n         (av1, NULL, BB_LV_SET (BLOCK_FOR_INSN (succ)));\n \n@@ -3572,7 +3572,7 @@ vinsn_vec_has_expr_p (vinsn_vec_t vinsn_vec, expr_t expr)\n   vinsn_t vinsn;\n   int n;\n \n-  for (n = 0; VEC_iterate (vinsn_t, vinsn_vec, n, vinsn); n++)\n+  FOR_EACH_VEC_ELT (vinsn_t, vinsn_vec, n, vinsn)\n     if (VINSN_SEPARABLE_P (vinsn))\n       {\n         if (vinsn_equal_p (vinsn, EXPR_VINSN (expr)))\n@@ -3646,7 +3646,7 @@ vinsn_vec_clear (vinsn_vec_t *vinsn_vec)\n       vinsn_t vinsn;\n       int n;\n \n-      for (n = 0; VEC_iterate (vinsn_t, *vinsn_vec, n, vinsn); n++)\n+      FOR_EACH_VEC_ELT (vinsn_t, *vinsn_vec, n, vinsn)\n         vinsn_detach (vinsn);\n       VEC_block_remove (vinsn_t, *vinsn_vec, 0, len);\n     }\n@@ -3942,7 +3942,7 @@ fill_vec_av_set (av_set_t av, blist_t bnds, fence_t fence,\n       sel_print (\"Total ready exprs: %d, stalled: %d\\n\",\n                  VEC_length (expr_t, vec_av_set), stalled);\n       sel_print (\"Sorted av set (%d): \", VEC_length (expr_t, vec_av_set));\n-      for (n = 0; VEC_iterate (expr_t, vec_av_set, n, expr); n++)\n+      FOR_EACH_VEC_ELT (expr_t, vec_av_set, n, expr)\n         dump_expr (expr);\n       sel_print (\"\\n\");\n     }\n@@ -3971,7 +3971,7 @@ convert_vec_av_set_to_ready (void)\n       sched_extend_ready_list (ready.n_ready);\n     }\n \n-  for (n = 0; VEC_iterate (expr_t, vec_av_set, n, expr); n++)\n+  FOR_EACH_VEC_ELT (expr_t, vec_av_set, n, expr)\n     {\n       vinsn_t vi = EXPR_VINSN (expr);\n       insn_t insn = VINSN_INSN_RTX (vi);\n@@ -4951,7 +4951,7 @@ remove_temp_moveop_nops (bool full_tidying)\n   int i;\n   insn_t insn;\n \n-  for (i = 0; VEC_iterate (insn_t, vec_temp_moveop_nops, i, insn); i++)\n+  FOR_EACH_VEC_ELT (insn_t, vec_temp_moveop_nops, i, insn)\n     {\n       gcc_assert (INSN_NOP_P (insn));\n       return_nop_to_pool (insn, full_tidying);"}, {"sha": "ffcb51c1737e98f6ba694afd20a30a8b564030d3", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -181,7 +181,7 @@ build_sese_loop_nests (sese region)\n   /* Make sure that the loops in the SESE_LOOP_NEST are ordered.  It\n      can be the case that an inner loop is inserted before an outer\n      loop.  To avoid this, semi-sort once.  */\n-  for (i = 0; VEC_iterate (loop_p, SESE_LOOP_NEST (region), i, loop0); i++)\n+  FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), i, loop0)\n     {\n       if (VEC_length (loop_p, SESE_LOOP_NEST (region)) == i + 1)\n \tbreak;"}, {"sha": "09bb594eb2bbe2a49d9369c8d31505006ad5bb58", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -258,7 +258,7 @@ self_referential_size (tree size)\n   /* Build the parameter and argument lists in parallel; also\n      substitute the former for the latter in the expression.  */\n   args = VEC_alloc (tree, gc, VEC_length (tree, self_refs));\n-  for (i = 0; VEC_iterate (tree, self_refs, i, ref); i++)\n+  FOR_EACH_VEC_ELT (tree, self_refs, i, ref)\n     {\n       tree subst, param_name, param_type, param_decl;\n "}, {"sha": "dfe6d8f0920a194e5accc499415c986cc223b27d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -6213,7 +6213,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n     {\n       eh_region region = NULL;\n \n-      for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+      FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n \tregion = find_outermost_region_in_block (saved_cfun, bb, region);\n \n       init_eh_for_function ();\n@@ -6242,7 +6242,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   d.eh_map = eh_map;\n   d.remap_decls_p = true;\n \n-  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n     {\n       /* No need to update edge counts on the last block.  It has\n \t already been updated earlier when we detached the region from\n@@ -6307,7 +6307,7 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n     }\n \n   set_immediate_dominator (CDI_DOMINATORS, bb, dom_entry);\n-  for (i = 0; VEC_iterate (basic_block, dom_bbs, i, abb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, dom_bbs, i, abb)\n     set_immediate_dominator (CDI_DOMINATORS, abb, bb);\n   VEC_free (basic_block, heap, dom_bbs);\n \n@@ -6917,15 +6917,15 @@ remove_edge_and_dominated_blocks (edge e)\n   else\n     {\n       bbs_to_remove = get_all_dominated_blocks (CDI_DOMINATORS, e->dest);\n-      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n+      FOR_EACH_VEC_ELT (basic_block, bbs_to_remove, i, bb)\n \t{\n \t  FOR_EACH_EDGE (f, ei, bb->succs)\n \t    {\n \t      if (f->dest != EXIT_BLOCK_PTR)\n \t\tbitmap_set_bit (df, f->dest->index);\n \t    }\n \t}\n-      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n+      FOR_EACH_VEC_ELT (basic_block, bbs_to_remove, i, bb)\n \tbitmap_clear_bit (df, bb->index);\n \n       EXECUTE_IF_SET_IN_BITMAP (df, 0, i, bi)"}, {"sha": "3c1ca2d2195e92813ad24f6b6d89d58d406f967b", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -901,7 +901,7 @@ remove_forwarder_block_with_phi (basic_block bb)\n \t\t redirection, replace it with the PHI argument that used\n \t\t to be on E.  */\n \t      head = redirect_edge_var_map_vector (e);\n-\t      for (i = 0; VEC_iterate (edge_var_map, head, i, vm); ++i)\n+\t      FOR_EACH_VEC_ELT (edge_var_map, head, i, vm)\n \t\t{\n \t\t  tree old_arg = redirect_edge_var_map_result (vm);\n \t\t  tree new_arg = redirect_edge_var_map_def (vm);"}, {"sha": "72955108c7bdd01e63a956c275a028d82da63e6d", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -659,7 +659,7 @@ chrec_apply_map (tree chrec, VEC (tree, heap) *iv_map)\n   int i;\n   tree expr;\n \n-  for (i = 0; VEC_iterate (tree, iv_map, i, expr); i++)\n+  FOR_EACH_VEC_ELT (tree, iv_map, i, expr)\n     if (expr)\n       chrec = chrec_apply (i, chrec, expr);\n "}, {"sha": "025368d54cda94e64ae3134696dd2ff9ecab535a", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -152,7 +152,7 @@ dump_data_references (FILE *file, VEC (data_reference_p, heap) *datarefs)\n   unsigned int i;\n   struct data_reference *dr;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     dump_data_reference (file, dr);\n }\n \n@@ -181,7 +181,7 @@ dump_data_dependence_relations (FILE *file,\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n \n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n     dump_data_dependence_relation (file, ddr);\n }\n \n@@ -342,7 +342,7 @@ print_dir_vectors (FILE *outf, VEC (lambda_vector, heap) *dir_vects,\n   unsigned j;\n   lambda_vector v;\n \n-  for (j = 0; VEC_iterate (lambda_vector, dir_vects, j, v); j++)\n+  FOR_EACH_VEC_ELT (lambda_vector, dir_vects, j, v)\n     print_direction_vector (outf, v, length);\n }\n \n@@ -355,7 +355,7 @@ print_dist_vectors  (FILE *outf, VEC (lambda_vector, heap) *dist_vects,\n   unsigned j;\n   lambda_vector v;\n \n-  for (j = 0; VEC_iterate (lambda_vector, dist_vects, j, v); j++)\n+  FOR_EACH_VEC_ELT (lambda_vector, dist_vects, j, v)\n     print_lambda_vector (outf, v, length);\n }\n \n@@ -420,7 +420,7 @@ dump_data_dependence_relation (FILE *outf,\n \n       fprintf (outf, \"  inner loop index: %d\\n\", DDR_INNER_LOOP (ddr));\n       fprintf (outf, \"  loop nest: (\");\n-      for (i = 0; VEC_iterate (loop_p, DDR_LOOP_NEST (ddr), i, loopi); i++)\n+      FOR_EACH_VEC_ELT (loop_p, DDR_LOOP_NEST (ddr), i, loopi)\n \tfprintf (outf, \"%d \", loopi->num);\n       fprintf (outf, \")\\n\");\n \n@@ -495,17 +495,17 @@ dump_dist_dir_vectors (FILE *file, VEC (ddr_p, heap) *ddrs)\n   struct data_dependence_relation *ddr;\n   lambda_vector v;\n \n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n     if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE && DDR_AFFINE_P (ddr))\n       {\n-\tfor (j = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), j, v); j++)\n+\tFOR_EACH_VEC_ELT (lambda_vector, DDR_DIST_VECTS (ddr), j, v)\n \t  {\n \t    fprintf (file, \"DISTANCE_V (\");\n \t    print_lambda_vector (file, v, DDR_NB_LOOPS (ddr));\n \t    fprintf (file, \")\\n\");\n \t  }\n \n-\tfor (j = 0; VEC_iterate (lambda_vector, DDR_DIR_VECTS (ddr), j, v); j++)\n+\tFOR_EACH_VEC_ELT (lambda_vector, DDR_DIR_VECTS (ddr), j, v)\n \t  {\n \t    fprintf (file, \"DIRECTION_V (\");\n \t    print_direction_vector (file, v, DDR_NB_LOOPS (ddr));\n@@ -524,7 +524,7 @@ dump_ddrs (FILE *file, VEC (ddr_p, heap) *ddrs)\n   unsigned int i;\n   struct data_dependence_relation *ddr;\n \n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n     dump_data_dependence_relation (file, ddr);\n \n   fprintf (file, \"\\n\\n\");\n@@ -923,7 +923,7 @@ dr_address_invariant_p (struct data_reference *dr)\n   unsigned i;\n   tree idx;\n \n-  for (i = 0; VEC_iterate (tree, DR_ACCESS_FNS (dr), i, idx); i++)\n+  FOR_EACH_VEC_ELT (tree, DR_ACCESS_FNS (dr), i, idx)\n     if (tree_contains_chrecs (idx, NULL))\n       return false;\n \n@@ -1506,7 +1506,7 @@ free_subscripts (VEC (subscript_p, heap) *subscripts)\n   unsigned i;\n   subscript_p s;\n \n-  for (i = 0; VEC_iterate (subscript_p, subscripts, i, s); i++)\n+  FOR_EACH_VEC_ELT (subscript_p, subscripts, i, s)\n     {\n       free_conflict_function (s->conflicting_iterations_in_a);\n       free_conflict_function (s->conflicting_iterations_in_b);\n@@ -2841,7 +2841,7 @@ save_dist_v (struct data_dependence_relation *ddr, lambda_vector dist_v)\n   unsigned i;\n   lambda_vector v;\n \n-  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, v); i++)\n+  FOR_EACH_VEC_ELT (lambda_vector, DDR_DIST_VECTS (ddr), i, v)\n     if (lambda_vector_equal (v, dist_v, DDR_NB_LOOPS (ddr)))\n       return;\n \n@@ -2856,7 +2856,7 @@ save_dir_v (struct data_dependence_relation *ddr, lambda_vector dir_v)\n   unsigned i;\n   lambda_vector v;\n \n-  for (i = 0; VEC_iterate (lambda_vector, DDR_DIR_VECTS (ddr), i, v); i++)\n+  FOR_EACH_VEC_ELT (lambda_vector, DDR_DIR_VECTS (ddr), i, v)\n     if (lambda_vector_equal (v, dir_v, DDR_NB_LOOPS (ddr)))\n       return;\n \n@@ -3319,7 +3319,7 @@ build_classic_dir_vector (struct data_dependence_relation *ddr)\n   unsigned i, j;\n   lambda_vector dist_v;\n \n-  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n+  FOR_EACH_VEC_ELT (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v)\n     {\n       lambda_vector dir_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n@@ -3421,7 +3421,7 @@ access_functions_are_affine_or_constant_p (const struct data_reference *a,\n   VEC(tree,heap) *fns = DR_ACCESS_FNS (a);\n   tree t;\n \n-  for (i = 0; VEC_iterate (tree, fns, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, fns, i, t)\n     if (!evolution_function_is_invariant_p (t, loop_nest->num)\n \t&& !evolution_function_is_affine_multivariate_p (t, loop_nest->num))\n       return false;\n@@ -3883,7 +3883,7 @@ ddr_consistent_p (FILE *file,\n \t       DDR_NUM_DIST_VECTS (ddr));\n \n       fprintf (file, \"Banerjee dist vectors:\\n\");\n-      for (i = 0; VEC_iterate (lambda_vector, dist_vects, i, b_dist_v); i++)\n+      FOR_EACH_VEC_ELT (lambda_vector, dist_vects, i, b_dist_v)\n \tprint_lambda_vector (file, b_dist_v, DDR_NB_LOOPS (ddr));\n \n       fprintf (file, \"Omega dist vectors:\\n\");\n@@ -3912,7 +3912,7 @@ ddr_consistent_p (FILE *file,\n \n       /* Distance vectors are not ordered in the same way in the DDR\n \t and in the DIST_VECTS: search for a matching vector.  */\n-      for (j = 0; VEC_iterate (lambda_vector, dist_vects, j, a_dist_v); j++)\n+      FOR_EACH_VEC_ELT (lambda_vector, dist_vects, j, a_dist_v)\n \tif (lambda_vector_equal (a_dist_v, b_dist_v, DDR_NB_LOOPS (ddr)))\n \t  break;\n \n@@ -3935,7 +3935,7 @@ ddr_consistent_p (FILE *file,\n \n       /* Direction vectors are not ordered in the same way in the DDR\n \t and in the DIR_VECTS: search for a matching vector.  */\n-      for (j = 0; VEC_iterate (lambda_vector, dir_vects, j, a_dir_v); j++)\n+      FOR_EACH_VEC_ELT (lambda_vector, dir_vects, j, a_dir_v)\n \tif (lambda_vector_equal (a_dir_v, b_dir_v, DDR_NB_LOOPS (ddr)))\n \t  break;\n \n@@ -4105,7 +4105,7 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n   struct data_reference *a, *b;\n   unsigned int i, j;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, a); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, a)\n     for (j = i + 1; VEC_iterate (data_reference_p, datarefs, j, b); j++)\n       if (!DR_IS_READ (a) || !DR_IS_READ (b) || compute_self_and_rr)\n \t{\n@@ -4116,7 +4116,7 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n \t}\n \n   if (compute_self_and_rr)\n-    for (i = 0; VEC_iterate (data_reference_p, datarefs, i, a); i++)\n+    FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, a)\n       {\n \tddr = initialize_data_dependence_relation (a, a, loop_nest);\n \tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n@@ -4214,7 +4214,7 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n       return false;\n     }\n \n-  for (i = 0; VEC_iterate (data_ref_loc, references, i, ref); i++)\n+  FOR_EACH_VEC_ELT (data_ref_loc, references, i, ref)\n     {\n       dr = create_data_ref (nest, *ref->pos, stmt, ref->is_read);\n       gcc_assert (dr != NULL);\n@@ -4257,7 +4257,7 @@ graphite_find_data_references_in_stmt (struct loop *nest, gimple stmt,\n       return false;\n     }\n \n-  for (i = 0; VEC_iterate (data_ref_loc, references, i, ref); i++)\n+  FOR_EACH_VEC_ELT (data_ref_loc, references, i, ref)\n     {\n       dr = create_data_ref (nest, *ref->pos, stmt, ref->is_read);\n       gcc_assert (dr != NULL);\n@@ -4526,7 +4526,7 @@ analyze_all_data_dependences (struct loop *loop)\n \t  unsigned nb_chrec_relations = 0;\n \t  struct data_dependence_relation *ddr;\n \n-\t  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+\t  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n \t    {\n \t      if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n \t\tnb_top_relations++;\n@@ -4587,7 +4587,7 @@ free_dependence_relations (VEC (ddr_p, heap) *dependence_relations)\n   struct data_dependence_relation *ddr;\n   VEC (loop_p, heap) *loop_nest = NULL;\n \n-  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n     {\n       if (ddr == NULL)\n \tcontinue;\n@@ -4612,7 +4612,7 @@ free_data_refs (VEC (data_reference_p, heap) *datarefs)\n   unsigned int i;\n   struct data_reference *dr;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     free_data_ref (dr);\n   VEC_free (data_reference_p, heap, datarefs);\n }\n@@ -4814,7 +4814,7 @@ create_rdg_edges (struct graph *rdg, VEC (ddr_p, heap) *ddrs)\n   def_operand_p def_p;\n   ssa_op_iter iter;\n \n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n     if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n       create_rdg_edge_for_ddr (rdg, ddr);\n \n@@ -4832,7 +4832,7 @@ create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts)\n   int i, j;\n   gimple stmt;\n \n-  for (i = 0; VEC_iterate (gimple, stmts, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n     {\n       VEC (data_ref_loc, heap) *references;\n       data_ref_loc *ref;\n@@ -4858,7 +4858,7 @@ create_rdg_vertices (struct graph *rdg, VEC (gimple, heap) *stmts)\n \tcontinue;\n \n       get_references_in_stmt (stmt, &references);\n-      for (j = 0; VEC_iterate (data_ref_loc, references, j, ref); j++)\n+      FOR_EACH_VEC_ELT (data_ref_loc, references, j, ref)\n \tif (!ref->is_read)\n \t  RDG_MEM_WRITE_STMT (rdg, i) = true;\n \telse\n@@ -4908,7 +4908,7 @@ known_dependences_p (VEC (ddr_p, heap) *dependence_relations)\n   ddr_p ddr;\n   unsigned int i;\n \n-  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n     if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n       return false;\n \n@@ -5142,12 +5142,12 @@ have_similar_memory_accesses (gimple s1, gimple s2)\n   get_references_in_stmt (s1, &refs1);\n   get_references_in_stmt (s2, &refs2);\n \n-  for (i = 0; VEC_iterate (data_ref_loc, refs1, i, ref1); i++)\n+  FOR_EACH_VEC_ELT (data_ref_loc, refs1, i, ref1)\n     {\n       tree base1 = ref_base_address (s1, ref1);\n \n       if (base1)\n-\tfor (j = 0; VEC_iterate (data_ref_loc, refs2, j, ref2); j++)\n+\tFOR_EACH_VEC_ELT (data_ref_loc, refs2, j, ref2)\n \t  if (base1 == ref_base_address (s2, ref2))\n \t    {\n \t      res = true;\n@@ -5183,7 +5183,7 @@ ref_base_address_1 (const void *s)\n \n   get_references_in_stmt (stmt, &refs);\n \n-  for (i = 0; VEC_iterate (data_ref_loc, refs, i, ref); i++)\n+  FOR_EACH_VEC_ELT (data_ref_loc, refs, i, ref)\n     if (!ref->is_read)\n       {\n \tres = htab_hash_pointer (ref_base_address (stmt, ref));\n@@ -5233,7 +5233,7 @@ access_matrix_get_index_for_parameter (tree parameter,\n   VEC (tree,heap) *lambda_parameters = AM_PARAMETERS (access_matrix);\n   tree lambda_parameter;\n \n-  for (i = 0; VEC_iterate (tree, lambda_parameters, i, lambda_parameter); i++)\n+  FOR_EACH_VEC_ELT (tree, lambda_parameters, i, lambda_parameter)\n     if (lambda_parameter == parameter)\n       return i + AM_NB_INDUCTION_VARS (access_matrix);\n "}, {"sha": "ec4e0ada0b39d3f573a24b5b3ff47172fed9b99a", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -714,7 +714,7 @@ ipa_lower_emutls (void)\n   VEC_safe_grow (tree, heap, access_vars, n_tls);\n \n   /* Create the control variables for each TLS variable.  */\n-  for (i = 0; VEC_iterate (varpool_node_ptr, tls_vars->nodes, i, var); ++i)\n+  FOR_EACH_VEC_ELT (varpool_node_ptr, tls_vars->nodes, i, var)\n     {\n       tree cdecl;\n       struct varpool_node *cvar;\n@@ -750,7 +750,7 @@ ipa_lower_emutls (void)\n   if (any_aliases)\n     {\n       alias_pair *p;\n-      for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n+      FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n \tif (DECL_THREAD_LOCAL_P (p->decl))\n \t  {\n \t    p->decl = emutls_decl (p->decl);"}, {"sha": "3784bc507d96e3c4b52a5b3df04c414ad002a957", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2370,7 +2370,7 @@ copy_debug_stmts (copy_body_data *id)\n   if (!id->debug_stmts)\n     return;\n \n-  for (i = 0; VEC_iterate (gimple, id->debug_stmts, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, id->debug_stmts, i, stmt)\n     copy_debug_stmt (stmt, id);\n \n   VEC_free (gimple, heap, id->debug_stmts);"}, {"sha": "cbd629c7fe53dcb831c8a10ecc07b9d7ae1d0a98", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1992,7 +1992,7 @@ rewrite_update_phi_arguments (basic_block bb)\n \tcontinue;\n \n       phis = VEC_index (gimple_vec, phis_to_rewrite, e->dest->index);\n-      for (i = 0; VEC_iterate (gimple, phis, i, phi); i++)\n+      FOR_EACH_VEC_ELT (gimple, phis, i, phi)\n \t{\n \t  tree arg, lhs_sym, reaching_def = NULL;\n \t  use_operand_p arg_p;"}, {"sha": "63f717807d480810a6041f95726c7f81fb174342", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -517,7 +517,7 @@ mark_nodes_having_upstream_mem_writes (struct graph *rdg)\n \n \tgraphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n \n-\tfor (i = 0; VEC_iterate (int, nodes, i, x); i++)\n+\tFOR_EACH_VEC_ELT (int, nodes, i, x)\n \t  {\n \t    if (!bitmap_set_bit (seen, x))\n \t      continue;\n@@ -672,7 +672,7 @@ rdg_flag_vertex_and_dependent (struct graph *rdg, int v, bitmap partition,\n   graphds_dfs (rdg, &v, 1, &nodes, false, remaining_stmts);\n   rdg_flag_vertex (rdg, v, partition, loops, part_has_writes);\n \n-  for (i = 0; VEC_iterate (int, nodes, i, x); i++)\n+  FOR_EACH_VEC_ELT (int, nodes, i, x)\n     if (!already_processed_vertex_p (processed, x))\n       rdg_flag_vertex_and_dependent (rdg, x, partition, loops, processed,\n \t\t\t\t     part_has_writes);\n@@ -690,7 +690,7 @@ collect_condition_stmts (struct loop *loop, VEC (gimple, heap) **conds)\n   edge e;\n   VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n \n-  for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, e)\n     {\n       gimple cond = last_stmt (e->src);\n \n@@ -771,7 +771,7 @@ rdg_flag_similar_memory_accesses (struct graph *rdg, bitmap partition,\n \n \t      /* Remove from OTHER_STORES the vertex that we flagged.  */\n \t      if (RDG_MEM_WRITE_STMT (rdg, j))\n-\t\tfor (k = 0; VEC_iterate (int, *other_stores, k, kk); k++)\n+\t\tFOR_EACH_VEC_ELT (int, *other_stores, k, kk)\n \t\t  if (kk == j)\n \t\t    {\n \t\t      VEC_unordered_remove (int, *other_stores, k);\n@@ -802,7 +802,7 @@ build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n   bitmap loops = BITMAP_ALLOC (NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n \n-  for (i = 0; VEC_iterate (int, c->vertices, i, v); i++)\n+  FOR_EACH_VEC_ELT (int, c->vertices, i, v)\n     if (!already_processed_vertex_p (processed, v))\n       rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed,\n \t\t\t\t     part_has_writes);\n@@ -829,7 +829,7 @@ free_rdg_components (VEC (rdgc, heap) *components)\n   int i;\n   rdgc x;\n \n-  for (i = 0; VEC_iterate (rdgc, components, i, x); i++)\n+  FOR_EACH_VEC_ELT (rdgc, components, i, x)\n     {\n       VEC_free (int, heap, x->vertices);\n       free (x);\n@@ -854,7 +854,7 @@ rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices,\n   for (i = 0; i < rdg->n_vertices; i++)\n     VEC_safe_push (int, heap, all_components[rdg->vertices[i].component], i);\n \n-  for (i = 0; VEC_iterate (int, starting_vertices, i, v); i++)\n+  FOR_EACH_VEC_ELT (int, starting_vertices, i, v)\n     {\n       int c = rdg->vertices[v].component;\n \n@@ -889,7 +889,7 @@ rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n   rdgc x;\n   bitmap partition = BITMAP_ALLOC (NULL);\n \n-  for (i = 0; VEC_iterate (rdgc, components, i, x); i++)\n+  FOR_EACH_VEC_ELT (rdgc, components, i, x)\n     {\n       bitmap np;\n       bool part_has_writes = false;\n@@ -955,7 +955,7 @@ dump_rdg_partitions (FILE *file, VEC (bitmap, heap) *partitions)\n   int i;\n   bitmap partition;\n \n-  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n     debug_bitmap_file (file, partition);\n }\n \n@@ -1019,7 +1019,7 @@ partition_contains_all_rw (struct graph *rdg, VEC (bitmap, heap) *partitions)\n   bitmap partition;\n   int nrw = number_of_rw_in_rdg (rdg);\n \n-  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n     if (nrw == number_of_rw_in_partition (rdg, partition))\n       return true;\n \n@@ -1054,7 +1054,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t  unsigned j;\n \t  bool found = false;\n \n-\t  for (j = 0; VEC_iterate (int, starting_vertices, j, v); j++)\n+\t  FOR_EACH_VEC_ELT (int, starting_vertices, j, v)\n \t    if (i == v)\n \t      {\n \t\tfound = true;\n@@ -1080,7 +1080,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg_partitions (dump_file, partitions);\n \n-  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n     if (!generate_code_for_partition (loop, partition, i < nbp - 1))\n       goto ldist_done;\n \n@@ -1092,7 +1092,7 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   BITMAP_FREE (remaining_stmts);\n   BITMAP_FREE (upstream_mem_writes);\n \n-  for (i = 0; VEC_iterate (bitmap, partitions, i, partition); i++)\n+  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n     BITMAP_FREE (partition);\n \n   VEC_free (int, heap, other_stores);\n@@ -1143,7 +1143,7 @@ distribute_loop (struct loop *loop, VEC (gimple, heap) *stmts)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg (dump_file, rdg);\n \n-  for (i = 0; VEC_iterate (gimple, stmts, i, s); i++)\n+  FOR_EACH_VEC_ELT (gimple, stmts, i, s)\n     {\n       int v = rdg_vertex_for_stmt (rdg, s);\n "}, {"sha": "a411c25c91cc4534608334f8ca37ff96c56ae602", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -99,7 +99,7 @@ gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations ATTRIBUTE_UNUS\n   *nb_deps_not_carried_by_loop = 0;\n   *access_strides = double_int_zero;\n \n-  for (i = 0; VEC_iterate (ddr_p, dependence_relations, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)\n     {\n       /* If we don't know anything about this dependence, or the distance\n \t vector is NULL, or there is no dependence, then there is no reuse of\n@@ -125,7 +125,7 @@ gather_interchange_stats (VEC (ddr_p, heap) *dependence_relations ATTRIBUTE_UNUS\n     }\n \n   /* Compute the access strides.  */\n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       unsigned int it;\n       tree ref = DR_REF (dr);\n@@ -414,7 +414,7 @@ linear_transform_loops (void)\n       VEC_free (loop_p, heap, nest);\n     }\n \n-  for (i = 0; VEC_iterate (gimple, remove_ivs, i, oldiv_stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, remove_ivs, i, oldiv_stmt)\n     remove_iv (oldiv_stmt);\n \n   VEC_free (tree, heap, oldivs);"}, {"sha": "f65d1dab5623b21b21a691241220444c7e1860c7", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1327,7 +1327,7 @@ mudflap_finish_file (void)\n     {\n       size_t i;\n       tree obj;\n-      for (i = 0; VEC_iterate (tree, deferred_static_decls, i, obj); i++)\n+      FOR_EACH_VEC_ELT (tree, deferred_static_decls, i, obj)\n         {\n           gcc_assert (DECL_P (obj));\n "}, {"sha": "87ccb2141677cd9f3b2ba08d47bfdb972a6c4a04", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -403,7 +403,7 @@ elim_graph_add_node (elim_graph g, int node)\n   int x;\n   int t;\n \n-  for (x = 0; VEC_iterate (int, g->nodes, x, t); x++)\n+  FOR_EACH_VEC_ELT (int, g->nodes, x, t)\n     if (t == node)\n       return;\n   VEC_safe_push (int, heap, g->nodes, node);\n@@ -678,7 +678,7 @@ eliminate_phi (edge e, elim_graph g)\n       sbitmap_zero (g->visited);\n       VEC_truncate (int, g->stack, 0);\n \n-      for (x = 0; VEC_iterate (int, g->nodes, x, part); x++)\n+      FOR_EACH_VEC_ELT (int, g->nodes, x, part)\n         {\n \t  if (!TEST_BIT (g->visited, part))\n \t    elim_forward (g, part);"}, {"sha": "4fc67a3adc93a111ff2e1132f7ec7b136ab0012a", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -549,7 +549,7 @@ eliminate_local_variables (edge entry, edge exit)\n \n   gather_blocks_in_sese_region (entry_bb, exit_bb, &body);\n \n-  for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n     if (bb != entry_bb && bb != exit_bb)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \teliminate_local_variables_stmt (entry, gsi_stmt (gsi),\n@@ -1087,7 +1087,7 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n   entry = single_succ_edge (entry_bb);\n   gather_blocks_in_sese_region (entry_bb, exit_bb, &body);\n \n-  for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+  FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n     {\n       if (bb != entry_bb && bb != exit_bb)\n \t{\n@@ -1115,7 +1115,7 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n      and discard those for which we know there's nothing we can\n      do.  */\n   if (has_debug_stmt)\n-    for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+    FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n       if (bb != entry_bb && bb != exit_bb)\n \t{\n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)"}, {"sha": "712cc68740d4a91985dd6178e3b46d6582f09fbf", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -420,7 +420,7 @@ dump_chain (FILE *file, chain_p chain)\n   if (chain->vars)\n     {\n       fprintf (file, \"  vars\");\n-      for (i = 0; VEC_iterate (tree, chain->vars, i, var); i++)\n+      FOR_EACH_VEC_ELT (tree, chain->vars, i, var)\n \t{\n \t  fprintf (file, \" \");\n \t  print_generic_expr (file, var, TDF_SLIM);\n@@ -431,7 +431,7 @@ dump_chain (FILE *file, chain_p chain)\n   if (chain->inits)\n     {\n       fprintf (file, \"  inits\");\n-      for (i = 0; VEC_iterate (tree, chain->inits, i, var); i++)\n+      FOR_EACH_VEC_ELT (tree, chain->inits, i, var)\n \t{\n \t  fprintf (file, \" \");\n \t  print_generic_expr (file, var, TDF_SLIM);\n@@ -440,7 +440,7 @@ dump_chain (FILE *file, chain_p chain)\n     }\n \n   fprintf (file, \"  references:\\n\");\n-  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, a)\n     dump_dref (file, a);\n \n   fprintf (file, \"\\n\");\n@@ -455,7 +455,7 @@ dump_chains (FILE *file, VEC (chain_p, heap) *chains)\n   chain_p chain;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n     dump_chain (file, chain);\n }\n \n@@ -470,7 +470,7 @@ dump_component (FILE *file, struct component *comp)\n \n   fprintf (file, \"Component%s:\\n\",\n \t   comp->comp_step == RS_INVARIANT ? \" (invariant)\" : \"\");\n-  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, comp->refs, i, a)\n     dump_dref (file, a);\n   fprintf (file, \"\\n\");\n }\n@@ -498,7 +498,7 @@ release_chain (chain_p chain)\n   if (chain == NULL)\n     return;\n \n-  for (i = 0; VEC_iterate (dref, chain->refs, i, ref); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, ref)\n     free (ref);\n \n   VEC_free (dref, heap, chain->refs);\n@@ -516,7 +516,7 @@ release_chains (VEC (chain_p, heap) *chains)\n   unsigned i;\n   chain_p chain;\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n     release_chain (chain);\n   VEC_free (chain_p, heap, chains);\n }\n@@ -682,7 +682,7 @@ last_always_executed_block (struct loop *loop)\n   edge ex;\n   basic_block last = loop->latch;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     last = nearest_common_dominator (CDI_DOMINATORS, last, ex->src);\n   VEC_free (edge, heap, exits);\n \n@@ -707,7 +707,7 @@ split_data_refs_to_components (struct loop *loop,\n   dref dataref;\n   basic_block last_always_executed = last_always_executed_block (loop);\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       if (!DR_REF (dr))\n \t{\n@@ -724,7 +724,7 @@ split_data_refs_to_components (struct loop *loop,\n   comp_father[n] = n;\n   comp_size[n] = 1;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       enum ref_step_type dummy;\n \n@@ -735,7 +735,7 @@ split_data_refs_to_components (struct loop *loop,\n \t}\n     }\n \n-  for (i = 0; VEC_iterate (ddr_p, depends, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, depends, i, ddr)\n     {\n       double_int dummy_off;\n \n@@ -762,7 +762,7 @@ split_data_refs_to_components (struct loop *loop,\n \n   comps = XCNEWVEC (struct component *, n);\n   bad = component_of (comp_father, n);\n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       ia = (unsigned) (size_t) dr->aux;\n       ca = component_of (comp_father, ia);\n@@ -819,7 +819,7 @@ suitable_component_p (struct loop *loop, struct component *comp)\n   basic_block ba, bp = loop->header;\n   bool ok, has_write = false;\n \n-  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, comp->refs, i, a)\n     {\n       ba = gimple_bb (a->stmt);\n \n@@ -883,7 +883,7 @@ filter_suitable_components (struct loop *loop, struct component *comps)\n \t  unsigned i;\n \n \t  *comp = act->next;\n-\t  for (i = 0; VEC_iterate (dref, act->refs, i, ref); i++)\n+\t  FOR_EACH_VEC_ELT (dref, act->refs, i, ref)\n \t    free (ref);\n \t  release_component (act);\n \t}\n@@ -963,7 +963,7 @@ make_invariant_chain (struct component *comp)\n \n   chain->all_always_accessed = true;\n \n-  for (i = 0; VEC_iterate (dref, comp->refs, i, ref); i++)\n+  FOR_EACH_VEC_ELT (dref, comp->refs, i, ref)\n     {\n       VEC_safe_push (dref, heap, chain->refs, ref);\n       chain->all_always_accessed &= ref->always_accessed;\n@@ -1135,7 +1135,7 @@ insert_looparound_copy (chain_p chain, dref ref, gimple phi)\n   nw->distance = ref->distance + 1;\n   nw->always_accessed = 1;\n \n-  for (i = 0; VEC_iterate (dref, chain->refs, i, aref); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, aref)\n     if (aref->distance >= nw->distance)\n       break;\n   VEC_safe_insert (dref, heap, chain->refs, i, nw);\n@@ -1159,7 +1159,7 @@ add_looparound_copies (struct loop *loop, chain_p chain)\n   dref ref, root = get_chain_root (chain);\n   gimple phi;\n \n-  for (i = 0; VEC_iterate (dref, chain->refs, i, ref); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, ref)\n     {\n       phi = find_looparound_phi (loop, ref, root);\n       if (!phi)\n@@ -1195,7 +1195,7 @@ determine_roots_comp (struct loop *loop,\n   qsort (VEC_address (dref, comp->refs), VEC_length (dref, comp->refs),\n \t sizeof (dref), order_drefs);\n \n-  for (i = 0; VEC_iterate (dref, comp->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, comp->refs, i, a)\n     {\n       if (!chain || !DR_IS_READ (a->ref)\n \t  || double_int_ucmp (uhwi_to_double_int (MAX_DISTANCE),\n@@ -1506,7 +1506,7 @@ initialize_root_vars (struct loop *loop, chain_p chain, bitmap tmp_vars)\n   if (reuse_first)\n     VEC_quick_push (tree, chain->vars, VEC_index (tree, chain->vars, 0));\n \n-  for (i = 0; VEC_iterate (tree, chain->vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, chain->vars, i, var)\n     VEC_replace (tree, chain->vars, i, make_ssa_name (var, NULL));\n \n   for (i = 0; i < n; i++)\n@@ -1571,7 +1571,7 @@ initialize_root_vars_lm (struct loop *loop, dref root, bool written,\n   if (written)\n     VEC_quick_push (tree, *vars, VEC_index (tree, *vars, 0));\n \n-  for (i = 0; VEC_iterate (tree, *vars, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, *vars, i, var)\n     VEC_replace (tree, *vars, i, make_ssa_name (var, NULL));\n \n   var = VEC_index (tree, *vars, 0);\n@@ -1610,7 +1610,7 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n \n   gcc_assert (chain->type == CT_INVARIANT);\n   gcc_assert (!chain->combined);\n-  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, a)\n     if (!DR_IS_READ (a->ref))\n       n_writes++;\n \n@@ -1622,7 +1622,7 @@ execute_load_motion (struct loop *loop, chain_p chain, bitmap tmp_vars)\n \t\t\t   &vars, chain->inits, tmp_vars);\n \n   ridx = 0;\n-  for (i = 0; VEC_iterate (dref, chain->refs, i, a); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, a)\n     {\n       bool is_read = DR_IS_READ (a->ref);\n       mark_virtual_ops_for_renaming (a->stmt);\n@@ -1777,7 +1777,7 @@ determine_unroll_factor (VEC (chain_p, heap) *chains)\n   unsigned factor = 1, af, nfactor, i;\n   unsigned max = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n     {\n       if (chain->type == CT_INVARIANT || chain->combined)\n \tcontinue;\n@@ -1806,7 +1806,7 @@ execute_pred_commoning (struct loop *loop, VEC (chain_p, heap) *chains,\n   chain_p chain;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n     {\n       if (chain->type == CT_INVARIANT)\n \texecute_load_motion (loop, chain, tmp_vars);\n@@ -1827,8 +1827,8 @@ replace_phis_by_defined_names (VEC (chain_p, heap) *chains)\n   dref a;\n   unsigned i, j;\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n-    for (j = 0; VEC_iterate (dref, chain->refs, j, a); j++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n+    FOR_EACH_VEC_ELT (dref, chain->refs, j, a)\n       {\n \tif (gimple_code (a->stmt) == GIMPLE_PHI)\n \t  {\n@@ -1848,8 +1848,8 @@ replace_names_by_phis (VEC (chain_p, heap) *chains)\n   dref a;\n   unsigned i, j;\n \n-  for (i = 0; VEC_iterate (chain_p, chains, i, chain); i++)\n-    for (j = 0; VEC_iterate (dref, chain->refs, j, a); j++)\n+  FOR_EACH_VEC_ELT (chain_p, chains, i, chain)\n+    FOR_EACH_VEC_ELT (dref, chain->refs, j, a)\n       if (a->stmt == NULL)\n \t{\n \t  a->stmt = SSA_NAME_DEF_STMT (a->name_defined_by_phi);\n@@ -2338,7 +2338,7 @@ try_combine_chains (VEC (chain_p, heap) **chains)\n   chain_p ch1, ch2, cch;\n   VEC (chain_p, heap) *worklist = NULL;\n \n-  for (i = 0; VEC_iterate (chain_p, *chains, i, ch1); i++)\n+  FOR_EACH_VEC_ELT (chain_p, *chains, i, ch1)\n     if (chain_can_be_combined_p (ch1))\n       VEC_safe_push (chain_p, heap, worklist, ch1);\n \n@@ -2348,7 +2348,7 @@ try_combine_chains (VEC (chain_p, heap) **chains)\n       if (!chain_can_be_combined_p (ch1))\n \tcontinue;\n \n-      for (j = 0; VEC_iterate (chain_p, *chains, j, ch2); j++)\n+      FOR_EACH_VEC_ELT (chain_p, *chains, j, ch2)\n \t{\n \t  if (!chain_can_be_combined_p (ch2))\n \t    continue;\n@@ -2385,7 +2385,7 @@ prepare_initializers_chain (struct loop *loop, chain_p chain)\n \n   /* If we have replaced some looparound phi nodes, use their initializers\n      instead of creating our own.  */\n-  for (i = 0; VEC_iterate (dref, chain->refs, i, laref); i++)\n+  FOR_EACH_VEC_ELT (dref, chain->refs, i, laref)\n     {\n       if (gimple_code (laref->stmt) != GIMPLE_PHI)\n \tcontinue;"}, {"sha": "2182fef6d1e839aeb492333a0ed0c8c3b4612a1c", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -538,7 +538,7 @@ dump_block_node (pretty_printer *buffer, tree block, int spc, int flags)\n       VEC(tree,gc) *nlv = BLOCK_NONLOCALIZED_VARS (block);\n \n       pp_string (buffer, \"NONLOCALIZED_VARS: \");\n-      for (i = 0; VEC_iterate (tree, nlv, i, t); i++)\n+      FOR_EACH_VEC_ELT (tree, nlv, i, t)\n \t{\n \t  dump_generic_node (buffer, t, 0, flags, false);\n \t  pp_string (buffer, \" \");"}, {"sha": "c7f45f229d13307d11e5f5dfacae812f833bed0e", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2809,7 +2809,7 @@ number_of_iterations_for_all_loops (VEC(gimple,heap) **exit_conditions)\n   unsigned nb_static_loops = 0;\n   gimple cond;\n \n-  for (i = 0; VEC_iterate (gimple, *exit_conditions, i, cond); i++)\n+  FOR_EACH_VEC_ELT (gimple, *exit_conditions, i, cond)\n     {\n       tree res = number_of_latch_executions (loop_containing_stmt (cond));\n       if (chrec_contains_undetermined (res))\n@@ -2963,7 +2963,7 @@ analyze_scalar_evolution_for_all_loop_phi_nodes (VEC(gimple,heap) **exit_conditi\n \n   reset_chrecs_counters (&stats);\n \n-  for (i = 0; VEC_iterate (gimple, *exit_conditions, i, cond); i++)\n+  FOR_EACH_VEC_ELT (gimple, *exit_conditions, i, cond)\n     {\n       struct loop *loop;\n       basic_block bb;"}, {"sha": "1eb6822149536ad901e0599ecc43d940b45afa03", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1272,7 +1272,7 @@ dump_enumerated_decls (FILE *file, int flags)\n \n       fprintf (file, \"Declarations used by %s, sorted by DECL_UID:\\n\",\n \t       current_function_name ());\n-      for (ix = 0; VEC_iterate (numbered_tree, decl_list, ix, ntp); ix++)\n+      FOR_EACH_VEC_ELT (numbered_tree, decl_list, ix, ntp)\n \t{\n \t  if (ntp->t == last)\n \t    continue;"}, {"sha": "477c4d2b260dd96ebeaf13ff8955e29fcb623568", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1442,7 +1442,7 @@ free_mem_ref_locs (mem_ref_locs_p accs)\n   if (!accs)\n     return;\n \n-  for (i = 0; VEC_iterate (mem_ref_loc_p, accs->locs, i, loc); i++)\n+  FOR_EACH_VEC_ELT (mem_ref_loc_p, accs->locs, i, loc)\n     free (loc);\n   VEC_free (mem_ref_loc_p, heap, accs->locs);\n   free (accs);\n@@ -1463,7 +1463,7 @@ memref_free (void *obj)\n   BITMAP_FREE (mem->indep_ref);\n   BITMAP_FREE (mem->dep_ref);\n \n-  for (i = 0; VEC_iterate (mem_ref_locs_p, mem->accesses_in_loop, i, accs); i++)\n+  FOR_EACH_VEC_ELT (mem_ref_locs_p, mem->accesses_in_loop, i, accs)\n     free_mem_ref_locs (accs);\n   VEC_free (mem_ref_locs_p, heap, mem->accesses_in_loop);\n \n@@ -1929,7 +1929,7 @@ get_all_locs_in_loop (struct loop *loop, mem_ref_p ref,\n       accs = VEC_index (mem_ref_locs_p, ref->accesses_in_loop, loop->num);\n       if (accs)\n \t{\n-\t  for (i = 0; VEC_iterate (mem_ref_loc_p, accs->locs, i, loc); i++)\n+\t  FOR_EACH_VEC_ELT (mem_ref_loc_p, accs->locs, i, loc)\n \t    VEC_safe_push (mem_ref_loc_p, heap, *locs, loc);\n \t}\n     }\n@@ -1948,7 +1948,7 @@ rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n   VEC (mem_ref_loc_p, heap) *locs = NULL;\n \n   get_all_locs_in_loop (loop, ref, &locs);\n-  for (i = 0; VEC_iterate (mem_ref_loc_p, locs, i, loc); i++)\n+  FOR_EACH_VEC_ELT (mem_ref_loc_p, locs, i, loc)\n     rewrite_mem_ref_loc (loc, tmp_var);\n   VEC_free (mem_ref_loc_p, heap, locs);\n }\n@@ -2113,7 +2113,7 @@ execute_sm (struct loop *loop, VEC (edge, heap) *exits, mem_ref_p ref)\n      all dependencies.  */\n   gsi_insert_on_edge (loop_latch_edge (loop), load);\n \n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     {\n       store = gimple_build_assign (unshare_expr (ref->mem), tmp_var);\n       gsi_insert_on_edge (ex, store);\n@@ -2157,7 +2157,7 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n     base = TREE_OPERAND (base, 0);\n \n   get_all_locs_in_loop (loop, ref, &locs);\n-  for (i = 0; VEC_iterate (mem_ref_loc_p, locs, i, loc); i++)\n+  FOR_EACH_VEC_ELT (mem_ref_loc_p, locs, i, loc)\n     {\n       if (!get_lim_data (loc->stmt))\n \tcontinue;\n@@ -2378,7 +2378,7 @@ loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n   unsigned i;\n   edge ex;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     if (ex->flags & EDGE_ABNORMAL)\n       return false;\n \n@@ -2545,19 +2545,19 @@ tree_ssa_lim_finalize (void)\n   VEC_free (mem_ref_p, heap, memory_accesses.refs_list);\n   htab_delete (memory_accesses.refs);\n \n-  for (i = 0; VEC_iterate (bitmap, memory_accesses.refs_in_loop, i, b); i++)\n+  FOR_EACH_VEC_ELT (bitmap, memory_accesses.refs_in_loop, i, b)\n     BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.refs_in_loop);\n \n-  for (i = 0; VEC_iterate (bitmap, memory_accesses.all_refs_in_loop, i, b); i++)\n+  FOR_EACH_VEC_ELT (bitmap, memory_accesses.all_refs_in_loop, i, b)\n     BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.all_refs_in_loop);\n \n-  for (i = 0; VEC_iterate (bitmap, memory_accesses.clobbered_vops, i, b); i++)\n+  FOR_EACH_VEC_ELT (bitmap, memory_accesses.clobbered_vops, i, b)\n     BITMAP_FREE (b);\n   VEC_free (bitmap, heap, memory_accesses.clobbered_vops);\n \n-  for (i = 0; VEC_iterate (htab_t, memory_accesses.vop_ref_map, i, h); i++)\n+  FOR_EACH_VEC_ELT (htab_t, memory_accesses.vop_ref_map, i, h)\n     htab_delete (h);\n   VEC_free (htab_t, heap, memory_accesses.vop_ref_map);\n "}, {"sha": "b0d45bc4b41c5ec3cb3a671b5fed28091fce046f", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -403,7 +403,7 @@ try_unroll_loop_completely (struct loop *loop,\n \t  return false;\n \t}\n \n-      for (i = 0; VEC_iterate (edge, to_remove, i, e); i++)\n+      FOR_EACH_VEC_ELT (edge, to_remove, i, e)\n \t{\n \t  bool ok = remove_path (e);\n \t  gcc_assert (ok);"}, {"sha": "a347c86025ad246d1ea0cccf6b7a2475f2310a7e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -6247,7 +6247,7 @@ free_loop_data (struct ivopts_data *data)\n \n   data->max_inv_id = 0;\n \n-  for (i = 0; VEC_iterate (tree, decl_rtl_to_reset, i, obj); i++)\n+  FOR_EACH_VEC_ELT (tree, decl_rtl_to_reset, i, obj)\n     SET_DECL_RTL (obj, NULL_RTX);\n \n   VEC_truncate (tree, decl_rtl_to_reset, 0);"}, {"sha": "dd2d3ceec7d675b1b48a4e8c8208d758d2d8469e", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1045,7 +1045,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   free (wont_exit);\n   gcc_assert (ok);\n \n-  for (i = 0; VEC_iterate (edge, to_remove, i, e); i++)\n+  FOR_EACH_VEC_ELT (edge, to_remove, i, e)\n     {\n       ok = remove_path (e);\n       gcc_assert (ok);"}, {"sha": "2630faf02fa7b25cbb753b018d983992adfb72ef", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1907,7 +1907,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n   struct tree_niter_desc desc;\n \n   *exit = NULL;\n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     {\n       if (!just_once_each_iteration_p (loop, ex->src))\n \tcontinue;\n@@ -1984,7 +1984,7 @@ finite_loop_p (struct loop *loop)\n     }\n \n   exits = get_loop_exit_edges (loop);\n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     {\n       if (!just_once_each_iteration_p (loop, ex->src))\n \tcontinue;\n@@ -2264,7 +2264,7 @@ find_loop_niter_by_eval (struct loop *loop, edge *exit)\n       && VEC_length (edge, exits) > 1)\n     return chrec_dont_know;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     {\n       if (!just_once_each_iteration_p (loop, ex->src))\n \tcontinue;\n@@ -2920,7 +2920,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n   loop->any_estimate = false;\n \n   exits = get_loop_exit_edges (loop);\n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n     {\n       if (!number_of_iterations_exit (loop, ex, &niter_desc, false))\n \tcontinue;"}, {"sha": "9ad6cd2a59e550801cb1b556a05b862ee5b4a9c8", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1196,7 +1196,7 @@ emit_mfence_after_loop (struct loop *loop)\n   gimple_stmt_iterator bsi;\n   unsigned i;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, exit); i++)\n+  FOR_EACH_VEC_ELT (edge, exits, i, exit)\n     {\n       call = gimple_build_call (FENCE_FOLLOWING_MOVNT, 0);\n \n@@ -1233,7 +1233,7 @@ may_use_storent_in_loop_p (struct loop *loop)\n       unsigned i;\n       edge exit;\n \n-      for (i = 0; VEC_iterate (edge, exits, i, exit); i++)\n+      FOR_EACH_VEC_ELT (edge, exits, i, exit)\n \tif ((exit->flags & EDGE_ABNORMAL)\n \t    && exit->dest == EXIT_BLOCK_PTR)\n \t  ret = false;\n@@ -1452,7 +1452,7 @@ self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n   strides = XCNEWVEC (HOST_WIDE_INT, n);\n   access_fns = DR_ACCESS_FNS (dr);\n \n-  for (i = 0; VEC_iterate (tree, access_fns, i, access_fn); i++)\n+  FOR_EACH_VEC_ELT (tree, access_fns, i, access_fn)\n     {\n       /* Keep track of the reference corresponding to the subscript, so that we\n \t know its stride.  */\n@@ -1574,7 +1574,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n \t  no_other_refs = false;\n       }\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       dist = self_reuse_distance (dr, loop_data_size, n, loop);\n       ref = (struct mem_ref *) dr->aux;\n@@ -1587,7 +1587,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n \n   compute_all_dependences (datarefs, &dependences, vloops, true);\n \n-  for (i = 0; VEC_iterate (ddr_p, dependences, i, dep); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, dependences, i, dep)\n     {\n       if (DDR_ARE_DEPENDENT (dep) == chrec_known)\n \tcontinue;"}, {"sha": "614546bed120d71d19e35da6031ee9e6fe3c1cc7", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -392,7 +392,7 @@ tree_ssa_phiprop (void)\n   /* Walk the dominator tree in preorder.  */\n   bbs = get_all_dominated_blocks (CDI_DOMINATORS,\n \t\t\t\t  single_succ (ENTRY_BLOCK_PTR));\n-  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); ++i)\n+  FOR_EACH_VEC_ELT (basic_block, bbs, i, bb)\n     for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       did_something |= propagate_with_phi (bb, gsi_stmt (gsi), phivn, n);\n "}, {"sha": "6d481231a87bfc63019b7ed1f496ac35a6eeb6bf", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1886,7 +1886,7 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n     }\n \n   exprs = sorted_array_from_bitmap_set (set);\n-  for (i = 0; VEC_iterate (pre_expr, exprs, i, expr); i++)\n+  FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       pre_expr translated;\n       translated = phi_translate (expr, set, NULL, pred, phiblock);\n@@ -2150,7 +2150,7 @@ valid_in_sets (bitmap_set_t set1, bitmap_set_t set2, pre_expr expr,\n \tvn_reference_op_t vro;\n \tunsigned int i;\n \n-\tfor (i = 0; VEC_iterate (vn_reference_op_s, ref->operands, i, vro); i++)\n+\tFOR_EACH_VEC_ELT (vn_reference_op_s, ref->operands, i, vro)\n \t  {\n \t    if (!vro_valid_in_sets (set1, set2, vro))\n \t      return false;\n@@ -2184,7 +2184,7 @@ dependent_clean (bitmap_set_t set1, bitmap_set_t set2, basic_block block)\n   pre_expr expr;\n   int i;\n \n-  for (i = 0; VEC_iterate (pre_expr, exprs, i, expr); i++)\n+  FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (!valid_in_sets (set1, set2, expr, block))\n \tbitmap_remove_from_set (set1, expr);\n@@ -2203,7 +2203,7 @@ clean (bitmap_set_t set, basic_block block)\n   pre_expr expr;\n   int i;\n \n-  for (i = 0; VEC_iterate (pre_expr, exprs, i, expr); i++)\n+  FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (!valid_in_sets (set, NULL, expr, block))\n \tbitmap_remove_from_set (set, expr);\n@@ -2337,7 +2337,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n       else\n \tbitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n \n-      for (i = 0; VEC_iterate (basic_block, worklist, i, bprime); i++)\n+      FOR_EACH_VEC_ELT (basic_block, worklist, i, bprime)\n \t{\n \t  if (!gimple_seq_empty_p (phi_nodes (bprime)))\n \t    {\n@@ -2480,7 +2480,7 @@ compute_partial_antic_aux (basic_block block,\n \t}\n       if (VEC_length (basic_block, worklist) > 0)\n \t{\n-\t  for (i = 0; VEC_iterate (basic_block, worklist, i, bprime); i++)\n+\t  FOR_EACH_VEC_ELT (basic_block, worklist, i, bprime)\n \t    {\n \t      unsigned int i;\n \t      bitmap_iterator bi;\n@@ -3259,7 +3259,7 @@ inhibit_phi_insertion (basic_block bb, pre_expr expr)\n      memory reference is a simple induction variable.  In other\n      cases the vectorizer won't do anything anyway (either it's\n      loop invariant or a complicated expression).  */\n-  for (i = 0; VEC_iterate (vn_reference_op_s, ops, i, op); ++i)\n+  FOR_EACH_VEC_ELT (vn_reference_op_s, ops, i, op)\n     {\n       switch (op->opcode)\n \t{\n@@ -3546,7 +3546,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n   pre_expr expr;\n   int i;\n \n-  for (i = 0; VEC_iterate (pre_expr, exprs, i, expr); i++)\n+  FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (expr->kind != NAME)\n \t{\n@@ -3692,7 +3692,7 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n   pre_expr expr;\n   int i;\n \n-  for (i = 0; VEC_iterate (pre_expr, exprs, i, expr); i++)\n+  FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (expr->kind != NAME)\n \t{\n@@ -4473,7 +4473,7 @@ eliminate (void)\n   /* We cannot remove stmts during BB walk, especially not release SSA\n      names there as this confuses the VN machinery.  The stmts ending\n      up in to_remove are either stores or simple copies.  */\n-  for (i = 0; VEC_iterate (gimple, to_remove, i, stmt); ++i)\n+  FOR_EACH_VEC_ELT (gimple, to_remove, i, stmt)\n     {\n       tree lhs = gimple_assign_lhs (stmt);\n       tree rhs = gimple_assign_rhs1 (stmt);"}, {"sha": "fd0a6d803d5c7a8eaa09adc125e0580ffb27292d", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1016,7 +1016,7 @@ undistribute_ops_list (enum tree_code opcode,\n   candidates = sbitmap_alloc (length);\n   sbitmap_zero (candidates);\n   nr_candidates = 0;\n-  for (i = 0; VEC_iterate (operand_entry_t, *ops, i, oe1); ++i)\n+  FOR_EACH_VEC_ELT (operand_entry_t, *ops, i, oe1)\n     {\n       enum tree_code dcode;\n       gimple oe1def;\n@@ -1067,7 +1067,7 @@ undistribute_ops_list (enum tree_code opcode,\n       linearize_expr_tree (&subops[i], oedef,\n \t\t\t   associative_tree_code (oecode), false);\n \n-      for (j = 0; VEC_iterate (operand_entry_t, subops[i], j, oe1); ++j)\n+      FOR_EACH_VEC_ELT (operand_entry_t, subops[i], j, oe1)\n \t{\n \t  oecount c;\n \t  void **slot;\n@@ -1100,7 +1100,7 @@ undistribute_ops_list (enum tree_code opcode,\n     {\n       oecount *c;\n       fprintf (dump_file, \"Candidates:\\n\");\n-      for (j = 0; VEC_iterate (oecount, cvec, j, c); ++j)\n+      FOR_EACH_VEC_ELT (oecount, cvec, j, c)\n \t{\n \t  fprintf (dump_file, \"  %u %s: \", c->cnt,\n \t\t   c->oecode == MULT_EXPR\n@@ -1139,7 +1139,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  if (oecode != c->oecode)\n \t    continue;\n \n-\t  for (j = 0; VEC_iterate (operand_entry_t, subops[i], j, oe1); ++j)\n+\t  FOR_EACH_VEC_ELT (operand_entry_t, subops[i], j, oe1)\n \t    {\n \t      if (oe1->op == c->op)\n \t\t{\n@@ -1864,7 +1864,7 @@ repropagate_negates (void)\n   unsigned int i = 0;\n   tree negate;\n \n-  for (i = 0; VEC_iterate (tree, plus_negates, i, negate); i++)\n+  FOR_EACH_VEC_ELT (tree, plus_negates, i, negate)\n     {\n       gimple user = get_single_immediate_use (negate);\n \n@@ -2148,7 +2148,7 @@ dump_ops_vector (FILE *file, VEC (operand_entry_t, heap) *ops)\n   operand_entry_t oe;\n   unsigned int i;\n \n-  for (i = 0; VEC_iterate (operand_entry_t, ops, i, oe); i++)\n+  FOR_EACH_VEC_ELT (operand_entry_t, ops, i, oe)\n     {\n       fprintf (file, \"Op %d -> rank: %d, tree: \", i, oe->rank);\n       print_generic_expr (file, oe->op, 0);"}, {"sha": "cbf0e25712f4224971a9ca58173dc7a53e9454c3", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -432,7 +432,7 @@ vn_reference_compute_hash (const vn_reference_t vr1)\n   HOST_WIDE_INT off = -1;\n   bool deref = false;\n \n-  for (i = 0; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro); i++)\n+  FOR_EACH_VEC_ELT (vn_reference_op_s, vr1->operands, i, vro)\n     {\n       if (vro->opcode == MEM_REF)\n \tderef = true;\n@@ -769,7 +769,7 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \n   /* Compute cumulative bit-offset for nested component-refs and array-refs,\n      and find the ultimate containing object.  */\n-  for (i = 0; VEC_iterate (vn_reference_op_s, ops, i, op); ++i)\n+  FOR_EACH_VEC_ELT (vn_reference_op_s, ops, i, op)\n     {\n       switch (op->opcode)\n \t{\n@@ -1140,7 +1140,7 @@ valueize_refs (VEC (vn_reference_op_s, heap) *orig)\n   vn_reference_op_t vro;\n   unsigned int i;\n \n-  for (i = 0; VEC_iterate (vn_reference_op_s, orig, i, vro); i++)\n+  FOR_EACH_VEC_ELT (vn_reference_op_s, orig, i, vro)\n     {\n       if (vro->opcode == SSA_NAME\n \t  || (vro->op0 && TREE_CODE (vro->op0) == SSA_NAME))\n@@ -1436,7 +1436,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n       else\n \tVEC_truncate (vn_reference_op_s, vr->operands,\n \t\t      i + 1 + VEC_length (vn_reference_op_s, rhs));\n-      for (j = 0; VEC_iterate (vn_reference_op_s, rhs, j, vro); ++j)\n+      FOR_EACH_VEC_ELT (vn_reference_op_s, rhs, j, vro)\n \tVEC_replace (vn_reference_op_s, vr->operands, i + 1 + j, vro);\n       VEC_free (vn_reference_op_s, heap, rhs);\n       vr->hashcode = vn_reference_compute_hash (vr);\n@@ -1933,7 +1933,7 @@ vn_phi_compute_hash (vn_phi_t vp1)\n \t     + (INTEGRAL_TYPE_P (type)\n \t\t? TYPE_PRECISION (type) + TYPE_UNSIGNED (type) : 0));\n \n-  for (i = 0; VEC_iterate (tree, vp1->phiargs, i, phi1op); i++)\n+  FOR_EACH_VEC_ELT (tree, vp1->phiargs, i, phi1op)\n     {\n       if (phi1op == VN_TOP)\n \tcontinue;\n@@ -1976,7 +1976,7 @@ vn_phi_eq (const void *p1, const void *p2)\n \n       /* Any phi in the same block will have it's arguments in the\n \t same edge order, because of how we store phi nodes.  */\n-      for (i = 0; VEC_iterate (tree, vp1->phiargs, i, phi1op); i++)\n+      FOR_EACH_VEC_ELT (tree, vp1->phiargs, i, phi1op)\n \t{\n \t  tree phi2op = VEC_index (tree, vp2->phiargs, i);\n \t  if (phi1op == VN_TOP || phi2op == VN_TOP)\n@@ -2067,7 +2067,7 @@ print_scc (FILE *out, VEC (tree, heap) *scc)\n   unsigned int i;\n \n   fprintf (out, \"SCC consists of: \");\n-  for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+  FOR_EACH_VEC_ELT (tree, scc, i, var)\n     {\n       print_generic_expr (out, var, 0);\n       fprintf (out, \" \");\n@@ -3131,9 +3131,9 @@ process_scc (VEC (tree, heap) *scc)\n       gcc_obstack_init (&optimistic_info->nary_obstack);\n       empty_alloc_pool (optimistic_info->phis_pool);\n       empty_alloc_pool (optimistic_info->references_pool);\n-      for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+      FOR_EACH_VEC_ELT (tree, scc, i, var)\n \tVN_INFO (var)->expr = NULL_TREE;\n-      for (i = 0; VEC_iterate (tree, scc, i, var); i++)\n+      FOR_EACH_VEC_ELT (tree, scc, i, var)\n \tchanged |= visit_use (var);\n     }\n "}, {"sha": "ef09014f0d37c3d9133afa57120e2f60785bd9cc", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -814,7 +814,7 @@ dump_constraint_graph (FILE *file)\n   /* Go over the list of constraints printing the edges in the constraint\n      graph.  */\n   fprintf (file, \"\\n  // The constraint edges:\\n\");\n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, constraints, i, c)\n     if (c)\n       dump_constraint_edge (file, c);\n \n@@ -939,7 +939,7 @@ constraint_set_union (VEC(constraint_t,heap) **to,\n   int i;\n   constraint_t c;\n \n-  for (i = 0; VEC_iterate (constraint_t, *from, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, *from, i, c)\n     {\n       if (constraint_vec_find (*to, *c) == NULL)\n \t{\n@@ -1096,7 +1096,7 @@ merge_node_constraints (constraint_graph_t graph, unsigned int to,\n   gcc_assert (find (from) == to);\n \n   /* Move all complex constraints from src node into to node  */\n-  for (i = 0; VEC_iterate (constraint_t, graph->complex[from], i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, graph->complex[from], i, c)\n     {\n       /* In complex constraints for node src, we may have either\n \t a = *src, and *src = a, or an offseted constraint which are\n@@ -1280,7 +1280,7 @@ build_pred_graph (void)\n   for (j = 0; j < VEC_length (varinfo_t, varmap); j++)\n     graph->indirect_cycles[j] = -1;\n \n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, constraints, i, c)\n     {\n       struct constraint_expr lhs = c->lhs;\n       struct constraint_expr rhs = c->rhs;\n@@ -1359,7 +1359,7 @@ build_succ_graph (void)\n   unsigned i, t;\n   constraint_t c;\n \n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, constraints, i, c)\n     {\n       struct constraint_expr lhs;\n       struct constraint_expr rhs;\n@@ -2437,7 +2437,7 @@ move_complex_constraints (constraint_graph_t graph)\n   int i;\n   constraint_t c;\n \n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, constraints, i, c)\n     {\n       if (c)\n \t{\n@@ -2478,7 +2478,7 @@ rewrite_constraints (constraint_graph_t graph,\n   for (j = 0; j < graph->size; j++)\n     gcc_assert (find (j) == j);\n \n-  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (constraint_t, constraints, i, c)\n     {\n       struct constraint_expr lhs = c->lhs;\n       struct constraint_expr rhs = c->rhs;\n@@ -2654,7 +2654,7 @@ solve_graph (constraint_graph_t graph)\n \t      solution_empty = bitmap_empty_p (solution);\n \n \t      /* Process the complex constraints */\n-\t      for (j = 0; VEC_iterate (constraint_t, complex, j, c); j++)\n+\t      FOR_EACH_VEC_ELT (constraint_t, complex, j, c)\n \t\t{\n \t\t  /* XXX: This is going to unsort the constraints in\n \t\t     some cases, which will occasionally add duplicate\n@@ -3239,7 +3239,7 @@ do_deref (VEC (ce_s, heap) **constraints)\n   struct constraint_expr *c;\n   unsigned int i = 0;\n \n-  for (i = 0; VEC_iterate (ce_s, *constraints, i, c); i++)\n+  FOR_EACH_VEC_ELT (ce_s, *constraints, i, c)\n     {\n       if (c->type == SCALAR)\n \tc->type = DEREF;\n@@ -3270,7 +3270,7 @@ get_constraint_for_address_of (tree t, VEC (ce_s, heap) **results)\n \n   get_constraint_for_1 (t, results, true);\n \n-  for (i = 0; VEC_iterate (ce_s, *results, i, c); i++)\n+  FOR_EACH_VEC_ELT (ce_s, *results, i, c)\n     {\n       if (c->type == DEREF)\n \tc->type = SCALAR;\n@@ -3383,7 +3383,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n \t\t  struct constraint_expr *rhsp;\n \t\t  unsigned j;\n \t\t  get_constraint_for_1 (val, &tmp, address_p);\n-\t\t  for (j = 0; VEC_iterate (ce_s, tmp, j, rhsp); ++j)\n+\t\t  FOR_EACH_VEC_ELT (ce_s, tmp, j, rhsp)\n \t\t    VEC_safe_push (ce_s, heap, *results, rhsp);\n \t\t  VEC_truncate (ce_s, tmp, 0);\n \t\t}\n@@ -3435,17 +3435,17 @@ process_all_all_constraints (VEC (ce_s, heap) *lhsc, VEC (ce_s, heap) *rhsc)\n   if (VEC_length (ce_s, lhsc) <= 1\n       || VEC_length (ce_s, rhsc) <= 1)\n     {\n-      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n-\tfor (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); ++j)\n+      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n+\tFOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n \t  process_constraint (new_constraint (*lhsp, *rhsp));\n     }\n   else\n     {\n       struct constraint_expr tmp;\n       tmp = new_scalar_tmp_constraint_exp (\"allalltmp\");\n-      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \tprocess_constraint (new_constraint (tmp, *rhsp));\n-      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n \tprocess_constraint (new_constraint (*lhsp, tmp));\n     }\n }\n@@ -3532,7 +3532,7 @@ make_constraint_to (unsigned id, tree op)\n   includes.type = SCALAR;\n \n   get_constraint_for (op, &rhsc);\n-  for (j = 0; VEC_iterate (ce_s, rhsc, j, c); j++)\n+  FOR_EACH_VEC_ELT (ce_s, rhsc, j, c)\n     process_constraint (new_constraint (includes, *c));\n   VEC_free (ce_s, heap, rhsc);\n }\n@@ -3795,7 +3795,7 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n       lhsc.var = escaped_id;\n       lhsc.offset = 0;\n       lhsc.type = SCALAR;\n-      for (i = 0; VEC_iterate (ce_s, tmpc, i, c); ++i)\n+      FOR_EACH_VEC_ELT (ce_s, tmpc, i, c)\n \tprocess_constraint (new_constraint (lhsc, *c));\n       VEC_free(ce_s, heap, tmpc);\n     }\n@@ -3905,7 +3905,7 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n \t  unsigned i;\n \t  struct constraint_expr *argp;\n \t  get_constraint_for (arg, &argc);\n-\t  for (i = 0; VEC_iterate (ce_s, argc, i, argp); ++i)\n+\t  FOR_EACH_VEC_ELT (ce_s, argc, i, argp)\n \t    VEC_safe_push (ce_s, heap, *results, argp);\n \t  VEC_free(ce_s, heap, argc);\n \t}\n@@ -4040,7 +4040,7 @@ find_func_aliases (gimple origt)\n \t      STRIP_NOPS (strippedrhs);\n \t      get_constraint_for (gimple_phi_arg_def (t, i), &rhsc);\n \n-\t      for (j = 0; VEC_iterate (ce_s, lhsc, j, c); j++)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, c)\n \t\t{\n \t\t  struct constraint_expr *c2;\n \t\t  while (VEC_length (ce_s, rhsc) > 0)\n@@ -4141,7 +4141,7 @@ find_func_aliases (gimple origt)\n \t\t  ac.var = integer_id;\n \t\t}\n \t      ac.offset = 0;\n-\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n \t\tprocess_constraint (new_constraint (*lhsp, ac));\n \t      VEC_free (ce_s, heap, lhsc);\n \t      return;\n@@ -4187,7 +4187,7 @@ find_func_aliases (gimple origt)\n \t\t    {\n \t\t      lhs = get_function_part_constraint (nfi, fi_static_chain);\n \t\t      get_constraint_for (frame, &rhsc);\n-\t\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t\t      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t\t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t\t      VEC_free (ce_s, heap, rhsc);\n \n@@ -4239,7 +4239,7 @@ find_func_aliases (gimple origt)\n \t\t  do_deref (&lhsc);\n \t\t  rhs = get_function_part_constraint (fi, ~0);\n \t\t  rhs.type = ADDRESSOF;\n-\t\t  for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\t\t  FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n \t\t    process_constraint (new_constraint (*lhsp, rhs));\n \t\t  VEC_free (ce_s, heap, lhsc);\n \t\t  /* va_list is clobbered.  */\n@@ -4352,7 +4352,7 @@ find_func_aliases (gimple origt)\n \t\t  rhs = *VEC_index (ce_s, tem, 0);\n \t\t  VEC_free(ce_s, heap, tem);\n \t\t}\n-\t      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, lhsp)\n \t\tprocess_constraint (new_constraint (*lhsp, rhs));\n \t    }\n \n@@ -4367,7 +4367,7 @@ find_func_aliases (gimple origt)\n \n \t      get_constraint_for_address_of (lhsop, &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_result);\n-\t      for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t      FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t      VEC_free (ce_s, heap, rhsc);\n \t    }\n@@ -4380,7 +4380,7 @@ find_func_aliases (gimple origt)\n \n \t      get_constraint_for (gimple_call_chain (t), &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_static_chain);\n-\t      for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t      FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t    }\n \t}\n@@ -4469,7 +4469,7 @@ find_func_aliases (gimple origt)\n \n \t  lhs = get_function_part_constraint (fi, fi_result);\n \t  get_constraint_for (gimple_return_retval (t), &rhsc);\n-\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t}\n     }\n@@ -4509,7 +4509,7 @@ find_func_aliases (gimple origt)\n \t      rhsc.var = nonlocal_id;\n \t      rhsc.offset = 0;\n \t      rhsc.type = SCALAR;\n-\t      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, j, lhsp)\n \t\tprocess_constraint (new_constraint (*lhsp, rhsc));\n \t      VEC_free (ce_s, heap, lhsc);\n \t    }\n@@ -4551,7 +4551,7 @@ process_ipa_clobber (varinfo_t fi, tree ptr)\n   unsigned i;\n   get_constraint_for (ptr, &ptrc);\n   lhs = get_function_part_constraint (fi, fi_clobbers);\n-  for (i = 0; VEC_iterate (ce_s, ptrc, i, c); i++)\n+  FOR_EACH_VEC_ELT (ce_s, ptrc, i, c)\n     process_constraint (new_constraint (lhs, *c));\n   VEC_free (ce_s, heap, ptrc);\n }\n@@ -4602,7 +4602,7 @@ find_func_clobbers (gimple origt)\n \t  unsigned i;\n \t  lhsc = get_function_part_constraint (fi, fi_clobbers);\n \t  get_constraint_for_address_of (lhs, &rhsc);\n-\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhsc, *rhsp));\n \t  VEC_free (ce_s, heap, rhsc);\n \t}\n@@ -4630,7 +4630,7 @@ find_func_clobbers (gimple origt)\n \t  unsigned i;\n \t  lhs = get_function_part_constraint (fi, fi_uses);\n \t  get_constraint_for_address_of (rhs, &rhsc);\n-\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t  VEC_free (ce_s, heap, rhsc);\n \t}\n@@ -4670,12 +4670,12 @@ find_func_clobbers (gimple origt)\n \t      struct constraint_expr *rhsp, *lhsp;\n \t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n \t      lhs = get_function_part_constraint (fi, fi_clobbers);\n-\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); i++)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n \t\tprocess_constraint (new_constraint (lhs, *lhsp));\n \t      VEC_free (ce_s, heap, lhsc);\n \t      get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_uses);\n-\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); i++)\n+\t      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t      VEC_free (ce_s, heap, rhsc);\n \t      return;\n@@ -4689,7 +4689,7 @@ find_func_clobbers (gimple origt)\n \t      ce_s *lhsp;\n \t      get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n \t      lhs = get_function_part_constraint (fi, fi_clobbers);\n-\t      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); i++)\n+\t      FOR_EACH_VEC_ELT (ce_s, lhsc, i, lhsp)\n \t\tprocess_constraint (new_constraint (lhs, *lhsp));\n \t      VEC_free (ce_s, heap, lhsc);\n \t      return;\n@@ -4758,7 +4758,7 @@ find_func_clobbers (gimple origt)\n \t    continue;\n \n \t  get_constraint_for_address_of (arg, &rhsc);\n-\t  for (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); j++)\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, j, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t  VEC_free (ce_s, heap, rhsc);\n \t}\n@@ -5269,7 +5269,7 @@ check_for_overlaps (VEC (fieldoff_s,heap) *fieldstack)\n   unsigned int i;\n   HOST_WIDE_INT lastoffset = -1;\n \n-  for (i = 0; VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n+  FOR_EACH_VEC_ELT (fieldoff_s, fieldstack, i, fo)\n     {\n       if (fo->offset == lastoffset)\n \treturn true;\n@@ -5434,7 +5434,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  lhs.var = vi->id;\n \t  lhs.offset = 0;\n \t  lhs.type = SCALAR;\n-\t  for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n \t  /* If this is a variable that escapes from the unit\n \t     the initializer escapes as well.  */\n@@ -5443,7 +5443,7 @@ create_variable_info_for (tree decl, const char *name)\n \t      lhs.var = escaped_id;\n \t      lhs.offset = 0;\n \t      lhs.type = SCALAR;\n-\t      for (i = 0; VEC_iterate (ce_s, rhsc, i, rhsp); ++i)\n+\t      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n \t    }\n \t  VEC_free (ce_s, heap, rhsc);\n@@ -6468,7 +6468,7 @@ compute_points_to_sets (void)\n   cfun->gimple_df->escaped.escaped = 0;\n \n   /* Mark escaped HEAP variables as global.  */\n-  for (i = 0; VEC_iterate (varinfo_t, varmap, i, vi); ++i)\n+  FOR_EACH_VEC_ELT (varinfo_t, varmap, i, vi)\n     if (vi->is_heap_var\n \t&& !vi->is_restrict_var\n \t&& !vi->is_global_var)\n@@ -6846,7 +6846,7 @@ ipa_pta_execute (void)\n       fn = DECL_STRUCT_FUNCTION (node->decl);\n \n       /* Compute the points-to sets for pointer SSA_NAMEs.  */\n-      for (i = 0; VEC_iterate (tree, fn->gimple_df->ssa_names, i, ptr); ++i)\n+      FOR_EACH_VEC_ELT (tree, fn->gimple_df->ssa_names, i, ptr)\n \t{\n \t  if (ptr\n \t      && POINTER_TYPE_P (TREE_TYPE (ptr)))"}, {"sha": "16f85f5d8688a7fe14aa0da09cf61f6e96a68ec4", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2040,7 +2040,7 @@ execute_update_addresses_taken (bool do_optimize)\n \t differences for -g vs. -g0.  */\n       for (var = DECL_ARGUMENTS (cfun->decl); var; var = DECL_CHAIN (var))\n \tupdate_vops |= maybe_optimize_var (var, addresses_taken, not_reg_needs);\n-      for (i = 0; VEC_iterate (tree, cfun->local_decls, i, var); ++i)\n+      FOR_EACH_VEC_ELT (tree, cfun->local_decls, i, var)\n \tupdate_vops |= maybe_optimize_var (var, addresses_taken, not_reg_needs);\n     }\n "}, {"sha": "2408b45535eeb919fffb9502fe8135e9c642f176", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -595,7 +595,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     }\n \n   loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n-  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n+  FOR_EACH_VEC_ELT (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v)\n     {\n       int dist = dist_v[loop_depth];\n \n@@ -692,7 +692,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n   else\n     ddrs = BB_VINFO_DDRS (bb_vinfo);\n \n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n     if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, max_vf))\n       return false;\n \n@@ -866,7 +866,7 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo,\n   else\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr)))\n         && !vect_compute_data_ref_alignment (dr))\n       {\n@@ -915,7 +915,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n      are aligned in the vector loop.  */\n   same_align_drs\n     = STMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr_peel)));\n-  for (i = 0; VEC_iterate (dr_p, same_align_drs, i, current_dr); i++)\n+  FOR_EACH_VEC_ELT (dr_p, same_align_drs, i, current_dr)\n     {\n       if (current_dr != dr)\n         continue;\n@@ -960,7 +960,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   else\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       gimple stmt = DR_STMT (dr);\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1186,7 +1186,7 @@ vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n@@ -1397,7 +1397,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n      - The cost of peeling (the extra runtime checks, the increase\n        in code size).  */\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n@@ -1643,7 +1643,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n-      for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+      FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n         {\n           int save_misalignment;\n \n@@ -1688,7 +1688,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n              by the peeling factor times the element size of DR_i (MOD the\n              vectorization factor times the size).  Otherwise, the\n              misalignment of DR_i must be set to unknown.  */\n-\t  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+\t  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n \t    if (dr != dr0)\n \t      vect_update_misalignment_for_peel (dr, dr0, npeel);\n \n@@ -1728,7 +1728,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (do_versioning)\n     {\n-      for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+      FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n         {\n \t  stmt = DR_STMT (dr);\n \t  stmt_info = vinfo_for_stmt (stmt);\n@@ -1797,7 +1797,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* It can now be assumed that the data references in the statements\n          in LOOP_VINFO_MAY_MISALIGN_STMTS will be aligned in the version\n          of the loop being vectorized.  */\n-      for (i = 0; VEC_iterate (gimple, may_misalign_stmts, i, stmt); i++)\n+      FOR_EACH_VEC_ELT (gimple, may_misalign_stmts, i, stmt)\n         {\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           dr = STMT_VINFO_DATA_REF (stmt_info);\n@@ -1860,7 +1860,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n     return;\n \n   loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n-  for (i = 0; VEC_iterate (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v); i++)\n+  FOR_EACH_VEC_ELT (lambda_vector, DDR_DIST_VECTS (ddr), i, dist_v)\n     {\n       int dist = dist_v[loop_depth];\n \n@@ -1908,7 +1908,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n       struct data_dependence_relation *ddr;\n       unsigned int i;\n \n-      for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+      FOR_EACH_VEC_ELT (ddr_p, ddrs, i, ddr)\n \tvect_find_same_alignment_drs (ddr, loop_vinfo);\n     }\n \n@@ -2254,7 +2254,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   else\n     datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n         && !vect_analyze_data_ref_access (dr))\n       {\n@@ -2415,7 +2415,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   /* Go through the data-refs, check that the analysis succeeded. Update pointer\n      from stmt_vec_info struct to DR and vectype.  */\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     {\n       gimple stmt;\n       stmt_vec_info stmt_info;\n@@ -3890,7 +3890,7 @@ vect_transform_strided_load (gimple stmt, VEC(tree,heap) *dr_chain, int size,\n      corresponds the order of data-refs in RESULT_CHAIN.  */\n   next_stmt = first_stmt;\n   gap_count = 1;\n-  for (i = 0; VEC_iterate (tree, result_chain, i, tmp_data_ref); i++)\n+  FOR_EACH_VEC_ELT (tree, result_chain, i, tmp_data_ref)\n     {\n       if (!next_stmt)\n \tbreak;"}, {"sha": "5771c51235d5167b8fd6199e482193a43224916d", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -2105,7 +2105,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_update_inits_of_dr ===\");\n \n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+  FOR_EACH_VEC_ELT (data_reference_p, datarefs, i, dr)\n     vect_update_init_of_dr (dr, niters);\n }\n \n@@ -2229,7 +2229,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   /* Create expression (mask & (dr_1 || ... || dr_n)) where dr_i is the address\n      of the first vector of the i'th data reference. */\n \n-  for (i = 0; VEC_iterate (gimple, may_misalign_stmts, i, ref_stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, may_misalign_stmts, i, ref_stmt)\n     {\n       gimple_seq new_stmt_list = NULL;\n       tree addr_base;\n@@ -2380,7 +2380,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n   if (VEC_empty (ddr_p, may_alias_ddrs))\n     return;\n \n-  for (i = 0; VEC_iterate (ddr_p, may_alias_ddrs, i, ddr); i++)\n+  FOR_EACH_VEC_ELT (ddr_p, may_alias_ddrs, i, ddr)\n     {\n       struct data_reference *dr_a, *dr_b;\n       gimple dr_group_first_a, dr_group_first_b;"}, {"sha": "371d30d72d988772521136faf4727a2f11673c54", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -840,7 +840,7 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   VEC_free (gimple, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n   VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n   slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  for (j = 0; VEC_iterate (slp_instance, slp_instances, j, instance); j++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, j, instance)\n     vect_free_slp_instance (instance);\n \n   VEC_free (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n@@ -2330,7 +2330,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   /* Add SLP costs.  */\n   slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n       vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n@@ -3179,7 +3179,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n     }\n \n   /* Set phi nodes arguments.  */\n-  for (i = 0; VEC_iterate (gimple, reduction_phis, i, phi); i++)\n+  FOR_EACH_VEC_ELT (gimple, reduction_phis, i, phi)\n     {\n       tree vec_init_def = VEC_index (tree, vec_initial_defs, i);\n       tree def = VEC_index (tree, vect_defs, i);\n@@ -3245,7 +3245,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n   exit_bb = single_exit (loop)->dest;\n   prev_phi_info = NULL;\n   new_phis = VEC_alloc (gimple, heap, VEC_length (tree, vect_defs));\n-  for (i = 0; VEC_iterate (tree, vect_defs, i, def); i++)\n+  FOR_EACH_VEC_ELT (tree, vect_defs, i, def)\n     {\n       for (j = 0; j < ncopies; j++)\n         {\n@@ -3424,7 +3424,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n             fprintf (vect_dump, \"Reduce using scalar code. \");\n \n           vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n-          for (i = 0; VEC_iterate (gimple, new_phis, i, new_phi); i++)\n+          FOR_EACH_VEC_ELT (gimple, new_phis, i, new_phi)\n             {\n               vec_temp = PHI_RESULT (new_phi);\n               rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n@@ -3647,7 +3647,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n          form.  */\n       gcc_assert (!VEC_empty (gimple, phis));\n \n-      for (i = 0; VEC_iterate (gimple, phis, i, exit_phi); i++)\n+      FOR_EACH_VEC_ELT (gimple, phis, i, exit_phi)\n         {\n           if (outer_loop)\n             {\n@@ -3786,7 +3786,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n             }\n         }\n \n-      for (i = 0; VEC_iterate (gimple, phis, i, exit_phi); i++)\n+      FOR_EACH_VEC_ELT (gimple, phis, i, exit_phi)\n         {\n           /* Replace the uses:  */\n           orig_name = PHI_RESULT (exit_phi);\n@@ -4346,7 +4346,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           STMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n         }\n \n-      for (i = 0; VEC_iterate (tree, vec_oprnds0, i, def0); i++)\n+      FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, def0)\n         {\n           if (slp_node)\n             reduc_def = PHI_RESULT (VEC_index (gimple, phis, i));"}, {"sha": "0d5824c97737b107196381a7e667cc5c424f939f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -746,9 +746,7 @@ vect_pattern_recog_1 (\n \n   /* Patterns cannot be vectorized using SLP, because they change the order of\n      computation.  */\n-  for (i = 0; VEC_iterate (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i,\n-                           next);\n-       i++)\n+  FOR_EACH_VEC_ELT (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i, next)\n     if (next == stmt)\n       VEC_ordered_remove (gimple, LOOP_VINFO_REDUCTIONS (loop_vinfo), i); \n }"}, {"sha": "135e1cbcaf1cb171bd120733d0f67c89cf9c5aca", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -337,7 +337,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   gimple first_load, prev_first_load = NULL;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n-  for (i = 0; VEC_iterate (gimple, stmts, i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n     {\n       if (vect_print_dump_info (REPORT_SLP))\n \t{\n@@ -715,7 +715,7 @@ vect_print_slp_tree (slp_tree node)\n     return;\n \n   fprintf (vect_dump, \"node \");\n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       fprintf (vect_dump, \"\\n\\tstmt %d \", i);\n       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n@@ -741,7 +741,7 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n   if (!node)\n     return;\n \n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     if (j < 0 || i == j)\n       STMT_SLP_TYPE (vinfo_for_stmt (stmt)) = mark;\n \n@@ -762,7 +762,7 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n   if (!node)\n     return;\n \n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       stmt_info = vinfo_for_stmt (stmt);\n       gcc_assert (!STMT_VINFO_RELEVANT (stmt_info)\n@@ -857,7 +857,7 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   for (i = 0; i < group_size; i++)\n     VEC_safe_push (gimple, heap, tmp_stmts, NULL);\n \n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       index = VEC_index (int, permutation, i);\n       VEC_replace (gimple, tmp_stmts, index, stmt);\n@@ -891,7 +891,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   if (vect_print_dump_info (REPORT_SLP))\n     {\n       fprintf (vect_dump, \"Load permutation \");\n-      for (i = 0; VEC_iterate (int, load_permutation, i, next); i++)\n+      FOR_EACH_VEC_ELT (int, load_permutation, i, next)\n         fprintf (vect_dump, \"%d \", next);\n     }\n \n@@ -903,9 +903,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n      permutation).  */\n \n   /* Check that all the load nodes are of the same size.  */\n-  for (i = 0;\n-       VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node);\n-       i++)\n+  FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node)\n     {\n       if (VEC_length (gimple, SLP_TREE_SCALAR_STMTS (node))\n           != (unsigned) group_size)\n@@ -926,13 +924,9 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n      chains are mixed, they match the above pattern.  */\n   if (complex_numbers)\n     {\n-      for (i = 0;\n-           VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node);\n-           i++)\n+      FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node)\n         {\n-          for (j = 0;\n-               VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), j, stmt);\n-               j++)\n+\t  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), j, stmt)\n             {\n               if (j == 0)\n                 first = stmt;\n@@ -1080,12 +1074,8 @@ vect_find_first_load_in_slp_instance (slp_instance instance)\n   slp_tree load_node;\n   gimple first_load = NULL, load;\n \n-  for (i = 0;\n-       VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (instance), i, load_node);\n-       i++)\n-    for (j = 0;\n-         VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (load_node), j, load);\n-         j++)\n+  FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (instance), i, load_node)\n+    FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (load_node), j, load)\n       first_load = get_earlier_stmt (load, first_load);\n \n   return first_load;\n@@ -1289,7 +1279,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     strided_stores = BB_VINFO_STRIDED_STORES (bb_vinfo);\n \n   /* Find SLP sequences starting from groups of strided stores.  */\n-  for (i = 0; VEC_iterate (gimple, strided_stores, i, store); i++)\n+  FOR_EACH_VEC_ELT (gimple, strided_stores, i, store)\n     if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, store))\n       ok = true;\n \n@@ -1325,7 +1315,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_make_slp_decision ===\");\n \n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       /* FORNOW: SLP if you can.  */\n       if (unrolling_factor < SLP_INSTANCE_UNROLLING_FACTOR (instance))\n@@ -1361,7 +1351,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node)\n   if (!node)\n     return;\n \n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     if (PURE_SLP_STMT (vinfo_for_stmt (stmt))\n \t&& TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))\n@@ -1391,7 +1381,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_detect_hybrid_slp ===\");\n \n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n }\n \n@@ -1471,7 +1461,7 @@ vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n       || !vect_slp_analyze_node_operations (bb_vinfo, SLP_TREE_RIGHT (node)))\n     return false;\n \n-  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n       gcc_assert (stmt_info);\n@@ -1532,7 +1522,7 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   int dummy = 0;\n \n   /* Calculate vector costs.  */\n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n       vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n@@ -1699,7 +1689,7 @@ vect_slp_analyze_bb (basic_block bb)\n \n   /* Mark all the statements that we want to vectorize as pure SLP and\n      relevant.  */\n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n       vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n@@ -1750,7 +1740,7 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_update_slp_costs_according_to_vf ===\");\n \n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     /* We assume that costs are linear in ncopies.  */\n     SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance) *= vf\n       / SLP_INSTANCE_UNROLLING_FACTOR (instance);\n@@ -1965,9 +1955,7 @@ vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n \n   gcc_assert (SLP_TREE_VEC_STMTS (slp_node));\n \n-  for (i = 0;\n-       VEC_iterate (gimple, SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt);\n-       i++)\n+  FOR_EACH_VEC_ELT (gimple, SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt)\n     {\n       gcc_assert (vec_def_stmt);\n       vec_oprnd = gimple_get_lhs (vec_def_stmt);\n@@ -2281,10 +2269,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n      we need the second and the third vectors: {b1,c1,a2,b2} and\n      {c2,a3,b3,c3}.  */\n \n-  for (i = 0;\n-       VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (slp_node_instance),\n-                    i, node);\n-       i++)\n+  FOR_EACH_VEC_ELT  (slp_tree, SLP_INSTANCE_LOADS (slp_node_instance), i, node)\n     {\n       scalar_index = 0;\n       index = 0;\n@@ -2404,9 +2389,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n      all the nodes that participate in that permutation.  */\n   if (SLP_INSTANCE_LOAD_PERMUTATION (instance))\n     {\n-      for (i = 0;\n-           VEC_iterate (slp_tree, SLP_INSTANCE_LOADS (instance), i, loads_node);\n-           i++)\n+      FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (instance), i, loads_node)\n         {\n           if (!SLP_TREE_VEC_STMTS (loads_node))\n             {\n@@ -2461,7 +2444,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       vf = 1;\n     }\n \n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n@@ -2471,7 +2454,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n     }\n \n-  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+  FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n     {\n       slp_tree root = SLP_INSTANCE_TREE (instance);\n       gimple store;"}, {"sha": "433416d555e7cb91299b7d2db19bba5c847aee99", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1803,7 +1803,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  builtin_decl =\n \t    targetm.vectorize.builtin_conversion (code,\n \t\t\t\t\t\t  vectype_out, vectype_in);\n-\t  for (i = 0; VEC_iterate (tree, vec_oprnds0, i, vop0); i++)\n+\t  FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n \t    {\n \t      /* Arguments are ready. create the new vector stmt.  */\n \t      new_stmt = gimple_build_call (builtin_decl, 1, vop0);\n@@ -2004,7 +2004,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n \n       /* Arguments are ready. create the new vector stmt.  */\n-      for (i = 0; VEC_iterate (tree, vec_oprnds, i, vop); i++)\n+      FOR_EACH_VEC_ELT (tree, vec_oprnds, i, vop)\n        {\n \t if (CONVERT_EXPR_CODE_P (code))\n \t   vop = build1 (VIEW_CONVERT_EXPR, vectype, vop);\n@@ -2382,7 +2382,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \tvect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n \n       /* Arguments are ready. Create the new vector stmt.  */\n-      for (i = 0; VEC_iterate (tree, vec_oprnds0, i, vop0); i++)\n+      FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n         {\n \t  vop1 = ((op_type == binary_op)\n \t\t  ? VEC_index (tree, vec_oprnds1, i) : NULL);\n@@ -2722,7 +2722,7 @@ vect_create_vectorized_promotion_stmts (VEC (tree, heap) **vec_oprnds0,\n   vec_dest = VEC_pop (tree, vec_dsts);\n   vec_tmp = VEC_alloc (tree, heap, VEC_length (tree, *vec_oprnds0) * 2);\n \n-  for (i = 0; VEC_iterate (tree, *vec_oprnds0, i, vop0); i++)\n+  FOR_EACH_VEC_ELT (tree, *vec_oprnds0, i, vop0)\n     {\n       if (op_type == binary_op)\n         vop1 = VEC_index (tree, *vec_oprnds1, i);"}, {"sha": "c5f146831c46ab4ee82b14c8fb53847028c0bbd5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -7470,7 +7470,7 @@ identify_jump_threads (void)\n \n   /* Do not thread across edges we are about to remove.  Just marking\n      them as EDGE_DFS_BACK will do.  */\n-  for (i = 0; VEC_iterate (edge, to_remove_edges, i, e); ++i)\n+  FOR_EACH_VEC_ELT (edge, to_remove_edges, i, e)\n     e->flags |= EDGE_DFS_BACK;\n \n   /* Allocate our unwinder stack to unwind any temporary equivalences\n@@ -7676,10 +7676,10 @@ execute_vrp (void)\n \n   /* Remove dead edges from SWITCH_EXPR optimization.  This leaves the\n      CFG in a broken state and requires a cfg_cleanup run.  */\n-  for (i = 0; VEC_iterate (edge, to_remove_edges, i, e); ++i)\n+  FOR_EACH_VEC_ELT (edge, to_remove_edges, i, e)\n     remove_edge (e);\n   /* Update SWITCH_EXPR case label vector.  */\n-  for (i = 0; VEC_iterate (switch_update, to_update_switch_stmts, i, su); ++i)\n+  FOR_EACH_VEC_ELT (switch_update, to_update_switch_stmts, i, su)\n     {\n       size_t j;\n       size_t n = TREE_VEC_LENGTH (su->vec);"}, {"sha": "4ad2f5b12357281e222666bbf3ff01ec71fe7ff4", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1371,7 +1371,7 @@ build_constructor (tree type, VEC(constructor_elt,gc) *vals)\n   TREE_TYPE (c) = type;\n   CONSTRUCTOR_ELTS (c) = vals;\n \n-  for (i = 0; VEC_iterate (constructor_elt, vals, i, elt); i++)\n+  FOR_EACH_VEC_ELT (constructor_elt, vals, i, elt)\n     if (!TREE_CONSTANT (elt->value))\n       {\n \tconstant_p = false;\n@@ -1970,7 +1970,7 @@ vec_member (const_tree elem, VEC(tree,gc) *v)\n {\n   unsigned ix;\n   tree t;\n-  for (ix = 0; VEC_iterate (tree, v, ix, t); ix++)\n+  FOR_EACH_VEC_ELT (tree, v, ix, t)\n     if (elem == t)\n       return true;\n   return false;\n@@ -2137,7 +2137,7 @@ build_tree_list_vec_stat (const VEC(tree,gc) *vec MEM_STAT_DECL)\n   tree *pp = &ret;\n   unsigned int i;\n   tree t;\n-  for (i = 0; VEC_iterate (tree, vec, i, t); ++i)\n+  FOR_EACH_VEC_ELT (tree, vec, i, t)\n     {\n       *pp = build_tree_list_stat (NULL, t PASS_MEM_STAT);\n       pp = &TREE_CHAIN (*pp);\n@@ -2915,7 +2915,7 @@ push_without_duplicates (tree exp, VEC (tree, heap) **queue)\n   unsigned int i;\n   tree iter;\n \n-  for (i = 0; VEC_iterate (tree, *queue, i, iter); i++)\n+  FOR_EACH_VEC_ELT (tree, *queue, i, iter)\n     if (simple_cst_equal (iter, exp) == 1)\n       break;\n \n@@ -3975,7 +3975,7 @@ build_nt_call_vec (tree fn, VEC(tree,gc) *args)\n   ret = build_vl_exp (CALL_EXPR, VEC_length (tree, args) + 3);\n   CALL_EXPR_FN (ret) = fn;\n   CALL_EXPR_STATIC_CHAIN (ret) = NULL_TREE;\n-  for (ix = 0; VEC_iterate (tree, args, ix, t); ++ix)\n+  FOR_EACH_VEC_ELT (tree, args, ix, t)\n     CALL_EXPR_ARG (ret, ix) = t;\n   return ret;\n }\n@@ -4254,7 +4254,7 @@ free_lang_data_in_binfo (tree binfo)\n   BINFO_INHERITANCE_CHAIN (binfo) = NULL_TREE;\n   BINFO_SUBVTT_INDEX (binfo) = NULL_TREE;\n \n-  for (i = 0; VEC_iterate (tree, BINFO_BASE_BINFOS (binfo), i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, BINFO_BASE_BINFOS (binfo), i, t)\n     free_lang_data_in_binfo (t);\n }\n \n@@ -5020,7 +5020,7 @@ free_lang_data_in_cgraph (void)\n   for (n = cgraph_nodes; n; n = n->next)\n     find_decls_types_in_node (n, &fld);\n \n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     find_decls_types (p->decl, &fld);\n \n   /* Find decls and types in every varpool symbol.  */\n@@ -5030,15 +5030,15 @@ free_lang_data_in_cgraph (void)\n   /* Set the assembler name on every decl found.  We need to do this\n      now because free_lang_data_in_decl will invalidate data needed\n      for mangling.  This breaks mangling on interdependent decls.  */\n-  for (i = 0; VEC_iterate (tree, fld.decls, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, fld.decls, i, t)\n     assign_assembler_name_if_neeeded (t);\n \n   /* Traverse every decl found freeing its language data.  */\n-  for (i = 0; VEC_iterate (tree, fld.decls, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, fld.decls, i, t)\n     free_lang_data_in_decl (t);\n \n   /* Traverse every type found freeing its language data.  */\n-  for (i = 0; VEC_iterate (tree, fld.types, i, t); i++)\n+  FOR_EACH_VEC_ELT (tree, fld.types, i, t)\n     free_lang_data_in_type (t);\n \n   pointer_set_destroy (fld.pset);\n@@ -9663,7 +9663,7 @@ build_call_vec (tree return_type, tree fn, VEC(tree,gc) *args)\n   TREE_TYPE (ret) = return_type;\n   CALL_EXPR_FN (ret) = fn;\n   CALL_EXPR_STATIC_CHAIN (ret) = NULL_TREE;\n-  for (ix = 0; VEC_iterate (tree, args, ix, t); ++ix)\n+  FOR_EACH_VEC_ELT (tree, args, ix, t)\n     CALL_EXPR_ARG (ret, ix) = t;\n   process_call_operands (ret);\n   return ret;"}, {"sha": "84956cdbac559286c2a749a45fbc182e096b0bc4", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1648,7 +1648,7 @@ gimple_find_values_to_profile (histogram_values *values)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       gimple_values_to_profile (gsi_stmt (gsi), values);\n \n-  for (i = 0; VEC_iterate (histogram_value, *values, i, hist); i++)\n+  FOR_EACH_VEC_ELT (histogram_value, *values, i, hist)\n     {\n       switch (hist->type)\n         {"}, {"sha": "ec402acf487a0618a2d20edd373adc075d5f46a8", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -5758,7 +5758,7 @@ compute_bb_dataflow (basic_block bb)\n   dataflow_set_copy (&old_out, out);\n   dataflow_set_copy (out, in);\n \n-  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n+  FOR_EACH_VEC_ELT (micro_operation, VTI (bb)->mos, i, mo)\n     {\n       rtx insn = mo->insn;\n \n@@ -7683,7 +7683,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n   dataflow_set_clear (set);\n   dataflow_set_copy (set, &VTI (bb)->in);\n \n-  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n+  FOR_EACH_VEC_ELT (micro_operation, VTI (bb)->mos, i, mo)\n     {\n       rtx insn = mo->insn;\n \n@@ -7978,7 +7978,7 @@ vt_emit_notes (void)\n       unsigned int i;\n       rtx val;\n \n-      for (i = 0; VEC_iterate (rtx, preserved_values, i, val); i++)\n+      FOR_EACH_VEC_ELT (rtx, preserved_values, i, val)\n \tadd_cselib_value_chains (dv_from_value (val));\n       changed_variables_stack = VEC_alloc (variable, heap, 40);\n       changed_values_stack = VEC_alloc (rtx, heap, 40);\n@@ -8008,7 +8008,7 @@ vt_emit_notes (void)\n       unsigned int i;\n       rtx val;\n \n-      for (i = 0; VEC_iterate (rtx, preserved_values, i, val); i++)\n+      FOR_EACH_VEC_ELT (rtx, preserved_values, i, val)\n \tremove_cselib_value_chains (dv_from_value (val));\n       gcc_assert (htab_elements (value_chains) == 0);\n     }"}, {"sha": "597bac69d2d22b1c5d1f57229637698e65cec450", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -5437,7 +5437,7 @@ finish_aliases_1 (void)\n   unsigned i;\n   alias_pair *p;\n \n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     {\n       tree target_decl;\n \n@@ -5470,7 +5470,7 @@ finish_aliases_2 (void)\n   unsigned i;\n   alias_pair *p;\n \n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); i++)\n+  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     do_assemble_alias (p->decl, p->target);\n \n   VEC_truncate (alias_pair, alias_pairs, 0);\n@@ -6715,12 +6715,12 @@ output_object_block (struct object_block *block)\n \n   /* Define the values of all anchors relative to the current section\n      position.  */\n-  for (i = 0; VEC_iterate (rtx, block->anchors, i, symbol); i++)\n+  FOR_EACH_VEC_ELT (rtx, block->anchors, i, symbol)\n     targetm.asm_out.output_anchor (symbol);\n \n   /* Output the objects themselves.  */\n   offset = 0;\n-  for (i = 0; VEC_iterate (rtx, block->objects, i, symbol); i++)\n+  FOR_EACH_VEC_ELT (rtx, block->objects, i, symbol)\n     {\n       /* Move to the object's offset, padding with zeros if necessary.  */\n       assemble_zeros (SYMBOL_REF_BLOCK_OFFSET (symbol) - offset);"}, {"sha": "1d2f067d8d5b77303112106f600290232ead0cba", "filename": "gcc/vec.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -190,6 +190,11 @@ along with GCC; see the file COPYING3.  If not see\n \n #define VEC_iterate(T,V,I,P)\t(VEC_OP(T,base,iterate)(VEC_BASE(V),I,&(P)))\n \n+/* Convenience macro for forward iteration.  */\n+\n+#define FOR_EACH_VEC_ELT(T, V, I, P)\t\t\\\n+  for (I = 0; VEC_iterate (T, (V), (I), (P)); ++(I))\n+\n /* Convenience macro for reverse iteration.  */\n \n #define FOR_EACH_VEC_ELT_REVERSE(T,V,I,P) \\"}, {"sha": "8ae5f2b6229c86278c315bb72425b7f16396a971", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac47786e993ddb3c50545230d13f57df891c0562/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=ac47786e993ddb3c50545230d13f57df891c0562", "patch": "@@ -1589,15 +1589,15 @@ vmsdbgout_finish (const char *main_input_filename ATTRIBUTE_UNUSED)\n   ASM_OUTPUT_ALIGN (asm_out_file, 0);\n \n   totsize = write_modbeg (1);\n-  for (i = 0; VEC_iterate (unsigned, funcnum_table, i, ifunc); i++)\n+  FOR_EACH_VEC_ELT (unsigned, funcnum_table, i, ifunc)\n     {\n       totsize += write_rtnbeg (i, 1);\n       totsize += write_rtnend (i, 1);\n     }\n   totsize += write_pclines (1);\n \n   write_modbeg (0);\n-  for (i = 0; VEC_iterate (unsigned, funcnum_table, i, ifunc); i++)\n+  FOR_EACH_VEC_ELT (unsigned, funcnum_table, i, ifunc)\n     {\n       write_rtnbeg (i, 0);\n       write_rtnend (i, 0);"}]}