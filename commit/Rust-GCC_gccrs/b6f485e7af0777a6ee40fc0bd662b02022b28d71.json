{"sha": "b6f485e7af0777a6ee40fc0bd662b02022b28d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmNDg1ZTdhZjA3NzdhNmVlNDBmYzBiZDY2MmIwMjAyMmIyOGQ3MQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2015-07-08T16:19:06Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2015-07-08T16:19:06Z"}, "message": "Don't pass/return vectors in registers for IAMCU\n\nVectors should be passed in memory for IAMCU.  No warning for vector ABI\nchange for IAMCU since IAMCU ABI won't change.\n\ngcc/\n\n\tPR target/66806\n\t* config/i386/i386.c (type_natural_mode): Don't warn vector ABI\n\tchange for IAMCU.\n\t(function_arg_advance_32): Don't pass vectors in registers for\n\tIAMCU.\n\t(function_arg_32): Likewise.\n\t(ix86_return_in_memory): Don't return vectors in registers for\n\tIAMCU.\n\ngcc/testsuite/\n\n\tPR target/66806\n\t* gcc.target/i386/pr66806.c: New test.\n\nFrom-SVN: r225564", "tree": {"sha": "40332ccc182cc332f0362a5fbc2bae56a291b642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40332ccc182cc332f0362a5fbc2bae56a291b642"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6f485e7af0777a6ee40fc0bd662b02022b28d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f485e7af0777a6ee40fc0bd662b02022b28d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f485e7af0777a6ee40fc0bd662b02022b28d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f485e7af0777a6ee40fc0bd662b02022b28d71/comments", "author": null, "committer": null, "parents": [{"sha": "529b9e5ad7f2f134dbcb7b3549bdb29e689c190c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529b9e5ad7f2f134dbcb7b3549bdb29e689c190c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/529b9e5ad7f2f134dbcb7b3549bdb29e689c190c"}], "stats": {"total": 82, "additions": 75, "deletions": 7}, "files": [{"sha": "55a32acc5814d2bca64fd1bcdafb880554019209", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f485e7af0777a6ee40fc0bd662b02022b28d71/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f485e7af0777a6ee40fc0bd662b02022b28d71/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b6f485e7af0777a6ee40fc0bd662b02022b28d71", "patch": "@@ -6685,7 +6685,7 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t    if (GET_MODE_NUNITS (mode) == TYPE_VECTOR_SUBPARTS (type)\n \t\t&& GET_MODE_INNER (mode) == innermode)\n \t      {\n-\t\tif (size == 64 && !TARGET_AVX512F)\n+\t\tif (size == 64 && !TARGET_AVX512F && !TARGET_IAMCU)\n \t\t  {\n \t\t    static bool warnedavx512f;\n \t\t    static bool warnedavx512f_ret;\n@@ -6705,7 +6705,7 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \n \t\t    return TYPE_MODE (type);\n \t\t  }\n-\t\telse if (size == 32 && !TARGET_AVX)\n+\t\telse if (size == 32 && !TARGET_AVX && !TARGET_IAMCU)\n \t\t  {\n \t\t    static bool warnedavx;\n \t\t    static bool warnedavx_ret;\n@@ -6726,7 +6726,8 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t\t    return TYPE_MODE (type);\n \t\t  }\n \t\telse if (((size == 8 && TARGET_64BIT) || size == 16)\n-\t\t\t && !TARGET_SSE)\n+\t\t\t && !TARGET_SSE\n+\t\t\t && !TARGET_IAMCU)\n \t\t  {\n \t\t    static bool warnedsse;\n \t\t    static bool warnedsse_ret;\n@@ -6744,7 +6745,9 @@ type_natural_mode (const_tree type, const CUMULATIVE_ARGS *cum,\n \t\t\t  warnedsse_ret = true;\n \t\t      }\n \t\t  }\n-\t\telse if ((size == 8 && !TARGET_64BIT) && !TARGET_MMX)\n+\t\telse if ((size == 8 && !TARGET_64BIT)\n+\t\t\t && !TARGET_MMX\n+\t\t\t && !TARGET_IAMCU)\n \t\t  {\n \t\t    static bool warnedmmx;\n \t\t    static bool warnedmmx_ret;\n@@ -7552,7 +7555,7 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n     {\n       /* Intel MCU psABI passes scalars and aggregates no larger than 8\n \t bytes in registers.  */\n-      if (bytes <= 8)\n+      if (!VECTOR_MODE_P (mode) && bytes <= 8)\n \tgoto pass_in_reg;\n       return res;\n     }\n@@ -7809,7 +7812,7 @@ function_arg_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n     {\n       /* Intel MCU psABI passes scalars and aggregates no larger than 8\n \t bytes in registers.  */\n-      if (bytes <= 8)\n+      if (!VECTOR_MODE_P (mode) && bytes <= 8)\n \tgoto pass_in_reg;\n       return NULL_RTX;\n     }\n@@ -8679,7 +8682,7 @@ ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n       /* Intel MCU psABI returns scalars and aggregates no larger than 8\n \t bytes in registers.  */\n       if (TARGET_IAMCU)\n-\treturn size > 8;\n+\treturn VECTOR_MODE_P (mode) || size > 8;\n \n       if (mode == BLKmode)\n \treturn true;"}, {"sha": "2486c5b5e71454f50ee2b4cf2d2479821c48be9b", "filename": "gcc/testsuite/gcc.target/i386/pr66806.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6f485e7af0777a6ee40fc0bd662b02022b28d71/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66806.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6f485e7af0777a6ee40fc0bd662b02022b28d71/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66806.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66806.c?ref=b6f485e7af0777a6ee40fc0bd662b02022b28d71", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-mno-sse -mno-mmx -miamcu\" } */\n+\n+/* AVX512F and AVX512BW modes.  */\n+typedef unsigned char V64QImode __attribute__((vector_size(64)));\n+typedef unsigned short V32HImode __attribute__((vector_size(64)));\n+typedef unsigned int V16SImode __attribute__((vector_size(64)));\n+typedef unsigned long long V8DImode __attribute__((vector_size(64)));\n+typedef float V16SFmode __attribute__((vector_size(64)));\n+typedef double V8DFmode __attribute__((vector_size(64)));\n+\n+/* AVX and AVX2 modes.  */\n+typedef unsigned char V32QImode __attribute__((vector_size(32)));\n+typedef unsigned short V16HImode __attribute__((vector_size(32)));\n+typedef unsigned int V8SImode __attribute__((vector_size(32)));\n+typedef unsigned long long V4DImode __attribute__((vector_size(32)));\n+typedef float V8SFmode __attribute__((vector_size(32)));\n+typedef double V4DFmode __attribute__((vector_size(32)));\n+\n+/* SSE1 and SSE2 modes.  */\n+typedef unsigned char V16QImode __attribute__((vector_size(16)));\n+typedef unsigned short V8HImode __attribute__((vector_size(16)));\n+typedef unsigned int V4SImode __attribute__((vector_size(16)));\n+typedef unsigned long long V2DImode __attribute__((vector_size(16)));\n+typedef float V4SFmode __attribute__((vector_size(16)));\n+typedef double V2DFmode __attribute__((vector_size(16)));\n+\n+/* MMX and 3DNOW modes.  */\n+typedef unsigned char V8QImode __attribute__((vector_size(8)));\n+typedef unsigned short V4HImode __attribute__((vector_size(8)));\n+typedef unsigned int V2SImode __attribute__((vector_size(8)));\n+typedef float V2SFmode __attribute__((vector_size(8)));\n+\n+/* Test argument loading and unloading of each.  */\n+#define TEST(TYPE)\t\t\t\t\t\\\n+extern TYPE data_##TYPE;\t\t\t\t\\\n+void p_##TYPE (TYPE x) { data_##TYPE = x; }\t\t\\\n+TYPE r_##TYPE (TYPE x) { return x; }\t\t\t\\\n+void s_##TYPE (void) { p_##TYPE (data_##TYPE); }\n+\n+TEST(V64QImode)\n+TEST(V32HImode)\n+TEST(V16SImode)\n+TEST(V8DImode)\n+TEST(V16SFmode)\n+TEST(V8DFmode)\n+\n+TEST(V32QImode)\n+TEST(V16HImode)\n+TEST(V8SImode)\n+TEST(V4DImode)\n+TEST(V8SFmode)\n+TEST(V4DFmode)\n+\n+TEST(V16QImode)\n+TEST(V8HImode)\n+TEST(V4SImode)\n+TEST(V2DImode)\n+TEST(V4SFmode)\n+TEST(V2DFmode)\n+\n+TEST(V8QImode)\n+TEST(V4HImode)\n+TEST(V2SImode)\n+TEST(V2SFmode)"}]}