{"sha": "2077db1be5b18b94a91095a3fb380bbc4a81e61b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA3N2RiMWJlNWIxOGI5NGE5MTA5NWEzZmIzODBiYmM0YTgxZTYxYg==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2013-08-07T03:38:59Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2013-08-07T03:38:59Z"}, "message": "Commit the vtable verification feature.\n\nCommit the vtable verification feature.  This feature is designed to\ndetect, at run time, if/when the vtable pointer in a C++ object has\nbeen corrupted, before allowing virtual calls through that pointer. \nIf pointer corruption is detected, execution of the program is halted.\n\nlibstdc++-v3 ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        * fragment.am: Add XTEMPLATE_FLAGS.\n        * configure.ac: Add definitions for --enable-vtable-verify.\n        * acinclude.m4:  Add --enable-vtable-verify and\n        --disable-vtable-verify; define --enable-vtable-verify; define\n        VTV_CXXFLAGS, VTV_PCH_CXXFLAGS and VTV_CXXLINKFLAGS.\n        * config/abi/pre/gnu.ver: Export symbols for vtable verification.\n        * libsupc++/Makefile.am: Define vtv_sources and add it to\n        libsupc___la_SOURCES and libsupc__convenience_la_SOURCES.\n        * libsupc++/vtv_stubs.cc: New file.\n        * include/Makefile.am: Add VTV_PCH_CXXFLAGS to PCHFLAGS.\n        * src/Makefile.am: Add VTV_CXXFLAGS to AM_CXXFLAGS; add\n        VTV_CXXLINKFLAGS to CXXLINK.\n        * src/c++98/Makefile.am: Comment out XTEMPLATE_FLAGS; add VTV_CXXFLAGS\n        to AM_CXXFLAGS; add VTV_CXXXLINKFLAGS to CXXLINK.\n        * src/C++11/Makefile.am: Ditto.\n        * doc/xml/manual/configure.xml: Add entry for --enable-vtable-verify.\n        * scripts/testsuite_flags.in: Add cxxvtvflags to Usage; cause\n        cxxvtvflags to use VTV_CXXFLAGS and VTV_CXXLINKFLAGS.\n        * testsuite/lib/libstdc++.exp: Add cxxvtvflags; add code to locate\n        libvtv if --enable-vtable-verify was used; set cxxvtvflags; add\n        cxxvtvflags to cxx_final.\n        * testsuite/18_support/bad_exception/23591_thread-1.c: Add\n        -fvtable-verify=none to compiler flags.\n        * testsuite/17_intro/freestanding.cc: Add -fvtable-verify=none\n        to compiler flags.\n        * configure: Regenerated.\n        * Makefile.in: Regenerated.\n        * python/Makefile.in: Regenerated.\n        * include/Makefile.in: Regenerated.\n        * libsupc++/Makefile.in: Regenerated.\n        * config.h.in: Regenerated.\n        * po/Makefile.in: Regenerated.\n        * src/Makefile.in: Regenerated.\n        * src/c++98/Makefile.in: Regenerated.\n        * src/c++11/Makefile.in: Regenerated.\n        * doc/Makefile.in: Regenerated.\n        * testsuite/Makefile.in: Regenerated.\n\ntop level ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        * configure.ac: Add target-libvtv to target_libraries; disable libvtv\n        on non-linux systems; add target-libvtv to noconfigdirs; add\n        libsupc++/.libs to C++ library search paths.\n        * configure: Regenerated.\n        * Makefile.def: Add libvtv to target_modules; make libvtv depend on\n        libstdc++ and libgcc.\n        * Makefile.in: Regenerated.\n\ninclude/ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        * vtv-change-permission.h: New file.\n\ncontrib/ChangeLog:\n2013-08-06  Caroline Tice4  <cmtice@google.com>\n\n        * gcc_update: Add libvtv files.\n\nlibgcc/ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        config.host (extra_parts): Add vtv_start.o, vtv_end.o\n        vtv_start_preinit.o and vtv_end_preinit.o.\n        configure.ac: Add code to check/set enable_vtable_verify.\n        Makefile.in: Add rules to build vtv_*.o, if enable_vtable_verify is\n        true.\n        vtv_start_preinit.c: New file.\n        vtv_end_preinit.c: New file.\n        vtv_start.c: New file.\n        vtv_end.c: New file.\n        configure: Regenerated.\n\ngcc/ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        * gcc.c (VTABLE_VERIFICATION_SPEC): New definition.\n        (LINK_COMMAND_SPEC): Add VTABLE_VERIFICATION_SPEC.\n        * tree-pass.h: Add pass_vtable_verify.\n        * varasm.c (assemble_variable): Add code to properly set the comdat\n        section and name for the .vtable_map_vars section.\n        (assemble_vtyv_preinit_initializer): New function.\n        (default_sectin_type_flags):  Make sure .vtable_map_vars section has\n        LINK_ONCE flag.\n        * output.h: Add function decl for assemble_vtv_preinit_initializer.\n        * vtable-verify.c: New file.\n        * vtable-verify.h: New file.\n        * flag-types.h (enum vtv_priority): Defintions for flag_vtable_verify\n        initialiation levels.\n        * timevar.def (TV_VTABLE_VERIFICATION): New definition.\n        * passes.def: Insert pass_vtable_verify.\n        * aclocal.m4: Reorder includes.\n        * doc/invoke.texi: Add documentation for the flags -fvtable-verify=,\n\t-fvtv-debug and -fvtv-counts.\n        * config/gnu-user.h (GNU_USER_TARGET_STARTFILE_SPEC): Add vtv_start*.o,\nas appropriate, if -fvtable-verify=... is used.\n        (GNU_USER_TARGET_ENDFILE_SPEC): Add vtv_end*.o as appropriate, if\n        -fvtable-verify=... is used.\n        * Makefile.in (OBJS):  Add vtable-verify.o to list.\n        (vtable-verify.o): Add new build rule.\n        (GTFILES): Add vtable-verify.c to list.\n        * common.opt (fvtable-verify=): New flag.\n        (vtv_priority): Values for fvtable-verify= flag.\n        (fvtv-counts): New flag.\n(fvtv-debug): New flag.\n        * tree.h (save_vtable_map_decl): New extern function decl.\n\n\ngcc/cp/ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        * Make-lang.in (*CXX_AND_OBJCXX_OBJS):  Add vtable-class-hierarchy.o to\n        list.\n        (vtable-class-hierarchy.o): Add build rule.\n        * cp-tree.h (vtv_start_verification_constructor_init_function): New\n        extern function decl.\n        (vtv_finish_verification_constructor_init_function): New extern\n        function decl.\n        (build_vtbl_address): New extern function decl.\n        (get_mangled_vtable_map_var_name): New extern function decl.\n        (vtv_compute_class_hierarchy_transitive_closure): New extern function\n        decl.\n        (vtv_generate_init_routine): New extern function decl.\n        (vtv_save_class_info): New extern function decl.\n        (vtv_recover_class_info): New extern function decl.\n        (vtv_build_vtable_verify_fndecl): New extern function decl.\n        * class.c (finish_struct_1): Add call to vtv_save_class_info if\n        flag_vtable_verify is true.\n        * config-lang.in: Add vtable-class-hierarchy.c to gtfiles list.\n        * vtable-class-hierarchy.c: New file.\n        * mangle.c (get_mangled_vtable_map_var_name):  New function.\n        * decl2.c (start_objects): Update function comment.\n        (cp_write_global_declarations): Call vtv_recover_class_info,\n        vtv_compute_class_hierarchy_transitive_closure and\n        vtv_build_vtable_verify_fndecl, before calling\n        finalize_compilation_unit, and call vtv_generate_init_rount after, IFF\n        flag_vtable_verify is true.\n        (vtv_start_verification_constructor_init_function): New function.\n        (vtv_finish_verification_constructor_init_function): New function.\n        * init.c (build_vtbl_address): Remove static qualifier from function.\n\nlibvtv/ChangeLog:\n2013-08-06  Caroline Tice  <cmtice@google.com>\n\n        Initial check-in of new vtable verification feature.\n        * configure.ac : New file.\n        * acinclude.m4 : New file.\n        * Makefile.am : New file.\n        * aclocal.m4 : New file.\n        * configure.tgt : New file.\n        * configure: New file (generated).\n        * Makefile.in: New file (generated).\n        * vtv_set.h : New file.\n        * vtv_utils.cc : New file.\n        * vtv_utils.h : New file.\n        * vtv_malloc.cc : New file.\n        * vtv_rts.cc : New file.\n        * vtv_malloc.h : New file.\n        * vtv_rts.h : New file.\n        * vtv_fail.cc : New file.\n        * vtv_fail.h : New file.\n        * vtv_map.h : New file.\n        * scripts/run-testsuite.sh : New file.\n        * scripts/sum-vtv-counts.c : New file.\n        * testsuite/parts-test-main.h : New file.\n        * testusite/dataentry.cc : New file.\n        * testsuite/temp_deriv.cc : New file.\n        * testsuite/register_pair.cc : New file.\n        * testsuite/virtual_inheritance.cc : New file.\n        * testsuite/field-test.cc : New file.\n        * testsuite/nested_vcall_test.cc : New file.\n        * testsuite/template-list-iostream.cc : New file.\n        * testsuite/register_pair_inserts.cc : New file.\n        * testsuite/register_pair_inserts_mt.cc : New file.\n        * testsuite/event.list : New file.\n        * testsuite/parts-test-extra-parts-views.cc : New file.\n        * testsuite/parts-test-extra-parts-views.h : New file.\n        * testsuite/environment-fail-32.s : New file.\n        * testsuite/parts-test-extra-parts.h : New file.\n        * testsuite/temp_deriv2.cc : New file.\n        * testsuite/dlopen_mt.cc : New file.\n        * testsuite/event.h : New file.\n        * testsuite/template-list.cc : New file.\n        * testsuite/replace-fail.cc : New file.\n        * testsuite/Makefile.am : New file.\n        * testsuite/Makefile.in: New file (generated).\n        * testsuite/mempool_negative.c : New file.\n        * testsuite/parts-test-main.cc : New file.\n        * testsuite/event-private.cc : New file.\n        * testsuite/thunk.cc : New file.\n        * testsuite/event-defintiions.cc : New file.\n        * testsuite/event-private.h : New file.\n        * testsuite/parts-test.list : New file.\n        * testusite/register_pair_mt.cc : New file.\n        * testsuite/povray-derived.cc : New file.\n        * testsuite/event-main.cc : New file.\n        * testsuite/environment.cc : New file.\n        * testsuite/template-list2.cc : New file.\n        * testsuite/thunk_vtable_map_attack.cc : New file.\n        * testsuite/parts-test-extra-parts.cc : New file.\n        * testsuite/environment-fail-64.s : New file.\n        * testsuite/dlopen.cc : New file.\n        * testsuite/so.cc : New file.\n        * testsuite/temp_deriv3.cc : New file.\n        * testsuite/const_vtable.cc : New file.\n        * testsuite/mempool_positive.c : New file.\n        * testsuite/dup_name.cc : New file.\n\nFrom-SVN: r201555", "tree": {"sha": "2799c94bc06794956a20aaa9db224f64c5e35e4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2799c94bc06794956a20aaa9db224f64c5e35e4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2077db1be5b18b94a91095a3fb380bbc4a81e61b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2077db1be5b18b94a91095a3fb380bbc4a81e61b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2077db1be5b18b94a91095a3fb380bbc4a81e61b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2077db1be5b18b94a91095a3fb380bbc4a81e61b/comments", "author": null, "committer": null, "parents": [{"sha": "03085d1cf9cc91b1283d7a13343760a526b69282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03085d1cf9cc91b1283d7a13343760a526b69282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03085d1cf9cc91b1283d7a13343760a526b69282"}], "stats": {"total": 49204, "additions": 49131, "deletions": 73}, "files": [{"sha": "51913df763cf9e52ae3da216c058a3fcfd423edd", "filename": "ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,13 @@\n+2013-08-02  Caroline Tice  <cmtice@google.com>\n+\n+\t* configure.ac: Add target-libvtv to target_libraries; disable libvtv\n+\ton non-linux systems; add target-libvtv to noconfigdirs; add\n+\tlibsupc++/.libs to C++ library search paths.\n+\t* configure: Regenerated.\n+\t* Makefile.def: Add libvtv to target_modules; make libvtv depend on\n+\tlibstdc++ and libgcc.\n+\t* Makefile.in: Regenerated.\n+\n 2013-07-19  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "3ba1a5b9a3a4b6e30e55264906dd8d2185134ac2", "filename": "Makefile.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -4,8 +4,7 @@ AutoGen definitions Makefile.tpl;\n // Makefile.in is generated from Makefile.tpl by 'autogen Makefile.def'.\n // This file was originally written by Nathanael Nerode.\n //\n-//   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-//   Free Software Foundation\n+//   Copyright 2002-2013 Free Software Foundation\n //\n // This file is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n@@ -123,6 +122,10 @@ target_modules = { module= libsanitizer;\n \t\t   bootstrap=true;\n \t\t   lib_path=.libs;\n \t\t   raw_cxx=true; };\n+target_modules = { module= libvtv;\n+\t\t   bootstrap=true;\n+\t\t   lib_path=.libs;\n+\t\t   raw_cxx=true; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true; };\n@@ -516,6 +519,7 @@ dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc;\n dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };\n dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };\n dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };\n+dependencies = { module=configure-target-libvtv; on=all-target-libstdc++-v3; };\n // parallel_list.o and parallel_settings.o depend on omp.h, which is\n // generated by the libgomp configure.  Unfortunately, due to the use of\n //  recursive make, we can't be that specific.\n@@ -526,6 +530,8 @@ dependencies = { module=install-target-libgfortran; on=install-target-libquadmat\n dependencies = { module=install-target-libgfortran; on=install-target-libgcc; };\n dependencies = { module=install-target-libsanitizer; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-libsanitizer; on=install-target-libgcc; };\n+dependencies = { module=install-target-libvtv; on=install-target-libstdc++-v3; };\n+dependencies = { module=install-target-libvtv; on=install-target-libgcc; };\n dependencies = { module=install-target-libjava; on=install-target-libgcc; };\n dependencies = { module=install-target-libitm; on=install-target-libgcc; };\n dependencies = { module=install-target-libobjc; on=install-target-libgcc; };"}, {"sha": "a13771d40eb539218d5b3c4e9128e5957270d299", "filename": "Makefile.in", "status": "modified", "additions": 1025, "deletions": 1, "changes": 1026, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -575,7 +575,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -589,6 +589,10 @@ TARGET_LIB_PATH_libmudflap = $$r/$(TARGET_SUBDIR)/libmudflap/.libs:\n TARGET_LIB_PATH_libsanitizer = $$r/$(TARGET_SUBDIR)/libsanitizer/.libs:\n @endif target-libsanitizer\n \n+@if target-libvtv\n+TARGET_LIB_PATH_libvtv = $$r/$(TARGET_SUBDIR)/libvtv/.libs:\n+@endif target-libvtv\n+\n @if target-libssp\n TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n @endif target-libssp\n@@ -925,6 +929,7 @@ configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n     maybe-configure-target-libmudflap \\\n     maybe-configure-target-libsanitizer \\\n+    maybe-configure-target-libvtv \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libgcc \\\n@@ -1076,6 +1081,9 @@ all-target: maybe-all-target-libmudflap\n @if target-libsanitizer-no-bootstrap\n all-target: maybe-all-target-libsanitizer\n @endif target-libsanitizer-no-bootstrap\n+@if target-libvtv-no-bootstrap\n+all-target: maybe-all-target-libvtv\n+@endif target-libvtv-no-bootstrap\n all-target: maybe-all-target-libssp\n all-target: maybe-all-target-newlib\n @if target-libgcc-no-bootstrap\n@@ -1167,6 +1175,7 @@ info-host: maybe-info-lto-plugin\n info-target: maybe-info-target-libstdc++-v3\n info-target: maybe-info-target-libmudflap\n info-target: maybe-info-target-libsanitizer\n+info-target: maybe-info-target-libvtv\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n info-target: maybe-info-target-libgcc\n@@ -1249,6 +1258,7 @@ dvi-host: maybe-dvi-lto-plugin\n dvi-target: maybe-dvi-target-libstdc++-v3\n dvi-target: maybe-dvi-target-libmudflap\n dvi-target: maybe-dvi-target-libsanitizer\n+dvi-target: maybe-dvi-target-libvtv\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n dvi-target: maybe-dvi-target-libgcc\n@@ -1331,6 +1341,7 @@ pdf-host: maybe-pdf-lto-plugin\n pdf-target: maybe-pdf-target-libstdc++-v3\n pdf-target: maybe-pdf-target-libmudflap\n pdf-target: maybe-pdf-target-libsanitizer\n+pdf-target: maybe-pdf-target-libvtv\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n pdf-target: maybe-pdf-target-libgcc\n@@ -1413,6 +1424,7 @@ html-host: maybe-html-lto-plugin\n html-target: maybe-html-target-libstdc++-v3\n html-target: maybe-html-target-libmudflap\n html-target: maybe-html-target-libsanitizer\n+html-target: maybe-html-target-libvtv\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n html-target: maybe-html-target-libgcc\n@@ -1495,6 +1507,7 @@ TAGS-host: maybe-TAGS-lto-plugin\n TAGS-target: maybe-TAGS-target-libstdc++-v3\n TAGS-target: maybe-TAGS-target-libmudflap\n TAGS-target: maybe-TAGS-target-libsanitizer\n+TAGS-target: maybe-TAGS-target-libvtv\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n TAGS-target: maybe-TAGS-target-libgcc\n@@ -1577,6 +1590,7 @@ install-info-host: maybe-install-info-lto-plugin\n install-info-target: maybe-install-info-target-libstdc++-v3\n install-info-target: maybe-install-info-target-libmudflap\n install-info-target: maybe-install-info-target-libsanitizer\n+install-info-target: maybe-install-info-target-libvtv\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n install-info-target: maybe-install-info-target-libgcc\n@@ -1659,6 +1673,7 @@ install-pdf-host: maybe-install-pdf-lto-plugin\n install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n install-pdf-target: maybe-install-pdf-target-libmudflap\n install-pdf-target: maybe-install-pdf-target-libsanitizer\n+install-pdf-target: maybe-install-pdf-target-libvtv\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n install-pdf-target: maybe-install-pdf-target-libgcc\n@@ -1741,6 +1756,7 @@ install-html-host: maybe-install-html-lto-plugin\n install-html-target: maybe-install-html-target-libstdc++-v3\n install-html-target: maybe-install-html-target-libmudflap\n install-html-target: maybe-install-html-target-libsanitizer\n+install-html-target: maybe-install-html-target-libvtv\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n install-html-target: maybe-install-html-target-libgcc\n@@ -1823,6 +1839,7 @@ installcheck-host: maybe-installcheck-lto-plugin\n installcheck-target: maybe-installcheck-target-libstdc++-v3\n installcheck-target: maybe-installcheck-target-libmudflap\n installcheck-target: maybe-installcheck-target-libsanitizer\n+installcheck-target: maybe-installcheck-target-libvtv\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n installcheck-target: maybe-installcheck-target-libgcc\n@@ -1905,6 +1922,7 @@ mostlyclean-host: maybe-mostlyclean-lto-plugin\n mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n mostlyclean-target: maybe-mostlyclean-target-libmudflap\n mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n+mostlyclean-target: maybe-mostlyclean-target-libvtv\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n mostlyclean-target: maybe-mostlyclean-target-libgcc\n@@ -1987,6 +2005,7 @@ clean-host: maybe-clean-lto-plugin\n clean-target: maybe-clean-target-libstdc++-v3\n clean-target: maybe-clean-target-libmudflap\n clean-target: maybe-clean-target-libsanitizer\n+clean-target: maybe-clean-target-libvtv\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n clean-target: maybe-clean-target-libgcc\n@@ -2069,6 +2088,7 @@ distclean-host: maybe-distclean-lto-plugin\n distclean-target: maybe-distclean-target-libstdc++-v3\n distclean-target: maybe-distclean-target-libmudflap\n distclean-target: maybe-distclean-target-libsanitizer\n+distclean-target: maybe-distclean-target-libvtv\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n distclean-target: maybe-distclean-target-libgcc\n@@ -2151,6 +2171,7 @@ maintainer-clean-host: maybe-maintainer-clean-lto-plugin\n maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n maintainer-clean-target: maybe-maintainer-clean-target-libmudflap\n maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n+maintainer-clean-target: maybe-maintainer-clean-target-libvtv\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n maintainer-clean-target: maybe-maintainer-clean-target-libgcc\n@@ -2288,6 +2309,7 @@ check-target:  \\\n     maybe-check-target-libstdc++-v3 \\\n     maybe-check-target-libmudflap \\\n     maybe-check-target-libsanitizer \\\n+    maybe-check-target-libvtv \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libgcc \\\n@@ -2443,6 +2465,7 @@ install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n     maybe-install-target-libmudflap \\\n     maybe-install-target-libsanitizer \\\n+    maybe-install-target-libvtv \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libgcc \\\n@@ -2545,6 +2568,7 @@ install-strip-target:  \\\n     maybe-install-strip-target-libstdc++-v3 \\\n     maybe-install-strip-target-libmudflap \\\n     maybe-install-strip-target-libsanitizer \\\n+    maybe-install-strip-target-libvtv \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n     maybe-install-strip-target-libgcc \\\n@@ -33152,6 +33176,980 @@ maintainer-clean-target-libsanitizer:\n \n \n \n+.PHONY: configure-target-libvtv maybe-configure-target-libvtv\n+maybe-configure-target-libvtv:\n+@if gcc-bootstrap\n+configure-target-libvtv: stage_current\n+@endif gcc-bootstrap\n+@if target-libvtv\n+maybe-configure-target-libvtv: configure-target-libvtv\n+configure-target-libvtv: \n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(RAW_CXX_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libvtv; \\\n+\tcd \"$(TARGET_SUBDIR)/libvtv\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libvtv\n+\n+\n+\n+.PHONY: configure-stage1-target-libvtv maybe-configure-stage1-target-libvtv\n+maybe-configure-stage1-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stage1-target-libvtv: configure-stage1-target-libvtv\n+configure-stage1-target-libvtv:\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 1 in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  $(STAGE1_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+.PHONY: configure-stage2-target-libvtv maybe-configure-stage2-target-libvtv\n+maybe-configure-stage2-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stage2-target-libvtv: configure-stage2-target-libvtv\n+configure-stage2-target-libvtv:\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 2 in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE2_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+.PHONY: configure-stage3-target-libvtv maybe-configure-stage3-target-libvtv\n+maybe-configure-stage3-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stage3-target-libvtv: configure-stage3-target-libvtv\n+configure-stage3-target-libvtv:\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 3 in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE3_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+.PHONY: configure-stage4-target-libvtv maybe-configure-stage4-target-libvtv\n+maybe-configure-stage4-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stage4-target-libvtv: configure-stage4-target-libvtv\n+configure-stage4-target-libvtv:\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage 4 in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGE4_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+.PHONY: configure-stageprofile-target-libvtv maybe-configure-stageprofile-target-libvtv\n+maybe-configure-stageprofile-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stageprofile-target-libvtv: configure-stageprofile-target-libvtv\n+configure-stageprofile-target-libvtv:\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage profile in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEprofile_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+.PHONY: configure-stagefeedback-target-libvtv maybe-configure-stagefeedback-target-libvtv\n+maybe-configure-stagefeedback-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-configure-stagefeedback-target-libvtv: configure-stagefeedback-target-libvtv\n+configure-stagefeedback-target-libvtv:\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\techo \"Checking multilib configuration for libvtv...\"; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libvtv/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libvtv/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libvtv/multilib.tmp $(TARGET_SUBDIR)/libvtv/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libvtv/Makefile || exit 0; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\"; export LIBCFLAGS;  \\\n+\techo Configuring stage feedback in $(TARGET_SUBDIR)/libvtv ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libvtv ; \\\n+\tcd $(TARGET_SUBDIR)/libvtv || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libvtv/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libvtv\"; \\\n+\tlibsrcdir=\"$$s/libvtv\"; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption} \\\n+\t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n+\t  $(STAGEfeedback_CONFIGURE_FLAGS)\n+@endif target-libvtv-bootstrap\n+\n+\n+\n+\n+\n+.PHONY: all-target-libvtv maybe-all-target-libvtv\n+maybe-all-target-libvtv:\n+@if gcc-bootstrap\n+all-target-libvtv: stage_current\n+@endif gcc-bootstrap\n+@if target-libvtv\n+TARGET-target-libvtv=all\n+maybe-all-target-libvtv: all-target-libvtv\n+all-target-libvtv: configure-target-libvtv\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\t$(TARGET-target-libvtv))\n+@endif target-libvtv\n+\n+\n+\n+.PHONY: all-stage1-target-libvtv maybe-all-stage1-target-libvtv\n+.PHONY: clean-stage1-target-libvtv maybe-clean-stage1-target-libvtv\n+maybe-all-stage1-target-libvtv:\n+maybe-clean-stage1-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stage1-target-libvtv: all-stage1-target-libvtv\n+all-stage1: all-stage1-target-libvtv\n+TARGET-stage1-target-libvtv = $(TARGET-target-libvtv)\n+all-stage1-target-libvtv: configure-stage1-target-libvtv\n+\t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS)  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'  \\\n+\t\t  \\\n+\t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n+\t\t$(TARGET-stage1-target-libvtv)\n+\n+maybe-clean-stage1-target-libvtv: clean-stage1-target-libvtv\n+clean-stage1: clean-stage1-target-libvtv\n+clean-stage1-target-libvtv:\n+\t@if [ $(current_stage) = stage1 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage1-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage1-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'  \\\n+\t  clean\n+@endif target-libvtv-bootstrap\n+\n+\n+.PHONY: all-stage2-target-libvtv maybe-all-stage2-target-libvtv\n+.PHONY: clean-stage2-target-libvtv maybe-clean-stage2-target-libvtv\n+maybe-all-stage2-target-libvtv:\n+maybe-clean-stage2-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stage2-target-libvtv: all-stage2-target-libvtv\n+all-stage2: all-stage2-target-libvtv\n+TARGET-stage2-target-libvtv = $(TARGET-target-libvtv)\n+all-stage2-target-libvtv: configure-stage2-target-libvtv\n+\t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n+\t\t$(TARGET-stage2-target-libvtv)\n+\n+maybe-clean-stage2-target-libvtv: clean-stage2-target-libvtv\n+clean-stage2: clean-stage2-target-libvtv\n+clean-stage2-target-libvtv:\n+\t@if [ $(current_stage) = stage2 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage2-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage2-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   clean\n+@endif target-libvtv-bootstrap\n+\n+\n+.PHONY: all-stage3-target-libvtv maybe-all-stage3-target-libvtv\n+.PHONY: clean-stage3-target-libvtv maybe-clean-stage3-target-libvtv\n+maybe-all-stage3-target-libvtv:\n+maybe-clean-stage3-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stage3-target-libvtv: all-stage3-target-libvtv\n+all-stage3: all-stage3-target-libvtv\n+TARGET-stage3-target-libvtv = $(TARGET-target-libvtv)\n+all-stage3-target-libvtv: configure-stage3-target-libvtv\n+\t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n+\t\t$(TARGET-stage3-target-libvtv)\n+\n+maybe-clean-stage3-target-libvtv: clean-stage3-target-libvtv\n+clean-stage3: clean-stage3-target-libvtv\n+clean-stage3-target-libvtv:\n+\t@if [ $(current_stage) = stage3 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage3-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage3-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   clean\n+@endif target-libvtv-bootstrap\n+\n+\n+.PHONY: all-stage4-target-libvtv maybe-all-stage4-target-libvtv\n+.PHONY: clean-stage4-target-libvtv maybe-clean-stage4-target-libvtv\n+maybe-all-stage4-target-libvtv:\n+maybe-clean-stage4-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stage4-target-libvtv: all-stage4-target-libvtv\n+all-stage4: all-stage4-target-libvtv\n+TARGET-stage4-target-libvtv = $(TARGET-target-libvtv)\n+all-stage4-target-libvtv: configure-stage4-target-libvtv\n+\t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n+\t\t$(TARGET-stage4-target-libvtv)\n+\n+maybe-clean-stage4-target-libvtv: clean-stage4-target-libvtv\n+clean-stage4: clean-stage4-target-libvtv\n+clean-stage4-target-libvtv:\n+\t@if [ $(current_stage) = stage4 ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stage4-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stage4-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   clean\n+@endif target-libvtv-bootstrap\n+\n+\n+.PHONY: all-stageprofile-target-libvtv maybe-all-stageprofile-target-libvtv\n+.PHONY: clean-stageprofile-target-libvtv maybe-clean-stageprofile-target-libvtv\n+maybe-all-stageprofile-target-libvtv:\n+maybe-clean-stageprofile-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stageprofile-target-libvtv: all-stageprofile-target-libvtv\n+all-stageprofile: all-stageprofile-target-libvtv\n+TARGET-stageprofile-target-libvtv = $(TARGET-target-libvtv)\n+all-stageprofile-target-libvtv: configure-stageprofile-target-libvtv\n+\t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n+\t\t$(TARGET-stageprofile-target-libvtv)\n+\n+maybe-clean-stageprofile-target-libvtv: clean-stageprofile-target-libvtv\n+clean-stageprofile: clean-stageprofile-target-libvtv\n+clean-stageprofile-target-libvtv:\n+\t@if [ $(current_stage) = stageprofile ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stageprofile-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stageprofile-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   clean\n+@endif target-libvtv-bootstrap\n+\n+\n+.PHONY: all-stagefeedback-target-libvtv maybe-all-stagefeedback-target-libvtv\n+.PHONY: clean-stagefeedback-target-libvtv maybe-clean-stagefeedback-target-libvtv\n+maybe-all-stagefeedback-target-libvtv:\n+maybe-clean-stagefeedback-target-libvtv:\n+@if target-libvtv-bootstrap\n+maybe-all-stagefeedback-target-libvtv: all-stagefeedback-target-libvtv\n+all-stagefeedback: all-stagefeedback-target-libvtv\n+TARGET-stagefeedback-target-libvtv = $(TARGET-target-libvtv)\n+all-stagefeedback-target-libvtv: configure-stagefeedback-target-libvtv\n+\t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t  \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n+\t\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n+\t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n+\t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\t$(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   \\\n+\t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n+\t\t$(TARGET-stagefeedback-target-libvtv)\n+\n+maybe-clean-stagefeedback-target-libvtv: clean-stagefeedback-target-libvtv\n+clean-stagefeedback: clean-stagefeedback-target-libvtv\n+clean-stagefeedback-target-libvtv:\n+\t@if [ $(current_stage) = stagefeedback ]; then \\\n+\t  [ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0; \\\n+\telse \\\n+\t  [ -f $(TARGET_SUBDIR)/stagefeedback-libvtv/Makefile ] || exit 0; \\\n+\t  $(MAKE) stagefeedback-start; \\\n+\tfi; \\\n+\tcd $(TARGET_SUBDIR)/libvtv && \\\n+\t$(MAKE) $(EXTRA_TARGET_FLAGS) 'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   clean\n+@endif target-libvtv-bootstrap\n+\n+\n+\n+\n+\n+\n+.PHONY: check-target-libvtv maybe-check-target-libvtv\n+maybe-check-target-libvtv:\n+@if target-libvtv\n+maybe-check-target-libvtv: check-target-libvtv\n+\n+check-target-libvtv:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  'CXX=$$(RAW_CXX_FOR_TARGET)' 'CXX_FOR_TARGET=$$(RAW_CXX_FOR_TARGET)'   check)\n+\n+@endif target-libvtv\n+\n+.PHONY: install-target-libvtv maybe-install-target-libvtv\n+maybe-install-target-libvtv:\n+@if target-libvtv\n+maybe-install-target-libvtv: install-target-libvtv\n+\n+install-target-libvtv: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libvtv\n+\n+.PHONY: install-strip-target-libvtv maybe-install-strip-target-libvtv\n+maybe-install-strip-target-libvtv:\n+@if target-libvtv\n+maybe-install-strip-target-libvtv: install-strip-target-libvtv\n+\n+install-strip-target-libvtv: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libvtv\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libvtv info-target-libvtv\n+maybe-info-target-libvtv:\n+@if target-libvtv\n+maybe-info-target-libvtv: info-target-libvtv\n+\n+info-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-dvi-target-libvtv dvi-target-libvtv\n+maybe-dvi-target-libvtv:\n+@if target-libvtv\n+maybe-dvi-target-libvtv: dvi-target-libvtv\n+\n+dvi-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-pdf-target-libvtv pdf-target-libvtv\n+maybe-pdf-target-libvtv:\n+@if target-libvtv\n+maybe-pdf-target-libvtv: pdf-target-libvtv\n+\n+pdf-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-html-target-libvtv html-target-libvtv\n+maybe-html-target-libvtv:\n+@if target-libvtv\n+maybe-html-target-libvtv: html-target-libvtv\n+\n+html-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-TAGS-target-libvtv TAGS-target-libvtv\n+maybe-TAGS-target-libvtv:\n+@if target-libvtv\n+maybe-TAGS-target-libvtv: TAGS-target-libvtv\n+\n+TAGS-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-install-info-target-libvtv install-info-target-libvtv\n+maybe-install-info-target-libvtv:\n+@if target-libvtv\n+maybe-install-info-target-libvtv: install-info-target-libvtv\n+\n+install-info-target-libvtv: \\\n+    configure-target-libvtv \\\n+    info-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-install-pdf-target-libvtv install-pdf-target-libvtv\n+maybe-install-pdf-target-libvtv:\n+@if target-libvtv\n+maybe-install-pdf-target-libvtv: install-pdf-target-libvtv\n+\n+install-pdf-target-libvtv: \\\n+    configure-target-libvtv \\\n+    pdf-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-install-html-target-libvtv install-html-target-libvtv\n+maybe-install-html-target-libvtv:\n+@if target-libvtv\n+maybe-install-html-target-libvtv: install-html-target-libvtv\n+\n+install-html-target-libvtv: \\\n+    configure-target-libvtv \\\n+    html-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-installcheck-target-libvtv installcheck-target-libvtv\n+maybe-installcheck-target-libvtv:\n+@if target-libvtv\n+maybe-installcheck-target-libvtv: installcheck-target-libvtv\n+\n+installcheck-target-libvtv: \\\n+    configure-target-libvtv \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-mostlyclean-target-libvtv mostlyclean-target-libvtv\n+maybe-mostlyclean-target-libvtv:\n+@if target-libvtv\n+maybe-mostlyclean-target-libvtv: mostlyclean-target-libvtv\n+\n+mostlyclean-target-libvtv: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-clean-target-libvtv clean-target-libvtv\n+maybe-clean-target-libvtv:\n+@if target-libvtv\n+maybe-clean-target-libvtv: clean-target-libvtv\n+\n+clean-target-libvtv: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-distclean-target-libvtv distclean-target-libvtv\n+maybe-distclean-target-libvtv:\n+@if target-libvtv\n+maybe-distclean-target-libvtv: distclean-target-libvtv\n+\n+distclean-target-libvtv: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+.PHONY: maybe-maintainer-clean-target-libvtv maintainer-clean-target-libvtv\n+maybe-maintainer-clean-target-libvtv:\n+@if target-libvtv\n+maybe-maintainer-clean-target-libvtv: maintainer-clean-target-libvtv\n+\n+maintainer-clean-target-libvtv: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libvtv/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(RAW_CXX_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libvtv\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libvtv && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libvtv\n+\n+\n+\n+\n+\n .PHONY: configure-target-libssp maybe-configure-target-libssp\n maybe-configure-target-libssp:\n @if gcc-bootstrap\n@@ -45384,6 +46382,12 @@ configure-stage3-target-libsanitizer: maybe-all-stage3-gcc\n configure-stage4-target-libsanitizer: maybe-all-stage4-gcc\n configure-stageprofile-target-libsanitizer: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libsanitizer: maybe-all-stagefeedback-gcc\n+configure-stage1-target-libvtv: maybe-all-stage1-gcc\n+configure-stage2-target-libvtv: maybe-all-stage2-gcc\n+configure-stage3-target-libvtv: maybe-all-stage3-gcc\n+configure-stage4-target-libvtv: maybe-all-stage4-gcc\n+configure-stageprofile-target-libvtv: maybe-all-stageprofile-gcc\n+configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-gcc\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n configure-stage1-target-libgcc: maybe-all-stage1-gcc\n@@ -45420,6 +46424,7 @@ configure-target-libatomic: stage_last\n configure-target-libstdc++-v3: maybe-all-gcc\n configure-target-libmudflap: maybe-all-gcc\n configure-target-libsanitizer: maybe-all-gcc\n+configure-target-libvtv: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n configure-target-libgcc: maybe-all-gcc\n@@ -46195,6 +47200,14 @@ configure-stage3-target-libsanitizer: maybe-all-stage3-target-libstdc++-v3\n configure-stage4-target-libsanitizer: maybe-all-stage4-target-libstdc++-v3\n configure-stageprofile-target-libsanitizer: maybe-all-stageprofile-target-libstdc++-v3\n configure-stagefeedback-target-libsanitizer: maybe-all-stagefeedback-target-libstdc++-v3\n+configure-target-libvtv: maybe-all-target-libstdc++-v3\n+\n+configure-stage1-target-libvtv: maybe-all-stage1-target-libstdc++-v3\n+configure-stage2-target-libvtv: maybe-all-stage2-target-libstdc++-v3\n+configure-stage3-target-libvtv: maybe-all-stage3-target-libstdc++-v3\n+configure-stage4-target-libvtv: maybe-all-stage4-target-libstdc++-v3\n+configure-stageprofile-target-libvtv: maybe-all-stageprofile-target-libstdc++-v3\n+configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-target-libstdc++-v3\n all-target-libstdc++-v3: maybe-configure-target-libgomp\n \n all-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp\n@@ -46208,6 +47221,8 @@ install-target-libgfortran: maybe-install-target-libquadmath\n install-target-libgfortran: maybe-install-target-libgcc\n install-target-libsanitizer: maybe-install-target-libstdc++-v3\n install-target-libsanitizer: maybe-install-target-libgcc\n+install-target-libvtv: maybe-install-target-libstdc++-v3\n+install-target-libvtv: maybe-install-target-libgcc\n install-target-libjava: maybe-install-target-libgcc\n install-target-libitm: maybe-install-target-libgcc\n install-target-libobjc: maybe-install-target-libgcc\n@@ -46237,6 +47252,12 @@ configure-stage3-target-libsanitizer: maybe-all-stage3-target-libgcc\n configure-stage4-target-libsanitizer: maybe-all-stage4-target-libgcc\n configure-stageprofile-target-libsanitizer: maybe-all-stageprofile-target-libgcc\n configure-stagefeedback-target-libsanitizer: maybe-all-stagefeedback-target-libgcc\n+configure-stage1-target-libvtv: maybe-all-stage1-target-libgcc\n+configure-stage2-target-libvtv: maybe-all-stage2-target-libgcc\n+configure-stage3-target-libvtv: maybe-all-stage3-target-libgcc\n+configure-stage4-target-libvtv: maybe-all-stage4-target-libgcc\n+configure-stageprofile-target-libvtv: maybe-all-stageprofile-target-libgcc\n+configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-target-libgcc\n configure-stage1-target-libgomp: maybe-all-stage1-target-libgcc\n configure-stage2-target-libgomp: maybe-all-stage2-target-libgcc\n configure-stage3-target-libgomp: maybe-all-stage3-target-libgcc\n@@ -46249,6 +47270,7 @@ configure-stagefeedback-target-libgomp: maybe-all-stagefeedback-target-libgcc\n configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libmudflap: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n+configure-target-libvtv: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n configure-target-libbacktrace: maybe-all-target-libgcc\n@@ -46277,6 +47299,8 @@ configure-target-libmudflap: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libsanitizer: maybe-all-target-newlib maybe-all-target-libgloss\n \n+configure-target-libvtv: maybe-all-target-newlib maybe-all-target-libgloss\n+\n configure-target-libssp: maybe-all-target-newlib maybe-all-target-libgloss\n \n "}, {"sha": "00bd73babc0e3ea0625efe5e5611a7244cebf661", "filename": "configure", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -2774,6 +2774,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n \t\ttarget-libsanitizer \\\n+\t\ttarget-libvtv \\\n \t\ttarget-libssp \\\n \t\ttarget-libquadmath \\\n \t\ttarget-libgfortran \\\n@@ -3215,6 +3216,25 @@ $as_echo \"yes\" >&6; }\n     fi\n fi\n \n+# Disable libvtv on unsupported systems.\n+if test -d ${srcdir}/libvtv; then\n+    if test x$enable_libvtv = x; then\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libvtv support\" >&5\n+$as_echo_n \"checking for libvtv support... \" >&6; }\n+\tif (srcdir=${srcdir}/libvtv; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+\t    noconfigdirs=\"$noconfigdirs target-libvtv\"\n+\telse\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; }\n+\tfi\n+    fi\n+fi\n+\n # Disable libquadmath for some systems.\n case \"${target}\" in\n   avr-*-*)\n@@ -6551,11 +6571,11 @@ case ,${enable_languages},:${enable_objc_gc} in\n     ;;\n esac\n \n-# Disable libitm and libsanitizer if we're not building C++\n+# Disable libitm, libsanitizer, libvtv if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*) ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer\"\n+    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n \n@@ -7032,6 +7052,11 @@ if echo \" ${target_configdirs} \" | grep \" libsanitizer \" > /dev/null 2>&1 ; then\n   bootstrap_target_libs=${bootstrap_target_libs}target-libsanitizer,\n fi\n \n+# If we are building libvtv, bootstrap it.\n+if echo \" ${target_configdirs} \" | grep \" libvtv \" > /dev/null 2>&1 ; then\n+  bootstrap_target_libs=${bootstrap_target_libs}target-libvtv,\n+fi\n+\n # Determine whether gdb needs tk/tcl or not.\n # Use 'maybe' since enable_gdbtk might be true even if tk isn't available\n # and in that case we want gdb to be built without tk.  Ugh!\n@@ -13747,7 +13772,7 @@ else\n   esac\n   if test $ok = yes; then\n     # An in-tree tool is available and we can use it\n-    CXX_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/xg++ -B$$r/$(HOST_SUBDIR)/gcc/ -nostdinc++ `if test -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags; then $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes; else echo -funconfigured-libstdc++-v3 ; fi` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n+    CXX_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/xg++ -B$$r/$(HOST_SUBDIR)/gcc/ -nostdinc++ `if test -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags; then $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes; else echo -funconfigured-libstdc++-v3 ; fi` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs'\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: result: just compiled\" >&5\n $as_echo \"just compiled\" >&6; }\n   elif expr \"x$CXX_FOR_TARGET\" : \"x/\" > /dev/null; then\n@@ -13792,7 +13817,7 @@ else\n   esac\n   if test $ok = yes; then\n     # An in-tree tool is available and we can use it\n-    RAW_CXX_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/xgcc -shared-libgcc -B$$r/$(HOST_SUBDIR)/gcc -nostdinc++ -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n+    RAW_CXX_FOR_TARGET='$$r/$(HOST_SUBDIR)/gcc/xgcc -shared-libgcc -B$$r/$(HOST_SUBDIR)/gcc -nostdinc++ -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs'\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: result: just compiled\" >&5\n $as_echo \"just compiled\" >&6; }\n   elif expr \"x$RAW_CXX_FOR_TARGET\" : \"x/\" > /dev/null; then"}, {"sha": "bcbc95c32f9848d22cdba54a03855f56eaae2fb8", "filename": "configure.ac", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -161,6 +161,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n \t\ttarget-libsanitizer \\\n+\t\ttarget-libvtv \\\n \t\ttarget-libssp \\\n \t\ttarget-libquadmath \\\n \t\ttarget-libgfortran \\\n@@ -554,6 +555,22 @@ if test -d ${srcdir}/libsanitizer; then\n     fi\n fi\n \n+# Disable libvtv on unsupported systems.\n+if test -d ${srcdir}/libvtv; then\n+    if test x$enable_libvtv = x; then\n+\tAC_MSG_CHECKING([for libvtv support])\n+\tif (srcdir=${srcdir}/libvtv; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    AC_MSG_RESULT([no])\n+\t    noconfigdirs=\"$noconfigdirs target-libvtv\"\n+\telse\n+\t    AC_MSG_RESULT([yes])\n+\tfi\n+    fi\n+fi\n+\n # Disable libquadmath for some systems.\n case \"${target}\" in\n   avr-*-*)\n@@ -2037,11 +2054,11 @@ case ,${enable_languages},:${enable_objc_gc} in\n     ;;\n esac\n \n-# Disable libitm and libsanitizer if we're not building C++\n+# Disable libitm, libsanitizer, libvtv if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*) ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer\"\n+    noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n \n@@ -2467,6 +2484,11 @@ if echo \" ${target_configdirs} \" | grep \" libsanitizer \" > /dev/null 2>&1 ; then\n   bootstrap_target_libs=${bootstrap_target_libs}target-libsanitizer,\n fi\n \n+# If we are building libvtv, bootstrap it.\n+if echo \" ${target_configdirs} \" | grep \" libvtv \" > /dev/null 2>&1 ; then\n+  bootstrap_target_libs=${bootstrap_target_libs}target-libvtv,\n+fi\n+\n # Determine whether gdb needs tk/tcl or not.\n # Use 'maybe' since enable_gdbtk might be true even if tk isn't available\n # and in that case we want gdb to be built without tk.  Ugh!\n@@ -3163,10 +3185,10 @@ GCC_TARGET_TOOL(as, AS_FOR_TARGET, AS, [gas/as-new])\n GCC_TARGET_TOOL(cc, CC_FOR_TARGET, CC, [gcc/xgcc -B$$r/$(HOST_SUBDIR)/gcc/])\n dnl see comments for CXX_FOR_TARGET_FLAG_TO_PASS\n GCC_TARGET_TOOL(c++, CXX_FOR_TARGET, CXX,\n-\t\t[gcc/xg++ -B$$r/$(HOST_SUBDIR)/gcc/ -nostdinc++ `if test -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags; then $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes; else echo -funconfigured-libstdc++-v3 ; fi` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs],\n+\t\t[gcc/xg++ -B$$r/$(HOST_SUBDIR)/gcc/ -nostdinc++ `if test -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags; then $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes; else echo -funconfigured-libstdc++-v3 ; fi` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs],\n \t\tc++)\n GCC_TARGET_TOOL(c++ for libstdc++, RAW_CXX_FOR_TARGET, CXX,\n-\t\t[gcc/xgcc -shared-libgcc -B$$r/$(HOST_SUBDIR)/gcc -nostdinc++ -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs],\n+\t\t[gcc/xgcc -shared-libgcc -B$$r/$(HOST_SUBDIR)/gcc -nostdinc++ -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/libsupc++/.libs],\n \t\tc++)\n GCC_TARGET_TOOL(dlltool, DLLTOOL_FOR_TARGET, DLLTOOL, [binutils/dlltool])\n GCC_TARGET_TOOL(gcc, GCC_FOR_TARGET, , [gcc/xgcc -B$$r/$(HOST_SUBDIR)/gcc/])"}, {"sha": "5728d5821017920d80bc80388a6ec1f005a6ec7e", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,7 @@\n+2013-08-03  Caroline Tice4  <cmtice@google.com>\n+\n+\t* gcc_update: Add libvtv files.\n+\t\n 2013-06-06  Brooks Moses  <bmoses@google.com>\n \n \t* testsuite-management/validate_failures.py: Fix handling of"}, {"sha": "70a5ef7d0e526bfb471b45df462e60ce6609412a", "filename": "contrib/gcc_update", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -158,6 +158,9 @@ libsanitizer/configure: libsanitizer/configure.ac libsanitizer/aclocal.m4\n libsanitizer/asan/Makefile.in: libsanitizer/asan/Makefile.am libsanitizer/aclocal.m4\n libsanitizer/interception/Makefile.in: libsanitizer/interception/Makefile.am libsanitizer/aclocal.m4\n libsanitizer/sanitizer_common/Makefile.in: libsanitizer/sanitizer_common/Makefile.am libsanitizer/aclocal.m4\n+libvtv/aclocal.m4: libvtv/configure.ac libvtv/acinclude.m4\n+libvtv/Makefile.in: libvtv/Makefile.am libvtv/aclocal.m4\n+libvtv/configure: libvtv/configure.ac libvtv/aclocal.m4\n # Top level\n Makefile.in: Makefile.tpl Makefile.def\n configure: configure.ac config/acx.m4"}, {"sha": "f3ce757fd75f7dbf95d12da3666128dc496fde3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,36 @@\n+2013-08-06  Caroline Tice  <cmtice@google.com>\n+\n+\t* gcc.c (VTABLE_VERIFICATION_SPEC): New definition.\n+\t(LINK_COMMAND_SPEC): Add VTABLE_VERIFICATION_SPEC.\n+\t* tree-pass.h: Add pass_vtable_verify.\n+\t* varasm.c (assemble_variable): Add code to properly set the comdat\n+\tsection and name for the .vtable_map_vars section.\n+\t(assemble_vtyv_preinit_initializer): New function.\n+\t(default_sectin_type_flags):  Make sure .vtable_map_vars section has\n+\tLINK_ONCE flag.\n+\t* output.h: Add function decl for assemble_vtv_preinit_initializer.\n+\t* vtable-verify.c: New file.\n+\t* vtable-verify.h: New file.\n+\t* flag-types.h (enum vtv_priority): Defintions for flag_vtable_verify\n+\tinitialiation levels.\n+\t* timevar.def (TV_VTABLE_VERIFICATION): New definition.\n+\t* passes.def: Insert pass_vtable_verify.\n+\t* aclocal.m4: Reorder includes.\n+\t* doc/invoke.texi:  Document the -fvtable-verify=, -fvtv-debug, and\n+\t-fvtv-counts options.\n+\t* config/gnu-user.h (GNU_USER_TARGET_STARTFILE_SPEC): Add vtv_start*.o,\n+\tas appropriate, if -fvtable-verify=... is used.\n+\t(GNU_USER_TARGET_ENDFILE_SPEC): Add vtv_end*.o as appropriate, if\n+\t-fvtable-verify=... is used.\n+\t* Makefile.in (OBJS):  Add vtable-verify.o to list.\n+\t(vtable-verify.o): Add new build rule.\n+\t(GTFILES): Add vtable-verify.c to list.\n+\t* common.opt (fvtable-verify=): New flag.\n+\t(vtv_priority): Values for fvtable-verify= flag.\n+\t(fvtv-counts): New flag.\n+\t(fvtv-debug): New flag.\n+\t* tree.h (save_vtable_map_decl): New extern function decl.\n+\n 2013-08-07  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/rl78/rl78.c (rl78_devirt_pass): Convert from a struct to..."}, {"sha": "6ddc8534f840f4c5faa8382b5c2198664ff8ee02", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1473,6 +1473,7 @@ OBJS = \\\n \tvarasm.o \\\n \tvarpool.o \\\n \tvmsdbgout.o \\\n+\tvtable-verify.o \\\n \tweb.o \\\n \txcoffout.o \\\n \t$(out_object_file) \\\n@@ -2644,6 +2645,12 @@ tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DUMPFILE_H) $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \\\n    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) \\\n    $(TREE_PRETTY_PRINT_H)\n+vtable-verify.o: vtable-verify.c vtable-verify.h $(CONFIG_H) \\\n+   $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) cp/cp-tree.h $(TM_P_H) \\\n+   $(BASIC_BLOCK_H) output.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(TREE_PASS_H) \\\n+   $(TIMEVAR_H) $(CFGLOOP_H) $(FLAGS_H)  $(TREE_INLINE_H) $(SCEV_H) \\\n+   $(DIAGNOSTIC_CORE_H) $(GIMPLE_PRETTY_PRINT_H) toplev.h langhooks.h \\\n+   gt-vtable-verify.h\n tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)\n tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -3817,6 +3824,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-inline.h \\\n+  $(srcdir)/vtable-verify.c \\\n   $(srcdir)/asan.c \\\n   $(srcdir)/tsan.c \\\n   @all_gtfiles@"}, {"sha": "1f3ce9d6935f834b88594df2892ed1aeb8fab918", "filename": "gcc/aclocal.m4", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faclocal.m4?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -99,11 +99,6 @@ m4_define([AC_PROG_CC],\n           [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])\n ])\n \n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])\n m4_include([../config/acx.m4])\n m4_include([../config/codeset.m4])\n m4_include([../config/dfp.m4])\n@@ -119,4 +114,9 @@ m4_include([../config/picflag.m4])\n m4_include([../config/progtest.m4])\n m4_include([../config/stdint.m4])\n m4_include([../config/warnings.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])\n m4_include([acinclude.m4])"}, {"sha": "90822801551c4c488c44976a7765482f4b467166", "filename": "gcc/common.opt", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -2311,6 +2311,30 @@ Enum(symbol_visibility) String(hidden) Value(VISIBILITY_HIDDEN)\n EnumValue\n Enum(symbol_visibility) String(protected) Value(VISIBILITY_PROTECTED)\n \n+fvtable-verify=\n+Common Joined RejectNegative Enum(vtv_priority) Var(flag_vtable_verify) Init(VTV_NO_PRIORITY)\n+Validate vtable pointers before using them.\n+\n+Enum\n+Name(vtv_priority) Type(enum vtv_priority) UnknownError(unknown vtable verify initialization priority %qs)\n+\n+EnumValue\n+Enum(vtv_priority) String(none) Value(VTV_NO_PRIORITY)\n+\n+EnumValue\n+Enum(vtv_priority) String(std) Value(VTV_STANDARD_PRIORITY)\n+\n+EnumValue\n+Enum(vtv_priority) String(preinit) Value(VTV_PREINIT_PRIORITY)\n+\n+fvtv-counts\n+Common Var(flag_vtv_counts)\n+Output vtable verification counters.\n+\n+fvtv-debug\n+Common Var(flag_vtv_debug)\n+Output vtable verification pointer sets information.\n+\n fvpt\n Common Report Var(flag_value_profile_transformations) Optimization\n Use expression value profiles in optimizations"}, {"sha": "2c48c18655a0aa5c57a3805ceeb4c80e8ddc1fb5", "filename": "gcc/config/gnu-user.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fconfig%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fconfig%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-user.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -39,15 +39,21 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    the GNU userspace magical crtbegin.o file (see crtstuff.c) which\n    provides part of the support for getting C++ file-scope static\n    object constructed before entering `main'.  */\n-   \n+\n #if defined HAVE_LD_PIE\n #define GNU_USER_TARGET_STARTFILE_SPEC \\\n   \"%{!shared: %{pg|p|profile:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \\\n-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}\"\n+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \\\n+   %{fvtable-verify=none:%s; \\\n+     fvtable-verify=preinit:vtv_start_preinit.o%s; \\\n+     fvtable-verify=std:vtv_start.o%s}\"\n #else\n #define GNU_USER_TARGET_STARTFILE_SPEC \\\n   \"%{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \\\n-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}\"\n+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \\\n+   %{fvtable-verify=none:%s; \\\n+     fvtable-verify=preinit:vtv_start_preinit.o%s; \\\n+     fvtable-verify=std:vtv_start.o%s}\"\n #endif\n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC GNU_USER_TARGET_STARTFILE_SPEC\n@@ -59,7 +65,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    GNU userspace \"finalizer\" file, `crtn.o'.  */\n \n #define GNU_USER_TARGET_ENDFILE_SPEC \\\n-  \"%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n+  \"%{fvtable-verify=none:%s; \\\n+     fvtable-verify=preinit:vtv_end_preinit.o%s; \\\n+     fvtable-verify=std:vtv_end.o%s} \\\n+   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC GNU_USER_TARGET_ENDFILE_SPEC\n "}, {"sha": "624af2b601cf865e27b15e7b1ebb8d55ee3cb39b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,35 @@\n+2013-08-06  Caroline Tice  <cmtice@google.com>\n+\n+\t* Make-lang.in (*CXX_AND_OBJCXX_OBJS):  Add vtable-class-hierarchy.o to\n+\tlist.\n+\t(vtable-class-hierarchy.o): Add build rule.\n+\t* cp-tree.h (vtv_start_verification_constructor_init_function): New\n+\textern function decl.\n+\t(vtv_finish_verification_constructor_init_function): New extern\n+\tfunction decl.\n+\t(build_vtbl_address): New extern function decl.\n+\t(get_mangled_vtable_map_var_name): New extern function decl.\n+\t(vtv_compute_class_hierarchy_transitive_closure): New extern function\n+\tdecl.\n+\t(vtv_generate_init_routine): New extern function decl.\n+\t(vtv_save_class_info): New extern function decl.\n+\t(vtv_recover_class_info): New extern function decl.\n+\t(vtv_build_vtable_verify_fndecl): New extern function decl.\n+\t* class.c (finish_struct_1): Add call to vtv_save_class_info if\n+\tflag_vtable_verify is true.\n+\t* config-lang.in: Add vtable-class-hierarchy.c to gtfiles list.\n+\t* vtable-class-hierarchy.c: New file.\n+\t* mangle.c (get_mangled_vtable_map_var_name):  New function.\n+\t* decl2.c (start_objects): Update function comment.\n+\t(cp_write_global_declarations):  Call vtv_recover_class_info,\n+\tvtv_compute_class_hierarchy_transitive_closure and\n+\tvtv_build_vtable_verify_fndecl, before calling\n+\tfinalize_compilation_unit, and call vtv_generate_init_rount after, IFF\n+\tflag_vtable_verify is true.\n+\t(vtv_start_verification_constructor_init_function): New function.\n+\t(vtv_finish_verification_constructor_init_function): New function.\n+\t* init.c (build_vtbl_address): Remove static qualifier from function.\n+\n 2013-08-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/57825"}, {"sha": "2c1774f1e50bde280fc4920aa9b98ea519c7b597", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -80,7 +80,8 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \\\n  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n- cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o $(CXX_C_OBJS)\n+ cp/cp-gimplify.o cp/cp-array-notation.o cp/lambda.o \\\n+ cp/vtable-class-hierarchy.o $(CXX_C_OBJS)\n \n # Language-specific object files for C++.\n CXX_OBJS = cp/cp-lang.o c-family/stub-objc.o $(CXX_AND_OBJCXX_OBJS)\n@@ -341,7 +342,12 @@ cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n   c-family/c-objc.h tree-pretty-print.h $(CXX_PARSER_H) $(TIMEVAR_H)\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h $(SPLAY_TREE_H)\n-\n+cp/vtable-class-hierarchy.o: cp/vtable-class-hierarchy.c \\\n+  $(TM_H) $(TIMEVAR_H) $(CXX_TREE_H) intl.h $(CXX_PARSER_H) cp/decl.h \\\n+  $(FLAGS_H) $(DIAGNOSTIC_CORE_H) output.h $(CGRAPH_H) c-family/c-common.h \\\n+  c-family/c-objc.h $(PLUGIN_H) \\\n+  tree-iterator.h vtable-verify.h $(GIMPLE_H) \\\n+  gt-cp-vtable-class-hierarchy.h\n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(CXX_TREE_H) $(TIMEVAR_H) gt-cp-name-lookup.h $(PARAMS_H) \\\n \t$(DIAGNOSTIC_CORE_H) $(FLAGS_H) debug.h pointer-set.h"}, {"sha": "2f08d5f0c7c1b5b823a16b9f77e56e1aeaebe579", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -6485,6 +6485,9 @@ finish_struct_1 (tree t)\n \n   maybe_suppress_debug_info (t);\n \n+  if (flag_vtable_verify)\n+    vtv_save_class_info (t);\n+\n   dump_class_hierarchy (t);\n \n   /* Finish debugging output for this type.  */"}, {"sha": "4ea9b4d9a2b61f0cb1c03fa952ec6c85942e30ca", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -29,4 +29,4 @@ compilers=\"cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3\"\n \n-gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/except.c\"\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/except.c \\$(srcdir)/cp/vtable-class-hierarchy.c\""}, {"sha": "86727398fbc7c13fcb1a2acd9f8c145dbb737e1a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -5298,6 +5298,8 @@ extern void note_vague_linkage_fn\t\t(tree);\n extern tree build_artificial_parm\t\t(tree, tree);\n extern bool possibly_inlined_p\t\t\t(tree);\n extern int parm_index                           (tree);\n+extern tree vtv_start_verification_constructor_init_function (void);\n+extern tree vtv_finish_verification_constructor_init_function (tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n@@ -5388,6 +5390,7 @@ extern tree build_java_class_ref\t\t(tree);\n extern tree integral_constant_value\t\t(tree);\n extern tree decl_constant_value_safe\t        (tree);\n extern int diagnose_uninitialized_cst_or_ref_member (tree, bool, bool);\n+extern tree build_vtbl_address                  (tree);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);\n@@ -5617,7 +5620,6 @@ extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n extern int shared_member_p\t\t\t(tree);\n \n-\n /* The representation of a deferred access check.  */\n \n typedef struct GTY(()) deferred_access_check {\n@@ -6112,6 +6114,7 @@ extern tree mangle_tls_init_fn\t\t\t(tree);\n extern tree mangle_tls_wrapper_fn\t\t(tree);\n extern bool decl_tls_wrapper_p\t\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n+extern char * get_mangled_vtable_map_var_name   (tree);\n \n /* in dump.c */\n extern bool cp_dump_tree\t\t\t(void *, tree);\n@@ -6144,6 +6147,13 @@ extern bool cxx_omp_privatize_by_reference\t(const_tree);\n extern void suggest_alternatives_for            (location_t, tree);\n extern tree strip_using_decl                    (tree);\n \n+/* in vtable-class-hierarchy.c */\n+extern void vtv_compute_class_hierarchy_transitive_closure (void);\n+extern void vtv_generate_init_routine           (void);\n+extern void vtv_save_class_info                 (tree);\n+extern void vtv_recover_class_info              (void);\n+extern void vtv_build_vtable_verify_fndecl      (void);\n+\n /* In cp/cp-array-notations.c */\n extern tree expand_array_notation_exprs         (tree);\n bool cilkplus_an_triplet_types_ok_p             (location_t, tree, tree, tree,"}, {"sha": "d5d29127cfd269ddd349db113834c9a408141516", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -3039,7 +3039,8 @@ generate_tls_wrapper (tree fn)\n }\n \n /* Start the process of running a particular set of global constructors\n-   or destructors.  Subroutine of do_[cd]tors.  */\n+   or destructors.  Subroutine of do_[cd]tors.  Also called from\n+   vtv_start_verification_constructor_init_function.  */\n \n static tree\n start_objects (int method_type, int initp)\n@@ -4353,8 +4354,25 @@ cp_write_global_declarations (void)\n   timevar_stop (TV_PHASE_DEFERRED);\n   timevar_start (TV_PHASE_OPT_GEN);\n \n+  if (flag_vtable_verify)\n+    {\n+      vtv_recover_class_info ();\n+      vtv_compute_class_hierarchy_transitive_closure ();\n+      vtv_build_vtable_verify_fndecl ();\n+    }\n+\n   finalize_compilation_unit ();\n \n+  if (flag_vtable_verify)\n+    {\n+      /* Generate the special constructor initialization function that\n+         calls __VLTRegisterPairs, and give it a very high\n+         initialization priority.  This must be done after\n+         finalize_compilation_unit so that we have accurate\n+         information about which vtable will actually be emitted.  */\n+      vtv_generate_init_routine ();\n+    }\n+\n   timevar_stop (TV_PHASE_OPT_GEN);\n   timevar_start (TV_PHASE_CHECK_DBGINFO);\n \n@@ -4731,4 +4749,23 @@ mark_used (tree decl)\n   return mark_used (decl, tf_warning_or_error);\n }\n \n+tree\n+vtv_start_verification_constructor_init_function (void)\n+{\n+  return start_objects ('I', MAX_RESERVED_INIT_PRIORITY - 1);\n+}\n+\n+tree\n+vtv_finish_verification_constructor_init_function (tree function_body)\n+{\n+  tree fn;\n+\n+  finish_compound_stmt (function_body);\n+  fn = finish_function (0);\n+  DECL_STATIC_CONSTRUCTOR (fn) = 1;\n+  decl_init_priority_insert (fn, MAX_RESERVED_INIT_PRIORITY - 1);\n+\n+  return fn;\n+}\n+\n #include \"gt-cp-decl2.h\""}, {"sha": "3ec32c580acccca63dd67b0522071350951e791f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -43,7 +43,6 @@ static tree initializing_context (tree);\n static void expand_cleanup_for_base (tree, tree);\n static tree dfs_initialize_vtbl_ptrs (tree, void *);\n static tree build_field_list (tree, tree, int *);\n-static tree build_vtbl_address (tree);\n static int diagnose_uninitialized_cst_or_ref_member_1 (tree, tree, bool, bool);\n \n /* We are about to generate some complex initialization code.\n@@ -1098,7 +1097,7 @@ emit_mem_initializers (tree mem_inits)\n /* Returns the address of the vtable (i.e., the value that should be\n    assigned to the vptr) for BINFO.  */\n \n-static tree\n+tree\n build_vtbl_address (tree binfo)\n {\n   tree binfo_for = binfo;"}, {"sha": "8c11ba8d394c56e312bd1c896a8520211d935c36", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -3888,4 +3888,34 @@ write_java_integer_type_codes (const tree type)\n     gcc_unreachable ();\n }\n \n+/* Given a CLASS_TYPE, such as a record for std::bad_exception this\n+   function generates a mangled name for the vtable map variable of\n+   the class type.  For example, if the class type is\n+   \"std::bad_exception\", the mangled name for the class is\n+   \"St13bad_exception\".  This function would generate the name\n+   \"_ZN4_VTVISt13bad_exceptionE12__vtable_mapE\", which unmangles as:\n+   \"_VTV<std::bad_exception>::__vtable_map\".  */\n+\n+\n+char *\n+get_mangled_vtable_map_var_name (tree class_type)\n+{\n+  char *var_name = NULL;\n+  const char *prefix = \"_ZN4_VTVI\";\n+  const char *postfix = \"E12__vtable_mapE\";\n+\n+  gcc_assert (TREE_CODE (class_type) == RECORD_TYPE);\n+\n+  tree class_id = DECL_ASSEMBLER_NAME (TYPE_NAME (class_type));\n+  unsigned int len = strlen (IDENTIFIER_POINTER (class_id)) +\n+                     strlen (prefix) +\n+                     strlen (postfix) + 1;\n+\n+  var_name = (char *) xmalloc (len);\n+\n+  sprintf (var_name, \"%s%s%s\", prefix, IDENTIFIER_POINTER (class_id), postfix);\n+\n+  return var_name;\n+}\n+\n #include \"gt-cp-mangle.h\""}, {"sha": "479447aa7d01a00e51f2b14cd127803af07ddbf6", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "added", "additions": 1353, "deletions": 0, "changes": 1353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,1353 @@\n+/* Copyright (C) 2012-2013  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Virtual Table Pointer Security Pass - Detect corruption of vtable pointers\n+   before using them for virtual method dispatches.  */\n+\n+/* This file is part of the vtable security feature implementation.\n+   The vtable security feature is designed to detect when a virtual\n+   call is about to be made through an invalid vtable pointer\n+   (possibly due to data corruption or malicious attacks). The\n+   compiler finds every virtual call, and inserts a verification call\n+   before the virtual call.  The verification call takes the actual\n+   vtable pointer value in the object through which the virtual call\n+   is being made, and compares the vtable pointer against a set of all\n+   valid vtable pointers that the object could contain (this set is\n+   based on the declared type of the object).  If the pointer is in\n+   the valid set, execution is allowed to continue; otherwise the\n+   program is halted.\n+\n+  There are several pieces needed in order to make this work: 1. For\n+  every virtual class in the program (i.e. a class that contains\n+  virtual methods), we need to build the set of all possible valid\n+  vtables that an object of that class could point to.  This includes\n+  vtables for any class(es) that inherit from the class under\n+  consideration.  2. For every such data set we build up, we need a\n+  way to find and reference the data set.  This is complicated by the\n+  fact that the real vtable addresses are not known until runtime,\n+  when the program is loaded into memory, but we need to reference the\n+  sets at compile time when we are inserting verification calls into\n+  the program.  3.  We need to find every virtual call in the program,\n+  and insert the verification call (with the appropriate arguments)\n+  before the virtual call.  4. We need some runtime library pieces:\n+  the code to build up the data sets at runtime; the code to actually\n+  perform the verification using the data sets; and some code to set\n+  protections on the data sets, so they themselves do not become\n+  hacker targets.\n+\n+  To find and reference the set of valid vtable pointers for any given\n+  virtual class, we create a special global varible for each virtual\n+  class.  We refer to this as the \"vtable map variable\" for that\n+  class.  The vtable map variable has the type \"void *\", and is\n+  initialized by the compiler to NULL.  At runtime when the set of\n+  valid vtable pointers for a virtual class, e.g. class Foo, is built,\n+  the vtable map variable for class Foo is made to point to the set.\n+  During compile time, when the compiler is inserting verification\n+  calls into the program, it passes the vtable map variable for the\n+  appropriate class to the verification call, so that at runtime the\n+  verification call can find the appropriate data set.\n+\n+  The actual set of valid vtable pointers for a virtual class,\n+  e.g. class Foo, cannot be built until runtime, when the vtables get\n+  loaded into memory and their addresses are known.  But the knowledge\n+  about which vtables belong in which class' hierarchy is only known\n+  at compile time.  Therefore at compile time we collect class\n+  hierarchy and vtable information about every virtual class, and we\n+  generate calls to build up the data sets at runtime.  To build the\n+  data sets, we call one of the functions we add to the runtime\n+  library, __VLTRegisterPair.  __VLTRegisterPair takes two arguments,\n+  a vtable map variable and the address of a vtable.  If the vtable\n+  map variable is currently NULL, it creates a new data set (hash\n+  table), makes the vtable map variable point to the new data set, and\n+  inserts the vtable address into the data set.  If the vtable map\n+  variable is not NULL, it just inserts the vtable address into the\n+  data set.  In order to make sure that our data sets are built before\n+  any verification calls happen, we create a special constructor\n+  initialization function for each compilation unit, give it a very\n+  high initialization priority, and insert all of our calls to\n+  __VLTRegisterPair into our special constructor initialization\n+  function.\n+\n+  The vtable verification feature is controlled by the flag\n+  '-fvtable-verify='.  There are three flavors of this:\n+  '-fvtable-verify=std', '-fvtable-verify=preinit', and\n+  '-fvtable-verify=none'.  If the option '-fvtable-verfy=preinit' is\n+  used, then our constructor initialization function gets put into the\n+  preinit array.  This is necessary if there are data sets that need\n+  to be built very early in execution.  If the constructor\n+  initialization function gets put into the preinit array, the we also\n+  add calls to __VLTChangePermission at the beginning and end of the\n+  function.  The call at the beginning sets the permissions on the\n+  data sets and vtable map variables to read/write, and the one at the\n+  end makes them read-only.  If the '-fvtable-verify=std' option is\n+  used, the constructor initialization functions are executed at their\n+  normal time, and the __VLTChangePermission calls are handled\n+  differently (see the comments in libstdc++-v3/libsupc++/vtv_rts.cc).\n+  The option '-fvtable-verify=none' turns off vtable verification.\n+\n+  This file contains code to find and record the class hierarchies for\n+  the virtual classes in a program, and all the vtables associated\n+  with each such class; to generate the vtable map variables; and to\n+  generate the constructor initialization function (with the calls to\n+  __VLTRegisterPair, and __VLTChangePermission).  The main data\n+  structures used for collecting the class hierarchy data and\n+  building/maintaining the vtable map variable data are defined in\n+  gcc/vtable-verify.h, because they are used both here and in\n+  gcc/vtable-verify.c.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"timevar.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"intl.h\"\n+#include \"c-family/c-pragma.h\"\n+#include \"decl.h\"\n+#include \"flags.h\"\n+#include \"diagnostic-core.h\"\n+#include \"output.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"c-family/c-common.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"plugin.h\"\n+#include \"tree-iterator.h\"\n+#include \"vtable-verify.h\"\n+#include \"gimple.h\"\n+#include \"bitmap.h\"\n+#include \"libiberty.h\"\n+\n+#define MAX_SET_SIZE 5000\n+\n+static int num_calls_to_regset = 0;\n+static int num_calls_to_regpair = 0;\n+static int current_set_size;\n+\n+/* Mark these specially since they need to be stored in precompiled\n+   header IR.  */\n+static GTY (()) vec<tree, va_gc> *vlt_saved_class_info;\n+static GTY (()) tree vlt_register_pairs_fndecl = NULL_TREE;\n+static GTY (()) tree vlt_register_set_fndecl = NULL_TREE;\n+\n+struct work_node {\n+  struct vtv_graph_node *node;\n+  struct work_node *next;\n+};\n+\n+struct vtbl_map_node *vtable_find_or_create_map_decl (tree);\n+\n+/* As part of vtable verification the compiler generates and inserts\n+   calls to __VLTVerifyVtablePointer, which is in libstdc++.  This\n+   function builds and initializes the function decl that is used\n+   in generating those function calls.\n+\n+   In addition to __VLTVerifyVtablePointer there is also\n+   __VLTVerifyVtablePointerDebug which can be used in place of\n+   __VLTVerifyVtablePointer, and which takes extra parameters and\n+   outputs extra information, to help debug problems.  The debug\n+   version of this function is generated and used if flag_vtv_debug is\n+   true.\n+\n+   The signatures for these functions are:\n+\n+   void * __VLTVerifyVtablePointer (void **, void*);\n+   void * __VLTVerifyVtablePointerDebug (void**, void *, char *, char *);\n+*/\n+\n+void\n+vtv_build_vtable_verify_fndecl (void)\n+{\n+  tree func_type = NULL_TREE;\n+\n+  if (verify_vtbl_ptr_fndecl != NULL_TREE\n+      && TREE_CODE (verify_vtbl_ptr_fndecl) != ERROR_MARK)\n+    return;\n+\n+  if (flag_vtv_debug)\n+    {\n+      func_type = build_function_type_list (const_ptr_type_node,\n+                                            build_pointer_type (ptr_type_node),\n+                                            const_ptr_type_node,\n+                                            const_string_type_node,\n+                                            const_string_type_node,\n+                                            NULL_TREE);\n+      verify_vtbl_ptr_fndecl =\n+        build_lang_decl (FUNCTION_DECL,\n+                         get_identifier (\"__VLTVerifyVtablePointerDebug\"),\n+                         func_type);\n+    }\n+  else\n+    {\n+      func_type = build_function_type_list (const_ptr_type_node,\n+                                            build_pointer_type (ptr_type_node),\n+                                            const_ptr_type_node,\n+                                            NULL_TREE);\n+      verify_vtbl_ptr_fndecl =\n+        build_lang_decl (FUNCTION_DECL,\n+                         get_identifier (\"__VLTVerifyVtablePointer\"),\n+                         func_type);\n+    }\n+\n+  TREE_NOTHROW (verify_vtbl_ptr_fndecl) = 1;\n+  DECL_ATTRIBUTES (verify_vtbl_ptr_fndecl)\n+      = tree_cons (get_identifier (\"leaf\"), NULL,\n+                   DECL_ATTRIBUTES (verify_vtbl_ptr_fndecl));\n+  DECL_PURE_P (verify_vtbl_ptr_fndecl) = 1;\n+  TREE_PUBLIC (verify_vtbl_ptr_fndecl) = 1;\n+  DECL_PRESERVE_P (verify_vtbl_ptr_fndecl) = 1;\n+}\n+\n+/* As part of vtable verification the compiler generates and inserts\n+   calls to __VLTRegisterSet and __VLTRegisterPair, which are in\n+   libsupc++.  This function builds and initializes the function decls\n+   that are used in generating those function calls.\n+\n+   The signatures for these functions are:\n+\n+   void __VLTRegisterSetDebug (void **, const void *, std::size_t,\n+                               size_t, void **);\n+\n+   void __VLTRegisterSet (void **, const void *, std::size_t,\n+                          size_t, void **);\n+\n+   void __VLTRegisterPairDebug (void **, const void *, size_t,\n+                                const void *, const char *, const char *);\n+\n+   void __VLTRegisterPair (void **, const void *, size_t, const void *);\n+*/\n+\n+static void\n+init_functions (void)\n+{\n+  tree register_set_type;\n+  tree register_pairs_type;\n+\n+  if (vlt_register_set_fndecl != NULL_TREE)\n+    return;\n+\n+  gcc_assert (vlt_register_pairs_fndecl == NULL_TREE);\n+  gcc_assert (vlt_register_set_fndecl == NULL_TREE);\n+\n+  /* Build function decl for __VLTRegisterSet*.  */\n+\n+  register_set_type = build_function_type_list\n+                                             (void_type_node,\n+                                              build_pointer_type (ptr_type_node),\n+                                              const_ptr_type_node,\n+                                              size_type_node,\n+                                              size_type_node,\n+                                              build_pointer_type (ptr_type_node),\n+                                              NULL_TREE);\n+\n+  if (flag_vtv_debug)\n+    vlt_register_set_fndecl = build_lang_decl\n+                                       (FUNCTION_DECL,\n+                                        get_identifier (\"__VLTRegisterSetDebug\"),\n+                                        register_set_type);\n+  else\n+    vlt_register_set_fndecl = build_lang_decl\n+                                       (FUNCTION_DECL,\n+                                        get_identifier (\"__VLTRegisterSet\"),\n+                                        register_set_type);\n+\n+\n+  TREE_NOTHROW (vlt_register_set_fndecl) = 1;\n+  DECL_ATTRIBUTES (vlt_register_set_fndecl) =\n+                    tree_cons (get_identifier (\"leaf\"), NULL,\n+                               DECL_ATTRIBUTES (vlt_register_set_fndecl));\n+  TREE_PUBLIC (vlt_register_set_fndecl) = 1;\n+  DECL_PRESERVE_P (vlt_register_set_fndecl) = 1;\n+  SET_DECL_LANGUAGE (vlt_register_set_fndecl, lang_cplusplus);\n+\n+  /* Build function decl for __VLTRegisterPair*.  */\n+\n+  if (flag_vtv_debug)\n+    {\n+      register_pairs_type = build_function_type_list (void_type_node,\n+                                                      build_pointer_type\n+                                                              (ptr_type_node),\n+                                                      const_ptr_type_node,\n+                                                      size_type_node,\n+                                                      const_ptr_type_node,\n+                                                      const_string_type_node,\n+                                                      const_string_type_node,\n+                                                      NULL_TREE);\n+\n+      vlt_register_pairs_fndecl = build_lang_decl\n+                                      (FUNCTION_DECL,\n+                                       get_identifier (\"__VLTRegisterPairDebug\"),\n+                                       register_pairs_type);\n+    }\n+  else\n+    {\n+      register_pairs_type = build_function_type_list (void_type_node,\n+                                                      build_pointer_type\n+                                                              (ptr_type_node),\n+                                                      const_ptr_type_node,\n+                                                      size_type_node,\n+                                                      const_ptr_type_node,\n+                                                      NULL_TREE);\n+\n+      vlt_register_pairs_fndecl = build_lang_decl\n+                                      (FUNCTION_DECL,\n+                                       get_identifier (\"__VLTRegisterPair\"),\n+                                       register_pairs_type);\n+    }\n+\n+  TREE_NOTHROW (vlt_register_pairs_fndecl) = 1;\n+  DECL_ATTRIBUTES (vlt_register_pairs_fndecl) =\n+                    tree_cons (get_identifier (\"leaf\"), NULL,\n+                               DECL_ATTRIBUTES (vlt_register_pairs_fndecl));\n+  TREE_PUBLIC (vlt_register_pairs_fndecl) = 1;\n+  DECL_PRESERVE_P (vlt_register_pairs_fndecl) = 1;\n+  SET_DECL_LANGUAGE (vlt_register_pairs_fndecl, lang_cplusplus);\n+\n+}\n+\n+/* This is a helper function for\n+   vtv_compute_class_hierarchy_transitive_closure.  It adds a\n+   vtv_graph_node to the WORKLIST, which is a linked list of\n+   seen-but-not-yet-processed nodes.  INSERTED is a bitmap, one bit\n+   per node, to help make sure that we don't insert a node into the\n+   worklist more than once.  Each node represents a class somewhere in\n+   our class hierarchy information. Every node in the graph gets added\n+   to the worklist exactly once and removed from the worklist exactly\n+   once (when all of its children have been processed).  */\n+\n+static void\n+add_to_worklist (struct work_node **worklist, struct vtv_graph_node *node,\n+                 sbitmap inserted)\n+{\n+  struct work_node *new_work_node;\n+\n+  if (bitmap_bit_p (inserted, node->class_uid))\n+    return;\n+\n+  new_work_node = XNEW (struct work_node);\n+  new_work_node->next = *worklist;\n+  new_work_node->node = node;\n+  *worklist = new_work_node;\n+\n+  bitmap_set_bit (inserted, node->class_uid);\n+}\n+\n+/* This is a helper function for\n+   vtv_compute_class_hierarchy_transitive_closure.  It goes through\n+   the WORKLIST of class hierarchy nodes looking for a \"leaf\" node,\n+   i.e. a node whose children in the hierarchy have all been\n+   processed.  When it finds the next leaf node, it removes it from\n+   the linked list (WORKLIST) and returns the node.  */\n+\n+static struct vtv_graph_node *\n+find_and_remove_next_leaf_node (struct work_node **worklist)\n+{\n+  struct work_node *prev, *cur;\n+  struct vtv_graph_node *ret_val = NULL;\n+\n+  for (prev = NULL, cur = *worklist; cur; prev = cur, cur = cur->next)\n+    {\n+      if ((cur->node->children).length() == cur->node->num_processed_children)\n+        {\n+          if (prev == NULL)\n+            (*worklist) = cur->next;\n+          else\n+            prev->next = cur->next;\n+\n+          cur->next = NULL;\n+          ret_val = cur->node;\n+          free (cur);\n+          return ret_val;\n+        }\n+    }\n+\n+  return NULL;\n+}\n+\n+/* In our class hierarchy graph, each class node contains a bitmap,\n+   with one bit for each class in the hierarchy.  The bits are set for\n+   classes that are descendants in the graph of the current node.\n+   Initially the descendants bitmap is only set for immediate\n+   descendants.  This function traverses the class hierarchy graph,\n+   bottom up, filling in the transitive closures for the descendants\n+   as we rise up the graph.  */\n+\n+void\n+vtv_compute_class_hierarchy_transitive_closure (void)\n+{\n+  struct work_node *worklist = NULL;\n+  sbitmap inserted = sbitmap_alloc (num_vtable_map_nodes);\n+  unsigned i;\n+  unsigned j;\n+\n+  /* Note: Every node in the graph gets added to the worklist exactly\n+   once and removed from the worklist exactly once (when all of its\n+   children have been processed).  Each node's children edges are\n+   followed exactly once, and each node's parent edges are followed\n+   exactly once.  So this algorithm is roughly O(V + 2E), i.e.\n+   O(E + V).  */\n+\n+  /* Set-up:                                                                */\n+  /* Find all the \"leaf\" nodes in the graph, and add them to the worklist.  */\n+  bitmap_clear (inserted);\n+  for (j = 0; j < num_vtable_map_nodes; ++j)\n+    {\n+      struct vtbl_map_node *cur = vtbl_map_nodes_vec[j];\n+      if (cur->class_info\n+          && ((cur->class_info->children).length() == 0)\n+          && ! (bitmap_bit_p (inserted, cur->class_info->class_uid)))\n+        add_to_worklist (&worklist, cur->class_info, inserted);\n+    }\n+\n+  /* Main work: pull next leaf node off work list, process it, add its\n+     parents to the worklist, where a 'leaf' node is one that has no\n+     children, or all of its children have been processed.  */\n+  while (worklist)\n+    {\n+      struct vtv_graph_node *temp_node =\n+                                  find_and_remove_next_leaf_node (&worklist);\n+\n+      gcc_assert (temp_node != NULL);\n+      temp_node->descendants = sbitmap_alloc (num_vtable_map_nodes);\n+      bitmap_clear (temp_node->descendants);\n+      bitmap_set_bit (temp_node->descendants, temp_node->class_uid);\n+      for (i = 0; i < (temp_node->children).length(); ++i)\n+        bitmap_ior (temp_node->descendants, temp_node->descendants,\n+                        temp_node->children[i]->descendants);\n+      for (i = 0; i < (temp_node->parents).length(); ++i)\n+        {\n+          temp_node->parents[i]->num_processed_children =\n+                    temp_node->parents[i]->num_processed_children + 1;\n+          if (!bitmap_bit_p (inserted, temp_node->parents[i]->class_uid))\n+            add_to_worklist (&worklist, temp_node->parents[i], inserted);\n+        }\n+    }\n+}\n+\n+/* Keep track of which pairs we have already created __VLTRegisterPair\n+   calls for, to prevent creating duplicate calls within the same\n+   compilation unit.  VTABLE_DECL is the var decl for the vtable of\n+   the (descendant) class that we are adding to our class hierarchy\n+   data.  VPTR_ADDRESS is an expression for calculating the correct\n+   offset into the vtable (VTABLE_DECL).  It is the actual vtable\n+   pointer address that will be stored in our list of valid vtable\n+   pointers for BASE_CLASS.  BASE_CLASS is the record_type node for\n+   the base class to whose hiearchy we want to add\n+   VPTR_ADDRESS. (VTABLE_DECL should be the vtable for BASE_CLASS or\n+   one of BASE_CLASS' descendents.  */\n+\n+static bool\n+check_and_record_registered_pairs (tree vtable_decl, tree vptr_address,\n+                                   tree base_class)\n+{\n+  unsigned offset;\n+  struct vtbl_map_node *base_vtable_map_node;\n+  bool inserted_something = false;\n+\n+\n+  if (TREE_CODE (vptr_address) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (vptr_address, 0)) == MEM_REF)\n+    vptr_address = TREE_OPERAND (vptr_address, 0);\n+\n+  if (TREE_OPERAND_LENGTH (vptr_address) > 1)\n+    offset = TREE_INT_CST_LOW (TREE_OPERAND (vptr_address, 1));\n+  else\n+    offset = 0;\n+\n+  base_vtable_map_node = vtbl_map_get_node (TYPE_MAIN_VARIANT (base_class));\n+\n+  inserted_something = vtbl_map_node_registration_insert\n+                                                        (base_vtable_map_node,\n+                                                         vtable_decl,\n+                                                         offset);\n+  return !inserted_something;\n+}\n+\n+/* Given an IDENTIFIER_NODE, build and return a string literal based on it.  */\n+\n+static tree\n+build_string_from_id (tree identifier)\n+{\n+  int len;\n+\n+  gcc_assert (TREE_CODE (identifier) == IDENTIFIER_NODE);\n+\n+  len = IDENTIFIER_LENGTH (identifier);\n+  return build_string_literal (len + 1, IDENTIFIER_POINTER (identifier));\n+}\n+\n+/* A class may contain secondary vtables in it, for various reasons.\n+   This function goes through the decl chain of a class record looking\n+   for any fields that point to secondary vtables, and adding calls to\n+   __VLTRegisterPair for the secondary vtable pointers.\n+\n+   BASE_CLASS_DECL_ARG is an expression for the address of the vtable\n+   map variable for the BASE_CLASS (whose hierarchy we are currently\n+   updating).  BASE_CLASS is the record_type node for the base class.\n+   RECORD_TYPE is the record_type node for the descendant class that\n+   we are possibly adding to BASE_CLASS's hierarchy.  BODY is the\n+   function body for the constructor init function to which we are\n+   adding our calls to __VLTRegisterPair.  */\n+\n+static void\n+register_construction_vtables (tree base_class, tree record_type,\n+                               tree *vtable_ptr_array, int *num_args)\n+{\n+  tree vtbl_var_decl;\n+\n+  if (TREE_CODE (record_type) != RECORD_TYPE)\n+    return;\n+\n+  vtbl_var_decl = CLASSTYPE_VTABLES (record_type);\n+\n+  if (CLASSTYPE_VBASECLASSES (record_type))\n+    {\n+      tree vtt_decl;\n+      bool already_registered = false;\n+      tree val_vtbl_decl = NULL_TREE;\n+\n+      vtt_decl = DECL_CHAIN (vtbl_var_decl);\n+\n+      /* Check to see if we have found a VTT.  Add its data if appropriate.  */\n+      if (vtt_decl)\n+        {\n+          tree values = DECL_INITIAL (vtt_decl);\n+          if (TREE_ASM_WRITTEN (vtt_decl)\n+              && values != NULL_TREE\n+              && TREE_CODE (values) == CONSTRUCTOR\n+              && TREE_CODE (TREE_TYPE (values)) == ARRAY_TYPE)\n+            {\n+              unsigned HOST_WIDE_INT cnt;\n+              constructor_elt *ce;\n+\n+              /* Loop through the initialization values for this\n+                 vtable to get all the correct vtable pointer\n+                 addresses that we need to add to our set of valid\n+                 vtable pointers for the current base class.  This may\n+                 result in adding more than just the element assigned\n+                 to the primary vptr of the class, so we may end up\n+                 with more vtable pointers than are strictly\n+                 necessary.  */\n+\n+              for (cnt = 0;\n+                   vec_safe_iterate (CONSTRUCTOR_ELTS (values),\n+                                     cnt, &ce);\n+                   cnt++)\n+                {\n+                  tree value = ce->value;\n+\n+                  /* Search for the ADDR_EXPR operand within the value.  */\n+\n+                  while (value\n+                         && TREE_OPERAND (value, 0)\n+                         && TREE_CODE (TREE_OPERAND (value, 0)) == ADDR_EXPR)\n+                    value = TREE_OPERAND (value, 0);\n+\n+                  /* The VAR_DECL for the vtable should be the first\n+                     argument of the ADDR_EXPR, which is the first\n+                     argument of value.*/\n+\n+                  if (TREE_OPERAND (value, 0))\n+                    val_vtbl_decl = TREE_OPERAND (value, 0);\n+\n+                  while (TREE_CODE (val_vtbl_decl) != VAR_DECL\n+                         && TREE_OPERAND (val_vtbl_decl, 0))\n+                    val_vtbl_decl = TREE_OPERAND (val_vtbl_decl, 0);\n+\n+                  gcc_assert (TREE_CODE (val_vtbl_decl) == VAR_DECL);\n+\n+                  /* Check to see if we already have this vtable pointer in\n+                     our valid set for this base class.  */\n+\n+                  already_registered = check_and_record_registered_pairs\n+                                                               (val_vtbl_decl,\n+                                                                value,\n+                                                                base_class);\n+\n+                  if (already_registered)\n+                    continue;\n+\n+                  /* Add this vtable pointer to our set of valid\n+                     pointers for the base class.  */\n+\n+                  gcc_assert (*num_args < (MAX_SET_SIZE - 1));\n+\n+                  vtable_ptr_array[*num_args] = value;\n+                  *num_args = *num_args + 1;\n+                  current_set_size++;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/* This function iterates through all the vtables it can find from the\n+   BINFO of a class, to make sure we have found ALL of the vtables\n+   that an object of that class could point to.  Generate calls to\n+   __VLTRegisterPair for those vtable pointers that we find.\n+\n+   BINFO is the tree_binfo node for the BASE_CLASS.  BODY is the\n+   function body for the constructor init function to which we are\n+   adding calls to __VLTRegisterPair.  ARG1 is an expression for the\n+   address of the vtable map variable (for the BASE_CLASS), that will\n+   point to the updated data set.  BASE_CLASS is the record_type node\n+   for the base class whose set of valid vtable pointers we are\n+   updating. STR1 and STR2 are all debugging information, to be passed\n+   as parameters to __VLTRegisterPairDebug.  STR1 represents the name\n+   of the vtable map variable to be updated by the call.  Similarly,\n+   STR2 represents the name of the class whose vtable pointer is being\n+   added to the hierarchy.  */\n+\n+static void\n+register_other_binfo_vtables (tree binfo, tree base_class,\n+                              tree *vtable_ptr_array, int *num_args)\n+{\n+  unsigned ix;\n+  tree base_binfo;\n+  tree vtable_decl;\n+  bool already_registered;\n+\n+  if (binfo == NULL_TREE)\n+    return;\n+\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+    {\n+      if ((!BINFO_PRIMARY_P (base_binfo)\n+           || BINFO_VIRTUAL_P (base_binfo))\n+          && (vtable_decl = get_vtbl_decl_for_binfo (base_binfo)))\n+        {\n+          tree vtable_address = build_vtbl_address (base_binfo);\n+\n+          already_registered = check_and_record_registered_pairs\n+                                                              (vtable_decl,\n+                                                               vtable_address,\n+                                                               base_class);\n+          if (!already_registered)\n+            {\n+              gcc_assert (*num_args < (MAX_SET_SIZE - 1));\n+\n+              vtable_ptr_array[*num_args] = vtable_address;\n+              *num_args = *num_args + 1;\n+              current_set_size++;\n+            }\n+        }\n+\n+      register_other_binfo_vtables (base_binfo, base_class, vtable_ptr_array,\n+                                    num_args);\n+    }\n+}\n+\n+/* The set of valid vtable pointers for any given class are stored in\n+   a hash table.  For reasons of efficiency, that hash table size is\n+   always a power of two.  In order to try to prevent re-sizing the\n+   hash tables very often, we pass __VLTRegisterPair an initial guess\n+   as to the number of entries the hashtable will eventually need\n+   (rounded up to the nearest power of two).  This function takes the\n+   class information we have collected for a particular class,\n+   CLASS_NODE, and calculates the hash table size guess.  */\n+\n+static int\n+guess_num_vtable_pointers (struct vtv_graph_node *class_node)\n+{\n+  tree vtbl;\n+  int total_num_vtbls = 0;\n+  int num_vtbls_power_of_two = 1;\n+  unsigned i;\n+\n+  for (i = 0; i < num_vtable_map_nodes; ++i)\n+    if (bitmap_bit_p (class_node->descendants, i))\n+      {\n+        tree class_type = vtbl_map_nodes_vec[i]->class_info->class_type;\n+        for (vtbl = CLASSTYPE_VTABLES (class_type); vtbl;\n+             vtbl = DECL_CHAIN (vtbl))\n+          {\n+            total_num_vtbls++;\n+            if (total_num_vtbls > num_vtbls_power_of_two)\n+              num_vtbls_power_of_two <<= 1;\n+          }\n+      }\n+  return num_vtbls_power_of_two;\n+}\n+\n+/* A simple hash function on strings */\n+/* Be careful about changing this routine. The values generated will\n+   be stored in the calls to InitSet. So, changing this routine may\n+   cause a binary incompatibility.  */\n+\n+static uint32_t\n+vtv_string_hash (const char *in)\n+{\n+  const char *s = in;\n+  uint32_t h = 0;\n+\n+  gcc_assert (in != NULL);\n+  for ( ; *s; ++s)\n+    h = 5 * h + *s;\n+  return h;\n+}\n+\n+static char *\n+get_log_file_name (const char *fname)\n+{\n+  const char *tmp_dir = concat (dump_dir_name, NULL);\n+  char *full_name;\n+  int dir_len;\n+  int fname_len;\n+\n+  dir_len = strlen (tmp_dir);\n+  fname_len = strlen (fname);\n+\n+  full_name = XNEWVEC (char, dir_len + fname_len + 1);\n+  strcpy (full_name, tmp_dir);\n+  strcpy (full_name + dir_len, fname);\n+\n+  return full_name;\n+}\n+\n+static void\n+write_out_current_set_data (tree base_class, int set_size)\n+{\n+  static int class_data_log_fd = -1;\n+  char buffer[1024];\n+  int bytes_written __attribute__ ((unused));\n+  char *file_name = get_log_file_name (\"vtv_class_set_sizes.log\");\n+\n+  if (class_data_log_fd == -1)\n+    class_data_log_fd = open (file_name,\n+                              O_WRONLY | O_APPEND | O_CREAT, S_IRWXU);\n+\n+  if (class_data_log_fd == -1)\n+    {\n+      warning (0, \"Unable to open log file 'vtv_class_set_sizes.log'\");\n+      return;\n+    }\n+\n+  snprintf (buffer, sizeof (buffer), \"%s %d\\n\",\n+            IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (base_class))),\n+            set_size);\n+  bytes_written = write (class_data_log_fd, buffer, strlen (buffer));\n+}\n+\n+static tree\n+build_key_buffer_arg (tree base_ptr_var_decl)\n+{\n+  const int key_type_fixed_size = 8;\n+  uint32_t len1 = IDENTIFIER_LENGTH (DECL_NAME (base_ptr_var_decl));\n+  uint32_t hash_value = vtv_string_hash (IDENTIFIER_POINTER\n+                                              (DECL_NAME (base_ptr_var_decl)));\n+  void *key_buffer = xmalloc (len1 + key_type_fixed_size);\n+  uint32_t *value_ptr = (uint32_t *) key_buffer;\n+  tree ret_value;\n+\n+  /* Set the len and hash for the string.  */\n+  *value_ptr = len1;\n+  value_ptr++;\n+  *value_ptr = hash_value;\n+\n+  /* Now copy the string representation of the vtbl map name...  */\n+  memcpy ((char *) key_buffer + key_type_fixed_size,\n+          IDENTIFIER_POINTER (DECL_NAME (base_ptr_var_decl)),\n+          len1);\n+\n+  /* ... and build a string literal from it. This will make a copy\n+     so the key_bufffer is not needed anymore after this.  */\n+  ret_value = build_string_literal (len1 + key_type_fixed_size,\n+                                    (char *) key_buffer);\n+  free (key_buffer);\n+  return ret_value;\n+}\n+\n+static void\n+insert_call_to_register_set (tree class_name, int num_args,\n+                             tree *vtbl_ptr_array, tree body, tree arg1,\n+                             tree arg2, tree size_hint_arg)\n+{\n+  tree call_expr;\n+  char *array_arg_name = ACONCAT ((\"__vptr_array_\",\n+                                   IDENTIFIER_POINTER (class_name), NULL));\n+  tree array_arg_type = build_array_type_nelts (build_pointer_type\n+                                                  (build_pointer_type\n+                                                     (void_type_node)),\n+                                                num_args);\n+  tree array_arg = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+                               get_identifier (array_arg_name),\n+                               array_arg_type);\n+  int k;\n+\n+  vec<constructor_elt, va_gc> *array_elements;\n+  vec_alloc (array_elements, num_args);\n+                                                        \n+  tree initial = NULL_TREE;\n+  tree arg3 = NULL_TREE;\n+\n+  TREE_PUBLIC (array_arg) = 0;\n+  DECL_EXTERNAL (array_arg) = 0;\n+  TREE_STATIC (array_arg) = 1;\n+  DECL_ARTIFICIAL (array_arg) = 0;\n+  TREE_READONLY (array_arg) = 1;\n+  DECL_IGNORED_P (array_arg) = 0;\n+  DECL_PRESERVE_P (array_arg) = 0;\n+  DECL_VISIBILITY (array_arg) = VISIBILITY_HIDDEN;\n+\n+  for (k = 0; k < num_args; ++k)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (array_elements, NULL_TREE, vtbl_ptr_array[k]);\n+    }\n+\n+  initial = build_constructor (TREE_TYPE (array_arg), array_elements);\n+\n+  TREE_CONSTANT (initial) = 1;\n+  TREE_STATIC (initial) = 1;\n+  DECL_INITIAL (array_arg) = initial;\n+  relayout_decl (array_arg);\n+  varpool_finalize_decl (array_arg);\n+\n+  arg3 = build1 (ADDR_EXPR, TYPE_POINTER_TO (TREE_TYPE (array_arg)), array_arg);\n+\n+  TREE_TYPE (arg3) = build_pointer_type (TREE_TYPE (array_arg));\n+\n+  call_expr = build_call_expr (vlt_register_set_fndecl, 5, arg1,\n+                               arg2, /* set_symbol_key */\n+                               size_hint_arg, build_int_cst (size_type_node,\n+                                                             num_args),\n+                               arg3);\n+  append_to_statement_list (call_expr, &body);\n+  num_calls_to_regset++;\n+}\n+\n+static void\n+insert_call_to_register_pair (tree vtable_address, int num_args, tree arg1,\n+                              tree arg2, tree size_hint_arg, tree str1,\n+                              tree str2, tree body)\n+{\n+  tree call_expr;\n+\n+  if (num_args == 0)\n+    vtable_address = build_int_cst (build_pointer_type (void_type_node), 0);\n+\n+  if (flag_vtv_debug)\n+    call_expr = build_call_expr (vlt_register_pairs_fndecl, 6, arg1, arg2,\n+                                 size_hint_arg, vtable_address, str1, str2);\n+  else\n+    call_expr = build_call_expr (vlt_register_pairs_fndecl, 4, arg1, arg2,\n+                                 size_hint_arg, vtable_address);\n+    \n+  append_to_statement_list (call_expr, &body);\n+  num_calls_to_regpair++;\n+}\n+\n+static void\n+output_set_info (tree record_type, tree *vtbl_ptr_array, int array_size)\n+{\n+  static int vtv_debug_log_fd = -1;\n+  char buffer[1024];\n+  int bytes_written __attribute__ ((unused));\n+  const char *class_name =\n+              IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (record_type)));\n+  char *file_name = get_log_file_name (\"vtv_set_ptr_data.log\");\n+\n+  if (vtv_debug_log_fd == -1)\n+    vtv_debug_log_fd = open (file_name,\n+                             O_WRONLY | O_APPEND | O_CREAT, S_IRWXU);\n+  if (vtv_debug_log_fd == -1)\n+    {\n+      warning (0, \"Unable to open log file 'vtv_set_ptr_data.log'\");\n+      return;\n+    }\n+\n+  for (int i = 0; i < array_size; ++i)\n+    {\n+      const char *vptr_name = \"unknown\";\n+      int vptr_offset = 0;\n+      \n+      if (TREE_CODE (vtbl_ptr_array[i]) == POINTER_PLUS_EXPR)\n+        {\n+          tree arg0 = TREE_OPERAND (vtbl_ptr_array[i], 0);\n+          tree arg1 = TREE_OPERAND (vtbl_ptr_array[i], 1);\n+\n+          if (TREE_CODE (arg0) == ADDR_EXPR)\n+            arg0 = TREE_OPERAND (arg0, 0);\n+\n+          if (TREE_CODE (arg0) == VAR_DECL)\n+            vptr_name = IDENTIFIER_POINTER (DECL_NAME (arg0));\n+\n+          if (TREE_CODE (arg1) == INTEGER_CST)\n+            vptr_offset = TREE_INT_CST_LOW (arg1);\n+        }\n+\n+      snprintf (buffer, sizeof (buffer), \"%s %s %s + %d\\n\",\n+                main_input_filename, class_name, vptr_name, vptr_offset);\n+      bytes_written = write (vtv_debug_log_fd, buffer, strlen(buffer));\n+    }\n+\n+}\n+\n+/* This function goes through our internal class hierarchy & vtable\n+   pointer data structure and outputs calls to __VLTRegisterPair for\n+   every class-vptr pair (for those classes whose vtable would be\n+   output in the current compilation unit).  These calls get put into\n+   our constructor initialization function.  BODY is the function\n+   body, so far, of our constructor initialization function, to which we\n+   add the calls.  */\n+\n+static bool\n+register_all_pairs (tree body)\n+{\n+  bool registered_at_least_one = false;\n+  tree vtbl_ptr_array[MAX_SET_SIZE];\n+  int num_vtable_args = 0;\n+  unsigned j;\n+\n+  for (j = 0; j < num_vtable_map_nodes; ++j)\n+    {\n+      struct vtbl_map_node *current = vtbl_map_nodes_vec[j];\n+      unsigned i = 0;\n+      tree base_class = current->class_info->class_type;\n+      tree base_ptr_var_decl = current->vtbl_map_decl;\n+      tree arg1;\n+      tree arg2;\n+      tree new_type;\n+      tree str1 = NULL_TREE;\n+      tree str2 = NULL_TREE;\n+      size_t size_hint;\n+      tree size_hint_arg;\n+\n+      gcc_assert (current->class_info != NULL);\n+\n+\n+      if (flag_vtv_debug)\n+        str1 = build_string_from_id (DECL_NAME (base_ptr_var_decl));\n+\n+      new_type = build_pointer_type (TREE_TYPE (base_ptr_var_decl));\n+      arg1 = build1 (ADDR_EXPR, new_type, base_ptr_var_decl);\n+\n+      num_vtable_args = 0;\n+\n+      for (i = 0; i < num_vtable_map_nodes; ++i)\n+        if (bitmap_bit_p (current->class_info->descendants, i))\n+          {\n+            struct vtbl_map_node *vtbl_class_node = vtbl_map_nodes_vec[i];\n+            tree class_type = vtbl_class_node->class_info->class_type;\n+\n+            if (class_type\n+                && (TREE_CODE (class_type) == RECORD_TYPE))\n+              {\n+                bool already_registered;\n+\n+                tree binfo = TYPE_BINFO (class_type);\n+                tree vtable_decl;\n+                bool vtable_should_be_output = false;\n+\n+                vtable_decl = CLASSTYPE_VTABLES (class_type);\n+\n+                /* Handle main vtable for this class.  */\n+\n+                if (vtable_decl)\n+                  {\n+                    vtable_should_be_output = TREE_ASM_WRITTEN (vtable_decl);\n+                    str2 = build_string_from_id (DECL_NAME (vtable_decl));\n+                  }\n+\n+                if (vtable_decl && vtable_should_be_output)\n+                  {\n+                    tree vtable_address = build_vtbl_address (binfo);\n+\n+                    already_registered = check_and_record_registered_pairs\n+                                                              (vtable_decl,\n+                                                               vtable_address,\n+                                                               base_class);\n+\n+\n+                    if (!already_registered)\n+                      {\n+\n+                        vtbl_ptr_array[num_vtable_args++] = vtable_address;\n+\n+                        /* Find and handle any 'extra' vtables associated\n+                           with this class, via virtual inheritance.   */\n+                        register_construction_vtables (base_class, class_type,\n+                                                       vtbl_ptr_array,\n+                                                       &num_vtable_args);\n+\n+                        /* Find and handle any 'extra' vtables associated\n+                           with this class, via multiple inheritance.   */\n+                        register_other_binfo_vtables (binfo, base_class,\n+                                                      vtbl_ptr_array,\n+                                                      &num_vtable_args);\n+                      }\n+                  }\n+              }\n+          }\n+      current_set_size = num_vtable_args;\n+\n+      /* Sometimes we need to initialize the set symbol even if we are\n+         not adding any vtable pointers to the set in the current\n+         compilation unit.  In that case, we need to initialize the\n+         set to our best guess as to what the eventual size of the set\n+         hash table will be (to prevent having to re-size the hash\n+         table later).  */\n+\n+      size_hint = guess_num_vtable_pointers (current->class_info);\n+\n+      /* If we have added vtable pointers to the set in this\n+         compilation unit, adjust the size hint for the set's hash\n+         table appropriately.  */\n+      if (num_vtable_args > 0)\n+        while ((size_t) num_vtable_args > size_hint)\n+          size_hint <<= 1;\n+      size_hint_arg = build_int_cst (size_type_node, size_hint);\n+\n+      /* Get the key-buffer argument.  */\n+      arg2 = build_key_buffer_arg (base_ptr_var_decl);\n+\n+      if (str2 == NULL_TREE)\n+        str2 = build_string_literal (strlen (\"unknown\") + 1,\n+                                     \"unknown\");\n+\n+      if (flag_vtv_debug)\n+        output_set_info (current->class_info->class_type,\n+                         vtbl_ptr_array, num_vtable_args);\n+\n+      if (num_vtable_args > 1)\n+        {\n+          insert_call_to_register_set (current->class_name, num_vtable_args,\n+                                       vtbl_ptr_array, body, arg1, arg2,\n+                                       size_hint_arg);\n+          registered_at_least_one = true;\n+        }\n+      else if (num_vtable_args >= 0)\n+        {\n+\n+          if (num_vtable_args > 0\n+              || (current->is_used\n+                  || (current->registered.size() > 0)))\n+            {\n+              insert_call_to_register_pair (vtbl_ptr_array[0], num_vtable_args,\n+                                            arg1, arg2, size_hint_arg, str1,\n+                                            str2, body);\n+              registered_at_least_one = true;\n+            }\n+        }\n+\n+      if (flag_vtv_counts && current_set_size > 0)\n+        write_out_current_set_data (base_class, current_set_size);\n+\n+    }\n+\n+  return registered_at_least_one;\n+}\n+\n+/* Given a tree containing a class type (CLASS_TYPE), this function\n+   finds and returns the class hierarchy node for that class in our\n+   data structure.  */\n+\n+static struct vtv_graph_node *\n+find_graph_node (tree class_type)\n+{\n+  struct vtbl_map_node *vtbl_node;\n+\n+  vtbl_node = vtbl_map_get_node (TYPE_MAIN_VARIANT (class_type));\n+  if (vtbl_node)\n+    return vtbl_node->class_info;\n+\n+  return NULL;\n+}\n+\n+/* Add base class/derived class pair to our internal class hierarchy\n+   data structure.  BASE_NODE is our vtv_graph_node that corresponds\n+   to a base class.  DERIVED_NODE is our vtv_graph_node that\n+   corresponds to a class that is a descendant of the base class\n+   (possibly the base class itself).  */\n+\n+static void\n+add_hierarchy_pair (struct vtv_graph_node *base_node,\n+                    struct vtv_graph_node *derived_node)\n+{\n+  (base_node->children).safe_push (derived_node);\n+  (derived_node->parents).safe_push (base_node);\n+}\n+\n+/* This functions adds a new base class/derived class relationship to\n+   our class hierarchy data structure.  Both parameters are trees\n+   representing the class types, i.e. RECORD_TYPE trees.\n+   DERIVED_CLASS can be the same as BASE_CLASS.  */\n+\n+static void\n+update_class_hierarchy_information (tree base_class,\n+                                    tree derived_class)\n+{\n+  struct vtv_graph_node *base_node = find_graph_node (base_class);\n+  struct vtv_graph_node *derived_node = find_graph_node (derived_class);\n+\n+  add_hierarchy_pair (base_node, derived_node);\n+}\n+\n+\n+static void\n+write_out_vtv_count_data (void)\n+{\n+  static int vtv_count_log_fd = -1;\n+  char buffer[1024];\n+  int unused_vtbl_map_vars = 0;\n+  int bytes_written __attribute__ ((unused));\n+  char *file_name = get_log_file_name (\"vtv_count_data.log\");\n+\n+  if (vtv_count_log_fd == -1)\n+    vtv_count_log_fd = open (file_name,\n+                             O_WRONLY | O_APPEND | O_CREAT, S_IRWXU);\n+  if (vtv_count_log_fd == -1)\n+    {\n+      warning (0, \"Unable to open log file 'vtv_count_data.log'\");\n+      return;\n+    }\n+\n+  for (unsigned i = 0; i < num_vtable_map_nodes; ++i)\n+    {\n+      struct vtbl_map_node *current = vtbl_map_nodes_vec[i];\n+      if (!current->is_used\n+          && current->registered.size() == 0)\n+        unused_vtbl_map_vars++;\n+    }\n+\n+  snprintf (buffer, sizeof (buffer), \"%s %d %d %d %d %d\\n\",\n+            main_input_filename, total_num_virtual_calls,\n+            total_num_verified_vcalls, num_calls_to_regset,\n+            num_calls_to_regpair, unused_vtbl_map_vars);\n+\n+  bytes_written = write (vtv_count_log_fd, buffer, strlen (buffer));\n+}\n+\n+/* This function calls register_all_pairs, which actually generates\n+   all the calls to __VLTRegisterPair (in the verification constructor\n+   init function).  It also generates the calls to\n+   __VLTChangePermission, if the verification constructor init\n+   function is going into the preinit array.  INIT_ROUTINE_BODY is\n+   the body of our constructior initialization function, to which we\n+   add our function calls.*/\n+\n+bool\n+vtv_register_class_hierarchy_information (tree init_routine_body)\n+{\n+  bool registered_something = false;\n+ \n+  init_functions ();\n+\n+  if (num_vtable_map_nodes == 0)\n+    return false;\n+\n+  /* Add class hierarchy pairs to the vtable map data structure.  */\n+  registered_something = register_all_pairs (init_routine_body);\n+\n+  if (flag_vtv_counts)\n+    write_out_vtv_count_data ();\n+\n+  return registered_something;\n+}\n+\n+\n+/* Generate the special constructor function that calls\n+   __VLTChangePermission and __VLTRegisterPairs, and give it a very\n+   high initialization priority.  */\n+\n+void\n+vtv_generate_init_routine (void)\n+{\n+  tree init_routine_body;\n+  bool vtable_classes_found = false;\n+\n+  push_lang_context (lang_name_c);\n+\n+  /* The priority for this init function (constructor) is carefully\n+     chosen so that it will happen after the calls to unprotect the\n+     memory used for vtable verification and before the memory is\n+     protected again.  */\n+  init_routine_body = vtv_start_verification_constructor_init_function ();\n+\n+  vtable_classes_found =\n+                 vtv_register_class_hierarchy_information (init_routine_body);\n+\n+  if (vtable_classes_found)\n+    {\n+      tree vtv_fndecl =\n+        vtv_finish_verification_constructor_init_function (init_routine_body);\n+      TREE_STATIC (vtv_fndecl) = 1;\n+      TREE_USED (vtv_fndecl) = 1;\n+      DECL_PRESERVE_P (vtv_fndecl) = 1;\n+      if (flag_vtable_verify == VTV_PREINIT_PRIORITY)\n+        {\n+          DECL_STATIC_CONSTRUCTOR (vtv_fndecl) = 0;\n+          assemble_vtv_preinit_initializer (vtv_fndecl);\n+        }\n+\n+      gimplify_function_tree (vtv_fndecl);\n+      cgraph_add_new_function (vtv_fndecl, false);\n+\n+      cgraph_process_new_functions ();\n+    }\n+  pop_lang_context ();\n+}\n+\n+/* This funtion takes a tree containing a class type (BASE_TYPE), and\n+   it either finds the existing vtbl_map_node for that class in our\n+   data structure, or it creates a new node and adds it to the data\n+   structure if there is not one for the class already.  As part of\n+   this process it also creates the global vtable map variable for the\n+   class.  */\n+\n+struct vtbl_map_node *\n+vtable_find_or_create_map_decl (tree base_type)\n+{\n+  char *var_name = NULL;\n+  struct vtbl_map_node *vtable_map_node = NULL;\n+\n+  /* Verify the type has an associated vtable.  */\n+  if (!TYPE_BINFO (base_type) || !BINFO_VTABLE (TYPE_BINFO (base_type)))\n+    return NULL;\n+\n+  /* Create map lookup symbol for base class */\n+  var_name = get_mangled_vtable_map_var_name (base_type);\n+\n+  /* We've already created the variable; just look it.  */\n+  vtable_map_node = vtbl_map_get_node (TYPE_MAIN_VARIANT (base_type));\n+\n+  if (!vtable_map_node || (vtable_map_node->vtbl_map_decl == NULL_TREE))\n+    {\n+      /* If we haven't already created the *__vtable_map global\n+         variable for this class, do so now, and add it to the\n+         varpool, to make sure it gets saved and written out.  */\n+\n+      tree var_decl = NULL;\n+      tree var_type = build_pointer_type (void_type_node);\n+      tree initial_value = integer_zero_node;\n+\n+      var_decl  = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+                              get_identifier (var_name), var_type);\n+\n+      DECL_EXTERNAL (var_decl) = 0;\n+      TREE_STATIC (var_decl) = 1;\n+      DECL_VISIBILITY (var_decl) = VISIBILITY_HIDDEN;\n+      SET_DECL_ASSEMBLER_NAME (var_decl, get_identifier (var_name));\n+      DECL_ARTIFICIAL (var_decl) = 1;\n+      /* We cannot mark this variable as read-only because we want to be\n+         able to write to it at runtime.  */\n+      TREE_READONLY (var_decl) = 0;\n+      DECL_IGNORED_P (var_decl) = 1;\n+      DECL_PRESERVE_P (var_decl) = 1;\n+\n+      /* Put these mmap variables in thr .vtable_map_vars section, so\n+         we can find and protect them.  */\n+\n+      DECL_SECTION_NAME (var_decl) = build_string (strlen (\".vtable_map_vars\"),\n+                                                   \".vtable_map_vars\");\n+      DECL_HAS_IMPLICIT_SECTION_NAME_P (var_decl) = true;\n+      DECL_INITIAL (var_decl) = initial_value;\n+\n+      comdat_linkage (var_decl);\n+\n+      varpool_finalize_decl (var_decl);\n+      if (!vtable_map_node)\n+        vtable_map_node =\n+                   find_or_create_vtbl_map_node (TYPE_MAIN_VARIANT (base_type));\n+      if (vtable_map_node->vtbl_map_decl == NULL_TREE)\n+        vtable_map_node->vtbl_map_decl = var_decl;\n+    }\n+\n+  gcc_assert (vtable_map_node);\n+  return vtable_map_node;\n+}\n+\n+/* This function is used to build up our class hierarchy data for a\n+   particular class.  TYPE is the record_type tree node for the\n+   class.  */\n+\n+static void\n+vtv_insert_single_class_info (tree type)\n+{\n+  if (flag_vtable_verify)\n+    {\n+      tree binfo =  TYPE_BINFO (type);\n+      tree base_binfo;\n+      struct vtbl_map_node *own_map;\n+      int i;\n+\n+      /* First make sure to create the map for this record type.  */\n+      own_map = vtable_find_or_create_map_decl (type);\n+      if (own_map == NULL)\n+        return;\n+\n+      /* Go through the list of all base classes for the current\n+         (derived) type, make sure the *__vtable_map global variable\n+         for the base class exists, and add the base class/derived\n+         class pair to the class hierarchy information we are\n+         accumulating (for vtable pointer verification).  */\n+      for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+        {\n+          tree tree_val = BINFO_TYPE (base_binfo);\n+          struct vtbl_map_node *vtable_map_node = NULL;\n+\n+          vtable_map_node = vtable_find_or_create_map_decl (tree_val);\n+\n+          if (vtable_map_node != NULL)\n+            update_class_hierarchy_information (tree_val, type);\n+        }\n+    }\n+}\n+\n+/* This function adds classes we are interested in to a list of\n+   classes.  RECORD is the record_type node for the class we are\n+   adding to the list.  */\n+\n+void\n+vtv_save_class_info (tree record)\n+{\n+  if (!flag_vtable_verify || TREE_CODE (record) == UNION_TYPE)\n+    return;\n+\n+  if (!vlt_saved_class_info)\n+    vec_alloc (vlt_saved_class_info, 10);\n+\n+  gcc_assert (TREE_CODE (record) == RECORD_TYPE);\n+\n+  vec_safe_push (vlt_saved_class_info, record);\n+}\n+\n+\n+/* This function goes through the list of classes we saved and calls\n+   vtv_insert_single_class_info on each one, to build up our class\n+   hierarchy data structure.  */\n+\n+void\n+vtv_recover_class_info (void)\n+{\n+  tree current_class;\n+  unsigned i;\n+\n+  if (vlt_saved_class_info)\n+    {\n+      for (i = 0; i < vlt_saved_class_info->length(); ++i)\n+        {\n+          current_class = (*vlt_saved_class_info)[i];\n+          gcc_assert (TREE_CODE (current_class) == RECORD_TYPE);\n+          vtv_insert_single_class_info (current_class);\n+        }\n+    }\n+}\n+\n+#include \"gt-cp-vtable-class-hierarchy.h\""}, {"sha": "14955dd1be0420f67fa892bde49a4c9425058fd6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -191,6 +191,8 @@ in the following sections.\n -ftemplate-depth=@var{n} @gol\n -fno-threadsafe-statics -fuse-cxa-atexit  -fno-weak  -nostdinc++ @gol\n -fno-default-inline  -fvisibility-inlines-hidden @gol\n+-fvtable-verify=@var{std|preinit|none} @gol\n+-fvtv-counts -fvtv-debug @gol\n -fvisibility-ms-compat @gol\n -fext-numeric-literals @gol\n -Wabi  -Wconversion-null  -Wctor-dtor-privacy @gol\n@@ -318,6 +320,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-sra@r{[}-@var{n}@r{]} @gol\n -fdump-tree-forwprop@r{[}-@var{n}@r{]} @gol\n -fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-vtable-verify @gol\n -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol\n -ftree-vectorizer-verbose=@var{n} @gol\n -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol\n@@ -2302,6 +2305,56 @@ and that pointers to function members defined in different shared\n objects may not compare equal.  When this flag is given, it is a\n violation of the ODR to define types with the same name differently.\n \n+@item -fvtable-verify=@var{std|preinit|none}\n+@opindex fvtable-verify\n+Turn on (or off, if using @option{-fvtable-verify=none}) the security\n+feature that verifies at runtime, for every virtual call that is made, that\n+the vtable pointer through which the call is made is valid for the type of\n+the object, and has not been corrupted or overwritten.  If an invalid vtable\n+pointer is detected (at runtime), an error is reported and execution of the\n+program is immediately halted.\n+\n+This option causes runtime data structures to be built, at program start up,\n+for verifying the vtable pointers.  The options @code{std} and @code{preinit}\n+control the timing of when these data structures are built.  In both cases the\n+data structures are built before execution reaches 'main'.  The\n+@option{-fvtable-verify=std} causes these data structure to be built after the\n+shared libraries have been loaded and initialized.\n+@option{-fvtable-verify=preinit} causes them to be built before the shared\n+libraries have been loaded and initialized.\n+\n+If this option appears multiple times in the compiler line, with different\n+values specified, 'none' will take highest priority over both 'std' and\n+'preinit'; 'preinit' will take priority over 'std'.\n+\n+@item -fvtv-debug\n+@opindex (fvtv-debug)\n+Causes debug versions of the runtime functions for the vtable verification \n+feature to be called.  This assumes the @option{-fvtable-verify=std} or\n+@option{-fvtable-verify=preinit} has been used.  This flag will also cause the\n+compiler to keep track of which vtable pointers it found for each class, and\n+record that information in the file ``vtv_set_ptr_data.log'', in the dump\n+file directory on the user's machine.\n+\n+Note:  This feature APPENDS data to the log file. If you want a fresh log\n+file, be sure to delete any existing one.\n+\n+@item -fvtv-counts\n+@opindex (fvtv-counts)\n+This is a debugging flag.  When used in conjunction with\n+@option{-fvtable-verify=std} or @option{-fvtable-verify=preinit}, this\n+causes the compiler to keep track of the total number of virtual calls\n+it encountered and the number of verifications it inserted.  It also\n+counts the number of calls to certain runtime library functions\n+that it inserts.  This information, for each compilation unit, is written\n+to a file named ``vtv_count_data.log'', in the dump_file directory on\n+the user's machine.   It also counts the size of the vtable pointer sets\n+for each class, and writes this information to ``vtv_class_set_sizes.log''\n+in the same directory.\n+\n+Note:  This feature APPENDS data to the log files.  To get a fresh log\n+files, be sure to delete any existing ones.\n+\n @item -fno-weak\n @opindex fno-weak\n Do not use weak symbol support, even if it is provided by the linker."}, {"sha": "8eea9a6707907faee17ecced0f34f1296f2180ce", "filename": "gcc/flag-types.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -191,4 +191,10 @@ enum fp_contract_mode {\n   FP_CONTRACT_FAST = 2\n };\n \n+/* flag_vtable_verify initialization levels. */\n+enum vtv_priority {\n+  VTV_NO_PRIORITY       = 0,  /* i.E. Do NOT do vtable verification. */\n+  VTV_STANDARD_PRIORITY = 1,\n+  VTV_PREINIT_PRIORITY  = 2\n+};\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "7c15cf3d17630ae6158942b6fc8b05a3870d4c22", "filename": "gcc/gcc.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -722,6 +722,16 @@ proper position among the other output files.  */\n     %{!pie:%{!shared:%e-fsanitize=thread linking must be done with -pie or -shared}}}}}\"\n #endif\n \n+/*  This is the spec to use, once the code for creating the vtable\n+    verification runtime library, libvtv.so, has been created.  Currently\n+    the vtable verification runtime functions are in libstdc++, so we use\n+    the spec just below this one.  */\n+#ifndef VTABLE_VERIFICATION_SPEC\n+#define VTABLE_VERIFICATION_SPEC \"\\\n+%{!nostdlib:%{fvtable-verify=std: -lvtv -u_vtable_map_vars_start -u_vtable_map_vars_end}\\\n+    %{fvtable-verify=preinit: -lvtv -u_vtable_map_vars_start -u_vtable_map_vars_end}}\"\n+#endif\n+\n /* -u* was put back because both BSD and SysV seem to support it.  */\n /* %{static:} simply prevents an error message if the target machine\n    doesn't handle -static.  */\n@@ -740,7 +750,7 @@ proper position among the other output files.  */\n     %{flto} %{flto=*} %l \" LINK_PIE_SPEC \\\n    \"%{fuse-ld=*:-fuse-ld=%*}\\\n     %X %{o*} %{e*} %{N} %{n} %{r}\\\n-    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}\\\n+    %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}} \" VTABLE_VERIFICATION_SPEC \" \\\n     %{static:} %{L*} %(mfwrap) %(link_libgcc) \" SANITIZER_EARLY_SPEC \" %o\\\n     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n     %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\\"}, {"sha": "7b262566c2f4796664122d2bcf6ea9dd7cd7010e", "filename": "gcc/output.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -197,6 +197,10 @@ extern void assemble_end_function (tree, const char *);\n    initial value (that will be done by the caller).  */\n extern void assemble_variable (tree, int, int, int);\n \n+/* Put the vtable verification constructor initialization function\n+   into the preinit array.  */\n+extern void assemble_vtv_preinit_initializer (tree);\n+\n /* Compute the alignment of variable specified by DECL.\n    DONT_OUTPUT_DATA is from assemble_variable.  */\n extern void align_variable (tree decl, bool dont_output_data);"}, {"sha": "b289713368f33d746444aa9b1a54a840c8963893", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -292,6 +292,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_tm_memopt);\n       NEXT_PASS (pass_tm_edges);\n   POP_INSERT_PASSES ()\n+  NEXT_PASS (pass_vtable_verify);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_asan_O0);"}, {"sha": "8ab9b99eadfa7ad87c85037deaaad3898693f566", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -255,6 +255,7 @@ DEFTIMEVAR (TV_TREE_UNINIT           , \"uninit var analysis\")\n DEFTIMEVAR (TV_PLUGIN_INIT           , \"plugin initialization\")\n DEFTIMEVAR (TV_PLUGIN_RUN            , \"plugin execution\")\n DEFTIMEVAR (TV_GIMPLE_SLSR           , \"straight-line strength reduction\")\n+DEFTIMEVAR (TV_VTABLE_VERIFICATION   , \"vtable verification\")\n \n /* Everything else in rest_of_compilation not included above.  */\n DEFTIMEVAR (TV_EARLY_LOCAL\t     , \"early local passes\")"}, {"sha": "787a49b7c41fbaeb27e9547466733d9ca831a09b", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -439,6 +439,7 @@ extern gimple_opt_pass *make_pass_tm_edges (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_split_functions (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_feedback_split_functions (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strength_reduction (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_vtable_verify (gcc::context *ctxt);\n \n /* IPA Passes */\n extern simple_ipa_opt_pass *make_pass_ipa_lower_emutls (gcc::context *ctxt);"}, {"sha": "94f112f43d79116ab83c8edf2ca9e59b6e3469d4", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -6496,6 +6496,9 @@ is_lang_specific (tree t)\n /* In gimple-low.c.  */\n extern bool block_may_fallthru (const_tree);\n \n+/* In vtable-verify.c.  */\n+extern void save_vtable_map_decl (tree);\n+\n \f\n /* Functional interface to the builtin functions.  */\n \n@@ -6586,7 +6589,6 @@ builtin_decl_implicit_p (enum built_in_function fncode)\n \t  && builtin_info.implicit_p[uns_fncode]);\n }\n \n-\n /* For anonymous aggregate types, we need some sort of name to\n    hold on to.  In practice, this should not appear, but it should\n    not be harmful if it does.  */"}, {"sha": "69ec26a5e6b4f643b4330f6db2ac47658cd3f2e0", "filename": "gcc/varasm.c", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -2107,7 +2107,31 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n     assemble_noswitch_variable (decl, name, sect, align);\n   else\n     {\n-      switch_to_section (sect);\n+      /* The following bit of code ensures that vtable_map \n+         variables are not only in the comdat section, but that\n+         each variable has its own unique comdat name.  If this\n+         code is removed, the variables end up in the same section\n+         with a single comdat name.\n+\n+         FIXME:  resolve_unique_section needs to deal better with\n+         decls with both DECL_SECTION_NAME and DECL_ONE_ONLY.  Once\n+         that is fixed, this if-else statement can be replaced with\n+         a single call to \"switch_to_section (sect)\".  */\n+      if (sect->named.name\n+\t  && (strcmp (sect->named.name, \".vtable_map_vars\") == 0))\n+\t{\n+#if defined (OBJECT_FORMAT_ELF)\n+          targetm.asm_out.named_section (sect->named.name,\n+\t\t\t\t\t sect->named.common.flags\n+\t\t\t\t         | SECTION_LINKONCE,\n+\t\t\t    \t         DECL_NAME (decl));\n+          in_section = sect;\n+#else\n+          switch_to_section (sect);\n+#endif\n+        }\n+      else\n+\tswitch_to_section (sect);\n       if (align > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n       assemble_variable_contents (decl, name, dont_output_data);\n@@ -2120,6 +2144,23 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n     }\n }\n \n+\n+/* Given a function declaration (FN_DECL), this function assembles the\n+   function into the .preinit_array section.  */\n+\n+void\n+assemble_vtv_preinit_initializer (tree fn_decl)\n+{\n+  section *sect;\n+  unsigned flags = SECTION_WRITE;\n+  rtx symbol = XEXP (DECL_RTL (fn_decl), 0);\n+\n+  flags |= SECTION_NOTYPE;\n+  sect = get_section (\".preinit_array\", flags, fn_decl);\n+  switch_to_section (sect);\n+  assemble_addr_to_section (symbol, sect);\n+}\n+\n /* Return 1 if type TYPE contains any pointers.  */\n \n static int\n@@ -6046,6 +6087,9 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n   if (decl && DECL_P (decl) && DECL_ONE_ONLY (decl))\n     flags |= SECTION_LINKONCE;\n \n+  if (strcmp (name, \".vtable_map_vars\") == 0)\n+    flags |= SECTION_LINKONCE;\n+\n   if (decl && TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n     flags |= SECTION_TLS | SECTION_WRITE;\n "}, {"sha": "b6c5bc3bce489b275cac6687c1c2c1cdefc044db", "filename": "gcc/vtable-verify.c", "status": "added", "additions": 793, "deletions": 0, "changes": 793, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,793 @@\n+/*   Copyright (C) 2013\n+    Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Virtual Table Pointer Security Pass - Detect corruption of vtable pointers\n+   before using them for virtual method dispatches.  */\n+\n+/* This file is part of the vtable security feature implementation.\n+   The vtable security feature is designed to detect when a virtual\n+   call is about to be made through an invalid vtable pointer\n+   (possibly due to data corruption or malicious attacks). The\n+   compiler finds every virtual call, and inserts a verification call\n+   before the virtual call.  The verification call takes the actual\n+   vtable pointer value in the object through which the virtual call\n+   is being made, and compares the vtable pointer against a set of all\n+   valid vtable pointers that the object could contain (this set is\n+   based on the declared type of the object).  If the pointer is in\n+   the valid set, execution is allowed to continue; otherwise the\n+   program is halted.\n+\n+  There are several pieces needed in order to make this work: 1. For\n+  every virtual class in the program (i.e. a class that contains\n+  virtual methods), we need to build the set of all possible valid\n+  vtables that an object of that class could point to.  This includes\n+  vtables for any class(es) that inherit from the class under\n+  consideration.  2. For every such data set we build up, we need a\n+  way to find and reference the data set.  This is complicated by the\n+  fact that the real vtable addresses are not known until runtime,\n+  when the program is loaded into memory, but we need to reference the\n+  sets at compile time when we are inserting verification calls into\n+  the program.  3.  We need to find every virtual call in the program,\n+  and insert the verification call (with the appropriate arguments)\n+  before the virtual call.  4. We need some runtime library pieces:\n+  the code to build up the data sets at runtime; the code to actually\n+  perform the verification using the data sets; and some code to set\n+  protections on the data sets, so they themselves do not become\n+  hacker targets.\n+\n+  To find and reference the set of valid vtable pointers for any given\n+  virtual class, we create a special global variable for each virtual\n+  class.  We refer to this as the \"vtable map variable\" for that\n+  class.  The vtable map variable has the type \"void *\", and is\n+  initialized by the compiler to NULL.  At runtime when the set of\n+  valid vtable pointers for a virtual class, e.g. class Foo, is built,\n+  the vtable map variable for class Foo is made to point to the set.\n+  During compile time, when the compiler is inserting verification\n+  calls into the program, it passes the vtable map variable for the\n+  appropriate class to the verification call, so that at runtime the\n+  verification call can find the appropriate data set.\n+\n+  The actual set of valid vtable pointers for a virtual class,\n+  e.g. class Foo, cannot be built until runtime, when the vtables get\n+  loaded into memory and their addresses are known.  But the knowledge\n+  about which vtables belong in which class' hierarchy is only known\n+  at compile time.  Therefore at compile time we collect class\n+  hierarchy and vtable information about every virtual class, and we\n+  generate calls to build up the data sets at runtime.  To build the\n+  data sets, we call one of the functions we add to the runtime\n+  library, __VLTRegisterPair.  __VLTRegisterPair takes two arguments,\n+  a vtable map variable and the address of a vtable.  If the vtable\n+  map variable is currently NULL, it creates a new data set (hash\n+  table), makes the vtable map variable point to the new data set, and\n+  inserts the vtable address into the data set.  If the vtable map\n+  variable is not NULL, it just inserts the vtable address into the\n+  data set.  In order to make sure that our data sets are built before\n+  any verification calls happen, we create a special constructor\n+  initialization function for each compilation unit, give it a very\n+  high initialization priority, and insert all of our calls to\n+  __VLTRegisterPair into our special constructor initialization\n+  function.\n+\n+  The vtable verification feature is controlled by the flag\n+  '-fvtable-verify='.  There are three flavors of this:\n+  '-fvtable-verify=std', '-fvtable-verify=preinit', and\n+  '-fvtable-verify=none'.  If the option '-fvtable-verfy=preinit' is\n+  used, then our constructor initialization function gets put into the\n+  preinit array.  This is necessary if there are data sets that need\n+  to be built very early in execution.  If the constructor\n+  initialization function gets put into the preinit array, the we also\n+  add calls to __VLTChangePermission at the beginning and end of the\n+  function.  The call at the beginning sets the permissions on the\n+  data sets and vtable map variables to read/write, and the one at the\n+  end makes them read-only.  If the '-fvtable-verify=std' option is\n+  used, the constructor initialization functions are executed at their\n+  normal time, and the __VLTChangePermission calls are handled\n+  differently (see the comments in libstdc++-v3/libsupc++/vtv_rts.cc).\n+  The option '-fvtable-verify=none' turns off vtable verification.\n+\n+  This file contains code for the tree pass that goes through all the\n+  statements in each basic block, looking for virtual calls, and\n+  inserting a call to __VLTVerifyVtablePointer (with appropriate\n+  arguments) before each one.  It also contains the hash table\n+  functions for the data structures used for collecting the class\n+  hierarchy data and building/maintaining the vtable map variable data\n+  are defined in gcc/vtable-verify.h.  These data structures are\n+  shared with the code in the C++ front end that collects the class\n+  hierarchy & vtable information and generates the vtable map\n+  variables (see cp/vtable-class-hierarchy.c).  This tree pass should\n+  run just before the gimple is converted to RTL.\n+\n+  Some implementation details for this pass:\n+\n+  To find all of the virtual calls, we iterate through all the\n+  gimple statements in each basic block, looking for any call\n+  statement with the code \"OBJ_TYPE_REF\".  Once we have found the\n+  virtual call, we need to find the vtable pointer through which the\n+  call is being made, and the type of the object containing the\n+  pointer (to find the appropriate vtable map variable).  We then use\n+  these to build a call to __VLTVerifyVtablePointer, passing the\n+  vtable map variable, and the vtable pointer.  We insert the\n+  verification call just after the gimple statement that gets the\n+  vtable pointer out of the object, and we update the next\n+  statement to depend on the result returned from\n+  __VLTVerifyVtablePointer (the vtable pointer value), to ensure\n+  subsequent compiler phases don't remove or reorder the call (it's no\n+  good to have the verification occur after the virtual call, for\n+  example).  To find the vtable pointer being used (and the type of\n+  the object) we search backwards through the def_stmts chain from the\n+  virtual call (see verify_bb_vtables for more details).  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"cfgloop.h\"\n+\n+#include \"vtable-verify.h\"\n+\n+unsigned num_vtable_map_nodes = 0;\n+int total_num_virtual_calls = 0;\n+int total_num_verified_vcalls = 0;\n+\n+extern GTY(()) tree verify_vtbl_ptr_fndecl;\n+tree verify_vtbl_ptr_fndecl = NULL_TREE;\n+\n+/* Keep track of whether or not any virtual call were verified.  */\n+static bool any_verification_calls_generated = false;\n+\n+unsigned int vtable_verify_main (void);\n+\n+\n+/* The following few functions are for the vtbl pointer hash table\n+   in the 'registered' field of the struct vtable_map_node.  The hash\n+   table keeps track of which vtable pointers have been used in\n+   calls to __VLTRegisterPair with that particular vtable map variable.  */\n+\n+/* This function checks to see if a particular VTABLE_DECL and OFFSET are\n+   already in the 'registered' hash table for NODE.  */\n+\n+bool\n+vtbl_map_node_registration_find (struct vtbl_map_node *node,\n+                                 tree vtable_decl,\n+                                 unsigned offset)\n+{\n+  struct vtable_registration key;\n+  struct vtable_registration **slot;\n+\n+  gcc_assert (node && node->registered.is_created());\n+\n+  key.vtable_decl = vtable_decl;\n+  slot = (struct vtable_registration **) node->registered.find_slot (&key,\n+                                                                     NO_INSERT);\n+\n+  if (slot && (*slot))\n+    {\n+      unsigned i;\n+      for (i = 0; i < ((*slot)->offsets).length(); ++i)\n+        if ((*slot)->offsets[i] == offset)\n+          return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* This function inserts VTABLE_DECL and OFFSET into the 'registered'\n+   hash table for NODE.  It returns a boolean indicating whether or not\n+   it actually inserted anything.  */\n+\n+bool\n+vtbl_map_node_registration_insert (struct vtbl_map_node *node,\n+                                   tree vtable_decl,\n+                                   unsigned offset)\n+{\n+  struct vtable_registration key;\n+  struct vtable_registration **slot;\n+  bool inserted_something = false;\n+\n+  if (!node || !node->registered.is_created())\n+    return false;\n+\n+  key.vtable_decl = vtable_decl;\n+  slot = (struct vtable_registration **) node->registered.find_slot (&key,\n+                                                                     INSERT);\n+\n+  if (! *slot)\n+    {\n+      struct vtable_registration *node;\n+      node = XNEW (struct vtable_registration);\n+      node->vtable_decl = vtable_decl;\n+\n+      (node->offsets).create (10);\n+      (node->offsets).safe_push (offset);\n+      *slot = node;\n+      inserted_something = true;\n+    }\n+  else\n+    {\n+      /* We found the vtable_decl slot; we need to see if it already\n+         contains the offset.  If not, we need to add the offset.  */\n+      unsigned i;\n+      bool found = false;\n+      for (i = 0; i < ((*slot)->offsets).length() && !found; ++i)\n+        if ((*slot)->offsets[i] == offset)\n+          found = true;\n+\n+      if (!found)\n+        {\n+          ((*slot)->offsets).safe_push (offset);\n+          inserted_something = true;\n+        }\n+     }\n+  return inserted_something;\n+}\n+\n+/* Hashtable functions for vtable_registration hashtables.  */\n+\n+inline hashval_t\n+registration_hasher::hash (const value_type *p)\n+{\n+  const struct vtable_registration *n = (const struct vtable_registration *) p;\n+  return (hashval_t) (DECL_UID (n->vtable_decl));\n+}\n+\n+inline bool\n+registration_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  const struct vtable_registration *n1 =\n+                                    (const struct vtable_registration *) p1;\n+  const struct vtable_registration *n2 =\n+                                    (const struct vtable_registration *) p2;\n+  return (DECL_UID (n1->vtable_decl) == DECL_UID (n2->vtable_decl));\n+}\n+\n+/* End of hashtable functions for \"registered\" hashtables.  */\n+\n+\n+\n+/* Hashtable definition and functions for vtbl_map_hash.  */\n+\n+struct vtbl_map_hasher : typed_noop_remove <struct vtbl_map_node>\n+{\n+  typedef struct vtbl_map_node value_type;\n+  typedef struct vtbl_map_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns a hash code for P.  */\n+\n+inline hashval_t\n+vtbl_map_hasher::hash (const value_type *p)\n+{\n+  const struct vtbl_map_node n = *((const struct vtbl_map_node *) p);\n+  return (hashval_t) IDENTIFIER_HASH_VALUE (n.class_name);\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+inline bool\n+vtbl_map_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  const struct vtbl_map_node n1 = *((const struct vtbl_map_node *) p1);\n+  const struct vtbl_map_node n2 = *((const struct vtbl_map_node *) p2);\n+  return (IDENTIFIER_HASH_VALUE (n1.class_name) ==\n+          IDENTIFIER_HASH_VALUE (n2.class_name));\n+}\n+\n+/* Here are the two structures into which we insert vtable map nodes.\n+   We use two data structures because of the vastly different ways we need\n+   to find the nodes for various tasks (see comments in vtable-verify.h\n+   for more details.  */\n+\n+typedef hash_table <vtbl_map_hasher> vtbl_map_table_type;\n+typedef vtbl_map_table_type::iterator vtbl_map_iterator_type;\n+\n+/* Vtable map variable nodes stored in a hash table.  */\n+static vtbl_map_table_type vtbl_map_hash;\n+\n+/* Vtable map variable nodes stored in a vector.  */\n+vec<struct vtbl_map_node *> vtbl_map_nodes_vec;\n+\n+/* Return vtbl_map node for CLASS_NAME  without creating a new one.  */\n+\n+struct vtbl_map_node *\n+vtbl_map_get_node (tree class_type)\n+{\n+  struct vtbl_map_node key;\n+  struct vtbl_map_node **slot;\n+\n+  tree class_type_decl;\n+  tree class_name;\n+  unsigned int type_quals;\n+\n+  if (!vtbl_map_hash.is_created())\n+    return NULL;\n+\n+  gcc_assert (TREE_CODE (class_type) == RECORD_TYPE);\n+\n+\n+  /* Find the TYPE_DECL for the class.  */\n+  class_type_decl = TYPE_NAME (class_type);\n+\n+  /* Verify that there aren't any qualifiers on the type.  */\n+  type_quals = TYPE_QUALS (TREE_TYPE (class_type_decl));\n+  gcc_assert (type_quals == TYPE_UNQUALIFIED);\n+\n+  /* Get the mangled name for the unqualified type.  */\n+  gcc_assert (HAS_DECL_ASSEMBLER_NAME_P (class_type_decl));\n+  class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n+\n+  key.class_name = class_name;\n+  slot = (struct vtbl_map_node **) vtbl_map_hash.find_slot (&key,\n+                                                            NO_INSERT);\n+  if (!slot)\n+    return NULL;\n+  return *slot;\n+}\n+\n+/* Return vtbl_map node assigned to BASE_CLASS_TYPE.  Create new one\n+   when needed.  */\n+\n+struct vtbl_map_node *\n+find_or_create_vtbl_map_node (tree base_class_type)\n+{\n+  struct vtbl_map_node key;\n+  struct vtbl_map_node *node;\n+  struct vtbl_map_node **slot;\n+  tree class_type_decl;\n+  unsigned int type_quals;\n+\n+  if (!vtbl_map_hash.is_created())\n+    vtbl_map_hash.create (10);\n+\n+  /* Find the TYPE_DECL for the class.  */\n+  class_type_decl = TYPE_NAME (base_class_type);\n+\n+  /* Verify that there aren't any type qualifiers on type.  */\n+  type_quals = TYPE_QUALS (TREE_TYPE (class_type_decl));\n+  gcc_assert (type_quals == TYPE_UNQUALIFIED);\n+\n+  gcc_assert (HAS_DECL_ASSEMBLER_NAME_P (class_type_decl));\n+  key.class_name = DECL_ASSEMBLER_NAME (class_type_decl);\n+  slot = (struct vtbl_map_node **) vtbl_map_hash.find_slot (&key,\n+                                                            INSERT);\n+\n+  if (*slot)\n+    return *slot;\n+\n+  node = XNEW (struct vtbl_map_node);\n+  node->vtbl_map_decl = NULL_TREE;\n+  node->class_name = key.class_name;\n+  node->uid = num_vtable_map_nodes++;\n+\n+  node->class_info = XNEW (struct vtv_graph_node);\n+  node->class_info->class_type = base_class_type;\n+  node->class_info->class_uid = node->uid;\n+  node->class_info->num_processed_children = 0;\n+\n+  (node->class_info->parents).create (4);\n+  (node->class_info->children).create (4);\n+\n+  node->registered.create (16);\n+\n+  node->is_used = false;\n+\n+  vtbl_map_nodes_vec.safe_push (node);\n+  gcc_assert (vtbl_map_nodes_vec[node->uid] == node);\n+\n+  *slot = node;\n+  return node;\n+}\n+\n+/* End of hashtable functions for vtable_map variables hash table.   */\n+\n+/* Given a gimple STMT, this function checks to see if the statement\n+   is an assignment, the rhs of which is getting the vtable pointer\n+   value out of an object.  (i.e. it's the value we need to verify\n+   because its the vtable pointer that will be used for a virtual\n+   call).  */\n+\n+static bool\n+is_vtable_assignment_stmt (gimple stmt)\n+{\n+\n+  if (gimple_code (stmt) != GIMPLE_ASSIGN)\n+    return false;\n+  else\n+    {\n+      tree lhs = gimple_assign_lhs (stmt);\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+\n+      if (TREE_CODE (lhs) != SSA_NAME)\n+        return false;\n+\n+      if (TREE_CODE (rhs) != COMPONENT_REF)\n+        return false;\n+\n+      if (! (TREE_OPERAND (rhs, 1))\n+          || (TREE_CODE (TREE_OPERAND (rhs, 1)) != FIELD_DECL))\n+        return false;\n+\n+      if (! DECL_VIRTUAL_P (TREE_OPERAND (rhs, 1)))\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+/* This function attempts to recover the declared class of an object\n+   that is used in making a virtual call.  We try to get the type from\n+   the type cast in the gimple assignment statement that extracts the\n+   vtable pointer from the object (DEF_STMT).  The gimple statement\n+   usually looks something like this:\n+\n+   D.2201_4 = MEM[(struct Event *)this_1(D)]._vptr.Event    */\n+\n+static tree\n+extract_object_class_type (tree rhs)\n+{\n+  tree result = NULL_TREE;\n+\n+  /* Try to find and extract the type cast from that stmt.  */\n+  if (TREE_CODE (rhs) == COMPONENT_REF)\n+    {\n+      tree op0 = TREE_OPERAND (rhs, 0);\n+      tree op1 = TREE_OPERAND (rhs, 1);\n+\n+      if (TREE_CODE (op1) == FIELD_DECL\n+          && DECL_VIRTUAL_P (op1))\n+        {\n+          if (TREE_CODE (op0) == COMPONENT_REF\n+              && TREE_CODE (TREE_OPERAND (op0, 0)) == MEM_REF\n+              && TREE_CODE (TREE_TYPE (TREE_OPERAND (op0, 0)))== RECORD_TYPE)\n+            result = TREE_TYPE (TREE_OPERAND (op0, 0));\n+          else\n+            result = TREE_TYPE (op0);\n+        }\n+      else if (TREE_CODE (op0) == COMPONENT_REF)\n+        {\n+          result = extract_object_class_type (op0);\n+          if (result == NULL_TREE\n+              && TREE_CODE (op1) == COMPONENT_REF)\n+            result = extract_object_class_type (op1);\n+        }\n+    }\n+\n+  return result;\n+}\n+\n+/* This function traces forward through the def-use chain of an SSA\n+   variable to see if it ever gets used in a virtual function call.  It\n+   returns a boolean indicating whether or not it found a virtual call in\n+   the use chain.  */\n+\n+static bool\n+var_is_used_for_virtual_call_p (tree lhs, int *mem_ref_depth)\n+{\n+  imm_use_iterator imm_iter;\n+  bool found_vcall = false;\n+  use_operand_p use_p;\n+\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    return false;\n+\n+  if (*mem_ref_depth > 2)\n+    return false;\n+\n+  /* Iterate through the immediate uses of the current variable.  If\n+     it's a virtual function call, we're done.  Otherwise, if there's\n+     an LHS for the use stmt, add the ssa var to the work list\n+     (assuming it's not already in the list and is not a variable\n+     we've already examined.  */\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+    {\n+      gimple stmt2 = USE_STMT (use_p);\n+\n+      if (gimple_code (stmt2) == GIMPLE_CALL)\n+        {\n+          tree fncall = gimple_call_fn (stmt2);\n+          if (TREE_CODE (fncall) == OBJ_TYPE_REF)\n+            found_vcall = true;\n+\t  else\n+\t    return false;\n+        }\n+      else if (gimple_code (stmt2) == GIMPLE_PHI)\n+        {\n+          found_vcall = var_is_used_for_virtual_call_p\n+\t                                            (gimple_phi_result (stmt2),\n+\t                                             mem_ref_depth);\n+        }\n+      else if (gimple_code (stmt2) == GIMPLE_ASSIGN)\n+        {\n+\t  tree rhs = gimple_assign_rhs1 (stmt2);\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR\n+\t      || TREE_CODE (rhs) == MEM_REF)\n+\t    *mem_ref_depth = *mem_ref_depth + 1;\n+\t  \n+\t  if (TREE_CODE (rhs) == COMPONENT_REF)\n+\t    {\n+\t      while (TREE_CODE (TREE_OPERAND (rhs, 0)) == COMPONENT_REF)\n+\t\trhs = TREE_OPERAND (rhs, 0);\n+\n+\t      if (TREE_CODE (TREE_OPERAND (rhs, 0)) == ADDR_EXPR\n+\t\t  || TREE_CODE (TREE_OPERAND (rhs, 0)) == MEM_REF)\n+\t\t*mem_ref_depth = *mem_ref_depth + 1;\n+\t    }\n+\n+\t  if (*mem_ref_depth < 3)\n+\t    found_vcall = var_is_used_for_virtual_call_p\n+\t                                            (gimple_assign_lhs (stmt2),\n+\t\t\t\t\t\t     mem_ref_depth);\n+        }\n+\n+      else\n+        break;\n+\n+      if (found_vcall)\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Search through all the statements in a basic block (BB), searching\n+   for virtual method calls.  For each virtual method dispatch, find\n+   the vptr value used, and the statically declared type of the\n+   object; retrieve the vtable map variable for the type of the\n+   object; generate a call to __VLTVerifyVtablePointer; and insert the\n+   generated call into the basic block, after the point where the vptr\n+   value is gotten out of the object and before the virtual method\n+   dispatch. Make the virtual method dispatch depend on the return\n+   value from the verification call, so that subsequent optimizations\n+   cannot reorder the two calls.  */\n+\n+static void\n+verify_bb_vtables (basic_block bb)\n+{\n+  gimple_seq stmts;\n+  gimple stmt = NULL;\n+  gimple_stmt_iterator gsi_vtbl_assign;\n+  gimple_stmt_iterator gsi_virtual_call;\n+\n+  stmts = bb_seq (bb);\n+  gsi_virtual_call = gsi_start (stmts);\n+  for (; !gsi_end_p (gsi_virtual_call); gsi_next (&gsi_virtual_call))\n+    {\n+      stmt = gsi_stmt (gsi_virtual_call);\n+\n+      /* Count virtual calls.  */\n+      if (gimple_code (stmt) == GIMPLE_CALL)\n+        {\n+          tree fncall = gimple_call_fn (stmt);\n+          if (TREE_CODE (fncall) == OBJ_TYPE_REF)\n+            total_num_virtual_calls++;\n+        }\n+\n+      if (is_vtable_assignment_stmt (stmt))\n+        {\n+          tree lhs = gimple_assign_lhs (stmt);\n+          tree vtbl_var_decl = NULL_TREE;\n+          struct vtbl_map_node *vtable_map_node;\n+          tree vtbl_decl = NULL_TREE;\n+          gimple call_stmt;\n+          const char *vtable_name = \"<unknown>\";\n+          tree tmp0;\n+          bool found;\n+\t  int mem_ref_depth = 0;\n+\n+          /* Make sure this vptr field access is for a virtual call.  */\n+          if (!var_is_used_for_virtual_call_p (lhs, &mem_ref_depth))\n+            continue;\n+\n+          /* Now we have found the virtual method dispatch and\n+             the preceding access of the _vptr.* field... Next\n+             we need to find the statically declared type of\n+             the object, so we can find and use the right\n+             vtable map variable in the verification call.  */\n+          tree class_type = extract_object_class_type\n+                                                   (gimple_assign_rhs1 (stmt));\n+\n+          gsi_vtbl_assign = gsi_for_stmt (stmt);\n+\n+          if (class_type\n+              && (TREE_CODE (class_type) == RECORD_TYPE)\n+              && TYPE_BINFO (class_type))\n+            {\n+              /* Get the vtable VAR_DECL for the type.  */\n+              vtbl_var_decl = BINFO_VTABLE (TYPE_BINFO (class_type));\n+\n+              if (TREE_CODE (vtbl_var_decl) == POINTER_PLUS_EXPR)\n+                vtbl_var_decl = TREE_OPERAND (TREE_OPERAND (vtbl_var_decl, 0),\n+                                              0);\n+\n+              gcc_assert (vtbl_var_decl);\n+\n+              vtbl_decl = vtbl_var_decl;\n+              vtable_map_node = vtbl_map_get_node\n+                                               (TYPE_MAIN_VARIANT (class_type));\n+\n+              gcc_assert (verify_vtbl_ptr_fndecl);\n+\n+              /* Given the vtable pointer for the base class of the\n+                 object, build the call to __VLTVerifyVtablePointer to\n+                 verify that the object's vtable pointer (contained in\n+                 lhs) is in the set of valid vtable pointers for the\n+                 base class.  */\n+\n+              if (vtable_map_node && vtable_map_node->vtbl_map_decl)\n+                {\n+                  use_operand_p use_p;\n+                  ssa_op_iter iter;\n+\n+                  vtable_map_node->is_used = true;\n+                  vtbl_var_decl = vtable_map_node->vtbl_map_decl;\n+\n+                  if (TREE_CODE (vtbl_decl) == VAR_DECL)\n+                    vtable_name = IDENTIFIER_POINTER (DECL_NAME (vtbl_decl));\n+\n+                  /* Call different routines if we are interested in\n+                     trace information to debug problems.  */\n+                  if (flag_vtv_debug)\n+                    {\n+                      int len1 = IDENTIFIER_LENGTH\n+                                                 (DECL_NAME (vtbl_var_decl));\n+                      int len2 = strlen (vtable_name);\n+\n+                      call_stmt = gimple_build_call\n+                                     (verify_vtbl_ptr_fndecl, 4,\n+                                      build1 (ADDR_EXPR,\n+                                                TYPE_POINTER_TO\n+                                                  (TREE_TYPE (vtbl_var_decl)),\n+                                              vtbl_var_decl),\n+                                      lhs,\n+                                      build_string_literal\n+                                                  (len1 + 1,\n+                                                   IDENTIFIER_POINTER\n+                                                       (DECL_NAME\n+                                                            (vtbl_var_decl))),\n+                                      build_string_literal (len2 + 1,\n+                                                            vtable_name));\n+                    }\n+                  else\n+                    call_stmt = gimple_build_call\n+                                     (verify_vtbl_ptr_fndecl, 2,\n+                                      build1 (ADDR_EXPR,\n+                                                TYPE_POINTER_TO\n+                                                  (TREE_TYPE (vtbl_var_decl)),\n+                                                 vtbl_var_decl),\n+                                      lhs);\n+\n+\n+                  /* Create a new SSA_NAME var to hold the call's\n+                     return value, and make the call_stmt use the\n+                     variable for that purpose.  */\n+                  tmp0 = make_temp_ssa_name (TREE_TYPE (lhs), NULL, \"VTV\");\n+                  gimple_call_set_lhs (call_stmt, tmp0);\n+                  update_stmt (call_stmt);\n+\n+                  /* Find the next stmt, after the vptr assignment\n+                     statememt, which should use the result of the\n+                     vptr assignment statement value. */\n+                  gsi_next (&gsi_vtbl_assign);\n+                  gimple next_stmt = gsi_stmt (gsi_vtbl_assign);\n+\n+                  if (!next_stmt)\n+                    return;\n+\n+                  /* Find any/all uses of 'lhs' in next_stmt, and\n+                     replace them with 'tmp0'.  */\n+                  found = false;\n+                  FOR_EACH_PHI_OR_STMT_USE (use_p, next_stmt, iter,\n+                                            SSA_OP_ALL_USES)\n+                    {\n+                      tree op = USE_FROM_PTR (use_p);\n+                      if (op == lhs)\n+                        {\n+                          SET_USE (use_p, tmp0);\n+                          found = true;\n+                        }\n+                    }\n+                  update_stmt (next_stmt);\n+                  gcc_assert (found);\n+\n+                  /* Insert the new verification call just after the\n+                     statement that gets the vtable pointer out of the\n+                     object.  */\n+                  gsi_vtbl_assign = gsi_for_stmt (stmt);\n+                  gsi_insert_after (&gsi_vtbl_assign, call_stmt,\n+                                    GSI_NEW_STMT);\n+\n+                  any_verification_calls_generated = true;\n+                  total_num_verified_vcalls++;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/* Main function, called from pass->excute().  Loop through all the\n+   basic blocks in the current function, passing them to\n+   verify_bb_vtables, which searches for virtual calls, and inserts\n+   calls to __VLTVerifyVtablePointer.  */\n+\n+unsigned int\n+vtable_verify_main (void)\n+{\n+  unsigned int ret = 1;\n+  basic_block bb;\n+\n+  FOR_ALL_BB (bb)\n+      verify_bb_vtables (bb);\n+\n+  return ret;\n+}\n+\n+/* Gate function for the pass.  */\n+\n+static bool\n+gate_tree_vtable_verify (void)\n+{\n+  return (flag_vtable_verify);\n+}\n+\n+/* Definition of this optimization pass.  */\n+\n+namespace {\n+\n+const pass_data pass_data_vtable_verify =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"vtable-verify\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_VTABLE_VERIFICATION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_vtable_verify : public gimple_opt_pass\n+{\n+public:\n+  pass_vtable_verify(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_vtable_verify, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_tree_vtable_verify (); }\n+  unsigned int execute () { return vtable_verify_main (); }\n+\n+}; // class pass_vtable_verify\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_vtable_verify (gcc::context *ctxt)\n+{\n+  return new pass_vtable_verify (ctxt);\n+}\n+\n+#include \"gt-vtable-verify.h\""}, {"sha": "7ac487bef5239c9ae57aff9a467cee4c1aeb024e", "filename": "gcc/vtable-verify.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvtable-verify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/gcc%2Fvtable-verify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,141 @@\n+/* Copyright (C) 2013\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Virtual Table Pointer Security.  */\n+\n+#ifndef VTABLE_VERIFY_H\n+#define VTABLE_VERIFY_H\n+\n+#include \"sbitmap.h\"\n+#include \"hash-table.h\"\n+\n+/* The function decl used to create calls to __VLTVtableVerify.  It must\n+   be global because it needs to be initialized in the C++ front end, but\n+   used in the middle end (in the vtable verification pass).  */\n+\n+extern tree verify_vtbl_ptr_fndecl;\n+\n+/* Global variable keeping track of how many vtable map variables we\n+   have created. */\n+extern unsigned num_vtable_map_nodes;\n+\n+/* Keep track of how many virtual calls we are actually verifying.  */\n+extern int total_num_virtual_calls;\n+extern int total_num_verified_vcalls;\n+\n+/* Each vtable map variable corresponds to a virtual class.  Each\n+   vtable map variable has a hash table associated with it, that keeps\n+   track of the vtable pointers for which we have generated a call to\n+   __VLTRegisterPair (with the current vtable map variable).  This is\n+   the hash table node that is used for each entry in this hash table\n+   of vtable pointers.\n+\n+   Sometimes there are multiple valid vtable pointer entries that use\n+   the same vtable pointer decl with different offsets.  Therefore,\n+   for each vtable pointer in the hash table, there is also an array\n+   of offsets used with that vtable. */\n+\n+struct vtable_registration\n+{\n+  tree vtable_decl;            /* The var decl of the vtable.               */\n+  vec<unsigned> offsets;       /* The offsets array.                        */\n+};\n+\n+struct registration_hasher : typed_noop_remove <struct vtable_registration>\n+{\n+  typedef struct vtable_registration value_type;\n+  typedef struct vtable_registration compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+typedef hash_table <registration_hasher> register_table_type;\n+typedef register_table_type::iterator registration_iterator_type;\n+\n+/*  This struct is used to represent the class hierarchy information\n+    that we need.  Each vtable map variable has an associated class\n+    hierarchy node (struct vtv_graph_node).  Note: In this struct,\n+    'children' means immediate descendants in the class hierarchy;\n+    'descendant' means any descendant however many levels deep. */\n+\n+struct vtv_graph_node {\n+  tree class_type;                  /* The record_type of the class.        */\n+  unsigned class_uid;               /* A unique, monotonically\n+                                       ascending id for class node.\n+                                       Each vtable map node also has\n+                                       an id.  The class uid is the\n+                                       same as the vtable map node id\n+                                       for nodes corresponding to the\n+                                       same class.                          */\n+  unsigned num_processed_children;  /* # of children for whom we have\n+                                       computed the class hierarchy\n+                                       transitive closure.                  */\n+  vec<struct vtv_graph_node *> parents;  /* Vector of parents in the graph. */\n+  vec<struct vtv_graph_node *> children; /* Vector of children in the graph.*/\n+  sbitmap descendants;              /* Bitmap representing all this node's\n+                                       descendants in the graph.            */\n+};\n+\n+/* This is the node used for our hashtable of vtable map variable\n+   information.  When we create a vtable map variable (var decl) we\n+   put it into one of these nodes; create a corresponding\n+   vtv_graph_node for our class hierarchy info and store that in this\n+   node; generate a unique (monotonically ascending) id for both the\n+   vtbl_map_node and the vtv_graph_node; and insert the node into two\n+   data structures (to make it easy to find in several different\n+   ways): 1). A hash table (\"vtbl_map_hash\" in vtable-verify.c).\n+   This gives us an easy way to check to see if we already have a node\n+   for the vtable map variable or not; and 2). An array (vector) of\n+   vtbl_map_nodes, where the array index corresponds to the unique id\n+   of the vtbl_map_node, which gives us an easy way to use bitmaps to\n+   represent and find the vtable map nodes.  */\n+\n+struct vtbl_map_node {\n+  tree vtbl_map_decl;                 /* The var decl for the vtable map\n+                                         variable.                          */\n+  tree class_name;                    /* The DECL_ASSEMBLER_NAME of the\n+                                         class.                             */\n+  struct vtv_graph_node *class_info;  /* Our class hierarchy info for the\n+                                         class.                             */\n+  unsigned uid;                       /* The unique id for the vtable map\n+                                         variable.                          */\n+  struct vtbl_map_node *next, *prev;  /* Pointers for the linked list\n+                                         structure.                         */\n+  register_table_type registered;     /* Hashtable of vtable pointers for which\n+                                         we have generated a _VLTRegisterPair\n+                                         call with this vtable map variable. */\n+  bool is_used;          /* Boolean indicating if we used this vtable map\n+                            variable in a call to __VLTVerifyVtablePointer. */\n+};\n+\n+/* Controls debugging for vtable verification.  */\n+extern bool vtv_debug;\n+\n+/* The global vector of vtbl_map_nodes.  */\n+extern vec<struct vtbl_map_node *> vtbl_map_nodes_vec;\n+\n+extern struct vtbl_map_node *vtbl_map_get_node (tree);\n+extern struct vtbl_map_node *find_or_create_vtbl_map_node (tree);\n+extern void vtbl_map_node_class_insert (struct vtbl_map_node *, unsigned);\n+extern bool vtbl_map_node_registration_find (struct vtbl_map_node *,\n+                                             tree, unsigned);\n+extern bool vtbl_map_node_registration_insert (struct vtbl_map_node *,\n+                                               tree, unsigned);\n+\n+#endif /* VTABLE_VERIFY_H */"}, {"sha": "d808f7bb6aee1849daeb3b165be485a3eef067ba", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,7 @@\n+2013-08-02  Caroline Tice  <cmtice@google.com>\n+\n+\t* vtv-change-permission.h: New file.\n+\n 2013-04-03  Jason Merrill  <jason@redhat.com>\n \n \tDemangle C++11 ref-qualifier."}, {"sha": "1adcb9745941dfe3aea0947a9704462f9ea2226c", "filename": "include/vtv-change-permission.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/include%2Fvtv-change-permission.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/include%2Fvtv-change-permission.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fvtv-change-permission.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,55 @@\n+/* Copyright (C) 2013\n+   Free Software Foundation\n+  \n+   This file is part of GCC.\n+  \n+   modify it under the terms of the GNU Library General Public License\n+   as published by the Free Software Foundation; either version 2, or\n+   (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Library General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Library Public License restrictions do apply in other\n+   respects; for example, they cover modification of the file, and\n+   distribution when not linked into a combined executable.)\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+\n+#ifndef __VTV_H__\n+#define __VTV_H__\n+\n+/* We could have used an enumeration here but it just makes it more\n+   difficult for the compiler to generate a call to this.  These are\n+   used as arguments to the function __VLTChangePermission, declared\n+   below.  */\n+#define __VLTP_READ_ONLY  0\n+#define __VLTP_READ_WRITE 1\n+\n+#ifdef __cplusplus\n+extern \"C\" void __VLTChangePermission (int);\n+#else\n+extern void __VLTChangePermission (int);\n+#endif\n+\n+#ifdef BIG_PAGE_SIZE\n+/* TODO - Replace '4096' below with correct big page size.  */\n+#define VTV_PAGE_SIZE 4096\n+#else \n+#define VTV_PAGE_SIZE 4096\n+#endif\n+\n+\n+\n+#endif /* __VTV_H__ */"}, {"sha": "af42e3e4555beb7c21225812c6932082005a4c60", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,16 @@\n+2013-08-06  Caroline Tice  <cmtice@google.com>\n+\n+\tconfig.host (extra_parts): Add vtv_start.o, vtv_end.o\n+\tvtv_start_preinit.o and vtv_end_preinit.o.\n+\tconfigure.ac: Add code to check/set enable_vtable_verify.\n+\tMakefile.in: Add rules to build vtv_*.o, if enable_vtable_verify is\n+\ttrue.\n+\tvtv_start_preinit.c: New file.\n+\tvtv_end_preinit.c: New file.\n+\tvtv_start.c: New file.\n+\tvtv_end.c: New file.\n+\tconfigure: Regenerated.\n+\n 2013-08-01  Maxim Kuvyrkov  <maxim@kugelworks.com>\n \n \t* config/aarch64/sfp-machine.h, config/aarch64/sync-cache.c,"}, {"sha": "63fd626da40fef34e0ae539ba84759c00eb8894b", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -39,6 +39,7 @@ enable_shared = @enable_shared@\n double_type_size = @double_type_size@\n long_double_type_size = @long_double_type_size@\n decimal_float = @decimal_float@\n+enable_vtable_verify = @enable_vtable_verify@\n enable_decimal_float = @enable_decimal_float@\n fixed_point = @fixed_point@\n \n@@ -971,6 +972,22 @@ crtendS$(objext): $(srcdir)/crtstuff.c\n # This is a version of crtbegin for -static links.\n crtbeginT$(objext): $(srcdir)/crtstuff.c\n \t$(crt_compile) $(CRTSTUFF_T_CFLAGS) -c $< -DCRT_BEGIN -DCRTSTUFFT_O\n+\n+ifeq ($(enable_vtable_verify),yes)\n+# These are used in vtable verification; see comments in source files for\n+# more details.\n+vtv_start$(objext): $(srcdir)/vtv_start.c\n+\t$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $(srcdir)/vtv_start.c\n+\n+vtv_end$(objext): $(srcdir)/vtv_end.c\n+\t$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $(srcdir)/vtv_end.c\n+\n+vtv_start_preinit$(objext): $(srcdir)/vtv_start_preinit.c\n+\t$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $(srcdir)/vtv_start_preinit.c\n+\n+vtv_end_preinit$(objext): $(srcdir)/vtv_end_preinit.c\n+\t$(crt_compile) $(CRTSTUFF_T_CFLAGS_S) -c $(srcdir)/vtv_end_preinit.c\n+endif\n endif\n \n ifeq ($(CUSTOM_CRTIN),)"}, {"sha": "f75ae9a571c04eaaf627ea8898c0c188284739ad", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -197,7 +197,7 @@ case ${host} in\n   ;;\n *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)\n   tmake_file=\"$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver t-linux\"\n-  extra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o\"\n+  extra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\"\n   ;;\n *-*-lynxos*)\n   tmake_file=\"$tmake_file t-lynx $cpu_type/t-crtstuff t-crtstuff-pic t-libgcc-pic\""}, {"sha": "29fa46f597a48d880471fe38ab83ef836b462b89", "filename": "libgcc/configure", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -608,6 +608,7 @@ build_os\n build_vendor\n build_cpu\n build\n+enable_vtable_verify\n enable_shared\n libgcc_topdir\n target_alias\n@@ -655,6 +656,7 @@ with_target_subdir\n with_cross_host\n with_ld\n enable_shared\n+enable_vtable_verify\n enable_version_specific_runtime_libs\n with_slibdir\n enable_maintainer_mode\n@@ -1288,6 +1290,7 @@ Optional Features:\n   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)\n   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n   --disable-shared        don't provide a shared libgcc\n+  --enable-vtable-verify    Enable vtable verification feature\n   --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory\n   --enable-maintainer-mode\n                           enable make rules and dependencies not useful (and\n@@ -2140,6 +2143,19 @@ fi\n \n \n \n+# Check whether --enable-vtable-verify was given.\n+if test \"${enable_vtable_verify+set}\" = set; then :\n+  enableval=$enable_vtable_verify; case \"$enableval\" in\n+ yes) enable_vtable_verify=yes ;;\n+ no)  enable_vtable_verify=no ;;\n+ *)   enable_vtable_verify=no;;\n+ esac\n+else\n+  enable_vtable_verify=no\n+fi\n+\n+\n+\n # Make sure we can run config.sub.\n $SHELL \"$ac_aux_dir/config.sub\" sun4 >/dev/null 2>&1 ||\n   as_fn_error \"cannot run $SHELL $ac_aux_dir/config.sub\" \"$LINENO\" 5"}, {"sha": "186cd6e9cd7422a662d2ccbf0ae5c267456fa25b", "filename": "libgcc/configure.ac", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -66,6 +66,16 @@ AC_ARG_ENABLE(shared,\n ], [enable_shared=yes])\n AC_SUBST(enable_shared)\n \n+AC_ARG_ENABLE(vtable-verify,\n+[  --enable-vtable-verify    Enable vtable verification feature ],\n+[case \"$enableval\" in\n+ yes) enable_vtable_verify=yes ;;\n+ no)  enable_vtable_verify=no ;;\n+ *)   enable_vtable_verify=no;;\n+ esac],\n+[enable_vtable_verify=no])\n+AC_SUBST(enable_vtable_verify)\n+\n GCC_PICFLAG\n AC_SUBST(PICFLAG)\n "}, {"sha": "83fa101c8e36c0297a36a108d54612cffb6c2ddb", "filename": "libgcc/vtv_end.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_end.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_end.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fvtv_end.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,66 @@\n+/*  Copyright (C) 2012, 2013\n+    Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verification feature (for a\n+   detailed description of the feature, see comments in\n+   vtable-verify.c).  The vtable verification feature creates\n+   certain global symbols that need to be read-write sometimes during\n+   program execution, and read-only at others.  It uses 'mprotect' to\n+   change the memory protections of the pages on which these variables\n+   are stored.  In order to not affect the protections of other\n+   program variables, these variables are put into a special named\n+   section, \".vtable_map_vars\", which is page-aligned at the start,\n+   and which is padded with a page-sized amount of zeros at the end.\n+   To make this section page aligned, we create a special symbol,\n+   \"_vtable_map_vars_start\" which we make the very first thing that\n+   goes into the section.  That is defined in vtv_start.c (which\n+   contains nothing else).  vtv_start.c gest compiled into\n+   vtv_start.o, and vtv_start.o gets inserted into the link line\n+   immediately after crtbegin.o, if the program is compiled with\n+   -fvtable.verify.\n+\n+   In order to pad the \".vtable_map_vars\" section with a page-sized\n+   amount of zeros at the end, there is a second symbol,\n+   _vtable_map_vars_end.  This file defines that symbol (and only this\n+   symbol).  This second symbol is a page-sized array of chars,\n+   zero-filled, and is the very last thing to go into the section.\n+   When the GCC driver inserts vtv_start.o into the link line (just\n+   after crtbegin.o) it also inserts vtv_end.o into the link line,\n+   just before crtend.o.  This has the desired effect of making our\n+   section page-aligned and page-size paded, ensuring that no other\n+   program data lands on our pages.  */\n+\n+\n+#include \"vtv-change-permission.h\"\n+\n+__attribute__ ((constructor(100))) void\n+__VLTprotect (void)\n+{\n+  __VLTChangePermission (__VLTP_READ_ONLY);\n+}\n+\n+/* Page-sized variable to mark end of .vtable_map_vars section.  */\n+char _vtable_map_vars_end[VTV_PAGE_SIZE]\n+  __attribute__ ((__visibility__ (\"protected\"), used,\n+\t\t  section(\".vtable_map_vars\")));"}, {"sha": "53d12b07ea1b7ddb69a318881f48b875a497fc59", "filename": "libgcc/vtv_end_preinit.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_end_preinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_end_preinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fvtv_end_preinit.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,71 @@\n+/*  Copyright (C) 2012, 2013\n+    Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verification feature (for a\n+   detailed description of the feature, see comments in\n+   vtable-verify.c).  The vtable verification feature creates\n+   certain global symbols that need to be read-write sometimes during\n+   program execution, and read-only at others.  It uses 'mprotect' to\n+   change the memory protections of the pages on which these variables\n+   are stored.  In order to not affect the protections of other\n+   program variables, these variables are put into a special named\n+   section, \".vtable_map_vars\", which is page-aligned at the start,\n+   and which is padded with a page-sized amount of zeros at the end.\n+   To make this section page aligned, we create a special symbol,\n+   \"_vtable_map_vars_start\" which we make the very first thing that\n+   goes into the section.  That is defined in vtv_start.c (which\n+   contains nothing else).  vtv_start.c gest compiled into\n+   vtv_start.o, and vtv_start.o gets inserted into the link line\n+   immediately after crtbegin.o, if the program is compiled with\n+   -fvtable.verify.\n+\n+   In order to pad the \".vtable_map_vars\" section with a page-sized\n+   amount of zeros at the end, there is a second symbol,\n+   _vtable_map_vars_end.  This file defines that symbol (and only this\n+   symbol).  This second symbol is a page-sized array of chars,\n+   zero-filled, and is the very last thing to go into the section.\n+   When the GCC driver inserts vtv_start.o into the link line (just\n+   after crtbegin.o) it also inserts vtv_end.o into the link line,\n+   just before crtend.o.  This has the desired effect of making our\n+   section page-aligned and page-size paded, ensuring that no other\n+   program data lands on our pages.  */\n+\n+#include \"vtv-change-permission.h\"\n+\n+void\n+__VLTProtectPreinit (void)\n+{\n+  __VLTChangePermission (__VLTP_READ_ONLY);\n+}\n+\n+/* Page-sized variable to mark end of .vtable_map_vars section.  */\n+char _vtable_map_vars_end[VTV_PAGE_SIZE]\n+  __attribute__ ((__visibility__ (\"protected\"), used,\n+\t\t  section(\".vtable_map_vars\")));\n+\n+/* Put the function __VLTProtectPreinit into the .preinit_array\n+   section.  */\n+\n+__attribute__ ((section (\".preinit_array\")))\n+    typeof (__VLTProtectPreinit) *__preinit_end = __VLTProtectPreinit;"}, {"sha": "3efb63dfbb034e3f1bb3224dfa225ac56f71012e", "filename": "libgcc/vtv_start.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_start.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_start.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fvtv_start.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,65 @@\n+/*  Copyright (C) 2012, 2013\n+    Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verification feature (for a\n+   detailed description of the feature, see comments in\n+   vtable-verify.c).  The vtable verification feature creates\n+   certain global symbols that need to be read-write sometimes during\n+   program execution, and read-only at others.  It uses 'mprotect' to\n+   change the memory protections of the pages on which these variables\n+   are stored.  In order to not affect the protections of other\n+   program variables, these variables are put into a special named\n+   section, \".vtable_map_vars\", which is page-aligned at the start,\n+   and which is padded with a page-sized amount of zeros at the end.\n+   To make this section page aligned, we create a special symbol,\n+   \"_vtable_map_vars_start\" which we make the very first thing that\n+   goes into the section.  This file defines that symbol (and only\n+   that symbol).  GCC compiles this file into vtv_start.o, and\n+   inserts vtv_start.o into the link line immediately after\n+   crtbegin.o, if the program is compiled with -fvtable.verify.\n+\n+   In order to pad the \".vtable_map_vars\" section with a page-sized\n+   amount of zeros at the end, there is a second symbol,\n+   _vtable_map_vars_end, which is defined in another file, vtv_end.c.\n+   This second symbol is a page-sized array of chars, zero-filled, and\n+   is the very last thing to go into the section.  When the GCC driver\n+   inserts vtv_start.o into the link line (just after crtbegin.o) it\n+   also inserts vtv_end.o into the link line, just before crtend.o.\n+   This has the desired effect of making our section page-aligned and\n+   page-size paded, ensuring that no other program data lands on our\n+   pages.  */\n+\n+#include \"vtv-change-permission.h\"\n+\n+__attribute__ ((constructor(98))) void\n+__VLTunprotect (void)\n+{\n+  __VLTChangePermission (__VLTP_READ_WRITE);\n+}\n+\n+/* Page-aligned symbol to mark beginning of .vtable_map_vars section.  */\n+char _vtable_map_vars_start []\n+__attribute__ ((__visibility__ (\"protected\"), used, aligned(VTV_PAGE_SIZE),\n+\t\tsection(\".vtable_map_vars\")))\n+  = { };"}, {"sha": "512c8581a283ef3f0ab02838b19cb9a4b5802e2b", "filename": "libgcc/vtv_start_preinit.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_start_preinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libgcc%2Fvtv_start_preinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fvtv_start_preinit.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,73 @@\n+/*  Copyright (C) 2012, 2013\n+    Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verification feature (for a\n+   detailed description of the feature, see comments in\n+   vtable-verify.c).  The vtable verification feature creates\n+   certain global symbols that need to be read-write sometimes during\n+   program execution, and read-only at others.  It uses 'mprotect' to\n+   change the memory protections of the pages on which these variables\n+   are stored.  In order to not affect the protections of other\n+   program variables, these variables are put into a special named\n+   section, \".vtable_map_vars\", which is page-aligned at the start,\n+   and which is padded with a page-sized amount of zeros at the end.\n+   To make this section page aligned, we create a special symbol,\n+   \"_vtable_map_vars_start\" which we make the very first thing that\n+   goes into the section.  This file defines that symbol (and only\n+   that symbol).  GCC compiles this file into vtv_start.o, and\n+   inserts vtv_start.o into the link line immediately after\n+   crtbegin.o, if the program is compiled with -fvtable.verify.\n+\n+   In order to pad the \".vtable_map_vars\" section with a page-sized\n+   amount of zeros at the end, there is a second symbol,\n+   _vtable_map_vars_end, which is defined in another file, vtv_end.c.\n+   This second symbol is a page-sized array of chars, zero-filled, and\n+   is the very last thing to go into the section.  When the GCC driver\n+   inserts vtv_start.o into the link line (just after crtbegin.o) it\n+   also inserts vtv_end.o into the link line, just before crtend.o.\n+   This has the desired effect of making our section page-aligned and\n+   page-size paded, ensuring that no other program data lands on our\n+   pages.  */\n+\n+#include \"vtv-change-permission.h\"\n+\n+void\n+__VLTUnprotectPreinit (void)\n+{\n+  __VLTChangePermission (__VLTP_READ_WRITE);\n+}\n+\n+/* Page-aligned symbol to mark beginning of .vtable_map_vars section.  */\n+char _vtable_map_vars_start []\n+__attribute__ ((__visibility__ (\"protected\"), used, aligned(VTV_PAGE_SIZE),\n+\t\tsection(\".vtable_map_vars\")))\n+  = { };\n+\n+\n+/* Put the function __VLTUnprotectPreinit into the .preinit_array\n+   section.  */\n+\n+__attribute__ ((section (\".preinit_array\")))\n+    typeof (__VLTUnprotectPreinit) *__preinit = __VLTUnprotectPreinit;\n+"}, {"sha": "40d569eec3780c20fd32a81199ebccf9a14e5675", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,3 +1,43 @@\n+2013-08-06  Caroline Tice  <cmtice@google.com>\n+\n+\t* fragment.am: Add XTEMPLATE_FLAGS.\n+\t* configure.ac: Add definitions for --enable-vtable-verify.\n+\t* acinclude.m4:  Add --enable-vtable-verify and\n+\t--disable-vtable-verify; define --enable-vtable-verify; define\n+\tVTV_CXXFLAGS, VTV_PCH_CXXFLAGS and VTV_CXXLINKFLAGS.\n+\t* config/abi/pre/gnu.ver: Export symbols for vtable verification.\n+\t* libsupc++/Makefile.am: Define vtv_sources and add it to\n+\tlibsupc___la_SOURCES and libsupc__convenience_la_SOURCES.\n+\t* libsupc++/vtv_stubs.cc: New file.\n+\t* include/Makefile.am: Add VTV_PCH_CXXFLAGS to PCHFLAGS.\n+\t* src/Makefile.am: Add VTV_CXXFLAGS to AM_CXXFLAGS; add\n+\tVTV_CXXLINKFLAGS to CXXLINK.\n+\t* src/c++98/Makefile.am: Comment out XTEMPLATE_FLAGS; add VTV_CXXFLAGS\n+\tto AM_CXXFLAGS; add VTV_CXXXLINKFLAGS to CXXLINK.\n+\t* src/C++11/Makefile.am: Ditto.\n+\t* doc/xml/manual/configure.xml: Add entry for --enable-vtable-verify.\n+\t* scripts/testsuite_flags.in: Add cxxvtvflags to Usage; cause\n+\tcxxvtvflags to use VTV_CXXFLAGS and VTV_CXXLINKFLAGS.\n+\t* testsuite/lib/libstdc++.exp: Add cxxvtvflags; add code to locate\n+\tlibvtv if --enable-vtable-verify was used; set cxxvtvflags; add\n+\tcxxvtvflags to cxx_final.\n+\t* testsuite/18_support/bad_exception/23591_thread-1.c: Add\n+\t-fvtable-verify=none to compiler flags.\n+\t* testsuite/17_intro/freestanding.cc: Add -fvtable-verify=none\n+\tto compiler flags.\n+\t* configure: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\t* python/Makefile.in: Regenerated.\n+\t* include/Makefile.in: Regenerated.\n+\t* libsupc++/Makefile.in: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* po/Makefile.in: Regenerated.\n+\t* src/Makefile.in: Regenerated.\n+\t* src/c++98/Makefile.in: Regenerated.\n+\t* src/c++11/Makefile.in: Regenerated.\n+\t* doc/Makefile.in: Regenerated.\n+\t* testsuite/Makefile.in: Regenerated.\n+\n 2013-08-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tRevert the last commit."}, {"sha": "bede542535d97be9f24a1a6f27d250601d740c69", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -203,6 +203,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -299,6 +302,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS."}, {"sha": "72b90a802522c5fcf4b420e5ef376720d768b000", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -2284,6 +2284,38 @@ AC_DEFUN([GLIBCXX_ENABLE_EXTERN_TEMPLATE], [\n   GLIBCXX_CONDITIONAL(ENABLE_EXTERN_TEMPLATE, test $enable_extern_template = yes)\n ])\n \n+dnl\n+dnl Use vtable verification.\n+dnl\n+dnl --enable-vtable-verify defines _GLIBCXX_VTABLE_VERIFY to 1\n+dnl --disable-vtable-verify defines _GLIBCXX_VTABLE_VERIFY to 0\n+\n+dnl  +  Usage:  GLIBCXX_ENABLE_VTABLE_VERIFY[(DEFAULT)]\n+dnl       Where DEFAULT is `yes' or `no'.\n+dnl\n+AC_DEFUN([GLIBCXX_ENABLE_VTABLE_VERIFY], [\n+\n+  GLIBCXX_ENABLE(vtable-verify,$1,,[enable vtable verify])\n+\n+  AC_MSG_CHECKING([for vtable verify support])\n+  AC_MSG_RESULT([$enable_vtable_verify])\n+\n+  if test $enable_vtable_verify = yes; then\n+    VTV_CXXFLAGS=\"-fvtable-verify=std -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\"\n+    VTV_PCH_CXXFLAGS=\"-fvtable-verify=std\"\n+    VTV_CXXLINKFLAGS=\"-L${toplevel_builddir}/libvtv/.libs -Wl,--rpath -Wl,${toplevel_builddir}/libvtv/.libs\"\t\t\n+  else\n+    VTV_CXXFLAGS= \n+    VTV_PCH_CXXFLAGS=\n+    VTV_CXXLINKFLAGS= \n+  fi\n+\n+  AC_SUBST(VTV_CXXFLAGS)\n+  AC_SUBST(VTV_PCH_CXXFLAGS)\n+  AC_SUBST(VTV_CXXLINKFLAGS)\n+  GLIBCXX_CONDITIONAL(ENABLE_VTABLE_VERIFY, test $enable_vtable_verify = yes)\n+])\n+\n dnl\n dnl Check for parallel mode pre-requisites, including OpenMP support.\n dnl"}, {"sha": "4c029d21ff2ef3ec96976c0cb1dea67d5edae009", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -810,12 +810,13 @@\n    namespace std::tr1. */\n #undef _GLIBCXX_USE_C99_STDINT_TR1\n \n+/* Defined if clock_gettime syscall has monotonic and realtime clock support.\n+   */\n+#undef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+\n /* Defined if clock_gettime has monotonic clock support. */\n #undef _GLIBCXX_USE_CLOCK_MONOTONIC\n \n-/* Defined if clock_gettime syscall has monotonic and realtime clock support. */\n-#undef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n-\n /* Defined if clock_gettime has realtime clock support. */\n #undef _GLIBCXX_USE_CLOCK_REALTIME\n "}, {"sha": "8972fcfca880d920d23213e328a3c424ad883f09", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1572,6 +1572,16 @@ CXXABI_1.3.8 {\n \n     __cxa_throw_bad_array_length;\n     _Z*St16bad_array_length*;\n+\n+    # Virtual table verification stub functions.\n+    _Z17__VLTRegisterPair*;\n+    _Z22__VLTRegisterPairDebug*;\n+    _Z16__VLTRegisterSet*;\n+    _Z21__VLTRegisterSetDebug*;\n+    _Z24__VLTVerifyVtablePointer*;\n+    _Z29__VLTVerifyVtablePointerDebug*;\n+    __VLTChangePermission;\n+\n } CXXABI_1.3.7;\n \n # Symbols in the support library (libsupc++) supporting transactional memory."}, {"sha": "f3b4b13ecd72a4bd65adad8563b6a0d13512b42b", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 72, "deletions": 10, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -664,6 +664,11 @@ LIBICONV\n OPT_LDFLAGS\n SECTION_LDFLAGS\n GLIBCXX_LIBS\n+ENABLE_VTABLE_VERIFY_FALSE\n+ENABLE_VTABLE_VERIFY_TRUE\n+VTV_CXXLINKFLAGS\n+VTV_PCH_CXXFLAGS\n+VTV_CXXFLAGS\n ENABLE_WERROR_FALSE\n ENABLE_WERROR_TRUE\n ENABLE_PYTHONDIR_FALSE\n@@ -866,6 +871,7 @@ enable_fully_dynamic_string\n enable_extern_template\n with_python_dir\n enable_werror\n+enable_vtable_verify\n enable_libstdcxx_time\n enable_tls\n enable_rpath\n@@ -1558,6 +1564,7 @@ Optional Features:\n   --enable-extern-template\n                           enable extern template [default=yes]\n   --enable-werror         turns on -Werror [default=yes]\n+  --enable-vtable-verify  enable vtable verify [default=no]\n   --enable-libstdcxx-time[=KIND]\n                           use KIND for check type [default=auto]\n   --enable-tls            Use thread-local storage [default=yes]\n@@ -11513,7 +11520,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11516 \"configure\"\n+#line 11523 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11619,7 +11626,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11622 \"configure\"\n+#line 11629 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -14906,6 +14913,12 @@ esac\n \n \n \n+if test \"$enable_vtable_verify\" = yes; then\n+  predep_objects_CXX=\"${predep_objects_CXX} ${glibcxx_builddir}/../libgcc/vtv_start.o\"\n+  postdep_objects_CXX=\"${postdep_objects_CXX} ${glibcxx_builddir}/../libgcc/vtv_end.o\"\n+fi\n+\n+\n # libtool variables for C++ shared and position-independent compiles.\n #\n # Use glibcxx_lt_pic_flag to designate the automake variable\n@@ -15033,7 +15046,7 @@ fi\n     #\n     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n-#line 15036 \"configure\"\n+#line 15049 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()\n@@ -15383,7 +15396,7 @@ $as_echo \"$glibcxx_cv_atomic_long_long\" >&6; }\n   # Fake what AC_TRY_COMPILE does.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15386 \"configure\"\n+#line 15399 \"configure\"\n int main()\n {\n   typedef bool atomic_type;\n@@ -15418,7 +15431,7 @@ $as_echo \"$glibcxx_cv_atomic_bool\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15421 \"configure\"\n+#line 15434 \"configure\"\n int main()\n {\n   typedef short atomic_type;\n@@ -15453,7 +15466,7 @@ $as_echo \"$glibcxx_cv_atomic_short\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15456 \"configure\"\n+#line 15469 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n@@ -15489,7 +15502,7 @@ $as_echo \"$glibcxx_cv_atomic_int\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15492 \"configure\"\n+#line 15505 \"configure\"\n int main()\n {\n   typedef long long atomic_type;\n@@ -15568,7 +15581,7 @@ $as_echo \"$as_me: WARNING: Performance of certain classes will degrade as a resu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15571 \"configure\"\n+#line 15584 \"configure\"\n int main()\n {\n   _Decimal32 d1;\n@@ -15610,7 +15623,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 15613 \"configure\"\n+#line 15626 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -15644,7 +15657,7 @@ $as_echo \"$enable_int128\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 15647 \"configure\"\n+#line 15660 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -17379,6 +17392,42 @@ $as_echo \"$enable_werror\" >&6; }\n \n \n \n+\n+   # Check whether --enable-vtable-verify was given.\n+if test \"${enable_vtable_verify+set}\" = set; then :\n+  enableval=$enable_vtable_verify;\n+      case \"$enableval\" in\n+       yes|no) ;;\n+       *) as_fn_error \"Argument to enable/disable vtable-verify must be yes or no\" \"$LINENO\" 5 ;;\n+      esac\n+\n+else\n+  enable_vtable_verify=no\n+fi\n+\n+\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for vtable verify support\" >&5\n+$as_echo_n \"checking for vtable verify support... \" >&6; }\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $enable_vtable_verify\" >&5\n+$as_echo \"$enable_vtable_verify\" >&6; }\n+\n+  if test $enable_vtable_verify = yes; then\n+    VTV_CXXFLAGS=\"-fvtable-verify=std -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\"\n+    VTV_PCH_CXXFLAGS=\"-fvtable-verify=std\"\n+    VTV_CXXLINKFLAGS=\"-L${toplevel_builddir}/libvtv/.libs -Wl,--rpath -Wl,${toplevel_builddir}/libvtv/.libs\"\n+  else\n+    VTV_CXXFLAGS=\n+    VTV_PCH_CXXFLAGS=\n+    VTV_CXXLINKFLAGS=\n+  fi\n+\n+\n+\n+\n+\n+\n+\n # Checks for operating systems support that doesn't require linking.\n \n \n@@ -72960,6 +73009,15 @@ else\n fi\n \n \n+    if test $enable_vtable_verify = yes; then\n+  ENABLE_VTABLE_VERIFY_TRUE=\n+  ENABLE_VTABLE_VERIFY_FALSE='#'\n+else\n+  ENABLE_VTABLE_VERIFY_TRUE='#'\n+  ENABLE_VTABLE_VERIFY_FALSE=\n+fi\n+\n+\n     if test $enable_symvers != no; then\n   ENABLE_SYMVERS_TRUE=\n   ENABLE_SYMVERS_FALSE='#'\n@@ -73403,6 +73461,10 @@ if test -z \"${ENABLE_WERROR_TRUE}\" && test -z \"${ENABLE_WERROR_FALSE}\"; then\n   as_fn_error \"conditional \\\"ENABLE_WERROR\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${ENABLE_VTABLE_VERIFY_TRUE}\" && test -z \"${ENABLE_VTABLE_VERIFY_FALSE}\"; then\n+  as_fn_error \"conditional \\\"ENABLE_VTABLE_VERIFY\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${ENABLE_SYMVERS_TRUE}\" && test -z \"${ENABLE_SYMVERS_FALSE}\"; then\n   as_fn_error \"conditional \\\"ENABLE_SYMVERS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "dd13b011f97a71c758e9454453fca06ee52ba636", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -97,6 +97,12 @@ ACX_LT_HOST_FLAGS\n AC_SUBST(enable_shared)\n AC_SUBST(enable_static)\n \n+if test \"$enable_vtable_verify\" = yes; then\n+  predep_objects_CXX=\"${predep_objects_CXX} ${glibcxx_builddir}/../libgcc/vtv_start.o\"\n+  postdep_objects_CXX=\"${postdep_objects_CXX} ${glibcxx_builddir}/../libgcc/vtv_end.o\"\n+fi\n+\n+\n # libtool variables for C++ shared and position-independent compiles.\n #\n # Use glibcxx_lt_pic_flag to designate the automake variable\n@@ -168,6 +174,7 @@ GLIBCXX_ENABLE_FULLY_DYNAMIC_STRING([no])\n GLIBCXX_ENABLE_EXTERN_TEMPLATE([yes])\n GLIBCXX_ENABLE_PYTHON\n GLIBCXX_ENABLE_WERROR([yes])\n+GLIBCXX_ENABLE_VTABLE_VERIFY([no])\n \n # Checks for operating systems support that doesn't require linking.\n GLIBCXX_CHECK_STDIO_PROTO"}, {"sha": "04e0d7d97f09ed842b194ca19c0cdf4216e45479", "filename": "libstdc++-v3/doc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -175,6 +175,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n \n@@ -281,6 +284,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS."}, {"sha": "cf0989720faca0744e5463b81cc91045059fc158", "filename": "libstdc++-v3/doc/xml/manual/configure.xml", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconfigure.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconfigure.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconfigure.xml?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -382,6 +382,18 @@\n    </para>\n  </listitem></varlistentry>\n \n+ <varlistentry><term><code>--enable-vtable-verify</code>[default]</term>\n+ <listitem>\n+    <para>Use <code>-fvtable-verify=std</code> to compile the C++\n+    runtime with instrumentation for vtable verification. All virtual\n+    functions in the standard library will be verified at runtime.\n+    Types impacted include <classname>locale</classname> and\n+    <classname>iostream</classname>, and others.  Disabling means that\n+    the C++ runtime is compiled without support for vtable\n+    verification. By default, this option is off.\n+     </para>\n+ </listitem></varlistentry>\n+\n </variablelist>\n \n </section>"}, {"sha": "0036ae8004a3567eb7c1336ee37fc9010eeedcae", "filename": "libstdc++-v3/fragment.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ffragment.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ffragment.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ffragment.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -19,6 +19,12 @@ else\n WERROR_FLAG=\n endif\n \n+if ENABLE_EXTERN_TEMPLATE\n+XTEMPLATE_FLAGS = -fno-implicit-templates\n+else\n+XTEMPLATE_FLAGS =\n+endif\n+\n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n CONFIG_CXXFLAGS = \\"}, {"sha": "d08864cf7b857942cae835796eed0be2a6f97018", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -893,7 +893,7 @@ pch_output_dirs = \\\n \t${pch1_output_builddir} ${pch2_output_builddir} ${pch3_output_builddir}\n pch_output_anchors = \\\n \t${pch1_output_anchor} ${pch2_output_anchor} ${pch3_output_anchor}\n-PCHFLAGS=-x c++-header -nostdinc++ $(CXXFLAGS)\n+PCHFLAGS=-x c++-header -nostdinc++ $(CXXFLAGS) $(VTV_PCH_CXXFLAGS)\n if GLIBCXX_BUILD_PCH\n pch_build = ${pch_output}\n else"}, {"sha": "95c5697f3febedf4ff55aba43ebf7f30d81e2650", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -175,6 +175,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -271,6 +274,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n@@ -1147,7 +1152,7 @@ pch_output_dirs = \\\n pch_output_anchors = \\\n \t${pch1_output_anchor} ${pch2_output_anchor} ${pch3_output_anchor}\n \n-PCHFLAGS = -x c++-header -nostdinc++ $(CXXFLAGS)\n+PCHFLAGS = -x c++-header -nostdinc++ $(CXXFLAGS) $(VTV_PCH_CXXFLAGS)\n @GLIBCXX_BUILD_PCH_FALSE@pch_build = \n @GLIBCXX_BUILD_PCH_TRUE@pch_build = ${pch_output}\n "}, {"sha": "f0ab6026ca36d16b79653149139b2e16a6dddaa0", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -26,6 +26,7 @@ include $(top_srcdir)/fragment.am\n # separately too.\n # 1) separate libsupc++.la\n toolexeclib_LTLIBRARIES = libsupc++.la\n+\n # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a\n noinst_LTLIBRARIES = libsupc++convenience.la\n \n@@ -96,8 +97,13 @@ sources = \\\n \tvmi_class_type_info.cc \\\n \tvterminate.cc\n \n-libsupc___la_SOURCES = $(sources) $(c_sources)\n-libsupc__convenience_la_SOURCES = $(sources) $(c_sources)\n+if ENABLE_VTABLE_VERIFY\n+  vtv_sources = \\\n+\tvtv_stubs.cc\n+endif\n+\n+libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)\n+libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)\n \n cp-demangle.c:\n \trm -f $@\n@@ -282,3 +288,8 @@ uninstall-bitsHEADERS:\n \t  q=`echo $$p | sed -e 's,.*/,,'`; \\\n \t  rm -f $(DESTDIR)$(bitsdir)/$$q; \\\n \tdone\n+\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = stamp-*\n+"}, {"sha": "88b237e1275e3759a26e75ba4f06b9b6ec72078e", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -105,10 +105,13 @@ am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \\\n \tpointer_type_info.lo pure.lo si_class_type_info.lo tinfo.lo \\\n \ttinfo2.lo vec.lo vmi_class_type_info.lo vterminate.lo\n @GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo\n-am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)\n+@ENABLE_VTABLE_VERIFY_TRUE@am__objects_3 = vtv_stubs.lo\n+am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n+\t$(am__objects_3)\n libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)\n libsupc__convenience_la_LIBADD =\n-am_libsupc__convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2)\n+am_libsupc__convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n+\t$(am__objects_3)\n libsupc__convenience_la_OBJECTS =  \\\n \t$(am_libsupc__convenience_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n@@ -235,6 +238,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -331,6 +337,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n@@ -348,6 +356,7 @@ AM_CPPFLAGS = $(GLIBCXX_INCLUDES)\n # separately too.\n # 1) separate libsupc++.la\n toolexeclib_LTLIBRARIES = libsupc++.la\n+\n # 2) integrated libsupc++convenience.la that is to be a part of libstdc++.a\n noinst_LTLIBRARIES = libsupc++convenience.la\n std_HEADERS = \\\n@@ -414,8 +423,11 @@ sources = \\\n \tvmi_class_type_info.cc \\\n \tvterminate.cc\n \n-libsupc___la_SOURCES = $(sources) $(c_sources)\n-libsupc__convenience_la_SOURCES = $(sources) $(c_sources)\n+@ENABLE_VTABLE_VERIFY_TRUE@vtv_sources = \\\n+@ENABLE_VTABLE_VERIFY_TRUE@\tvtv_stubs.cc\n+\n+libsupc___la_SOURCES = $(sources) $(c_sources) $(vtv_sources)\n+libsupc__convenience_la_SOURCES = $(sources) $(c_sources) $(vtv_sources)\n \n # AM_CXXFLAGS needs to be in each subdirectory so that it can be\n # modified in a per-library or per-sub-library way.  Need to manually\n@@ -499,6 +511,9 @@ CXXLINK = \\\n # prepending each of $(*_HEADERS) with VPATH below.\n stddir = $(gxx_include_dir)\n bitsdir = $(gxx_include_dir)/bits\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = stamp-*\n all: all-am\n \n .SUFFIXES:\n@@ -683,6 +698,7 @@ install-strip:\n mostlyclean-generic:\n \n clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n \n distclean-generic:\n \t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)"}, {"sha": "a41d943f31f95283a9a39580a7813bb50391dc48", "filename": "libstdc++-v3/libsupc++/vtv_stubs.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvtv_stubs.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,100 @@\n+// Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/* This is part of the vtable verification runtime library.  For more\n+   information about this feature, see the comments in libvtv/vtv_rts.cc.  */\n+\n+/* The functions in this file are used to create the libvtv_stubs\n+   library, as part of the vtable verification feature.  When building\n+   a binary without vtable verification, and linking it with a\n+   (possibly pre-built third-party) library that was built with\n+   verification, it is possible that vtable verification will fail due\n+   to incomplete data (rather than due to corrupt vtable pointers).  In\n+   this case we need to give programmers a way of turning off the\n+   vtable verification in their libraries.  They can do so by linking\n+   with the libvtv_stubs library, which (as you can see) will replace\n+   the real verification functions with a set of functions that do\n+   nothing (so no more verification failures/aborts).  */\n+\n+#include <cstddef>\n+\n+// Declare as weak for libsupc++, strong definitions are in libvtv.\n+#if __GXX_WEAK__\n+extern \"C\"\n+void\n+__VLTChangePermission(int) __attribute__((weak));\n+\n+void\n+__VLTRegisterSet(void**, const void*, std::size_t, std::size_t,\n+\t\t void**) __attribute__((weak));\n+\n+void\n+__VLTRegisterPair(void**, const void*, std::size_t,\n+\t\t  const void*) __attribute__((weak));\n+\n+const void*\n+__VLTVerifyVtablePointer(void**, const void*) __attribute__((weak));\n+\n+void\n+__VLTRegisterSetDebug(void**, const void*, std::size_t, std::size_t,\n+\t\t      void**) __attribute__((weak));\n+\n+void\n+__VLTRegisterPairDebug(void**, const void*, std::size_t, const void*,\n+\t\t       const char*, const char*) __attribute__((weak));\n+\n+const void*\n+__VLTVerifyVtablePointerDebug(void**, const void*, const char*,\n+\t\t\t      const char*) __attribute__((weak));\n+#endif\n+\n+// Stub definitions.\n+extern \"C\"\n+void\n+__VLTChangePermission(int)\n+{ }\n+\n+void\n+__VLTRegisterSet(void**, const void*, std::size_t, std::size_t, void**)\n+{ }\n+\n+void\n+__VLTRegisterPair(void**, const void*, std::size_t, const void*)\n+{ }\n+\n+const void*\n+__VLTVerifyVtablePointer(void**, const void* vtable_ptr)\n+{ return vtable_ptr; }\n+\n+void\n+__VLTRegisterSetDebug(void**, const void*, std::size_t, std::size_t, void**)\n+{ }\n+\n+void\n+__VLTRegisterPairDebug(void**, const void*, std::size_t, const void*,\n+\t\t       const char*, const  char*)\n+{ }\n+\n+const void*\n+__VLTVerifyVtablePointerDebug(void**, const void* vtable_ptr, const char*,\n+\t\t\t      const char*)\n+{ return vtable_ptr; }"}, {"sha": "52f5256a6cebd4313e88562260cfee3f318a7d15", "filename": "libstdc++-v3/po/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpo%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -175,6 +175,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -271,6 +274,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS."}, {"sha": "21d74a909307e0aa03ab4b46675ea2d589fe47eb", "filename": "libstdc++-v3/python/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fpython%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fpython%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -199,6 +199,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -295,6 +298,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS."}, {"sha": "cf692f8f059cd1e6d32750d45fdb3e99740b9550", "filename": "libstdc++-v3/scripts/testsuite_flags.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Ftestsuite_flags.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -18,8 +18,10 @@ Usage:\n \t\t    --build-cc\n \t\t    --install-cxx\n \t\t    --cxxflags\n-\t\t    --cxxpchflags\n \t\t    --cxxldflags\n+\t\t    --cxxpchflags\n+\t\t    --cxxvtvflags\n+\n EOF\n }\n \n@@ -56,7 +58,12 @@ case ${query} in\n     --cxxflags)\n       CXXFLAGS_default=\"-D_GLIBCXX_ASSERT -fmessage-length=0\"\n       CXXFLAGS_config=\"@SECTION_FLAGS@ @CXXFLAGS@ @EXTRA_CXX_FLAGS@\"\n-      echo ${CXXFLAGS_default} ${CXXFLAGS_config}\n+      echo ${CXXFLAGS_default} ${CXXFLAGS_config} \n+      ;;\n+    --cxxvtvflags)\n+      CXXFLAGS_vtv=\"@VTV_CXXFLAGS@\"\n+      LDFLAGS_vtv=\"@VTV_CXXLINKFLAGS@\"\n+      echo ${CXXFLAGS_vtv} ${LDFLAGS_vtv}\n       ;;\n     --cxxparallelflags)\n       CXXFLAGS_parallel=\"-D_GLIBCXX_PARALLEL -fopenmp"}, {"sha": "c3c6ab77e7a60c82a42bdef12eb512e05ce9384a", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -73,7 +73,6 @@ libstdc___la_LDFLAGS = \\\n \n libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)\n \n-\n # Use special rules for compatibility-ldbl.cc compilation, as we need to\n # pass -mlong-double-64.\n if GLIBCXX_LDBL_COMPAT\n@@ -138,7 +137,7 @@ compatibility-condvar.o: compatibility-condvar.cc\n # as the occasion calls for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_compiler_pic_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n # Libtool notes\n@@ -185,9 +184,9 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n \n-\n # Symbol versioning for shared libraries.\n if ENABLE_SYMVERS\n libstdc++-symbols.ver:  ${glibcxx_srcdir}/$(SYMVER_FILE) \\"}, {"sha": "cd3943b1afc842bcb2bbb628d48b9208649163e0", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -226,6 +226,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -322,6 +325,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n@@ -403,7 +408,7 @@ libstdc___la_LINK = $(CXXLINK) $(libstdc___la_LDFLAGS)\n # as the occasion calls for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_compiler_pic_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n \n@@ -451,6 +456,7 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n \n @ENABLE_SYMVERS_TRUE@CLEANFILES = libstdc++-symbols.ver $(version_dep)"}, {"sha": "58d3025f0e733be3c84b34b1e133cfc8504d4e24", "filename": "libstdc++-v3/src/c++11/Makefile.am", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -46,13 +46,13 @@ sources = \\\n \tthread.cc\n \n if ENABLE_EXTERN_TEMPLATE\n-XTEMPLATE_FLAGS = -fno-implicit-templates\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n inst_sources = \\\n \tfstream-inst.cc \\\n \tstring-inst.cc \\\n \twstring-inst.cc\n else\n-XTEMPLATE_FLAGS =\n+# XTEMPLATE_FLAGS =\n inst_sources =\n endif\n \n@@ -75,7 +75,7 @@ hashtable_c++0x.o: hashtable_c++0x.cc\n AM_CXXFLAGS = \\\n \t-std=gnu++11 \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\\n@@ -125,4 +125,5 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX --tag disable-shared \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@"}, {"sha": "5daae3edf69aba6abc8d9969589a2d34905188af", "filename": "libstdc++-v3/src/c++11/Makefile.in", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -192,6 +192,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -288,6 +291,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n@@ -322,9 +327,10 @@ sources = \\\n \tsystem_error.cc \\\n \tthread.cc\n \n-@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n-@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n+# XTEMPLATE_FLAGS =\n @ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = \n+\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n @ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tfstream-inst.cc \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tstring-inst.cc \\\n@@ -340,7 +346,7 @@ libc__11convenience_la_SOURCES = $(sources)  $(inst_sources)\n AM_CXXFLAGS = \\\n \t-std=gnu++11 \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\\n@@ -391,6 +397,7 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX --tag disable-shared \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n \n all: all-am"}, {"sha": "8ebff1aff23c339676c8e54dca65bb58a3d46884", "filename": "libstdc++-v3/src/c++98/Makefile.am", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -82,7 +82,7 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \n \n if ENABLE_EXTERN_TEMPLATE\n-XTEMPLATE_FLAGS = -fno-implicit-templates\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n inst_sources = \\\n \tallocator-inst.cc \\\n \tconcept-inst.cc \\\n@@ -97,7 +97,7 @@ inst_sources = \\\n \tstreambuf-inst.cc \\\n \twlocale-inst.cc\n else\n-XTEMPLATE_FLAGS =\n+# XTEMPLATE_FLAGS =\n inst_sources =\n endif\n \n@@ -172,7 +172,7 @@ parallel_settings.o: parallel_settings.cc\n # as the occasion calls for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\\n@@ -222,4 +222,5 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX --tag disable-shared \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@"}, {"sha": "cf9cda5f4d6d564a8d0b0c667fe1038994744730", "filename": "libstdc++-v3/src/c++98/Makefile.in", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B98%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -208,6 +208,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -304,6 +307,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.\n@@ -342,9 +347,10 @@ host_sources_extra = \\\n \tbasic_file.cc c++locale.cc \\\n \t${inst_sources} ${parallel_sources}\n \n-@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n-@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n+# XTEMPLATE_FLAGS =\n @ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = \n+\n+# XTEMPLATE_FLAGS = -fno-implicit-templates\n @ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tallocator-inst.cc \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tconcept-inst.cc \\\n@@ -412,7 +418,7 @@ PARALLEL_FLAGS = -D_GLIBCXX_PARALLEL\n # as the occasion calls for it.\n AM_CXXFLAGS = \\\n \t$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \\\n-\t$(XTEMPLATE_FLAGS) \\\n+\t$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \\\n \t$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)\n \n AM_MAKEFLAGS = \\\n@@ -463,6 +469,7 @@ CXXLINK = \\\n \t$(LIBTOOL) --tag CXX --tag disable-shared \\\n \t$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXX) \\\n+\t$(VTV_CXXLINKFLAGS) \\\n \t$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@\n \n all: all-am"}, {"sha": "6518af5b8316c2c5463a9587a884f43f85ddf5e7", "filename": "libstdc++-v3/testsuite/17_intro/freestanding.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,4 +1,4 @@\n-// { dg-options \"-x c -std=gnu++0x -lsupc++\" }\n+// { dg-options \"-x c -std=gnu++0x -lsupc++ -fvtable-verify=none\" }\n \n // Copyright (C) 2010-2013 Free Software Foundation, Inc.\n //"}, {"sha": "0b8d1e26d3b03fb4ab3090cc9bd64a680763f4c0", "filename": "libstdc++-v3/testsuite/18_support/bad_exception/23591_thread-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbad_exception%2F23591_thread-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbad_exception%2F23591_thread-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fbad_exception%2F23591_thread-1.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -1,5 +1,5 @@\n // { dg-require-sharedlib \"\" }\n-// { dg-options \"-g -O2 -pthread -ldl -x c\" { target *-*-linux* *-*-gnu* } }\n+// { dg-options \"-g -O2 -pthread -ldl -x c -fvtable-verify=none\" { target *-*-linux* *-*-gnu* } }\n \n // Copyright (C) 2005-2013 Free Software Foundation, Inc.\n //"}, {"sha": "779e932ea279bcfa6314e1b9d4f968561a73b23d", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -175,6 +175,9 @@ SYMVER_FILE = @SYMVER_FILE@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n USE_NLS = @USE_NLS@\n VERSION = @VERSION@\n+VTV_CXXFLAGS = @VTV_CXXFLAGS@\n+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@\n+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@\n WARN_FLAGS = @WARN_FLAGS@\n WERROR = @WERROR@\n XMLLINT = @XMLLINT@\n@@ -274,6 +277,8 @@ toolexecdir = $(glibcxx_toolexecdir)\n toolexeclibdir = $(glibcxx_toolexeclibdir)\n @ENABLE_WERROR_FALSE@WERROR_FLAG = \n @ENABLE_WERROR_TRUE@WERROR_FLAG = $(WERROR)\n+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = \n+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates\n \n # These bits are all figured out from configure.  Look in acinclude.m4\n # or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS."}, {"sha": "83a3862fbd0338248fdf331a189b339503a09169", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -84,7 +84,7 @@ proc libstdc++_init { testfile } {\n     global env\n     global v3-sharedlib v3-libgomp\n     global srcdir blddir objdir tool_root_dir\n-    global cc cxx cxxflags cxxpchflags cxxldflags\n+    global cc cxx cxxflags cxxpchflags cxxldflags cxxvtvflags\n     global includes\n     global gluefile wrap_flags\n     global ld_library_path\n@@ -157,6 +157,17 @@ proc libstdc++_init { testfile } {\n     }\n     v3track libgompdir 3\n \n+    # Locate libvtv. This is only required for --enable-vtable-verify.\n+    set v3-libvtv 0\n+    set libvtvdir [lookfor_file $blddir/../libvtv .libs/libvtv.$shlib_ext]\n+    if {$libvtvdir != \"\"} {\n+\tset v3-libvtv 1\n+        set libvtvdir [file dirname $libvtvdir]\n+\tappend ld_library_path_tmp \":${libvtvdir}\"\n+\tverbose -log \"libvtv support detected\"\n+    }\n+    v3track libvtvdir 3\n+\n     # Locate libstdc++ shared library. (ie libstdc++.so.)\n     set v3-sharedlib 0\n     set sharedlibdir [lookfor_file $blddir src/.libs/libstdc++.$shlib_ext]\n@@ -214,6 +225,7 @@ proc libstdc++_init { testfile } {\n     set cxx [transform \"g++\"]\n     set cxxflags \"-D_GLIBCXX_ASSERT -fmessage-length=0\"\n     set cxxpchflags \"\"\n+    set cxxvtvflags \"\"\n     set cxxldflags \"\"\n     set cc [transform \"gcc\"]\n     # Locate testsuite_hooks.h and other testsuite headers.\n@@ -261,6 +273,7 @@ proc libstdc++_init { testfile } {\n \tset cxx [exec sh $flags_file --build-cxx]\n \tset cxxflags [exec sh $flags_file --cxxflags]\n \tset cxxpchflags [exec sh $flags_file --cxxpchflags]\n+\tset cxxvtvflags [exec sh $flags_file --cxxvtvflags]\n \tset cxxldflags [exec sh $flags_file --cxxldflags]\n \tset cc [exec sh $flags_file --build-cc]\n \tset includes [exec sh $flags_file --build-includes]\n@@ -424,6 +437,7 @@ proc v3_target_compile { source dest type options } {\n     global wrap_flags\n     global cxx\n     global cxxflags\n+    global cxxvtvflags\n     global cxxldflags\n     global includes\n     global STATIC_LIBCXXFLAGS\n@@ -438,6 +452,7 @@ proc v3_target_compile { source dest type options } {\n     set cxx_final [concat $cxx_final $cxxlibglossflags]\n     set cxx_final [concat $cxx_final $STATIC_LIBCXXFLAGS]\n     set cxx_final [concat $cxx_final $cxxflags]\n+    set cxx_final [concat $cxx_final $cxxvtvflags]\n     set cxx_final [concat $cxx_final $includes]\n \n     # Flag setting based on type argument."}, {"sha": "e85a9bde4509dd41b5c33fed141c9af6c031b077", "filename": "libvtv/ChangeLog", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FChangeLog?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,66 @@\n+2013-08-02  Caroline Tice  <cmtice@google.com>\n+\n+\tInitial check-in of new vtable verification feature.\n+\t* configure.ac : New file.\n+\t* acinclude.m4 : New file.\n+\t* Makefile.am : New file.\n+\t* aclocal.m4 : New file.\n+\t* configure.tgt : New file.\n+\t* configure: New file (generated).\n+\t* Makefile.in: New file (generated).\n+\t* vtv_set.h : New file.\n+\t* vtv_utils.cc : New file.\n+\t* vtv_utils.h : New file.\n+\t* vtv_malloc.cc : New file.\n+\t* vtv_rts.cc : New file.\n+\t* vtv_malloc.h : New file.\n+\t* vtv_rts.h : New file.\n+\t* vtv_fail.cc : New file.\n+\t* vtv_fail.h : New file.\n+\t* vtv_map.h : New file.\n+\t* scripts/run-testsuite.sh : New file.\n+\t* scripts/sum-vtv-counts.c : New file.\n+\t* testsuite/parts-test-main.h : New file.\n+\t* testusite/dataentry.cc : New file.\n+\t* testsuite/temp_deriv.cc : New file.\n+\t* testsuite/register_pair.cc : New file.\n+\t* testsuite/virtual_inheritance.cc : New file.\n+\t* testsuite/field-test.cc : New file.\n+\t* testsuite/nested_vcall_test.cc : New file.\n+\t* testsuite/template-list-iostream.cc : New file.\n+\t* testsuite/register_pair_inserts.cc : New file.\n+\t* testsuite/register_pair_inserts_mt.cc : New file.\n+\t* testsuite/event.list : New file.\n+\t* testsuite/parts-test-extra-parts-views.cc : New file.\n+\t* testsuite/parts-test-extra-parts-views.h : New file.\n+\t* testsuite/environment-fail-32.s : New file.\n+\t* testsuite/parts-test-extra-parts.h : New file.\n+\t* testsuite/temp_deriv2.cc : New file.\n+\t* testsuite/dlopen_mt.cc : New file.\n+\t* testsuite/event.h : New file.\n+\t* testsuite/template-list.cc : New file.\n+\t* testsuite/replace-fail.cc : New file.\n+\t* testsuite/Makefile.am : New file.\n+\t* testsuite/Makefile.in: New file (generated).\n+\t* testsuite/mempool_negative.c : New file.\n+\t* testsuite/parts-test-main.cc : New file.\n+\t* testsuite/event-private.cc : New file.\n+\t* testsuite/thunk.cc : New file.\n+\t* testsuite/event-defintiions.cc : New file.\n+\t* testsuite/event-private.h : New file.\n+\t* testsuite/parts-test.list : New file.\n+\t* testusite/register_pair_mt.cc : New file.\n+\t* testsuite/povray-derived.cc : New file.\n+\t* testsuite/event-main.cc : New file.\n+\t* testsuite/environment.cc : New file.\n+\t* testsuite/template-list2.cc : New file.\n+\t* testsuite/thunk_vtable_map_attack.cc : New file.\n+\t* testsuite/parts-test-extra-parts.cc : New file.\n+\t* testsuite/environment-fail-64.s : New file.\n+\t* testsuite/dlopen.cc : New file.\n+\t* testsuite/so.cc : New file.\n+\t* testsuite/temp_deriv3.cc : New file.\n+\t* testsuite/const_vtable.cc : New file.\n+\t* testsuite/mempool_positive.c : New file.\n+\t* testsuite/dup_name.cc : New file.\n+"}, {"sha": "ab3233f2d93947340e3e9b83d355e5a6e9f6b0dd", "filename": "libvtv/Makefile.am", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,83 @@\n+## Makefile for the VTV library.\n+##\n+## Copyright (C) 2013 Free Software Foundation, Inc.\n+##\n+## Process this file with automake to produce Makefile.in.\n+##\n+## This file is part of the Vtable Verification (VTV) Library.  This\n+## library is free software; you can redistribute it and/or modify it\n+## under the terms of the GNU General Public License as published by\n+## the Free Software Foundation; either version 3, or (at your option)\n+## any later version.\n+\n+## This library is distributed in the hope that it will be useful, but\n+## WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+## General Public License for more details.\n+\n+## You should have received a copy of the GNU General Public License\n+## along with this library; see the file COPYING3.  If not see\n+## <http://www.gnu.org/licenses/>.\n+\n+SUBDIRS = testsuite\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+DEFS = \n+AM_CPPFLAGS = -I$(top_srcdir)/../include\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_CXXFLAGS = $(XCFLAGS)  \n+AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\n+\n+toolexeclib_LTLIBRARIES = libvtv.la\n+\n+vtv_headers = \\\n+\tvtv_map.h \\\n+\tvtv_malloc.h \\\n+\tvtv_fail.h \\\n+\tvtv_set.h \\\n+\tvtv_utils.h \\\n+\tvtv_rts.h\n+\n+vtv_sources = \\\n+\tvtv_start.c \\\n+        vtv_malloc.cc \\\n+        vtv_rts.cc \\\n+        vtv_utils.cc \\\n+\tvtv_end.c\n+\n+libvtv_includedir = $(includedir)\n+\n+# Link in vtv_start and vtv_end. \n+BUILT_SOURCES = vtv_start.c vtv_end.c\n+vtv_start.c:\n+\trm -f $@\n+\t$(LN_S) $(toplevel_srcdir)/libgcc/vtv_start.c $@\n+\n+vtv_end.c:\n+\trm -f $@\n+\t$(LN_S) $(toplevel_srcdir)/libgcc/vtv_end.c $@\n+\n+if ENABLE_VTABLE_VERIFY\n+libvtv_la_SOURCES = $(vtv_sources)\n+libvtv_include_HEADERS = $(vtv_headers)\n+else\n+libvtv_la_SOURCES = \n+libvtv_include_HEADERS = \n+endif\n+\n+# Least ordering for dependencies mean linking w/o libstdc++ for as\n+# long as the development of libvtv does not absolutely require it.\n+CXXVTV=$(CC_FOR_TARGET)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXXVTV) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXVTV) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@"}, {"sha": "928a05a91d203095dd109e393ccb5bcf67e0d980", "filename": "libvtv/Makefile.in", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,766 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = .\n+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n+\t$(top_srcdir)/configure $(am__configure_deps) \\\n+\t$(srcdir)/../mkinstalldirs $(srcdir)/../depcomp \\\n+\t$(am__libvtv_include_HEADERS_DIST)\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/libstdc++-raw-cxx.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+\t\"$(DESTDIR)$(libvtv_includedir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libvtv_la_LIBADD =\n+am__objects_1 = vtv_start.lo vtv_malloc.lo vtv_rts.lo vtv_utils.lo \\\n+\tvtv_end.lo\n+@ENABLE_VTABLE_VERIFY_TRUE@am_libvtv_la_OBJECTS = $(am__objects_1)\n+libvtv_la_OBJECTS = $(am_libvtv_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+SOURCES = $(libvtv_la_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-dvi-recursive install-exec-recursive \\\n+\tinstall-html-recursive install-info-recursive \\\n+\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n+\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n+\tps-recursive uninstall-recursive\n+am__libvtv_include_HEADERS_DIST = vtv_map.h vtv_malloc.h vtv_fail.h \\\n+\tvtv_set.h vtv_utils.h vtv_rts.h\n+HEADERS = $(libvtv_include_HEADERS)\n+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n+  distclean-recursive maintainer-clean-recursive\n+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n+\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AS = @AS@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = \n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBSTDCXX_RAW_CXX_CXXFLAGS = @LIBSTDCXX_RAW_CXX_CXXFLAGS@\n+LIBSTDCXX_RAW_CXX_LDFLAGS = @LIBSTDCXX_RAW_CXX_LDFLAGS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+libvtv_builddir = @libvtv_builddir@\n+libvtv_srcdir = @libvtv_srcdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_noncanonical = @target_noncanonical@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+toplevel_builddir = @toplevel_builddir@\n+toplevel_srcdir = @toplevel_srcdir@\n+SUBDIRS = testsuite\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+AM_CPPFLAGS = -I$(top_srcdir)/../include\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_CXXFLAGS = $(XCFLAGS) $(LIBSTDCXX_RAW_CXX_CXXFLAGS) \\\n+\t-Wl,-u_vtable_map_vars_start,-u_vtable_map_vars_end\n+toolexeclib_LTLIBRARIES = libvtv.la\n+vtv_headers = \\\n+\tvtv_map.h \\\n+\tvtv_malloc.h \\\n+\tvtv_fail.h \\\n+\tvtv_set.h \\\n+\tvtv_utils.h \\\n+\tvtv_rts.h\n+\n+vtv_sources = \\\n+\tvtv_start.c \\\n+        vtv_malloc.cc \\\n+        vtv_rts.cc \\\n+        vtv_utils.cc \\\n+\tvtv_end.c\n+\n+libvtv_includedir = $(includedir)\n+\n+# Link in vtv_start and vtv_end. \n+BUILT_SOURCES = vtv_start.c vtv_end.c\n+@ENABLE_VTABLE_VERIFY_FALSE@libvtv_la_SOURCES = \n+@ENABLE_VTABLE_VERIFY_TRUE@libvtv_la_SOURCES = $(vtv_sources)\n+@ENABLE_VTABLE_VERIFY_FALSE@libvtv_include_HEADERS = \n+@ENABLE_VTABLE_VERIFY_TRUE@libvtv_include_HEADERS = $(vtv_headers)\n+\n+# Least ordering for dependencies mean linking w/o libstdc++ for as\n+# long as the development of libvtv does not absolutely require it.\n+CXXVTV = $(CC_FOR_TARGET)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXXVTV) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXVTV) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+\n+all: $(BUILT_SOURCES)\n+\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .cc .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign ./Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign ./Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libvtv.la: $(libvtv_la_OBJECTS) $(libvtv_la_DEPENDENCIES) \n+\t$(CXXLINK) -rpath $(toolexeclibdir) $(libvtv_la_OBJECTS) $(libvtv_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vtv_end.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vtv_malloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vtv_rts.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vtv_start.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vtv_utils.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+install-libvtv_includeHEADERS: $(libvtv_include_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(libvtv_includedir)\" || $(MKDIR_P) \"$(DESTDIR)$(libvtv_includedir)\"\n+\t@list='$(libvtv_include_HEADERS)'; test -n \"$(libvtv_includedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(libvtv_includedir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(libvtv_includedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-libvtv_includeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(libvtv_include_HEADERS)'; test -n \"$(libvtv_includedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(libvtv_includedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(libvtv_includedir)\" && rm -f $$files\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+$(RECURSIVE_CLEAN_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: $(BUILT_SOURCES)\n+\t$(MAKE) $(AM_MAKEFLAGS) check-recursive\n+all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS)\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(libvtv_includedir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: $(BUILT_SOURCES)\n+\t$(MAKE) $(AM_MAKEFLAGS) install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\t-test -z \"$(BUILT_SOURCES)\" || rm -f $(BUILT_SOURCES)\n+clean: clean-multi clean-recursive\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-multi distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-libtool distclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am:\n+\n+html: html-recursive\n+\n+html-am:\n+\n+info: info-recursive\n+\n+info-am:\n+\n+install-data-am: install-libvtv_includeHEADERS\n+\n+install-dvi: install-dvi-recursive\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-recursive\n+\n+install-html-am:\n+\n+install-info: install-info-recursive\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-recursive\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-recursive\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-multi mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am:\n+\n+ps: ps-recursive\n+\n+ps-am:\n+\n+uninstall-am: uninstall-libvtv_includeHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n+\tcheck clean-multi ctags-recursive distclean-multi install \\\n+\tinstall-am install-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi tags-recursive\n+\n+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n+\tall all-am all-multi am--refresh check check-am clean \\\n+\tclean-generic clean-libtool clean-multi \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-multi distclean-tags dvi dvi-am html html-am info \\\n+\tinfo-am install install-am install-data install-data-am \\\n+\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n+\tinstall-html install-html-am install-info install-info-am \\\n+\tinstall-libvtv_includeHEADERS install-man install-multi \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs installdirs-am maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n+\tuninstall uninstall-am uninstall-libvtv_includeHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+vtv_start.c:\n+\trm -f $@\n+\t$(LN_S) $(toplevel_srcdir)/libgcc/vtv_start.c $@\n+\n+vtv_end.c:\n+\trm -f $@\n+\t$(LN_S) $(toplevel_srcdir)/libgcc/vtv_end.c $@\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "6faca986edd9a06dc2be0db0164c1dffd639e14e", "filename": "libvtv/acinclude.m4", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Facinclude.m4?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,58 @@\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libgfortran.\n+\n+sinclude(../libtool.m4)\n+dnl The lines below arrange for aclocal not to bring an installed\n+dnl libtool.m4 into aclocal.m4, while still arranging for automake to\n+dnl add a definition of LIBTOOL to Makefile.in.\n+ifelse(,,,[AC_SUBST(LIBTOOL)\n+AC_DEFUN([AM_PROG_LIBTOOL])\n+])\n+\n+\n+\n+dnl\n+dnl Initialize the rest of the library configury.  At this point we have\n+dnl variables like $host.\n+dnl\n+dnl Substs:\n+dnl  libvtv_builddir     (absolute path)\n+dnl  libvtv_srcdir       (absolute path)\n+dnl  toplevel_builddir    (absolute path)\n+dnl  toplevel_srcdir      (absolute path)\n+dnl  with_cross_host\n+dnl  with_newlib\n+dnl  with_target_subdir\n+dnl plus\n+dnl  - the variables in LIBVTV_CHECK_HOST / configure.host\n+dnl  - default settings for all AM_CONDITIONAL test variables\n+dnl  - lots of tools, like CC and CXX\n+dnl\n+AC_DEFUN([LIBVTV_CONFIGURE], [\n+\n+  # Use same top-level configure hooks in libgcc/libstdc++/libvtv.\n+  AC_ARG_ENABLE(vtable-verify,\n+  [  --enable-vtable-verify    Enable vtable verification feature ],\n+  [case \"$enableval\" in\n+   yes) enable_vtable_verify=yes ;;\n+   no)  enable_vtable_verify=no ;;\n+   *)   enable_vtable_verify=no;;\n+   esac],\n+  [enable_vtable_verify=no])\n+  AM_CONDITIONAL(ENABLE_VTABLE_VERIFY, test $enable_vtable_verify = yes)\n+\n+  # These need to be absolute paths, yet at the same time need to\n+  # canonicalize only relative paths, because then amd will not unmount\n+  # drives. Thus the use of PWDCMD: set it to 'pawd' or 'amq -w' if using amd.\n+  libvtv_builddir=`${PWDCMD-pwd}`\n+  case $srcdir in\n+    [\\\\/$]* | ?:[\\\\/]*) libvtv_srcdir=${srcdir} ;;\n+    *) libvtv_srcdir=`cd \"$srcdir\" && ${PWDCMD-pwd} || echo \"$srcdir\"` ;;\n+  esac\n+  toplevel_builddir=${libvtv_builddir}/..\n+  toplevel_srcdir=${libvtv_srcdir}/..\n+  AC_SUBST(libvtv_builddir)\n+  AC_SUBST(libvtv_srcdir)\n+  AC_SUBST(toplevel_builddir)\n+  AC_SUBST(toplevel_srcdir)\n+])"}, {"sha": "5478f2b7df72f883e6cfb160070ccfced2beede7", "filename": "libvtv/aclocal.m4", "status": "added", "additions": 1016, "deletions": 0, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Faclocal.m4?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,1016 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_PROG_CC_C_O\n+# --------------\n+# Like AC_PROG_CC_C_O, but changed for automake.\n+AC_DEFUN([AM_PROG_CC_C_O],\n+[AC_REQUIRE([AC_PROG_CC_C_O])dnl\n+AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([compile])dnl\n+# FIXME: we rely on the cache variable name because\n+# there is no other way.\n+set dummy $CC\n+am_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`\n+eval am_t=\\$ac_cv_prog_cc_${am_cc}_c_o\n+if test \"$am_t\" != yes; then\n+   # Losing compiler, so override with the script.\n+   # FIXME: It is wrong to rewrite CC.\n+   # But if we don't then we get into trouble of one sort or another.\n+   # A longer-term fix would be to have automake use am__CC in this case,\n+   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n+   CC=\"$am_aux_dir/compile $CC\"\n+fi\n+dnl Make sure AC_PROG_CC is never called again, or it will override our\n+dnl setting of CC.\n+m4_define([AC_PROG_CC],\n+          [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/acx.m4])\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/libstdc++-raw-cxx.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])\n+m4_include([acinclude.m4])"}, {"sha": "c905b447f50157794c84f01c766790c5d3f86715", "filename": "libvtv/autom4te.cache/output.0", "status": "added", "additions": 17164, "deletions": 0, "changes": 17164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Foutput.0", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Foutput.0", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fautom4te.cache%2Foutput.0?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b"}, {"sha": "a38386c4f367733ab1e6785e35eaf1f3541c6eb7", "filename": "libvtv/autom4te.cache/requests", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Frequests", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Frequests", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fautom4te.cache%2Frequests?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,68 @@\n+# This file was generated.\n+# It contains the lists of macros which have been traced.\n+# It can be safely removed.\n+\n+@request = (\n+             bless( [\n+                      '0',\n+                      1,\n+                      [\n+                        '/usr/local/share/autoconf'\n+                      ],\n+                      [\n+                        '/usr/local/share/autoconf/autoconf/autoconf.m4f',\n+                        'aclocal.m4',\n+                        'configure.ac'\n+                      ],\n+                      {\n+                        'AM_PROG_F77_C_O' => 1,\n+                        '_LT_AC_TAGCONFIG' => 1,\n+                        'm4_pattern_forbid' => 1,\n+                        'AC_INIT' => 1,\n+                        'AC_CANONICAL_TARGET' => 1,\n+                        '_AM_COND_IF' => 1,\n+                        'AC_CONFIG_LIBOBJ_DIR' => 1,\n+                        'AC_SUBST' => 1,\n+                        'AC_CANONICAL_HOST' => 1,\n+                        'AC_FC_SRCEXT' => 1,\n+                        'AC_PROG_LIBTOOL' => 1,\n+                        'AM_INIT_AUTOMAKE' => 1,\n+                        'AC_CONFIG_SUBDIRS' => 1,\n+                        'AM_AUTOMAKE_VERSION' => 1,\n+                        'LT_CONFIG_LTDL_DIR' => 1,\n+                        'AC_CONFIG_LINKS' => 1,\n+                        'AC_REQUIRE_AUX_FILE' => 1,\n+                        'LT_SUPPORTED_TAG' => 1,\n+                        'm4_sinclude' => 1,\n+                        'AM_MAINTAINER_MODE' => 1,\n+                        'AM_GNU_GETTEXT_INTL_SUBDIR' => 1,\n+                        '_m4_warn' => 1,\n+                        'AM_PROG_CXX_C_O' => 1,\n+                        '_AM_COND_ENDIF' => 1,\n+                        'AM_ENABLE_MULTILIB' => 1,\n+                        'AM_SILENT_RULES' => 1,\n+                        'AC_CONFIG_FILES' => 1,\n+                        'include' => 1,\n+                        'LT_INIT' => 1,\n+                        'AM_GNU_GETTEXT' => 1,\n+                        'AC_LIBSOURCE' => 1,\n+                        'AC_CANONICAL_BUILD' => 1,\n+                        'AM_PROG_FC_C_O' => 1,\n+                        'AC_FC_FREEFORM' => 1,\n+                        'AH_OUTPUT' => 1,\n+                        'AC_CONFIG_AUX_DIR' => 1,\n+                        '_AM_SUBST_NOTMAKE' => 1,\n+                        'AM_PROG_CC_C_O' => 1,\n+                        'm4_pattern_allow' => 1,\n+                        'sinclude' => 1,\n+                        'AM_CONDITIONAL' => 1,\n+                        'AC_CANONICAL_SYSTEM' => 1,\n+                        'AC_CONFIG_HEADERS' => 1,\n+                        'AC_DEFINE_TRACE_LITERAL' => 1,\n+                        'm4_include' => 1,\n+                        '_AM_COND_ELSE' => 1,\n+                        'AC_SUBST_TRACE' => 1\n+                      }\n+                    ], 'Autom4te::Request' )\n+           );\n+"}, {"sha": "8b13c0cdd380a2378e73055a84dd26c52bc119ba", "filename": "libvtv/autom4te.cache/traces.0", "status": "added", "additions": 680, "deletions": 0, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Ftraces.0", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fautom4te.cache%2Ftraces.0", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fautom4te.cache%2Ftraces.0?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,680 @@\n+m4trace:aclocal.m4:1006: -1- m4_include([../config/acx.m4])\n+m4trace:aclocal.m4:1007: -1- m4_include([../config/depstand.m4])\n+m4trace:aclocal.m4:1008: -1- m4_include([../config/lead-dot.m4])\n+m4trace:aclocal.m4:1009: -1- m4_include([../config/libstdc++-raw-cxx.m4])\n+m4trace:aclocal.m4:1010: -1- m4_include([../config/multi.m4])\n+m4trace:aclocal.m4:1011: -1- m4_include([../config/override.m4])\n+m4trace:aclocal.m4:1012: -1- m4_include([../ltoptions.m4])\n+m4trace:aclocal.m4:1013: -1- m4_include([../ltsugar.m4])\n+m4trace:aclocal.m4:1014: -1- m4_include([../ltversion.m4])\n+m4trace:aclocal.m4:1015: -1- m4_include([../lt~obsolete.m4])\n+m4trace:aclocal.m4:1016: -1- m4_include([acinclude.m4])\n+m4trace:acinclude.m4:4: -1- sinclude([../libtool.m4])\n+m4trace:configure.ac:5: -1- AC_INIT([GNU Vtable Verification Runtime Library], [1.0], [], [libvtv])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([^_?A[CHUM]_])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([_AC_])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([^LIBOBJS$], [do not use LIBOBJS directly, use AC_LIBOBJ (see section `AC_LIBOBJ vs LIBOBJS'])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^AS_FLAGS$])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([^_?m4_])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([^dnl$])\n+m4trace:configure.ac:5: -1- m4_pattern_forbid([^_?AS_])\n+m4trace:configure.ac:5: -1- AC_SUBST([SHELL])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([SHELL])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^SHELL$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PATH_SEPARATOR])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PATH_SEPARATOR])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PATH_SEPARATOR$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_NAME], [m4_ifdef([AC_PACKAGE_NAME],      ['AC_PACKAGE_NAME'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_NAME])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_NAME$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_TARNAME], [m4_ifdef([AC_PACKAGE_TARNAME],   ['AC_PACKAGE_TARNAME'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_TARNAME])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_TARNAME$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_VERSION], [m4_ifdef([AC_PACKAGE_VERSION],   ['AC_PACKAGE_VERSION'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_VERSION])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_VERSION$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_STRING], [m4_ifdef([AC_PACKAGE_STRING],    ['AC_PACKAGE_STRING'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_STRING])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_STRING$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_BUGREPORT], [m4_ifdef([AC_PACKAGE_BUGREPORT], ['AC_PACKAGE_BUGREPORT'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_BUGREPORT])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])\n+m4trace:configure.ac:5: -1- AC_SUBST([PACKAGE_URL], [m4_ifdef([AC_PACKAGE_URL],       ['AC_PACKAGE_URL'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([PACKAGE_URL])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_URL$])\n+m4trace:configure.ac:5: -1- AC_SUBST([exec_prefix], [NONE])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([exec_prefix])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^exec_prefix$])\n+m4trace:configure.ac:5: -1- AC_SUBST([prefix], [NONE])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([prefix])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^prefix$])\n+m4trace:configure.ac:5: -1- AC_SUBST([program_transform_name], [s,x,x,])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([program_transform_name])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^program_transform_name$])\n+m4trace:configure.ac:5: -1- AC_SUBST([bindir], ['${exec_prefix}/bin'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([bindir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^bindir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([sbindir], ['${exec_prefix}/sbin'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([sbindir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^sbindir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([libexecdir], ['${exec_prefix}/libexec'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([libexecdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^libexecdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([datarootdir], ['${prefix}/share'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([datarootdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^datarootdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([datadir], ['${datarootdir}'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([datadir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^datadir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([sysconfdir], ['${prefix}/etc'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([sysconfdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^sysconfdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([sharedstatedir], ['${prefix}/com'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([sharedstatedir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^sharedstatedir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([localstatedir], ['${prefix}/var'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([localstatedir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^localstatedir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([includedir], ['${prefix}/include'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([includedir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^includedir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([oldincludedir], ['/usr/include'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([oldincludedir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^oldincludedir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([docdir], [m4_ifset([AC_PACKAGE_TARNAME],\n+\t\t\t\t     ['${datarootdir}/doc/${PACKAGE_TARNAME}'],\n+\t\t\t\t     ['${datarootdir}/doc/${PACKAGE}'])])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([docdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^docdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([infodir], ['${datarootdir}/info'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([infodir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^infodir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([htmldir], ['${docdir}'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([htmldir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^htmldir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([dvidir], ['${docdir}'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([dvidir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^dvidir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([pdfdir], ['${docdir}'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([pdfdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^pdfdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([psdir], ['${docdir}'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([psdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^psdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([libdir], ['${exec_prefix}/lib'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([libdir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^libdir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([localedir], ['${datarootdir}/locale'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([localedir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^localedir$])\n+m4trace:configure.ac:5: -1- AC_SUBST([mandir], ['${datarootdir}/man'])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([mandir])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^mandir$])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_NAME])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_NAME$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_NAME], [/* Define to the full name of this package. */\n+@%:@undef PACKAGE_NAME])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_TARNAME])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_TARNAME$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_TARNAME], [/* Define to the one symbol short name of this package. */\n+@%:@undef PACKAGE_TARNAME])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_VERSION])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_VERSION$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_VERSION], [/* Define to the version of this package. */\n+@%:@undef PACKAGE_VERSION])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_STRING])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_STRING$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_STRING], [/* Define to the full name and version of this package. */\n+@%:@undef PACKAGE_STRING])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_BUGREPORT])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_BUGREPORT$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_BUGREPORT], [/* Define to the address where bug reports for this package should be sent. */\n+@%:@undef PACKAGE_BUGREPORT])\n+m4trace:configure.ac:5: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE_URL])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^PACKAGE_URL$])\n+m4trace:configure.ac:5: -1- AH_OUTPUT([PACKAGE_URL], [/* Define to the home page for this package. */\n+@%:@undef PACKAGE_URL])\n+m4trace:configure.ac:5: -1- AC_SUBST([DEFS])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([DEFS])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^DEFS$])\n+m4trace:configure.ac:5: -1- AC_SUBST([ECHO_C])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([ECHO_C])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^ECHO_C$])\n+m4trace:configure.ac:5: -1- AC_SUBST([ECHO_N])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([ECHO_N])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^ECHO_N$])\n+m4trace:configure.ac:5: -1- AC_SUBST([ECHO_T])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([ECHO_T])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^ECHO_T$])\n+m4trace:configure.ac:5: -1- AC_SUBST([LIBS])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([LIBS])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^LIBS$])\n+m4trace:configure.ac:5: -1- AC_SUBST([build_alias])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([build_alias])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^build_alias$])\n+m4trace:configure.ac:5: -1- AC_SUBST([host_alias])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([host_alias])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^host_alias$])\n+m4trace:configure.ac:5: -1- AC_SUBST([target_alias])\n+m4trace:configure.ac:5: -1- AC_SUBST_TRACE([target_alias])\n+m4trace:configure.ac:5: -1- m4_pattern_allow([^target_alias$])\n+m4trace:configure.ac:25: -1- AC_CANONICAL_SYSTEM\n+m4trace:configure.ac:25: -1- _m4_warn([obsolete], [The macro `AC_CANONICAL_SYSTEM' is obsolete.\n+You should run autoupdate.], [../../lib/autoconf/general.m4:1863: AC_CANONICAL_SYSTEM is expanded from...\n+configure.ac:25: the top level])\n+m4trace:configure.ac:25: -1- AC_CANONICAL_TARGET\n+m4trace:configure.ac:25: -1- AC_CANONICAL_HOST\n+m4trace:configure.ac:25: -1- AC_CANONICAL_BUILD\n+m4trace:configure.ac:25: -1- AC_REQUIRE_AUX_FILE([config.sub])\n+m4trace:configure.ac:25: -1- AC_REQUIRE_AUX_FILE([config.guess])\n+m4trace:configure.ac:25: -1- AC_SUBST([build], [$ac_cv_build])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^build$])\n+m4trace:configure.ac:25: -1- AC_SUBST([build_cpu], [$[1]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_cpu])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^build_cpu$])\n+m4trace:configure.ac:25: -1- AC_SUBST([build_vendor], [$[2]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_vendor])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^build_vendor$])\n+m4trace:configure.ac:25: -1- AC_SUBST([build_os])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([build_os])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^build_os$])\n+m4trace:configure.ac:25: -1- AC_SUBST([host], [$ac_cv_host])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^host$])\n+m4trace:configure.ac:25: -1- AC_SUBST([host_cpu], [$[1]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_cpu])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^host_cpu$])\n+m4trace:configure.ac:25: -1- AC_SUBST([host_vendor], [$[2]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_vendor])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^host_vendor$])\n+m4trace:configure.ac:25: -1- AC_SUBST([host_os])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([host_os])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^host_os$])\n+m4trace:configure.ac:25: -1- AC_SUBST([target], [$ac_cv_target])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^target$])\n+m4trace:configure.ac:25: -1- AC_SUBST([target_cpu], [$[1]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_cpu])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^target_cpu$])\n+m4trace:configure.ac:25: -1- AC_SUBST([target_vendor], [$[2]])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_vendor])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^target_vendor$])\n+m4trace:configure.ac:25: -1- AC_SUBST([target_os])\n+m4trace:configure.ac:25: -1- AC_SUBST_TRACE([target_os])\n+m4trace:configure.ac:25: -1- m4_pattern_allow([^target_os$])\n+m4trace:configure.ac:27: -1- AC_SUBST([target_alias])\n+m4trace:configure.ac:27: -1- AC_SUBST_TRACE([target_alias])\n+m4trace:configure.ac:27: -1- m4_pattern_allow([^target_alias$])\n+m4trace:configure.ac:28: -1- AC_SUBST([target_noncanonical])\n+m4trace:configure.ac:28: -1- AC_SUBST_TRACE([target_noncanonical])\n+m4trace:configure.ac:28: -1- m4_pattern_allow([^target_noncanonical$])\n+m4trace:configure.ac:28: -1- AC_SUBST([LIBSTDCXX_RAW_CXX_CXXFLAGS])\n+m4trace:configure.ac:28: -1- AC_SUBST_TRACE([LIBSTDCXX_RAW_CXX_CXXFLAGS])\n+m4trace:configure.ac:28: -1- m4_pattern_allow([^LIBSTDCXX_RAW_CXX_CXXFLAGS$])\n+m4trace:configure.ac:28: -1- AC_SUBST([LIBSTDCXX_RAW_CXX_LDFLAGS])\n+m4trace:configure.ac:28: -1- AC_SUBST_TRACE([LIBSTDCXX_RAW_CXX_LDFLAGS])\n+m4trace:configure.ac:28: -1- m4_pattern_allow([^LIBSTDCXX_RAW_CXX_LDFLAGS$])\n+m4trace:configure.ac:30: -1- AM_INIT_AUTOMAKE([foreign no-dist])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AM_[A-Z]+FLAGS$])\n+m4trace:configure.ac:30: -1- AM_AUTOMAKE_VERSION([1.11.1])\n+m4trace:configure.ac:30: -1- AC_REQUIRE_AUX_FILE([install-sh])\n+m4trace:configure.ac:30: -1- AC_SUBST([INSTALL_PROGRAM])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([INSTALL_PROGRAM])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^INSTALL_PROGRAM$])\n+m4trace:configure.ac:30: -1- AC_SUBST([INSTALL_SCRIPT])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([INSTALL_SCRIPT])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^INSTALL_SCRIPT$])\n+m4trace:configure.ac:30: -1- AC_SUBST([INSTALL_DATA])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([INSTALL_DATA])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^INSTALL_DATA$])\n+m4trace:configure.ac:30: -1- AC_SUBST([am__isrc], [' -I$(srcdir)'])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([am__isrc])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^am__isrc$])\n+m4trace:configure.ac:30: -1- _AM_SUBST_NOTMAKE([am__isrc])\n+m4trace:configure.ac:30: -1- AC_SUBST([CYGPATH_W])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([CYGPATH_W])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^CYGPATH_W$])\n+m4trace:configure.ac:30: -1- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([PACKAGE])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^PACKAGE$])\n+m4trace:configure.ac:30: -1- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([VERSION])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^VERSION$])\n+m4trace:configure.ac:30: -1- AC_DEFINE_TRACE_LITERAL([PACKAGE])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^PACKAGE$])\n+m4trace:configure.ac:30: -1- AH_OUTPUT([PACKAGE], [/* Name of package */\n+@%:@undef PACKAGE])\n+m4trace:configure.ac:30: -1- AC_DEFINE_TRACE_LITERAL([VERSION])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^VERSION$])\n+m4trace:configure.ac:30: -1- AH_OUTPUT([VERSION], [/* Version number of package */\n+@%:@undef VERSION])\n+m4trace:configure.ac:30: -1- AC_REQUIRE_AUX_FILE([missing])\n+m4trace:configure.ac:30: -1- AC_SUBST([ACLOCAL])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([ACLOCAL])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^ACLOCAL$])\n+m4trace:configure.ac:30: -1- AC_SUBST([AUTOCONF])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([AUTOCONF])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AUTOCONF$])\n+m4trace:configure.ac:30: -1- AC_SUBST([AUTOMAKE])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([AUTOMAKE])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AUTOMAKE$])\n+m4trace:configure.ac:30: -1- AC_SUBST([AUTOHEADER])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([AUTOHEADER])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AUTOHEADER$])\n+m4trace:configure.ac:30: -1- AC_SUBST([MAKEINFO])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([MAKEINFO])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^MAKEINFO$])\n+m4trace:configure.ac:30: -1- AC_SUBST([install_sh])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([install_sh])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^install_sh$])\n+m4trace:configure.ac:30: -1- AC_SUBST([STRIP])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([STRIP])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^STRIP$])\n+m4trace:configure.ac:30: -1- AC_SUBST([INSTALL_STRIP_PROGRAM])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([INSTALL_STRIP_PROGRAM])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^INSTALL_STRIP_PROGRAM$])\n+m4trace:configure.ac:30: -1- AC_REQUIRE_AUX_FILE([install-sh])\n+m4trace:configure.ac:30: -1- AC_SUBST([MKDIR_P])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([MKDIR_P])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^MKDIR_P$])\n+m4trace:configure.ac:30: -1- AC_SUBST([mkdir_p], [\"$MKDIR_P\"])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([mkdir_p])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^mkdir_p$])\n+m4trace:configure.ac:30: -1- AC_SUBST([AWK])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([AWK])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AWK$])\n+m4trace:configure.ac:30: -1- AC_SUBST([SET_MAKE])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([SET_MAKE])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^SET_MAKE$])\n+m4trace:configure.ac:30: -1- AC_SUBST([am__leading_dot])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([am__leading_dot])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^am__leading_dot$])\n+m4trace:configure.ac:30: -1- AC_SUBST([AMTAR])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([AMTAR])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^AMTAR$])\n+m4trace:configure.ac:30: -1- AC_SUBST([am__tar])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([am__tar])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^am__tar$])\n+m4trace:configure.ac:30: -1- AC_SUBST([am__untar])\n+m4trace:configure.ac:30: -1- AC_SUBST_TRACE([am__untar])\n+m4trace:configure.ac:30: -1- m4_pattern_allow([^am__untar$])\n+m4trace:configure.ac:31: -1- AM_ENABLE_MULTILIB([], [..])\n+m4trace:configure.ac:31: -1- AC_SUBST([multi_basedir])\n+m4trace:configure.ac:31: -1- AC_SUBST_TRACE([multi_basedir])\n+m4trace:configure.ac:31: -1- m4_pattern_allow([^multi_basedir$])\n+m4trace:configure.ac:31: -1- _m4_warn([obsolete], [The macro `AC_OUTPUT_COMMANDS' is obsolete.\n+You should run autoupdate.], [../../lib/autoconf/status.m4:1040: AC_OUTPUT_COMMANDS is expanded from...\n+../config/multi.m4:14: AM_ENABLE_MULTILIB is expanded from...\n+configure.ac:31: the top level])\n+m4trace:configure.ac:32: -1- AM_MAINTAINER_MODE\n+m4trace:configure.ac:32: -1- AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+m4trace:configure.ac:32: -1- AC_SUBST([MAINTAINER_MODE_TRUE])\n+m4trace:configure.ac:32: -1- AC_SUBST_TRACE([MAINTAINER_MODE_TRUE])\n+m4trace:configure.ac:32: -1- m4_pattern_allow([^MAINTAINER_MODE_TRUE$])\n+m4trace:configure.ac:32: -1- AC_SUBST([MAINTAINER_MODE_FALSE])\n+m4trace:configure.ac:32: -1- AC_SUBST_TRACE([MAINTAINER_MODE_FALSE])\n+m4trace:configure.ac:32: -1- m4_pattern_allow([^MAINTAINER_MODE_FALSE$])\n+m4trace:configure.ac:32: -1- _AM_SUBST_NOTMAKE([MAINTAINER_MODE_TRUE])\n+m4trace:configure.ac:32: -1- _AM_SUBST_NOTMAKE([MAINTAINER_MODE_FALSE])\n+m4trace:configure.ac:32: -1- AC_SUBST([MAINT])\n+m4trace:configure.ac:32: -1- AC_SUBST_TRACE([MAINT])\n+m4trace:configure.ac:32: -1- m4_pattern_allow([^MAINT$])\n+m4trace:configure.ac:61: -1- AC_SUBST([toolexecdir])\n+m4trace:configure.ac:61: -1- AC_SUBST_TRACE([toolexecdir])\n+m4trace:configure.ac:61: -1- m4_pattern_allow([^toolexecdir$])\n+m4trace:configure.ac:62: -1- AC_SUBST([toolexeclibdir])\n+m4trace:configure.ac:62: -1- AC_SUBST_TRACE([toolexeclibdir])\n+m4trace:configure.ac:62: -1- m4_pattern_allow([^toolexeclibdir$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CFLAGS])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CFLAGS])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CFLAGS$])\n+m4trace:configure.ac:67: -1- AC_SUBST([LDFLAGS])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([LDFLAGS])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^LDFLAGS$])\n+m4trace:configure.ac:67: -1- AC_SUBST([LIBS])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([LIBS])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^LIBS$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CPPFLAGS])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CPPFLAGS])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CPPFLAGS$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([ac_ct_CC])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([ac_ct_CC])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^ac_ct_CC$])\n+m4trace:configure.ac:67: -1- AC_SUBST([EXEEXT], [$ac_cv_exeext])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([EXEEXT])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^EXEEXT$])\n+m4trace:configure.ac:67: -1- AC_SUBST([OBJEXT], [$ac_cv_objext])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([OBJEXT])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^OBJEXT$])\n+m4trace:configure.ac:67: -1- AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([DEPDIR])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^DEPDIR$])\n+m4trace:configure.ac:67: -1- AC_SUBST([am__include])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([am__include])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^am__include$])\n+m4trace:configure.ac:67: -1- AC_SUBST([am__quote])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([am__quote])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^am__quote$])\n+m4trace:configure.ac:67: -1- AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+m4trace:configure.ac:67: -1- AC_SUBST([AMDEP_TRUE])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([AMDEP_TRUE])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^AMDEP_TRUE$])\n+m4trace:configure.ac:67: -1- AC_SUBST([AMDEP_FALSE])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([AMDEP_FALSE])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^AMDEP_FALSE$])\n+m4trace:configure.ac:67: -1- _AM_SUBST_NOTMAKE([AMDEP_TRUE])\n+m4trace:configure.ac:67: -1- _AM_SUBST_NOTMAKE([AMDEP_FALSE])\n+m4trace:configure.ac:67: -1- AC_SUBST([AMDEPBACKSLASH])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([AMDEPBACKSLASH])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^AMDEPBACKSLASH$])\n+m4trace:configure.ac:67: -1- _AM_SUBST_NOTMAKE([AMDEPBACKSLASH])\n+m4trace:configure.ac:67: -1- AC_SUBST([CCDEPMODE], [depmode=$am_cv_CC_dependencies_compiler_type])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([CCDEPMODE])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^CCDEPMODE$])\n+m4trace:configure.ac:67: -1- AM_CONDITIONAL([am__fastdepCC], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_CC_dependencies_compiler_type\" = gcc3])\n+m4trace:configure.ac:67: -1- AC_SUBST([am__fastdepCC_TRUE])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([am__fastdepCC_TRUE])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^am__fastdepCC_TRUE$])\n+m4trace:configure.ac:67: -1- AC_SUBST([am__fastdepCC_FALSE])\n+m4trace:configure.ac:67: -1- AC_SUBST_TRACE([am__fastdepCC_FALSE])\n+m4trace:configure.ac:67: -1- m4_pattern_allow([^am__fastdepCC_FALSE$])\n+m4trace:configure.ac:67: -1- _AM_SUBST_NOTMAKE([am__fastdepCC_TRUE])\n+m4trace:configure.ac:67: -1- _AM_SUBST_NOTMAKE([am__fastdepCC_FALSE])\n+m4trace:configure.ac:68: -1- AC_SUBST([CXX])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([CXX])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^CXX$])\n+m4trace:configure.ac:68: -1- AC_SUBST([CXXFLAGS])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([CXXFLAGS])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^CXXFLAGS$])\n+m4trace:configure.ac:68: -1- AC_SUBST([LDFLAGS])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([LDFLAGS])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^LDFLAGS$])\n+m4trace:configure.ac:68: -1- AC_SUBST([LIBS])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([LIBS])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^LIBS$])\n+m4trace:configure.ac:68: -1- AC_SUBST([CPPFLAGS])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([CPPFLAGS])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^CPPFLAGS$])\n+m4trace:configure.ac:68: -1- AC_SUBST([CXX])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([CXX])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^CXX$])\n+m4trace:configure.ac:68: -1- AC_SUBST([ac_ct_CXX])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([ac_ct_CXX])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^ac_ct_CXX$])\n+m4trace:configure.ac:68: -1- AC_SUBST([CXXDEPMODE], [depmode=$am_cv_CXX_dependencies_compiler_type])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([CXXDEPMODE])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^CXXDEPMODE$])\n+m4trace:configure.ac:68: -1- AM_CONDITIONAL([am__fastdepCXX], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_CXX_dependencies_compiler_type\" = gcc3])\n+m4trace:configure.ac:68: -1- AC_SUBST([am__fastdepCXX_TRUE])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([am__fastdepCXX_TRUE])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^am__fastdepCXX_TRUE$])\n+m4trace:configure.ac:68: -1- AC_SUBST([am__fastdepCXX_FALSE])\n+m4trace:configure.ac:68: -1- AC_SUBST_TRACE([am__fastdepCXX_FALSE])\n+m4trace:configure.ac:68: -1- m4_pattern_allow([^am__fastdepCXX_FALSE$])\n+m4trace:configure.ac:68: -1- _AM_SUBST_NOTMAKE([am__fastdepCXX_TRUE])\n+m4trace:configure.ac:68: -1- _AM_SUBST_NOTMAKE([am__fastdepCXX_FALSE])\n+m4trace:configure.ac:71: -1- AM_PROG_CC_C_O\n+m4trace:configure.ac:71: -1- AC_DEFINE_TRACE_LITERAL([NO_MINUS_C_MINUS_O])\n+m4trace:configure.ac:71: -1- m4_pattern_allow([^NO_MINUS_C_MINUS_O$])\n+m4trace:configure.ac:71: -1- AH_OUTPUT([NO_MINUS_C_MINUS_O], [/* Define to 1 if your C compiler doesn\\'t accept -c and -o together. */\n+@%:@undef NO_MINUS_C_MINUS_O])\n+m4trace:configure.ac:71: -1- AC_REQUIRE_AUX_FILE([compile])\n+m4trace:configure.ac:73: -1- AC_SUBST([CFLAGS])\n+m4trace:configure.ac:73: -1- AC_SUBST_TRACE([CFLAGS])\n+m4trace:configure.ac:73: -1- m4_pattern_allow([^CFLAGS$])\n+m4trace:configure.ac:74: -1- AC_SUBST([CXXFLAGS])\n+m4trace:configure.ac:74: -1- AC_SUBST_TRACE([CXXFLAGS])\n+m4trace:configure.ac:74: -1- m4_pattern_allow([^CXXFLAGS$])\n+m4trace:configure.ac:79: -1- AC_SUBST([CCAS])\n+m4trace:configure.ac:79: -1- AC_SUBST_TRACE([CCAS])\n+m4trace:configure.ac:79: -1- m4_pattern_allow([^CCAS$])\n+m4trace:configure.ac:80: -1- AC_SUBST([CCASFLAGS])\n+m4trace:configure.ac:80: -1- AC_SUBST_TRACE([CCASFLAGS])\n+m4trace:configure.ac:80: -1- m4_pattern_allow([^CCASFLAGS$])\n+m4trace:configure.ac:82: -1- AC_SUBST([AS])\n+m4trace:configure.ac:82: -1- AC_SUBST_TRACE([AS])\n+m4trace:configure.ac:82: -1- m4_pattern_allow([^AS$])\n+m4trace:configure.ac:83: -1- AC_SUBST([AR])\n+m4trace:configure.ac:83: -1- AC_SUBST_TRACE([AR])\n+m4trace:configure.ac:83: -1- m4_pattern_allow([^AR$])\n+m4trace:configure.ac:84: -1- AC_SUBST([RANLIB])\n+m4trace:configure.ac:84: -1- AC_SUBST_TRACE([RANLIB])\n+m4trace:configure.ac:84: -1- m4_pattern_allow([^RANLIB$])\n+m4trace:configure.ac:87: -1- _m4_warn([obsolete], [The macro `AC_LIBTOOL_DLOPEN' is obsolete.\n+You should run autoupdate.], [../ltoptions.m4:111: AC_LIBTOOL_DLOPEN is expanded from...\n+configure.ac:87: the top level])\n+m4trace:configure.ac:87: -1- _m4_warn([obsolete], [AC_LIBTOOL_DLOPEN: Remove this warning and the call to _LT_SET_OPTION when you\n+put the `dlopen' option into LT_INIT's first parameter.], [../ltoptions.m4:111: AC_LIBTOOL_DLOPEN is expanded from...\n+configure.ac:87: the top level])\n+m4trace:configure.ac:88: -1- _m4_warn([obsolete], [The macro `AM_PROG_LIBTOOL' is obsolete.\n+You should run autoupdate.], [../libtool.m4:106: AM_PROG_LIBTOOL is expanded from...\n+configure.ac:88: the top level])\n+m4trace:configure.ac:88: -1- LT_INIT\n+m4trace:configure.ac:88: -1- m4_pattern_forbid([^_?LT_[A-Z_]+$])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])\n+m4trace:configure.ac:88: -1- AC_REQUIRE_AUX_FILE([ltmain.sh])\n+m4trace:configure.ac:88: -1- AC_SUBST([LIBTOOL])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([LIBTOOL])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LIBTOOL$])\n+m4trace:configure.ac:88: -1- AC_SUBST([SED])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([SED])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^SED$])\n+m4trace:configure.ac:88: -1- AC_SUBST([GREP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([GREP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^GREP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([EGREP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([EGREP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^EGREP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([FGREP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([FGREP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^FGREP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([GREP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([GREP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^GREP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([LD])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([LD])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LD$])\n+m4trace:configure.ac:88: -1- AC_SUBST([DUMPBIN])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([DUMPBIN])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^DUMPBIN$])\n+m4trace:configure.ac:88: -1- AC_SUBST([ac_ct_DUMPBIN])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([ac_ct_DUMPBIN])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^ac_ct_DUMPBIN$])\n+m4trace:configure.ac:88: -1- AC_SUBST([DUMPBIN])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([DUMPBIN])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^DUMPBIN$])\n+m4trace:configure.ac:88: -1- AC_SUBST([NM])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([NM])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^NM$])\n+m4trace:configure.ac:88: -1- AC_SUBST([LN_S], [$as_ln_s])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([LN_S])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LN_S$])\n+m4trace:configure.ac:88: -1- AC_SUBST([OBJDUMP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([OBJDUMP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^OBJDUMP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([OBJDUMP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([OBJDUMP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^OBJDUMP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([AR])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([AR])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^AR$])\n+m4trace:configure.ac:88: -1- AC_SUBST([STRIP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([STRIP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^STRIP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([RANLIB])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([RANLIB])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^RANLIB$])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([LT_OBJDIR])\n+m4trace:configure.ac:88: -1- AC_DEFINE_TRACE_LITERAL([LT_OBJDIR])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LT_OBJDIR$])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([LT_OBJDIR], [/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+@%:@undef LT_OBJDIR])\n+m4trace:configure.ac:88: -1- LT_SUPPORTED_TAG([CC])\n+m4trace:configure.ac:88: -1- AC_SUBST([DSYMUTIL])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([DSYMUTIL])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^DSYMUTIL$])\n+m4trace:configure.ac:88: -1- AC_SUBST([NMEDIT])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([NMEDIT])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^NMEDIT$])\n+m4trace:configure.ac:88: -1- AC_SUBST([LIPO])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([LIPO])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LIPO$])\n+m4trace:configure.ac:88: -1- AC_SUBST([OTOOL])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([OTOOL])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^OTOOL$])\n+m4trace:configure.ac:88: -1- AC_SUBST([OTOOL64])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([OTOOL64])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^OTOOL64$])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_DLFCN_H], [/* Define to 1 if you have the <dlfcn.h> header file. */\n+@%:@undef HAVE_DLFCN_H])\n+m4trace:configure.ac:88: -1- AC_SUBST([CPP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CPP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CPP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([CPPFLAGS])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CPPFLAGS])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CPPFLAGS$])\n+m4trace:configure.ac:88: -1- AC_SUBST([CPP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CPP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CPP$])\n+m4trace:configure.ac:88: -1- AC_DEFINE_TRACE_LITERAL([STDC_HEADERS])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^STDC_HEADERS$])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([STDC_HEADERS], [/* Define to 1 if you have the ANSI C header files. */\n+@%:@undef STDC_HEADERS])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_SYS_TYPES_H], [/* Define to 1 if you have the <sys/types.h> header file. */\n+@%:@undef HAVE_SYS_TYPES_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_SYS_STAT_H], [/* Define to 1 if you have the <sys/stat.h> header file. */\n+@%:@undef HAVE_SYS_STAT_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_STDLIB_H], [/* Define to 1 if you have the <stdlib.h> header file. */\n+@%:@undef HAVE_STDLIB_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_STRING_H], [/* Define to 1 if you have the <string.h> header file. */\n+@%:@undef HAVE_STRING_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_MEMORY_H], [/* Define to 1 if you have the <memory.h> header file. */\n+@%:@undef HAVE_MEMORY_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_STRINGS_H], [/* Define to 1 if you have the <strings.h> header file. */\n+@%:@undef HAVE_STRINGS_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_INTTYPES_H], [/* Define to 1 if you have the <inttypes.h> header file. */\n+@%:@undef HAVE_INTTYPES_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_STDINT_H], [/* Define to 1 if you have the <stdint.h> header file. */\n+@%:@undef HAVE_STDINT_H])\n+m4trace:configure.ac:88: -1- AH_OUTPUT([HAVE_UNISTD_H], [/* Define to 1 if you have the <unistd.h> header file. */\n+@%:@undef HAVE_UNISTD_H])\n+m4trace:configure.ac:88: -1- AC_DEFINE_TRACE_LITERAL([HAVE_DLFCN_H])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^HAVE_DLFCN_H$])\n+m4trace:configure.ac:88: -1- LT_SUPPORTED_TAG([CXX])\n+m4trace:configure.ac:88: -1- AC_SUBST([CXXCPP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CXXCPP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CXXCPP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([CPPFLAGS])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CPPFLAGS])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CPPFLAGS$])\n+m4trace:configure.ac:88: -1- AC_SUBST([CXXCPP])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([CXXCPP])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^CXXCPP$])\n+m4trace:configure.ac:88: -1- AC_SUBST([LD])\n+m4trace:configure.ac:88: -1- AC_SUBST_TRACE([LD])\n+m4trace:configure.ac:88: -1- m4_pattern_allow([^LD$])\n+m4trace:configure.ac:89: -1- AC_SUBST([enable_shared])\n+m4trace:configure.ac:89: -1- AC_SUBST_TRACE([enable_shared])\n+m4trace:configure.ac:89: -1- m4_pattern_allow([^enable_shared$])\n+m4trace:configure.ac:90: -1- AC_SUBST([enable_static])\n+m4trace:configure.ac:90: -1- AC_SUBST_TRACE([enable_static])\n+m4trace:configure.ac:90: -1- m4_pattern_allow([^enable_static$])\n+m4trace:configure.ac:94: -1- AC_SUBST([libtool_VERSION])\n+m4trace:configure.ac:94: -1- AC_SUBST_TRACE([libtool_VERSION])\n+m4trace:configure.ac:94: -1- m4_pattern_allow([^libtool_VERSION$])\n+m4trace:configure.ac:97: -1- AC_SUBST([XCFLAGS])\n+m4trace:configure.ac:97: -1- AC_SUBST_TRACE([XCFLAGS])\n+m4trace:configure.ac:97: -1- m4_pattern_allow([^XCFLAGS$])\n+m4trace:configure.ac:105: -1- AM_CONDITIONAL([ENABLE_VTABLE_VERIFY], [test $enable_vtable_verify = yes])\n+m4trace:configure.ac:105: -1- AC_SUBST([ENABLE_VTABLE_VERIFY_TRUE])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([ENABLE_VTABLE_VERIFY_TRUE])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^ENABLE_VTABLE_VERIFY_TRUE$])\n+m4trace:configure.ac:105: -1- AC_SUBST([ENABLE_VTABLE_VERIFY_FALSE])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([ENABLE_VTABLE_VERIFY_FALSE])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^ENABLE_VTABLE_VERIFY_FALSE$])\n+m4trace:configure.ac:105: -1- _AM_SUBST_NOTMAKE([ENABLE_VTABLE_VERIFY_TRUE])\n+m4trace:configure.ac:105: -1- _AM_SUBST_NOTMAKE([ENABLE_VTABLE_VERIFY_FALSE])\n+m4trace:configure.ac:105: -1- AC_SUBST([libvtv_builddir])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([libvtv_builddir])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^libvtv_builddir$])\n+m4trace:configure.ac:105: -1- AC_SUBST([libvtv_srcdir])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([libvtv_srcdir])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^libvtv_srcdir$])\n+m4trace:configure.ac:105: -1- AC_SUBST([toplevel_builddir])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([toplevel_builddir])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^toplevel_builddir$])\n+m4trace:configure.ac:105: -1- AC_SUBST([toplevel_srcdir])\n+m4trace:configure.ac:105: -1- AC_SUBST_TRACE([toplevel_srcdir])\n+m4trace:configure.ac:105: -1- m4_pattern_allow([^toplevel_srcdir$])\n+m4trace:configure.ac:110: -1- AM_CONDITIONAL([VTV_SUPPORTED], [test \"x$VTV_SUPPORTED\" = \"xyes\"])\n+m4trace:configure.ac:110: -1- AC_SUBST([VTV_SUPPORTED_TRUE])\n+m4trace:configure.ac:110: -1- AC_SUBST_TRACE([VTV_SUPPORTED_TRUE])\n+m4trace:configure.ac:110: -1- m4_pattern_allow([^VTV_SUPPORTED_TRUE$])\n+m4trace:configure.ac:110: -1- AC_SUBST([VTV_SUPPORTED_FALSE])\n+m4trace:configure.ac:110: -1- AC_SUBST_TRACE([VTV_SUPPORTED_FALSE])\n+m4trace:configure.ac:110: -1- m4_pattern_allow([^VTV_SUPPORTED_FALSE$])\n+m4trace:configure.ac:110: -1- _AM_SUBST_NOTMAKE([VTV_SUPPORTED_TRUE])\n+m4trace:configure.ac:110: -1- _AM_SUBST_NOTMAKE([VTV_SUPPORTED_FALSE])\n+m4trace:configure.ac:112: -1- AC_CONFIG_FILES([Makefile])\n+m4trace:configure.ac:115: -2- _m4_warn([obsolete], [The macro `AC_FOREACH' is obsolete.\n+You should run autoupdate.], [../../lib/autoconf/general.m4:217: AC_FOREACH is expanded from...\n+configure.ac:115: the top level])\n+m4trace:configure.ac:115: -1- AC_CONFIG_FILES([./Makefile testsuite/Makefile ], [cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+    sed -f vpsed$$ $ac_file > tmp$$\n+    mv tmp$$ $ac_file\n+    rm vpsed$$\n+    echo 'MULTISUBDIR =' >> $ac_file\n+    ml_norecursion=yes\n+    . ${multi_basedir}/config-ml.in\n+    AS_UNSET([ml_norecursion])\n+])\n+m4trace:configure.ac:129: -1- AC_SUBST([LIB@&t@OBJS], [$ac_libobjs])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([LIB@&t@OBJS])\n+m4trace:configure.ac:129: -1- m4_pattern_allow([^LIB@&t@OBJS$])\n+m4trace:configure.ac:129: -1- AC_SUBST([LTLIBOBJS], [$ac_ltlibobjs])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([LTLIBOBJS])\n+m4trace:configure.ac:129: -1- m4_pattern_allow([^LTLIBOBJS$])\n+m4trace:configure.ac:129: -1- AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])\n+m4trace:configure.ac:129: -1- AC_SUBST([am__EXEEXT_TRUE])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([am__EXEEXT_TRUE])\n+m4trace:configure.ac:129: -1- m4_pattern_allow([^am__EXEEXT_TRUE$])\n+m4trace:configure.ac:129: -1- AC_SUBST([am__EXEEXT_FALSE])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([am__EXEEXT_FALSE])\n+m4trace:configure.ac:129: -1- m4_pattern_allow([^am__EXEEXT_FALSE$])\n+m4trace:configure.ac:129: -1- _AM_SUBST_NOTMAKE([am__EXEEXT_TRUE])\n+m4trace:configure.ac:129: -1- _AM_SUBST_NOTMAKE([am__EXEEXT_FALSE])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([top_builddir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([top_build_prefix])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([srcdir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([abs_srcdir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([top_srcdir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([abs_top_srcdir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([builddir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([abs_builddir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([abs_top_builddir])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([INSTALL])\n+m4trace:configure.ac:129: -1- AC_SUBST_TRACE([MKDIR_P])\n+m4trace:configure.ac:129: -1- AC_REQUIRE_AUX_FILE([ltmain.sh])"}, {"sha": "2aeb42cb39b91fd030f29da64947fde61693e1aa", "filename": "libvtv/configure", "status": "added", "additions": 17164, "deletions": 0, "changes": 17164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fconfigure?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b"}, {"sha": "cc8e28098edf64eb281df823b63a4e38896b3e57", "filename": "libvtv/configure.ac", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fconfigure.ac?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,129 @@\n+# -*- Autoconf -*-\n+# Process this file with autoconf to produce a configure script.\n+\n+AC_PREREQ([2.64])\n+AC_INIT([GNU Vtable Verification Runtime Library], 1.0,,[libvtv])\n+#AC_INIT(package-unused, version-unused, libvtv)\n+AC_CONFIG_SRCDIR([vtv_rts.h])\n+\n+# -------\n+# Options\n+# -------\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+AC_ARG_ENABLE(version-specific-runtime-libs,\n+[  --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory ],\n+[case \"$enableval\" in\n+ yes) version_specific_libs=yes ;;\n+ no)  version_specific_libs=no ;;\n+ *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n+ esac],\n+[version_specific_libs=no])\n+AC_MSG_RESULT($version_specific_libs)\n+\n+# Do not delete or change the following two lines.  For why, see\n+# http://gcc.gnu.org/ml/libstdc++/2003-07/msg00451.html\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+AC_SUBST(target_alias)\n+GCC_LIBSTDCXX_RAW_CXX_FLAGS\n+\n+AM_INIT_AUTOMAKE(foreign no-dist)\n+AM_ENABLE_MULTILIB(, ..)\n+AM_MAINTAINER_MODE\n+\n+# Calculate toolexeclibdir\n+# Also toolexecdir, though it's only used in toolexeclibdir\n+case ${version_specific_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+# Check for programs.\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+AC_PROG_CXX\n+m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AM_PROG_CC_C_O\n+\n+AC_SUBST(CFLAGS)\n+AC_SUBST(CXXFLAGS)\n+\n+# Newer automakes demand CCAS and CCASFLAGS.\n+: ${CCAS='$(CC)'}\n+: ${CCASFLAGS='$(CFLAGS)'}\n+AC_SUBST(CCAS)\n+AC_SUBST(CCASFLAGS)\n+\n+AC_CHECK_TOOL(AS, as)\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+# Configure libtool\n+AC_LIBTOOL_DLOPEN\n+AM_PROG_LIBTOOL\n+AC_SUBST(enable_shared)\n+AC_SUBST(enable_static)\n+\n+# For libtool versioning info, format is CURRENT:REVISION:AGE\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+XCFLAGS=\"-D_GNU_SOURCE -Wall -Wextra -fno-exceptions\"\n+AC_SUBST(XCFLAGS)\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+LIBVTV_CONFIGURE\n+\n+# Get target configury.\n+unset VTV_SUPPORTED\n+. ${srcdir}/configure.tgt\n+AM_CONDITIONAL(VTV_SUPPORTED, [test \"x$VTV_SUPPORTED\" = \"xyes\"])\n+\n+AC_CONFIG_FILES([Makefile])\n+\n+if test \"x$VTV_SUPPORTED\" = \"xyes\"; then\n+  AC_CONFIG_FILES(AC_FOREACH([DIR], [. testsuite], [DIR/Makefile ]), \n+    [cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+    sed -f vpsed$$ $ac_file > tmp$$\n+    mv tmp$$ $ac_file\n+    rm vpsed$$\n+    echo 'MULTISUBDIR =' >> $ac_file\n+    ml_norecursion=yes\n+    . ${multi_basedir}/config-ml.in\n+    AS_UNSET([ml_norecursion])\n+])\n+fi\n+\n+AC_OUTPUT"}, {"sha": "a84ed27f8ec574642882c0605a62c6660ee68619", "filename": "libvtv/configure.tgt", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fconfigure.tgt?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,38 @@\n+# -*- shell-script -*-\n+#   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not see <http://www.gnu.org/licenses/>.\n+\n+# This is the target specific configuration file.  This is invoked by the\n+# autoconf generated configure script.  Putting it in a separate shell file\n+# lets us skip running autoconf when modifying target specific information.\n+\n+# Filter out unsupported systems.\n+case \"${target}\" in\n+  x86_64-*-linux* | i?86-*-linux*)\n+\tVTV_SUPPORTED=yes\n+\t;;\n+  powerpc*-*-linux*)\n+\t;;\n+  sparc*-*-linux*)\n+\t;;\n+  arm*-*-linux*)\n+\t;;\n+  x86_64-*-darwin[1]* | i?86-*-darwin[1]*)\n+\tVTV_SUPPORTED=no\n+\t;;\n+  *)\n+\tUNSUPPORTED=1\n+\t;;\n+esac"}, {"sha": "a02ce1562e63b717f96f783a63e3b9ffd42876a7", "filename": "libvtv/scripts/run-testsuite.sh", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fscripts%2Frun-testsuite.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fscripts%2Frun-testsuite.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fscripts%2Frun-testsuite.sh?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,226 @@\n+#!/usr/bin/env bash\n+\n+# Script to do testing.\n+\n+# Invocation\n+# run-testsuite SRC_DIR BUILD_DIR\n+\n+# Pass in build/src directory as parameters.\n+SRC_DIR=$1\n+BUILD_DIR=$2\n+\n+# Now that we've successfully translated the numerical option into\n+# a symbolic one, we can safely ignore it.\n+shift\n+\n+# Use build compiler/library flags from libstdc++\n+flags_script=$BUILD_DIR/../libstdc++-v3/scripts/testsuite_flags\n+INCLUDES=`$flags_script --build-includes`\n+COMPILER=`$flags_script --build-cxx`\n+CXX=\"$COMPILER $INCLUDES -L$BUILD_DIR/.libs -Wl,--rpath -Wl,$BUILD_DIR/.libs\"\n+\n+echo \"compiler config is:\"\n+echo $CXX\n+echo \"\"\n+\n+# Other constants.\n+LOPT_LEVELS=${OPT_LEVELS:-\"-O0 -O2\"}\n+#LDATA_MODELS=${DATA_MODELS:-\"32 64\"}\n+LDATA_MODELS=${DATA_MODELS:-\"64\"}\n+\n+# Check if value of LGCC_LIB_PATH/$1 exists. If it does, save this path.\n+# If it doesn't, use LGCC_LIB_PATH as the library path.\n+# This allows us to check for paths that are of the form <x>/lib32 or <x>/lib64.\n+get_lib_path()\n+{\n+  if [[ -e $LGCC_LIB_PATH$1 ]]; then\n+    LLGCC_LIB_PATH=$LGCC_LIB_PATH$1\n+  else\n+    LLGCC_LIB_PATH=$LGCC_LIB_PATH\n+  fi\n+  return\n+}\n+\n+LGCC_SRC=$SRC_DIR/testsuite\n+\n+TESTS=\"const_vtable.cc dataentry.cc dup_name.cc environment.cc template-list.cc template-list2.cc template-list-iostream.cc povray-derived.cc thunk.cc thunk_vtable_map_attack.cc virtual_inheritance.cc \"\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fvtable-verify=std -fpic -rdynamic -Wl,-z,relro ${TSRC} ${OL}\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+TESTS_COMPOUND_parts=\"${LGCC_SRC}/parts-test-main.cc ${LGCC_SRC}/parts-test-extra-parts.cc ${LGCC_SRC}/parts-test-extra-parts-views.cc\"\n+TESTS_COMPOUND_events=\"${LGCC_SRC}/event-main.cc ${LGCC_SRC}/event-definitions.cc ${LGCC_SRC}/event-private.cc\"\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fvtable-verify=std -fpic -rdynamic -Wl,-z,relro ${TESTS_COMPOUND_parts} ${OL}\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+   done\n+done\n+\n+for M in $LDATA_MODELS; do\n+  for (( TN = 0 ; TN < 100 ; TN++ )); do\n+    SO_NAME=so$TN.so\n+    if [ -f ./lib${M}/$SO_NAME ]; then\n+      /bin/rm ./lib${M}/$SO_NAME\n+    fi\n+    CMD=\"${CXX} -m${M} -fvtable-verify=std -O0 -g -shared -fpic -rdynamic -Wl,-z,relro -DTPID=$TN -I${SRC_DIR} ${LGCC_SRC}/so.cc -o ./lib${M}/$SO_NAME\"\n+    echo ${CMD}\n+    ${CMD} || exit 8\n+  done\n+done\n+\n+DLOPEN_TESTS=\"dlopen.cc dlopen_mt.cc\"\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $DLOPEN_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fvtable-verify=std -fpic -rdynamic -Wl,-z,relro -Wl,-R,./lib${M} -I${SRC_DIR} ${TSRC} ${OL} -ldl -lpthread\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fvtable-verify=preinit -fpic -rdynamic -Wl,-z,relro ${TSRC} ${OL}\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+for M in $LDATA_MODELS; do\n+  if [ -f ./lib${M}/vtv_malloc.o ]; then\n+    /bin/rm ./lib${M}/vtv_malloc.o;\n+  fi\n+  CMD=\"${CXX} -m${M} -O2 -g -c -fpic ${SRC_DIR}/vtv_malloc.cc -o ./lib${M}/vtv_malloc.o\"\n+  echo ${CMD}\n+  ${CMD} || exit 3\n+\n+  if [ -f ./lib${M}/vtv_utils.o ]; then\n+    /bin/rm ./lib${M}/vtv_utils.o;\n+  fi\n+  CMD=\"${CXX} -m${M} -O2 -g -c -fpic ${SRC_DIR}/vtv_utils.cc -o ./lib${M}/vtv_utils.o\"\n+  echo ${CMD}\n+  ${CMD} || exit 4\n+done\n+\n+MEMPOOL_TESTS=\"mempool_positive.c mempool_negative.c\"\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $MEMPOOL_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fpic -rdynamic -I${SRC_DIR} ${TSRC} ${OL} ./lib${M}/vtv_malloc.o ./lib${M}/vtv_utils.o\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+# bkoz not working ATM signature mismatch\n+#MT_TESTS=\"register_pair_mt.cc register_pair_inserts_mt.cc\"\n+MT_TESTS=\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $MT_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fpic -rdynamic -I${SRC_DIR} ${TSRC} ${OL} -lpthread\"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+# These test cases were written for performance measurements, not for\n+# correctness but lets run them here so that we dont loose track of\n+# them\n+# bkoz not working ATM signature mismatch\n+#PERF_TESTS=\"register_pair.cc register_pair_inserts.cc\"\n+PERF_TESTS=\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $PERF_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fpic -rdynamic -I${SRC_DIR} ${TSRC} ${OL} \"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+\n+PASS_FAIL_TESTS=\"field-test.cc temp_deriv.cc temp_deriv2.cc temp_deriv3.cc\"\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $PASS_FAIL_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fvtable-verify=std -fpic -rdynamic ${TSRC} ${OL}  -Wl,-z,relro -DTPID\"\n+      echo $CMD\n+      ($CMD && ( ./a.out > $T.$OL.out 2>&1 )) || (( grep \"Pass first attack\" $T.$OL.out ) && echo \"PASS $T $OL - correctly passed then failed.\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for T in $PERF_TESTS; do\n+    TSRC=${LGCC_SRC}/${T}\n+    for OL in $LOPT_LEVELS; do\n+      CMD=\"${CXX} -m${M} -fpic -rdynamic -I${SRC_DIR} ${TSRC} ${OL} \"\n+      echo $CMD\n+      ($CMD  && ( ./a.out > $T.$OL.out 2>&1 ) && echo \"PASS $T $OL\") || echo \"FAIL $T $OL\"\n+    done\n+  done\n+done\n+\n+for M in $LDATA_MODELS; do\n+  get_lib_path lib${M}\n+  for OL in $LOPT_LEVELS; do\n+\n+    CMD=\"as --${M} -o environment-fail-${M}.o ${LGCC_SRC}/environment-fail-${M}.s\"\n+    echo $CMD\n+    ${CMD} || exit 5\n+\n+    CMD=\"${CXX} -m${M} environment-fail-${M}.o -O0 -Wl,-z,relro -o environment-fail-${M}\"\n+    echo ${CMD}\n+ #   ${CMD} || exit 6\n+ #   (./environment-fail-${M}) || echo \"PASS environment-fail-${M} (correctly failed), ${OL}\"\n+\n+    CMD=\"${CXX} -fvtable-verify=std -m${M} environment-fail-${M}.o -O0 -Wl,-z,relro -o environment-fail-${M}\"\n+    echo ${CMD}\n+    ($CMD && ( ./environment-fail-${M} > environment-fail-${M}-stubs.out 2>&1 ) && echo \"PASS environment-fail-${M} with libvtv_stubs ${OL}\" ) || echo \"FAIL environment-fail-${M} with libvtv_stubs ${OL}\"\n+\n+    CMD=\"${CXX} -m${M} ${LGCC_SRC}/replace-fail.cc -O0 -c -o replace-fail-${M}.o\"\n+    echo ${CMD}\n+    ${CMD} || exit 7\n+\n+    CMD=\"${CXX} -fvtable-verify=std -m${M} environment-fail-${M}.o replace-fail-${M}.o -O0 -Wl,-z,relro -o environment-fail-${M}\"\n+    echo ${CMD}\n+    ($CMD && ( ./environment-fail-${M} > environment-fail-${M}-stubs.out 2>&1 ) && echo \"PASS environment-fail-${M} with replace-fail ${OL}\" ) || echo \"FAIL environment-fail-${M} with replace-fail ${OL}\"\n+  done\n+done\n+"}, {"sha": "fc99498e70522a77645d27f01f4b3cdf754a8829", "filename": "libvtv/scripts/sum-vtv-counts.c", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fscripts%2Fsum-vtv-counts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fscripts%2Fsum-vtv-counts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fscripts%2Fsum-vtv-counts.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,150 @@\n+/*\n+This script sums up the counters for seeing how many virtual calls are\n+actually being verified.  The flag for generating the count data is\n+\"-fvtv-counts\".  This flag will generate two files in /tmp,\n+\"vtv_count_data.log\" and \"vtv_class_set_sizes.log\".  The first file is\n+the one that contains the info I mentioned; the second one is one I\n+generated because I was curious about how big the average set size was\n+for the vtable verification work.\n+\n+After compiling the attached program, run it on the vtv_count_data.log\n+file:\n+\n+$ sum-counters /tmp/vtv_count_data.log\n+\n+One can optionally pass a \"--verbose\" flag.  This file generates an\n+output file whose name is the same as the input file, with \".summary\"\n+appended to it, e.g. /tmp/vtv_count_data.log.summary .  Without the\n+verbose flag, it will just contain something like this:\n+\n+Total # virtual calls: 349123\n+Total # verified calls: 348236\n+Percent verified: 99 %\n+\n+Total calls to __VLTRegisterSet: 42236\n+Total calls to __VLTRegisterPair: 84371\n+Total # unused vtable map vars: 1536333\n+\n+With the --verbose flag it will also output one line for each\n+compilation unit for which it verified less than 90% of the virtual\n+calls (and there were more than 20 virtual calls in the file),\n+something like this:\n+\n+Verified 1 out of 25   (4.00%) :  foo.cc\n+Verified 27 out of 43   (62.00%) : bar.cc\n+*/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+void\n+usage (const char *error_text)\n+{\n+  fprintf (stderr, \"%s\", error_text);\n+  fprintf (stderr, \"Usage: \\n\");\n+  fprintf (stderr, \"sum-counters <input-file> [--verbose]\\n\");\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  FILE *fp_in = NULL;\n+  FILE *fp_out = NULL;\n+  int sum_vcalls = 0;\n+  int sum_verified = 0;\n+  int sum_regset = 0;\n+  int sum_regpair = 0;\n+  int sum_unused = 0;\n+  char fname_in[1024];\n+  char fname_out[1024];\n+  int total;\n+  int verified;\n+  int regset;\n+  int regpair;\n+  int unused;\n+  float pct;\n+  char buffer[1024];\n+  int verbose = 0;\n+\n+  if (argc < 2)\n+    {\n+      usage (\"Error: Need an input file.\\n\");\n+      return 1;\n+    }\n+\n+  fp_in = fopen (argv[1], \"r\");\n+  if (!fp_in)\n+    {\n+      snprintf (buffer, 1024, \"Error: Unable to open input file '%s'.\\n\",\n+\t\targv[1]);\n+      usage (buffer);\n+      return 1;\n+    }\n+\n+  if (argc == 3)\n+    {\n+      if (strcmp (argv[2], \"--verbose\") == 0)\n+\tverbose = 1;\n+      else\n+\t{\n+\t  snprintf (buffer, 1024, \"Error: Unrecognized option '%s'.\\n\",\n+\t\t    argv[2]);\n+\t  usage (buffer);\n+\t  return 1;\n+\t}\n+    }\n+\n+  snprintf (fname_out, 1024, \"%s.summary\", argv[1]);\n+\n+  fp_out = fopen (fname_out, \"w\");\n+  if (!fp_out)\n+    {\n+      fprintf (stderr, \"Error: Unable to open output file '%s'\\n\",\n+\t       fname_out);\n+      return 1;\n+    }\n+\n+  while (fscanf (fp_in, \"%s %d %d %d %d %d\\n\", fname_in,  &total,\n+\t\t &verified, &regset, &regpair, &unused) != EOF)\n+    {\n+      sum_vcalls += total;\n+      sum_verified += verified;\n+      sum_regset += regset;\n+      sum_regpair += regpair;\n+      sum_unused += unused;\n+\n+      float tmp_pct = 0.0;\n+\n+      if (total > 0)\n+\ttmp_pct = (verified * 100) / total;\n+\n+      if (verbose && tmp_pct < 90 && total >= 20)\n+\t{\n+\t  fprintf (fp_out, \"Verified %d out of %d   (%.2f%%) : %s\\n\",\n+\t\t   verified, total, tmp_pct, fname_in);\n+\t}\n+\n+    }\n+\n+  fclose (fp_in);\n+\n+  fprintf (fp_out, \"\\n\\n\");\n+  fprintf (fp_out, \"Total # virtual calls: %d\\n\", sum_vcalls);\n+  fprintf (fp_out, \"Total # verified calls: %d\\n\", sum_verified);\n+  if (sum_vcalls > 0)\n+    fprintf (fp_out, \"Percent verified: %d %%\\n\",\n+\t     sum_verified * 100 / sum_vcalls);\n+  else\n+    fprintf (fp_out, \"Percent verified: NA %%\\n\");\n+    \n+  fprintf (fp_out, \"\\nTotal calls to __VLTRegisterSet: %d\\n\",\n+\t   sum_regset);\n+  fprintf (fp_out, \"Total calls to __VLTRegisterPair: %d\\n\",\n+\t   sum_regpair);\n+  fprintf (fp_out, \"Total # unused vtable map vars: %d\\n\", sum_unused);\n+\n+  fclose (fp_out);\n+\n+  return 0;\n+}"}, {"sha": "5f6ab0a037f0720e511d2b9e8f7820e264d9dda2", "filename": "libvtv/testsuite/Makefile.am", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2FMakefile.am?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,56 @@\n+## Makefile for the testsuite subdirectory of the VTV library.\n+##\n+## Copyright (C) 2013 Free Software Foundation, Inc.\n+##\n+## Process this file with automake to produce Makefile.in.\n+##\n+## This file is part of the Vtable Verification (VTV) Library.  This\n+## library is free software; you can redistribute it and/or modify it\n+## under the terms of the GNU General Public License as published by\n+## the Free Software Foundation; either version 3, or (at your option)\n+## any later version.\n+\n+## This library is distributed in the hope that it will be useful, but\n+## WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+## General Public License for more details.\n+\n+## You should have received a copy of the GNU General Public License\n+## along with this library; see the file COPYING3.  If not see\n+## <http://www.gnu.org/licenses/>.\n+\n+AUTOMAKE_OPTIONS = nostdinc\n+\n+# Runs the testsuite via a script.\n+\n+# Create subdirectories.\n+stamp-subdir:\n+\tif test ! -d lib64; then \\\n+\t  mkdir -p lib64; \\\n+\tfi; \\\n+\tif test ! -d lib32; then \\\n+\t  mkdir -p lib32; \\\n+\tfi; \\\n+\techo `date` > stamp-subdir;\n+\n+\n+testing_script=${libvtv_srcdir}/scripts/run-testsuite.sh\n+check-script: ${testing_script} stamp-subdir\n+\t-@(chmod +x ${testing_script}; \\\n+\t${testing_script} ${libvtv_srcdir} ${libvtv_builddir})\n+\n+if ENABLE_VTABLE_VERIFY\n+check-am:\n+\t$(MAKE) $(AM_MAKEFLAGS) check-script\n+else\n+check-am:\n+endif\n+\n+.PHONY: check-script\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = *.out environment-fail-*  stamp-* replace-fail-*\n+\n+# To remove directories.\n+clean-local:\n+\trm -rf lib*"}, {"sha": "2992a9051427f5c720fdd886c0f3b5a723af74ad", "filename": "libvtv/testsuite/Makefile.in", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2FMakefile.in?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,380 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = testsuite\n+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/libstdc++-raw-cxx.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+SOURCES =\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AS = @AS@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBSTDCXX_RAW_CXX_CXXFLAGS = @LIBSTDCXX_RAW_CXX_CXXFLAGS@\n+LIBSTDCXX_RAW_CXX_LDFLAGS = @LIBSTDCXX_RAW_CXX_LDFLAGS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+libvtv_builddir = @libvtv_builddir@\n+libvtv_srcdir = @libvtv_srcdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_noncanonical = @target_noncanonical@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+toplevel_builddir = @toplevel_builddir@\n+toplevel_srcdir = @toplevel_srcdir@\n+AUTOMAKE_OPTIONS = nostdinc\n+testing_script = ${libvtv_srcdir}/scripts/run-testsuite.sh\n+\n+# By adding these files here, automake will remove them for 'make clean'\n+CLEANFILES = *.out environment-fail-*  stamp-* replace-fail-*\n+all: all-am\n+\n+.SUFFIXES:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign testsuite/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+tags: TAGS\n+TAGS:\n+\n+ctags: CTAGS\n+CTAGS:\n+\n+check-am: all-am\n+check: check-am\n+all-am: Makefile\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-local mostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-generic\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: all all-am check check-am clean clean-generic clean-libtool \\\n+\tclean-local distclean distclean-generic distclean-libtool dvi \\\n+\tdvi-am html html-am info info-am install install-am \\\n+\tinstall-data install-data-am install-dvi install-dvi-am \\\n+\tinstall-exec install-exec-am install-html install-html-am \\\n+\tinstall-info install-info-am install-man install-pdf \\\n+\tinstall-pdf-am install-ps install-ps-am install-strip \\\n+\tinstallcheck installcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-generic \\\n+\tmostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am\n+\n+\n+# Runs the testsuite via a script.\n+\n+# Create subdirectories.\n+stamp-subdir:\n+\tif test ! -d lib64; then \\\n+\t  mkdir -p lib64; \\\n+\tfi; \\\n+\tif test ! -d lib32; then \\\n+\t  mkdir -p lib32; \\\n+\tfi; \\\n+\techo `date` > stamp-subdir;\n+check-script: ${testing_script} stamp-subdir\n+\t-@(chmod +x ${testing_script}; \\\n+\t${testing_script} ${libvtv_srcdir} ${libvtv_builddir})\n+\n+@ENABLE_VTABLE_VERIFY_TRUE@check-am:\n+@ENABLE_VTABLE_VERIFY_TRUE@\t$(MAKE) $(AM_MAKEFLAGS) check-script\n+@ENABLE_VTABLE_VERIFY_FALSE@check-am:\n+\n+.PHONY: check-script\n+\n+# To remove directories.\n+clean-local:\n+\trm -rf lib*\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "a0946abf4fe22f5401360380c2db330ccc8ab6ce", "filename": "libvtv/testsuite/const_vtable.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fconst_vtable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fconst_vtable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fconst_vtable.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,82 @@\n+extern \"C\" int printf(const char *,...); \n+struct V1 {\n+  int v; \n+  virtual int foo(); \n+  V1(); \n+  ~V1(); \n+}; \n+struct V2 : virtual V1 {\n+  int v2; \n+  virtual int foo(); \n+  V2(); \n+  ~V2(); \n+}; \n+struct C : virtual V1, virtual V2 {\n+  int c; \n+  virtual int foo(); \n+  C(); \n+  ~C(); \n+}; \n+\n+struct B {\n+  int b; }; \n+struct D : B, C {\n+  int d; \n+  virtual int bar(); \n+  D(); \n+  ~D(); \n+}; \n+extern \"C\" int printf(const char *,...); \n+main() \n+{\n+  try {\n+    D *d = new D; \n+    delete d; \n+  } catch (int) {\n+    printf(\"Int caught\\n\"); \n+  } \n+} \n+\n+int V1::foo() {\n+  printf(\"V1::foo called\\n\"); return 1; } \n+V1::V1() : v(5) {\n+  printf(\"V1 called\\n\"); } \n+V1::~V1() {\n+  printf(\"~V1 called\\n\"); } \n+\n+int V2::foo() {\n+  printf(\"V2::foo called\\n\"); return 1; } \n+V2::V2() : v2(6) {\n+  printf(\"V2 called\\n\"); } \n+V2::~V2() {\n+  printf(\"~V2 called\\n\"); } \n+\n+int C::foo() {\n+  printf(\"C::foo called %d\\n\", c); return 1; } \n+C::C() : c(7) {\n+  printf(\"C called\\n\"); \n+  V1 *vv = this; vv->foo(); \n+  C *cp = dynamic_cast<C *>(vv); \n+  if (this == cp) {\n+    printf(\"PASSED this == cp\\n\"); \n+  } else {\n+    printf(\"FAILED this != cp\\n\"); \n+  } \n+} \n+C::~C() {\n+  printf(\"~C called\\n\"); \n+  V1 *vv = this; vv->foo(); \n+  C *cp = dynamic_cast<C *>(vv); \n+  if (this == cp) {\n+    printf(\"PASSED this == cp\\n\"); \n+  } else {\n+    printf(\"FAILED this != cp\\n\"); \n+  } \n+} \n+\n+int D::bar() {\n+  printf(\"D::bar called\\n\"); return 1; } \n+D::D() : d(8) {\n+  printf(\"D called\\n\"); throw 5; } \n+D::~D() {\n+  printf(\"~D called\\n\"); } "}, {"sha": "fa027d5bc71bc4e25e0ca1cb861d6653cc5b65ab", "filename": "libvtv/testsuite/dataentry.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdataentry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdataentry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fdataentry.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,37 @@\n+template<int patch_dim, int patch_space_dim>\n+class DataOutInterface\n+{\n+ public:\n+  virtual ~DataOutInterface() {}\n+};\n+\n+template <int dof_handler_dim, int patch_dim, int patch_space_dim=patch_dim>\n+class DataOut_DoFData : public DataOutInterface<patch_dim,patch_space_dim>\n+{\n+ public:\n+  virtual ~DataOut_DoFData() {}\n+\n+class DataEntryBase {\n+ public:\n+  virtual ~DataEntryBase () {}\n+};\n+\n+template <typename T>\n+class DataEntry : public DataEntryBase\n+{\n+ public:\n+  virtual ~DataEntry() {}\n+};\n+};\n+\n+template <typename T> void Destroy(T * p) __attribute__((noinline));\n+template <typename T> void Destroy(T * p)\n+{\n+  delete p;\n+}\n+\n+int main()\n+{\n+  DataOut_DoFData<3,3>::DataEntryBase * p  = new DataOut_DoFData<3,3>::DataEntry<int>();\n+  Destroy(p);\n+}"}, {"sha": "4ffbe83acf7718130e0e09e2a05141a8ae60abab", "filename": "libvtv/testsuite/dlopen.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdlopen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdlopen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fdlopen.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,38 @@\n+#include <stdlib.h>\n+#include <dlfcn.h>\n+#include <stdio.h>\n+\n+\n+\n+typedef void (*voidfn)(void);\n+\n+int failures = 0;\n+\n+void\n+__vtv_verify_fail (void **data_set_ptr, const void *vtbl_pointer)\n+{\n+  failures++;\n+  return;\n+}\n+\n+\n+int main()\n+{\n+  char so_name[] = \"so0.so\";\n+  void * dlhandle = dlopen(so_name, RTLD_NOW);\n+  if (!dlhandle)\n+    {\n+      fprintf(stderr, \"dlopen %s error: %s\\n\", so_name, dlerror());\n+      exit(1);\n+    }\n+  voidfn so_entry = (voidfn)dlsym(dlhandle, \"so_entry_0\");\n+  if (!so_entry)\n+    {\n+      fprintf(stderr, \"dlopen %s dlsym error: %s\\n\", so_name, dlerror());\n+      exit(2);\n+    }\n+\n+  so_entry();\n+\n+  dlclose(dlhandle);\n+}"}, {"sha": "772e8a733ed13ca3796de488e295342493c60d4c", "filename": "libvtv/testsuite/dlopen_mt.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdlopen_mt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdlopen_mt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fdlopen_mt.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,112 @@\n+#include <stdlib.h>\n+#include <dlfcn.h>\n+#include <stdio.h>\n+\n+#include \"vtv_utils.h\"\n+#include \"vtv_rts.h\"\n+#include \"pthread.h\"\n+\n+#define NUM_REPEATS 10\n+#define NUM_THREADS 10\n+#define NUM_SOS 100\n+#define NUM_SOS_PER_THREAD (NUM_SOS/NUM_THREADS)\n+\n+typedef void (*voidfn)(void);\n+\n+int failures = 0;\n+\n+void\n+__vtv_verify_fail (void **data_set_ptr, const void *vtbl_pointer)\n+{\n+  failures++;\n+  return;\n+}\n+\n+\n+void do_dlopen(int so_num)\n+{\n+  char so_name [sizeof(\"soxxx.so\")];\n+  sprintf(so_name, \"so%d.so\", so_num);\n+  //  printf(\"dl-opening %s\\n\", so_name);\n+  void * dlhandle = dlopen(so_name, RTLD_NOW);\n+  if (!dlhandle)\n+    {\n+      fprintf(stderr, \"dlopen so:%s error: %s\\n\", so_name, dlerror());\n+      exit(1);\n+    }\n+  char so_entry [sizeof(\"so_entry_xxx\")];\n+  sprintf(so_entry, \"so_entry_%d\", so_num);\n+  voidfn so_entry_fn = (voidfn)dlsym(dlhandle, so_entry);\n+  if (!so_entry_fn)\n+    {\n+      fprintf(stderr, \"so:%s dlsym error: %s\\n\", so_name, dlerror());\n+      exit(2);\n+    }\n+\n+  so_entry_fn();\n+\n+  dlclose(dlhandle);\n+}\n+\n+volatile int threads_completed_it = 0;\n+volatile int current_wave = -1;\n+\n+void * do_dlopens(void * ptid)\n+{\n+  for (int k = 0; k < NUM_REPEATS; k++)\n+    {\n+\n+      for (int i = 0; i < NUM_SOS_PER_THREAD; i++)\n+\t{\n+\t  while (current_wave < (k*NUM_SOS_PER_THREAD + i)) /* from 0 to 99 */\n+\t    ;\n+\n+          do_dlopen((NUM_SOS_PER_THREAD * *(int *)ptid) + i);\n+\n+\t  int old_value;\n+\t  do {\n+\t    old_value = threads_completed_it;\n+\t  } while (!__sync_bool_compare_and_swap(&threads_completed_it, old_value, old_value + 1));\n+\n+\t  if (old_value == (NUM_THREADS - 1)) // Only one thread will do this.\n+\t    {\n+\t      threads_completed_it = 0;\n+\t      printf(\"%c%d\", 13, current_wave + 1);\n+\t      fflush(stdout);\n+\t      current_wave++;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+int main()\n+{\n+  pthread_t thread_ids[NUM_THREADS];\n+  int thread_nids[NUM_THREADS];\n+\n+  for (int t = 0; t < NUM_THREADS; t++ )\n+  {\n+    thread_nids[t] = t;\n+    if (pthread_create(&thread_ids[t], NULL, do_dlopens, &thread_nids[t]) != 0)\n+      {\n+\tprintf(\"failed pthread_create\\n\");\n+\texit(1);\n+      }\n+  }\n+\n+  current_wave = 0; // start the work on the other threads\n+\n+  for (int t = 0; t < NUM_THREADS; t++)\n+    if (pthread_join(thread_ids[t], NULL) != 0)\n+      { \n+\tprintf(\"failed pthread_join\\n\");\n+\texit(2);\n+      }\n+\n+  printf(\"\\n\");\n+\n+  return 0;\n+}"}, {"sha": "f0f1c2a8136b4e9a7b7bcf1dc077961ab25fdb69", "filename": "libvtv/testsuite/dup_name.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdup_name.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fdup_name.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fdup_name.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,60 @@\n+#include <assert.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+class Subscriptor\n+{\n+  public:\n+\n+  Subscriptor()\n+    { counter = 1;}\n+\n+  virtual ~Subscriptor()\n+  {\n+    counter--;\n+    assert(counter == 0);\n+  }\n+\n+  private:\n+    static int counter;\n+};\n+\n+int Subscriptor::counter;\n+\n+template <typename number>\n+class Polynomial : public Subscriptor\n+{\n+};\n+\n+class LagrangeEquidistant: public Polynomial<double>\n+{\n+};\n+\n+template <int value>\n+class A\n+{\n+ public:\n+  class Nested: public LagrangeEquidistant\n+  {\n+  };\n+  A() { n = new Nested; }\n+  ~A() { delete n; }\n+  Subscriptor * n;\n+};\n+\n+template<typename _Tp>\n+inline void\n+_MyDestroy(_Tp* __pointer)\n+  { __pointer->~_Tp(); }\n+\n+int main()\n+{\n+  Subscriptor * s1 =  new  LagrangeEquidistant;\n+  _MyDestroy(s1);\n+  A<1> * a1 = new A<1>;\n+  _MyDestroy(a1);\n+  A<2> * a2 = new A<2>;\n+  _MyDestroy(a2);\n+\n+  return 0;\n+}"}, {"sha": "cac501652a78e1c917562d7fe39df43c38b9a8d3", "filename": "libvtv/testsuite/environment-fail-32.s", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment-fail-32.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment-fail-32.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fenvironment-fail-32.s?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,514 @@\n+\t.file\t\"environment.cc\"\n+\t.section\t.text._ZN15EnvironmentImpl6GetVarEPKcPc,\"axG\",@progbits,_ZN15EnvironmentImpl6GetVarEPKcPc,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.type\t_ZN15EnvironmentImpl6GetVarEPKcPc, @function\n+_ZN15EnvironmentImpl6GetVarEPKcPc:\n+.LFB0:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tmovl\t$1, %eax\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE0:\n+\t.size\t_ZN15EnvironmentImpl6GetVarEPKcPc, .-_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.text\n+\t.align 2\n+\t.globl\t_ZN11EnvironmentD2Ev\n+\t.type\t_ZN11EnvironmentD2Ev, @function\n+_ZN11EnvironmentD2Ev:\n+.LFB2:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$20, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t_ZTV11Environment@GOT(%ebx), %edx\n+\tleal\t8(%edx), %edx\n+\tmovl\t%edx, (%eax)\n+\tmovl\t$0, %eax\n+\ttestl\t%eax, %eax\n+\tje\t.L3\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZdlPv@PLT\n+.L3:\n+\taddl\t$20, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE2:\n+\t.size\t_ZN11EnvironmentD2Ev, .-_ZN11EnvironmentD2Ev\n+\t.globl\t_ZN11EnvironmentD1Ev\n+\t.set\t_ZN11EnvironmentD1Ev,_ZN11EnvironmentD2Ev\n+\t.align 2\n+\t.globl\t_ZN11EnvironmentD0Ev\n+\t.type\t_ZN11EnvironmentD0Ev, @function\n+_ZN11EnvironmentD0Ev:\n+.LFB4:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$20, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZN11EnvironmentD1Ev@PLT\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZdlPv@PLT\n+\taddl\t$20, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE4:\n+\t.size\t_ZN11EnvironmentD0Ev, .-_ZN11EnvironmentD0Ev\n+\t.section\t.text._ZN11EnvironmentC2Ev,\"axG\",@progbits,_ZN11EnvironmentC5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN11EnvironmentC2Ev\n+\t.type\t_ZN11EnvironmentC2Ev, @function\n+_ZN11EnvironmentC2Ev:\n+.LFB8:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tcall\t__x86.get_pc_thunk.cx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ecx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t_ZTV11Environment@GOT(%ecx), %edx\n+\tleal\t8(%edx), %edx\n+\tmovl\t%edx, (%eax)\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE8:\n+\t.size\t_ZN11EnvironmentC2Ev, .-_ZN11EnvironmentC2Ev\n+\t.weak\t_ZN11EnvironmentC1Ev\n+\t.set\t_ZN11EnvironmentC1Ev,_ZN11EnvironmentC2Ev\n+\t.section\t.text._ZN15EnvironmentImplC2Ev,\"axG\",@progbits,_ZN15EnvironmentImplC5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplC2Ev\n+\t.type\t_ZN15EnvironmentImplC2Ev, @function\n+_ZN15EnvironmentImplC2Ev:\n+.LFB10:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$20, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZN11EnvironmentC2Ev@PLT\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t_ZTV15EnvironmentImpl@GOT(%ebx), %edx\n+\tleal\t8(%edx), %edx\n+\tmovl\t%edx, (%eax)\n+\taddl\t$20, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE10:\n+\t.size\t_ZN15EnvironmentImplC2Ev, .-_ZN15EnvironmentImplC2Ev\n+\t.weak\t_ZN15EnvironmentImplC1Ev\n+\t.set\t_ZN15EnvironmentImplC1Ev,_ZN15EnvironmentImplC2Ev\n+\t.text\n+\t.align 2\n+\t.globl\t_ZN11Environment6CreateEv\n+\t.type\t_ZN11Environment6CreateEv, @function\n+_ZN11Environment6CreateEv:\n+.LFB5:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%esi\n+\tpushl\t%ebx\n+\tsubl\t$16, %esp\n+\t.cfi_offset 6, -12\n+\t.cfi_offset 3, -16\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t$4, (%esp)\n+\tcall\t_Znwj@PLT\n+\tmovl\t%eax, %esi\n+\tmovl\t$0, (%esi)\n+\tmovl\t%esi, (%esp)\n+\tcall\t_ZN15EnvironmentImplC1Ev@PLT\n+\tmovl\t%esi, %eax\n+\taddl\t$16, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%esi\n+\t.cfi_restore 6\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE5:\n+\t.size\t_ZN11Environment6CreateEv, .-_ZN11Environment6CreateEv\n+\t.section\t.rodata\n+.LC0:\n+\t.string\t\"%p\\n\"\n+\t.text\n+\t.globl\tmain\n+\t.type\tmain, @function\n+main:\n+.LFB12:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tandl\t$-16, %esp\n+\tsubl\t$32, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t$0, 28(%esp)\n+\tcall\t_ZN11Environment6CreateEv@PLT\n+\tmovl\t%eax, 24(%esp)\n+\tmovl\t24(%esp), %eax\n+\tmovl\t(%eax), %eax\n+\tmovl\t%eax, 4(%esp)\n+\tleal\t_ZN4_VTVI11EnvironmentE12__vtable_mapE@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_Z24__VLTVerifyVtablePointerPPvPKv@PLT\n+\taddl\t$8, %eax\n+\tmovl\t(%eax), %eax\n+\tmovl\t28(%esp), %edx\n+\tmovl\t%edx, 8(%esp)\n+\tmovl\t$0, 4(%esp)\n+\tmovl\t24(%esp), %edx\n+\tmovl\t%edx, (%esp)\n+\tcall\t*%eax\n+\tmovl\t24(%esp), %eax\n+\tmovl\t%eax, 4(%esp)\n+\tleal\t.LC0@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\tprintf@PLT\n+\tmovl\t$0, %eax\n+\tmovl\t-4(%ebp), %ebx\n+\tleave\n+\t.cfi_restore 5\n+\t.cfi_restore 3\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE12:\n+\t.size\tmain, .-main\n+\t.weak\t_ZTV11Environment\n+\t.section\t.data.rel.ro._ZTV11Environment,\"awG\",@progbits,_ZTV11Environment,comdat\n+\t.align 8\n+\t.type\t_ZTV11Environment, @object\n+\t.size\t_ZTV11Environment, 20\n+_ZTV11Environment:\n+\t.long\t0\n+\t.long\t_ZTI11Environment\n+\t.long\t_ZN11EnvironmentD1Ev\n+\t.long\t_ZN11EnvironmentD0Ev\n+\t.long\t__cxa_pure_virtual\n+\t.weak\t_ZTV15EnvironmentImpl\n+\t.section\t.data.rel.ro._ZTV15EnvironmentImpl,\"awG\",@progbits,_ZTV15EnvironmentImpl,comdat\n+\t.align 8\n+\t.type\t_ZTV15EnvironmentImpl, @object\n+\t.size\t_ZTV15EnvironmentImpl, 20\n+_ZTV15EnvironmentImpl:\n+\t.long\t0\n+\t.long\t_ZTI15EnvironmentImpl\n+\t.long\t_ZN15EnvironmentImplD1Ev\n+\t.long\t_ZN15EnvironmentImplD0Ev\n+\t.long\t_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.section\t.text._ZN15EnvironmentImplD2Ev,\"axG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplD2Ev\n+\t.type\t_ZN15EnvironmentImplD2Ev, @function\n+_ZN15EnvironmentImplD2Ev:\n+.LFB14:\n+\t.cfi_startproc\n+\t.cfi_personality 0x9b,DW.ref.__gxx_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA14\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$20, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t_ZTV15EnvironmentImpl@GOT(%ebx), %edx\n+\tleal\t8(%edx), %edx\n+\tmovl\t%edx, (%eax)\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+.LEHB0:\n+\tcall\t_ZN11EnvironmentD2Ev@PLT\n+.LEHE0:\n+\tmovl\t$0, %eax\n+\ttestl\t%eax, %eax\n+\tje\t.L19\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZdlPv@PLT\n+\tjmp\t.L19\n+.L18:\n+\tmovl\t%eax, (%esp)\n+.LEHB1:\n+\tcall\t_Unwind_Resume@PLT\n+.LEHE1:\n+.L19:\n+\taddl\t$20, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE14:\n+\t.globl\t__gxx_personality_v0\n+\t.section\t.gcc_except_table._ZN15EnvironmentImplD2Ev,\"aG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+.LLSDA14:\n+\t.byte\t0xff\n+\t.byte\t0xff\n+\t.byte\t0x1\n+\t.uleb128 .LLSDACSE14-.LLSDACSB14\n+.LLSDACSB14:\n+\t.uleb128 .LEHB0-.LFB14\n+\t.uleb128 .LEHE0-.LEHB0\n+\t.uleb128 .L18-.LFB14\n+\t.uleb128 0\n+\t.uleb128 .LEHB1-.LFB14\n+\t.uleb128 .LEHE1-.LEHB1\n+\t.uleb128 0\n+\t.uleb128 0\n+.LLSDACSE14:\n+\t.section\t.text._ZN15EnvironmentImplD2Ev,\"axG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+\t.size\t_ZN15EnvironmentImplD2Ev, .-_ZN15EnvironmentImplD2Ev\n+\t.weak\t_ZN15EnvironmentImplD1Ev\n+\t.set\t_ZN15EnvironmentImplD1Ev,_ZN15EnvironmentImplD2Ev\n+\t.section\t.text._ZN15EnvironmentImplD0Ev,\"axG\",@progbits,_ZN15EnvironmentImplD0Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplD0Ev\n+\t.type\t_ZN15EnvironmentImplD0Ev, @function\n+_ZN15EnvironmentImplD0Ev:\n+.LFB16:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$20, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZN15EnvironmentImplD1Ev@PLT\n+\tmovl\t8(%ebp), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_ZdlPv@PLT\n+\taddl\t$20, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE16:\n+\t.size\t_ZN15EnvironmentImplD0Ev, .-_ZN15EnvironmentImplD0Ev\n+\t.weak\t_ZTS15EnvironmentImpl\n+\t.section\t.rodata._ZTS15EnvironmentImpl,\"aG\",@progbits,_ZTS15EnvironmentImpl,comdat\n+\t.type\t_ZTS15EnvironmentImpl, @object\n+\t.size\t_ZTS15EnvironmentImpl, 18\n+_ZTS15EnvironmentImpl:\n+\t.string\t\"15EnvironmentImpl\"\n+\t.weak\t_ZTI15EnvironmentImpl\n+\t.section\t.data.rel.ro._ZTI15EnvironmentImpl,\"awG\",@progbits,_ZTI15EnvironmentImpl,comdat\n+\t.align 4\n+\t.type\t_ZTI15EnvironmentImpl, @object\n+\t.size\t_ZTI15EnvironmentImpl, 12\n+_ZTI15EnvironmentImpl:\n+\t.long\t_ZTVN10__cxxabiv120__si_class_type_infoE+8\n+\t.long\t_ZTS15EnvironmentImpl\n+\t.long\t_ZTI11Environment\n+\t.weak\t_ZTI11Environment\n+\t.section\t.data.rel.ro._ZTI11Environment,\"awG\",@progbits,_ZTI11Environment,comdat\n+\t.align 4\n+\t.type\t_ZTI11Environment, @object\n+\t.size\t_ZTI11Environment, 8\n+_ZTI11Environment:\n+\t.long\t_ZTVN10__cxxabiv117__class_type_infoE+8\n+\t.long\t_ZTS11Environment\n+\t.weak\t_ZTS11Environment\n+\t.section\t.rodata._ZTS11Environment,\"aG\",@progbits,_ZTS11Environment,comdat\n+\t.type\t_ZTS11Environment, @object\n+\t.size\t_ZTS11Environment, 14\n+_ZTS11Environment:\n+\t.string\t\"11Environment\"\n+\t.hidden\t_ZN4_VTVI11EnvironmentE12__vtable_mapE\n+\t.weak\t_ZN4_VTVI11EnvironmentE12__vtable_mapE\n+\t.section\t.vtable_map_vars,\"awG\",@progbits,_ZN4_VTVI11EnvironmentE12__vtable_mapE,comdat\n+\t.align 4\n+\t.type\t_ZN4_VTVI11EnvironmentE12__vtable_mapE, @gnu_unique_object\n+\t.size\t_ZN4_VTVI11EnvironmentE12__vtable_mapE, 4\n+_ZN4_VTVI11EnvironmentE12__vtable_mapE:\n+\t.zero\t4\n+\t.hidden\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\n+\t.weak\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\n+\t.section\t.vtable_map_vars,\"awG\",@progbits,_ZN4_VTVI15EnvironmentImplE12__vtable_mapE,comdat\n+\t.align 4\n+\t.type\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE, @gnu_unique_object\n+\t.size\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE, 4\n+_ZN4_VTVI15EnvironmentImplE12__vtable_mapE:\n+\t.zero\t4\n+\t.section\t.data.rel.ro,\"aw\",@progbits\n+\t.align 4\n+\t.type\t__vptr_array_11Environment, @object\n+\t.size\t__vptr_array_11Environment, 8\n+__vptr_array_11Environment:\n+\t.long\t_ZTV11Environment+8\n+\t.long\t_ZTV15EnvironmentImpl+8\n+\t.section\t.rodata\n+\t.align 4\n+.LC1:\n+\t.string\t\"&\"\n+\t.string\t\"\"\n+\t.string\t\"\"\n+\t.ascii\t\"\\224\\tl\\022_ZN4_VTVI11EnvironmentE12__vtable_mapE\"\n+\t.align 4\n+.LC2:\n+\t.string\t\"*\"\n+\t.string\t\"\"\n+\t.string\t\"\"\n+\t.ascii\t\"N\\225\\r\\334_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\"\n+\t.text\n+\t.type\t_GLOBAL__sub_I.00099_environment.cc, @function\n+_GLOBAL__sub_I.00099_environment.cc:\n+.LFB17:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tpushl\t%ebx\n+\tsubl\t$36, %esp\n+\t.cfi_offset 3, -12\n+\tcall\t__x86.get_pc_thunk.bx\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tleal\t__vptr_array_11Environment@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, 16(%esp)\n+\tmovl\t$2, 12(%esp)\n+\tmovl\t$2, 8(%esp)\n+\tleal\t.LC1@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, 4(%esp)\n+\tleal\t_ZN4_VTVI11EnvironmentE12__vtable_mapE@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, (%esp)\n+\tmovl\t_ZTV15EnvironmentImpl@GOT(%ebx), %eax\n+\tleal\t8(%eax), %eax\n+\tmovl\t%eax, 12(%esp)\n+\tmovl\t$1, 8(%esp)\n+\tleal\t.LC2@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, 4(%esp)\n+\tleal\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE@GOTOFF(%ebx), %eax\n+\tmovl\t%eax, (%esp)\n+\tcall\t_Z17__VLTRegisterPairPPvPKvjS2_@PLT\n+\taddl\t$36, %esp\n+\tpopl\t%ebx\n+\t.cfi_restore 3\n+\tpopl\t%ebp\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+.LFE17:\n+\t.size\t_GLOBAL__sub_I.00099_environment.cc, .-_GLOBAL__sub_I.00099_environment.cc\n+\t.section\t.init_array.00099,\"aw\"\n+\t.align 4\n+\t.long\t_GLOBAL__sub_I.00099_environment.cc\n+\t.section\t.text.__x86.get_pc_thunk.cx,\"axG\",@progbits,__x86.get_pc_thunk.cx,comdat\n+\t.globl\t__x86.get_pc_thunk.cx\n+\t.hidden\t__x86.get_pc_thunk.cx\n+\t.type\t__x86.get_pc_thunk.cx, @function\n+__x86.get_pc_thunk.cx:\n+.LFB18:\n+\t.cfi_startproc\n+\tmovl\t(%esp), %ecx\n+\tret\n+\t.cfi_endproc\n+.LFE18:\n+\t.section\t.text.__x86.get_pc_thunk.bx,\"axG\",@progbits,__x86.get_pc_thunk.bx,comdat\n+\t.globl\t__x86.get_pc_thunk.bx\n+\t.hidden\t__x86.get_pc_thunk.bx\n+\t.type\t__x86.get_pc_thunk.bx, @function\n+__x86.get_pc_thunk.bx:\n+.LFB19:\n+\t.cfi_startproc\n+\tmovl\t(%esp), %ebx\n+\tret\n+\t.cfi_endproc\n+.LFE19:\n+\t.hidden\tDW.ref.__gxx_personality_v0\n+\t.weak\tDW.ref.__gxx_personality_v0\n+\t.section\t.data.DW.ref.__gxx_personality_v0,\"awG\",@progbits,DW.ref.__gxx_personality_v0,comdat\n+\t.align 4\n+\t.type\tDW.ref.__gxx_personality_v0, @object\n+\t.size\tDW.ref.__gxx_personality_v0, 4\n+DW.ref.__gxx_personality_v0:\n+\t.long\t__gxx_personality_v0\n+\t.ident\t\"GCC: (GNU) 4.9.0 20130616 (experimental)\"\n+\t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "d75db248b0706196b7e0d7988699ddc0790d1a68", "filename": "libvtv/testsuite/environment-fail-64.s", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment-fail-64.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment-fail-64.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fenvironment-fail-64.s?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,425 @@\n+\t.file\t\"environment.cc\"\n+\t.section\t.text._ZN15EnvironmentImpl6GetVarEPKcPc,\"axG\",@progbits,_ZN15EnvironmentImpl6GetVarEPKcPc,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.type\t_ZN15EnvironmentImpl6GetVarEPKcPc, @function\n+_ZN15EnvironmentImpl6GetVarEPKcPc:\n+.LFB0:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t%rsi, -16(%rbp)\n+\tmovq\t%rdx, -24(%rbp)\n+\tmovl\t$1, %eax\n+\tpopq\t%rbp\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE0:\n+\t.size\t_ZN15EnvironmentImpl6GetVarEPKcPc, .-_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.text\n+\t.align 2\n+\t.globl\t_ZN11EnvironmentD2Ev\n+\t.type\t_ZN11EnvironmentD2Ev, @function\n+_ZN11EnvironmentD2Ev:\n+.LFB2:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t_ZTV11Environment@GOTPCREL(%rip), %rdx\n+\tleaq\t16(%rdx), %rdx\n+\tmovq\t%rdx, (%rax)\n+\tmovl\t$0, %eax\n+\ttestl\t%eax, %eax\n+\tje\t.L3\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZdlPv@PLT\n+.L3:\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE2:\n+\t.size\t_ZN11EnvironmentD2Ev, .-_ZN11EnvironmentD2Ev\n+\t.globl\t_ZN11EnvironmentD1Ev\n+\t.set\t_ZN11EnvironmentD1Ev,_ZN11EnvironmentD2Ev\n+\t.align 2\n+\t.globl\t_ZN11EnvironmentD0Ev\n+\t.type\t_ZN11EnvironmentD0Ev, @function\n+_ZN11EnvironmentD0Ev:\n+.LFB4:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZN11EnvironmentD1Ev@PLT\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZdlPv@PLT\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE4:\n+\t.size\t_ZN11EnvironmentD0Ev, .-_ZN11EnvironmentD0Ev\n+\t.section\t.text._ZN11EnvironmentC2Ev,\"axG\",@progbits,_ZN11EnvironmentC5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN11EnvironmentC2Ev\n+\t.type\t_ZN11EnvironmentC2Ev, @function\n+_ZN11EnvironmentC2Ev:\n+.LFB8:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t_ZTV11Environment@GOTPCREL(%rip), %rdx\n+\tleaq\t16(%rdx), %rdx\n+\tmovq\t%rdx, (%rax)\n+\tpopq\t%rbp\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE8:\n+\t.size\t_ZN11EnvironmentC2Ev, .-_ZN11EnvironmentC2Ev\n+\t.weak\t_ZN11EnvironmentC1Ev\n+\t.set\t_ZN11EnvironmentC1Ev,_ZN11EnvironmentC2Ev\n+\t.section\t.text._ZN15EnvironmentImplC2Ev,\"axG\",@progbits,_ZN15EnvironmentImplC5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplC2Ev\n+\t.type\t_ZN15EnvironmentImplC2Ev, @function\n+_ZN15EnvironmentImplC2Ev:\n+.LFB10:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZN11EnvironmentC2Ev@PLT\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t_ZTV15EnvironmentImpl@GOTPCREL(%rip), %rdx\n+\tleaq\t16(%rdx), %rdx\n+\tmovq\t%rdx, (%rax)\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE10:\n+\t.size\t_ZN15EnvironmentImplC2Ev, .-_ZN15EnvironmentImplC2Ev\n+\t.weak\t_ZN15EnvironmentImplC1Ev\n+\t.set\t_ZN15EnvironmentImplC1Ev,_ZN15EnvironmentImplC2Ev\n+\t.text\n+\t.align 2\n+\t.globl\t_ZN11Environment6CreateEv\n+\t.type\t_ZN11Environment6CreateEv, @function\n+_ZN11Environment6CreateEv:\n+.LFB5:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tpushq\t%rbx\n+\tsubq\t$8, %rsp\n+\t.cfi_offset 3, -24\n+\tmovl\t$8, %edi\n+\tcall\t_Znwm@PLT\n+\tmovq\t%rax, %rbx\n+\tmovq\t$0, (%rbx)\n+\tmovq\t%rbx, %rdi\n+\tcall\t_ZN15EnvironmentImplC1Ev@PLT\n+\tmovq\t%rbx, %rax\n+\taddq\t$8, %rsp\n+\tpopq\t%rbx\n+\tpopq\t%rbp\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE5:\n+\t.size\t_ZN11Environment6CreateEv, .-_ZN11Environment6CreateEv\n+\t.section\t.rodata\n+.LC0:\n+\t.string\t\"%p\\n\"\n+\t.text\n+\t.globl\tmain\n+\t.type\tmain, @function\n+main:\n+.LFB12:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t$0, -8(%rbp)\n+\tcall\t_ZN11Environment6CreateEv@PLT\n+\tmovq\t%rax, -16(%rbp)\n+\tmovq\t-16(%rbp), %rax\n+\tmovq\t(%rax), %rax\n+\tmovq\t%rax, %rsi\n+\tleaq\t_ZN4_VTVI11EnvironmentE12__vtable_mapE(%rip), %rdi\n+\tcall\t_Z24__VLTVerifyVtablePointerPPvPKv@PLT\n+\taddq\t$16, %rax\n+\tmovq\t(%rax), %rax\n+\tmovq\t-8(%rbp), %rdx\n+\tmovq\t-16(%rbp), %rcx\n+\tmovl\t$0, %esi\n+\tmovq\t%rcx, %rdi\n+\tcall\t*%rax\n+\tmovq\t-16(%rbp), %rax\n+\tmovq\t%rax, %rsi\n+\tleaq\t.LC0(%rip), %rdi\n+\tmovl\t$0, %eax\n+\tcall\tprintf@PLT\n+\tmovl\t$0, %eax\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE12:\n+\t.size\tmain, .-main\n+\t.weak\t_ZTV11Environment\n+\t.section\t.data.rel.ro._ZTV11Environment,\"awG\",@progbits,_ZTV11Environment,comdat\n+\t.align 32\n+\t.type\t_ZTV11Environment, @object\n+\t.size\t_ZTV11Environment, 40\n+_ZTV11Environment:\n+\t.quad\t0\n+\t.quad\t_ZTI11Environment\n+\t.quad\t_ZN11EnvironmentD1Ev\n+\t.quad\t_ZN11EnvironmentD0Ev\n+\t.quad\t__cxa_pure_virtual\n+\t.weak\t_ZTV15EnvironmentImpl\n+\t.section\t.data.rel.ro._ZTV15EnvironmentImpl,\"awG\",@progbits,_ZTV15EnvironmentImpl,comdat\n+\t.align 32\n+\t.type\t_ZTV15EnvironmentImpl, @object\n+\t.size\t_ZTV15EnvironmentImpl, 40\n+_ZTV15EnvironmentImpl:\n+\t.quad\t0\n+\t.quad\t_ZTI15EnvironmentImpl\n+\t.quad\t_ZN15EnvironmentImplD1Ev\n+\t.quad\t_ZN15EnvironmentImplD0Ev\n+\t.quad\t_ZN15EnvironmentImpl6GetVarEPKcPc\n+\t.section\t.text._ZN15EnvironmentImplD2Ev,\"axG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplD2Ev\n+\t.type\t_ZN15EnvironmentImplD2Ev, @function\n+_ZN15EnvironmentImplD2Ev:\n+.LFB14:\n+\t.cfi_startproc\n+\t.cfi_personality 0x9b,DW.ref.__gxx_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA14\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t_ZTV15EnvironmentImpl@GOTPCREL(%rip), %rdx\n+\tleaq\t16(%rdx), %rdx\n+\tmovq\t%rdx, (%rax)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+.LEHB0:\n+\tcall\t_ZN11EnvironmentD2Ev@PLT\n+.LEHE0:\n+\tmovl\t$0, %eax\n+\ttestl\t%eax, %eax\n+\tje\t.L19\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZdlPv@PLT\n+\tjmp\t.L19\n+.L18:\n+\tmovq\t%rax, %rdi\n+.LEHB1:\n+\tcall\t_Unwind_Resume@PLT\n+.LEHE1:\n+.L19:\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE14:\n+\t.globl\t__gxx_personality_v0\n+\t.section\t.gcc_except_table._ZN15EnvironmentImplD2Ev,\"aG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+.LLSDA14:\n+\t.byte\t0xff\n+\t.byte\t0xff\n+\t.byte\t0x1\n+\t.uleb128 .LLSDACSE14-.LLSDACSB14\n+.LLSDACSB14:\n+\t.uleb128 .LEHB0-.LFB14\n+\t.uleb128 .LEHE0-.LEHB0\n+\t.uleb128 .L18-.LFB14\n+\t.uleb128 0\n+\t.uleb128 .LEHB1-.LFB14\n+\t.uleb128 .LEHE1-.LEHB1\n+\t.uleb128 0\n+\t.uleb128 0\n+.LLSDACSE14:\n+\t.section\t.text._ZN15EnvironmentImplD2Ev,\"axG\",@progbits,_ZN15EnvironmentImplD5Ev,comdat\n+\t.size\t_ZN15EnvironmentImplD2Ev, .-_ZN15EnvironmentImplD2Ev\n+\t.weak\t_ZN15EnvironmentImplD1Ev\n+\t.set\t_ZN15EnvironmentImplD1Ev,_ZN15EnvironmentImplD2Ev\n+\t.section\t.text._ZN15EnvironmentImplD0Ev,\"axG\",@progbits,_ZN15EnvironmentImplD0Ev,comdat\n+\t.align 2\n+\t.weak\t_ZN15EnvironmentImplD0Ev\n+\t.type\t_ZN15EnvironmentImplD0Ev, @function\n+_ZN15EnvironmentImplD0Ev:\n+.LFB16:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tsubq\t$16, %rsp\n+\tmovq\t%rdi, -8(%rbp)\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZN15EnvironmentImplD1Ev@PLT\n+\tmovq\t-8(%rbp), %rax\n+\tmovq\t%rax, %rdi\n+\tcall\t_ZdlPv@PLT\n+\tleave\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE16:\n+\t.size\t_ZN15EnvironmentImplD0Ev, .-_ZN15EnvironmentImplD0Ev\n+\t.weak\t_ZTS15EnvironmentImpl\n+\t.section\t.rodata._ZTS15EnvironmentImpl,\"aG\",@progbits,_ZTS15EnvironmentImpl,comdat\n+\t.align 16\n+\t.type\t_ZTS15EnvironmentImpl, @object\n+\t.size\t_ZTS15EnvironmentImpl, 18\n+_ZTS15EnvironmentImpl:\n+\t.string\t\"15EnvironmentImpl\"\n+\t.weak\t_ZTI15EnvironmentImpl\n+\t.section\t.data.rel.ro._ZTI15EnvironmentImpl,\"awG\",@progbits,_ZTI15EnvironmentImpl,comdat\n+\t.align 16\n+\t.type\t_ZTI15EnvironmentImpl, @object\n+\t.size\t_ZTI15EnvironmentImpl, 24\n+_ZTI15EnvironmentImpl:\n+\t.quad\t_ZTVN10__cxxabiv120__si_class_type_infoE+16\n+\t.quad\t_ZTS15EnvironmentImpl\n+\t.quad\t_ZTI11Environment\n+\t.weak\t_ZTI11Environment\n+\t.section\t.data.rel.ro._ZTI11Environment,\"awG\",@progbits,_ZTI11Environment,comdat\n+\t.align 16\n+\t.type\t_ZTI11Environment, @object\n+\t.size\t_ZTI11Environment, 16\n+_ZTI11Environment:\n+\t.quad\t_ZTVN10__cxxabiv117__class_type_infoE+16\n+\t.quad\t_ZTS11Environment\n+\t.weak\t_ZTS11Environment\n+\t.section\t.rodata._ZTS11Environment,\"aG\",@progbits,_ZTS11Environment,comdat\n+\t.type\t_ZTS11Environment, @object\n+\t.size\t_ZTS11Environment, 14\n+_ZTS11Environment:\n+\t.string\t\"11Environment\"\n+\t.hidden\t_ZN4_VTVI11EnvironmentE12__vtable_mapE\n+\t.weak\t_ZN4_VTVI11EnvironmentE12__vtable_mapE\n+\t.section\t.vtable_map_vars,\"awG\",@progbits,_ZN4_VTVI11EnvironmentE12__vtable_mapE,comdat\n+\t.align 8\n+\t.type\t_ZN4_VTVI11EnvironmentE12__vtable_mapE, @gnu_unique_object\n+\t.size\t_ZN4_VTVI11EnvironmentE12__vtable_mapE, 8\n+_ZN4_VTVI11EnvironmentE12__vtable_mapE:\n+\t.zero\t8\n+\t.hidden\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\n+\t.weak\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\n+\t.section\t.vtable_map_vars,\"awG\",@progbits,_ZN4_VTVI15EnvironmentImplE12__vtable_mapE,comdat\n+\t.align 8\n+\t.type\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE, @gnu_unique_object\n+\t.size\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE, 8\n+_ZN4_VTVI15EnvironmentImplE12__vtable_mapE:\n+\t.zero\t8\n+\t.section\t.data.rel.ro,\"aw\",@progbits\n+\t.align 16\n+\t.type\t__vptr_array_11Environment, @object\n+\t.size\t__vptr_array_11Environment, 16\n+__vptr_array_11Environment:\n+\t.quad\t_ZTV11Environment+16\n+\t.quad\t_ZTV15EnvironmentImpl+16\n+\t.section\t.rodata\n+\t.align 8\n+.LC1:\n+\t.string\t\"&\"\n+\t.string\t\"\"\n+\t.string\t\"\"\n+\t.ascii\t\"\\224\\tl\\022_ZN4_VTVI11EnvironmentE12__vtable_mapE\"\n+\t.align 8\n+.LC2:\n+\t.string\t\"*\"\n+\t.string\t\"\"\n+\t.string\t\"\"\n+\t.ascii\t\"N\\225\\r\\334_ZN4_VTVI15EnvironmentImplE12__vtable_mapE\"\n+\t.text\n+\t.type\t_GLOBAL__sub_I.00099_environment.cc, @function\n+_GLOBAL__sub_I.00099_environment.cc:\n+.LFB17:\n+\t.cfi_startproc\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset 6, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register 6\n+\tleaq\t__vptr_array_11Environment(%rip), %r8\n+\tmovl\t$2, %ecx\n+\tmovl\t$2, %edx\n+\tleaq\t.LC1(%rip), %rsi\n+\tleaq\t_ZN4_VTVI11EnvironmentE12__vtable_mapE(%rip), %rdi\n+\tmovq\t_ZTV15EnvironmentImpl@GOTPCREL(%rip), %rax\n+\tleaq\t16(%rax), %rcx\n+\tmovl\t$1, %edx\n+\tleaq\t.LC2(%rip), %rsi\n+\tleaq\t_ZN4_VTVI15EnvironmentImplE12__vtable_mapE(%rip), %rdi\n+\tcall\t_Z17__VLTRegisterPairPPvPKvmS2_@PLT\n+\tpopq\t%rbp\n+\t.cfi_def_cfa 7, 8\n+\tret\n+\t.cfi_endproc\n+.LFE17:\n+\t.size\t_GLOBAL__sub_I.00099_environment.cc, .-_GLOBAL__sub_I.00099_environment.cc\n+\t.section\t.init_array.00099,\"aw\"\n+\t.align 8\n+\t.quad\t_GLOBAL__sub_I.00099_environment.cc\n+\t.hidden\tDW.ref.__gxx_personality_v0\n+\t.weak\tDW.ref.__gxx_personality_v0\n+\t.section\t.data.DW.ref.__gxx_personality_v0,\"awG\",@progbits,DW.ref.__gxx_personality_v0,comdat\n+\t.align 8\n+\t.type\tDW.ref.__gxx_personality_v0, @object\n+\t.size\tDW.ref.__gxx_personality_v0, 8\n+DW.ref.__gxx_personality_v0:\n+\t.quad\t__gxx_personality_v0\n+\t.ident\t\"GCC: (GNU) 4.9.0 20130616 (experimental)\"\n+\t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "83adf53b601949d839ff4e0e981c8638f1b004b3", "filename": "libvtv/testsuite/environment.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fenvironment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fenvironment.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,37 @@\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+class Environment {\n+ public:\n+  virtual ~Environment();\n+\n+  // Static factory method that returns the implementation that provide the\n+  // appropriate platform-specific instance.\n+  static Environment* Create();\n+\n+  // Gets an environment variable's value and stores it in |result|.\n+  // Returns false if the key is unset.\n+  virtual bool GetVar(const char* variable_name, char* result) = 0;\n+};\n+\n+class EnvironmentImpl : public Environment {\n+ public:\n+  virtual bool GetVar(const char* variable_name, char* result) {\n+      return true;\n+  }\n+};\n+\n+Environment::~Environment() {}\n+\n+// static\n+Environment* Environment::Create() {\n+  return new EnvironmentImpl();\n+}\n+\n+int main()\n+{\n+  char * null = 0;\n+  Environment * env = Environment::Create();\n+  env->GetVar(0, null);\n+  printf(\"%p\\n\", env);\n+}"}, {"sha": "ba9efe11a4dc96704d2d49af0dd16c8b7e720a1c", "filename": "libvtv/testsuite/event-definitions.cc", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-definitions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-definitions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent-definitions.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,10 @@\n+#include \"event.h\"\n+\n+Event::Event()\n+{\n+}\n+\n+Event::~Event()\n+{\n+\n+}"}, {"sha": "b031284893427dc37cb0aebd22556c4c92ef0c70", "filename": "libvtv/testsuite/event-main.cc", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-main.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-main.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent-main.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,13 @@\n+#include \"event-private.h\"\n+\n+template<typename T> void derefIfNotNull(T* ptr)\n+{\n+  if (ptr != 0)\n+    ptr->deref();\n+}\n+\n+int main()\n+{\n+  Event * ev = new Event;\n+  derefIfNotNull(ev);\n+}"}, {"sha": "a27f4697a25d68eeaf46071ad1fc6bf5c9b4c3c7", "filename": "libvtv/testsuite/event-private.cc", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-private.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-private.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent-private.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,10 @@\n+#include \"event-private.h\"\n+\n+PrivateEvent::PrivateEvent()\n+{\n+}\n+\n+PrivateEvent::~PrivateEvent()\n+{\n+\n+}"}, {"sha": "678ab5f68af8909ce22b9faf7a622b03a5b9c15b", "filename": "libvtv/testsuite/event-private.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-private.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent-private.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent-private.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,7 @@\n+#include \"event.h\"\n+\n+class PrivateEvent: public Event {\n+ public:\n+  PrivateEvent();\n+  ~PrivateEvent ();\n+};"}, {"sha": "61e1d7c917265b56761d6bda0a9ce37b05215835", "filename": "libvtv/testsuite/event.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,29 @@\n+class RefCountedBase {\n+protected:\n+  bool derefBase()\n+  {\n+    return true;\n+  }\n+};\n+\n+template<typename T> class RefCounted : public RefCountedBase {\n+public:\n+    void deref()\n+    {\n+        if (derefBase())\n+            delete static_cast<T*>(this);\n+    }\n+\n+protected:\n+  //    RefCounted() { }\n+    ~RefCounted()\n+    {\n+    }\n+};\n+\n+\n+class Event : public RefCounted<Event> {\n+ public:\n+        Event();\n+        virtual ~Event();\n+};"}, {"sha": "83226fdd03f7bfd9dd6e9ee0fe1875f94f779ebe", "filename": "libvtv/testsuite/event.list", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent.list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fevent.list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fevent.list?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1 @@\n+event-main.cc event-definitions.cc event-private.cc\n\\ No newline at end of file"}, {"sha": "b6f34bca02cd35e13ac3d52473c0635190b0d1b8", "filename": "libvtv/testsuite/field-test.cc", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ffield-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ffield-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ffield-test.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,94 @@\n+// Compile with /home/llozano/local2/proj/vtable/gcc-root/usr/local/bin/g++ -m32 -fvtable-verify=std -fpic -rdynamic -Wl,-R,/home/llozano/local2/proj/vtable/gcc-root/usr/local/lib32:./lib32 -I/home/llozano/local2/proj/vtable/vt2/gcc-4_6-mobile-vtable-security//libstdc++-v3/libsupc++ temp_deriv.cc -O0 -ldl -lpthread -Wl,--whole-archive,-lvtv_init,--no-whole-archive,-z,relro -DTPID=0 -g\n+// Look at assembly with: objdump -drl a.out\n+\n+#include <dlfcn.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+static int counter = 0;\n+\n+int i = TPID;\n+struct base\n+{\n+  virtual void inc() { counter += i; }\n+};\n+\n+struct derived: public base\n+{\n+  virtual void inc() { counter += (10*i); }\n+};\n+\n+// We don't use this class. It is just here so that the\n+// compiler does not devirtualize calls to derived::inc()\n+struct derived2: public derived\n+{\n+  virtual void inc() { counter += (20*i); }\n+};\n+\n+/*\n+static base * bp = new base();\n+static derived * dp = new derived();\n+static base * dbp = new derived();\n+*/\n+\n+struct my_struct {\n+  base *bp;\n+  derived *dp;\n+  base *dbp;\n+};\n+\n+typedef void * vtptr;\n+\n+vtptr get_vtptr(void * object_ptr)\n+{\n+  vtptr * object_vtptr_ptr = (vtptr *)object_ptr;\n+  return *object_vtptr_ptr;\n+}\n+\n+void set_vptr(void * object_ptr, vtptr vtp)\n+{\n+  vtptr * object_vtptr_ptr = (vtptr *)object_ptr;\n+  *object_vtptr_ptr = vtp;\n+}\n+\n+// Given 2 pointers to C++ objects (non PODs), exchange the pointers to vtable\n+void exchange_vtptr(void * object1_ptr, void * object2_ptr)\n+{\n+  vtptr object1_vtptr = get_vtptr(object1_ptr);\n+  vtptr object2_vtptr = get_vtptr(object2_ptr);\n+  set_vptr(object1_ptr, object2_vtptr);\n+  set_vptr(object2_ptr, object1_vtptr);\n+}\n+\n+main()\n+{\n+  int prev_counter;\n+\n+  struct my_struct *my_obj = (struct my_struct *) malloc (sizeof (struct my_struct));\n+\n+  my_obj->bp = new base();\n+  my_obj->dp = new derived ();\n+  my_obj->dbp = new derived ();\n+\n+\n+  counter = 0;\n+  my_obj->bp->inc();\n+  my_obj->dp->inc();\n+  my_obj->dbp->inc();\n+  assert(counter == (TPID + 10*TPID + 10*TPID));\n+\n+  prev_counter = counter;\n+  printf(\"before ex bp vptr=%x dp vptr=%x\\n\", get_vtptr(my_obj->bp), get_vtptr(my_obj->dp));\n+  exchange_vtptr(my_obj->bp, my_obj->dp);\n+  printf(\"after ex bp vptr=%x dp vptr=%x\\n\", get_vtptr(my_obj->bp), get_vtptr(my_obj->dp));\n+  my_obj->bp->inc(); // This one should not abort but it is calling the wrong member\n+  assert(counter == (prev_counter + 10*TPID));\n+  printf(\"Pass first attack! Expected!\\n\");\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  my_obj->dp->inc();\n+  printf(\"Pass second attack! SHOULD NOT BE HERE!\\n\");\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  exit(1);\n+}"}, {"sha": "50ed53109bd4b316b140950df5c0029d48a2a1a6", "filename": "libvtv/testsuite/mempool_negative.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fmempool_negative.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fmempool_negative.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fmempool_negative.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,196 @@\n+#include <string.h>\n+#include <assert.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <setjmp.h>\n+\n+#include \"vtv_malloc.h\"\n+\n+volatile static int signal_count = 0;\n+\n+sigjmp_buf before_segv;\n+\n+bool vtv_debug = false;\n+\n+static void\n+handler(int sig, siginfo_t *si, void *unused)\n+{\n+  /*\n+  printf(\"Got SIGSEGV at address: 0x%lx\\n\",\n+         (long) si->si_addr);\n+  */\n+\n+  signal_count++;\n+  /* You are not supposed to longjmp out of a signal handler but it seems\n+     to work for this test case and it simplifies it */\n+  siglongjmp(before_segv, 1);\n+  /* exit(1); */\n+}\n+\n+/* Try to modify the memory pointed by \"s\" but dont actually change the values.\n+   Assumes and verifies the memory to be modified is mprotected */\n+void mempoke(void * s, size_t n)\n+{\n+  volatile char * p = (char *)s;\n+  int ret;\n+\n+  signal_count = 0;\n+  ret = sigsetjmp(before_segv, 1);\n+  if (ret == 0)\n+    p[0] = p[0];\n+  /* printf(\"after first setjmp ret=%d\\n\", ret); */\n+  assert(ret == 1 && signal_count == 1);\n+\n+  ret = sigsetjmp(before_segv, 1);\n+  if (ret == 0)\n+    p[n - 1] = p[n - 1];\n+  /* printf(\"after second setjmp ret=%d\\n\", ret); */\n+  assert(ret == 1 && signal_count == 2);\n+}\n+\n+int main()\n+{\n+  char * ptr;\n+  int size;\n+\n+  /* Set up handler for SIGSEGV. */\n+  struct sigaction sa;\n+  sa.sa_flags = SA_SIGINFO;\n+  sigemptyset(&sa.sa_mask);\n+  sa.sa_sigaction = handler;\n+  if (sigaction(SIGSEGV, &sa, NULL) == -1)\n+    assert(0);\n+\n+  __vtv_malloc_init();\n+\n+  size = 10;\n+\n+  /* Verify not writable after unprotect */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  memset(ptr, 'a', size);\n+  __vtv_malloc_protect();\n+  mempoke(ptr, size);\n+  __vtv_free(ptr);\n+\n+  /* verify not-writable after protect, unprotect */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  memset(ptr, 'a', size);\n+  __vtv_malloc_protect();\n+  __vtv_malloc_unprotect();\n+  memset(ptr, 'a', size);\n+  assert(ptr[size - 1] == 'a');\n+  __vtv_malloc_protect();\n+  assert(ptr[size - 1] == 'a');\n+  mempoke(ptr,size);\n+  __vtv_free(ptr);\n+\n+  /* Allocate a bunch of small objects.\n+     Make sure the alignment is correct.\n+     Verify data has not been corrupted.\n+     Make sure the data cannot modified */\n+  {\n+    int s;\n+    for (s = 3; s < 28; s += 3)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS 1000\n+        char * ptrs[ITERS];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS; i++)\n+        {\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, (i & 127), size);\n+          assert(ptr[size - 1] == (i & 127));\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        for (i = 0; i < ITERS; i++)\n+          mempoke(ptrs[i], size);\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS; i++)\n+          __vtv_free(ptrs[i]);\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  /* Allocate a bunch of medium size objects.\n+     Make sure the alignment is correct.\n+     Verify data has not been corrupted.\n+     Try to modify the data to verify everything gets unprotected */\n+  {\n+    int s;\n+    for (s = 501; s < 2500; s += 91)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS2 100\n+        char * ptrs[ITERS2];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS2; i++)\n+        {\n+\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, i & 127, size);\n+          assert(ptr[size - 1] == i & 127);\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        for (i = 0; i < ITERS2; i++)\n+          mempoke(ptrs[i], size);\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS2; i++)\n+          __vtv_free(ptrs[i]);\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  /* Allocate a bunch of medium size objects. Make sure the alignment is correct */\n+  {\n+    int s;\n+    for (s = 3001; s < 15000; s += 307)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS3 50\n+        char * ptrs[ITERS3];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS3; i++)\n+        {\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, i & 127, size);\n+          assert(ptr[size - 1] == i & 127);\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        for (i = 0; i < ITERS3; i++)\n+          mempoke(ptrs[i], size);\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS3; i++)\n+          __vtv_free(ptrs[i]);\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  return 0;\n+}"}, {"sha": "511f50a1040bf3a00902c6a1555934968c20e25d", "filename": "libvtv/testsuite/mempool_positive.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fmempool_positive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fmempool_positive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fmempool_positive.c?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,196 @@\n+#include <string.h>\n+#include <assert.h>\n+#include <signal.h>\n+#include <stdio.h>\n+\n+#include \"vtv_malloc.h\"\n+\n+bool vtv_debug = false;\n+\n+static void\n+handler(int sig, siginfo_t *si, void *unused)\n+{\n+  printf(\"Got SIGSEGV at address: 0x%lx\\n\",\n+         (long) si->si_addr);\n+  exit(1);\n+}\n+\n+int memchk(const void * s, int c, size_t n)\n+{\n+  const char * p = (const char *)s;\n+  for (; p < ((char *)s + n); p++)\n+    if (*p != c)\n+      return 1;\n+  return 0;\n+}\n+\n+int main()\n+{\n+  char * ptr;\n+  int size;\n+\n+  /* Set up handler for SIGSEGV. In this test case, we should never hit any SIGSEGV */\n+  struct sigaction sa;\n+  sa.sa_flags = SA_SIGINFO;\n+  sigemptyset(&sa.sa_mask);\n+  sa.sa_sigaction = handler;\n+  if (sigaction(SIGSEGV, &sa, NULL) == -1)\n+    assert(0);\n+\n+  __vtv_malloc_init();\n+\n+  size = 10;\n+\n+  /* Verify simple allocation and deallocation */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  __vtv_malloc_protect();\n+  __vtv_free(ptr);\n+\n+  /* Verify writable after unprotect */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  memset(ptr, 'a', size);\n+  __vtv_malloc_protect();\n+  __vtv_free(ptr);\n+\n+  /* verify readable after protect */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  memset(ptr, 'a', size);\n+  __vtv_malloc_protect();\n+  assert(ptr[size - 1] == 'a');\n+  __vtv_free(ptr);\n+\n+  /* verify writable after protect, unprotect */\n+  __vtv_malloc_unprotect();\n+  ptr = (char *)__vtv_malloc(size);\n+  memset(ptr, 'a', size);\n+  __vtv_malloc_protect();\n+  __vtv_malloc_unprotect();\n+  memset(ptr, 'a', size);\n+  assert(ptr[size - 1] == 'a');\n+  __vtv_malloc_protect();\n+  assert(ptr[size - 1] == 'a');\n+  __vtv_free(ptr);\n+\n+  /* Allocate a bunch of small objects.\n+     Make sure the alignment is correct.\n+     Verify data has not been corrupted.\n+     Try to modify the data to verify everything gets unprotected */\n+  {\n+    int s;\n+    for (s = 3; s < 28; s += 3)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS 1000\n+        char * ptrs[ITERS];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS; i++)\n+        {\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, (i & 127), size);\n+          assert(ptr[size - 1] == (i & 127));\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS; i++)\n+        {\n+          if (memchk(ptrs[i], i & 127, size) != 0)\n+            assert(0);\n+          memset(ptrs[i], (i + 1) & 127, size);\n+          if (memchk(ptrs[i], (i + 1) & 127, size) != 0)\n+            assert(0);\n+          __vtv_free(ptrs[i]);\n+        }\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  /* Allocate a bunch of medium size objects.\n+     Make sure the alignment is correct.\n+     Verify data has not been corrupted.\n+     Try to modify the data to verify everything gets unprotected */\n+  {\n+    int s;\n+    for (s = 501; s < 2500; s += 91)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS2 100\n+        char * ptrs[ITERS2];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS2; i++)\n+        {\n+\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, i & 127, size);\n+          assert(ptr[size - 1] == i & 127);\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS2; i++)\n+        {\n+          if (memchk(ptrs[i], i & 127, size) != 0)\n+            assert(0);\n+          memset(ptrs[i], (i + 1) & 127, size);\n+          if (memchk(ptrs[i], (i + 1) & 127, size) != 0)\n+            assert(0);\n+          __vtv_free(ptrs[i]);\n+        }\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  /* Allocate a bunch of medium size objects. Make sure the alignment is correct */\n+  {\n+    int s;\n+    for (s = 3001; s < 15000; s += 307)\n+    {\n+      size = s;\n+      {\n+        int i;\n+        #define ITERS3 50\n+        char * ptrs[ITERS3];\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS3; i++)\n+        {\n+          ptr = (char *)__vtv_malloc(size);\n+          assert(((long)ptr & VTV_ALIGNMENT_MASK) == 0);\n+          memset(ptr, i & 127, size);\n+          assert(ptr[size - 1] == i & 127);\n+          ptrs[i] = ptr;\n+        }\n+        __vtv_malloc_protect();\n+\n+        __vtv_malloc_unprotect();\n+        for (i = 0; i < ITERS3; i++)\n+        {\n+          if (memchk(ptrs[i], i & 127, size) != 0)\n+            assert(0);\n+          memset(ptrs[i], (i + 1) & 127, size);\n+          if (memchk(ptrs[i], (i + 1) & 127, size) != 0)\n+            assert(0);\n+          __vtv_free(ptrs[i]);\n+        }\n+        __vtv_malloc_protect();\n+      }\n+    }\n+  }\n+\n+  return 0;\n+}"}, {"sha": "13d7143edf86573e653d92d395b541c80cf88cc4", "filename": "libvtv/testsuite/nested_vcall_test.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fnested_vcall_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fnested_vcall_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fnested_vcall_test.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,76 @@\n+\n+class EtherCtrl {\n+ protected:\n+  int ssap;\n+\n+ public:\n+  EtherCtrl(void);\n+  ~EtherCtrl();\n+  virtual int getSsap(void) const;\n+  virtual void setSsap(int);\n+};\n+\n+class EtherFrameWithLLC {\n+ protected:\n+  int ssap;\n+\n+ public:\n+  EtherFrameWithLLC(const char *, int);\n+  ~EtherFrameWithLLC();\n+  virtual int getSsap(void) const;\n+  virtual void setSsap(int);\n+};\n+\n+\n+EtherCtrl::EtherCtrl()\n+{\n+  this->ssap = 0;\n+}\n+\n+EtherCtrl::~EtherCtrl()\n+{\n+}\n+\n+int EtherCtrl::getSsap() const\n+{\n+  return ssap;\n+}\n+\n+void EtherCtrl::setSsap(int ssap)\n+{\n+  this->ssap = ssap;\n+}\n+\n+EtherFrameWithLLC::EtherFrameWithLLC(const char *name, int kind)\n+{\n+  this->ssap = 0;\n+}\n+\n+EtherFrameWithLLC::~EtherFrameWithLLC()\n+{\n+}\n+\n+int EtherFrameWithLLC::getSsap() const\n+{\n+  return ssap;\n+}\n+\n+void EtherFrameWithLLC::setSsap(int ssap)\n+{\n+  this->ssap = ssap;\n+}\n+\n+\n+int\n+main (int argc, char **argv)\n+{\n+  EtherCtrl *etherctrl = new EtherCtrl ();\n+  EtherFrameWithLLC *frame = new EtherFrameWithLLC (\"test\", 10);\n+  int my_value;\n+\n+  etherctrl->setSsap(43);\n+  frame->setSsap(etherctrl->getSsap());\n+  my_value = frame->getSsap();\n+\n+  return 0;\n+}"}, {"sha": "13d7fdc6e4fad5cfd09068c9287c008346055af2", "filename": "libvtv/testsuite/parts-test-extra-parts-views.cc", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,16 @@\n+#include \"parts-test-extra-parts-views.h\"\n+\n+ExtraPartsViews::ExtraPartsViews ()\n+  : ExtraParts () {\n+}\n+\n+ExtraPartsViews::~ExtraPartsViews () {}\n+\n+void\n+ExtraPartsViews::ToolkitInitialized ()\n+{\n+  /* Do something */\n+  int sum = 0;\n+  for (int i = 0; i < 10; ++i)\n+    sum += i;\n+}"}, {"sha": "0784c0ecdaad9ecca11672090749ce6b76d40a5f", "filename": "libvtv/testsuite/parts-test-extra-parts-views.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-extra-parts-views.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,14 @@\n+#ifndef _EXTRA_PARTS_VIEWS_H_\n+#define _EXTRA_PARTS_VIEWS_H_\n+\n+#include \"parts-test-extra-parts.h\"\n+\n+class ExtraPartsViews : public ExtraParts {\n+ public:\n+  ExtraPartsViews ();\n+  virtual ~ExtraPartsViews ();\n+\n+  virtual void ToolkitInitialized ();\n+};\n+\n+#endif /* _EXTRA_PARTS_VIEWS_H_ */"}, {"sha": "dbd3dbfd8f5b66dddb98d6267dc9c1f302c68cf2", "filename": "libvtv/testsuite/parts-test-extra-parts.cc", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-extra-parts.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,15 @@\n+#include \"parts-test-extra-parts.h\"\n+\n+ExtraParts::ExtraParts () {}\n+\n+ExtraParts::~ExtraParts () {}\n+\n+void\n+ExtraParts::ToolkitInitialized ()\n+{\n+}\n+\n+void\n+ExtraParts::PreEarlyInitialization ()\n+{\n+}"}, {"sha": "4ed2a4ce1a01d642645d01f76d165e49c3fc96ae", "filename": "libvtv/testsuite/parts-test-extra-parts.h", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-extra-parts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-extra-parts.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,13 @@\n+#ifndef _EXTRA_PARTS_H_\n+#define _EXTRA_PARTS_H_\n+\n+class ExtraParts {\n+ public:\n+  ExtraParts ();\n+  virtual ~ExtraParts ();\n+\n+  virtual void PreEarlyInitialization ();\n+  virtual void ToolkitInitialized ();\n+};\n+\n+#endif /* _EXTRA_PARTS_H_ */"}, {"sha": "c90901e79197bfa49699bbb97f8894d26549f99e", "filename": "libvtv/testsuite/parts-test-main.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-main.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-main.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-main.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,37 @@\n+#include \"parts-test-main.h\"\n+#include \"parts-test-extra-parts-views.h\"\n+\n+MainParts::MainParts () {}\n+\n+MainParts::~MainParts ()\n+{\n+  for (int i = static_cast<int>(main_extra_parts_.size()) - 1; i >= 0; --i)\n+    delete main_extra_parts_[i];\n+  main_extra_parts_.clear();\n+}\n+\n+void\n+MainParts::AddParts (ExtraParts *parts)\n+{\n+  main_extra_parts_.push_back (parts);\n+}\n+\n+\n+void\n+MainParts::PreEarlyInitialization (void) \n+{\n+  for (int i = 0; i < main_extra_parts_.size(); ++i)\n+    main_extra_parts_[i]->PreEarlyInitialization ();\n+}\n+\n+\n+int\n+main (int argc, char **argv)\n+{\n+  MainParts *main_parts = new MainParts ();\n+\n+  main_parts->AddParts (new ExtraPartsViews ());\n+  main_parts->PreEarlyInitialization ();\n+\n+  return 0;\n+}"}, {"sha": "fb631dec340c06d512e8258815c7f571234eadc0", "filename": "libvtv/testsuite/parts-test-main.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-main.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test-main.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test-main.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,15 @@\n+#include <vector>\n+\n+class ExtraParts;\n+\n+class MainParts {\n+ public:\n+  MainParts ();\n+  virtual ~MainParts ();\n+  virtual void AddParts (ExtraParts *parts);\n+\n+  virtual void PreEarlyInitialization ();\n+\n+ protected:\n+  std::vector<ExtraParts *> main_extra_parts_;\n+};"}, {"sha": "fdf95a8876c5aad31f2f644c702ce8cc91b43354", "filename": "libvtv/testsuite/parts-test.list", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test.list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fparts-test.list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fparts-test.list?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1 @@\n+parts-test-main.cc parts-test-extra-parts.cc parts-test-extra-parts-views.cc"}, {"sha": "4f56a3d730fb14c4de14bf2a8275ba1e8cc01988", "filename": "libvtv/testsuite/povray-derived.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fpovray-derived.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fpovray-derived.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fpovray-derived.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,72 @@\n+// Small test case from povray, see if it reproduces.\n+\n+#include <stdio.h>\n+\n+class POVMS_MessageReceiver\n+{\n+\n+private:\n+   int x;\n+   class Handler\n+   {\n+      public:\n+         virtual void print() = 0;\n+   };\n+protected:\n+   template<class T> class MemberHandler : public Handler\n+   {\n+   public:\n+      MemberHandler(T *xx)\n+      {\n+        x = xx;\n+      }\n+         \n+      ~MemberHandler() {}\n+    \n+      void print()\n+      {\n+         printf(\"In print\\n\");\n+      }\n+  private:\n+      T *x;\n+   };\n+\n+private:\n+   struct HandlerNode\n+   {\n+      Handler *handler;\n+   };\n+\n+   HandlerNode *receiver;\n+public:\n+   POVMS_MessageReceiver(int xx) : x(xx) {}\n+   ~POVMS_MessageReceiver() {}\n+\n+   void foo(int *xx);\n+   void try_call();\n+};\n+\n+void POVMS_MessageReceiver::foo(int *xx)\n+{\n+   receiver = new HandlerNode;\n+\n+   receiver->handler = new MemberHandler<int>(xx);\n+}\n+\n+void POVMS_MessageReceiver::try_call()\n+{\n+   receiver->handler->print();\n+}\n+\n+\n+int main()\n+{\n+   int loc = 34;\n+   POVMS_MessageReceiver a_test(100);\n+\n+   a_test.foo(&loc);\n+   a_test.try_call();\n+}\n+\n+\n+"}, {"sha": "0759c472df15f384e2c152293cc59164dae37b31", "filename": "libvtv/testsuite/register_pair.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fregister_pair.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,39 @@\n+#include \"vtv_utils.h\"\n+#include \"vtv_rts.h\"\n+\n+/* This configuration will test mostly inserting of elements that are already inserted since \n+   the number of repeats is 200 */\n+\n+#define NUM_MAPS 4000\n+#define ELEMENTS_PER_MAP 100\n+#define NUM_REPEATS 200\n+\n+/* This variable has to be put in rel.ro */\n+void * maps[NUM_MAPS] VTV_PROTECTED_VAR;\n+\n+struct fake_vt {\n+  void * fake_vfp [4];\n+};\n+void * fake_vts [NUM_MAPS * ELEMENTS_PER_MAP];\n+\n+int main()\n+{\n+  __VLTChangePermission(__VLTP_READ_WRITE);\n+\n+  for (int k = 0; k < NUM_REPEATS; k++)\n+    {\n+      int curr_fake_vt = 0;\n+      for (int i = 0; i < NUM_MAPS; i++)\n+\tfor (int j = 0; j < ELEMENTS_PER_MAP; j++)\n+\t  {\n+#ifdef VTV_DEBUG\n+\t    __VLTRegisterPairDebug(&maps[i], &fake_vts[curr_fake_vt]);\n+#endif\n+\t    curr_fake_vt++;\n+\t  }\n+    }\n+\n+  __VLTChangePermission(__VLTP_READ_ONLY);\n+  \n+  return 0;\n+}"}, {"sha": "72d6d9684653df73a59e55c0c792f4bc046be03d", "filename": "libvtv/testsuite/register_pair_inserts.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_inserts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_inserts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fregister_pair_inserts.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,46 @@\n+#include \"vtv_utils.h\"\n+#include \"vtv_rts.h\"\n+\n+/* This configuration will test mostly inserting of new elements since \n+   the number of repeats is 1. It should also do a lot of rehashing */\n+\n+/* This test case may fail depending on the system configuration.\n+   Check the value of  /proc/sys/vm/max_map_count and fix by doing\n+   Ex: sudo sh -c  \"echo 131060 > /proc/sys/vm/max_map_count\" */\n+\n+#define NUM_MAPS 40000\n+#define ELEMENTS_PER_MAP 100\n+#define NUM_REPEATS 1\n+\n+/* This variable has to be put in rel.ro */\n+void * maps[NUM_MAPS] VTV_PROTECTED_VAR;\n+\n+struct fake_vt {\n+  void * fake_vfp [4];\n+};\n+void * fake_vts [NUM_MAPS * ELEMENTS_PER_MAP];\n+\n+\n+int main()\n+{\n+  __VLTChangePermission(__VLTP_READ_WRITE);\n+\n+  for (int k = 0; k < NUM_REPEATS; k++)\n+    {\n+      int curr_fake_vt = 0;\n+      for (int i = 0; i < NUM_MAPS; i++)\n+\tfor (int j = 0; j < ELEMENTS_PER_MAP; j++)\n+\t  {\n+#ifdef VTV_DEBUG\n+\t    __VLTRegisterPairDebug(&maps[i], &fake_vts[curr_fake_vt], 0, 0, 0, 0);\n+#else\n+\t    __VLTRegisterPair(&maps[i], &fake_vts[curr_fake_vt]);\n+#endif\n+\t    curr_fake_vt++;\n+\t  }\n+    }\n+\n+  __VLTChangePermission(__VLTP_READ_ONLY);\n+\n+  return 0;\n+}"}, {"sha": "a79dc1f9196d07ce66d7a7a095292e0a4a80e46c", "filename": "libvtv/testsuite/register_pair_inserts_mt.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_inserts_mt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_inserts_mt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fregister_pair_inserts_mt.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,100 @@\n+#include \"vtv_utils.h\"\n+#include \"vtv_rts.h\"\n+#include \"pthread.h\"\n+#include <stdio.h>\n+\n+\n+/* Multi-threaded test for calls to RegisterPair */\n+\n+/* This configuration will test mostly inserting of new elements since \n+   the number of repeats is 1. It should also do a lot of rehashing */\n+\n+/* This test case may fail depending on the system configuration.\n+   Check the value of  /proc/sys/vm/max_map_count and fix by doing\n+   Ex: sudo sh -c  \"echo 131060 > /proc/sys/vm/max_map_count\" */\n+\n+#define NUM_MAPS 2000\n+#define ELEMENTS_PER_MAP 100\n+#define NUM_REPEATS 1\n+\n+#define NUM_THREADS 9\n+\n+/* This variable has to be put in rel.ro */\n+void * volatile maps[NUM_MAPS] VTV_PROTECTED_VAR;\n+\n+struct fake_vt {\n+  void * fake_vfp [4];\n+};\n+void * fake_vts [NUM_MAPS * ELEMENTS_PER_MAP];\n+\n+volatile int current_map = -1;\n+volatile int threads_completed_it = 0;\n+\n+void * do_register_pairs(void *)\n+{\n+  for (int k = 0; k < NUM_REPEATS; k++)\n+    {\n+      int curr_fake_vt = 0;\n+      for (int i = 0; i < NUM_MAPS; i++)\n+\t{\n+\t  while (current_map < (k*NUM_MAPS + i))\n+\t    ;\n+\n+\t  __VLTChangePermission(__VLTP_READ_WRITE);\n+\n+\t  for (int j = 0; j < ELEMENTS_PER_MAP; j++)\n+\t    {\n+#ifdef VTV_DEBUG\n+\t      __VLTRegisterPairDebug((void **) &maps[i], &fake_vts[curr_fake_vt], 0, 0, 0, 0);\n+#else\n+\t      __VLTRegisterPair((void **) &maps[i], &fake_vts[curr_fake_vt]);\n+#endif\n+\t      __VLTVerifyVtablePointer((void **) &maps[i],  &fake_vts[curr_fake_vt]);\n+\t      curr_fake_vt++;\n+\t    }\n+\n+\t  __VLTChangePermission(__VLTP_READ_ONLY);\n+\n+\t  int old_value;\n+\t  do {\n+\t    old_value = threads_completed_it;\n+\t  } while (!__sync_bool_compare_and_swap(&threads_completed_it, old_value, old_value + 1));\n+\n+\t  if (old_value == (NUM_THREADS - 1)) // Only one thread will do this.\n+\t    {\n+\t      threads_completed_it = 0;\n+\t      printf(\"%c%d\", 13, current_map + 1);\n+\t      fflush(stdout);\n+\t      current_map++;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+int main()\n+{\n+  pthread_t thread_ids[NUM_THREADS];\n+ \n+  for (int t = 0; t < NUM_THREADS; t++ )\n+    if (pthread_create(&thread_ids[t], NULL, do_register_pairs, NULL) != 0)\n+      {\n+\tprintf(\"failed pthread_create\\n\");\n+\texit(1);\n+      }\n+\n+  current_map = 0; // start the work on the other threads\n+\n+  for (int t = 0; t < NUM_THREADS; t++)\n+    if (pthread_join(thread_ids[t], NULL) != 0)\n+      { \n+\tprintf(\"failed pthread_join\\n\");\n+\texit(2);\n+      }\n+\n+  printf(\"\\n\");\n+\n+  return 0;\n+}"}, {"sha": "e421c4f0d2b85e41940c6aaa5a1392d8194e0ccd", "filename": "libvtv/testsuite/register_pair_mt.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_mt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fregister_pair_mt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fregister_pair_mt.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,102 @@\n+#include \"vtv_utils.h\"\n+#include \"vtv_rts.h\"\n+#include \"pthread.h\"\n+#include <stdio.h>\n+\n+\n+/* Multi-threaded test for calls to RegisterPair */\n+\n+/* This configuration will test mostly inserting of elements that are already inserted since \n+   the number of repeats is 10 */\n+\n+/* This test case may fail depending on the system configuration.\n+   Check the value of  /proc/sys/vm/max_map_count and fix by doing\n+   Ex: sudo sh -c  \"echo 131060 > /proc/sys/vm/max_map_count\" */\n+\n+#define NUM_MAPS 200\n+#define ELEMENTS_PER_MAP 100\n+#define NUM_REPEATS 10\n+\n+#define NUM_THREADS 9\n+\n+/* This variable has to be put in rel.ro */\n+void * volatile maps[NUM_MAPS] VTV_PROTECTED_VAR;\n+\n+struct fake_vt {\n+  void * fake_vfp [4];\n+};\n+void * fake_vts [NUM_MAPS * ELEMENTS_PER_MAP];\n+\n+volatile int current_map = -1;\n+volatile int threads_completed_it = 0;\n+\n+void * do_register_pairs(void *)\n+{\n+  for (int k = 0; k < NUM_REPEATS; k++)\n+    {\n+      int curr_fake_vt = 0;\n+      for (int i = 0; i < NUM_MAPS; i++)\n+\t{\n+\t  while (current_map < (k*NUM_MAPS + i))\n+\t    ;\n+\n+\t  __VLTChangePermission(__VLTP_READ_WRITE);\n+\n+\t  for (int j = 0; j < ELEMENTS_PER_MAP; j++)\n+\t    {\n+#ifdef VTV_DEBUG\n+\t      __VLTRegisterPair((void **) &maps[i], &fake_vts[curr_fake_vt], 0, 0, 0, 0);\n+#else\n+\t      __VLTRegisterPair((void **) &maps[i], &fake_vts[curr_fake_vt]);\n+#endif\n+\t      __VLTVerifyVtablePointer((void **) &maps[i],  &fake_vts[curr_fake_vt]);\n+\t      curr_fake_vt++;\n+\t    }\n+\n+\t  __VLTChangePermission(__VLTP_READ_ONLY);\n+\n+\t  int old_value;\n+\t  do {\n+\t    old_value = threads_completed_it;\n+\t  } while (!__sync_bool_compare_and_swap(&threads_completed_it, old_value, old_value + 1));\n+\n+\t  if (old_value == (NUM_THREADS - 1)) // Only one thread will do this.\n+\t    {\n+\t      threads_completed_it = 0;\n+\t      printf(\"%c%d\", 13, current_map + 1);\n+\t      fflush(stdout);\n+\t      current_map++;\n+\t    }\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+int main()\n+{\n+  pthread_t thread_ids[NUM_THREADS];\n+ \n+  for (int t = 0; t < NUM_THREADS; t++ )\n+    if (pthread_create(&thread_ids[t], NULL, do_register_pairs, NULL) != 0)\n+      {\n+\tprintf(\"failed pthread_create\\n\");\n+\texit(1);\n+      }\n+\n+  current_map = 0; // start the work on the other threads\n+\n+  for (int t = 0; t < NUM_THREADS; t++)\n+    if (pthread_join(thread_ids[t], NULL) != 0)\n+      { \n+\tprintf(\"failed pthread_join\\n\");\n+\texit(2);\n+      }\n+\n+  printf(\"\\n\");\n+\n+\n+  \n+  return 0;\n+}"}, {"sha": "2b4070eec77640212c7aa5b51dbd474e9167c1fc", "filename": "libvtv/testsuite/replace-fail.cc", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Freplace-fail.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Freplace-fail.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Freplace-fail.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,11 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+\n+void __vtv_verify_fail (void **, void*) __attribute__((visibility (\"default\")));\n+\n+void\n+__vtv_verify_fail (void **hash_table, const void *vtbl_ptr)\n+{\n+  fprintf (stdout, \"Executing alternative failure routine.\\n\");\n+}"}, {"sha": "3f0a346f1e8c71b57165a44ba8b6bce9c754fabb", "filename": "libvtv/testsuite/so.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fso.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fso.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fso.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,93 @@\n+#include <dlfcn.h>\n+#include <assert.h>\n+#include <unistd.h>\n+#include <vtv_fail.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+extern \"C\" int sprintf(char *, const char*, ...);\n+\n+static int counter = 0;\n+extern int failures;\n+\n+template <int i> struct base\n+{\n+  virtual char * whoami() {\n+    static char sl[100];\n+    sprintf(sl, \"I am base %d\", i);\n+    return sl;\n+  }\n+  virtual void inc() { counter += i; }\n+};\n+\n+template <int i> struct derived: base<i>\n+{\n+  virtual char * whoami() {\n+    static char sl[100];\n+    sprintf(sl, \"I am derived %d\", i);\n+    return sl;\n+  }\n+  virtual void inc() { counter += (10*i); }\n+};\n+\n+// We don't use this class. It is just here so that the\n+// compiler does not devirtualize calls to derived::inc()\n+template <int i> struct derived2: derived<i>\n+{\n+  virtual void inc() { counter += (20*i); }\n+};\n+\n+static base<TPID> * bp = new base<TPID>();\n+static derived<TPID> * dp = new derived<TPID>();\n+static base<TPID> * dbp = new derived<TPID>();\n+\n+\n+// Given 2 pointers to C++ objects (non PODs), exchange the pointers to vtable\n+static void exchange_vtptr(void * object1_ptr, void * object2_ptr)\n+{\n+  void ** object1_vtptr_ptr = (void **)object1_ptr;\n+  void ** object2_vtptr_ptr = (void **)object2_ptr;\n+  void * object1_vtptr = *object1_vtptr_ptr;\n+  void * object2_vtptr = *object2_vtptr_ptr;\n+  *object1_vtptr_ptr = object2_vtptr;\n+  *object2_vtptr_ptr = object1_vtptr;\n+}\n+\n+#define BUILD_NAME(NAME,ID) NAME##ID\n+#define EXPAND(NAME,X) BUILD_NAME(NAME,X)\n+extern \"C\" void EXPAND(so_entry_,TPID)(void)\n+{\n+  int prev_counter;\n+  int prev_failures;\n+\n+  counter = 0;\n+  bp->inc();\n+  dp->inc();\n+  dbp->inc();\n+  assert(counter == (TPID + 10*TPID + 10*TPID));\n+\n+  prev_counter = counter;\n+  exchange_vtptr(bp, dp);\n+  bp->inc(); // This one should succeed but it is calling the wrong member\n+  if (counter != (prev_counter + 10*TPID))\n+  {\n+    printf(\"TPID=%d whoami=%s wrong counter value prev_counter=%d counter=%d\\n\", TPID, bp->whoami(), prev_counter, counter);\n+    sleep(2);\n+  }\n+  assert(counter == (prev_counter + 10*TPID));\n+  //  printf(\"Pass first attack!\\n\");\n+\n+ // This one should fail verification!. So it should jump to __vtv_verify_fail above.\n+  prev_failures = failures;\n+  dp->inc();\n+  // this code may be executed by multiple threads at the same time. So, just verify the number of failures has\n+  // increased as opposed to check for increase by 1.\n+  assert(failures > prev_failures);\n+  assert(counter == (prev_counter + 10*TPID + TPID));\n+  //  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  //  printf(\"Pass second attack!\\n\");\n+\n+  // restore the vtable pointers to the original state.\n+  // This is very important. For some reason the dlclose is not \"really\" closing the library so when we reopen it we are\n+  // getting the old memory state.\n+  exchange_vtptr(bp, dp);\n+}"}, {"sha": "ca360c0bc9153afd6205c55d79bf6f29f9dd5b44", "filename": "libvtv/testsuite/temp_deriv.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemp_deriv.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,67 @@\n+// Compile with /home/llozano/local2/proj/vtable/gcc-root/usr/local/bin/g++ -m32 -fvtable-verify=std -fpic -rdynamic -Wl,-R,/home/llozano/local2/proj/vtable/gcc-root/usr/local/lib32:./lib32 -I/home/llozano/local2/proj/vtable/vt2/gcc-4_6-mobile-vtable-security//libstdc++-v3/libsupc++ temp_deriv.cc -O0 -ldl -lpthread -Wl,--whole-archive,-lvtv_init,--no-whole-archive,-z,relro -DTPID=0 -g\n+// Look at assembly with: objdump -drl a.out\n+\n+#include <dlfcn.h>\n+#include <assert.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+static int counter = 0;\n+\n+template <int i> struct base\n+{\n+  virtual void inc() { counter += i; }\n+};\n+\n+template <int i> struct derived: base<i>\n+{\n+  virtual void inc() { counter += (10*i); }\n+};\n+\n+// We don't use this class. It is just here so that the\n+// compiler does not devirtualize calls to derived::inc()\n+template <int i> struct derived2: derived<i>\n+{\n+  virtual void inc() { counter += (20*i); }\n+};\n+\n+static base<TPID> * bp = new base<TPID>();\n+static derived<TPID> * dp = new derived<TPID>();\n+static base<TPID> * dbp = new derived<TPID>();\n+\n+// Given 2 pointers to C++ objects (non PODs), exchange the pointers to vtable\n+void exchange_vtptr(void * object1_ptr, void * object2_ptr)\n+{\n+  void ** object1_vtptr_ptr = (void **)object1_ptr;\n+  void ** object2_vtptr_ptr = (void **)object2_ptr;\n+  void * object1_vtptr = *object1_vtptr_ptr;\n+  void * object2_vtptr = *object2_vtptr_ptr;\n+  *object1_vtptr_ptr = object2_vtptr;\n+  *object2_vtptr_ptr = object1_vtptr;\n+}\n+\n+main()\n+{\n+  int prev_counter;\n+\n+  exchange_vtptr(bp, dp);\n+  exchange_vtptr(bp, dp);\n+  exchange_vtptr(bp, dbp);\n+  exchange_vtptr(bp, dbp);\n+\n+  counter = 0;\n+  bp->inc();\n+  dp->inc();\n+  dbp->inc();\n+  assert(counter == (TPID + 10*TPID + 10*TPID));\n+\n+  prev_counter = counter;\n+  exchange_vtptr(bp, dp);\n+  bp->inc(); // This one should succeed but it is calling the wrong member\n+  assert(counter == (prev_counter + 10*TPID));\n+  printf(\"Pass first attack!\\n\");\n+  dp->inc();\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  printf(\"Pass second attack!\\n\");\n+\n+}"}, {"sha": "78b43f8b08b3b2e2806bdf351adbdcc02dd0c1bb", "filename": "libvtv/testsuite/temp_deriv2.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemp_deriv2.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,69 @@\n+// Compile with /home/llozano/local2/proj/vtable/gcc-root/usr/local/bin/g++ -m32 -fvtable-verify=std -fpic -rdynamic -Wl,-R,/home/llozano/local2/proj/vtable/gcc-root/usr/local/lib32:./lib32 -I/home/llozano/local2/proj/vtable/vt2/gcc-4_6-mobile-vtable-security//libstdc++-v3/libsupc++ temp_deriv.cc -O0 -ldl -lpthread -Wl,--whole-archive,-lvtv_init,--no-whole-archive,-z,relro -DTPID=0 -g\n+// Look at assembly with: objdump -drl a.out\n+\n+#include <dlfcn.h>\n+#include <assert.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+static int counter = 0;\n+\n+int i = TPID;\n+struct base\n+{\n+  virtual void inc() { counter += i; }\n+};\n+\n+struct derived: public base\n+{\n+  virtual void inc() { counter += (10*i); }\n+};\n+\n+// We don't use this class. It is just here so that the\n+// compiler does not devirtualize calls to derived::inc()\n+struct derived2: public derived\n+{\n+  virtual void inc() { counter += (20*i); }\n+};\n+\n+static base * bp = new base();\n+static derived * dp = new derived();\n+static base * dbp = new derived();\n+\n+// Given 2 pointers to C++ objects (non PODs), exchange the pointers to vtable\n+void exchange_vtptr(void * object1_ptr, void * object2_ptr)\n+{\n+  typedef void * vtptr;\n+  vtptr * object1_vtptr_ptr = (vtptr *)object1_ptr;\n+  vtptr * object2_vtptr_ptr = (vtptr *)object2_ptr;\n+  vtptr object1_vtptr = *object1_vtptr_ptr;\n+  vtptr object2_vtptr = *object2_vtptr_ptr;\n+  *object1_vtptr_ptr = object2_vtptr;\n+  *object2_vtptr_ptr = object1_vtptr;\n+}\n+\n+main()\n+{\n+  int prev_counter;\n+\n+  exchange_vtptr(bp, dp);\n+  exchange_vtptr(bp, dp);\n+  exchange_vtptr(bp, dbp);\n+  exchange_vtptr(bp, dbp);\n+\n+  counter = 0;\n+  bp->inc();\n+  dp->inc();\n+  dbp->inc();\n+  assert(counter == (TPID + 10*TPID + 10*TPID));\n+\n+  prev_counter = counter;\n+  exchange_vtptr(bp, dp);\n+  bp->inc(); // This one should succeed but it is calling the wrong member\n+  assert(counter == (prev_counter + 10*TPID));\n+  printf(\"Pass first attack!\\n\");\n+  dp->inc();\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  printf(\"Pass second attack!\\n\");\n+\n+}"}, {"sha": "924c47e962810cc5f9d8ee8f34d8bb1af75b8cef", "filename": "libvtv/testsuite/temp_deriv3.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemp_deriv3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemp_deriv3.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,79 @@\n+// Compile with /home/llozano/local2/proj/vtable/gcc-root/usr/local/bin/g++ -m32 -fvtable-verify=std -fpic -rdynamic -Wl,-R,/home/llozano/local2/proj/vtable/gcc-root/usr/local/lib32:./lib32 -I/home/llozano/local2/proj/vtable/vt2/gcc-4_6-mobile-vtable-security//libstdc++-v3/libsupc++ temp_deriv.cc -O0 -ldl -lpthread -Wl,--whole-archive,-lvtv_init,--no-whole-archive,-z,relro -DTPID=0 -g\n+// Look at assembly with: objdump -drl a.out\n+\n+#include <dlfcn.h>\n+#include <assert.h>\n+#include <stdlib.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+static int counter = 0;\n+\n+int i = TPID;\n+struct base\n+{\n+  virtual void inc() { counter += i; }\n+};\n+\n+struct derived: public base\n+{\n+  virtual void inc() { counter += (10*i); }\n+};\n+\n+// We don't use this class. It is just here so that the\n+// compiler does not devirtualize calls to derived::inc()\n+struct derived2: public derived\n+{\n+  virtual void inc() { counter += (20*i); }\n+};\n+\n+static base * bp = new base();\n+static derived * dp = new derived();\n+static base * dbp = new derived();\n+\n+typedef void * vtptr;\n+\n+vtptr get_vtptr(void * object_ptr)\n+{\n+  vtptr * object_vtptr_ptr = (vtptr *)object_ptr;\n+  return *object_vtptr_ptr;\n+}\n+\n+void set_vptr(void * object_ptr, vtptr vtp)\n+{\n+  vtptr * object_vtptr_ptr = (vtptr *)object_ptr;\n+  *object_vtptr_ptr = vtp;\n+}\n+\n+// Given 2 pointers to C++ objects (non PODs), exchange the pointers to vtable\n+void exchange_vtptr(void * object1_ptr, void * object2_ptr)\n+{\n+  vtptr object1_vtptr = get_vtptr(object1_ptr);\n+  vtptr object2_vtptr = get_vtptr(object2_ptr);\n+  set_vptr(object1_ptr, object2_vtptr);\n+  set_vptr(object2_ptr, object1_vtptr);\n+}\n+\n+main()\n+{\n+  int prev_counter;\n+\n+  counter = 0;\n+  bp->inc();\n+  dp->inc();\n+  dbp->inc();\n+  assert(counter == (TPID + 10*TPID + 10*TPID));\n+\n+  prev_counter = counter;\n+  printf(\"before ex bp vptr=%x dp vptr=%x\\n\", get_vtptr(bp), get_vtptr(dp));\n+  exchange_vtptr(bp, dp);\n+  printf(\"after ex bp vptr=%x dp vptr=%x\\n\", get_vtptr(bp), get_vtptr(dp));\n+  bp->inc(); // This one should not abort but it is calling the wrong member\n+  assert(counter == (prev_counter + 10*TPID));\n+  printf(\"Pass first attack! Expected!\\n\");\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  dp->inc();\n+  printf(\"Pass second attack! SHOULD NOT BE HERE!\\n\");\n+  printf(\"TPDI=%d counter %d\\n\", TPID, counter);\n+  exit(1);\n+}"}, {"sha": "a35fd308382dfced51b8b91f1cd42ef29ce76b5a", "filename": "libvtv/testsuite/template-list-iostream.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list-iostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list-iostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemplate-list-iostream.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,118 @@\n+#include <assert.h>\n+#include <iostream>\n+#include <fstream>\n+\n+using std::ofstream;\n+using std::ifstream;\n+using std::ios;\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+class Subscriptor\n+{\n+  public:\n+\n+  Subscriptor() : counter(1) {}\n+\n+  virtual ~Subscriptor()\n+  {\n+    counter--;\n+    assert(counter == 0);\n+  }\n+\n+  private:\n+    mutable int counter;\n+};\n+\n+template <int dim> struct Function\n+{\n+  Function(int i): value(dim + i) {}\n+  int value;\n+};\n+\n+template <int dim> struct Triangulation\n+{\n+\n+};\n+\n+template <int dim> struct Exercise_2_3\n+{\n+  enum { DIM = dim };\n+};\n+\n+  template <int dim>\n+  struct SetUpBase : public Subscriptor\n+  {\n+      virtual\n+      const Function<dim> get_boundary_values () const = 0;\n+\n+      virtual\n+      const Function<dim> get_right_hand_side () const = 0;\n+\n+    //      virtual\n+    //      void create_coarse_grid (Triangulation<dim> &coarse_grid) const = 0;\n+  };\n+\n+  template <class Traits, int dim>\n+  struct SetUp : public SetUpBase<dim>\n+  {\n+      SetUp () {};\n+\n+      virtual\n+      const Function<dim>  get_boundary_values () const\n+    { return Function<dim>(Traits::DIM); }\n+\n+      virtual\n+      const Function<dim>  get_right_hand_side () const\n+    { return Function<dim>(Traits::DIM); }\n+\n+    //      virtual\n+    //      void create_coarse_grid (Triangulation<dim> &coarse_grid) const;\n+\n+    //      static const typename Traits::BoundaryValues boundary_values;\n+    //      static const typename Traits::RightHandSide  right_hand_side;\n+  };\n+\n+\n+void myread(std::istream * in)\n+{\n+  char input_str[50] = \"\\0\";\n+  if (in->good())\n+    (*in) >> input_str;\n+  std::cout << input_str << std::endl;\n+  delete in;\n+}\n+\n+\n+\n+int main()\n+{\n+  /*\n+\n+  SetUp<Exercise_2_3<1000>, 2> s1a;\n+  SetUp<Exercise_2_3<2000>, 1> s2;\n+  SetUp<Exercise_2_3<2000>, 2> s2a;\n+  return s1->get_boundary_values().value + s1a.get_boundary_values().value +\n+      s2.get_boundary_values().value + s2a.get_boundary_values().value +\n+      s1->get_right_hand_side().value + s1a.get_right_hand_side().value +\n+      s2.get_right_hand_side().value + s2a.get_right_hand_side().value;\n+  */\n+\n+  SetUp<Exercise_2_3<1000>, 1> * s1 =  new  SetUp<Exercise_2_3<1000>, 1>();\n+\n+  printf(\"%d\\n\", s1->get_boundary_values().value);\n+\n+  ifstream * infile = new ifstream(\"./template-list-iostream.cc\");\n+\n+  myread(infile);\n+\n+  ofstream * outfile = new ofstream(\"/tmp/xxx.txt\");\n+\n+  if (outfile->good())\n+    (*outfile) << \"hello there\" << std::endl;\n+  std::cerr << \"Reached End\" << std::endl;\n+\n+  delete outfile;\n+\n+  return 0;\n+}"}, {"sha": "95233f87765601b07ae83e4e974bc57af9e96a77", "filename": "libvtv/testsuite/template-list.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemplate-list.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,92 @@\n+#include <assert.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+class Subscriptor\n+{\n+  public:\n+\n+  Subscriptor() : counter(1) {}\n+\n+  virtual ~Subscriptor()\n+  {\n+    counter--;\n+    assert(counter == 0);\n+  }\n+\n+  private:\n+    mutable int counter;\n+};\n+\n+template <int dim> struct Function\n+{\n+  Function(int i): value(dim + i) {}\n+  int value;\n+};\n+\n+template <int dim> struct Triangulation\n+{\n+\n+};\n+\n+template <int dim> struct Exercise_2_3\n+{\n+  enum { DIM = dim };\n+};\n+\n+  template <int dim>\n+  struct SetUpBase : public Subscriptor\n+  {\n+      virtual\n+      const Function<dim> get_boundary_values () const = 0;\n+\n+      virtual\n+      const Function<dim> get_right_hand_side () const = 0;\n+\n+    //      virtual\n+    //      void create_coarse_grid (Triangulation<dim> &coarse_grid) const = 0;\n+  };\n+\n+  template <class Traits, int dim>\n+  struct SetUp : public SetUpBase<dim>\n+  {\n+      SetUp () {};\n+\n+      virtual\n+      const Function<dim>  get_boundary_values () const\n+    { return Function<dim>(Traits::DIM); }\n+\n+      virtual\n+      const Function<dim>  get_right_hand_side () const\n+    { return Function<dim>(Traits::DIM); }\n+\n+    //      virtual\n+    //      void create_coarse_grid (Triangulation<dim> &coarse_grid) const;\n+\n+    //      static const typename Traits::BoundaryValues boundary_values;\n+    //      static const typename Traits::RightHandSide  right_hand_side;\n+  };\n+\n+\n+int main()\n+{\n+  /*\n+\n+  SetUp<Exercise_2_3<1000>, 2> s1a;\n+  SetUp<Exercise_2_3<2000>, 1> s2;\n+  SetUp<Exercise_2_3<2000>, 2> s2a;\n+  return s1->get_boundary_values().value + s1a.get_boundary_values().value +\n+      s2.get_boundary_values().value + s2a.get_boundary_values().value +\n+      s1->get_right_hand_side().value + s1a.get_right_hand_side().value +\n+      s2.get_right_hand_side().value + s2a.get_right_hand_side().value;\n+  */\n+#ifndef NFAIL\n+  SetUp<Exercise_2_3<1000>, 1> * s1 =  new  SetUp<Exercise_2_3<1000>, 1>();\n+  printf(\"%d\\n\", s1->get_boundary_values().value);\n+  return 0;\n+#else\n+  SetUp<Exercise_2_3<1000>, 1> s1;\n+  printf(\"%d\\n\", s1.get_boundary_values().value);\n+  return 0;\n+#endif\n+}"}, {"sha": "f8ec739b6d5112656e739736ab352b55620ca5d3", "filename": "libvtv/testsuite/template-list2.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Ftemplate-list2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Ftemplate-list2.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,44 @@\n+#include <assert.h>\n+\n+extern \"C\" int printf(const char *, ...);\n+\n+class Subscriptor\n+{\n+  public:\n+\n+  Subscriptor()\n+    { counter = 1;}\n+\n+  virtual ~Subscriptor()\n+  {\n+    counter--;\n+    assert(counter == 0);\n+  }\n+\n+  private:\n+    static int counter;\n+};\n+\n+int Subscriptor::counter;\n+\n+template <typename number>\n+class Polynomial : public Subscriptor\n+{\n+};\n+\n+class LagrangeEquidistant: public Polynomial<double>\n+{\n+};\n+\n+template<typename _Tp>\n+inline void\n+_MyDestroy(_Tp* __pointer)\n+  { __pointer->~_Tp(); }\n+\n+int main()\n+{\n+  LagrangeEquidistant * s1 =  new  LagrangeEquidistant;\n+  _MyDestroy(s1);\n+\n+  return 0;\n+}"}, {"sha": "6ab81a0dfd4f620253eeffdc7c71bbbe4cd1d234", "filename": "libvtv/testsuite/thunk.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fthunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fthunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fthunk.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,35 @@\n+#include <assert.h>\n+struct A {\n+  A():value(123) {}\n+    int value;\n+    virtual int access() { return this->value; }\n+};\n+struct B {\n+  B():value(456) {}\n+    int value;\n+    virtual int access() { return this->value; }\n+};\n+struct C : public A, public B {\n+  C():better_value(789) {}\n+    int better_value;\n+    virtual int access() { return this->better_value; }\n+};\n+struct D: public C {\n+  D():other_value(987) {}\n+  int other_value;\n+  virtual int access() { return this->other_value; }\n+};\n+\n+int use(B *b)\n+{\n+    return b->access();\n+}\n+\n+int main()\n+{\n+  C c;\n+  assert(use(&c) == 789);\n+  D d;\n+  assert(use(&d) == 987);\n+  return 0;\n+}"}, {"sha": "84d4bbf3257fad9f4e65a9aa8e36d9fb18ad7947", "filename": "libvtv/testsuite/thunk_vtable_map_attack.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fthunk_vtable_map_attack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fthunk_vtable_map_attack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fthunk_vtable_map_attack.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,111 @@\n+#include <assert.h>\n+#include <signal.h>\n+#include <setjmp.h>\n+#include <stdio.h>\n+\n+#include <iostream>\n+#include <fstream>\n+\n+using std::ofstream;\n+using std::ifstream;\n+using std::ios;\n+\n+struct A {\n+  A():value(123) {}\n+    int value;\n+    virtual int access() { return this->value; }\n+};\n+struct B {\n+  B():value(456) {}\n+    int value;\n+    virtual int access() { return this->value; }\n+};\n+struct C : public A, public B {\n+  C():better_value(789) {}\n+    int better_value;\n+    virtual int access() { return this->better_value; }\n+};\n+struct D: public C {\n+  D():other_value(987) {}\n+  int other_value;\n+  virtual int access() { return this->other_value; }\n+};\n+\n+volatile static int signal_count = 0;\n+\n+sigjmp_buf before_segv;\n+\n+static void\n+handler(int sig, siginfo_t *si, void *unused)\n+{\n+  /*\n+  printf(\"Got SIGSEGV at address: 0x%lx\\n\",\n+         (long) si->si_addr);\n+  */\n+\n+  signal_count++;\n+  /* You are not supposed to longjmp out of a signal handler but it seems\n+     to work for this test case and it simplifies it */\n+  siglongjmp(before_segv, 1);\n+  /* exit(1); */\n+}\n+\n+/* Access one of the vtable_map variables generated by this .o */\n+extern void * _ZN4_VTVI1BE12__vtable_mapE;\n+\n+/* Access one of the vtable_map variables generated by libstdc++ */\n+extern void * _ZN4_VTVISt8ios_baseE12__vtable_mapE;\n+\n+int use(B *b)\n+{\n+  int ret;\n+\n+  ret = sigsetjmp(before_segv, 1);\n+  if (ret == 0)\n+    {\n+      /* This should generate a segmentation violation. ie: at this point it should \n+\t be protected */\n+      _ZN4_VTVI1BE12__vtable_mapE = 0;\n+    }\n+  assert(ret == 1 && signal_count == 1);\n+\n+  ret = sigsetjmp(before_segv, 1);\n+  if (ret == 0)\n+    {\n+      /* Try to modify one of the vtable_map variables in the stdc++ library.\n+\t This should generate a segmentation violation. ie: at this point it\n+\t should be protected */\n+      _ZN4_VTVISt8ios_baseE12__vtable_mapE = 0;\n+    }\n+  assert(ret == 1 && signal_count == 2);\n+\n+  return b->access();\n+}\n+\n+void myread(std::istream * in)\n+{\n+  char input_str[50] = \"\\0\";\n+  if (in->good())\n+    (*in) >> input_str;\n+  std::cout << input_str << std::endl;\n+  delete in;\n+}\n+\n+int main()\n+{\n+  ifstream * infile = new ifstream(\"./thunk_vtable_map_attack.cpp\");\n+  myread(infile);\n+\n+  /* Set up handler for SIGSEGV. */\n+  struct sigaction sa;\n+  sa.sa_flags = SA_SIGINFO;\n+  sigemptyset(&sa.sa_mask);\n+  sa.sa_sigaction = handler;\n+  if (sigaction(SIGSEGV, &sa, NULL) == -1)\n+    assert(0);\n+\n+  C c;\n+  assert(use(&c) == 789);\n+\n+  return 0;\n+}"}, {"sha": "89fe388a856c7d1a15acbf554518fd7962bd696f", "filename": "libvtv/testsuite/virtual_inheritance.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fvirtual_inheritance.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Ftestsuite%2Fvirtual_inheritance.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Ftestsuite%2Fvirtual_inheritance.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,46 @@\n+#include <assert.h>\n+struct V {\n+  V(): virtual_value(-123) {}\n+  int virtual_value;\n+  virtual int access_vv() { return virtual_value; }\n+};\n+\n+struct A: virtual public V {\n+  A():value(123) {}\n+    int value;\n+    virtual int access() { return value; }\n+};\n+struct B: virtual public V {\n+  B():value(456) {}\n+    int value;\n+    virtual int access() { return value; }\n+};\n+struct C : public A, public B {\n+  C():better_value(789) {}\n+    int better_value;\n+    virtual int access() { return better_value; }\n+};\n+struct D: public A, public B {\n+  D():better_virtual_value(-345) {}\n+  int better_virtual_value;\n+  virtual int access_vv() { return better_virtual_value; }\n+};\n+\n+int use(B *b)\n+{\n+    return b->access();\n+}\n+\n+int v_use(V * v)\n+{\n+  return v->access_vv();\n+}\n+\n+int main()\n+{\n+  C c;\n+  assert(v_use(&c) == -123);\n+  D d;\n+  assert(v_use(&d) == -345);\n+  return 0;\n+}"}, {"sha": "4f183d8cac2f6e37480aa56e92ffa6a254dfca3e", "filename": "libvtv/vtv_fail.cc", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_fail.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_fail.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_fail.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,233 @@\n+/* Copyright (C) 2012-2013\n+ Free Software Foundation\n+\n+ This file is part of GCC.\n+\n+ GCC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 3, or (at your option)\n+ any later version.\n+\n+ GCC is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ Under Section 7 of GPL version 3, you are granted additional\n+ permissions described in the GCC Runtime Library Exception, version\n+ 3.1, as published by the Free Software Foundation.\n+\n+ You should have received a copy of the GNU General Public License and\n+ a copy of the GCC Runtime Library Exception along with this program;\n+ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+ <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable security feature implementation.\n+   The vtable security feature is designed to detect when a virtual\n+   call is about to be made through an invalid vtable pointer\n+   (possibly due to data corruption or malicious attacks).\n+\n+   This file also contains the failure functions that get called when\n+   a vtable pointer is not found in the data set.  Two particularly\n+   important functions are __vtv_verify_fail and __vtv_really_fail.\n+   They are both externally visible.  __vtv_verify_fail is defined in\n+   such a way that it can be replaced by a programmer, if desired.  It\n+   is the function that __VLTVerifyVtablePointer calls if it can't\n+   find the pointer in the data set.  Allowing the programmer to\n+   overwrite this function means that he/she can do some alternate\n+   verification, including NOT failing in certain specific cases, if\n+   desired.  This may be the case if the programmer has to deal wtih\n+   unverified third party software, for example.  __vtv_really_fail is\n+   available for the programmer to call from his version of\n+   __vtv_verify_fail, if he decides the failure is real.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <execinfo.h>\n+#include <unistd.h>\n+\n+#include \"vtv_utils.h\"\n+#include \"vtv_fail.h\"\n+\n+/* This is used to disable aborts for debugging purposes.  */\n+bool vtv_no_abort = false;\n+\n+\n+extern \"C\" {\n+\n+  /* __fortify_fail is a function in glibc that calls __libc_message,\n+     causing it to print out a program termination error message\n+     (including the name of the binary being terminated), a stack\n+     trace where the error occurred, and a memory map dump.  Ideally\n+     we would have called __libc_message directly, but that function\n+     does not appear to be accessible to functions outside glibc,\n+     whereas __fortify_fail is.  We call __fortify_fail from\n+     __vtv_really_fail.  We looked at calling __libc_fatal, which is\n+     externally accessible, but it does not do the back trace and\n+     memory dump.  */\n+\n+  extern void __fortify_fail (const char *) __attribute__((noreturn));\n+\n+} /* extern \"C\" */\n+\n+const unsigned long SET_HANDLE_HANDLE_BIT = 0x2;\n+\n+/* Instantiate the template classes (in vtv_set.h) for our particular\n+   hash table needs.  */\n+typedef void * vtv_set_handle;\n+typedef vtv_set_handle * vtv_set_handle_handle; \n+\n+static int vtv_failures_log_fd = -1;\n+\n+/* Open error logging file, if not already open, and write vtable\n+   verification failure messages (LOG_MSG) to the log file.  Also\n+   generate a backtrace in the log file, if GENERATE_BACKTRACE is\n+   set.  */\n+\n+static void\n+log_error_message (const char *log_msg, bool generate_backtrace)\n+{\n+  if (vtv_failures_log_fd == -1)\n+    vtv_failures_log_fd = vtv_open_log (\"vtable_verification_failures.log\");\n+\n+  if (vtv_failures_log_fd == -1)\n+    return;\n+\n+  vtv_add_to_log (vtv_failures_log_fd, \"%s\", log_msg);\n+\n+  if (generate_backtrace)\n+    {\n+#define STACK_DEPTH 20\n+      void *callers[STACK_DEPTH];\n+      int actual_depth = backtrace (callers, STACK_DEPTH);\n+      backtrace_symbols_fd (callers, actual_depth, vtv_failures_log_fd);\n+    }\n+}\n+\n+/* In the case where a vtable map variable is the only instance of the\n+   variable we have seen, it points directly to the set of valid\n+   vtable pointers.  All subsequent instances of the 'same' vtable map\n+   variable point to the first vtable map variable.  This function,\n+   given a vtable map variable PTR, checks a bit to see whether it's\n+   pointing directly to the data set or to the first vtable map\n+   variable.  */\n+\n+static inline bool\n+is_set_handle_handle (void * ptr)\n+{\n+  return ((unsigned long) ptr & SET_HANDLE_HANDLE_BIT)\n+                                                      == SET_HANDLE_HANDLE_BIT;\n+}\n+\n+/* Returns the actual pointer value of a vtable map variable, PTR (see\n+   comments for is_set_handle_handle for more details).  */\n+\n+static inline vtv_set_handle * \n+ptr_from_set_handle_handle (void * ptr)\n+{\n+  return (vtv_set_handle *) ((unsigned long) ptr & ~SET_HANDLE_HANDLE_BIT);\n+}\n+\n+/* Given a vtable map variable, PTR, this function sets the bit that\n+   says this is the second (or later) instance of a vtable map\n+   variable.  */\n+\n+static inline vtv_set_handle_handle\n+set_handle_handle (vtv_set_handle * ptr)\n+{\n+  return (vtv_set_handle_handle) ((unsigned long) ptr | SET_HANDLE_HANDLE_BIT);\n+}\n+\n+/* This function is called from __VLTVerifyVtablePointerDebug; it\n+   sends as much debugging information as it can to the error log\n+   file, then calls __vtv_verify_fail.  SET_HANDLE_PTR is the pointer\n+   to the set of valid vtable pointers, VTBL_PTR is the pointer that\n+   was not found in the set, and DEBUG_MSG is the message to be\n+   written to the log file before failing. n */\n+\n+void\n+__vtv_verify_fail_debug (void **set_handle_ptr, const void *vtbl_ptr, \n+                         const char *debug_msg)\n+{\n+  log_error_message (debug_msg, false);\n+\n+  /* Call the public interface in case it has been overwritten by\n+     user.  */\n+  __vtv_verify_fail (set_handle_ptr, vtbl_ptr);\n+\n+  log_error_message (\"Returned from __vtv_verify_fail.\"\n+                     \" Secondary verification succeeded.\\n\", false);\n+}\n+\n+/* This function calls __fortify_fail with a FAILURE_MSG and then\n+   calls abort.  */\n+\n+void\n+__vtv_really_fail (const char *failure_msg)\n+{\n+  __fortify_fail (failure_msg);\n+\n+  /* We should never get this far; __fortify_fail calls __libc_message\n+     which prints out a back trace and a memory dump and then is\n+     supposed to call abort, but let's play it safe anyway and call abort\n+     ourselves.  */\n+  abort ();\n+}\n+\n+/* This function takes an error MSG, a vtable map variable\n+   (DATA_SET_PTR) and a vtable pointer (VTBL_PTR).  It is called when\n+   an attempt to verify VTBL_PTR with the set pointed to by\n+   DATA_SET_PTR failed.  It outputs a failure message with the\n+   addresses involved, and calls __vtv_really_fail.  */\n+\n+static void\n+vtv_fail (const char *msg, void **data_set_ptr, const void *vtbl_ptr)\n+{\n+  char buffer[128];\n+  int buf_len;\n+  const char *format_str =\n+                 \"*** Unable to verify vtable pointer (%p) in set (%p) *** \\n\";\n+\n+  snprintf (buffer, sizeof (buffer), format_str, vtbl_ptr,\n+            is_set_handle_handle(*data_set_ptr) ?\n+              ptr_from_set_handle_handle (*data_set_ptr) :\n+\t      *data_set_ptr);\n+  buf_len = strlen (buffer);\n+  /*  Send this to to stderr.  */\n+  write (2, buffer, buf_len);\n+\n+  if (!vtv_no_abort)\n+    __vtv_really_fail (msg);\n+}\n+\n+/* Send information about what we were trying to do when verification\n+   failed to the error log, then call vtv_fail.  This function can be\n+   overwritten/replaced by the user, to implement a secondary\n+   verification function instead.  DATA_SET_PTR is the vtable map\n+   variable used for the failed verification, and VTBL_PTR is the\n+   vtable pointer that was not found in the set.  */\n+\n+void\n+__vtv_verify_fail (void **data_set_ptr, const void *vtbl_ptr)\n+{\n+  char log_msg[256];\n+  snprintf (log_msg, sizeof (log_msg), \"Looking for vtable %p in set %p.\\n\",\n+            vtbl_ptr,\n+            is_set_handle_handle (*data_set_ptr) ?\n+              ptr_from_set_handle_handle (*data_set_ptr) :\n+              *data_set_ptr);\n+  log_error_message (log_msg, false);\n+\n+  const char *format_str =\n+            \"*** Unable to verify vtable pointer (%p) in set (%p) *** \\n\";\n+  snprintf (log_msg, sizeof (log_msg), format_str, vtbl_ptr, *data_set_ptr);\n+  log_error_message (log_msg, false);\n+  log_error_message (\"  Backtrace: \\n\", true);\n+\n+  const char *fail_msg = \"Potential vtable pointer corruption detected!!\\n\";\n+  vtv_fail (fail_msg, data_set_ptr, vtbl_ptr);\n+}\n+"}, {"sha": "30741616a46c9cb41a2eabcf326757f99ab37a1d", "filename": "libvtv/vtv_fail.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_fail.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_fail.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_fail.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2012-2013\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _VTV_FAIL_H\n+#define _VTV_FAIL_H 1\n+\n+/* __vtv_really_fail prints a backtrace and a memory dump, then calls\n+  abort.  It is here for programmers to call, presumably from\n+  __vtv_verify_fail, if they choose to overwrite the standard\n+  __vtv_verify_fail with one of their own.  Programmers should NOT\n+  attempt to rewrite __vtv_really_fail. */\n+\n+extern void\n+__vtv_really_fail (const char *fail_msg)\n+  __attribute__ ((visibility (\"default\"), noreturn, nothrow));\n+\n+/* __vtv_verify_fail is the function that gets called if the vtable\n+  verification code discovers a vtable pointer that it cannot verify\n+  as valid.  Normally __vtv_verify_fail calls __vtv_really_fail.\n+  However programmers can write and link in their own version of\n+  __vtv_verify_fail, if they wish to do some kind of secondary\n+  verification, for example.  The main verification code assumes that\n+  IF __vtv_verify_fail returns, then some kind of secondary\n+  verification was done AND that the secondary verification succeeded,\n+  i.e. that the vtable pointer is actually valid and ok to use.  If\n+  the secondary verification fails, then __vtv_verify_fail should not\n+  return.  */\n+\n+extern void\n+__vtv_verify_fail (void **data_set_ptr, const void *vtbl_pointer)\n+  __attribute__((visibility (\"default\"), nothrow));\n+\n+extern void\n+__vtv_verify_fail_debug (void **data_set_ptr, const void *vtbl_pointer,\n+\t\t\t const char *debug_msg)\n+  __attribute__((visibility (\"default\"), nothrow));\n+\n+#endif /* _VTV_FAIL_H */"}, {"sha": "8aaa636e0e304b7e265affef0e5c3921e7d85cd8", "filename": "libvtv/vtv_malloc.cc", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_malloc.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,267 @@\n+/* Copyright (C) 2012-2013\n+   Free Software Foundation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verification runtime library.  It\n+   contains our memory allocation and deallocation routines, which we\n+   use in order to keep track of the pages in memory in which our sets\n+   of valid vtable pointes are stored.  (We need to know the pages so\n+   we can set the protections on them appropriately).  For more\n+   information about the vtable verification feature, see the comments\n+   in vtv_rts.cc.  We use the existing obstack implementation in our\n+   memory allocation scheme.  */\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+\n+#include \"vtv_utils.h\"\n+#include \"vtv_malloc.h\"\n+#include \"obstack.h\"\n+\n+/* The following variables are used only for debugging and performance tuning\n+   purposes. Therefore they do not need to be \"protected\".  They cannot be used\n+   to attack the vtable verification system and if they become corrupted it will\n+   not affect the correctness or security of any of the rest of the vtable\n+   verification feature.  */\n+\n+unsigned int num_calls_to_mprotect = 0;\n+unsigned int num_pages_protected = 0;\n+unsigned int long long mprotect_cycles = 0;\n+\n+/* Put the following variables in our \".vtable_map_vars\" section so\n+   that they are protected.  They are explicitly unprotected and\n+   protected again by calls to __vtv_unprotect and __vtv_protect */\n+\n+static struct obstack vtv_obstack VTV_PROTECTED_VAR;\n+static void *current_chunk VTV_PROTECTED_VAR = 0;\n+static size_t current_chunk_size VTV_PROTECTED_VAR = 0;\n+static int malloc_initialized VTV_PROTECTED_VAR = 0;\n+\n+/* The function goes through and counts all the pages we have allocated\n+   so far.  It returns the page count.  */\n+\n+int\n+__vtv_count_mmapped_pages (void)\n+{\n+  int count = 0;\n+  struct _obstack_chunk * ci = (struct _obstack_chunk *) current_chunk;\n+  while (ci)\n+    {\n+      count++;\n+      ci = ci->prev;\n+    }\n+\n+  return count;\n+}\n+\n+/* This function goes through all of the pages we have allocated so\n+   far and calls mprotect to change the protections on the pages,\n+   according to the value of PROTECTION_FLAG.  */\n+\n+static void\n+change_protections_on_data_chunks (int protection_flag)\n+{\n+  struct _obstack_chunk *ci;\n+  ci = (struct _obstack_chunk *) current_chunk;\n+\n+  while (ci)\n+    {\n+      /* Initial set up for mprotect call.*/\n+      struct _obstack_chunk *protect_start = ci;\n+      size_t chunk_size;\n+      size_t total_size;\n+      unsigned int num_pages_in_chunk;\n+      char *next_page;\n+      unsigned long long start, end;\n+      int result;\n+\n+\n+      /* As long as the next 'chunk' is adjacent to the current one,\n+         keep going down the list.  */\n+      do\n+        {\n+          chunk_size = (ci->limit - (char *) ci);\n+          total_size = (ci->limit - (char *) protect_start);\n+          num_pages_in_chunk = chunk_size / VTV_PAGE_SIZE;\n+          if (chunk_size % VTV_PAGE_SIZE > 0)\n+            num_pages_in_chunk++;\n+          next_page = (char *) ci + (num_pages_in_chunk * VTV_PAGE_SIZE);\n+          ci = ci->prev;\n+        } while (ci && (char *) ci == next_page);\n+\n+      VTV_DEBUG_ASSERT (((unsigned long) protect_start & (VTV_PAGE_SIZE - 1))\n+                                                                       == 0);\n+\n+      /* Protect the contiguous chunks so far.  */\n+      start = rdtsc ();\n+      result = mprotect (protect_start, total_size, protection_flag);\n+      end = rdtsc ();\n+      mprotect_cycles += end - start;\n+      if (result == -1)\n+        VTV_error ();\n+      num_calls_to_mprotect++;\n+      num_pages_protected += (total_size + VTV_PAGE_SIZE - 1)/ VTV_PAGE_SIZE;\n+    }\n+\n+#ifdef VTV_DEBUG\n+    VTV_malloc_dump_stats ();\n+#endif\n+}\n+\n+/* This function makes all of our allocated pages read-only.  */\n+\n+void\n+__vtv_malloc_protect (void)\n+{\n+  change_protections_on_data_chunks (PROT_READ);\n+}\n+\n+/* This function makes all of our allocated pages read-write.  */\n+\n+void\n+__vtv_malloc_unprotect (void)\n+{\n+  change_protections_on_data_chunks (PROT_READ | PROT_WRITE);\n+}\n+\n+/* Allocates a SIZE-sized chunk of memory that is aligned to a page\n+   boundary.  The amount of memory requested (SIZE) must be a multiple\n+   of the page size.  Note: We must use mmap to allocate the memory;\n+   using malloc here will cause problems.  */\n+\n+static void *\n+obstack_chunk_alloc (size_t size)\n+{\n+  /* Increase size to the next multiple of VTV_PAGE_SIZE.   */\n+  size = (size + (VTV_PAGE_SIZE - 1)) & (~(VTV_PAGE_SIZE - 1));\n+  VTV_DEBUG_ASSERT ((size & (VTV_PAGE_SIZE - 1)) == 0);\n+  void *allocated;\n+\n+  if ((allocated = mmap (NULL, size, PROT_READ | PROT_WRITE,\n+                         MAP_PRIVATE | MAP_ANONYMOUS,  -1, 0)) == 0)\n+    VTV_error ();\n+\n+  VTV_DEBUG_ASSERT (((unsigned long) allocated & (VTV_PAGE_SIZE - 1)) == 0);\n+\n+  current_chunk = allocated;\n+  current_chunk_size = size;\n+  return allocated;\n+}\n+\n+static void\n+obstack_chunk_free (size_t)\n+{\n+  /* Do nothing. For our purposes there should be very little\n+     de-allocation. */\n+}\n+\n+/* This function sets up and initializes the obstack pieces for our\n+   memory allocation scheme.  */\n+\n+void\n+__vtv_malloc_init (void)\n+{\n+  /* Make sure we only execute the main body of this function ONCE.  */\n+  if (malloc_initialized)\n+    return;\n+\n+  if (VTV_PAGE_SIZE != sysconf (_SC_PAGE_SIZE))\n+    VTV_error ();\n+\n+  obstack_chunk_size (&vtv_obstack) = VTV_PAGE_SIZE;\n+  obstack_alignment_mask (&vtv_obstack) = sizeof (long) - 1;\n+  /* We guarantee that the obstack alloc failed handler will never be\n+     called because in case the allocation of the chunk fails, it will\n+     never return */\n+  obstack_alloc_failed_handler = NULL;\n+\n+  obstack_init (&vtv_obstack);\n+  malloc_initialized = 1;\n+}\n+\n+/* This is our external interface for the memory allocation.  SIZE is\n+   the requested number of bytes to be allocated/  */\n+\n+void *\n+__vtv_malloc (size_t size)\n+{\n+  return obstack_alloc (&vtv_obstack, size);\n+}\n+\n+\n+/* This is our external interface for memory deallocation.  */\n+\n+void\n+__vtv_free (void *)\n+{\n+  /* Do nothing. We dont care about recovering unneded memory at this\n+     time.  */\n+}\n+\n+\n+/* This is a debugging function tat collects statistics about our\n+   memory allocation.  */\n+void\n+__vtv_malloc_stats (void)\n+{\n+  int count = 0;\n+  struct _obstack_chunk * ci = (struct _obstack_chunk *) current_chunk;\n+  while (ci)\n+    {\n+      count++;\n+      ci = ci->prev;\n+    }\n+  fprintf (stderr,\n+           \"__vtv_malloc_stats:\\n  Page Size = %lu bytes\\n  \"\n+           \"Number of pages = %d\\n\", static_cast<unsigned long>(VTV_PAGE_SIZE),\n+\t   count);\n+}\n+\n+/* This is a debugging function.  It writes out our memory allocation\n+   statistics to a log file.  */\n+\n+void\n+__vtv_malloc_dump_stats (void)\n+{\n+  static int fd = -1;\n+\n+  if (fd == -1)\n+    fd = __vtv_open_log (\"vtv_mem_protection.log\");\n+  if (fd == -1)\n+    return;\n+\n+  int count = 0;\n+  struct _obstack_chunk * ci = (struct _obstack_chunk *) current_chunk;\n+  while (ci)\n+    {\n+      count++;\n+      ci = ci->prev;\n+    }\n+\n+  __vtv_add_to_log (fd, \"__vtv_malloc_protect protected=%d pages\\n\", count);\n+}"}, {"sha": "55f5fe8022b1ad5646cc4910f52cc1f5e676fc3b", "filename": "libvtv/vtv_malloc.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_malloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_malloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_malloc.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2012-2013\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _VTV_MALLOC_H\n+#define _VTV_MALLOC_H 1\n+\n+#include <stdlib.h>\n+\n+/* Alignment mask for any object returned by the VTV memory pool */\n+#ifdef __LP64__\n+#define VTV_ALIGNMENT_MASK (0x7)\n+#else\n+#define VTV_ALIGNMENT_MASK (0x3)\n+#endif\n+\n+/* The following function is used to instrument the compiler and find\n+   out how many cycles are being spent in various vtable verification\n+   runtime library functions.  */\n+\n+#ifdef __x86_64__\n+static inline unsigned long\n+rdtsc ()\n+{\n+  unsigned long long hi, lo;\n+\n+  asm volatile (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+  return hi << 32 | lo;\n+}\n+#elif defined (__i386__)\n+static inline unsigned long long\n+rdtsc ()\n+{\n+  unsigned long long var;\n+\n+  asm volatile (\"rdtsc\" : \"=A\" (var));\n+\n+  return var;\n+}\n+#else \n+static inline unsigned long long\n+rdtsc ()\n+{\n+  /* Create an empty function for unknown architectures, so that the\n+     calls to this function in vtv_malloc.cc and vtv_rts.cc do not cause\n+     compilation errors.  */\n+  return ((unsigned long long) 0);\n+}\n+#endif\n+\n+\n+/* The following variables are used only for debugging and performance tuning\n+   purposes. Therefore they do not need to be \"protected\".  They cannot be used\n+   to attack the vtable verification system and if they become corrupted it will\n+   not affect the correctness or security of any of the rest of the vtable\n+   verification feature.  */\n+\n+extern unsigned int num_calls_to_mprotect;\n+extern unsigned int num_pages_protected;\n+extern unsigned int num_calls_to_regset;\n+extern unsigned int num_calls_to_regpair;\n+extern unsigned long long mprotect_cycles;\n+extern unsigned long long regset_cycles;\n+extern unsigned long long regpair_cycles;\n+\n+\n+/* Function declarations.  */\n+\n+extern void __vtv_malloc_init (void);\n+extern void *__vtv_malloc (size_t size) __attribute__ ((malloc));\n+extern void __vtv_free (void * ptr);\n+extern void __vtv_malloc_protect (void);\n+extern void __vtv_malloc_unprotect (void);\n+extern void __vtv_malloc_stats (void);\n+extern void __vtv_malloc_dump_stats (void);\n+extern int __vtv_count_mmapped_pages (void);\n+\n+#endif /* vtv_malloc.h */"}, {"sha": "ec058f845f793f636a54b97328a6fbdd132882a4", "filename": "libvtv/vtv_map.h", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_map.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,311 @@\n+/* Copyright (C) 2012-2013\n+   Free Software Foundation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _VTV_MAP_H\n+#define _VTV_MAP_H 1\n+\n+#include <string.h>\n+#include <vtv_utils.h>\n+\n+inline uint64_t\n+load8bytes (const void *p)\n+{\n+  uint64_t result;\n+  memcpy (&result, p, 8);\n+  return result;\n+}\n+\n+/* Insert_only_hash_map maps keys to values.  The implementation is a\n+   basic hash table with open addressing.  The keys are not \"owned\" by\n+   the table; it only stores pointers to keys.  The key type is\n+   specified below (see insert_only_hash_map::key_type) and is,\n+   roughly speaking, a string of any length with the string length and\n+   a hash code stored at the front.  The code here does not compute\n+   any hash codes, but rather uses what's given.  */\n+\n+template<typename T, typename Alloc>\n+class insert_only_hash_map\n+  {\n+    public:\n+      typedef size_t size_type;\n+      typedef T value_type;\n+      typedef Alloc alloc_type;\n+      enum { min_capacity = 4 };\n+#if HASHMAP_STATS\n+  enum { stats = true };\n+#else\n+  enum { stats = false };\n+#endif\n+\n+  /* Keys are a byte string (up to 2^32 - 1 long) plus a uint32_t\n+     that's used as a hash code.  The latter can encode arbitrary\n+     information at the client's discretion, so, e.g., multiple keys\n+     that are the same string still \"differ\" if the hash codes differ.\n+     Keys are equal if the first 8 bytes are equal and the next n\n+     bytes are equal.  */\n+  struct key_type\n+  {\n+    uint32_t n;\n+    uint32_t hash;\n+    char bytes[0];\n+\n+    bool\n+    equals (const key_type *k) const;\n+  };\n+\n+  /* Create an empty map with a reasonable number of buckets for the\n+     expected size.  Returns NULL if the allocator fails.  */\n+\n+  static insert_only_hash_map *\n+  create (size_type expected_size);\n+\n+  /* The opposite of create().  Free the memory for the given map.  */\n+\n+  static void\n+  destroy (insert_only_hash_map *m)\n+  { Alloc().dealloc (m, m->size_in_bytes_); }\n+\n+  /* Return a map identical to this except that *k is mapped to v.\n+     Typcially it's done by modifying this in place, but if a resize\n+     is necessary then this is deallocated and a new map is returned.\n+     Requires k to be non-NULL.  Does nothing and returns NULL if the\n+     allocator fails.  */\n+\n+  insert_only_hash_map*\n+  put (const key_type *k, const value_type &v)\n+  { return this->put_internal (k, v, false); }\n+\n+  /* If *k is a key in this then set *v to point to the corresponding\n+     value.  Otherwise, do the equivalent of insert(k, value_type())\n+     and, if that succeeds, set *v to point to the inserted value.\n+     Requires k to be non-NULL.  Does nothing and returns NULL if the\n+     allocator fails.  Typically returns this, but will return a new\n+     insert_only_hash_map if a resize occurs.  If the return value is\n+     non-NULL, *v is set and it's valid until a resize of the map that\n+     is the return value.  */\n+\n+  insert_only_hash_map *\n+  find_or_add_key (const key_type *k, value_type **v);\n+\n+  /* Get the value corresponding to *k.  Returns NULL if there is\n+     none.  Requires k to be non-NULL.  The return value is valid\n+     until any resize.  */\n+  const value_type *get (const key_type *k) const;\n+\n+  size_type\n+  size () const\n+  { return num_entries_; }\n+\n+  bool\n+  empty () const\n+  { return this->size () == 0; }\n+\n+  size_type\n+  bucket_count () const\n+  { return num_buckets_; }\n+\n+ private:\n+  typedef std::pair <const key_type *, value_type> bucket_type;\n+\n+  insert_only_hash_map *put_internal (const key_type *, const value_type &,\n+\t\t\t\t      bool);\n+\n+  /* This function determines when to resize the table.  */\n+  bool\n+  is_too_full (size_type entries) const\n+  { return entries > (this->bucket_count () * 0.7); }\n+\n+  /* Return a copy with double the number of buckets.  Returns NULL if\n+     the allocator fails.  Otherwise, calls destroy (this).  */\n+  insert_only_hash_map *destructive_copy ();\n+\n+ /* Must be a power of 2 not less than min_capacity. */\n+  size_type num_buckets_; \n+  size_type num_entries_;\n+  size_type size_in_bytes_;\n+  bucket_type buckets[0];  /* Actual array size is num_buckets.  */\n+};\n+\n+template <typename T, typename Alloc>\n+insert_only_hash_map <T, Alloc> *\n+insert_only_hash_map <T, Alloc>::create (size_type expected_size)\n+{\n+  size_t cap = min_capacity;\n+  while (expected_size >= cap)\n+    {\n+      cap *= 2;\n+    }\n+  size_t size_in_bytes = sizeof (insert_only_hash_map <T, Alloc>)\n+                                                  + cap * sizeof (bucket_type);\n+  insert_only_hash_map <T, Alloc>* result =\n+      static_cast <insert_only_hash_map <T, Alloc>*> (Alloc ()\n+                                                       .alloc (size_in_bytes));\n+  if (result != NULL)\n+    {\n+      result->size_in_bytes_ = size_in_bytes;\n+      result->num_buckets_ = cap;\n+      result->num_entries_ = 0;\n+      memset (result->buckets, 0, cap * sizeof (bucket_type));\n+    }\n+  return result;\n+}\n+\n+template <typename T, typename Alloc>\n+insert_only_hash_map <T, Alloc>*\n+insert_only_hash_map <T, Alloc>::destructive_copy ()\n+{\n+  insert_only_hash_map* copy = create (this->bucket_count ());\n+  if (copy == NULL)\n+    return NULL;\n+  VTV_DEBUG_ASSERT (copy->bucket_count () == 2 * this->bucket_count ());\n+  for (size_type i = 0; i < this->bucket_count (); i++)\n+    if (this->buckets[i].first != NULL)\n+      copy->put_internal (this->buckets[i].first, this->buckets[i].second,\n+\t\t\t  true);\n+  VTV_DEBUG_ASSERT (copy->size () == this->size ());\n+  destroy (this);\n+  return copy;\n+}\n+\n+template <typename T, typename Alloc>\n+insert_only_hash_map <T, Alloc>*\n+insert_only_hash_map <T, Alloc>::find_or_add_key (const key_type *k,\n+\t\t\t\t\t\t  value_type **v)\n+{\n+  /* Table size is always a power of 2.  */\n+  const size_type mask = this->bucket_count () - 1;\n+  size_type bucket_index = k->hash & mask;\n+  size_type step = 1;\n+  for (;;)\n+    {\n+      bucket_type &bucket = this->buckets[bucket_index];\n+      if (bucket.first == NULL)\n+        {\n+          /* Key was not present. */\n+          if (this->is_too_full (this->size () + 1))\n+            {\n+              insert_only_hash_map <T, Alloc>* result =\n+\t\t                                     this->destructive_copy ();\n+              return result == NULL\n+                  ? NULL\n+                  : result->find_or_add_key (k, v);\n+            }\n+          else\n+            {\n+              bucket.first = k;\n+              bucket.second = T ();\n+              this->num_entries_++;\n+              *v = &bucket.second;\n+              return this;\n+            }\n+        }\n+      else if (bucket.first->equals (k))\n+        {\n+          /* Key was present. */\n+          *v = &bucket.second;\n+          return this;\n+        }\n+      else\n+        bucket_index = (bucket_index + step++) & mask;\n+    }\n+}\n+\n+template <typename T, typename Alloc>\n+insert_only_hash_map <T, Alloc>*\n+insert_only_hash_map <T, Alloc>::put_internal (\n+\t\t\t\t     const insert_only_hash_map::key_type *k,\n+\t\t\t\t     const insert_only_hash_map::value_type &v,\n+\t\t\t\t     bool unique_key_and_resize_not_needed)\n+{\n+  /* Table size is always a power of 2.  */\n+  const size_type mask = this->bucket_count () - 1;\n+  size_type bucket_index = k->hash & mask;\n+  size_type step = 1;\n+  for (;;)\n+    {\n+      bucket_type &bucket = this->buckets[bucket_index];\n+      if (bucket.first == NULL)\n+        {\n+          /* Key was not present.  */\n+          if (!unique_key_and_resize_not_needed\n+              && this->is_too_full (this->size () + 1))\n+            {\n+              insert_only_hash_map <T, Alloc>* result =\n+                                                     this->destructive_copy ();\n+              return result == NULL\n+                  ? NULL\n+                  : result->put_internal (k, v, true);\n+            }\n+          else\n+            {\n+              bucket.first = k;\n+              bucket.second = v;\n+              this->num_entries_++;\n+              return this;\n+            }\n+        }\n+      else if (!unique_key_and_resize_not_needed && bucket.first->equals (k))\n+        {\n+          /* Key was present.  Just change the value.  */\n+          bucket.second = v;\n+          return this;\n+        }\n+      else\n+        bucket_index = (bucket_index + step++) & mask;\n+    }\n+}\n+\n+template <typename T, typename Alloc>\n+inline const typename insert_only_hash_map <T, Alloc>::value_type*\n+insert_only_hash_map <T, Alloc>::get (const insert_only_hash_map::key_type *k)\n+                                                                          const\n+{\n+  /* Table size is always a power of 2.  */\n+  const size_type mask = this->bucket_count () - 1;\n+  size_type bucket_index = k->hash & mask;\n+  size_type step = 1;\n+  for (;;)\n+    {\n+      const bucket_type &bucket = this->buckets[bucket_index];\n+      if (bucket.first == NULL)\n+        return NULL;\n+      else if (bucket.first->equals (k))\n+        return &bucket.second;\n+      else\n+        bucket_index = (bucket_index + step++) & mask;\n+    }\n+}\n+\n+template <typename T, typename Alloc>\n+inline bool\n+insert_only_hash_map <T, Alloc>::key_type::equals (\n+             const typename insert_only_hash_map <T, Alloc>::key_type *k) const\n+{\n+  const char* x = reinterpret_cast <const char *> (k);\n+  const char* y = reinterpret_cast <const char *> (this);\n+  return (load8bytes (x) == load8bytes (y)\n+          && memcmp (x + 8, y + 8, this->n) == 0);\n+}\n+\n+#endif  /* _VTV_MAP_H  */"}, {"sha": "1ddbbec7a0745739933d2d1b4aa368d739c7db6e", "filename": "libvtv/vtv_rts.cc", "status": "added", "additions": 1523, "deletions": 0, "changes": 1523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_rts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_rts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_rts.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,1523 @@\n+/* Copyright (C) 2012-2013\n+ Free Software Foundation\n+\n+ This file is part of GCC.\n+\n+ GCC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 3, or (at your option)\n+ any later version.\n+\n+ GCC is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ Under Section 7 of GPL version 3, you are granted additional\n+ permissions described in the GCC Runtime Library Exception, version\n+ 3.1, as published by the Free Software Foundation.\n+\n+ You should have received a copy of the GNU General Public License and\n+ a copy of the GCC Runtime Library Exception along with this program;\n+ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+ <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable security feature implementation.\n+   The vtable security feature is designed to detect when a virtual\n+   call is about to be made through an invalid vtable pointer\n+   (possibly due to data corruption or malicious attacks). The\n+   compiler finds every virtual call, and inserts a verification call\n+   before the virtual call.  The verification call takes the actual\n+   vtable pointer value in the object through which the virtual call\n+   is being made, and compares the vtable pointer against a set of all\n+   valid vtable pointers that the object could contain (this set is\n+   based on the declared type of the object).  If the pointer is in\n+   the valid set, execution is allowed to continue; otherwise the\n+   program is halted.\n+\n+  There are several pieces needed in order to make this work: 1. For\n+  every virtual class in the program (i.e. a class that contains\n+  virtual methods), we need to build the set of all possible valid\n+  vtables that an object of that class could point to.  This includes\n+  vtables for any class(es) that inherit from the class under\n+  consideration.  2. For every such data set we build up, we need a\n+  way to find and reference the data set.  This is complicated by the\n+  fact that the real vtable addresses are not known until runtime,\n+  when the program is loaded into memory, but we need to reference the\n+  sets at compile time when we are inserting verification calls into\n+  the program.  3.  We need to find every virtual call in the program,\n+  and insert the verification call (with the appropriate arguments)\n+  before the virtual call.  4. We need some runtime library pieces:\n+  the code to build up the data sets at runtime; the code to actually\n+  perform the verification using the data sets; and some code to set\n+  protections on the data sets, so they themselves do not become\n+  hacker targets.\n+\n+  To find and reference the set of valid vtable pointers for any given\n+  virtual class, we create a special global varible for each virtual\n+  class.  We refer to this as the \"vtable map variable\" for that\n+  class.  The vtable map variable has the type \"void *\", and is\n+  initialized by the compiler to NULL.  At runtime when the set of\n+  valid vtable pointers for a virtual class, e.g. class Foo, is built,\n+  the vtable map variable for class Foo is made to point to the set.\n+  During compile time, when the compiler is inserting verification\n+  calls into the program, it passes the vtable map variable for the\n+  appropriate class to the verification call, so that at runtime the\n+  verification call can find the appropriate data set.\n+\n+  The actual set of valid vtable pointers for a polymorphic class,\n+  e.g. class Foo, cannot be built until runtime, when the vtables get\n+  loaded into memory and their addresses are known.  But the knowledge\n+  about which vtables belong in which class' hierarchy is only known\n+  at compile time.  Therefore at compile time we collect class\n+  hierarchy and vtable information about every virtual class, and we\n+  generate calls to build up the data sets at runtime.  To build the\n+  data sets, we call one of the functions we add to the runtime\n+  library, __VLTRegisterPair.  __VLTRegisterPair takes two arguments,\n+  a vtable map variable and the address of a vtable.  If the vtable\n+  map variable is currently NULL, it creates a new data set (hash\n+  table), makes the vtable map variable point to the new data set, and\n+  inserts the vtable address into the data set.  If the vtable map\n+  variable is not NULL, it just inserts the vtable address into the\n+  data set.  In order to make sure that our data sets are built before\n+  any verification calls happen, we create a special constructor\n+  initialization function for each compilation unit, give it a very\n+  high initialization priority, and insert all of our calls to\n+  __VLTRegisterPair into our special constructor initialization\n+  function.  */\n+\n+/* This file contains the main externally visible runtime library\n+   functions for vtable verification: __VLTChangePermission,\n+   __VLTRegisterPair, and __VLTVerifyVtablePointer.  It also contains\n+   debug versions __VLTRegisterPairDebug and\n+   __VLTVerifyVtablePointerDebug, which have extra parameters in order\n+   to make it easier to debug verification failures.\n+\n+   The final piece of functionality implemented in this file is symbol\n+   resolution for multiple instances of the same vtable map variable.\n+   If the same virtual class is used in two different compilation\n+   units, then each compilation unit will create a vtable map variable\n+   for the class.  We need all instances of the same vtable map\n+   variable to point to the same (single) set of valid vtable\n+   pointers for the class, so we wrote our own hashtable-based symbol\n+   resolution for vtable map variables (with a tiny optimization in\n+   the case where there is only one instance of the variable).\n+\n+   There are two other important pieces to the runtime for vtable\n+   verification besides the main pieces that go into libstdc++.so: two\n+   special tiny shared libraries, libvtv_init.so and libvtv_stubs.so.\n+   libvtv_init.so is built from vtv_init.cc.  It is designed to help\n+   minimize the calls made to mprotect (see the comments in\n+   vtv_init.cc for more details).  Anything compiled with\n+   \"-fvtable-verify=std\" must be linked with libvtv_init.so (the gcc\n+   driver has been modified to do this).  vtv_stubs.so is built from\n+   vtv_stubs.cc.  It replaces the main runtime functions\n+   (__VLTChangePermissino, __VLTRegisterPair and\n+   __VLTVerifyVtablePointer) with stub functions that do nothing.  If\n+   a programmer has a library that was built with verification, but\n+   wishes to not have verification turned on, the programmer can link\n+   in the vtv_stubs.so library.  */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <execinfo.h>\n+\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <errno.h>\n+#include <link.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+\n+/* For gthreads suppport */\n+#include <bits/c++config.h>\n+#include <ext/concurrence.h>\n+\n+#include \"vtv_utils.h\"\n+#include \"vtv_malloc.h\"\n+#include \"vtv_set.h\"\n+#include \"vtv_map.h\"\n+#include \"vtv_rts.h\"\n+#include \"vtv_fail.h\"\n+\n+#include \"vtv-change-permission.h\"\n+\n+extern \"C\" {\n+\n+  /* __fortify_fail is a function in glibc that calls __libc_message,\n+     causing it to print out a program termination error message\n+     (including the name of the binary being terminated), a stack\n+     trace where the error occurred, and a memory map dump.  Ideally\n+     we would have called __libc_message directly, but that function\n+     does not appear to be accessible to functions outside glibc,\n+     whereas __fortify_fail is.  We call __fortify_fail from\n+     __vtv_really_fail.  We looked at calling __libc_fatal, which is\n+     externally accessible, but it does not do the back trace and\n+     memory dump.  */\n+\n+  extern void __fortify_fail (const char *) __attribute__((noreturn));\n+\n+} /* extern \"C\" */\n+\n+/* The following variables are used only for debugging and performance\n+   tuning purposes. Therefore they do not need to be \"protected\".\n+   They cannot be used to attack the vtable verification system and if\n+   they become corrupted it will not affect the correctness or\n+   security of any of the rest of the vtable verification feature.  */\n+\n+unsigned int num_calls_to_regset = 0;\n+unsigned int num_calls_to_regpair = 0;\n+unsigned int num_calls_to_verify_vtable = 0;\n+unsigned long long regset_cycles = 0;\n+unsigned long long regpair_cycles = 0;\n+unsigned long long verify_vtable_cycles = 0;\n+\n+/* Be careful about initialization of statics in this file.  Some of\n+   the routines below are called before any runtime initialization for\n+   statics in this file will be done. For example, dont try to\n+   initialize any of these statics with a runtime call (for ex:\n+   sysconf). The initialization will happen after calls to the routines\n+   to protect/unprotec the vtabla_map variables */\n+\n+/* No need to mark the following variables with VTV_PROTECTED_VAR.\n+   These are either const or are only used for debugging/tracing.\n+   debugging/tracing will not be ON on production environments */\n+\n+static const bool debug_hash = HASHTABLE_STATS;\n+static const int debug_functions = 0;\n+static const int debug_init = 0;\n+static const int debug_verify_vtable = 0;\n+\n+#ifdef VTV_DEBUG\n+static const int debug_functions = 1;\n+static const int debug_init = 1;\n+static const int debug_verify_vtable = 1;\n+#endif\n+\n+/* Global file descriptor variables for logging, tracing and debugging.  */\n+\n+static int init_log_fd = -1;\n+static int verify_vtable_log_fd = -1;\n+\n+/* This holds a formatted error logging message, to be written to the\n+   vtable verify failures log.  */\n+static char debug_log_message[1024];\n+\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t change_permissions_lock = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t change_permissions_lock;\n+#endif\n+\n+\n+#ifndef VTV_STATS\n+#define VTV_STATS 0\n+#endif\n+\n+#if VTV_STATS\n+\n+static inline unsigned long long\n+get_cycle_count (void)\n+{\n+  return rdtsc();\n+}\n+\n+static inline void\n+accumulate_cycle_count (unsigned long long *sum, unsigned long long start)\n+{\n+  unsigned long long end = rdtsc();\n+  *sum = *sum + (end - start);\n+}\n+\n+static inline void\n+increment_num_calls (unsigned int *num_calls)\n+{\n+  *num_calls = *num_calls + 1;\n+}\n+\n+#else\n+\n+static inline unsigned long long\n+get_cycle_count (void)\n+{\n+  return (unsigned long long) 0;\n+}\n+\n+static inline void\n+accumulate_cycle_count (unsigned long long *sum __attribute__((__unused__)),\n+                        unsigned long long start __attribute__((__unused__)))\n+{\n+  /* Do nothing.  */\n+}\n+\n+static inline void\n+increment_num_calls (unsigned int *num_calls __attribute__((__unused__)))\n+{\n+  /* Do nothing.  */\n+}\n+\n+#endif\n+\n+/* Types needed by insert_only_hash_sets.  */\n+typedef uintptr_t int_vptr;\n+\n+/* The set of valid vtable pointers for each virtual class is stored\n+   in a hash table.  This is the hashing function used for the hash\n+   table.  For more information on the implementation of the hash\n+   table, see the class insert_only_hash_sets in vtv_set.h.  */\n+\n+struct vptr_hash\n+  {\n+    /* Hash function, used to convert vtable pointer, V, (a memory\n+       address) into an index into the hash table.  */\n+    size_t\n+    operator() (int_vptr v) const\n+      {\n+\tconst uint32_t x = 0x7a35e4d9;\n+\tconst int shift = (sizeof (v) == 8) ? 23 : 21;\n+\tv = x * v;\n+\treturn v ^ (v >> shift);\n+      }\n+  };\n+\n+/* This is the memory allocator used to create the hash table data\n+   sets of valid vtable pointers.  We use VTV_malloc in order to keep\n+   track of which pages have been allocated, so we can update the\n+   protections on those pages appropriately.  See the class\n+   insert_only_hash_sets in vtv_set.h for more information.  */\n+\n+struct vptr_set_alloc\n+  {\n+    /* Memory allocator operator.  N is the number of bytes to be\n+       allocated.  */\n+    void *\n+    operator() (size_t n) const\n+      {\n+\treturn __vtv_malloc (n);\n+      }\n+  };\n+\n+/* Instantiate the template classes (in vtv_set.h) for our particular\n+   hash table needs.  */\n+typedef insert_only_hash_sets<int_vptr, vptr_hash, vptr_set_alloc> vtv_sets;\n+typedef vtv_sets::insert_only_hash_set vtv_set;\n+typedef vtv_set * vtv_set_handle;\n+typedef vtv_set_handle * vtv_set_handle_handle; \n+\n+/* Records for caching the section header information that we have\n+   read out of the file(s) on disk (in dl_iterate_phdr_callback), to\n+   avoid having to re-open and re-read the same file multiple\n+   times.  */\n+\n+struct sect_hdr_data\n+{\n+  ElfW (Addr) dlpi_addr; /* The header address in the INFO record,\n+                            passed in from dl_iterate_phdr.  */\n+  ElfW (Addr) mp_low;    /* Start address of the .vtable_map_vars\n+                            section in memory.  */\n+  size_t mp_size;        /* Size of the .vtable_map_vars section in\n+                            memory.  */\n+};\n+\n+/* Array for caching the section header information, read from file,\n+   to avoid re-opening and re-reading the same file over-and-over\n+   again.  */\n+\n+#define MAX_ENTRIES 250\n+static struct sect_hdr_data vtv_sect_info_cache[MAX_ENTRIES] VTV_PROTECTED_VAR;\n+\n+unsigned int num_cache_entries VTV_PROTECTED_VAR = 0;\n+\n+/* This function takes the LOAD_ADDR for an object opened by the\n+   dynamic loader, and checks the array of cached file data to see if\n+   there is an entry with the same addres.  If it finds such an entry,\n+   it returns the record for that entry; otherwise it returns\n+   NULL.  */\n+\n+struct sect_hdr_data *\n+search_cached_file_data (ElfW (Addr) load_addr)\n+{\n+  unsigned int i;\n+  for (i = 0; i < num_cache_entries; ++i)\n+    {\n+      if (vtv_sect_info_cache[i].dlpi_addr == load_addr)\n+        return &(vtv_sect_info_cache[i]);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* This function tries to read COUNT bytes out of the file referred to\n+   by FD into the buffer BUF.  It returns the actual number of bytes\n+   it succeeded in reading.  */\n+\n+static size_t\n+ReadPersistent (int fd, void *buf, size_t count)\n+{\n+  char *buf0 = (char *) buf;\n+  size_t num_bytes = 0;\n+  while (num_bytes < count)\n+    {\n+      int len;\n+      len = read (fd, buf0 + num_bytes, count - num_bytes);\n+      if (len < 0)\n+\treturn -1;\n+      if (len == 0)\n+\tbreak;\n+      num_bytes += len;\n+    }\n+\n+  return num_bytes;\n+}\n+\n+/* This function tries to read COUNT bytes, starting at OFFSET from\n+   the file referred to by FD, and put them into BUF.  It calls\n+   ReadPersistent to help it do so.  It returns the actual number of\n+   bytes read, or -1 if it fails altogether.  */\n+\n+static size_t\n+ReadFromOffset (int fd, void *buf, const size_t count, const off_t offset)\n+{\n+  off_t off = lseek (fd, offset, SEEK_SET);\n+  if (off != (off_t) -1)\n+    return ReadPersistent (fd, buf, count);\n+  return -1;\n+}\n+\n+/* The function takes a MESSAGE and attempts to write it to the vtable\n+   memory protection log (for debugging purposes).  If the file is not\n+   open, it attempts to open the file first.  */\n+\n+static void\n+log_memory_protection_data (char *message)\n+{\n+  static int log_fd = -1;\n+\n+  if (log_fd == -1)\n+    log_fd = __vtv_open_log (\"vtv_memory_protection_data_%d.log\");\n+\n+  __vtv_add_to_log (log_fd, \"%s\", message);\n+}\n+\n+static void\n+read_section_offset_and_length (struct dl_phdr_info *info,\n+                                const char *sect_name,\n+                                int mprotect_flags,\n+                                off_t *sect_offset,\n+                                ElfW (Word) *sect_len)\n+{\n+  char program_name[PATH_MAX];\n+  char *cptr;\n+  bool found = false;\n+  struct sect_hdr_data *cached_data = NULL;\n+  const ElfW (Phdr) *phdr_info = info->dlpi_phdr;\n+  const ElfW (Ehdr) *ehdr_info =\n+    (const ElfW (Ehdr) *) (info->dlpi_addr + info->dlpi_phdr[0].p_vaddr\n+                           - info->dlpi_phdr[0].p_offset);\n+\n+\n+  /* Get the name of the main executable.  This may or may not include\n+     arguments passed to the program.  Find the first space, assume it\n+     is the start of the argument list, and change it to a '\\0'. */\n+  snprintf (program_name, sizeof (program_name), program_invocation_name);\n+\n+  /* Check to see if we already have the data for this file.  */\n+  cached_data = search_cached_file_data (info->dlpi_addr);\n+\n+  if (cached_data)\n+    {\n+      *sect_offset = cached_data->mp_low;\n+      *sect_len = cached_data->mp_size;\n+      return;\n+    }\n+\n+  /* Find the first non-escaped space in the program name and make it\n+     the end of the string.  */\n+  cptr = strchr (program_name, ' ');\n+  if (cptr != NULL && cptr[-1] != '\\\\')\n+    cptr[0] = '\\0';\n+\n+  if ((phdr_info->p_type == PT_PHDR || phdr_info->p_type == PT_LOAD)\n+      && (ehdr_info->e_shoff && ehdr_info->e_shnum))\n+    {\n+      int name_len = strlen (sect_name);\n+      int fd = -1;\n+\n+      /* Attempt to open the binary file on disk.  */\n+      if (strlen (info->dlpi_name) == 0)\n+        {\n+          /* If the constructor initialization function was put into\n+             the preinit array, then this function will get called\n+             while handling preinit array stuff, in which case\n+             program_invocation_name has not been initialized.  In\n+             that case we can get the filename of the executable from\n+             \"/proc/self/exe\".  */\n+          if (strlen (program_name) > 0)\n+            {\n+              if (phdr_info->p_type == PT_PHDR)\n+                fd = open (program_name, O_RDONLY);\n+            }\n+          else\n+            fd = open (\"/proc/self/exe\", O_RDONLY);\n+        }\n+      else\n+        fd = open (info->dlpi_name, O_RDONLY);\n+\n+      if (fd != -1)\n+        {\n+          /* Find the section header information in the file.  */\n+          ElfW (Half) strtab_idx = ehdr_info->e_shstrndx;\n+          ElfW (Shdr) shstrtab;\n+          off_t shstrtab_offset = ehdr_info->e_shoff +\n+                                         (ehdr_info->e_shentsize * strtab_idx);\n+          size_t bytes_read = ReadFromOffset (fd, &shstrtab, sizeof (shstrtab),\n+                                              shstrtab_offset);\n+          VTV_ASSERT (bytes_read == sizeof (shstrtab));\n+\n+          ElfW (Shdr) sect_hdr;\n+\n+\t  /* This code will be needed once we have crated libvtv.so. */\n+\t  bool is_libvtv = false;\n+\n+\t  /*\n+\t  if (strstr (info->dlpi_name, \"libvtv.so\"))\n+\t    is_libvtv = true;\n+\t  */\n+\n+          /* Loop through all the section headers, looking for one whose\n+             name is \".vtable_map_vars\".  */\n+\n+          for (int i = 0; i < ehdr_info->e_shnum && !found; ++i)\n+            {\n+              off_t offset = ehdr_info->e_shoff + (ehdr_info->e_shentsize * i);\n+\n+              bytes_read = ReadFromOffset (fd, &sect_hdr, sizeof (sect_hdr),\n+                                           offset);\n+\n+              VTV_ASSERT (bytes_read == sizeof (sect_hdr));\n+\n+              char header_name[64];\n+              off_t name_offset = shstrtab.sh_offset +  sect_hdr.sh_name;\n+\n+              bytes_read = ReadFromOffset (fd, &header_name, 64, name_offset);\n+\n+              VTV_ASSERT (bytes_read > 0);\n+\n+              if (memcmp (header_name, sect_name, name_len) == 0)\n+                {\n+                  /* We found the section; get its load offset and\n+                     size.  */\n+                  *sect_offset = sect_hdr.sh_addr;\n+\t\t  if (!is_libvtv)\n+\t\t    *sect_len = sect_hdr.sh_size - VTV_PAGE_SIZE;\n+\t\t  else\n+\t\t    *sect_len = sect_hdr.sh_size;\n+                  found = true;\n+                }\n+            }\n+          close (fd);\n+        }\n+    }\n+\n+  if (*sect_offset != 0 && *sect_len != 0)\n+    {\n+      /* Calculate the page location in memory, making sure the\n+         address is page-aligned.  */\n+      ElfW (Addr) start_addr = (const ElfW (Addr)) info->dlpi_addr\n+                                                                 + *sect_offset;\n+      *sect_offset = start_addr & ~(VTV_PAGE_SIZE - 1);\n+      *sect_len = *sect_len - 1;\n+\n+      /* Since we got this far, we must not have found these pages in\n+         the cache, so add them to it.  NOTE: We could get here either\n+         while making everything read-only or while making everything\n+         read-write.  We will only update the cache if we get here on\n+         a read-write (to make absolutely sure the cache is writable\n+         -- also the read-write pass should come before the read-only\n+         pass).  */\n+      if ((mprotect_flags & PROT_WRITE)\n+          && num_cache_entries < MAX_ENTRIES)\n+        {\n+          vtv_sect_info_cache[num_cache_entries].dlpi_addr = info->dlpi_addr;\n+          vtv_sect_info_cache[num_cache_entries].mp_low = *sect_offset;\n+          vtv_sect_info_cache[num_cache_entries].mp_size = *sect_len;\n+          num_cache_entries++;\n+        }\n+    }\n+}\n+\n+/* This is the callback function used by dl_iterate_phdr (which is\n+   called from vtv_unprotect_vtable_vars and vtv_protect_vtable_vars).\n+   It attempts to find the binary file on disk for the INFO record\n+   that dl_iterate_phdr passes in; open the binary file, and read its\n+   section header information.  If the file contains a\n+   \".vtable_map_vars\" section, read the section offset and size.  Use\n+   the section offset and size, in conjunction with the data in INFO\n+   to locate the pages in memory where the section is.  Call\n+   'mprotect' on those pages, setting the protection either to\n+   read-only or read-write, depending on what's in DATA.  */\n+\n+static int\n+dl_iterate_phdr_callback (struct dl_phdr_info *info, size_t, void *data)\n+{\n+  int * mprotect_flags = (int *) data;\n+  off_t map_sect_offset = 0;\n+  ElfW (Word) map_sect_len = 0;\n+  char buffer[1024];\n+  char program_name[1024];\n+  const char *map_sect_name = VTV_PROTECTED_VARS_SECTION;\n+\n+  /* Check to see if this is the record for the Linux Virtual Dynamic\n+     Shared Object (linux-vdso.so.1), which exists only in memory (and\n+     therefore cannot be read from disk).  */\n+\n+  if (strcmp (info->dlpi_name, \"linux-vdso.so.1\") == 0)\n+    return 0;\n+\n+  if (strlen (info->dlpi_name) == 0\n+      && info->dlpi_addr != 0)\n+    return 0;\n+\n+  /* Get the name of the main executable.  This may or may not include\n+     arguments passed to the program.  Find the first space, assume it\n+     is the start of the argument list, and change it to a '\\0'. */\n+  snprintf (program_name, sizeof (program_name), program_invocation_name);\n+\n+  read_section_offset_and_length (info, map_sect_name, *mprotect_flags,\n+\t\t\t\t  &map_sect_offset, &map_sect_len);\n+\n+  if (debug_functions)\n+    {\n+      snprintf (buffer, sizeof(buffer),\n+\t\t\"  Looking at load module %s to change permissions to %s\\n\",\n+\t\t((strlen (info->dlpi_name) == 0) ? program_name\n+                                                 : info->dlpi_name),\n+\t\t(*mprotect_flags & PROT_WRITE) ? \"READ/WRITE\" : \"READ-ONLY\");\n+      log_memory_protection_data (buffer);\n+    }\n+\n+  /* See if we actually found the section.  */\n+  if (map_sect_offset && map_sect_len)\n+    {\n+      unsigned long long start;\n+      int result;\n+\n+      if (debug_functions)\n+        {\n+          snprintf (buffer, sizeof (buffer),\n+                    \"  (%s): Protecting %p to %p\\n\",\n+                    ((strlen (info->dlpi_name) == 0) ? program_name\n+                     : info->dlpi_name),\n+                    (void *) map_sect_offset,\n+                    (void *) (map_sect_offset + map_sect_len));\n+          log_memory_protection_data (buffer);\n+        }\n+\n+      /* Change the protections on the pages for the section.  */\n+\n+      start = get_cycle_count ();\n+      result = mprotect ((void *) map_sect_offset, map_sect_len,\n+                         *mprotect_flags);\n+      accumulate_cycle_count (&mprotect_cycles, start);\n+      if (result == -1)\n+        {\n+          if (debug_functions)\n+            {\n+              snprintf (buffer, sizeof (buffer),\n+                        \"Failed called to mprotect for %s error: \",\n+                        (*mprotect_flags & PROT_WRITE) ?\n+                        \"READ/WRITE\" : \"READ-ONLY\");\n+              log_memory_protection_data (buffer);\n+              perror(NULL);\n+            }\n+          VTV_error();\n+        }\n+      else\n+        {\n+          if (debug_functions)\n+           {\n+              snprintf (buffer, sizeof (buffer),\n+                        \"mprotect'ed range [%p, %p]\\n\",\n+                        (void *) map_sect_offset,\n+                        (char *) map_sect_offset + map_sect_len);\n+              log_memory_protection_data (buffer);\n+            }\n+        }\n+      increment_num_calls (&num_calls_to_mprotect);\n+      /* num_pages_protected += (map_sect_len + VTV_PAGE_SIZE - 1) / VTV_PAGE_SIZE; */\n+      num_pages_protected += (map_sect_len + 4096 - 1) / 4096;\n+    }\n+\n+  return 0;\n+}\n+\n+/* This function explicitly changes the protection (read-only or read-write)\n+   on the vtv_sect_info_cache, which is used for speeding up look ups in the\n+   function dl_iterate_phdr_callback.  This data structure needs to be\n+   explicitly made read-write before any calls  to dl_iterate_phdr_callback,\n+   because otherwise it may still be read-only when dl_iterate_phdr_callback\n+   attempts to write to it.\n+\n+   More detailed explanation:  dl_iterate_phdr_callback finds all the\n+   .vtable_map_vars sections in all loaded objects (including the main program)\n+   and (depending on where it was called from) either makes all the pages in the\n+   sections read-write or read-only.  The vtv_sect_info_cache should be in the\n+   .vtable_map_vars section for libstdc++.so, which means that normally it would\n+   be read-only until libstdc++.so is processed by dl_iterate_phdr_callback\n+   (on the read-write pass), after which it will be writable.  But if any loaded\n+   object gets processed before libstdc++.so, it will attempt to update the\n+   data cache, which will still be read-only, and cause a seg fault.  Hence\n+   we need a special function, called before dl_iterate_phdr_callback, that\n+   will make the data cache writable.  */\n+\n+static void\n+change_protections_on_phdr_cache (int protection_flag)\n+{\n+  char * low_address = (char *) &(vtv_sect_info_cache);\n+  size_t cache_size = MAX_ENTRIES * sizeof (struct sect_hdr_data);\n+\n+  low_address = (char *) ((unsigned long) low_address & ~(VTV_PAGE_SIZE - 1));\n+  \n+  if (mprotect ((void *) low_address, cache_size, protection_flag) == -1)\n+    VTV_error ();\n+}\n+\n+/* Unprotect all the vtable map vars and other side data that is used\n+   to keep the core hash_map data. All of these data have been put\n+   into relro sections */\n+\n+static void\n+vtv_unprotect_vtable_vars (void)\n+{\n+  int mprotect_flags;\n+\n+  mprotect_flags = PROT_READ | PROT_WRITE;\n+  change_protections_on_phdr_cache (mprotect_flags);\n+  dl_iterate_phdr (dl_iterate_phdr_callback, (void *) &mprotect_flags);\n+}\n+\n+/* Protect all the vtable map vars and other side data that is used\n+   to keep the core hash_map data. All of these data have been put\n+   into relro sections */\n+\n+static void\n+vtv_protect_vtable_vars (void)\n+{\n+  int mprotect_flags;\n+\n+  mprotect_flags = PROT_READ;\n+  dl_iterate_phdr (dl_iterate_phdr_callback, (void *) &mprotect_flags);\n+  change_protections_on_phdr_cache (mprotect_flags);\n+}\n+\n+#ifndef __GTHREAD_MUTEX_INIT\n+static void\n+initialize_change_permissions_mutexes ()\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&change_permissions_lock);\n+}\n+#endif\n+\n+/*  Variables needed for getting the statistics about the hashtable set.  */\n+#if HASHTABLE_STATS\n+_AtomicStatCounter stat_contains = 0;\n+_AtomicStatCounter stat_insert = 0;\n+_AtomicStatCounter stat_resize = 0;\n+_AtomicStatCounter stat_create = 0;\n+_AtomicStatCounter stat_probes_in_non_trivial_set = 0;\n+_AtomicStatCounter stat_contains_size0 = 0;\n+_AtomicStatCounter stat_contains_size1 = 0;\n+_AtomicStatCounter stat_contains_size2 = 0;\n+_AtomicStatCounter stat_contains_size3 = 0;\n+_AtomicStatCounter stat_contains_size4 = 0;\n+_AtomicStatCounter stat_contains_size5 = 0;\n+_AtomicStatCounter stat_contains_size6 = 0;\n+_AtomicStatCounter stat_contains_size7 = 0;\n+_AtomicStatCounter stat_contains_size8 = 0;\n+_AtomicStatCounter stat_contains_size9 = 0;\n+_AtomicStatCounter stat_contains_size10 = 0;\n+_AtomicStatCounter stat_contains_size11 = 0;\n+_AtomicStatCounter stat_contains_size12 = 0;\n+_AtomicStatCounter stat_contains_size13_or_more = 0;\n+_AtomicStatCounter stat_contains_sizes = 0;\n+_AtomicStatCounter stat_grow_from_size0_to_1 = 0;\n+_AtomicStatCounter stat_grow_from_size1_to_2 = 0;\n+_AtomicStatCounter stat_double_the_number_of_buckets = 0;\n+_AtomicStatCounter stat_insert_found_hash_collision = 0;\n+_AtomicStatCounter stat_contains_in_non_trivial_set = 0;\n+_AtomicStatCounter stat_insert_key_that_was_already_present = 0;\n+#endif\n+/* Record statistics about the hash table sets, for debugging.  */\n+\n+static void\n+log_set_stats (void)\n+{\n+#if HASHTABLE_STATS\n+      if (set_log_fd == -1)\n+\tset_log_fd = __vtv_open_log (\"vtv_set_stats.log\");\n+\n+      __vtv_add_to_log (set_log_fd, \"---\\n%s\\n\",\n+\t\t\tinsert_only_hash_tables_stats().c_str());\n+#endif\n+}\n+\n+/* Change the permissions on all the pages we have allocated for the\n+   data sets and all the \".vtable_map_var\" sections in memory (which\n+   contain our vtable map variables).  PERM indicates whether to make\n+   the permissions read-only or read-write.  */\n+\n+extern \"C\" /* This is only being applied to __VLTChangePermission*/\n+void\n+__VLTChangePermission (int perm)\n+{\n+  if (debug_functions)\n+    {\n+      if (perm == __VLTP_READ_WRITE)\n+\tfprintf (stdout, \"Changing VLT permisisons to Read-Write.\\n\");\n+      else if (perm == __VLTP_READ_ONLY)\n+\tfprintf (stdout, \"Changing VLT permissions to Read-only.\\n\");\n+\n+      else\n+\tfprintf (stdout, \"Unrecognized permissions value: %d\\n\", perm);\n+    }\n+\n+#ifndef __GTHREAD_MUTEX_INIT\n+  static __gthread_once_t mutex_once VTV_PROTECTED_VAR = __GTHREAD_ONCE_INIT;\n+\n+  __gthread_once (&mutex_once, initialize_change_permissions_mutexes);\n+#endif\n+\n+  /* Ordering of these unprotect/protect calls is very important.\n+     You first need to unprotect all the map vars and side\n+     structures before you do anything with the core data\n+     structures (hash_maps) */\n+\n+  if (perm == __VLTP_READ_WRITE)\n+    {\n+      /* TODO: Need to revisit this code for dlopen. It most probably\n+         is not unlocking the protected vtable vars after for load\n+         module that is not the first load module.  */\n+      __gthread_mutex_lock (&change_permissions_lock);\n+\n+      vtv_unprotect_vtable_vars ();\n+      __vtv_malloc_init ();\n+      __vtv_malloc_unprotect ();\n+\n+    }\n+  else if (perm == __VLTP_READ_ONLY)\n+    {\n+      if (debug_hash)\n+        log_set_stats();\n+\n+      __vtv_malloc_protect ();\n+      vtv_protect_vtable_vars ();\n+\n+      __gthread_mutex_unlock (&change_permissions_lock);\n+    }\n+}\n+\n+/* This is the memory allocator used to create the hash table that\n+   maps from vtable map variable name to the data set that vtable map\n+   variable should point to.  This is part of our vtable map variable\n+   symbol resolution, which is necessary because the same vtable map\n+   variable may be created by multiple compilation units and we need a\n+   method to make sure that all vtable map variables for a particular\n+   class point to the same data set at runtime.  */\n+\n+struct insert_only_hash_map_allocator\n+  {\n+    /* N is the number of bytes to allocate.  */\n+    void *\n+    alloc (size_t n) const\n+    {  \n+      return __vtv_malloc (n);\n+    }\n+\n+    /* P points to the memory to be deallocated; N is the number of\n+       bytes to deallocate.  */\n+    void\n+    dealloc (void *p, size_t) const\n+    {\n+      __vtv_free (p);\n+    }\n+  };\n+\n+/* Explicitly instantiate this class since this file is compiled with\n+   -fno-implicit-templates.  These are for the hash table that is used\n+   to do vtable map variable symbol resolution.  */\n+template class insert_only_hash_map <vtv_set_handle *, \n+\t\t\t\t     insert_only_hash_map_allocator >;\n+typedef insert_only_hash_map <vtv_set_handle *,\n+                              insert_only_hash_map_allocator > s2s;\n+typedef const s2s::key_type  vtv_symbol_key;\n+\n+static s2s * vtv_symbol_unification_map VTV_PROTECTED_VAR = NULL;\n+\n+const unsigned long SET_HANDLE_HANDLE_BIT = 0x2;\n+\n+/* In the case where a vtable map variable is the only instance of the\n+   variable we have seen, it points directly to the set of valid\n+   vtable pointers.  All subsequent instances of the 'same' vtable map\n+   variable point to the first vtable map variable.  This function,\n+   given a vtable map variable PTR, checks a bit to see whether it's\n+   pointing directly to the data set or to the first vtable map\n+   variable.  */\n+\n+static inline bool\n+is_set_handle_handle (void * ptr)\n+{\n+  return ((unsigned long) ptr & SET_HANDLE_HANDLE_BIT)\n+                                                      == SET_HANDLE_HANDLE_BIT;\n+}\n+\n+/* Returns the actual pointer value of a vtable map variable, PTR (see\n+   comments for is_set_handle_handle for more details).  */\n+\n+static inline vtv_set_handle * \n+ptr_from_set_handle_handle (void * ptr)\n+{\n+  return (vtv_set_handle *) ((unsigned long) ptr & ~SET_HANDLE_HANDLE_BIT);\n+}\n+\n+/* Given a vtable map variable, PTR, this function sets the bit that\n+   says this is the second (or later) instance of a vtable map\n+   variable.  */\n+\n+static inline vtv_set_handle_handle\n+set_handle_handle (vtv_set_handle * ptr)\n+{\n+  return (vtv_set_handle_handle) ((unsigned long) ptr | SET_HANDLE_HANDLE_BIT);\n+}\n+\n+static inline void\n+register_set_common (void **set_handle_ptr, size_t num_args,\n+                     void **vtable_ptr_array, bool debug)\n+{\n+  /* Now figure out what pointer to use for the set pointer, for the\n+     inserts.  */\n+  vtv_set_handle *handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+\n+  if (debug)\n+    VTV_DEBUG_ASSERT (vtv_symbol_unification_map != NULL);\n+\n+  if (!is_set_handle_handle (*set_handle_ptr))\n+    handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+  else\n+    handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+\n+  /* Now we've got the set and it's initialized, add the vtable\n+     pointers.  */\n+  for (size_t index = 0; index < num_args; ++index)\n+    {\n+      int_vptr vtbl_ptr = (int_vptr) vtable_ptr_array[index];\n+      vtv_sets::insert (vtbl_ptr, handle_ptr);\n+    }\n+}\n+\n+static inline void\n+register_pair_common (void **set_handle_ptr, const void *vtable_ptr,\n+                      const char *set_symbol_name, const char *vtable_name,\n+                      bool debug)\n+{\n+  /* Now we've got the set and it's initialized, add the vtable\n+     pointer (assuming that it's not NULL...It may be NULL, as we may\n+     have called this function merely to initialize the set\n+     pointer).  */\n+  int_vptr vtbl_ptr = (int_vptr) vtable_ptr;\n+  if (vtbl_ptr)\n+    {\n+      vtv_set_handle *handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+      if (debug)\n+        VTV_DEBUG_ASSERT (vtv_symbol_unification_map != NULL);\n+      if (!is_set_handle_handle (*set_handle_ptr))\n+        handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+      else\n+        handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+\n+      vtv_sets::insert (vtbl_ptr, handle_ptr);\n+    }\n+\n+  if (debug && debug_init)\n+    {\n+      if (init_log_fd == -1)\n+        init_log_fd = __vtv_open_log(\"vtv_init.log\");\n+\n+      __vtv_add_to_log(init_log_fd,\n+\t\t       \"Registered %s : %s (%p) 2 level deref = %s\\n\",\n+\t\t       set_symbol_name, vtable_name, vtbl_ptr,\n+\t\t       is_set_handle_handle(*set_handle_ptr) ? \"yes\" : \"no\" );\n+    }\n+}\n+\n+/* This routine initializes a set handle to a vtable set. It makes\n+   sure that there is only one set handle for a particular set by\n+   using a map from set name to pointer to set handle. Since there\n+   will be multiple copies of the pointer to the set handle (one per\n+   compilation unit that uses it), it makes sure to initialize all the\n+   pointers to the set handle so that the set handle is unique. To\n+   make this a little more efficient and avoid a level of indirection\n+   in some cases, the first pointer to handle for a particular handle\n+   becomes the handle itself and the other pointers will point to the\n+   set handle.  This is the debug version of this function, so it\n+   outputs extra debugging messages and logging.  SET_HANDLE_PTR is\n+   the address of the vtable map variable, SET_SYMBOL_KEY is the hash\n+   table key (containing the name of the map variable and the hash\n+   value) and SIZE_HINT is a guess for the best initial size for the\n+   set of vtable pointers that SET_HANDLE_POINTER will point to.  */\n+\n+static inline void\n+init_set_symbol_debug (void **set_handle_ptr, const void *set_symbol_key,\n+                       size_t size_hint)\n+{\n+  VTV_DEBUG_ASSERT (set_handle_ptr);\n+\n+  if (vtv_symbol_unification_map == NULL)\n+    {\n+      /* TODO:  For now we have chosen 1024, but we need to come up with a\n+         better initial size for this.  */\n+      vtv_symbol_unification_map = s2s::create (1024);\n+      VTV_DEBUG_ASSERT(vtv_symbol_unification_map);\n+    }\n+\n+  vtv_set_handle *handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+  vtv_symbol_key *symbol_key_ptr = (vtv_symbol_key *) set_symbol_key;\n+\n+  const s2s::value_type * map_value_ptr =\n+                              vtv_symbol_unification_map->get (symbol_key_ptr);\n+  char buffer[200];\n+  if (map_value_ptr == NULL)\n+    {\n+      if (*handle_ptr != NULL)\n+        {\n+          snprintf (buffer, sizeof (buffer),\n+                    \"*** Found non-NULL local set ptr %p missing for symbol\"\n+                    \" %.*s\",\n+                    *handle_ptr, symbol_key_ptr->n, symbol_key_ptr->bytes);\n+          __vtv_log_verification_failure (buffer, true);\n+          VTV_DEBUG_ASSERT (0);\n+        }\n+    }\n+  else if (*handle_ptr != NULL &&\n+           (handle_ptr != *map_value_ptr &&\n+            ptr_from_set_handle_handle (*handle_ptr) != *map_value_ptr))\n+    {\n+      VTV_DEBUG_ASSERT (*map_value_ptr != NULL);\n+      snprintf (buffer, sizeof(buffer),\n+                \"*** Found diffence between local set ptr %p and set ptr %p\"\n+                \"for symbol %.*s\",\n+                *handle_ptr, *map_value_ptr,\n+                symbol_key_ptr->n, symbol_key_ptr->bytes);\n+      __vtv_log_verification_failure (buffer, true);\n+      VTV_DEBUG_ASSERT (0);\n+    }\n+  else if (*handle_ptr == NULL)\n+    {\n+      /* Execution should not reach this point.  */\n+    }\n+\n+  if (*handle_ptr != NULL)\n+    {\n+      if (!is_set_handle_handle (*set_handle_ptr))\n+        handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+      else\n+        handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+      vtv_sets::resize (size_hint, handle_ptr);\n+      return;\n+    }\n+\n+  VTV_DEBUG_ASSERT (*handle_ptr == NULL);\n+  if (map_value_ptr != NULL)\n+    {\n+      if (*map_value_ptr == handle_ptr)\n+        vtv_sets::resize (size_hint, *map_value_ptr);\n+      else\n+        {\n+          /* The one level handle to the set already exists. So, we\n+             are adding one level of indirection here and we will\n+             store a pointer to the one level handle here.  */\n+\n+          vtv_set_handle_handle * handle_handle_ptr =\n+                                           (vtv_set_handle_handle *)handle_ptr;\n+          *handle_handle_ptr = set_handle_handle(*map_value_ptr);\n+          VTV_DEBUG_ASSERT(*handle_handle_ptr != NULL);\n+\n+          /* The handle can itself be NULL if the set has only\n+             been initiazlied with size hint == 1. */\n+          vtv_sets::resize (size_hint, *map_value_ptr);\n+        }\n+    }\n+  else\n+    {\n+      /* We will create a new set. So, in this case handle_ptr is the\n+         one level pointer to the set handle.  Create copy of map name\n+         in case the memory where this comes from gets unmapped by\n+         dlclose.  */\n+      size_t map_key_len = symbol_key_ptr->n + sizeof (vtv_symbol_key);\n+      void *map_key = __vtv_malloc (map_key_len);\n+\n+      memcpy (map_key, symbol_key_ptr, map_key_len);\n+\n+      s2s::value_type *value_ptr;\n+      vtv_symbol_unification_map =\n+        vtv_symbol_unification_map->find_or_add_key ((vtv_symbol_key *)map_key,\n+                                                     &value_ptr);\n+      *value_ptr = handle_ptr;\n+\n+      /*  TODO: We should verify the return value. */\n+      vtv_sets::create (size_hint, handle_ptr);\n+      VTV_DEBUG_ASSERT (size_hint <= 1 || *handle_ptr != NULL);\n+    }\n+\n+  if (debug_init)\n+    {\n+      if (init_log_fd == -1)\n+        init_log_fd = __vtv_open_log (\"vtv_init.log\");\n+\n+      __vtv_add_to_log (init_log_fd,\n+\t\t\t\"Init handle:%p for symbol:%.*s hash:%u size_hint:%lu\"\n+\t\t\t\"number of symbols:%lu \\n\",\n+\t\t\tset_handle_ptr, symbol_key_ptr->n,\n+\t\t\tsymbol_key_ptr->bytes, symbol_key_ptr->hash, size_hint,\n+\t\t\tvtv_symbol_unification_map->size ());\n+    }\n+}\n+\n+\n+/* This routine initializes a set handle to a vtable set. It makes\n+   sure that there is only one set handle for a particular set by\n+   using a map from set name to pointer to set handle. Since there\n+   will be multiple copies of the pointer to the set handle (one per\n+   compilation unit that uses it), it makes sure to initialize all the\n+   pointers to the set handle so that the set handle is unique. To\n+   make this a little more efficient and avoid a level of indirection\n+   in some cases, the first pointer to handle for a particular handle\n+   becomes the handle itself and the other pointers will point to the\n+   set handle.  This is the debug version of this function, so it\n+   outputs extra debugging messages and logging.  SET_HANDLE_PTR is\n+   the address of the vtable map variable, SET_SYMBOL_KEY is the hash\n+   table key (containing the name of the map variable and the hash\n+   value) and SIZE_HINT is a guess for the best initial size for the\n+   set of vtable pointers that SET_HANDLE_POINTER will point to.  */\n+\n+void\n+__VLTRegisterSetDebug (void **set_handle_ptr, const void *set_symbol_key,\n+                       size_t size_hint, size_t num_args,\n+                       void **vtable_ptr_array)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  increment_num_calls (&num_calls_to_regset);\n+\n+  VTV_DEBUG_ASSERT(set_handle_ptr != NULL);\n+  init_set_symbol_debug (set_handle_ptr, set_symbol_key, size_hint);\n+\n+  register_set_common (set_handle_ptr, num_args, vtable_ptr_array, true);\n+\n+  accumulate_cycle_count (&regset_cycles, start);\n+}\n+\n+/* This function takes a the address of a vtable map variable\n+   (SET_HANDLE_PTR), a VTABLE_PTR to add to the data set, the name of\n+   the vtable map variable (SET_SYMBOL_NAME) and the name of the\n+   vtable (VTABLE_NAME) being pointed to.  If the vtable map variable\n+   is NULL it creates a new data set and initializes the variable,\n+   otherwise it uses our symbol unification to find the right data\n+   set; in either case it then adds the vtable pointer to the set.\n+   The other two parameters are used for debugging information.  */\n+\n+void\n+__VLTRegisterPairDebug (void **set_handle_ptr, const  void *set_symbol_key,\n+                        size_t size_hint, const void *vtable_ptr,\n+                        const char *set_symbol_name, const char *vtable_name)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  increment_num_calls (&num_calls_to_regpair);\n+\n+  VTV_DEBUG_ASSERT(set_handle_ptr != NULL);\n+  init_set_symbol_debug (set_handle_ptr, set_symbol_key, size_hint);\n+\n+  register_pair_common (set_handle_ptr, vtable_ptr, set_symbol_name, vtable_name,\n+                        true);\n+\n+  accumulate_cycle_count (&regpair_cycles, start);\n+}\n+\n+\n+/* This is the debug version of the verification function.  It takes\n+   the address of a vtable map variable (SET_HANDLE_PTR) and a\n+   VTABLE_PTR to validate, as well as the name of the vtable map\n+   variable (SET_SYMBOL_NAME) and VTABLE_NAME, which are used for\n+   debugging messages.  It checks to see if VTABLE_PTR is in the set\n+   pointed to by SET_HANDLE_PTR.  If so, it returns VTABLE_PTR,\n+   otherwise it calls __vtv_verify_fail, which usually logs error\n+   messages and calls abort.  */\n+\n+const void *\n+__VLTVerifyVtablePointerDebug (void **set_handle_ptr, const void *vtable_ptr,\n+                               const char *set_symbol_name,\n+\t\t\t       const char *vtable_name)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  VTV_DEBUG_ASSERT (set_handle_ptr != NULL && *set_handle_ptr != NULL);\n+  int_vptr vtbl_ptr = (int_vptr) vtable_ptr;\n+\n+  increment_num_calls (&num_calls_to_verify_vtable);\n+  vtv_set_handle *handle_ptr;\n+  if (!is_set_handle_handle (*set_handle_ptr))\n+    handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+  else\n+    handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+\n+  if (vtv_sets::contains (vtbl_ptr, handle_ptr))\n+    {\n+      if (debug_verify_vtable)\n+        {\n+          if (verify_vtable_log_fd == -1)\n+            __vtv_open_log (\"vtv_verify_vtable.log\");\n+          __vtv_add_to_log (verify_vtable_log_fd,\n+\t\t\t    \"Verified %s %s value = %p\\n\",\n+\t\t\t    set_symbol_name, vtable_name, vtable_ptr);\n+        }\n+    }\n+  else\n+    {\n+      /* We failed to find the vtable pointer in the set of valid\n+\t pointers.  Log the error data and call the failure\n+\t function.  */\n+      snprintf (debug_log_message, sizeof (debug_log_message),\n+\t\t\"Looking for %s in %s\\n\", vtable_name, set_symbol_name);\n+      __vtv_verify_fail_debug (set_handle_ptr, vtable_ptr, debug_log_message);\n+\n+      /* Normally __vtv_verify_fail_debug will call abort, so we won't\n+         execute the return below.  If we get this far, the assumption\n+         is that the programmer has replaced __vtv_verify_fail_debug\n+         with some kind of secondary verification AND this secondary\n+         verification succeeded, so the vtable pointer is valid.  */\n+    }\n+  accumulate_cycle_count (&verify_vtable_cycles, start);\n+\n+  return vtable_ptr;\n+}\n+\n+/* This routine initializes a set handle to a vtable set. It makes\n+   sure that there is only one set handle for a particular set by\n+   using a map from set name to pointer to set handle. Since there\n+   will be multiple copies of the pointer to the set handle (one per\n+   compilation unit that uses it), it makes sure to initialize all the\n+   pointers to the set handle so that the set handle is unique. To\n+   make this a little more efficient and avoid a level of indirection\n+   in some cases, the first pointer to handle for a particular handle\n+   becomes the handle itself and the other pointers will point to the\n+   set handle.  SET_HANDLE_PTR is the address of the vtable map\n+   variable, SET_SYMBOL_KEY is the hash table key (containing the name\n+   of the map variable and the hash value) and SIZE_HINT is a guess\n+   for the best initial size for the set of vtable pointers that\n+   SET_HANDLE_POINTER will point to.*/\n+\n+static inline void\n+init_set_symbol (void **set_handle_ptr, const void *set_symbol_key,\n+                 size_t size_hint)\n+{\n+  vtv_set_handle *handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+\n+  if (*handle_ptr != NULL)\n+    {\n+      if (!is_set_handle_handle (*set_handle_ptr))\n+        handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+      else\n+        handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+      vtv_sets::resize (size_hint, handle_ptr);\n+      return;\n+    }\n+\n+  if (vtv_symbol_unification_map == NULL)\n+    vtv_symbol_unification_map = s2s::create (1024);\n+\n+  vtv_symbol_key *symbol_key_ptr = (vtv_symbol_key *) set_symbol_key;\n+  const s2s::value_type *map_value_ptr =\n+                              vtv_symbol_unification_map->get (symbol_key_ptr);\n+\n+  if (map_value_ptr != NULL)\n+    {\n+      if (*map_value_ptr == handle_ptr)\n+        vtv_sets::resize (size_hint, *map_value_ptr);\n+      else\n+        {\n+          /* The one level handle to the set already exists. So, we\n+             are adding one level of indirection here and we will\n+             store a pointer to the one level pointer here.  */\n+          vtv_set_handle_handle *handle_handle_ptr =\n+                                          (vtv_set_handle_handle *) handle_ptr;\n+          *handle_handle_ptr = set_handle_handle (*map_value_ptr);\n+          vtv_sets::resize (size_hint, *map_value_ptr);\n+        }\n+    }\n+  else\n+    {\n+      /* We will create a new set. So, in this case handle_ptr is the\n+         one level pointer to the set handle.  Create copy of map name\n+         in case the memory where this comes from gets unmapped by\n+         dlclose.  */\n+      size_t map_key_len = symbol_key_ptr->n + sizeof (vtv_symbol_key);\n+      void * map_key = __vtv_malloc (map_key_len);\n+      memcpy (map_key, symbol_key_ptr, map_key_len);\n+\n+      s2s::value_type * value_ptr;\n+      vtv_symbol_unification_map =\n+        vtv_symbol_unification_map->find_or_add_key ((vtv_symbol_key *)map_key,\n+                                                     &value_ptr);\n+\n+      *value_ptr = handle_ptr;\n+\n+      /* TODO: We should verify the return value.  */\n+      vtv_sets::create (size_hint, handle_ptr);\n+    }\n+}\n+\n+/* This routine initializes a set handle to a vtable set. It makes\n+   sure that there is only one set handle for a particular set by\n+   using a map from set name to pointer to set handle. Since there\n+   will be multiple copies of the pointer to the set handle (one per\n+   compilation unit that uses it), it makes sure to initialize all the\n+   pointers to the set handle so that the set handle is unique. To\n+   make this a little more efficient and avoid a level of indirection\n+   in some cases, the first pointer to handle for a particular handle\n+   becomes the handle itself and the other pointers will point to the\n+   set handle.  SET_HANDLE_PTR is the address of the vtable map\n+   variable, SET_SYMBOL_KEY is the hash table key (containing the name\n+   of the map variable and the hash value) and SIZE_HINT is a guess\n+   for the best initial size for the set of vtable pointers that\n+   SET_HANDLE_POINTER will point to.*/\n+\n+\n+void\n+__VLTRegisterSet (void **set_handle_ptr, const void *set_symbol_key,\n+                  size_t size_hint, size_t num_args, void **vtable_ptr_array)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  increment_num_calls (&num_calls_to_regset);\n+\n+  init_set_symbol (set_handle_ptr, set_symbol_key, size_hint);\n+  register_set_common (set_handle_ptr, num_args, vtable_ptr_array, false);\n+\n+  accumulate_cycle_count (&regset_cycles, start);\n+}\n+\n+\n+\n+/* This function takes a the address of a vtable map variable\n+   (SET_HANDLE_PTR) and a VTABLE_PTR.  If the vtable map variable is\n+   NULL it creates a new data set and initializes the variable,\n+   otherwise it uses our symbol unification to find the right data\n+   set; in either case it then adds the vtable pointer to the set.  */\n+\n+void\n+__VLTRegisterPair (void **set_handle_ptr, const  void *set_symbol_key,\n+                   size_t size_hint, const void *vtable_ptr)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  increment_num_calls (&num_calls_to_regpair);\n+\n+  init_set_symbol (set_handle_ptr, set_symbol_key, size_hint);\n+  register_pair_common (set_handle_ptr, vtable_ptr, NULL, NULL,  false);\n+\n+  accumulate_cycle_count (&regpair_cycles, start);\n+}\n+\n+/* This is the main verification function.  It takes the address of a\n+   vtable map variable (SET_HANDLE_PTR) and a VTABLE_PTR to validate.\n+   It checks to see if VTABLE_PTR is in the set pointed to by\n+   SET_HANDLE_PTR.  If so, it returns VTABLE_PTR, otherwise it calls\n+   __vtv_verify_fail, which usually logs error messages and calls\n+   abort.  Since this function gets called VERY frequently, it is\n+   important for it to be as efficient as possible.  */\n+\n+const void *\n+__VLTVerifyVtablePointer (void ** set_handle_ptr, const void * vtable_ptr)\n+{\n+  unsigned long long start = get_cycle_count ();\n+  int_vptr vtbl_ptr = (int_vptr) vtable_ptr;\n+\n+  vtv_set_handle *handle_ptr;\n+  increment_num_calls (&num_calls_to_verify_vtable);\n+  if (!is_set_handle_handle (*set_handle_ptr))\n+    handle_ptr = (vtv_set_handle *) set_handle_ptr;\n+  else\n+    handle_ptr = ptr_from_set_handle_handle (*set_handle_ptr);\n+\n+  if (!vtv_sets::contains (vtbl_ptr, handle_ptr))\n+    {\n+      __vtv_verify_fail ((void **) handle_ptr, vtable_ptr);\n+      /* Normally __vtv_verify_fail will call abort, so we won't\n+         execute the return below.  If we get this far, the assumption\n+         is that the programmer has replaced __vtv_verify_fail with\n+         some kind of secondary verification AND this secondary\n+         verification succeeded, so the vtable pointer is valid.  */\n+    }\n+  accumulate_cycle_count (&verify_vtable_cycles, start);\n+\n+  return vtable_ptr;\n+}\n+\n+static int page_count_2 = 0;\n+\n+static int\n+dl_iterate_phdr_count_pages (struct dl_phdr_info *info,\n+                             size_t unused __attribute__ ((__unused__)),\n+                             void *data)\n+{\n+  int *mprotect_flags = (int *) data;\n+  off_t map_sect_offset = 0;\n+  ElfW (Word) map_sect_len = 0;\n+  const char *map_sect_name = VTV_PROTECTED_VARS_SECTION;\n+\n+  /* Check to see if this is the record for the Linux Virtual Dynamic\n+     Shared Object (linux-vdso.so.1), which exists only in memory (and\n+     therefore cannot be read from disk).  */\n+\n+  if (strcmp (info->dlpi_name, \"linux-vdso.so.1\") == 0)\n+    return 0;\n+\n+  if (strlen (info->dlpi_name) == 0\n+      && info->dlpi_addr != 0)\n+    return 0;\n+\n+  read_section_offset_and_length (info, map_sect_name, *mprotect_flags,\n+                                 &map_sect_offset, &map_sect_len);\n+\n+  /* See if we actually found the section.  */\n+  if (map_sect_len)\n+    page_count_2 += (map_sect_len + VTV_PAGE_SIZE - 1) / VTV_PAGE_SIZE;\n+\n+  return 0;\n+}\n+\n+static void\n+count_all_pages (void)\n+{\n+  int mprotect_flags;\n+\n+  mprotect_flags = PROT_READ;\n+  page_count_2 = 0;\n+\n+  dl_iterate_phdr (dl_iterate_phdr_count_pages, (void *) &mprotect_flags);\n+  page_count_2 += __vtv_count_mmapped_pages ();\n+}\n+\n+void\n+__VLTDumpStats (void)\n+{\n+  int log_fd = __vtv_open_log (\"vtv-runtime-stats.log\");\n+\n+  if (log_fd != -1)\n+    {\n+      count_all_pages ();\n+      __vtv_add_to_log (log_fd,\n+\t\t\t\"Calls: mprotect (%d)  regset (%d) regpair (%d)\"\n+\t\t\t\" verify_vtable (%d)\\n\",\n+\t\t\tnum_calls_to_mprotect, num_calls_to_regset,\n+\t\t\tnum_calls_to_regpair, num_calls_to_verify_vtable);\n+      __vtv_add_to_log (log_fd,\n+\t\t\t\"Cycles: mprotect (%lld) regset (%lld) \"\n+\t\t\t\"regpair (%lld) verify_vtable (%lld)\\n\",\n+\t\t\tmprotect_cycles, regset_cycles, regpair_cycles,\n+\t\t\tverify_vtable_cycles);\n+      __vtv_add_to_log (log_fd,\n+\t\t\t\"Pages protected (1): %d\\n\", num_pages_protected);\n+      __vtv_add_to_log (log_fd, \"Pages protected (2): %d\\n\", page_count_2);\n+\n+      close (log_fd);\n+    }\n+}\n+\n+/* This function is called from __VLTVerifyVtablePointerDebug; it\n+   sends as much debugging information as it can to the error log\n+   file, then calls __vtv_verify_fail.  SET_HANDLE_PTR is the pointer\n+   to the set of valid vtable pointers, VTBL_PTR is the pointer that\n+   was not found in the set, and DEBUG_MSG is the message to be\n+   written to the log file before failing. n */\n+\n+void\n+__vtv_verify_fail_debug (void **set_handle_ptr, const void *vtbl_ptr, \n+                         const char *debug_msg)\n+{\n+  __vtv_log_verification_failure (debug_msg, false);\n+\n+  /* Call the public interface in case it has been overwritten by\n+     user.  */\n+  __vtv_verify_fail (set_handle_ptr, vtbl_ptr);\n+\n+  __vtv_log_verification_failure (\"Returned from __vtv_verify_fail.\"\n+                     \" Secondary verification succeeded.\\n\", false);\n+}\n+\n+/* This function calls __fortify_fail with a FAILURE_MSG and then\n+   calls abort.  */\n+\n+void\n+__vtv_really_fail (const char *failure_msg)\n+{\n+  __fortify_fail (failure_msg);\n+\n+  /* We should never get this far; __fortify_fail calls __libc_message\n+     which prints out a back trace and a memory dump and then is\n+     supposed to call abort, but let's play it safe anyway and call abort\n+     ourselves.  */\n+  abort ();\n+}\n+\n+/* This function takes an error MSG, a vtable map variable\n+   (DATA_SET_PTR) and a vtable pointer (VTBL_PTR).  It is called when\n+   an attempt to verify VTBL_PTR with the set pointed to by\n+   DATA_SET_PTR failed.  It outputs a failure message with the\n+   addresses involved, and calls __vtv_really_fail.  */\n+\n+static void\n+vtv_fail (const char *msg, void **data_set_ptr, const void *vtbl_ptr)\n+{\n+  char buffer[128];\n+  int buf_len;\n+  const char *format_str =\n+                 \"*** Unable to verify vtable pointer (%p) in set (%p) *** \\n\";\n+\n+  snprintf (buffer, sizeof (buffer), format_str, vtbl_ptr,\n+            is_set_handle_handle(*data_set_ptr) ?\n+              ptr_from_set_handle_handle (*data_set_ptr) :\n+\t      *data_set_ptr);\n+  buf_len = strlen (buffer);\n+  /*  Send this to to stderr.  */\n+  write (2, buffer, buf_len);\n+\n+#ifndef VTV_NO_ABORT\n+    __vtv_really_fail (msg);\n+#endif\n+}\n+\n+/* Send information about what we were trying to do when verification\n+   failed to the error log, then call vtv_fail.  This function can be\n+   overwritten/replaced by the user, to implement a secondary\n+   verification function instead.  DATA_SET_PTR is the vtable map\n+   variable used for the failed verification, and VTBL_PTR is the\n+   vtable pointer that was not found in the set.  */\n+\n+void\n+__vtv_verify_fail (void **data_set_ptr, const void *vtbl_ptr)\n+{\n+  char log_msg[256];\n+  snprintf (log_msg, sizeof (log_msg), \"Looking for vtable %p in set %p.\\n\",\n+            vtbl_ptr,\n+            is_set_handle_handle (*data_set_ptr) ?\n+              ptr_from_set_handle_handle (*data_set_ptr) :\n+              *data_set_ptr);\n+  __vtv_log_verification_failure (log_msg, false);\n+\n+  const char *format_str =\n+            \"*** Unable to verify vtable pointer (%p) in set (%p) *** \\n\";\n+  snprintf (log_msg, sizeof (log_msg), format_str, vtbl_ptr, *data_set_ptr);\n+  __vtv_log_verification_failure (log_msg, false);\n+  __vtv_log_verification_failure (\"  Backtrace: \\n\", true);\n+\n+  const char *fail_msg = \"Potential vtable pointer corruption detected!!\\n\";\n+  vtv_fail (fail_msg, data_set_ptr, vtbl_ptr);\n+}"}, {"sha": "0e2763cb404688c22f91c409e01a3e52f620bf14", "filename": "libvtv/vtv_rts.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_rts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_rts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_rts.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2012-2013\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef _VTV_RTS_H\n+#define _VTV_RTS_H 1\n+\n+#include <cstdlib>\n+\n+// These prototypes needs to be kept in sync with the compiler-generated declarations in vtable-class-hierarchy.c\n+extern void \n+__VLTRegisterSet(void**, const void*, std::size_t, std::size_t, void**);\n+\n+extern void \n+__VLTRegisterSetDebug(void**, const void*, std::size_t, std::size_t, void**);\n+\n+extern void \n+__VLTRegisterPair(void**, const void*, size_t, const void*);\n+\n+extern void \n+__VLTRegisterPairDebug(void**, const void*, size_t, const void*, \n+\t\t       const char*, const char*);\n+\n+extern const void*\n+__VLTVerifyVtablePointer(void**, const void*);\n+\n+extern const void*\n+__VLTVerifyVtablePointerDebug(void**, const void*, const char*, const char*);\n+\n+#endif /* _VTV_RTS_H */"}, {"sha": "6d0e3c97f9b744ec5c624e40b4b84ddb883e642b", "filename": "libvtv/vtv_set.h", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_set.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,653 @@\n+/* Copyright (C) 2012-2013\n+   Free Software Foundation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License\n+   and a copy of the GCC Runtime Library Exception along with this\n+   program; see the files COPYING3 and COPYING.RUNTIME respectively.\n+   If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _VTV_SET_H\n+#define _VTV_SET_H 1\n+\n+/* Code in this file manages a collection of insert-only sets.  We\n+   have only tested the case where Key is uintptr_t, though it\n+   theoretically should work for some other cases.  All odd keys are\n+   reserved, and must not be inserted into any of the sets.  This code\n+   is intended primarily for sets of pointers, and the code is\n+   optimized for small sets (including size 0 and 1), but regardless\n+   of the set size, insert() and contains() have close to O(1) speed\n+   in practice.\n+\n+   TODO(gpike): fix this comment.\n+\n+   Recommended multithreaded use of a set:\n+\n+   For speed, we want to use a lock-free test for set membership.  The\n+   code handles simultaneous reads and inserts, as long as at most one\n+   insertion is in progress at a time.  After an insert, other threads\n+   may not immediately \"see\" the inserted key if they perform a\n+   lock-free read, so we recommend retrying, as explained below.\n+\n+   Also, to make data corruption less likely, we recommend using a\n+   \"normal\" RW page as well as one or pages that are typically RO\n+   but that can be switched to RW and back as needed.  The latter\n+   pages should contain sets.  The former should contain a lock, L,\n+   and an int or similar, num_writers.  Then, to insert, something\n+   like this would be safe:\n+    o Acquire L.\n+    o Increment num_writers; if that made it 1, change pages to RW.\n+    o Release L.\n+    o while (there are insertions to do in some set, S) {\n+        acquire L;\n+        do some insertions in S;\n+        release L;\n+      }\n+    o Acquire L.\n+    o Decrement num_writers; if that made it 0, change pages to RO.\n+    o Release L.\n+\n+   And to check if the set contains some key, one could use\n+     set.contains(key) ||\n+       ({ Acquire L; bool b = set.contains(key); Release L; b; })\n+\n+   In this scheme, the number of threads with reads in progress isn't\n+   tracked, so old sets can never be deleted.  In addition, on some\n+   architectures the intentionally racy reads might cause contains()\n+   to return true when it should have returned false.  This should be\n+   no problem on x86, and most other machines, where reading or\n+   writing an aligned uintptr_t is atomic.  E.g., on those machines,\n+   if *p is 0 and one thread does *p = x while another reads *p, the\n+   read will see either 0 or x.\n+\n+   To make the above easier, the insert_only_hash_sets class provides\n+   an interface to manipulate any number of hash sets.  One shouldn't\n+   create objects of that class, as it has no member data and its\n+   methods are static.\n+\n+   So the recommended model is to have a single lock, a single\n+   num_writers variable, and some number of sets.  If lock contention\n+   becomes a problem then the sets can be divided into k groups, each\n+   of which has a lock and a num_writers variable; or each set can be\n+   represented as a set of values that equal 0 mod m, a set of values\n+   that equal 1 mod m, ..., plus a set of values that equal m-1 mod m.\n+\n+   However, we expect most or all uses of this code to call contains()\n+   much more frequently than anything else, so lock contention is\n+   likely to be low.  */\n+\n+#include <algorithm>\n+\n+#ifndef HASHTABLE_STATS\n+#define HASHTABLE_STATS 0\n+#endif\n+\n+#ifndef HASHTABLE_STATS_ATOMIC\n+#define HASHTABLE_STATS_ATOMIC 0\n+#endif\n+\n+#if HASHTABLE_STATS\n+#if HASHTABLE_STATS_ATOMIC\n+/* Stat counters, with atomics. */\n+#include <bits/atomic_word.h>\n+\n+typedef _Atomic_word _AtomicStatCounter;\n+\n+void\n+inc_by (_AtomicStatCounter &stat, int amount)\n+{ \n+  __atomic_add_fetch (&stat, amount,  __ATOMIC_ACQ_REL);\n+}\n+\n+#else\n+\n+/* Stat counters, but without atomics. */\n+typedef int _AtomicStatCounter;\n+\n+void\n+inc_by (_AtomicStatCounter& stat, int amount)\n+{ \n+  stat += amount;\n+}\n+\n+#endif\n+\n+\n+/* Number of calls to contains(), insert(), etc. */\n+extern _AtomicStatCounter stat_insert;\n+extern _AtomicStatCounter stat_contains;\n+extern _AtomicStatCounter stat_resize;\n+extern _AtomicStatCounter stat_create;\n+\n+/* Sum of set size over all calls to contains().  */\n+extern _AtomicStatCounter stat_contains_sizes;\n+\n+/* contains() calls in a set whose capacity is more than 1. */\n+extern _AtomicStatCounter stat_contains_in_non_trivial_set;\n+\n+/* Probes in a set whose capacity is more than 1.  Ideally, this will\n+   be pretty close to stat_contains_in_non_trivial_set.  That will\n+   happen if our hash function is good and/or important keys were\n+   inserted before unimportant keys.  */\n+extern _AtomicStatCounter stat_probes_in_non_trivial_set;\n+\n+/* number of calls to contains() with size=0, 1, etc. */\n+extern _AtomicStatCounter stat_contains_size0;\n+extern _AtomicStatCounter stat_contains_size1;\n+extern _AtomicStatCounter stat_contains_size2;\n+extern _AtomicStatCounter stat_contains_size3;\n+extern _AtomicStatCounter stat_contains_size4;\n+extern _AtomicStatCounter stat_contains_size5;\n+extern _AtomicStatCounter stat_contains_size6;\n+extern _AtomicStatCounter stat_contains_size7;\n+extern _AtomicStatCounter stat_contains_size8;\n+extern _AtomicStatCounter stat_contains_size9;\n+extern _AtomicStatCounter stat_contains_size10;\n+extern _AtomicStatCounter stat_contains_size11;\n+extern _AtomicStatCounter stat_contains_size12;\n+extern _AtomicStatCounter stat_contains_size13_or_more;\n+extern _AtomicStatCounter stat_grow_from_size0_to_1;\n+extern _AtomicStatCounter stat_grow_from_size1_to_2;\n+extern _AtomicStatCounter stat_double_the_number_of_buckets;\n+extern _AtomicStatCounter stat_insert_key_that_was_already_present;\n+\n+/* Hash collisions detected during insert_no_resize().  Only counts\n+   hasher(k) == hasher(k'); hasher(k) % tablesize == hasher(k') %\n+   tablesize is not sufficient.  Will count collisions that are\n+   detected during table resizes etc., so the same two keys may add to\n+   this stat multiple times.  */\n+extern _AtomicStatCounter stat_insert_found_hash_collision;\n+\n+#include <string>\n+\n+struct insert_only_hash_sets_logger\n+{\n+  static char *\n+  log (char c, char *buf)\n+  {\n+    *buf++ = c;\n+    return buf;\n+  }\n+\n+  static char *\n+  log (const char *s, char *buf)\n+  { return strcpy (buf, s) + strlen (s); }\n+\n+  static char *\n+  log (_AtomicStatCounter i, char *buf)\n+  {\n+    if (i < 10)\n+      return log ((char) ('0' + i), buf);\n+    else\n+      return log ((char) ('0' + i % 10), log (i / 10, buf));\n+  }\n+\n+  static char *\n+  log (const char *label, _AtomicStatCounter i, char *buf)\n+  {\n+    buf = log (label, buf);\n+    buf = log (\": \", buf);\n+    buf = log (i, buf);\n+    return log ('\\n', buf);\n+  }\n+};\n+\n+// Write stats to the given buffer, which should be at least 4000 bytes.\n+static inline void\n+insert_only_hash_tables_stats (char *buf)\n+{\n+  buf = insert_only_hash_sets_logger::log (\"insert\", stat_insert, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains\", stat_contains, buf);\n+  buf = insert_only_hash_sets_logger::log (\"resize\", stat_resize, buf);\n+  buf = insert_only_hash_sets_logger::log (\"create\", stat_create, buf);\n+  buf = insert_only_hash_sets_logger::log (\"insert_key_that_was_already_\"\n+\t\t\t\t      \"present\",\n+\t\t\t\t      stat_insert_key_that_was_already_present,\n+\t\t\t\t      buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_sizes\",\n+\t\t\t\t\t   stat_contains_sizes, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_in_non_trivial_set\",\n+\t\t\t\t\t   stat_contains_in_non_trivial_set,\n+\t\t\t\t\t   buf);\n+  buf = insert_only_hash_sets_logger::log (\"probes_in_non_trivial_set\",\n+\t\t\t\t\t   stat_probes_in_non_trivial_set,\n+\t\t\t\t\t   buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size0\",\n+\t\t\t\t\t   stat_contains_size0, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size1\",\n+\t\t\t\t\t   stat_contains_size1, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size2\",\n+\t\t\t\t\t   stat_contains_size2, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size3\",\n+\t\t\t\t\t   stat_contains_size3, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size4\",\n+\t\t\t\t\t   stat_contains_size4, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size5\",\n+\t\t\t\t\t   stat_contains_size5, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size6\",\n+\t\t\t\t\t   stat_contains_size6, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size7\",\n+\t\t\t\t\t   stat_contains_size7, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size8\",\n+\t\t\t\t\t   stat_contains_size8, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size9\",\n+\t\t\t\t\t   stat_contains_size9, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size10\",\n+\t\t\t\t\t   stat_contains_size10, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size11\",\n+\t\t\t\t\t   stat_contains_size11, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size12\",\n+\t\t\t\t\t   stat_contains_size12, buf);\n+  buf = insert_only_hash_sets_logger::log (\"contains_size13_or_more\",\n+\t\t\t\t\t   stat_contains_size13_or_more, buf);\n+  buf = insert_only_hash_sets_logger::log (\"grow_from_size0_to_1\",\n+\t\t\t\t\t   stat_grow_from_size0_to_1, buf);\n+  buf = insert_only_hash_sets_logger::log (\"grow_from_size1_to_2\",\n+\t\t\t\t\t   stat_grow_from_size1_to_2, buf);\n+  buf = insert_only_hash_sets_logger::log (\"insert_found_hash_collision\",\n+\t\t\t\t\t   stat_insert_found_hash_collision,\n+\t\t\t\t\t   buf);\n+  buf = insert_only_hash_sets_logger::log (\"double_the_number_of_buckets\",\n+\t\t\t\t\t   stat_double_the_number_of_buckets,\n+\t\t\t\t\t   buf);\n+  *buf = '\\0';\n+}\n+\n+#else\n+\n+/* No stats. */\n+#define inc_by(statname, amount) do { } while (false && (amount))\n+\n+#endif\n+\n+#define inc(statname) inc_by (statname, 1)\n+\n+template <typename Key, class HashFcn, class Alloc>\n+class insert_only_hash_sets\n+{\n+ public:\n+  typedef Key key_type;\n+  typedef size_t size_type;\n+  typedef Alloc alloc_type;\n+  enum { illegal_key = 1 };\n+  enum { min_capacity = 4 };\n+#if HASHTABLE_STATS\n+  enum { stats = true };\n+#else\n+  enum { stats = false };\n+#endif\n+\n+  /* Do not directly use insert_only_hash_set.  Instead, use the\n+     static methods below to create and manipulate objects of the\n+     following class.\n+  \n+     Implementation details: each set is represented by a pointer\n+     plus, perhaps, out-of-line data, which would be an object of type\n+     insert_only_hash_set.  For a pointer, s, the interpretation is: s\n+     == NULL means empty set, lsb(s) == 1 means a set with one\n+     element, which is (uintptr_t)s - 1, and otherwise s is a pointer\n+     of type insert_only_hash_set*.  So, to increase the size of a set\n+     we have to change s and/or *s.  To check if a set contains some\n+     key we have to examine s and possibly *s.  */\n+  class insert_only_hash_set\n+  {\n+   public:\n+    /* Insert a key.  The key must not be a reserved key.  */\n+    static inline insert_only_hash_set *insert (key_type key,\n+\t\t\t\t\t\tinsert_only_hash_set *s);\n+    \n+\n+    /* Create an empty set.  */\n+    static inline insert_only_hash_set *create (size_type capacity);\n+\n+    /* Return whether the given key is present.  If key is illegal_key\n+       then either true or false may be returned, but for all other\n+       reserved keys false will be returned.  */\n+    static bool\n+    contains (key_type key, const insert_only_hash_set *s)\n+    {\n+      if (stats)\n+\t{\n+\t  inc (stat_contains);\n+\t  switch (size (s))\n+\t    {\n+\t      case 0: inc (stat_contains_size0); break;\n+\t      case 1: inc (stat_contains_size1); break;\n+\t      case 2: inc (stat_contains_size2); break;\n+\t      case 3: inc (stat_contains_size3); break;\n+\t      case 4: inc (stat_contains_size4); break;\n+\t      case 5: inc (stat_contains_size5); break;\n+\t      case 6: inc (stat_contains_size6); break;\n+\t      case 7: inc (stat_contains_size7); break;\n+\t      case 8: inc (stat_contains_size8); break;\n+\t      case 9: inc (stat_contains_size9); break;\n+\t      case 10: inc (stat_contains_size10); break;\n+\t      case 11: inc (stat_contains_size11); break;\n+\t      case 12: inc (stat_contains_size12); break;\n+\t      default: inc (stat_contains_size13_or_more); break;\n+\t    }\n+          inc_by (stat_contains_sizes, size (s));\n+\t}\n+\n+      return (singleton (s) ?\n+              singleton_key (key) == s :\n+              ((s != NULL) && s->contains (key)));\n+    }\n+\n+    /* Return a set's size.  */\n+    static size_type\n+    size (const insert_only_hash_set *s)\n+    { return (s == NULL) ? 0 : (singleton (s) ? 1 : s->num_entries); }\n+\n+    static inline insert_only_hash_set *resize (size_type target_num_buckets,\n+\t\t\t\t\t\tinsert_only_hash_set *s);\n+    \n+\n+   private:\n+    /* Return whether a set has size 1. */\n+    static bool\n+    singleton (const insert_only_hash_set *s)\n+    { return (uintptr_t) s & 1; }\n+\n+    /* Return the representation of a singleton set containing the\n+       given key.  */\n+    static insert_only_hash_set *\n+    singleton_key (key_type key)\n+    { return (insert_only_hash_set *) ((uintptr_t) key + 1); }\n+\n+    /* Given a singleton set, what key does it contain?  */\n+    static key_type\n+    extract_singleton_key (const insert_only_hash_set *s)\n+    {\n+      VTV_DEBUG_ASSERT (singleton (s));\n+      return (key_type) ((uintptr_t) s - 1);\n+    }\n+\n+    volatile key_type &\n+    key_at_index (size_type index)\n+    { return buckets[index]; }\n+\n+    key_type\n+    key_at_index (size_type index) const\n+    { return buckets[index]; }\n+\n+    size_type\n+    next_index (size_type index, size_type indices_examined) const\n+    { return (index + indices_examined) & (num_buckets - 1); }\n+\n+    inline void insert_no_resize (key_type key);\n+    \n+    inline bool contains (key_type key) const;\n+    \n+    inline insert_only_hash_set *resize_if_necessary (void);\n+    \n+    size_type num_buckets;  /* Must be a power of 2 not less than\n+\t\t\t       min_capacity.  */\n+    volatile size_type num_entries;\n+    volatile key_type buckets[0];  /* Actual array size is num_buckets.  */\n+  };\n+\n+  /* Create an empty set with the given capacity.  Requires that n be\n+     0 or a power of 2.  If 1 < n < min_capacity then treat n as\n+     min_capacity.  Sets *handle.  Returns true unless the allocator\n+     fails.  Subsequent operations on this set should use the same\n+     handle. */\n+\n+  static inline bool create (size_type n, insert_only_hash_set **handle);\n+\n+  /* Force the capacity of a set to be n, unless it was more than n\n+     already.  Requires that n be 0 or a power of 2.  Sets *handle\n+     unless the current capacity is n or more.  Returns true unless\n+     the allocator fails.  */\n+\n+  static inline bool resize (size_type n, insert_only_hash_set **handle);\n+\n+  /* Insert a key.  *handle is unmodified unless (1) a resize occurs,\n+     or (2) the set was initially empty. Returns true unless the\n+     allocator fails during a resize.  If the allocator fails during a\n+     resize then the set is reset to be the empty set.  The key must\n+     not be a reserved key.  */\n+\n+  static inline bool insert (key_type key, insert_only_hash_set **handle);\n+\n+  /* Check for the presence of a key.  If key is illegal_key then\n+     either true or false may be returned, but for all other reserved\n+     keys false will be returned.  */\n+\n+  static inline bool\n+  contains (key_type key, /* const */ insert_only_hash_set **handle)\n+  { return insert_only_hash_set::contains (key, *handle); }\n+\n+  /* Return the size of the given set.  */\n+  static size_type\n+  size (const insert_only_hash_set **handle)\n+  { return insert_only_hash_set::size (*handle); }\n+\n+  static bool\n+  is_reserved_key (key_type key)\n+  { return ((uintptr_t) key % 2) == 1; }\n+};\n+\n+template <typename Key, class HashFcn, class Alloc>\n+typename insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set *\n+insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set::resize\n+                                         (size_type n, insert_only_hash_set *s)\n+{\n+  if (s == NULL)\n+    return create (n);\n+\n+  size_type capacity = singleton (s) ? 1 : s->num_buckets;\n+\n+  if (n <= capacity)\n+    return s;\n+\n+  insert_only_hash_set *result =\n+                                create (std::max<size_type> (n, min_capacity));\n+  if (result != NULL)\n+    {\n+      if (singleton (s))\n+        {\n+          result->insert_no_resize (extract_singleton_key (s));\n+        }\n+      else\n+        {\n+          for (size_type i = 0; i < s->num_buckets; i++)\n+            if (s->buckets[i] != (key_type) illegal_key)\n+              result->insert_no_resize (s->buckets[i]);\n+        }\n+      VTV_DEBUG_ASSERT (size (result) == size (s));\n+    }\n+  return result;\n+}\n+\n+template <typename Key, class HashFcn, class Alloc>\n+typename insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set *\n+insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set::insert \n+                                        (key_type key, insert_only_hash_set *s)\n+{\n+  VTV_DEBUG_ASSERT (!is_reserved_key (key));\n+\n+  inc_by (stat_grow_from_size0_to_1, s == NULL);\n+\n+  if (s == NULL)\n+    return singleton_key (key);\n+\n+  if (singleton (s))\n+    {\n+      const key_type old_key = extract_singleton_key (s);\n+      if (old_key == key)\n+\treturn s;\n+\n+      /* Grow from size 1 to size 2.  */\n+      inc (stat_grow_from_size1_to_2);\n+      s = create (2);\n+      if (s == NULL)\n+\treturn NULL;\n+\n+      s->insert_no_resize (old_key);\n+      s->insert_no_resize (key);\n+      VTV_DEBUG_ASSERT (size (s) == 2);\n+      return s;\n+    }\n+  s = s->resize_if_necessary();\n+  if (s != NULL)\n+    s->insert_no_resize (key);\n+  return s;\n+}\n+\n+template <typename Key, class HashFcn, class Alloc>\n+typename insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set *\n+insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set::create\n+                                                           (size_type capacity)\n+{\n+  if (capacity <= 1)\n+    return NULL;\n+\n+  VTV_DEBUG_ASSERT (capacity > 1 && (capacity & (capacity - 1)) == 0);\n+  VTV_DEBUG_ASSERT (sizeof (insert_only_hash_set) == 2 * sizeof (size_type));\n+  capacity = std::max <size_type> (capacity, min_capacity);\n+  const size_t num_bytes = sizeof (insert_only_hash_set) +\n+                                                  sizeof (key_type) * capacity;\n+  alloc_type alloc;\n+  insert_only_hash_set *result = (insert_only_hash_set *) alloc (num_bytes);\n+  result->num_buckets = capacity;\n+  result->num_entries = 0;\n+  for (size_type i = 0; i < capacity; i++)\n+    result->buckets[i] = (key_type) illegal_key;\n+  return result;\n+}\n+\n+template <typename Key, class HashFcn, class Alloc>\n+void\n+insert_only_hash_sets<Key, HashFcn,\n+                                 Alloc>::insert_only_hash_set::insert_no_resize\n+                                                                 (key_type key)\n+{\n+  HashFcn hasher;\n+  const size_type capacity = num_buckets;\n+  VTV_DEBUG_ASSERT (capacity >= min_capacity);\n+  VTV_DEBUG_ASSERT (!is_reserved_key (key));\n+  size_type index = hasher (key) & (capacity - 1);\n+  key_type k = key_at_index (index);\n+  size_type indices_examined = 0;\n+  while (k != key)\n+    {\n+      ++indices_examined;\n+      if (k == (key_type) illegal_key)\n+        {\n+          key_at_index (index) = key;\n+          ++num_entries;\n+          return;\n+        }\n+      else\n+\t{\n+\t  inc_by (stat_insert_found_hash_collision,\n+\t\t  hasher (k) == hasher (key));\n+\t}\n+      VTV_DEBUG_ASSERT (indices_examined < capacity);\n+      index = next_index (index, indices_examined);\n+      k = key_at_index (index);\n+    }\n+}\n+\n+template<typename Key, class HashFcn, class Alloc>\n+bool\n+insert_only_hash_sets<Key, HashFcn, Alloc>::insert_only_hash_set::contains\n+                                                           (key_type key) const\n+{\n+  inc (stat_contains_in_non_trivial_set);\n+  HashFcn hasher;\n+  const size_type capacity = num_buckets;\n+  size_type index = hasher (key) & (capacity - 1);\n+  key_type k = key_at_index (index);\n+  size_type indices_examined = 0;\n+  inc (stat_probes_in_non_trivial_set);\n+  while (k != key)\n+    {\n+      ++indices_examined;\n+      if (/*UNLIKELY*/(k == (key_type) illegal_key\n+\t\t       || indices_examined == capacity))\n+\treturn false;\n+\n+      index = next_index (index, indices_examined);\n+      k = key_at_index (index);\n+      inc (stat_probes_in_non_trivial_set);\n+    }\n+  return true;\n+}\n+\n+template <typename Key, class HashFcn, class Alloc>\n+typename insert_only_hash_sets <Key, HashFcn, Alloc>::insert_only_hash_set *\n+   insert_only_hash_sets<Key, HashFcn,\n+                       Alloc>::insert_only_hash_set::resize_if_necessary (void)\n+{\n+  VTV_DEBUG_ASSERT (num_buckets >= min_capacity);\n+  size_type unused = num_buckets - num_entries;\n+  if (unused < (num_buckets >> 2))\n+    {\n+      inc (stat_double_the_number_of_buckets);\n+      size_type new_num_buckets = num_buckets * 2;\n+      insert_only_hash_set *s = create (new_num_buckets);\n+      for (size_type i = 0; i < num_buckets; i++)\n+        if (buckets[i] != (key_type) illegal_key)\n+          s->insert_no_resize (buckets[i]);\n+      VTV_DEBUG_ASSERT (size (this) == size (s));\n+      return s;\n+    }\n+  else\n+    return this;\n+}\n+\n+template<typename Key, class HashFcn, class Alloc>\n+bool\n+insert_only_hash_sets<Key, HashFcn, Alloc>::create (size_type n,\n+\t\t\t\t\t\t insert_only_hash_set **handle)\n+  \n+{\n+  inc (stat_create);\n+  *handle = insert_only_hash_set::create (n);\n+  return (n <= 1) || (*handle != NULL);\n+}\n+\n+template<typename Key, class HashFcn, class Alloc>\n+bool\n+insert_only_hash_sets<Key, HashFcn, Alloc>::resize (size_type n,\n+\t\t\t\t\t         insert_only_hash_set **handle)\n+{\n+  inc (stat_resize);\n+  *handle = insert_only_hash_set::resize (n, *handle);\n+  return (n <= 1) || (*handle != NULL);\n+}\n+\n+template<typename Key, class HashFcn, class Alloc>\n+bool\n+insert_only_hash_sets<Key, HashFcn, Alloc>::insert (key_type key,\n+                                                 insert_only_hash_set **handle)\n+{\n+  inc (stat_insert);\n+  const size_type old_size = insert_only_hash_set::size (*handle);\n+  *handle = insert_only_hash_set::insert (key, *handle);\n+  if (*handle != NULL)\n+    {\n+      const size_type delta = insert_only_hash_set::size (*handle) - old_size;\n+      inc_by (stat_insert_key_that_was_already_present, delta == 0);\n+    }\n+  return *handle != NULL;\n+}\n+\n+#endif /* VTV_SET_H  */"}, {"sha": "480bfa308dc12717d190caba461549f349b4bb25", "filename": "libvtv/vtv_utils.cc", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_utils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_utils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_utils.cc?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,131 @@\n+/* Copyright (C) 2012-2013\n+   Free Software Foundation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is part of the vtable verication runtime library (see\n+   comments in vtv_rts.cc for more information about vtable\n+   verification).  This file contains log file utilities.  */\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <execinfo.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include \"vtv_utils.h\"\n+\n+/* This is the directory into which all vtable verication log files\n+   get written.  */\n+static const char * const logs_dir = \"/tmp/vtv_logs\";\n+static int vtv_failures_log_fd = -1;\n+\n+\n+\n+/* This function takes the NAME of a log file to open, attempts to\n+   open it in the logs_dir directory, and returns the resulting file\n+   decriptor.  */\n+\n+int\n+__vtv_open_log (const char *name)\n+{\n+  char log_name[256];\n+  snprintf (log_name, sizeof (log_name), \"%s/%s\", logs_dir, name);\n+  mkdir (logs_dir, S_IRWXU);\n+  int fd = open (log_name, O_WRONLY | O_APPEND | O_CREAT, S_IRWXU);\n+  if (fd == -1)\n+    __vtv_add_to_log (2, \"Cannot open log file %s %s\\n\", name,\n+                    strerror (errno));\n+  return fd;\n+}\n+\n+/* This function takes a file descriptor (FD) and a string (STR) and\n+   tries to write the string to the file.  */\n+\n+static int\n+vtv_log_write (int fd, const char *str)\n+{\n+  if (write (fd, str, strlen (str)) != -1)\n+    return 0;\n+\n+  if (fd != 2) /* Make sure we dont get in a loop.  */\n+    __vtv_add_to_log (2, \"Error writing to log: %s\\n\", strerror (errno));\n+  return -1;\n+}\n+\n+\n+/* This function takes a file decriptor (LOG_FILE) and an output\n+ format string (FORMAT), followed by zero or more print format\n+ arguments (the same as fprintf, for example).  It gets the current\n+ process ID and PPID, pre-pends them to the formatted message, and\n+ writes write it out to the log file referenced by LOG_FILE via calles\n+ to vtv_log_write.  */\n+\n+int\n+__vtv_add_to_log (int log_file, const char * format, ...)\n+{\n+  /* We dont want to dynamically allocate this buffer. This should be\n+     more than enough in most cases. It if isn't we are careful not to\n+     do a buffer overflow.  */\n+  char output[1024];\n+\n+  va_list ap;\n+  va_start (ap, format);\n+\n+  snprintf (output, sizeof (output), \"VTV: PID=%d PPID=%d \", getpid (),\n+            getppid ());\n+  vtv_log_write (log_file, output);\n+  vsnprintf (output, sizeof (output), format, ap);\n+  vtv_log_write (log_file, output);\n+  va_end (ap);\n+\n+  return 0;\n+}\n+\n+/* Open error logging file, if not already open, and write vtable\n+   verification failure messages (LOG_MSG) to the log file.  Also\n+   generate a backtrace in the log file, if GENERATE_BACKTRACE is\n+   set.  */\n+\n+void\n+__vtv_log_verification_failure (const char *log_msg, bool generate_backtrace)\n+{\n+  if (vtv_failures_log_fd == -1)\n+    vtv_failures_log_fd = __vtv_open_log (\"vtable_verification_failures.log\");\n+\n+  if (vtv_failures_log_fd == -1)\n+    return;\n+\n+  __vtv_add_to_log (vtv_failures_log_fd, \"%s\", log_msg);\n+\n+  if (generate_backtrace)\n+    {\n+#define STACK_DEPTH 20\n+      void *callers[STACK_DEPTH];\n+      int actual_depth = backtrace (callers, STACK_DEPTH);\n+      backtrace_symbols_fd (callers, actual_depth, vtv_failures_log_fd);\n+    }\n+}"}, {"sha": "f20d0b562e9d52456bb5ae227ad60b6ac18e8c92", "filename": "libvtv/vtv_utils.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2077db1be5b18b94a91095a3fb380bbc4a81e61b/libvtv%2Fvtv_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libvtv%2Fvtv_utils.h?ref=2077db1be5b18b94a91095a3fb380bbc4a81e61b", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2012-2013\n+   Free Software Foundation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _VTV_UTILS_H\n+#define _VTV_UTILS_H 1\n+\n+#include <stdlib.h>\n+#include \"../include/vtv-change-permission.h\"\n+\n+static inline void\n+VTV_not_an_error (void)\n+{\n+}\n+\n+/* Handler for verification runtime errors.  */\n+#define VTV_error abort\n+\n+/* Assertion macros used in vtable verification runtime.  */\n+#define VTV_ASSERT(EXPR) \\\n+  if (!(EXPR)) VTV_error();\n+\n+#ifdef VTV_DEBUG\n+#define VTV_DEBUG_ASSERT(EXPR) \\\n+                      ((bool) (!(EXPR)) ? VTV_error() : (void) 0)\n+#else\n+#define VTV_DEBUG_ASSERT(EXPR) ((void) 0)\n+#endif\n+\n+/* Name of the section where we put general VTV variables for protection */\n+#define VTV_PROTECTED_VARS_SECTION \".vtable_map_vars\"\n+#define VTV_PROTECTED_VAR \\\n+                       __attribute__ ((section (VTV_PROTECTED_VARS_SECTION)))\n+\n+/* The following logging routines try to use low level file access\n+   routines and avoid calling malloc. We need this so that we dont\n+   disturb the order of calls to dlopen.  Changing the order of dlopen\n+   calls may lead to deadlocks */\n+int __vtv_open_log (const char * name);\n+int __vtv_add_to_log (int log, const char * format, ...);\n+void __vtv_log_verification_failure (const char *, bool);\n+\n+#endif /* VTV_UTILS_H */"}]}