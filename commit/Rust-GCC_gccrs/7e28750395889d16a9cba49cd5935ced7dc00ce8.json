{"sha": "7e28750395889d16a9cba49cd5935ced7dc00ce8", "node_id": "C_kwDOANBUbNoAKDdlMjg3NTAzOTU4ODlkMTZhOWNiYTQ5Y2Q1OTM1Y2VkN2RjMDBjZTg", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-03-13T11:28:05Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-03-13T12:20:02Z"}, "message": "d: Merge upstream dmd 02a3fafc6, druntime 26b58167, phobos 16cb085b5.\n\nD front-end changes:\n\n    - Import dmd v2.099.0.\n    - The deprecation period for D1-style operators has ended, any use\n      of the D1 overload operators will now result in a compiler error.\n    - `scope' as a type constraint on class, struct, union, and enum\n      declarations has been deprecated.\n    - Fix segmentation fault when emplacing a new front-end Expression\n      node during CTFE (PR104835).\n\nD runtime changes:\n\n    - Import druntime v2.099.0.\n    - Fix C bindings for stdint types (PR104738).\n    - Fix bus error when allocating new array on the GC (PR104742).\n    - Fix bus error when allocating new pointer on the GC (PR104745).\n\nPhobos changes:\n\n    - Import phobos v2.099.0.\n    - New function `bind' in `std.functional'.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 02a3fafc6.\n\t* dmd/VERSION: Update version to v2.099.0.\n\t* imports.cc (ImportVisitor::visit (EnumDeclaration *)): Don't cache\n\tdecl in front-end AST node.\n\t(ImportVisitor::visit (AggregateDeclaration *)): Likewise.\n\t(ImportVisitor::visit (ClassDeclaration *)): Likewise.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 26b58167.\n\t* src/MERGE: Merge upstream phobos 16cb085b5.", "tree": {"sha": "d2a981788cda569e1a226540c009c09ea1b4ac73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2a981788cda569e1a226540c009c09ea1b4ac73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e28750395889d16a9cba49cd5935ced7dc00ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e28750395889d16a9cba49cd5935ced7dc00ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e28750395889d16a9cba49cd5935ced7dc00ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e28750395889d16a9cba49cd5935ced7dc00ce8/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b85638affe6c987a33427c54e0369b819cd7915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b85638affe6c987a33427c54e0369b819cd7915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b85638affe6c987a33427c54e0369b819cd7915"}], "stats": {"total": 2767, "additions": 1792, "deletions": 975}, "files": [{"sha": "220088969c5ac02b5719849e1e43b1461688bb82", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,4 +1,4 @@\n-423f19b41089f627808bf16ff21c60c0791712ba\n+cbba5f41a32cfed7f22a213d537f8e2dee0b92f7\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "17724c661f7ca9101fc6304ef981b19e0037a76c", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1 +1 @@\n-v2.099.0-rc.1\n+v2.099.0"}, {"sha": "0705c1880c055b872856960c1a8fb9f3b7660178", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -662,6 +662,8 @@ struct OutBuffer\n         return cast(char)data[i];\n     }\n \n+    alias opDollar = length;\n+\n     /***********************************\n      * Extract the data as a slice and take ownership of it.\n      *\n@@ -879,3 +881,36 @@ unittest\n     s = unsignedToTempString(29, buf[], 16);\n     assert(s == \"1d\");\n }\n+\n+unittest\n+{\n+    OutBuffer buf;\n+    buf.writeUTF8(0x0000_0011);\n+    buf.writeUTF8(0x0000_0111);\n+    buf.writeUTF8(0x0000_1111);\n+    buf.writeUTF8(0x0001_1111);\n+    buf.writeUTF8(0x0010_0000);\n+    assert(buf[] == \"\\x11\\U00000111\\U00001111\\U00011111\\U00100000\");\n+\n+    buf.reset();\n+    buf.writeUTF16(0x0000_0011);\n+    buf.writeUTF16(0x0010_FFFF);\n+    assert(buf[] == cast(string) \"\\u0011\\U0010FFFF\"w);\n+}\n+\n+unittest\n+{\n+    OutBuffer buf;\n+    buf.doindent = true;\n+\n+    const(char)[] s = \"abc\";\n+    buf.writestring(s);\n+    buf.level += 1;\n+    buf.indent();\n+    buf.writestring(\"abs\");\n+\n+    assert(buf[] == \"abc\\tabs\");\n+\n+    buf.setsize(4);\n+    assert(buf.length == 4);\n+}"}, {"sha": "96ca5207511b9151de84f76bd8839add8274b048", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1230,7 +1230,7 @@ UnionExp ArrayLength(Type type, Expression e1)\n \n /* Also return EXP.cantExpression if this fails\n  */\n-UnionExp Index(Type type, Expression e1, Expression e2)\n+UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n@@ -1255,8 +1255,9 @@ UnionExp Index(Type type, Expression e1, Expression e2)\n         TypeSArray tsa = cast(TypeSArray)e1.type.toBasetype();\n         uinteger_t length = tsa.dim.toInteger();\n         uinteger_t i = e2.toInteger();\n-        if (i >= length)\n+        if (i >= length && (e1.op == EXP.arrayLiteral || !indexIsInBounds))\n         {\n+            // C code only checks bounds if an ArrayLiteralExp\n             e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), length);\n             emplaceExp!(ErrorExp)(&ue);\n         }"}, {"sha": "2edab14c2a4b04bf67b6d442ad87c943596aa9ca", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 264, "deletions": 1, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -22,6 +22,7 @@ import dmd.identifier;\n import dmd.lexer;\n import dmd.parse;\n import dmd.errors;\n+import dmd.root.array;\n import dmd.root.filename;\n import dmd.common.outbuffer;\n import dmd.root.rmem;\n@@ -38,6 +39,24 @@ final class CParser(AST) : Parser!AST\n     bool addFuncName;           /// add declaration of __func__ to function symbol table\n     bool importBuiltins;        /// seen use of C compiler builtins, so import __builtins;\n \n+    private\n+    {\n+        structalign_t packalign;        // current state of #pragma pack alignment\n+\n+        // #pragma pack stack\n+        Array!Identifier* records;      // identifers (or null)\n+        Array!structalign_t* packs;     // parallel alignment values\n+    }\n+\n+    /** C allows declaring a function with a typedef:\n+     *   typedef int (myfunc)(); myfunc fun;\n+     * but we need to distinguish `fun` being a function as opposed to a variable in the\n+     * parse pass. This is accomplished by having a simple symbol table of typedefs\n+     * where we know, by syntax, if they are function types or non-function types.\n+     * funcTypeIds is the symbol table, of the identifiers of typedefs of function types.\n+     */\n+    AST.Identifiers funcTypeIds;  /// Identifiers in this are typedefs of function types\n+\n     extern (D) this(TARGET)(AST.Module _module, const(char)[] input, bool doDocComment,\n                             const ref TARGET target)\n     {\n@@ -47,6 +66,7 @@ final class CParser(AST) : Parser!AST\n         mod = _module;\n         linkage = LINK.c;\n         Ccompile = true;\n+        this.packalign.setDefault();\n \n         // Configure sizes for C `long`, `long double`, `wchar_t`, ...\n         this.boolsize = target.boolsize;\n@@ -130,6 +150,7 @@ final class CParser(AST) : Parser!AST\n \n         //printf(\"cparseStatement()\\n\");\n \n+        const funcTypeIdsLengthSave = funcTypeIds.length;\n         auto symbolsSave = symbols;\n         if (!(flags & (ParseStatementFlags.scope_ | ParseStatementFlags.curlyScope)))\n             symbols = new AST.Dsymbols();\n@@ -572,6 +593,7 @@ final class CParser(AST) : Parser!AST\n         if (pEndloc)\n             *pEndloc = prevloc;\n         symbols = symbolsSave;\n+        funcTypeIds.setDim(funcTypeIdsLengthSave);\n         return s;\n     }\n \n@@ -1551,6 +1573,7 @@ final class CParser(AST) : Parser!AST\n             return;\n         }\n \n+        const funcTypeIdsLengthSave = funcTypeIds.length;\n         auto symbolsSave = symbols;\n         Specifier specifier;\n         specifier.packalign = this.packalign;\n@@ -1660,11 +1683,13 @@ final class CParser(AST) : Parser!AST\n                 t.value == TOK.leftCurly)  // start of compound-statement\n             {\n                 auto s = cparseFunctionDefinition(id, dt.isTypeFunction(), specifier);\n+                funcTypeIds.setDim(funcTypeIdsLengthSave);\n                 symbols = symbolsSave;\n                 symbols.push(s);\n                 return;\n             }\n             AST.Dsymbol s = null;\n+            funcTypeIds.setDim(funcTypeIdsLengthSave);\n             symbols = symbolsSave;\n             if (!symbols)\n                 symbols = new AST.Dsymbols;     // lazilly create it\n@@ -1722,6 +1747,10 @@ final class CParser(AST) : Parser!AST\n                         }\n                     }\n                 }\n+                else if (isFunctionTypedef(dt))\n+                {\n+                    funcTypeIds.push(id);       // remember function typedefs\n+                }\n                 if (isalias)\n                     s = new AST.AliasDeclaration(token.loc, id, dt);\n             }\n@@ -1743,7 +1772,8 @@ final class CParser(AST) : Parser!AST\n                 }\n                 // declare the symbol\n                 assert(id);\n-                if (dt.isTypeFunction())\n+\n+                if (isFunctionTypedef(dt))\n                 {\n                     if (hasInitializer)\n                         error(\"no initializer for function declaration\");\n@@ -4546,5 +4576,238 @@ final class CParser(AST) : Parser!AST\n         return s;\n     }\n \n+    /********************************\n+     * Determines if type t is a function type.\n+     * Make this work without needing semantic analysis.\n+     * Params:\n+     *  t = type to test\n+     * Returns:\n+     *  true if it represents a function\n+     */\n+    bool isFunctionTypedef(AST.Type t)\n+    {\n+        //printf(\"isFunctionTypedef() %s\\n\", t.toChars());\n+        if (t.isTypeFunction())\n+            return true;\n+        if (auto tid = t.isTypeIdentifier())\n+        {\n+            /* Scan array of typedef identifiers that are an alias for\n+             * a function type\n+             */\n+            foreach (ftid; funcTypeIds[])\n+            {\n+                if (tid.ident == ftid)\n+                {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //}\n+\n+    /******************************************************************************/\n+    /********************************* Directive Parser ***************************/\n+    //{\n+\n+    override bool parseSpecialTokenSequence()\n+    {\n+        Token n;\n+        scan(&n);\n+        if (n.value == TOK.int32Literal)\n+        {\n+            poundLine(n, true);\n+            return true;\n+        }\n+        if (n.value == TOK.identifier)\n+        {\n+            if (n.ident == Id.line)\n+            {\n+                poundLine(n, false);\n+                return true;\n+            }\n+            else if (n.ident == Id.__pragma)\n+            {\n+                pragmaDirective(scanloc);\n+                return true;\n+            }\n+        }\n+        error(\"C preprocessor directive `#%s` is not supported\", n.toChars());\n+        return false;\n+    }\n+\n+    /*********************************************\n+     * C11 6.10.6 Pragma directive\n+     * # pragma pp-tokens(opt) new-line\n+     * The C preprocessor sometimes leaves pragma directives in\n+     * the preprocessed output. Ignore them.\n+     * Upon return, p is at start of next line.\n+     */\n+    private void pragmaDirective(const ref Loc loc)\n+    {\n+        Token n;\n+        scan(&n);\n+        if (n.value == TOK.identifier && n.ident == Id.pack)\n+            return pragmaPack(loc);\n+        skipToNextLine();\n+    }\n+\n+    /*********\n+     * # pragma pack\n+     * https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html\n+     * https://docs.microsoft.com/en-us/cpp/preprocessor/pack\n+     * Scanner is on the `pack`\n+     * Params:\n+     *  startloc = location to use for error messages\n+     */\n+    private void pragmaPack(const ref Loc startloc)\n+    {\n+        const loc = startloc;\n+        Token n;\n+        scan(&n);\n+        if (n.value != TOK.leftParenthesis)\n+        {\n+            error(loc, \"left parenthesis expected to follow `#pragma pack`\");\n+            skipToNextLine();\n+            return;\n+        }\n+\n+        void closingParen()\n+        {\n+            if (n.value != TOK.rightParenthesis)\n+            {\n+                error(loc, \"right parenthesis expected to close `#pragma pack(`\");\n+            }\n+            skipToNextLine();\n+        }\n+\n+        void setPackAlign(ref const Token t)\n+        {\n+            const n = t.unsvalue;\n+            if (n < 1 || n & (n - 1) || ushort.max < n)\n+                error(loc, \"pack must be an integer positive power of 2, not 0x%llx\", cast(ulong)n);\n+            packalign.set(cast(uint)n);\n+            packalign.setPack(true);\n+        }\n+\n+        scan(&n);\n+\n+        if (!records)\n+        {\n+            records = new Array!Identifier;\n+            packs = new Array!structalign_t;\n+        }\n+\n+        /* # pragma pack ( show )\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.show)\n+        {\n+            if (packalign.isDefault())\n+                warning(startloc, \"current pack attribute is default\");\n+            else\n+                warning(startloc, \"current pack attribute is %d\", packalign.get());\n+            scan(&n);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( push )\n+         * # pragma pack ( push , identifier )\n+         * # pragma pack ( push , integer )\n+         * # pragma pack ( push , identifier , integer )\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.push)\n+        {\n+            scan(&n);\n+            Identifier record = null;\n+            if (n.value == TOK.comma)\n+            {\n+                scan(&n);\n+                if (n.value == TOK.identifier)\n+                {\n+                    record = n.ident;\n+                    scan(&n);\n+                    if (n.value == TOK.comma)\n+                    {\n+                        scan(&n);\n+                        if (n.value == TOK.int32Literal)\n+                        {\n+                            setPackAlign(n);\n+                            scan(&n);\n+                        }\n+                        else\n+                            error(loc, \"alignment value expected, not `%s`\", n.toChars());\n+                    }\n+                }\n+                else if (n.value == TOK.int32Literal)\n+                {\n+                    setPackAlign(n);\n+                    scan(&n);\n+                }\n+                else\n+                    error(loc, \"alignment value expected, not `%s`\", n.toChars());\n+            }\n+            this.records.push(record);\n+            this.packs.push(packalign);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( pop )\n+         * # pragma pack ( pop PopList )\n+         * PopList :\n+         *    , IdentifierOrInteger\n+         *    , IdentifierOrInteger PopList\n+         * IdentifierOrInteger:\n+         *      identifier\n+         *      integer\n+         */\n+        if (n.value == TOK.identifier && n.ident == Id.pop)\n+        {\n+            scan(&n);\n+            while (n.value == TOK.comma)\n+            {\n+                scan(&n);\n+                if (n.value == TOK.identifier)\n+                {\n+                    for (size_t len = this.records.length; len; --len)\n+                    {\n+                        if ((*this.records)[len - 1] == n.ident)\n+                        {\n+                            packalign = (*this.packs)[len - 1];\n+                            this.records.setDim(len - 1);\n+                            this.packs.setDim(len - 1);\n+                            break;\n+                        }\n+                    }\n+                    scan(&n);\n+                }\n+                else if (n.value == TOK.int32Literal)\n+                {\n+                    setPackAlign(n);\n+                    this.records.push(null);\n+                    this.packs.push(packalign);\n+                    scan(&n);\n+                }\n+            }\n+            return closingParen();\n+        }\n+        /* # pragma pack ( integer )\n+         */\n+        if (n.value == TOK.int32Literal)\n+        {\n+            setPackAlign(n);\n+            scan(&n);\n+            return closingParen();\n+        }\n+        /* # pragma pack ( )\n+         */\n+        if (n.value == TOK.rightParenthesis)\n+        {\n+            packalign.setDefault();\n+            return closingParen();\n+        }\n+\n+        error(loc, \"unrecognized `#pragma pack(%s)`\", n.toChars());\n+        skipToNextLine();\n+    }\n+\n     //}\n }"}, {"sha": "69036ada483ef09035b24436282d9d0d57470890", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2443,7 +2443,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         {\n             printf(\"DelegateExp::castTo(this=%s, type=%s, t=%s)\\n\", e.toChars(), e.type.toChars(), t.toChars());\n         }\n-        __gshared const(char)* msg = \"cannot form delegate due to covariant return type\";\n+        static immutable msg = \"cannot form delegate due to covariant return type\";\n \n         Type tb = t.toBasetype();\n         Type typeb = e.type.toBasetype();\n@@ -2453,7 +2453,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n             int offset;\n             e.func.tookAddressOf++;\n             if (e.func.tintro && e.func.tintro.nextOf().isBaseOf(e.func.type.nextOf(), &offset) && offset)\n-                e.error(\"%s\", msg);\n+                e.error(\"%s\", msg.ptr);\n             auto result = e.copy();\n             result.type = t;\n             return result;\n@@ -2469,15 +2469,15 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 {\n                     int offset;\n                     if (f.tintro && f.tintro.nextOf().isBaseOf(f.type.nextOf(), &offset) && offset)\n-                        e.error(\"%s\", msg);\n+                        e.error(\"%s\", msg.ptr);\n                     if (f != e.func)    // if address not already marked as taken\n                         f.tookAddressOf++;\n                     auto result = new DelegateExp(e.loc, e.e1, f, false, e.vthis2);\n                     result.type = t;\n                     return result;\n                 }\n                 if (e.func.tintro)\n-                    e.error(\"%s\", msg);\n+                    e.error(\"%s\", msg.ptr);\n             }\n         }\n "}, {"sha": "15ac8d917351db6e987f897069497df380189bc6", "filename": "gcc/d/dmd/dclass.d", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -205,7 +205,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n \n         super(loc, id);\n \n-        __gshared const(char)* msg = \"only object.d can define this reserved class name\";\n+        static immutable msg = \"only object.d can define this reserved class name\";\n \n         if (baseclasses)\n         {\n@@ -232,37 +232,37 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n             if (id == Id.TypeInfo)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.dtypeinfo = this;\n             }\n             if (id == Id.TypeInfo_Class)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoclass = this;\n             }\n             if (id == Id.TypeInfo_Interface)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfointerface = this;\n             }\n             if (id == Id.TypeInfo_Struct)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfostruct = this;\n             }\n             if (id == Id.TypeInfo_Pointer)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfopointer = this;\n             }\n             if (id == Id.TypeInfo_Array)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoarray = this;\n             }\n             if (id == Id.TypeInfo_StaticArray)\n@@ -274,94 +274,94 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n             if (id == Id.TypeInfo_AssociativeArray)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoassociativearray = this;\n             }\n             if (id == Id.TypeInfo_Enum)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoenum = this;\n             }\n             if (id == Id.TypeInfo_Function)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfofunction = this;\n             }\n             if (id == Id.TypeInfo_Delegate)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfodelegate = this;\n             }\n             if (id == Id.TypeInfo_Tuple)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfotypelist = this;\n             }\n             if (id == Id.TypeInfo_Const)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoconst = this;\n             }\n             if (id == Id.TypeInfo_Invariant)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoinvariant = this;\n             }\n             if (id == Id.TypeInfo_Shared)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfoshared = this;\n             }\n             if (id == Id.TypeInfo_Wild)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfowild = this;\n             }\n             if (id == Id.TypeInfo_Vector)\n             {\n                 if (!inObject)\n-                    error(\"%s\", msg);\n+                    error(\"%s\", msg.ptr);\n                 Type.typeinfovector = this;\n             }\n         }\n \n         if (id == Id.Object)\n         {\n             if (!inObject)\n-                error(\"%s\", msg);\n+                error(\"%s\", msg.ptr);\n             object = this;\n         }\n \n         if (id == Id.Throwable)\n         {\n             if (!inObject)\n-                error(\"%s\", msg);\n+                error(\"%s\", msg.ptr);\n             throwable = this;\n         }\n         if (id == Id.Exception)\n         {\n             if (!inObject)\n-                error(\"%s\", msg);\n+                error(\"%s\", msg.ptr);\n             exception = this;\n         }\n         if (id == Id.Error)\n         {\n             if (!inObject)\n-                error(\"%s\", msg);\n+                error(\"%s\", msg.ptr);\n             errorException = this;\n         }\n         if (id == Id.cpp_type_info_ptr)\n         {\n             if (!inObject)\n-                error(\"%s\", msg);\n+                error(\"%s\", msg.ptr);\n             cpp_type_info_ptr = this;\n         }\n "}, {"sha": "585ac2f0b609dae312b52cc2717a17a3b34299af", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -29,6 +29,7 @@ import dmd.errors;\n import dmd.expression;\n import dmd.func;\n import dmd.globals;\n+import dmd.gluelayer;\n import dmd.id;\n import dmd.identifier;\n import dmd.init;\n@@ -227,6 +228,8 @@ extern (C++) abstract class Declaration : Dsymbol\n       enum wasRead    = 1; // set if AliasDeclaration was read\n       enum ignoreRead = 2; // ignore any reads of AliasDeclaration\n \n+    Symbol* isym;           // import version of csym\n+\n     // overridden symbol with pragma(mangle, \"...\")\n     const(char)[] mangleOverride;\n \n@@ -679,10 +682,12 @@ extern (C++) final class TupleDeclaration : Declaration\n }\n \n /***********************************************************\n+ * https://dlang.org/spec/declaration.html#AliasDeclaration\n  */\n extern (C++) final class AliasDeclaration : Declaration\n {\n-    Dsymbol aliassym;\n+    Dsymbol aliassym;   // alias ident = aliassym;\n+\n     Dsymbol overnext;   // next in overload list\n     Dsymbol _import;    // !=null if unresolved internal alias for selective import\n "}, {"sha": "93e3a5a0b5dc6338f4f8bf019b2c4d3ca5560245", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -119,6 +119,7 @@ class Declaration : public Dsymbol\n     LINK linkage;\n     short inuse;                // used to detect cycles\n     uint8_t adFlags;\n+    Symbol* isym;               // import version of csym\n     DString mangleOverride;     // overridden symbol with pragma(mangle, \"...\")\n \n     const char *kind() const;"}, {"sha": "00fa031397c9886f26ba9e28186f057a73e59869", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -675,24 +675,28 @@ extern (C++) final class Module : Package\n \n         //printf(\"Module::read('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n \n-        if (global.params.emitMakeDeps)\n-        {\n-            global.params.makeDeps.push(srcfile.toChars());\n-        }\n \n+\n+        bool success;\n         if (auto readResult = FileManager.fileManager.lookup(srcfile))\n         {\n             srcBuffer = readResult;\n-            return true;\n+            success = true;\n         }\n-\n-        auto readResult = File.read(srcfile.toChars());\n-        if (loadSourceBuffer(loc, readResult))\n+        else\n         {\n-            FileManager.fileManager.add(srcfile, srcBuffer);\n-            return true;\n+            auto readResult = File.read(srcfile.toChars());\n+            if (loadSourceBuffer(loc, readResult))\n+            {\n+                FileManager.fileManager.add(srcfile, srcBuffer);\n+                success = true;\n+            }\n         }\n-        return false;\n+        if (success && global.params.emitMakeDeps)\n+        {\n+            global.params.makeDeps.push(srcfile.toChars());\n+        }\n+        return success;\n     }\n \n     /// syntactic parse"}, {"sha": "f8ada2b1ea1ff8b1b9253a37f9bde114f3d6f4ff", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -245,8 +245,6 @@ extern (C++) class Dsymbol : ASTNode\n     /// C++ namespace this symbol belongs to\n     CPPNamespaceDeclaration cppnamespace;\n     Symbol* csym;           // symbol for code generator\n-    Symbol* isym;           // import version of csym\n-    const(char)* comment;   // documentation comment for this Dsymbol\n     const Loc loc;          // where defined\n     Scope* _scope;          // !=null means context to use for semantic()\n     const(char)* prettystring;  // cached value of toPrettyChars()\n@@ -257,10 +255,6 @@ extern (C++) class Dsymbol : ASTNode\n     DeprecatedDeclaration depdecl;           // customized deprecation message\n     UserAttributeDeclaration userAttribDecl;    // user defined attributes\n \n-    // !=null means there's a ddoc unittest associated with this symbol\n-    // (only use this with ddoc)\n-    UnitTestDeclaration ddocUnittest;\n-\n     final extern (D) this()\n     {\n         //printf(\"Dsymbol::Dsymbol(%p)\\n\", this);\n@@ -811,7 +805,7 @@ extern (C++) class Dsymbol : ASTNode\n             Dsymbol s2 = sds.symtabLookup(this,ident);\n \n             // If using C tag/prototype/forward declaration rules\n-            if (sc.flags & SCOPE.Cfile)\n+            if (sc.flags & SCOPE.Cfile && !this.isImport())\n             {\n                 if (handleTagSymbols(*sc, this, s2, sds))\n                     return;\n@@ -1214,17 +1208,65 @@ extern (C++) class Dsymbol : ASTNode\n      */\n     void addComment(const(char)* comment)\n     {\n-        //if (comment)\n-        //    printf(\"adding comment '%s' to symbol %p '%s'\\n\", comment, this, toChars());\n-        if (!this.comment)\n-            this.comment = comment;\n-        else if (comment && strcmp(cast(char*)comment, cast(char*)this.comment) != 0)\n+        if (!comment || !*comment)\n+            return;\n+\n+        //printf(\"addComment '%s' to Dsymbol %p '%s'\\n\", comment, this, toChars());\n+        void* h = cast(void*)this;      // just the pointer is the key\n+        auto p = h in commentHashTable;\n+        if (!p)\n+        {\n+            commentHashTable[h] = comment;\n+            return;\n+        }\n+        if (strcmp(*p, comment) != 0)\n         {\n             // Concatenate the two\n-            this.comment = Lexer.combineComments(this.comment.toDString(), comment.toDString(), true);\n+            *p = Lexer.combineComments((*p).toDString(), comment.toDString(), true);\n         }\n     }\n \n+    /// get documentation comment for this Dsymbol\n+    final const(char)* comment()\n+    {\n+        //printf(\"getcomment: %p '%s'\\n\", this, this.toChars());\n+        if (auto p = cast(void*)this in commentHashTable)\n+        {\n+            //printf(\"comment: '%s'\\n\", *p);\n+            return *p;\n+        }\n+        return null;\n+    }\n+\n+    /* Shell around addComment() to avoid disruption for the moment */\n+    final void comment(const(char)* comment) { addComment(comment); }\n+\n+    private extern (D) __gshared const(char)*[void*] commentHashTable;\n+\n+\n+    /**********************************\n+     * Get ddoc unittest associated with this symbol.\n+     * (only use this with ddoc)\n+     * Returns: ddoc unittest, null if none\n+     */\n+    final UnitTestDeclaration ddocUnittest()\n+    {\n+        if (auto p = cast(void*)this in ddocUnittestHashTable)\n+            return *p;\n+        return null;\n+    }\n+\n+    /**********************************\n+     * Set ddoc unittest associated with this symbol.\n+     */\n+    final void ddocUnittest(UnitTestDeclaration utd)\n+    {\n+        ddocUnittestHashTable[cast(void*)this] = utd;\n+    }\n+\n+    private extern (D) __gshared UnitTestDeclaration[void*] ddocUnittestHashTable;\n+\n+\n     /****************************************\n      * Returns true if this symbol is defined in a non-root module without instantiation.\n      */\n@@ -1247,6 +1289,18 @@ extern (C++) class Dsymbol : ASTNode\n         return false;\n     }\n \n+    /**\n+     * Deinitializes the global state of the compiler.\n+     *\n+     * This can be used to restore the state set by `_init` to its original\n+     * state.\n+     */\n+    static void deinitialize()\n+    {\n+        commentHashTable = commentHashTable.init;\n+        ddocUnittestHashTable = ddocUnittestHashTable.init;\n+    }\n+\n     /************\n      */\n     override void accept(Visitor v)"}, {"sha": "c5af06eb4cd51b4f58b246028c7c00dc7ab33069", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -175,8 +175,6 @@ class Dsymbol : public ASTNode\n     /// C++ namespace this symbol belongs to\n     CPPNamespaceDeclaration *namespace_;\n     Symbol *csym;               // symbol for code generator\n-    Symbol *isym;               // import version of csym\n-    const utf8_t *comment;      // documentation comment for this Dsymbol\n     Loc loc;                    // where defined\n     Scope *_scope;               // !=NULL means context to use for semantic()\n     const utf8_t *prettystring;\n@@ -185,7 +183,6 @@ class Dsymbol : public ASTNode\n     unsigned short localNum;        // perturb mangled name to avoid collisions with those in FuncDeclaration.localsymtab\n     DeprecatedDeclaration *depdecl; // customized deprecation message\n     UserAttributeDeclaration *userAttribDecl;   // user defined attributes\n-    UnitTestDeclaration *ddocUnittest; // !=NULL means there's a ddoc unittest associated with this symbol (only use this with ddoc)\n \n     static Dsymbol *create(Identifier *);\n     const char *toChars() const;\n@@ -252,6 +249,10 @@ class Dsymbol : public ASTNode\n     virtual void checkCtorConstInit() { }\n \n     virtual void addComment(const utf8_t *comment);\n+    const utf8_t *comment();                      // current value of comment\n+\n+    UnitTestDeclaration *ddocUnittest();\n+    void ddocUnittest(UnitTestDeclaration *);\n \n     bool inNonRoot();\n "}, {"sha": "b68d840c396028ad4df3e6d812508ca25d94f8d8", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2140,6 +2140,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         Module.dprogress++;\n \n+        // @@@DEPRECATED_2.110@@@ https://dlang.org/deprecate.html#scope%20as%20a%20type%20constraint\n+        // Deprecated in 2.100\n+        // Make an error in 2.110\n+        if (sc.stc & STC.scope_)\n+            deprecation(ed.loc, \"`scope` as a type constraint is deprecated.  Use `scope` at the usage site.\");\n+\n         Scope* sce;\n         if (ed.isAnonymous())\n             sce = sc;\n@@ -3085,6 +3091,25 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             return null;\n         }\n \n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            /* C11 allows a function to be declared with a typedef, D does not.\n+             */\n+            if (auto ti = funcdecl.type.isTypeIdentifier())\n+            {\n+                auto tj = ti.typeSemantic(funcdecl.loc, sc);\n+                if (auto tjf = tj.isTypeFunction())\n+                {\n+                    /* Copy the type instead of just pointing to it,\n+                     * as we don't merge function types\n+                     */\n+                    auto tjf2 = new TypeFunction(tjf.parameterList, tjf.next, tjf.linkage);\n+                    funcdecl.type = tjf2;\n+                    funcdecl.originalType = tjf2;\n+                }\n+            }\n+        }\n+\n         if (!getFunctionType(funcdecl))\n             return;\n \n@@ -3550,6 +3575,15 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n             default:\n                 {\n+                    if (vi >= cd.vtbl.length)\n+                    {\n+                        /* the derived class cd doesn't have its vtbl[] allocated yet.\n+                         * https://issues.dlang.org/show_bug.cgi?id=21008\n+                         */\n+                        funcdecl.error(\"circular reference to class `%s`\", cd.toChars());\n+                        funcdecl.errors = true;\n+                        return;\n+                    }\n                     FuncDeclaration fdv = cd.baseClass.vtbl[vi].isFuncDeclaration();\n                     FuncDeclaration fdc = cd.vtbl[vi].isFuncDeclaration();\n                     // This function is covariant with fdv\n@@ -4625,6 +4659,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             sd.deferred.semantic2(sc);\n             sd.deferred.semantic3(sc);\n         }\n+\n+        // @@@DEPRECATED_2.110@@@ https://dlang.org/deprecate.html#scope%20as%20a%20type%20constraint\n+        // Deprecated in 2.100\n+        // Make an error in 2.110\n+        if (sd.storage_class & STC.scope_)\n+            deprecation(sd.loc, \"`scope` as a type constraint is deprecated.  Use `scope` at the usage site.\");\n     }\n \n     void interfaceSemantic(ClassDeclaration cd)\n@@ -5283,12 +5323,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n         //printf(\"-ClassDeclaration.dsymbolSemantic(%s), type = %p, sizeok = %d, this = %p\\n\", toChars(), type, sizeok, this);\n \n-        // @@@DEPRECATED_2.097@@@ https://dlang.org/deprecate.html#scope%20as%20a%20type%20constraint\n-        // Deprecated in 2.087\n-        // Make an error in 2.091\n+        // @@@DEPRECATED_2.110@@@ https://dlang.org/deprecate.html#scope%20as%20a%20type%20constraint\n+        // Deprecated in 2.100\n+        // Make an error in 2.110\n         // Don't forget to remove code at https://github.com/dlang/dmd/blob/b2f8274ba76358607fc3297a1e9f361480f9bcf9/src/dmd/dsymbolsem.d#L1032-L1036\n-        if (0 &&          // deprecation disabled for now to accommodate existing extensive use\n-            cldec.storage_class & STC.scope_)\n+        if (cldec.storage_class & STC.scope_)\n             deprecation(cldec.loc, \"`scope` as a type constraint is deprecated.  Use `scope` at the usage site.\");\n     }\n "}, {"sha": "adb91edec78f60c83bda767823df6ff41e0c1413", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -7806,10 +7806,10 @@ struct TemplateInstanceBox\n             /* Used when a proposed instance is used to see if there's\n              * an existing instance.\n              */\n-            static if (__VERSION__ >= 2099)\n-                res = (cast()ti).equalsx(cast()s.ti);\n-            else // https://issues.dlang.org/show_bug.cgi?id=22717\n+            static if (__VERSION__ < 2099) // https://issues.dlang.org/show_bug.cgi?id=22717\n                 res = (cast()s.ti).equalsx(cast()ti);\n+            else\n+                res = (cast()ti).equalsx(cast()s.ti);\n         }\n \n         debug (FindExistingInstance) ++(res ? nHits : nCollisions);"}, {"sha": "285b834f468300fa3548c147526651244dddabfd", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -180,6 +180,15 @@ struct _d_dynamicArray final\n `);\n     }\n \n+    // prevent trailing newlines\n+    version (Windows)\n+        while (buf.length >= 4 && buf[$-4..$] == \"\\r\\n\\r\\n\")\n+            buf.remove(buf.length - 2, 2);\n+    else\n+        while (buf.length >= 2 && buf[$-2..$] == \"\\n\\n\")\n+            buf.remove(buf.length - 1, 1);\n+\n+\n     if (global.params.cxxhdrname is null)\n     {\n         // Write to stdout; assume it succeeds"}, {"sha": "be11f26b04aa17272af19437b8e7759f67c855bc", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -497,7 +497,7 @@ bool checkConstructorEscape(Scope* sc, CallExp ce, bool gag)\n     {\n         Expression arg = (*ce.arguments)[i];\n         if (!arg.type.hasPointers())\n-            return false;\n+            continue;\n \n         //printf(\"\\targ[%d]: %s\\n\", i, arg.toChars());\n \n@@ -620,7 +620,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n                 return false;\n             if (va == fd.vthis) // `this` of a non-static member function is considered to be the first parameter\n                 return true;\n-            if (fd.parameters && fd.parameters.length && (*fd.parameters)[0] == va) // va is first parameter\n+            if (!fd.vthis && fd.parameters && fd.parameters.length && (*fd.parameters)[0] == va) // va is first parameter\n                 return true;\n         }\n         return false;\n@@ -1029,7 +1029,6 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n                  */\n                 !(p.parent == sc.func))\n             {\n-                // Only look for errors if in module listed on command line\n                 if (global.params.useDIP1000 == FeatureState.enabled   // https://issues.dlang.org/show_bug.cgi?id=17029\n                     && sc.func.setUnsafe())     // https://issues.dlang.org/show_bug.cgi?id=20868\n                 {\n@@ -1095,7 +1094,6 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n             continue;\n \n         // https://dlang.org/spec/function.html#return-ref-parameters\n-        // Only look for errors if in module listed on command line\n         if (p == sc.func)\n         {\n             //printf(\"escaping reference to local ref variable %s\\n\", v.toChars());\n@@ -1246,7 +1244,6 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                 !(!refs && sc.func.isFuncDeclaration().getLevel(pfunc, sc.intypeof) > 0)\n                )\n             {\n-                // Only look for errors if in module listed on command line\n                 // https://issues.dlang.org/show_bug.cgi?id=17029\n                 if (global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe())\n                 {\n@@ -1278,11 +1275,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n     {\n         if (log)\n         {\n-            printf(\"byref `%s`\\n\", v.toChars());\n-            if (v.storage_class & STC.return_) printf(\" return\");\n-            if (v.storage_class & STC.ref_)    printf(\" ref\");\n-            if (v.storage_class & STC.scope_)  printf(\" scope\");\n-            printf(\"\\n\");\n+            printf(\"byref `%s` %s\\n\", v.toChars(), toChars(buildScopeRef(v.storage_class)));\n         }\n \n         // 'featureState' tells us whether to emit an error or a deprecation,\n@@ -1714,9 +1707,10 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n                     {\n                         Parameter p = tf.parameterList[i - j];\n                         const stc = tf.parameterStorageClass(null, p);\n-                        if ((stc & (STC.scope_)) && (stc & STC.return_))\n+                        ScopeRef psr = buildScopeRef(stc);\n+                        if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n                             arg.accept(this);\n-                        else if ((stc & (STC.ref_)) && (stc & STC.return_))\n+                        else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                         {\n                             if (tf.isref)\n                             {\n@@ -1974,9 +1968,10 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                         {\n                             Parameter p = tf.parameterList[i - j];\n                             const stc = tf.parameterStorageClass(null, p);\n-                            if ((stc & (STC.out_ | STC.ref_)) && (stc & STC.return_))\n+                            ScopeRef psr = buildScopeRef(stc);\n+                            if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                                 arg.accept(this);\n-                            else if ((stc & STC.scope_) && (stc & STC.return_))\n+                            else if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n                             {\n                                 if (auto de = arg.isDelegateExp())\n                                 {"}, {"sha": "45fefc03dea57f35883c1971eb0ec2d2c1725e89", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -72,10 +72,15 @@ import dmd.typesem;\n import dmd.visitor;\n \n enum LOGSEMANTIC = false;\n+\n void emplaceExp(T : Expression, Args...)(void* p, Args args)\n {\n-    scope tmp = new T(args);\n-    memcpy(p, cast(void*)tmp, __traits(classInstanceSize, T));\n+    static if (__VERSION__ < 2099)\n+        const init = typeid(T).initializer;\n+    else\n+        const init = __traits(initSymbol, T);\n+    p[0 .. __traits(classInstanceSize, T)] = init[];\n+    (cast(T)p).__ctor(args);\n }\n \n void emplaceExp(T : UnionExp)(T* p, Expression e)\n@@ -5831,6 +5836,13 @@ extern (C++) final class IndexExp : BinExp\n         //printf(\"IndexExp::IndexExp('%s')\\n\", toChars());\n     }\n \n+    extern (D) this(const ref Loc loc, Expression e1, Expression e2, bool indexIsInBounds)\n+    {\n+        super(loc, EXP.index, __traits(classInstanceSize, IndexExp), e1, e2);\n+        this.indexIsInBounds = indexIsInBounds;\n+        //printf(\"IndexExp::IndexExp('%s')\\n\", toChars());\n+    }\n+\n     override IndexExp syntaxCopy()\n     {\n         auto ie = new IndexExp(loc, e1.syntaxCopy(), e2.syntaxCopy());"}, {"sha": "f8e5af4ac959951bbf0555f9f1212e2272c18e78", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -5279,6 +5279,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     // The mangling change only works for D mangling\n                 }\n \n+                if (!(sc.flags & SCOPE.Cfile))\n                 {\n                     /* https://issues.dlang.org/show_bug.cgi?id=21272\n                      * If we are in a foreach body we need to extract the\n@@ -7057,19 +7058,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     return setError();\n             }\n         }\n-        else if (exp.e1.op == EXP.call)\n+        else if (auto ce = exp.e1.isCallExp())\n         {\n-            CallExp ce = cast(CallExp)exp.e1;\n-            if (ce.e1.type.ty == Tfunction)\n-            {\n-                TypeFunction tf = cast(TypeFunction)ce.e1.type;\n-                if (tf.isref && sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_)\n-                    && tf.next.hasPointers() && sc.func.setUnsafe())\n-                {\n-                    exp.error(\"cannot take address of `ref return` of `%s()` in `@safe` function `%s`\",\n-                        ce.e1.toChars(), sc.func.toChars());\n-                }\n-            }\n+            if (!checkAddressCall(sc, ce, \"take address of\"))\n+                return setError();\n         }\n         else if (exp.e1.op == EXP.index)\n         {\n@@ -7800,7 +7792,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n \n         Type t1b = exp.e1.type.toBasetype();\n-        if (t1b.ty == Tpointer)\n+        if (auto tp = t1b.isTypePointer())\n         {\n             if (t1b.isPtrToFunction())\n             {\n@@ -7809,7 +7801,27 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             if (!exp.lwr || !exp.upr)\n             {\n-                exp.error(\"need upper and lower bound to slice pointer\");\n+                exp.error(\"upper and lower bounds are needed to slice a pointer\");\n+                if (auto ad = isAggregate(tp.next.toBasetype()))\n+                {\n+                    auto s = search_function(ad, Id.index);\n+                    if (!s) s = search_function(ad, Id.slice);\n+                    if (s)\n+                    {\n+                        auto fd = s.isFuncDeclaration();\n+                        if ((fd && !fd.getParameterList().length) || s.isTemplateDeclaration())\n+                        {\n+                            exp.errorSupplemental(\n+                                \"pointer `%s` points to an aggregate that defines an `%s`, perhaps you meant `(*%s)[]`\",\n+                                exp.e1.toChars(),\n+                                s.ident.toChars(),\n+                                exp.e1.toChars()\n+                            );\n+                        }\n+\n+                    }\n+                }\n+\n                 return setError();\n             }\n             if (sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_) && sc.func.setUnsafe())\n@@ -7844,6 +7856,12 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     if (v && !checkAddressVar(sc, exp.e1, v))\n                         return setError();\n                 }\n+                // https://issues.dlang.org/show_bug.cgi?id=22539\n+                if (auto ce = exp.e1.isCallExp())\n+                {\n+                    if (!checkAddressCall(sc, ce, \"slice static array of\"))\n+                        return setError();\n+                }\n             }\n         }\n         else if (t1b.ty == Ttuple)\n@@ -8446,7 +8464,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 if (length)\n                 {\n                     auto bounds = IntRange(SignExtendedNumber(0), SignExtendedNumber(length - 1));\n-                    exp.indexIsInBounds = bounds.contains(getIntRange(exp.e2));\n+                    // OR it in, because it might already be set for C array indexing\n+                    exp.indexIsInBounds |= bounds.contains(getIntRange(exp.e2));\n                 }\n             }\n         }\n@@ -12943,6 +12962,38 @@ bool checkAddressVar(Scope* sc, Expression exp, VarDeclaration v)\n     return true;\n }\n \n+/****************************************************\n+ * Determine if the address of a `ref return` value of\n+ * a function call with type `tf` can be taken safely.\n+ *\n+ * This is currently stricter than necessary: it can be safe to take the\n+ * address of a `ref` with pointer type when the pointer isn't `scope`, but\n+ * that involves inspecting the function arguments and parameter types, which\n+ * is left as a future enhancement.\n+ *\n+ * Params:\n+ *      sc = context\n+ *      ce = function call in question\n+ *      action = for the error message, how the pointer is taken, e.g. \"slice static array of\"\n+ * Returns:\n+ *      `true` if ok, `false` for error\n+ */\n+private bool checkAddressCall(Scope* sc, CallExp ce, const(char)* action)\n+{\n+    if (auto tf = ce.e1.type.isTypeFunction())\n+    {\n+        if (tf.isref && sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_)\n+            && tf.next.hasPointers() && sc.func.setUnsafe())\n+        {\n+            ce.error(\"cannot %s `ref return` of `%s()` in `@safe` function `%s`\",\n+                action, ce.e1.toChars(), sc.func.toChars());\n+            ce.errorSupplemental(\"return type `%s` has pointers that may be `scope`\", tf.next.toChars());\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n /*******************************\n  * Checks the attributes of a function.\n  * Purity (`pure`), safety (`@safe`), no GC allocations(`@nogc`)"}, {"sha": "72e0e1a93a5480ff5749b6e5dd2c19ae2ba53103", "filename": "gcc/d/dmd/importc.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fimportc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fimportc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimportc.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -159,15 +159,16 @@ Expression carraySemantic(ArrayExp ae, Scope* sc)\n     if (t1.isTypeDArray() || t1.isTypeSArray())\n     {\n         e2 = e2.expressionSemantic(sc).arrayFuncConv(sc);\n-        return new IndexExp(ae.loc, e1, e2).expressionSemantic(sc);\n+        // C doesn't do array bounds checking, so `true` turns it off\n+        return new IndexExp(ae.loc, e1, e2, true).expressionSemantic(sc);\n     }\n \n     e1 = e1.arrayFuncConv(sc);   // e1 might still be a function call\n     e2 = e2.expressionSemantic(sc);\n     auto t2 = e2.type.toBasetype();\n     if (t2.isTypeDArray() || t2.isTypeSArray())\n     {\n-        return new IndexExp(ae.loc, e2, e1).expressionSemantic(sc); // swap operands\n+        return new IndexExp(ae.loc, e2, e1, true).expressionSemantic(sc); // swap operands\n     }\n \n     e2 = e2.arrayFuncConv(sc);"}, {"sha": "dbdf6a503d19b43e1d36c52d83487bdda7de5220", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 42, "deletions": 302, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -68,8 +68,6 @@ class Lexer\n     ubyte long_doublesize;      /// size of C long double, 8 or D real.sizeof\n     ubyte wchar_tsize;          /// size of C wchar_t, 2 or 4\n \n-    structalign_t packalign;    /// current state of #pragma pack alignment (ImportC)\n-\n     private\n     {\n         const(char)* base;      // pointer to start of buffer\n@@ -89,10 +87,6 @@ class Lexer\n         int lastDocLine;        // last line of previous doc comment\n \n         Token* tokenFreelist;\n-\n-        // ImportC #pragma pack stack\n-        Array!Identifier* records;      // identifers (or null)\n-        Array!structalign_t* packs;     // parallel alignment values\n     }\n \n   nothrow:\n@@ -124,7 +118,6 @@ class Lexer\n         this.commentToken = commentToken;\n         this.inTokenStringConstant = 0;\n         this.lastDocLine = 0;\n-        this.packalign.setDefault();\n         //initKeywords();\n         /* If first line starts with '#!', ignore the line\n          */\n@@ -381,24 +374,18 @@ class Lexer\n                 goto case_ident;\n \n             case 'r':\n-                if (p[1] != '\"')\n+                if (Ccompile || p[1] != '\"')\n                     goto case_ident;\n                 p++;\n                 goto case '`';\n             case '`':\n+                if (Ccompile)\n+                    goto default;\n                 wysiwygStringConstant(t);\n                 return;\n-            case 'x':\n-                if (p[1] != '\"')\n-                    goto case_ident;\n-                p++;\n-                auto start = p;\n-                OutBuffer hexString;\n-                t.value = hexStringConstant(t);\n-                hexString.write(start[0 .. p - start]);\n-                error(\"Built-in hex string literals are obsolete, use `std.conv.hexString!%s` instead.\", hexString.extractChars());\n-                return;\n             case 'q':\n+                if (Ccompile)\n+                    goto case_ident;\n                 if (p[1] == '\"')\n                 {\n                     p++;\n@@ -438,7 +425,7 @@ class Lexer\n             //case 'u':\n             case 'v':\n             case 'w':\n-                /*case 'x':*/\n+            case 'x':\n             case 'y':\n             case 'z':\n             case 'A':\n@@ -676,6 +663,7 @@ class Lexer\n                     endOfLine();\n                     continue;\n                 case '+':\n+                    if (!Ccompile)\n                     {\n                         int nest;\n                         startLoc = loc();\n@@ -745,6 +733,7 @@ class Lexer\n                         }\n                         continue;\n                     }\n+                    break;\n                 default:\n                     break;\n                 }\n@@ -1051,35 +1040,8 @@ class Lexer\n             case '#':\n                 {\n                     p++;\n-                    Token n;\n-                    scan(&n);\n-                    if (Ccompile && n.value == TOK.int32Literal)\n-                    {\n-                        poundLine(n, true);\n+                    if (parseSpecialTokenSequence())\n                         continue;\n-                    }\n-                    if (n.value == TOK.identifier)\n-                    {\n-                        if (n.ident == Id.line)\n-                        {\n-                            poundLine(n, false);\n-                            continue;\n-                        }\n-                        else if (n.ident == Id.__pragma && Ccompile)\n-                        {\n-                            pragmaDirective(scanloc);\n-                            continue;\n-                        }\n-                        else\n-                        {\n-                            const locx = loc();\n-                            warning(locx, \"C preprocessor directive `#%s` is not supported\", n.ident.toChars());\n-                        }\n-                    }\n-                    else if (n.value == TOK.if_)\n-                    {\n-                        error(\"C preprocessor directive `#if` is not supported, use `version` or `static if`\");\n-                    }\n                     t.value = TOK.pound;\n                     return;\n                 }\n@@ -1388,84 +1350,6 @@ class Lexer\n         }\n     }\n \n-    /**************************************\n-     * Lex hex strings:\n-     *      x\"0A ae 34FE BD\"\n-     */\n-    private TOK hexStringConstant(Token* t)\n-    {\n-        Loc start = loc();\n-        uint n = 0;\n-        uint v = ~0; // dead assignment, needed to suppress warning\n-        p++;\n-        stringbuffer.setsize(0);\n-        while (1)\n-        {\n-            dchar c = *p++;\n-            switch (c)\n-            {\n-            case ' ':\n-            case '\\t':\n-            case '\\v':\n-            case '\\f':\n-                continue; // skip white space\n-            case '\\r':\n-                if (*p == '\\n')\n-                    continue; // ignore '\\r' if followed by '\\n'\n-                // Treat isolated '\\r' as if it were a '\\n'\n-                goto case '\\n';\n-            case '\\n':\n-                endOfLine();\n-                continue;\n-            case 0:\n-            case 0x1A:\n-                error(\"unterminated string constant starting at %s\", start.toChars());\n-                t.setString();\n-                // decrement `p`, because it needs to point to the next token (the 0 or 0x1A character is the TOK.endOfFile token).\n-                p--;\n-                return TOK.hexadecimalString;\n-            case '\"':\n-                if (n & 1)\n-                {\n-                    error(\"odd number (%d) of hex characters in hex string\", n);\n-                    stringbuffer.writeByte(v);\n-                }\n-                t.setString(stringbuffer);\n-                stringPostfix(t);\n-                return TOK.hexadecimalString;\n-            default:\n-                if (c >= '0' && c <= '9')\n-                    c -= '0';\n-                else if (c >= 'a' && c <= 'f')\n-                    c -= 'a' - 10;\n-                else if (c >= 'A' && c <= 'F')\n-                    c -= 'A' - 10;\n-                else if (c & 0x80)\n-                {\n-                    p--;\n-                    const u = decodeUTF();\n-                    p++;\n-                    if (u == PS || u == LS)\n-                        endOfLine();\n-                    else\n-                        error(\"non-hex character \\\\u%04x in hex string\", u);\n-                }\n-                else\n-                    error(\"non-hex character '%c' in hex string\", c);\n-                if (n & 1)\n-                {\n-                    v = (v << 4) | c;\n-                    stringbuffer.writeByte(v);\n-                }\n-                else\n-                    v = c;\n-                n++;\n-                break;\n-            }\n-        }\n-        assert(0); // see bug 15731\n-    }\n-\n     /**\n     Lex a delimited string. Some examples of delimited strings are:\n     ---\n@@ -2666,6 +2550,37 @@ class Lexer\n         va_end(args);\n     }\n \n+    /***************************************\n+     * Parse special token sequence:\n+     * Returns:\n+     *  true if the special token sequence was handled\n+     * References:\n+     *  https://dlang.org/spec/lex.html#special-token-sequence\n+     */\n+    bool parseSpecialTokenSequence()\n+    {\n+        Token n;\n+        scan(&n);\n+        if (n.value == TOK.identifier)\n+        {\n+            if (n.ident == Id.line)\n+            {\n+                poundLine(n, false);\n+                return true;\n+            }\n+            else\n+            {\n+                const locx = loc();\n+                warning(locx, \"C preprocessor directive `#%s` is not supported\", n.ident.toChars());\n+            }\n+        }\n+        else if (n.value == TOK.if_)\n+        {\n+            error(\"C preprocessor directive `#if` is not supported, use `version` or `static if`\");\n+        }\n+        return false;\n+    }\n+\n     /*********************************************\n      * Parse line/file preprocessor directive:\n      *    #line linnum [filespec]\n@@ -2680,7 +2595,7 @@ class Lexer\n      * References:\n      *  linemarker https://gcc.gnu.org/onlinedocs/gcc-11.1.0/cpp/Preprocessor-Output.html\n      */\n-    private void poundLine(ref Token tok, bool linemarker)\n+    final void poundLine(ref Token tok, bool linemarker)\n     {\n         auto linnum = this.scanloc.linnum;\n         const(char)* filespec = null;\n@@ -2806,183 +2721,10 @@ class Lexer\n             error(loc, \"#line integer [\\\"filespec\\\"]\\\\n expected\");\n     }\n \n-    /*********************************************\n-     * C11 6.10.6 Pragma directive\n-     * # pragma pp-tokens(opt) new-line\n-     * The C preprocessor sometimes leaves pragma directives in\n-     * the preprocessed output. Ignore them.\n-     * Upon return, p is at start of next line.\n-     */\n-    private void pragmaDirective(const ref Loc loc)\n-    {\n-        Token n;\n-        scan(&n);\n-        if (n.value == TOK.identifier && n.ident == Id.pack)\n-            return pragmaPack(loc);\n-        skipToNextLine();\n-    }\n-\n-    /*********\n-     * ImportC\n-     * # pragma pack\n-     * https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/Structure_002dPacking-Pragmas.html\n-     * https://docs.microsoft.com/en-us/cpp/preprocessor/pack\n-     * Scanner is on the `pack`\n-     * Params:\n-     *  startloc = location to use for error messages\n-     */\n-    private void pragmaPack(const ref Loc startloc)\n-    {\n-        const loc = startloc;\n-        Token n;\n-        scan(&n);\n-        if (n.value != TOK.leftParenthesis)\n-        {\n-            error(loc, \"left parenthesis expected to follow `#pragma pack`\");\n-            skipToNextLine();\n-            return;\n-        }\n-\n-        void closingParen()\n-        {\n-            if (n.value != TOK.rightParenthesis)\n-            {\n-                error(loc, \"right parenthesis expected to close `#pragma pack(`\");\n-            }\n-            skipToNextLine();\n-        }\n-\n-        void setPackAlign(ref const Token t)\n-        {\n-            const n = t.unsvalue;\n-            if (n < 1 || n & (n - 1) || ushort.max < n)\n-                error(loc, \"pack must be an integer positive power of 2, not 0x%llx\", cast(ulong)n);\n-            packalign.set(cast(uint)n);\n-            packalign.setPack(true);\n-        }\n-\n-        scan(&n);\n-\n-        if (!records)\n-        {\n-            records = new Array!Identifier;\n-            packs = new Array!structalign_t;\n-        }\n-\n-        /* # pragma pack ( show )\n-         */\n-        if (n.value == TOK.identifier && n.ident == Id.show)\n-        {\n-            if (packalign.isDefault())\n-                warning(startloc, \"current pack attribute is default\");\n-            else\n-                warning(startloc, \"current pack attribute is %d\", packalign.get());\n-            scan(&n);\n-            return closingParen();\n-        }\n-        /* # pragma pack ( push )\n-         * # pragma pack ( push , identifier )\n-         * # pragma pack ( push , integer )\n-         * # pragma pack ( push , identifier , integer )\n-         */\n-        if (n.value == TOK.identifier && n.ident == Id.push)\n-        {\n-            scan(&n);\n-            Identifier record = null;\n-            if (n.value == TOK.comma)\n-            {\n-                scan(&n);\n-                if (n.value == TOK.identifier)\n-                {\n-                    record = n.ident;\n-                    scan(&n);\n-                    if (n.value == TOK.comma)\n-                    {\n-                        scan(&n);\n-                        if (n.value == TOK.int32Literal)\n-                        {\n-                            setPackAlign(n);\n-                            scan(&n);\n-                        }\n-                        else\n-                            error(loc, \"alignment value expected, not `%s`\", n.toChars());\n-                    }\n-                }\n-                else if (n.value == TOK.int32Literal)\n-                {\n-                    setPackAlign(n);\n-                    scan(&n);\n-                }\n-                else\n-                    error(loc, \"alignment value expected, not `%s`\", n.toChars());\n-            }\n-            this.records.push(record);\n-            this.packs.push(packalign);\n-            return closingParen();\n-        }\n-        /* # pragma pack ( pop )\n-         * # pragma pack ( pop PopList )\n-         * PopList :\n-         *    , IdentifierOrInteger\n-         *    , IdentifierOrInteger PopList\n-         * IdentifierOrInteger:\n-         *      identifier\n-         *      integer\n-         */\n-        if (n.value == TOK.identifier && n.ident == Id.pop)\n-        {\n-            scan(&n);\n-            while (n.value == TOK.comma)\n-            {\n-                scan(&n);\n-                if (n.value == TOK.identifier)\n-                {\n-                    for (size_t len = this.records.length; len; --len)\n-                    {\n-                        if ((*this.records)[len - 1] == n.ident)\n-                        {\n-                            packalign = (*this.packs)[len - 1];\n-                            this.records.setDim(len - 1);\n-                            this.packs.setDim(len - 1);\n-                            break;\n-                        }\n-                    }\n-                    scan(&n);\n-                }\n-                else if (n.value == TOK.int32Literal)\n-                {\n-                    setPackAlign(n);\n-                    this.records.push(null);\n-                    this.packs.push(packalign);\n-                    scan(&n);\n-                }\n-            }\n-            return closingParen();\n-        }\n-        /* # pragma pack ( integer )\n-         */\n-        if (n.value == TOK.int32Literal)\n-        {\n-            setPackAlign(n);\n-            scan(&n);\n-            return closingParen();\n-        }\n-        /* # pragma pack ( )\n-         */\n-        if (n.value == TOK.rightParenthesis)\n-        {\n-            packalign.setDefault();\n-            return closingParen();\n-        }\n-\n-        error(loc, \"unrecognized `#pragma pack(%s)`\", n.toChars());\n-        skipToNextLine();\n-    }\n-\n     /***************************************\n      * Scan forward to start of next line.\n      */\n-    private void skipToNextLine()\n+    final void skipToNextLine()\n     {\n         while (1)\n         {\n@@ -3557,5 +3299,3 @@ unittest\n         assert(tok == TOK.endOfFile);\n     }\n }\n-\n-"}, {"sha": "18af7721df14ef654812cac76f5a459b31d4e5d8", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -4214,6 +4214,7 @@ extern (C++) final class TypeFunction : TypeNext\n         inoutParam      = 0x0400, // inout on the parameters\n         inoutQual       = 0x0800, // inout on the qualifier\n         isctor          = 0x1000, // the function is a constructor\n+        isreturnscope   = 0x2000, // `this` is returned by value\n     }\n \n     LINK linkage;               // calling convention\n@@ -4247,6 +4248,8 @@ extern (C++) final class TypeFunction : TypeNext\n             this.isref = true;\n         if (stc & STC.return_)\n             this.isreturn = true;\n+        if (stc & STC.returnScope)\n+            this.isreturnscope = true;\n         if (stc & STC.returninferred)\n             this.isreturninferred = true;\n         if (stc & STC.scope_)\n@@ -4285,6 +4288,7 @@ extern (C++) final class TypeFunction : TypeNext\n         t.isproperty = isproperty;\n         t.isref = isref;\n         t.isreturn = isreturn;\n+        t.isreturnscope = isreturnscope;\n         t.isScopeQual = isScopeQual;\n         t.isreturninferred = isreturninferred;\n         t.isscopeinferred = isscopeinferred;\n@@ -4507,6 +4511,7 @@ extern (C++) final class TypeFunction : TypeNext\n             tf.isproperty = t.isproperty;\n             tf.isref = t.isref;\n             tf.isreturn = t.isreturn;\n+            tf.isreturnscope = t.isreturnscope;\n             tf.isScopeQual = t.isScopeQual;\n             tf.isreturninferred = t.isreturninferred;\n             tf.isscopeinferred = t.isscopeinferred;\n@@ -4573,6 +4578,7 @@ extern (C++) final class TypeFunction : TypeNext\n         t.isproperty = isproperty;\n         t.isref = isref;\n         t.isreturn = isreturn;\n+        t.isreturnscope = isreturnscope;\n         t.isScopeQual = isScopeQual;\n         t.isreturninferred = isreturninferred;\n         t.isscopeinferred = isscopeinferred;\n@@ -5136,6 +5142,18 @@ extern (C++) final class TypeFunction : TypeNext\n         else funcFlags &= ~FunctionFlag.isreturn;\n     }\n \n+    /// set or get if the function has the `returnscope` attribute\n+    bool isreturnscope() const pure nothrow @safe @nogc\n+    {\n+        return (funcFlags & FunctionFlag.isreturnscope) != 0;\n+    }\n+    /// ditto\n+    void isreturnscope(bool v) pure nothrow @safe @nogc\n+    {\n+        if (v) funcFlags |= FunctionFlag.isreturnscope;\n+        else funcFlags &= ~FunctionFlag.isreturnscope;\n+    }\n+\n     /// set or get if the function has the `scope` attribute\n     bool isScopeQual() const pure nothrow @safe @nogc\n     {\n@@ -6384,7 +6402,7 @@ extern (C++) final class TypeClass : Type\n         /* Conversion derived to const(base)\n          */\n         int offset = 0;\n-        if (to.isBaseOf(this, &offset) && MODimplicitConv(mod, to.mod))\n+        if (to.isBaseOf(this, &offset) && offset == 0 && MODimplicitConv(mod, to.mod))\n         {\n             // Disallow:\n             //  derived to base"}, {"sha": "3f085b06091cc36d13dd5f062eb6be5dc0b0ccfe", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -625,6 +625,8 @@ class TypeFunction : public TypeNext\n     void isref(bool v);\n     bool isreturn() const;\n     void isreturn(bool v);\n+    bool isreturnscope() const;\n+    void isreturnscope(bool v);\n     bool isScopeQual() const;\n     void isScopeQual(bool v);\n     bool isreturninferred() const;"}, {"sha": "fc643776edda3705106f56c594ff06e5671a2507", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -396,13 +396,10 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                     fd = search_function(ad, id);\n                     if (fd)\n                     {\n-                        // @@@DEPRECATED_2.098@@@.\n-                        // Deprecated in 2.088\n-                        // Make an error in 2.098\n-                        e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n-                        // Rewrite +e1 as e1.add()\n-                        result = build_overload(e.loc, sc, e.e1, null, fd);\n-                        return result;\n+                        // @@@DEPRECATED_2.110@@@.\n+                        // Deprecated in 2.088, made an error in 2.100\n+                        e.error(\"`%s` is obsolete.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n+                        return ErrorExp.get();\n                     }\n                 }\n                 // Didn't find it. Forward to aliasthis\n@@ -670,13 +667,13 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                     s = search_function(ad1, id);\n                     if (s && id != Id.assign)\n                     {\n-                        // @@@DEPRECATED_2.098@@@.\n-                        // Deprecated in 2.088\n-                        // Make an error in 2.098\n+                        // @@@DEPRECATED_2.110@@@.\n+                        // Deprecated in 2.088, made an error in 2.100\n                         if (id == Id.postinc || id == Id.postdec)\n-                            e.deprecation(\"`%s` is deprecated.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n+                            e.error(\"`%s` is obsolete.  Use `opUnary(string op)() if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n                         else\n-                            e.deprecation(\"`%s` is deprecated.  Use `opBinary(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n+                            e.error(\"`%s` is obsolete.  Use `opBinary(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), EXPtoString(e.op).ptr);\n+                        return ErrorExp.get();\n                     }\n                 }\n                 if (ad2 && id_r)\n@@ -689,10 +686,10 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         s_r = null;\n                     if (s_r)\n                     {\n-                        // @@@DEPRECATED_2.098@@@.\n-                        // Deprecated in 2.088\n-                        // Make an error in 2.098\n-                        e.deprecation(\"`%s` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \\\"%s\\\")` instead.\", id_r.toChars(), EXPtoString(e.op).ptr);\n+                        // @@@DEPRECATED_2.110@@@.\n+                        // Deprecated in 2.088, made an error in 2.100\n+                        e.error(\"`%s` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \\\"%s\\\")` instead.\", id_r.toChars(), EXPtoString(e.op).ptr);\n+                        return ErrorExp.get();\n                     }\n                 }\n             }\n@@ -1232,12 +1229,12 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 s = search_function(ad1, id);\n                 if (s)\n                 {\n-                    // @@@DEPRECATED_2.098@@@.\n-                    // Deprecated in 2.088\n-                    // Make an error in 2.098\n+                    // @@@DEPRECATED_2.110@@@.\n+                    // Deprecated in 2.088, made an error in 2.100\n                     scope char[] op = EXPtoString(e.op).dup;\n                     op[$-1] = '\\0'; // remove trailing `=`\n-                    e.deprecation(\"`%s` is deprecated.  Use `opOpAssign(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), op.ptr);\n+                    e.error(\"`%s` is obsolete.  Use `opOpAssign(string op)(...) if (op == \\\"%s\\\")` instead.\", id.toChars(), op.ptr);\n+                    return ErrorExp.get();\n                 }\n             }\n \n@@ -1552,7 +1549,8 @@ bool inferForeachAggregate(Scope* sc, bool isForeach, ref Expression feaggr, out\n  * Params:\n  *      fes = the foreach statement\n  *      sc = context\n- *      sapply = null or opApply or delegate\n+ *      sapply = null or opApply or delegate, overload resolution has not been done.\n+ *               Do overload resolution on sapply.\n  * Returns:\n  *      false for errors\n  */\n@@ -1588,8 +1586,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n          */\n         if (FuncDeclaration fd = sapply.isFuncDeclaration())\n         {\n-            auto fdapply = findBestOpApplyMatch(ethis, fd, fes.parameters);\n-            if (fdapply)\n+            if (auto fdapply = findBestOpApplyMatch(ethis, fd, fes.parameters))\n             {\n                 // Fill in any missing types on foreach parameters[]\n                 matchParamsToOpApply(fdapply.type.isTypeFunction(), fes.parameters, true);\n@@ -1598,7 +1595,7 @@ bool inferApplyArgTypes(ForeachStatement fes, Scope* sc, ref Dsymbol sapply)\n             }\n             return false;\n         }\n-        return sapply !is null;\n+        return true;   // shouldn't this be false?\n     }\n \n     Parameter p = (*fes.parameters)[0];"}, {"sha": "cc02bd9ea7cdc9955be1d3ccee898c104d924487", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -338,9 +338,9 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n     void visitTuple(TupleExp e)\n     {\n         expOptimize(e.e0, WANTvalue);\n-        for (size_t i = 0; i < e.exps.dim; i++)\n+        foreach (ref ex; (*e.exps)[])\n         {\n-            expOptimize((*e.exps)[i], WANTvalue);\n+            expOptimize(ex, WANTvalue);\n         }\n     }\n \n@@ -349,19 +349,19 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         if (e.elements)\n         {\n             expOptimize(e.basis, result & WANTexpand);\n-            for (size_t i = 0; i < e.elements.dim; i++)\n+            foreach (ref ex; (*e.elements)[])\n             {\n-                expOptimize((*e.elements)[i], result & WANTexpand);\n+                expOptimize(ex, result & WANTexpand);\n             }\n         }\n     }\n \n     void visitAssocArrayLiteral(AssocArrayLiteralExp e)\n     {\n         assert(e.keys.dim == e.values.dim);\n-        for (size_t i = 0; i < e.keys.dim; i++)\n+        foreach (i, ref ekey; (*e.keys)[])\n         {\n-            expOptimize((*e.keys)[i], result & WANTexpand);\n+            expOptimize(ekey, result & WANTexpand);\n             expOptimize((*e.values)[i], result & WANTexpand);\n         }\n     }\n@@ -374,9 +374,9 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         e.stageflags |= stageOptimize;\n         if (e.elements)\n         {\n-            for (size_t i = 0; i < e.elements.dim; i++)\n+            foreach (ref ex; (*e.elements)[])\n             {\n-                expOptimize((*e.elements)[i], result & WANTexpand);\n+                expOptimize(ex, result & WANTexpand);\n             }\n         }\n         e.stageflags = old;\n@@ -647,9 +647,9 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         // Optimize parameters\n         if (e.arguments)\n         {\n-            for (size_t i = 0; i < e.arguments.dim; i++)\n+            foreach (ref arg; (*e.arguments)[])\n             {\n-                expOptimize((*e.arguments)[i], WANTvalue);\n+                expOptimize(arg, WANTvalue);\n             }\n         }\n     }\n@@ -663,16 +663,16 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         if (e.arguments)\n         {\n             Type t1 = e.e1.type.toBasetype();\n-            if (t1.ty == Tdelegate)\n-                t1 = t1.nextOf();\n+            if (auto td = t1.isTypeDelegate())\n+                t1 = td.next;\n             // t1 can apparently be void for __ArrayDtor(T) calls\n             if (auto tf = t1.isTypeFunction())\n             {\n-                for (size_t i = 0; i < e.arguments.dim; i++)\n+                foreach (i, ref arg; (*e.arguments)[])\n                 {\n                     Parameter p = tf.parameterList[i];\n                     bool keep = p && p.isReference();\n-                    expOptimize((*e.arguments)[i], WANTvalue, keep);\n+                    expOptimize(arg, WANTvalue, keep);\n                 }\n             }\n         }\n@@ -719,14 +719,17 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             }\n         }\n \n-        if (e.e1.op == EXP.structLiteral && e.e1.type.implicitConvTo(e.type) >= MATCH.constant)\n+        // Returning e.e1 with changing its type\n+        void returnE_e1()\n         {\n-            //printf(\" returning2 %s\\n\", e.e1.toChars());\n-        L1:\n-            // Returning e1 with changing its type\n             ret = (e1old == e.e1 ? e.e1.copy() : e.e1);\n             ret.type = e.type;\n-            return;\n+        }\n+\n+        if (e.e1.op == EXP.structLiteral && e.e1.type.implicitConvTo(e.type) >= MATCH.constant)\n+        {\n+            //printf(\" returning2 %s\\n\", e.e1.toChars());\n+            return returnE_e1();\n         }\n         /* The first test here is to prevent infinite loops\n          */\n@@ -738,7 +741,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         if (e.e1.op == EXP.null_ && (e.type.ty == Tpointer || e.type.ty == Tclass || e.type.ty == Tarray))\n         {\n             //printf(\" returning3 %s\\n\", e.e1.toChars());\n-            goto L1;\n+            return returnE_e1();\n         }\n         if (e.type.ty == Tclass && e.e1.type.ty == Tclass)\n         {\n@@ -750,7 +753,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             if (cdfrom.errors || cdto.errors)\n                 return error();\n             if (cdto == ClassDeclaration.object && !cdfrom.isInterfaceDeclaration())\n-                goto L1;    // can always convert a class to Object\n+                return returnE_e1();    // can always convert a class to Object\n             // Need to determine correct offset before optimizing away the cast.\n             // https://issues.dlang.org/show_bug.cgi?id=16980\n             cdfrom.size(e.loc);\n@@ -760,13 +763,13 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             if (cdto.isBaseOf(cdfrom, &offset) && offset == 0)\n             {\n                 //printf(\" returning4 %s\\n\", e.e1.toChars());\n-                goto L1;\n+                return returnE_e1();\n             }\n         }\n         if (e.e1.type.mutableOf().unSharedOf().equals(e.to.mutableOf().unSharedOf()))\n         {\n             //printf(\" returning5 %s\\n\", e.e1.toChars());\n-            goto L1;\n+            return returnE_e1();\n         }\n         if (e.e1.isConst())\n         {\n@@ -781,7 +784,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                         return error();\n \n                     if (esz == e1sz)\n-                        goto L1;\n+                        return returnE_e1();\n                 }\n                 return;\n             }\n@@ -1065,7 +1068,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         // Don't optimize to an array literal element directly in case an lvalue is requested\n         if (keepLvalue && ex.op == EXP.arrayLiteral)\n             return;\n-        ret = Index(e.type, ex, e.e2).copy();\n+        ret = Index(e.type, ex, e.e2, e.indexIsInBounds).copy();\n         if (CTFEExp.isCantExp(ret) || (!ret.isErrorExp() && keepLvalue && !ret.isLvalue()))\n             ret = e;\n     }"}, {"sha": "480a96c25db9bce25b5e2f4f5dd15ef4cd58adcb", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1971,7 +1971,6 @@ class Parser(AST) : Lexer\n         case TOK.wcharLiteral:\n         case TOK.dcharLiteral:\n         case TOK.string_:\n-        case TOK.hexadecimalString:\n         case TOK.file:\n         case TOK.fileFullPath:\n         case TOK.line:\n@@ -5623,7 +5622,6 @@ LagainStc:\n         case TOK.true_:\n         case TOK.false_:\n         case TOK.string_:\n-        case TOK.hexadecimalString:\n         case TOK.leftParenthesis:\n         case TOK.cast_:\n         case TOK.mul:\n@@ -7106,7 +7104,6 @@ LagainStc:\n                     case TOK.wcharLiteral:\n                     case TOK.dcharLiteral:\n                     case TOK.string_:\n-                    case TOK.hexadecimalString:\n                     case TOK.file:\n                     case TOK.fileFullPath:\n                     case TOK.line:\n@@ -7987,7 +7984,6 @@ LagainStc:\n             break;\n \n         case TOK.string_:\n-        case TOK.hexadecimalString:\n             {\n                 // cat adjacent strings\n                 auto s = token.ustring;\n@@ -7997,7 +7993,7 @@ LagainStc:\n                 {\n                     const prev = token;\n                     nextToken();\n-                    if (token.value == TOK.string_ || token.value == TOK.hexadecimalString)\n+                    if (token.value == TOK.string_)\n                     {\n                         if (token.postfix)\n                         {"}, {"sha": "f229918d89915741538d04d09511f6693692cece", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -866,7 +866,6 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                             assert(t.ty == Tdelegate);\n                             tfld = cast(TypeFunction)t.nextOf();\n                         }\n-                        //printf(\"tfld = %s\\n\", tfld.toChars());\n                     }\n                 }\n             }\n@@ -1442,12 +1441,12 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         /* Call:\n          *      _aApply(aggr, flde)\n          */\n-        __gshared const(char)** fntab =\n+        static immutable fntab =\n         [\n          \"cc\", \"cw\", \"cd\",\n          \"wc\", \"cc\", \"wd\",\n          \"dc\", \"dw\", \"dd\"\n-         ];\n+        ];\n \n         const(size_t) BUFFER_LEN = 7 + 1 + 2 + dim.sizeof * 3 + 1;\n         char[BUFFER_LEN] fdname;\n@@ -1470,7 +1469,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 assert(0);\n         }\n         const(char)* r = (fs.op == TOK.foreach_reverse_) ? \"R\" : \"\";\n-        int j = sprintf(fdname.ptr, \"_aApply%s%.*s%llu\", r, 2, fntab[flag], cast(ulong)dim);\n+        int j = sprintf(fdname.ptr, \"_aApply%s%.*s%llu\", r, 2, fntab[flag].ptr, cast(ulong)dim);\n         assert(j < BUFFER_LEN);\n \n         FuncDeclaration fdapply;\n@@ -2475,68 +2474,66 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             Expression initialExp = cs.exp;\n \n             // The switch'ed value has errors and doesn't provide the actual type\n-            // Don't touch the case to not replace it with an `ErrorExp` even if it is valid\n+            // Omit the cast to enable further semantic (exluding the check for matching types)\n             if (sw.condition.type && !sw.condition.type.isTypeError())\n-            {\n                 cs.exp = cs.exp.implicitCastTo(sc, sw.condition.type);\n-                cs.exp = cs.exp.optimize(WANTvalue | WANTexpand);\n+            cs.exp = cs.exp.optimize(WANTvalue | WANTexpand);\n+\n+            Expression e = cs.exp;\n+            // Remove all the casts the user and/or implicitCastTo may introduce\n+            // otherwise we'd sometimes fail the check below.\n+            while (e.op == EXP.cast_)\n+                e = (cast(CastExp)e).e1;\n+\n+            /* This is where variables are allowed as case expressions.\n+            */\n+            if (e.op == EXP.variable)\n+            {\n+                VarExp ve = cast(VarExp)e;\n+                VarDeclaration v = ve.var.isVarDeclaration();\n+                Type t = cs.exp.type.toBasetype();\n+                if (v && (t.isintegral() || t.ty == Tclass))\n+                {\n+                    /* Flag that we need to do special code generation\n+                    * for this, i.e. generate a sequence of if-then-else\n+                    */\n+                    sw.hasVars = 1;\n+\n+                    /* TODO check if v can be uninitialized at that point.\n+                    */\n+                    if (!v.isConst() && !v.isImmutable())\n+                    {\n+                        cs.error(\"`case` variables have to be `const` or `immutable`\");\n+                    }\n \n-                Expression e = cs.exp;\n-                // Remove all the casts the user and/or implicitCastTo may introduce\n-                // otherwise we'd sometimes fail the check below.\n-                while (e.op == EXP.cast_)\n-                    e = (cast(CastExp)e).e1;\n+                    if (sw.isFinal)\n+                    {\n+                        cs.error(\"`case` variables not allowed in `final switch` statements\");\n+                        errors = true;\n+                    }\n \n-                /* This is where variables are allowed as case expressions.\n-                */\n-                if (e.op == EXP.variable)\n-                {\n-                    VarExp ve = cast(VarExp)e;\n-                    VarDeclaration v = ve.var.isVarDeclaration();\n-                    Type t = cs.exp.type.toBasetype();\n-                    if (v && (t.isintegral() || t.ty == Tclass))\n+                    /* Find the outermost scope `scx` that set `sw`.\n+                    * Then search scope `scx` for a declaration of `v`.\n+                    */\n+                    for (Scope* scx = sc; scx; scx = scx.enclosing)\n                     {\n-                        /* Flag that we need to do special code generation\n-                        * for this, i.e. generate a sequence of if-then-else\n-                        */\n-                        sw.hasVars = 1;\n-\n-                        /* TODO check if v can be uninitialized at that point.\n-                        */\n-                        if (!v.isConst() && !v.isImmutable())\n-                        {\n-                            cs.error(\"`case` variables have to be `const` or `immutable`\");\n-                        }\n+                        if (scx.enclosing && scx.enclosing.sw == sw)\n+                            continue;\n+                        assert(scx.sw == sw);\n \n-                        if (sw.isFinal)\n+                        if (!scx.search(cs.exp.loc, v.ident, null))\n                         {\n-                            cs.error(\"`case` variables not allowed in `final switch` statements\");\n+                            cs.error(\"`case` variable `%s` declared at %s cannot be declared in `switch` body\",\n+                                v.toChars(), v.loc.toChars());\n                             errors = true;\n                         }\n-\n-                        /* Find the outermost scope `scx` that set `sw`.\n-                        * Then search scope `scx` for a declaration of `v`.\n-                        */\n-                        for (Scope* scx = sc; scx; scx = scx.enclosing)\n-                        {\n-                            if (scx.enclosing && scx.enclosing.sw == sw)\n-                                continue;\n-                            assert(scx.sw == sw);\n-\n-                            if (!scx.search(cs.exp.loc, v.ident, null))\n-                            {\n-                                cs.error(\"`case` variable `%s` declared at %s cannot be declared in `switch` body\",\n-                                    v.toChars(), v.loc.toChars());\n-                                errors = true;\n-                            }\n-                            break;\n-                        }\n-                        goto L1;\n+                        break;\n                     }\n+                    goto L1;\n                 }\n-                else\n-                    cs.exp = cs.exp.ctfeInterpret();\n             }\n+            else\n+                cs.exp = cs.exp.ctfeInterpret();\n \n             if (StringExp se = cs.exp.toStringExp())\n                 cs.exp = se;"}, {"sha": "6e56eb25474ea190eef5f2a268396e2d8d296a1d", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -124,7 +124,6 @@ enum TOK : ubyte\n     // Leaf operators\n     identifier,\n     string_,\n-    hexadecimalString,\n     this_,\n     super_,\n     error,\n@@ -854,8 +853,6 @@ extern (C++) struct Token\n         TOK.wchar_tLiteral: \"wchar_tv\",\n         TOK.whitespace: \"whitespace\",\n \n-        TOK.hexadecimalString: \"xstring\",\n-\n         // C only keywords\n         TOK.inline    : \"inline\",\n         TOK.register  : \"register\",\n@@ -1008,24 +1005,6 @@ nothrow:\n                 p = buf.extractSlice().ptr;\n             }\n             break;\n-        case TOK.hexadecimalString:\n-            {\n-                OutBuffer buf;\n-                buf.writeByte('x');\n-                buf.writeByte('\"');\n-                foreach (size_t i; 0 .. len)\n-                {\n-                    if (i)\n-                        buf.writeByte(' ');\n-                    buf.printf(\"%02x\", ustring[i]);\n-                }\n-                buf.writeByte('\"');\n-                if (postfix)\n-                    buf.writeByte(postfix);\n-                buf.writeByte(0);\n-                p = buf.extractSlice().ptr;\n-                break;\n-            }\n         case TOK.identifier:\n         case TOK.enum_:\n         case TOK.struct_:"}, {"sha": "c404cab2ad5dfebf368ff7402af9dea999133dbe", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -133,7 +133,6 @@ enum class TOK : unsigned char\n     // Leaf operators\n     identifier,\n     string_,\n-    hexadecimalString,\n     this_,\n     super_,\n     error,"}, {"sha": "57188af90d64356a2b3c8ede30443ef5c2d41a40", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -666,9 +666,13 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n \n     Type visitType(Type t)\n     {\n+        // @@@DEPRECATED_2.110@@@\n+        // Use of `cent` and `ucent` has always been an error.\n+        // Starting from 2.100, recommend core.int128 as a replace for the\n+        // lack of compiler support.\n         if (t.ty == Tint128 || t.ty == Tuns128)\n         {\n-            .error(loc, \"`cent` and `ucent` types not implemented\");\n+            .error(loc, \"`cent` and `ucent` types are obsolete, use `core.int128.Cent` instead\");\n             return error();\n         }\n \n@@ -1188,6 +1192,8 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             tf.isref = true;\n         if (sc.stc & STC.return_)\n             tf.isreturn = true;\n+        if (sc.stc & STC.returnScope)\n+            tf.isreturnscope = true;\n         if (sc.stc & STC.returninferred)\n             tf.isreturninferred = true;\n         if (sc.stc & STC.scope_)\n@@ -3828,10 +3834,10 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                  *  e.opDot().ident\n                  */\n                 e = build_overload(e.loc, sc, e, null, fd);\n-                // @@@DEPRECATED_2.092@@@.\n-                e.deprecation(\"`opDot` is deprecated. Use `alias this`\");\n-                e = new DotIdExp(e.loc, e, ident);\n-                return returnExp(e.expressionSemantic(sc));\n+                // @@@DEPRECATED_2.110@@@.\n+                // Deprecated in 2.082, made an error in 2.100.\n+                e.error(\"`opDot` is obsolete. Use `alias this`\");\n+                return ErrorExp.get();\n             }\n \n             /* Look for overloaded opDispatch to see if we should forward request"}, {"sha": "6747ee5df27a459bd772b4246f655e23c1b48b06", "filename": "gcc/d/imports.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fimports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Fd%2Fimports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fimports.cc?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -106,20 +106,20 @@ class ImportVisitor : public Visitor\n     tree type = build_ctype (d->type);\n     /* Not all kinds of D enums create a TYPE_DECL.  */\n     if (TREE_CODE (type) == ENUMERAL_TYPE)\n-      d->isym = this->make_import (TYPE_STUB_DECL (type));\n+      this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n   void visit (AggregateDeclaration *d)\n   {\n     tree type = build_ctype (d->type);\n-    d->isym = this->make_import (TYPE_STUB_DECL (type));\n+    this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n   void visit (ClassDeclaration *d)\n   {\n     /* Want the RECORD_TYPE, not POINTER_TYPE.  */\n     tree type = TREE_TYPE (build_ctype (d->type));\n-    d->isym = this->make_import (TYPE_STUB_DECL (type));\n+    this->result_ = this->make_import (TYPE_STUB_DECL (type));\n   }\n \n   /* For now, ignore importing other kinds of dsymbols.  */"}, {"sha": "076e29baece1e2f4d6e3a066cb3c67440f60b5c2", "filename": "gcc/testsuite/gdc.test/compilable/commontype.d", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcommontype.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -196,8 +196,7 @@ static assert(is( X!( C***, B*** ) == const(B**)* )); // `B***`\n \n static assert(is( X!( C*, I* ) == I* ));\n static assert(is( X!( I*, C* ) == I* ));\n-//static assert(Error!( C**, I** ));\n-static assert(is( X!( C**, I** ) == const(I*)* ));\n+static assert(Error!( C**, I** ));\n \n static assert(Error!( C*, D* )); // should work\n \n@@ -304,15 +303,13 @@ static assert(is( X!(C[4], B[4]) ));\n static assert(Error!( C[4], I[4] ));\n static assert(Error!( C[4], D[4] ));\n static assert(is( X!( C[4], const(B)[4] ) == const(B)[4] ));\n-//static assert(Error!( C[4], const(I)[4] ));\n-static assert(is( X!( C[4], const(I)[4] ) == const(I)[] ));\n+static assert(Error!( C[4], const(I)[4] ));\n static assert(Error!( C[4], const(D)[4] ));\n static assert(Error!( C*[4], B*[4] ));\n static assert(Error!( C*[4], I*[4] ));\n static assert(Error!( C*[4], D*[4] ));\n static assert(is( X!( C*[4], const(B*)[4] ) == const(B*)[] )); // !?\n-//static assert(Error!( C*[4], const(I*)[4] ));\n-static assert(is( X!( C*[4], const(I*)[4] ) == const(I*)[] ));\n+static assert(Error!( C*[4], const(I*)[4] ));\n static assert(Error!( C*[4], const(D*)[4] ));\n static assert(Error!( C*[4], B**[4] ));\n static assert(Error!( C*[4], const(B*)*[4] ));"}, {"sha": "013630bd48363b51369612c9625de060633eb10f", "filename": "gcc/testsuite/gdc.test/compilable/test7172.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7172.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7172.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7172.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,3 +1,8 @@\n+/* TEST_OUTPUT:\n+---\n+compilable/test7172.d(14): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+---\n+*/\n void main()\n {\n     abstract class AbstractC{}"}, {"sha": "19c64752aaf1148262f10ab064bd51551a4144c4", "filename": "gcc/testsuite/gdc.test/fail_compilation/dep_d1_ops.d", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdep_d1_ops.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdep_d1_ops.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdep_d1_ops.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2,47 +2,47 @@\n REQUIRED_ARGS: -de\n TEST_OUTPUT:\n ---\n-fail_compilation/dep_d1_ops.d(105): Deprecation: `opAdd` is deprecated.  Use `opBinary(string op)(...) if (op == \"+\")` instead.\n-fail_compilation/dep_d1_ops.d(106): Deprecation: `opAdd_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"+\")` instead.\n-fail_compilation/dep_d1_ops.d(107): Deprecation: `opSub` is deprecated.  Use `opBinary(string op)(...) if (op == \"-\")` instead.\n-fail_compilation/dep_d1_ops.d(108): Deprecation: `opSub_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"-\")` instead.\n-fail_compilation/dep_d1_ops.d(109): Deprecation: `opMul` is deprecated.  Use `opBinary(string op)(...) if (op == \"*\")` instead.\n-fail_compilation/dep_d1_ops.d(110): Deprecation: `opMul_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"*\")` instead.\n-fail_compilation/dep_d1_ops.d(111): Deprecation: `opDiv` is deprecated.  Use `opBinary(string op)(...) if (op == \"/\")` instead.\n-fail_compilation/dep_d1_ops.d(112): Deprecation: `opDiv_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"/\")` instead.\n-fail_compilation/dep_d1_ops.d(113): Deprecation: `opMod` is deprecated.  Use `opBinary(string op)(...) if (op == \"%\")` instead.\n-fail_compilation/dep_d1_ops.d(114): Deprecation: `opMod_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"%\")` instead.\n-fail_compilation/dep_d1_ops.d(116): Deprecation: `opAnd` is deprecated.  Use `opBinary(string op)(...) if (op == \"&\")` instead.\n-fail_compilation/dep_d1_ops.d(117): Deprecation: `opOr` is deprecated.  Use `opBinary(string op)(...) if (op == \"|\")` instead.\n-fail_compilation/dep_d1_ops.d(118): Deprecation: `opXor` is deprecated.  Use `opBinary(string op)(...) if (op == \"^\")` instead.\n-fail_compilation/dep_d1_ops.d(120): Deprecation: `opShl` is deprecated.  Use `opBinary(string op)(...) if (op == \"<<\")` instead.\n-fail_compilation/dep_d1_ops.d(121): Deprecation: `opShl_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"<<\")` instead.\n-fail_compilation/dep_d1_ops.d(122): Deprecation: `opShr` is deprecated.  Use `opBinary(string op)(...) if (op == \">>\")` instead.\n-fail_compilation/dep_d1_ops.d(123): Deprecation: `opShr_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \">>\")` instead.\n-fail_compilation/dep_d1_ops.d(124): Deprecation: `opUShr` is deprecated.  Use `opBinary(string op)(...) if (op == \">>>\")` instead.\n-fail_compilation/dep_d1_ops.d(125): Deprecation: `opUShr_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \">>>\")` instead.\n-fail_compilation/dep_d1_ops.d(127): Deprecation: `opCat` is deprecated.  Use `opBinary(string op)(...) if (op == \"~\")` instead.\n-fail_compilation/dep_d1_ops.d(128): Deprecation: `opCat_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"~\")` instead.\n-fail_compilation/dep_d1_ops.d(130): Deprecation: `opNeg` is deprecated.  Use `opUnary(string op)() if (op == \"-\")` instead.\n-fail_compilation/dep_d1_ops.d(131): Deprecation: `opCom` is deprecated.  Use `opUnary(string op)() if (op == \"~\")` instead.\n-fail_compilation/dep_d1_ops.d(132): Deprecation: `opPostInc` is deprecated.  Use `opUnary(string op)() if (op == \"++\")` instead.\n-fail_compilation/dep_d1_ops.d(133): Deprecation: `opPostDec` is deprecated.  Use `opUnary(string op)() if (op == \"--\")` instead.\n-fail_compilation/dep_d1_ops.d(134): Deprecation: `opStar` is deprecated.  Use `opUnary(string op)() if (op == \"*\")` instead.\n-fail_compilation/dep_d1_ops.d(136): Deprecation: `opIn` is deprecated.  Use `opBinary(string op)(...) if (op == \"in\")` instead.\n-fail_compilation/dep_d1_ops.d(137): Deprecation: `opIn_r` is deprecated.  Use `opBinaryRight(string op)(...) if (op == \"in\")` instead.\n-fail_compilation/dep_d1_ops.d(139): Deprecation: `opAddAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"+\")` instead.\n-fail_compilation/dep_d1_ops.d(140): Deprecation: `opSubAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"-\")` instead.\n-fail_compilation/dep_d1_ops.d(141): Deprecation: `opMulAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"*\")` instead.\n-fail_compilation/dep_d1_ops.d(142): Deprecation: `opDivAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"/\")` instead.\n-fail_compilation/dep_d1_ops.d(143): Deprecation: `opModAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"%\")` instead.\n-fail_compilation/dep_d1_ops.d(144): Deprecation: `opAndAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"&\")` instead.\n-fail_compilation/dep_d1_ops.d(145): Deprecation: `opOrAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"|\")` instead.\n-fail_compilation/dep_d1_ops.d(146): Deprecation: `opXorAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"^\")` instead.\n-fail_compilation/dep_d1_ops.d(147): Deprecation: `opShlAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"<<\")` instead.\n-fail_compilation/dep_d1_ops.d(148): Deprecation: `opShrAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \">>\")` instead.\n-fail_compilation/dep_d1_ops.d(149): Deprecation: `opUShrAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \">>>\")` instead.\n-fail_compilation/dep_d1_ops.d(150): Deprecation: `opCatAssign` is deprecated.  Use `opOpAssign(string op)(...) if (op == \"~\")` instead.\n-fail_compilation/dep_d1_ops.d(158): Deprecation: `opCom` is deprecated.  Use `opUnary(string op)() if (op == \"~\")` instead.\n+fail_compilation/dep_d1_ops.d(105): Error: `opAdd` is obsolete.  Use `opBinary(string op)(...) if (op == \"+\")` instead.\n+fail_compilation/dep_d1_ops.d(106): Error: `opAdd_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"+\")` instead.\n+fail_compilation/dep_d1_ops.d(107): Error: `opSub` is obsolete.  Use `opBinary(string op)(...) if (op == \"-\")` instead.\n+fail_compilation/dep_d1_ops.d(108): Error: `opSub_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"-\")` instead.\n+fail_compilation/dep_d1_ops.d(109): Error: `opMul` is obsolete.  Use `opBinary(string op)(...) if (op == \"*\")` instead.\n+fail_compilation/dep_d1_ops.d(110): Error: `opMul_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"*\")` instead.\n+fail_compilation/dep_d1_ops.d(111): Error: `opDiv` is obsolete.  Use `opBinary(string op)(...) if (op == \"/\")` instead.\n+fail_compilation/dep_d1_ops.d(112): Error: `opDiv_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"/\")` instead.\n+fail_compilation/dep_d1_ops.d(113): Error: `opMod` is obsolete.  Use `opBinary(string op)(...) if (op == \"%\")` instead.\n+fail_compilation/dep_d1_ops.d(114): Error: `opMod_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"%\")` instead.\n+fail_compilation/dep_d1_ops.d(116): Error: `opAnd` is obsolete.  Use `opBinary(string op)(...) if (op == \"&\")` instead.\n+fail_compilation/dep_d1_ops.d(117): Error: `opOr` is obsolete.  Use `opBinary(string op)(...) if (op == \"|\")` instead.\n+fail_compilation/dep_d1_ops.d(118): Error: `opXor` is obsolete.  Use `opBinary(string op)(...) if (op == \"^\")` instead.\n+fail_compilation/dep_d1_ops.d(120): Error: `opShl` is obsolete.  Use `opBinary(string op)(...) if (op == \"<<\")` instead.\n+fail_compilation/dep_d1_ops.d(121): Error: `opShl_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"<<\")` instead.\n+fail_compilation/dep_d1_ops.d(122): Error: `opShr` is obsolete.  Use `opBinary(string op)(...) if (op == \">>\")` instead.\n+fail_compilation/dep_d1_ops.d(123): Error: `opShr_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \">>\")` instead.\n+fail_compilation/dep_d1_ops.d(124): Error: `opUShr` is obsolete.  Use `opBinary(string op)(...) if (op == \">>>\")` instead.\n+fail_compilation/dep_d1_ops.d(125): Error: `opUShr_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \">>>\")` instead.\n+fail_compilation/dep_d1_ops.d(127): Error: `opCat` is obsolete.  Use `opBinary(string op)(...) if (op == \"~\")` instead.\n+fail_compilation/dep_d1_ops.d(128): Error: `opCat_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"~\")` instead.\n+fail_compilation/dep_d1_ops.d(130): Error: `opNeg` is obsolete.  Use `opUnary(string op)() if (op == \"-\")` instead.\n+fail_compilation/dep_d1_ops.d(131): Error: `opCom` is obsolete.  Use `opUnary(string op)() if (op == \"~\")` instead.\n+fail_compilation/dep_d1_ops.d(132): Error: `opPostInc` is obsolete.  Use `opUnary(string op)() if (op == \"++\")` instead.\n+fail_compilation/dep_d1_ops.d(133): Error: `opPostDec` is obsolete.  Use `opUnary(string op)() if (op == \"--\")` instead.\n+fail_compilation/dep_d1_ops.d(134): Error: `opStar` is obsolete.  Use `opUnary(string op)() if (op == \"*\")` instead.\n+fail_compilation/dep_d1_ops.d(136): Error: `opIn` is obsolete.  Use `opBinary(string op)(...) if (op == \"in\")` instead.\n+fail_compilation/dep_d1_ops.d(137): Error: `opIn_r` is obsolete.  Use `opBinaryRight(string op)(...) if (op == \"in\")` instead.\n+fail_compilation/dep_d1_ops.d(139): Error: `opAddAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"+\")` instead.\n+fail_compilation/dep_d1_ops.d(140): Error: `opSubAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"-\")` instead.\n+fail_compilation/dep_d1_ops.d(141): Error: `opMulAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"*\")` instead.\n+fail_compilation/dep_d1_ops.d(142): Error: `opDivAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"/\")` instead.\n+fail_compilation/dep_d1_ops.d(143): Error: `opModAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"%\")` instead.\n+fail_compilation/dep_d1_ops.d(144): Error: `opAndAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"&\")` instead.\n+fail_compilation/dep_d1_ops.d(145): Error: `opOrAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"|\")` instead.\n+fail_compilation/dep_d1_ops.d(146): Error: `opXorAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"^\")` instead.\n+fail_compilation/dep_d1_ops.d(147): Error: `opShlAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"<<\")` instead.\n+fail_compilation/dep_d1_ops.d(148): Error: `opShrAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \">>\")` instead.\n+fail_compilation/dep_d1_ops.d(149): Error: `opUShrAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \">>>\")` instead.\n+fail_compilation/dep_d1_ops.d(150): Error: `opCatAssign` is obsolete.  Use `opOpAssign(string op)(...) if (op == \"~\")` instead.\n+fail_compilation/dep_d1_ops.d(158): Error: `opCom` is obsolete.  Use `opUnary(string op)() if (op == \"~\")` instead.\n ---\n */\n "}, {"sha": "2ce37959e11cb9f20390ce58621fba3b114dd873", "filename": "gcc/testsuite/gdc.test/fail_compilation/dephexstrings.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2,7 +2,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/dephexstrings.d(8): Error: Built-in hex string literals are obsolete, use `std.conv.hexString!\"60\"` instead.\n+fail_compilation/dephexstrings.d(9): Error: semicolon expected following auto declaration, not `\"60\"`\n+fail_compilation/dephexstrings.d(9): Error: declaration expected, not `\"60\"`\n ---\n */\n enum xstr = x\"60\";"}, {"sha": "46c949376e3506a601ade7388b4f9d9bde1bc082", "filename": "gcc/testsuite/gdc.test/fail_compilation/deprecateopdot.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecateopdot.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecateopdot.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecateopdot.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2,9 +2,9 @@\n REQUIRED_ARGS: -de\n TEST_OUTPUT:\n ---\n-fail_compilation/deprecateopdot.d(27): Deprecation: `opDot` is deprecated. Use `alias this`\n-fail_compilation/deprecateopdot.d(28): Deprecation: `opDot` is deprecated. Use `alias this`\n-fail_compilation/deprecateopdot.d(29): Deprecation: `opDot` is deprecated. Use `alias this`\n+fail_compilation/deprecateopdot.d(27): Error: `opDot` is obsolete. Use `alias this`\n+fail_compilation/deprecateopdot.d(28): Error: `opDot` is obsolete. Use `alias this`\n+fail_compilation/deprecateopdot.d(29): Error: `opDot` is obsolete. Use `alias this`\n ---\n */\n struct S6"}, {"sha": "16659b5fdc117a17f08daa4918e898e3b92a2365", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail136.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail136.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail136.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail136.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail136.d(10): Error: Built-in hex string literals are obsolete, use `std.conv.hexString!\"EF BB BF\"` instead.\n+fail_compilation/fail136.d(10): Error: found `\"EF BB BF\"` when expecting `;` following statement\n ---\n */\n "}, {"sha": "848b65116f16790de6c5a782ed3621e19b60ad14", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail18.d(14): Error: need upper and lower bound to slice pointer\n+fail_compilation/fail18.d(14): Error: upper and lower bounds are needed to slice a pointer\n ---\n */\n "}, {"sha": "e22be9fe047e1dcc8b0d3d8707152305fabe06ff", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22780.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22780.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22780.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22780.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,7 +1,8 @@\n // https://issues.dlang.org/show_bug.cgi?id=22780\n /* TEST_OUTPUT:\n ---\n-fail_compilation/fail22780.d(11): Error: variable `fail22780.test10717.c` reference to `scope class` must be `scope`\n+fail_compilation/fail22780.d(8): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+fail_compilation/fail22780.d(12): Error: variable `fail22780.test10717.c` reference to `scope class` must be `scope`\n ---\n */\n scope class C10717 { }"}, {"sha": "ee031ae1906711baf6c8e8a81d3a19265651b2cb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22827.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22827.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22827.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22827.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -0,0 +1,9 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22827\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail22827.d(8): Error: `cent` and `ucent` types are obsolete, use `core.int128.Cent` instead\n+fail_compilation/fail22827.d(9): Error: `cent` and `ucent` types are obsolete, use `core.int128.Cent` instead\n+---\n+*/\n+cent i22827;\n+ucent j22827;"}, {"sha": "af42b46d524aa10bf0bea235b1558a1263513a24", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue22820.d", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22820.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22820.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22820.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -0,0 +1,68 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/issue22820.d(138): Error: upper and lower bounds are needed to slice a pointer\n+fail_compilation/issue22820.d(138):        pointer `s1` points to an aggregate that defines an `opIndex`, perhaps you meant `(*s1)[]`\n+fail_compilation/issue22820.d(139): Error: upper and lower bounds are needed to slice a pointer\n+fail_compilation/issue22820.d(139):        pointer `s2` points to an aggregate that defines an `opSlice`, perhaps you meant `(*s2)[]`\n+fail_compilation/issue22820.d(140): Error: upper and lower bounds are needed to slice a pointer\n+fail_compilation/issue22820.d(140):        pointer `s3` points to an aggregate that defines an `opIndex`, perhaps you meant `(*s3)[]`\n+fail_compilation/issue22820.d(141): Error: upper and lower bounds are needed to slice a pointer\n+fail_compilation/issue22820.d(141):        pointer `cp` points to an aggregate that defines an `opIndex`, perhaps you meant `(*cp)[]`\n+fail_compilation/issue22820.d(142): Error: upper and lower bounds are needed to slice a pointer\n+fail_compilation/issue22820.d(142):        pointer `e` points to an aggregate that defines an `opIndex`, perhaps you meant `(*e)[]`\n+---\n+*/\n+\n+#line 100\n+\n+// normal functions\n+struct S1 {\n+\tint[] opIndex() { return a; }\n+\tint[] a;\n+}\n+\n+// opSlice alternative\n+struct S2 {\n+\tint[] opSlice() { return a; }\n+\tint[] a;\n+}\n+\n+// templates\n+struct S3 {\n+\tint[] opIndex()() { return a; }\n+\tint[] a;\n+}\n+\n+class C {\n+\tint[] opIndex()() { return a; }\n+\tint[] a;\n+}\n+\n+enum E : S1\n+{\n+\ta = S1([1])\n+}\n+\n+void main() {\n+\tS1* s1 = new S1;\n+\tS2* s2 = new S2;\n+\tS3* s3 = new S3;\n+\tC c = new C;\n+\tC* cp = &c;\n+\tE* e = new E;\n+\tint* p;\n+\n+\tp = s1[].ptr;\n+\tp = s2[].ptr;\n+\tp = s3[].ptr;\n+\tp = cp[].ptr;\n+\tp = e[].ptr;\n+\n+\tp = (*s1)[].ptr;\n+\tp = (*s2)[].ptr;\n+\tp = (*s3)[].ptr;\n+\tp = (*cp)[].ptr;\n+\tp = (*e)[].ptr;\n+}\n+"}, {"sha": "115f1366dcef9aee8c5455122b371b23cece8ede", "filename": "gcc/testsuite/gdc.test/fail_compilation/lexer1.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer1.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,8 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/lexer1.d(30): Error: Built-in hex string literals are obsolete, use `std.conv.hexString!\"01 02 03\"w` instead.\n-fail_compilation/lexer1.d(30): Error: declaration expected, not `x\"01 02 03\"w`\n+fail_compilation/lexer1.d(30): Error: no identifier for declarator `x`\n+fail_compilation/lexer1.d(30): Error: declaration expected, not `\"01 02 03\"w`\n fail_compilation/lexer1.d(31): Error: declaration expected, not `2147483649U`\n fail_compilation/lexer1.d(32): Error: declaration expected, not `0.1`\n fail_compilation/lexer1.d(33): Error: declaration expected, not `0.1f`"}, {"sha": "f895e644c449a392735f98dfd0126b445a86485c", "filename": "gcc/testsuite/gdc.test/fail_compilation/lexer2.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Flexer2.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,10 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/lexer2.d(16): Error: odd number (3) of hex characters in hex string\n-fail_compilation/lexer2.d(16): Error: Built-in hex string literals are obsolete, use `std.conv.hexString!\"123\"` instead.\n-fail_compilation/lexer2.d(17): Error: non-hex character 'G' in hex string\n-fail_compilation/lexer2.d(17): Error: Built-in hex string literals are obsolete, use `std.conv.hexString!\"123G\"` instead.\n+fail_compilation/lexer2.d(16): Error: semicolon expected following auto declaration, not `\"123\"`\n+fail_compilation/lexer2.d(16): Error: declaration expected, not `\"123\"`\n+fail_compilation/lexer2.d(17): Error: semicolon expected following auto declaration, not `\"123G\"`\n+fail_compilation/lexer2.d(17): Error: declaration expected, not `\"123G\"`\n fail_compilation/lexer2.d(18): Error: heredoc rest of line should be blank\n fail_compilation/lexer2.d(20): Error: unterminated delimited string constant starting at fail_compilation/lexer2.d(20)\n fail_compilation/lexer2.d(22): Error: semicolon expected following auto declaration, not `End of File`"}, {"sha": "b15d6e49b182283eae3e5fbdab24610f6028ba1b", "filename": "gcc/testsuite/gdc.test/fail_compilation/opapplyscope.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fopapplyscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fopapplyscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fopapplyscope.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -0,0 +1,27 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/opapplyscope.d(113): Error: function `opapplyscope.S.opApply(scope int delegate(scope int* ptr) @safe dg)` is not callable using argument types `(int delegate(int* x) nothrow @nogc @safe)`\n+fail_compilation/opapplyscope.d(113):        cannot pass argument `__foreachbody3` of type `int delegate(int* x) nothrow @nogc @safe` to parameter `scope int delegate(scope int* ptr) @safe dg`\n+---\n+ */\n+\n+#line 100\n+\n+struct S\n+{\n+    int opApply(scope int delegate (scope int* ptr) @safe dg) @safe\n+    {\n+        return 0;\n+    }\n+}\n+\n+void test() @safe\n+{\n+    static int* global;\n+    S s;\n+    foreach (/*scope*/ int* x; s)\n+    {\n+        global = x;\n+    }\n+}\n+"}, {"sha": "bba14908833017bfa90d8c4e6cd2b8bd8af7a749", "filename": "gcc/testsuite/gdc.test/fail_compilation/scope_class.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_class.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_class.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_class.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/scope_class.d(11): Error: functions cannot return `scope scope_class.C`\n+fail_compilation/scope_class.d(10): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+fail_compilation/scope_class.d(12): Error: functions cannot return `scope scope_class.C`\n ---\n */\n "}, {"sha": "e0550138b7e4642ed2e8d3cfe395de52163fddc2", "filename": "gcc/testsuite/gdc.test/fail_compilation/scope_type.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_type.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_type.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fscope_type.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2,11 +2,15 @@\n REQUIRED_ARGS: -de\n TEST_OUTPUT:\n ---\n-fail_compilation/scope_type.d(11): Error: `scope` as a type constraint is obsolete.  Use `scope` at the usage site.\n+fail_compilation/scope_type.d(13): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+fail_compilation/scope_type.d(14): Error: `scope` as a type constraint is obsolete.  Use `scope` at the usage site.\n+fail_compilation/scope_type.d(15): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+fail_compilation/scope_type.d(16): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n ---\n */\n \n \n scope class C { }\n scope interface I { }\n-//scope struct S { }\n+scope struct S { }\n+scope enum E { e }"}, {"sha": "2ac3b56219899d9ce52763a44aa52276348dd3ec", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15191.d", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,15 +1,19 @@\n /* TEST_OUTPUT:\n-PERMUTE_ARGS: -dip1000\n+REQUIRED_ARGS: -preview=dip1000\n ---\n-fail_compilation/test15191.d(31): Error: returning `&identity(x)` escapes a reference to local variable `x`\n-fail_compilation/test15191.d(37): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`\n-fail_compilation/test15191.d(43): Error: cannot take address of `ref return` of `identityPtr()` in `@safe` function `addrOfRefTransitive`\n-fail_compilation/test15191.d(43): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`\n+fail_compilation/test15191.d(35): Error: returning `&identity(x)` escapes a reference to local variable `x`\n+fail_compilation/test15191.d(41): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`\n+fail_compilation/test15191.d(47): Error: cannot take address of `ref return` of `identityPtr()` in `@safe` function `addrOfRefTransitive`\n+fail_compilation/test15191.d(47):        return type `int*` has pointers that may be `scope`\n+fail_compilation/test15191.d(68): Error: cannot slice static array of `ref return` of `identityArr()` in `@safe` function `sliceOfRefEscape`\n+fail_compilation/test15191.d(68):        return type `int*[1]` has pointers that may be `scope`\n ---\n */\n \n+// Test taking the address of a `ref return` using & and [] operators\n // https://issues.dlang.org/show_bug.cgi?id=15191\n // https://issues.dlang.org/show_bug.cgi?id=22519\n+// https://issues.dlang.org/show_bug.cgi?id=22539\n \n @safe:\n ref int foo(return ref int s)\n@@ -50,3 +54,17 @@ int* addrOfRefGlobal()\n {\n \treturn &getGlobalInt();\n }\n+\n+// Slice:\n+ref int*[1] identityArr(ref return scope int*[1] x)\n+{\n+\treturn x;\n+}\n+\n+int* sliceOfRefEscape()\n+{\n+\tint stackVar = 0xFF;\n+\tscope int*[1] x = [&stackVar];\n+\tint*[] y = identityArr(x)[];\n+\treturn y[0];\n+}"}, {"sha": "034813b5316c06feae39396232ac662a185789f7", "filename": "gcc/testsuite/gdc.test/fail_compilation/test19097.d", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,7 +1,9 @@\n /* REQUIRED_ARGS: -preview=dip1000\n  * TEST_OUTPUT:\n ---\n-fail_compilation/test19097.d(35): Error: scope variable `s` may not be returned\n+fail_compilation/test19097.d(37): Error: scope variable `s` may not be returned\n+fail_compilation/test19097.d(66): Error: scope variable `z` assigned to `refPtr` with longer lifetime\n+fail_compilation/test19097.d(97): Error: scope variable `s` may not be returned\n ---\n  */\n \n@@ -54,3 +56,43 @@ struct S2(T)\n \n S2!int s2;\n \n+/************************/\n+struct S3\n+{\n+    int* ptr;\n+    void assign(ref int* refPtr, return scope int* z) scope @safe\n+    {\n+        this.ptr = z; // allowed, first ref\n+        refPtr = z; // should not be allowed\n+    }\n+}\n+\n+int* escape() @safe\n+{\n+    int local;\n+\n+    S3 escapeThis;\n+    int* escapeRef;\n+\n+    escapeThis.assign(escapeRef, &local);\n+\n+    return escapeRef;\n+}\n+\n+/************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22837\n+struct S4\n+{\n+    int* p;\n+    this(int dummy, return scope int* p) @safe\n+    {\n+        this.p = p;\n+    }\n+}\n+\n+int* escape2()\n+{\n+    int x;\n+    auto s = S4(0, &x);\n+    return s.p;\n+}"}, {"sha": "d5cf96a6c3ac985686afa68302918dc18dcab694", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21008.d", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -0,0 +1,41 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21008.d(110): Error: function `test21008.C.after` circular reference to class `C`\n+fail_compilation/test21008.d(117): Error: need `this` for `toString` of type `string()`\n+fail_compilation/test21008.d(117): Error: need `this` for `toHash` of type `nothrow @trusted $?:32=uint|64=ulong$()`\n+fail_compilation/test21008.d(117): Error: function `object.Object.opCmp(Object o)` is not callable using argument types `()`\n+fail_compilation/test21008.d(117):        missing argument for parameter #1: `Object o`\n+fail_compilation/test21008.d(117): Error: function `object.Object.opEquals(Object o)` is not callable using argument types `()`\n+fail_compilation/test21008.d(117):        missing argument for parameter #1: `Object o`\n+fail_compilation/test21008.d(117): Error: `Monitor` has no effect\n+fail_compilation/test21008.d(117): Error: function `object.Object.factory(string classname)` is not callable using argument types `()`\n+fail_compilation/test21008.d(117):        missing argument for parameter #1: `string classname`\n+fail_compilation/test21008.d(105):        called from here: `handleMiddlewareAnnotation()`\n+fail_compilation/test21008.d(108): Error: class `test21008.C` no size because of forward reference\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21008\n+\n+#line 100\n+\n+class Base\n+{\n+    bool after();\n+\n+    mixin(handleMiddlewareAnnotation);\n+}\n+\n+class C : Base\n+{\n+    override bool after();\n+}\n+\n+string handleMiddlewareAnnotation()\n+{\n+    foreach (member; __traits(allMembers, C))\n+    {\n+        __traits(getMember, C, member);\n+    }\n+}"}, {"sha": "bfd8803d2f2a247aa5b9e6ffa8146423f3260088", "filename": "gcc/testsuite/gdc.test/fail_compilation/test_switch_error.d", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -99,3 +99,81 @@ void test5(int i)\n \n     }\n }\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(513): Error: undefined identifier `undefinedFunc`\n+fail_compilation/test_switch_error.d(517): Error: `case` must be a `string` or an integral constant, not `Strukt(1)`\n+fail_compilation/test_switch_error.d(518): Error: `case` variables have to be `const` or `immutable`\n+fail_compilation/test_switch_error.d(518): Error: `case` variables not allowed in `final switch` statements\n+fail_compilation/test_switch_error.d(519): Error: `case` variables not allowed in `final switch` statements\n+fail_compilation/test_switch_error.d(522): Error: undefined identifier `undefinedFunc2`\n+---\n+++/\n+#line 500\n+\n+enum Foo\n+{\n+   one, two\n+}\n+\n+struct Strukt\n+{\n+    int i;\n+}\n+\n+void errorsWithErrors(int param, immutable int constant)\n+{\n+   final switch(undefinedFunc())\n+   {\n+      case Foo.one:     break;\n+      case Foo.two:     break;\n+      case Strukt(1):   break;\n+      case param:       break;\n+      case constant:    break;\n+   }\n+\n+   switch (undefinedFunc2())\n+   {\n+       case constant:   break;\n+   }\n+}\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(622): Error: undefined identifier `undefinedFunc`\n+fail_compilation/test_switch_error.d(624): Error: `case` must be a `string` or an integral constant, not `SubtypeOfInt(2)`\n+fail_compilation/test_switch_error.d(625): Error: `case` must be a `string` or an integral constant, not `SubtypeOfIntMethod()`\n+---\n+++/\n+#line 600\n+\n+struct SubtypeOfInt\n+{\n+    int i;\n+    alias i this;\n+}\n+\n+struct SubtypeOfIntMethod\n+{\n+    int getI() { return 0; }\n+    alias getI this;\n+}\n+\n+void errorsWithErrors2(int param)\n+{\n+    final switch(param)\n+    {\n+        case SubtypeOfInt(1):         break;\n+        case SubtypeOfIntMethod():    break;\n+    }\n+\n+    // This snippet causes somewhat misleading error messages\n+    final switch(undefinedFunc())\n+    {\n+        case SubtypeOfInt(2):         break;\n+        case SubtypeOfIntMethod():    break;\n+    }\n+}"}, {"sha": "37395d4b897ac5a67fb814c59cee4d5036df8b52", "filename": "gcc/testsuite/gdc.test/fail_compilation/typeerrors.d", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftypeerrors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftypeerrors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftypeerrors.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,22 +1,23 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/typeerrors.d(36): Error: tuple index 4 exceeds 4\n-fail_compilation/typeerrors.d(38): Error: variable `x` cannot be read at compile time\n-fail_compilation/typeerrors.d(39): Error: cannot have array of `void()`\n-fail_compilation/typeerrors.d(40): Error: cannot have array of scope `typeerrors.C`\n+fail_compilation/typeerrors.d(32): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+fail_compilation/typeerrors.d(37): Error: tuple index 4 exceeds 4\n+fail_compilation/typeerrors.d(39): Error: variable `x` cannot be read at compile time\n+fail_compilation/typeerrors.d(40): Error: cannot have array of `void()`\n fail_compilation/typeerrors.d(41): Error: cannot have array of scope `typeerrors.C`\n-fail_compilation/typeerrors.d(44): Error: `int[5]` is not an expression\n-fail_compilation/typeerrors.d(46): Error: variable `x` is used as a type\n-fail_compilation/typeerrors.d(37):        variable `x` is declared here\n-fail_compilation/typeerrors.d(47): Error: cannot have associative array key of `void()`\n-fail_compilation/typeerrors.d(48): Error: cannot have associative array key of `void`\n-fail_compilation/typeerrors.d(49): Error: cannot have array of scope `typeerrors.C`\n-fail_compilation/typeerrors.d(50): Error: cannot have associative array of `void`\n-fail_compilation/typeerrors.d(51): Error: cannot have associative array of `void()`\n-fail_compilation/typeerrors.d(53): Error: cannot have parameter of type `void`\n-fail_compilation/typeerrors.d(55): Error: slice `[1..5]` is out of range of [0..4]\n-fail_compilation/typeerrors.d(56): Error: slice `[2..1]` is out of range of [0..4]\n+fail_compilation/typeerrors.d(42): Error: cannot have array of scope `typeerrors.C`\n+fail_compilation/typeerrors.d(45): Error: `int[5]` is not an expression\n+fail_compilation/typeerrors.d(47): Error: variable `x` is used as a type\n+fail_compilation/typeerrors.d(38):        variable `x` is declared here\n+fail_compilation/typeerrors.d(48): Error: cannot have associative array key of `void()`\n+fail_compilation/typeerrors.d(49): Error: cannot have associative array key of `void`\n+fail_compilation/typeerrors.d(50): Error: cannot have array of scope `typeerrors.C`\n+fail_compilation/typeerrors.d(51): Error: cannot have associative array of `void`\n+fail_compilation/typeerrors.d(52): Error: cannot have associative array of `void()`\n+fail_compilation/typeerrors.d(54): Error: cannot have parameter of type `void`\n+fail_compilation/typeerrors.d(56): Error: slice `[1..5]` is out of range of [0..4]\n+fail_compilation/typeerrors.d(57): Error: slice `[2..1]` is out of range of [0..4]\n ---\n */\n "}, {"sha": "6ee075089d14adafed52cdf39fb62b79e132ea6e", "filename": "gcc/testsuite/gdc.test/runnable/auto1.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fauto1.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -16,7 +16,7 @@ import core.stdc.stdio;\n \n /******************************************/\n \n-scope class Foo\n+class Foo\n {\n     static int x;\n \n@@ -65,7 +65,7 @@ void test1()\n \n int ax;\n \n-scope class A2\n+class A2\n {\n   this()\n   {\n@@ -96,11 +96,11 @@ void test2()\n \n int status3;\n \n-scope class Parent3\n+class Parent3\n {\n }\n \n-scope class Child3 : Parent3\n+class Child3 : Parent3\n {\n         this(){\n                 assert(status3==0);"}, {"sha": "6b1e89b65ff8e35e4561ce2a04d6396037a91d06", "filename": "gcc/testsuite/gdc.test/runnable/interpret.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -3246,7 +3246,7 @@ int test6907()\n     }\n     {\n         S1* p = new S1();\n-        if (__ctfe) \n+        if (__ctfe)\n         {\n             (*p).__dtor();\n             destroy(p);"}, {"sha": "253a7a54ceb193e33d7a9650a53f073366a962fa", "filename": "gcc/testsuite/gdc.test/runnable/opover.d", "status": "modified", "additions": 146, "deletions": 206, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fopover.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -31,7 +31,8 @@ import core.stdc.stdio;\n \n class A1\n {\n-    int opAdd(int i) { return 7 + i; }\n+    int opBinary(string op)(int i) if (op == \"+\") { return 7 + i; }\n+    alias opBinaryRight = opBinary;\n }\n \n void test1()\n@@ -50,8 +51,8 @@ void test1()\n \n class A2\n {\n-    int opDiv(int i)   { return 9 + i; }\n-    int opDiv_r(int i) { return 17 + i; }\n+    int opBinary(string op)(int i)      if (op == \"/\") { return 9 + i; }\n+    int opBinaryRight(string op)(int i) if (op == \"/\") { return 17 + i; }\n }\n \n void test2()\n@@ -74,31 +75,31 @@ class C1\n \n class C2\n {\n-    int opAdd(D1 d)   { return 1; }\n-    int opAdd(D2 d)   { return 2; }\n-    int opAdd(D3 d)   { return 3; }\n-    int opAdd(D4 d)   { return 4; }\n+    int opBinary(string op)(D1 d) if (op == \"+\") { return 1; }\n+    int opBinary(string op)(D2 d) if (op == \"+\") { return 2; }\n+    int opBinary(string op)(D3 d) if (op == \"+\") { return 3; }\n+    int opBinary(string op)(D4 d) if (op == \"+\") { return 4; }\n }\n \n class C3\n {\n-    int opAdd_r(D1 d) { return 5; }\n-    int opAdd_r(D2 d) { return 6; }\n-    int opAdd_r(D3 d) { return 7; }\n-    int opAdd_r(D4 d) { return 8; }\n+    int opBinaryRight(string op)(D1 d) if (op == \"+\") { return 5; }\n+    int opBinaryRight(string op)(D2 d) if (op == \"+\") { return 6; }\n+    int opBinaryRight(string op)(D3 d) if (op == \"+\") { return 7; }\n+    int opBinaryRight(string op)(D4 d) if (op == \"+\") { return 8; }\n }\n \n class C4\n {\n-    int opAdd(D1 d)   { return 9; }\n-    int opAdd(D2 d)   { return 10; }\n-    int opAdd(D3 d)   { return 11; }\n-    int opAdd(D4 d)   { return 12; }\n+    int opBinary(string op)(D1 d) if (op == \"+\") { return 9; }\n+    int opBinary(string op)(D2 d) if (op == \"+\") { return 10; }\n+    int opBinary(string op)(D3 d) if (op == \"+\") { return 11; }\n+    int opBinary(string op)(D4 d) if (op == \"+\") { return 12; }\n \n-    int opAdd_r(D1 d) { return 13; }\n-    int opAdd_r(D2 d) { return 14; }\n-    int opAdd_r(D3 d) { return 15; }\n-    int opAdd_r(D4 d) { return 16; }\n+    int opBinaryRight(string op)(D1 d) if (op == \"+\") { return 13; }\n+    int opBinaryRight(string op)(D2 d) if (op == \"+\") { return 14; }\n+    int opBinaryRight(string op)(D3 d) if (op == \"+\") { return 15; }\n+    int opBinaryRight(string op)(D4 d) if (op == \"+\") { return 16; }\n }\n \n class D1\n@@ -107,31 +108,31 @@ class D1\n \n class D2\n {\n-    int opAdd(C1 c)   { return 17; }\n-    int opAdd(C2 d)   { return 18; }\n-    int opAdd(C3 d)   { return 19; }\n-    int opAdd(C4 d)   { return 20; }\n+    int opBinary(string op)(C1 d) if (op == \"+\") { return 17; }\n+    int opBinary(string op)(C2 d) if (op == \"+\") { return 18; }\n+    int opBinary(string op)(C3 d) if (op == \"+\") { return 19; }\n+    int opBinary(string op)(C4 d) if (op == \"+\") { return 20; }\n }\n \n class D3\n {\n-    int opAdd_r(C1 d) { return 21; }\n-    int opAdd_r(C2 d) { return 22; }\n-    int opAdd_r(C3 d) { return 23; }\n-    int opAdd_r(C4 d) { return 24; }\n+    int opBinaryRight(string op)(C1 d) if (op == \"+\") { return 21; }\n+    int opBinaryRight(string op)(C2 d) if (op == \"+\") { return 22; }\n+    int opBinaryRight(string op)(C3 d) if (op == \"+\") { return 23; }\n+    int opBinaryRight(string op)(C4 d) if (op == \"+\") { return 24; }\n }\n \n class D4\n {\n-    int opAdd(C1 d)   { return 25; }\n-    int opAdd(C2 d)   { return 26; }\n-    int opAdd(C3 d)   { return 27; }\n-    int opAdd(C4 d)   { return 28; }\n+    int opBinary(string op)(C1 d) if (op == \"+\") { return 25; }\n+    int opBinary(string op)(C2 d) if (op == \"+\") { return 26; }\n+    int opBinary(string op)(C3 d) if (op == \"+\") { return 27; }\n+    int opBinary(string op)(C4 d) if (op == \"+\") { return 28; }\n \n-    int opAdd_r(C1 d) { return 29; }\n-    int opAdd_r(C2 d) { return 30; }\n-    int opAdd_r(C3 d) { return 31; }\n-    int opAdd_r(C4 d) { return 32; }\n+    int opBinaryRight(string op)(C1 d) if (op == \"+\") { return 29; }\n+    int opBinaryRight(string op)(C2 d) if (op == \"+\") { return 30; }\n+    int opBinaryRight(string op)(C3 d) if (op == \"+\") { return 31; }\n+    int opBinaryRight(string op)(C4 d) if (op == \"+\") { return 32; }\n }\n \n \n@@ -149,90 +150,45 @@ void test3()\n \n     int i;\n \n-  version (ADD_R)\n-  {\n     //i = c1 + d1;    assert(i == );\n-    i = c1 + d2;    assert(i == 17);\n+    //i = c1 + d2;    assert(i == );\n     i = c1 + d3;    assert(i == 21);\n     i = c1 + d4;    assert(i == 29);\n \n     i = c2 + d1;    assert(i == 1);\n     i = c2 + d2;    assert(i == 2);\n-    i = c2 + d3;    assert(i == 3);\n-    i = c2 + d4;    assert(i == 4);\n+    i = c2 + d3;    assert(i == 22);\n+    i = c2 + d4;    assert(i == 30);\n \n     //i = c3 + d1;    assert(i == );\n-    i = c3 + d2;    assert(i == 19);\n+    //i = c3 + d2;    assert(i == );\n     i = c3 + d3;    assert(i == 23);\n     i = c3 + d4;    assert(i == 31);\n \n     i = c4 + d1;    assert(i == 9);\n     i = c4 + d2;    assert(i == 10);\n-    i = c4 + d3;    assert(i == 11);\n-    i = c4 + d4;    assert(i == 12);\n+    i = c4 + d3;    assert(i == 24);\n+    i = c4 + d4;    assert(i == 32);\n \n     //i = d1 + c1;    assert(i == );\n-    i = d1 + c2;    assert(i == 1);\n+    //i = d1 + c2;    assert(i == );\n     i = d1 + c3;    assert(i == 5);\n     i = d1 + c4;    assert(i == 13);\n \n     i = d2 + c1;    assert(i == 17);\n     i = d2 + c2;    assert(i == 18);\n-    i = d2 + c3;    assert(i == 19);\n-    i = d2 + c4;    assert(i == 20);\n+    i = d2 + c3;    assert(i == 6);\n+    i = d2 + c4;    assert(i == 14);\n \n     //i = d3 + c1;    assert(i == );\n-    i = d3 + c2;    assert(i == 3);\n+    //i = d3 + c2;    assert(i == );\n     i = d3 + c3;    assert(i == 7);\n     i = d3 + c4;    assert(i == 15);\n \n     i = d4 + c1;    assert(i == 25);\n     i = d4 + c2;    assert(i == 26);\n-    i = d4 + c3;    assert(i == 27);\n-    i = d4 + c4;    assert(i == 28);\n-  }\n-  else\n-  {\n-    //i = c1 + d1;    assert(i == );\n-    i = c1 + d2;    assert(i == 17);\n-//    i = c1 + d3;    assert(i == 21);\n-    i = c1 + d4;    assert(i == 29);\n-\n-    i = c2 + d1;    assert(i == 1);\n-    i = c2 + d2;    assert(i == 2);\n-//    i = c2 + d3;    assert(i == 3);\n-//    i = c2 + d4;    assert(i == 4);\n-\n-    //i = c3 + d1;    assert(i == );\n-//    i = c3 + d2;    printf(\"i = %d\\n\", i); assert(i == 19);\n-//    i = c3 + d3;    assert(i == 23);\n-    i = c3 + d4;    assert(i == 31);\n-\n-    i = c4 + d1;    assert(i == 9);\n-    i = c4 + d2;    assert(i == 10);\n-//    i = c4 + d3;    assert(i == 11);\n-//    i = c4 + d4;    assert(i == 12);\n-\n-    //i = d1 + c1;    assert(i == );\n-    i = d1 + c2;    assert(i == 1);\n-//    i = d1 + c3;    assert(i == 5);\n-    i = d1 + c4;    assert(i == 13);\n-\n-    i = d2 + c1;    assert(i == 17);\n-    i = d2 + c2;    assert(i == 18);\n-//    i = d2 + c3;    assert(i == 19);\n-//    i = d2 + c4;    assert(i == 20);\n-\n-    //i = d3 + c1;    assert(i == );\n-//    i = d3 + c2;    assert(i == 3);\n-//    i = d3 + c3;    assert(i == 7);\n-    i = d3 + c4;    assert(i == 15);\n-\n-    i = d4 + c1;    assert(i == 25);\n-    i = d4 + c2;    assert(i == 26);\n-//    i = d4 + c3;    assert(i == 27);\n-//    i = d4 + c4;    assert(i == 28);\n-  }\n+    i = d4 + c3;    assert(i == 8);\n+    i = d4 + c4;    assert(i == 16);\n }\n \n /**************************************/\n@@ -258,44 +214,45 @@ void test4()\n \n class A5\n {\n-    int opNeg()     { return 10; }\n-    int opCom()     { return 11; }\n-    int opPostInc() { return 12; }\n-    int opPostDec() { return 13; }\n-\n-    int opAdd(int j)     { return 14; }\n-    int opSub(int j)     { return 15; }\n-    int opSub_r(int j)   { return 16; }\n-    int opMul(int j)     { return 17; }\n-    int opDiv(int j)     { return 18; }\n-    int opDiv_r(int j)   { return 19; }\n-    int opMod(int j)     { return 20; }\n-    int opMod_r(int j)   { return 21; }\n-    int opAnd(int j)     { return 22; }\n-    int opOr(int j)      { return 23; }\n-    int opXor(int j)     { return 24; }\n-    int opShl(int j)     { return 25; }\n-    int opShl_r(int j)   { return 26; }\n-    int opShr(int j)     { return 27; }\n-    int opShr_r(int j)   { return 28; }\n-    int opUShr(int j)    { return 29; }\n-    int opUShr_r(int j)  { return 30; }\n-    int opCat(int j)     { return 31; }\n-    int opCat_r(int j)   { return 32; }\n+    int opUnary(string op)() if (op == \"-\")  { return 10; }\n+    int opUnary(string op)() if (op == \"~\")  { return 11; }\n+    int opUnary(string op)() if (op == \"++\") { return 12; }\n+    int opUnary(string op)() if (op == \"--\") { return 13; }\n+\n+\n+    int opBinary(string op)(int j)      if (op == \"+\")   { return 14; }\n+    int opBinary(string op)(int j)      if (op == \"-\")   { return 15; }\n+    int opBinaryRight(string op)(int j) if (op == \"-\")   { return 16; }\n+    int opBinary(string op)(int j)      if (op == \"*\")   { return 17; }\n+    int opBinary(string op)(int j)      if (op == \"/\")   { return 18; }\n+    int opBinaryRight(string op)(int j) if (op == \"/\")   { return 19; }\n+    int opBinary(string op)(int j)      if (op == \"%\")   { return 20; }\n+    int opBinaryRight(string op)(int j) if (op == \"%\")   { return 21; }\n+    int opBinary(string op)(int j)      if (op == \"&\")   { return 22; }\n+    int opBinary(string op)(int j)      if (op == \"|\")   { return 23; }\n+    int opBinary(string op)(int j)      if (op == \"^\")   { return 24; }\n+    int opBinary(string op)(int j)      if (op == \"<<\")  { return 25; }\n+    int opBinaryRight(string op)(int j) if (op == \"<<\")  { return 26; }\n+    int opBinary(string op)(int j)      if (op == \">>\")  { return 27; }\n+    int opBinaryRight(string op)(int j) if (op == \">>\")  { return 28; }\n+    int opBinary(string op)(int j)      if (op == \">>>\") { return 29; }\n+    int opBinaryRight(string op)(int j) if (op == \">>>\") { return 30; }\n+    int opBinary(string op)(int j)      if (op == \"~\")   { return 31; }\n+    int opBinaryRight(string op)(int j) if (op == \"~\")   { return 32; }\n     int opEquals(int j)  { return 33; }\n     int opCmp(int j)     { return 34; }\n-    int opAddAssign(int j)  { return 35; }\n-    int opSubAssign(int j)  { return 36; }\n-    int opMulAssign(int j)  { return 37; }\n-    int opDivAssign(int j)  { return 38; }\n-    int opModAssign(int j)  { return 39; }\n-    int opAndAssign(int j)  { return 40; }\n-    int opOrAssign(int j)   { return 41; }\n-    int opXorAssign(int j)  { return 42; }\n-    int opShlAssign(int j)  { return 43; }\n-    int opShrAssign(int j)  { return 44; }\n-    int opUShrAssign(int j) { return 45; }\n-    int opCatAssign(int j)  { return 46; }\n+    int opOpAssign(string op)(int j) if (op == \"+\")   { return 35; }\n+    int opOpAssign(string op)(int j) if (op == \"-\")   { return 36; }\n+    int opOpAssign(string op)(int j) if (op == \"*\")   { return 37; }\n+    int opOpAssign(string op)(int j) if (op == \"/\")   { return 38; }\n+    int opOpAssign(string op)(int j) if (op == \"%\")   { return 39; }\n+    int opOpAssign(string op)(int j) if (op == \"&\")   { return 40; }\n+    int opOpAssign(string op)(int j) if (op == \"|\")   { return 41; }\n+    int opOpAssign(string op)(int j) if (op == \"^\")   { return 42; }\n+    int opOpAssign(string op)(int j) if (op == \"<<\")  { return 43; }\n+    int opOpAssign(string op)(int j) if (op == \">>\")  { return 44; }\n+    int opOpAssign(string op)(int j) if (op == \">>>\") { return 45; }\n+    int opOpAssign(string op)(int j) if (op == \"~\")   { return 46; }\n }\n \n void test5()\n@@ -309,10 +266,10 @@ void test5()\n     i = ~a;\n     assert(i == 11);\n \n-    i = a++;\n+    i = ++a;\n     assert(i == 12);\n \n-    i = a--;\n+    i = --a;\n     assert(i == 13);\n \n     i = a + 1;\n@@ -402,13 +359,9 @@ printf(\"i = %d\\n\", i);\n \n     i = (a += 1);\n     assert(i == 35);\n-    i = ++a;\n-    assert(i == 35);\n \n     i = (a -= 1);\n     assert(i == 36);\n-    i = --a;\n-    assert(i == 36);\n \n     i = (a *= 1);\n     assert(i == 37);\n@@ -445,45 +398,45 @@ printf(\"i = %d\\n\", i);\n \n struct A6\n {\n-    int opNeg()     { return 10; }\n-    int opCom()     { return 11; }\n-    int opPostInc() { return 12; }\n-    int opPostDec() { return 13; }\n-\n-    int opAdd(int j)     { return 14; }\n-    int opSub(int j)     { return 15; }\n-    int opSub_r(int j)   { return 16; }\n-    int opMul(int j)     { return 17; }\n-    int opDiv(int j)     { return 18; }\n-    int opDiv_r(int j)   { return 19; }\n-    int opMod(int j)     { return 20; }\n-    int opMod_r(int j)   { return 21; }\n-    int opAnd(int j)     { return 22; }\n-    int opOr(int j)      { return 23; }\n-    int opXor(int j)     { return 24; }\n-    int opShl(int j)     { return 25; }\n-    int opShl_r(int j)   { return 26; }\n-    int opShr(int j)     { return 27; }\n-    int opShr_r(int j)   { return 28; }\n-    int opUShr(int j)    { return 29; }\n-    int opUShr_r(int j)  { return 30; }\n-    int opCat(int j)     { return 31; }\n-    int opCat_r(int j)   { return 32; }\n-    int opEquals(int j)      { return 33; }\n+    int opUnary(string op)() if (op == \"-\")  { return 10; }\n+    int opUnary(string op)() if (op == \"~\")  { return 11; }\n+    int opUnary(string op)() if (op == \"++\") { return 12; }\n+    int opUnary(string op)() if (op == \"--\") { return 13; }\n+\n+    int opBinary(string op)(int j)      if (op == \"+\")   { return 14; }\n+    int opBinary(string op)(int j)      if (op == \"-\")   { return 15; }\n+    int opBinaryRight(string op)(int j) if (op == \"-\")   { return 16; }\n+    int opBinary(string op)(int j)      if (op == \"*\")   { return 17; }\n+    int opBinary(string op)(int j)      if (op == \"/\")   { return 18; }\n+    int opBinaryRight(string op)(int j) if (op == \"/\")   { return 19; }\n+    int opBinary(string op)(int j)      if (op == \"%\")   { return 20; }\n+    int opBinaryRight(string op)(int j) if (op == \"%\")   { return 21; }\n+    int opBinary(string op)(int j)      if (op == \"&\")   { return 22; }\n+    int opBinary(string op)(int j)      if (op == \"|\")   { return 23; }\n+    int opBinary(string op)(int j)      if (op == \"^\")   { return 24; }\n+    int opBinary(string op)(int j)      if (op == \"<<\")  { return 25; }\n+    int opBinaryRight(string op)(int j) if (op == \"<<\")  { return 26; }\n+    int opBinary(string op)(int j)      if (op == \">>\")  { return 27; }\n+    int opBinaryRight(string op)(int j) if (op == \">>\")  { return 28; }\n+    int opBinary(string op)(int j)      if (op == \">>>\") { return 29; }\n+    int opBinaryRight(string op)(int j) if (op == \">>>\") { return 30; }\n+    int opBinary(string op)(int j)      if (op == \"~\")   { return 31; }\n+    int opBinaryRight(string op)(int j) if (op == \"~\")   { return 32; }\n+    int opEquals(int j)  { return 33; }\n     const bool opEquals(const ref A6)      { return false; }\n     int opCmp(int j)     { return 34; }\n-    int opAddAssign(int j)  { return 35; }\n-    int opSubAssign(int j)  { return 36; }\n-    int opMulAssign(int j)  { return 37; }\n-    int opDivAssign(int j)  { return 38; }\n-    int opModAssign(int j)  { return 39; }\n-    int opAndAssign(int j)  { return 40; }\n-    int opOrAssign(int j)   { return 41; }\n-    int opXorAssign(int j)  { return 42; }\n-    int opShlAssign(int j)  { return 43; }\n-    int opShrAssign(int j)  { return 44; }\n-    int opUShrAssign(int j) { return 45; }\n-    int opCatAssign(int j)  { return 46; }\n+    int opOpAssign(string op)(int j) if (op == \"+\")   { return 35; }\n+    int opOpAssign(string op)(int j) if (op == \"-\")   { return 36; }\n+    int opOpAssign(string op)(int j) if (op == \"*\")   { return 37; }\n+    int opOpAssign(string op)(int j) if (op == \"/\")   { return 38; }\n+    int opOpAssign(string op)(int j) if (op == \"%\")   { return 39; }\n+    int opOpAssign(string op)(int j) if (op == \"&\")   { return 40; }\n+    int opOpAssign(string op)(int j) if (op == \"|\")   { return 41; }\n+    int opOpAssign(string op)(int j) if (op == \"^\")   { return 42; }\n+    int opOpAssign(string op)(int j) if (op == \"<<\")  { return 43; }\n+    int opOpAssign(string op)(int j) if (op == \">>\")  { return 44; }\n+    int opOpAssign(string op)(int j) if (op == \">>>\") { return 45; }\n+    int opOpAssign(string op)(int j) if (op == \"~\")   { return 46; }\n }\n \n void test6()\n@@ -497,10 +450,10 @@ void test6()\n     i = ~a;\n     assert(i == 11);\n \n-    i = a++;\n+    i = ++a;\n     assert(i == 12);\n \n-    i = a--;\n+    i = --a;\n     assert(i == 13);\n \n     i = a + 1;\n@@ -589,13 +542,9 @@ void test6()\n \n     i = (a += 1);\n     assert(i == 35);\n-    i = ++a;\n-    assert(i == 35);\n \n     i = (a -= 1);\n     assert(i == 36);\n-    i = --a;\n-    assert(i == 36);\n \n     i = (a *= 1);\n     assert(i == 37);\n@@ -652,19 +601,19 @@ void test7()\n \n interface IWriter\n {\n-        int opShl (string i);\n-        int opShl (int i);\n+        int opBinary(string op)(string i) if (op == \"<<\");\n+        int opBinary(string op)(int i) if (op == \"<<\");\n }\n \n class Writer : IWriter\n {\n-    int opShl (string i)\n+    int opBinary(string op)(string i) if (op == \"<<\")\n     {\n         printf(\"Writer.opShl(char[])\\n\");\n         return 1;\n     }\n \n-    int opShl (int i)\n+    int opBinary(string op)(int i) if (op == \"<<\")\n     {\n         printf(\"Writer.opShl(int)\\n\");\n         return 2;\n@@ -673,9 +622,13 @@ class Writer : IWriter\n \n class BinaryWriter : Writer\n {\n-    alias Writer.opShl opShl;\n+    int opBinary(string op)(string i) if (op == \"<<\")\n+    {\n+        printf(\"Writer.opShl(char[])\\n\");\n+        return 1;\n+    }\n \n-    override int opShl (int i)\n+    int opBinary(string op)(int i) if (op == \"<<\")\n     {\n         printf(\"BinaryWriter.opShl(int)\\n\");\n         return 3;\n@@ -712,12 +665,14 @@ void test9()\n \n class A10\n {\n-    int opAdd(int i) { return i + 1; }\n+    int opBinary(string op)(int i) if (op == \"+\") { return i + 1; }\n+    alias opBinaryRight = opBinary;\n }\n \n class B10\n {\n-    int opAdd_r(A10 a) { return 3; }\n+    int opBinaryRight(string op)(A10 a) if (op == \"+\") { return 3; }\n+    alias opBinary = opBinaryRight;\n }\n \n void test10()\n@@ -791,13 +746,13 @@ void test12()\n \n class A13\n {\n- A13 opShl(int x)\n+ A13 opBinary(string op)(int x) if (op == \"<<\")\n  {\n     printf(\"A::opShl(int %d)\\n\", x);\n     printf(\"%d\",x);\n     return this;\n  }\n- A13 opShl(string x)\n+ A13 opBinary(string op)(string x) if (op == \"<<\")\n  {\n     printf(\"A::opShl(char[])\\n\");\n     printf(\"%.*s\", cast(int)x.length, x.ptr);\n@@ -807,7 +762,7 @@ class A13\n \n class B13\n {\n- A13 opShl_r(A13 a)\n+ A13 opBinaryRight(string op)(A13 a) if (op == \"<<\")\n  {\n     printf(\"B::opShl_r(A)\\n\");\n     return a;\n@@ -829,7 +784,7 @@ void test13()\n class Foo14\n {   int a;\n \n-    int opIn(int x)\n+    int opBinary(string op)(int x) if (op == \"in\")\n     {\n         return a + x;\n     }\n@@ -999,36 +954,21 @@ struct Vec12778X\n     float x = 0, y = 0;\n }\n \n-struct Vec12778Y\n-{\n-    Vec12778Y opAdd()(Vec12778Y b) const\n-    {\n-        enum op = \"+\";\n-        mixin(\"return Vec12778Y(this.x \" ~ op ~ \" b.x, this.y \" ~ op ~ \" b.y);\");\n-    }\n-    alias opAdd_r = opAdd;\n-\n-    float x = 0, y = 0;\n-}\n-\n void test12778()\n {\n     struct S\n     {\n         void test1()\n         {\n             Vec12778X vx = vx1 + vx2;   // ok\n-            Vec12778Y vy = vy1 + vy2;   // ok\n         }\n \n         void test2() const\n         {\n             Vec12778X vx = vx1 + vx2;   // ok <- error\n-            Vec12778Y vy = vy1 + vy2;   // ok <- error\n         }\n \n         Vec12778X vx1, vx2;\n-        Vec12778Y vy1, vy2;\n     }\n }\n \n@@ -1049,8 +989,8 @@ struct S14343b\n     int i;\n     immutable(Object) o;\n \n-    void opAddAssign(int j) { i += j; }\n-    S14343b opPostInc() { ++i; return this; }\n+    void opOpAssign(string op)(int j) if (op == \"+\") { i += j; }\n+    S14343b opUnary(string op)() if (op == \"++\") { ++i; return this; }\n     void opAssign(S14343b other) {}\n }\n "}, {"sha": "bd820e498f41d9ee3efd009f1048d4a22f569720", "filename": "gcc/testsuite/gdc.test/runnable/sctor2.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsctor2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsctor2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsctor2.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,5 +1,10 @@\n-// REQUIRED_ARGS: -w -de\n+// REQUIRED_ARGS: -w -dw\n // PERMUTE_ARGS:\n+/* TEST_OUTPUT:\n+---\n+runnable/sctor2.d(12): Deprecation: `scope` as a type constraint is deprecated.  Use `scope` at the usage site.\n+---\n+*/\n \n /***************************************************/\n // 15665"}, {"sha": "8b5af24396e2182f91120d760b567de854f18800", "filename": "gcc/testsuite/gdc.test/runnable/test22136.d", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b85638affe6c987a33427c54e0369b819cd7915/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22136.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b85638affe6c987a33427c54e0369b819cd7915/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22136.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest22136.d?ref=1b85638affe6c987a33427c54e0369b819cd7915", "patch": "@@ -1,25 +0,0 @@\n-\n-interface IObject\n-{\n-    size_t toHash() @trusted nothrow;\n-}\n-\n-interface Dummy {}\n-interface Bug(E) : Dummy, IObject {}\n-interface OK(E) : IObject, Dummy {}\n-\n-void main()\n-{\n-\n-    {\n-        Bug!string s;\n-        size_t t = hashOf(s);\n-    }\n-    {\n-        OK!string s;\n-        size_t t = hashOf(s);\n-    }\n-\n-    static assert(is(immutable Bug!string* : immutable IObject*));\n-    static assert(is(immutable OK!string* : immutable IObject*));\n-}"}, {"sha": "17e3236f80fa262217def022461ed513c7ba36a0", "filename": "gcc/testsuite/gdc.test/runnable/testconst.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -2175,13 +2175,13 @@ void test4251b()\n     // derived class to const(base interface) in tail\n     interface I {}\n     class X : I {}\n-    static assert(is( X[] : const(I)[] ));\n+    static assert(!is( X[] : const(I)[] ));\n \n     // interface to const(base interface) in tail\n     interface J {}\n     interface K : I, J {}\n     static assert( is( K[] : const(I)[] )); // OK, runtime offset is same\n-    static assert(is( K[] : const(J)[] )); // !? NG, runtime offset is different\n+    static assert(!is( K[] : const(J)[] )); // NG, runtime offset is different\n }\n \n /************************************/"}, {"sha": "eeaa1dbe72d3f9ba69a075796843bc8ad4c47ab9", "filename": "gcc/testsuite/gdc.test/runnable/xtest46.d", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -14,14 +14,6 @@ tuple(height)\n tuple(get, get)\n tuple(clear)\n tuple(draw, draw)\n-runnable/xtest46.d(149): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(151): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(152): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(154): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(181): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(183): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(184): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46.d(186): Deprecation: `opDot` is deprecated. Use `alias this`\n const(int)\n string[]\n double[]\n@@ -137,10 +129,7 @@ struct T6\n     S6 s;\n     int b = 7;\n \n-    S6* opDot() return\n-    {\n-        return &s;\n-    }\n+    alias s this;\n }\n \n void test6()\n@@ -169,10 +158,7 @@ class C7\n     S7 s;\n     int b = 7;\n \n-    S7* opDot()\n-    {\n-        return &s;\n-    }\n+    alias s this;\n }\n \n void test7()"}, {"sha": "348c05bd09d0feb3257ca1b0e90d1f1614afab73", "filename": "gcc/testsuite/gdc.test/runnable/xtest46_gc.d", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46_gc.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -15,14 +15,6 @@ tuple(height)\n tuple(get, get)\n tuple(clear)\n tuple(draw, draw)\n-runnable/xtest46_gc.d-mixin-$n$(185): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(187): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(188): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(190): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(217): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(219): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(220): Deprecation: `opDot` is deprecated. Use `alias this`\n-runnable/xtest46_gc.d-mixin-$n$(222): Deprecation: `opDot` is deprecated. Use `alias this`\n const(int)\n string[]\n double[]"}, {"sha": "77b6ad001739637b31e39d524c7f5f6da1dc5c81", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,4 +1,4 @@\n-0316b981e5f2fa1525e893c5d94c59c847a8c386\n+26b581670ef6e2643d74078f200d1cd21fa40e90\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "aa94e4076428a2698d76e50fa7c5b5c844133868", "filename": "libphobos/libdruntime/core/internal/gc/bits.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -239,7 +239,9 @@ struct GCBits\n             size_t cntWords = lastWord - firstWord;\n             copyWordsShifted(firstWord, cntWords, firstOff, source);\n \n-            wordtype src = (source[cntWords - 1] >> (BITS_PER_WORD - firstOff)) | (source[cntWords] << firstOff);\n+            wordtype src = (source[cntWords - 1] >> (BITS_PER_WORD - firstOff));\n+            if (lastOff >= firstOff) // prevent buffer overread\n+                src |= (source[cntWords] << firstOff);\n             wordtype mask = (BITS_2 << lastOff) - 1;\n             data[lastWord] = (data[lastWord] & ~mask) | (src & mask);\n         }"}, {"sha": "037af25a675c5b2c890ba62d888dea15381e65ac", "filename": "libphobos/libdruntime/core/stdc/config.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fconfig.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -34,7 +34,7 @@ version (StdDdoc)\n             alias ddoc_long = int;\n             alias ddoc_ulong = uint;\n         }\n-        struct ddoc_complex(T) { T re; T im; };\n+        struct ddoc_complex(T) { T re; T im; }\n     }\n \n     /***"}, {"sha": "88123fb16a64f4a95cbca66f7f492f000dd52e00", "filename": "libphobos/libdruntime/core/stdc/fenv.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ffenv.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -151,6 +151,8 @@ version (GNUFP)\n     // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/sparc/fpu/bits/fenv.h\n     else version (SPARC_Any)\n     {\n+        import core.stdc.config : c_ulong;\n+\n         alias fenv_t = c_ulong;\n         alias fexcept_t = c_ulong;\n     }"}, {"sha": "556ac019eeb5b32498e18b18302a17ae447b62cb", "filename": "libphobos/libdruntime/core/stdc/stdint.d", "status": "modified", "additions": 258, "deletions": 56, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdint.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -36,20 +36,7 @@ extern (C):\n nothrow:\n @nogc:\n \n-// These are defined the same way as D basic types, so the definition is\n-// platform-independant\n-alias int8_t   = byte;   ///\n-alias int16_t  = short;  ///\n-alias uint8_t  = ubyte;  ///\n-alias uint16_t = ushort; ///\n-\n-// 32 bit types and need to be defined on-platform basis, because\n-// they might have C++ binary mangling of `int` or `long`.\n-// 64-bit types respectively might be mangled as `long` or `long long`\n-\n-// It would seem correct to define intmax_t and uintmax_t here, but C and C++\n-// compilers don't in practice always set them to the maximum supported value.\n-// See https://quuxplusone.github.io/blog/2019/02/28/is-int128-integral/\n+\n static if (is(ucent))\n {\n     alias int128_t = cent;   ///\n@@ -58,6 +45,10 @@ static if (is(ucent))\n \n version (Windows)\n {\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n     version (CRuntime_DigitalMars)\n     {\n         alias int32_t  = cpp_long;  ///\n@@ -71,23 +62,31 @@ version (Windows)\n     alias int64_t  = long;   ///\n     alias uint64_t = ulong;  ///\n \n-    alias int_least8_t   = byte; ///\n-    alias uint_least8_t  = ubyte; ///\n-    alias int_least16_t  = short; ///\n-    alias uint_least16_t = ushort; ///\n-    alias int_least32_t  = int32_t; ///\n+    alias int_least8_t   = byte;     ///\n+    alias uint_least8_t  = ubyte;    ///\n+    alias int_least16_t  = short;    ///\n+    alias uint_least16_t = ushort;   ///\n+    alias int_least32_t  = int32_t;  ///\n     alias uint_least32_t = uint32_t; ///\n-    alias int_least64_t  = long; ///\n-    alias uint_least64_t = ulong; ///\n+    alias int_least64_t  = long;     ///\n+    alias uint_least64_t = ulong;    ///\n \n-    alias int_fast8_t   = byte; ///\n-    alias uint_fast8_t  = ubyte; ///\n-    alias int_fast16_t  = int; ///\n-    alias uint_fast16_t = uint; ///\n-    alias int_fast32_t  = int32_t; ///\n+    alias int_fast8_t   = byte;     ///\n+    alias uint_fast8_t  = ubyte;    ///\n+    version (MinGW)\n+    {\n+        alias int_fast16_t  = short;  ///\n+        alias uint_fast16_t = ushort; ///\n+    }\n+    else\n+    {\n+        alias int_fast16_t  = int;  ///\n+        alias uint_fast16_t = uint; ///\n+    }\n+    alias int_fast32_t  = int32_t;  ///\n     alias uint_fast32_t = uint32_t; ///\n-    alias int_fast64_t  = long; ///\n-    alias uint_fast64_t = ulong; ///\n+    alias int_fast64_t  = long;     ///\n+    alias uint_fast64_t = ulong;    ///\n \n     alias intptr_t  = ptrdiff_t; ///\n     alias uintptr_t = size_t;    ///\n@@ -96,6 +95,10 @@ version (Windows)\n }\n else version (Darwin)\n {\n+    alias int8_t   = byte;          ///\n+    alias int16_t  = short;         ///\n+    alias uint8_t  = ubyte;         ///\n+    alias uint16_t = ushort;        ///\n     alias int32_t  = int;           ///\n     alias uint32_t = uint;          ///\n     alias int64_t  = cpp_longlong;  ///\n@@ -124,32 +127,27 @@ else version (Darwin)\n     alias intmax_t  = long;      ///\n     alias uintmax_t = ulong;     ///\n }\n-else version (Posix)\n+else version (linux)\n {\n-    alias int32_t  = int; ///\n-    alias uint32_t = uint; ///\n-    alias int64_t  = long; ///\n-    alias uint64_t = ulong; ///\n-\n-    alias int_least8_t   = byte; ///\n-    alias uint_least8_t  = ubyte; ///\n-    alias int_least16_t  = short; ///\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = byte;   ///\n+    alias uint_least8_t  = ubyte;  ///\n+    alias int_least16_t  = short;  ///\n     alias uint_least16_t = ushort; ///\n-    alias int_least32_t  = int; ///\n-    alias uint_least32_t = uint; ///\n-    alias int_least64_t  = long; ///\n-    alias uint_least64_t = ulong;///\n+    alias int_least32_t  = int;    ///\n+    alias uint_least32_t = uint;   ///\n+    alias int_least64_t  = long;   ///\n+    alias uint_least64_t = ulong;  ///\n \n-    version (FreeBSD)\n-    {\n-        alias int_fast8_t   = int;  ///\n-        alias uint_fast8_t  = uint; ///\n-        alias int_fast16_t  = int;  ///\n-        alias uint_fast16_t = uint; ///\n-        alias int_fast32_t  = int;  ///\n-        alias uint_fast32_t = uint; ///\n-    }\n-    else version (CRuntime_Musl)\n+    version (CRuntime_Musl)\n     {\n         alias int_fast8_t   = byte;  ///\n         alias uint_fast8_t  = ubyte; ///\n@@ -167,17 +165,221 @@ else version (Posix)\n         alias int_fast32_t  = ptrdiff_t; ///\n         alias uint_fast32_t = size_t;    ///\n     }\n-    alias int_fast64_t  = long; ///\n+    alias int_fast64_t  = long;      ///\n+    alias uint_fast64_t = ulong;     ///\n+\n+    alias intptr_t  = ptrdiff_t; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n+}\n+else version (CRuntime_Glibc)\n+{\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = byte;   ///\n+    alias uint_least8_t  = ubyte;  ///\n+    alias int_least16_t  = short;  ///\n+    alias uint_least16_t = ushort; ///\n+    alias int_least32_t  = int;    ///\n+    alias uint_least32_t = uint;   ///\n+    alias int_least64_t  = long;   ///\n+    alias uint_least64_t = ulong;  ///\n+\n+    alias int_fast8_t   = byte;      ///\n+    alias uint_fast8_t  = ubyte;     ///\n+    alias int_fast16_t  = ptrdiff_t; ///\n+    alias uint_fast16_t = size_t;    ///\n+    alias int_fast32_t  = ptrdiff_t; ///\n+    alias uint_fast32_t = size_t;    ///\n+    alias int_fast64_t  = long;      ///\n+    alias uint_fast64_t = ulong;     ///\n+\n+    alias intptr_t  = ptrdiff_t; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n+}\n+else version (DragonFlyBSD)\n+{\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = int8_t;   ///\n+    alias uint_least8_t  = uint8_t;  ///\n+    alias int_least16_t  = int16_t;  ///\n+    alias uint_least16_t = uint16_t; ///\n+    alias int_least32_t  = int32_t;  ///\n+    alias uint_least32_t = uint32_t; ///\n+    alias int_least64_t  = int64_t;  ///\n+    alias uint_least64_t = uint64_t; ///\n+\n+    alias int_fast8_t   = int32_t;   ///\n+    alias uint_fast8_t  = uint32_t;  ///\n+    alias int_fast16_t  = int32_t;   ///\n+    alias uint_fast16_t = uint32_t;  ///\n+    alias int_fast32_t  = int32_t;   ///\n+    alias uint_fast32_t = uint32_t;  ///\n+    alias int_fast64_t  = int64_t;   ///\n+    alias uint_fast64_t = uint64_t;  ///\n+\n+    alias intptr_t  = ptrdiff_t; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n+}\n+else version (FreeBSD)\n+{\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = byte;   ///\n+    alias uint_least8_t  = ubyte;  ///\n+    alias int_least16_t  = short;  ///\n+    alias uint_least16_t = ushort; ///\n+    alias int_least32_t  = int;    ///\n+    alias uint_least32_t = uint;   ///\n+    alias int_least64_t  = long;   ///\n+    alias uint_least64_t = ulong;  ///\n+\n+    alias int_fast8_t   = int;   ///\n+    alias uint_fast8_t  = uint;  ///\n+    alias int_fast16_t  = int;   ///\n+    alias uint_fast16_t = uint;  ///\n+    alias int_fast32_t  = int;   ///\n+    alias uint_fast32_t = uint;  ///\n+    alias int_fast64_t  = long;  ///\n     alias uint_fast64_t = ulong; ///\n \n     alias intptr_t  = ptrdiff_t; ///\n-    alias uintptr_t = size_t; ///\n-    alias intmax_t  = long; ///\n-    alias uintmax_t = ulong; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n+}\n+else version (NetBSD)\n+{\n+    alias int8_t   = byte;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = int8_t;   ///\n+    alias uint_least8_t  = uint8_t;  ///\n+    alias int_least16_t  = int16_t;  ///\n+    alias uint_least16_t = uint16_t; ///\n+    alias int_least32_t  = int32_t;  ///\n+    alias uint_least32_t = uint32_t; ///\n+    alias int_least64_t  = int64_t;  ///\n+    alias uint_least64_t = uint64_t; ///\n+\n+    alias int_fast8_t   = int32_t;   ///\n+    alias uint_fast8_t  = uint32_t;  ///\n+    alias int_fast16_t  = int32_t;   ///\n+    alias uint_fast16_t = uint32_t;  ///\n+    alias int_fast32_t  = int32_t;   ///\n+    alias uint_fast32_t = uint32_t;  ///\n+    alias int_fast64_t  = int64_t;   ///\n+    alias uint_fast64_t = uint64_t;  ///\n+\n+    alias intptr_t  = ptrdiff_t; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n+}\n+else version (OpenBSD)\n+{\n+    alias int8_t   = byte;          ///\n+    alias int16_t  = short;         ///\n+    alias uint8_t  = ubyte;         ///\n+    alias uint16_t = ushort;        ///\n+    alias int32_t  = int;           ///\n+    alias uint32_t = uint;          ///\n+    alias int64_t  = cpp_longlong;  ///\n+    alias uint64_t = cpp_ulonglong; ///\n+\n+    alias int_least8_t   = byte;          ///\n+    alias uint_least8_t  = ubyte;         ///\n+    alias int_least16_t  = short;         ///\n+    alias uint_least16_t = ushort;        ///\n+    alias int_least32_t  = int;           ///\n+    alias uint_least32_t = uint;          ///\n+    alias int_least64_t  = cpp_longlong;  ///\n+    alias uint_least64_t = cpp_ulonglong; ///\n+\n+    alias int_fast8_t   = int;           ///\n+    alias uint_fast8_t  = uint;          ///\n+    alias int_fast16_t  = int;           ///\n+    alias uint_fast16_t = uint;          ///\n+    alias int_fast32_t  = int;           ///\n+    alias uint_fast32_t = uint;          ///\n+    alias int_fast64_t  = cpp_longlong;  ///\n+    alias uint_fast64_t = cpp_ulonglong; ///\n+\n+    alias intptr_t  = cpp_long;      ///\n+    alias uintptr_t = cpp_ulong;     ///\n+    alias intmax_t  = cpp_longlong;  ///\n+    alias uintmax_t = cpp_ulonglong; ///\n+}\n+else version (Solaris)\n+{\n+    alias int8_t   = char;   ///\n+    alias int16_t  = short;  ///\n+    alias uint8_t  = ubyte;  ///\n+    alias uint16_t = ushort; ///\n+    alias int32_t  = int;    ///\n+    alias uint32_t = uint;   ///\n+    alias int64_t  = long;   ///\n+    alias uint64_t = ulong;  ///\n+\n+    alias int_least8_t   = char;   ///\n+    alias uint_least8_t  = ubyte;  ///\n+    alias int_least16_t  = short;  ///\n+    alias uint_least16_t = ushort; ///\n+    alias int_least32_t  = int;    ///\n+    alias uint_least32_t = uint;   ///\n+    alias int_least64_t  = long;   ///\n+    alias uint_least64_t = ulong;  ///\n+\n+    alias int_fast8_t   = char;  ///\n+    alias uint_fast8_t  = ubyte; ///\n+    alias int_fast16_t  = int;   ///\n+    alias uint_fast16_t = uint;  ///\n+    alias int_fast32_t  = int;   ///\n+    alias uint_fast32_t = uint;  ///\n+    alias int_fast64_t  = long;  ///\n+    alias uint_fast64_t = ulong; ///\n+\n+    alias intptr_t  = ptrdiff_t; ///\n+    alias uintptr_t = size_t;    ///\n+    alias intmax_t  = long;      ///\n+    alias uintmax_t = ulong;     ///\n }\n else\n {\n-    static assert(0);\n+    static assert(false, \"Unsupported architecture.\");\n }\n \n "}, {"sha": "6a598baec286dc05a82d426939a7bab7909aa219", "filename": "libphobos/libdruntime/core/stdcpp/new_.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fnew_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fnew_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fnew_.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -26,7 +26,7 @@ extern (C++, \"std\")\n     struct nothrow_t {}\n \n     ///\n-    enum align_val_t : size_t { defaultAlignment = __STDCPP_DEFAULT_NEW_ALIGNMENT__ };\n+    enum align_val_t : size_t { defaultAlignment = __STDCPP_DEFAULT_NEW_ALIGNMENT__ }\n \n     ///\n     class bad_alloc : exception"}, {"sha": "16f66e1287e0d3a21a9159fd223afce18d42120b", "filename": "libphobos/libdruntime/core/sys/windows/stat.d", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fstat.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -8,6 +8,8 @@ version (Windows):\n extern (C) nothrow @nogc:\n @system:\n \n+import core.sys.windows.stdc.time;\n+\n // Posix version is in core.sys.posix.sys.stat\n \n enum S_IFMT   = 0xF000;\n@@ -30,22 +32,49 @@ int S_ISDIR(int m)  { return (m & S_IFMT) == S_IFDIR; }\n int S_ISCHR(int m)  { return (m & S_IFMT) == S_IFCHR; }\n }\n \n-struct struct_stat\n+version (CRuntime_DigitalMars)\n {\n-    short st_dev;\n-    ushort st_ino;\n-    ushort st_mode;\n-    short st_nlink;\n-    ushort st_uid;\n-    ushort st_gid;\n-    short st_rdev;\n-    short dummy;\n-    int st_size;\n-    int st_atime;\n-    int st_mtime;\n-    int st_ctime;\n+    struct struct_stat\n+    {\n+        short st_dev;\n+        ushort st_ino;\n+        ushort st_mode;\n+        short st_nlink;\n+        ushort st_uid;\n+        ushort st_gid;\n+        short st_rdev;\n+        short dummy;\n+        int st_size;\n+        time_t st_atime;\n+        time_t st_mtime;\n+        time_t st_ctime;\n+    }\n+\n+    int stat(const(char)*, struct_stat *);\n+    int fstat(int, struct_stat *) @trusted;\n+    int _wstat(const(wchar)*, struct_stat *);\n }\n+else version (CRuntime_Microsoft)\n+{\n+    struct struct_stat\n+    {\n+        uint st_dev;\n+        ushort st_ino;\n+        ushort st_mode;\n+        short st_nlink;\n+        short st_uid;\n+        short st_gid;\n+        uint st_rdev;\n+        int st_size;\n+        time_t st_atime;\n+        time_t st_mtime;\n+        time_t st_ctime;\n+    }\n \n-int  stat(const(char)*, struct_stat *);\n-int  fstat(int, struct_stat *) @trusted;\n-int  _wstat(const(wchar)*, struct_stat *);\n+    // These assume time_t is 32 bits (which druntime's definition currently is)\n+    // Add pragma(mangle) to use _stat64 etc. when time_t is made 64-bit\n+    // See also: https://issues.dlang.org/show_bug.cgi?id=21134\n+    int stat(const(char)*, struct_stat *);\n+    int fstat(int, struct_stat *) @trusted;\n+    int _wstat(const(wchar)*, struct_stat *);\n+}"}, {"sha": "b0e25b570541dd4c022706c88fe273fb1765c37e", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1011,8 +1011,12 @@ extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length) pure nothrow @\n     foreach (T; AliasSeq!(ubyte, ushort, uint, ulong))\n     {\n     case T.sizeof:\n-        (cast(T*)result.ptr)[0 .. size * length / T.sizeof] = *cast(T*)init.ptr;\n-        return result;\n+        if (tinext.talign % T.alignof == 0)\n+        {\n+            (cast(T*)result.ptr)[0 .. size * length / T.sizeof] = *cast(T*)init.ptr;\n+            return result;\n+        }\n+        goto default;\n     }\n \n     default:\n@@ -1118,7 +1122,8 @@ extern (C) void* _d_newitemU(scope const TypeInfo _ti) pure nothrow @weak\n \n     if (tiSize)\n     {\n-        *cast(TypeInfo*)(p + itemSize) = null; // the GC might not have cleared this area\n+        // the GC might not have cleared the padding area in the block\n+        *cast(TypeInfo*)(p + (itemSize & ~(size_t.sizeof - 1))) = null;\n         *cast(TypeInfo*)(p + blkInf.size - tiSize) = cast() ti;\n     }\n "}, {"sha": "963ffe020de7705c5faeb4825ebc9601ec2e2771", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1,4 +1,4 @@\n-a1f8c4c0700ce4e256f4130ad7883c6ea3890901\n+16cb085b584f100fa677e2e64ff6b6dbb4921ad1\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "cc6f5b77db799ecf9b53e3ef15f92751b16c7c5a", "filename": "libphobos/src/std/algorithm/setops.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsetops.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsetops.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsetops.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -404,7 +404,7 @@ if (ranges.length >= 2 &&\n                     r = ranges[i].save; // rollover\n             }\n         }\n-        @property Result save() scope return\n+        @property Result save() return scope\n         {\n             Result copy = this;\n             foreach (i, r; ranges)"}, {"sha": "de2e0fb262f8f3fbb512f72ef0f08d276de15cb8", "filename": "libphobos/src/std/bitmanip.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fbitmanip.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fbitmanip.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1447,7 +1447,8 @@ public:\n             size_t bitCount;\n             foreach (i; 0 .. fullWords)\n                 bitCount += countBitsSet(_ptr[i]);\n-            bitCount += countBitsSet(_ptr[fullWords] & endMask);\n+            if (endBits)\n+                bitCount += countBitsSet(_ptr[fullWords] & endMask);\n             return bitCount;\n         }\n         else"}, {"sha": "d787e3a8080cc5e76c77b6e632b69657aa85cd10", "filename": "libphobos/src/std/datetime/interval.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Finterval.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -7848,12 +7848,12 @@ if (isTimePoint!TP &&\n         duration = The duration which separates each successive time point in\n                    the range.\n   +/\n-TP delegate(scope const TP) everyDuration(TP, Direction dir = Direction.fwd, D)(D duration) nothrow\n+TP delegate(return scope const TP) everyDuration(TP, Direction dir = Direction.fwd, D)(D duration) nothrow\n if (isTimePoint!TP &&\n     __traits(compiles, TP.init + duration) &&\n     (dir == Direction.fwd || dir == Direction.bwd))\n {\n-    TP func(scope const TP tp)\n+    TP func(return scope const TP tp)\n     {\n         static if (dir == Direction.fwd)\n             return tp + duration;"}, {"sha": "949ad7d75ccaf16087f1ab6689471fc04ff750a7", "filename": "libphobos/src/std/datetime/systime.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Fsystime.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -6269,7 +6269,7 @@ public:\n             duration = The $(REF Duration, core,time) to add to or subtract from\n                        this $(LREF SysTime).\n       +/\n-    SysTime opBinary(string op)(Duration duration) @safe const pure nothrow scope\n+    SysTime opBinary(string op)(Duration duration) @safe const pure nothrow return scope\n         if (op == \"+\" || op == \"-\")\n     {\n         SysTime retval = SysTime(this._stdTime, this._timezone);\n@@ -7668,7 +7668,7 @@ public:\n         $(LREF SysTime) for the last day in the month that this Date is in.\n         The time portion of endOfMonth is always 23:59:59.9999999.\n       +/\n-    @property SysTime endOfMonth() @safe const nothrow scope\n+    @property SysTime endOfMonth() @safe const nothrow return scope\n     {\n         immutable hnsecs = adjTime;\n         immutable days = getUnitsFromHNSecs!\"days\"(hnsecs);"}, {"sha": "de9afbbf7d53c4f27320a039a013949634628a78", "filename": "libphobos/src/std/experimental/allocator/mallocator.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fmallocator.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fmallocator.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fmallocator.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -392,6 +392,7 @@ version (Posix)\n     AlignedMallocator.instance.alignedReallocate(c, 32, 32);\n     assert(c.ptr);\n \n+    version (LDC_AddressSanitizer) {} else // AddressSanitizer does not support such large memory allocations (0x10000000000 max)\n     version (DragonFlyBSD) {} else    /* FIXME: Malloc on DragonFly does not return NULL when allocating more than UINTPTR_MAX\n                                        * $(LINK: https://bugs.dragonflybsd.org/issues/3114, dragonfly bug report)\n                                        * $(LINK: https://github.com/dlang/druntime/pull/1999#discussion_r157536030, PR Discussion) */"}, {"sha": "90b0f91ecce0b2c1b2899845b8b771ea5905e2fd", "filename": "libphobos/src/std/functional.d", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Ffunctional.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Ffunctional.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffunctional.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1847,3 +1847,168 @@ if (isCallable!(F))\n         static assert(! is(typeof(dg_xtrnC) == typeof(dg_xtrnD)));\n     }\n }\n+\n+// Converts an unsigned integer to a compile-time string constant.\n+private enum toCtString(ulong n) = n.stringof[0 .. $ - \"LU\".length];\n+\n+// Check that .stringof does what we expect, since it's not guaranteed by the\n+// language spec.\n+@safe unittest\n+{\n+    assert(toCtString!0 == \"0\");\n+    assert(toCtString!123456 == \"123456\");\n+}\n+\n+/**\n+ * Passes the fields of a struct as arguments to a function.\n+ *\n+ * Can be used with a $(LINK2 https://dlang.org/spec/expression.html#function_literals,\n+ * function literal) to give temporary names to the fields of a struct or\n+ * tuple.\n+ *\n+ * Params:\n+ *   fun = Callable that the struct's fields will be passed to.\n+ *\n+ * Returns:\n+ *   A function that accepts a single struct as an argument and passes its\n+ *   fields to `fun` when called.\n+ */\n+template bind(alias fun)\n+{\n+    /**\n+     * Params:\n+     *   args = The struct or tuple whose fields will be used as arguments.\n+     *\n+     * Returns: `fun(args.tupleof)`\n+     */\n+    auto ref bind(T)(auto ref T args)\n+    if (is(T == struct))\n+    {\n+        import std.meta : Map = staticMap;\n+        import core.lifetime : move;\n+\n+        // Forwards the i'th member of `args`\n+        // Needed because core.lifetime.forward doesn't work on struct members\n+        template forwardArg(size_t i)\n+        {\n+            static if (__traits(isRef, args) || !is(typeof(move(args.tupleof[i]))))\n+                enum forwardArg = \"args.tupleof[\" ~ toCtString!i ~ \"], \";\n+            else\n+                enum forwardArg = \"move(args.tupleof[\" ~ toCtString!i ~ \"]), \";\n+        }\n+\n+        static if (args.tupleof.length == 0)\n+            enum argList = \"\";\n+        else\n+            alias argList = Map!(forwardArg, Iota!(args.tupleof.length));\n+\n+        return mixin(\"fun(\", argList, \")\");\n+    }\n+}\n+\n+/// Giving names to tuple elements\n+@safe unittest\n+{\n+    import std.typecons : tuple;\n+\n+    auto name = tuple(\"John\", \"Doe\");\n+    string full = name.bind!((first, last) => first ~ \" \" ~ last);\n+    assert(full == \"John Doe\");\n+}\n+\n+/// Passing struct fields to a function\n+@safe unittest\n+{\n+    import std.algorithm.comparison : min, max;\n+\n+    struct Pair\n+    {\n+        int a;\n+        int b;\n+    }\n+\n+    auto p = Pair(123, 456);\n+    assert(p.bind!min == 123); // min(p.a, p.b)\n+    assert(p.bind!max == 456); // max(p.a, p.b)\n+}\n+\n+/// In a range pipeline\n+@safe unittest\n+{\n+    import std.algorithm.iteration : map, filter;\n+    import std.algorithm.comparison : equal;\n+    import std.typecons : tuple;\n+\n+    auto ages = [\n+        tuple(\"Alice\", 35),\n+        tuple(\"Bob\",   64),\n+        tuple(\"Carol\", 21),\n+        tuple(\"David\", 39),\n+        tuple(\"Eve\",   50)\n+    ];\n+\n+    auto overForty = ages\n+        .filter!(bind!((name, age) => age > 40))\n+        .map!(bind!((name, age) => name));\n+\n+    assert(overForty.equal([\"Bob\", \"Eve\"]));\n+}\n+\n+// Zero arguments\n+@safe unittest\n+{\n+    struct Empty {}\n+\n+    assert(Empty().bind!(() => 123) == 123);\n+}\n+\n+// Non-copyable arguments\n+@safe unittest\n+{\n+    import std.typecons : tuple;\n+\n+    static struct NoCopy\n+    {\n+        int n;\n+        @disable this(this);\n+    }\n+\n+    static struct Pair\n+    {\n+        NoCopy a, b;\n+    }\n+\n+    static auto fun(NoCopy a, NoCopy b)\n+    {\n+        return tuple(a.n, b.n);\n+    }\n+\n+    auto expected = fun(NoCopy(1), NoCopy(2));\n+    assert(Pair(NoCopy(1), NoCopy(2)).bind!fun == expected);\n+}\n+\n+// ref arguments\n+@safe unittest\n+{\n+    import std.typecons : tuple;\n+\n+    auto t = tuple(123, 456);\n+    t.bind!((ref int a, int b) { a = 789; b = 1011; });\n+\n+    assert(t[0] == 789);\n+    assert(t[1] == 456);\n+}\n+\n+// auto ref arguments\n+@safe unittest\n+{\n+    import std.typecons : tuple;\n+\n+    auto t = tuple(123);\n+    t.bind!((auto ref x) {\n+        static assert(__traits(isRef, x));\n+    });\n+    tuple(123).bind!((auto ref x) {\n+        static assert(!__traits(isRef, x));\n+    });\n+}"}, {"sha": "8da38bdb4e69b38196778eb2d1f2edd3d61eaed5", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -13,6 +13,7 @@ include:\n \n License: Boost License 1.0\n Authors: Paul Backus\n+Source: $(PHOBOSSRC std/sumtype.d)\n +/\n module std.sumtype;\n "}, {"sha": "f0200ce705220d519d963217170705e72a0739dc", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e28750395889d16a9cba49cd5935ced7dc00ce8/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=7e28750395889d16a9cba49cd5935ced7dc00ce8", "patch": "@@ -1209,6 +1209,15 @@ do\n     assert(\"\u00eb\"w.decode(i) == '\u00eb' && i == 1);\n }\n \n+@safe pure unittest // https://issues.dlang.org/show_bug.cgi?id=22867\n+{\n+    import std.conv : hexString;\n+    string data = hexString!\"f787a598\";\n+    size_t offset = 0;\n+    try data.decode(offset);\n+    catch (UTFException ex) assert(offset == 0);\n+}\n+\n /++\n     `decodeFront` is a variant of $(LREF decode) which specifically decodes\n     the first code point. Unlike $(LREF decode), `decodeFront` accepts any\n@@ -1671,7 +1680,6 @@ if (\n                 }\n             }\n \n-            index += i + 1;\n             static if (i == 3)\n             {\n                 if (d > dchar.max)\n@@ -1682,6 +1690,8 @@ if (\n                         throw invalidUTF();\n                 }\n             }\n+\n+            index += i + 1;\n             return d;\n         }\n     }"}]}