{"sha": "d1be3be36793cb20f6f2df953a9e795f6da2953e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFiZTNiZTM2NzkzY2IyMGY2ZjJkZjk1M2E5ZTc5NWY2ZGEyOTUzZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-11-24T20:42:38Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-11-24T20:42:38Z"}, "message": "Add m68k-elf port from Cygnus gcc sources.\n\n\t* configure.in (m68020-*-elf*, m68k-*-elf*): New targets.\n\t* configure: Rebuild.\n\t* config/elfos.h: New file.\n\t* config/m68k/m68020-elf.h, config/m68k/m68kelf.h,\n\tconfig/m68k/t-m68kelf: New file.\n\nFrom-SVN: r23835", "tree": {"sha": "89e1aedfe5feca2642a8227dede6ff77f4ca513b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89e1aedfe5feca2642a8227dede6ff77f4ca513b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1be3be36793cb20f6f2df953a9e795f6da2953e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1be3be36793cb20f6f2df953a9e795f6da2953e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1be3be36793cb20f6f2df953a9e795f6da2953e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1be3be36793cb20f6f2df953a9e795f6da2953e/comments", "author": null, "committer": null, "parents": [{"sha": "23a79c61921246f3d84df2503555208f2683203e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a79c61921246f3d84df2503555208f2683203e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a79c61921246f3d84df2503555208f2683203e"}], "stats": {"total": 1118, "additions": 1115, "deletions": 3}, "files": [{"sha": "d986252563b22c0d5a49b62dff7a7d606461935b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -1,3 +1,11 @@\n+Tue Nov 24 20:24:59 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* configure.in (m68020-*-elf*, m68k-*-elf*): New targets.\n+\t* configure: Rebuild.\n+\t* config/elfos.h: New file.\n+\t* config/m68k/m68020-elf.h, config/m68k/m68kelf.h,\n+\tconfig/m68k/t-m68kelf: New file.\n+\t\n Tue Nov 24 13:40:06 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (HOST_AR): Define."}, {"sha": "ad1c3f5aeb638f0bbd5895706a09d3840cc08d63", "filename": "gcc/config/elfos.h", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -0,0 +1,755 @@\n+/* elfos.h  --  operating system specific defines to be used when\n+   targeting GCC for some generic ELF system\n+   Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.\n+   Based on svr4.h contributed by Ron Guilmette (rfg@netcom.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+*/\n+\n+/* For the sake of libgcc2.c, indicate target supports atexit.  */\n+#define HAVE_ATEXIT\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s\"\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared: \\\n+\t\t\t %{!symbolic: \\\n+\t\t\t  %{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\\\n+\t\t\tcrtbegin.o%s\"\n+\n+/* Attach a special .ident directive to the end of the file to identify\n+   the version of GCC which compiled this code.  The format of the\n+   .ident string is patterned after the ones produced by native svr4\n+   C compilers.  */\n+\n+#define IDENT_ASM_OP \".ident\"\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+do {\t\t\t\t \t\t\t\t\\\n+     fprintf ((FILE), \"\\t%s\\t\\\"GCC: (GNU) %s\\\"\\n\",\t\t\\\n+\t      IDENT_ASM_OP, version_string);\t\t\t\\\n+   } while (0)\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t%s\\t\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n+\n+/* Use periods rather than dollar signs in special g++ assembler names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* Writing `int' for a bitfield forces int alignment for the structure.  */\n+\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Handle #pragma weak and #pragma pack.  */\n+\n+#define HANDLE_SYSV_PRAGMA\n+\n+/* System V Release 4 uses DWARF debugging info.  */\n+\n+#define DWARF_DEBUGGING_INFO\n+\n+/* All ELF targets can support DWARF-2.  */\n+\n+#define DWARF2_DEBUGGING_INFO\n+\n+/* gas on SVR4 supports the use of .stabs.  Permit -gstabs to be used\n+   in general, although it will only work when using gas.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* The GNU tools operate better with stabs.  Since we don't have\n+   any native tools to be compatible with, default to stabs.  */\n+\n+#ifndef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+#endif\n+\n+/* Make LBRAC and RBRAC addresses relative to the start of the\n+   function.  The native Solaris stabs debugging format works this\n+   way, gdb expects it, and it reduces the number of relocation\n+   entries.  */\n+\n+#define DBX_BLOCKS_FUNCTION_RELATIVE 1\n+\n+/* When using stabs, gcc2_compiled must be a stabs entry, not an\n+   ordinary symbol, or gdb won't see it.  Furthermore, since gdb reads\n+   the input piecemeal, starting with each N_SO, it's a lot easier if\n+   the gcc2 flag symbol is *after* the N_SO rather than before it.  So\n+   we emit an N_OPT stab there.  */\n+\n+#define ASM_IDENTIFY_GCC(FILE)\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (write_symbols != DBX_DEBUG)\t\t\t\t\t\\\n+      fputs (\"gcc2_compiled.:\\n\", FILE);\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+#define ASM_IDENTIFY_GCC_AFTER_SOURCE(FILE)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (write_symbols == DBX_DEBUG)\t\t\t\t\t\\\n+      fputs (\"\\t.stabs\\t\\\"gcc2_compiled.\\\", 0x3c, 0, 0, 0\\n\", FILE);\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Like block addresses, stabs line numbers are relative to the\n+   current function.  */\n+\n+#undef  ASM_OUTPUT_SOURCE_LINE\n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static int sym_lineno = 1;\t\t\t\t\t\t\\\n+    fprintf (file, \"\\t.stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n+\t     line, sym_lineno);\t\t\t\t\t\t\\\n+    assemble_name (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n+    fprintf (file, \"\\n.LM%d:\\n\", sym_lineno);\t\t\t\t\\\n+    sym_lineno += 1;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* In order for relative line numbers to work, we must output the\n+   stabs entry for the function name first.  */\n+\n+#define DBX_FUNCTION_FIRST\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\".byte\"\n+\n+#undef SET_ASM_OP\n+#define SET_ASM_OP\t\".set\"\n+\n+/* This is how to begin an assembly language file.  Most svr4 assemblers want\n+   at least a .file directive to come first, and some want to see a .version\n+   directive come right after that.  Here we just establish a default\n+   which generates only the .file directive.  If you need a .version\n+   directive for any specific target, you should override this definition\n+   in the target-specific file which includes this one.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)                                    \\\n+  output_file_directive ((FILE), main_input_filename)\n+\n+/* This is how to allocate empty space in some section.  The .zero\n+   pseudo-op is used for this on most svr4 assemblers.  */\n+\n+#define SKIP_ASM_OP\t\".zero\"\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE) \\\n+  fprintf (FILE, \"\\t%s\\t%u\\n\", SKIP_ASM_OP, (SIZE))\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   For System V Release 4 the convention is *not* to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler.  */\n+\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler.  */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label which precedes a jumptable.  Note that for all svr4\n+   systems where we actually generate jumptables (which is to say every\n+   svr4 target except i386, where we use casesi instead) we put the jump-\n+   tables into the .rodata section and since other stuff could have been\n+   put into the .rodata section prior to any given jumptable, we have to\n+   make sure that the location counter for the .rodata section gets pro-\n+   perly re-aligned prior to the actual beginning of the jump table.  */\n+\n+#define ALIGN_ASM_OP \".align\"\n+\n+#ifndef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n+  ASM_OUTPUT_ALIGN ((FILE), 2);\n+#endif\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,JUMPTABLE)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_BEFORE_CASE_LABEL (FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n+    ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+  } while (0)\n+\n+/* The standard SVR4 assembler seems to require that certain builtin\n+   library routines (e.g. .udiv) be explicitly declared as .globl\n+   in each assembly file where they are referenced.  */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized external linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define COMMON_ASM_OP\t\".comm\"\n+\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", COMMON_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+} while (0)\n+\n+/* This says how to output assembler code to declare an\n+   uninitialized internal linkage data object.  Under SVR4,\n+   the linker seems to want the alignment of data objects\n+   to depend on their types.  We do exactly that here.  */\n+\n+#define LOCAL_ASM_OP\t\".local\"\n+\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n+} while (0)\n+\n+/* This is the pseudo-op used to generate a 32-bit word of data with a\n+   specific value in some section.  This is the same for all known svr4\n+   assemblers.  */\n+\n+#define INT_ASM_OP\t\t\".long\"\n+\n+/* This is the pseudo-op used to generate a contiguous sequence of byte\n+   values from a double-quoted string WITHOUT HAVING A TERMINATING NUL\n+   AUTOMATICALLY APPENDED.  This is the same for most svr4 assemblers.  */\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\".ascii\"\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n+\n+#define USE_CONST_SECTION\t1\n+\n+#define CONST_SECTION_ASM_OP\t\".section\\t.rodata\"\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+\n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\"\"\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n+\n+/* On svr4, we *do* have support for the .init and .fini sections, and we\n+   can put stuff in there to be executed before and after `main'.  We let\n+   crtstuff.c and other files know this by defining the following symbols.\n+   The definitions say how to change sections to the .init and .fini\n+   sections.  This is the same for all known svr4 assemblers.  */\n+\n+#define INIT_SECTION_ASM_OP\t\".section\\t.init\"\n+#define FINI_SECTION_ASM_OP\t\".section\\t.fini\"\n+\n+/* A default list of other sections which we might be \"in\" at any given\n+   time.  For targets that use additional sections (e.g. .tdesc) you\n+   should override this definition in the target-specific file which\n+   includes this file.  */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_ctors, in_dtors\n+\n+/* A default list of extra section function definitions.  For targets\n+   that use additional sections (e.g. .tdesc) you should override this\n+   definition in the target-specific file which includes this file.  */\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+extern void text_section ();\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch into a generic section.\n+   This is currently only used to support section attributes.  */\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  static struct section_info\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      struct section_info *next;\t\t\t\t        \\\n+      char *name;\t\t\t\t\t\t        \\\n+      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+    } *sections;\t\t\t\t\t\t\t\\\n+  struct section_info *s;\t\t\t\t\t\t\\\n+  char *mode;\t\t\t\t\t\t\t\t\\\n+  enum sect_enum type;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (s = sections; s; s = s->next)\t\t\t\t\t\\\n+    if (!strcmp (NAME, s->name))\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    type = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n+    type = SECT_RO, mode = \"a\";\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    type = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (s == 0)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n+      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));\t\t\\\n+      strcpy (s->name, NAME);\t\t\t\t\t\t\\\n+      s->type = type;\t\t\t\t\t\t\t\\\n+      s->next = sections;\t\t\t\t\t\t\\\n+      sections = s;\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \".section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, mode);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (DECL && s->type != type)\t\t\t\t\t\\\n+\terror_with_decl (DECL, \"%s causes a section type conflict\");\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \".section\\t%s\\n\", NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n+#define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))\n+#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  int len;\t\t\t\t\t\t\t\\\n+  char *name, *string, *prefix;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL));\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (! DECL_ONE_ONLY (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\tprefix = \".text.\";\t\t\t\t\t\\\n+      else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\tprefix = \".rodata.\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tprefix = \".data.\";\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+    prefix = \".gnu.linkonce.t.\";\t\t\t\t\\\n+  else if (DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n+    prefix = \".gnu.linkonce.r.\";\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    prefix = \".gnu.linkonce.d.\";\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  len = strlen (name) + strlen (prefix);\t\t\t\\\n+  string = alloca (len + 1);\t\t\t\t\t\\\n+  sprintf (string, \"%s%s\", prefix, name);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  DECL_SECTION_NAME (DECL) = build_string (len, string);\t\\\n+} while (0)\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((flag_pic && RELOC)\t\t\t\t\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX) const_section()\n+\n+/* Define the strings used for the special svr4 .type and .size directives.\n+   These strings generally do not vary from one system running svr4 to\n+   another, but if a given system (e.g. m88k running svr) needs to use\n+   different pseudo-op names for these, they may be overridden in the\n+   file which includes this one.  */\n+\n+#define TYPE_ASM_OP\t\".type\"\n+#define SIZE_ASM_OP\t\".size\"\n+\n+/* This is how we tell the assembler that a symbol is weak.  */\n+\n+#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n+  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n+       fputc ('\\n', FILE); } while (0)\n+\n+/* The following macro defines the format used to output the second\n+   operand of the .type assembler directive.  Different svr4 assemblers\n+   expect various different forms for this operand.  The one given here\n+   is just a default.  You may need to override it in your machine-\n+   specific tm.h file (depending upon the particulars of your assembler).  */\n+\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* Write the extra assembler code needed to declare a function's result.\n+   Most svr4 assemblers don't require any special declaration of the\n+   result value, but there are exceptions.  */\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* These macros generate the special .type and .size directives which\n+   are used to set the corresponding fields of the linker symbol table\n+   entries in an ELF object file under SVR4.  These macros also output\n+   the starting labels for the relevant functions/objects.  */\n+\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    size_directive_output = 0;\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tsize_directive_output = 1;\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n+         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n+\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n+\t && !size_directive_output)\t\t\t\t\t \\\n+       {\t\t\t\t\t\t\t\t \\\n+\t size_directive_output = 1;\t\t\t\t\t \\\n+\t fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t \\\n+\t assemble_name (FILE, name);\t\t\t\t\t \\\n+\t fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL))); \\\n+       }\t\t\t\t\t\t\t\t \\\n+   } while (0)\n+\n+/* This is how to declare the size of a function.  */\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        char label[256];\t\t\t\t\t\t\\\n+\tstatic int labelno;\t\t\t\t\t\t\\\n+\tlabelno++;\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+        fprintf (FILE, \",\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, label);\t\t\t\t\t\\\n+        fprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, (FNAME));\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n+   corresponds to a particular byte value [0..255].  For any\n+   given byte value, if the value in the corresponding table\n+   position is zero, the given character can be output directly.\n+   If the table value is 1, the byte must be output as a \\ooo\n+   octal escape.  If the tables value is anything else, then the\n+   byte value should be output as a \\ followed by the value\n+   in the table.  Note that we can use standard UN*X escape\n+   sequences for many control characters, but we don't use\n+   \\a to represent BEL because some svr4 assemblers (e.g. on\n+   the i386) don't know about that.  Also, we don't use \\v\n+   since some versions of gas, such as 2.2 did not accept it.  */\n+\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+/* Some svr4 assemblers have a limit on the number of characters which\n+   can appear in the operand of a .string directive.  If your assembler\n+   has such a limitation, you should define STRING_LIMIT to reflect that\n+   limit.  Note that at least some svr4 assemblers have a limit on the\n+   actual number of bytes in the double-quoted string, and that they\n+   count each character in an escape sequence as one byte.  Thus, an\n+   escape sequence like \\377 would count as four bytes.\n+\n+   If your target assembler doesn't support the .string directive, you\n+   should define this to zero.\n+*/\n+\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#define STRING_ASM_OP\t\".string\"\n+\n+/* The routine used to output NUL terminated strings.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable, especially for targets like the i386\n+   (where the only alternative is to output character sequences as\n+   comma separated lists of numbers).   */\n+\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_limited_str = (unsigned char *) (STR);\t\\\n+      register unsigned ch;\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s\\t\\\"\", STRING_ASM_OP);\t\t\t\\\n+      for (; ch = *_limited_str; _limited_str++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      register int escape;\t\t\t\t\t\\\n+\t      register unsigned ch;\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\t\\\n+\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\tcase 0:\t\t\t\t\t\t\t\\\n+\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tcase 1:\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n+\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tdefault:\t\t\t\t\t\t\\\n+\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t\t  putc (escape, (FILE));\t\t\t\t\\\n+\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* All SVR4 targets use the ELF object file format.  */\n+#define OBJECT_FORMAT_ELF"}, {"sha": "ac9ae43120cac25658ac318ad52b4577113b5765", "filename": "gcc/config/m68k/m68020-elf.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Fm68020-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Fm68020-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68020-elf.h?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -0,0 +1,42 @@\n+/* Definitions of target machine for GNU compiler.  \"naked\" 68020,\n+   elf object files and debugging, version.\n+   Copyright (C) 1987, 1988, 1992, 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This comment is here to see if it will keep Sun's cpp from dying.  */\n+\n+#include \"m68k/m68k-none.h\"\n+#include \"m68k/m68kelf.h\"\n+#include \"elfos.h\"\n+/* m68k/m68kemb.h sets some macros in ways that override the svr4 abi.  */\n+#include \"m68k/m68kemb.h\" \n+\n+/* We need to override the default specs from elfos.h.  This suppresses the\n+   loading of crt0.o by gcc's default linker spec.  For embedded targets crt0\n+   now comes from the linker script.  */\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"crtbegin.o%s\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s\"\n+\n+#define LIB_SPEC \"-lc\"\n+\n+/* end of m68020-elf.h */"}, {"sha": "25f2c383c0ad25d2371e06d4241406802079bc80", "filename": "gcc/config/m68k/m68kelf.h", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -0,0 +1,266 @@\n+/* m68kelf support, derived from m68kv4.h */\n+\n+/* Target definitions for GNU compiler for mc680x0 running System V.4\n+   Copyright (C) 1991, 1993 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@netcom.com) and Fred Fish (fnf@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #notinclude \"m68k/sgs.h\"\t/* The m68k/SVR4 assembler is SGS based */\n+\n+/* These are necessary for -fpic/-fPIC to work correctly.  */\n+#ifndef MOTOROLA\n+#define MOTOROLA                /* Use MOTOROLA syntax.  */\n+#endif\n+#ifdef  USE_GAS  /* when present, forces jsbr instead of jsr.  */\n+#undef  USE_GAS\n+#endif\n+\n+#ifndef SWBEG_ASM_OP\n+#define SWBEG_ASM_OP \".swbeg\"\n+#endif\n+\n+/* Here are four prefixes that are used by asm_fprintf to\n+   facilitate customization for alternate assembler syntaxes.\n+   Machines with no likelihood of an alternate syntax need not\n+   define these and need not use asm_fprintf.  */\n+\n+/* The prefix for register names.  Note that REGISTER_NAMES\n+   is supposed to include this prefix. Also note that this is NOT an\n+   fprintf format string, it is a literal string */\n+\n+#undef REGISTER_PREFIX\n+#define REGISTER_PREFIX \"%\"\n+\n+/* The prefix for local (compiler generated) labels.\n+   These labels will not appear in the symbol table. */\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+/* The prefix to add to user-visible assembler symbols. */\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+/* The prefix for immediate operands.  */\n+\n+#undef  IMMEDIATE_PREFIX\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+/* In the machine description we can't use %R, because it will not be seen\n+   by ASM_FPRINTF.  (Isn't that a design bug?).  */\n+\n+#undef REGISTER_PREFIX_MD\n+#define REGISTER_PREFIX_MD \"%%\"\n+\n+/* config/m68k.md has an explicit reference to the program counter,\n+   prefix this by the register prefix.  */\n+\n+#define ASM_RETURN_CASE_JUMP    return \"jmp %%pc@(2,%0:w)\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number.\n+   Motorola format uses different register names than defined \n+   in m68k.h.  */\n+\n+#undef REGISTER_NAMES\n+\n+#define REGISTER_NAMES \\\n+{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n+ \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%a6\",   \"%sp\",\t     \\\n+ \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\" }\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\t\\\n+  if ((LOG) > 0)\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s \\t%u\\n\", ALIGN_ASM_OP, 1 << (LOG));\t\\\n+  else if ((LOG) > 31)\t\t\t\t\t\t\\\n+    abort ();\n+\n+/* Use proper assembler syntax for these macros.  */\n+#undef ASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  asm_fprintf (FILE, \"\\t%Omove.l %s,-(%Rsp)\\n\", reg_names[REGNO])\n+\n+#undef ASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  asm_fprintf (FILE, \"\\t%Omove.l (%Rsp)+,%s\\n\", reg_names[REGNO])\n+\n+/*  Override the definition of NO_DOLLAR_IN_LABEL in svr4.h, for special\n+    g++ assembler names.  When this is defined, g++ uses embedded '.'\n+    characters and some m68k assemblers have problems with this.  The\n+    chances are much greater that any particular assembler will permit\n+    embedded '$' characters. */\n+\n+#undef NO_DOLLAR_IN_LABEL\n+\n+/* Define PCC_STATIC_STRUCT_RETURN if the convention on the target machine\n+   is to use the nonreentrant technique for returning structure and union\n+   values, as commonly implemented by the AT&T Portable C Compiler (PCC).\n+   When defined, the gcc option -fpcc-struct-return can be used to cause\n+   this form to be generated.  When undefined, the option does nothing.\n+   For m68k SVR4, the convention is to use a reentrant technique compatible\n+   with the gcc default, so override the definition of this macro in m68k.h */\n+\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Local common symbols are declared to the assembler with \".lcomm\" rather\n+   than \".bss\", so override the definition in svr4.h */\n+\n+#undef BSS_ASM_OP\n+#define BSS_ASM_OP\t\".lcomm\"\n+\n+/* Register in which address to store a structure value is passed to a\n+   function.  The default in m68k.h is a1.  For m68k/SVR4 it is a0. */\n+\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE_REGNUM 8\n+\n+#define ASM_COMMENT_START \"|\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"@%s\"\n+\n+/* Define how the m68k registers should be numbered for Dwarf output.\n+   The numbering provided here should be compatible with the native\n+   SVR4 SDB debugger in the m68k/SVR4 reference port, where d0-d7\n+   are 0-7, a0-a8 are 8-15, and fp0-fp7 are 16-23. */\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* The ASM_OUTPUT_SKIP macro is first defined in m68k.h, using \".skip\".\n+   It is then overridden by m68k/sgs.h to use \".space\", and again by svr4.h\n+   to use \".zero\".  The m68k/SVR4 assembler uses \".space\", so repeat the\n+   definition from m68k/sgs.h here.  Note that ASM_NO_SKIP_IN_TEXT is\n+   defined in m68k/sgs.h, so we don't have to repeat it here. */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t%s %u\\n\", SPACE_ASM_OP, (SIZE))\n+\n+#if 0\n+/* SVR4 m68k assembler is bitching on the `comm i,1,1' which askes for \n+   1 byte alignment. Don't generate alignment for COMMON seems to be\n+   safer until we the assembler is fixed. */\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+/* Same problem with this one.  */\n+#undef ASM_OUTPUT_ALIGNED_LOCAL\n+#endif\n+\n+/* The `string' directive on m68k svr4 does not handle string with\n+   escape char (ie., `\\') right. Use normal way to output ASCII bytes\n+   seems to be safer. */\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  register int sp = 0, lp = 0, ch;\t\t\t\t\\\n+  fprintf ((FILE), \"\\t%s \", BYTE_ASM_OP);\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    ch = (PTR)[sp];\t\t\t\t\t\t\\\n+    if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"'%c\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf ((FILE), \"0x%x\", ch);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (++sp < (LEN))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tif ((sp % 10) == 0)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf ((FILE), \"\\n\\t%s \", BYTE_ASM_OP);\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    putc (',', (FILE));\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (sp < (LEN));\t\t\t\t\t\t\\\n+  putc ('\\n', (FILE));\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* SVR4 m68k assembler is bitching on the syntax `2.b'.\n+   So use the \"LLDnnn-LLnnn\" format.  Define LLDnnn after the table.  */\n+\n+#undef ASM_OUTPUT_CASE_END\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (switch_table_difference_label_flag)\t\t\t\t\\\n+    asm_fprintf ((FILE), \"\\t%s %LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\\\n+  switch_table_difference_label_flag = 0;\t\t\t\t\\\n+} while (0)\n+\n+extern int switch_table_difference_label_flag;\n+\n+#undef ASM_OUTPUT_COMMON\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+\n+/* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n+   keep switch tables in the text section. */\n+   \n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* Override the definition in svr4.h. In m68k svr4, using swbeg is the \n+   standard way to do switch table. */\n+#undef ASM_OUTPUT_BEFORE_CASE_LABEL\n+#define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\\\n+  fprintf ((FILE), \"\\t%s &%d\\n\", SWBEG_ASM_OP, XVECLEN (PATTERN (TABLE), 1));\n+\n+/* In m68k svr4, a symbol_ref rtx can be a valid PIC operand if it is an\n+   operand of a function call. */\n+#undef LEGITIMATE_PIC_OPERAND_P\n+#define LEGITIMATE_PIC_OPERAND_P(X) \\\n+  (! symbolic_operand (X, VOIDmode) \\\n+   || ((GET_CODE(X) == SYMBOL_REF) && SYMBOL_REF_FLAG(X)))\n+\n+/* Turn off function cse if we are doing PIC. We always want function call\n+   to be done as `bsr foo@PLTPC', so it will force the assembler to create \n+   the PLT entry for `foo'. Doing function cse will cause the address of `foo'\n+   to be loaded into a register, which is exactly what we want to avoid when\n+   we are doing PIC on svr4 m68k. */\n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (flag_pic) flag_no_function_cse = 1; \\\n+  if (! TARGET_68020 && flag_pic == 2)\t\\\n+    error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\t\\\n+}\n+/* end of stuff from m68kv4.h */\n+\n+#undef SGS_CMP_ORDER\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s\"\n+\n+#undef\tSTARTFILE_SPEC\n+#define STARTFILE_SPEC \"crtbegin.o%s\""}, {"sha": "7bdac3c6dc39b4ca37e05bb10c65bb289c095180", "filename": "gcc/config/m68k/t-m68kelf", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-m68kelf?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -0,0 +1,29 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = m68k/lb1sf68.asm\n+LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \\\n+   _double _float _floatex \\\n+   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \\\n+   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+LIB2FUNCS_EXTRA = fpgnulib.c xfgnulib.c\n+\n+fpgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n+\tcp $(srcdir)/config/m68k/fpgnulib.c fpgnulib.c\n+xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n+\techo '#define EXTFLOAT' > xfgnulib.c\n+\tcat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c\n+\n+MULTILIB_OPTIONS = m68000/m68020/m5200 m68881/msoft-float\n+MULTILIB_DIRNAMES =\n+MULTILIB_MATCHES = m68000=mc68000 m68000=m68302 m68000=m68332 m68020=mc68020 m68020=m68040\n+MULTILIB_EXCEPTIONS = *m5200/*m68881 *m5200/*msoft-float\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# from ../t-svr4\n+EXTRA_PARTS=crtbegin.o crtend.o\n+# no pic for now\n+#CRTSTUFF_T_CFLAGS=-fpic"}, {"sha": "f53baab4d4078f7365ce957386ceab4e03d656ac", "filename": "gcc/configure", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -4189,6 +4189,12 @@ for machine in $build $host $target; do\n \t\textra_headers=math-68881.h\n \t\tfloat_format=m68k\n \t\t;;\n+\tm68020-*-elf* | m68k-*-elf*)\n+\t\ttm_file=\"m68k/m68020-elf.h libgloss.h\"\n+\t\txm_file=m68k/xm-m68kv.h\n+\t\ttmake_file=m68k/t-m68kelf\n+\t\theader_files=math-68881.h\n+\t\t;;\n \tm68k-*-lynxos*)\n \t\tif test x$gas = xyes\n \t\tthen\n@@ -5951,7 +5957,7 @@ fi\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:5955: checking assembler alignment features\" >&5\n+echo \"configure:5961: checking assembler alignment features\" >&5\n gcc_cv_as=\n gcc_cv_as_alignment_features=\n gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas\n@@ -6024,7 +6030,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n \n echo $ac_n \"checking assembler subsection support\"\"... $ac_c\" 1>&6\n-echo \"configure:6028: checking assembler subsection support\" >&5\n+echo \"configure:6034: checking assembler subsection support\" >&5\n gcc_cv_as_subsections=\n if test x$gcc_cv_as != x; then\n \t# Check if we have .subsection\n@@ -6260,7 +6266,7 @@ fi\n \n # Warn if using init_priority.\n echo $ac_n \"checking whether to enable init_priority by default\"\"... $ac_c\" 1>&6\n-echo \"configure:6264: checking whether to enable init_priority by default\" >&5\n+echo \"configure:6270: checking whether to enable init_priority by default\" >&5\n if test x$enable_init_priority != xyes; then\n   enable_init_priority=no\n fi"}, {"sha": "c75bcec11f2515e1bb4978d79bde7dd9203ecec6", "filename": "gcc/configure.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1be3be36793cb20f6f2df953a9e795f6da2953e/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=d1be3be36793cb20f6f2df953a9e795f6da2953e", "patch": "@@ -1936,6 +1936,12 @@ changequote([,])dnl\n \t\textra_headers=math-68881.h\n \t\tfloat_format=m68k\n \t\t;;\n+\tm68020-*-elf* | m68k-*-elf*)\n+\t\ttm_file=\"m68k/m68020-elf.h libgloss.h\"\n+\t\txm_file=m68k/xm-m68kv.h\n+\t\ttmake_file=m68k/t-m68kelf\n+\t\theader_files=math-68881.h\n+\t\t;;\n \tm68k-*-lynxos*)\n \t\tif test x$gas = xyes\n \t\tthen"}]}