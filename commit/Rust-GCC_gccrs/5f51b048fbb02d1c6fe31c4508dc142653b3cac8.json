{"sha": "5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1MWIwNDhmYmIwMmQxYzZmZTMxYzQ1MDhkYzE0MjY1M2IzY2FjOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-15T18:31:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-15T18:31:13Z"}, "message": "InflaterInputStream.java (read): Loop if data has been read but none output by inflater.\n\n\t* java/util/zip/InflaterInputStream.java (read): Loop if data has\n\tbeen read but none output by inflater.\n\t* java/util/zip/natDeflater.cc (reset): Set is_finished.\n\t* java/util/zip/natInflater.cc (reset): Set dist_needed and\n\tis_finished.\n\t* java/util/zip/ZipOutputStream.java: Replaced with Classpath\n\tversion.\n\t* java/util/zip/ZipFile.java: Replaced with Classpath version.\n\t* java/util/zip/ZipEntry.java: Replaced with Classpath version.\n\t* java/util/zip/ZipInputStream.java: Replaced with Classpath\n\tversion.\n\t* java/util/zip/ZipConstants.java: Replaced with Classpath version.\n\nFrom-SVN: r54653", "tree": {"sha": "5bc4d8b0019a7c9f9259e1a51e3833b92c21db21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bc4d8b0019a7c9f9259e1a51e3833b92c21db21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/comments", "author": null, "committer": null, "parents": [{"sha": "21505616a59b467fa047d9b857d6bc7df39e43d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21505616a59b467fa047d9b857d6bc7df39e43d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21505616a59b467fa047d9b857d6bc7df39e43d0"}], "stats": {"total": 2134, "additions": 1347, "deletions": 787}, "files": [{"sha": "32955b512435aa641afb0d079832698be6fb2f71", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,3 +1,18 @@\n+2002-06-15  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/zip/InflaterInputStream.java (read): Loop if data has\n+\tbeen read but none output by inflater.\n+\t* java/util/zip/natDeflater.cc (reset): Set is_finished.\n+\t* java/util/zip/natInflater.cc (reset): Set dist_needed and\n+\tis_finished.\n+\t* java/util/zip/ZipOutputStream.java: Replaced with Classpath\n+\tversion.\n+\t* java/util/zip/ZipFile.java: Replaced with Classpath version.\n+\t* java/util/zip/ZipEntry.java: Replaced with Classpath version.\n+\t* java/util/zip/ZipInputStream.java: Replaced with Classpath\n+\tversion.\n+\t* java/util/zip/ZipConstants.java: Replaced with Classpath version.\n+\n 2002-06-13  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natString.cc (init): Handle case where DONT_COPY is"}, {"sha": "5aac73d7e5ab4acc6d5cc4e17a954d313e06e644", "filename": "libjava/java/util/zip/InflaterInputStream.java", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,5 +1,5 @@\n /* InflaterInputStream.java - Input stream filter for decompressing\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -92,23 +92,30 @@ public int read (byte[] buf, int off, int len) throws IOException\n       throw new IOException (\"stream closed\");\n     if (inf.finished())\n       return -1;\n-    if (inf.needsInput())\n-      fill ();\n-    int count;\n-    try\n+\n+    int count = 0;\n+    while (count == 0)\n       {\n-\tcount = inf.inflate(buf, off, len);\t\n-\tif (count == 0)\n+\tif (inf.needsInput())\n+\t  fill ();\n+\ttry\n \t  {\n-\t    if (this.len == -1)\n-\t      return -1; // Couldn't get any more data to feed to the Inflater\n-\t    if (inf.needsDictionary())\n-\t      throw new ZipException (\"Inflater needs Dictionary\");\n-\t  }\t      \n-      }\n-    catch (DataFormatException dfe)\n-      {\n-\tthrow new ZipException (dfe.getMessage());\n+\t    count = inf.inflate(buf, off, len);\t\n+\t    if (count == 0)\n+\t      {\n+\t\tif (this.len == -1)\n+\t\t  {\n+\t\t    // Couldn't get any more data to feed to the Inflater\n+\t\t    return -1;\n+\t\t  }\n+\t\tif (inf.needsDictionary())\n+\t\t  throw new ZipException (\"Inflater needs Dictionary\");\n+\t      }\n+\t  }\n+\tcatch (DataFormatException dfe)\n+\t  {\n+\t    throw new ZipException (dfe.getMessage());\n+\t  }\n       }\n     return count;\n   }"}, {"sha": "3d6b7447c922ebc9729ef541b7f1e6edac9e26b8", "filename": "libjava/java/util/zip/ZipConstants.java", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipConstants.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,13 +1,13 @@\n-/* ZipConstants.java - Some constants used in the zip package\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.zip.ZipConstants\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,19 +37,61 @@\n \n package java.util.zip;\n \n-/**\n- * Some constants used in the zip package.\n- * <p>\n- * Since this package local interface is completely undocumented no effort\n- * is made to make it compatible with other implementations.\n- * If someone is really interested you can probably come up with the right\n- * constants and documentation by studying the Info-ZIP zipfile.c constants.\n- */\n interface ZipConstants\n {\n-  // Size in bytes of local file header, including signature.\n-  public static final int LOCAL_FILE_HEADER_SIZE = 30;\n+    /* The local file header */\n+    public final static int LOCHDR = 30;\n+    public final static int LOCSIG = 'P'|('K'<<8)|(3<<16)|(4<<24);\n+\n+    public final static int LOCVER =  4;\n+    public final static int LOCFLG =  6;\n+    public final static int LOCHOW =  8;\n+    public final static int LOCTIM = 10;\n+    public final static int LOCCRC = 14;\n+    public final static int LOCSIZ = 18;\n+    public final static int LOCLEN = 22;\n+    public final static int LOCNAM = 26;\n+    public final static int LOCEXT = 28;\n+\n+    /* The Data descriptor */\n+    public final static int EXTSIG = 'P'|('K'<<8)|(7<<16)|(8<<24);\n+    public final static int EXTHDR = 16;\n+\n+    public final static int EXTCRC =  4;\n+    public final static int EXTSIZ =  8;\n+    public final static int EXTLEN = 12;\n \n-  // Size in bytes of the \"end of central directory\" record, with signature.\n-  public static final int END_CENTRAL_DIR_SIZE = 22;\n+    /* The central directory file header */\n+    public final static int CENSIG = 'P'|('K'<<8)|(1<<16)|(2<<24);\n+    public final static int CENHDR = 46;\n+\n+    public final static int CENVEM =  4;\n+    public final static int CENVER =  6;\n+    public final static int CENFLG =  8;\n+    public final static int CENHOW = 10;\n+    public final static int CENTIM = 12;\n+    public final static int CENCRC = 16;\n+    public final static int CENSIZ = 20;\n+    public final static int CENLEN = 24;\n+    public final static int CENNAM = 28;\n+    public final static int CENEXT = 30;\n+    public final static int CENCOM = 32;\n+    public final static int CENDSK = 34;\n+    public final static int CENATT = 36;\n+    public final static int CENATX = 38;\n+    public final static int CENOFF = 42;\n+\n+    /* The entries in the end of central directory */\n+    public final static int ENDSIG = 'P'|('K'<<8)|(5<<16)|(6<<24);\n+    public final static int ENDHDR = 22;\n+\n+    /* The following two fields are missing in SUN JDK */\n+    final static int ENDNRD =  4;\n+    final static int ENDDCD =  6;\n+    public final static int ENDSUB =  8;\n+    public final static int ENDTOT = 10;\n+    public final static int ENDSIZ = 12;\n+    public final static int ENDOFF = 16;\n+    public final static int ENDCOM = 20;\n }\n+"}, {"sha": "5a43b1f5a2e599b3fb1aceb51984b9aeac367113", "filename": "libjava/java/util/zip/ZipEntry.java", "status": "modified", "additions": 304, "deletions": 144, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,13 +1,13 @@\n-/* ZipEntry.java - Represents entries in a zip file archive\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.zip.ZipEntry\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,201 +36,361 @@\n exception statement from your version. */\n \n package java.util.zip;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+import java.util.Date;\n \n /**\n- * @author Per Bothner\n- * @date January 6, 1999.\n- */\n-\n-/*\n- * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Believed complete and correct.\n- */\n-\n-/**\n- * Represents entries in a zip file archive.\n- * An Entry cn be created by giving a name or by giving an already existing\n- * ZipEntries whose values should be copied. The name normally represents a\n- * file path name or directory name.\n+ * This class represents a member of a zip archive.  ZipFile and\n+ * ZipInputStream will give you instances of this class as information\n+ * about the members in an archive.  On the other hand ZipOutputStream\n+ * needs an instance of this class to create a new member.\n+ *\n+ * @author Jochen Hoenicke \n  */\n public class ZipEntry implements ZipConstants, Cloneable\n {\n-  // These values were determined using a simple test program.\n-  public static final int STORED = 0;\n-  public static final int DEFLATED = 8;\n-\n-  String comment;\n-  long compressedSize = -1;\n-  long crc = -1;\n-  byte[] extra;\n-  int method = -1;\n-  String name;\n-  long size = -1;\n-  long time = -1;\n-  long relativeOffset = -1;\n-\n-  ZipEntry next;\n-\n-  public ZipEntry (String name)\n-  {\n-    if (name.length() > 65535)\n-      throw new IllegalArgumentException ();\n-    this.name = name;\n-  }\n+  private static int KNOWN_SIZE   = 1;\n+  private static int KNOWN_CSIZE  = 2;\n+  private static int KNOWN_CRC    = 4;\n+  private static int KNOWN_TIME   = 8;\n+\n+  private static Calendar cal = Calendar.getInstance();\n+\n+  private String name;\n+  private int size;\n+  private int compressedSize;\n+  private int crc;\n+  private int time;\n+  private short known = 0;\n+  private short method = -1;\n+  private byte[] extra = null;\n+  private String comment = null;\n+\n+  int zipFileIndex = -1;  /* used by ZipFile */\n+  int flags;              /* used by ZipOutputStream */\n+  int offset;             /* used by ZipFile and ZipOutputStream */\n+\n+\n+  /**\n+   * Compression method.  This method doesn't compress at all.\n+   */\n+  public final static int STORED      =  0;\n+  /**\n+   * Compression method.  This method uses the Deflater.\n+   */\n+  public final static int DEFLATED    =  8;\n \n   /**\n-   * Creates a new ZipEntry using the fields of a given ZipEntry.\n-   * The comment, compressedSize, crc, extra, method, name, size, time and\n-   * relativeOffset fields are copied from the given entry.\n-   * Note that the contents of the extra byte array field is not cloned,\n-   * only the reference is copied.\n-   * The clone() method does clone the contents of the extra byte array if\n-   * needed.\n-   * @since 1.2\n+   * Creates a zip entry with the given name.\n+   * @param name the name. May include directory components separated\n+   * by '/'.\n    */\n-  public ZipEntry (ZipEntry ent)\n+  public ZipEntry(String name)\n   {\n-    comment = ent.comment;\n-    compressedSize = ent.compressedSize;\n-    crc = ent.crc;\n-    extra = ent.extra;\n-    method = ent.method;\n-    name = ent.name;\n-    size = ent.size;\n-    time = ent.time;\n-    relativeOffset = ent.relativeOffset;\n+    if (name == null)\n+      throw new NullPointerException();\n+    this.name = name;\n   }\n- \n+\n   /**\n-   * Creates a clone of this ZipEntry. Calls <code>new ZipEntry (this)</code>\n-   * and creates a clone of the contents of the extra byte array field.\n-   *\n-   * @since 1.2\n+   * Creates a copy of the given zip entry.\n+   * @param e the entry to copy.\n    */\n-  public Object clone ()\n+  public ZipEntry(ZipEntry e)\n   {\n-    // JCL defines this as being the same as the copy constructor above,\n-    // except that value of the \"extra\" field is also copied.\n-    ZipEntry clone = new ZipEntry (this);\n-    clone.extra = (byte[]) extra.clone ();\n-    return clone;\n+    name = e.name;\n+    known = e.known;\n+    size = e.size;\n+    compressedSize = e.compressedSize;\n+    crc = e.crc;\n+    time = e.time;\n+    method = e.method;\n+    extra = e.extra;\n+    comment = e.comment;\n   }\n \n-  public String getComment () { return comment; }\n-\n-  public long getCompressedSize () { return compressedSize; }\n+  void setDOSTime(int dostime)\n+  {\n+    int sec = 2 * (dostime & 0x1f);\n+    int min = (dostime >> 5) & 0x3f;\n+    int hrs = (dostime >> 11) & 0x1f;\n+    int day = (dostime >> 16) & 0x1f;\n+    int mon = ((dostime >> 21) & 0xf) - 1;\n+    int year = ((dostime >> 25) & 0x7f) + 1980; /* since 1900 */\n+    \n+    // Guard against invalid or missing date causing\n+    // IndexOutOfBoundsException.\n+    try\n+      {\n+\tsynchronized (cal)\n+\t  {\n+\t    cal.set(year, mon, day, hrs, min, sec);\n+\t    time = (int) (cal.getTime().getTime() / 1000L);\n+\t  }\n+\tknown |= KNOWN_TIME;\n+      }\n+    catch (RuntimeException ex)\n+      {\n+\t/* Ignore illegal time stamp */\n+\tknown &= ~KNOWN_TIME;\n+      }\n+  }\n \n-  public long getCrc () { return crc; }\n+  int getDOSTime()\n+  {\n+    if ((known & KNOWN_TIME) == 0)\n+      return 0;\n+    synchronized (cal)\n+      {\n+\tcal.setTime(new Date(time*1000L));\n+\treturn (cal.get(cal.YEAR) - 1980 & 0x7f) << 25\n+\t  | (cal.get(cal.MONTH) + 1) << 21\n+\t  | (cal.get(cal.DAY_OF_MONTH)) << 16\n+\t  | (cal.get(cal.HOUR_OF_DAY)) << 11\n+\t  | (cal.get(cal.MINUTE)) << 5\n+\t  | (cal.get(cal.SECOND)) >> 1;\n+      }\n+  }\n \n-  public byte[] getExtra() { return extra; }\n+  /**\n+   * Creates a copy of this zip entry.\n+   */\n+  /**\n+   * Clones the entry.\n+   */\n+  public Object clone()\n+  {\n+    try\n+      {\n+\t// The JCL says that the `extra' field is also copied.\n+\tZipEntry clone = (ZipEntry) super.clone();\n+\tif (extra != null)\n+\t  clone.extra = (byte[]) extra.clone();\n+\treturn clone;\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\tthrow new InternalError();\n+      }\n+  }\n \n-  public int getMethod () { return method; }\n+  /**\n+   * Returns the entry name.  The path components in the entry are\n+   * always separated by slashes ('/').  \n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n \n-  public String getName () { return name; }\n+  /**\n+   * Sets the time of last modification of the entry.\n+   * @time the time of last modification of the entry.\n+   */\n+  public void setTime(long time)\n+  {\n+    this.time = (int) (time / 1000L);\n+    this.known |= KNOWN_TIME;\n+  }\n \n-  public long getSize () { return size; }\n+  /**\n+   * Gets the time of last modification of the entry.\n+   * @return the time of last modification of the entry, or -1 if unknown.\n+   */\n+  public long getTime()\n+  {\n+    return (known & KNOWN_TIME) != 0 ? time * 1000L : -1;\n+  }\n \n-  public long getTime () { return time; }\n+  /**\n+   * Sets the size of the uncompressed data.\n+   * @exception IllegalArgumentException if size is not in 0..0xffffffffL\n+   */\n+  public void setSize(long size)\n+  {\n+    if ((size & 0xffffffff00000000L) != 0)\n+\tthrow new IllegalArgumentException();\n+    this.size = (int) size;\n+    this.known |= KNOWN_SIZE;\n+  }\n \n-  public boolean isDirectory ()\n+  /**\n+   * Gets the size of the uncompressed data.\n+   * @return the size or -1 if unknown.\n+   */\n+  public long getSize()\n   {\n-    if (name != null)\n-      {\n-\tint nlen = name.length();\n-\tif (nlen > 0 && name.charAt(nlen-1) == '/')\n-\t  return true;\n-      }\n-    return false;\n+    return (known & KNOWN_SIZE) != 0 ? size & 0xffffffffL : -1L;\n   }\n \n-  public void setComment (String comment)\n+  /**\n+   * Sets the size of the compressed data.\n+   * @exception IllegalArgumentException if size is not in 0..0xffffffffL\n+   */\n+  public void setCompressedSize(long csize)\n   {\n-    if (comment != null && comment.length() > 65535)\n-      throw new IllegalArgumentException ();\n-    this.comment = comment;\n+    if ((csize & 0xffffffff00000000L) != 0)\n+\tthrow new IllegalArgumentException();\n+    this.compressedSize = (int) csize;\n+    this.known |= KNOWN_CSIZE;\n   }\n- \n+\n   /**\n-   * Sets the compressedSize of this ZipEntry.\n-   * The new size must be between 0 and 0xffffffffL.\n-   * @since 1.2\n+   * Gets the size of the compressed data.\n+   * @return the size or -1 if unknown.\n    */\n-  public void setCompressedSize (long compressedSize)\n+  public long getCompressedSize()\n   {\n-    if (compressedSize < 0 || compressedSize > 0xffffffffL)\n-      throw new IllegalArgumentException ();\n-    this.compressedSize = compressedSize;\n+    return (known & KNOWN_CSIZE) != 0 ? compressedSize & 0xffffffffL : -1L;\n   }\n \n-  public void setCrc (long crc) \n+  /**\n+   * Sets the crc of the uncompressed data.\n+   * @exception IllegalArgumentException if crc is not in 0..0xffffffffL\n+   */\n+  public void setCrc(long crc)\n   {\n-    if (crc < 0 || crc > 0xffffffffL)\n-      throw new IllegalArgumentException ();\n-    this.crc = crc;\n+    if ((crc & 0xffffffff00000000L) != 0)\n+\tthrow new IllegalArgumentException();\n+    this.crc = (int) crc;\n+    this.known |= KNOWN_CRC;\n   }\n \n-  public void setExtra (byte[] extra)\n+  /**\n+   * Gets the crc of the uncompressed data.\n+   * @return the crc or -1 if unknown.\n+   */\n+  public long getCrc()\n   {\n-    if (extra != null && extra.length > 65535)\n-      throw new IllegalArgumentException ();\n-    this.extra = extra;\n+    return (known & KNOWN_CRC) != 0 ? crc & 0xffffffffL : -1L;\n   }\n \n-  public void setMethod (int method)\n+  /**\n+   * Sets the compression method.  Only DEFLATED and STORED are\n+   * supported.\n+   * @exception IllegalArgumentException if method is not supported.\n+   * @see ZipOutputStream#DEFLATED\n+   * @see ZipOutputStream#STORED \n+   */\n+  public void setMethod(int method)\n   {\n-    if (method != DEFLATED && method != STORED)\n-      throw new IllegalArgumentException ();\n-    this.method = method;\n+    if (method != ZipOutputStream.STORED\n+\t&& method != ZipOutputStream.DEFLATED)\n+\tthrow new IllegalArgumentException();\n+    this.method = (short) method;\n   }\n \n-  public void setSize (long size)\n+  /**\n+   * Gets the compression method.  \n+   * @return the compression method or -1 if unknown.\n+   */\n+  public int getMethod()\n   {\n-    if (size < 0 || size > 0xffffffffL)\n-      throw new IllegalArgumentException ();\n-    this.size = size;\n+    return method;\n   }\n \n-  public void setTime (long time)\n+  /**\n+   * Sets the extra data.\n+   * @exception IllegalArgumentException if extra is longer than 0xffff bytes.\n+   */\n+  public void setExtra(byte[] extra)\n   {\n-    this.time = time;\n+    if (extra == null) \n+      {\n+\tthis.extra = null;\n+\treturn;\n+      }\n+\n+    if (extra.length > 0xffff)\n+      throw new IllegalArgumentException();\n+    this.extra = extra;\n+    try\n+      {\n+\tint pos = 0;\n+\twhile (pos < extra.length) \n+\t  {\n+\t    int sig = (extra[pos++] & 0xff)\n+\t      | (extra[pos++] & 0xff) << 8;\n+\t    int len = (extra[pos++] & 0xff)\n+\t      | (extra[pos++] & 0xff) << 8;\n+\t    if (sig == 0x5455) \n+\t      {\n+\t\t/* extended time stamp */\n+\t\tint flags = extra[pos];\n+\t\tif ((flags & 1) != 0)\n+\t\t  {\n+\t\t    time = ((extra[pos+1] & 0xff)\n+\t\t\t    | (extra[pos+2] & 0xff) << 8\n+\t\t\t    | (extra[pos+3] & 0xff) << 16\n+\t\t\t    | (extra[pos+4] & 0xff) << 24);\n+\t\t    known |= KNOWN_TIME;\n+\t\t  }\n+\t      }\n+\t    pos += len;\n+\t  }\n+      }\n+    catch (ArrayIndexOutOfBoundsException ex)\n+      {\n+\t/* be lenient */\n+\treturn;\n+      }\n   }\n \n-  private final static short[] daysToMonthStart = {\n-    //Jan Feb Mar    Apr      May         Jun         Jul\n-    0,    31, 31+28, 2*31+28, 2*31+28+30, 3*31+28+30, 3*31+28+2*30,\n-    // Aug        Sep           Oct           Nov           Dec\n-    4*31+28+2*30, 5*31+28+2*30, 5*31+28+3*30, 6*31+28+3*30, 6*31+28+4*30};\n+  /**\n+   * Gets the extra data.\n+   * @return the extra data or null if not set.\n+   */\n+  public byte[] getExtra()\n+  {\n+    return extra;\n+  }\n \n-  /** Convert a DOS-style type value to milliseconds since 1970. */\n-  static long timeFromDOS (int date, int time)\n+  /**\n+   * Sets the entry comment.\n+   * @exception IllegalArgumentException if comment is longer than 0xffff.\n+   */\n+  public void setComment(String comment)\n   {\n-    int sec = 2 * (time & 0x1f);\n-    int min = (time >> 5) & 0x3f;\n-    int hrs = (time >> 11) & 0x1f;\n-    int day = date & 0x1f;\n-    int mon = ((date >> 5) & 0xf) - 1;\n-    int year = ((date >> 9) & 0x7f) + 10;  /* Since 1970. */\n+    if (comment.length() > 0xffff)\n+      throw new IllegalArgumentException();\n+    this.comment = comment;\n+  }\n \n-    // Guard against invalid or missing date causing IndexOutOfBoundsException.\n-    if (mon < 0 || mon > 11)\n-      return -1;\n+  /**\n+   * Gets the comment.\n+   * @return the comment or null if not set.\n+   */\n+  public String getComment()\n+  {\n+    return comment;\n+  }\n \n-    long mtime = (((hrs * 60) + min) * 60 + sec) * 1000;\n+  /**\n+   * Gets true, if the entry is a directory.  This is solely\n+   * determined by the name, a trailing slash '/' marks a directory.  \n+   */\n+  public boolean isDirectory()\n+  {\n+    int nlen = name.length();\n+    return nlen > 0 && name.charAt(nlen - 1) == '/';\n+  }\n \n-    // Leap year calculations are rather trivial in this case ...\n-    int days = 365 * year + ((year+1)>>2);\n-    days += daysToMonthStart[mon];\n-    if ((year & 3) == 0 && mon > 1)\n-      days++;\n-    days += day;\n-    return (days * 24*60*60L + ((hrs * 60) + min) * 60 + sec) * 1000L;\n+  /**\n+   * Gets the string representation of this ZipEntry.  This is just\n+   * the name as returned by getName().\n+   */\n+  public String toString()\n+  {\n+    return name;\n   }\n \n-  public String toString () { return name; }\n- \n   /**\n-   * Returns the hashcode of the name of this ZipEntry.\n+   * Gets the hashCode of this ZipEntry.  This is just the hashCode\n+   * of the name.  Note that the equals method isn't changed, though.\n    */\n-  public int hashCode () { return name.hashCode (); }\n+  public int hashCode()\n+  {\n+    return name.hashCode();\n+  }\n }"}, {"sha": "6dbed7cdaee9bd79224dcfb9122960d2ef9e0246", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 362, "deletions": 173, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,13 +1,13 @@\n-/* ZipFile.java - Read contents of a ZIP file\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.zip.ZipFile\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,233 +36,422 @@\n exception statement from your version. */\n \n package java.util.zip;\n-\n-import java.io.*;\n-\n-/* Written using on-line Java Platform 1.2 API Specification\n- * and JCL book.\n- * Believed complete and correct.\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.EOFException;\n+import java.io.RandomAccessFile;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * This class represents a Zip archive.  You can ask for the contained\n+ * entries, or get an input stream for a file entry.  The entry is\n+ * automatically decompressed.\n+ *\n+ * This class is thread safe:  You can open input streams for arbitrary\n+ * entries in different threads.\n+ *\n+ * @author Jochen Hoenicke\n  */\n-\n public class ZipFile implements ZipConstants\n {\n-  public static final int OPEN_READ = 1;\n-  public static final int OPEN_DELETE = 4;\n \n-  public ZipFile (String fname) throws IOException\n+  /** Mode flag to open a zip file for reading \n+   *\n+   */\n+\n+  public static final int OPEN_READ = 0x1;\n+\n+  /** Mode flag to delete a zip file after reading \n+   *\n+   */\n+\n+  public static final int OPEN_DELETE = 0x4;\n+\n+  private String name;\n+  RandomAccessFile raf;\n+  ZipEntry[] entries;\n+\n+  /**\n+   * Opens a Zip file with the given name for reading.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the file doesn't contain a valid zip\n+   * archive.  \n+   */\n+  public ZipFile(String name) throws ZipException, IOException\n   {\n-    this(new File(fname));\n+    this.raf = new RandomAccessFile(name, \"r\");\n+    this.name = name;\n+    readEntries();\n   }\n \n-  public ZipFile (File f) throws IOException\n+  /**\n+   * Opens a Zip file reading the given File.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the file doesn't contain a valid zip\n+   * archive.  \n+   */\n+  public ZipFile(File file) throws ZipException, IOException\n   {\n-    this(f, OPEN_READ);\n+    this.raf = new RandomAccessFile(file, \"r\");\n+    this.name = file.getName();\n+    readEntries();\n   }\n \n-  public ZipFile (File f, int mode) throws IOException\n+  /**\n+   * Opens a Zip file reading the given File in the given mode.\n+   *\n+   * If the OPEN_DELETE mode is specified, the zip file will be deleted at some time moment\n+   * after it is opened. It will be deleted before the zip file is closed or the Virtual Machine\n+   * exits.\n+   * \n+   * The contents of the zip file will be accessible until it is closed.\n+   *\n+   * The OPEN_DELETE mode is currently unimplemented in this library\n+   * \n+   * @since JDK1.3\n+   * @param mode Must be one of OPEN_READ or OPEN_READ | OPEN_DELETE\n+   *\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the file doesn't contain a valid zip\n+   * archive.  \n+   */\n+  public ZipFile(File file, int mode) throws ZipException, IOException\n   {\n-    if (mode != OPEN_READ && mode != (OPEN_READ | OPEN_DELETE))\n-        throw new IllegalArgumentException\n-            (\"mode can only be OPEN_READ or OPEN_READ | OPEN_DELETE\");\n-\n     if ((mode & OPEN_DELETE) != 0)\n       {\n-\tdelete_on_close = f;\n-\tf.deleteOnExit();\n-      }\n-    else\n-      {\n-\tdelete_on_close = null;\n+\tthrow new IllegalArgumentException(\"OPEN_DELETE mode not supported yet in java.util.zip.ZipFile\");\n       }\n+    this.raf = new RandomAccessFile(file, \"r\");\n+    this.name = file.getName();\n+    readEntries();\n+  }\n \n-    file = new RandomAccessFile(f, \"r\");\n-    name = f.getName();\n-    readDirectory ();\n+  /**\n+   * Read an unsigned short in little endian byte order.\n+   * @exception IOException if a i/o error occured.\n+   * @exception EOFException if the file ends prematurely\n+   */\n+  private final int readLeShort() throws IOException {\n+    return raf.readUnsignedByte() | raf.readUnsignedByte() << 8;\n   }\n \n-  void readDirectory () throws IOException\n+  /**\n+   * Read an int in little endian byte order.\n+   * @exception IOException if a i/o error occured.\n+   * @exception EOFException if the file ends prematurely\n+   */\n+  private final int readLeInt() throws IOException {\n+    return readLeShort() | readLeShort() << 16;\n+  }\n+\n+  /**\n+   * Read the central directory of a zip file and fill the entries\n+   * array.  This is called exactly once by the constructors.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the central directory is malformed \n+   */\n+  private void readEntries() throws ZipException, IOException\n   {\n-    long size = file.length ();\n-    if (size < ZipConstants.END_CENTRAL_DIR_SIZE)\n-      throw new ZipException (\"zipfile too short\");\n-    // We do not handle a \"zipfile comment\", which the appnote says can\n-    // be at the end of a .zip file.  We could handle this by seeking\n-    // to the beginning and reading forwards.\n-    file.seek(size - ZipConstants.END_CENTRAL_DIR_SIZE);\n-    if (file.read() != 'P'\n-\t|| file.read() != 'K'\n-\t|| file.read() != '\\005'\n-\t|| file.read() != '\\006')\n-      throw new ZipException(\"not a valid zipfile\");\n-    file.skipBytes(6);\n-    numEntries = readu2();\n-    int dir_size = read4 ();  // Read \"size of the central directory\".\n-    file.seek(size - (dir_size + ZipConstants.END_CENTRAL_DIR_SIZE));\n-\n-    ZipEntry last = null;\n-    for (int i = 0;  i < numEntries;  i++)\n+    /* Search for the End Of Central Directory.  When a zip comment is \n+     * present the directory may start earlier.\n+     * FIXME: This searches the whole file in a very slow manner if the\n+     * file isn't a zip file.\n+     */\n+    long pos = raf.length() - ENDHDR;\n+    do\n+      {\n+\tif (pos < 0)\n+\t  throw new ZipException\n+\t    (\"central directory not found, probably not a zip file\");\n+\traf.seek(pos--);\n+      }\n+    while (readLeInt() != ENDSIG);\n+    if (raf.skipBytes(ENDTOT - ENDNRD) != ENDTOT - ENDNRD)\n+      throw new EOFException();\n+    int count = readLeShort();\n+    if (raf.skipBytes(ENDOFF - ENDSIZ) != ENDOFF - ENDSIZ)\n+      throw new EOFException();\n+    int centralOffset = readLeInt();\n+\n+    entries = new ZipEntry[count];\n+    raf.seek(centralOffset);\n+    for (int i = 0; i < count; i++)\n       {\n-\tfile.skipBytes(10);\n-\tint method = readu2();\n-\tint modtime = readu2();\n-\tint moddate = readu2();\n-\tint crc = read4();\n-\tint compressedSize = read4();\n-\tint uncompressedSize = read4();\n-\tint filenameLength = readu2();\n-\tint extraLength = readu2();\n-\tint commentLength = readu2();\n-\tint diskNumberStart = readu2();\n-\tint intAttributes = readu2();\n-\tint extAttributes = read4();\n-\tint relativeOffset = read4();\n-\tbyte[] bname = new byte[filenameLength];\n-\tfile.readFully(bname);\n-\tZipEntry entry = new ZipEntry(new String(bname, \"8859_1\"));\n-\tif (extraLength > 0)\n+\tif (readLeInt() != CENSIG)\n+\t  throw new ZipException(\"Wrong Central Directory signature\");\n+\tif (raf.skipBytes(CENHOW - CENVEM) != CENHOW - CENVEM)\n+\t  throw new EOFException();\n+\tint method = readLeShort();\n+\tint dostime = readLeInt();\n+\tint crc = readLeInt();\n+\tint csize = readLeInt();\n+\tint size = readLeInt();\n+\tint nameLen = readLeShort();\n+\tint extraLen = readLeShort();\n+\tint commentLen = readLeShort();\n+\tif (raf.skipBytes(CENOFF - CENDSK) != CENOFF - CENDSK)\n+\t  throw new EOFException();\n+\tint offset = readLeInt();\n+\n+\tbyte[] buffer = new byte[Math.max(nameLen, commentLen)];\n+\n+\traf.readFully(buffer, 0, nameLen);\n+\tString name = new String(buffer, 0, nameLen);\n+\n+\tZipEntry entry = new ZipEntry(name);\n+\tentry.setMethod(method);\n+\tentry.setCrc(crc & 0xffffffffL);\n+\tentry.setSize(size & 0xffffffffL);\n+\tentry.setCompressedSize(csize & 0xffffffffL);\n+\tentry.setDOSTime(dostime);\n+\tif (extraLen > 0)\n \t  {\n-\t    byte[] bextra = new byte[extraLength];\n-\t    file.readFully(bextra);\n-\t    entry.extra = bextra;\n+\t    byte[] extra = new byte[extraLen];\n+\t    raf.readFully(extra);\n+\t    entry.setExtra(extra);\n \t  }\n-\tif (commentLength > 0)\n+\tif (commentLen > 0)\n \t  {\n-\t    byte[] bcomment = new byte[commentLength];\n-\t    file.readFully(bcomment);\n-\t    entry.comment = new String(bcomment, \"8859_1\");\n+\t    raf.readFully(buffer, 0, commentLen);\n+\t    entry.setComment(new String(buffer, 0, commentLen));\n \t  }\n-\tentry.compressedSize = compressedSize;\n-\tentry.size = uncompressedSize;\n-\tentry.crc = (long) crc & 0xffffffffL;\n-\tentry.method = method;\n-\tentry.relativeOffset = relativeOffset;\n-\tentry.time = ZipEntry.timeFromDOS(moddate, modtime);\n-\tif (last == null)\n-\t  entries = entry;\n-\telse\n-\t  last.next = entry;\n-\tlast = entry;\n+\tentry.zipFileIndex = i;\n+\tentry.offset = offset;\n+\tentries[i] = entry;\n       }\n   }\n \n-  public java.util.Enumeration entries()\n-  {\n-    return new ZipEnumeration(this);\n-  }\n-\n+  /**\n+   * Closes the ZipFile.  This also closes all input streams given by\n+   * this class.  After this is called, no further method should be\n+   * called.\n+   * @exception IOException if a i/o error occured.\n+   */\n   public void close() throws IOException\n   {\n-    file.close();\n     entries = null;\n-    numEntries = 0;\n-    if (delete_on_close != null)\n-\tdelete_on_close.delete();\n-  }\n-\n-  public ZipEntry getEntry(String name)\n-  {\n-    for (ZipEntry entry = entries;  entry != null;  entry = entry.next)\n+    synchronized (raf)\n       {\n-\tif (name.equals(entry.getName()))\n-\t  return entry;\n+\traf.close();\n       }\n-    return null;\n   }\n \n-  public InputStream getInputStream(ZipEntry ze)  throws IOException\n+  /**\n+   * Returns an enumeration of all Zip entries in this Zip file.\n+   */\n+  public Enumeration entries()\n   {\n-    byte[] buffer = new byte[(int) ze.getCompressedSize()];\n-\n-    /* Read the size of the extra field, and skip to the start of the\n-       data.  */\n-    file.seek (ze.relativeOffset + ZipConstants.LOCAL_FILE_HEADER_SIZE - 2);\n-    int extraFieldLength = readu2();\n-    file.skipBytes (ze.getName().length() + extraFieldLength);\n-\n-    file.readFully(buffer);\n-\n-    InputStream is = new ByteArrayInputStream (buffer);\n-    if (ze.getMethod() == ZipEntry.DEFLATED)\n-      // Data in zipfile entries does not have a zlib header, so construct\n-      // an Inflater with the `nowrapper' option.\n-      is = new InflaterInputStream (is, new Inflater (true), 512);\n-    return is;\n+    if (entries == null)\n+      throw new IllegalStateException(\"ZipFile has closed\");\n+    return new ZipEntryEnumeration(entries);\n   }\n \n-  public String getName ()\n+  private int getEntryIndex(String name)\n   {\n-    return name;\n+    for (int i = 0; i < entries.length; i++)\n+      if (name.equals(entries[i].getName()))\n+\treturn i;\n+    return -1;\n   }\n \n   /**\n-   * Returns the number of entries in this ZipFile.\n-   * @exception IllegalStateException if the ZipFile has been closed.\n-   *\n-   * @since 1.2\n-   */\n-  public int size ()\n+   * Searches for a zip entry in this archive with the given name.\n+   * @param the name. May contain directory components separated by\n+   * slashes ('/').\n+   * @return the zip entry, or null if no entry with that name exists.\n+   * @see #entries */\n+  public ZipEntry getEntry(String name)\n   {\n     if (entries == null)\n-      throw new IllegalStateException(\"ZipFile already closed\");\n-    else\n-      return numEntries;\n+      throw new IllegalStateException(\"ZipFile has closed\");\n+    int index = getEntryIndex(name);\n+    return index >= 0 ? (ZipEntry) entries[index].clone() : null;\n   }\n \n-  protected void finalize () throws IOException\n+  /**\n+   * Checks, if the local header of the entry at index i matches the\n+   * central directory, and returns the offset to the data.\n+   * @return the start offset of the (compressed) data.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the local header doesn't match the \n+   * central directory header\n+   */\n+  private long checkLocalHeader(ZipEntry entry) throws IOException\n   {\n-    close();\n+    synchronized (raf)\n+      {\n+\traf.seek(entry.offset);\n+\tif (readLeInt() != LOCSIG)\n+\t  throw new ZipException(\"Wrong Local header signature\");\n+\n+\t/* skip version and flags */\n+\tif (raf.skipBytes(LOCHOW - LOCVER) != LOCHOW - LOCVER)\n+\t  throw new EOFException();\n+\n+\tif (entry.getMethod() != readLeShort())\n+\t  throw new ZipException(\"Compression method mismatch\");\n+\n+\t/* Skip time, crc, size and csize */\n+\tif (raf.skipBytes(LOCNAM - LOCTIM) != LOCNAM - LOCTIM)\n+\t  throw new EOFException();\n+\n+\tif (entry.getName().length() != readLeShort())\n+\t  throw new ZipException(\"file name length mismatch\");\n+\n+\tint extraLen = entry.getName().length() + readLeShort();\n+\treturn entry.offset + LOCHDR + extraLen;\n+      }\n   }\n \n-  private int readu2 () throws IOException\n+  /**\n+   * Creates an input stream reading the given zip entry as\n+   * uncompressed data.  Normally zip entry should be an entry\n+   * returned by getEntry() or entries().\n+   * @return the input stream.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the Zip archive is malformed.  \n+   */\n+  public InputStream getInputStream(ZipEntry entry) throws IOException\n   {\n-    int byte0 = file.read();\n-    int byte1 = file.read();\n-    if (byte0 < 0 || byte1 < 0)\n-      throw new ZipException (\".zip archive ended prematurely\");\n-    return ((byte1 & 0xFF) << 8) | (byte0 & 0xFF);\n-  }\n+    if (entries == null)\n+      throw new IllegalStateException(\"ZipFile has closed\");\n+    int index = entry.zipFileIndex;\n+    if (index < 0 || index >= entries.length\n+\t|| entries[index].getName() != entry.getName())\n+      {\n+\tindex = getEntryIndex(entry.getName());\n+\tif (index < 0)\n+\t  throw new NoSuchElementException();\n+      }\n \n-  private int read4 () throws IOException\n+    long start = checkLocalHeader(entries[index]);\n+    int method = entries[index].getMethod();\n+    InputStream is = new PartialInputStream\n+      (raf, start, entries[index].getCompressedSize());\n+    switch (method)\n+      {\n+      case ZipOutputStream.STORED:\n+\treturn is;\n+      case ZipOutputStream.DEFLATED:\n+\treturn new InflaterInputStream(is, new Inflater(true));\n+      default:\n+\tthrow new ZipException(\"Unknown compression method \" + method);\n+      }\n+  }\n+  \n+  /**\n+   * Returns the name of this zip file.\n+   */\n+  public String getName()\n   {\n-    int byte0 = file.read();\n-    int byte1 = file.read();\n-    int byte2 = file.read();\n-    int byte3 = file.read();\n-    if (byte3 < 0)\n-      throw new ZipException (\".zip archive ended prematurely\");\n-    return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)\n-      + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);\n+    return name;\n   }\n \n-  ZipEntry entries;\n-  int numEntries;\n-  RandomAccessFile file;\n-  String name;\n-  /** File to delete on close or null. */\n-  File delete_on_close;\n-    \n-}\n-\n-final class ZipEnumeration implements java.util.Enumeration\n-{\n-  ZipEntry entry;\n-\n-  ZipEnumeration (ZipFile zfile)\n+  /**\n+   * Returns the number of entries in this zip file.\n+   */\n+  public int size()\n   {\n-    entry = zfile.entries;\n+    try\n+      {\n+\treturn entries.length;\n+      }\n+    catch (NullPointerException ex)\n+      {\n+\tthrow new IllegalStateException(\"ZipFile has closed\");\n+      }\n   }\n-\n-  public boolean hasMoreElements ()\n+  \n+  private static class ZipEntryEnumeration implements Enumeration\n   {\n-    return entry != null;\n+    ZipEntry[] array;\n+    int ptr = 0;\n+\n+    public ZipEntryEnumeration(ZipEntry[] arr)\n+    {\n+      array = arr;\n+    }\n+\n+    public boolean hasMoreElements()\n+    {\n+      return ptr < array.length;\n+    }\n+\n+    public Object nextElement()\n+    {\n+      try\n+\t{\n+\t  /* We return a clone, just to be safe that the user doesn't\n+\t   * change the entry.  \n+\t   */\n+\t  return array[ptr++].clone();\n+\t}\n+      catch (ArrayIndexOutOfBoundsException ex)\n+\t{\n+\t  throw new NoSuchElementException();\n+\t}\n+    }\n   }\n \n-  public Object nextElement ()\n+  private static class PartialInputStream extends InputStream\n   {\n-    ZipEntry cur = entry;\n-    if (cur == null)\n-      throw new java.util.NoSuchElementException();\n-    entry = cur.next;\n-    return cur;\n+    RandomAccessFile raf;\n+    long filepos, end;\n+\n+    public PartialInputStream(RandomAccessFile raf, long start, long len)\n+    {\n+      this.raf = raf;\n+      filepos = start;\n+      end = start + len;\n+    }\n+    \n+    public int available()\n+    {\n+      long amount = end - filepos;\n+      if (amount > Integer.MAX_VALUE)\n+\treturn Integer.MAX_VALUE;\n+      return (int) amount;\n+    }\n+    \n+    public int read() throws IOException\n+    {\n+      if (filepos == end)\n+\treturn -1;\n+      synchronized (raf)\n+\t{\n+\t  raf.seek(filepos++);\n+\t  return raf.read();\n+\t}\n+    }\n+\n+    public int read(byte[] b, int off, int len) throws IOException\n+    {\n+      if (len > end - filepos)\n+\t{\n+\t  len = (int) (end - filepos);\n+\t  if (len == 0)\n+\t    return -1;\n+\t}\n+      synchronized (raf)\n+\t{\n+\t  raf.seek(filepos);\n+\t  int count = raf.read(b, off, len);\n+\t  if (count > 0)\n+\t    filepos += len;\n+\t  return count;\n+\t}\n+    }\n+\n+    public long skip(long amount)\n+    {\n+      if (amount < 0)\n+\tthrow new IllegalArgumentException();\n+      if (amount > end - filepos)\n+\tamount = end - filepos;\n+      filepos += amount;\n+      return amount;\n+    }\n   }\n }"}, {"sha": "63153b649c9e19f8c817a09e327e6defd1c81c89", "filename": "libjava/java/util/zip/ZipInputStream.java", "status": "modified", "additions": 265, "deletions": 197, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,13 +1,13 @@\n-/* ZipInputStream.java - Input filter for reading zip file\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.zip.ZipInputStream\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,259 +36,327 @@\n exception statement from your version. */\n \n package java.util.zip;\n-import java.io.*;\n+import java.io.EOFException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.Enumeration;\n \n /**\n- * @author Per Bothner\n- * @date May 1999.\n+ * This is a FilterInputStream that reads the files in an zip archive\n+ * one after another.  It has a special method to get the zip entry of\n+ * the next file.  The zip entry contains information about the file name\n+ * size, compressed size, CRC, etc.\n+ *\n+ * It includes support for STORED and DEFLATED entries.\n+ *\n+ * @author Jochen Hoenicke\n  */\n+public class ZipInputStream extends InflaterInputStream implements ZipConstants\n+{\n+  private CRC32 crc = new CRC32();\n+  private ZipEntry entry = null;\n \n-/*\n- * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Quite incomplete, but can read uncompressed .zip archives.\n- */\n+  private int csize;\n+  private int size;\n+  private int method;\n+  private int flags;\n+  private int avail;\n \n-// We do not calculate the CRC and compare it with the specified value;\n-// we probably should.  FIXME.\n-   \n+  /**\n+   * Creates a new Zip input stream, reading a zip archive.\n+   */\n+  public ZipInputStream(InputStream in)\n+  {\n+    super(in, new Inflater(true));\n+  }\n \n-public class ZipInputStream extends InflaterInputStream implements ZipConstants\n-{\n-  public ZipInputStream (InputStream in)\n+  private void fillBuf() throws IOException\n   {\n-    super (in, new Inflater (true));\n+    avail = len = in.read(buf, 0, buf.length);\n   }\n \n-  public ZipEntry getNextEntry () throws IOException\n+  private int readBuf(byte[] out, int offset, int length) throws IOException\n   {\n-    if (closed)\n-      throw new IOException (\"stream closed\");\n-    if (current != null)\n-      closeEntry();\n-    if (in.read() != 'P'\n-\t|| in.read() != 'K')\n-      return null;\n-    int code = in.read();\n-    while (code == '\\001')\n+    if (avail <= 0)\n       {\n-\tcode = in.read();\n-\tif (code != '\\002')\n-\t  return null;\n-\tin.skip(16);\n-\tint size = read4();\n-\tin.skip(4);\n-\tint fname_length = readu2();\n-\tint extra_length = readu2();\n-\tint fcomment_length = readu2();\n-\t// `12' is the number of bytes between the comment length\n-\t// field and the end of the fixed part of the header:\n-\t// 2 bytes for `disk number start'\n-\t// 2 bytes for `internal file attributes'\n-\t// 4 bytes for `external file attributes'\n-\t// 4 bytes for `relative offset of local header'\n-\tin.skip(12 + fname_length + extra_length + fcomment_length);\n-\tif (in.read() != 'P' || in.read() != 'K')\n-\t  return null;\n-\tcode = in.read();\n+\tfillBuf();\n+\tif (avail <= 0)\n+\t  return -1;\n       }\n-    if (code == '\\005')\n+    if (length > avail)\n+      length = avail;\n+    System.arraycopy(buf, len - avail, out, offset, length);\n+    avail -= length;\n+    return length;\n+  }\n+  \n+  private void readFully(byte[] out) throws IOException\n+  {\n+    int off = 0;\n+    int len = out.length;\n+    while (len > 0)\n       {\n-\tif (in.read() != '\\006')\n-\t  return null;\n-\tin.skip(16);\n-\tint comment_size = readu2();\n-\tin.skip(comment_size);\n-\tif (in.read() != 'P' || in.read() != 'K')\n-\t  return null;\n-\tcode = in.read();\n+\tint count = readBuf(out, off, len);\n+\tif (count == -1)\n+\t  throw new EOFException();\n+\toff += count;\n+\tlen -= count;\n       }\n-    if (code != '\\003'\n-\t|| in.read() != '\\004')\n-      return null;\n-    int ex_version = readu2();\n-    current_flags = readu2();\n-    int method = readu2();\n-    int modtime = readu2();\n-    int moddate = readu2();\n-    int crc = read4();\n-    int compressedSize = read4();\n-    int uncompressedSize = read4();\n-    int filenameLength = readu2();\n-    int extraLength = readu2();\n-    byte[] bname = new byte[filenameLength];\n-    readFully(bname);\n-    ZipEntry entry = createZipEntry(new String(bname, \"8859_1\"));\n-    if (extraLength > 0)\n+  }\n+  \n+  private final int readLeByte() throws IOException\n+  {\n+    if (avail <= 0)\n       {\n-\tbyte[] bextra = new byte[extraLength];\n-\treadFully(bextra);\n-\tentry.extra = bextra;\n+\tfillBuf();\n+\tif (avail <= 0)\n+\t  throw new ZipException(\"EOF in header\");\n       }\n-    entry.compressedSize = compressedSize;\n-    entry.size = uncompressedSize;\n-    entry.crc = (long) crc & 0xffffffffL;\n-    entry.method = method;\n-    entry.time = ZipEntry.timeFromDOS(moddate, modtime);\n-    current = entry;\n-    avail = uncompressedSize;\n-    compressed_bytes = compressedSize;\n-    return entry;\n+    return buf[len - avail--] & 0xff;\n   }\n \n-  // We override fill to let us control how much data gets read from\n-  // the underlying input stream.  This lets us avoid having to push\n-  // back data.\n-  protected void fill () throws IOException\n+  /**\n+   * Read an unsigned short in little endian byte order.\n+   */\n+  private final int readLeShort() throws IOException \n   {\n-    if (closed)\n-      throw new IOException (\"stream closed\");\n-    int count = buf.length;\n-    if (count > compressed_bytes)\n-      count = compressed_bytes;\n-    len = in.read(buf, 0, count);\n-    if (len != -1)\n-      {\n-\tcompressed_bytes -= len;\n-\tinf.setInput(buf, 0, len);\n-      }\n+    return readLeByte() | (readLeByte() << 8);\n   }\n \n   /**\n-   * Creates a new ZipEntry with the given name.\n-   * Used by ZipInputStream when normally <code>new ZipEntry (name)</code>\n-   * would be called. This gives subclasses such as JarInputStream a change\n-   * to override this method and add aditional information to the ZipEntry\n-   * (subclass).\n+   * Read an int in little endian byte order.\n    */\n-  protected ZipEntry createZipEntry (String name)\n+  private final int readLeInt() throws IOException \n   {\n-    return new ZipEntry (name);\n+    return readLeShort() | (readLeShort() << 16);\n   }\n \n-  public int read (byte[] b, int off, int len)  throws IOException\n+  /**\n+   * Open the next entry from the zip archive, and return its description.\n+   * If the previous entry wasn't closed, this method will close it.\n+   */\n+  public ZipEntry getNextEntry() throws IOException\n   {\n-    if (closed)\n-      throw new IOException (\"stream closed\");\n-    if (len > avail)\n-      len = avail;\n-    int count;\n-    if (current.method == Deflater.DEFLATED)\n-      count = super.read(b, off, len);\n-    else\n-      count = in.read(b, off, len);\n-    if (count == -1 || avail == 0)\n+    if (crc == null)\n+      throw new IllegalStateException(\"Closed.\");\n+    if (entry != null)\n+      closeEntry();\n+\n+    int header = readLeInt();\n+    if (header == CENSIG)\n       {\n-\tinf.reset();\n-\tcount = -1;\n+\t/* Central Header reached. */\n+\tclose();\n+\treturn null;\n       }\n-    else\n-      avail -= count;\n-    return count;\n+    if (header != LOCSIG)\n+      throw new ZipException(\"Wrong Local header signature\" + Integer.toHexString(header));\n+    /* skip version */\n+    readLeShort();\n+    flags = readLeShort();\n+    method = readLeShort();\n+    int dostime = readLeInt();\n+    int crc = readLeInt();\n+    csize = readLeInt();\n+    size = readLeInt();\n+    int nameLen = readLeShort();\n+    int extraLen = readLeShort();\n+\n+    if (method == ZipOutputStream.STORED && csize != size)\n+      throw new ZipException(\"Stored, but compressed != uncompressed\");\n+\n+\n+    byte[] buffer = new byte[nameLen];\n+    readFully(buffer);\n+    String name = new String(buffer);\n+    \n+    entry = createZipEntry(name);\n+    entry.setMethod(method);\n+    if ((flags & 8) == 0)\n+      {\n+\tentry.setCrc(crc & 0xffffffffL);\n+\tentry.setSize(size & 0xffffffffL);\n+\tentry.setCompressedSize(csize & 0xffffffffL);\n+      }\n+    entry.setDOSTime(dostime);\n+    if (extraLen > 0)\n+      {\n+\tbyte[] extra = new byte[extraLen];\n+\treadFully(extra);\n+\tentry.setExtra(extra);\n+      }\n+\n+    if (method == ZipOutputStream.DEFLATED && avail > 0)\n+      {\n+\tSystem.arraycopy(buf, len - avail, buf, 0, avail);\n+\tlen = avail;\n+\tavail = 0;\n+\tinf.setInput(buf, 0, len);\n+      }\n+    return entry;\n   }\n \n-  public long skip (long n)  throws IOException\n+  private void readDataDescr() throws IOException\n   {\n-    if (closed)\n-      throw new IOException (\"stream closed\");\n-    if (n > avail)\n-      n = avail;\n-    long count;\n-    if (current.method == Deflater.DEFLATED)\n-      count = super.skip(n);\n-    else\n-      count = in.skip(n);\n-    avail = avail - (int) count;\n-    return count;\n+    if (readLeInt() != EXTSIG)\n+      throw new ZipException(\"Data descriptor signature not found\");\n+    entry.setCrc(readLeInt() & 0xffffffffL);\n+    csize = readLeInt();\n+    size = readLeInt();\n+    entry.setSize(size & 0xffffffffL);\n+    entry.setCompressedSize(csize & 0xffffffffL);\n   }\n \n   /**\n-   * Returns 0 if the ZipInputStream is closed and 1 otherwise.\n-   *\n-   * @since 1.2\n+   * Closes the current zip entry and moves to the next one.\n    */\n-  public int available()\n+  public void closeEntry() throws IOException\n   {\n-    return closed ? 0 : 1;\n-  }\n+    if (crc == null)\n+      throw new IllegalStateException(\"Closed.\");\n+    if (entry == null)\n+      return;\n \n-  private void readFully (byte[] b)  throws IOException\n-  {\n-    int off = 0;\n-    int len = b.length;\n-    while (len > 0)\n+    if (method == ZipOutputStream.DEFLATED)\n       {\n-\tint count = in.read(b, off, len);\n-\tif (count <= 0)\n-\t  throw new EOFException(\".zip archive ended prematurely\");\n-\toff += count;\n-\tlen -= count;\n+\tif ((flags & 8) != 0)\n+\t  {\n+\t    /* We don't know how much we must skip, read until end. */\n+\t    byte[] tmp = new byte[2048];\n+\t    while (read(tmp) > 0)\n+\t      ;\n+\t    /* read will close this entry */\n+\t    return;\n+\t  }\n+\tcsize -= inf.getTotalIn();\n+\tavail = inf.getRemaining();\n+      }\n+\n+    if (avail > csize && csize >= 0)\n+      avail -= csize;\n+    else\n+      {\n+\tcsize -= avail;\n+\tavail = 0;\n+\twhile (csize != 0)\n+\t  {\n+\t    long skipped = in.skip(csize & 0xffffffffL);\n+\t    if (skipped <= 0)\n+\t      throw new ZipException(\"zip archive ends early.\");\n+\t    csize -= skipped;\n+\t  }\n       }\n+\n+    size = 0;\n+    crc.reset();\n+    if (method == ZipOutputStream.DEFLATED)\n+      inf.reset();\n+    entry = null;\n   }\n \n-  private int readu2 ()  throws IOException\n+  public int available() throws IOException\n   {\n-    int byte0 = in.read();\n-    int byte1 = in.read();\n-    if (byte0 < 0 || byte1 < 0)\n-      throw new EOFException(\".zip archive ended prematurely\");\n-    return ((byte1 & 0xFF) << 8) | (byte0 & 0xFF);\n+    return entry != null ? 1 : 0;\n   }\n \n-  private int read4 () throws IOException\n+  /**\n+   * Reads a byte from the current zip entry.\n+   * @return the byte or -1 on EOF.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the deflated stream is corrupted.\n+   */\n+  public int read() throws IOException\n   {\n-    int byte0 = in.read();\n-    int byte1 = in.read();\n-    int byte2 = in.read();\n-    int byte3 = in.read();\n-    if (byte3 < 0)\n-      throw new EOFException(\".zip archive ended prematurely\");\n-    return ((byte3 & 0xFF) << 24) + ((byte2 & 0xFF) << 16)\n-      + ((byte1 & 0xFF) << 8) + (byte0 & 0xFF);\n+    byte[] b = new byte[1];\n+    if (read(b, 0, 1) <= 0)\n+      return -1;\n+    return b[0] & 0xff;\n   }\n \n-  public void closeEntry ()  throws IOException\n+  /**\n+   * Reads a block of bytes from the current zip entry.\n+   * @return the number of bytes read (may be smaller, even before\n+   * EOF), or -1 on EOF.\n+   * @exception IOException if a i/o error occured.\n+   * @exception ZipException if the deflated stream is corrupted.\n+   */\n+  public int read(byte[] b, int off, int len) throws IOException\n   {\n-    if (current != null)\n+    if (crc == null)\n+      throw new IllegalStateException(\"Closed.\");\n+    if (entry == null)\n+      return -1;\n+    boolean finished = false;\n+    switch (method)\n       {\n-\tif (avail > 0)\n-\t  skip (avail);\n-\tif ((current_flags & 8) != 0)\n+      case ZipOutputStream.DEFLATED:\n+\tlen = super.read(b, off, len);\n+\tif (len < 0)\n \t  {\n-\t    int sig = read4();\n-\t    if (sig != 0x04034b50)\n-\t      throw new ZipException(\"bad/missing magic number at end of .zip entry\");\n-\t    int crc = read4();\n-\t    int compressedSize = read4();\n-\t    int uncompressedSize = read4();\n-\t    if (current.compressedSize != compressedSize\n-\t\t|| current.size != uncompressedSize\n-\t\t|| current.crc != crc)\n-\t      throw new ZipException(\"bad data descriptor at end of .zip entry\");\n+\t    if (!inf.finished())\n+\t      throw new ZipException(\"Inflater not finished!?\");\n+\t    avail = inf.getRemaining();\n+\t    if ((flags & 8) != 0)\n+\t      readDataDescr();\n+\n+\t    if (inf.getTotalIn() != csize\n+\t\t|| inf.getTotalOut() != size)\n+\t      throw new ZipException(\"size mismatch: \"+csize+\";\"+size+\" <-> \"+inf.getTotalIn()+\";\"+inf.getTotalOut());\n+\t    inf.reset();\n+\t    finished = true;\n \t  }\n-\tcurrent = null;\n-\tavail = 0;\n+\tbreak;\n+\t\n+      case ZipOutputStream.STORED:\n+\n+\tif (len > csize && csize >= 0)\n+\t  len = csize;\n+\t\n+\tlen = readBuf(b, off, len);\n+\tif (len > 0)\n+\t  {\n+\t    csize -= len;\n+\t    size -= len;\n+\t  }\n+\n+\tif (csize == 0)\n+\t  finished = true;\n+\telse if (len < 0)\n+\t  throw new ZipException(\"EOF in stored block\");\n+\tbreak;\n+      }\n+\n+    if (len > 0)\n+      crc.update(b, off, len);\n+\n+    if (finished)\n+      {\n+\tif ((crc.getValue() & 0xffffffffL) != entry.getCrc())\n+\t  throw new ZipException(\"CRC mismatch\");\n+\tcrc.reset();\n+\tentry = null;\n       }\n+    return len;\n   }\n \n   /**\n-   * Closes this InflaterInputStream.\n-   *\n-   * @since 1.2\n+   * Closes the zip file.\n+   * @exception IOException if a i/o error occured.\n    */\n-  public void close ()  throws IOException\n+  public void close() throws IOException\n   {\n-    current = null;\n-    closed = true;\n     super.close();\n+    crc = null;\n+    entry = null;\n   }\n \n-  private ZipEntry current;\n-  private int current_flags;\n-  // Number of uncompressed bytes to be read.\n-  private int avail;\n-  // Number of bytes we can read from underlying stream.\n-  private int compressed_bytes;\n-  // Is this ZipInputStream closed? Set by the close() method.\n-  private boolean closed = false;\n+  /**\n+   * Creates a new zip entry for the given name.  This is equivalent\n+   * to new ZipEntry(name).\n+   * @param name the name of the zip entry.\n+   */\n+  protected ZipEntry createZipEntry(String name) \n+  {\n+    return new ZipEntry(name);\n+  }\n }"}, {"sha": "e4fb864a95536612132c259651054bb89b03b796", "filename": "libjava/java/util/zip/ZipOutputStream.java", "status": "modified", "additions": 316, "deletions": 240, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipOutputStream.java?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,13 +1,13 @@\n-/* ZipOutputStream.java - Create a file in zip format\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* java.util.zip.ZipOutputStream\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,286 +36,362 @@\n exception statement from your version. */\n \n package java.util.zip;\n-\n-import java.io.*;\n-\n-/* Written using on-line Java Platform 1.2 API Specification\n- * and JCL book.\n- * Believed complete and correct.\n+import java.io.OutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Vector;\n+import java.util.Enumeration;\n+\n+/**\n+ * This is a FilterOutputStream that writes the files into a zip\n+ * archive one after another.  It has a special method to start a new\n+ * zip entry.  The zip entries contains information about the file name\n+ * size, compressed size, CRC, etc.\n+ *\n+ * It includes support for STORED and DEFLATED entries.\n+ *\n+ * This class is not thread safe.\n+ *\n+ * @author Jochen Hoenicke \n  */\n-\n-public class ZipOutputStream extends DeflaterOutputStream\n-  implements ZipConstants\n+public class ZipOutputStream extends DeflaterOutputStream implements ZipConstants\n {\n-  public static final int STORED = 0;\n-  public static final int DEFLATED = 8;\n-\n-  public void close () throws IOException\n+  private Vector entries = new Vector();\n+  private CRC32 crc = new CRC32();\n+  private ZipEntry curEntry = null;\n+\n+  private int curMethod;\n+  private int size;\n+  private int offset = 0;\n+\n+  private byte[] zipComment = new byte[0];\n+  private int defaultMethod = DEFLATED;\n+\n+  /**\n+   * Our Zip version is hard coded to 1.0 resp. 2.0\n+   */\n+  private final static int ZIP_STORED_VERSION   = 10;\n+  private final static int ZIP_DEFLATED_VERSION = 20;\n+\n+  /**\n+   * Compression method.  This method doesn't compress at all.\n+   */\n+  public final static int STORED      =  0;\n+  /**\n+   * Compression method.  This method uses the Deflater.\n+   */\n+  public final static int DEFLATED    =  8;\n+\n+  /**\n+   * Creates a new Zip output stream, writing a zip archive.\n+   * @param out the output stream to which the zip archive is written.\n+   */\n+  public ZipOutputStream(OutputStream out)\n   {\n-    finish ();\n-    out.close();\n+    super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true));\n   }\n \n-  public void closeEntry ()  throws IOException\n+  /**\n+   * Set the zip file comment.\n+   * @param comment the comment.\n+   * @exception IllegalArgumentException if encoding of comment is\n+   * longer than 0xffff bytes.\n+   */\n+  public void setComment(String comment)\n   {\n-    int compressed_size;\n-    if (current.method == STORED)\n-      {\n-\tcompressed_size = uncompressed_size;\n-      }\n-    else\n-      {\n-\tsuper.finish();\n-\tcompressed_size = def.getTotalOut();\n-      }\n-    long crc = sum.getValue();\n-\n-    bytes_written += compressed_size;\n-\n-    if (current.getCrc() == -1 || current.getCompressedSize() == -1\n-\t|| current.getSize() == -1)\n-      {\n-\tcurrent.setCrc(crc);\n-\tcurrent.compressedSize = compressed_size;\n-\tcurrent.setSize(uncompressed_size);\n-\tput4 (0x08074b50);\n-\tput4 ((int) (current.getCrc()));\n-\tput4 ((int) (current.getCompressedSize()));\n-\tput4 ((int) (current.getSize()));\n-\tbytes_written += 16;\n-      }\n-    else if (current.getCrc() != crc\n-\t     || current.getCompressedSize() != compressed_size\n-\t     || current.getSize() != uncompressed_size)\n-      throw new ZipException (\"zip entry field incorrect\");\n-\n-    current.next = chain;\n-    chain = current;\n-    current = null;\n+    byte[] commentBytes;\n+    commentBytes = comment.getBytes();\n+    if (commentBytes.length > 0xffff)\n+      throw new IllegalArgumentException(\"Comment too long.\");\n+    zipComment = commentBytes;\n   }\n-\n-  public void write (int bval) throws IOException\n+  \n+  /**\n+   * Sets default compression method.  If the Zip entry specifies\n+   * another method its method takes precedence.\n+   * @param method the method.\n+   * @exception IllegalArgumentException if method is not supported.\n+   * @see #STORED\n+   * @see #DEFLATED\n+   */\n+  public void setMethod(int method)\n   {\n-    if (current.method == STORED)\n-      {\n-\tout.write(bval);\n-      }\n-    else\n-      super.write(bval);\n-    sum.update(bval);\n-    uncompressed_size += 1;\n+    if (method != STORED && method != DEFLATED)\n+      throw new IllegalArgumentException(\"Method not supported.\");\n+    defaultMethod = method;\n   }\n \n-  public void write (byte[] buf, int off, int len) throws IOException\n+  /**\n+   * Sets default compression level.  The new level will be activated\n+   * immediately.  \n+   * @exception IllegalArgumentException if level is not supported.\n+   * @see Deflater\n+   */\n+  public void setLevel(int level)\n   {\n-    if (current.method == STORED)\n-      out.write(buf, off, len);\n-    else\n-      super.write(buf, off, len);\n-    sum.update(buf, off, len);\n-    uncompressed_size += len;\n+    def.setLevel(level);\n   }\n-\n-  public void finish () throws IOException\n+  \n+  /**\n+   * Write an unsigned short in little endian byte order.\n+   */\n+  private final void writeLeShort(int value) throws IOException \n   {\n-    if (current != null)\n-      closeEntry ();\n-\n-    // Write the central directory.\n-    long offset = bytes_written;\n-    int count = 0;\n-    int bytes = 0;\n-    while (chain != null)\n-      {\n-\tbytes += write_entry (chain, false);\n-\t++count;\n-\tchain = chain.next;\n-      }\n+    out.write(value & 0xff);\n+    out.write((value >> 8) & 0xff);\n+  }\n \n-    // Write the end of the central directory record.\n-    put4 (0x06054b50);\n-    // Disk number.\n-    put2 (0);\n-    // Another disk number.\n-    put2 (0);\n-    put2 (count);\n-    put2 (count);\n-    put4 (bytes);\n-    put4 ((int) offset);\n-\n-    byte[] c = comment.getBytes(\"8859_1\");\n-    put2 (c.length);\n-    out.write(c);\n+  /**\n+   * Write an int in little endian byte order.\n+   */\n+  private final void writeLeInt(int value) throws IOException \n+  {\n+    writeLeShort(value);\n+    writeLeShort(value >> 16);\n   }\n \n-  // Helper for finish and putNextEntry.\n-  private int write_entry (ZipEntry entry, boolean is_local)\n-    throws IOException\n+  /**\n+   * Starts a new Zip entry. It automatically closes the previous\n+   * entry if present.  If the compression method is stored, the entry\n+   * must have a valid size and crc, otherwise all elements (except\n+   * name) are optional, but must be correct if present.  If the time\n+   * is not set in the entry, the current time is used.\n+   * @param entry the entry.\n+   * @exception IOException if an I/O error occured.\n+   * @exception IllegalStateException if stream was finished\n+   */\n+  public void putNextEntry(ZipEntry entry) throws IOException\n   {\n-    int bytes = put4 (is_local ? 0x04034b50 : 0x02014b50);\n-    if (! is_local)\n-      bytes += put_version ();\n-    bytes += put_version ();\n-\n-    boolean crc_after = false;\n-    if (is_local\n-\t&& (entry.getCrc() == -1 || entry.getCompressedSize() == -1\n-\t    || entry.getSize() == -1))\n-      crc_after = true;\n-    // For the bits field we always indicate `normal' compression,\n-    // even if that isn't true.\n-    bytes += put2 (crc_after ? (1 << 3) : 0);\n-    bytes += put2 (entry.method);\n-\n-    bytes += put2(0);  // time - FIXME\n-    bytes += put2(0);  // date - FIXME\n-\n-    if (crc_after)\n-      {\n-\t// CRC, compressedSize, and Size are always 0 in this header.\n-\t// The actual values are given after the entry.\n-\tbytes += put4 (0);\n-\tbytes += put4 (0);\n-\tbytes += put4 (0);\n-      }\n-    else\n-      {\n-\tbytes += put4 ((int) (entry.getCrc()));\n-\tbytes += put4 ((int) (entry.getCompressedSize()));\n-\tbytes += put4 ((int) (entry.getSize()));\n-      }\n+    if (entries == null)\n+      throw new IllegalStateException(\"ZipOutputStream was finished\");\n \n-    byte[] name = entry.name.getBytes(\"8859_1\");\n-    bytes += put2 (name.length);\n-    bytes += put2 (entry.extra == null ? 0 : entry.extra.length);\n+    int method = entry.getMethod();\n+    int flags = 0;\n+    if (method == -1)\n+      method = defaultMethod;\n \n-    byte[] comment = null;\n-    if (! is_local)\n+    if (method == STORED)\n       {\n-\tif (entry.getComment() == null)\n-\t  bytes += put2 (0);\n-\telse\n+\tif (entry.getCompressedSize() >= 0)\n \t  {\n-\t    comment = entry.getComment().getBytes(\"8859_1\");\n-\t    bytes += put2 (comment.length);\n+\t    if (entry.getSize() < 0)\n+\t      entry.setSize(entry.getCompressedSize());\n+\t    else if (entry.getSize() != entry.getCompressedSize())\n+\t      throw new ZipException\n+\t\t(\"Method STORED, but compressed size != size\");\n \t  }\n+\telse\n+\t  entry.setCompressedSize(entry.getSize());\n \n-\t// Disk number start.\n-\tbytes += put2 (0);\n-\t// Internal file attributes.\n-\tbytes += put2 (0);\n-\t// External file attributes.\n-\tbytes += put4 (0);\n-\t// Relative offset of local header.\n-\tbytes += put4 ((int) entry.relativeOffset);\n+\tif (entry.getSize() < 0)\n+\t  throw new ZipException(\"Method STORED, but size not set\");\n+\tif (entry.getCrc() < 0)\n+\t  throw new ZipException(\"Method STORED, but crc not set\");\n+      }\n+    else if (method == DEFLATED)\n+      {\n+\tif (entry.getCompressedSize() < 0\n+\t    || entry.getSize() < 0 || entry.getCrc() < 0)\n+\t  flags |= 8;\n       }\n \n-    out.write (name);\n-    bytes += name.length;\n-    if (entry.extra != null)\n+    if (curEntry != null)\n+      closeEntry();\n+\n+    if (entry.getTime() < 0)\n+      entry.setTime(System.currentTimeMillis());\n+\n+    entry.flags = flags;\n+    entry.offset = offset;\n+    entry.setMethod(method);\n+    curMethod = method;\n+    /* Write the local file header */\n+    writeLeInt(LOCSIG);\n+    writeLeShort(method == STORED\n+\t\t ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);\n+    writeLeShort(flags);\n+    writeLeShort(method);\n+    writeLeInt(entry.getDOSTime());\n+    if ((flags & 8) == 0)\n       {\n-\tout.write(entry.extra);\n-\tbytes += entry.extra.length;\n+\twriteLeInt((int)entry.getCrc());\n+\twriteLeInt((int)entry.getCompressedSize());\n+\twriteLeInt((int)entry.getSize());\n       }\n-    if (comment != null)\n+    else\n       {\n-\tout.write(comment);\n-\tbytes += comment.length;\n+\twriteLeInt(0);\n+\twriteLeInt(0);\n+\twriteLeInt(0);\n       }\n-\n-    bytes_written += bytes;\n-    return bytes;\n+    byte[] name = entry.getName().getBytes();\n+    if (name.length > 0xffff)\n+      throw new ZipException(\"Name too long.\");\n+    byte[] extra = entry.getExtra();\n+    if (extra == null)\n+      extra = new byte[0];\n+    writeLeShort(name.length);\n+    writeLeShort(extra.length);\n+    out.write(name);\n+    out.write(extra);\n+\n+    offset += LOCHDR + name.length + extra.length;\n+\n+    /* Activate the entry. */\n+\n+    curEntry = entry;\n+    crc.reset();\n+    if (method == DEFLATED)\n+      def.reset();\n+    size = 0;\n   }\n \n-  public void putNextEntry (ZipEntry entry) throws IOException\n+  /**\n+   * Closes the current entry.\n+   * @exception IOException if an I/O error occured.\n+   * @exception IllegalStateException if no entry is active.\n+   */\n+  public void closeEntry() throws IOException\n   {\n-    if (current != null)\n-      closeEntry ();\n-\n-    if (entry.method < 0 )\n-      entry.method = method;\n-    if (entry.method == STORED)\n+    if (curEntry == null)\n+      throw new IllegalStateException(\"No open entry\");\n+\n+    /* First finish the deflater, if appropriate */\n+    if (curMethod == DEFLATED)\n+      super.finish();\n+\n+    int csize = curMethod == DEFLATED ? def.getTotalOut() : size;\n+\n+    if (curEntry.getSize() < 0)\n+      curEntry.setSize(size);\n+    else if (curEntry.getSize() != size)\n+      throw new ZipException(\"size was \"+size\n+\t\t\t     +\", but I expected \"+curEntry.getSize());\n+\n+    if (curEntry.getCompressedSize() < 0)\n+      curEntry.setCompressedSize(csize);\n+    else if (curEntry.getCompressedSize() != csize)\n+      throw new ZipException(\"compressed size was \"+csize\n+\t\t\t     +\", but I expected \"+curEntry.getSize());\n+\n+    if (curEntry.getCrc() < 0)\n+      curEntry.setCrc(crc.getValue());\n+    else if (curEntry.getCrc() != crc.getValue())\n+      throw new ZipException(\"crc was \" + Long.toHexString(crc.getValue())\n+\t\t\t     + \", but I expected \" \n+\t\t\t     + Long.toHexString(curEntry.getCrc()));\n+\n+    offset += csize;\n+\n+    /* Now write the data descriptor entry if needed. */\n+    if (curMethod == DEFLATED && (curEntry.flags & 8) != 0)\n       {\n-\tif (entry.getSize() == -1 || entry.getCrc() == -1)\n-\t  throw new ZipException (\"required entry not set\");\n-\t// Just in case.\n-\tentry.compressedSize = entry.getSize();\n+\twriteLeInt(EXTSIG);\n+\twriteLeInt((int)curEntry.getCrc());\n+\twriteLeInt((int)curEntry.getCompressedSize());\n+\twriteLeInt((int)curEntry.getSize());\n+\toffset += EXTHDR;\n       }\n-    entry.relativeOffset = bytes_written;\n-    write_entry (entry, true);\n-    current = entry;\n-    int compr = (method == STORED) ? Deflater.NO_COMPRESSION : level;\n-    def.reset();\n-    def.setLevel(compr);\n-    sum.reset();\n-    uncompressed_size = 0;\n-  }\n \n-  public void setLevel (int level)\n-  {\n-    if (level != Deflater.DEFAULT_COMPRESSION\n-\t&& (level < Deflater.NO_COMPRESSION\n-\t    || level > Deflater.BEST_COMPRESSION))\n-      throw new IllegalArgumentException ();\n-    this.level = level;\n+    entries.addElement(curEntry);\n+    curEntry = null;\n   }\n \n-  public void setMethod (int method)\n+  /**\n+   * Writes the given buffer to the current entry.\n+   * @exception IOException if an I/O error occured.\n+   * @exception IllegalStateException if no entry is active.\n+   */\n+  public void write(byte[] b, int off, int len) throws IOException\n   {\n-    if (method != DEFLATED && method != STORED)\n-      throw new IllegalArgumentException ();\n-    this.method = method;\n-  }\n-\n-  public void setComment (String comment)\n-  {\n-    if (comment.length() > 65535)\n-      throw new IllegalArgumentException ();\n-    this.comment = comment;\n-  }\n+    if (curEntry == null)\n+      throw new IllegalStateException(\"No open entry.\");\n \n-  public ZipOutputStream (OutputStream out)\n-  {\n-    super (out, new Deflater (Deflater.DEFAULT_COMPRESSION, true), 8192);\n-    sum = new CRC32 ();\n-  }\n+    switch (curMethod)\n+      {\n+      case DEFLATED:\n+\tsuper.write(b, off, len);\n+\tbreak;\n+\t\n+      case STORED:\n+\tout.write(b, off, len);\n+\tbreak;\n+      }\n \n-  private int put2 (int i) throws IOException\n-  {\n-    out.write (i);\n-    out.write (i >> 8);\n-    return 2;\n+    crc.update(b, off, len);\n+    size += len;\n   }\n \n-  private int put4 (int i) throws IOException\n+  /**\n+   * Finishes the stream.  This will write the central directory at the\n+   * end of the zip file and flush the stream.\n+   * @exception IOException if an I/O error occured.\n+   */\n+  public void finish() throws IOException\n   {\n-    out.write (i);\n-    out.write (i >> 8);\n-    out.write (i >> 16);\n-    out.write (i >> 24);\n-    return 4;\n-  }\n+    if (entries == null)\n+      return;\n+    if (curEntry != null)\n+      closeEntry();\n+\n+    int numEntries = 0;\n+    int sizeEntries = 0;\n+    \n+    Enumeration enum = entries.elements();\n+    while (enum.hasMoreElements())\n+      {\n+\tZipEntry entry = (ZipEntry) enum.nextElement();\n+\t\n+\tint method = entry.getMethod();\n+\twriteLeInt(CENSIG);\n+\twriteLeShort(method == STORED\n+\t\t     ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);\n+\twriteLeShort(method == STORED\n+\t\t     ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);\n+\twriteLeShort(entry.flags);\n+\twriteLeShort(method);\n+\twriteLeInt(entry.getDOSTime());\n+\twriteLeInt((int)entry.getCrc());\n+\twriteLeInt((int)entry.getCompressedSize());\n+\twriteLeInt((int)entry.getSize());\n+\n+\tbyte[] name = entry.getName().getBytes();\n+\tif (name.length > 0xffff)\n+\t  throw new ZipException(\"Name too long.\");\n+\tbyte[] extra = entry.getExtra();\n+\tif (extra == null)\n+\t  extra = new byte[0];\n+\tString strComment = entry.getComment();\n+\tbyte[] comment = strComment != null\n+\t  ? strComment.getBytes() : new byte[0];\n+\tif (comment.length > 0xffff)\n+\t  throw new ZipException(\"Comment too long.\");\n+\n+\twriteLeShort(name.length);\n+\twriteLeShort(extra.length);\n+\twriteLeShort(comment.length);\n+\twriteLeShort(0); /* disk number */\n+\twriteLeShort(0); /* internal file attr */\n+\twriteLeInt(0);   /* external file attr */\n+\twriteLeInt(entry.offset);\n+\n+\tout.write(name);\n+\tout.write(extra);\n+\tout.write(comment);\n+\tnumEntries++;\n+\tsizeEntries += CENHDR + name.length + extra.length + comment.length;\n+      }\n \n-  private int put_version () throws IOException\n-  {\n-    // FIXME: for now we assume Unix, and we ignore the version\n-    // number.\n-    return put2 (3 << 8);\n+    writeLeInt(ENDSIG);\n+    writeLeShort(0); /* disk number */\n+    writeLeShort(0); /* disk with start of central dir */\n+    writeLeShort(numEntries);\n+    writeLeShort(numEntries);\n+    writeLeInt(sizeEntries);\n+    writeLeInt(offset);\n+    writeLeShort(zipComment.length);\n+    out.write(zipComment);\n+    out.flush();\n+    entries = null;\n   }\n-\n-  // The entry we are currently writing, or null if we've called\n-  // closeEntry.\n-  private ZipEntry current;\n-  // The chain of entries which have been written to this file.\n-  private ZipEntry chain;\n-\n-  private int method = DEFLATED;\n-  private int level = Deflater.DEFAULT_COMPRESSION;\n-  private String comment = \"\";\n-  private long bytes_written;\n-\n-  private int uncompressed_size;\n-\n-  /** The checksum object. */\n-  private Checksum sum;\n }"}, {"sha": "0941143954132505b3336eab562012c1e92cbdb6", "filename": "libjava/java/util/zip/natDeflater.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FnatDeflater.cc?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,6 +1,6 @@\n // natDeflater.cc - Implementation of Deflater native methods.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+/* Copyright (C) 1999, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -125,6 +125,7 @@ java::util::zip::Deflater::reset ()\n   // Just ignore errors.\n   deflateReset (s);\n   flush_flag = 0;\n+  is_finished = false;\n }\n \n void"}, {"sha": "0568b5e85d3f26fda328b454b4458cf7b05ae0a8", "filename": "libjava/java/util/zip/natInflater.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f51b048fbb02d1c6fe31c4508dc142653b3cac8/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FnatInflater.cc?ref=5f51b048fbb02d1c6fe31c4508dc142653b3cac8", "patch": "@@ -1,6 +1,6 @@\n // natInflater.cc - Implementation of Inflater native methods.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+/* Copyright (C) 1999, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -149,6 +149,8 @@ java::util::zip::Inflater::reset ()\n   z_streamp s = (z_streamp) zstream;\n   // Just ignore errors.\n   inflateReset (s);\n+  is_finished = false;\n+  dict_needed = false;\n }\n \n void"}]}