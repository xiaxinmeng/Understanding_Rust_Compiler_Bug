{"sha": "68435eb293a6b9c161936bccab66e4b1f702372b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg0MzVlYjI5M2E2YjljMTYxOTM2YmNjYWI2NmU0YjFmNzAyMzcyYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-05-16T13:08:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-05-16T13:08:04Z"}, "message": "tree-vectorizer.h (struct stmt_info_for_cost): Add where member.\n\n2018-05-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct stmt_info_for_cost): Add where member.\n\t(dump_stmt_cost): Declare.\n\t(add_stmt_cost): Dump cost we add.\n\t(add_stmt_costs): New function.\n\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n\tNo longer exported.\n\t(vect_analyze_stmt): Adjust prototype.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t(vectorizable_induction): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Create local\n\tcost vector to pass to vectorizable_ and record afterwards.\n\t(vect_model_reduction_cost): Take cost vector argument and adjust.\n\t(vect_model_induction_cost): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n\tSLP_TREE_NUMBER_OF_VEC_STMTS.\n\t(vect_analyze_slp_cost_1): Remove.\n\t(vect_analyze_slp_cost): Likewise.\n\t(vect_slp_analyze_node_operations): Take visited args and\n\ta target cost vector.  Avoid processing already visited stmt sets.\n\t(vect_slp_analyze_operations): Use a local cost vector to gather\n\tcosts and register those of non-discarded instances.\n\t(vect_bb_vectorization_profitable_p): Use add_stmt_costs.\n\t(vect_schedule_slp_instance): Remove copying of\n\tSLP_TREE_NUMBER_OF_VEC_STMTS.  Instead assert that it is not\n\tzero.\n\t* tree-vect-stmts.c (record_stmt_cost): Remove path directly\n\tadding cost.  Record cost entry location.\n\t(vect_prologue_cost_for_slp_op): Function to compute cost of\n\ta constant or invariant generated for SLP vect in the prologue,\n\tsplit out from vect_analyze_slp_cost_1.\n\t(vect_model_simple_cost): Make static.  Adjust for SLP costing.\n\t(vect_model_promotion_demotion_cost): Likewise.\n\t(vect_model_store_cost): Likewise, make static.\n\t(vect_model_load_cost): Likewise.\n\t(vectorizable_bswap): Add cost vector arg and adjust.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\t(can_vectorize_live_stmts): Likewise.\n\t(vect_analyze_stmt): Likewise.\n\t(vect_transform_stmt): Adjust calls to vectorizable_*.\n\t* tree-vectorizer.c: Include gimple-pretty-print.h.\n\t(dump_stmt_cost): New function.\n\nFrom-SVN: r260289", "tree": {"sha": "cc78ecc836cfbaccc33a2703cd1f0d2486754a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc78ecc836cfbaccc33a2703cd1f0d2486754a71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68435eb293a6b9c161936bccab66e4b1f702372b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68435eb293a6b9c161936bccab66e4b1f702372b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68435eb293a6b9c161936bccab66e4b1f702372b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68435eb293a6b9c161936bccab66e4b1f702372b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311eb8168ea83b8b7ce76735fee8c594cda5a0e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/311eb8168ea83b8b7ce76735fee8c594cda5a0e0"}], "stats": {"total": 1169, "additions": 611, "deletions": 558}, "files": [{"sha": "7043c34428a7a2f10e00f10e3376dc50e1018fd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -1,3 +1,61 @@\n+2018-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct stmt_info_for_cost): Add where member.\n+\t(dump_stmt_cost): Declare.\n+\t(add_stmt_cost): Dump cost we add.\n+\t(add_stmt_costs): New function.\n+\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n+\tNo longer exported.\n+\t(vect_analyze_stmt): Adjust prototype.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Create local\n+\tcost vector to pass to vectorizable_ and record afterwards.\n+\t(vect_model_reduction_cost): Take cost vector argument and adjust.\n+\t(vect_model_induction_cost): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Initialize\n+\tSLP_TREE_NUMBER_OF_VEC_STMTS.\n+\t(vect_analyze_slp_cost_1): Remove.\n+\t(vect_analyze_slp_cost): Likewise.\n+\t(vect_slp_analyze_node_operations): Take visited args and\n+\ta target cost vector.  Avoid processing already visited stmt sets.\n+\t(vect_slp_analyze_operations): Use a local cost vector to gather\n+\tcosts and register those of non-discarded instances.\n+\t(vect_bb_vectorization_profitable_p): Use add_stmt_costs.\n+\t(vect_schedule_slp_instance): Remove copying of\n+\tSLP_TREE_NUMBER_OF_VEC_STMTS.  Instead assert that it is not\n+\tzero.\n+\t* tree-vect-stmts.c (record_stmt_cost): Remove path directly\n+\tadding cost.  Record cost entry location.\n+\t(vect_prologue_cost_for_slp_op): Function to compute cost of\n+\ta constant or invariant generated for SLP vect in the prologue,\n+\tsplit out from vect_analyze_slp_cost_1.\n+\t(vect_model_simple_cost): Make static.  Adjust for SLP costing.\n+\t(vect_model_promotion_demotion_cost): Likewise.\n+\t(vect_model_store_cost): Likewise, make static.\n+\t(vect_model_load_cost): Likewise.\n+\t(vectorizable_bswap): Add cost vector arg and adjust.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\t(can_vectorize_live_stmts): Likewise.\n+\t(vect_analyze_stmt): Likewise.\n+\t(vect_transform_stmt): Adjust calls to vectorizable_*.\n+\t* tree-vectorizer.c: Include gimple-pretty-print.h.\n+\t(dump_stmt_cost): New function.\n+\n 2018-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* params.def (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE): New param."}, {"sha": "00db49d691657ec905a94f18604e8637a654c5fe", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 79, "deletions": 73, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -1528,6 +1528,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_analyze_loop_operations ===\\n\");\n \n+  stmt_vector_for_cost cost_vec;\n+  cost_vec.create (2);\n+\n   for (i = 0; i < nbbs; i++)\n     {\n       basic_block bb = bbs[i];\n@@ -1613,18 +1616,20 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n               need_to_vectorize = true;\n               if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n \t\t  && ! PURE_SLP_STMT (stmt_info))\n-                ok = vectorizable_induction (phi, NULL, NULL, NULL);\n+                ok = vectorizable_induction (phi, NULL, NULL, NULL, &cost_vec);\n \t      else if ((STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n \t\t\t|| STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n \t\t       && ! PURE_SLP_STMT (stmt_info))\n-\t\tok = vectorizable_reduction (phi, NULL, NULL, NULL, NULL);\n+\t\tok = vectorizable_reduction (phi, NULL, NULL, NULL, NULL,\n+\t\t\t\t\t     &cost_vec);\n             }\n \n \t  /* SLP PHIs are tested by vect_slp_analyze_node_operations.  */\n \t  if (ok\n \t      && STMT_VINFO_LIVE_P (stmt_info)\n \t      && !PURE_SLP_STMT (stmt_info))\n-\t    ok = vectorizable_live_operation (phi, NULL, NULL, -1, NULL);\n+\t    ok = vectorizable_live_operation (phi, NULL, NULL, -1, NULL,\n+\t\t\t\t\t      &cost_vec);\n \n           if (!ok)\n             {\n@@ -1644,11 +1649,15 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n         {\n \t  gimple *stmt = gsi_stmt (si);\n \t  if (!gimple_clobber_p (stmt)\n-\t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL, NULL))\n+\t      && !vect_analyze_stmt (stmt, &need_to_vectorize, NULL, NULL,\n+\t\t\t\t     &cost_vec))\n \t    return false;\n         }\n     } /* bbs */\n \n+  add_stmt_costs (loop_vinfo->target_cost_data, &cost_vec);\n+  cost_vec.release ();\n+\n   /* All operations in the loop are either irrelevant (deal with loop\n      control, or dead), or only used outside the loop and can be moved\n      out of the loop (e.g. invariants, inductions).  The loop can be\n@@ -3840,7 +3849,7 @@ have_whole_vector_shift (machine_mode mode)\n \n static void\n vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n-\t\t\t   int ncopies)\n+\t\t\t   int ncopies, stmt_vector_for_cost *cost_vec)\n {\n   int prologue_cost = 0, epilogue_cost = 0, inside_cost;\n   enum tree_code code;\n@@ -3850,15 +3859,9 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n   machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n-  void *target_cost_data;\n \n   if (loop_vinfo)\n-    {\n-      loop = LOOP_VINFO_LOOP (loop_vinfo);\n-      target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-    }\n-  else\n-    target_cost_data = BB_VINFO_TARGET_COST_DATA (STMT_VINFO_BB_VINFO (stmt_info));\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Condition reductions generate two reductions in the loop.  */\n   vect_reduction_type reduction_type\n@@ -3883,18 +3886,18 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \n       if (reduction_type == EXTRACT_LAST_REDUCTION || reduc_fn != IFN_LAST)\n \t/* Count one reduction-like operation per vector.  */\n-\tinside_cost = add_stmt_cost (target_cost_data, ncopies, vec_to_scalar,\n-\t\t\t\t     stmt_info, 0, vect_body);\n+\tinside_cost = record_stmt_cost (cost_vec, ncopies, vec_to_scalar,\n+\t\t\t\t\tstmt_info, 0, vect_body);\n       else\n \t{\n \t  /* Use NELEMENTS extracts and NELEMENTS scalar ops.  */\n \t  unsigned int nelements = ncopies * vect_nunits_for_cost (vectype);\n-\t  inside_cost = add_stmt_cost (target_cost_data,  nelements,\n-\t\t\t\t       vec_to_scalar, stmt_info, 0,\n-\t\t\t\t       vect_body);\n-\t  inside_cost += add_stmt_cost (target_cost_data,  nelements,\n-\t\t\t\t\tscalar_stmt, stmt_info, 0,\n-\t\t\t\t\tvect_body);\n+\t  inside_cost = record_stmt_cost (cost_vec, nelements,\n+\t\t\t\t\t  vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t  vect_body);\n+\t  inside_cost += record_stmt_cost (cost_vec, nelements,\n+\t\t\t\t\t   scalar_stmt, stmt_info, 0,\n+\t\t\t\t\t   vect_body);\n \t}\n     }\n   else\n@@ -3904,13 +3907,13 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t initial result of the data reduction, initial value of the index\n \t reduction.  */\n       int prologue_stmts = reduction_type == COND_REDUCTION ? 4 : 1;\n-      prologue_cost += add_stmt_cost (target_cost_data, prologue_stmts,\n-\t\t\t\t      scalar_to_vec, stmt_info, 0,\n-\t\t\t\t      vect_prologue);\n+      prologue_cost += record_stmt_cost (cost_vec, prologue_stmts,\n+\t\t\t\t\t scalar_to_vec, stmt_info, 0,\n+\t\t\t\t\t vect_prologue);\n \n       /* Cost of reduction op inside loop.  */\n-      inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n-\t\t\t\t   stmt_info, 0, vect_body);\n+      inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t      stmt_info, 0, vect_body);\n     }\n \n   /* Determine cost of epilogue code.\n@@ -3925,41 +3928,41 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t  if (reduction_type == COND_REDUCTION)\n \t    {\n \t      /* An EQ stmt and an COND_EXPR stmt.  */\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 2,\n-\t\t\t\t\t      vector_stmt, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 2,\n+\t\t\t\t\t\t vector_stmt, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n \t      /* Reduction of the max index and a reduction of the found\n \t\t values.  */\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 2,\n-\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 2,\n+\t\t\t\t\t\t vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n \t      /* A broadcast of the max value.  */\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n-\t\t\t\t\t      scalar_to_vec, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 1,\n+\t\t\t\t\t\t scalar_to_vec, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n \t    }\n \t  else\n \t    {\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n-\t\t\t\t\t      stmt_info, 0, vect_epilogue);\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n-\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 1, vector_stmt,\n+\t\t\t\t\t\t stmt_info, 0, vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 1,\n+\t\t\t\t\t\t vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n \t    }\n \t}\n       else if (reduction_type == COND_REDUCTION)\n \t{\n \t  unsigned estimated_nunits = vect_nunits_for_cost (vectype);\n \t  /* Extraction of scalar elements.  */\n-\t  epilogue_cost += add_stmt_cost (target_cost_data,\n-\t\t\t\t\t  2 * estimated_nunits,\n-\t\t\t\t\t  vec_to_scalar, stmt_info, 0,\n-\t\t\t\t\t  vect_epilogue);\n+\t  epilogue_cost += record_stmt_cost (cost_vec,\n+\t\t\t\t\t     2 * estimated_nunits,\n+\t\t\t\t\t     vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t     vect_epilogue);\n \t  /* Scalar max reductions via COND_EXPR / MAX_EXPR.  */\n-\t  epilogue_cost += add_stmt_cost (target_cost_data,\n-\t\t\t\t\t  2 * estimated_nunits - 3,\n-\t\t\t\t\t  scalar_stmt, stmt_info, 0,\n-\t\t\t\t\t  vect_epilogue);\n+\t  epilogue_cost += record_stmt_cost (cost_vec,\n+\t\t\t\t\t     2 * estimated_nunits - 3,\n+\t\t\t\t\t     scalar_stmt, stmt_info, 0,\n+\t\t\t\t\t     vect_epilogue);\n \t}\n       else if (reduction_type == EXTRACT_LAST_REDUCTION\n \t       || reduction_type == FOLD_LEFT_REDUCTION)\n@@ -3986,21 +3989,21 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t    {\n \t      /* Final reduction via vector shifts and the reduction operator.\n \t\t Also requires scalar extract.  */\n-\t      epilogue_cost += add_stmt_cost (target_cost_data,\n-\t\t\t\t\t      exact_log2 (nelements) * 2,\n-\t\t\t\t\t      vector_stmt, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n-\t      epilogue_cost += add_stmt_cost (target_cost_data, 1,\n-\t\t\t\t\t      vec_to_scalar, stmt_info, 0,\n-\t\t\t\t\t      vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec,\n+\t\t\t\t\t\t exact_log2 (nelements) * 2,\n+\t\t\t\t\t\t vector_stmt, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n+\t      epilogue_cost += record_stmt_cost (cost_vec, 1,\n+\t\t\t\t\t\t vec_to_scalar, stmt_info, 0,\n+\t\t\t\t\t\t vect_epilogue);\n \t    }\t  \n \t  else\n \t    /* Use extracts and reduction op for final reduction.  For N\n \t       elements, we have N extracts and N-1 reduction ops.  */\n-\t    epilogue_cost += add_stmt_cost (target_cost_data, \n-\t\t\t\t\t    nelements + nelements - 1,\n-\t\t\t\t\t    vector_stmt, stmt_info, 0,\n-\t\t\t\t\t    vect_epilogue);\n+\t    epilogue_cost += record_stmt_cost (cost_vec, \n+\t\t\t\t\t       nelements + nelements - 1,\n+\t\t\t\t\t       vector_stmt, stmt_info, 0,\n+\t\t\t\t\t       vect_epilogue);\n \t}\n     }\n \n@@ -4017,22 +4020,21 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n    Models cost for induction operations.  */\n \n static void\n-vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n+vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n+\t\t\t   stmt_vector_for_cost *cost_vec)\n {\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n   unsigned inside_cost, prologue_cost;\n \n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n   /* loop cost for vec_loop.  */\n-  inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n-\t\t\t       stmt_info, 0, vect_body);\n+  inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t  stmt_info, 0, vect_body);\n \n   /* prologue cost for vec_init and vec_step.  */\n-  prologue_cost = add_stmt_cost (target_cost_data, 2, scalar_to_vec,\n-\t\t\t\t stmt_info, 0, vect_prologue);\n+  prologue_cost = record_stmt_cost (cost_vec, 2, scalar_to_vec,\n+\t\t\t\t    stmt_info, 0, vect_prologue);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -6124,7 +6126,8 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n bool\n vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\tgimple **vec_stmt, slp_tree slp_node,\n-\t\t\tslp_instance slp_node_instance)\n+\t\t\tslp_instance slp_node_instance,\n+\t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -6633,7 +6636,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* Only call during the analysis stage, otherwise we'll lose\n \t STMT_VINFO_TYPE.  */\n       if (!vec_stmt && !vectorizable_condition (stmt, gsi, NULL,\n-\t\t\t\t\t\tops[reduc_index], 0, NULL))\n+\t\t\t\t\t\tops[reduc_index], 0, NULL,\n+\t\t\t\t\t\tcost_vec))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -7055,7 +7059,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       if (first_p)\n-\tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies);\n+\tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies, cost_vec);\n       if (loop_vinfo && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \t{\n \t  if (reduction_type != FOLD_LEFT_REDUCTION\n@@ -7109,7 +7113,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       gcc_assert (!slp_node);\n       return vectorizable_condition (stmt, gsi, vec_stmt,\n-\t\t\t\t     NULL, reduc_index, NULL);\n+\t\t\t\t     NULL, reduc_index, NULL, NULL);\n     }\n \n   /* Create the destination vector  */\n@@ -7142,7 +7146,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n           gcc_assert (!slp_node);\n           vectorizable_condition (stmt, gsi, vec_stmt, \n                                   PHI_RESULT (phis[0]), \n-                                  reduc_index, NULL);\n+                                  reduc_index, NULL, NULL);\n           /* Multiple types are not supported for condition.  */\n           break;\n         }\n@@ -7327,7 +7331,8 @@ vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n bool\n vectorizable_induction (gimple *phi,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node)\n+\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tstmt_vector_for_cost *cost_vec)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -7448,7 +7453,7 @@ vectorizable_induction (gimple *phi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_induction ===\\n\");\n-      vect_model_induction_cost (stmt_info, ncopies);\n+      vect_model_induction_cost (stmt_info, ncopies, cost_vec);\n       return true;\n     }\n \n@@ -7882,7 +7887,8 @@ bool\n vectorizable_live_operation (gimple *stmt,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t\t\t     slp_tree slp_node, int slp_index,\n-\t\t\t     gimple **vec_stmt)\n+\t\t\t     gimple **vec_stmt,\n+\t\t\t     stmt_vector_for_cost *)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);"}, {"sha": "ff59c4ceecc81e1ca48d670fb3bf597addb0fce2", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 47, "deletions": 308, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -112,6 +112,7 @@ vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n   node = XNEW (struct _slp_tree);\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n   SLP_TREE_VEC_STMTS (node).create (0);\n+  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n   SLP_TREE_CHILDREN (node).create (nops);\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n   SLP_TREE_TWO_OPERATORS (node) = false;\n@@ -1084,6 +1085,10 @@ bst_traits::equal (value_type existing, value_type candidate)\n typedef hash_set <vec <gimple *>, bst_traits> scalar_stmts_set_t;\n static scalar_stmts_set_t *bst_fail;\n \n+typedef hash_map <vec <gimple *>, slp_tree,\n+\t\t  simple_hashmap_traits <bst_traits, slp_tree> >\n+  scalar_stmts_to_slp_tree_map_t;\n+\n static slp_tree\n vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n@@ -1819,285 +1824,6 @@ vect_find_last_scalar_stmt_in_slp (slp_tree node)\n   return last;\n }\n \n-/* Compute the cost for the SLP node NODE in the SLP instance INSTANCE.  */\n-\n-static void\n-vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n-\t\t\t stmt_vector_for_cost *prologue_cost_vec,\n-\t\t\t stmt_vector_for_cost *body_cost_vec,\n-\t\t\t unsigned ncopies_for_cost,\n-\t\t\t scalar_stmts_set_t* visited)\n-{\n-  unsigned i, j;\n-  slp_tree child;\n-  gimple *stmt;\n-  stmt_vec_info stmt_info;\n-  tree lhs;\n-\n-  /* If we already costed the exact same set of scalar stmts we're done.\n-     We share the generated vector stmts for those.  */\n-  if (visited->contains (SLP_TREE_SCALAR_STMTS (node)))\n-    return;\n-\n-  visited->add (SLP_TREE_SCALAR_STMTS (node).copy ());\n-\n-  /* Recurse down the SLP tree.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n-      vect_analyze_slp_cost_1 (instance, child, prologue_cost_vec,\n-\t\t\t       body_cost_vec, ncopies_for_cost, visited);\n-\n-  /* Look at the first scalar stmt to determine the cost.  */\n-  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  stmt_info = vinfo_for_stmt (stmt);\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      vect_memory_access_type memory_access_type\n-\t= (STMT_VINFO_STRIDED_P (stmt_info)\n-\t   ? VMAT_STRIDED_SLP\n-\t   : VMAT_CONTIGUOUS);\n-      if (DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n-\tvect_model_store_cost (stmt_info, ncopies_for_cost,\n-\t\t\t       memory_access_type, VLS_STORE,\n-\t\t\t       node, prologue_cost_vec, body_cost_vec);\n-      else\n-\t{\n-\t  gcc_checking_assert (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)));\n-\t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\t    {\n-\t      /* If the load is permuted then the alignment is determined by\n-\t\t the first group element not by the first scalar stmt DR.  */\n-\t      stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-\t      stmt_info = vinfo_for_stmt (stmt);\n-\t      /* Record the cost for the permutation.  */\n-\t      unsigned n_perms;\n-\t      vect_transform_slp_perm_load (node, vNULL, NULL,\n-\t\t\t\t\t    ncopies_for_cost, instance, true,\n-\t\t\t\t\t    &n_perms);\n-\t      record_stmt_cost (body_cost_vec, n_perms, vec_perm,\n-\t\t\t\tstmt_info, 0, vect_body);\n-\t      unsigned assumed_nunits\n-\t\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (stmt_info));\n-\t      /* And adjust the number of loads performed.  This handles\n-\t         redundancies as well as loads that are later dead.  */\n-\t      auto_sbitmap perm (GROUP_SIZE (stmt_info));\n-\t      bitmap_clear (perm);\n-\t      for (i = 0; i < SLP_TREE_LOAD_PERMUTATION (node).length (); ++i)\n-\t\tbitmap_set_bit (perm, SLP_TREE_LOAD_PERMUTATION (node)[i]);\n-\t      ncopies_for_cost = 0;\n-\t      bool load_seen = false;\n-\t      for (i = 0; i < GROUP_SIZE (stmt_info); ++i)\n-\t\t{\n-\t\t  if (i % assumed_nunits == 0)\n-\t\t    {\n-\t\t      if (load_seen)\n-\t\t\tncopies_for_cost++;\n-\t\t      load_seen = false;\n-\t\t    }\n-\t\t  if (bitmap_bit_p (perm, i))\n-\t\t    load_seen = true;\n-\t\t}\n-\t      if (load_seen)\n-\t\tncopies_for_cost++;\n-\t      gcc_assert (ncopies_for_cost\n-\t\t\t  <= (GROUP_SIZE (stmt_info) - GROUP_GAP (stmt_info)\n-\t\t\t      + assumed_nunits - 1) / assumed_nunits);\n-\t      poly_uint64 uf = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n-\t      ncopies_for_cost *= estimated_poly_value (uf);\n-\t    }\n-\t  /* Record the cost for the vector loads.  */\n-\t  vect_model_load_cost (stmt_info, ncopies_for_cost,\n-\t\t\t\tmemory_access_type, node, prologue_cost_vec,\n-\t\t\t\tbody_cost_vec);\n-\t  return;\n-\t}\n-    }\n-  else if (STMT_VINFO_TYPE (stmt_info) == induc_vec_info_type)\n-    {\n-      /* ncopies_for_cost is the number of IVs we generate.  */\n-      record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n-\t\t\tstmt_info, 0, vect_body);\n-\n-      /* Prologue cost for the initial values and step vector.  */\n-      record_stmt_cost (prologue_cost_vec, ncopies_for_cost,\n-\t\t\tCONSTANT_CLASS_P\n-\t\t\t  (STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED\n-\t\t\t     (stmt_info))\n-\t\t\t? vector_load : vec_construct,\n-\t\t\tstmt_info, 0, vect_prologue);\n-      record_stmt_cost (prologue_cost_vec, 1,\n-\t\t\tCONSTANT_CLASS_P\n-\t\t\t  (STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info))\n-\t\t\t? vector_load : vec_construct,\n-\t\t\tstmt_info, 0, vect_prologue);\n-      \n-      /* ???  No easy way to get at the actual number of vector stmts\n-         to be geneated and thus the derived IVs.  */\n-    }\n-  else\n-    {\n-      record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n-\t\t\tstmt_info, 0, vect_body);\n-      if (SLP_TREE_TWO_OPERATORS (node))\n-\t{\n-\t  record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n-\t\t\t    stmt_info, 0, vect_body);\n-\t  record_stmt_cost (body_cost_vec, ncopies_for_cost, vec_perm,\n-\t\t\t    stmt_info, 0, vect_body);\n-\t}\n-    }\n-\n-  /* Push SLP node def-type to stmts.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n-\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = SLP_TREE_DEF_TYPE (child);\n-\n-  /* Scan operands and account for prologue cost of constants/externals.\n-     ???  This over-estimates cost for multiple uses and should be\n-     re-engineered.  */\n-  stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-  lhs = gimple_get_lhs (stmt);\n-  for (i = 0; i < gimple_num_ops (stmt); ++i)\n-    {\n-      tree op = gimple_op (stmt, i);\n-      gimple *def_stmt;\n-      enum vect_def_type dt;\n-      if (!op || op == lhs)\n-\tcontinue;\n-      if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt)\n-\t  && (dt == vect_constant_def || dt == vect_external_def))\n-\t{\n-\t  /* Without looking at the actual initializer a vector of\n-\t     constants can be implemented as load from the constant pool.\n-\t     When all elements are the same we can use a splat.  */\n-\t  tree vectype = get_vectype_for_scalar_type (TREE_TYPE (op));\n-\t  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n-\t  unsigned num_vects_to_check;\n-\t  unsigned HOST_WIDE_INT const_nunits;\n-\t  unsigned nelt_limit;\n-\t  if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n-\t      && ! multiple_p (const_nunits, group_size))\n-\t    {\n-\t      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n-\t      nelt_limit = const_nunits;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If either the vector has variable length or the vectors\n-\t         are composed of repeated whole groups we only need to\n-\t\t cost construction once.  All vectors will be the same.  */\n-\t      num_vects_to_check = 1;\n-\t      nelt_limit = group_size;\n-\t    }\n-\t  tree elt = NULL_TREE;\n-\t  unsigned nelt = 0;\n-\t  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n-\t    {\n-\t      unsigned si = j % group_size;\n-\t      if (nelt == 0)\n-\t\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], i);\n-\t      /* ???  We're just tracking whether all operands of a single\n-\t\t vector initializer are the same, ideally we'd check if\n-\t\t we emitted the same one already.  */\n-\t      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], i))\n-\t\telt = NULL_TREE;\n-\t      nelt++;\n-\t      if (nelt == nelt_limit)\n-\t\t{\n-\t\t  /* ???  We need to pass down stmt_info for a vector type\n-\t\t     even if it points to the wrong stmt.  */\n-\t\t  record_stmt_cost (prologue_cost_vec, 1,\n-\t\t\t\t    dt == vect_external_def\n-\t\t\t\t    ? (elt ? scalar_to_vec : vec_construct)\n-\t\t\t\t    : vector_load,\n-\t\t\t\t    stmt_info, 0, vect_prologue);\n-\t\t  nelt = 0;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Restore stmt def-types.  */\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (child), j, stmt)\n-\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) = vect_internal_def;\n-}\n-\n-/* Compute the cost for the SLP instance INSTANCE.  */\n-\n-static void\n-vect_analyze_slp_cost (slp_instance instance, void *data, scalar_stmts_set_t *visited)\n-{\n-  stmt_vector_for_cost body_cost_vec, prologue_cost_vec;\n-  unsigned ncopies_for_cost;\n-  stmt_info_for_cost *si;\n-  unsigned i;\n-\n-  /* Calculate the number of vector stmts to create based on the unrolling\n-     factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n-     GROUP_SIZE / NUNITS otherwise.  */\n-  unsigned group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n-  slp_tree node = SLP_INSTANCE_TREE (instance);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n-  /* Get the estimated vectorization factor, which is always one for\n-     basic-block vectorization.  */\n-  unsigned int assumed_vf;\n-  if (STMT_VINFO_LOOP_VINFO (stmt_info))\n-    assumed_vf = vect_vf_for_cost (STMT_VINFO_LOOP_VINFO (stmt_info));\n-  else\n-    assumed_vf = 1;\n-  /* For reductions look at a reduction operand in case the reduction\n-     operation is widening like DOT_PROD or SAD.  */\n-  tree vectype_for_cost = STMT_VINFO_VECTYPE (stmt_info);\n-  if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n-      switch (gimple_assign_rhs_code (stmt))\n-\t{\n-\tcase DOT_PROD_EXPR:\n-\tcase SAD_EXPR:\n-\t  vectype_for_cost = get_vectype_for_scalar_type\n-\t    (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n-\t  break;\n-\tdefault:;\n-\t}\n-    }\n-  unsigned int assumed_nunits = vect_nunits_for_cost (vectype_for_cost);\n-  ncopies_for_cost = (least_common_multiple (assumed_nunits,\n-\t\t\t\t\t     group_size * assumed_vf)\n-\t\t      / assumed_nunits);\n-\n-  prologue_cost_vec.create (10);\n-  body_cost_vec.create (10);\n-  vect_analyze_slp_cost_1 (instance, SLP_INSTANCE_TREE (instance),\n-\t\t\t   &prologue_cost_vec, &body_cost_vec,\n-\t\t\t   ncopies_for_cost, visited);\n-\n-  /* Record the prologue costs, which were delayed until we were\n-     sure that SLP was successful.  */\n-  FOR_EACH_VEC_ELT (prologue_cost_vec, i, si)\n-    {\n-      struct _stmt_vec_info *stmt_info\n-\t= si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n-      (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n-\t\t\t    si->misalign, vect_prologue);\n-    }\n-\n-  /* Record the instance's instructions in the target cost model.  */\n-  FOR_EACH_VEC_ELT (body_cost_vec, i, si)\n-    {\n-      struct _stmt_vec_info *stmt_info\n-\t= si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n-      (void) add_stmt_cost (data, si->count, si->kind, stmt_info,\n-\t\t\t    si->misalign, vect_body);\n-    }\n-\n-  prologue_cost_vec.release ();\n-  body_cost_vec.release ();\n-}\n-\n /* Splits a group of stores, currently beginning at FIRST_STMT, into two groups:\n    one (still beginning at FIRST_STMT) of size GROUP1_SIZE (also containing\n    the first GROUP1_SIZE stmts, since stores are consecutive), the second\n@@ -2758,7 +2484,10 @@ _bb_vec_info::~_bb_vec_info ()\n \n static bool\n vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n-\t\t\t\t  slp_instance node_instance)\n+\t\t\t\t  slp_instance node_instance,\n+\t\t\t\t  scalar_stmts_to_slp_tree_map_t *visited,\n+\t\t\t\t  scalar_stmts_to_slp_tree_map_t *lvisited,\n+\t\t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   bool dummy;\n   int i, j;\n@@ -2768,8 +2497,25 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return true;\n \n+  /* If we already analyzed the exact same set of scalar stmts we're done.\n+     We share the generated vector stmts for those.  */\n+  slp_tree *leader;\n+  if ((leader = visited->get (SLP_TREE_SCALAR_STMTS (node)))\n+      || (leader = lvisited->get (SLP_TREE_SCALAR_STMTS (node))))\n+    {\n+      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n+\t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n+      return true;\n+    }\n+\n+  /* The SLP graph is acyclic so not caching whether we failed or succeeded\n+     doesn't result in any issue since we throw away the lvisited set\n+     when we fail.  */\n+  lvisited->put (SLP_TREE_SCALAR_STMTS (node).copy (), node);\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    if (!vect_slp_analyze_node_operations (vinfo, child, node_instance))\n+    if (!vect_slp_analyze_node_operations (vinfo, child, node_instance,\n+\t\t\t\t\t   visited, lvisited, cost_vec))\n       return false;\n \n   stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n@@ -2831,7 +2577,7 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n       STMT_VINFO_DEF_TYPE (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (child)[0]))\n \t= SLP_TREE_DEF_TYPE (child);\n-  bool res = vect_analyze_stmt (stmt, &dummy, node, node_instance);\n+  bool res = vect_analyze_stmt (stmt, &dummy, node, node_instance, cost_vec);\n   /* Restore def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n     if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n@@ -2857,11 +2603,17 @@ vect_slp_analyze_operations (vec_info *vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_slp_analyze_operations ===\\n\");\n \n+  scalar_stmts_to_slp_tree_map_t *visited\n+    = new scalar_stmts_to_slp_tree_map_t ();\n   for (i = 0; vinfo->slp_instances.iterate (i, &instance); )\n     {\n+      scalar_stmts_to_slp_tree_map_t lvisited;\n+      stmt_vector_for_cost cost_vec;\n+      cost_vec.create (2);\n       if (!vect_slp_analyze_node_operations (vinfo,\n \t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n-\t\t\t\t\t     instance))\n+\t\t\t\t\t     instance, visited, &lvisited,\n+\t\t\t\t\t     &cost_vec))\n         {\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"removing SLP instance operations starting from: \");\n@@ -2870,19 +2622,19 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n \t  vect_free_slp_instance (instance);\n           vinfo->slp_instances.ordered_remove (i);\n+\t  cost_vec.release ();\n \t}\n       else\n-\ti++;\n-    }\n-\n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_slp_cost ===\\n\");\n+\t{\n+\t  for (scalar_stmts_to_slp_tree_map_t::iterator x = lvisited.begin();\n+\t       x != lvisited.end(); ++x)\n+\t    visited->put ((*x).first.copy (), (*x).second);\n+\t  i++;\n \n-  /* Compute the costs of the SLP instances.  */\n-  scalar_stmts_set_t *visited = new scalar_stmts_set_t ();\n-  for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n-    vect_analyze_slp_cost (instance, vinfo->target_cost_data, visited);\n+\t  add_stmt_costs (vinfo->target_cost_data, &cost_vec);\n+\t  cost_vec.release ();\n+\t}\n+    }\n   delete visited;\n \n   return !vinfo->slp_instances.is_empty ();\n@@ -2989,15 +2741,7 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n \t\t\t       &life, &scalar_costs);\n     }\n   void *target_cost_data = init_cost (NULL);\n-  stmt_info_for_cost *si;\n-  FOR_EACH_VEC_ELT (scalar_costs, i, si)\n-    {\n-      struct _stmt_vec_info *stmt_info\n-\t  = si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n-      (void) add_stmt_cost (target_cost_data, si->count,\n-\t\t\t    si->kind, stmt_info, si->misalign,\n-\t\t\t    vect_body);\n-    }\n+  add_stmt_costs (target_cost_data, &scalar_costs);\n   scalar_costs.release ();\n   unsigned dummy;\n   finish_cost (target_cost_data, &dummy, &scalar_cost, &dummy);\n@@ -4060,10 +3804,6 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   return true;\n }\n \n-typedef hash_map <vec <gimple *>, slp_tree,\n-\t\t  simple_hashmap_traits <bst_traits, slp_tree> >\n-  scalar_stmts_to_slp_tree_map_t;\n-\n /* Vectorize SLP instance tree in postorder.  */\n \n static bool\n@@ -4087,8 +3827,6 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   if (slp_tree *leader = bst_map->get (SLP_TREE_SCALAR_STMTS (node)))\n     {\n       SLP_TREE_VEC_STMTS (node).safe_splice (SLP_TREE_VEC_STMTS (*leader));\n-      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n-\t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n       return false;\n     }\n \n@@ -4110,6 +3848,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n \n+  gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n   if (!SLP_TREE_VEC_STMTS (node).exists ())\n     SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n "}, {"sha": "a90c9349735493c7c87903f921aa1490d3f9ad25", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 309, "deletions": 162, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -97,19 +97,15 @@ record_stmt_cost (stmt_vector_for_cost *body_cost_vec, int count,\n   if ((kind == vector_store || kind == unaligned_store)\n       && STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     kind = vector_scatter_store;\n-  if (body_cost_vec)\n-    {\n-      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n-      stmt_info_for_cost si = { count, kind,\n-\t\t\t        stmt_info ? STMT_VINFO_STMT (stmt_info) : NULL,\n-\t\t\t\tmisalign };\n-      body_cost_vec->safe_push (si);\n-      return (unsigned)\n-\t(builtin_vectorization_cost (kind, vectype, misalign) * count);\n-    }\n-  else\n-    return add_stmt_cost (stmt_info->vinfo->target_cost_data,\n-\t\t\t  count, kind, stmt_info, misalign, where);\n+\n+  stmt_info_for_cost si = { count, kind, where,\n+      stmt_info ? STMT_VINFO_STMT (stmt_info) : NULL,\n+      misalign };\n+  body_cost_vec->safe_push (si);\n+\n+  tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n+  return (unsigned)\n+      (builtin_vectorization_cost (kind, vectype, misalign) * count);\n }\n \n /* Return a variable of type ELEM_TYPE[NELEMS].  */\n@@ -819,37 +815,131 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Compute the prologue cost for invariant or constant operands.  */\n+\n+static unsigned\n+vect_prologue_cost_for_slp_op (slp_tree node, stmt_vec_info stmt_info,\n+\t\t\t       unsigned opno, enum vect_def_type dt,\n+\t\t\t       stmt_vector_for_cost *cost_vec)\n+{\n+  gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+  tree op = gimple_op (stmt, opno);\n+  unsigned prologue_cost = 0;\n+\n+  /* Without looking at the actual initializer a vector of\n+     constants can be implemented as load from the constant pool.\n+     When all elements are the same we can use a splat.  */\n+  tree vectype = get_vectype_for_scalar_type (TREE_TYPE (op));\n+  unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n+  unsigned num_vects_to_check;\n+  unsigned HOST_WIDE_INT const_nunits;\n+  unsigned nelt_limit;\n+  if (TYPE_VECTOR_SUBPARTS (vectype).is_constant (&const_nunits)\n+      && ! multiple_p (const_nunits, group_size))\n+    {\n+      num_vects_to_check = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+      nelt_limit = const_nunits;\n+    }\n+  else\n+    {\n+      /* If either the vector has variable length or the vectors\n+\t are composed of repeated whole groups we only need to\n+\t cost construction once.  All vectors will be the same.  */\n+      num_vects_to_check = 1;\n+      nelt_limit = group_size;\n+    }\n+  tree elt = NULL_TREE;\n+  unsigned nelt = 0;\n+  for (unsigned j = 0; j < num_vects_to_check * nelt_limit; ++j)\n+    {\n+      unsigned si = j % group_size;\n+      if (nelt == 0)\n+\telt = gimple_op (SLP_TREE_SCALAR_STMTS (node)[si], opno);\n+      /* ???  We're just tracking whether all operands of a single\n+\t vector initializer are the same, ideally we'd check if\n+\t we emitted the same one already.  */\n+      else if (elt != gimple_op (SLP_TREE_SCALAR_STMTS (node)[si],\n+\t\t\t\t opno))\n+\telt = NULL_TREE;\n+      nelt++;\n+      if (nelt == nelt_limit)\n+\t{\n+\t  /* ???  We need to pass down stmt_info for a vector type\n+\t     even if it points to the wrong stmt.  */\n+\t  prologue_cost += record_stmt_cost\n+\t      (cost_vec, 1,\n+\t       dt == vect_external_def\n+\t       ? (elt ? scalar_to_vec : vec_construct)\n+\t       : vector_load,\n+\t       stmt_info, 0, vect_prologue);\n+\t  nelt = 0;\n+\t}\n+    }\n+\n+  return prologue_cost;\n+}\n \n /* Function vect_model_simple_cost.\n \n    Models cost for simple operations, i.e. those that only emit ncopies of a\n    single op.  Right now, this does not account for multiple insns that could\n    be generated for the single vector op.  We will handle that shortly.  */\n \n-void\n+static void\n vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\tenum vect_def_type *dt,\n \t\t\tint ndts,\n-\t\t\tstmt_vector_for_cost *prologue_cost_vec,\n-\t\t\tstmt_vector_for_cost *body_cost_vec)\n+\t\t\tslp_tree node,\n+\t\t\tstmt_vector_for_cost *cost_vec)\n {\n-  int i;\n   int inside_cost = 0, prologue_cost = 0;\n \n-  /* The SLP costs were already calculated during SLP tree build.  */\n-  gcc_assert (!PURE_SLP_STMT (stmt_info));\n+  gcc_assert (cost_vec != NULL);\n \n-  /* Cost the \"broadcast\" of a scalar operand in to a vector operand.\n-     Use scalar_to_vec to cost the broadcast, as elsewhere in the vector\n-     cost model.  */\n-  for (i = 0; i < ndts; i++)\n-    if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-      prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n-\t\t\t\t\t stmt_info, 0, vect_prologue);\n+  /* ???  Somehow we need to fix this at the callers.  */\n+  if (node)\n+    ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n+\n+  if (node)\n+    {\n+      /* Scan operands and account for prologue cost of constants/externals.\n+\t ???  This over-estimates cost for multiple uses and should be\n+\t re-engineered.  */\n+      gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n+      tree lhs = gimple_get_lhs (stmt);\n+      for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n+\t{\n+\t  tree op = gimple_op (stmt, i);\n+\t  gimple *def_stmt;\n+\t  enum vect_def_type dt;\n+\t  if (!op || op == lhs)\n+\t    continue;\n+\t  if (vect_is_simple_use (op, stmt_info->vinfo, &def_stmt, &dt)\n+\t      && (dt == vect_constant_def || dt == vect_external_def))\n+\t    prologue_cost += vect_prologue_cost_for_slp_op (node, stmt_info,\n+\t\t\t\t\t\t\t    i, dt, cost_vec);\n+\t}\n+    }\n+  else\n+    /* Cost the \"broadcast\" of a scalar operand in to a vector operand.\n+       Use scalar_to_vec to cost the broadcast, as elsewhere in the vector\n+       cost model.  */\n+    for (int i = 0; i < ndts; i++)\n+      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n+\tprologue_cost += record_stmt_cost (cost_vec, 1, scalar_to_vec,\n+\t\t\t\t\t   stmt_info, 0, vect_prologue);\n+\n+  /* Adjust for two-operator SLP nodes.  */\n+  if (node && SLP_TREE_TWO_OPERATORS (node))\n+    {\n+      ncopies *= 2;\n+      inside_cost += record_stmt_cost (cost_vec, ncopies, vec_perm,\n+\t\t\t\t       stmt_info, 0, vect_body);\n+    }\n \n   /* Pass the inside-of-loop statements to the target-specific cost model.  */\n-  inside_cost = record_stmt_cost (body_cost_vec, ncopies, vector_stmt,\n-\t\t\t\t  stmt_info, 0, vect_body);\n+  inside_cost += record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t   stmt_info, 0, vect_body);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -865,36 +955,26 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n \n static void\n vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n-\t\t\t\t    enum vect_def_type *dt, int pwr)\n+\t\t\t\t    enum vect_def_type *dt, int pwr,\n+\t\t\t\t    stmt_vector_for_cost *cost_vec)\n {\n   int i, tmp;\n   int inside_cost = 0, prologue_cost = 0;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  void *target_cost_data;\n-\n-  /* The SLP costs were already calculated during SLP tree build.  */\n-  gcc_assert (!PURE_SLP_STMT (stmt_info));\n-\n-  if (loop_vinfo)\n-    target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n-  else\n-    target_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n \n   for (i = 0; i < pwr + 1; i++)\n     {\n       tmp = (STMT_VINFO_TYPE (stmt_info) == type_promotion_vec_info_type) ?\n \t(i + 1) : i;\n-      inside_cost += add_stmt_cost (target_cost_data, vect_pow2 (tmp),\n-\t\t\t\t    vec_promote_demote, stmt_info, 0,\n-\t\t\t\t    vect_body);\n+      inside_cost += record_stmt_cost (cost_vec, vect_pow2 (tmp),\n+\t\t\t\t       vec_promote_demote, stmt_info, 0,\n+\t\t\t\t       vect_body);\n     }\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-      prologue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n-\t\t\t\t      stmt_info, 0, vect_prologue);\n+      prologue_cost += record_stmt_cost (cost_vec, 1, vector_stmt,\n+\t\t\t\t\t stmt_info, 0, vect_prologue);\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -907,21 +987,31 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n    Models cost for stores.  In the case of grouped accesses, one access\n    has the overhead of the grouped access attributed to it.  */\n \n-void\n+static void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n+\t\t       enum vect_def_type dt,\n \t\t       vect_memory_access_type memory_access_type,\n \t\t       vec_load_store_type vls_type, slp_tree slp_node,\n-\t\t       stmt_vector_for_cost *prologue_cost_vec,\n-\t\t       stmt_vector_for_cost *body_cost_vec)\n+\t\t       stmt_vector_for_cost *cost_vec)\n {\n   unsigned int inside_cost = 0, prologue_cost = 0;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n+  /* ???  Somehow we need to fix this at the callers.  */\n+  if (slp_node)\n+    ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\n   if (vls_type == VLS_STORE_INVARIANT)\n-    prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n-\t\t\t\t       stmt_info, 0, vect_prologue);\n+    {\n+      if (slp_node)\n+\tprologue_cost += vect_prologue_cost_for_slp_op (slp_node, stmt_info,\n+\t\t\t\t\t\t\t1, dt, cost_vec);\n+      else\n+\tprologue_cost += record_stmt_cost (cost_vec, 1, scalar_to_vec,\n+\t\t\t\t\t   stmt_info, 0, vect_prologue);\n+    }\n \n   /* Grouped stores update all elements in the group at once,\n      so we want the DR for the first statement.  */\n@@ -947,7 +1037,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t needed permute.  */\n       int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n-      inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n+      inside_cost = record_stmt_cost (cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n \n       if (dump_enabled_p ())\n@@ -963,19 +1053,19 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     {\n       /* N scalar stores plus extracting the elements.  */\n       unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n-      inside_cost += record_stmt_cost (body_cost_vec,\n+      inside_cost += record_stmt_cost (cost_vec,\n \t\t\t\t       ncopies * assumed_nunits,\n \t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n     }\n   else\n-    vect_get_store_cost (dr, ncopies, &inside_cost, body_cost_vec);\n+    vect_get_store_cost (dr, ncopies, &inside_cost, cost_vec);\n \n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_STRIDED_SLP)\n     {\n       /* N scalar stores plus extracting the elements.  */\n       unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n-      inside_cost += record_stmt_cost (body_cost_vec,\n+      inside_cost += record_stmt_cost (cost_vec,\n \t\t\t\t       ncopies * assumed_nunits,\n \t\t\t\t       vec_to_scalar, stmt_info, 0, vect_body);\n     }\n@@ -1047,18 +1137,70 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n    accesses are supported for loads, we also account for the costs of the\n    access scheme chosen.  */\n \n-void\n-vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n+static void\n+vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t      vect_memory_access_type memory_access_type,\n+\t\t      slp_instance instance,\n \t\t      slp_tree slp_node,\n-\t\t      stmt_vector_for_cost *prologue_cost_vec,\n-\t\t      stmt_vector_for_cost *body_cost_vec)\n+\t\t      stmt_vector_for_cost *cost_vec)\n {\n   gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   unsigned int inside_cost = 0, prologue_cost = 0;\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n+  gcc_assert (cost_vec);\n+\n+  /* ???  Somehow we need to fix this at the callers.  */\n+  if (slp_node)\n+    ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\n+  if (slp_node && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n+    {\n+      /* If the load is permuted then the alignment is determined by\n+\t the first group element not by the first scalar stmt DR.  */\n+      gimple *stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+      /* Record the cost for the permutation.  */\n+      unsigned n_perms;\n+      unsigned assumed_nunits\n+\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (stmt_info));\n+      unsigned slp_vf = (ncopies * assumed_nunits) / instance->group_size; \n+      vect_transform_slp_perm_load (slp_node, vNULL, NULL,\n+\t\t\t\t    slp_vf, instance, true,\n+\t\t\t\t    &n_perms);\n+      inside_cost += record_stmt_cost (cost_vec, n_perms, vec_perm,\n+\t\t\t\t       stmt_info, 0, vect_body);\n+      /* And adjust the number of loads performed.  This handles\n+\t redundancies as well as loads that are later dead.  */\n+      auto_sbitmap perm (GROUP_SIZE (stmt_info));\n+      bitmap_clear (perm);\n+      for (unsigned i = 0;\n+\t   i < SLP_TREE_LOAD_PERMUTATION (slp_node).length (); ++i)\n+\tbitmap_set_bit (perm, SLP_TREE_LOAD_PERMUTATION (slp_node)[i]);\n+      ncopies = 0;\n+      bool load_seen = false;\n+      for (unsigned i = 0; i < GROUP_SIZE (stmt_info); ++i)\n+\t{\n+\t  if (i % assumed_nunits == 0)\n+\t    {\n+\t      if (load_seen)\n+\t\tncopies++;\n+\t      load_seen = false;\n+\t    }\n+\t  if (bitmap_bit_p (perm, i))\n+\t    load_seen = true;\n+\t}\n+      if (load_seen)\n+\tncopies++;\n+      gcc_assert (ncopies\n+\t\t  <= (GROUP_SIZE (stmt_info) - GROUP_GAP (stmt_info)\n+\t\t      + assumed_nunits - 1) / assumed_nunits);\n+    }\n+\n+  /* ???  Need to transition load permutation (and load cost) handling\n+     from vect_analyze_slp_cost_1 to here.  */\n+\n   /* Grouped loads read all elements in the group at once,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n@@ -1083,8 +1225,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t for each needed permute.  */\n       int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n-      inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n-\t\t\t\t      stmt_info, 0, vect_body);\n+      inside_cost += record_stmt_cost (cost_vec, nstmts, vec_perm,\n+\t\t\t\t       stmt_info, 0, vect_body);\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1099,17 +1241,17 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n       /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n-      inside_cost += record_stmt_cost (body_cost_vec,\n+      inside_cost += record_stmt_cost (cost_vec,\n \t\t\t\t       ncopies * assumed_nunits,\n \t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n     }\n   else\n     vect_get_load_cost (dr, ncopies, first_stmt_p,\n \t\t\t&inside_cost, &prologue_cost, \n-\t\t\tprologue_cost_vec, body_cost_vec, true);\n+\t\t\tcost_vec, cost_vec, true);\n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_STRIDED_SLP)\n-    inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n+    inside_cost += record_stmt_cost (cost_vec, ncopies, vec_construct,\n \t\t\t\t     stmt_info, 0, vect_body);\n \n   if (dump_enabled_p ())\n@@ -2851,7 +2993,8 @@ vect_get_data_ptr_increment (data_reference *dr, tree aggr_type,\n static bool\n vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    gimple **vec_stmt, slp_tree slp_node,\n-\t\t    tree vectype_in, enum vect_def_type *dt)\n+\t\t    tree vectype_in, enum vect_def_type *dt,\n+\t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree op, vectype;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -2902,10 +3045,10 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n                          \"\\n\");\n       if (! slp_node)\n \t{\n-\t  add_stmt_cost (stmt_info->vinfo->target_cost_data,\n-\t\t\t 1, vector_stmt, stmt_info, 0, vect_prologue);\n-\t  add_stmt_cost (stmt_info->vinfo->target_cost_data,\n-\t\t\t ncopies, vec_perm, stmt_info, 0, vect_body);\n+\t  record_stmt_cost (cost_vec,\n+\t\t\t    1, vector_stmt, stmt_info, 0, vect_prologue);\n+\t  record_stmt_cost (cost_vec,\n+\t\t\t    ncopies, vec_perm, stmt_info, 0, vect_body);\n \t}\n       return true;\n     }\n@@ -2995,7 +3138,7 @@ simple_integer_narrowing (tree vectype_out, tree vectype_in,\n \n static bool\n vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-\t\t   slp_tree slp_node)\n+\t\t   slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   gcall *stmt;\n   tree vec_dest;\n@@ -3192,7 +3335,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t   || gimple_call_builtin_p (stmt, BUILT_IN_BSWAP32)\n \t\t   || gimple_call_builtin_p (stmt, BUILT_IN_BSWAP64)))\n \treturn vectorizable_bswap (stmt, gsi, vec_stmt, slp_node,\n-\t\t\t\t   vectype_in, dt);\n+\t\t\t\t   vectype_in, dt, cost_vec);\n       else\n \t{\n \t  if (dump_enabled_p ())\n@@ -3219,13 +3362,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n                          \"\\n\");\n-      if (!slp_node)\n-\t{\n-\t  vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n-\t  if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n-\t    add_stmt_cost (stmt_info->vinfo->target_cost_data, ncopies / 2,\n-\t\t\t   vec_promote_demote, stmt_info, 0, vect_body);\n-\t}\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n+      if (ifn != IFN_LAST && modifier == NARROW && !slp_node)\n+\trecord_stmt_cost (cost_vec, ncopies / 2,\n+\t\t\t  vec_promote_demote, stmt_info, 0, vect_body);\n \n       return true;\n     }\n@@ -3596,7 +3736,8 @@ simd_clone_subparts (tree vectype)\n \n static bool\n vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t      gimple **vec_stmt, slp_tree slp_node)\n+\t\t\t      gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t      stmt_vector_for_cost *)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -3898,7 +4039,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"=== vectorizable_simd_clone_call ===\\n\");\n-/*      vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL); */\n+/*      vect_model_simple_cost (stmt_info, ncopies, dt, slp_node, cost_vec); */\n       return true;\n     }\n \n@@ -4443,7 +4584,8 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \n static bool\n vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t gimple **vec_stmt, slp_tree slp_node)\n+\t\t\t gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -4742,20 +4884,20 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n-\t  if (!slp_node)\n-\t    vect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+\t  vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node,\n+\t\t\t\t  cost_vec);\n \t}\n       else if (modifier == NARROW)\n \t{\n \t  STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n-\t  if (!slp_node)\n-\t    vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n+\t  vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt,\n+\t\t\t\t\t      cost_vec);\n \t}\n       else\n \t{\n \t  STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n-\t  if (!slp_node)\n-\t    vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt);\n+\t  vect_model_promotion_demotion_cost (stmt_info, dt, multi_step_cvt,\n+\t\t\t\t\t      cost_vec);\n \t}\n       interm_types.release ();\n       return true;\n@@ -5044,7 +5186,8 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t gimple **vec_stmt, slp_tree slp_node)\n+\t\t\t gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -5152,8 +5295,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_assignment ===\\n\");\n-      if (!slp_node)\n-\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }\n \n@@ -5248,7 +5390,8 @@ vect_supportable_shift (enum tree_code code, tree scalar_type)\n \n static bool\n vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n-                    gimple **vec_stmt, slp_tree slp_node)\n+                    gimple **vec_stmt, slp_tree slp_node,\n+\t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -5517,8 +5660,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_shift ===\\n\");\n-      if (!slp_node)\n-\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }\n \n@@ -5617,7 +5759,8 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node)\n+\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -5841,8 +5984,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_operation ===\\n\");\n-      if (!slp_node)\n-\tvect_model_simple_cost (stmt_info, ncopies, dt, ndts, NULL, NULL);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, ndts, slp_node, cost_vec);\n       return true;\n     }\n \n@@ -6068,7 +6210,7 @@ get_group_alias_ptr_type (gimple *first_stmt)\n \n static bool\n vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-                    slp_tree slp_node)\n+                    slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree data_ref;\n   tree op;\n@@ -6264,10 +6406,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t  memory_access_type, &gs_info);\n \n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      /* The SLP costs are calculated during SLP analysis.  */\n-      if (!slp_node)\n-\tvect_model_store_cost (stmt_info, ncopies, memory_access_type,\n-\t\t\t       vls_type, NULL, NULL, NULL);\n+      vect_model_store_cost (stmt_info, ncopies, rhs_dt, memory_access_type,\n+\t\t\t     vls_type, slp_node, cost_vec);\n       return true;\n     }\n   gcc_assert (memory_access_type == STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info));\n@@ -7230,7 +7370,8 @@ hoist_defs_of_uses (gimple *stmt, struct loop *loop)\n \n static bool\n vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-                   slp_tree slp_node, slp_instance slp_node_instance)\n+                   slp_tree slp_node, slp_instance slp_node_instance,\n+\t\t   stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n   tree vec_dest = NULL;\n@@ -7491,10 +7632,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t  memory_access_type, &gs_info);\n \n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      /* The SLP costs are calculated during SLP analysis.  */\n-      if (! slp_node)\n-\tvect_model_load_cost (stmt_info, ncopies, memory_access_type,\n-\t\t\t      NULL, NULL, NULL);\n+      vect_model_load_cost (stmt_info, ncopies, memory_access_type,\n+\t\t\t    slp_node_instance, slp_node, cost_vec);\n       return true;\n     }\n \n@@ -8550,7 +8689,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n bool\n vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\tgimple **vec_stmt, tree reduc_def, int reduc_index,\n-\t\t\tslp_tree slp_node)\n+\t\t\tslp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n@@ -8704,7 +8843,6 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt)\n     {\n-      STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n       if (bitop1 != NOP_EXPR)\n \t{\n \t  machine_mode mode = TYPE_MODE (comp_vectype);\n@@ -8725,8 +8863,9 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (expand_vec_cond_expr_p (vectype, comp_vectype,\n \t\t\t\t     cond_code))\n \t{\n-\t  if (!slp_node)\n-\t    vect_model_simple_cost (stmt_info, ncopies, dts, ndts, NULL, NULL);\n+\t  STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n+\t  vect_model_simple_cost (stmt_info, ncopies, dts, ndts, slp_node,\n+\t\t\t\t  cost_vec);\n \t  return true;\n \t}\n       return false;\n@@ -8954,7 +9093,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n static bool\n vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t gimple **vec_stmt, tree reduc_def,\n-\t\t\t slp_tree slp_node)\n+\t\t\t slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree lhs, rhs1, rhs2;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -9089,12 +9228,11 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt)\n     {\n-      STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n-      if (!slp_node)\n-\tvect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n-\t\t\t\tdts, ndts, NULL, NULL);\n       if (bitop1 == NOP_EXPR)\n-\treturn expand_vec_cmp_expr_p (vectype, mask_type, code);\n+\t{\n+\t  if (!expand_vec_cmp_expr_p (vectype, mask_type, code))\n+\t    return false;\n+\t}\n       else\n \t{\n \t  machine_mode mode = TYPE_MODE (vectype);\n@@ -9110,8 +9248,12 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      if (!optab || optab_handler (optab, mode) == CODE_FOR_nothing)\n \t\treturn false;\n \t    }\n-\t  return true;\n \t}\n+\n+      STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n+      vect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n+\t\t\t      dts, ndts, slp_node, cost_vec);\n+      return true;\n     }\n \n   /* Transform.  */\n@@ -9221,7 +9363,8 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t  slp_tree slp_node, gimple **vec_stmt)\n+\t\t\t  slp_tree slp_node, gimple **vec_stmt,\n+\t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   if (slp_node)\n     {\n@@ -9232,12 +9375,13 @@ can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  stmt_vec_info slp_stmt_info = vinfo_for_stmt (slp_stmt);\n \t  if (STMT_VINFO_LIVE_P (slp_stmt_info)\n \t      && !vectorizable_live_operation (slp_stmt, gsi, slp_node, i,\n-\t\t\t\t\t       vec_stmt))\n+\t\t\t\t\t       vec_stmt, cost_vec))\n \t    return false;\n \t}\n     }\n   else if (STMT_VINFO_LIVE_P (vinfo_for_stmt (stmt))\n-\t   && !vectorizable_live_operation (stmt, gsi, slp_node, -1, vec_stmt))\n+\t   && !vectorizable_live_operation (stmt, gsi, slp_node, -1, vec_stmt,\n+\t\t\t\t\t    cost_vec))\n     return false;\n \n   return true;\n@@ -9247,7 +9391,7 @@ can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n \n bool\n vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n-\t\t   slp_instance node_instance)\n+\t\t   slp_instance node_instance, stmt_vector_for_cost *cost_vec)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n@@ -9327,7 +9471,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n         }\n \n       if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node,\n-\t\t\t      node_instance))\n+\t\t\t      node_instance, cost_vec))\n         return false;\n    }\n \n@@ -9352,7 +9496,8 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n \t\t}\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt,\n-\t\t\t\t      need_to_vectorize, node, node_instance))\n+\t\t\t\t      need_to_vectorize, node, node_instance,\n+\t\t\t\t      cost_vec))\n \t\treturn false;\n \t    }\n \t}\n@@ -9404,31 +9549,35 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n   if (!bb_vinfo\n       && (STMT_VINFO_RELEVANT_P (stmt_info)\n \t  || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def))\n-    ok = (vectorizable_simd_clone_call (stmt, NULL, NULL, node)\n-\t  || vectorizable_conversion (stmt, NULL, NULL, node)\n-\t  || vectorizable_shift (stmt, NULL, NULL, node)\n-\t  || vectorizable_operation (stmt, NULL, NULL, node)\n-\t  || vectorizable_assignment (stmt, NULL, NULL, node)\n-\t  || vectorizable_load (stmt, NULL, NULL, node, NULL)\n-\t  || vectorizable_call (stmt, NULL, NULL, node)\n-\t  || vectorizable_store (stmt, NULL, NULL, node)\n-\t  || vectorizable_reduction (stmt, NULL, NULL, node, node_instance)\n-\t  || vectorizable_induction (stmt, NULL, NULL, node)\n-\t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n-\t  || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n+    ok = (vectorizable_simd_clone_call (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_conversion (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_shift (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_operation (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_assignment (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_load (stmt, NULL, NULL, node, node_instance, cost_vec)\n+\t  || vectorizable_call (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_store (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_reduction (stmt, NULL, NULL, node, node_instance,\n+\t\t\t\t     cost_vec)\n+\t  || vectorizable_induction (stmt, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node, cost_vec)\n+\t  || vectorizable_comparison (stmt, NULL, NULL, NULL, node, cost_vec));\n   else\n     {\n       if (bb_vinfo)\n-\tok = (vectorizable_simd_clone_call (stmt, NULL, NULL, node)\n-\t      || vectorizable_conversion (stmt, NULL, NULL, node)\n-\t      || vectorizable_shift (stmt, NULL, NULL, node)\n-\t      || vectorizable_operation (stmt, NULL, NULL, node)\n-\t      || vectorizable_assignment (stmt, NULL, NULL, node)\n-\t      || vectorizable_load (stmt, NULL, NULL, node, NULL)\n-\t      || vectorizable_call (stmt, NULL, NULL, node)\n-\t      || vectorizable_store (stmt, NULL, NULL, node)\n-\t      || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n-\t      || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n+\tok = (vectorizable_simd_clone_call (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_conversion (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_shift (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_operation (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_assignment (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_load (stmt, NULL, NULL, node, node_instance,\n+\t\t\t\t    cost_vec)\n+\t      || vectorizable_call (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_store (stmt, NULL, NULL, node, cost_vec)\n+\t      || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node,\n+\t\t\t\t\t cost_vec)\n+\t      || vectorizable_comparison (stmt, NULL, NULL, NULL, node,\n+\t\t\t\t\t  cost_vec));\n     }\n \n   if (!ok)\n@@ -9444,13 +9593,11 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n       return false;\n     }\n \n-  if (bb_vinfo)\n-    return true;\n-\n   /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n       need extra handling, except for vectorizable reductions.  */\n-  if (STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type\n-      && !can_vectorize_live_stmts (stmt, NULL, node, NULL))\n+  if (!bb_vinfo\n+      && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type\n+      && !can_vectorize_live_stmts (stmt, NULL, node, NULL, cost_vec))\n     {\n       if (dump_enabled_p ())\n         {\n@@ -9493,38 +9640,38 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n     case type_demotion_vec_info_type:\n     case type_promotion_vec_info_type:\n     case type_conversion_vec_info_type:\n-      done = vectorizable_conversion (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_conversion (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case induc_vec_info_type:\n-      done = vectorizable_induction (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_induction (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case shift_vec_info_type:\n-      done = vectorizable_shift (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_shift (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case op_vec_info_type:\n-      done = vectorizable_operation (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_operation (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case assignment_vec_info_type:\n-      done = vectorizable_assignment (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_assignment (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case load_vec_info_type:\n       done = vectorizable_load (stmt, gsi, &vec_stmt, slp_node,\n-                                slp_node_instance);\n+                                slp_node_instance, NULL);\n       gcc_assert (done);\n       break;\n \n     case store_vec_info_type:\n-      done = vectorizable_store (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_store (stmt, gsi, &vec_stmt, slp_node, NULL);\n       gcc_assert (done);\n       if (STMT_VINFO_GROUPED_ACCESS (stmt_info) && !slp_node)\n \t{\n@@ -9543,28 +9690,28 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case condition_vec_info_type:\n-      done = vectorizable_condition (stmt, gsi, &vec_stmt, NULL, 0, slp_node);\n+      done = vectorizable_condition (stmt, gsi, &vec_stmt, NULL, 0, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case comparison_vec_info_type:\n-      done = vectorizable_comparison (stmt, gsi, &vec_stmt, NULL, slp_node);\n+      done = vectorizable_comparison (stmt, gsi, &vec_stmt, NULL, slp_node, NULL);\n       gcc_assert (done);\n       break;\n \n     case call_vec_info_type:\n-      done = vectorizable_call (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_call (stmt, gsi, &vec_stmt, slp_node, NULL);\n       stmt = gsi_stmt (*gsi);\n       break;\n \n     case call_simd_clone_vec_info_type:\n-      done = vectorizable_simd_clone_call (stmt, gsi, &vec_stmt, slp_node);\n+      done = vectorizable_simd_clone_call (stmt, gsi, &vec_stmt, slp_node, NULL);\n       stmt = gsi_stmt (*gsi);\n       break;\n \n     case reduc_vec_info_type:\n       done = vectorizable_reduction (stmt, gsi, &vec_stmt, slp_node,\n-\t\t\t\t     slp_node_instance);\n+\t\t\t\t     slp_node_instance, NULL);\n       gcc_assert (done);\n       break;\n \n@@ -9626,7 +9773,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n      being vectorized.  */\n   if (STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n     {\n-      done = can_vectorize_live_stmts (stmt, gsi, slp_node, &vec_stmt);\n+      done = can_vectorize_live_stmts (stmt, gsi, slp_node, &vec_stmt, NULL);\n       gcc_assert (done);\n     }\n "}, {"sha": "86cd025fe7398c2bc934a1dc5e7a4ea89c6a76c5", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -78,13 +78,104 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"gimple-pretty-print.h\"\n \n \n /* Loop or bb location.  */\n source_location vect_location;\n \n /* Vector mapping GIMPLE stmt to stmt_vec_info. */\n vec<stmt_vec_info> stmt_vec_info_vec;\n+\n+/* Dump a cost entry according to args to F.  */\n+\n+void\n+dump_stmt_cost (FILE *f, void *data, int count, enum vect_cost_for_stmt kind,\n+\t\tstmt_vec_info stmt_info, int misalign,\n+\t\tenum vect_cost_model_location where)\n+{\n+  fprintf (f, \"%p \", data);\n+  if (stmt_info)\n+    {\n+      print_gimple_expr (f, STMT_VINFO_STMT (stmt_info), 0, TDF_SLIM);\n+      fprintf (f, \" \");\n+    }\n+  else\n+    fprintf (f, \"<unknown> \");\n+  fprintf (f, \"%d times \", count);\n+  const char *ks = \"unknown\";\n+  switch (kind)\n+    {\n+    case scalar_stmt:\n+      ks = \"scalar_stmt\";\n+      break;\n+    case scalar_load:\n+      ks = \"scalar_load\";\n+      break;\n+    case scalar_store:\n+      ks = \"scalar_store\";\n+      break;\n+    case vector_stmt:\n+      ks = \"vector_stmt\";\n+      break;\n+    case vector_load:\n+      ks = \"vector_load\";\n+      break;\n+    case vector_gather_load:\n+      ks = \"vector_gather_load\";\n+      break;\n+    case unaligned_load:\n+      ks = \"unaligned_load\";\n+      break;\n+    case unaligned_store:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vector_store:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vector_scatter_store:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vec_to_scalar:\n+      ks = \"unaligned_store\";\n+      break;\n+    case scalar_to_vec:\n+      ks = \"unaligned_store\";\n+      break;\n+    case cond_branch_not_taken:\n+      ks = \"unaligned_store\";\n+      break;\n+    case cond_branch_taken:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vec_perm:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vec_promote_demote:\n+      ks = \"unaligned_store\";\n+      break;\n+    case vec_construct:\n+      ks = \"unaligned_store\";\n+      break;\n+    }\n+  fprintf (f, \"%s \", ks);\n+  if (kind == unaligned_load || kind == unaligned_store)\n+    fprintf (f, \"(misalign %d) \", misalign);\n+  const char *ws = \"unknown\";\n+  switch (where)\n+    {\n+    case vect_prologue:\n+      ws = \"prologue\";\n+      break;\n+    case vect_body:\n+      ws = \"body\";\n+      break;\n+    case vect_epilogue:\n+      ws = \"epilogue\";\n+      break;\n+    }\n+  fprintf (f, \"in %s\\n\", ws);\n+}\n \f\n /* For mapping simduid to vectorization factor.  */\n "}, {"sha": "13886584e8b1325b931061fcbc967d8b0239f828", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68435eb293a6b9c161936bccab66e4b1f702372b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=68435eb293a6b9c161936bccab66e4b1f702372b", "patch": "@@ -94,6 +94,7 @@ enum vect_reduction_type {\n struct stmt_info_for_cost {\n   int count;\n   enum vect_cost_for_stmt kind;\n+  enum vect_cost_model_location where;\n   gimple *stmt;\n   int misalign;\n };\n@@ -1171,13 +1172,18 @@ init_cost (struct loop *loop_info)\n   return targetm.vectorize.init_cost (loop_info);\n }\n \n+extern void dump_stmt_cost (FILE *, void *, int, enum vect_cost_for_stmt,\n+\t\t\t    stmt_vec_info, int, enum vect_cost_model_location);\n+\n /* Alias targetm.vectorize.add_stmt_cost.  */\n \n static inline unsigned\n add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t       stmt_vec_info stmt_info, int misalign,\n \t       enum vect_cost_model_location where)\n {\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_stmt_cost (dump_file, data, count, kind, stmt_info, misalign, where);\n   return targetm.vectorize.add_stmt_cost (data, count, kind,\n \t\t\t\t\t  stmt_info, misalign, where);\n }\n@@ -1199,6 +1205,17 @@ destroy_cost_data (void *data)\n   targetm.vectorize.destroy_cost_data (data);\n }\n \n+inline void\n+add_stmt_costs (void *data, stmt_vector_for_cost *cost_vec)\n+{\n+  stmt_info_for_cost *cost;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (*cost_vec, i, cost)\n+    add_stmt_cost (data, cost->count, cost->kind,\n+\t\t   cost->stmt ? vinfo_for_stmt (cost->stmt) : NULL,\n+\t\t   cost->misalign, cost->where);\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/\n@@ -1422,16 +1439,6 @@ extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n \t\t\t\t\t     int *, vec<tree> *);\n extern stmt_vec_info new_stmt_vec_info (gimple *stmt, vec_info *);\n extern void free_stmt_vec_info (gimple *stmt);\n-extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n-\t\t\t\t    int, stmt_vector_for_cost *,\n-\t\t\t\t    stmt_vector_for_cost *);\n-extern void vect_model_store_cost (stmt_vec_info, int, vect_memory_access_type,\n-\t\t\t\t   vec_load_store_type, slp_tree,\n-\t\t\t\t   stmt_vector_for_cost *,\n-\t\t\t\t   stmt_vector_for_cost *);\n-extern void vect_model_load_cost (stmt_vec_info, int, vect_memory_access_type,\n-\t\t\t\t  slp_tree, stmt_vector_for_cost *,\n-\t\t\t\t  stmt_vector_for_cost *);\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,\n \t\t\t\t  int, enum vect_cost_model_location);\n@@ -1452,9 +1459,11 @@ extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n extern bool vect_transform_stmt (gimple *, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple *);\n-extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance);\n+extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance,\n+\t\t\t       stmt_vector_for_cost *);\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, tree, int, slp_tree);\n+\t\t\t\t    gimple **, tree, int, slp_tree,\n+\t\t\t\t    stmt_vector_for_cost *);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,\n@@ -1539,11 +1548,14 @@ extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t\t slp_tree, int, gimple **);\n+\t\t\t\t\t slp_tree, int, gimple **,\n+\t\t\t\t\t stmt_vector_for_cost *);\n extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, slp_tree, slp_instance);\n+\t\t\t\t    gimple **, slp_tree, slp_instance,\n+\t\t\t\t    stmt_vector_for_cost *);\n extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, slp_tree);\n+\t\t\t\t    gimple **, slp_tree,\n+\t\t\t\t    stmt_vector_for_cost *);\n extern tree get_initial_def_for_reduction (gimple *, tree, tree *);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,"}]}