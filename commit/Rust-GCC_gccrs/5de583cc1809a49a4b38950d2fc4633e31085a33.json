{"sha": "5de583cc1809a49a4b38950d2fc4633e31085a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRlNTgzY2MxODA5YTQ5YTRiMzg5NTBkMmZjNDYzM2UzMTA4NWEzMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-25T10:20:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-25T10:20:37Z"}, "message": "tree-ssa-sccvn.h (vn_eliminate): Declare.\n\n2017-10-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.h (vn_eliminate): Declare.\n\t* tree-ssa-pre.c (class eliminate_dom_walker, eliminate,\n\tclass pass_fre): Move to ...\n\t* tree-ssa-sccvn.c (class eliminate_dom_walker, vn_eliminate,\n\tclass pass_fre): ... here and adjust for statistics.\n\nFrom-SVN: r254074", "tree": {"sha": "198ddd88d5d8d344cb9e2897703403d7435e8072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/198ddd88d5d8d344cb9e2897703403d7435e8072"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5de583cc1809a49a4b38950d2fc4633e31085a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de583cc1809a49a4b38950d2fc4633e31085a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de583cc1809a49a4b38950d2fc4633e31085a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de583cc1809a49a4b38950d2fc4633e31085a33/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a596f4970ededd424328f7789b4a304e5b3a7338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a596f4970ededd424328f7789b4a304e5b3a7338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a596f4970ededd424328f7789b4a304e5b3a7338"}], "stats": {"total": 1752, "additions": 884, "deletions": 868}, "files": [{"sha": "c5dfcb704eb7a25e824e8e37c2c5476eba91aeb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5de583cc1809a49a4b38950d2fc4633e31085a33", "patch": "@@ -1,3 +1,11 @@\n+2017-10-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.h (vn_eliminate): Declare.\n+\t* tree-ssa-pre.c (class eliminate_dom_walker, eliminate,\n+\tclass pass_fre): Move to ...\n+\t* tree-ssa-sccvn.c (class eliminate_dom_walker, vn_eliminate,\n+\tclass pass_fre): ... here and adjust for statistics.\n+\n 2017-10-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libstdc++/81706"}, {"sha": "e4189d1fd8eb0c2dd124ddc19aaf0f7d87a4d89c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 867, "changes": 868, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5de583cc1809a49a4b38950d2fc4633e31085a33", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n-#include \"tree-ssa-loop.h\"\n #include \"tree-into-ssa.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n@@ -50,9 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"domwalk.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"ipa-utils.h\"\n #include \"tree-cfgcleanup.h\"\n-#include \"langhooks.h\"\n #include \"alias.h\"\n \n /* Even though this file is called tree-ssa-pre.c, we actually\n@@ -516,9 +513,6 @@ typedef struct bb_bitmap_sets\n    optimization PRE was able to perform.  */\n static struct\n {\n-  /* The number of RHS computations eliminated by PRE.  */\n-  int eliminations;\n-\n   /* The number of new expressions/temporaries generated by PRE.  */\n   int insertions;\n \n@@ -4036,807 +4030,6 @@ compute_avail (void)\n   free (worklist);\n }\n \n-class eliminate_dom_walker : public dom_walker\n-{\n-public:\n-  eliminate_dom_walker (cdi_direction direction, bool do_pre_);\n-  ~eliminate_dom_walker ();\n-\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-  tree eliminate_avail (tree op);\n-  void eliminate_push_avail (tree op);\n-  tree eliminate_insert (gimple_stmt_iterator *gsi, tree val);\n-\n-  bool do_pre;\n-  unsigned int el_todo;\n-\n-  /* Blocks with statements that have had their EH properties changed.  */\n-  bitmap need_eh_cleanup;\n-\n-  /* Blocks with statements that have had their AB properties changed.  */\n-  bitmap need_ab_cleanup;\n-\n-  auto_vec<gimple *> to_remove;\n-  auto_vec<gimple *> to_fixup;\n-  auto_vec<tree> avail;\n-  auto_vec<tree> avail_stack;\n-};\n-\n-eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,\n-\t\t\t\t\t    bool do_pre_)\n-  : dom_walker (direction), do_pre (do_pre_), el_todo (0)\n-{\n-  need_eh_cleanup = BITMAP_ALLOC (NULL);\n-  need_ab_cleanup = BITMAP_ALLOC (NULL);\n-}\n-\n-eliminate_dom_walker::~eliminate_dom_walker ()\n-{\n-  BITMAP_FREE (need_eh_cleanup);\n-  BITMAP_FREE (need_ab_cleanup);\n-}\n-\n-/* Return a leader for OP that is available at the current point of the\n-   eliminate domwalk.  */\n-\n-tree\n-eliminate_dom_walker::eliminate_avail (tree op)\n-{\n-  tree valnum = VN_INFO (op)->valnum;\n-  if (TREE_CODE (valnum) == SSA_NAME)\n-    {\n-      if (SSA_NAME_IS_DEFAULT_DEF (valnum))\n-\treturn valnum;\n-      if (avail.length () > SSA_NAME_VERSION (valnum))\n-\treturn avail[SSA_NAME_VERSION (valnum)];\n-    }\n-  else if (is_gimple_min_invariant (valnum))\n-    return valnum;\n-  return NULL_TREE;\n-}\n-\n-/* At the current point of the eliminate domwalk make OP available.  */\n-\n-void\n-eliminate_dom_walker::eliminate_push_avail (tree op)\n-{\n-  tree valnum = VN_INFO (op)->valnum;\n-  if (TREE_CODE (valnum) == SSA_NAME)\n-    {\n-      if (avail.length () <= SSA_NAME_VERSION (valnum))\n-\tavail.safe_grow_cleared (SSA_NAME_VERSION (valnum) + 1);\n-      tree pushop = op;\n-      if (avail[SSA_NAME_VERSION (valnum)])\n-\tpushop = avail[SSA_NAME_VERSION (valnum)];\n-      avail_stack.safe_push (pushop);\n-      avail[SSA_NAME_VERSION (valnum)] = op;\n-    }\n-}\n-\n-/* Insert the expression recorded by SCCVN for VAL at *GSI.  Returns\n-   the leader for the expression if insertion was successful.  */\n-\n-tree\n-eliminate_dom_walker::eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n-{\n-  /* We can insert a sequence with a single assignment only.  */\n-  gimple_seq stmts = VN_INFO (val)->expr;\n-  if (!gimple_seq_singleton_p (stmts))\n-    return NULL_TREE;\n-  gassign *stmt = dyn_cast <gassign *> (gimple_seq_first_stmt (stmts));\n-  if (!stmt\n-      || (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n-\t  && gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR\n-\t  && gimple_assign_rhs_code (stmt) != BIT_FIELD_REF\n-\t  && (gimple_assign_rhs_code (stmt) != BIT_AND_EXPR\n-\t      || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)))\n-    return NULL_TREE;\n-\n-  tree op = gimple_assign_rhs1 (stmt);\n-  if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n-      || gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n-    op = TREE_OPERAND (op, 0);\n-  tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (op) : op;\n-  if (!leader)\n-    return NULL_TREE;\n-\n-  tree res;\n-  stmts = NULL;\n-  if (gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n-    res = gimple_build (&stmts, BIT_FIELD_REF,\n-\t\t\tTREE_TYPE (val), leader,\n-\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 1),\n-\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 2));\n-  else if (gimple_assign_rhs_code (stmt) == BIT_AND_EXPR)\n-    res = gimple_build (&stmts, BIT_AND_EXPR,\n-\t\t\tTREE_TYPE (val), leader, gimple_assign_rhs2 (stmt));\n-  else\n-    res = gimple_build (&stmts, gimple_assign_rhs_code (stmt),\n-\t\t\tTREE_TYPE (val), leader);\n-  if (TREE_CODE (res) != SSA_NAME\n-      || SSA_NAME_IS_DEFAULT_DEF (res)\n-      || gimple_bb (SSA_NAME_DEF_STMT (res)))\n-    {\n-      gimple_seq_discard (stmts);\n-\n-      /* During propagation we have to treat SSA info conservatively\n-         and thus we can end up simplifying the inserted expression\n-\t at elimination time to sth not defined in stmts.  */\n-      /* But then this is a redundancy we failed to detect.  Which means\n-         res now has two values.  That doesn't play well with how\n-\t we track availability here, so give up.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  if (TREE_CODE (res) == SSA_NAME)\n-\t    res = eliminate_avail (res);\n-\t  if (res)\n-\t    {\n-\t      fprintf (dump_file, \"Failed to insert expression for value \");\n-\t      print_generic_expr (dump_file, val);\n-\t      fprintf (dump_file, \" which is really fully redundant to \");\n-\t      print_generic_expr (dump_file, res);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-  else\n-    {\n-      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-      VN_INFO_GET (res)->valnum = val;\n-    }\n-\n-  pre_stats.insertions++;\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Inserted \");\n-      print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (res), 0);\n-    }\n-\n-  return res;\n-}\n-\n-\n-\n-/* Perform elimination for the basic-block B during the domwalk.  */\n-\n-edge\n-eliminate_dom_walker::before_dom_children (basic_block b)\n-{\n-  /* Mark new bb.  */\n-  avail_stack.safe_push (NULL_TREE);\n-\n-  /* Skip unreachable blocks marked unreachable during the SCCVN domwalk.  */\n-  edge_iterator ei;\n-  edge e;\n-  FOR_EACH_EDGE (e, ei, b->preds)\n-    if (e->flags & EDGE_EXECUTABLE)\n-      break;\n-  if (! e)\n-    return NULL;\n-\n-  for (gphi_iterator gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n-    {\n-      gphi *phi = gsi.phi ();\n-      tree res = PHI_RESULT (phi);\n-\n-      if (virtual_operand_p (res))\n-\t{\n-\t  gsi_next (&gsi);\n-\t  continue;\n-\t}\n-\n-      tree sprime = eliminate_avail (res);\n-      if (sprime\n-\t  && sprime != res)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Replaced redundant PHI node defining \");\n-\t      print_generic_expr (dump_file, res);\n-\t      fprintf (dump_file, \" with \");\n-\t      print_generic_expr (dump_file, sprime);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  /* If we inserted this PHI node ourself, it's not an elimination.  */\n-\t  if (inserted_exprs\n-\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n-\t    pre_stats.phis--;\n-\t  else\n-\t    pre_stats.eliminations++;\n-\n-\t  /* If we will propagate into all uses don't bother to do\n-\t     anything.  */\n-\t  if (may_propagate_copy (res, sprime))\n-\t    {\n-\t      /* Mark the PHI for removal.  */\n-\t      to_remove.safe_push (phi);\n-\t      gsi_next (&gsi);\n-\t      continue;\n-\t    }\n-\n-\t  remove_phi_node (&gsi, false);\n-\n-\t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n-\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n-\t  gimple *stmt = gimple_build_assign (res, sprime);\n-\t  gimple_stmt_iterator gsi2 = gsi_after_labels (b);\n-\t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n-\t  continue;\n-\t}\n-\n-      eliminate_push_avail (res);\n-      gsi_next (&gsi);\n-    }\n-\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (b);\n-       !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n-    {\n-      tree sprime = NULL_TREE;\n-      gimple *stmt = gsi_stmt (gsi);\n-      tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && TREE_CODE (lhs) == SSA_NAME\n-\t  && !gimple_has_volatile_ops (stmt)\n-\t  /* See PR43491.  Do not replace a global register variable when\n-\t     it is a the RHS of an assignment.  Do replace local register\n-\t     variables since gcc does not guarantee a local variable will\n-\t     be allocated in register.\n-\t     ???  The fix isn't effective here.  This should instead\n-\t     be ensured by not value-numbering them the same but treating\n-\t     them like volatiles?  */\n-\t  && !(gimple_assign_single_p (stmt)\n-\t       && (TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL\n-\t\t   && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt))\n-\t\t   && is_global_var (gimple_assign_rhs1 (stmt)))))\n-\t{\n-\t  sprime = eliminate_avail (lhs);\n-\t  if (!sprime)\n-\t    {\n-\t      /* If there is no existing usable leader but SCCVN thinks\n-\t\t it has an expression it wants to use as replacement,\n-\t\t insert that.  */\n-\t      tree val = VN_INFO (lhs)->valnum;\n-\t      if (val != VN_TOP\n-\t\t  && TREE_CODE (val) == SSA_NAME\n-\t\t  && VN_INFO (val)->needs_insertion\n-\t\t  && VN_INFO (val)->expr != NULL\n-\t\t  && (sprime = eliminate_insert (&gsi, val)) != NULL_TREE)\n-\t\teliminate_push_avail (sprime);\n-\t    }\n-\n-\t  /* If this now constitutes a copy duplicate points-to\n-\t     and range info appropriately.  This is especially\n-\t     important for inserted code.  See tree-ssa-copy.c\n-\t     for similar code.  */\n-\t  if (sprime\n-\t      && TREE_CODE (sprime) == SSA_NAME)\n-\t    {\n-\t      basic_block sprime_b = gimple_bb (SSA_NAME_DEF_STMT (sprime));\n-\t      if (POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t\t  && VN_INFO_PTR_INFO (lhs)\n-\t\t  && ! VN_INFO_PTR_INFO (sprime))\n-\t\t{\n-\t\t  duplicate_ssa_name_ptr_info (sprime,\n-\t\t\t\t\t       VN_INFO_PTR_INFO (lhs));\n-\t\t  if (b != sprime_b)\n-\t\t    mark_ptr_info_alignment_unknown\n-\t\t\t(SSA_NAME_PTR_INFO (sprime));\n-\t\t}\n-\t      else if (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t\t       && VN_INFO_RANGE_INFO (lhs)\n-\t\t       && ! VN_INFO_RANGE_INFO (sprime)\n-\t\t       && b == sprime_b)\n-\t\tduplicate_ssa_name_range_info (sprime,\n-\t\t\t\t\t       VN_INFO_RANGE_TYPE (lhs),\n-\t\t\t\t\t       VN_INFO_RANGE_INFO (lhs));\n-\t    }\n-\n-\t  /* Inhibit the use of an inserted PHI on a loop header when\n-\t     the address of the memory reference is a simple induction\n-\t     variable.  In other cases the vectorizer won't do anything\n-\t     anyway (either it's loop invariant or a complicated\n-\t     expression).  */\n-\t  if (sprime\n-\t      && TREE_CODE (sprime) == SSA_NAME\n-\t      && do_pre\n-\t      && (flag_tree_loop_vectorize || flag_tree_parallelize_loops > 1)\n-\t      && loop_outer (b->loop_father)\n-\t      && has_zero_uses (sprime)\n-\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))\n-\t      && gimple_assign_load_p (stmt))\n-\t    {\n-\t      gimple *def_stmt = SSA_NAME_DEF_STMT (sprime);\n-\t      basic_block def_bb = gimple_bb (def_stmt);\n-\t      if (gimple_code (def_stmt) == GIMPLE_PHI\n-\t\t  && def_bb->loop_father->header == def_bb)\n-\t\t{\n-\t\t  loop_p loop = def_bb->loop_father;\n-\t\t  ssa_op_iter iter;\n-\t\t  tree op;\n-\t\t  bool found = false;\n-\t\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t\t    {\n-\t\t      affine_iv iv;\n-\t\t      def_bb = gimple_bb (SSA_NAME_DEF_STMT (op));\n-\t\t      if (def_bb\n-\t\t\t  && flow_bb_inside_loop_p (loop, def_bb)\n-\t\t\t  && simple_iv (loop, loop, op, &iv, true))\n-\t\t\t{\n-\t\t\t  found = true;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  if (found)\n-\t\t    {\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file, \"Not replacing \");\n-\t\t\t  print_gimple_expr (dump_file, stmt, 0);\n-\t\t\t  fprintf (dump_file, \" with \");\n-\t\t\t  print_generic_expr (dump_file, sprime);\n-\t\t\t  fprintf (dump_file, \" which would add a loop\"\n-\t\t\t\t   \" carried dependence to loop %d\\n\",\n-\t\t\t\t   loop->num);\n-\t\t\t}\n-\t\t      /* Don't keep sprime available.  */\n-\t\t      sprime = NULL_TREE;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (sprime)\n-\t    {\n-\t      /* If we can propagate the value computed for LHS into\n-\t\t all uses don't bother doing anything with this stmt.  */\n-\t      if (may_propagate_copy (lhs, sprime))\n-\t\t{\n-\t\t  /* Mark it for removal.  */\n-\t\t  to_remove.safe_push (stmt);\n-\n-\t\t  /* ???  Don't count copy/constant propagations.  */\n-\t\t  if (gimple_assign_single_p (stmt)\n-\t\t      && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-\t\t\t  || gimple_assign_rhs1 (stmt) == sprime))\n-\t\t    continue;\n-\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Replaced \");\n-\t\t      print_gimple_expr (dump_file, stmt, 0);\n-\t\t      fprintf (dump_file, \" with \");\n-\t\t      print_generic_expr (dump_file, sprime);\n-\t\t      fprintf (dump_file, \" in all uses of \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t\t    }\n-\n-\t\t  pre_stats.eliminations++;\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* If this is an assignment from our leader (which\n-\t         happens in the case the value-number is a constant)\n-\t\t then there is nothing to do.  */\n-\t      if (gimple_assign_single_p (stmt)\n-\t\t  && sprime == gimple_assign_rhs1 (stmt))\n-\t\tcontinue;\n-\n-\t      /* Else replace its RHS.  */\n-\t      bool can_make_abnormal_goto\n-\t\t  = is_gimple_call (stmt)\n-\t\t  && stmt_can_make_abnormal_goto (stmt);\n-\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"Replaced \");\n-\t\t  print_gimple_expr (dump_file, stmt, 0);\n-\t\t  fprintf (dump_file, \" with \");\n-\t\t  print_generic_expr (dump_file, sprime);\n-\t\t  fprintf (dump_file, \" in \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t\t}\n-\n-\t      pre_stats.eliminations++;\n-\t      gimple *orig_stmt = stmt;\n-\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n-\t\t\t\t\t      TREE_TYPE (sprime)))\n-\t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n-\t      tree vdef = gimple_vdef (stmt);\n-\t      tree vuse = gimple_vuse (stmt);\n-\t      propagate_tree_value_into_stmt (&gsi, sprime);\n-\t      stmt = gsi_stmt (gsi);\n-\t      update_stmt (stmt);\n-\t      if (vdef != gimple_vdef (stmt))\n-\t\tVN_INFO (vdef)->valnum = vuse;\n-\n-\t      /* If we removed EH side-effects from the statement, clean\n-\t\t its EH information.  */\n-\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n-\t\t{\n-\t\t  bitmap_set_bit (need_eh_cleanup,\n-\t\t\t\t  gimple_bb (stmt)->index);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t\t}\n-\n-\t      /* Likewise for AB side-effects.  */\n-\t      if (can_make_abnormal_goto\n-\t\t  && !stmt_can_make_abnormal_goto (stmt))\n-\t\t{\n-\t\t  bitmap_set_bit (need_ab_cleanup,\n-\t\t\t\t  gimple_bb (stmt)->index);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n-\t\t}\n-\n-\t      continue;\n-\t    }\n-\t}\n-\n-      /* If the statement is a scalar store, see if the expression\n-         has the same value number as its rhs.  If so, the store is\n-         dead.  */\n-      if (gimple_assign_single_p (stmt)\n-\t  && !gimple_has_volatile_ops (stmt)\n-\t  && !is_gimple_reg (gimple_assign_lhs (stmt))\n-\t  && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-\t      || is_gimple_min_invariant (gimple_assign_rhs1 (stmt))))\n-\t{\n-\t  tree val;\n-\t  tree rhs = gimple_assign_rhs1 (stmt);\n-\t  vn_reference_t vnresult;\n-\t  val = vn_reference_lookup (lhs, gimple_vuse (stmt), VN_WALKREWRITE,\n-\t\t\t\t     &vnresult, false);\n-\t  if (TREE_CODE (rhs) == SSA_NAME)\n-\t    rhs = VN_INFO (rhs)->valnum;\n-\t  if (val\n-\t      && operand_equal_p (val, rhs, 0))\n-\t    {\n-\t      /* We can only remove the later store if the former aliases\n-\t\t at least all accesses the later one does or if the store\n-\t\t was to readonly memory storing the same value.  */\n-\t      alias_set_type set = get_alias_set (lhs);\n-\t      if (! vnresult\n-\t\t  || vnresult->set == set\n-\t\t  || alias_set_subset_of (set, vnresult->set))\n-\t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file, \"Deleted redundant store \");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t\t    }\n-\n-\t\t  /* Queue stmt for removal.  */\n-\t\t  to_remove.safe_push (stmt);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If this is a control statement value numbering left edges\n-\t unexecuted on force the condition in a way consistent with\n-\t that.  */\n-      if (gcond *cond = dyn_cast <gcond *> (stmt))\n-\t{\n-\t  if ((EDGE_SUCC (b, 0)->flags & EDGE_EXECUTABLE)\n-\t      ^ (EDGE_SUCC (b, 1)->flags & EDGE_EXECUTABLE))\n-\t    {\n-              if (dump_file && (dump_flags & TDF_DETAILS))\n-                {\n-                  fprintf (dump_file, \"Removing unexecutable edge from \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0);\n-                }\n-\t      if (((EDGE_SUCC (b, 0)->flags & EDGE_TRUE_VALUE) != 0)\n-\t\t  == ((EDGE_SUCC (b, 0)->flags & EDGE_EXECUTABLE) != 0))\n-\t\tgimple_cond_make_true (cond);\n-\t      else\n-\t\tgimple_cond_make_false (cond);\n-\t      update_stmt (cond);\n-\t      el_todo |= TODO_cleanup_cfg;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      bool can_make_abnormal_goto = stmt_can_make_abnormal_goto (stmt);\n-      bool was_noreturn = (is_gimple_call (stmt)\n-\t\t\t   && gimple_call_noreturn_p (stmt));\n-      tree vdef = gimple_vdef (stmt);\n-      tree vuse = gimple_vuse (stmt);\n-\n-      /* If we didn't replace the whole stmt (or propagate the result\n-         into all uses), replace all uses on this stmt with their\n-\t leaders.  */\n-      bool modified = false;\n-      use_operand_p use_p;\n-      ssa_op_iter iter;\n-      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-\t{\n-\t  tree use = USE_FROM_PTR (use_p);\n-\t  /* ???  The call code above leaves stmt operands un-updated.  */\n-\t  if (TREE_CODE (use) != SSA_NAME)\n-\t    continue;\n-\t  tree sprime = eliminate_avail (use);\n-\t  if (sprime && sprime != use\n-\t      && may_propagate_copy (use, sprime)\n-\t      /* We substitute into debug stmts to avoid excessive\n-\t         debug temporaries created by removed stmts, but we need\n-\t\t to avoid doing so for inserted sprimes as we never want\n-\t\t to create debug temporaries for them.  */\n-\t      && (!inserted_exprs\n-\t\t  || TREE_CODE (sprime) != SSA_NAME\n-\t\t  || !is_gimple_debug (stmt)\n-\t\t  || !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))))\n-\t    {\n-\t      propagate_value (use_p, sprime);\n-\t      modified = true;\n-\t    }\n-\t}\n-\n-      /* Fold the stmt if modified, this canonicalizes MEM_REFs we propagated\n-         into which is a requirement for the IPA devirt machinery.  */\n-      gimple *old_stmt = stmt;\n-      if (modified)\n-\t{\n-\t  /* If a formerly non-invariant ADDR_EXPR is turned into an\n-\t     invariant one it was on a separate stmt.  */\n-\t  if (gimple_assign_single_p (stmt)\n-\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n-\t  gimple_stmt_iterator prev = gsi;\n-\t  gsi_prev (&prev);\n-\t  if (fold_stmt (&gsi))\n-\t    {\n-\t      /* fold_stmt may have created new stmts inbetween\n-\t\t the previous stmt and the folded stmt.  Mark\n-\t\t all defs created there as varying to not confuse\n-\t\t the SCCVN machinery as we're using that even during\n-\t\t elimination.  */\n-\t      if (gsi_end_p (prev))\n-\t\tprev = gsi_start_bb (b);\n-\t      else\n-\t\tgsi_next (&prev);\n-\t      if (gsi_stmt (prev) != gsi_stmt (gsi))\n-\t\tdo\n-\t\t  {\n-\t\t    tree def;\n-\t\t    ssa_op_iter dit;\n-\t\t    FOR_EACH_SSA_TREE_OPERAND (def, gsi_stmt (prev),\n-\t\t\t\t\t       dit, SSA_OP_ALL_DEFS)\n-\t\t      /* As existing DEFs may move between stmts\n-\t\t\t we have to guard VN_INFO_GET.  */\n-\t\t      if (! has_VN_INFO (def))\n-\t\t\tVN_INFO_GET (def)->valnum = def;\n-\t\t    if (gsi_stmt (prev) == gsi_stmt (gsi))\n-\t\t      break;\n-\t\t    gsi_next (&prev);\n-\t\t  }\n-\t\twhile (1);\n-\t    }\n-\t  stmt = gsi_stmt (gsi);\n-\t  /* In case we folded the stmt away schedule the NOP for removal.  */\n-\t  if (gimple_nop_p (stmt))\n-\t    to_remove.safe_push (stmt);\n-\t}\n-\n-      /* Visit indirect calls and turn them into direct calls if\n-\t possible using the devirtualization machinery.  Do this before\n-\t checking for required EH/abnormal/noreturn cleanup as devird\n-\t may expose more of those.  */\n-      if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n-\t{\n-\t  tree fn = gimple_call_fn (call_stmt);\n-\t  if (fn\n-\t      && flag_devirtualize\n-\t      && virtual_method_call_p (fn))\n-\t    {\n-\t      tree otr_type = obj_type_ref_class (fn);\n-\t      unsigned HOST_WIDE_INT otr_tok\n-\t\t= tree_to_uhwi (OBJ_TYPE_REF_TOKEN (fn));\n-\t      tree instance;\n-\t      ipa_polymorphic_call_context context (current_function_decl,\n-\t\t\t\t\t\t    fn, stmt, &instance);\n-\t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn),\n-\t\t\t\t\totr_type, stmt);\n-\t      bool final;\n-\t      vec <cgraph_node *> targets\n-\t\t= possible_polymorphic_call_targets (obj_type_ref_class (fn),\n-\t\t\t\t\t\t     otr_tok, context, &final);\n-\t      if (dump_file)\n-\t\tdump_possible_polymorphic_call_targets (dump_file, \n-\t\t\t\t\t\t\tobj_type_ref_class (fn),\n-\t\t\t\t\t\t\totr_tok, context);\n-\t      if (final && targets.length () <= 1 && dbg_cnt (devirt))\n-\t\t{\n-\t\t  tree fn;\n-\t\t  if (targets.length () == 1)\n-\t\t    fn = targets[0]->decl;\n-\t\t  else\n-\t\t    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      location_t loc = gimple_location (stmt);\n-\t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t\t\t       \"converting indirect call to \"\n-\t\t\t\t       \"function %s\\n\",\n-\t\t\t\t       lang_hooks.decl_printable_name (fn, 2));\n-\t\t    }\n-\t\t  gimple_call_set_fndecl (call_stmt, fn);\n-\t\t  /* If changing the call to __builtin_unreachable\n-\t\t     or similar noreturn function, adjust gimple_call_fntype\n-\t\t     too.  */\n-\t\t  if (gimple_call_noreturn_p (call_stmt)\n-\t\t      && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fn)))\n-\t\t      && TYPE_ARG_TYPES (TREE_TYPE (fn))\n-\t\t      && (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fn)))\n-\t\t\t  == void_type_node))\n-\t\t    gimple_call_set_fntype (call_stmt, TREE_TYPE (fn));\n-\t\t  maybe_remove_unused_call_args (cfun, call_stmt);\n-\t\t  modified = true;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (modified)\n-\t{\n-\t  /* When changing a call into a noreturn call, cfg cleanup\n-\t     is needed to fix up the noreturn call.  */\n-\t  if (!was_noreturn\n-\t      && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n-\t    to_fixup.safe_push  (stmt);\n-\t  /* When changing a condition or switch into one we know what\n-\t     edge will be executed, schedule a cfg cleanup.  */\n-\t  if ((gimple_code (stmt) == GIMPLE_COND\n-\t       && (gimple_cond_true_p (as_a <gcond *> (stmt))\n-\t\t   || gimple_cond_false_p (as_a <gcond *> (stmt))))\n-\t      || (gimple_code (stmt) == GIMPLE_SWITCH\n-\t\t  && TREE_CODE (gimple_switch_index\n-\t\t\t\t  (as_a <gswitch *> (stmt))) == INTEGER_CST))\n-\t    el_todo |= TODO_cleanup_cfg;\n-\t  /* If we removed EH side-effects from the statement, clean\n-\t     its EH information.  */\n-\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n-\t    {\n-\t      bitmap_set_bit (need_eh_cleanup,\n-\t\t\t      gimple_bb (stmt)->index);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n-\t    }\n-\t  /* Likewise for AB side-effects.  */\n-\t  if (can_make_abnormal_goto\n-\t      && !stmt_can_make_abnormal_goto (stmt))\n-\t    {\n-\t      bitmap_set_bit (need_ab_cleanup,\n-\t\t\t      gimple_bb (stmt)->index);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Removed AB side-effects.\\n\");\n-\t    }\n-\t  update_stmt (stmt);\n-\t  if (vdef != gimple_vdef (stmt))\n-\t    VN_INFO (vdef)->valnum = vuse;\n-\t}\n-\n-      /* Make new values available - for fully redundant LHS we\n-         continue with the next stmt above and skip this.  */\n-      def_operand_p defp;\n-      FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)\n-\teliminate_push_avail (DEF_FROM_PTR (defp));\n-    }\n-\n-  /* Replace destination PHI arguments.  */\n-  FOR_EACH_EDGE (e, ei, b->succs)\n-    if (e->flags & EDGE_EXECUTABLE)\n-      for (gphi_iterator gsi = gsi_start_phis (e->dest);\n-\t   !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n-\t{\n-\t  gphi *phi = gsi.phi ();\n-\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n-\t  tree arg = USE_FROM_PTR (use_p);\n-\t  if (TREE_CODE (arg) != SSA_NAME\n-\t      || virtual_operand_p (arg))\n-\t    continue;\n-\t  tree sprime = eliminate_avail (arg);\n-\t  if (sprime && may_propagate_copy (arg, sprime))\n-\t    propagate_value (use_p, sprime);\n-\t}\n-  return NULL;\n-}\n-\n-/* Make no longer available leaders no longer available.  */\n-\n-void\n-eliminate_dom_walker::after_dom_children (basic_block)\n-{\n-  tree entry;\n-  while ((entry = avail_stack.pop ()) != NULL_TREE)\n-    {\n-      tree valnum = VN_INFO (entry)->valnum;\n-      tree old = avail[SSA_NAME_VERSION (valnum)];\n-      if (old == entry)\n-\tavail[SSA_NAME_VERSION (valnum)] = NULL_TREE;\n-      else\n-\tavail[SSA_NAME_VERSION (valnum)] = entry;\n-    }\n-}\n-\n-/* Eliminate fully redundant computations.  */\n-\n-static unsigned int\n-eliminate (bool do_pre)\n-{\n-  eliminate_dom_walker el (CDI_DOMINATORS, do_pre);\n-  el.avail.reserve (num_ssa_names);\n-\n-  el.walk (cfun->cfg->x_entry_block_ptr);\n-\n-  /* We cannot remove stmts during BB walk, especially not release SSA\n-     names there as this confuses the VN machinery.  The stmts ending\n-     up in to_remove are either stores or simple copies.\n-     Remove stmts in reverse order to make debug stmt creation possible.  */\n-  while (!el.to_remove.is_empty ())\n-    {\n-      gimple *stmt = el.to_remove.pop ();\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Removing dead stmt \");\n-\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t}\n-\n-      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tremove_phi_node (&gsi, true);\n-      else\n-\t{\n-\t  basic_block bb = gimple_bb (stmt);\n-\t  unlink_stmt_vdef (stmt);\n-\t  if (gsi_remove (&gsi, true))\n-\t    bitmap_set_bit (el.need_eh_cleanup, bb->index);\n-\t  if (is_gimple_call (stmt) && stmt_can_make_abnormal_goto (stmt))\n-\t    bitmap_set_bit (el.need_ab_cleanup, bb->index);\n-\t  release_defs (stmt);\n-\t}\n-\n-      /* Removing a stmt may expose a forwarder block.  */\n-      el.el_todo |= TODO_cleanup_cfg;\n-    }\n-\n-  /* Fixup stmts that became noreturn calls.  This may require splitting\n-     blocks and thus isn't possible during the dominator walk.  Do this\n-     in reverse order so we don't inadvertedly remove a stmt we want to\n-     fixup by visiting a dominating now noreturn call first.  */\n-  while (!el.to_fixup.is_empty ())\n-    {\n-      gimple *stmt = el.to_fixup.pop ();\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Fixing up noreturn call \");\n-\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t}\n-\n-      if (fixup_noreturn_call (stmt))\n-\tel.el_todo |= TODO_cleanup_cfg;\n-    }\n-\n-  bool do_eh_cleanup = !bitmap_empty_p (el.need_eh_cleanup);\n-  bool do_ab_cleanup = !bitmap_empty_p (el.need_ab_cleanup);\n-\n-  if (do_eh_cleanup)\n-    gimple_purge_all_dead_eh_edges (el.need_eh_cleanup);\n-\n-  if (do_ab_cleanup)\n-    gimple_purge_all_dead_abnormal_call_edges (el.need_ab_cleanup);\n-\n-  if (do_eh_cleanup || do_ab_cleanup)\n-    el.el_todo |= TODO_cleanup_cfg;\n-  return el.el_todo;\n-}\n-\n /* Cheap DCE of a known set of possibly dead stmts.\n \n    Because we don't follow exactly the standard PRE algorithm, and decide not\n@@ -5023,13 +4216,12 @@ pass_pre::execute (function *fun)\n   gcc_assert (!need_ssa_update_p (fun));\n \n   /* Remove all the redundant expressions.  */\n-  todo |= eliminate (true);\n+  todo |= vn_eliminate (inserted_exprs);\n \n   statistics_counter_event (fun, \"Insertions\", pre_stats.insertions);\n   statistics_counter_event (fun, \"PA inserted\", pre_stats.pa_insert);\n   statistics_counter_event (fun, \"HOIST inserted\", pre_stats.hoist_insert);\n   statistics_counter_event (fun, \"New PHIs\", pre_stats.phis);\n-  statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n \n   clear_expression_ids ();\n \n@@ -5069,61 +4261,3 @@ make_pass_pre (gcc::context *ctxt)\n {\n   return new pass_pre (ctxt);\n }\n-\n-namespace {\n-\n-const pass_data pass_data_fre =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"fre\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_FRE, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_fre : public gimple_opt_pass\n-{\n-public:\n-  pass_fre (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_fre, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_fre (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_fre != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_fre\n-\n-unsigned int\n-pass_fre::execute (function *fun)\n-{\n-  unsigned int todo = 0;\n-\n-  run_scc_vn (VN_WALKREWRITE);\n-\n-  memset (&pre_stats, 0, sizeof (pre_stats));\n-\n-  /* Remove all the redundant expressions.  */\n-  todo |= eliminate (false);\n-\n-  scc_vn_restore_ssa_info ();\n-  free_scc_vn ();\n-\n-  statistics_counter_event (fun, \"Insertions\", pre_stats.insertions);\n-  statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n-\n-  return todo;\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_fre (gcc::context *ctxt)\n-{\n-  return new pass_fre (ctxt);\n-}"}, {"sha": "306080b6a4148303809f00a147aae0987de0cd75", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 874, "deletions": 1, "changes": 875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=5de583cc1809a49a4b38950d2fc4633e31085a33", "patch": "@@ -55,13 +55,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"params.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"tree-ssa-sccvn.h\"\n #include \"tree-cfg.h\"\n #include \"domwalk.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-match.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"tree-pass.h\"\n+#include \"statistics.h\"\n+#include \"langhooks.h\"\n+#include \"ipa-utils.h\"\n+#include \"dbgcnt.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-sccvn.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n    Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\"\n@@ -5149,3 +5157,868 @@ vn_nary_may_trap (vn_nary_op_t nary)\n \n   return false;\n }\n+\n+\n+class eliminate_dom_walker : public dom_walker\n+{\n+public:\n+  eliminate_dom_walker (cdi_direction, bitmap);\n+  ~eliminate_dom_walker ();\n+\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+  tree eliminate_avail (tree op);\n+  void eliminate_push_avail (tree op);\n+  tree eliminate_insert (gimple_stmt_iterator *gsi, tree val);\n+\n+  bool do_pre;\n+  unsigned int el_todo;\n+  unsigned int eliminations;\n+  unsigned int insertions;\n+\n+  /* SSA names that had their defs inserted by PRE if do_pre.  */\n+  bitmap inserted_exprs;\n+\n+  /* Blocks with statements that have had their EH properties changed.  */\n+  bitmap need_eh_cleanup;\n+\n+  /* Blocks with statements that have had their AB properties changed.  */\n+  bitmap need_ab_cleanup;\n+\n+  auto_vec<gimple *> to_remove;\n+  auto_vec<gimple *> to_fixup;\n+  auto_vec<tree> avail;\n+  auto_vec<tree> avail_stack;\n+};\n+\n+eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,\n+\t\t\t\t\t    bitmap inserted_exprs_)\n+  : dom_walker (direction), do_pre (inserted_exprs_ != NULL),\n+    el_todo (0), eliminations (0), insertions (0),\n+    inserted_exprs (inserted_exprs_)\n+{\n+  need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  need_ab_cleanup = BITMAP_ALLOC (NULL);\n+}\n+\n+eliminate_dom_walker::~eliminate_dom_walker ()\n+{\n+  BITMAP_FREE (need_eh_cleanup);\n+  BITMAP_FREE (need_ab_cleanup);\n+}\n+\n+/* Return a leader for OP that is available at the current point of the\n+   eliminate domwalk.  */\n+\n+tree\n+eliminate_dom_walker::eliminate_avail (tree op)\n+{\n+  tree valnum = VN_INFO (op)->valnum;\n+  if (TREE_CODE (valnum) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (valnum))\n+\treturn valnum;\n+      if (avail.length () > SSA_NAME_VERSION (valnum))\n+\treturn avail[SSA_NAME_VERSION (valnum)];\n+    }\n+  else if (is_gimple_min_invariant (valnum))\n+    return valnum;\n+  return NULL_TREE;\n+}\n+\n+/* At the current point of the eliminate domwalk make OP available.  */\n+\n+void\n+eliminate_dom_walker::eliminate_push_avail (tree op)\n+{\n+  tree valnum = VN_INFO (op)->valnum;\n+  if (TREE_CODE (valnum) == SSA_NAME)\n+    {\n+      if (avail.length () <= SSA_NAME_VERSION (valnum))\n+\tavail.safe_grow_cleared (SSA_NAME_VERSION (valnum) + 1);\n+      tree pushop = op;\n+      if (avail[SSA_NAME_VERSION (valnum)])\n+\tpushop = avail[SSA_NAME_VERSION (valnum)];\n+      avail_stack.safe_push (pushop);\n+      avail[SSA_NAME_VERSION (valnum)] = op;\n+    }\n+}\n+\n+/* Insert the expression recorded by SCCVN for VAL at *GSI.  Returns\n+   the leader for the expression if insertion was successful.  */\n+\n+tree\n+eliminate_dom_walker::eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n+{\n+  /* We can insert a sequence with a single assignment only.  */\n+  gimple_seq stmts = VN_INFO (val)->expr;\n+  if (!gimple_seq_singleton_p (stmts))\n+    return NULL_TREE;\n+  gassign *stmt = dyn_cast <gassign *> (gimple_seq_first_stmt (stmts));\n+  if (!stmt\n+      || (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))\n+\t  && gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR\n+\t  && gimple_assign_rhs_code (stmt) != BIT_FIELD_REF\n+\t  && (gimple_assign_rhs_code (stmt) != BIT_AND_EXPR\n+\t      || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)))\n+    return NULL_TREE;\n+\n+  tree op = gimple_assign_rhs1 (stmt);\n+  if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n+      || gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n+    op = TREE_OPERAND (op, 0);\n+  tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (op) : op;\n+  if (!leader)\n+    return NULL_TREE;\n+\n+  tree res;\n+  stmts = NULL;\n+  if (gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)\n+    res = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\tTREE_TYPE (val), leader,\n+\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 1),\n+\t\t\tTREE_OPERAND (gimple_assign_rhs1 (stmt), 2));\n+  else if (gimple_assign_rhs_code (stmt) == BIT_AND_EXPR)\n+    res = gimple_build (&stmts, BIT_AND_EXPR,\n+\t\t\tTREE_TYPE (val), leader, gimple_assign_rhs2 (stmt));\n+  else\n+    res = gimple_build (&stmts, gimple_assign_rhs_code (stmt),\n+\t\t\tTREE_TYPE (val), leader);\n+  if (TREE_CODE (res) != SSA_NAME\n+      || SSA_NAME_IS_DEFAULT_DEF (res)\n+      || gimple_bb (SSA_NAME_DEF_STMT (res)))\n+    {\n+      gimple_seq_discard (stmts);\n+\n+      /* During propagation we have to treat SSA info conservatively\n+         and thus we can end up simplifying the inserted expression\n+\t at elimination time to sth not defined in stmts.  */\n+      /* But then this is a redundancy we failed to detect.  Which means\n+         res now has two values.  That doesn't play well with how\n+\t we track availability here, so give up.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  if (TREE_CODE (res) == SSA_NAME)\n+\t    res = eliminate_avail (res);\n+\t  if (res)\n+\t    {\n+\t      fprintf (dump_file, \"Failed to insert expression for value \");\n+\t      print_generic_expr (dump_file, val);\n+\t      fprintf (dump_file, \" which is really fully redundant to \");\n+\t      print_generic_expr (dump_file, res);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+  else\n+    {\n+      gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+      VN_INFO_GET (res)->valnum = val;\n+    }\n+\n+  insertions++;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Inserted \");\n+      print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (res), 0);\n+    }\n+\n+  return res;\n+}\n+\n+\n+\n+/* Perform elimination for the basic-block B during the domwalk.  */\n+\n+edge\n+eliminate_dom_walker::before_dom_children (basic_block b)\n+{\n+  /* Mark new bb.  */\n+  avail_stack.safe_push (NULL_TREE);\n+\n+  /* Skip unreachable blocks marked unreachable during the SCCVN domwalk.  */\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, b->preds)\n+    if (e->flags & EDGE_EXECUTABLE)\n+      break;\n+  if (! e)\n+    return NULL;\n+\n+  for (gphi_iterator gsi = gsi_start_phis (b); !gsi_end_p (gsi);)\n+    {\n+      gphi *phi = gsi.phi ();\n+      tree res = PHI_RESULT (phi);\n+\n+      if (virtual_operand_p (res))\n+\t{\n+\t  gsi_next (&gsi);\n+\t  continue;\n+\t}\n+\n+      tree sprime = eliminate_avail (res);\n+      if (sprime\n+\t  && sprime != res)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Replaced redundant PHI node defining \");\n+\t      print_generic_expr (dump_file, res);\n+\t      fprintf (dump_file, \" with \");\n+\t      print_generic_expr (dump_file, sprime);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  /* If we inserted this PHI node ourself, it's not an elimination.  */\n+\t  if (! inserted_exprs\n+\t      || ! bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))\n+\t    eliminations++;\n+\n+\t  /* If we will propagate into all uses don't bother to do\n+\t     anything.  */\n+\t  if (may_propagate_copy (res, sprime))\n+\t    {\n+\t      /* Mark the PHI for removal.  */\n+\t      to_remove.safe_push (phi);\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n+\n+\t  remove_phi_node (&gsi, false);\n+\n+\t  if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))\n+\t    sprime = fold_convert (TREE_TYPE (res), sprime);\n+\t  gimple *stmt = gimple_build_assign (res, sprime);\n+\t  gimple_stmt_iterator gsi2 = gsi_after_labels (b);\n+\t  gsi_insert_before (&gsi2, stmt, GSI_NEW_STMT);\n+\t  continue;\n+\t}\n+\n+      eliminate_push_avail (res);\n+      gsi_next (&gsi);\n+    }\n+\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (b);\n+       !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      tree sprime = NULL_TREE;\n+      gimple *stmt = gsi_stmt (gsi);\n+      tree lhs = gimple_get_lhs (stmt);\n+      if (lhs && TREE_CODE (lhs) == SSA_NAME\n+\t  && !gimple_has_volatile_ops (stmt)\n+\t  /* See PR43491.  Do not replace a global register variable when\n+\t     it is a the RHS of an assignment.  Do replace local register\n+\t     variables since gcc does not guarantee a local variable will\n+\t     be allocated in register.\n+\t     ???  The fix isn't effective here.  This should instead\n+\t     be ensured by not value-numbering them the same but treating\n+\t     them like volatiles?  */\n+\t  && !(gimple_assign_single_p (stmt)\n+\t       && (TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL\n+\t\t   && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt))\n+\t\t   && is_global_var (gimple_assign_rhs1 (stmt)))))\n+\t{\n+\t  sprime = eliminate_avail (lhs);\n+\t  if (!sprime)\n+\t    {\n+\t      /* If there is no existing usable leader but SCCVN thinks\n+\t\t it has an expression it wants to use as replacement,\n+\t\t insert that.  */\n+\t      tree val = VN_INFO (lhs)->valnum;\n+\t      if (val != VN_TOP\n+\t\t  && TREE_CODE (val) == SSA_NAME\n+\t\t  && VN_INFO (val)->needs_insertion\n+\t\t  && VN_INFO (val)->expr != NULL\n+\t\t  && (sprime = eliminate_insert (&gsi, val)) != NULL_TREE)\n+\t\teliminate_push_avail (sprime);\n+\t    }\n+\n+\t  /* If this now constitutes a copy duplicate points-to\n+\t     and range info appropriately.  This is especially\n+\t     important for inserted code.  See tree-ssa-copy.c\n+\t     for similar code.  */\n+\t  if (sprime\n+\t      && TREE_CODE (sprime) == SSA_NAME)\n+\t    {\n+\t      basic_block sprime_b = gimple_bb (SSA_NAME_DEF_STMT (sprime));\n+\t      if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t\t  && VN_INFO_PTR_INFO (lhs)\n+\t\t  && ! VN_INFO_PTR_INFO (sprime))\n+\t\t{\n+\t\t  duplicate_ssa_name_ptr_info (sprime,\n+\t\t\t\t\t       VN_INFO_PTR_INFO (lhs));\n+\t\t  if (b != sprime_b)\n+\t\t    mark_ptr_info_alignment_unknown\n+\t\t\t(SSA_NAME_PTR_INFO (sprime));\n+\t\t}\n+\t      else if (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t\t       && VN_INFO_RANGE_INFO (lhs)\n+\t\t       && ! VN_INFO_RANGE_INFO (sprime)\n+\t\t       && b == sprime_b)\n+\t\tduplicate_ssa_name_range_info (sprime,\n+\t\t\t\t\t       VN_INFO_RANGE_TYPE (lhs),\n+\t\t\t\t\t       VN_INFO_RANGE_INFO (lhs));\n+\t    }\n+\n+\t  /* Inhibit the use of an inserted PHI on a loop header when\n+\t     the address of the memory reference is a simple induction\n+\t     variable.  In other cases the vectorizer won't do anything\n+\t     anyway (either it's loop invariant or a complicated\n+\t     expression).  */\n+\t  if (sprime\n+\t      && TREE_CODE (sprime) == SSA_NAME\n+\t      && do_pre\n+\t      && (flag_tree_loop_vectorize || flag_tree_parallelize_loops > 1)\n+\t      && loop_outer (b->loop_father)\n+\t      && has_zero_uses (sprime)\n+\t      && bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))\n+\t      && gimple_assign_load_p (stmt))\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (sprime);\n+\t      basic_block def_bb = gimple_bb (def_stmt);\n+\t      if (gimple_code (def_stmt) == GIMPLE_PHI\n+\t\t  && def_bb->loop_father->header == def_bb)\n+\t\t{\n+\t\t  loop_p loop = def_bb->loop_father;\n+\t\t  ssa_op_iter iter;\n+\t\t  tree op;\n+\t\t  bool found = false;\n+\t\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\t\t    {\n+\t\t      affine_iv iv;\n+\t\t      def_bb = gimple_bb (SSA_NAME_DEF_STMT (op));\n+\t\t      if (def_bb\n+\t\t\t  && flow_bb_inside_loop_p (loop, def_bb)\n+\t\t\t  && simple_iv (loop, loop, op, &iv, true))\n+\t\t\t{\n+\t\t\t  found = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  if (found)\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"Not replacing \");\n+\t\t\t  print_gimple_expr (dump_file, stmt, 0);\n+\t\t\t  fprintf (dump_file, \" with \");\n+\t\t\t  print_generic_expr (dump_file, sprime);\n+\t\t\t  fprintf (dump_file, \" which would add a loop\"\n+\t\t\t\t   \" carried dependence to loop %d\\n\",\n+\t\t\t\t   loop->num);\n+\t\t\t}\n+\t\t      /* Don't keep sprime available.  */\n+\t\t      sprime = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (sprime)\n+\t    {\n+\t      /* If we can propagate the value computed for LHS into\n+\t\t all uses don't bother doing anything with this stmt.  */\n+\t      if (may_propagate_copy (lhs, sprime))\n+\t\t{\n+\t\t  /* Mark it for removal.  */\n+\t\t  to_remove.safe_push (stmt);\n+\n+\t\t  /* ???  Don't count copy/constant propagations.  */\n+\t\t  if (gimple_assign_single_p (stmt)\n+\t\t      && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+\t\t\t  || gimple_assign_rhs1 (stmt) == sprime))\n+\t\t    continue;\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Replaced \");\n+\t\t      print_gimple_expr (dump_file, stmt, 0);\n+\t\t      fprintf (dump_file, \" with \");\n+\t\t      print_generic_expr (dump_file, sprime);\n+\t\t      fprintf (dump_file, \" in all uses of \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0);\n+\t\t    }\n+\n+\t\t  eliminations++;\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* If this is an assignment from our leader (which\n+\t         happens in the case the value-number is a constant)\n+\t\t then there is nothing to do.  */\n+\t      if (gimple_assign_single_p (stmt)\n+\t\t  && sprime == gimple_assign_rhs1 (stmt))\n+\t\tcontinue;\n+\n+\t      /* Else replace its RHS.  */\n+\t      bool can_make_abnormal_goto\n+\t\t  = is_gimple_call (stmt)\n+\t\t  && stmt_can_make_abnormal_goto (stmt);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Replaced \");\n+\t\t  print_gimple_expr (dump_file, stmt, 0);\n+\t\t  fprintf (dump_file, \" with \");\n+\t\t  print_generic_expr (dump_file, sprime);\n+\t\t  fprintf (dump_file, \" in \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t\t}\n+\n+\t      eliminations++;\n+\t      gimple *orig_stmt = stmt;\n+\t      if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t      TREE_TYPE (sprime)))\n+\t\tsprime = fold_convert (TREE_TYPE (lhs), sprime);\n+\t      tree vdef = gimple_vdef (stmt);\n+\t      tree vuse = gimple_vuse (stmt);\n+\t      propagate_tree_value_into_stmt (&gsi, sprime);\n+\t      stmt = gsi_stmt (gsi);\n+\t      update_stmt (stmt);\n+\t      if (vdef != gimple_vdef (stmt))\n+\t\tVN_INFO (vdef)->valnum = vuse;\n+\n+\t      /* If we removed EH side-effects from the statement, clean\n+\t\t its EH information.  */\n+\t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n+\t\t{\n+\t\t  bitmap_set_bit (need_eh_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t\t}\n+\n+\t      /* Likewise for AB side-effects.  */\n+\t      if (can_make_abnormal_goto\n+\t\t  && !stmt_can_make_abnormal_goto (stmt))\n+\t\t{\n+\t\t  bitmap_set_bit (need_ab_cleanup,\n+\t\t\t\t  gimple_bb (stmt)->index);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"  Removed AB side-effects.\\n\");\n+\t\t}\n+\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* If the statement is a scalar store, see if the expression\n+         has the same value number as its rhs.  If so, the store is\n+         dead.  */\n+      if (gimple_assign_single_p (stmt)\n+\t  && !gimple_has_volatile_ops (stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (stmt))\n+\t  && (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+\t      || is_gimple_min_invariant (gimple_assign_rhs1 (stmt))))\n+\t{\n+\t  tree val;\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t  vn_reference_t vnresult;\n+\t  val = vn_reference_lookup (lhs, gimple_vuse (stmt), VN_WALKREWRITE,\n+\t\t\t\t     &vnresult, false);\n+\t  if (TREE_CODE (rhs) == SSA_NAME)\n+\t    rhs = VN_INFO (rhs)->valnum;\n+\t  if (val\n+\t      && operand_equal_p (val, rhs, 0))\n+\t    {\n+\t      /* We can only remove the later store if the former aliases\n+\t\t at least all accesses the later one does or if the store\n+\t\t was to readonly memory storing the same value.  */\n+\t      alias_set_type set = get_alias_set (lhs);\n+\t      if (! vnresult\n+\t\t  || vnresult->set == set\n+\t\t  || alias_set_subset_of (set, vnresult->set))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Deleted redundant store \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0);\n+\t\t    }\n+\n+\t\t  /* Queue stmt for removal.  */\n+\t\t  to_remove.safe_push (stmt);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If this is a control statement value numbering left edges\n+\t unexecuted on force the condition in a way consistent with\n+\t that.  */\n+      if (gcond *cond = dyn_cast <gcond *> (stmt))\n+\t{\n+\t  if ((EDGE_SUCC (b, 0)->flags & EDGE_EXECUTABLE)\n+\t      ^ (EDGE_SUCC (b, 1)->flags & EDGE_EXECUTABLE))\n+\t    {\n+              if (dump_file && (dump_flags & TDF_DETAILS))\n+                {\n+                  fprintf (dump_file, \"Removing unexecutable edge from \");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0);\n+                }\n+\t      if (((EDGE_SUCC (b, 0)->flags & EDGE_TRUE_VALUE) != 0)\n+\t\t  == ((EDGE_SUCC (b, 0)->flags & EDGE_EXECUTABLE) != 0))\n+\t\tgimple_cond_make_true (cond);\n+\t      else\n+\t\tgimple_cond_make_false (cond);\n+\t      update_stmt (cond);\n+\t      el_todo |= TODO_cleanup_cfg;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      bool can_make_abnormal_goto = stmt_can_make_abnormal_goto (stmt);\n+      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_noreturn_p (stmt));\n+      tree vdef = gimple_vdef (stmt);\n+      tree vuse = gimple_vuse (stmt);\n+\n+      /* If we didn't replace the whole stmt (or propagate the result\n+         into all uses), replace all uses on this stmt with their\n+\t leaders.  */\n+      bool modified = false;\n+      use_operand_p use_p;\n+      ssa_op_iter iter;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  tree use = USE_FROM_PTR (use_p);\n+\t  /* ???  The call code above leaves stmt operands un-updated.  */\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\t  tree sprime = eliminate_avail (use);\n+\t  if (sprime && sprime != use\n+\t      && may_propagate_copy (use, sprime)\n+\t      /* We substitute into debug stmts to avoid excessive\n+\t         debug temporaries created by removed stmts, but we need\n+\t\t to avoid doing so for inserted sprimes as we never want\n+\t\t to create debug temporaries for them.  */\n+\t      && (!inserted_exprs\n+\t\t  || TREE_CODE (sprime) != SSA_NAME\n+\t\t  || !is_gimple_debug (stmt)\n+\t\t  || !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))))\n+\t    {\n+\t      propagate_value (use_p, sprime);\n+\t      modified = true;\n+\t    }\n+\t}\n+\n+      /* Fold the stmt if modified, this canonicalizes MEM_REFs we propagated\n+         into which is a requirement for the IPA devirt machinery.  */\n+      gimple *old_stmt = stmt;\n+      if (modified)\n+\t{\n+\t  /* If a formerly non-invariant ADDR_EXPR is turned into an\n+\t     invariant one it was on a separate stmt.  */\n+\t  if (gimple_assign_single_p (stmt)\n+\t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));\n+\t  gimple_stmt_iterator prev = gsi;\n+\t  gsi_prev (&prev);\n+\t  if (fold_stmt (&gsi))\n+\t    {\n+\t      /* fold_stmt may have created new stmts inbetween\n+\t\t the previous stmt and the folded stmt.  Mark\n+\t\t all defs created there as varying to not confuse\n+\t\t the SCCVN machinery as we're using that even during\n+\t\t elimination.  */\n+\t      if (gsi_end_p (prev))\n+\t\tprev = gsi_start_bb (b);\n+\t      else\n+\t\tgsi_next (&prev);\n+\t      if (gsi_stmt (prev) != gsi_stmt (gsi))\n+\t\tdo\n+\t\t  {\n+\t\t    tree def;\n+\t\t    ssa_op_iter dit;\n+\t\t    FOR_EACH_SSA_TREE_OPERAND (def, gsi_stmt (prev),\n+\t\t\t\t\t       dit, SSA_OP_ALL_DEFS)\n+\t\t      /* As existing DEFs may move between stmts\n+\t\t\t we have to guard VN_INFO_GET.  */\n+\t\t      if (! has_VN_INFO (def))\n+\t\t\tVN_INFO_GET (def)->valnum = def;\n+\t\t    if (gsi_stmt (prev) == gsi_stmt (gsi))\n+\t\t      break;\n+\t\t    gsi_next (&prev);\n+\t\t  }\n+\t\twhile (1);\n+\t    }\n+\t  stmt = gsi_stmt (gsi);\n+\t  /* In case we folded the stmt away schedule the NOP for removal.  */\n+\t  if (gimple_nop_p (stmt))\n+\t    to_remove.safe_push (stmt);\n+\t}\n+\n+      /* Visit indirect calls and turn them into direct calls if\n+\t possible using the devirtualization machinery.  Do this before\n+\t checking for required EH/abnormal/noreturn cleanup as devird\n+\t may expose more of those.  */\n+      if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n+\t{\n+\t  tree fn = gimple_call_fn (call_stmt);\n+\t  if (fn\n+\t      && flag_devirtualize\n+\t      && virtual_method_call_p (fn))\n+\t    {\n+\t      tree otr_type = obj_type_ref_class (fn);\n+\t      unsigned HOST_WIDE_INT otr_tok\n+\t\t= tree_to_uhwi (OBJ_TYPE_REF_TOKEN (fn));\n+\t      tree instance;\n+\t      ipa_polymorphic_call_context context (current_function_decl,\n+\t\t\t\t\t\t    fn, stmt, &instance);\n+\t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn),\n+\t\t\t\t\totr_type, stmt);\n+\t      bool final;\n+\t      vec <cgraph_node *> targets\n+\t\t= possible_polymorphic_call_targets (obj_type_ref_class (fn),\n+\t\t\t\t\t\t     otr_tok, context, &final);\n+\t      if (dump_file)\n+\t\tdump_possible_polymorphic_call_targets (dump_file, \n+\t\t\t\t\t\t\tobj_type_ref_class (fn),\n+\t\t\t\t\t\t\totr_tok, context);\n+\t      if (final && targets.length () <= 1 && dbg_cnt (devirt))\n+\t\t{\n+\t\t  tree fn;\n+\t\t  if (targets.length () == 1)\n+\t\t    fn = targets[0]->decl;\n+\t\t  else\n+\t\t    fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      location_t loc = gimple_location (stmt);\n+\t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t\t\t       \"converting indirect call to \"\n+\t\t\t\t       \"function %s\\n\",\n+\t\t\t\t       lang_hooks.decl_printable_name (fn, 2));\n+\t\t    }\n+\t\t  gimple_call_set_fndecl (call_stmt, fn);\n+\t\t  /* If changing the call to __builtin_unreachable\n+\t\t     or similar noreturn function, adjust gimple_call_fntype\n+\t\t     too.  */\n+\t\t  if (gimple_call_noreturn_p (call_stmt)\n+\t\t      && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fn)))\n+\t\t      && TYPE_ARG_TYPES (TREE_TYPE (fn))\n+\t\t      && (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fn)))\n+\t\t\t  == void_type_node))\n+\t\t    gimple_call_set_fntype (call_stmt, TREE_TYPE (fn));\n+\t\t  maybe_remove_unused_call_args (cfun, call_stmt);\n+\t\t  modified = true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (modified)\n+\t{\n+\t  /* When changing a call into a noreturn call, cfg cleanup\n+\t     is needed to fix up the noreturn call.  */\n+\t  if (!was_noreturn\n+\t      && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n+\t    to_fixup.safe_push  (stmt);\n+\t  /* When changing a condition or switch into one we know what\n+\t     edge will be executed, schedule a cfg cleanup.  */\n+\t  if ((gimple_code (stmt) == GIMPLE_COND\n+\t       && (gimple_cond_true_p (as_a <gcond *> (stmt))\n+\t\t   || gimple_cond_false_p (as_a <gcond *> (stmt))))\n+\t      || (gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t  && TREE_CODE (gimple_switch_index\n+\t\t\t\t  (as_a <gswitch *> (stmt))) == INTEGER_CST))\n+\t    el_todo |= TODO_cleanup_cfg;\n+\t  /* If we removed EH side-effects from the statement, clean\n+\t     its EH information.  */\n+\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\t    {\n+\t      bitmap_set_bit (need_eh_cleanup,\n+\t\t\t      gimple_bb (stmt)->index);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Removed EH side-effects.\\n\");\n+\t    }\n+\t  /* Likewise for AB side-effects.  */\n+\t  if (can_make_abnormal_goto\n+\t      && !stmt_can_make_abnormal_goto (stmt))\n+\t    {\n+\t      bitmap_set_bit (need_ab_cleanup,\n+\t\t\t      gimple_bb (stmt)->index);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Removed AB side-effects.\\n\");\n+\t    }\n+\t  update_stmt (stmt);\n+\t  if (vdef != gimple_vdef (stmt))\n+\t    VN_INFO (vdef)->valnum = vuse;\n+\t}\n+\n+      /* Make new values available - for fully redundant LHS we\n+         continue with the next stmt above and skip this.  */\n+      def_operand_p defp;\n+      FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)\n+\teliminate_push_avail (DEF_FROM_PTR (defp));\n+    }\n+\n+  /* Replace destination PHI arguments.  */\n+  FOR_EACH_EDGE (e, ei, b->succs)\n+    if (e->flags & EDGE_EXECUTABLE)\n+      for (gphi_iterator gsi = gsi_start_phis (e->dest);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  tree arg = USE_FROM_PTR (use_p);\n+\t  if (TREE_CODE (arg) != SSA_NAME\n+\t      || virtual_operand_p (arg))\n+\t    continue;\n+\t  tree sprime = eliminate_avail (arg);\n+\t  if (sprime && may_propagate_copy (arg, sprime))\n+\t    propagate_value (use_p, sprime);\n+\t}\n+  return NULL;\n+}\n+\n+/* Make no longer available leaders no longer available.  */\n+\n+void\n+eliminate_dom_walker::after_dom_children (basic_block)\n+{\n+  tree entry;\n+  while ((entry = avail_stack.pop ()) != NULL_TREE)\n+    {\n+      tree valnum = VN_INFO (entry)->valnum;\n+      tree old = avail[SSA_NAME_VERSION (valnum)];\n+      if (old == entry)\n+\tavail[SSA_NAME_VERSION (valnum)] = NULL_TREE;\n+      else\n+\tavail[SSA_NAME_VERSION (valnum)] = entry;\n+    }\n+}\n+\n+/* Eliminate fully redundant computations.  */\n+\n+unsigned int\n+vn_eliminate (bitmap inserted_exprs)\n+{\n+  eliminate_dom_walker el (CDI_DOMINATORS, inserted_exprs);\n+  el.avail.reserve (num_ssa_names);\n+\n+  el.walk (cfun->cfg->x_entry_block_ptr);\n+\n+  /* We cannot remove stmts during BB walk, especially not release SSA\n+     names there as this confuses the VN machinery.  The stmts ending\n+     up in to_remove are either stores or simple copies.\n+     Remove stmts in reverse order to make debug stmt creation possible.  */\n+  while (!el.to_remove.is_empty ())\n+    {\n+      gimple *stmt = el.to_remove.pop ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Removing dead stmt \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tremove_phi_node (&gsi, true);\n+      else\n+\t{\n+\t  basic_block bb = gimple_bb (stmt);\n+\t  unlink_stmt_vdef (stmt);\n+\t  if (gsi_remove (&gsi, true))\n+\t    bitmap_set_bit (el.need_eh_cleanup, bb->index);\n+\t  if (is_gimple_call (stmt) && stmt_can_make_abnormal_goto (stmt))\n+\t    bitmap_set_bit (el.need_ab_cleanup, bb->index);\n+\t  release_defs (stmt);\n+\t}\n+\n+      /* Removing a stmt may expose a forwarder block.  */\n+      el.el_todo |= TODO_cleanup_cfg;\n+    }\n+\n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!el.to_fixup.is_empty ())\n+    {\n+      gimple *stmt = el.to_fixup.pop ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Fixing up noreturn call \");\n+\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t}\n+\n+      if (fixup_noreturn_call (stmt))\n+\tel.el_todo |= TODO_cleanup_cfg;\n+    }\n+\n+  bool do_eh_cleanup = !bitmap_empty_p (el.need_eh_cleanup);\n+  bool do_ab_cleanup = !bitmap_empty_p (el.need_ab_cleanup);\n+\n+  if (do_eh_cleanup)\n+    gimple_purge_all_dead_eh_edges (el.need_eh_cleanup);\n+\n+  if (do_ab_cleanup)\n+    gimple_purge_all_dead_abnormal_call_edges (el.need_ab_cleanup);\n+\n+  if (do_eh_cleanup || do_ab_cleanup)\n+    el.el_todo |= TODO_cleanup_cfg;\n+\n+  statistics_counter_event (cfun, \"Eliminated\", el.eliminations);\n+  statistics_counter_event (cfun, \"Insertions\", el.insertions);\n+\n+  return el.el_todo;\n+}\n+\n+\n+namespace {\n+\n+const pass_data pass_data_fre =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"fre\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_FRE, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_fre : public gimple_opt_pass\n+{\n+public:\n+  pass_fre (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_fre, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_fre (m_ctxt); }\n+  virtual bool gate (function *) { return flag_tree_fre != 0; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_fre\n+\n+unsigned int\n+pass_fre::execute (function *)\n+{\n+  unsigned int todo = 0;\n+\n+  run_scc_vn (VN_WALKREWRITE);\n+\n+  /* Remove all the redundant expressions.  */\n+  todo |= vn_eliminate (NULL);\n+\n+  scc_vn_restore_ssa_info ();\n+  free_scc_vn ();\n+\n+  return todo;\n+}\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_fre (gcc::context *ctxt)\n+{\n+  return new pass_fre (ctxt);\n+}"}, {"sha": "38877bc62c4e8c406e4409c1b09abfe30fb1ed6b", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5de583cc1809a49a4b38950d2fc4633e31085a33/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=5de583cc1809a49a4b38950d2fc4633e31085a33", "patch": "@@ -214,6 +214,7 @@ extern vn_ssa_aux_t VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO_GET (tree);\n tree vn_get_expr_for (tree);\n void run_scc_vn (vn_lookup_kind);\n+unsigned int vn_eliminate (bitmap);\n void free_scc_vn (void);\n void scc_vn_restore_ssa_info (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);"}]}