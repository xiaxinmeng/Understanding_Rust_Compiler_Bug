{"sha": "df62f951d005dd50be23fd6e28f3ed813b708251", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY2MmY5NTFkMDA1ZGQ1MGJlMjNmZDZlMjhmM2VkODEzYjcwODI1MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-17T09:52:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-17T09:52:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1611", "tree": {"sha": "68a30c50bcfdf3ef17c1f89ee9dfea147160c35e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68a30c50bcfdf3ef17c1f89ee9dfea147160c35e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df62f951d005dd50be23fd6e28f3ed813b708251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df62f951d005dd50be23fd6e28f3ed813b708251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df62f951d005dd50be23fd6e28f3ed813b708251", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df62f951d005dd50be23fd6e28f3ed813b708251/comments", "author": null, "committer": null, "parents": [{"sha": "a8ddbf69e5f8af8fea9b676701e9d9a0711a82c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ddbf69e5f8af8fea9b676701e9d9a0711a82c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ddbf69e5f8af8fea9b676701e9d9a0711a82c2"}], "stats": {"total": 124, "additions": 72, "deletions": 52}, "files": [{"sha": "b3865ed06d2adb2fa73e05801460e18bf7ffea16", "filename": "gcc/combine.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f951d005dd50be23fd6e28f3ed813b708251/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f951d005dd50be23fd6e28f3ed813b708251/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=df62f951d005dd50be23fd6e28f3ed813b708251", "patch": "@@ -3182,49 +3182,6 @@ subst (x, from, to, in_dest, unique_copy)\n       /* Convert this into a field assignment operation, if possible.  */\n       x = make_field_assignment (x);\n \n-      /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some\n-\t operation, and X being a REG or (subreg (reg)), we may be able to\n-\t convert this to (set (subreg:m2 x) (op)).\n-\n-\t We can always do this if M1 is narrower than M2 because that\n-\t means that we only care about the low bits of the result.\n-\n-\t However, on most machines (those with BYTE_LOADS_ZERO_EXTEND\n-\t not defined), we cannot perform a narrower operation that\n-\t requested since the high-order bits will be undefined.  On\n-\t machine where BYTE_LOADS_ZERO_EXTEND are defined, however, this\n-\t transformation is safe as long as M1 and M2 have the same number\n-\t of words.  */\n- \n-      if (GET_CODE (SET_SRC (x)) == SUBREG\n-\t  && subreg_lowpart_p (SET_SRC (x))\n-\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (SET_SRC (x)))) != 'o'\n-\t  && (((GET_MODE_SIZE (GET_MODE (SET_SRC (x))) + (UNITS_PER_WORD - 1))\n-\t       / UNITS_PER_WORD)\n-\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n-\t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-#ifndef BYTE_LOADS_ZERO_EXTEND\n-\t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n-\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n-#endif\n-\t  && (GET_CODE (SET_DEST (x)) == REG\n-\t      || (GET_CODE (SET_DEST (x)) == SUBREG\n-\t\t  && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG)))\n-\t{\n-\t  /* Get the object that will be the SUBREG_REG of the\n-\t     SUBREG we are making.  Note that SUBREG_WORD will always\n-\t     be zero because this will either be a paradoxical SUBREG\n-\t     or a SUBREG with the same number of words on the outside and\n-\t     inside.  */\n-\t  rtx object = (GET_CODE (SET_DEST (x)) == REG ? SET_DEST (x)\n-\t\t\t: SUBREG_REG (SET_DEST (x)));\n-\n-\t  SUBST (SET_DEST (x),\n-\t\t gen_rtx (SUBREG, GET_MODE (SUBREG_REG (SET_SRC (x))),\n-\t\t\t  object, 0));\n-\t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n-\t}\n-\n       /* If we are setting CC0 or if the source is a COMPARE, look for the\n \t use of the comparison result and try to simplify it unless we already\n \t have used undobuf.other_insn.  */\n@@ -3356,6 +3313,49 @@ subst (x, from, to, in_dest, unique_copy)\n \t  SUBST (SET_SRC (x), temp);\n \t}\n \n+      /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some\n+\t operation, and X being a REG or (subreg (reg)), we may be able to\n+\t convert this to (set (subreg:m2 x) (op)).\n+\n+\t We can always do this if M1 is narrower than M2 because that\n+\t means that we only care about the low bits of the result.\n+\n+\t However, on most machines (those with BYTE_LOADS_ZERO_EXTEND\n+\t not defined), we cannot perform a narrower operation that\n+\t requested since the high-order bits will be undefined.  On\n+\t machine where BYTE_LOADS_ZERO_EXTEND are defined, however, this\n+\t transformation is safe as long as M1 and M2 have the same number\n+\t of words.  */\n+ \n+      if (GET_CODE (SET_SRC (x)) == SUBREG\n+\t  && subreg_lowpart_p (SET_SRC (x))\n+\t  && GET_RTX_CLASS (GET_CODE (SUBREG_REG (SET_SRC (x)))) != 'o'\n+\t  && (((GET_MODE_SIZE (GET_MODE (SET_SRC (x))) + (UNITS_PER_WORD - 1))\n+\t       / UNITS_PER_WORD)\n+\t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n+\t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n+#ifndef BYTE_LOADS_ZERO_EXTEND\n+\t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n+#endif\n+\t  && (GET_CODE (SET_DEST (x)) == REG\n+\t      || (GET_CODE (SET_DEST (x)) == SUBREG\n+\t\t  && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG)))\n+\t{\n+\t  /* Get the object that will be the SUBREG_REG of the\n+\t     SUBREG we are making.  Note that SUBREG_WORD will always\n+\t     be zero because this will either be a paradoxical SUBREG\n+\t     or a SUBREG with the same number of words on the outside and\n+\t     inside.  */\n+\t  rtx object = (GET_CODE (SET_DEST (x)) == REG ? SET_DEST (x)\n+\t\t\t: SUBREG_REG (SET_DEST (x)));\n+\n+\t  SUBST (SET_DEST (x),\n+\t\t gen_rtx (SUBREG, GET_MODE (SUBREG_REG (SET_SRC (x))),\n+\t\t\t  object, 0));\n+\t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n+\t}\n+\n #ifdef BYTE_LOADS_ZERO_EXTEND\n       /* If we have (set FOO (subreg:M (mem:N BAR) 0)) with\n \t M wider than N, this would require a paradoxical subreg.\n@@ -4029,10 +4029,11 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   if (tmode != BLKmode\n       && ! (spans_byte && inner_mode != tmode)\n-      && ((pos == 0 && GET_CODE (inner) == REG\n+      && ((pos == 0 && GET_CODE (inner) != MEM\n \t   && (! in_dest\n-\t       || (movstrict_optab->handlers[(int) tmode].insn_code\n-\t\t   != CODE_FOR_nothing)))\n+\t       || (GET_CODE (inner) == REG\n+\t\t   && (movstrict_optab->handlers[(int) tmode].insn_code\n+\t\t       != CODE_FOR_nothing))))\n \t  || (GET_CODE (inner) == MEM && pos >= 0\n \t      && (pos\n \t\t  % (STRICT_ALIGNMENT ? GET_MODE_ALIGNMENT (tmode)\n@@ -4051,7 +4052,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t adjust the offset.  Otherwise, we do if bytes big endian.  \n \n \t If INNER is not a MEM, get a piece consisting of the just the field\n-\t of interest (in this case INNER must be a REG and POS must be 0).  */\n+\t of interest (in this case POS must be 0).  */\n \n       if (GET_CODE (inner) == MEM)\n \t{\n@@ -4066,7 +4067,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (inner);\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (inner);\n \t}\n-      else if (GET_MODE (inner) == REG)\n+      else if (GET_CODE (inner) == REG)\n \t/* We can't call gen_lowpart_for_combine here since we always want\n \t   a SUBREG and it would sometimes return a new hard register.  */\n \tnew = gen_rtx (SUBREG, tmode, inner,\n@@ -4417,7 +4418,7 @@ make_compound_operation (x, in_code)\n \n   if (new)\n     {\n-      x = new;\n+      x = gen_lowpart_for_combine (mode, new);\n       code = GET_CODE (x);\n     }\n "}, {"sha": "62f8d673d8fdcda5bb391aa0d9f1c03505572c2c", "filename": "gcc/reload.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f951d005dd50be23fd6e28f3ed813b708251/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f951d005dd50be23fd6e28f3ed813b708251/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=df62f951d005dd50be23fd6e28f3ed813b708251", "patch": "@@ -476,7 +476,10 @@ push_reload (in, out, inloc, outloc, class,\n      we can't handle it here because CONST_INT does not indicate a mode.\n \n      Similarly, we must reload the inside expression if we have a\n-     STRICT_LOW_PART (presumably, in == out in the cas).  */\n+     STRICT_LOW_PART (presumably, in == out in the cas).\n+\n+     Also reload the inner expression if it does not require a secondary\n+     reload but the SUBREG does.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n       && (GET_CODE (SUBREG_REG (in)) != REG\n@@ -494,7 +497,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t   / UNITS_PER_WORD)\n \t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))))\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+\t  || (SECONDARY_INPUT_RELOAD_CLASS (class, inmode, in) != NO_REGS\n+\t      && (SECONDARY_INPUT_RELOAD_CLASS (class,\n+\t\t\t\t\t\tGET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\tSUBREG_REG (in))\n+\t\t  == NO_REGS))\n+#endif\n+\t  ))\n     {\n       in_subreg_loc = inloc;\n       inloc = &SUBREG_REG (in);\n@@ -529,7 +540,15 @@ push_reload (in, out, inloc, outloc, class,\n \t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n \t\t\t   / UNITS_PER_WORD)\n \t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (out)))))))))\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (out)))))))\n+#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n+\t  || (SECONDARY_OUTPUT_RELOAD_CLASS (class, outmode, out) != NO_REGS\n+\t      && (SECONDARY_OUTPUT_RELOAD_CLASS (class,\n+\t\t\t\t\t\t GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t\t SUBREG_REG (out))\n+\t\t  == NO_REGS))\n+#endif\n+\t  ))\n     {\n       out_subreg_loc = outloc;\n       outloc = &SUBREG_REG (out);"}]}