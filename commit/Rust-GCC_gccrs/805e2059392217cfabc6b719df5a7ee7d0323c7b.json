{"sha": "805e2059392217cfabc6b719df5a7ee7d0323c7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA1ZTIwNTkzOTIyMTdjZmFiYzZiNzE5ZGY1YTdlZTdkMDMyM2M3Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-09-09T08:46:12Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-09-09T08:46:12Z"}, "message": "tree-vectorizer.h (enum vect_def_type): Start enumeration from 1.\n\n\t* tree-vectorizer.h (enum vect_def_type): Start enumeration from 1.\n\t(struct _slp_tree, struct _slp_instance): Define new data structures\n\talong macros for their access.\n\t(struct _loop_vec_info): Define new fields: strided_stores,\n\tslp_instances, and slp_unrolling_factor along macros for their access.\n\t(enum slp_vect_type): New.\n\t(struct _stmt_vec_info): Define new field, slp_type, and macros for its\n\taccess.\n\t(STMT_VINFO_STRIDED_ACCESS): New macro.\n\t(vect_free_slp_tree): Declare.\n\t(vectorizable_load): Add an argument of type slp_tree.\n\t(vectorizable_store, vectorizable_operation, vectorizable_conversion,\n\tvectorizable_assignment): Likewise.\n\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n\tDeclare (make extern).\n\t* tree-vectorizer.c (new_stmt_vec_info): Initiliaze the new field.\n\t(new_loop_vec_info): Likewise.\n\t(destroy_loop_vec_info): Free memory allocated for SLP structures.\n\t* tree-vect-analyze.c: Include recog.h.\n\t(vect_update_slp_costs_according_to_vf): New.\n\t(vect_analyze_operations): Add argument for calls to vectorizable_ ()\n\tfunctions. For not pure SLP stmts with strided access check that the\n\tgroup size is power of 2. Update the vectorization factor according to\n\tSLP. Call vect_update_slp_costs_according_to_vf.\n\t(vect_analyze_group_access): New.\n\t(vect_analyze_data_ref_access): Call vect_analyze_group_access.\n\t(vect_free_slp_tree): New functions.\n\t(vect_get_and_check_slp_defs, vect_build_slp_tree, vect_print_slp_tree,\n\tvect_mark_slp_stmts, vect_analyze_slp_instance, vect_analyze_slp,\n\tvect_make_slp_decision, vect_detect_hybrid_slp_stmts,\n\tvect_detect_hybrid_slp): Likewise.\n\t(vect_analyze_loop): Call vect_analyze_slp, vect_make_slp_decision\n\tand vect_detect_hybrid_slp.\n\t* tree-vect-transform.c (vect_estimate_min_profitable_iters): Take\n\tSLP costs into account.\n\t(vect_get_cost_fields): New function.\n\t(vect_model_simple_cost): Make extern, add SLP parameter and handle\n\tSLP.\n\t(vect_model_store_cost, vect_model_load_cost): Likewise.\n\t(vect_get_constant_vectors): New function.\n\t(vect_get_slp_vect_defs, vect_get_slp_defs,\n\tvect_get_vec_defs_for_stmt_copy, vect_get_vec_defs_for_stmt_copy,\n\tvect_get_vec_defs): Likewise.\n\t(vectorizable_reduction): Don't handle SLP for now.\n\t(vectorizable_call): Don't handle SLP for now. Add argument to\n\tvect_model_simple_cost.\n\t(vectorizable_conversion): Handle SLP (call vect_get_vec_defs to\n\tget SLPed and vectorized defs). Fix indentation and spacing.\n\t(vectorizable_assignment): Handle SLP.\n\t(vectorizable_induction): Don't handle SLP for now.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_type_demotion): Add argument to\n\tvect_model_simple_cost.\n\t(vectorizable_type_promotion): Likewise.\n\t(vectorizable_store, vectorizable_load): Handle SLP.\n\t(vectorizable_condition): Don't handle SLP for now.\n\t(vect_transform_stmt): Add a new argument for SLP. Check that there is\n\tno SLP transformation required for unsupported cases. Add SLP\n\targument for supported cases.\n\t(vect_remove_stores): New function.\n\t(vect_schedule_slp_instance, vect_schedule_slp): Likewise.\n\t(vect_transform_loop): Schedule SLP instances.\n\t* Makefile.in: (tree-vect-analyze.o): Depend on recog.h.\n\nFrom-SVN: r128289", "tree": {"sha": "614dcb43b7c25205723a4314d1363a71f9cf26cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/614dcb43b7c25205723a4314d1363a71f9cf26cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/805e2059392217cfabc6b719df5a7ee7d0323c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805e2059392217cfabc6b719df5a7ee7d0323c7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/805e2059392217cfabc6b719df5a7ee7d0323c7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/805e2059392217cfabc6b719df5a7ee7d0323c7b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae2bd7d2edf73ff8386e6185bfc033fa7e6e4633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2bd7d2edf73ff8386e6185bfc033fa7e6e4633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae2bd7d2edf73ff8386e6185bfc033fa7e6e4633"}], "stats": {"total": 6090, "additions": 5780, "deletions": 310}, "files": [{"sha": "de8ecc2b79dc140f45dc23b2f97b7c4ee4013228", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -1,3 +1,69 @@\n+2007-09-09  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (enum vect_def_type): Start enumeration from 1.\n+\t(struct _slp_tree, struct _slp_instance): Define new data structures\n+\talong macros for their access.\n+\t(struct _loop_vec_info): Define new fields: strided_stores,\n+\tslp_instances, and slp_unrolling_factor along macros for their access.\n+\t(enum slp_vect_type): New.\n+\t(struct _stmt_vec_info): Define new field, slp_type, and macros for its\n+\taccess.\n+\t(STMT_VINFO_STRIDED_ACCESS): New macro.\n+\t(vect_free_slp_tree): Declare.\n+\t(vectorizable_load): Add an argument of type slp_tree.\n+\t(vectorizable_store, vectorizable_operation, vectorizable_conversion,\n+\tvectorizable_assignment): Likewise.\n+\t(vect_model_simple_cost, vect_model_store_cost, vect_model_load_cost):\n+\tDeclare (make extern).\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initiliaze the new field.\n+\t(new_loop_vec_info): Likewise.\n+\t(destroy_loop_vec_info): Free memory allocated for SLP structures.\n+\t* tree-vect-analyze.c: Include recog.h.\n+\t(vect_update_slp_costs_according_to_vf): New.\n+\t(vect_analyze_operations): Add argument for calls to vectorizable_ ()\n+\tfunctions. For not pure SLP stmts with strided access check that the\n+\tgroup size is power of 2. Update the vectorization factor according to\n+\tSLP. Call vect_update_slp_costs_according_to_vf.\n+\t(vect_analyze_group_access): New.\n+\t(vect_analyze_data_ref_access): Call vect_analyze_group_access.\n+\t(vect_free_slp_tree): New functions.\n+\t(vect_get_and_check_slp_defs, vect_build_slp_tree, vect_print_slp_tree,\n+\tvect_mark_slp_stmts, vect_analyze_slp_instance, vect_analyze_slp,\n+\tvect_make_slp_decision, vect_detect_hybrid_slp_stmts,\n+\tvect_detect_hybrid_slp): Likewise.\n+\t(vect_analyze_loop): Call vect_analyze_slp, vect_make_slp_decision\n+\tand vect_detect_hybrid_slp.\n+\t* tree-vect-transform.c (vect_estimate_min_profitable_iters): Take\n+\tSLP costs into account.\n+\t(vect_get_cost_fields): New function.\n+\t(vect_model_simple_cost): Make extern, add SLP parameter and handle\n+\tSLP.\n+\t(vect_model_store_cost, vect_model_load_cost): Likewise.\n+\t(vect_get_constant_vectors): New function.\n+\t(vect_get_slp_vect_defs, vect_get_slp_defs,\n+\tvect_get_vec_defs_for_stmt_copy, vect_get_vec_defs_for_stmt_copy,\n+\tvect_get_vec_defs): Likewise.\n+\t(vectorizable_reduction): Don't handle SLP for now.\n+\t(vectorizable_call): Don't handle SLP for now. Add argument to\n+\tvect_model_simple_cost.\n+\t(vectorizable_conversion): Handle SLP (call vect_get_vec_defs to\n+\tget SLPed and vectorized defs). Fix indentation and spacing.\n+\t(vectorizable_assignment): Handle SLP.\n+\t(vectorizable_induction): Don't handle SLP for now.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Add argument to\n+\tvect_model_simple_cost.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_store, vectorizable_load): Handle SLP.\n+\t(vectorizable_condition): Don't handle SLP for now.\n+\t(vect_transform_stmt): Add a new argument for SLP. Check that there is\n+\tno SLP transformation required for unsupported cases. Add SLP\n+\targument for supported cases.\n+\t(vect_remove_stores): New function.\n+\t(vect_schedule_slp_instance, vect_schedule_slp): Likewise.\n+\t(vect_transform_loop): Schedule SLP instances.\n+\t* Makefile.in: (tree-vect-analyze.o): Depend on recog.h.\n+\n 2007-09-09  Andrew Haley  <aph@redhat.com>\n \n         * optabs.c (sign_expand_binop): Set libcall_gen = NULL in the"}, {"sha": "348dbc4b774704569e308cfbd7e2d6362d21664f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -2246,7 +2246,7 @@ tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h langhooks.h\n tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RECOG_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    tree-vectorizer.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) tree-chrec.h\n tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "4d294e10fac89afefe183721393f0ca696c804f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -1,3 +1,29 @@\n+2007-09-09  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect.exp: Compile tests starting with slp-.\n+\tRemove \"vect\" part from test names for -ffast-math, -ffast-math-errno,\n+\t-fwrapv, -ftrapv tests. Add -fno-tree-scev-cprop for slp- tests.\n+\tCompile tests with -fno-tree-pre.\n+\t* gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp: Run SLP tests.\n+\t* lib/target-supports.exp (check_effective_target_vect_strided): New.\n+\t* gcc.dg/vect/slp-1.c, gcc.dg/vect/slp-2.c, gcc.dg/vect/slp-3.c,\n+\tgcc.dg/vect/slp-4.c, gcc.dg/vect/slp-5.c, gcc.dg/vect/slp-6.c,\n+\tgcc.dg/vect/slp-7.c, gcc.dg/vect/slp-8.c, gcc.dg/vect/slp-9.c,\n+\tgcc.dg/vect/slp-10.c, gcc.dg/vect/slp-11.c, gcc.dg/vect/slp-12.c,\n+\tgcc.dg/vect/slp-13.c, gcc.dg/vect/slp-14.c, gcc.dg/vect/slp-15.c,\n+\tgcc.dg/vect/slp-16.c, gcc.dg/vect/slp-17.c, gcc.dg/vect/slp-18.c,\n+\tgcc.dg/vect/slp-19.c, gcc.dg/vect/slp-20.c, gcc.dg/vect/slp-21.c,\n+\tgcc.dg/vect/slp-22.c, gcc.dg/vect/slp-23.c, gcc.dg/vect/slp-24.c,\n+\tgcc.dg/vect/slp-25.c, gcc.dg/vect/slp-26.c, gcc.dg/vect/slp-28.c,\n+\tgcc.dg/vect/fast-math-slp-27.c, gcc.dg/vect/no-tree-pre-slp-29.c,\n+\tgcc.dg/vect/no-scevccp-slp-30.c, gcc.dg/vect/no-scevccp-slp-31.c,\n+\tgcc.dg/vect/no-math-errno-slp-32.c, gcc.dg/vect/slp-33.c,\n+\tgcc.dg/vect/slp-34.c, gcc.dg/vect/slp-35.c, gcc.dg/vect/slp-36.c,\n+\tgcc.dg/vect/slp-37.c, gcc.dg/vect/vect-vfa-slp.c, \n+\tgcc.dg/vect/costmodel/ppc/costmodel-slp-12.c,\n+\tgcc.dg/vect/costmodel/ppc/costmodel-slp-33.c: New testcases.\n+\t* gcc.dg/vect/vect-vfa-03.c: Change the test to prevent SLP.\n+\n 2007-09-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lib/file-format.exp (gcc_target_object_format): Use remote_exec"}, {"sha": "752c4f61390b2757f803f92bfa11d2c545e9a8b0", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-12.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-12.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8], fa[N*4];\n+  unsigned int ia[N], ib[N*2];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      \n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6;\n+      a2 = in[i*8 + 2] + 7;\n+      a3 = in[i*8 + 3] + 8;\n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+\n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+\n+      ia[i] = b6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7\n+         || ia[i] != (in[i*8 + 6] + 11) * 3)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = (in[i*4] + 2) * 3;\n+      out[i*4 + 1] = (in[i*4 + 1] + 2) * 7;\n+      out[i*4 + 2] = (in[i*4 + 2] + 7) * 3;\n+      out[i*4 + 3] = (in[i*4 + 3] + 7) * 7;\n+\n+      ib[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  (in[i*4] + 2) * 3\n+         || out[i*4 + 1] != (in[i*4 + 1] + 2) * 7\n+         || out[i*4 + 2] != (in[i*4 + 2] + 7) * 3\n+         || out[i*4 + 3] != (in[i*4 + 3] + 7) * 7\n+         || ib[i] != 7)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out2[i*2] = (float) (in[i*2] * 2 + 11) ;\n+      out2[i*2 + 1] = (float) (in[i*2 + 1] * 3 + 7);\n+    \n+      fa[i] = (float) in[i*2+1];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out2[i*2] !=  (float) (in[i*2] * 2 + 11)\n+         || out2[i*2 + 1] != (float) (in[i*2 + 1] * 3 + 7)\n+         || fa[i] != (float) in[i*2+1])\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  {target { vect_strided && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" {target { vect_strided && vect_int_mult } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "9cae12fdbb37b34e3fe3a7748c470ab8cb025e7d", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-slp-33.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-slp-33.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  short a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 2B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/4; i++)\n+    {\n+      tmp.b[2*i] = 5;\n+      tmp.b[2*i+1] = 15;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/4; i++)\n+    {\n+      if (tmp.b[2*i] != 5\n+          || tmp.b[2*i+1] != 15)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4f710634e8ad174fe50678ce627c99c777b6d2cd", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -64,6 +64,8 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-slp-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS"}, {"sha": "d4c7d19925b203bed763c3c4f78801968b5e5ea3", "filename": "gcc/testsuite/gcc.dg/vect/fast-math-slp-27.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-slp-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-slp-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ffast-math-slp-27.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_float } */\n+\n+float x[256];\n+\n+void foo(void)\n+{\n+  int i;\n+  for (i=0; i<256; ++i)\n+   {\n+    x[2*i] = x[2*i] * x[2*i];\n+    x[2*i+1] = x[2*i+1] * x[2*i+1];\n+   }\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { target vect_strided } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c952e7f1b11cf714d8af1f70ed42747cb2ffba36", "filename": "gcc/testsuite/gcc.dg/vect/no-math-errno-slp-32.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-math-errno-slp-32.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double x[256];\n+\n+void foo(void)\n+{\n+  int i;\n+  for (i=0; i<128; ++i)\n+   {\n+    x[2*i] = __builtin_pow (x[2*i], 0.5);\n+    x[2*i+1] = __builtin_pow (x[2*i+1], 0.5);\n+   }\n+}\n+\n+/* { dg-final { scan-tree-dump \"pattern recognized\" \"vect\" { xfail spu*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "30cb947bed0d92c199fbc8dd0ba7ad016e2386b3", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-slp-30.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-30.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 ()\n+{\n+  int i, j;\n+  unsigned short out[N*8], a[N];\n+   \n+ for (j = 0; j < N; j++)\n+   {\n+    for (i = 0; i < N; i++)\n+      {\n+        out[i*4] = 8;\n+        out[i*4 + 1] = 18;\n+        out[i*4 + 2] = 28;\n+        out[i*4 + 3] = 38;\n+      }\n+    a[j] = 8;\n+   }\n+\n+  /* check results:  */\n+   for (j = 0; j < N; j++)\n+   {\n+    for (i = 0; i < N; i++)\n+      {\n+        if (out[i*4] != 8\n+            || out[i*4 + 1] != 18\n+            || out[i*4 + 2] != 28\n+            || out[i*4 + 3] != 38)\n+          abort();\n+      }\n+   \n+    if (a[j] != 8)\n+       abort ();\n+   }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "2e43db1360191927db489137075ef5874de00997", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-slp-31.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-slp-31.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 ()\n+{\n+  int i, j;\n+  unsigned short out[N*8], a[N][N];\n+   \n+ for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++)\n+      {\n+        a[i][j] = 8;\n+      }\n+    out[i*4] = 8;\n+    out[i*4 + 1] = 18;\n+    out[i*4 + 2] = 28;\n+    out[i*4 + 3] = 38;\n+   }\n+\n+  /* check results:  */\n+ for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++) \n+      {\n+        if (a[i][j] != 8)\n+           abort ();\n+      }\n+    if (out[i*4] != 8\n+        || out[i*4 + 1] != 18\n+        || out[i*4 + 2] != 28\n+        || out[i*4 + 3] != 38)\n+      abort();\n+   }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "9c75e9dc5b082e2917f48d388ad446b49f37e674", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-pre-slp-29.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-pre-slp-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-pre-slp-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-pre-slp-29.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+unsigned short in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+int\n+main1 (unsigned short *in)\n+{\n+  int i;\n+  unsigned short out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int\n+main2 (unsigned short * __restrict__ in, unsigned short * __restrict__ out)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  unsigned short out[N*8];\n+\n+  check_vect ();\n+\n+  main1 (&in2[5]);\n+  main2 (&in2[3], &out[3]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "f7e20973818363ada5599533a42fcc730b10b9dd", "filename": "gcc/testsuite/gcc.dg/vect/slp-1.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-1.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*4] = 8;\n+      out[i*4 + 1] = 18;\n+      out[i*4 + 2] = 28;\n+      out[i*4 + 3] = 38;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != 8 \n+         || out[i*4 + 1] != 18\n+         || out[i*4 + 2] != 28\n+         || out[i*4 + 3] != 38)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = 8;\n+      out[i*8 + 1] = 7;\n+      out[i*8 + 2] = 81;\n+      out[i*8 + 3] = 28;\n+      out[i*8 + 4] = 18;\n+      out[i*8 + 5] = 85;\n+      out[i*8 + 6] = 5;\n+      out[i*8 + 7] = 4;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] != 8\n+         || out[i*8 + 1] != 7\n+         || out[i*8 + 2] != 81\n+         || out[i*8 + 3] != 28\n+         || out[i*8 + 4] != 18\n+         || out[i*8 + 5] != 85\n+         || out[i*8 + 6] != 5\n+         || out[i*8 + 7] != 4)\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*5] = 8;\n+      out[i*5 + 1] = 7;\n+      out[i*5 + 2] = 81;\n+      out[i*5 + 3] = 28;\n+      out[i*5 + 4] = 18;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*5] != 8\n+         || out[i*5 + 1] != 7\n+         || out[i*5 + 2] != 81\n+         || out[i*5 + 3] != 28\n+         || out[i*5 + 4] != 18)\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*9] = 8;\n+      out[i*9 + 1] = 7;\n+      out[i*9 + 2] = 81;\n+      out[i*9 + 3] = 28;\n+      out[i*9 + 4] = 18;\n+      out[i*9 + 5] = 85;\n+      out[i*9 + 6] = 5;\n+      out[i*9 + 7] = 4;\n+      out[i*9 + 8] = 14;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*9] != 8\n+         || out[i*9 + 1] != 7\n+         || out[i*9 + 2] != 81\n+         || out[i*9 + 3] != 28\n+         || out[i*9 + 4] != 18\n+         || out[i*9 + 5] != 85\n+         || out[i*9 + 6] != 5\n+         || out[i*9 + 7] != 4\n+         || out[i*9 + 8] != 14)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "737e1e7860d2ed7c6741b1affa8aa7d2eab21c7f", "filename": "gcc/testsuite/gcc.dg/vect/slp-10.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-10.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      \n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6;\n+      a2 = in[i*8 + 2] + 7;\n+      a3 = in[i*8 + 3] + 8;\n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+\n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = (in[i*4] + 2) * 3;\n+      out[i*4 + 1] = (in[i*4 + 1] + 2) * 7;\n+      out[i*4 + 2] = (in[i*4 + 2] + 7) * 3;\n+      out[i*4 + 3] = (in[i*4 + 3] + 7) * 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  (in[i*4] + 2) * 3\n+         || out[i*4 + 1] != (in[i*4 + 1] + 2) * 7\n+         || out[i*4 + 2] != (in[i*4 + 2] + 7) * 3\n+         || out[i*4 + 3] != (in[i*4 + 3] + 7) * 7)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out2[i*2] = (float) (in[i*2] * 2 + 5) ;\n+      out2[i*2 + 1] = (float) (in[i*2 + 1] * 3 + 7);\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out2[i*2] !=  (float) (in[i*2] * 2 + 5)\n+         || out2[i*2 + 1] != (float) (in[i*2 + 1] * 3 + 7))\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target {vect_intfloat_cvt && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target {{! { vect_intfloat_cvt}} && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target {{! { vect_intfloat_cvt}} && {!{vect_int_mult}}} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target {vect_intfloat_cvt && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  {target {{! { vect_intfloat_cvt}} && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  {target {{! { vect_intfloat_cvt}} && {!{vect_int_mult}}} } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "118818c97bdc6fc36e37ff576b3f70fa1d71f3c4", "filename": "gcc/testsuite/gcc.dg/vect/slp-11.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-11.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,113 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8];\n+\n+  /* Different operations - not SLPable.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] * 6;\n+      a2 = in[i*8 + 2] + 7;\n+      a3 = in[i*8 + 3] + 8;\n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+\n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] * 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7)\n+\tabort ();\n+    }\n+\n+  /* Requires permutation - not SLPable.  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = (in[i*4] + 2) * 3;\n+      out[i*4 + 1] = (in[i*4 + 2] + 2) * 7;\n+      out[i*4 + 2] = (in[i*4 + 1] + 7) * 3;\n+      out[i*4 + 3] = (in[i*4 + 3] + 3) * 4;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  (in[i*4] + 2) * 3\n+         || out[i*4 + 1] != (in[i*4 + 2] + 2) * 7\n+         || out[i*4 + 2] != (in[i*4 + 1] + 7) * 3\n+         || out[i*4 + 3] != (in[i*4 + 3] + 3) * 4)\n+        abort ();\n+    }\n+\n+  /* Different operations - not SLPable.  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      out2[i*2] = ((float) in[i*2] * 2 + 6) ;\n+      out2[i*2 + 1] = (float) (in[i*2 + 1] * 3 + 7);\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*4; i++)\n+    {\n+      if (out2[i*2] !=  ((float) in[i*2] * 2 + 6)\n+         || out2[i*2 + 1] != (float) (in[i*2 + 1] * 3 + 7))\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  { target { vect_strided &&  vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target  { ! { vect_int_mult && vect_strided } } } } }  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0  \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "066bf7ff9a324a405d23af98c854a52c20d9d68f", "filename": "gcc/testsuite/gcc.dg/vect/slp-12a.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12a.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int ia[N], ib[N*2];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      \n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6;\n+      a2 = in[i*8 + 2] + 7;\n+      a3 = in[i*8 + 3] + 8;\n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+\n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+\n+      ia[i] = b6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7\n+         || ia[i] != (in[i*8 + 6] + 11) * 3)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = (in[i*4] + 2) * 3;\n+      out[i*4 + 1] = (in[i*4 + 1] + 2) * 7;\n+      out[i*4 + 2] = (in[i*4 + 2] + 7) * 3;\n+      out[i*4 + 3] = (in[i*4 + 3] + 7) * 7;\n+\n+      ib[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  (in[i*4] + 2) * 3\n+         || out[i*4 + 1] != (in[i*4 + 1] + 2) * 7\n+         || out[i*4 + 2] != (in[i*4 + 2] + 7) * 3\n+         || out[i*4 + 3] != (in[i*4 + 3] + 7) * 7 \n+         || ib[i] != 7)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target { vect_strided && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  {target { {! {vect_strided}} && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target  { ! vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" {target { vect_strided && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" {target { {! {vect_strided}} && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" {target  { ! vect_int_mult } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "39570016f386a10be8ee7dcf6c43335547dc3a52", "filename": "gcc/testsuite/gcc.dg/vect/slp-12b.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-12b.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_intfloat_cvt } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8], fa[N*4];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out2[i*2] = (float) (in[i*2] * 2 + 11) ;\n+      out2[i*2 + 1] = (float) (in[i*2 + 1] * 3 + 7);\n+    \n+      fa[i] = (float) in[i*2+1];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out2[i*2] !=  (float) (in[i*2] * 2 + 11)\n+         || out2[i*2 + 1] != (float) (in[i*2 + 1] * 3 + 7)\n+         || fa[i] != (float) in[i*2+1])\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  {target { vect_strided && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target { { ! { vect_int_mult }} || { ! {vect_strided}}} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  {target { vect_strided && vect_int_mult } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  {target { { ! { vect_int_mult }} || { ! {vect_strided}}} } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "0041526b9729fc76d14d3dff028a2032200327a6", "filename": "gcc/testsuite/gcc.dg/vect/slp-13.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int out2[N*8];\n+\n+  /* Induction is not SLPable yet.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8] + i;\n+      out[i*8 + 1] = in[i*8 + 1] + i;\n+      out[i*8 + 2] = in[i*8 + 2] + i;\n+      out[i*8 + 3] = in[i*8 + 3] + i;\n+      out[i*8 + 4] = in[i*8 + 4] + i;\n+      out[i*8 + 5] = in[i*8 + 5] + i;\n+      out[i*8 + 6] = in[i*8 + 6] + i;\n+      out[i*8 + 7] = in[i*8 + 7] + i;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8] + i\n+         || out[i*8 + 1] != in[i*8 + 1] + i\n+         || out[i*8 + 2] != in[i*8 + 2] + i\n+         || out[i*8 + 3] != in[i*8 + 3] + i\n+         || out[i*8 + 4] != in[i*8 + 4] + i\n+         || out[i*8 + 5] != in[i*8 + 5] + i\n+         || out[i*8 + 6] != in[i*8 + 6] + i\n+         || out[i*8 + 7] != in[i*8 + 7] + i)\n+\tabort ();\n+    }\n+\n+  /* Induction is not SLPable yet and strided group size must be a power of 2 \n+     to get vectorized.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out2[i*12] = in2[i*12] + i;\n+      out2[i*12 + 1] = in2[i*12 + 1] + i;\n+      out2[i*12 + 2] = in2[i*12 + 2] + i;\n+      out2[i*12 + 3] = in2[i*12 + 3] + i;\n+      out2[i*12 + 4] = in2[i*12 + 4] + i;\n+      out2[i*12 + 5] = in2[i*12 + 5] + i;\n+      out2[i*12 + 6] = in2[i*12 + 6] + i;\n+      out2[i*12 + 7] = in2[i*12 + 7] + i;\n+      out2[i*12 + 8] = in2[i*12 + 8] + i;\n+      out2[i*12 + 9] = in2[i*12 + 9] + i;\n+      out2[i*12 + 10] = in2[i*12 + 10] + i;\n+      out2[i*12 + 11] = in2[i*12 + 11] + i;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+        if (out2[i*12] != in2[i*12] + i\n+            || out2[i*12 + 1] != in2[i*12 + 1] + i\n+            || out2[i*12 + 2] != in2[i*12 + 2] + i\n+            || out2[i*12 + 3] != in2[i*12 + 3] + i\n+            || out2[i*12 + 4] != in2[i*12 + 4] + i\n+            || out2[i*12 + 5] != in2[i*12 + 5] + i\n+            || out2[i*12 + 6] != in2[i*12 + 6] + i\n+            || out2[i*12 + 7] != in2[i*12 + 7] + i\n+            || out2[i*12 + 8] != in2[i*12 + 8] + i\n+            || out2[i*12 + 9] != in2[i*12 + 9] + i\n+            || out2[i*12 + 10] != in2[i*12 + 10] + i\n+            || out2[i*12 + 11] != in2[i*12 + 11] + i)\n+          abort ();\n+    }\n+\n+  /* Not power of 2 but SLPable.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out2[i*12] = in2[i*12] + 1;\n+      out2[i*12 + 1] = in2[i*12 + 1] + 2;\n+      out2[i*12 + 2] = in2[i*12 + 2] + 3;\n+      out2[i*12 + 3] = in2[i*12 + 3] + 4;\n+      out2[i*12 + 4] = in2[i*12 + 4] + 5;\n+      out2[i*12 + 5] = in2[i*12 + 5] + 6;\n+      out2[i*12 + 6] = in2[i*12 + 6] + 7;\n+      out2[i*12 + 7] = in2[i*12 + 7] + 8;\n+      out2[i*12 + 8] = in2[i*12 + 8] + 9;\n+      out2[i*12 + 9] = in2[i*12 + 9] + 10;\n+      out2[i*12 + 10] = in2[i*12 + 10] + 11;\n+      out2[i*12 + 11] = in2[i*12 + 11] + 12;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+        if (out2[i*12] != in2[i*12] + 1\n+            || out2[i*12 + 1] != in2[i*12 + 1] + 2\n+            || out2[i*12 + 2] != in2[i*12 + 2] + 3\n+            || out2[i*12 + 3] != in2[i*12 + 3] + 4\n+            || out2[i*12 + 4] != in2[i*12 + 4] + 5\n+            || out2[i*12 + 5] != in2[i*12 + 5] + 6\n+            || out2[i*12 + 6] != in2[i*12 + 6] + 7\n+            || out2[i*12 + 7] != in2[i*12 + 7] + 8\n+            || out2[i*12 + 8] != in2[i*12 + 8] + 9\n+            || out2[i*12 + 9] != in2[i*12 + 9] + 10\n+            || out2[i*12 + 10] != in2[i*12 + 10] + 11\n+            || out2[i*12 + 11] != in2[i*12 + 11] + 12)\n+          abort ();\n+    }\n+\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail *-*-* }  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "62610dc0233c1d65cadce53133ffef2df91f0f2d", "filename": "gcc/testsuite/gcc.dg/vect/slp-14.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-14.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 (int n)\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short in2[N*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short out2[N*16];\n+\n+  /* Multiple types are not SLPable yet.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6; \n+      a2 = in[i*8 + 2] + 7; \n+      a3 = in[i*8 + 3] + 8; \n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+    \n+      b0 = a0 * 3;\n+      b1 = a1 * 2; \n+      b2 = a2 * 12;\n+      b3 = a3 * 5; \n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+    \n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+    \n+      out2[i*16] = in2[i*16] + 2;\n+      out2[i*16 + 1] = in2[i*16 + 1] + 3;\n+      out2[i*16 + 2] = in2[i*16 + 2] + 4;\n+      out2[i*16 + 3] = in2[i*16 + 3] + 3;\n+      out2[i*16 + 4] = in2[i*16 + 4] + 2;\n+      out2[i*16 + 5] = in2[i*16 + 5] + 3;\n+      out2[i*16 + 6] = in2[i*16 + 6] + 2;\n+      out2[i*16 + 7] = in2[i*16 + 7] + 4;\n+      out2[i*16 + 8] = in2[i*16 + 8] + 2;\n+      out2[i*16 + 9] = in2[i*16 + 9] + 5;\n+      out2[i*16 + 10] = in2[i*16 + 10] + 2;\n+      out2[i*16 + 11] = in2[i*16 + 11] + 3;\n+      out2[i*16 + 12] = in2[i*16 + 12] + 4;\n+      out2[i*16 + 13] = in2[i*16 + 13] + 4;\n+      out2[i*16 + 14] = in2[i*16 + 14] + 3;\n+      out2[i*16 + 15] = in2[i*16 + 15] + 2;\n+}\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7)\n+        abort ();\n+\n+      if (out2[i*16] !=  in2[i*16] + 2\n+         || out2[i*16 + 1] != in2[i*16 + 1] + 3\n+         || out2[i*16 + 2] != in2[i*16 + 2] + 4\n+         || out2[i*16 + 3] != in2[i*16 + 3] + 3\n+         || out2[i*16 + 4] != in2[i*16 + 4] + 2\n+         || out2[i*16 + 5] != in2[i*16 + 5] + 3\n+         || out2[i*16 + 6] != in2[i*16 + 6] + 2\n+         || out2[i*16 + 7] != in2[i*16 + 7] + 4\n+         || out2[i*16 + 8] != in2[i*16 + 8] + 2\n+         || out2[i*16 + 9] != in2[i*16 + 9] + 5\n+         || out2[i*16 + 10] != in2[i*16 + 10] + 2\n+         || out2[i*16 + 11] != in2[i*16 + 11] + 3\n+         || out2[i*16 + 12] != in2[i*16 + 12] + 4\n+         || out2[i*16 + 13] != in2[i*16 + 13] + 4\n+         || out2[i*16 + 14] != in2[i*16 + 14] + 3\n+         || out2[i*16 + 15] != in2[i*16 + 15] + 2)\n+        abort ();\n+    \n+    }\n+\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (N);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_strided && vect_int_mult  } } } }  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target { ! { vect_strided  && vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail *-*-* }  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "6f04e6a3784cf2c1116d05f663120b593d7fa706", "filename": "gcc/testsuite/gcc.dg/vect/slp-15.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-15.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 (int n)\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int in2[N*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int out2[N*16];\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6; \n+      a2 = in[i*8 + 2] + 7; \n+      a3 = in[i*8 + 3] + 8; \n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+    \n+      b0 = a0 * 3;\n+      b1 = a1 * 2; \n+      b2 = a2 * 12;\n+      b3 = a3 * 5; \n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+    \n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+    \n+      out2[i*16] = in2[i*16] * 2;\n+      out2[i*16 + 1] = in2[i*16 + 1] * 3;\n+      out2[i*16 + 2] = in2[i*16 + 2] * 4;\n+      out2[i*16 + 3] = in2[i*16 + 3] * 3;\n+      out2[i*16 + 4] = in2[i*16 + 4] * 2;\n+      out2[i*16 + 5] = in2[i*16 + 5] * 3;\n+      out2[i*16 + 6] = in2[i*16 + 6] * 2;\n+      out2[i*16 + 7] = in2[i*16 + 7] * 4;\n+      out2[i*16 + 8] = in2[i*16 + 8] * 2;\n+      out2[i*16 + 9] = in2[i*16 + 9] * 5;\n+      out2[i*16 + 10] = in2[i*16 + 10] * 2;\n+      out2[i*16 + 11] = in2[i*16 + 11] * 3;\n+      out2[i*16 + 12] = in2[i*16 + 12] * 4;\n+      out2[i*16 + 13] = in2[i*16 + 13] * 4;\n+      out2[i*16 + 14] = in2[i*16 + 14] * 3;\n+      out2[i*16 + 15] = in2[i*16 + 15] * 2;\n+}\n+\n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7)\n+        abort ();\n+\n+      if (out2[i*16] !=  in2[i*16] * 2\n+         || out2[i*16 + 1] != in2[i*16 + 1] * 3\n+         || out2[i*16 + 2] != in2[i*16 + 2] * 4\n+         || out2[i*16 + 3] != in2[i*16 + 3] * 3\n+         || out2[i*16 + 4] != in2[i*16 + 4] * 2\n+         || out2[i*16 + 5] != in2[i*16 + 5] * 3\n+         || out2[i*16 + 6] != in2[i*16 + 6] * 2\n+         || out2[i*16 + 7] != in2[i*16 + 7] * 4\n+         || out2[i*16 + 8] != in2[i*16 + 8] * 2\n+         || out2[i*16 + 9] != in2[i*16 + 9] * 5\n+         || out2[i*16 + 10] != in2[i*16 + 10] * 2\n+         || out2[i*16 + 11] != in2[i*16 + 11] * 3\n+         || out2[i*16 + 12] != in2[i*16 + 12] * 4\n+         || out2[i*16 + 13] != in2[i*16 + 13] * 4\n+         || out2[i*16 + 14] != in2[i*16 + 14] * 3\n+         || out2[i*16 + 15] != in2[i*16 + 15] * 2)\n+        abort ();\n+    \n+    }\n+\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (N);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  {target vect_int_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target  { ! { vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" {target vect_int_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" {target { ! { vect_int_mult } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "cbc47cd1f2be1efedcfd33a2ccc076b28fc42ed6", "filename": "gcc/testsuite/gcc.dg/vect/slp-16.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-16.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int in2[N*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int out2[N*16];\n+\n+  /* SLP group of size that is not a multiple of vector size. \n+     Unrolling by 2.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*2] + 5;\n+      a1 = in[i*2 + 1] + 6; \n+    \n+      b0 = a0 * 3;\n+      b1 = a1 * 2; \n+    \n+      out[i*2] = b0 - 2;\n+      out[i*2 + 1] = b1 - 3; \n+    \n+      out2[i*6] = in2[i*6] * 2;\n+      out2[i*6 + 1] = in2[i*6 + 1] * 3;\n+      out2[i*6 + 2] = in2[i*6 + 2] * 4;\n+      out2[i*6 + 3] = in2[i*6 + 3] * 2;\n+      out2[i*6 + 4] = in2[i*6 + 4] * 4;\n+      out2[i*6 + 5] = in2[i*6 + 5] * 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*2] !=  (in[i*2] + 5) * 3 - 2\n+         || out[i*2 + 1] != (in[i*2 + 1] + 6) * 2 - 3\n+         || out2[i*6] != in2[i*6] * 2\n+         || out2[i*6 + 1] != in2[i*6 + 1] * 3\n+         || out2[i*6 + 2] != in2[i*6 + 2] * 4\n+         || out2[i*6 + 3] != in2[i*6 + 3] * 2\n+         || out2[i*6 + 4] != in2[i*6 + 4] * 4\n+         || out2[i*6 + 5] != in2[i*6 + 5] * 3)\n+        abort ();\n+    }\n+\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_int_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "0a760bf2c686da36214a1c1930294a9c4986a21c", "filename": "gcc/testsuite/gcc.dg/vect/slp-17.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-17.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short out2[N*8];\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*2] = in[i*2] + 5;\n+      out[i*2 + 1] = in[i*2 + 1] + 6;\n+\n+      out2[i*4] = in2[i*4] + 2;\n+      out2[i*4 + 1] = in2[i*4 + 1] + 2;\n+      out2[i*4 + 2] = in2[i*4 + 2] + 1;\n+      out2[i*4 + 3] = in2[i*4 + 3] + 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*2] != in[i*2] + 5\n+         || out[i*2 + 1] != in[i*2 + 1] + 6\n+         || out2[i*4] !=  in2[i*4] + 2\n+         || out2[i*4 + 1] != in2[i*4 + 1] + 2\n+         || out2[i*4 + 2] != in2[i*4 + 2] + 1\n+         || out2[i*4 + 3] != in2[i*4 + 3] + 3)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "b8e122c6cfa4221a8f6335f38375187e4971aff3", "filename": "gcc/testsuite/gcc.dg/vect/slp-18.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-18.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      \n+      a0 = in[i*8] + 5;\n+      a1 = in[i*8 + 1] + 6;\n+      a2 = in[i*8 + 2] + 7;\n+      a3 = in[i*8 + 3] + 8;\n+      a4 = in[i*8 + 4] + 9;\n+      a5 = in[i*8 + 5] + 10;\n+      a6 = in[i*8 + 6] + 11;\n+      a7 = in[i*8 + 7] + 12;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+      b7 = a7 * 2;\n+\n+      out[i*8] = b0 - 2;\n+      out[i*8 + 1] = b1 - 3; \n+      out[i*8 + 2] = b2 - 2;\n+      out[i*8 + 3] = b3 - 1;\n+      out[i*8 + 4] = b4 - 8;\n+      out[i*8 + 5] = b5 - 7;\n+      out[i*8 + 6] = b6 - 3;\n+      out[i*8 + 7] = b7 - 7;\n+\n+\n+      out2[i*8] = (float) b0;\n+      out2[i*8 + 1] = (float) b1;\n+      out2[i*8 + 2] = (float) b2; \n+      out2[i*8 + 3] = (float) b3; \n+      out2[i*8 + 4] = (float) b4; \n+      out2[i*8 + 5] = (float) b5; \n+      out2[i*8 + 6] = (float) b6;\n+      out2[i*8 + 7] = (float) b7;\n+  }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  (in[i*8] + 5) * 3 - 2\n+         || out[i*8 + 1] != (in[i*8 + 1] + 6) * 2 - 3\n+         || out[i*8 + 2] != (in[i*8 + 2] + 7) * 12 - 2\n+         || out[i*8 + 3] != (in[i*8 + 3] + 8) * 5 - 1\n+         || out[i*8 + 4] != (in[i*8 + 4] + 9) * 8 - 8\n+         || out[i*8 + 5] != (in[i*8 + 5] + 10) * 4 - 7\n+         || out[i*8 + 6] != (in[i*8 + 6] + 11) * 3 - 3\n+         || out[i*8 + 7] != (in[i*8 + 7] + 12) * 2 - 7)\n+\tabort ();\n+\n+      if (out2[i*8] != (float) ((in[i*8] + 5) * 3)\n+         || out2[i*8 + 1] != (float) ((in[i*8 + 1] + 6) * 2)\n+         || out2[i*8 + 2] != (float) ((in[i*8 + 2] + 7) * 12)\n+         || out2[i*8 + 3] != (float) ((in[i*8 + 3] + 8) * 5)\n+         || out2[i*8 + 4] != (float) ((in[i*8 + 4] + 9) * 8)\n+         || out2[i*8 + 5] != (float) ((in[i*8 + 5] + 10) * 4)\n+         || out2[i*8 + 6] != (float) ((in[i*8 + 6] + 11) * 3)\n+         || out2[i*8 + 7] != (float) ((in[i*8 + 7] + 12) * 2))\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_strided } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_strided } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "d9a68cd69d4ddf08fb59b3b0b8e0327266e11c85", "filename": "gcc/testsuite/gcc.dg/vect/slp-19.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-19.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,155 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+int\n+main1 ()\n+{\n+  unsigned int i;\n+  unsigned int out[N*8];\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int ia[N*2], a0, a1, a2, a3;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8];\n+      out[i*8 + 1] = in[i*8 + 1];\n+      out[i*8 + 2] = in[i*8 + 2];\n+      out[i*8 + 3] = in[i*8 + 3];\n+      out[i*8 + 4] = in[i*8 + 4];\n+      out[i*8 + 5] = in[i*8 + 5];\n+      out[i*8 + 6] = in[i*8 + 6];\n+      out[i*8 + 7] = in[i*8 + 7];\n+    \n+      ia[i] = in[i*8 + 2];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7]\n+         || ia[i] != in[i*8 + 2])\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      a0 = in[i*4] + 1;\n+      a1 = in[i*4 + 1] + 2;\n+      a2 = in[i*4 + 2] + 3;\n+      a3 = in[i*4 + 3] + 4;\n+\n+      out[i*4] = a0;\n+      out[i*4 + 1] = a1;\n+      out[i*4 + 2] = a2;\n+      out[i*4 + 3] = a3;\n+\n+      ia[i] = a2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4] + 1\n+         || out[i*4 + 1] != in[i*4 + 1] + 2\n+         || out[i*4 + 2] != in[i*4 + 2] + 3\n+         || out[i*4 + 3] != in[i*4 + 3] + 4\n+         || ia[i] != in[i*4 + 2] + 3)\n+        abort ();\n+    }\n+\n+  /* The last stmt requires interleaving of not power of 2 size - not \n+     vectorizable.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*12] = in[i*12];\n+      out[i*12 + 1] = in[i*12 + 1];\n+      out[i*12 + 2] = in[i*12 + 2];\n+      out[i*12 + 3] = in[i*12 + 3];\n+      out[i*12 + 4] = in[i*12 + 4];\n+      out[i*12 + 5] = in[i*12 + 5];\n+      out[i*12 + 6] = in[i*12 + 6];\n+      out[i*12 + 7] = in[i*12 + 7];\n+      out[i*12 + 8] = in[i*12 + 8];\n+      out[i*12 + 9] = in[i*12 + 9];\n+      out[i*12 + 10] = in[i*12 + 10];\n+      out[i*12 + 11] = in[i*12 + 11];\n+\n+      ia[i] = in[i*12 + 7];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*12] !=  in[i*12]\n+         || out[i*12 + 1] != in[i*12 + 1]\n+         || out[i*12 + 2] != in[i*12 + 2]\n+         || out[i*12 + 3] != in[i*12 + 3]\n+         || out[i*12 + 4] != in[i*12 + 4]\n+         || out[i*12 + 5] != in[i*12 + 5]\n+         || out[i*12 + 6] != in[i*12 + 6]\n+         || out[i*12 + 7] != in[i*12 + 7]\n+         || out[i*12 + 8] != in[i*12 + 8]\n+         || out[i*12 + 9] != in[i*12 + 9]\n+         || out[i*12 + 10] != in[i*12 + 10]\n+         || out[i*12 + 11] != in[i*12 + 11]\n+         || ia[i] != in[i*12 + 7])\n+        abort ();\n+    }\n+\n+  /* Hybrid SLP with unrolling by 2.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*6] = in[i*6];\n+      out[i*6 + 1] = in[i*6 + 1];\n+      out[i*6 + 2] = in[i*6 + 2];\n+      out[i*6 + 3] = in[i*6 + 3];\n+      out[i*6 + 4] = in[i*6 + 4];\n+      out[i*6 + 5] = in[i*6 + 5];\n+    \n+      ia[i] = i;\n+    } \n+    \n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*6] !=  in[i*6]\n+         || out[i*6 + 1] != in[i*6 + 1]\n+         || out[i*6 + 2] != in[i*6 + 2]\n+         || out[i*6 + 3] != in[i*6 + 3]\n+         || out[i*6 + 4] != in[i*6 + 4]\n+         || out[i*6 + 5] != in[i*6 + 5]\n+         || ia[i] != i)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target  vect_strided  } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target  { ! { vect_strided } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\"  { target  vect_strided  } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { target { ! { vect_strided } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "2731747dbcf86637beb519cd0d5231a0550d3064", "filename": "gcc/testsuite/gcc.dg/vect/slp-2.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-2.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,146 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 (unsigned short a0, unsigned short a1, unsigned short a2, \n+       unsigned short a3, unsigned short a4, unsigned short a5,\n+       unsigned short a6, unsigned short a7, unsigned short a8,\n+       unsigned short a9, unsigned short a10, unsigned short a11,\n+       unsigned short a12, unsigned short a13, unsigned short a14,\n+       unsigned short a15)\n+{\n+  int i;\n+  unsigned short out[N*16];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*4] = a8;\n+      out[i*4 + 1] = a1;\n+      out[i*4 + 2] = a2;\n+      out[i*4 + 3] = a3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != a8 \n+         || out[i*4 + 1] != a1\n+         || out[i*4 + 2] != a2\n+         || out[i*4 + 3] != a3)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*16] = a8;\n+      out[i*16 + 1] = a7;\n+      out[i*16 + 2] = a1;\n+      out[i*16 + 3] = a2;\n+      out[i*16 + 4] = a8;\n+      out[i*16 + 5] = a5;\n+      out[i*16 + 6] = a5;\n+      out[i*16 + 7] = a4;\n+      out[i*16 + 8] = a12;\n+      out[i*16 + 9] = a13;\n+      out[i*16 + 10] = a14;\n+      out[i*16 + 11] = a15;\n+      out[i*16 + 12] = a6;\n+      out[i*16 + 13] = a9;\n+      out[i*16 + 14] = a0;\n+      out[i*16 + 15] = a7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*16] != a8\n+          || out[i*16 + 1] != a7\n+          || out[i*16 + 2] != a1\n+          || out[i*16 + 3] != a2\n+          || out[i*16 + 4] != a8\n+          || out[i*16 + 5] != a5\n+          || out[i*16 + 6] != a5\n+          || out[i*16 + 7] != a4\n+          || out[i*16 + 8] != a12\n+          || out[i*16 + 9] != a13\n+          || out[i*16 + 10] != a14\n+          || out[i*16 + 11] != a15\n+          || out[i*16 + 12] != a6\n+          || out[i*16 + 13] != a9\n+          || out[i*16 + 14] != a0\n+          || out[i*16 + 15] != a7)\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*3] = a8;\n+      out[i*3 + 1] = a1;\n+      out[i*3 + 2] = a2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*3] != a8\n+         || out[i*3 + 1] != a1\n+         || out[i*3 + 2] != a2)\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*11] = a8;\n+      out[i*11 + 1] = a7;\n+      out[i*11 + 2] = a1;\n+      out[i*11 + 3] = a2;\n+      out[i*11 + 4] = a8;\n+      out[i*11 + 5] = a5;\n+      out[i*11 + 6] = a5;\n+      out[i*11 + 7] = a4;\n+      out[i*11 + 8] = a12;\n+      out[i*11 + 9] = a13;\n+      out[i*11 + 10] = a14;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*11] != a8\n+          || out[i*11 + 1] != a7\n+          || out[i*11 + 2] != a1\n+          || out[i*11 + 3] != a2\n+          || out[i*11 + 4] != a8\n+          || out[i*11 + 5] != a5\n+          || out[i*11 + 6] != a5\n+          || out[i*11 + 7] != a4\n+          || out[i*11 + 8] != a12\n+          || out[i*11 + 9] != a13\n+          || out[i*11 + 10] != a14)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "86d3927a42c2db6005fd66972bf7d0d5767504b7", "filename": "gcc/testsuite/gcc.dg/vect/slp-20.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-20.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,116 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 (unsigned short a0, unsigned short a1, unsigned short a2, \n+       unsigned short a3, unsigned short a4, unsigned short a5,\n+       unsigned short a6, unsigned short a7, unsigned short a8)\n+{\n+  int i;\n+  unsigned short out[N*8], out2[N*8], b0, b1, b2, b3, b4, b5, b6, b7, b8;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+      b4 = a4 + 4;\n+      b5 = a5 + 3;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*4] = b0;\n+      out2[i*4 + 1] = b1;\n+      out2[i*4 + 2] = b4;\n+      out2[i*4 + 3] = b5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != b0 \n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+\tabort ();\n+\n+      if (out2[i*4] != b0  \n+         || out2[i*4 + 1] != b1\n+         || out2[i*4 + 2] != b4\n+         || out2[i*4 + 3] != b5)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+      b4 = a4 + 4;\n+      b5 = a5 + 3;\n+      b6 = a6 + 2;\n+      b7 = a7 + 1;\n+      b8 = a8 + 9;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*8] = b0;\n+      out2[i*8 + 1] = b1;\n+      out2[i*8 + 2] = b4;\n+      out2[i*8 + 3] = b5;\n+      out2[i*8 + 4] = b6;\n+      out2[i*8 + 5] = b2;\n+      out2[i*8 + 6] = b7;\n+      out2[i*8 + 7] = b8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != b0 \n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+        abort ();\n+\n+      if (out2[i*8] != b0\n+         || out2[i*8 + 1] != b1\n+         || out2[i*8 + 2] != b4\n+         || out2[i*8 + 3] != b5\n+         || out2[i*8 + 4] != b6\n+         || out2[i*8 + 5] != b2\n+         || out2[i*8 + 6] != b7\n+         || out2[i*8 + 7] != b8)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (8,7,6,5,4,3,2,1,0);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "327045e4789ef0698971fc572a8672b7fbc4d5b4", "filename": "gcc/testsuite/gcc.dg/vect/slp-21.c", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-21.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,208 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 ()\n+{\n+  unsigned short i;\n+  unsigned short out[N*8], out2[N*8], b0, b1, b2, b3, b4, a0, a1, a2, a3, b5;\n+  unsigned short in[N*8];\n+\n+  for (i = 0; i < N*8; i++)\n+    {\n+      in[i] = i;\n+    }\n+\n+  /* Different operations in both cases - vectorization with interleaving.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 * 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 * 5;\n+      \n+      b4 = a2 + 4;\n+      b5 = a3 + 3;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*4] = b0;\n+      out2[i*4 + 1] = b1;\n+      out2[i*4 + 2] = b4;\n+      out2[i*4 + 3] = b5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 * 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 * 5;\n+\n+      b4 = a2 + 4;\n+      b5 = a3 + 3;\n+\n+      if (out[i*4] != b0 \n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+\tabort ();\n+\n+      if (out2[i*4] != b0  \n+         || out2[i*4 + 1] != b1\n+         || out2[i*4 + 2] != b4\n+         || out2[i*4 + 3] != b5)\n+        abort ();\n+    }\n+\n+  /* Different operations in the first case - vectorization with interleaving.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 * 5;\n+\n+      b4 = a2 + 4;\n+      b5 = a3 + 3;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*4] = b0;\n+      out2[i*4 + 1] = b1;\n+      out2[i*4 + 2] = b4;\n+      out2[i*4 + 3] = b5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 * 5;\n+\n+      b4 = a2 + 4;\n+      b5 = a3 + 3;\n+\n+      if (out[i*4] != b0\n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+        abort ();\n+\n+      if (out2[i*4] != b0\n+         || out2[i*4 + 1] != b1\n+         || out2[i*4 + 2] != b4\n+         || out2[i*4 + 3] != b5)\n+        abort ();\n+    }\n+\n+\n+  /* Different operations in the second case - vectorization with interleaving.  */\n+  for (i = 0; i < N; i++) \n+    { \n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+\n+      b4 = a2 * 4;\n+      b5 = a3 + 3;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*4] = b0;\n+      out2[i*4 + 1] = b1;\n+      out2[i*4 + 2] = b4;\n+      out2[i*4 + 3] = b5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*4];\n+      a1 = in[i*4 + 1];\n+      a2 = in[i*4 + 2];\n+      a3 = in[i*4 + 3];\n+\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+\n+      b4 = a2 * 4;\n+      b5 = a3 + 3;\n+\n+      if (out[i*4] != b0\n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+        abort ();\n+\n+      if (out2[i*4] != b0\n+         || out2[i*4 + 1] != b1\n+         || out2[i*4 + 2] != b4\n+         || out2[i*4 + 3] != b5)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\"  { target vect_strided } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target  { ! { vect_strided } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target vect_strided }  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  { target { ! { vect_strided } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "18df4269a6c87e607303f677017b511be30c4db0", "filename": "gcc/testsuite/gcc.dg/vect/slp-22.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-22.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+int\n+main1 (unsigned short a0, unsigned short a1, unsigned short a2, \n+       unsigned short a3, unsigned short a4, unsigned short a5,\n+       unsigned short a6, unsigned short a7, unsigned short a8)\n+{\n+  int i;\n+  unsigned short out[N*8], out2[N*8], out3[N*8], b0, b1, b2, b3, b4, b5, b6, b7, b8;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+      b4 = a4 + 4;\n+      b5 = a5 + 3;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*4] = b0;\n+      out2[i*4 + 1] = b1;\n+      out2[i*4 + 2] = b4;\n+      out2[i*4 + 3] = b5;\n+\n+      out3[i*4] = b2;\n+      out3[i*4 + 1] = b1;\n+      out3[i*4 + 2] = b4;\n+      out3[i*4 + 3] = b5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != b0 \n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+\tabort ();\n+\n+    \n+      if (out2[i*4] != b0\n+         || out2[i*4 + 1] != b1\n+         || out2[i*4 + 2] != b4\n+         || out2[i*4 + 3] != b5)\n+        abort ();\n+   \n+      if (out3[i*4] != b2  \n+         || out3[i*4 + 1] != b1\n+         || out3[i*4 + 2] != b4\n+         || out3[i*4 + 3] != b5)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      b0 = a0 + 8;\n+      b1 = a1 + 7;\n+      b2 = a2 + 6;\n+      b3 = a3 + 5;\n+      b4 = a4 + 4;\n+      b5 = a5 + 3;\n+      b6 = a6 + 2;\n+      b7 = a7 + 1;\n+      b8 = a8 + 9;\n+\n+      out[i*4] = b0;\n+      out[i*4 + 1] = b1;\n+      out[i*4 + 2] = b2;\n+      out[i*4 + 3] = b3;\n+\n+      out2[i*8] = b0;\n+      out2[i*8 + 1] = b1;\n+      out2[i*8 + 2] = b4;\n+      out2[i*8 + 3] = b5;\n+      out2[i*8 + 4] = b6;\n+      out2[i*8 + 5] = b2;\n+      out2[i*8 + 6] = b7;\n+      out2[i*8 + 7] = b8;\n+\n+      out3[2*i + 1] = a0;\n+      out3[2*i] = b8; \n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] != b0 \n+         || out[i*4 + 1] != b1\n+         || out[i*4 + 2] != b2\n+         || out[i*4 + 3] != b3)\n+        abort ();\n+\n+      if (out2[i*8] != b0\n+         || out2[i*8 + 1] != b1\n+         || out2[i*8 + 2] != b4\n+         || out2[i*8 + 3] != b5\n+         || out2[i*8 + 4] != b6\n+         || out2[i*8 + 5] != b2\n+         || out2[i*8 + 6] != b7\n+         || out2[i*8 + 7] != b8)\n+        abort ();\n+\n+      if (out3[2*i] != b8\n+          || out3[2*i+1] != a0)\n+        abort();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (8,7,6,5,4,3,2,1,0);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 6 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "2bba580271dbf10f376e9f27dcc5dbdfcf160127", "filename": "gcc/testsuite/gcc.dg/vect/slp-23.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-23.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,113 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   int a;\n+   int b;\n+   int c;\n+   int d;\n+   int e;\n+   int f;\n+   int g;\n+   int h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->c + ptr->c;\n+      res[i].a = ptr->a + ptr->a;\n+      res[i].d = ptr->d + ptr->d;\n+      res[i].b = ptr->b + ptr->b;\n+      res[i].f = ptr->f + ptr->f;\n+      res[i].e = ptr->e + ptr->e; \n+      res[i].h = ptr->h + ptr->h;   \n+      res[i].g = ptr->g + ptr->g;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].c + arr[i].c\n+          || res[i].a != arr[i].a + arr[i].a\n+          || res[i].d != arr[i].d + arr[i].d\n+          || res[i].b != arr[i].b + arr[i].b\n+          || res[i].f != arr[i].f + arr[i].f\n+          || res[i].e != arr[i].e + arr[i].e\n+          || res[i].h != arr[i].h + arr[i].h\n+          || res[i].g != arr[i].g + arr[i].g)\n+         abort();\n+    }\n+\n+  ptr = arr;\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->c + ptr->c;\n+      res[i].a = ptr->a + ptr->a;\n+      res[i].d = ptr->d + ptr->d;\n+      res[i].b = ptr->b + ptr->b;\n+      res[i].f = ptr->f + ptr->f;\n+      res[i].e = ptr->e + ptr->e;\n+      res[i].h = ptr->e + ptr->e;\n+      res[i].g = ptr->g + ptr->g;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].c != arr[i].c + arr[i].c\n+          || res[i].a != arr[i].a + arr[i].a\n+          || res[i].d != arr[i].d + arr[i].d\n+          || res[i].b != arr[i].b + arr[i].b\n+          || res[i].f != arr[i].f + arr[i].f\n+          || res[i].e != arr[i].e + arr[i].e\n+          || res[i].h != arr[i].e + arr[i].e\n+          || res[i].g != arr[i].g + arr[i].g)\n+         abort();\n+    }\n+\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      arr[i].f = i * 5;\n+      arr[i].g = i - 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_strided } && {! { vect_no_align} } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { ! { vect_strided || vect_no_align} } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "b3bf0735b028609cb700b2f8c45269621f95c623", "filename": "gcc/testsuite/gcc.dg/vect/slp-24.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-24.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+} s;\n+\n+void\n+main1 (unsigned char x, unsigned char max_result, unsigned char min_result, s *arr)\n+{\n+  int i;\n+  unsigned char ub[N*2] = {1,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,1,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char uc[N] = {1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned char udiff = 2;\n+  unsigned char umax = x;\n+  unsigned char umin = x;\n+  unsigned char ua1[N*2];\n+  s *pIn = arr;\n+  s out[N];\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned char)(ub[i] - uc[i]);\n+\n+    ua1[2*i+1] = ub[2*i+1];\n+    ua1[2*i] = ub[2*i];\n+\n+    out[i].d = pIn->d - 1;\n+    out[i].b = pIn->b - 4;\n+    out[i].c = pIn->c - 8;\n+    out[i].a = pIn->a - 3;\n+\n+    pIn++;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    if (ua1[2*i] != ub[2*i]\n+        || ua1[2*i+1] != ub[2*i+1]\n+        || out[i].a != arr[i].a - 3\n+        || out[i].b != arr[i].b - 4\n+        || out[i].c != arr[i].c - 8\n+        || out[i].d != arr[i].d - 1)\n+      abort();\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+}\n+\n+int main (void)\n+{\n+  int i; \n+  s arr[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i + 9;\n+      arr[i].b = i * 2 + 10;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+  check_vect ();\n+  \n+  main1 (100, 100, 1, arr);\n+  main1 (0, 15, 0, arr);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "21f1900dc206fcda595f364cc24a0310e91ed5f3", "filename": "gcc/testsuite/gcc.dg/vect/slp-25.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* Unaligned stores.  */\n+\n+int main1 (int n)\n+{\n+  int i;\n+  int ia[N+1];\n+  short sa[N+1];\n+\n+  for (i = 1; i <= N/2; i++)\n+    {\n+      ia[2*i] = 25;\n+      ia[2*i + 1] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N/2; i++)\n+    {\n+      if (ia[2*i] != 25\n+          || ia[2*i + 1] != 5)\n+        abort ();\n+    }\n+\n+  for (i = 1; i <= n/2; i++)\n+    {\n+      sa[2*i] = 25;\n+      sa[2*i + 1] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= n/2; i++)\n+    {\n+      if (sa[2*i] != 25\n+          || sa[2*i + 1] != 5)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+\n+  check_vect ();\n+  \n+  return main1 (N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "14be68bd289cad8dec57de3f0f70e2e2a1f5506a", "filename": "gcc/testsuite/gcc.dg/vect/slp-26.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-26.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short out[N*8], a[N], b[N] = {3,6,9,12,15,18,21,24};\n+\n+  /* Partial SLP is not supported.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+\n+      a[i] = b[i] / 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3]\n+         || a[i] != b[i] / 3)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "069116ac58ec96f0f677c254167f973db4b9c2e9", "filename": "gcc/testsuite/gcc.dg/vect/slp-28.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-28.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+  unsigned short in2[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+  unsigned short in3[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+  unsigned short check[N] = {0,1,2,3,5,6,7,8,10,11,12,13,15,16,17,18,20,21,22,23,25,26,27,28,30,31,32,33,35,36,37,38};\n+  unsigned short check3[N] = {0,1,2,3,4,5,6,7,8,9,10,11,5,6,7,8,9,10,11,12,13,14,15,16,10,11,12,13,14,15,16,17};\n+\n+  for (i = 0; i < N/4; i++)\n+    {\n+      in[i*4] = in[i*4] + 5;\n+      in[i*4 + 1] = in[i*4 + 1] + 5;\n+      in[i*4 + 2] = in[i*4 + 2] + 5;\n+      in[i*4 + 3] = in[i*4 + 3] + 5;\n+\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (in[i] != i+5)\n+        abort ();\n+    }\n+\n+  /* Not vectorizable because of data dependencies.  */\n+  for (i = 1; i < N/4; i++)\n+    {\n+      in2[i*4] = in2[(i-1)*4] + 5;\n+      in2[i*4 + 1] = in2[(i-1)*4 + 1] + 5;\n+      in2[i*4 + 2] = in2[(i-1)*4 + 2] + 5;\n+      in2[i*4 + 3] = in2[(i-1)*4 + 3] + 5;\n+\n+    }\n+\n+  /* check results:  */\n+  for (i = 4; i < N; i++)\n+    {\n+      if (in2[i] != check[i])\n+        abort ();\n+    }\n+  \n+  /* Not vectorizable because of data dependencies: distance 3 is greater than \n+     the actual VF with SLP (2), but the analysis fail to detect that for now.  */\n+  for (i = 3; i < N/4; i++)\n+    {\n+      in3[i*4] = in3[(i-3)*4] + 5;\n+      in3[i*4 + 1] = in3[(i-3)*4 + 1] + 5;\n+      in3[i*4 + 2] = in3[(i-3)*4 + 2] + 5;\n+      in3[i*4 + 3] = in3[(i-3)*4 + 3] + 5;\n+\n+    }\n+\n+  /* check results:  */\n+  for (i = 12; i < N; i++)\n+    {\n+      if (in3[i] != check3[i])\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "474bfe8285f7d6e709b83c1bb2218a4671f9c5c3", "filename": "gcc/testsuite/gcc.dg/vect/slp-3.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-3.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,147 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8];\n+      out[i*8 + 1] = in[i*8 + 1];\n+      out[i*8 + 2] = in[i*8 + 2];\n+      out[i*8 + 3] = in[i*8 + 3];\n+      out[i*8 + 4] = in[i*8 + 4];\n+      out[i*8 + 5] = in[i*8 + 5];\n+      out[i*8 + 6] = in[i*8 + 6];\n+      out[i*8 + 7] = in[i*8 + 7];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7])\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3])\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*16] = in[i*16];\n+      out[i*16 + 1] = in[i*16 + 1];\n+      out[i*16 + 2] = in[i*16 + 2];\n+      out[i*16 + 3] = in[i*16 + 3];\n+      out[i*16 + 4] = in[i*16 + 4];\n+      out[i*16 + 5] = in[i*16 + 5];\n+      out[i*16 + 6] = in[i*16 + 6];\n+      out[i*16 + 7] = in[i*16 + 7];\n+      out[i*16 + 8] = in[i*16 + 8];\n+      out[i*16 + 9] = in[i*16 + 9];\n+      out[i*16 + 10] = in[i*16 + 10];\n+      out[i*16 + 11] = in[i*16 + 11];\n+      out[i*16 + 12] = in[i*16 + 12];\n+      out[i*16 + 13] = in[i*16 + 13];\n+      out[i*16 + 14] = in[i*16 + 14];\n+      out[i*16 + 15] = in[i*16 + 15];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*16] !=  in[i*16]\n+         || out[i*16 + 1] != in[i*16 + 1]\n+         || out[i*16 + 2] != in[i*16 + 2]\n+         || out[i*16 + 3] != in[i*16 + 3]\n+         || out[i*16 + 4] != in[i*16 + 4]\n+         || out[i*16 + 5] != in[i*16 + 5]\n+         || out[i*16 + 6] != in[i*16 + 6]\n+         || out[i*16 + 7] != in[i*16 + 7]\n+         || out[i*16 + 8] != in[i*16 + 8]\n+         || out[i*16 + 9] != in[i*16 + 9]\n+         || out[i*16 + 10] != in[i*16 + 10]\n+         || out[i*16 + 11] != in[i*16 + 11]\n+         || out[i*16 + 12] != in[i*16 + 12]\n+         || out[i*16 + 13] != in[i*16 + 13]\n+         || out[i*16 + 14] != in[i*16 + 14]\n+         || out[i*16 + 15] != in[i*16 + 15])\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*9] = in[i*9];\n+      out[i*9 + 1] = in[i*9 + 1];\n+      out[i*9 + 2] = in[i*9 + 2];\n+      out[i*9 + 3] = in[i*9 + 3];\n+      out[i*9 + 4] = in[i*9 + 4];\n+      out[i*9 + 5] = in[i*9 + 5];\n+      out[i*9 + 6] = in[i*9 + 6];\n+      out[i*9 + 7] = in[i*9 + 7];\n+      out[i*9 + 8] = in[i*9 + 8];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*9] !=  in[i*9]\n+         || out[i*9 + 1] != in[i*9 + 1]\n+         || out[i*9 + 2] != in[i*9 + 2]\n+         || out[i*9 + 3] != in[i*9 + 3]\n+         || out[i*9 + 4] != in[i*9 + 4]\n+         || out[i*9 + 5] != in[i*9 + 5]\n+         || out[i*9 + 6] != in[i*9 + 6]\n+         || out[i*9 + 7] != in[i*9 + 7]\n+         || out[i*9 + 8] != in[i*9 + 8])\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "86a641cfdf597a58fd0fd0ab4f8d18f61752e0c4", "filename": "gcc/testsuite/gcc.dg/vect/slp-33.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-33.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], a0, a1, a2, a3, a4, a5, a6, a7, b1, b0, b2, b3, b4, b5, b6, b7;\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  float out2[N*8];\n+\n+  /* SLP with unrolling by 4.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      a0 = in[i*7] + 5;\n+      a1 = in[i*7 + 1] + 6;\n+      a2 = in[i*7 + 2] + 7;\n+      a3 = in[i*7 + 3] + 8;\n+      a4 = in[i*7 + 4] + 9;\n+      a5 = in[i*7 + 5] + 10;\n+      a6 = in[i*7 + 6] + 11;\n+\n+      b0 = a0 * 3;\n+      b1 = a1 * 2;\n+      b2 = a2 * 12;\n+      b3 = a3 * 5;\n+      b4 = a4 * 8;\n+      b5 = a5 * 4;\n+      b6 = a6 * 3;\n+\n+      out[i*7] = b0 - 2;\n+      out[i*7 + 1] = b1 - 3; \n+      out[i*7 + 2] = b2 - 2;\n+      out[i*7 + 3] = b3 - 1;\n+      out[i*7 + 4] = b4 - 8;\n+      out[i*7 + 5] = b5 - 7;\n+      out[i*7 + 6] = b6 - 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*7] !=  (in[i*7] + 5) * 3 - 2\n+         || out[i*7 + 1] != (in[i*7 + 1] + 6) * 2 - 3\n+         || out[i*7 + 2] != (in[i*7 + 2] + 7) * 12 - 2\n+         || out[i*7 + 3] != (in[i*7 + 3] + 8) * 5 - 1\n+         || out[i*7 + 4] != (in[i*7 + 4] + 9) * 8 - 8\n+         || out[i*7 + 5] != (in[i*7 + 5] + 10) * 4 - 7\n+         || out[i*7 + 6] != (in[i*7 + 6] + 11) * 3 - 3)\n+\tabort ();\n+    }\n+\n+  /* SLP with unrolling by 4.  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*3] = (in[i*3] + 2) * 3;\n+      out[i*3 + 1] = (in[i*3 + 1] + 2) * 7;\n+      out[i*3 + 2] = (in[i*3 + 2] + 7) * 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*3] !=  (in[i*3] + 2) * 3\n+         || out[i*3 + 1] != (in[i*3 + 1] + 2) * 7\n+         || out[i*3 + 2] != (in[i*3 + 2] + 7) * 3)\n+        abort ();\n+    }\n+\n+  /* SLP with unrolling by 4.  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out2[i*3] = (float) (in[i*3] * 2 + 5) ;\n+      out2[i*3 + 1] = (float) (in[i*3 + 1] * 3 + 7);\n+      out2[i*3 + 2] = (float) (in[i*3 + 2] * 5 + 4);\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out2[i*3] !=  (float) (in[i*3] * 2 + 5)\n+         || out2[i*3 + 1] != (float) (in[i*3 + 1] * 3 + 7)\n+         || out2[i*3 + 2] != (float) (in[i*3 + 2] * 5 + 4))\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target {vect_intfloat_cvt && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target {{! { vect_intfloat_cvt}} && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\"  {target {{! { vect_intfloat_cvt}} && {!{vect_int_mult}}} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target {vect_intfloat_cvt && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  {target {{! { vect_intfloat_cvt}} && vect_int_mult} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  {target {{! { vect_intfloat_cvt}} && {!{vect_int_mult}}} } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "d25eef0210114829969f39072e986766fced3afd", "filename": "gcc/testsuite/gcc.dg/vect/slp-34.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-34.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short out2[N*8];\n+\n+  /* SLP with unrolling by 8.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*3] = in[i*3] + 5;\n+      out[i*3 + 1] = in[i*3 + 1] + 6;\n+      out[i*3 + 2] = in[i*3 + 2] + 16;\n+\n+      out2[i*5] = in2[i*5] + 2;\n+      out2[i*5 + 1] = in2[i*5 + 1] + 2;\n+      out2[i*5 + 2] = in2[i*5 + 2] + 1;\n+      out2[i*5 + 3] = in2[i*5 + 3] + 3;\n+      out2[i*5 + 4] = in2[i*5 + 4] + 13;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*3] != in[i*3] + 5\n+          || out[i*3 + 1] != in[i*3 + 1] + 6\n+          || out[i*3 + 2] != in[i*3 + 2] + 16\n+          || out2[i*5] != in2[i*5] + 2\n+          || out2[i*5 + 1] != in2[i*5 + 1] + 2\n+          || out2[i*5 + 2] != in2[i*5 + 2] + 1\n+          || out2[i*5 + 3] != in2[i*5 + 3] + 3\n+          || out2[i*5 + 4] != in2[i*5 + 4] + 13)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "39a7089ae7b24bcce0896de80d74721401aab18e", "filename": "gcc/testsuite/gcc.dg/vect/slp-35.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-35.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   int a;\n+   int b;\n+   int c;\n+   int d;\n+   int e;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+\n+  /* SLP with unrolling by 4.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->c + ptr->c;\n+      res[i].a = ptr->a + ptr->a;\n+      res[i].d = ptr->d + ptr->d;\n+      res[i].b = ptr->b + ptr->b;\n+      res[i].e = ptr->e + ptr->e; \n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].c + arr[i].c\n+          || res[i].a != arr[i].a + arr[i].a\n+          || res[i].d != arr[i].d + arr[i].d\n+          || res[i].b != arr[i].b + arr[i].b\n+          || res[i].e != arr[i].e + arr[i].e)\n+         abort();\n+    }\n+\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\"  { xfail vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "98d1473419e9b1bb62c4c14129e3749e50c7a72a", "filename": "gcc/testsuite/gcc.dg/vect/slp-36.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-36.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_shift } */\n+\n+#define N 32\n+\n+/* All the loops are vectorizable on platforms with vector shift argument.  */\n+\n+void\n+test_1 (void)\n+{\n+  static unsigned int bm[N];\n+  static unsigned int cm[N];\n+  int j;\n+\n+  /* Vectorizable on platforms with scalar shift argument.  */\n+  for (j = 0; j < N/2; j++)\n+   {\n+    bm[2*j] <<= 8;\n+    bm[2*j+1] <<= 8;\n+   }\n+\n+  /* Not vectorizable on platforms with scalar shift argument.  */\n+  for (j = 0; j < N/2; j++)\n+   {\n+    cm[2*j] <<= 8;\n+    cm[2*j+1] <<= 7;\n+   }\n+}\n+\n+void\n+test_2 (int a, int b)\n+{\n+  static unsigned int bm[N];\n+  static unsigned int cm[N];\n+  int j;\n+\n+  /* Vectorizable on platforms with scalar shift argument.  */\n+  for (j = 0; j < N/2; j++)\n+   {\n+    bm[2*j] <<= a;\n+    bm[2*j+1] <<= a;\n+   }\n+\n+  /* Not vectorizable on platforms with scalar shift argument.  */\n+  for (j = 0; j < N/2; j++)\n+   {\n+    cm[2*j] <<= a;\n+    cm[2*j+1] <<= b;\n+   }\n+}\n+\n+void\n+test_3 (void)\n+{\n+ static unsigned int bm[N];\n+ int am[N];\n+ int j;\n+\n+ /* Not vectorizable on platforms with scalar shift argument.  */\n+ for (j = 0; j < N/2; j++)\n+   {\n+    bm[2*j] <<= am[j];\n+    bm[2*j+1] <<= am[j];\n+   }\n+\n+ /* Not vectorizable on platforms with scalar shift argument.  */\n+ for (j = 0; j < N/2; j++)\n+   {\n+    bm[2*j] <<= am[2*j];\n+    bm[2*j+1] <<= am[2*j+1];\n+   }\n+\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "48642db96e71bc72b6c8454f894354ced7fab159", "filename": "gcc/testsuite/gcc.dg/vect/slp-37.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-37.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   int a;\n+   int b;\n+   void *c;\n+} s1;\n+\n+int\n+foo1 (s1 *arr)\n+{\n+  int i;\n+  s1 *ptr = arr;\n+\n+  /* Different constant types - not SLPable.  The group size is not power of 2,\n+     interleaving is not supported either.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      ptr->a = 6;\n+      ptr->b = 7;\n+      ptr->c = NULL;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+       if (arr[i].a != 6 \n+           || arr[i].b != 7\n+           || arr[i].c != NULL)\n+         abort();\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s1 arr1[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr1[i].a = i;\n+      arr1[i].b = i * 2;\n+      arr1[i].c = (void *)arr1;\n+\n+      if (arr1[i].a == 178)\n+         abort(); \n+    } \n+\n+\n+  foo1 (arr1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "e1353584fd2ff00d5b970871570ae757a3859d28", "filename": "gcc/testsuite/gcc.dg/vect/slp-4.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-4.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int ia[N*2];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8];\n+      out[i*8 + 1] = in[i*8 + 1];\n+      out[i*8 + 2] = in[i*8 + 2];\n+      out[i*8 + 3] = in[i*8 + 3];\n+      out[i*8 + 4] = in[i*8 + 4];\n+      out[i*8 + 5] = in[i*8 + 5];\n+      out[i*8 + 6] = in[i*8 + 6];\n+      out[i*8 + 7] = in[i*8 + 7];\n+    \n+      ia[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7]\n+         || ia[i] != 7)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+\n+      ia[i] = 12;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3]\n+         || ia[i] != 12)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*16] = in[i*16];\n+      out[i*16 + 1] = in[i*16 + 1];\n+      out[i*16 + 2] = in[i*16 + 2];\n+      out[i*16 + 3] = in[i*16 + 3];\n+      out[i*16 + 4] = in[i*16 + 4];\n+      out[i*16 + 5] = in[i*16 + 5];\n+      out[i*16 + 6] = in[i*16 + 6];\n+      out[i*16 + 7] = in[i*16 + 7];\n+      out[i*16 + 8] = in[i*16 + 8];\n+      out[i*16 + 9] = in[i*16 + 9];\n+      out[i*16 + 10] = in[i*16 + 10];\n+      out[i*16 + 11] = in[i*16 + 11];\n+      out[i*16 + 12] = in[i*16 + 12];\n+      out[i*16 + 13] = in[i*16 + 13];\n+      out[i*16 + 14] = in[i*16 + 14];\n+      out[i*16 + 15] = in[i*16 + 15];\n+\n+      ia[i] = 21;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*16] !=  in[i*16]\n+         || out[i*16 + 1] != in[i*16 + 1]\n+         || out[i*16 + 2] != in[i*16 + 2]\n+         || out[i*16 + 3] != in[i*16 + 3]\n+         || out[i*16 + 4] != in[i*16 + 4]\n+         || out[i*16 + 5] != in[i*16 + 5]\n+         || out[i*16 + 6] != in[i*16 + 6]\n+         || out[i*16 + 7] != in[i*16 + 7]\n+         || out[i*16 + 8] != in[i*16 + 8]\n+         || out[i*16 + 9] != in[i*16 + 9]\n+         || out[i*16 + 10] != in[i*16 + 10]\n+         || out[i*16 + 11] != in[i*16 + 11]\n+         || out[i*16 + 12] != in[i*16 + 12]\n+         || out[i*16 + 13] != in[i*16 + 13]\n+         || out[i*16 + 14] != in[i*16 + 14]\n+         || out[i*16 + 15] != in[i*16 + 15]\n+         || ia[i] != 21)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "0f9c2eefb21f0b5864dd4b7155b541704411cd30", "filename": "gcc/testsuite/gcc.dg/vect/slp-5.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-5.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8];\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short ia[N];\n+  unsigned int ib[N*2];\n+\n+  /* Not SLPable for now: multiple types with SLP of the smaller type.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8];\n+      out[i*8 + 1] = in[i*8 + 1];\n+      out[i*8 + 2] = in[i*8 + 2];\n+      out[i*8 + 3] = in[i*8 + 3];\n+      out[i*8 + 4] = in[i*8 + 4];\n+      out[i*8 + 5] = in[i*8 + 5];\n+      out[i*8 + 6] = in[i*8 + 6];\n+      out[i*8 + 7] = in[i*8 + 7];\n+    \n+      ia[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7]\n+         || ia[i] != 7)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = in[i*4];\n+      out[i*4 + 1] = in[i*4 + 1];\n+      out[i*4 + 2] = in[i*4 + 2];\n+      out[i*4 + 3] = in[i*4 + 3];\n+\n+      ib[i] = 12;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4]\n+         || out[i*4 + 1] != in[i*4 + 1]\n+         || out[i*4 + 2] != in[i*4 + 2]\n+         || out[i*4 + 3] != in[i*4 + 3]\n+         || ib[i] != 12)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out[i*16] = in[i*16];\n+      out[i*16 + 1] = in[i*16 + 1];\n+      out[i*16 + 2] = in[i*16 + 2];\n+      out[i*16 + 3] = in[i*16 + 3];\n+      out[i*16 + 4] = in[i*16 + 4];\n+      out[i*16 + 5] = in[i*16 + 5];\n+      out[i*16 + 6] = in[i*16 + 6];\n+      out[i*16 + 7] = in[i*16 + 7];\n+      out[i*16 + 8] = in[i*16 + 8];\n+      out[i*16 + 9] = in[i*16 + 9];\n+      out[i*16 + 10] = in[i*16 + 10];\n+      out[i*16 + 11] = in[i*16 + 11];\n+      out[i*16 + 12] = in[i*16 + 12];\n+      out[i*16 + 13] = in[i*16 + 13];\n+      out[i*16 + 14] = in[i*16 + 14];\n+      out[i*16 + 15] = in[i*16 + 15];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out[i*16] !=  in[i*16]\n+         || out[i*16 + 1] != in[i*16 + 1]\n+         || out[i*16 + 2] != in[i*16 + 2]\n+         || out[i*16 + 3] != in[i*16 + 3]\n+         || out[i*16 + 4] != in[i*16 + 4]\n+         || out[i*16 + 5] != in[i*16 + 5]\n+         || out[i*16 + 6] != in[i*16 + 6]\n+         || out[i*16 + 7] != in[i*16 + 7]\n+         || out[i*16 + 8] != in[i*16 + 8]\n+         || out[i*16 + 9] != in[i*16 + 9]\n+         || out[i*16 + 10] != in[i*16 + 10]\n+         || out[i*16 + 11] != in[i*16 + 11]\n+         || out[i*16 + 12] != in[i*16 + 12]\n+         || out[i*16 + 13] != in[i*16 + 13]\n+         || out[i*16 + 14] != in[i*16 + 14]\n+         || out[i*16 + 15] != in[i*16 + 15])\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { vect_strided } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target  { ! { vect_strided } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "5e86410588a94aebfc5b782aefcd7622e8759335", "filename": "gcc/testsuite/gcc.dg/vect/slp-6.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-6.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,122 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned short out[N*8];\n+  unsigned short in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned int out2[N*8];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8] + 5;\n+      out[i*8 + 1] = in[i*8 + 1] + 6;\n+      out[i*8 + 2] = in[i*8 + 2] + 7;\n+      out[i*8 + 3] = in[i*8 + 3] + 8;\n+      out[i*8 + 4] = in[i*8 + 4] + 9;\n+      out[i*8 + 5] = in[i*8 + 5] + 10;\n+      out[i*8 + 6] = in[i*8 + 6] + 11;\n+      out[i*8 + 7] = in[i*8 + 7] + 12;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8] + 5\n+         || out[i*8 + 1] != in[i*8 + 1] + 6\n+         || out[i*8 + 2] != in[i*8 + 2] + 7\n+         || out[i*8 + 3] != in[i*8 + 3] + 8\n+         || out[i*8 + 4] != in[i*8 + 4] + 9\n+         || out[i*8 + 5] != in[i*8 + 5] + 10\n+         || out[i*8 + 6] != in[i*8 + 6] + 11\n+         || out[i*8 + 7] != in[i*8 + 7] + 12)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = in[i*4] + 2;\n+      out[i*4 + 1] = in[i*4 + 1] + 2;\n+      out[i*4 + 2] = in[i*4 + 2] + 1;\n+      out[i*4 + 3] = in[i*4 + 3] + 3;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4] + 2\n+         || out[i*4 + 1] != in[i*4 + 1] + 2\n+         || out[i*4 + 2] != in[i*4 + 2] + 1\n+         || out[i*4 + 3] != in[i*4 + 3] + 3)\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      out2[i*16] = in2[i*16] * 2;\n+      out2[i*16 + 1] = in2[i*16 + 1] * 3;\n+      out2[i*16 + 2] = in2[i*16 + 2] * 4;\n+      out2[i*16 + 3] = in2[i*16 + 3] * 3;\n+      out2[i*16 + 4] = in2[i*16 + 4] * 2;\n+      out2[i*16 + 5] = in2[i*16 + 5] * 3;\n+      out2[i*16 + 6] = in2[i*16 + 6] * 2;\n+      out2[i*16 + 7] = in2[i*16 + 7] * 4;\n+      out2[i*16 + 8] = in2[i*16 + 8] * 2;\n+      out2[i*16 + 9] = in2[i*16 + 9] * 5;\n+      out2[i*16 + 10] = in2[i*16 + 10] * 2;\n+      out2[i*16 + 11] = in2[i*16 + 11] * 3;\n+      out2[i*16 + 12] = in2[i*16 + 12] * 4;\n+      out2[i*16 + 13] = in2[i*16 + 13] * 4;\n+      out2[i*16 + 14] = in2[i*16 + 14] * 3;\n+      out2[i*16 + 15] = in2[i*16 + 15] * 2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (out2[i*16] !=  in2[i*16] * 2\n+         || out2[i*16 + 1] != in2[i*16 + 1] * 3\n+         || out2[i*16 + 2] != in2[i*16 + 2] * 4\n+         || out2[i*16 + 3] != in2[i*16 + 3] * 3\n+         || out2[i*16 + 4] != in2[i*16 + 4] * 2\n+         || out2[i*16 + 5] != in2[i*16 + 5] * 3\n+         || out2[i*16 + 6] != in2[i*16 + 6] * 2\n+         || out2[i*16 + 7] != in2[i*16 + 7] * 4\n+         || out2[i*16 + 8] != in2[i*16 + 8] * 2\n+         || out2[i*16 + 9] != in2[i*16 + 9] * 5\n+         || out2[i*16 + 10] != in2[i*16 + 10] * 2\n+         || out2[i*16 + 11] != in2[i*16 + 11] * 3\n+         || out2[i*16 + 12] != in2[i*16 + 12] * 4\n+         || out2[i*16 + 13] != in2[i*16 + 13] * 4\n+         || out2[i*16 + 14] != in2[i*16 + 14] * 3\n+         || out2[i*16 + 15] != in2[i*16 + 15] * 2)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target vect_int_mult} } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target  { ! { vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" {target vect_int_mult  } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" {target  { ! { vect_int_mult } } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "4ee7029af0ecedfbe0379148fc7c8615c0f69c2b", "filename": "gcc/testsuite/gcc.dg/vect/slp-7.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-7.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,127 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 8 \n+\n+int\n+main1 ()\n+{\n+  int i;\n+  unsigned int out[N*8], ia[N*2];\n+  unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short in2[N*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+  unsigned short sa[N], out2[N*16];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i*8] = in[i*8] + 5;\n+      out[i*8 + 1] = in[i*8 + 1] + 6;\n+      out[i*8 + 2] = in[i*8 + 2] + 7;\n+      out[i*8 + 3] = in[i*8 + 3] + 8;\n+      out[i*8 + 4] = in[i*8 + 4] + 9;\n+      out[i*8 + 5] = in[i*8 + 5] + 10;\n+      out[i*8 + 6] = in[i*8 + 6] + 11;\n+      out[i*8 + 7] = in[i*8 + 7] + 12;\n+\n+      ia[i] = in[i]; \n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8] + 5\n+         || out[i*8 + 1] != in[i*8 + 1] + 6\n+         || out[i*8 + 2] != in[i*8 + 2] + 7\n+         || out[i*8 + 3] != in[i*8 + 3] + 8\n+         || out[i*8 + 4] != in[i*8 + 4] + 9\n+         || out[i*8 + 5] != in[i*8 + 5] + 10\n+         || out[i*8 + 6] != in[i*8 + 6] + 11\n+         || out[i*8 + 7] != in[i*8 + 7] + 12\n+         || ia[i] != in[i])\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < N*2; i++)\n+    {\n+      out[i*4] = in[i*4] + 1; \n+      out[i*4 + 1] = in[i*4 + 1] + 2;\n+      out[i*4 + 2] = in[i*4 + 2] + 3;\n+      out[i*4 + 3] = in[i*4 + 3] + 4;\n+\n+      ia[i] = in[i];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N*2; i++)\n+    {\n+      if (out[i*4] !=  in[i*4] + 1\n+         || out[i*4 + 1] != in[i*4 + 1] + 2\n+         || out[i*4 + 2] != in[i*4 + 2] + 3 \n+         || out[i*4 + 3] != in[i*4 + 3] + 4\n+         || ia[i] != in[i])\n+        abort ();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out2[i*16] = in2[i*16] * 2;\n+      out2[i*16 + 1] = in2[i*16 + 1] * 3;\n+      out2[i*16 + 2] = in2[i*16 + 2] * 4;\n+      out2[i*16 + 3] = in2[i*16 + 3] * 3;\n+      out2[i*16 + 4] = in2[i*16 + 4] * 2;\n+      out2[i*16 + 5] = in2[i*16 + 5] * 3;\n+      out2[i*16 + 6] = in2[i*16 + 6] * 2;\n+      out2[i*16 + 7] = in2[i*16 + 7] * 4;\n+      out2[i*16 + 8] = in2[i*16 + 8] * 2;\n+      out2[i*16 + 9] = in2[i*16 + 9] * 5;\n+      out2[i*16 + 10] = in2[i*16 + 10] * 2;\n+      out2[i*16 + 11] = in2[i*16 + 11] * 3;\n+      out2[i*16 + 12] = in2[i*16 + 12] * 4;\n+      out2[i*16 + 13] = in2[i*16 + 13] * 4;\n+      out2[i*16 + 14] = in2[i*16 + 14] * 3;\n+      out2[i*16 + 15] = in2[i*16 + 15] * 2;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (out2[i*16] !=  in2[i*16] * 2\n+         || out2[i*16 + 1] != in2[i*16 + 1] * 3\n+         || out2[i*16 + 2] != in2[i*16 + 2] * 4\n+         || out2[i*16 + 3] != in2[i*16 + 3] * 3\n+         || out2[i*16 + 4] != in2[i*16 + 4] * 2\n+         || out2[i*16 + 5] != in2[i*16 + 5] * 3\n+         || out2[i*16 + 6] != in2[i*16 + 6] * 2\n+         || out2[i*16 + 7] != in2[i*16 + 7] * 4\n+         || out2[i*16 + 8] != in2[i*16 + 8] * 2\n+         || out2[i*16 + 9] != in2[i*16 + 9] * 5\n+         || out2[i*16 + 10] != in2[i*16 + 10] * 2\n+         || out2[i*16 + 11] != in2[i*16 + 11] * 3\n+         || out2[i*16 + 12] != in2[i*16 + 12] * 4\n+         || out2[i*16 + 13] != in2[i*16 + 13] * 4\n+         || out2[i*16 + 14] != in2[i*16 + 14] * 3\n+         || out2[i*16 + 15] != in2[i*16 + 15] * 2)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\"  {target {  vect_strided &&  vect_int_mult  } } } }*/\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  {target  { ! {  vect_strided && vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+ "}, {"sha": "1260ddce5046aaab7fa3e7cf4281e84271861110", "filename": "gcc/testsuite/gcc.dg/vect/slp-8.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-8.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+\n+int main1 ()\n+{\n+  int i;\n+  int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  float fa[N];\n+\n+  /* int -> float */\n+  for (i = 0; i < N/4; i++)\n+    {\n+      fa[4*i] = (float) ib[4*i];\t\n+      fa[4*i + 1] = (float) ib[4*i + 1];\t\n+      fa[4*i + 2] = (float) ib[4*i + 2];\t\n+      fa[4*i + 3] = (float) ib[4*i + 3];\t\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N/4; i++)\n+    {\n+      if (fa[4*i] != (float) ib[4*i]      \n+          || fa[4*i + 1] != (float) ib[4*i + 1]\n+          || fa[4*i + 2] != (float) ib[4*i + 2]\n+          || fa[4*i + 3] != (float) ib[4*i + 3])\n+        abort (); \n+    }   \n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cfb30bd718b2ef953b900235f4fc97ce5cd6b6b4", "filename": "gcc/testsuite/gcc.dg/vect/slp-9.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-9.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+short X[N] __attribute__ ((__aligned__(16)));\n+short Y[N] __attribute__ ((__aligned__(16)));\n+int result[N];\n+\n+/* short->int widening-mult */\n+int\n+foo1(int len) {\n+  int i;\n+\n+  for (i=0; i<len/2; i++) {\n+    result[2*i] = X[2*i] * Y[2*i];\n+    result[2*i+1] = X[2*i+1] * Y[2*i+1];\n+  }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i=0; i<N; i++) {\n+    X[i] = i;\n+    Y[i] = 64-i;\n+  }\n+\n+  foo1 (N);\n+\n+  for (i=0; i<N; i++) {\n+    if (result[i] != X[i] * Y[i])\n+      abort ();\n+  }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" {  target { vect_strided && vect_widen_mult_hi_to_si } } } }*/\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "7d684aa1ff06d9361fcbd7eaee50f5b92c78cf78", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-03.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-03.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -10,9 +10,9 @@ struct S\n   unsigned short b;\n };\n \n-struct S result[N] = {12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18,\n-                      18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24,\n-\t\t      24, 25, 25, 26, 26, 27, 27, 28};\n+struct S result[N] = {20, 13, 22, 14, 24, 15, 26, 16, 28, 17, 30, 18,\n+                      32, 19, 34, 20, 36, 21, 38, 22, 40, 23, 42, 24,\n+\t\t      44, 25, 46, 26, 48, 27, 50, 28};\n struct S X[N] = {10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16,\n                  16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n \t\t 23, 23, 24, 24, 25, 25};\n@@ -25,7 +25,7 @@ foo (struct S * in, struct S * out)\n \n   for (i = 0; i < N; i++)\n     {\n-      out[i].a = in[i].a + 2;\n+      out[i].a = in[i].a * 2;\n       out[i].b = in[i].b + 3;\n     }\n }\n@@ -42,10 +42,10 @@ main (void)\n   /* check results:  */\n   for (i = 0; i < N; i++)\n     {\n-      if (Y[i].a != result[i].a)\n+      if (Y[i].a != result[i].a)  \n \tabort ();\n \n-      if (Y[i].b != result[i].b)\n+      if (Y[i].b != result[i].b) \n \tabort ();\n \n     }"}, {"sha": "27560c72d9d956e412a723c87e6152a983f48bda", "filename": "gcc/testsuite/gcc.dg/vect/vect-vfa-slp.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-vfa-slp.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+struct S\n+{\n+  unsigned short a;\n+  unsigned short b;\n+};\n+\n+struct S result[N] = {12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18,\n+                      18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24,\n+\t\t      24, 25, 25, 26, 26, 27, 27, 28};\n+struct S X[N] = {10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16,\n+                 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n+\t\t 23, 23, 24, 24, 25, 25};\n+struct S Y[N] = {};\n+ \n+__attribute__ ((noinline)) void\n+foo (struct S * in, struct S * out)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      out[i].a = in[i].a + 2;\n+      out[i].b = in[i].b + 3;\n+    }\n+}\n+\n+int\n+main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  foo (X, Y);\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (Y[i].a != result[i].a)\n+\tabort ();\n+\n+      if (Y[i].b != result[i].b)\n+\tabort ();\n+\n+    }\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e9be793621e96917e79ae9bc31548e91b556e102", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -108,6 +108,8 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/slp-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS\n@@ -122,25 +124,25 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-vfa-*.\\[cS\\]]]  \\\n # -ffast-math tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-vect*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/fast-math-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fno-math-errno tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-math-errno\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-math-errno-vect*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-math-errno-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fwrapv tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fwrapv\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/wrapv-vect*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/wrapv-*.\\[cS\\]]]  \\\n         \"\" $DEFAULT_VECTCFLAGS\n \n # -ftrapv tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-ftrapv\"\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/trapv-vect*.\\[cS\\]]]  \\\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/trapv-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n # -fdump-tree-dceloop-details tests\n@@ -197,12 +199,24 @@ lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\" \"-fno-tree-reassoc\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-noreassoc-*.\\[cS\\]]]  \\\n         \"\" $DEFAULT_VECTCFLAGS\n \n+# -fno-tree-scev-cprop\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fno-tree-scev-cprop\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-scevccp-slp-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n # -fno-tree-dominator-opts\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-fno-tree-dominator-opts\"\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-dom-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n+# -fno-tree-pre\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-fno-tree-pre\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-pre-*.\\[cS\\]]]  \\\n+        \"\" $DEFAULT_VECTCFLAGS\n+\n # With -Os\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n lappend DEFAULT_VECTCFLAGS \"-Os\""}, {"sha": "55e2a8a4c3038c2eac2451cc4064f894e2a1f504", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -2043,7 +2043,7 @@ proc check_effective_target_vect_no_align { } {\n \tset et_vect_no_align_saved 0\n \tif { [istarget mipsisa64*-*-*]\n \t     || [istarget sparc*-*-*]\n-\t     || [istarget ia64-*-*] } {\n+\t     || [istarget ia64-*-*] } { \n \t    set et_vect_no_align_saved 1\n \t}\n     }\n@@ -2255,6 +2255,24 @@ proc check_effective_target_vect_interleave { } {\n     return $et_vect_interleave_saved\n }\n \n+# Return 1 if the target supports vector interleaving and extract even/odd, 0 otherwise.\n+proc check_effective_target_vect_strided { } {\n+    global et_vect_strided_saved\n+\n+    if [info exists et_vect_strided_saved] {\n+        verbose \"check_effective_target_vect_strided: using cached result\" 2\n+    } else {\n+        set et_vect_strided_saved 0\n+        if { [check_effective_target_vect_interleave]\n+             && [check_effective_target_vect_extract_even_odd] } {\n+           set et_vect_strided_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_strided: returning $et_vect_strided_saved\" 2\n+    return $et_vect_strided_saved\n+}\n+\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {"}, {"sha": "684d12dfcb437c4d8862a3e957157c725367e528", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 937, "deletions": 123, "changes": 1060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"toplev.h\"\n+#include \"recog.h\"\n \n /* Main analysis functions.  */\n static loop_vec_info vect_analyze_loop_form (struct loop *);\n@@ -300,6 +301,30 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n }\n \n \n+/* SLP costs are calculated according to SLP instance unrolling factor (i.e., \n+   the number of created vector stmts depends on the unrolling factor). However,\n+   the actual number of vector stmts for every SLP node depends on VF which is\n+   set later in vect_analyze_operations(). Hence, SLP costs should be updated.\n+   In this function we assume that the inside costs calculated in \n+   vect_model_xxx_cost are linear in ncopies.  */\n+\n+static void\n+vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n+{\n+  unsigned int i, vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  slp_instance instance;\n+\n+  if (vect_print_dump_info (REPORT_SLP))\n+    fprintf (vect_dump, \"=== vect_update_slp_costs_according_to_vf ===\");\n+\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    /* We assume that costs are linear in ncopies.  */\n+    SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance) *= vf \n+      / SLP_INSTANCE_UNROLLING_FACTOR (instance);\t  \n+}\n+\n+\n /* Function vect_analyze_operations.\n \n    Scan the loop stmts and make sure they are all vectorizable.  */\n@@ -320,6 +345,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   int min_profitable_iters;\n   int min_scalar_loop_bound;\n   unsigned int th;\n+  bool only_slp_in_loop = true;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n@@ -456,12 +482,12 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n \t  ok = (vectorizable_type_promotion (stmt, NULL, NULL)\n \t\t|| vectorizable_type_demotion (stmt, NULL, NULL)\n-\t\t|| vectorizable_conversion (stmt, NULL, NULL)\n-\t\t|| vectorizable_operation (stmt, NULL, NULL)\n-\t\t|| vectorizable_assignment (stmt, NULL, NULL)\n-\t\t|| vectorizable_load (stmt, NULL, NULL)\n+\t\t|| vectorizable_conversion (stmt, NULL, NULL, NULL)\n+\t\t|| vectorizable_operation (stmt, NULL, NULL, NULL)\n+\t\t|| vectorizable_assignment (stmt, NULL, NULL, NULL)\n+\t\t|| vectorizable_load (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_call (stmt, NULL, NULL)\n-\t\t|| vectorizable_store (stmt, NULL, NULL)\n+\t\t|| vectorizable_store (stmt, NULL, NULL, NULL)\n \t\t|| vectorizable_condition (stmt, NULL, NULL)\n \t\t|| vectorizable_reduction (stmt, NULL, NULL));\n \n@@ -480,6 +506,30 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t\t}\n \t      return false;\n \t    }\t\n+\n+\t  if (!PURE_SLP_STMT (stmt_info))\n+\t    {\n+\t      /* STMT needs loop-based vectorization.  */\n+\t      only_slp_in_loop = false;\n+\n+\t      /* Groups of strided accesses whose size is not a power of 2 are \n+\t\t not vectorizable yet using loop-vectorization. Therefore, if \n+\t\t this stmt feeds non-SLP-able stmts (i.e., this stmt has to be \n+\t\t both SLPed and loop-based vectorzed), the loop cannot be \n+\t\t vectorized.  */\n+\t      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+\t\t  && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n+\t\t\t          DR_GROUP_FIRST_DR (stmt_info)))) == -1)\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    {\n+\t\t      fprintf (vect_dump, \"not vectorized: the size of group \"\n+\t\t\t       \"of strided accesses is not a power of 2\");\n+\t\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t    }\n \t} /* stmts in bb */\n     } /* bbs */\n \n@@ -499,6 +549,18 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n+     vectorization factor of the loop is the unrolling factor required by the\n+     SLP instances.  If that unrolling factor is 1, we say, that we perform\n+     pure SLP on loop - cross iteration parallelism is not exploited.  */\n+  if (only_slp_in_loop)\n+    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+  else\n+    vectorization_factor = least_common_multiple (vectorization_factor,\n+\t\t\t\tLOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+  \n+  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump,\n@@ -518,6 +580,10 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n   /* Analyze cost. Decide if worth while to vectorize.  */\n \n+  /* Once VF is set, SLP costs should be updated since the number of created\n+     vector stmts depends on VF.  */\n+  vect_update_slp_costs_according_to_vf (loop_vinfo);\n+\n   min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n   if (min_profitable_iters < 0)\n@@ -1462,9 +1528,9 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n \n  /* For interleaved data accesses the step in the loop must be multiplied by\n      the size of the interleaving group.  */\n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     dr_size *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_DR (stmt_info)));\n-  if (DR_GROUP_FIRST_DR (peel_stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (peel_stmt_info))\n     dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n \n   /* It can be assumed that the data refs with the same alignment as dr_peel\n@@ -1516,7 +1582,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n       stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n       /* For interleaving, only the alignment of the first access matters.  */\n-      if (DR_GROUP_FIRST_DR (stmt_info)\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n         continue;\n \n@@ -1554,7 +1620,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       /* For interleaved access we peel only if number of iterations in\n \t the prolog loop ({VF - misalignment}), is a multiple of the\n@@ -1768,7 +1834,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n       /* For interleaving, only the alignment of the first access\n          matters.  */\n-      if (DR_GROUP_FIRST_DR (stmt_info)\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n         continue;\n \n@@ -1818,7 +1884,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t     members of the group, therefore we divide the number of iterations\n \t     by the group size.  */\n \t  stmt_info = vinfo_for_stmt (DR_STMT (dr0));\t  \n-\t  if (DR_GROUP_FIRST_DR (stmt_info))\n+\t  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n \t    npeel /= DR_GROUP_SIZE (stmt_info);\n \n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1837,7 +1903,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  stmt_info = vinfo_for_stmt (stmt);\n \t  /* For interleaving, only the alignment of the first access\n             matters.  */\n-\t  if (DR_GROUP_FIRST_DR (stmt_info)\n+\t  if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n \t      && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n \t    continue;\n \n@@ -1907,7 +1973,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  /* For interleaving, only the alignment of the first access\n \t     matters.  */\n \t  if (aligned_access_p (dr)\n-\t      || (DR_GROUP_FIRST_DR (stmt_info)\n+\t      || (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n \t\t  && DR_GROUP_FIRST_DR (stmt_info) != stmt))\n \t    continue;\n \n@@ -2019,64 +2085,28 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_data_ref_access.\n-\n-   Analyze the access pattern of the data-reference DR. For now, a data access\n-   has to be consecutive to be considered vectorizable.  */\n+/* Analyze groups of strided accesses: check that DR belongs to a group of\n+   strided accesses of legal size, step, etc. Detect gaps, single element\n+   interleaving, and other special cases. Set strided access info.\n+   Collect groups of strided stores for further use in SLP analysis.  */\n \n static bool\n-vect_analyze_data_ref_access (struct data_reference *dr)\n+vect_analyze_group_access (struct data_reference *dr)\n {\n   tree step = DR_STEP (dr);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n   HOST_WIDE_INT type_size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n   tree stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n   HOST_WIDE_INT stride;\n+  bool slp_impossible = false;\n \n-  /* Don't allow invariant accesses.  */\n-  if (dr_step == 0)\n-    return false; \n-\n-  if (nested_in_vect_loop_p (loop, stmt))\n-    {\n-      /* For the rest of the analysis we use the outer-loop step.  */\n-      step = STMT_VINFO_DR_STEP (stmt_info);\n-      dr_step = TREE_INT_CST_LOW (step);\n-      \n-      if (dr_step == 0)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\t    fprintf (vect_dump, \"zero step in outer loop.\");\n-\t  if (DR_IS_READ (dr))\n-  \t    return true; \n-\t  else\n-\t    return false;\n-\t}\n-    }\n-    \n   /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the \n      interleaving group (including gaps).  */\n   stride = dr_step / type_size; \n \n-  /* Consecutive?  */\n-  if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n-    {\n-      /* Mark that it is not interleaving.  */\n-      DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = NULL_TREE;\n-      return true;\n-    }\n-\n-  if (nested_in_vect_loop_p (loop, stmt))\n-    {\n-      if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\tfprintf (vect_dump, \"strided access in outer loop.\");\n-      return false;\n-    }\n-\n   /* Not consecutive access is possible only if it is a part of interleaving.  */\n   if (!DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n     {\n@@ -2119,122 +2149,204 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       HOST_WIDE_INT diff, count_in_bytes;\n \n       while (next)\n-\t{\n-\t  /* Skip same data-refs. In case that two or more stmts share data-ref\n-\t     (supported only for loads), we vectorize only the first stmt, and\n-\t     the rest get their vectorized loads from the first one.  */\n-\t  if (!tree_int_cst_compare (DR_INIT (data_ref),\n-\t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (\n-\t\t\t\t\t\t      vinfo_for_stmt (next)))))\n-\t    {\n+        {\n+          /* Skip same data-refs. In case that two or more stmts share data-ref\n+             (supported only for loads), we vectorize only the first stmt, and\n+             the rest get their vectorized loads from the first one.  */\n+          if (!tree_int_cst_compare (DR_INIT (data_ref),\n+                                     DR_INIT (STMT_VINFO_DATA_REF (\n+\t\t\t\t\t\t   vinfo_for_stmt (next)))))\n+            {\n               if (!DR_IS_READ (data_ref))\n-                { \n+                {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump, \"Two store stmts share the same dr.\");\n-                  return false; \n+                  return false;\n                 }\n \n-              /* Check that there is no load-store dependencies for this loads \n+              /* Check that there is no load-store dependencies for this loads\n                  to prevent a case of load-store-load to the same location.  */\n               if (DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n                   || DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump, \n+                    fprintf (vect_dump,\n                              \"READ_WRITE dependence in interleaving.\");\n                   return false;\n                 }\n \n-\t      /* For load use the same data-ref load.  */\n-\t      DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n+              /* For load use the same data-ref load.  */\n+              DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n \n-\t      prev = next;\n-\t      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n-\t      continue;\n-\t    }\n-\t  prev = next;\n+              prev = next;\n+              next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+              continue;\n+            }\n+          prev = next;\n \n-\t  /* Check that all the accesses have the same STEP.  */\n-\t  next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n-\t  if (tree_int_cst_compare (step, next_step))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"not consecutive access in interleaving\");\n-\t      return false;\n-\t    }\n+          /* Check that all the accesses have the same STEP.  */\n+          next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n+          if (tree_int_cst_compare (step, next_step))\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"not consecutive access in interleaving\");\n+              return false;\n+            }\n \n-\t  data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n-\t  /* Check that the distance between two accesses is equal to the type\n-\t     size. Otherwise, we have gaps.  */\n-\t  diff = (TREE_INT_CST_LOW (DR_INIT (data_ref)) \n-\t\t  - TREE_INT_CST_LOW (prev_init)) / type_size;\n-\t  if (!DR_IS_READ (data_ref) && diff != 1)\n+          data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n+          /* Check that the distance between two accesses is equal to the type\n+             size. Otherwise, we have gaps.  */\n+          diff = (TREE_INT_CST_LOW (DR_INIT (data_ref))\n+                  - TREE_INT_CST_LOW (prev_init)) / type_size;\n+\t  if (diff != 1)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"interleaved store with gaps\");\n-\t      return false;\n+\t      /* FORNOW: SLP of accesses with gaps is not supported.  */\n+\t      slp_impossible = true;\n+\t      if (!DR_IS_READ (data_ref))\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    fprintf (vect_dump, \"interleaved store with gaps\");\n+\t\t  return false;\n+\t\t}\n \t    }\n-\t  /* Store the gap from the previous member of the group. If there is no\n+\n+          /* Store the gap from the previous member of the group. If there is no\n              gap in the access, DR_GROUP_GAP is always 1.  */\n-\t  DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n+          DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n \n-\t  prev_init = DR_INIT (data_ref);\n-\t  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n-\t  /* Count the number of data-refs in the chain.  */\n-\t  count++;\n-\t}\n+          prev_init = DR_INIT (data_ref);\n+          next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+          /* Count the number of data-refs in the chain.  */\n+          count++;\n+        }\n \n-      /* COUNT is the number of accesses found, we multiply it by the size of \n-\t the type to get COUNT_IN_BYTES.  */\n+      /* COUNT is the number of accesses found, we multiply it by the size of\n+         the type to get COUNT_IN_BYTES.  */\n       count_in_bytes = type_size * count;\n \n       /* Check that the size of the interleaving is not greater than STEP.  */\n-      if (dr_step < count_in_bytes) \n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    {\n-\t      fprintf (vect_dump, \"interleaving size is greater than step for \");\n-\t      print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM); \n-\t    }\n-\t  return false;\n-\t}\n+      if (dr_step < count_in_bytes)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"interleaving size is greater than step for \");\n+              print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n+            }\n+          return false;\n+        }\n \n-      /* Check that the size of the interleaving is equal to STEP for stores, \n-         i.e., that there are no gaps.  */ \n-      if (!DR_IS_READ (dr) && dr_step != count_in_bytes) \n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"interleaved store with gaps\");\n-\t  return false;\n-\t}\n+      /* Check that the size of the interleaving is equal to STEP for stores,\n+         i.e., that there are no gaps.  */\n+      if (!DR_IS_READ (dr) && dr_step != count_in_bytes)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"interleaved store with gaps\");\n+          return false;\n+        }\n \n       /* Check that STEP is a multiple of type size.  */\n       if ((dr_step % type_size) != 0)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS)) \n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n             {\n               fprintf (vect_dump, \"step is not a multiple of type size: step \");\n               print_generic_expr (vect_dump, step, TDF_SLIM);\n               fprintf (vect_dump, \" size \");\n               print_generic_expr (vect_dump, TYPE_SIZE_UNIT (scalar_type),\n                                   TDF_SLIM);\n             }\n-\t  return false;\n-\t}\n+          return false;\n+        }\n \n-      /* FORNOW: we handle only interleaving that is a power of 2.  */\n+      /* FORNOW: we handle only interleaving that is a power of 2.  \n+         We don't fail here if it may be still possible to vectorize the\n+         group using SLP. If not, the size of the group will be checked in\n+         vect_analyze_operations, and the vectorization will fail.  */\n       if (exact_log2 (stride) == -1)\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"interleaving is not a power of 2\");\n-\t  return false;\n+\n+\t  if (slp_impossible)\n+\t    return false;\n \t}\n       DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"Detected interleaving of size %d\", (int)stride);\n+\n+      /* SLP: create an SLP data structure for every interleaving group of \n+\t stores for further analysis in vect_analyse_slp.  */\n+      if (!DR_IS_READ (dr) && !slp_impossible)\n+\tVEC_safe_push (tree, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo), stmt);\n     }\n+\n   return true;\n }\n \n \n+/* Analyze the access pattern of the data-reference DR.\n+   In case of non-consecutive accesse call vect_analyze_group_access() to\n+   analyze groups of strided accesses.  */\n+\n+static bool\n+vect_analyze_data_ref_access (struct data_reference *dr)\n+{\n+  tree step = DR_STEP (dr);\n+  tree scalar_type = TREE_TYPE (DR_REF (dr));\n+  tree stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n+\n+  if (!step)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"bad data-ref access\");\n+      return false;\n+    }\n+\n+  /* Don't allow invariant accesses.  */\n+  if (dr_step == 0)\n+    return false; \n+\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      /* For the rest of the analysis we use the outer-loop step.  */\n+      step = STMT_VINFO_DR_STEP (stmt_info);\n+      dr_step = TREE_INT_CST_LOW (step);\n+      \n+      if (dr_step == 0)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\t    fprintf (vect_dump, \"zero step in outer loop.\");\n+\t  if (DR_IS_READ (dr))\n+  \t    return true; \n+\t  else\n+\t    return false;\n+\t}\n+    }\n+\n+  /* Consecutive?  */\n+  if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n+    {\n+      /* Mark that it is not interleaving.  */\n+      DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = NULL_TREE;\n+      return true;\n+    }\n+\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    {\n+      if (vect_print_dump_info (REPORT_ALIGNMENT))\n+\tfprintf (vect_dump, \"strided access in outer loop.\");\n+      return false;\n+    }\n+\n+  /* Not consecutive access - check if it's a part of interleaving group.  */\n+  return vect_analyze_group_access (dr);\n+}\n+\n+\n /* Function vect_analyze_data_ref_accesses.\n \n    Analyze the access pattern of all the data references in the loop.\n@@ -2266,6 +2378,697 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n }\n \n \n+/* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n+\n+void\n+vect_free_slp_tree (slp_tree node)\n+{\n+  if (!node)\n+    return;\n+\n+  if (SLP_TREE_LEFT (node))\n+    vect_free_slp_tree (SLP_TREE_LEFT (node));\n+   \n+  if (SLP_TREE_RIGHT (node))\n+    vect_free_slp_tree (SLP_TREE_RIGHT (node));\n+   \n+  VEC_free (tree, heap, SLP_TREE_SCALAR_STMTS (node));\n+  \n+  if (SLP_TREE_VEC_STMTS (node))\n+    VEC_free (tree, heap, SLP_TREE_VEC_STMTS (node));\n+\n+  free (node);\n+}\n+\n+\n+/* Get the defs for the RHS (collect them in DEF_STMTS0/1), check that they are \n+   of a legal type and that they match the defs of the first stmt of the SLP \n+   group (stored in FIRST_STMT_...).  */\n+\n+static bool\n+vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n+\t\t\t     tree rhs, VEC (tree, heap) **def_stmts0,\n+\t\t\t     VEC (tree, heap) **def_stmts1,\n+\t\t\t     enum vect_def_type *first_stmt_dt0,\n+\t\t\t     enum vect_def_type *first_stmt_dt1,\n+\t\t\t     tree *first_stmt_def0_type, \n+\t\t\t     tree *first_stmt_def1_type,\n+\t\t\t     tree *first_stmt_const_oprnd,\n+\t\t\t     int ncopies_for_cost)\n+{\n+  tree oprnd;\n+  enum operation_type op_type = TREE_OPERAND_LENGTH (rhs);\n+  unsigned int i, number_of_oprnds = op_type;\n+  tree def, def_stmt;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  stmt_vec_info stmt_info = \n+    vinfo_for_stmt (VEC_index (tree, SLP_TREE_SCALAR_STMTS (slp_node), 0));\n+\n+  /* Store.  */\n+  if (!op_type)\n+    number_of_oprnds = 1;\n+  else\n+    gcc_assert (op_type == unary_op || op_type == binary_op);\n+\n+  for (i = 0; i < number_of_oprnds; i++)\n+    {\n+      if (op_type)\n+\toprnd = TREE_OPERAND (rhs, i);\n+      else\n+\toprnd = rhs;\n+\n+      if (!vect_is_simple_use (oprnd, loop_vinfo, &def_stmt, &def, &dt[i])\n+\t  || (!def_stmt && dt[i] != vect_constant_def))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_SLP)) \n+\t    {\n+\t      fprintf (vect_dump, \"Build SLP failed: can't find def for \");\n+\t      print_generic_expr (vect_dump, oprnd, TDF_SLIM);\n+\t    }\n+\n+\t  return false;\n+\t}\n+\n+      if (!*first_stmt_dt0)\n+\t{\n+\t  /* op0 of the first stmt of the group - store its info.  */\n+\t  *first_stmt_dt0 = dt[i];\n+\t  if (def)\n+\t    *first_stmt_def0_type = TREE_TYPE (def);\n+\t  else\n+\t    *first_stmt_const_oprnd = oprnd;\n+\n+\t  /* Analyze costs (for the first stmt of the group only).  */\n+\t  if (op_type)\n+\t    /* Not memory operation (we don't call this functions for loads).  */\n+\t    vect_model_simple_cost (stmt_info, ncopies_for_cost, dt, slp_node);\n+\t  else\n+\t    /* Store.  */\n+\t    vect_model_store_cost (stmt_info, ncopies_for_cost, dt[0], slp_node);\n+\t}\n+      \n+      else\n+\t{\n+\t  if (!*first_stmt_dt1 && i == 1)\n+\t    {\n+\t      /* op1 of the first stmt of the group - store its info.  */\n+\t      *first_stmt_dt1 = dt[i];\n+\t      if (def)\n+\t\t*first_stmt_def1_type = TREE_TYPE (def);\n+\t      else\n+\t\t{\n+\t\t  /* We assume that the stmt contains only one constant \n+\t\t     operand. We fail otherwise, to be on the safe side.  */\n+\t\t  if (*first_stmt_const_oprnd)\n+\t\t    {\n+\t\t      if (vect_print_dump_info (REPORT_SLP)) \n+\t\t\tfprintf (vect_dump, \"Build SLP failed: two constant \"\n+\t\t\t\t \"oprnds in stmt\");\t\t    \n+\t\t      return false;\n+\t\t    }\n+\t\t  *first_stmt_const_oprnd = oprnd;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Not first stmt of the group, check that the def-stmt/s match \n+\t\t the def-stmt/s of the first stmt.  */\n+\t      if ((i == 0 \n+\t\t   && (*first_stmt_dt0 != dt[i]\n+\t\t       || (*first_stmt_def0_type && def\n+\t\t\t   && *first_stmt_def0_type != TREE_TYPE (def))))\n+\t\t  || (i == 1 \n+\t\t      && (*first_stmt_dt1 != dt[i]\n+\t\t\t  || (*first_stmt_def1_type && def\n+\t\t\t      && *first_stmt_def1_type != TREE_TYPE (def))))\t\t  \n+\t\t  || (!def \n+\t\t      && TREE_TYPE (*first_stmt_const_oprnd) \n+\t\t      != TREE_TYPE (oprnd)))\n+\t\t{ \n+\t\t  if (vect_print_dump_info (REPORT_SLP)) \n+\t\t    fprintf (vect_dump, \"Build SLP failed: different types \");\n+\t\t  \n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Check the types of the definitions.  */\n+      switch (dt[i])\n+\t{\n+\tcase vect_constant_def:\n+\tcase vect_invariant_def:\n+\t  break;\n+\t  \n+\tcase vect_loop_def:\n+\t  if (i == 0)\n+\t    VEC_safe_push (tree, heap, *def_stmts0, def_stmt);\n+\t  else\n+\t    VEC_safe_push (tree, heap, *def_stmts1, def_stmt);\n+\t  break;\n+\n+\tdefault:\n+\t  /* FORNOW: Not supported.  */\n+\t  if (vect_print_dump_info (REPORT_SLP)) \n+\t    {\n+\t      fprintf (vect_dump, \"Build SLP failed: illegal type of def \");\n+\t      print_generic_expr (vect_dump, def, TDF_SLIM);\n+\t    }\n+\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Recursively build an SLP tree starting from NODE.\n+   Fail (and return FALSE) if def-stmts are not isomorphic, require data \n+   permutation or are of unsupported types of operation. Otherwise, return \n+   TRUE.\n+   SLP_IMPOSSIBLE is TRUE if it is impossible to SLP in the loop, for example\n+   in the case of multiple types for now.  */\n+\n+static bool\n+vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node, \n+\t\t     unsigned int group_size, bool *slp_impossible,\n+\t\t     int *inside_cost, int *outside_cost,\n+\t\t     int ncopies_for_cost)\n+{\n+  VEC (tree, heap) *def_stmts0 = VEC_alloc (tree, heap, group_size);\n+  VEC (tree, heap) *def_stmts1 =  VEC_alloc (tree, heap, group_size);\n+  unsigned int i;\n+  VEC (tree, heap) *stmts = SLP_TREE_SCALAR_STMTS (*node);\n+  tree stmt = VEC_index (tree, stmts, 0);\n+  enum vect_def_type first_stmt_dt0 = 0, first_stmt_dt1 = 0;\n+  enum tree_code first_stmt_code = 0;\n+  tree first_stmt_def1_type = NULL_TREE, first_stmt_def0_type = NULL_TREE;\n+  tree lhs, rhs, prev_stmt = NULL_TREE;\n+  bool stop_recursion = false, need_same_oprnds = false;\n+  tree vectype, scalar_type, first_op1 = NULL_TREE;\n+  unsigned int vectorization_factor = 0, ncopies;\n+  optab optab;\n+  int icode;\n+  enum machine_mode optab_op2_mode;\n+  enum machine_mode vec_mode;\n+  tree first_stmt_const_oprnd = NULL_TREE;\n+  struct data_reference *first_dr;\n+ \n+  /* For every stmt in NODE find its def stmt/s.  */\n+  for (i = 0; VEC_iterate (tree, stmts, i, stmt); i++)\n+    {\n+      if (vect_print_dump_info (REPORT_SLP)) \n+\t{\n+\t  fprintf (vect_dump, \"Build SLP for \");\n+\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t}\n+\n+      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_SLP)) \n+\t    {\n+\t      fprintf (vect_dump, \"Build SLP failed: not MODIFY_STMT \");\n+\t      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t    }\n+\t  \n+\t  return false;\n+\t}\n+\n+      scalar_type = TREE_TYPE (GIMPLE_STMT_OPERAND (stmt, 0));\n+      vectype = get_vectype_for_scalar_type (scalar_type);\n+      gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+      vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+      ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n+      if (ncopies > 1)\n+\t{\n+\t  /* FORNOW.  */\n+\t  if (vect_print_dump_info (REPORT_SLP)) \n+\t    fprintf (vect_dump, \"SLP failed - multiple types \");\n+\t  \n+\t  *slp_impossible = true;\n+\t  return false;\n+\t}\n+\n+      lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+      /* Check the operation.  */\n+      if (i == 0)\n+\t{\n+\t  first_stmt_code = TREE_CODE (rhs);\n+\n+\t  /* Shift arguments should be equal in all the packed stmts for a \n+\t     vector shift with scalar shift operand.  */\n+\t  if (TREE_CODE (rhs) == LSHIFT_EXPR || TREE_CODE (rhs) == RSHIFT_EXPR)\n+\t    {\n+\t      vec_mode = TYPE_MODE (vectype);\n+\t      optab = optab_for_tree_code (TREE_CODE (rhs), vectype);\n+\t      if (!optab)\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_SLP))\n+\t\t    fprintf (vect_dump, \"Build SLP failed: no optab.\");\n+\t\t  return false;\n+\t\t}\n+\t      icode = (int) optab->handlers[(int) vec_mode].insn_code;\n+\t      optab_op2_mode = insn_data[icode].operand[2].mode;\n+\t      if (!VECTOR_MODE_P (optab_op2_mode))\n+\t\t{\n+\t\t  need_same_oprnds = true;\n+\t\t  first_op1 = TREE_OPERAND (rhs, 1);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (first_stmt_code != TREE_CODE (rhs))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_SLP)) \n+\t\t{\n+\t\t  fprintf (vect_dump, \n+\t\t\t   \"Build SLP failed: different operation in stmt \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t}\n+\t      \n+\t      return false;\n+\t    }\n+\t  \n+\t  if (need_same_oprnds \n+\t      && !operand_equal_p (first_op1, TREE_OPERAND (rhs, 1), 0))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_SLP)) \n+\t\t{\n+\t\t  fprintf (vect_dump, \n+\t\t\t   \"Build SLP failed: different shift arguments in \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t}\n+\t      \n+\t      return false;\n+\t    }\n+\t}\n+\n+      /* Strided store or load.  */\n+      if (STMT_VINFO_STRIDED_ACCESS (vinfo_for_stmt (stmt)))\n+\t{\n+\t  if (REFERENCE_CLASS_P (lhs))\n+\t    {\n+\t      /* Store.  */\n+\t      if (!vect_get_and_check_slp_defs (loop_vinfo, *node, rhs, \n+\t\t\t\t\t\t&def_stmts0, &def_stmts1, \n+\t\t\t\t\t\t&first_stmt_dt0, \n+\t\t\t\t\t\t&first_stmt_dt1, \n+\t\t\t\t\t\t&first_stmt_def0_type, \n+\t\t\t\t\t\t&first_stmt_def1_type,\n+\t\t\t\t\t\t&first_stmt_const_oprnd,\n+\t\t\t\t\t\tncopies_for_cost))\n+\t\treturn false;\n+\t    }\n+\t    else\n+\t      {\n+\t\t/* Load.  */\n+\t\tif (i == 0)\n+\t\t  {\n+\t\t    /* First stmt of the SLP group should be the first load of \n+\t\t       the interleaving loop if data permutation is not \n+\t\t       allowed.  */\n+\t\t    if  (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) != stmt) \n+\t\t      {\n+\t\t\t/* FORNOW: data permutations are not supported.  */\n+\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n+\t\t\t  {\n+\t\t\t    fprintf (vect_dump, \"Build SLP failed: strided \"\n+\t\t\t\t     \" loads need permutation \");\n+\t\t\t    print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t\t  }\n+\n+\t\t\treturn false;\n+\t\t      }\n+\n+\t\t    first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n+\t\t    if (vect_supportable_dr_alignment (first_dr)\n+\t\t\t== dr_unaligned_unsupported)\n+\t\t      {\n+\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n+\t\t\t  {\n+\t\t\t    fprintf (vect_dump, \"Build SLP failed: unsupported \"\n+\t\t\t\t     \" unaligned load \");\n+\t\t\t    print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t\t  }\n+\n+\t\t\treturn false;\n+\t\t      }\n+\n+\t\t    /* Analyze costs (for the first stmt in the group).  */\n+\t\t    vect_model_load_cost (vinfo_for_stmt (stmt), \n+\t\t\t\t\t  ncopies_for_cost, *node);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (DR_GROUP_NEXT_DR (vinfo_for_stmt (prev_stmt)) != stmt)\n+\t\t      {\n+\t\t\t/* FORNOW: data permutations are not supported.  */\n+\t\t\tif (vect_print_dump_info (REPORT_SLP)) \n+\t\t\t  {\n+\t\t\t    fprintf (vect_dump, \"Build SLP failed: strided \"\n+\t\t\t\t     \" loads need permutation \");\n+\t\t\t    print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t\t  }\n+\t\t\treturn false;\n+\t\t      }\n+\t\t  }\n+\n+\t\tprev_stmt = stmt;\n+\n+\t\t/* We stop the tree when we reach a group of loads.  */\n+\t\tstop_recursion = true;\n+\t\tcontinue;\n+\t      }\n+\t} /* Strided access.  */\n+      else\n+\t{\n+\t  if (REFERENCE_CLASS_P (rhs))\n+\t    {\n+\t      /* Not strided load. */\n+\t      if (vect_print_dump_info (REPORT_SLP)) \n+\t\t{\n+\t\t  fprintf (vect_dump, \"Build SLP failed: not strided load \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t}\n+\n+\t      /* FORNOW: Not strided loads are not supported.  */\n+\t      return false;\n+\t    }\n+\n+\t  /* Not memory operation.  */\n+\t  if (!BINARY_CLASS_P (rhs) && !UNARY_CLASS_P (rhs))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_SLP)) \n+\t\t{\n+\t\t  fprintf (vect_dump, \"Build SLP failed: operation\");\n+\t\t  fprintf (vect_dump, \" unsupported \");\n+\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+\t\t}\n+\n+\t      return false;\n+\t    }\n+\n+\t  /* Find the def-stmts.  */ \n+\t  if (!vect_get_and_check_slp_defs (loop_vinfo, *node, rhs, &def_stmts0, \n+\t\t\t\t\t    &def_stmts1, &first_stmt_dt0, \n+\t\t\t\t\t    &first_stmt_dt1, \n+\t\t\t\t\t    &first_stmt_def0_type, \n+\t\t\t\t\t    &first_stmt_def1_type,\n+\t\t\t\t\t    &first_stmt_const_oprnd,\n+\t\t\t\t\t    ncopies_for_cost))\n+\t    return false;\n+\t}\n+    }\n+\n+  /* Add the costs of the node to the overall instance costs.  */\n+  *inside_cost += SLP_TREE_INSIDE_OF_LOOP_COST (*node); \n+  *outside_cost += SLP_TREE_OUTSIDE_OF_LOOP_COST (*node);\n+\n+  /* Strided loads were reached - stop the recursion.  */\n+  if (stop_recursion)\n+    return true;\n+\n+  /* Create SLP_TREE nodes for the definition node/s.  */ \n+  if (first_stmt_dt0 == vect_loop_def)\n+    {\n+      slp_tree left_node = XNEW (struct _slp_tree);\n+      SLP_TREE_SCALAR_STMTS (left_node) = def_stmts0;\n+      SLP_TREE_VEC_STMTS (left_node) = NULL;\n+      SLP_TREE_LEFT (left_node) = NULL;\n+      SLP_TREE_RIGHT (left_node) = NULL;\n+      SLP_TREE_OUTSIDE_OF_LOOP_COST (left_node) = 0;\n+      SLP_TREE_INSIDE_OF_LOOP_COST (left_node) = 0;\n+      if (!vect_build_slp_tree (loop_vinfo, &left_node, group_size, \n+\t\t\t\tslp_impossible, inside_cost, outside_cost,\n+\t\t\t\tncopies_for_cost))\n+\treturn false;\n+      \n+      SLP_TREE_LEFT (*node) = left_node;\n+    }\n+\n+  if (first_stmt_dt1 == vect_loop_def)\n+    {\n+      slp_tree right_node = XNEW (struct _slp_tree);\n+      SLP_TREE_SCALAR_STMTS (right_node) = def_stmts1;\n+      SLP_TREE_VEC_STMTS (right_node) = NULL;\n+      SLP_TREE_LEFT (right_node) = NULL;\n+      SLP_TREE_RIGHT (right_node) = NULL;\n+      SLP_TREE_OUTSIDE_OF_LOOP_COST (right_node) = 0;\n+      SLP_TREE_INSIDE_OF_LOOP_COST (right_node) = 0;\n+      if (!vect_build_slp_tree (loop_vinfo, &right_node, group_size,\n+\t\t\t\tslp_impossible, inside_cost, outside_cost,\n+\t\t\t\tncopies_for_cost))\n+\treturn false;\n+      \n+      SLP_TREE_RIGHT (*node) = right_node;\n+    }\n+\n+  return true;\n+}\n+\n+\n+static void\n+vect_print_slp_tree (slp_tree node)\n+{\n+  int i;\n+  tree stmt;\n+\n+  if (!node)\n+    return;\n+\n+  fprintf (vect_dump, \"node \");\n+  for (i = 0; VEC_iterate (tree, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+    {\n+      fprintf (vect_dump, \"\\n\\tstmt %d \", i);\n+      print_generic_expr (vect_dump, stmt, TDF_SLIM);  \n+    }\n+  fprintf (vect_dump, \"\\n\");\n+\n+  vect_print_slp_tree (SLP_TREE_LEFT (node));\n+  vect_print_slp_tree (SLP_TREE_RIGHT (node));\n+}\n+\n+\n+/* Mark the tree rooted at NODE with MARK (PURE_SLP or HYBRID). \n+   If MARK is HYBRID, it refers to a specific stmt in NODE (the stmt at index \n+   J). Otherwise, MARK is PURE_SLP and J is -1, which indicates that all the \n+   stmts in NODE are to be marked.  */\n+\n+static void\n+vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n+{\n+  int i;\n+  tree stmt;\n+\n+  if (!node)\n+    return;\n+\n+  for (i = 0; VEC_iterate (tree, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+    if (j < 0 || i == j)\n+      STMT_SLP_TYPE (vinfo_for_stmt (stmt)) = mark;\n+\n+  vect_mark_slp_stmts (SLP_TREE_LEFT (node), mark, j);\n+  vect_mark_slp_stmts (SLP_TREE_RIGHT (node), mark, j);\n+}\n+\n+\n+/* Analyze an SLP instance starting from a group of strided stores. Call\n+   vect_build_slp_tree to build a tree of packed stmts if possible. \n+   Return FALSE if it's impossible to SLP any stmt in the loop.  */\n+\n+static bool\n+vect_analyze_slp_instance (loop_vec_info loop_vinfo, tree stmt)\n+{\n+  slp_instance new_instance;\n+  slp_tree node = XNEW (struct _slp_tree);\n+  unsigned int group_size = DR_GROUP_SIZE (vinfo_for_stmt (stmt));\n+  unsigned int unrolling_factor = 1, nunits;\n+  tree vectype, scalar_type, next;\n+  unsigned int vectorization_factor = 0, ncopies;\n+  bool slp_impossible = false; \n+  int inside_cost = 0, outside_cost = 0, ncopies_for_cost;\n+\n+  /* FORNOW: multiple types are not supported.  */\n+  scalar_type = TREE_TYPE (DR_REF (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))));\n+  vectype = get_vectype_for_scalar_type (scalar_type);\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  ncopies = vectorization_factor / nunits;\n+  if (ncopies > 1)\n+    {\n+      if (vect_print_dump_info (REPORT_SLP)) \n+\t  fprintf (vect_dump, \"SLP failed - multiple types \");\n+\n+      return false;\n+    }\n+\n+  /* Create a node (a root of the SLP tree) for the packed strided stores.  */ \n+  SLP_TREE_SCALAR_STMTS (node) = VEC_alloc (tree, heap, group_size);\n+  next = stmt;\n+  /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n+  while (next)\n+    {\n+      VEC_safe_push (tree, heap, SLP_TREE_SCALAR_STMTS (node), next);\n+      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+    }\n+\n+  SLP_TREE_VEC_STMTS (node) = NULL;\n+  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n+  SLP_TREE_LEFT (node) = NULL;\n+  SLP_TREE_RIGHT (node) = NULL;\n+  SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n+  SLP_TREE_INSIDE_OF_LOOP_COST (node) = 0;\n+\n+  /* Calculate the unrolling factor.  */\n+  unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n+\t\n+  /* Calculate the number of vector stmts to create based on the unrolling\n+     factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n+     GROUP_SIZE / NUNITS otherwise.  */\n+  ncopies_for_cost = unrolling_factor * group_size / nunits;\n+\n+  /* Build the tree for the SLP instance.  */\n+  if (vect_build_slp_tree (loop_vinfo, &node, group_size, &slp_impossible,\n+\t\t\t   &inside_cost, &outside_cost, ncopies_for_cost))\n+    {\n+      /* Create a new SLP instance.  */  \n+      new_instance = XNEW (struct _slp_instance);\n+      SLP_INSTANCE_TREE (new_instance) = node;\n+      SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n+      SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n+      SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n+      SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n+      VEC_safe_push (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo), \n+\t\t     new_instance);\n+      if (vect_print_dump_info (REPORT_SLP))\n+\tvect_print_slp_tree (node);\n+\n+      return true;\n+    }\n+\n+  /* Failed to SLP.  */\n+  /* Free the allocated memory.  */\n+  vect_free_slp_tree (node);\n+\n+  if (slp_impossible)\n+    return false;\n+\n+  /* SLP failed for this instance, but it is still possible to SLP other stmts \n+     in the loop.  */\n+  return true;\n+}\n+\n+\n+/* Check if there are stmts in the loop can be vectorized using SLP. Build SLP\n+   trees of packed scalar stmts if SLP is possible.  */\n+\n+static bool\n+vect_analyze_slp (loop_vec_info loop_vinfo)\n+{\n+  unsigned int i;\n+  VEC (tree, heap) *strided_stores = LOOP_VINFO_STRIDED_STORES (loop_vinfo);\n+  tree store;\n+\n+  if (vect_print_dump_info (REPORT_SLP))\n+    fprintf (vect_dump, \"=== vect_analyze_slp ===\");\n+\n+  for (i = 0; VEC_iterate (tree, strided_stores, i, store); i++)\n+    if (!vect_analyze_slp_instance (loop_vinfo, store))\n+      {\n+\t/* SLP failed. No instance can be SLPed in the loop.  */\n+\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\t\n+\t  fprintf (vect_dump, \"SLP failed.\");\n+\n+\treturn false;\n+      }\n+\n+  return true;\n+}\n+\n+\n+/* For each possible SLP instance decide whether to SLP it and calculate overall\n+   unrolling factor needed to SLP the loop.  */\n+\n+static void\n+vect_make_slp_decision (loop_vec_info loop_vinfo)\n+{\n+  unsigned int i, unrolling_factor = 1;\n+  VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  slp_instance instance;\n+  int decided_to_slp = 0;\n+\n+  if (vect_print_dump_info (REPORT_SLP))\n+    fprintf (vect_dump, \"=== vect_make_slp_decision ===\");\n+\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    {\n+      /* FORNOW: SLP if you can.  */\n+      if (unrolling_factor < SLP_INSTANCE_UNROLLING_FACTOR (instance))\n+\tunrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n+\n+      /* Mark all the stmts that belong to INSTANCE as PURE_SLP stmts. Later we \n+\t call vect_detect_hybrid_slp () to find stmts that need hybrid SLP and \n+\t loop-based vectorization. Such stmts will be marked as HYBRID.  */\n+      vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n+      decided_to_slp++;\n+    }\n+\n+  LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo) = unrolling_factor;\n+\n+  if (decided_to_slp && vect_print_dump_info (REPORT_SLP)) \n+    fprintf (vect_dump, \"Decided to SLP %d instances. Unrolling factor %d\", \n+\t     decided_to_slp, unrolling_factor);\n+}\n+\n+\n+/* Find stmts that must be both vectorized and SLPed (since they feed stmts that\n+   can't be SLPed) in the tree rooted at NODE. Mark such stmts as HYBRID.  */\n+\n+static void\n+vect_detect_hybrid_slp_stmts (slp_tree node)\n+{\n+  int i;\n+  tree stmt;\n+  imm_use_iterator imm_iter;\n+  tree use_stmt;\n+\n+  if (!node)\n+    return;\n+\n+  for (i = 0; VEC_iterate (tree, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+    if (PURE_SLP_STMT (vinfo_for_stmt (stmt))\n+\t&& TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME)\n+      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, GIMPLE_STMT_OPERAND (stmt, 0))\n+\tif (vinfo_for_stmt (use_stmt)\n+\t    && !STMT_SLP_TYPE (vinfo_for_stmt (use_stmt)))\n+\t  vect_mark_slp_stmts (node, hybrid, i);\n+\n+  vect_detect_hybrid_slp_stmts (SLP_TREE_LEFT (node));\n+  vect_detect_hybrid_slp_stmts (SLP_TREE_RIGHT (node));\n+}\n+\n+\n+/* Find stmts that must be both vectorized and SLPed.  */\n+\n+static void\n+vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n+{\n+  unsigned int i;\n+  VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  slp_instance instance;\n+\n+  if (vect_print_dump_info (REPORT_SLP))\n+    fprintf (vect_dump, \"=== vect_detect_hybrid_slp ===\");\n+\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n+}\n+\n+\n /* Function vect_analyze_data_refs.\n \n   Find all the data references in the loop.\n@@ -3424,6 +4227,17 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n+  ok = vect_analyze_slp (loop_vinfo);\n+  if (ok)\n+    {\n+      /* Decide which possible SLP instances to SLP.  */\n+      vect_make_slp_decision (loop_vinfo);\n+\n+      /* Find stmts that need to be both vectorized and SLPed.  */\n+      vect_detect_hybrid_slp (loop_vinfo);\n+    }\n+\n   /* This pass will decide on using loop versioning and/or loop peeling in\n      order to enhance the alignment of data references in the loop.  */\n "}, {"sha": "9698b417885b4c0503bb3aef7892d6b99a993e3c", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 732, "deletions": 168, "changes": 900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"real.h\"\n \n /* Utility functions for the code transformation.  */\n-static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *);\n+static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *, slp_tree);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n   (tree, struct loop*, tree, tree *, tree *, bool, tree, bool *); \n@@ -125,6 +125,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   int nbbs = loop->num_nodes;\n   int byte_misalign;\n   int innerloop_iters = 0, factor;\n+  VEC (slp_instance, heap) *slp_instances;\n+  slp_instance instance;\n \n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n@@ -287,6 +289,14 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t\t  targetm.vectorize.builtin_vectorization_cost (runtime_test));\n     }\n \n+  /* Add SLP costs.  */\n+  slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    {\n+      vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n+      vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n+    }\n+\n   /* Calculate number of iterations required to make the vector version \n      profitable, relative to the loop bodies only. The following condition\n      must hold true: ((SIC*VF)-VIC)*niters > VOC*VF, where\n@@ -452,30 +462,55 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n }\n \n \n+/* Return addresses of the cost fields of SLP_NODE if it's not NULL, and of\n+   the stmt otherwise.  */\n+\n+static inline void\n+vect_get_cost_fields (stmt_vec_info stmt_info, slp_tree slp_node, \n+\t\t      int **inside_cost_field, int **outside_cost_field)\n+{\n+  if (slp_node)\n+    {\n+      *inside_cost_field = &(SLP_TREE_INSIDE_OF_LOOP_COST (slp_node));\n+      *outside_cost_field = &(SLP_TREE_OUTSIDE_OF_LOOP_COST (slp_node));\n+    }\n+  else\n+    {\n+      *inside_cost_field = &(STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info));\n+      *outside_cost_field = &(STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+    }\n+}\n+\n+\n /* Function vect_model_simple_cost.  \n \n    Models cost for simple operations, i.e. those that only emit ncopies of a \n    single op.  Right now, this does not account for multiple insns that could\n    be generated for the single vector op.  We will handle that shortly.  */\n \n-static void\n-vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type *dt)\n+void\n+vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies, \n+\t\t\tenum vect_def_type *dt, slp_tree slp_node)\n {\n   int i;\n+  int *inside_cost_field, *outside_cost_field;\n \n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n+  /* Take addresses of relevant fields to update in the function.  */\n+  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n+\t\t\t&outside_cost_field);\n+\n+  *inside_cost_field = ncopies * TARG_VEC_STMT_COST;\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n-  for (i=0; i<2; i++)\n+  for (i = 0; i < 2; i++)\n     {\n       if (dt[i] == vect_constant_def || dt[i] == vect_invariant_def)\n-\tSTMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) += TARG_SCALAR_TO_VEC_COST; \n+\t*outside_cost_field += TARG_SCALAR_TO_VEC_COST; \n     }\n   \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n-             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n }\n \n \n@@ -502,14 +537,20 @@ vect_cost_strided_group_size (stmt_vec_info stmt_info)\n    Models cost for stores.  In the case of strided accesses, one access\n    has the overhead of the strided access attributed to it.  */\n \n-static void\n-vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type dt)\n+void\n+vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, \n+\t\t       enum vect_def_type dt, slp_tree slp_node)\n {\n   int cost = 0;\n   int group_size;\n+  int *inside_cost_field, *outside_cost_field;\n+\n+  /* Take addresses of relevant fields to update in the function.  */\n+  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n+\t\t\t&outside_cost_field);\n \n   if (dt == vect_constant_def || dt == vect_invariant_def)\n-    STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = TARG_SCALAR_TO_VEC_COST;\n+    *outside_cost_field = TARG_SCALAR_TO_VEC_COST;\n \n   /* Strided access?  */\n   if (DR_GROUP_FIRST_DR (stmt_info)) \n@@ -535,12 +576,11 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type\n   /* Costs of the stores.  */\n   cost += ncopies * TARG_VEC_STORE_COST;\n \n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = cost;\n+  *inside_cost_field = cost;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n-             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n }\n \n \n@@ -551,19 +591,24 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type\n    accesses are supported for loads, we also account for the costs of the \n    access scheme chosen.  */\n \n-static void\n-vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n+void\n+vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n \t\t \n {\n   int inner_cost = 0;\n   int group_size;\n   int alignment_support_cheme;\n   tree first_stmt;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n+  int *inside_cost_field, *outside_cost_field;\n+\n+  /* Take addresses of relevant fields to update in the function.  */\n+  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n+\t\t\t&outside_cost_field);\n \n   /* Strided accesses?  */\n   first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n-  if (first_stmt)\n+  if (first_stmt && !slp_node)\n     {\n       group_size = vect_cost_strided_group_size (stmt_info);\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n@@ -641,14 +686,14 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n            access in the group. Inside the loop, there is a load op\n            and a realignment op.  */\n \n-        if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1)\n+        if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node)\n           {\n             outer_cost = 2*TARG_VEC_STMT_COST;\n             if (targetm.vectorize.builtin_mask_for_load)\n               outer_cost += TARG_VEC_STMT_COST;\n           }\n         \n-        STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = outer_cost;\n+        *outside_cost_field = outer_cost;\n \n         inner_cost += ncopies * (TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n \n@@ -659,12 +704,11 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n       gcc_unreachable ();\n     }\n \n-  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = inner_cost;\n+  *inside_cost_field = inner_cost;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n-             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n \n }\n \n@@ -1256,6 +1300,177 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type,\n }\n \n \n+/* For constant and loop invariant defs of SLP_NODE this function returns \n+   (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.  \n+   OP_NUM determines if we gather defs for operand 0 or operand 1 of the scalar\n+   stmts.  */\n+\n+static void\n+vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n+\t\t\t   unsigned int op_num)\n+{\n+  VEC (tree, heap) *stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  tree stmt = VEC_index (tree, stmts, 0);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  tree vec_cst;\n+  tree t = NULL_TREE;\n+  int j, number_of_places_left_in_vector;\n+  tree vector_type;\n+  tree op, vop, operation;\n+  int group_size = VEC_length (tree, stmts);\n+  unsigned int vec_num, i;\n+  int number_of_copies = 1;\n+  bool is_store = false;\n+  unsigned int number_of_vectors = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+  VEC (tree, heap) *voprnds = VEC_alloc (tree, heap, number_of_vectors);\n+\n+  if (STMT_VINFO_DATA_REF (stmt_vinfo))\n+    is_store = true;\n+\n+  /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n+     created vectors. It is greater than 1 if unrolling is performed. \n+\n+     For example, we have two scalar operands, s1 and s2 (e.g., group of\n+     strided accesses of size two), while NUINTS is four (i.e., four scalars\n+     of this type can be packed in a vector). The output vector will contain\n+     two copies of each scalar operand: {s1, s2, s1, s2}. (NUMBER_OF_COPIES\n+     will be 2).\n+\n+     If GROUP_SIZE > NUNITS, the scalars will be split into several vectors \n+     containing the operands.\n+\n+     For example, NUINTS is four as before, and the group size is 8 \n+     (s1, s2, ..., s8). We will create two vectors {s1, s2, s3, s4} and\n+     {s5, s6, s7, s8}.  */\n+    \n+  number_of_copies = least_common_multiple (nunits, group_size) / group_size;\n+\n+  number_of_places_left_in_vector = nunits;\n+  for (j = 0; j < number_of_copies; j++)\n+    {\n+      for (i = group_size - 1; VEC_iterate (tree, stmts, i, stmt); i--)\n+        {\n+          operation = GIMPLE_STMT_OPERAND (stmt, 1);\n+\t  if (is_store)\n+\t    op = operation;\n+\t  else\n+\t    op = TREE_OPERAND (operation, op_num);\n+\n+          /* Create 'vect_ = {op0,op1,...,opn}'.  */\n+          t = tree_cons (NULL_TREE, op, t);\n+\n+          number_of_places_left_in_vector--;\n+\n+          if (number_of_places_left_in_vector == 0)\n+            {\n+              number_of_places_left_in_vector = nunits;\n+\n+\t      vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+              vec_cst = build_constructor_from_list (vector_type, t);\n+              VEC_quick_push (tree, voprnds,\n+                              vect_init_vector (stmt, vec_cst, vector_type,\n+\t\t\t\t\t\tNULL));\n+              t = NULL_TREE;\n+            }\n+        }\n+    }\n+\n+  /* Since the vectors are created in the reverse order, we should invert \n+     them.  */\n+  vec_num = VEC_length (tree, voprnds);\n+  for (j = vec_num - 1; j >= 0; j--)\n+    {\n+      vop = VEC_index (tree, voprnds, j);\n+      VEC_quick_push (tree, *vec_oprnds, vop);\n+    }\n+\n+  VEC_free (tree, heap, voprnds);\n+\n+  /* In case that VF is greater than the unrolling factor needed for the SLP\n+     group of stmts, NUMBER_OF_VECTORS to be created is greater than \n+     NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have \n+     to replicate the vectors.  */\n+  while (number_of_vectors > VEC_length (tree, *vec_oprnds))\n+    {\n+      for (i = 0; VEC_iterate (tree, *vec_oprnds, i, vop) && i < vec_num; i++)\n+        VEC_quick_push (tree, *vec_oprnds, vop);\n+    }\n+}\n+\n+\n+/* Get vectorized defintions from SLP_NODE that contains corresponding\n+   vectorized def-stmts.  */\n+ \n+static void\n+vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n+{\n+  tree vec_oprnd;\n+  tree vec_def_stmt;\n+  unsigned int i;\n+\n+  gcc_assert (SLP_TREE_VEC_STMTS (slp_node));\n+\n+  for (i = 0; \n+       VEC_iterate (tree, SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt); \n+       i++)\n+    {\n+      gcc_assert (vec_def_stmt);\n+      vec_oprnd = GIMPLE_STMT_OPERAND (vec_def_stmt, 0);\n+      VEC_quick_push (tree, *vec_oprnds, vec_oprnd);\n+    }\n+}\n+\n+\n+/* Get vectorized definitions for SLP_NODE. \n+   If the scalar definitions are loop invariants or constants, collect them and \n+   call vect_get_constant_vectors() to create vector stmts.\n+   Otherwise, the def-stmts must be already vectorized and the vectorized stmts\n+   must be stored in the LEFT/RIGHT node of SLP_NODE, and we call\n+   vect_get_slp_vect_defs() to retrieve them.  */\n+ \n+static void\n+vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n+                   VEC (tree,heap) **vec_oprnds1)\n+{\n+  tree operation, first_stmt;\n+\n+  /* Allocate memory for vectorized defs.  */\n+  *vec_oprnds0 = VEC_alloc (tree, heap, \n+\t\t\t    SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node));\n+\n+  /* SLP_NODE corresponds either to a group of stores or to a group of \n+     unary/binary operations. We don't call this function for loads.  */\n+  if (SLP_TREE_LEFT (slp_node)) \n+    /* The defs are already vectorized.  */ \n+    vect_get_slp_vect_defs (SLP_TREE_LEFT (slp_node), vec_oprnds0);\n+  else\n+    /* Build vectors from scalar defs.  */\n+    vect_get_constant_vectors (slp_node, vec_oprnds0, 0);\n+\n+  first_stmt = VEC_index (tree, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n+  if (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt)))\n+    /* Since we don't call this function with loads, this is a group of \n+       stores.  */\n+    return;\n+\n+  operation = GIMPLE_STMT_OPERAND (first_stmt, 1);\n+  if (TREE_OPERAND_LENGTH (operation) == unary_op)\n+    return;\n+\n+  *vec_oprnds1 = VEC_alloc (tree, heap, \n+\t\t\t    SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node));\n+\n+  if (SLP_TREE_RIGHT (slp_node))\n+    /* The defs are already vectorized.  */ \n+    vect_get_slp_vect_defs (SLP_TREE_RIGHT (slp_node), vec_oprnds1);\n+  else\n+    /* Build vectors from scalar defs.  */\n+    vect_get_constant_vectors (slp_node, vec_oprnds1, 1);\n+}\n+\n+\n /* Function get_initial_def_for_induction\n \n    Input:\n@@ -1744,6 +1959,54 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n }\n \n \n+/* Get vectorized definitions for the operands to create a copy of an original\n+   stmt. See vect_get_vec_def_for_stmt_copy() for details.  */\n+\n+static void\n+vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt, \n+\t\t\t\t VEC(tree,heap) **vec_oprnds0, \n+\t\t\t\t VEC(tree,heap) **vec_oprnds1)\n+{\n+  tree vec_oprnd = VEC_pop (tree, *vec_oprnds0);\n+\n+  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd);\n+  VEC_quick_push (tree, *vec_oprnds0, vec_oprnd);\n+\n+  if (vec_oprnds1)\n+    {\n+      vec_oprnd = VEC_pop (tree, *vec_oprnds1);\n+      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd);\n+      VEC_quick_push (tree, *vec_oprnds1, vec_oprnd);\n+    }\n+}\n+\n+\n+/* Get vectorized definitions for OP0 and OP1, or SLP_NODE if it is not NULL.  */\n+\n+static void\n+vect_get_vec_defs (tree op0, tree op1, tree stmt, VEC(tree,heap) **vec_oprnds0, \n+\t\t   VEC(tree,heap) **vec_oprnds1, slp_tree slp_node)\n+{\n+  if (slp_node)\n+    vect_get_slp_defs (slp_node, vec_oprnds0, vec_oprnds1);\n+  else\n+    {\n+      tree vec_oprnd;\n+\n+      *vec_oprnds0 = VEC_alloc (tree, heap, 1);\t\n+      vec_oprnd = vect_get_vec_def_for_operand (op0, stmt, NULL);      \n+      VEC_quick_push (tree, *vec_oprnds0, vec_oprnd);\n+\n+      if (op1)\n+\t{\n+\t  *vec_oprnds1 = VEC_alloc (tree, heap, 1);\t\n+\t  vec_oprnd = vect_get_vec_def_for_operand (op1, stmt, NULL);      \n+\t  VEC_quick_push (tree, *vec_oprnds1, vec_oprnd);\n+\t}\n+    }\n+}\n+\n+\n /* Function vect_finish_stmt_generation.\n \n    Insert a new stmt.  */\n@@ -2399,6 +2662,10 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   gcc_assert (ncopies >= 1);\n \n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   /* 1. Is vectorizable reduction?  */\n \n   /* Not supportable if the reduction variable is used in the loop.  */\n@@ -2707,6 +2974,10 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n     return false;\n \n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n@@ -2815,7 +3086,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_call ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -3005,16 +3276,14 @@ vect_gen_widened_results_half (enum tree_code code, tree vectype, tree decl,\n }\n \n \n-/* Function vectorizable_conversion.\n-\n-Check if STMT performs a conversion operation, that can be vectorized. \n-If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n-stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+/* Check if STMT performs a conversion operation, that can be vectorized. \n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n bool\n-vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n-\t\t\t\t   tree * vec_stmt)\n+vectorizable_conversion (tree stmt, block_stmt_iterator *bsi,\n+\t\t\t tree *vec_stmt, slp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n@@ -3028,8 +3297,8 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   tree new_temp;\n   tree def, def_stmt;\n-  enum vect_def_type dt0;\n-  tree new_stmt;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  tree new_stmt = NULL_TREE;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n   int nunits_out;\n@@ -3039,6 +3308,9 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   tree rhs_type, lhs_type;\n   tree builtin_decl;\n   enum { NARROW, NONE, WIDEN } modifier;\n+  int i;\n+  VEC(tree,heap) *vec_oprnds0 = NULL;\n+  tree vop0;\n \n   /* Is STMT a vectorizable conversion?   */\n \n@@ -3067,7 +3339,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   if (code != FIX_TRUNC_EXPR && code != FLOAT_EXPR)\n     return false;\n \n-  /* Check types of lhs and rhs */\n+  /* Check types of lhs and rhs.  */\n   op0 = TREE_OPERAND (operation, 0);\n   rhs_type = TREE_TYPE (op0);\n   vectype_in = get_vectype_for_scalar_type (rhs_type);\n@@ -3091,7 +3363,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   if (modifier == NONE)\n     gcc_assert (STMT_VINFO_VECTYPE (stmt_info) == vectype_out);\n \n-  /* Bail out if the types are both integral or non-integral */\n+  /* Bail out if the types are both integral or non-integral.  */\n   if ((INTEGRAL_TYPE_P (rhs_type) && INTEGRAL_TYPE_P (lhs_type))\n       || (!INTEGRAL_TYPE_P (rhs_type) && !INTEGRAL_TYPE_P (lhs_type)))\n     return false;\n@@ -3101,6 +3373,11 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n \n+  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n+     this, so we can safely override NCOPIES with 1 here.  */\n+  if (slp_node)\n+    ncopies = 1;\n+  \n   /* Sanity check: make sure that at least one copy of the vectorized stmt\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n@@ -3114,7 +3391,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n     }\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"use not simple.\");\n@@ -3138,7 +3415,12 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n     }\n \n   if (modifier != NONE)\n-    STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n+    {\n+      STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n+      /* FORNOW: SLP not supported.  */\n+      if (STMT_SLP_TYPE (stmt_info))\n+\treturn false;      \n+    }\n \n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n@@ -3153,6 +3435,9 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n+  if (modifier == NONE && !slp_node)\n+    vec_oprnds0 = VEC_alloc (tree, heap, 1);\n+\n   prev_stmt_info = NULL;\n   switch (modifier)\n     {\n@@ -3163,24 +3448,30 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n \t  ssa_op_iter iter;\n \n \t  if (j == 0)\n-\t    vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n+\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node);\n \t  else\n-\t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n \n \t  builtin_decl =\n \t    targetm.vectorize.builtin_conversion (code, vectype_in);\n-\t  new_stmt = build_call_expr (builtin_decl, 1, vec_oprnd0);\n+\t  for (i = 0; VEC_iterate (tree, vec_oprnds0, i, vop0); i++)\n+\t    { \n+\t      new_stmt = build_call_expr (builtin_decl, 1, vop0);\n \n-\t  /* Arguments are ready. create the new vector stmt.  */\n-\t  new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n-\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n-\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-\t  FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, SSA_OP_ALL_VIRTUALS)\n-\t    {\n-\t      if (TREE_CODE (sym) == SSA_NAME)\n-\t\tsym = SSA_NAME_VAR (sym);\n-\t      mark_sym_for_renaming (sym);\n+\t      /* Arguments are ready. create the new vector stmt.  */\n+\t      new_stmt = build_gimple_modify_stmt (vec_dest, new_stmt);\n+\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t      FOR_EACH_SSA_TREE_OPERAND (sym, new_stmt, iter, \n+\t\t\t\t\t SSA_OP_ALL_VIRTUALS)\n+\t\t{\n+\t\t  if (TREE_CODE (sym) == SSA_NAME)\n+\t\t    sym = SSA_NAME_VAR (sym);\n+\t\t  mark_sym_for_renaming (sym);\n+\t\t}\n+\t      if (slp_node)\n+\t\tVEC_quick_push (tree, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n \t    }\n \n \t  if (j == 0)\n@@ -3201,7 +3492,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n \t  if (j == 0)\n \t    vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n \t  else\n-\t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \n \t  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n \n@@ -3237,12 +3528,12 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n \t  if (j == 0)\n \t    {\n \t      vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t    }\n \t  else\n \t    {\n-\t      vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd1);\n-\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t      vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n+\t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t    }\n \n \t  /* Arguments are ready. Create the new vector stmt.  */\n@@ -3262,6 +3553,7 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n \n       *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n     }\n+\n   return true;\n }\n \n@@ -3274,12 +3566,12 @@ vectorizable_conversion (tree stmt, block_stmt_iterator * bsi,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n bool\n-vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt, \n+\t\t\t slp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op;\n-  tree vec_oprnd;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -3288,6 +3580,9 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int i;\n+  VEC(tree,heap) *vec_oprnds = NULL;\n+  tree vop;\n \n   gcc_assert (ncopies >= 1);\n   if (ncopies > 1)\n@@ -3328,7 +3623,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_assignment ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -3340,15 +3635,22 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n   /* Handle use.  */\n-  op = GIMPLE_STMT_OPERAND (stmt, 1);\n-  vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n+  vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node);\n \n   /* Arguments are ready. create the new vector stmt.  */\n-  *vec_stmt = build_gimple_modify_stmt (vec_dest, vec_oprnd);\n-  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n-  GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n-  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+  for (i = 0; VEC_iterate (tree, vec_oprnds, i, vop); i++)\n+    {\n+      *vec_stmt = build_gimple_modify_stmt (vec_dest, vop);\n+      new_temp = make_ssa_name (vec_dest, *vec_stmt);\n+      GIMPLE_STMT_OPERAND (*vec_stmt, 0) = new_temp;\n+      vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+      STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt;\n+\n+      if (slp_node)\n+\tVEC_quick_push (tree, SLP_TREE_VEC_STMTS (slp_node), *vec_stmt);\n+   }\n   \n+  VEC_free (tree, heap, vec_oprnds);       \n   return true;\n }\n \n@@ -3403,6 +3705,10 @@ vectorizable_induction (tree phi, block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def);\n \n   if (STMT_VINFO_LIVE_P (stmt_info))\n@@ -3444,13 +3750,14 @@ vectorizable_induction (tree phi, block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n bool\n-vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt, \n+\t\t\tslp_tree slp_node)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree operation;\n   tree op0, op1 = NULL;\n-  tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n+  tree vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -3464,14 +3771,20 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   enum machine_mode optab_op2_mode;\n   tree def, def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n-  tree new_stmt;\n+  tree new_stmt = NULL_TREE;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n   int nunits_out;\n   tree vectype_out;\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n-  int j;\n-\n+  int j, i;\n+  VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n+  tree vop0, vop1;\n+\n+  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n+     this, so we can safely override NCOPIES with 1 here.  */\n+  if (slp_node)\n+    ncopies = 1;\n   gcc_assert (ncopies >= 1);\n   /* FORNOW. This restriction should be relaxed.  */\n   if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n@@ -3601,7 +3914,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_operation ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -3613,6 +3926,13 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n \n+  if (!slp_node)\n+    {\n+      vec_oprnds0 = VEC_alloc (tree, heap, 1);\n+      if (op_type == binary_op)\n+\tvec_oprnds1 = VEC_alloc (tree, heap, 1);\n+    }\n+\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n@@ -3672,45 +3992,53 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       /* Handle uses.  */\n       if (j == 0)\n \t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t  if (op_type == binary_op)\n+\t  if (op_type == binary_op\n+\t      && (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n+              && !slp_node)\n \t    {\n-\t      if (code == LSHIFT_EXPR || code == RSHIFT_EXPR)\n-\t        {\n-\t          /* Vector shl and shr insn patterns can be defined with\n-\t             scalar operand 2 (shift operand).  In this case, use\n-\t             constant or loop invariant op1 directly, without\n-\t             extending it to vector mode first.  */\n-\t          optab_op2_mode = insn_data[icode].operand[2].mode;\n-\t          if (!VECTOR_MODE_P (optab_op2_mode))\n-\t            {\n-\t              if (vect_print_dump_info (REPORT_DETAILS))\n-\t                fprintf (vect_dump, \"operand 1 using scalar mode.\");\n-\t              vec_oprnd1 = op1;\n-\t            }\n-\t        }\n-\t      if (!vec_oprnd1)\n-\t        vec_oprnd1 = vect_get_vec_def_for_operand (op1, stmt, NULL);\n+\t      /* Vector shl and shr insn patterns can be defined with scalar \n+\t\t operand 2 (shift operand). In this case, use constant or loop \n+\t\t invariant op1 directly, without extending it to vector mode \n+\t\t first.  */\n+\t      optab_op2_mode = insn_data[icode].operand[2].mode;\n+\t      if (!VECTOR_MODE_P (optab_op2_mode))\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    fprintf (vect_dump, \"operand 1 using scalar mode.\");\n+\t\t  vec_oprnd1 = op1;\n+\t\t  VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+\t\t}\n \t    }\n+\t \n+\t  if (op_type == binary_op && !vec_oprnd1)\n+\t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1, \n+\t\t\t       slp_node);\n+\t  else\n+\t    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, &vec_oprnds1, \n+\t\t\t       slp_node);\n \t}\n       else\n-\t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n-\t  if (op_type == binary_op)\n-\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n-\t}\n+\tvect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n \n-      /* Arguments are ready. create the new vector stmt.  */\n+      /* Arguments are ready. Create the new vector stmt.  */\n+      for (i = 0; VEC_iterate (tree, vec_oprnds0, i, vop0); i++)\n+        {\n+          if (op_type == binary_op)\n+            {\n+              vop1 = VEC_index (tree, vec_oprnds1, i);\n+              new_stmt = build_gimple_modify_stmt (vec_dest,\n+\t\t\t\t\t build2 (code, vectype, vop0, vop1));\n+            }\n+\t  else\n+\t    new_stmt = build_gimple_modify_stmt (vec_dest,\n+\t\t\t\t    build1 (code, vectype, vop0));\n \n-      if (op_type == binary_op)\n-        new_stmt = build_gimple_modify_stmt (vec_dest,\n-                    build2 (code, vectype, vec_oprnd0, vec_oprnd1));\n-      else\n-        new_stmt = build_gimple_modify_stmt (vec_dest,\n-                    build1 (code, vectype, vec_oprnd0));\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  GIMPLE_STMT_OPERAND (new_stmt, 0) = new_temp;\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+          if (slp_node)\n+            VEC_quick_push (tree, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n+        }\n \n       if (j == 0)\n \tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n@@ -3719,6 +4047,10 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n \n+  VEC_free (tree, heap, vec_oprnds0);\n+  if (vec_oprnds1)\n+    VEC_free (tree, heap, vec_oprnds1);\n+\n   return true;\n }\n \n@@ -3829,7 +4161,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_demotion ===\");\n-      vect_model_simple_cost (stmt_info, ncopies, dt);\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -4000,7 +4332,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_promotion ===\");\n-      vect_model_simple_cost (stmt_info, 2*ncopies, dt);\n+      vect_model_simple_cost (stmt_info, 2*ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -4095,6 +4427,7 @@ vect_strided_store_supported (tree vectype)\n \tfprintf (vect_dump, \"interleave op not supported by target.\");\n       return false;\n     }\n+\n   return true;\n }\n \n@@ -4242,7 +4575,8 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n bool\n-vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n+\t\t    slp_tree slp_node)\n {\n   tree scalar_dest;\n   tree data_ref;\n@@ -4268,6 +4602,15 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   unsigned int group_size, i;\n   VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n   bool inv_p;\n+  VEC(tree,heap) *vec_oprnds = NULL;\n+  bool slp = (slp_node != NULL);\n+  stmt_vec_info first_stmt_vinfo;\n+  unsigned int vec_num;\n+\n+   /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n+      this, so we can safely override NCOPIES with 1 here.  */\n+  if (slp)\n+    ncopies = 1;\n \n   gcc_assert (ncopies >= 1);\n \n@@ -4300,7 +4643,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   scalar_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n   if (TREE_CODE (scalar_dest) != ARRAY_REF\n       && TREE_CODE (scalar_dest) != INDIRECT_REF\n-      && !DR_GROUP_FIRST_DR (stmt_info))\n+      && !STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     return false;\n \n   op = GIMPLE_STMT_OPERAND (stmt, 1);\n@@ -4320,17 +4663,19 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       strided_store = true;\n-      if (!vect_strided_store_supported (vectype))\n+      if (!vect_strided_store_supported (vectype)\n+\t  && !PURE_SLP_STMT (stmt_info) && !slp)\n \treturn false;      \n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies, dt);\n+      if (!PURE_SLP_STMT (stmt_info))\n+\tvect_model_store_cost (stmt_info, ncopies, dt, NULL);\n       return true;\n     }\n \n@@ -4350,17 +4695,28 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n       if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt)) \n-\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt)))\n+\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+\t  && !slp)\n \t{\n \t  *vec_stmt = NULL_TREE;\n \t  return true;\n \t}\n+\n+      if (slp)\n+\tstrided_store = false;\n+\n+      /* VEC_NUM is the number of vect stmts to be created for this group.  */\n+      if (slp && SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node) < group_size)\n+\tvec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      else\n+\tvec_num = group_size;\n     }\n   else \n     {\n       first_stmt = stmt;\n       first_dr = dr;\n-      group_size = 1;\n+      group_size = vec_num = 1;\n+      first_stmt_vinfo = stmt_info;\n     }\n   \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -4420,26 +4776,39 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n       if (j == 0)\n \t{\n-\t  /* For interleaved stores we collect vectorized defs for all the \n-\t     stores in the group in DR_CHAIN and OPRNDS. DR_CHAIN is then used\n-\t     as an input to vect_permute_store_chain(), and OPRNDS as an input\n-\t     to vect_get_vec_def_for_stmt_copy() for the next copy.\n-\t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n-\t     OPRNDS are of size 1.  */\n-\t  next_stmt = first_stmt;\t  \n-\t  for (i = 0; i < group_size; i++)\n-\t    {\n-\t      /* Since gaps are not supported for interleaved stores, GROUP_SIZE\n-\t\t is the exact number of stmts in the chain. Therefore, NEXT_STMT\n-\t\t can't be NULL_TREE.  In case that there is no interleaving, \n-\t\t GROUP_SIZE is 1, and only one iteration of the loop will be \n-\t\t executed.  */\n-\t      gcc_assert (next_stmt);\n-\t      op = GIMPLE_STMT_OPERAND (next_stmt, 1);\n-\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt, NULL);\n-\t      VEC_quick_push(tree, dr_chain, vec_oprnd); \n-\t      VEC_quick_push(tree, oprnds, vec_oprnd); \n-\t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+          if (slp)\n+            {\n+\t      /* Get vectorized arguments for SLP_NODE.  */\n+              vect_get_slp_defs (slp_node, &vec_oprnds, NULL);\n+\n+              vec_oprnd = VEC_index (tree, vec_oprnds, 0);\n+            }\n+          else\n+            {\n+\t      /* For interleaved stores we collect vectorized defs for all the \n+\t\t stores in the group in DR_CHAIN and OPRNDS. DR_CHAIN is then \n+\t\t used as an input to vect_permute_store_chain(), and OPRNDS as \n+\t\t an input to vect_get_vec_def_for_stmt_copy() for the next copy.\n+\n+\t\t If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n+\t\t OPRNDS are of size 1.  */\n+\t      next_stmt = first_stmt;\t  \n+\t      for (i = 0; i < group_size; i++)\n+\t\t{\n+\t\t  /* Since gaps are not supported for interleaved stores, \n+\t\t     GROUP_SIZE is the exact number of stmts in the chain. \n+\t\t     Therefore, NEXT_STMT can't be NULL_TREE.  In case that \n+\t\t     there is no interleaving, GROUP_SIZE is 1, and only one \n+\t\t     iteration of the loop will be executed.  */\n+\t\t  gcc_assert (next_stmt);\n+\t\t  op = GIMPLE_STMT_OPERAND (next_stmt, 1);\n+\n+\t\t  vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt, \n+\t\t\t\t\t\t\t    NULL);\n+\t\t  VEC_quick_push(tree, dr_chain, vec_oprnd); \n+\t\t  VEC_quick_push(tree, oprnds, vec_oprnd); \n+\t\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t\t}\n \t    }\n \t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE, \n \t\t\t\t\t\t  &dummy, &ptr_incr, false,\n@@ -4448,6 +4817,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n       else \n \t{\n+\t  /* FORNOW SLP doesn't work for multiple types.  */\n+\t  gcc_assert (!slp);\n+\n \t  /* For interleaved stores we created vectorized defs for all the \n \t     defs stored in OPRNDS in the previous iteration (previous copy). \n \t     DR_CHAIN is then used as an input to vect_permute_store_chain(), \n@@ -4476,12 +4848,19 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n \n       next_stmt = first_stmt;\n-      for (i = 0; i < group_size; i++)\n+      for (i = 0; i < vec_num; i++)\n \t{\n-\t  /* For strided stores vectorized defs are interleaved in \n-\t     vect_permute_store_chain().  */\n-\t  if (strided_store)\n-\t    vec_oprnd = VEC_index(tree, result_chain, i);\n+\t  if (i > 0)\n+\t    /* Bump the vector pointer.  */\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt,\n+\t\t\t\t\t   NULL_TREE);\n+\n+\t  if (slp)\n+\t    vec_oprnd = VEC_index (tree, vec_oprnds, i);\n+\t  else if (strided_store)\n+\t    /* For strided stores vectorized defs are interleaved in \n+\t       vect_permute_store_chain().  */\n+\t    vec_oprnd = VEC_index (tree, result_chain, i);\n \n \t  data_ref = build_fold_indirect_ref (dataref_ptr);\n \t  /* Arguments are ready. Create the new vector stmt.  */\n@@ -4498,9 +4877,6 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n \t  if (!next_stmt)\n \t    break;\n-\t  /* Bump the vector pointer.  */\n-\t  dataref_ptr = \n-\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\n \t}\n     }\n \n@@ -5021,7 +5397,8 @@ vect_transform_strided_load (tree stmt, VEC(tree,heap) *dr_chain, int size,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n bool\n-vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt, \n+\t\t   slp_tree slp_node)\n {\n   tree scalar_dest;\n   tree vec_dest = NULL;\n@@ -5056,6 +5433,13 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   bool inv_p;\n   bool compute_in_loop = false;\n   struct loop *at_loop;\n+  int vec_num;\n+  bool slp = (slp_node != NULL);\n+\n+  /* FORNOW: SLP with multiple types is not supported. The SLP analysis verifies\n+      this, so we can safely override NCOPIES with 1 here.  */\n+  if (slp)\n+    ncopies = 1;\n \n   gcc_assert (ncopies >= 1);\n \n@@ -5092,7 +5476,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   op = GIMPLE_STMT_OPERAND (stmt, 1);\n   if (TREE_CODE (op) != ARRAY_REF \n       && TREE_CODE (op) != INDIRECT_REF\n-      && !DR_GROUP_FIRST_DR (stmt_info))\n+      && !STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     return false;\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -5111,21 +5495,22 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     }\n \n   /* Check if the load is a part of an interleaving chain.  */\n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       strided_load = true;\n       /* FORNOW */\n       gcc_assert (! nested_in_vect_loop);\n \n       /* Check if interleaving is supported.  */\n-      if (!vect_strided_load_supported (vectype))\n+      if (!vect_strided_load_supported (vectype)\n+\t  && !PURE_SLP_STMT (stmt_info) && !slp)\n \treturn false;\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      vect_model_load_cost (stmt_info, ncopies);\n+      vect_model_load_cost (stmt_info, ncopies, NULL);\n       return true;\n     }\n \n@@ -5146,12 +5531,21 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n       group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n       dr_chain = VEC_alloc (tree, heap, group_size);\n+\n+      /* VEC_NUM is the number of vect stmts to be created for this group.  */\n+      if (slp)\n+\t{\n+\t  strided_load = false;\n+\t  vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+\t}\n+      else\n+\tvec_num = group_size;\n     }\n   else\n     {\n       first_stmt = stmt;\n       first_dr = dr;\n-      group_size = 1;\n+      group_size = vec_num = 1;\n     }\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n@@ -5296,8 +5690,12 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n         dataref_ptr = \n \t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\n \n-      for (i = 0; i < group_size; i++)\n+      for (i = 0; i < vec_num; i++)\n \t{\n+\t  if (i > 0)\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt,\n+\t\t\t\t\t   NULL_TREE);\n+\n \t  /* 2. Create the vector-load in the loop.  */\n \t  switch (alignment_support_scheme)\n \t    {\n@@ -5373,7 +5771,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n \t      if (alignment_support_scheme == dr_explicit_realign_optimized)\n \t\t{\n-\t\t  if (i == group_size - 1 && j == ncopies - 1)\n+\t\t  if (i == vec_num - 1 && j == ncopies - 1)\n \t\t    add_phi_arg (phi, lsq, loop_latch_edge (containing_loop));\n \t\t  msq = lsq;\n \t\t}\n@@ -5414,13 +5812,20 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t\tgcc_unreachable (); /* FORNOW. */\n \t    }\n \n-\t  if (strided_load)\n-\t    VEC_quick_push (tree, dr_chain, new_temp);\n-\t  if (i < group_size - 1)\n-\t    dataref_ptr = \n-\t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);\t  \n+\t  /* Collect vector loads and later create their permutation in\n+\t     vect_transform_strided_load ().  */\n+          if (strided_load)\n+            VEC_quick_push (tree, dr_chain, new_temp);\n+\n+         /* Store vector loads in the corresponding SLP_NODE.  */\n+\t  if (slp)\n+\t    VEC_quick_push (tree, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n \t}\n \n+      /* FORNOW: SLP with multiple types is unsupported.  */\n+      if (slp)\n+\treturn true;\n+\n       if (strided_load)\n \t{\n \t  if (!vect_transform_strided_load (stmt, dr_chain, group_size, bsi))\n@@ -5586,6 +5991,10 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n     return false;\n \n+  /* FORNOW: SLP not supported.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n   /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n@@ -5676,12 +6085,14 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   return true;\n }\n \n+\n /* Function vect_transform_stmt.\n \n    Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n \n-bool\n-vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n+static bool\n+vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store, \n+\t\t     slp_tree slp_node)\n {\n   bool is_store = false;\n   tree vec_stmt = NULL_TREE;\n@@ -5692,44 +6103,47 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n     case type_demotion_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_type_demotion (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n \n     case type_promotion_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_type_promotion (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n \n     case type_conversion_vec_info_type:\n-      done = vectorizable_conversion (stmt, bsi, &vec_stmt);\n+      done = vectorizable_conversion (stmt, bsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n     case induc_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_induction (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n \n     case op_vec_info_type:\n-      done = vectorizable_operation (stmt, bsi, &vec_stmt);\n+      done = vectorizable_operation (stmt, bsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n     case assignment_vec_info_type:\n-      done = vectorizable_assignment (stmt, bsi, &vec_stmt);\n+      done = vectorizable_assignment (stmt, bsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n     case load_vec_info_type:\n-      done = vectorizable_load (stmt, bsi, &vec_stmt);\n+      done = vectorizable_load (stmt, bsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n \n     case store_vec_info_type:\n-      done = vectorizable_store (stmt, bsi, &vec_stmt);\n+      done = vectorizable_store (stmt, bsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n-      if (DR_GROUP_FIRST_DR (stmt_info))\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n \t{\n \t  /* In case of interleaving, the whole chain is vectorized when the\n \t     last store in the chain is reached. Store stmts before the last\n@@ -5744,15 +6158,18 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n       break;\n \n     case condition_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_condition (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n \n     case call_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_call (stmt, bsi, &vec_stmt);\n       break;\n \n     case reduc_vec_info_type:\n+      gcc_assert (!slp_node);\n       done = vectorizable_reduction (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n       break;\n@@ -6165,7 +6582,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n   int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  if (DR_GROUP_FIRST_DR (stmt_info))\n+  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n       /* For interleaved access element size must be multiplied by the size of\n \t the interleaved group.  */\n@@ -6593,6 +7010,115 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n }\n \n+/* Remove a group of stores (for SLP or interleaving), free their \n+   stmt_vec_info.  */\n+\n+static void\n+vect_remove_stores (tree first_stmt)\n+{\n+  stmt_ann_t ann;\n+  tree next = first_stmt;\n+  tree tmp;\n+  stmt_vec_info next_stmt_info;\n+  block_stmt_iterator next_si;\n+\n+  while (next)\n+    {\n+      /* Free the attached stmt_vec_info and remove the stmt.  */\n+      next_si = bsi_for_stmt (next);\n+      bsi_remove (&next_si, true);\n+      next_stmt_info = vinfo_for_stmt (next);\n+      ann = stmt_ann (next);\n+      tmp = DR_GROUP_NEXT_DR (next_stmt_info);\n+      free (next_stmt_info);\n+      set_stmt_info (ann, NULL);\n+      next = tmp;\n+    }\n+}\n+\n+\n+/* Vectorize SLP instance tree in postorder.  */\n+\n+static bool\n+vect_schedule_slp_instance (slp_tree node, unsigned int vec_stmts_size)\n+{\n+  tree stmt;\n+  bool strided_store, is_store;\n+  block_stmt_iterator si;\n+  stmt_vec_info stmt_info;\n+\n+  if (!node)\n+    return false;\n+\n+  vect_schedule_slp_instance (SLP_TREE_LEFT (node), vec_stmts_size);\n+  vect_schedule_slp_instance (SLP_TREE_RIGHT (node), vec_stmts_size);\n+  \n+  stmt = VEC_index(tree, SLP_TREE_SCALAR_STMTS (node), 0);\n+  stmt_info = vinfo_for_stmt (stmt);\n+  SLP_TREE_VEC_STMTS (node) = VEC_alloc (tree, heap, vec_stmts_size);\n+  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"------>vectorizing SLP node starting from: \");\n+      print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+    }\t\n+\n+  si = bsi_for_stmt (stmt);\n+  is_store = vect_transform_stmt (stmt, &si, &strided_store, node);\n+  if (is_store)\n+    {\n+      if (DR_GROUP_FIRST_DR (stmt_info))\n+\t/* If IS_STORE is TRUE, the vectorization of the\n+\t   interleaving chain was completed - free all the stores in\n+\t   the chain.  */\n+\tvect_remove_stores (DR_GROUP_FIRST_DR (stmt_info));\n+      else\n+\t/* FORNOW: SLP originates only from strided stores.  */\n+\tgcc_unreachable ();\n+\n+      return true;\n+    }\n+\n+  /* FORNOW: SLP originates only from strided stores.  */\n+  return false;\n+}\n+\n+\n+static bool\n+vect_schedule_slp (loop_vec_info loop_vinfo, unsigned int nunits)\n+{\n+  VEC (slp_instance, heap) *slp_instances = \n+    LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  slp_instance instance;\n+  unsigned int vec_stmts_size;\n+  unsigned int group_size, i;\n+  unsigned int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  bool is_store = false;\n+\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    {\n+      group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n+      /* For each SLP instance calculate number of vector stmts to be created \n+\t for the scalar stmts in each node of the SLP tree. Number of vector \n+\t elements in one vector iteration is the number of scalar elements in \n+\t one scalar iteration (GROUP_SIZE) multiplied by VF divided by vector \n+\t size.  */\t\t      \n+      vec_stmts_size = vectorization_factor * group_size / nunits;\n+\t\t\t  \n+      /* Schedule the tree of INSTANCE.  */\n+      is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance), \n+\t\t\t\t\t     vec_stmts_size);\n+\t\t     \n+      if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS)\n+\t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n+    }\n+\n+  return is_store;\n+}\n+\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -6610,6 +7136,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree ratio = NULL;\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   bool strided_store;\n+  bool slp_scheduled = false;\n+  unsigned int nunits;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n@@ -6744,6 +7272,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t  stmt_info = vinfo_for_stmt (phi);\n \t  if (!stmt_info)\n \t    continue;\n+\n \t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n \t      && !STMT_VINFO_LIVE_P (stmt_info))\n \t    continue;\n@@ -6757,7 +7286,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    {\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\tfprintf (vect_dump, \"transform phi.\");\n-\t      vect_transform_stmt (phi, NULL, NULL);\n+\t      vect_transform_stmt (phi, NULL, NULL, NULL);\n \t    }\n \t}\n \n@@ -6791,21 +7320,56 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \n \t  gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-\t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n-\t\t != (unsigned HOST_WIDE_INT) vectorization_factor)\n-\t      && vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"multiple-types.\");\n+\t  nunits =\n+\t    (unsigned int) TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+\t  if (!STMT_SLP_TYPE (stmt_info)\n+\t      && nunits != (unsigned int) vectorization_factor\n+              && vect_print_dump_info (REPORT_DETAILS))\n+\t    /* For SLP VF is set according to unrolling factor, and not to\n+\t       vector size, hence for SLP this print is not valid.  */\n+            fprintf (vect_dump, \"multiple-types.\");\n+\n+\t  /* SLP. Schedule all the SLP instances when the first SLP stmt is\n+\t     reached.  */\n+\t  if (STMT_SLP_TYPE (stmt_info))\n+\t    {\n+\t      if (!slp_scheduled)\n+\t\t{\n+\t\t  slp_scheduled = true;\n+\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    fprintf (vect_dump, \"=== scheduling SLP instances ===\");\n \n+\t\t  is_store = vect_schedule_slp (loop_vinfo, nunits);\n+\n+\t\t  /* IS_STORE is true if STMT is a store. Stores cannot be of\n+\t\t     hybrid SLP type. They are removed in\n+\t\t     vect_schedule_slp_instance and their vinfo is destroyed. */\n+\t\t  if (is_store)\n+\t\t    {\n+\t\t      bsi_next (&si);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n+\t      if (PURE_SLP_STMT (stmt_info))\n+\t\t{\n+\t\t  bsi_next (&si);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  \n \t  /* -------- vectorize statement ------------ */\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"transform statement.\");\n \n \t  strided_store = false;\n-\t  is_store = vect_transform_stmt (stmt, &si, &strided_store);\n+\t  is_store = vect_transform_stmt (stmt, &si, &strided_store, NULL);\n           if (is_store)\n             {\n \t      stmt_ann_t ann;\n-\t      if (DR_GROUP_FIRST_DR (stmt_info))\n+\t      if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n \t\t{\n \t\t  /* Interleaving. If IS_STORE is TRUE, the vectorization of the\n \t\t     interleaving chain was completed - free all the stores in"}, {"sha": "29acfac5289f467a69d22bbdcc1e59f13a5d3c36", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -1359,6 +1359,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n   STMT_VINFO_INSIDE_OF_LOOP_COST (res) = 0;\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n+  STMT_SLP_TYPE (res) = 0;\n   DR_GROUP_FIRST_DR (res) = NULL_TREE;\n   DR_GROUP_NEXT_DR (res) = NULL_TREE;\n   DR_GROUP_SIZE (res) = 0;\n@@ -1478,7 +1479,9 @@ new_loop_vec_info (struct loop *loop)\n     VEC_alloc (tree, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS));\n   LOOP_VINFO_MAY_ALIAS_DDRS (res) =\n     VEC_alloc (ddr_p, heap, PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS));\n-\n+  LOOP_VINFO_STRIDED_STORES (res) = VEC_alloc (tree, heap, 10);\n+  LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);\n+  LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n \n   return res;\n }\n@@ -1497,6 +1500,8 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   int nbbs;\n   block_stmt_iterator si;\n   int j;\n+  VEC (slp_instance, heap) *slp_instances;\n+  slp_instance instance;\n \n   if (!loop_vinfo)\n     return;\n@@ -1571,6 +1576,10 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   free_dependence_relations (LOOP_VINFO_DDRS (loop_vinfo));\n   VEC_free (tree, heap, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n   VEC_free (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n+  slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  for (j = 0; VEC_iterate (slp_instance, slp_instances, j, instance); j++)\n+    vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n+  VEC_free (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo));\n \n   free (loop_vinfo);\n   loop->aux = NULL;"}, {"sha": "0168c2397bbed253f38b9e528d0a8694b0c4c2fb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 129, "deletions": 6, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/805e2059392217cfabc6b719df5a7ee7d0323c7b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=805e2059392217cfabc6b719df5a7ee7d0323c7b", "patch": "@@ -60,7 +60,7 @@ enum dr_alignment_support {\n \n /* Define type of def-use cross-iteration cycle.  */\n enum vect_def_type {\n-  vect_constant_def,\n+  vect_constant_def = 1,\n   vect_invariant_def,\n   vect_loop_def,\n   vect_induction_def,\n@@ -77,11 +77,80 @@ enum verbosity_levels {\n   REPORT_DR_DETAILS,\n   REPORT_BAD_FORM_LOOPS,\n   REPORT_OUTER_LOOPS,\n+  REPORT_SLP,\n   REPORT_DETAILS,\n   /* New verbosity levels should be added before this one.  */\n   MAX_VERBOSITY_LEVEL\n };\n \n+/************************************************************************\n+  SLP\n+ ************************************************************************/\n+\n+/* A computation tree of an SLP instance. Each node corresponds to a group of\n+   stmts to be packed in a SIMD stmt.  */\n+typedef struct _slp_tree {\n+  /* Only binary and unary operations are supported. LEFT child corresponds to\n+     the first operand and RIGHT child to the second if the operation is\n+     binary.  */\n+  struct _slp_tree *left;\n+  struct _slp_tree *right;\n+  /* A group of scalar stmts to be vectorized together.  */\n+  VEC (tree, heap) *stmts;\n+  /* Vectorized stmt/s.  */\n+  VEC (tree, heap) *vec_stmts;\n+  /* Number of vector stmts that are created to replace the group of scalar \n+     stmts. It is calculated during the transformation phase as the number of \n+     scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF \n+     divided by vector size.  */\n+  unsigned int vec_stmts_size;\n+  /* Vectorization costs associated with SLP node.  */\n+  struct\n+  {\n+    int outside_of_loop;     /* Statements generated outside loop.  */\n+    int inside_of_loop;      /* Statements generated inside loop.  */\n+  } cost;\n+} *slp_tree;\n+\n+\n+/* SLP instance is a sequence of stmts in a loop that can be packed into\n+   SIMD stmts.  */\n+typedef struct _slp_instance {\n+  /* The root of SLP tree.  */\n+  slp_tree root;\n+\n+  /* Size of groups of scalar stmts that will be replaced by SIMD stmt/s.  */\n+  unsigned int group_size;\n+\n+  /* The unrolling factor required to vectorized this SLP instance.  */\n+  unsigned int unrolling_factor;\n+\n+  /* Vectorization costs associated with SLP instance.  */\n+  struct  \n+  {\n+    int outside_of_loop;     /* Statements generated outside loop.  */\n+    int inside_of_loop;      /* Statements generated inside loop.  */\n+  } cost;\n+} *slp_instance;\n+\n+DEF_VEC_P(slp_instance);\n+DEF_VEC_ALLOC_P(slp_instance, heap);\n+\n+/* Access Functions.  */\n+#define SLP_INSTANCE_TREE(S)                     (S)->root\n+#define SLP_INSTANCE_GROUP_SIZE(S)               (S)->group_size\n+#define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n+#define SLP_INSTANCE_OUTSIDE_OF_LOOP_COST(S)     (S)->cost.outside_of_loop\n+#define SLP_INSTANCE_INSIDE_OF_LOOP_COST(S)      (S)->cost.inside_of_loop\n+\n+#define SLP_TREE_LEFT(S)                         (S)->left\n+#define SLP_TREE_RIGHT(S)                        (S)->right\n+#define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n+#define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n+#define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n+#define SLP_TREE_OUTSIDE_OF_LOOP_COST(S)         (S)->cost.outside_of_loop\n+#define SLP_TREE_INSIDE_OF_LOOP_COST(S)          (S)->cost.inside_of_loop\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -141,6 +210,18 @@ typedef struct _loop_vec_info {\n \n   /* The loop location in the source.  */\n   LOC loop_line_number;\n+\n+  /* All interleaving chains of stores in the loop, represented by the first\n+     stmt in the chain.  */\n+  VEC(tree, heap) *strided_stores;\n+\n+  /* All SLP instances in the loop. This is a subset of the set of STRIDED_STORES\n+     of the loop.  */\n+  VEC(slp_instance, heap) *slp_instances;\n+\n+  /* The unrolling factor needed to SLP the loop. In case of that pure SLP is \n+     applied to the loop, i.e., no unrolling is needed, this is 1.  */\n+  unsigned slp_unrolling_factor;\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -159,6 +240,9 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_MAY_MISALIGN_STMTS(L) (L)->may_misalign_stmts\n #define LOOP_VINFO_LOC(L)             (L)->loop_line_number\n #define LOOP_VINFO_MAY_ALIAS_DDRS(L)  (L)->may_alias_ddrs\n+#define LOOP_VINFO_STRIDED_STORES(L)  (L)->strided_stores\n+#define LOOP_VINFO_SLP_INSTANCES(L)   (L)->slp_instances\n+#define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n \n #define NITERS_KNOWN_P(n)                     \\\n (host_integerp ((n),0)                        \\\n@@ -216,6 +300,29 @@ enum vect_relevant {\n   vect_used_in_loop  \n };\n \n+/* The type of vectorization that can be applied to the stmt: regular loop-based\n+   vectorization; pure SLP - the stmt is a part of SLP instances and does not\n+   have uses outside SLP instances; or hybrid SLP and loop-based - the stmt is\n+   a part of SLP instance and also must be loop-based vectorized, since it has\n+   uses outside SLP sequences. \n+\n+   In the loop context the meanings of pure and hybrid SLP are slightly \n+   different. By saying that pure SLP is applied to the loop, we mean that we \n+   exploit only intra-iteration parallelism in the loop; i.e., the loop can be \n+   vectorized without doing any conceptual unrolling, cause we don't pack \n+   together stmts from different iterations, only within a single iteration. \n+   Loop hybrid SLP means that we exploit both intra-iteration and \n+   inter-iteration parallelism (e.g., number of elements in the vector is 4\n+   and the slp-group-size is 2, in which case we don't have enough parallelism \n+   within an iteration, so we obtain the rest of the parallelism from subsequent \n+   iterations by unrolling the loop by 2).  */\n+enum slp_vect_type { \n+  loop_vect = 0,\n+  pure_slp,\n+  hybrid\n+};\n+\n+\n typedef struct data_reference *dr_p;\n DEF_VEC_P(dr_p);\n DEF_VEC_ALLOC_P(dr_p,heap);\n@@ -309,6 +416,9 @@ typedef struct _stmt_vec_info {\n     int outside_of_loop;     /* Statements generated outside loop.  */\n     int inside_of_loop;      /* Statements generated inside loop.  */\n   } cost;\n+\n+  /*  Whether the stmt is SLPed, loop-based vectorized, or both.  */\n+  enum slp_vect_type slp_type;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -338,6 +448,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_DR_GROUP_GAP(S)         (S)->gap\n #define STMT_VINFO_DR_GROUP_SAME_DR_STMT(S)(S)->same_dr_stmt\n #define STMT_VINFO_DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n+#define STMT_VINFO_STRIDED_ACCESS(S)      ((S)->first_dr != NULL)\n \n #define DR_GROUP_FIRST_DR(S)               (S)->first_dr\n #define DR_GROUP_NEXT_DR(S)                (S)->next_dr\n@@ -351,6 +462,10 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop\n #define STMT_VINFO_INSIDE_OF_LOOP_COST(S)  (S)->cost.inside_of_loop\n \n+#define HYBRID_SLP_STMT(S)                ((S)->slp_type == hybrid)\n+#define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n+#define STMT_SLP_TYPE(S)                   (S)->slp_type\n+\n /* These are some defines for the initial implementation of the vectorizer's\n    cost model.  These will later be target specific hooks.  */\n \n@@ -524,6 +639,7 @@ extern stmt_vec_info new_stmt_vec_info (tree stmt, loop_vec_info);\n /** In tree-vect-analyze.c  **/\n /* Driver for analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *);\n+extern void vect_free_slp_tree (slp_tree);\n \n \n /** In tree-vect-patterns.c  **/\n@@ -536,21 +652,28 @@ void vect_pattern_recog (loop_vec_info);\n \n \n /** In tree-vect-transform.c  **/\n-extern bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n-extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n-extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_load (tree, block_stmt_iterator *, tree *, slp_tree);\n+extern bool vectorizable_store (tree, block_stmt_iterator *, tree *, slp_tree);\n+extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *, \n+\t\t\t\t    slp_tree);\n extern bool vectorizable_type_promotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_type_demotion (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_conversion (tree, block_stmt_iterator *, \n-\t\t\t\t     tree *);\n-extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n+\t\t\t\t     tree *, slp_tree);\n+extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *, \n+\t\t\t\t     slp_tree);\n extern tree vectorizable_function (tree, tree, tree);\n extern bool vectorizable_call (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_induction (tree, block_stmt_iterator *, tree *);\n extern int  vect_estimate_min_profitable_iters (loop_vec_info);\n+extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *, \n+\t\t\t\t    slp_tree);\n+extern void vect_model_store_cost (stmt_vec_info, int, enum vect_def_type, \n+\t\t\t\t   slp_tree);\n+extern void vect_model_load_cost (stmt_vec_info, int, slp_tree);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info);\n "}]}