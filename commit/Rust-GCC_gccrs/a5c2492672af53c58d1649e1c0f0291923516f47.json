{"sha": "a5c2492672af53c58d1649e1c0f0291923516f47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjMjQ5MjY3MmFmNTNjNThkMTY0OWUxYzBmMDI5MTkyMzUxNmY0Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-06-16T06:18:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-16T06:18:41Z"}, "message": "alpha-protos.h, [...]: Update to ISO C.\n\n        * config/alpha/alpha-protos.h, config/alpha/elf.h,\n        config/alpha/osf.h, config/alpha/unicosmk.h, config/alpha/vms.h,\n        config/alpha/vms-cc.c, config/alpha/vms-ld.c: Update to ISO C.\n        * config/alpha/alpha.c: Likewise.  Move targetm init to end of file.\n        Remove unneeded static function decls.\n\nFrom-SVN: r68000", "tree": {"sha": "816109e57bd1f1d5e77b2838c0dbe24422b58240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/816109e57bd1f1d5e77b2838c0dbe24422b58240"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5c2492672af53c58d1649e1c0f0291923516f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c2492672af53c58d1649e1c0f0291923516f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c2492672af53c58d1649e1c0f0291923516f47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c2492672af53c58d1649e1c0f0291923516f47/comments", "author": null, "committer": null, "parents": [{"sha": "7b086b11df0c065c531a6cf2aa505504fe9ec8e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b086b11df0c065c531a6cf2aa505504fe9ec8e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b086b11df0c065c531a6cf2aa505504fe9ec8e2"}], "stats": {"total": 1878, "additions": 711, "deletions": 1167}, "files": [{"sha": "d9c45b108320da58f5e8ddab958be512e5010045", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -1,3 +1,11 @@\n+2003-06-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha-protos.h, config/alpha/elf.h,\n+\tconfig/alpha/osf.h, config/alpha/unicosmk.h, config/alpha/vms.h,\n+\tconfig/alpha/vms-cc.c, config/alpha/vms-ld.c: Update to ISO C.\n+\t* config/alpha/alpha.c: Likewise.  Move targetm init to end of file.\n+\tRemove unneeded static function decls.\n+\n 2003-06-16  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* c-opts.c (c_common_handle_option): s/on/value/."}, {"sha": "9e96d18939bebcd4e7b403eb0571607721673812", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 140, "deletions": 149, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -20,165 +20,156 @@ Boston, MA 02111-1307, USA.  */\n \n extern int alpha_next_sequence_number;\n \n-extern void literal_section PARAMS ((void));\n-extern void override_options PARAMS ((void));\n-extern int zap_mask PARAMS ((HOST_WIDE_INT));\n-extern int direct_return PARAMS ((void));\n-\n-extern int alpha_sa_size PARAMS ((void));\n-extern HOST_WIDE_INT alpha_initial_elimination_offset PARAMS ((unsigned int,\n-\t\t\t\t\t\t\t       unsigned int));\n-extern int alpha_pv_save_size PARAMS ((void));\n-extern int alpha_using_fp PARAMS ((void));\n-extern void alpha_write_verstamp PARAMS ((FILE *));\n-extern void alpha_expand_prologue PARAMS ((void));\n-extern void alpha_expand_epilogue PARAMS ((void));\n-extern void alpha_output_filename PARAMS ((FILE *, const char *));\n-extern void alpha_output_lineno PARAMS ((FILE *, int));\n-\n-extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_6bit_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_8bit_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_const_int_operand PARAMS ((rtx, enum machine_mode));\n-extern int cint8_operand PARAMS ((rtx, enum machine_mode));\n-extern int add_operand PARAMS ((rtx, enum machine_mode));\n-extern int sext_add_operand PARAMS ((rtx, enum machine_mode));\n-extern int const48_operand PARAMS ((rtx, enum machine_mode));\n-extern int and_operand PARAMS ((rtx, enum machine_mode));\n-extern int or_operand PARAMS ((rtx, enum machine_mode));\n-extern int mode_width_operand PARAMS ((rtx, enum machine_mode));\n-extern int mode_mask_operand PARAMS ((rtx, enum machine_mode));\n-extern int mul8_operand PARAMS ((rtx, enum machine_mode));\n-extern int const0_operand PARAMS ((rtx, enum machine_mode));\n-extern int hard_fp_register_operand PARAMS ((rtx, enum machine_mode));\n-extern int hard_int_register_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int some_operand PARAMS ((rtx, enum machine_mode));\n-extern int some_ni_operand PARAMS ((rtx, enum machine_mode));\n-extern int input_operand PARAMS ((rtx, enum machine_mode));\n-extern int samegp_function_operand PARAMS ((rtx, enum machine_mode));\n-extern int direct_call_operand PARAMS ((rtx, enum machine_mode));\n-extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int some_small_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int global_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int dtp16_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int dtp32_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int gotdtp_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int tp16_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int tp32_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int gottp_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_operand PARAMS ((rtx, enum machine_mode));\n-extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int alpha_zero_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int alpha_swapped_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int signed_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int alpha_fp_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int divmod_operator PARAMS ((rtx, enum machine_mode));\n-extern int aligned_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int unaligned_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_unaligned_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int any_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_not_elim_operand PARAMS ((rtx, enum machine_mode));\n-extern int normal_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_no_subreg_operand PARAMS ((rtx, enum machine_mode));\n-extern int addition_operation PARAMS ((rtx, enum machine_mode));\n-\n-extern bool alpha_const_ok_for_letter_p PARAMS ((HOST_WIDE_INT, int));\n-extern bool alpha_const_double_ok_for_letter_p PARAMS ((rtx, int));\n-extern bool alpha_extra_constraint PARAMS ((rtx, int));\n-\n-extern rtx alpha_tablejump_addr_vec PARAMS ((rtx));\n-extern rtx alpha_tablejump_best_label PARAMS ((rtx));\n-\n-extern bool alpha_legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n-extern rtx alpha_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n-extern rtx alpha_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\t\t    int, int, int));\n-\n-extern rtx split_small_symbolic_operand PARAMS ((rtx));\n-\n-extern void get_aligned_mem PARAMS ((rtx, rtx *, rtx *));\n-extern rtx get_unaligned_address PARAMS ((rtx, int));\n-extern enum reg_class alpha_preferred_reload_class PARAMS ((rtx, \n-\t\t\t\t\t\t\t    enum reg_class));\n-extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t     enum machine_mode, \n-\t\t\t\t\t\t     rtx, int));\n-\n-extern void alpha_set_memflags PARAMS ((rtx, rtx));\n-extern rtx alpha_emit_set_const PARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\tHOST_WIDE_INT, int));\n-extern rtx alpha_emit_set_long_const PARAMS ((rtx, HOST_WIDE_INT,\n-\t\t\t\t\t     HOST_WIDE_INT));\n-extern bool alpha_expand_mov PARAMS ((enum machine_mode, rtx *));\n-extern bool alpha_expand_mov_nobwx PARAMS ((enum machine_mode, rtx *));\n-extern void alpha_emit_floatuns PARAMS ((rtx[]));\n-extern rtx alpha_emit_conditional_move PARAMS ((rtx, enum machine_mode));\n-extern void alpha_split_tfmode_pair PARAMS ((rtx[]));\n-extern void alpha_split_tfmode_frobsign PARAMS ((rtx[],\n-\t\t\t\t\t\t rtx (*)(rtx, rtx, rtx)));\n-extern void alpha_expand_unaligned_load PARAMS ((rtx, rtx, HOST_WIDE_INT,\n-\t\t\t\t\t\tHOST_WIDE_INT, int));\n-extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-extern int alpha_expand_block_move PARAMS ((rtx []));\n-extern int alpha_expand_block_clear PARAMS ((rtx []));\n-extern rtx alpha_expand_zap_mask PARAMS ((HOST_WIDE_INT));\n-extern void alpha_expand_builtin_vector_binop PARAMS ((rtx (*)(rtx, rtx, rtx),\n-\t\t\t\t\t\t       enum machine_mode,\n-\t\t\t\t\t\t       rtx, rtx, rtx));\n-extern rtx alpha_return_addr PARAMS ((int, rtx));\n-extern rtx alpha_gp_save_rtx PARAMS ((void));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void alpha_initialize_trampoline PARAMS ((rtx, rtx, rtx, int, int, int));\n-\n-extern tree alpha_build_va_list PARAMS ((void));\n-extern void alpha_setup_incoming_varargs\n-  PARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int *, int));\n-extern void alpha_va_start PARAMS ((tree, rtx));\n-extern rtx alpha_va_arg PARAMS ((tree, tree));\n-extern rtx function_arg PARAMS ((CUMULATIVE_ARGS, enum machine_mode,\n-\t\t\t\t tree, int));\n-extern void alpha_start_function PARAMS ((FILE *, const char *, tree));\n-extern void alpha_end_function PARAMS ((FILE *, const char *, tree));\n-\n-extern int alpha_find_lo_sum_using_gp PARAMS ((rtx));\n+extern void literal_section (void);\n+extern void override_options (void);\n+extern int zap_mask (HOST_WIDE_INT);\n+extern int direct_return (void);\n+\n+extern int alpha_sa_size (void);\n+extern HOST_WIDE_INT alpha_initial_elimination_offset (unsigned int,\n+\t\t\t\t\t\t       unsigned int);\n+extern int alpha_pv_save_size (void);\n+extern int alpha_using_fp (void);\n+extern void alpha_write_verstamp (FILE *);\n+extern void alpha_expand_prologue (void);\n+extern void alpha_expand_epilogue (void);\n+extern void alpha_output_filename (FILE *, const char *);\n+extern void alpha_output_lineno (FILE *, int);\n+\n+extern int reg_or_0_operand (rtx, enum machine_mode);\n+extern int reg_or_6bit_operand (rtx, enum machine_mode);\n+extern int reg_or_8bit_operand (rtx, enum machine_mode);\n+extern int reg_or_const_int_operand (rtx, enum machine_mode);\n+extern int cint8_operand (rtx, enum machine_mode);\n+extern int add_operand (rtx, enum machine_mode);\n+extern int sext_add_operand (rtx, enum machine_mode);\n+extern int const48_operand (rtx, enum machine_mode);\n+extern int and_operand (rtx, enum machine_mode);\n+extern int or_operand (rtx, enum machine_mode);\n+extern int mode_width_operand (rtx, enum machine_mode);\n+extern int mode_mask_operand (rtx, enum machine_mode);\n+extern int mul8_operand (rtx, enum machine_mode);\n+extern int const0_operand (rtx, enum machine_mode);\n+extern int hard_fp_register_operand (rtx, enum machine_mode);\n+extern int hard_int_register_operand (rtx, enum machine_mode);\n+extern int reg_or_cint_operand (rtx, enum machine_mode);\n+extern int some_operand (rtx, enum machine_mode);\n+extern int some_ni_operand (rtx, enum machine_mode);\n+extern int input_operand (rtx, enum machine_mode);\n+extern int samegp_function_operand (rtx, enum machine_mode);\n+extern int direct_call_operand (rtx, enum machine_mode);\n+extern int local_symbolic_operand (rtx, enum machine_mode);\n+extern int small_symbolic_operand (rtx, enum machine_mode);\n+extern int some_small_symbolic_operand (rtx, enum machine_mode);\n+extern int global_symbolic_operand (rtx, enum machine_mode);\n+extern int dtp16_symbolic_operand (rtx, enum machine_mode);\n+extern int dtp32_symbolic_operand (rtx, enum machine_mode);\n+extern int gotdtp_symbolic_operand (rtx, enum machine_mode);\n+extern int tp16_symbolic_operand (rtx, enum machine_mode);\n+extern int tp32_symbolic_operand (rtx, enum machine_mode);\n+extern int gottp_symbolic_operand (rtx, enum machine_mode);\n+extern int call_operand (rtx, enum machine_mode);\n+extern int symbolic_operand (rtx, enum machine_mode);\n+extern int alpha_comparison_operator (rtx, enum machine_mode);\n+extern int alpha_zero_comparison_operator (rtx, enum machine_mode);\n+extern int alpha_swapped_comparison_operator (rtx, enum machine_mode);\n+extern int signed_comparison_operator (rtx, enum machine_mode);\n+extern int alpha_fp_comparison_operator (rtx, enum machine_mode);\n+extern int divmod_operator (rtx, enum machine_mode);\n+extern int aligned_memory_operand (rtx, enum machine_mode);\n+extern int unaligned_memory_operand (rtx, enum machine_mode);\n+extern int reg_or_unaligned_mem_operand (rtx, enum machine_mode);\n+extern int any_memory_operand (rtx, enum machine_mode);\n+extern int reg_not_elim_operand (rtx, enum machine_mode);\n+extern int normal_memory_operand (rtx, enum machine_mode);\n+extern int reg_no_subreg_operand (rtx, enum machine_mode);\n+extern int addition_operation (rtx, enum machine_mode);\n+\n+extern bool alpha_const_ok_for_letter_p (HOST_WIDE_INT, int);\n+extern bool alpha_const_double_ok_for_letter_p (rtx, int);\n+extern bool alpha_extra_constraint (rtx, int);\n+\n+extern rtx alpha_tablejump_addr_vec (rtx);\n+extern rtx alpha_tablejump_best_label (rtx);\n+\n+extern bool alpha_legitimate_address_p (enum machine_mode, rtx, int);\n+extern rtx alpha_legitimize_address (rtx, rtx, enum machine_mode);\n+extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n+\t\t\t\t\t    int, int, int);\n+\n+extern rtx split_small_symbolic_operand (rtx);\n+\n+extern void get_aligned_mem (rtx, rtx *, rtx *);\n+extern rtx get_unaligned_address (rtx, int);\n+extern enum reg_class alpha_preferred_reload_class (rtx, enum reg_class);\n+extern enum reg_class secondary_reload_class (enum reg_class,\n+\t\t\t\t\t      enum machine_mode, rtx, int);\n+\n+extern void alpha_set_memflags (rtx, rtx);\n+extern rtx alpha_emit_set_const (rtx, enum machine_mode, HOST_WIDE_INT, int);\n+extern rtx alpha_emit_set_long_const (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+extern bool alpha_expand_mov (enum machine_mode, rtx *);\n+extern bool alpha_expand_mov_nobwx (enum machine_mode, rtx *);\n+extern void alpha_emit_floatuns (rtx[]);\n+extern rtx alpha_emit_conditional_move (rtx, enum machine_mode);\n+extern void alpha_split_tfmode_pair (rtx[]);\n+extern void alpha_split_tfmode_frobsign (rtx[], rtx (*)(rtx, rtx, rtx));\n+extern void alpha_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t HOST_WIDE_INT, int);\n+extern void alpha_expand_unaligned_store (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t  HOST_WIDE_INT);\n+extern int alpha_expand_block_move (rtx []);\n+extern int alpha_expand_block_clear (rtx []);\n+extern rtx alpha_expand_zap_mask (HOST_WIDE_INT);\n+extern void alpha_expand_builtin_vector_binop (rtx (*)(rtx, rtx, rtx),\n+\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t       rtx, rtx, rtx);\n+extern rtx alpha_return_addr (int, rtx);\n+extern rtx alpha_gp_save_rtx (void);\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern void alpha_initialize_trampoline (rtx, rtx, rtx, int, int, int);\n+\n+extern tree alpha_build_va_list (void);\n+extern void alpha_setup_incoming_varargs (CUMULATIVE_ARGS, enum machine_mode,\n+\t\t\t\t\t  tree, int *, int);\n+extern void alpha_va_start (tree, rtx);\n+extern rtx alpha_va_arg (tree, tree);\n+extern rtx function_arg (CUMULATIVE_ARGS, enum machine_mode, tree, int);\n+extern void alpha_start_function (FILE *, const char *, tree);\n+extern void alpha_end_function (FILE *, const char *, tree);\n+\n+extern int alpha_find_lo_sum_using_gp (rtx);\n \n #ifdef REAL_VALUE_TYPE\n-extern int check_float_value PARAMS ((enum machine_mode,\n-\t\t\t\t      REAL_VALUE_TYPE *, int));\n+extern int check_float_value (enum machine_mode, REAL_VALUE_TYPE *, int);\n #endif\n \n #ifdef RTX_CODE\n-extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n-extern rtx alpha_emit_setcc PARAMS ((enum rtx_code));\n-extern int alpha_split_conditional_move PARAMS ((enum rtx_code, rtx, rtx,\n-\t\t\t\t\t\t rtx, rtx));\n-extern void alpha_emit_xfloating_arith PARAMS ((enum rtx_code, rtx[]));\n-extern void alpha_emit_xfloating_cvt PARAMS ((enum rtx_code, rtx[]));\n+extern rtx alpha_emit_conditional_branch (enum rtx_code);\n+extern rtx alpha_emit_setcc (enum rtx_code);\n+extern int alpha_split_conditional_move (enum rtx_code, rtx, rtx, rtx, rtx);\n+extern void alpha_emit_xfloating_arith (enum rtx_code, rtx[]);\n+extern void alpha_emit_xfloating_cvt (enum rtx_code, rtx[]);\n #endif\n \n-extern rtx alpha_need_linkage PARAMS ((const char *, int));\n-extern rtx alpha_use_linkage PARAMS ((rtx, tree, int, int));\n+extern rtx alpha_need_linkage (const char *, int);\n+extern rtx alpha_use_linkage (rtx, tree, int, int);\n \n #if TARGET_ABI_OPEN_VMS\n-#ifdef HAVE_MACHINE_MODES\n-extern enum avms_arg_type alpha_arg_type PARAMS ((enum machine_mode));\n+extern enum avms_arg_type alpha_arg_type (enum machine_mode);\n+extern rtx alpha_arg_info_reg_val (CUMULATIVE_ARGS);\n #endif\n-extern rtx alpha_arg_info_reg_val PARAMS ((CUMULATIVE_ARGS));\n-#endif /* TARGET_ABI_OPEN_VMS */\n \n-extern rtx unicosmk_add_call_info_word PARAMS ((rtx));\n+extern rtx unicosmk_add_call_info_word (rtx);\n \n #if TARGET_ABI_UNICOSMK\n-extern void unicosmk_defer_case_vector PARAMS ((rtx, rtx));\n-extern void unicosmk_add_extern PARAMS ((const char *));\n-extern void unicosmk_output_align PARAMS ((FILE *, int));\n-extern char * unicosmk_text_section PARAMS ((void));\n-extern char * unicosmk_data_section PARAMS ((void));\n-extern void unicosmk_asm_file_start PARAMS ((FILE *));\n-extern void unicosmk_output_common PARAMS ((FILE *, const char *, int, int));\n-#endif /* TARGET_ABI_UNICOSMK */\n+extern void unicosmk_defer_case_vector (rtx, rtx);\n+extern void unicosmk_add_extern (const char *);\n+extern void unicosmk_output_align (FILE *, int);\n+extern char * unicosmk_text_section (void);\n+extern char * unicosmk_data_section (void);\n+extern void unicosmk_asm_file_start (FILE *);\n+extern void unicosmk_output_common (FILE *, const char *, int, int);\n+extern int unicosmk_initial_elimination_offset (int, int);\n+#endif"}, {"sha": "47bd3ca837d6a59a1eeec227c4997d01b4392f20", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 512, "deletions": 935, "changes": 1447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -172,108 +172,6 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n   },\n };\n \n-/* Declarations of static functions.  */\n-static bool alpha_function_ok_for_sibcall\n-  PARAMS ((tree, tree));\n-static int tls_symbolic_operand_1\n-  PARAMS ((rtx, enum machine_mode, int, int));\n-static enum tls_model tls_symbolic_operand_type\n-  PARAMS ((rtx));\n-static bool decl_has_samegp\n-  PARAMS ((tree));\n-static bool alpha_in_small_data_p\n-  PARAMS ((tree));\n-static rtx get_tls_get_addr\n-  PARAMS ((void));\n-static int some_small_symbolic_operand_1\n-  PARAMS ((rtx *, void *));\n-static int split_small_symbolic_operand_1\n-  PARAMS ((rtx *, void *));\n-static bool alpha_cannot_copy_insn_p\n-  PARAMS ((rtx));\n-static bool alpha_rtx_costs\n-  PARAMS ((rtx, int, int, int *));\n-static void alpha_set_memflags_1\n-  PARAMS ((rtx, int, int, int));\n-static rtx alpha_emit_set_const_1\n-  PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT, int));\n-static void alpha_expand_unaligned_load_words\n-  PARAMS ((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n-static void alpha_expand_unaligned_store_words\n-  PARAMS ((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n-static void alpha_init_builtins\n-  PARAMS ((void));\n-static rtx alpha_expand_builtin\n-  PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-static void alpha_sa_mask\n-  PARAMS ((unsigned long *imaskP, unsigned long *fmaskP));\n-static int find_lo_sum_using_gp\n-  PARAMS ((rtx *, void *));\n-static int alpha_does_function_need_gp\n-  PARAMS ((void));\n-static int alpha_ra_ever_killed\n-  PARAMS ((void));\n-static const char *get_trap_mode_suffix\n-  PARAMS ((void));\n-static const char *get_round_mode_suffix\n-  PARAMS ((void));\n-static const char *get_some_local_dynamic_name\n-  PARAMS ((void));\n-static int get_some_local_dynamic_name_1\n-  PARAMS ((rtx *, void *));\n-static rtx set_frame_related_p\n-  PARAMS ((void));\n-static const char *alpha_lookup_xfloating_lib_func\n-  PARAMS ((enum rtx_code));\n-static int alpha_compute_xfloating_mode_arg\n-  PARAMS ((enum rtx_code, enum alpha_fp_rounding_mode));\n-static void alpha_emit_xfloating_libcall\n-  PARAMS ((const char *, rtx, rtx[], int, rtx));\n-static rtx alpha_emit_xfloating_compare\n-  PARAMS ((enum rtx_code, rtx, rtx));\n-static void alpha_output_function_end_prologue\n-  PARAMS ((FILE *));\n-static int alpha_adjust_cost\n-  PARAMS ((rtx, rtx, rtx, int));\n-static int alpha_issue_rate\n-  PARAMS ((void));\n-static int alpha_use_dfa_pipeline_interface\n-  PARAMS ((void));\n-static int alpha_multipass_dfa_lookahead\n-  PARAMS ((void));\n-static void alpha_reorg\n-  PARAMS ((void));\n-\n-#ifdef OBJECT_FORMAT_ELF\n-static void alpha_elf_select_rtx_section\n-  PARAMS ((enum machine_mode, rtx, unsigned HOST_WIDE_INT));\n-#endif\n-\n-#if TARGET_ABI_OPEN_VMS\n-static bool alpha_linkage_symbol_p\n-  PARAMS ((const char *symname));\n-static int alpha_write_one_linkage\n-  PARAMS ((splay_tree_node, void *));\n-static void alpha_write_linkage\n-  PARAMS ((FILE *, const char *, tree));\n-#endif\n-\n-#if TARGET_ABI_OSF\n-static void alpha_output_mi_thunk_osf\n-  PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n-#endif\n-\n-static struct machine_function * alpha_init_machine_status\n-  PARAMS ((void));\n-\n-static void unicosmk_output_deferred_case_vectors PARAMS ((FILE *));\n-static void unicosmk_gen_dsib PARAMS ((unsigned long *imaskP));\n-static void unicosmk_output_ssib PARAMS ((FILE *, const char *));\n-static int unicosmk_need_dex PARAMS ((rtx));\n-#if TARGET_ABI_UNICOSMK\n-static void unicosmk_file_end PARAMS ((void));\n-#endif\n-\n /* Get the number of args of a function in one of two ways.  */\n #if TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK\n #define NUM_ARGS current_function_args_info.num_args\n@@ -283,108 +181,24 @@ static void unicosmk_file_end PARAMS ((void));\n \n #define REG_PV 27\n #define REG_RA 26\n-\f\n-/* Initialize the GCC target structure.  */\n-#if TARGET_ABI_OPEN_VMS\n-const struct attribute_spec vms_attribute_table[];\n-static unsigned int vms_section_type_flags PARAMS ((tree, const char *, int));\n-static void vms_asm_named_section PARAMS ((const char *, unsigned int));\n-static void vms_asm_out_constructor PARAMS ((rtx, int));\n-static void vms_asm_out_destructor PARAMS ((rtx, int));\n-# undef TARGET_ATTRIBUTE_TABLE\n-# define TARGET_ATTRIBUTE_TABLE vms_attribute_table\n-# undef TARGET_SECTION_TYPE_FLAGS\n-# define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags\n-#endif\n-\n-#undef TARGET_IN_SMALL_DATA_P\n-#define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p\n-\n-#if TARGET_ABI_UNICOSMK\n-static void unicosmk_asm_named_section PARAMS ((const char *, unsigned int));\n-static void unicosmk_insert_attributes PARAMS ((tree, tree *));\n-static unsigned int unicosmk_section_type_flags PARAMS ((tree, const char *, \n-\t\t\t\t\t\t\t int));\n-static void unicosmk_unique_section PARAMS ((tree, int));\n-# undef TARGET_INSERT_ATTRIBUTES\n-# define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes\n-# undef TARGET_SECTION_TYPE_FLAGS\n-# define TARGET_SECTION_TYPE_FLAGS unicosmk_section_type_flags\n-# undef TARGET_ASM_UNIQUE_SECTION\n-# define TARGET_ASM_UNIQUE_SECTION unicosmk_unique_section\n-# undef TARGET_ASM_GLOBALIZE_LABEL\n-# define TARGET_ASM_GLOBALIZE_LABEL hook_void_FILEptr_constcharptr\n-#endif\n-\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n-#undef TARGET_ASM_ALIGNED_DI_OP\n-#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n-\n-/* Default unaligned ops are provided for ELF systems.  To get unaligned\n-   data for non-ELF systems, we have to turn off auto alignment.  */\n-#ifndef OBJECT_FORMAT_ELF\n-#undef TARGET_ASM_UNALIGNED_HI_OP\n-#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.align 0\\n\\t.word\\t\"\n-#undef TARGET_ASM_UNALIGNED_SI_OP\n-#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.align 0\\n\\t.long\\t\"\n-#undef TARGET_ASM_UNALIGNED_DI_OP\n-#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.align 0\\n\\t.quad\\t\"\n-#endif\n-\n-#ifdef OBJECT_FORMAT_ELF\n-#undef\tTARGET_ASM_SELECT_RTX_SECTION\n-#define\tTARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section\n-#endif\n-\n-#undef TARGET_ASM_FUNCTION_END_PROLOGUE\n-#define TARGET_ASM_FUNCTION_END_PROLOGUE alpha_output_function_end_prologue\n-\n-#undef TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST alpha_adjust_cost\n-#undef TARGET_SCHED_ISSUE_RATE\n-#define TARGET_SCHED_ISSUE_RATE alpha_issue_rate\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n-  alpha_use_dfa_pipeline_interface\n-#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n-#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n-  alpha_multipass_dfa_lookahead\n-\n-#undef TARGET_HAVE_TLS\n-#define TARGET_HAVE_TLS HAVE_AS_TLS\n-\n-#undef  TARGET_INIT_BUILTINS\n-#define TARGET_INIT_BUILTINS alpha_init_builtins\n-#undef  TARGET_EXPAND_BUILTIN\n-#define TARGET_EXPAND_BUILTIN alpha_expand_builtin\n \n-#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n-#define TARGET_FUNCTION_OK_FOR_SIBCALL alpha_function_ok_for_sibcall\n-#undef TARGET_CANNOT_COPY_INSN_P\n-#define TARGET_CANNOT_COPY_INSN_P alpha_cannot_copy_insn_p\n+/* Declarations of static functions.  */\n+static struct machine_function *alpha_init_machine_status (void);\n+static rtx alpha_emit_xfloating_compare (enum rtx_code, rtx, rtx);\n \n-#if TARGET_ABI_OSF\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK alpha_output_mi_thunk_osf\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n+#if TARGET_ABI_OPEN_VMS\n+static void alpha_write_linkage (FILE *, const char *, tree);\n #endif\n \n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS alpha_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST hook_int_rtx_0\n-\n-#undef TARGET_MACHINE_DEPENDENT_REORG\n-#define TARGET_MACHINE_DEPENDENT_REORG alpha_reorg\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n+static void unicosmk_output_deferred_case_vectors (FILE *);\n+static void unicosmk_gen_dsib (unsigned long *);\n+static void unicosmk_output_ssib (FILE *, const char *);\n+static int unicosmk_need_dex (rtx);\n \f\n /* Parse target option strings.  */\n \n void\n-override_options ()\n+override_options (void)\n {\n   int i;\n   static const struct cpu_table {\n@@ -667,8 +481,7 @@ override_options ()\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n \n int\n-zap_mask (value)\n-     HOST_WIDE_INT value;\n+zap_mask (HOST_WIDE_INT value)\n {\n   int i;\n \n@@ -684,9 +497,7 @@ zap_mask (value)\n    register, it must be in the proper mode unless MODE is VOIDmode.  */\n \n int\n-reg_or_0_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n+reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   return op == CONST0_RTX (mode) || register_operand (op, mode);\n }\n@@ -695,9 +506,7 @@ reg_or_0_operand (op, mode)\n    any register.  */\n \n int\n-reg_or_6bit_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+reg_or_6bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 64)\n@@ -708,9 +517,7 @@ reg_or_6bit_operand (op, mode)\n /* Return 1 if OP is an 8-bit constant or any register.  */\n \n int\n-reg_or_8bit_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 0x100)\n@@ -720,19 +527,15 @@ reg_or_8bit_operand (op, mode)\n /* Return 1 if OP is a constant or any register.  */\n \n int\n-reg_or_const_int_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+reg_or_const_int_operand (rtx op, enum machine_mode mode)\n {\n   return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n }\n \n /* Return 1 if OP is an 8-bit constant.  */\n \n int\n-cint8_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cint8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (unsigned HOST_WIDE_INT) INTVAL (op) < 0x100));\n@@ -741,9 +544,7 @@ cint8_operand (op, mode)\n /* Return 1 if the operand is a valid second operand to an add insn.  */\n \n int\n-add_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+add_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     /* Constraints I, J, O and P are covered by K.  */\n@@ -757,9 +558,7 @@ add_operand (op, mode)\n    add insn.  */\n \n int\n-sext_add_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+sext_add_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n@@ -771,9 +570,7 @@ sext_add_operand (op, mode)\n /* Return 1 if OP is the constant 4 or 8.  */\n \n int\n-const48_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+const48_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) == 4 || INTVAL (op) == 8));\n@@ -782,9 +579,7 @@ const48_operand (op, mode)\n /* Return 1 if OP is a valid first operand to an AND insn.  */\n \n int\n-and_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+and_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n     return (zap_mask (CONST_DOUBLE_LOW (op))\n@@ -801,9 +596,7 @@ and_operand (op, mode)\n /* Return 1 if OP is a valid first operand to an IOR or XOR insn.  */\n \n int\n-or_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+or_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return ((unsigned HOST_WIDE_INT) INTVAL (op) < 0x100\n@@ -816,9 +609,7 @@ or_operand (op, mode)\n    mode smaller than DImode.  */\n \n int\n-mode_width_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mode_width_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) == 8 || INTVAL (op) == 16\n@@ -829,9 +620,7 @@ mode_width_operand (op, mode)\n    smaller than an integer.  */\n \n int\n-mode_mask_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mode_mask_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -858,9 +647,7 @@ mode_mask_operand (op, mode)\n /* Return 1 if OP is a multiple of 8 less than 64.  */\n \n int\n-mul8_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mul8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (op) < 64\n@@ -870,19 +657,15 @@ mul8_operand (op, mode)\n /* Return 1 if OP is the zero constant for MODE.  */\n \n int\n-const0_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+const0_operand (rtx op, enum machine_mode mode)\n {\n   return op == CONST0_RTX (mode);\n }\n \n /* Return 1 if OP is a hard floating-point register.  */\n \n int\n-hard_fp_register_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+hard_fp_register_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -895,9 +678,7 @@ hard_fp_register_operand (op, mode)\n /* Return 1 if OP is a hard general register.  */\n \n int\n-hard_int_register_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+hard_int_register_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -911,9 +692,7 @@ hard_int_register_operand (op, mode)\n \n \n int\n-reg_or_cint_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n+reg_or_cint_operand (rtx op, enum machine_mode mode)\n {\n      return (GET_CODE (op) == CONST_INT\n \t     || register_operand (op, mode));\n@@ -923,9 +702,7 @@ reg_or_cint_operand (op, mode)\n    if it is a MEM, it need not be valid.  */\n \n int\n-some_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+some_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -956,9 +733,7 @@ some_operand (op, mode)\n /* Likewise, but don't accept constants.  */\n \n int\n-some_ni_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+some_ni_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -972,9 +747,7 @@ some_ni_operand (op, mode)\n /* Return 1 if OP is a valid operand for the source of a move insn.  */\n \n int\n-input_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+input_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1039,9 +812,7 @@ input_operand (op, mode)\n    file, and in the same section as the current function.  */\n \n int\n-samegp_function_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+samegp_function_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != SYMBOL_REF)\n     return false;\n@@ -1070,9 +841,7 @@ samegp_function_operand (op, mode)\n /* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */\n \n int\n-direct_call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+direct_call_operand (rtx op, enum machine_mode mode)\n {\n   tree op_decl, cfun_sec, op_sec;\n \n@@ -1124,9 +893,7 @@ direct_call_operand (op, mode)\n    a (non-tls) variable known to be defined in this file.  */\n \n int\n-local_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+local_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1149,9 +916,7 @@ local_symbolic_operand (op, mode)\n    known to be defined in this file in the small data area.  */\n \n int\n-small_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! TARGET_SMALL_DATA)\n     return 0;\n@@ -1181,9 +946,7 @@ small_symbolic_operand (op, mode)\n    not known (or known not) to be defined in this file.  */\n \n int\n-global_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+global_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1202,9 +965,7 @@ global_symbolic_operand (op, mode)\n /* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != Pmode)\n     return 0;\n@@ -1233,9 +994,7 @@ call_operand (op, mode)\n    possibly with an offset.  */\n \n int\n-symbolic_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n+symbolic_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1252,10 +1011,7 @@ symbolic_operand (op, mode)\n /* Return true if OP is valid for a particular TLS relocation.  */\n \n static int\n-tls_symbolic_operand_1 (op, mode, size, unspec)\n-     rtx op;\n-     enum machine_mode mode;\n-     int size, unspec;\n+tls_symbolic_operand_1 (rtx op, enum machine_mode mode, int size, int unspec)\n {\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n@@ -1298,59 +1054,47 @@ tls_symbolic_operand_1 (op, mode, size, unspec)\n /* Return true if OP is valid for 16-bit DTP relative relocations.  */\n \n int\n-dtp16_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+dtp16_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_DTPREL);\n }\n \n /* Return true if OP is valid for 32-bit DTP relative relocations.  */\n \n int\n-dtp32_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+dtp32_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_DTPREL);\n }\n \n /* Return true if OP is valid for 64-bit DTP relative relocations.  */\n \n int\n-gotdtp_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+gotdtp_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_DTPREL);\n }\n \n /* Return true if OP is valid for 16-bit TP relative relocations.  */\n \n int\n-tp16_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+tp16_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 16, UNSPEC_TPREL);\n }\n \n /* Return true if OP is valid for 32-bit TP relative relocations.  */\n \n int\n-tp32_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+tp32_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 32, UNSPEC_TPREL);\n }\n \n /* Return true if OP is valid for 64-bit TP relative relocations.  */\n \n int\n-gottp_symbolic_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+gottp_symbolic_operand (rtx op, enum machine_mode mode)\n {\n   return tls_symbolic_operand_1 (op, mode, 64, UNSPEC_TPREL);\n }\n@@ -1359,9 +1103,7 @@ gottp_symbolic_operand (op, mode)\n    comparisons are valid in which insn.  */\n \n int\n-alpha_comparison_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+alpha_comparison_operator (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -1376,9 +1118,7 @@ alpha_comparison_operator (op, mode)\n    Here we know which comparisons are valid in which insn.  */\n \n int\n-alpha_zero_comparison_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+alpha_zero_comparison_operator (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -1392,9 +1132,7 @@ alpha_zero_comparison_operator (op, mode)\n /* Return 1 if OP is a valid Alpha swapped comparison operator.  */\n \n int\n-alpha_swapped_comparison_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+alpha_swapped_comparison_operator (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -1410,9 +1148,7 @@ alpha_swapped_comparison_operator (op, mode)\n /* Return 1 if OP is a signed comparison operation.  */\n \n int\n-signed_comparison_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+signed_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -1428,9 +1164,7 @@ signed_comparison_operator (op, mode)\n    Here we know which comparisons are valid in which insn.  */\n \n int\n-alpha_fp_comparison_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+alpha_fp_comparison_operator (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -1443,9 +1177,7 @@ alpha_fp_comparison_operator (op, mode)\n /* Return 1 if this is a divide or modulus operator.  */\n \n int\n-divmod_operator (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+divmod_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -1466,9 +1198,7 @@ divmod_operator (op, mode)\n    Take into account what reload will do.  */\n \n int\n-aligned_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+aligned_memory_operand (rtx op, enum machine_mode mode)\n {\n   rtx base;\n \n@@ -1510,9 +1240,7 @@ aligned_memory_operand (op, mode)\n /* Similar, but return 1 if OP is a MEM which is not alignable.  */\n \n int\n-unaligned_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+unaligned_memory_operand (rtx op, enum machine_mode mode)\n {\n   rtx base;\n \n@@ -1554,19 +1282,15 @@ unaligned_memory_operand (op, mode)\n /* Return 1 if OP is either a register or an unaligned memory location.  */\n \n int\n-reg_or_unaligned_mem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_unaligned_mem_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode) || unaligned_memory_operand (op, mode);\n }\n \n /* Return 1 if OP is any memory location.  During reload a pseudo matches.  */\n \n int\n-any_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+any_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == MEM\n \t  || (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n@@ -1589,9 +1313,7 @@ any_memory_operand (op, mode)\n    preventing combine from making the optimization.  */\n \n int\n-reg_not_elim_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n+reg_not_elim_operand (rtx op, enum machine_mode mode)\n {\n   rtx inner = op;\n   if (GET_CODE (op) == SUBREG)\n@@ -1607,9 +1329,7 @@ reg_not_elim_operand (op, mode)\n    will do.  */\n \n int\n-normal_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+normal_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (reload_in_progress)\n     {\n@@ -1636,9 +1356,7 @@ normal_memory_operand (op, mode)\n    int->fp conversion.  */\n \n int\n-reg_no_subreg_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+reg_no_subreg_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != REG)\n     return 0;\n@@ -1650,9 +1368,7 @@ reg_no_subreg_operand (op, mode)\n    elimination.  */\n \n int\n-addition_operation (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n+addition_operation (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -1668,9 +1384,7 @@ addition_operation (op, mode)\n    the range defined for C in [I-P].  */\n \n bool\n-alpha_const_ok_for_letter_p (value, c)\n-     HOST_WIDE_INT value;\n-     int c;\n+alpha_const_ok_for_letter_p (HOST_WIDE_INT value, int c)\n {\n   switch (c)\n     {\n@@ -1709,9 +1423,7 @@ alpha_const_ok_for_letter_p (value, c)\n    matches for C in [GH].  */\n \n bool\n-alpha_const_double_ok_for_letter_p (value, c)\n-     rtx value;\n-     int c;\n+alpha_const_double_ok_for_letter_p (rtx value, int c)\n {\n   switch (c)\n     {\n@@ -1735,9 +1447,7 @@ alpha_const_double_ok_for_letter_p (value, c)\n    matches for C.  */\n \n bool\n-alpha_extra_constraint (value, c)\n-     rtx value;\n-     int c;\n+alpha_extra_constraint (rtx value, int c)\n {\n   switch (c)\n     {\n@@ -1763,7 +1473,7 @@ alpha_extra_constraint (value, c)\n /* Return 1 if this function can directly return via $26.  */\n \n int\n-direct_return ()\n+direct_return (void)\n {\n   return (! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\n \t  && reload_completed\n@@ -1776,8 +1486,7 @@ direct_return ()\n /* Return the ADDR_VEC associated with a tablejump insn.  */\n \n rtx\n-alpha_tablejump_addr_vec (insn)\n-     rtx insn;\n+alpha_tablejump_addr_vec (rtx insn)\n {\n   rtx tmp;\n \n@@ -1796,8 +1505,7 @@ alpha_tablejump_addr_vec (insn)\n /* Return the label of the predicted edge, or CONST0_RTX if we don't know.  */\n \n rtx\n-alpha_tablejump_best_label (insn)\n-     rtx insn;\n+alpha_tablejump_best_label (rtx insn)\n {\n   rtx jump_table = alpha_tablejump_addr_vec (insn);\n   rtx best_label = NULL_RTX;\n@@ -1831,8 +1539,7 @@ alpha_tablejump_best_label (insn)\n /* Return the TLS model to use for SYMBOL.  */\n \n static enum tls_model\n-tls_symbolic_operand_type (symbol)\n-     rtx symbol;\n+tls_symbolic_operand_type (rtx symbol)\n {\n   enum tls_model model;\n \n@@ -1851,8 +1558,7 @@ tls_symbolic_operand_type (symbol)\n    function in the current unit of translation.  */\n \n static bool\n-decl_has_samegp (decl)\n-     tree decl;\n+decl_has_samegp (tree decl)\n {\n   /* Functions that are not local can be overridden, and thus may\n      not share the same gp.  */\n@@ -1875,8 +1581,7 @@ decl_has_samegp (decl)\n /* Return true if EXP should be placed in the small data section.  */\n \n static bool\n-alpha_in_small_data_p (exp)\n-     tree exp;\n+alpha_in_small_data_p (tree exp)\n {\n   /* We want to merge strings, so we never consider them small data.  */\n   if (TREE_CODE (exp) == STRING_CST)\n@@ -1904,8 +1609,7 @@ alpha_in_small_data_p (exp)\n \n #if TARGET_ABI_OPEN_VMS\n static bool\n-alpha_linkage_symbol_p (symname)\n-     const char *symname;\n+alpha_linkage_symbol_p (const char *symname)\n {\n   int symlen = strlen (symname);\n \n@@ -1934,10 +1638,7 @@ alpha_linkage_symbol_p (symname)\n    low-order three bits; this is an \"unaligned\" access.  */\n \n bool\n-alpha_legitimate_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+alpha_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   /* If this is an ldq_u type address, discard the outer AND.  */\n   if (mode == DImode\n@@ -2038,7 +1739,7 @@ alpha_legitimate_address_p (mode, x, strict)\n static GTY(()) rtx tls_get_addr_libfunc;\n \n static rtx\n-get_tls_get_addr ()\n+get_tls_get_addr (void)\n {\n   if (!tls_get_addr_libfunc)\n     tls_get_addr_libfunc = init_one_libfunc (\"__tls_get_addr\");\n@@ -2049,10 +1750,8 @@ get_tls_get_addr ()\n    to be legitimate.  If we find one, return the new, valid address.  */\n \n rtx\n-alpha_legitimize_address (x, scratch, mode)\n-     rtx x;\n-     rtx scratch;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+alpha_legitimize_address (rtx x, rtx scratch,\n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT addend;\n \n@@ -2241,9 +1940,7 @@ alpha_legitimize_address (x, scratch, mode)\n    into a sibcall.  */\n \n static bool\n-alpha_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+alpha_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   /* Can't do indirect tail calls, since we don't know if the target\n      uses the same GP.  */\n@@ -2260,18 +1957,8 @@ alpha_function_ok_for_sibcall (decl, exp)\n    to replace (mem (symbol_ref)) with (mem (lo_sum $29 symbol_ref))\n    so that sched2 has the proper dependency information.  */\n \n-int\n-some_small_symbolic_operand (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return for_each_rtx (&x, some_small_symbolic_operand_1, NULL);\n-}\n-\n static int\n-some_small_symbolic_operand_1 (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+some_small_symbolic_operand_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *px;\n \n@@ -2282,19 +1969,14 @@ some_small_symbolic_operand_1 (px, data)\n   return small_symbolic_operand (x, Pmode) != 0;\n }\n \n-rtx\n-split_small_symbolic_operand (x)\n-     rtx x;\n+int\n+some_small_symbolic_operand (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  x = copy_insn (x);\n-  for_each_rtx (&x, split_small_symbolic_operand_1, NULL);\n-  return x;\n+  return for_each_rtx (&x, some_small_symbolic_operand_1, NULL);\n }\n \n static int\n-split_small_symbolic_operand_1 (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+split_small_symbolic_operand_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *px;\n \n@@ -2312,6 +1994,14 @@ split_small_symbolic_operand_1 (px, data)\n   return 0;\n }\n \n+rtx\n+split_small_symbolic_operand (rtx x)\n+{\n+  x = copy_insn (x);\n+  for_each_rtx (&x, split_small_symbolic_operand_1, NULL);\n+  return x;\n+}\n+\n /* Indicate that INSN cannot be duplicated.  This is true for any insn\n    that we've marked with gpdisp relocs, since those have to stay in\n    1-1 correspondence with one another.\n@@ -2322,8 +2012,7 @@ split_small_symbolic_operand_1 (px, data)\n    from sched-ebb could move one of the pair of insns to a different block.  */\n \n static bool\n-alpha_cannot_copy_insn_p (insn)\n-     rtx insn;\n+alpha_cannot_copy_insn_p (rtx insn)\n {\n   rtx pat;\n \n@@ -2359,12 +2048,10 @@ alpha_cannot_copy_insn_p (insn)\n    operand.  If we find one, push the reload and return the new rtx.  */\n    \n rtx\n-alpha_legitimize_reload_address (x, mode, opnum, type, ind_levels)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int opnum;\n-     int type;\n-     int ind_levels ATTRIBUTE_UNUSED;\n+alpha_legitimize_reload_address (rtx x,\n+\t\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t int opnum, int type,\n+\t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n {\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n@@ -2418,10 +2105,7 @@ alpha_legitimize_reload_address (x, mode, opnum, type, ind_levels)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-alpha_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n@@ -2563,9 +2247,7 @@ alpha_rtx_costs (x, code, outer_code, total)\n    of range stack slots.  */\n \n void\n-get_aligned_mem (ref, paligned_mem, pbitnum)\n-     rtx ref;\n-     rtx *paligned_mem, *pbitnum;\n+get_aligned_mem (rtx ref, rtx *paligned_mem, rtx *pbitnum)\n {\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n@@ -2603,9 +2285,7 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n    Add EXTRA_OFFSET to the address we return.  */\n \n rtx\n-get_unaligned_address (ref, extra_offset)\n-     rtx ref;\n-     int extra_offset;\n+get_unaligned_address (rtx ref, int extra_offset)\n {\n   rtx base;\n   HOST_WIDE_INT offset = 0;\n@@ -2638,9 +2318,7 @@ get_unaligned_address (ref, extra_offset)\n    symbolic constants cannot be dropped to memory.  */\n \n enum reg_class\n-alpha_preferred_reload_class(x, class)\n-     rtx x;\n-     enum reg_class class;\n+alpha_preferred_reload_class(rtx x, enum reg_class class)\n {\n   /* Zero is present in any register class.  */\n   if (x == CONST0_RTX (GET_MODE (x)))\n@@ -2677,11 +2355,8 @@ alpha_preferred_reload_class(x, class)\n    from register elimination into a DImode fp register.  */\n \n enum reg_class\n-secondary_reload_class (class, mode, x, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx x;\n-     int in;\n+secondary_reload_class (enum reg_class class, enum machine_mode mode,\n+\t\t\trtx x, int in)\n {\n   if ((mode == QImode || mode == HImode) && ! TARGET_BWX)\n     {\n@@ -2719,9 +2394,7 @@ secondary_reload_class (class, mode, x, in)\n    found in part of X.  */\n \n static void\n-alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n-     rtx x;\n-     int in_struct_p, volatile_p, unchanging_p;\n+alpha_set_memflags_1 (rtx x, int in_struct_p, int volatile_p, int unchanging_p)\n {\n   int i;\n \n@@ -2771,9 +2444,7 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n    a MEM, don't do anything.  */\n \n void\n-alpha_set_memflags (insn, ref)\n-     rtx insn;\n-     rtx ref;\n+alpha_set_memflags (rtx insn, rtx ref)\n {\n   int in_struct_p, volatile_p, unchanging_p;\n \n@@ -2793,62 +2464,11 @@ alpha_set_memflags (insn, ref)\n   alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n }\n \f\n-/* Try to output insns to set TARGET equal to the constant C if it can be\n-   done in less than N insns.  Do all computations in MODE.  Returns the place\n-   where the output has been placed if it can be done and the insns have been\n-   emitted.  If it would take more than N insns, zero is returned and no\n-   insns and emitted.  */\n-\n-rtx\n-alpha_emit_set_const (target, mode, c, n)\n-     rtx target;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT c;\n-     int n;\n-{\n-  rtx result = 0;\n-  rtx orig_target = target;\n-  int i;\n-\n-  /* If we can't make any pseudos, TARGET is an SImode hard register, we\n-     can't load this constant in one insn, do this in DImode.  */\n-  if (no_new_pseudos && mode == SImode\n-      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER\n-      && (result = alpha_emit_set_const_1 (target, mode, c, 1)) == 0)\n-    {\n-      target = gen_lowpart (DImode, target);\n-      mode = DImode;\n-    }\n-\n-  /* Try 1 insn, then 2, then up to N.  */\n-  for (i = 1; i <= n; i++)\n-    {\n-      result = alpha_emit_set_const_1 (target, mode, c, i);\n-      if (result)\n-\t{\n-\t  rtx insn = get_last_insn ();\n-\t  rtx set = single_set (insn);\n-\t  if (! CONSTANT_P (SET_SRC (set)))\n-\t    set_unique_reg_note (get_last_insn (), REG_EQUAL, GEN_INT (c));\n-\t  break;\n-\t}\n-    }\n-\n-  /* Allow for the case where we changed the mode of TARGET.  */\n-  if (result == target)\n-    result = orig_target;\n-\n-  return result;\n-}\n-\n-/* Internal routine for the above to check for N or below insns.  */\n+/* Internal routine for alpha_emit_set_const to check for N or below insns.  */\n \n static rtx\n-alpha_emit_set_const_1 (target, mode, c, n)\n-     rtx target;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT c;\n-     int n;\n+alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n+\t\t\tHOST_WIDE_INT c, int n)\n {\n   HOST_WIDE_INT new;\n   int i, bits;\n@@ -3030,15 +2650,58 @@ alpha_emit_set_const_1 (target, mode, c, n)\n   return 0;\n }\n \n+/* Try to output insns to set TARGET equal to the constant C if it can be\n+   done in less than N insns.  Do all computations in MODE.  Returns the place\n+   where the output has been placed if it can be done and the insns have been\n+   emitted.  If it would take more than N insns, zero is returned and no\n+   insns and emitted.  */\n+\n+rtx\n+alpha_emit_set_const (rtx target, enum machine_mode mode,\n+\t\t      HOST_WIDE_INT c, int n)\n+{\n+  rtx result = 0;\n+  rtx orig_target = target;\n+  int i;\n+\n+  /* If we can't make any pseudos, TARGET is an SImode hard register, we\n+     can't load this constant in one insn, do this in DImode.  */\n+  if (no_new_pseudos && mode == SImode\n+      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER\n+      && (result = alpha_emit_set_const_1 (target, mode, c, 1)) == 0)\n+    {\n+      target = gen_lowpart (DImode, target);\n+      mode = DImode;\n+    }\n+\n+  /* Try 1 insn, then 2, then up to N.  */\n+  for (i = 1; i <= n; i++)\n+    {\n+      result = alpha_emit_set_const_1 (target, mode, c, i);\n+      if (result)\n+\t{\n+\t  rtx insn = get_last_insn ();\n+\t  rtx set = single_set (insn);\n+\t  if (! CONSTANT_P (SET_SRC (set)))\n+\t    set_unique_reg_note (get_last_insn (), REG_EQUAL, GEN_INT (c));\n+\t  break;\n+\t}\n+    }\n+\n+  /* Allow for the case where we changed the mode of TARGET.  */\n+  if (result == target)\n+    result = orig_target;\n+\n+  return result;\n+}\n+\n /* Having failed to find a 3 insn sequence in alpha_emit_set_const,\n    fall back to a straight forward decomposition.  We do this to avoid\n    exponential run times encountered when looking for longer sequences\n    with alpha_emit_set_const.  */\n \n rtx\n-alpha_emit_set_long_const (target, c1, c2)\n-     rtx target;\n-     HOST_WIDE_INT c1, c2;\n+alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n {\n   HOST_WIDE_INT d1, d2, d3, d4;\n \n@@ -3095,9 +2758,7 @@ alpha_emit_set_long_const (target, c1, c2)\n    We don't handle non-bwx subword loads here.  */\n \n bool\n-alpha_expand_mov (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+alpha_expand_mov (enum machine_mode mode, rtx *operands)\n {\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM\n@@ -3195,9 +2856,7 @@ alpha_expand_mov (mode, operands)\n    return true if all work is done.  */\n \n bool\n-alpha_expand_mov_nobwx (mode, operands)\n-     enum machine_mode mode;\n-     rtx *operands;\n+alpha_expand_mov_nobwx (enum machine_mode mode, rtx *operands)\n {\n   /* If the output is not a register, the input must be.  */\n   if (GET_CODE (operands[0]) == MEM)\n@@ -3350,8 +3009,7 @@ alpha_expand_mov_nobwx (mode, operands)\n    much lower minimum execution time.  */\n \n void\n-alpha_emit_floatuns (operands)\n-     rtx operands[2];\n+alpha_emit_floatuns (rtx operands[2])\n {\n   rtx neglab, donelab, i0, i1, f0, in, out;\n   enum machine_mode mode;\n@@ -3385,8 +3043,7 @@ alpha_emit_floatuns (operands)\n /* Generate the comparison for a conditional branch.  */\n \n rtx\n-alpha_emit_conditional_branch (code)\n-     enum rtx_code code;\n+alpha_emit_conditional_branch (enum rtx_code code)\n {\n   enum rtx_code cmp_code, branch_code;\n   enum machine_mode cmp_mode, branch_mode = VOIDmode;\n@@ -3542,8 +3199,7 @@ alpha_emit_conditional_branch (code)\n    valid.  Return the final comparison, or NULL if we can't work.  */\n \n rtx\n-alpha_emit_setcc (code)\n-     enum rtx_code code;\n+alpha_emit_setcc (enum rtx_code code)\n {\n   enum rtx_code cmp_code;\n   rtx op0 = alpha_compare.op0, op1 = alpha_compare.op1;\n@@ -3654,10 +3310,9 @@ alpha_emit_setcc (code)\n    If both of the operands that set cc0 are nonzero we must emit\n    an insn to perform the compare (it can't be done within\n    the conditional move).  */\n+\n rtx\n-alpha_emit_conditional_move (cmp, mode)\n-     rtx cmp;\n-     enum machine_mode mode;\n+alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (cmp);\n   enum rtx_code cmov_code = NE;\n@@ -3792,9 +3447,8 @@ alpha_emit_conditional_move (cmp, mode)\n    cases we wouldn't have before cse.  */\n \n int\n-alpha_split_conditional_move (code, dest, cond, t_rtx, f_rtx)\n-     enum rtx_code code;\n-     rtx dest, cond, t_rtx, f_rtx;\n+alpha_split_conditional_move (enum rtx_code code, rtx dest, rtx cond,\n+\t\t\t      rtx t_rtx, rtx f_rtx)\n {\n   HOST_WIDE_INT t, f, diff;\n   enum machine_mode mode;\n@@ -3879,8 +3533,7 @@ alpha_split_conditional_move (code, dest, cond, t_rtx, f_rtx)\n    given operation.  */\n \n static const char *\n-alpha_lookup_xfloating_lib_func (code)\n-     enum rtx_code code;\n+alpha_lookup_xfloating_lib_func (enum rtx_code code)\n {\n   struct xfloating_op\n     {\n@@ -3966,9 +3619,8 @@ alpha_lookup_xfloating_lib_func (code)\n    Compute that here.  */\n \n static int\n-alpha_compute_xfloating_mode_arg (code, round)\n-     enum rtx_code code;\n-     enum alpha_fp_rounding_mode round;\n+alpha_compute_xfloating_mode_arg (enum rtx_code code,\n+\t\t\t\t  enum alpha_fp_rounding_mode round)\n {\n   int mode;\n \n@@ -4012,12 +3664,8 @@ alpha_compute_xfloating_mode_arg (code, round)\n */\n \n static void\n-alpha_emit_xfloating_libcall (func, target, operands, noperands, equiv)\n-     const char *func;\n-     rtx target;\n-     rtx operands[];\n-     int noperands;\n-     rtx equiv;\n+alpha_emit_xfloating_libcall (const char *func, rtx target, rtx operands[],\n+\t\t\t      int noperands, rtx equiv)\n {\n   rtx usage = NULL_RTX, tmp, reg;\n   int regno = 16, i;\n@@ -4084,9 +3732,7 @@ alpha_emit_xfloating_libcall (func, target, operands, noperands, equiv)\n /* Emit an X_floating library function call for arithmetic (+,-,*,/).  */\n \n void\n-alpha_emit_xfloating_arith (code, operands)\n-     enum rtx_code code;\n-     rtx operands[];\n+alpha_emit_xfloating_arith (enum rtx_code code, rtx operands[])\n {\n   const char *func;\n   int mode;\n@@ -4106,9 +3752,7 @@ alpha_emit_xfloating_arith (code, operands)\n /* Emit an X_floating library function call for a comparison.  */\n \n static rtx\n-alpha_emit_xfloating_compare (code, op0, op1)\n-     enum rtx_code code;\n-     rtx op0, op1;\n+alpha_emit_xfloating_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n   const char *func;\n   rtx out, operands[2];\n@@ -4130,9 +3774,7 @@ alpha_emit_xfloating_compare (code, op0, op1)\n /* Emit an X_floating library function call for a conversion.  */\n \n void\n-alpha_emit_xfloating_cvt (code, operands)\n-     enum rtx_code code;\n-     rtx operands[];\n+alpha_emit_xfloating_cvt (enum rtx_code code, rtx operands[])\n {\n   int noperands = 1, mode;\n   rtx out_operands[2];\n@@ -4168,8 +3810,7 @@ alpha_emit_xfloating_cvt (code, operands)\n    little-endian.  */\n \n void\n-alpha_split_tfmode_pair (operands)\n-     rtx operands[4];\n+alpha_split_tfmode_pair (rtx operands[4])\n {\n   if (GET_CODE (operands[1]) == REG)\n     {\n@@ -4205,9 +3846,7 @@ alpha_split_tfmode_pair (operands)\n    logical operation to be performed.  */\n \n void\n-alpha_split_tfmode_frobsign (operands, operation)\n-     rtx operands[3];\n-     rtx (*operation) PARAMS ((rtx, rtx, rtx));\n+alpha_split_tfmode_frobsign (rtx operands[3], rtx (*operation) (rtx, rtx, rtx))\n {\n   rtx high_bit = operands[2];\n   rtx scratch;\n@@ -4274,10 +3913,8 @@ alpha_split_tfmode_frobsign (operands, operation)\n */\n \n void\n-alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n-     rtx tgt, mem;\n-     HOST_WIDE_INT size, ofs;\n-     int sign;\n+alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n+\t\t\t     HOST_WIDE_INT ofs, int sign)\n {\n   rtx meml, memh, addr, extl, exth, tmp, mema;\n   enum machine_mode mode;\n@@ -4400,9 +4037,8 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n /* Similarly, use ins and msk instructions to perform unaligned stores.  */\n \n void\n-alpha_expand_unaligned_store (dst, src, size, ofs)\n-     rtx dst, src;\n-     HOST_WIDE_INT size, ofs;\n+alpha_expand_unaligned_store (rtx dst, rtx src,\n+\t\t\t      HOST_WIDE_INT size, HOST_WIDE_INT ofs)\n {\n   rtx dstl, dsth, addr, insl, insh, meml, memh, dsta;\n   \n@@ -4545,10 +4181,8 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n /* Load an integral number of consecutive unaligned quadwords.  */\n \n static void\n-alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n-     rtx *out_regs;\n-     rtx smem;\n-     HOST_WIDE_INT words, ofs;\n+alpha_expand_unaligned_load_words (rtx *out_regs, rtx smem,\n+\t\t\t\t   HOST_WIDE_INT words, HOST_WIDE_INT ofs)\n {\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n@@ -4629,10 +4263,8 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n    may be NULL to store zeros.  */\n \n static void\n-alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n-     rtx *data_regs;\n-     rtx dmem;\n-     HOST_WIDE_INT words, ofs;\n+alpha_expand_unaligned_store_words (rtx *data_regs, rtx dmem,\n+\t\t\t\t    HOST_WIDE_INT words, HOST_WIDE_INT ofs)\n {\n   rtx const im8 = GEN_INT (-8);\n   rtx const i64 = GEN_INT (64);\n@@ -4746,8 +4378,7 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n    operands[3] is the alignment.  */\n \n int\n-alpha_expand_block_move (operands)\n-     rtx operands[];\n+alpha_expand_block_move (rtx operands[])\n {\n   rtx bytes_rtx\t= operands[2];\n   rtx align_rtx = operands[3];\n@@ -5083,8 +4714,7 @@ alpha_expand_block_move (operands)\n }\n \n int\n-alpha_expand_block_clear (operands)\n-     rtx operands[];\n+alpha_expand_block_clear (rtx operands[])\n {\n   rtx bytes_rtx\t= operands[1];\n   rtx align_rtx = operands[2];\n@@ -5374,8 +5004,7 @@ alpha_expand_block_clear (operands)\n /* Returns a mask so that zap(x, value) == x & mask.  */\n \n rtx\n-alpha_expand_zap_mask (value)\n-     HOST_WIDE_INT value;\n+alpha_expand_zap_mask (HOST_WIDE_INT value)\n {\n   rtx result;\n   int i;\n@@ -5420,10 +5049,9 @@ alpha_expand_zap_mask (value)\n }\n \n void\n-alpha_expand_builtin_vector_binop (gen, mode, op0, op1, op2)\n-     rtx (*gen) PARAMS ((rtx, rtx, rtx));\n-     enum machine_mode mode;\n-     rtx op0, op1, op2;\n+alpha_expand_builtin_vector_binop (rtx (*gen) (rtx, rtx, rtx),\n+\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t   rtx op0, rtx op1, rtx op2)\n {\n   op0 = gen_lowpart (mode, op0);\n \n@@ -5444,11 +5072,7 @@ alpha_expand_builtin_vector_binop (gen, mode, op0, op1, op2)\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-alpha_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn;\n-     int cost;\n+alpha_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n   enum attr_type insn_type, dep_insn_type;\n \n@@ -5479,13 +5103,13 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n /* The number of instructions that can be issued per cycle.  */\n \n static int\n-alpha_issue_rate ()\n+alpha_issue_rate (void)\n {\n   return (alpha_cpu == PROCESSOR_EV4 ? 2 : 4);\n }\n \n static int\n-alpha_use_dfa_pipeline_interface ()\n+alpha_use_dfa_pipeline_interface (void)\n {\n   return true;\n }\n@@ -5499,7 +5123,7 @@ alpha_use_dfa_pipeline_interface ()\n    FA/FM.  For EV6, an arithmatic insn can be issued to U0/U1/L0/L1.  */\n \n static int\n-alpha_multipass_dfa_lookahead ()\n+alpha_multipass_dfa_lookahead (void)\n {\n   return (alpha_cpu == PROCESSOR_EV6 ? 4 : 2);\n }\n@@ -5524,7 +5148,7 @@ struct machine_function GTY(())\n /* How to allocate a 'struct machine_function'.  */\n \n static struct machine_function *\n-alpha_init_machine_status ()\n+alpha_init_machine_status (void)\n {\n   return ((struct machine_function *) \n \t\tggc_alloc_cleared (sizeof (struct machine_function)));\n@@ -5535,9 +5159,7 @@ alpha_init_machine_status ()\n /* Start the ball rolling with RETURN_ADDR_RTX.  */\n \n rtx\n-alpha_return_addr (count, frame)\n-     int count;\n-     rtx frame ATTRIBUTE_UNUSED;\n+alpha_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n   if (count != 0)\n     return const0_rtx;\n@@ -5549,7 +5171,7 @@ alpha_return_addr (count, frame)\n    function.  Needed only if TARGET_LD_BUGGY_LDGP.  */\n \n rtx\n-alpha_gp_save_rtx ()\n+alpha_gp_save_rtx (void)\n {\n   rtx r = get_hard_reg_initial_val (DImode, 29);\n   if (GET_CODE (r) != MEM)\n@@ -5558,7 +5180,7 @@ alpha_gp_save_rtx ()\n }\n \n static int\n-alpha_ra_ever_killed ()\n+alpha_ra_ever_killed (void)\n {\n   rtx top;\n \n@@ -5577,7 +5199,7 @@ alpha_ra_ever_killed ()\n    instruction, or NULL.  */\n \n static const char *\n-get_trap_mode_suffix ()\n+get_trap_mode_suffix (void)\n {\n   enum attr_trap_suffix s = get_attr_trap_suffix (current_output_insn);\n \n@@ -5644,7 +5266,7 @@ get_trap_mode_suffix ()\n    instruction, or NULL.  */\n \n static const char *\n-get_round_mode_suffix ()\n+get_round_mode_suffix (void)\n {\n   enum attr_round_suffix s = get_attr_round_suffix (current_output_insn);\n \n@@ -5675,8 +5297,23 @@ get_round_mode_suffix ()\n /* Locate some local-dynamic symbol still in use by this function\n    so that we can print its name in some movdi_er_tlsldm pattern.  */\n \n+static int\n+get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n+    {\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n static const char *\n-get_some_local_dynamic_name ()\n+get_some_local_dynamic_name (void)\n {\n   rtx insn;\n \n@@ -5691,30 +5328,10 @@ get_some_local_dynamic_name ()\n   abort ();\n }\n \n-static int\n-get_some_local_dynamic_name_1 (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  rtx x = *px;\n-\n-  if (GET_CODE (x) == SYMBOL_REF\n-      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n-    {\n-      cfun->machine->some_ld_name = XSTR (x, 0);\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Print an operand.  Recognize special options, documented below.  */\n \n void\n-print_operand (file, x, code)\n-    FILE *file;\n-    rtx x;\n-    int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   int i;\n \n@@ -6066,9 +5683,7 @@ print_operand (file, x, code)\n }\n \n void\n-print_operand_address (file, addr)\n-    FILE *file;\n-     rtx addr;\n+print_operand_address (FILE *file, rtx addr)\n {\n   int basereg = 31;\n   HOST_WIDE_INT offset = 0;\n@@ -6177,9 +5792,8 @@ print_operand_address (file, addr)\n    Note that the hint field is PC (new) + 4 * bits 13:0.  */\n \n void\n-alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n-     rtx tramp, fnaddr, cxt;\n-     int fnofs, cxtofs, jmpofs;\n+alpha_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt,\n+\t\t\t     int fnofs, int cxtofs, int jmpofs)\n {\n   rtx temp, temp1, addr;\n   /* VMS really uses DImode pointers in memory at this point.  */\n@@ -6244,11 +5858,8 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n    and the rest are pushed.  */\n \n rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n+\t      int named ATTRIBUTE_UNUSED)\n {\n   int basereg;\n   int num_args;\n@@ -6359,7 +5970,7 @@ function_arg (cum, mode, type, named)\n }\n \n tree\n-alpha_build_va_list ()\n+alpha_build_va_list (void)\n {\n   tree base, ofs, record, type_decl;\n \n@@ -6405,12 +6016,10 @@ alpha_build_va_list ()\n \n #if TARGET_ABI_OSF\n void\n-alpha_setup_incoming_varargs(cum, mode, type, pretend_size, no_rtl)\n-     CUMULATIVE_ARGS cum;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int *pretend_size;\n-     int no_rtl;\n+alpha_setup_incoming_varargs(CUMULATIVE_ARGS cum,\n+\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     tree type ATTRIBUTE_UNUSED,\n+\t\t\t     int *pretend_size, int no_rtl)\n {\n   if (cum >= 6)\n     return;\n@@ -6438,9 +6047,7 @@ alpha_setup_incoming_varargs(cum, mode, type, pretend_size, no_rtl)\n #endif\n \n void\n-alpha_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n+alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT offset;\n   tree t, offset_field, base_field;\n@@ -6502,8 +6109,7 @@ alpha_va_start (valist, nextarg)\n }\n \n rtx\n-alpha_va_arg (valist, type)\n-     tree valist, type;\n+alpha_va_arg (tree valist, tree type)\n {\n   rtx addr;\n   tree t, type_size, rounded_size;\n@@ -6763,7 +6369,7 @@ static struct alpha_builtin_def const two_arg_builtins[] = {\n };\n \n static void\n-alpha_init_builtins ()\n+alpha_init_builtins (void)\n {\n   const struct alpha_builtin_def *p;\n   tree ftype;\n@@ -6814,12 +6420,10 @@ alpha_init_builtins ()\n    IGNORE is nonzero if the value is to be ignored.  */\n \n static rtx\n-alpha_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+alpha_expand_builtin (tree exp, rtx target,\n+\t\t      rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      int ignore ATTRIBUTE_UNUSED)\n {\n #define MAX_ARGS 2\n \n@@ -6923,9 +6527,7 @@ static int vms_base_regno;\n /* Compute register masks for saved registers.  */\n \n static void\n-alpha_sa_mask (imaskP, fmaskP)\n-    unsigned long *imaskP;\n-    unsigned long *fmaskP;\n+alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n {\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n@@ -6980,7 +6582,7 @@ alpha_sa_mask (imaskP, fmaskP)\n }\n \n int\n-alpha_sa_size ()\n+alpha_sa_size (void)\n {\n   unsigned long mask[2];\n   int sa_size = 0;\n@@ -7086,8 +6688,8 @@ alpha_sa_size ()\n    and the other its replacement, at the start of a routine.  */\n \n HOST_WIDE_INT\n-alpha_initial_elimination_offset (from, to)\n-     unsigned int from, to ATTRIBUTE_UNUSED;\n+alpha_initial_elimination_offset (unsigned int from,\n+\t\t\t\t  unsigned int to ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT ret;\n \n@@ -7107,14 +6709,14 @@ alpha_initial_elimination_offset (from, to)\n }\n \n int\n-alpha_pv_save_size ()\n+alpha_pv_save_size (void)\n {\n   alpha_sa_size ();\n   return alpha_procedure_type == PT_STACK ? 8 : 0;\n }\n \n int\n-alpha_using_fp ()\n+alpha_using_fp (void)\n {\n   alpha_sa_size ();\n   return vms_unwind_regno == HARD_FRAME_POINTER_REGNUM;\n@@ -7134,22 +6736,19 @@ const struct attribute_spec vms_attribute_table[] =\n #endif\n \n static int\n-find_lo_sum_using_gp (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+find_lo_sum_using_gp (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (*px) == LO_SUM && XEXP (*px, 0) == pic_offset_table_rtx;\n }\n \n int\n-alpha_find_lo_sum_using_gp (insn)\n-     rtx insn;\n+alpha_find_lo_sum_using_gp (rtx insn)\n {\n   return for_each_rtx (&PATTERN (insn), find_lo_sum_using_gp, NULL) > 0;\n }\n \n static int\n-alpha_does_function_need_gp ()\n+alpha_does_function_need_gp (void)\n {\n   rtx insn;\n \n@@ -7189,8 +6788,7 @@ alpha_does_function_need_gp ()\n #endif\n \n void\n-alpha_write_verstamp (file)\n-     FILE *file ATTRIBUTE_UNUSED;\n+alpha_write_verstamp (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifdef MS_STAMP\n   fprintf (file, \"\\t.verstamp %d %d\\n\", MS_STAMP, LS_STAMP);\n@@ -7201,7 +6799,7 @@ alpha_write_verstamp (file)\n    sequences.  */\n \n static rtx\n-set_frame_related_p ()\n+set_frame_related_p (void)\n {\n   rtx seq = get_insns ();\n   rtx insn;\n@@ -7249,7 +6847,7 @@ set_frame_related_p ()\n    simply allocate stack without saving registers.  */\n \n void\n-alpha_expand_prologue ()\n+alpha_expand_prologue (void)\n {\n   /* Registers to save.  */\n   unsigned long imask = 0;\n@@ -7568,10 +7166,8 @@ alpha_expand_prologue ()\n /* Output the textual info surrounding the prologue.  */\n \n void\n-alpha_start_function (file, fnname, decl)\n-     FILE *file;\n-     const char *fnname;\n-     tree decl ATTRIBUTE_UNUSED;\n+alpha_start_function (FILE *file, const char *fnname,\n+\t\t      tree decl ATTRIBUTE_UNUSED)\n {\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n@@ -7753,8 +7349,7 @@ alpha_start_function (file, fnname, decl)\n /* Emit the .prologue note at the scheduled end of the prologue.  */\n \n static void\n-alpha_output_function_end_prologue (file)\n-     FILE *file;\n+alpha_output_function_end_prologue (FILE *file)\n {\n   if (TARGET_ABI_UNICOSMK)\n     ;\n@@ -7776,7 +7371,7 @@ alpha_output_function_end_prologue (file)\n #define FRP(exp) exp\n \n void\n-alpha_expand_epilogue ()\n+alpha_expand_epilogue (void)\n {\n   /* Registers to save.  */\n   unsigned long imask = 0;\n@@ -8034,10 +7629,7 @@ alpha_expand_epilogue ()\n /* Output the rest of the textual info surrounding the epilogue.  */\n \n void\n-alpha_end_function (file, fnname, decl)\n-     FILE *file;\n-     const char *fnname;\n-     tree decl ATTRIBUTE_UNUSED;\n+alpha_end_function (FILE *file, const char *fnname, tree decl ATTRIBUTE_UNUSED)\n {\n   /* End the function.  */\n   if (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive)\n@@ -8071,12 +7663,9 @@ alpha_end_function (file, fnname, decl)\n    Not sure why this idea hasn't been explored before...  */\n \n static void\n-alpha_output_mi_thunk_osf (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset;\n-     tree function;\n+alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t\t   HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t\t   tree function)\n {\n   HOST_WIDE_INT hi, lo;\n   rtx this, insn, funexp;\n@@ -8194,9 +7783,7 @@ long alpha_auto_offset;\n /* Emit a new filename to a stream.  */\n \n void\n-alpha_output_filename (stream, name)\n-     FILE *stream;\n-     const char *name;\n+alpha_output_filename (FILE *stream, const char *name)\n {\n   static int first_time = TRUE;\n   char ltext_label_name[100];\n@@ -8237,13 +7824,11 @@ alpha_output_filename (stream, name)\n       fprintf (stream, \"\\n\");\n     }\n }\n-\f\n+\n /* Emit a linenumber to a stream.  */\n \n void\n-alpha_output_lineno (stream, line)\n-     FILE *stream;\n-     int line;\n+alpha_output_lineno (FILE *stream, int line)\n {\n   if (write_symbols == DBX_DEBUG)\n     {\n@@ -8267,18 +7852,12 @@ struct shadow_summary\n   } used, defd;\n };\n \n-static void summarize_insn PARAMS ((rtx, struct shadow_summary *, int));\n-static void alpha_handle_trap_shadows PARAMS ((void));\n-\n /* Summary the effects of expression X on the machine.  Update SUM, a pointer\n    to the summary structure.  SET is nonzero if the insn is setting the\n    object, otherwise zero.  */\n \n static void\n-summarize_insn (x, sum, set)\n-     rtx x;\n-     struct shadow_summary *sum;\n-     int set;\n+summarize_insn (rtx x, struct shadow_summary *sum, int set)\n {\n   const char *format_ptr;\n   int i, j;\n@@ -8432,7 +8011,7 @@ summarize_insn (x, sum, set)\n    (d) The trap shadow may not include any branch instructions.  */\n \n static void\n-alpha_handle_trap_shadows ()\n+alpha_handle_trap_shadows (void)\n {\n   struct shadow_summary shadow;\n   int trap_pending, exception_nesting;\n@@ -8585,19 +8164,8 @@ enum alphaev5_pipe {\n   EV5_FM = 64\n };\n \n-static enum alphaev4_pipe alphaev4_insn_pipe PARAMS ((rtx));\n-static enum alphaev5_pipe alphaev5_insn_pipe PARAMS ((rtx));\n-static rtx alphaev4_next_group PARAMS ((rtx, int *, int *));\n-static rtx alphaev5_next_group PARAMS ((rtx, int *, int *));\n-static rtx alphaev4_next_nop PARAMS ((int *));\n-static rtx alphaev5_next_nop PARAMS ((int *));\n-\n-static void alpha_align_insns\n-  PARAMS ((unsigned int, rtx (*)(rtx, int *, int *), rtx (*)(int *)));\n-\n static enum alphaev4_pipe\n-alphaev4_insn_pipe (insn)\n-     rtx insn;\n+alphaev4_insn_pipe (rtx insn)\n {\n   if (recog_memoized (insn) < 0)\n     return EV4_STOP;\n@@ -8639,8 +8207,7 @@ alphaev4_insn_pipe (insn)\n }\n \n static enum alphaev5_pipe\n-alphaev5_insn_pipe (insn)\n-     rtx insn;\n+alphaev5_insn_pipe (rtx insn)\n {\n   if (recog_memoized (insn) < 0)\n     return EV5_STOP;\n@@ -8695,9 +8262,7 @@ alphaev5_insn_pipe (insn)\n    LEN is, of course, the length of the group in bytes.  */\n \n static rtx\n-alphaev4_next_group (insn, pin_use, plen)\n-     rtx insn;\n-     int *pin_use, *plen;\n+alphaev4_next_group (rtx insn, int *pin_use, int *plen)\n {\n   int len, in_use;\n \n@@ -8795,9 +8360,7 @@ alphaev4_next_group (insn, pin_use, plen)\n    LEN is, of course, the length of the group in bytes.  */\n \n static rtx\n-alphaev5_next_group (insn, pin_use, plen)\n-     rtx insn;\n-     int *pin_use, *plen;\n+alphaev5_next_group (rtx insn, int *pin_use, int *plen)\n {\n   int len, in_use;\n \n@@ -8922,8 +8485,7 @@ alphaev5_next_group (insn, pin_use, plen)\n }\n \n static rtx\n-alphaev4_next_nop (pin_use)\n-     int *pin_use;\n+alphaev4_next_nop (int *pin_use)\n {\n   int in_use = *pin_use;\n   rtx nop;\n@@ -8951,8 +8513,7 @@ alphaev4_next_nop (pin_use)\n }\n \n static rtx\n-alphaev5_next_nop (pin_use)\n-     int *pin_use;\n+alphaev5_next_nop (int *pin_use)\n {\n   int in_use = *pin_use;\n   rtx nop;\n@@ -8982,10 +8543,9 @@ alphaev5_next_nop (pin_use)\n /* The instruction group alignment main loop.  */\n \n static void\n-alpha_align_insns (max_align, next_group, next_nop)\n-     unsigned int max_align;\n-     rtx (*next_group) PARAMS ((rtx, int *, int *));\n-     rtx (*next_nop) PARAMS ((int *));\n+alpha_align_insns (unsigned int max_align,\n+\t\t   rtx (*next_group) (rtx, int *, int *),\n+\t\t   rtx (*next_nop) (int *))\n {\n   /* ALIGN is the known alignment for the insn group.  */\n   unsigned int align;\n@@ -9108,7 +8668,7 @@ alpha_align_insns (max_align, next_group, next_nop)\n /* Machine dependent reorg pass.  */\n \n static void\n-alpha_reorg ()\n+alpha_reorg (void)\n {\n   if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)\n     alpha_handle_trap_shadows ();\n@@ -9133,10 +8693,8 @@ alpha_reorg ()\n    special we do here is to honor small data.  */\n \n static void\n-alpha_elf_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+alpha_elf_select_rtx_section (enum machine_mode mode, rtx x,\n+\t\t\t      unsigned HOST_WIDE_INT align)\n {\n   if (TARGET_SMALL_DATA && GET_MODE_SIZE (mode) <= g_switch_value)\n     /* ??? Consider using mergable sdata sections.  */\n@@ -9180,8 +8738,7 @@ static GTY(()) int alpha_funcs_num;\n /* Return the VMS argument type corresponding to MODE.  */\n \n enum avms_arg_type\n-alpha_arg_type (mode)\n-     enum machine_mode mode;\n+alpha_arg_type (enum machine_mode mode)\n {\n   switch (mode)\n     {\n@@ -9198,8 +8755,7 @@ alpha_arg_type (mode)\n    register value.  */\n \n rtx\n-alpha_arg_info_reg_val (cum)\n-     CUMULATIVE_ARGS cum;\n+alpha_arg_info_reg_val (CUMULATIVE_ARGS cum)\n {\n   unsigned HOST_WIDE_INT regval = cum.num_args;\n   int i;\n@@ -9217,9 +8773,7 @@ alpha_arg_info_reg_val (cum)\n    Return an SYMBOL_REF rtx for the linkage.  */\n \n rtx\n-alpha_need_linkage (name, is_local)\n-    const char *name;\n-    int is_local;\n+alpha_need_linkage (const char *name, int is_local)\n {\n   splay_tree_node node;\n   struct alpha_links *al;\n@@ -9298,11 +8852,7 @@ alpha_need_linkage (name, is_local)\n }\n \n rtx\n-alpha_use_linkage (linkage, cfundecl, lflag, rflag)\n-     rtx linkage;\n-     tree cfundecl;\n-     int lflag;\n-     int rflag;\n+alpha_use_linkage (rtx linkage, tree cfundecl, int lflag, int rflag)\n {\n   splay_tree_node cfunnode;\n   struct alpha_funcs *cfaf;\n@@ -9376,9 +8926,7 @@ alpha_use_linkage (linkage, cfundecl, lflag, rflag)\n }\n \n static int\n-alpha_write_one_linkage (node, data)\n-     splay_tree_node node;\n-     void *data;\n+alpha_write_one_linkage (splay_tree_node node, void *data)\n {\n   const char *const name = (const char *) node->key;\n   struct alpha_links *link = (struct alpha_links *) node->value;\n@@ -9417,10 +8965,7 @@ alpha_write_one_linkage (node, data)\n }\n \n static void\n-alpha_write_linkage (stream, funname, fundecl)\n-     FILE *stream;\n-     const char *funname;\n-     tree fundecl;\n+alpha_write_linkage (FILE *stream, const char *funname, tree fundecl)\n {\n   splay_tree_node node;\n   struct alpha_funcs *func;\n@@ -9455,10 +9000,7 @@ alpha_write_linkage (stream, funname, fundecl)\n #define SECTION_VMS_INITIALIZE (SECTION_VMS_GLOBAL << 1)\n \n static unsigned int\n-vms_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+vms_section_type_flags (tree decl, const char *name, int reloc)\n {\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n@@ -9480,9 +9022,7 @@ vms_section_type_flags (decl, name, reloc)\n    the section; 0 if the default should be used.  */\n \n static void\n-vms_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+vms_asm_named_section (const char *name, unsigned int flags)\n {\n   fputc ('\\n', asm_out_file);\n   fprintf (asm_out_file, \".section\\t%s\", name);\n@@ -9508,19 +9048,15 @@ vms_asm_named_section (name, flags)\n    used by a normal pointer.  */\n \n static void\n-vms_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+vms_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   ctors_section ();\n   assemble_align (BITS_PER_WORD);\n   assemble_integer (symbol, UNITS_PER_WORD, BITS_PER_WORD, 1);\n }\n \n static void\n-vms_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority ATTRIBUTE_UNUSED;\n+vms_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   dtors_section ();\n   assemble_align (BITS_PER_WORD);\n@@ -9529,19 +9065,17 @@ vms_asm_out_destructor (symbol, priority)\n #else\n \n rtx\n-alpha_need_linkage (name, is_local)\n-     const char *name ATTRIBUTE_UNUSED;\n-     int is_local ATTRIBUTE_UNUSED;\n+alpha_need_linkage (const char *name ATTRIBUTE_UNUSED,\n+\t\t    int is_local ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n }\n \n rtx\n-alpha_use_linkage (linkage, cfundecl, lflag, rflag)\n-     rtx linkage ATTRIBUTE_UNUSED;\n-     tree cfundecl ATTRIBUTE_UNUSED;\n-     int lflag ATTRIBUTE_UNUSED;\n-     int rflag ATTRIBUTE_UNUSED;\n+alpha_use_linkage (rtx linkage ATTRIBUTE_UNUSED,\n+\t\t   tree cfundecl ATTRIBUTE_UNUSED,\n+\t\t   int lflag ATTRIBUTE_UNUSED,\n+\t\t   int rflag ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n }\n@@ -9550,21 +9084,11 @@ alpha_use_linkage (linkage, cfundecl, lflag, rflag)\n \f\n #if TARGET_ABI_UNICOSMK\n \n-static void unicosmk_output_module_name PARAMS ((FILE *));\n-static void unicosmk_output_default_externs PARAMS ((FILE *));\n-static void unicosmk_output_dex PARAMS ((FILE *));\n-static void unicosmk_output_externs PARAMS ((FILE *));\n-static void unicosmk_output_addr_vec PARAMS ((FILE *, rtx));\n-static const char *unicosmk_ssib_name PARAMS ((void));\n-static int unicosmk_special_name PARAMS ((const char *));\n-\n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n \n int\n-unicosmk_initial_elimination_offset (from, to)\n-      int from;\n-      int to;\n+unicosmk_initial_elimination_offset (int from, int to)\n {\n   int fixed_size;\n   \n@@ -9592,8 +9116,7 @@ unicosmk_initial_elimination_offset (from, to)\n    or '$'.  */\n \n static void\n-unicosmk_output_module_name (file)\n-      FILE *file;\n+unicosmk_output_module_name (FILE *file)\n {\n   const char *name;\n \n@@ -9613,93 +9136,13 @@ unicosmk_output_module_name (file)\n   output_clean_symbol_name (file, name);\n }\n \n-/* Output text that to appear at the beginning of an assembler file.  */\n+/* Output the definition of a common variable.  */\n \n-void \n-unicosmk_asm_file_start (file)\n-      FILE *file;\n+void\n+unicosmk_output_common (FILE *file, const char *name, int size, int align)\n {\n-  int i;\n-\n-  fputs (\"\\t.ident\\t\", file);\n-  unicosmk_output_module_name (file);\n-  fputs (\"\\n\\n\", file);\n-\n-  /* The Unicos/Mk assembler uses different register names. Instead of trying\n-     to support them, we simply use micro definitions.  */\n-\n-  /* CAM has different register names: rN for the integer register N and fN\n-     for the floating-point register N. Instead of trying to use these in\n-     alpha.md, we define the symbols $N and $fN to refer to the appropriate\n-     register.  */\n-\n-  for (i = 0; i < 32; ++i)\n-    fprintf (file, \"$%d <- r%d\\n\", i, i);\n-\n-  for (i = 0; i < 32; ++i)\n-    fprintf (file, \"$f%d <- f%d\\n\", i, i);\n-\n-  putc ('\\n', file);\n-\n-  /* The .align directive fill unused space with zeroes which does not work\n-     in code sections. We define the macro 'gcc@code@align' which uses nops\n-     instead. Note that it assumes that code sections always have the\n-     biggest possible alignment since . refers to the current offset from\n-     the beginning of the section.  */\n-\n-  fputs (\"\\t.macro gcc@code@align n\\n\", file);\n-  fputs (\"gcc@n@bytes = 1 << n\\n\", file);\n-  fputs (\"gcc@here = . % gcc@n@bytes\\n\", file);\n-  fputs (\"\\t.if ne, gcc@here, 0\\n\", file);\n-  fputs (\"\\t.repeat (gcc@n@bytes - gcc@here) / 4\\n\", file);\n-  fputs (\"\\tbis r31,r31,r31\\n\", file);\n-  fputs (\"\\t.endr\\n\", file);\n-  fputs (\"\\t.endif\\n\", file);\n-  fputs (\"\\t.endm gcc@code@align\\n\\n\", file);\n-\n-  /* Output extern declarations which should always be visible.  */\n-  unicosmk_output_default_externs (file);\n-\n-  /* Open a dummy section. We always need to be inside a section for the\n-     section-switching code to work correctly.\n-     ??? This should be a module id or something like that. I still have to\n-     figure out what the rules for those are.  */\n-  fputs (\"\\n\\t.psect\\t$SG00000,data\\n\", file);\n-}\n-\n-/* Output text to appear at the end of an assembler file. This includes all\n-   pending extern declarations and DEX expressions.  */\n-\n-static void\n-unicosmk_file_end ()\n-{\n-  fputs (\"\\t.endp\\n\\n\", asm_out_file);\n-\n-  /* Output all pending externs.  */\n-\n-  unicosmk_output_externs (asm_out_file);\n-\n-  /* Output dex definitions used for functions whose names conflict with \n-     register names.  */\n-\n-  unicosmk_output_dex (asm_out_file);\n-\n-  fputs (\"\\t.end\\t\", asm_out_file);\n-  unicosmk_output_module_name (asm_out_file);\n-  putc ('\\n', asm_out_file);\n-}\n-\n-/* Output the definition of a common variable.  */\n-\n-void\n-unicosmk_output_common (file, name, size, align)\n-      FILE *file;\n-      const char *name;\n-      int size;\n-      int align;\n-{\n-  tree name_tree;\n-  printf (\"T3E__: common %s\\n\", name);\n+  tree name_tree;\n+  printf (\"T3E__: common %s\\n\", name);\n \n   common_section ();\n   fputs(\"\\t.endp\\n\\n\\t.psect \", file);\n@@ -9717,10 +9160,8 @@ unicosmk_output_common (file, name, size, align)\n static int current_section_align;\n \n static unsigned int\n-unicosmk_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc ATTRIBUTE_UNUSED;\n+unicosmk_section_type_flags (tree decl, const char *name,\n+\t\t\t     int reloc ATTRIBUTE_UNUSED)\n {\n   unsigned int flags = default_section_type_flags (decl, name, reloc);\n \n@@ -9749,9 +9190,7 @@ unicosmk_section_type_flags (decl, name, reloc)\n    declaration.  */\n \n static void\n-unicosmk_unique_section (decl, reloc)\n-      tree decl;\n-      int reloc ATTRIBUTE_UNUSED;\n+unicosmk_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n {\n   const char *name;\n   int len;\n@@ -9792,9 +9231,7 @@ unicosmk_unique_section (decl, reloc)\n    the section; 0 if the default should be used.  */\n \n static void\n-unicosmk_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+unicosmk_asm_named_section (const char *name, unsigned int flags)\n {\n   const char *kind;\n \n@@ -9822,9 +9259,7 @@ unicosmk_asm_named_section (name, flags)\n }\n \n static void\n-unicosmk_insert_attributes (decl, attr_ptr)\n-     tree decl;\n-     tree *attr_ptr ATTRIBUTE_UNUSED;\n+unicosmk_insert_attributes (tree decl, tree *attr_ptr ATTRIBUTE_UNUSED)\n {\n   if (DECL_P (decl)\n       && (TREE_PUBLIC (decl) || TREE_CODE (decl) == FUNCTION_DECL))\n@@ -9835,9 +9270,7 @@ unicosmk_insert_attributes (decl, attr_ptr)\n    in code sections because .align fill unused space with zeroes.  */\n       \n void\n-unicosmk_output_align (file, align)\n-      FILE *file;\n-      int align;\n+unicosmk_output_align (FILE *file, int align)\n {\n   if (inside_function)\n     fprintf (file, \"\\tgcc@code@align\\t%d\\n\", align);\n@@ -9850,9 +9283,7 @@ unicosmk_output_align (file, align)\n    does not allow data definitions in code sections.  */\n \n void\n-unicosmk_defer_case_vector (lab, vec)\n-      rtx lab;\n-      rtx vec;\n+unicosmk_defer_case_vector (rtx lab, rtx vec)\n {\n   struct machine_function *machine = cfun->machine;\n   \n@@ -9864,9 +9295,7 @@ unicosmk_defer_case_vector (lab, vec)\n /* Output a case vector.  */\n \n static void\n-unicosmk_output_addr_vec (file, vec)\n-      FILE *file;\n-      rtx vec;\n+unicosmk_output_addr_vec (FILE *file, rtx vec)\n {\n   rtx lab  = XEXP (vec, 0);\n   rtx body = XEXP (vec, 1);\n@@ -9885,8 +9314,7 @@ unicosmk_output_addr_vec (file, vec)\n /* Output current function's deferred case vectors.  */\n \n static void\n-unicosmk_output_deferred_case_vectors (file)\n-      FILE *file;\n+unicosmk_output_deferred_case_vectors (FILE *file)\n {\n   struct machine_function *machine = cfun->machine;\n   rtx t;\n@@ -9899,13 +9327,48 @@ unicosmk_output_deferred_case_vectors (file)\n     unicosmk_output_addr_vec (file, XEXP (t, 0));\n }\n \n+/* Generate the name of the SSIB section for the current function.  */\n+\n+#define SSIB_PREFIX \"__SSIB_\"\n+#define SSIB_PREFIX_LEN 7\n+\n+static const char *\n+unicosmk_ssib_name (void)\n+{\n+  /* This is ok since CAM won't be able to deal with names longer than that \n+     anyway.  */\n+\n+  static char name[256];\n+\n+  rtx x;\n+  const char *fnname;\n+  int len;\n+\n+  x = DECL_RTL (cfun->decl);\n+  if (GET_CODE (x) != MEM)\n+    abort ();\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    abort ();\n+  fnname = XSTR (x, 0);\n+\n+  len = strlen (fnname);\n+  if (len + SSIB_PREFIX_LEN > 255)\n+    len = 255 - SSIB_PREFIX_LEN;\n+\n+  strcpy (name, SSIB_PREFIX);\n+  strncpy (name + SSIB_PREFIX_LEN, fnname, len);\n+  name[len + SSIB_PREFIX_LEN] = 0;\n+\n+  return name;\n+}\n+\n /* Set up the dynamic subprogram information block (DSIB) and update the \n    frame pointer register ($15) for subroutines which have a frame. If the \n    subroutine doesn't have a frame, simply increment $15.  */\n \n static void\n-unicosmk_gen_dsib (imaskP)\n-      unsigned long * imaskP;\n+unicosmk_gen_dsib (unsigned long *imaskP)\n {\n   if (alpha_procedure_type == PT_STACK)\n     {\n@@ -9968,49 +9431,11 @@ unicosmk_gen_dsib (imaskP)\n     }\n }\n \n-#define SSIB_PREFIX \"__SSIB_\"\n-#define SSIB_PREFIX_LEN 7\n-\n-/* Generate the name of the SSIB section for the current function.  */\n-\n-static const char *\n-unicosmk_ssib_name ()\n-{\n-  /* This is ok since CAM won't be able to deal with names longer than that \n-     anyway.  */\n-\n-  static char name[256];\n-\n-  rtx x;\n-  const char *fnname;\n-  int len;\n-\n-  x = DECL_RTL (cfun->decl);\n-  if (GET_CODE (x) != MEM)\n-    abort ();\n-  x = XEXP (x, 0);\n-  if (GET_CODE (x) != SYMBOL_REF)\n-    abort ();\n-  fnname = XSTR (x, 0);\n-\n-  len = strlen (fnname);\n-  if (len + SSIB_PREFIX_LEN > 255)\n-    len = 255 - SSIB_PREFIX_LEN;\n-\n-  strcpy (name, SSIB_PREFIX);\n-  strncpy (name + SSIB_PREFIX_LEN, fnname, len);\n-  name[len + SSIB_PREFIX_LEN] = 0;\n-\n-  return name;\n-}\n-\n /* Output the static subroutine information block for the current\n    function.  */\n \n static void\n-unicosmk_output_ssib (file, fnname)\n-      FILE *file;\n-      const char *fnname;\n+unicosmk_output_ssib (FILE *file, const char *fnname)\n {\n   int len;\n   int i;\n@@ -10072,8 +9497,7 @@ unicosmk_output_ssib (file, fnname)\n    X is a CONST_INT or CONST_DOUBLE representing the CIW.  */\n \n rtx\n-unicosmk_add_call_info_word (x)\n-      rtx x;\n+unicosmk_add_call_info_word (rtx x)\n {\n   rtx node;\n   struct machine_function *machine = cfun->machine;\n@@ -10094,7 +9518,7 @@ unicosmk_add_call_info_word (x)\n static char unicosmk_section_buf[100];\n \n char *\n-unicosmk_text_section ()\n+unicosmk_text_section (void)\n {\n   static int count = 0;\n   sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@text___%d,code\", \n@@ -10103,7 +9527,7 @@ unicosmk_text_section ()\n }\n \n char *\n-unicosmk_data_section ()\n+unicosmk_data_section (void)\n {\n   static int count = 1;\n   sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@data___%d,data\", \n@@ -10132,8 +9556,7 @@ static struct unicosmk_extern_list *unicosmk_extern_head = 0;\n /* Output extern declarations which are required for every asm file.  */\n \n static void\n-unicosmk_output_default_externs (file)\n-\tFILE *file;\n+unicosmk_output_default_externs (FILE *file)\n {\n   static const char *const externs[] =\n     { \"__T3E_MISMATCH\" };\n@@ -10151,8 +9574,7 @@ unicosmk_output_default_externs (file)\n    referenced but not defined.  */\n \n static void\n-unicosmk_output_externs (file)\n-      FILE *file;\n+unicosmk_output_externs (FILE *file)\n {\n   struct unicosmk_extern_list *p;\n   const char *real_name;\n@@ -10184,8 +9606,7 @@ unicosmk_output_externs (file)\n /* Record an extern.  */\n \n void\n-unicosmk_add_extern (name)\n-     const char *name;\n+unicosmk_add_extern (const char *name)\n {\n   struct unicosmk_extern_list *p;\n \n@@ -10221,8 +9642,7 @@ static int unicosmk_dex_count = 0;\n /* Check if NAME must be replaced by a DEX expression.  */\n \n static int\n-unicosmk_special_name (name)\n-      const char *name;\n+unicosmk_special_name (const char *name)\n {\n   if (name[0] == '*')\n     ++name;\n@@ -10251,8 +9671,7 @@ unicosmk_special_name (name)\n    otherwise.  */\n \n static int\n-unicosmk_need_dex (x)\n-      rtx x;\n+unicosmk_need_dex (rtx x)\n {\n   struct unicosmk_dex *dex;\n   const char *name;\n@@ -10285,8 +9704,7 @@ unicosmk_need_dex (x)\n /* Output the DEX definitions for this file.  */\n \n static void\n-unicosmk_output_dex (file)\n-      FILE *file;\n+unicosmk_output_dex (FILE *file)\n {\n   struct unicosmk_dex *dex;\n   int i;\n@@ -10308,39 +9726,198 @@ unicosmk_output_dex (file)\n   fprintf (file, \"\\t.dexend\\n\");\n }\n \n+/* Output text that to appear at the beginning of an assembler file.  */\n+\n+void \n+unicosmk_asm_file_start (FILE *file)\n+{\n+  int i;\n+\n+  fputs (\"\\t.ident\\t\", file);\n+  unicosmk_output_module_name (file);\n+  fputs (\"\\n\\n\", file);\n+\n+  /* The Unicos/Mk assembler uses different register names. Instead of trying\n+     to support them, we simply use micro definitions.  */\n+\n+  /* CAM has different register names: rN for the integer register N and fN\n+     for the floating-point register N. Instead of trying to use these in\n+     alpha.md, we define the symbols $N and $fN to refer to the appropriate\n+     register.  */\n+\n+  for (i = 0; i < 32; ++i)\n+    fprintf (file, \"$%d <- r%d\\n\", i, i);\n+\n+  for (i = 0; i < 32; ++i)\n+    fprintf (file, \"$f%d <- f%d\\n\", i, i);\n+\n+  putc ('\\n', file);\n+\n+  /* The .align directive fill unused space with zeroes which does not work\n+     in code sections. We define the macro 'gcc@code@align' which uses nops\n+     instead. Note that it assumes that code sections always have the\n+     biggest possible alignment since . refers to the current offset from\n+     the beginning of the section.  */\n+\n+  fputs (\"\\t.macro gcc@code@align n\\n\", file);\n+  fputs (\"gcc@n@bytes = 1 << n\\n\", file);\n+  fputs (\"gcc@here = . % gcc@n@bytes\\n\", file);\n+  fputs (\"\\t.if ne, gcc@here, 0\\n\", file);\n+  fputs (\"\\t.repeat (gcc@n@bytes - gcc@here) / 4\\n\", file);\n+  fputs (\"\\tbis r31,r31,r31\\n\", file);\n+  fputs (\"\\t.endr\\n\", file);\n+  fputs (\"\\t.endif\\n\", file);\n+  fputs (\"\\t.endm gcc@code@align\\n\\n\", file);\n+\n+  /* Output extern declarations which should always be visible.  */\n+  unicosmk_output_default_externs (file);\n+\n+  /* Open a dummy section. We always need to be inside a section for the\n+     section-switching code to work correctly.\n+     ??? This should be a module id or something like that. I still have to\n+     figure out what the rules for those are.  */\n+  fputs (\"\\n\\t.psect\\t$SG00000,data\\n\", file);\n+}\n+\n+/* Output text to appear at the end of an assembler file. This includes all\n+   pending extern declarations and DEX expressions.  */\n+\n+static void\n+unicosmk_file_end (void)\n+{\n+  fputs (\"\\t.endp\\n\\n\", asm_out_file);\n+\n+  /* Output all pending externs.  */\n+\n+  unicosmk_output_externs (asm_out_file);\n+\n+  /* Output dex definitions used for functions whose names conflict with \n+     register names.  */\n+\n+  unicosmk_output_dex (asm_out_file);\n+\n+  fputs (\"\\t.end\\t\", asm_out_file);\n+  unicosmk_output_module_name (asm_out_file);\n+  putc ('\\n', asm_out_file);\n+}\n+\n #else\n \n static void\n-unicosmk_output_deferred_case_vectors (file)\n-      FILE *file ATTRIBUTE_UNUSED;\n+unicosmk_output_deferred_case_vectors (FILE *file ATTRIBUTE_UNUSED)\n {}\n \n static void\n-unicosmk_gen_dsib (imaskP)\n-      unsigned long * imaskP ATTRIBUTE_UNUSED;\n+unicosmk_gen_dsib (unsigned long *imaskP ATTRIBUTE_UNUSED)\n {}\n \n static void\n-unicosmk_output_ssib (file, fnname)\n-      FILE * file ATTRIBUTE_UNUSED;\n-      const char * fnname ATTRIBUTE_UNUSED;\n+unicosmk_output_ssib (FILE * file ATTRIBUTE_UNUSED,\n+\t\t      const char * fnname ATTRIBUTE_UNUSED)\n {}\n \n rtx\n-unicosmk_add_call_info_word (x)\n-     rtx x ATTRIBUTE_UNUSED;\n+unicosmk_add_call_info_word (rtx x ATTRIBUTE_UNUSED)\n {\n   return NULL_RTX;\n }\n \n static int\n-unicosmk_need_dex (x)\n-      rtx x ATTRIBUTE_UNUSED;\n+unicosmk_need_dex (rtx x ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n #endif /* TARGET_ABI_UNICOSMK */\n \n+\f\n+/* Initialize the GCC target structure.  */\n+#if TARGET_ABI_OPEN_VMS\n+# undef TARGET_ATTRIBUTE_TABLE\n+# define TARGET_ATTRIBUTE_TABLE vms_attribute_table\n+# undef TARGET_SECTION_TYPE_FLAGS\n+# define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags\n+#endif\n+\n+#undef TARGET_IN_SMALL_DATA_P\n+#define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p\n+\n+#if TARGET_ABI_UNICOSMK\n+# undef TARGET_INSERT_ATTRIBUTES\n+# define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes\n+# undef TARGET_SECTION_TYPE_FLAGS\n+# define TARGET_SECTION_TYPE_FLAGS unicosmk_section_type_flags\n+# undef TARGET_ASM_UNIQUE_SECTION\n+# define TARGET_ASM_UNIQUE_SECTION unicosmk_unique_section\n+# undef TARGET_ASM_GLOBALIZE_LABEL\n+# define TARGET_ASM_GLOBALIZE_LABEL hook_void_FILEptr_constcharptr\n+#endif\n+\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n+#undef TARGET_ASM_ALIGNED_DI_OP\n+#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n+\n+/* Default unaligned ops are provided for ELF systems.  To get unaligned\n+   data for non-ELF systems, we have to turn off auto alignment.  */\n+#ifndef OBJECT_FORMAT_ELF\n+#undef TARGET_ASM_UNALIGNED_HI_OP\n+#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.align 0\\n\\t.word\\t\"\n+#undef TARGET_ASM_UNALIGNED_SI_OP\n+#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.align 0\\n\\t.long\\t\"\n+#undef TARGET_ASM_UNALIGNED_DI_OP\n+#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.align 0\\n\\t.quad\\t\"\n+#endif\n+\n+#ifdef OBJECT_FORMAT_ELF\n+#undef\tTARGET_ASM_SELECT_RTX_SECTION\n+#define\tTARGET_ASM_SELECT_RTX_SECTION  alpha_elf_select_rtx_section\n+#endif\n+\n+#undef TARGET_ASM_FUNCTION_END_PROLOGUE\n+#define TARGET_ASM_FUNCTION_END_PROLOGUE alpha_output_function_end_prologue\n+\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST alpha_adjust_cost\n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE alpha_issue_rate\n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n+  alpha_use_dfa_pipeline_interface\n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n+  alpha_multipass_dfa_lookahead\n+\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS HAVE_AS_TLS\n+\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS alpha_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN alpha_expand_builtin\n+\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL alpha_function_ok_for_sibcall\n+#undef TARGET_CANNOT_COPY_INSN_P\n+#define TARGET_CANNOT_COPY_INSN_P alpha_cannot_copy_insn_p\n+\n+#if TARGET_ABI_OSF\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK alpha_output_mi_thunk_osf\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n+#endif\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS alpha_rtx_costs\n+#undef TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST hook_int_rtx_0\n+\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG alpha_reorg\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+\f\n #include \"gt-alpha.h\"\n "}, {"sha": "986d5edadd5169d0200d6a574210e2ce32c14d81", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -231,8 +231,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   SECTION_FUNCTION_TEMPLATE(sbss_section, in_sbss, SBSS_SECTION_ASM_OP)\t\\\n   SECTION_FUNCTION_TEMPLATE(sdata_section, in_sdata, SDATA_SECTION_ASM_OP)\n \n-extern void sbss_section\t\tPARAMS ((void));\n-extern void sdata_section\t\tPARAMS ((void));\n+extern void sbss_section (void);\n+extern void sdata_section (void);\n \n #undef  SECTION_FUNCTION_TEMPLATE\n #define SECTION_FUNCTION_TEMPLATE(FN, ENUM, OP)\t\\"}, {"sha": "529a9a302881ba47ca366540982d93a7bfd3d024", "filename": "gcc/config/alpha/osf.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fosf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fosf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf.h?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -155,13 +155,10 @@ Boston, MA 02111-1307, USA.  */\n /* Attempt to turn on access permissions for the stack.  */\n \n #define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\t\\\n-extern void __enable_execute_stack PARAMS ((void *));\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n-__enable_execute_stack (addr)\t\t\t\t\t\t\\\n-     void *addr;\t\t\t\t\t\t\t\\\n+__enable_execute_stack (void *addr)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  extern int mprotect PARAMS ((const void *, size_t, int));\t\t\\\n+  extern int mprotect (const void *, size_t, int);\t\t\t\\\n   long size = getpagesize ();\t\t\t\t\t\t\\\n   long mask = ~(size-1);\t\t\t\t\t\t\\\n   char *page = (char *) (((long) addr) & mask);\t\t\t\t\\"}, {"sha": "a5ed9415708e9fb1f87324da4dbeccdb638de6bb", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -102,8 +102,6 @@ Boston, MA 02111-1307, USA.  */\n    other its replacement, at the start of a routine. This is somewhat\n    complicated on the T3E which is why we use a function.  */\n \n-extern int unicosmk_initial_elimination_offset PARAMS ((int, int));\n-\n #undef INITIAL_ELIMINATION_OFFSET\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -319,15 +317,15 @@ do { fprintf (FILE, \"\\tbr $1,0\\n\");\t\t\t\\\n COMMON_SECTION\t\t\t\\\n SSIB_SECTION\t\n \n-extern void common_section PARAMS ((void));\n+extern void common_section (void);\n #define COMMON_SECTION\t\t\\\n void\t\t\t\t\\\n common_section ()\t\t\\\n {\t\t\t\t\\\n   in_section = in_common;\t\\\n }\n \n-extern void ssib_section PARAMS ((void));\n+extern void ssib_section (void);\n #define SSIB_SECTION\t\t\\\n void\t\t\t\t\\\n ssib_section ()\t\t\t\\"}, {"sha": "faf98dde3b88250e01694d424611933aca84c503", "filename": "gcc/config/alpha/vms-cc.c", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms-cc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-cc.c?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -1,5 +1,5 @@\n /* VMS DEC C wrapper.\n-   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n \n This file is part of GNU CC.\n@@ -34,50 +34,47 @@ Boston, MA 02111-1307, USA.  */\n #define PATH_SEPARATOR_STR \",\"\n \n /* These can be set by command line arguments */\n-int verbose = 0;\n-int save_temps = 0;\n+static int verbose = 0;\n+static int save_temps = 0;\n \n-int comp_arg_max = -1;\n-const char **comp_args = 0;\n-int comp_arg_index = -1;\n-char *objfilename = 0;\n+static int comp_arg_max = -1;\n+static const char **comp_args = 0;\n+static int comp_arg_index = -1;\n+static char *objfilename = 0;\n \n-char *system_search_dirs = (char *) \"\";\n-char *search_dirs;\n+static char *system_search_dirs = (char *) \"\";\n+static char *search_dirs;\n \n-char *default_defines = (char *) \"\";\n-char *defines;\n+static char *default_defines = (char *) \"\";\n+static char *defines;\n \n /* Translate a Unix syntax directory specification into VMS syntax.\n    If indicators of VMS syntax found, return input string. */\n-static char *to_host_dir_spec PARAMS ((char *));\n+static char *to_host_dir_spec (char *);\n \n /* Translate a Unix syntax file specification into VMS syntax.\n    If indicators of VMS syntax found, return input string. */\n-static char *to_host_file_spec PARAMS ((char *));\n+static char *to_host_file_spec (char *);\n \n /* Add a translated arg to the list to be passed to DEC CC */\n-static void addarg PARAMS ((const char *));\n+static void addarg (const char *);\n \n /* Preprocess the number of args in P_ARGC and contained in ARGV.\n    Look for special flags, etc. that must be handled first. */\n-static void preprocess_args PARAMS ((int *, char **));\n+static void preprocess_args (int *, char **);\n \n /* Process the number of args in P_ARGC and contained in ARGV. Look\n    for special flags, etc. that must be handled for the VMS compiler. */\n-static void process_args PARAMS ((int *, char **));\n+static void process_args (int *, char **);\n \n /* Action routine called by decc$to_vms */\n-static int translate_unix PARAMS ((char *, int));\n-\n-int main PARAMS ((int, char **));\n+static int translate_unix (char *, int);\n \f\n /* Add the argument contained in STR to the list of arguments to pass to the\n    compiler.  */\n \n static void\n-addarg (str)\n-     const char *str;\n+addarg (const char *str)\n {\n   int i;\n \n@@ -100,9 +97,7 @@ addarg (str)\n }\n \n static void\n-preprocess_args (p_argc, argv)\n-     int *p_argc;\n-     char *argv[];\n+preprocess_args (int *p_argc, char *argv[])\n {\n   int i;\n \n@@ -122,9 +117,7 @@ preprocess_args (p_argc, argv)\n }\n \n static void\n-process_args (p_argc, argv)\n-     int *p_argc;\n-     char *argv[];\n+process_args (int *p_argc, char *argv[])\n {\n   int i;\n \n@@ -185,9 +178,7 @@ process_args (p_argc, argv)\n typedef struct dsc {unsigned short len, mbz; char *adr; } Descr;\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int i;\n   char cwdev [128], *devptr;\n@@ -320,17 +311,14 @@ static char new_host_dirspec [255];\n static char filename_buff [256];\n \n static int\n-translate_unix (name, type)\n-     char *name;\n-     int type ATTRIBUTE_UNUSED;\n+translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n {\n   strcpy (filename_buff, name);\n   return 0;\n }\n \n static char *\n-to_host_dir_spec (dirspec)\n-     char *dirspec;\n+to_host_dir_spec (char *dirspec)\n {\n   int len = strlen (dirspec);\n \n@@ -353,8 +341,7 @@ to_host_dir_spec (dirspec)\n }\n \n static char *\n-to_host_file_spec (filespec)\n-     char *filespec;\n+to_host_file_spec (char *filespec)\n {\n   strcpy (new_host_filespec, \"\");\n   if (strchr (filespec, ']') || strchr (filespec, ':'))"}, {"sha": "6ddfe5ad62a437c60a1af5abca7becb25b5b2296", "filename": "gcc/config/alpha/vms-ld.c", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-ld.c?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -1,5 +1,5 @@\n /* VMS linker wrapper.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (rupp@gnat.com).\n \n@@ -89,39 +89,38 @@ static char *search_dirs;\n \n /* Add STR to the list of arguments to pass to the linker. Expand the list as\n    necessary to accommodate.  */\n-static void addarg PARAMS ((const char *));\n+static void addarg (const char *);\n \n /* Check to see if NAME is a regular file, i.e. not a directory */\n-static int is_regular_file PARAMS ((char *));\n+static int is_regular_file (char *);\n \n /* Translate a Unix syntax file specification FILESPEC into VMS syntax.\n    If indicators of VMS syntax found, return input string. */\n-static char *to_host_file_spec PARAMS ((char *));\n+static char *to_host_file_spec (char *);\n \n /* Locate the library named LIB_NAME in the set of paths PATH_VAL. */\n-static char *locate_lib PARAMS ((char *, char *));\n+static char *locate_lib (char *, char *);\n \n /* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then\n    libfoo.a in the set of directories we are allowed to search in.  */\n-static const char *expand_lib PARAMS ((char *));\n+static const char *expand_lib (char *);\n \n /* Preprocess the number of args P_ARGC in ARGV.\n    Look for special flags, etc. that must be handled first. */\n-static void preprocess_args PARAMS ((int *, char **));\n+static void preprocess_args (int *, char **);\n \n /* Preprocess the number of args P_ARGC in ARGV.  Look for\n    special flags, etc. that must be handled for the VMS linker. */\n-static void process_args PARAMS ((int *, char **));\n+static void process_args (int *, char **);\n \n /* Action routine called by decc$to_vms. NAME is a file name or\n    directory name. TYPE is unused. */\n-static int translate_unix PARAMS ((char *, int));\n+static int translate_unix (char *, int);\n \n-int main PARAMS ((int, char **));\n+int main (int, char **);\n \f\n static void\n-addarg (str)\n-     const char *str;\n+addarg (const char *str)\n {\n   int i;\n \n@@ -144,9 +143,7 @@ addarg (str)\n }\n \n static char *\n-locate_lib (lib_name, path_val)\n-     char *lib_name;\n-     char *path_val;\n+locate_lib (char *lib_name, char *path_val)\n {\n   int lib_len = strlen (lib_name);\n   char *eptr, *sptr;\n@@ -206,8 +203,7 @@ locate_lib (lib_name, path_val)\n }\n \n static const char *\n-expand_lib (name)\n-     char *name;\n+expand_lib (char *name)\n {\n   char *lib, *lib_path;\n \n@@ -240,8 +236,7 @@ expand_lib (name)\n }\n \n static int\n-is_regular_file (name)\n-     char *name;\n+is_regular_file (char *name)\n {\n   int ret;\n   struct stat statbuf;\n@@ -251,9 +246,7 @@ is_regular_file (name)\n }\n \n static void\n-preprocess_args (p_argc, argv)\n-     int *p_argc;\n-     char **argv;\n+preprocess_args (int *p_argc, char **argv)\n {\n   int i;\n \n@@ -305,9 +298,7 @@ preprocess_args (p_argc, argv)\n }\n \n static void\n-process_args (p_argc, argv)\n-     int *p_argc;\n-     char **argv;\n+process_args (int *p_argc, char **argv)\n {\n   int i;\n \n@@ -381,9 +372,7 @@ process_args (p_argc, argv)\n    and args to be what the VMS linker wants.  */\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int i;\n   char cwdev [128], *devptr;\n@@ -753,17 +742,14 @@ static char new_host_filespec [255];\n static char filename_buff [256];\n \n static int\n-translate_unix (name, type)\n-     char *name;\n-     int type ATTRIBUTE_UNUSED;\n+translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n {\n   strcpy (filename_buff, name);\n   return 0;\n }\n \n static char *\n-to_host_file_spec (filespec)\n-     char *filespec;\n+to_host_file_spec (char *filespec)\n {\n   strcpy (new_host_filespec, \"\");\n   if (strchr (filespec, ']') || strchr (filespec, ':'))"}, {"sha": "fe12fba23040dee78b35e6a37b8d68b3b1c29d8e", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c2492672af53c58d1649e1c0f0291923516f47/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=a5c2492672af53c58d1649e1c0f0291923516f47", "patch": "@@ -287,8 +287,8 @@ literals_section ()\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n-extern void link_section\tPARAMS ((void));\n-extern void literals_section\tPARAMS ((void));\n+extern void link_section (void);\n+extern void literals_section (void);\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()"}]}