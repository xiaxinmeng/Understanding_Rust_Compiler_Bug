{"sha": "0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM5ZWY3YWRmN2JlMjVlYmNkYjM5YTYzOGQxOTAxYWNmOWQ5NDliYQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2014-10-23T12:22:16Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2014-10-23T12:22:16Z"}, "message": "avr.c: Fix GNU coding rules and typos.\n\n\t* config/avr/avr.c: Fix GNU coding rules and typos.\n\t* config/avr/avr.h: Dito.\n\t* config/avr/avr-c.c: Dito.\n\t* config/avr/avr.md: Dito.\n\nFrom-SVN: r216592", "tree": {"sha": "d6367433ed9494e2e6095bd9448d6cd833f3fc52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6367433ed9494e2e6095bd9448d6cd833f3fc52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e650a5685c92e4e8c54b649e77e351ba06bcb3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e650a5685c92e4e8c54b649e77e351ba06bcb3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e650a5685c92e4e8c54b649e77e351ba06bcb3f3"}], "stats": {"total": 847, "additions": 445, "deletions": 402}, "files": [{"sha": "92303ccb9840233d678acb6872ccaaf4e31346ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "patch": "@@ -1,3 +1,10 @@\n+2014-10-23  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.c: Fix GNU coding rules and typos.\n+\t* config/avr/avr.h: Dito.\n+\t* config/avr/avr-c.c: Dito.\n+\t* config/avr/avr.md: Dito.\n+\n 2014-10-23  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/sse.md (define_mode_iterator VI1248_AVX512VL_AVX512BW):"}, {"sha": "13ece98694afa0f015749cb20cafa3f9e03b3373", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "patch": "@@ -327,14 +327,14 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n       cpp_define (pfile, \"__AVR_TINY__\");\n \n       /* Define macro \"__AVR_TINY_PM_BASE_ADDRESS__\" with mapped program memory\n-         start address. This macro shall be referred where mapped program memory\n-         is accessed. (Eg. copying data section (do_copy_data) contents to data\n-         memory region.\n+         start address.  This macro shall be used where mapped program\n+         memory is accessed, eg. copying data section (__do_copy_data)\n+         contents to data memory region.\n          NOTE:\n-         Program memory of AVR_TINY devices can not be accessed directly, it has\n-         been mapped to the data memory. For AVR_TINY devices (ATtiny4/ 5/ 9/ 10/\n-         20 and 40) mapped program memory starts at 0x4000.\n-      */\n+         Program memory of AVR_TINY devices cannot be accessed directly,\n+         it has been mapped to the data memory.  For AVR_TINY devices\n+         (ATtiny4/5/9/10/20 and 40) mapped program memory starts at 0x4000. */\n+\n       cpp_define (pfile, \"__AVR_TINY_PM_BASE_ADDRESS__=0x4000\");\n     }\n "}, {"sha": "d5b0707b36a5ba0007f61f175a798c760f12c979", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 368, "deletions": 331, "changes": 699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "patch": "@@ -89,12 +89,12 @@\n    / SYMBOL_FLAG_MACH_DEP)\n \n #define TINY_ADIW(REG1, REG2, I)                                \\\n-    \"subi \" #REG1 \",lo8(-(\" #I \"))\" CR_TAB                        \\\n-    \"sbci \" #REG2 \",hi8(-(\" #I \"))\"        \n+    \"subi \" #REG1 \",lo8(-(\" #I \"))\" CR_TAB                      \\\n+    \"sbci \" #REG2 \",hi8(-(\" #I \"))\"\n \n #define TINY_SBIW(REG1, REG2, I)                                \\\n-    \"subi \" #REG1 \",lo8((\" #I \"))\" CR_TAB                         \\\n-    \"sbci \" #REG2 \",hi8((\" #I \"))\"        \n+    \"subi \" #REG1 \",lo8((\" #I \"))\" CR_TAB                       \\\n+    \"sbci \" #REG2 \",hi8((\" #I \"))\"\n \n #define AVR_TMP_REGNO (AVR_TINY ? TMP_REGNO_TINY : TMP_REGNO)\n #define AVR_ZERO_REGNO (AVR_TINY ? ZERO_REGNO_TINY : ZERO_REGNO)\n@@ -358,10 +358,10 @@ avr_option_override (void)\n   for (avr_current_device = avr_mcu_types; ; avr_current_device++)\n     {\n       if (!avr_current_device->name)\n-\tfatal_error (\"mcu not found\");\n+        fatal_error (\"mcu not found\");\n       if (!avr_current_device->macro\n-\t  && avr_current_device->arch == avr_arch_index)\n-\tbreak;\n+          && avr_current_device->arch == avr_arch_index)\n+        break;\n     }\n \n   avr_current_arch = &avr_arch_types[avr_arch_index];\n@@ -428,7 +428,7 @@ avr_init_expanders (void)\n   /* TINY core does not have regs r10-r16, but avr-dimode.md expects them\n      to be present */\n   if (AVR_TINY)\n-    avr_have_dimode = false; \n+    avr_have_dimode = false;\n }\n \n \n@@ -3186,32 +3186,34 @@ avr_out_xload (rtx_insn *insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n   return \"\";\n }\n \n-/*\n-AVRTC-579\n-if operand is symbol or constant expression with value > 0xbf\n-  return false, otherwise true\n-This check is used to avoid lds/sts instruction with invalid memory\n-access range (valid range 0x40..0xbf). For io operand range 0x0..0x3f,\n-in/out instruction will be generated.\n-*/\n-bool tiny_valid_direct_memory_access_range(rtx op, enum machine_mode mode)\n+\n+/* AVRTC-579\n+   If OP is a symbol or a constant expression with value > 0xbf\n+   return FALSE, otherwise TRUE.\n+   This check is used to avoid LDS / STS instruction with invalid memory\n+   access range (valid range 0x40..0xbf).  For I/O operand range 0x0..0x3f,\n+   IN / OUT instruction will be generated.  */\n+\n+bool\n+tiny_valid_direct_memory_access_range (rtx op, enum machine_mode mode)\n {\n   rtx x;\n \n   if (!AVR_TINY)\n     return true;\n \n-  x = XEXP(op,0);\n+  x = XEXP (op,0);\n \n-  if (MEM_P(op) && x && (GET_CODE(x) == SYMBOL_REF))\n-  {\n-    return false;\n-  }\n-  if (MEM_P(op) && x && (CONSTANT_ADDRESS_P (x)) &&\n-     !(IN_RANGE (INTVAL (x), 0, 0xC0 - GET_MODE_SIZE (mode))))\n-  {\n-    return false;\n-  }\n+  if (MEM_P (op) && x && GET_CODE (x) == SYMBOL_REF)\n+    {\n+      return false;\n+    }\n+\n+  if (MEM_P (op) && x && (CONSTANT_ADDRESS_P (x))\n+      && !(IN_RANGE (INTVAL (x), 0, 0xC0 - GET_MODE_SIZE (mode))))\n+    {\n+      return false;\n+    }\n \n   return true;\n }\n@@ -3343,7 +3345,9 @@ output_movhi (rtx_insn *insn, rtx xop[], int *plen)\n   return \"\";\n }\n \n+\n /* Same as out_movqi_r_mr, but TINY does not have ADIW or SBIW */\n+\n static const char*\n avr_out_movqi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n {\n@@ -3352,11 +3356,11 @@ avr_out_movqi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n   rtx x = XEXP (src, 0);\n \n   avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-          \"ld %0,%b1\" , op, plen, -3);\n+               \"ld %0,%b1\" , op, plen, -3);\n \n   if (!reg_overlap_mentioned_p (dest, XEXP (x,0))\n-          && !reg_unused_after (insn, XEXP (x,0)))\n-      avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);\n+      && !reg_unused_after (insn, XEXP (x,0)))\n+    avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);\n \n   return \"\";\n }\n@@ -3426,7 +3430,9 @@ out_movqi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n   return avr_asm_len (\"ld %0,%1\", op, plen, -1);\n }\n \n+\n /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+\n static const char*\n avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)\n {\n@@ -3438,18 +3444,19 @@ avr_out_movhi_r_mr_reg_no_disp_tiny (rtx op[], int *plen)\n   int reg_base = true_regnum (base);\n \n   if (reg_dest == reg_base)         /* R = (R) */\n-      return avr_asm_len (\"ld __tmp_reg__,%1+\" CR_TAB\n-              \"ld %B0,%1\"          CR_TAB\n-              \"mov %A0,__tmp_reg__\", op, plen, -3);\n-\n-  return avr_asm_len (\"ld %A0,%1\"             CR_TAB                        \n-          TINY_ADIW (%E1, %F1, 1) CR_TAB                       \n-          \"ld %B0,%1\"             CR_TAB                        \n-          TINY_SBIW (%E1, %F1, 1), op, plen, -6);\n+    return avr_asm_len (\"ld __tmp_reg__,%1+\" CR_TAB\n+\t\t\t\"ld %B0,%1\"          CR_TAB\n+\t\t\t\"mov %A0,__tmp_reg__\", op, plen, -3);\n \n+  return avr_asm_len (\"ld %A0,%1\"             CR_TAB\n+                      TINY_ADIW (%E1, %F1, 1) CR_TAB\n+                      \"ld %B0,%1\"             CR_TAB\n+                      TINY_SBIW (%E1, %F1, 1), op, plen, -6);\n }\n \n+\n /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+\n static const char*\n avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)\n {\n@@ -3461,22 +3468,24 @@ avr_out_movhi_r_mr_reg_disp_tiny (rtx op[], int *plen)\n   int reg_base = true_regnum (XEXP (base, 0));\n \n   if (reg_base == reg_dest)\n-  {\n+    {\n       return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-              \"ld __tmp_reg__,%b1+\"    CR_TAB\n-              \"ld %B0,%b1\"             CR_TAB \n-              \"mov %A0,__tmp_reg__\", op, plen, -5);\n-  }\n+                          \"ld __tmp_reg__,%b1+\"     CR_TAB\n+                          \"ld %B0,%b1\"              CR_TAB\n+                          \"mov %A0,__tmp_reg__\", op, plen, -5);\n+    }\n   else\n-  {\n+    {\n       return avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-              \"ld %A0,%b1+\"             CR_TAB\n-              \"ld %B0,%b1\"              CR_TAB\n-              TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);\n-  }\n-} \n+                          \"ld %A0,%b1+\"             CR_TAB\n+                          \"ld %B0,%b1\"              CR_TAB\n+                          TINY_SBIW (%I1, %J1, %o1+1), op, plen, -6);\n+    }\n+}\n+\n \n /* Same as movhi_r_mr, but TINY does not have ADIW, SBIW and LDD */\n+\n static const char*\n avr_out_movhi_r_mr_pre_dec_tiny (rtx_insn *insn, rtx op[], int *plen)\n {\n@@ -3490,18 +3499,19 @@ avr_out_movhi_r_mr_pre_dec_tiny (rtx_insn *insn, rtx op[], int *plen)\n   mem_volatile_p = MEM_VOLATILE_P (src);\n \n   if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n-      fatal_insn (\"incorrect insn:\", insn);\n+    fatal_insn (\"incorrect insn:\", insn);\n \n   if (!mem_volatile_p)\n-      return avr_asm_len (\"ld %B0,%1\" CR_TAB\n-              \"ld %A0,%1\", op, plen, -2);\n+    return avr_asm_len (\"ld %B0,%1\" CR_TAB\n+                        \"ld %A0,%1\", op, plen, -2);\n \n   return avr_asm_len (TINY_SBIW (%I1, %J1, 2)  CR_TAB\n-          \"ld %A0,%p1+\"   CR_TAB\n-          \"ld %B0,%p1\"    CR_TAB\n-          TINY_SBIW (%I1, %J1, 1), op, plen, -6);\n+                      \"ld %A0,%p1+\"            CR_TAB\n+                      \"ld %B0,%p1\"             CR_TAB\n+                      TINY_SBIW (%I1, %J1, 1), op, plen, -6);\n }\n \n+\n static const char*\n out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n {\n@@ -3590,7 +3600,7 @@ out_movhi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n   else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     {\n       if (AVR_TINY)\n-          return avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);\n+\treturn avr_out_movhi_r_mr_pre_dec_tiny (insn, op, plen);\n \n       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n         fatal_insn (\"incorrect insn:\", insn);\n@@ -3643,40 +3653,41 @@ avr_out_movsi_r_mr_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n \n   if (reg_dest == reg_base)\n     {\n-\t  /* \"ld r26,-X\" is undefined */\n-      return *l=9, (TINY_ADIW (%E1, %F1, 3) CR_TAB\n-                    \"ld %D0,%1\"             CR_TAB\n-                    \"ld %C0,-%1\"            CR_TAB\n-                    \"ld __tmp_reg__,-%1\"   CR_TAB\n-                    TINY_SBIW (%E1, %F1, 1) CR_TAB\n-                    \"ld %A0,%1\"             CR_TAB\n-                    \"mov %B0,__tmp_reg__\");\n+      /* \"ld r26,-X\" is undefined */\n+      return *l = 9, (TINY_ADIW (%E1, %F1, 3) CR_TAB\n+\t\t      \"ld %D0,%1\"             CR_TAB\n+\t\t      \"ld %C0,-%1\"            CR_TAB\n+\t\t      \"ld __tmp_reg__,-%1\"    CR_TAB\n+\t\t      TINY_SBIW (%E1, %F1, 1) CR_TAB\n+\t\t      \"ld %A0,%1\"             CR_TAB\n+\t\t      \"mov %B0,__tmp_reg__\");\n     }\n   else if (reg_dest == reg_base - 2)\n     {\n-      return *l=5, (\"ld %A0,%1+\"            CR_TAB\n-                    \"ld %B0,%1+\"            CR_TAB\n-                    \"ld __tmp_reg__,%1+\"   CR_TAB\n-                    \"ld %D0,%1\"            CR_TAB\n-                    \"mov %C0,__tmp_reg__\");\n+      return *l = 5, (\"ld %A0,%1+\"            CR_TAB\n+\t\t      \"ld %B0,%1+\"            CR_TAB\n+\t\t      \"ld __tmp_reg__,%1+\"    CR_TAB\n+\t\t      \"ld %D0,%1\"             CR_TAB\n+\t\t      \"mov %C0,__tmp_reg__\");\n     }\n   else if (reg_unused_after (insn, base))\n     {\n-      return *l=4, (\"ld %A0,%1+\"    CR_TAB\n-                    \"ld %B0,%1+\"    CR_TAB \n-                    \"ld %C0,%1+\"    CR_TAB\n-                    \"ld %D0,%1\");\n+      return *l = 4, (\"ld %A0,%1+\"    CR_TAB\n+\t\t      \"ld %B0,%1+\"    CR_TAB\n+\t\t      \"ld %C0,%1+\"    CR_TAB\n+\t\t      \"ld %D0,%1\");\n     }\n   else\n     {\n-      return *l=6, (\"ld %A0,%1+\"    CR_TAB\n-                    \"ld %B0,%1+\"    CR_TAB \n-                    \"ld %C0,%1+\"    CR_TAB\n-                    \"ld %D0,%1\"     CR_TAB\n-                    TINY_SBIW (%E1, %F1, 3));\n+      return *l = 6, (\"ld %A0,%1+\"    CR_TAB\n+\t\t      \"ld %B0,%1+\"    CR_TAB\n+\t\t      \"ld %C0,%1+\"    CR_TAB\n+\t\t      \"ld %D0,%1\"     CR_TAB\n+\t\t      TINY_SBIW (%E1, %F1, 3));\n     }\n }\n \n+\n static const char*\n avr_out_movsi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n {\n@@ -3688,40 +3699,40 @@ avr_out_movsi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n \n   if (reg_dest == reg_base)\n     {\n-\t  /* \"ld r26,-X\" is undefined */\n-      return *l=9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB\n-                    \"ld %D0,%b1\"                 CR_TAB\n-                    \"ld %C0,-%b1\"                CR_TAB\n-                    \"ld __tmp_reg__,-%b1\"        CR_TAB\n-                    TINY_SBIW (%I1, %J1, 1)     CR_TAB\n-                    \"ld %A0,%b1\"                 CR_TAB\n-                    \"mov %B0,__tmp_reg__\");\n+      /* \"ld r26,-X\" is undefined */\n+      return *l = 9, (TINY_ADIW (%I1, %J1, %o1+3) CR_TAB\n+                      \"ld %D0,%b1\"                CR_TAB\n+                      \"ld %C0,-%b1\"               CR_TAB\n+                      \"ld __tmp_reg__,-%b1\"       CR_TAB\n+                      TINY_SBIW (%I1, %J1, 1)     CR_TAB\n+                      \"ld %A0,%b1\"                CR_TAB\n+                      \"mov %B0,__tmp_reg__\");\n     }\n   else if (reg_dest == reg_base - 2)\n     {\n-      return *l=7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-                    \"ld %A0,%b1+\"              CR_TAB\n-                    \"ld %B0,%b1+\"              CR_TAB\n-                    \"ld __tmp_reg__,%b1+\"      CR_TAB\n-                    \"ld %D0,%b1\"               CR_TAB\n-                    \"mov %C0,__tmp_reg__\");\n+      return *l = 7, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+                      \"ld %A0,%b1+\"             CR_TAB\n+                      \"ld %B0,%b1+\"             CR_TAB\n+                      \"ld __tmp_reg__,%b1+\"     CR_TAB\n+                      \"ld %D0,%b1\"              CR_TAB\n+                      \"mov %C0,__tmp_reg__\");\n     }\n   else if (reg_unused_after (insn, XEXP (base, 0)))\n     {\n-      return *l=6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-                    \"ld %A0,%b1+\"              CR_TAB\n-                    \"ld %B0,%b1+\"              CR_TAB \n-                    \"ld %C0,%b1+\"              CR_TAB\n-                    \"ld %D0,%b1\");\n+      return *l = 6, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n+                      \"ld %A0,%b1+\"             CR_TAB\n+                      \"ld %B0,%b1+\"             CR_TAB\n+                      \"ld %C0,%b1+\"             CR_TAB\n+                      \"ld %D0,%b1\");\n     }\n   else\n     {\n-      return *l=8, (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n-                    \"ld %A0,%b1+\"              CR_TAB\n-                    \"ld %B0,%b1+\"              CR_TAB \n-                    \"ld %C0,%b1+\"              CR_TAB\n-                    \"ld %D0,%b1\"               CR_TAB\n-                    TINY_SBIW (%I1, %J1, %o1+3));\n+      return *l = 8, (TINY_ADIW (%I1, %J1, %o1)  CR_TAB\n+                      \"ld %A0,%b1+\"              CR_TAB\n+                      \"ld %B0,%b1+\"              CR_TAB\n+                      \"ld %C0,%b1+\"              CR_TAB\n+                      \"ld %D0,%b1\"               CR_TAB\n+                      TINY_SBIW (%I1, %J1, %o1+3));\n     }\n }\n \n@@ -3914,56 +3925,56 @@ avr_out_movsi_mr_r_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *l)\n   rtx base = XEXP (dest, 0);\n   int reg_base = true_regnum (base);\n   int reg_src = true_regnum (src);\n-  \n+\n   if (reg_base == reg_src)\n     {\n \t  /* \"ld r26,-X\" is undefined */\n       if (reg_unused_after (insn, base))\n-        { \n-          return *l=7, (\"mov __tmp_reg__, %B1\"  CR_TAB\n-                        \"st %0,%A1\"             CR_TAB\n-                        TINY_ADIW (%E0, %F0, 1) CR_TAB\n-                        \"st %0+,__tmp_reg__\"    CR_TAB\n-                        \"st %0+,%C1\"            CR_TAB\n-                        \"st %0+,%D1\");\n+        {\n+          return *l = 7, (\"mov __tmp_reg__, %B1\"  CR_TAB\n+\t\t\t  \"st %0,%A1\"             CR_TAB\n+\t\t\t  TINY_ADIW (%E0, %F0, 1) CR_TAB\n+\t\t\t  \"st %0+,__tmp_reg__\"    CR_TAB\n+\t\t\t  \"st %0+,%C1\"            CR_TAB\n+\t\t\t  \"st %0+,%D1\");\n         }\n       else\n         {\n-          return *l=9, (\"mov __tmp_reg__, %B1\"  CR_TAB\n-                        \"st %0,%A1\"             CR_TAB\n-                        TINY_ADIW (%E0, %F0, 1) CR_TAB\n-                        \"st %0+,__tmp_reg__\"    CR_TAB\n-                        \"st %0+,%C1\"            CR_TAB\n-                        \"st %0+,%D1\"            CR_TAB\n-                        TINY_SBIW (%E0, %F0, 3));\n+          return *l = 9, (\"mov __tmp_reg__, %B1\"  CR_TAB\n+\t\t\t  \"st %0,%A1\"             CR_TAB\n+\t\t\t  TINY_ADIW (%E0, %F0, 1) CR_TAB\n+\t\t\t  \"st %0+,__tmp_reg__\"    CR_TAB\n+\t\t\t  \"st %0+,%C1\"            CR_TAB\n+\t\t\t  \"st %0+,%D1\"            CR_TAB\n+\t\t\t  TINY_SBIW (%E0, %F0, 3));\n         }\n     }\n-    else if (reg_base == reg_src + 2)\n-      {\n-        if (reg_unused_after (insn, base))\n-          return *l=7, (\"mov __zero_reg__,%C1\" CR_TAB\n+  else if (reg_base == reg_src + 2)\n+    {\n+      if (reg_unused_after (insn, base))\n+\treturn *l = 7, (\"mov __zero_reg__,%C1\" CR_TAB\n                         \"mov __tmp_reg__,%D1\"  CR_TAB\n                         \"st %0+,%A1\"           CR_TAB\n                         \"st %0+,%B1\"           CR_TAB\n                         \"st %0+,__zero_reg__\"  CR_TAB\n                         \"st %0,__tmp_reg__\"    CR_TAB\n                         \"clr __zero_reg__\");\n-        else\n-          return *l=9, (\"mov __zero_reg__,%C1\" CR_TAB\n-                        \"mov __tmp_reg__,%D1\"  CR_TAB\n-                        \"st %0+,%A1\"           CR_TAB\n-                        \"st %0+,%B1\"           CR_TAB\n-                        \"st %0+,__zero_reg__\"  CR_TAB\n-                        \"st %0,__tmp_reg__\"    CR_TAB\n-                        \"clr __zero_reg__\"     CR_TAB\n-                        TINY_SBIW (%E0, %F0, 3));\n-      }\n+      else\n+\treturn *l = 9, (\"mov __zero_reg__,%C1\" CR_TAB\n+\t\t\t\"mov __tmp_reg__,%D1\"  CR_TAB\n+\t\t\t\"st %0+,%A1\"           CR_TAB\n+\t\t\t\"st %0+,%B1\"           CR_TAB\n+\t\t\t\"st %0+,__zero_reg__\"  CR_TAB\n+\t\t\t\"st %0,__tmp_reg__\"    CR_TAB\n+\t\t\t\"clr __zero_reg__\"     CR_TAB\n+\t\t\tTINY_SBIW (%E0, %F0, 3));\n+    }\n \n-    return *l=6, (\"st %0+,%A1\" CR_TAB\n-                  \"st %0+,%B1\" CR_TAB\n-                  \"st %0+,%C1\" CR_TAB\n-                  \"st %0,%D1\"  CR_TAB\n-                  TINY_SBIW (%E0, %F0, 3));\n+  return *l = 6, (\"st %0+,%A1\" CR_TAB\n+\t\t  \"st %0+,%B1\" CR_TAB\n+\t\t  \"st %0+,%C1\" CR_TAB\n+\t\t  \"st %0,%D1\"  CR_TAB\n+\t\t  TINY_SBIW (%E0, %F0, 3));\n }\n \n static const char*\n@@ -3977,37 +3988,37 @@ avr_out_movsi_mr_r_reg_disp_tiny (rtx op[], int *l)\n \n   if (reg_base == reg_src)\n     {\n-\t  *l = 11;\n-\t  return (\"mov __tmp_reg__,%A2\"        CR_TAB\n-\t\t      \"mov __zero_reg__,%B2\"       CR_TAB\n+      *l = 11;\n+      return (\"mov __tmp_reg__,%A2\"        CR_TAB\n+              \"mov __zero_reg__,%B2\"       CR_TAB\n               TINY_ADIW (%I0, %J0, %o0)    CR_TAB\n-\t\t      \"st %b0+,__tmp_reg__\"        CR_TAB\n-\t\t      \"st %b0+,__zero_reg__\"       CR_TAB\n-\t\t      \"st %b0+,%C2\"                CR_TAB\n-\t\t      \"st %b0,%D2\"                 CR_TAB\n-\t\t      \"clr __zero_reg__\"           CR_TAB\n-\t\t      TINY_SBIW (%I0, %J0, %o0+3));\n-\t }\n+              \"st %b0+,__tmp_reg__\"        CR_TAB\n+              \"st %b0+,__zero_reg__\"       CR_TAB\n+              \"st %b0+,%C2\"                CR_TAB\n+              \"st %b0,%D2\"                 CR_TAB\n+              \"clr __zero_reg__\"           CR_TAB\n+              TINY_SBIW (%I0, %J0, %o0+3));\n+    }\n   else if (reg_src == reg_base - 2)\n     {\n-\t  *l = 11;\n-\t  return (\"mov __tmp_reg__,%C2\"         CR_TAB\n-\t\t      \"mov __zero_reg__,%D2\"        CR_TAB\n-\t\t      TINY_ADIW (%I0, %J0, %o0)     CR_TAB\n-\t\t      \"st %b0+,%A0\"                 CR_TAB\n-\t\t      \"st %b0+,%B0\"                 CR_TAB\n-\t\t      \"st %b0+,__tmp_reg__\"         CR_TAB\n-\t\t      \"st %b0,__zero_reg__\"         CR_TAB\n-\t\t      \"clr __zero_reg__\"            CR_TAB\n-\t\t      TINY_SBIW (%I0, %J0, %o0+3));\n-\t    }\n+      *l = 11;\n+      return (\"mov __tmp_reg__,%C2\"         CR_TAB\n+              \"mov __zero_reg__,%D2\"        CR_TAB\n+              TINY_ADIW (%I0, %J0, %o0)     CR_TAB\n+              \"st %b0+,%A0\"                 CR_TAB\n+              \"st %b0+,%B0\"                 CR_TAB\n+              \"st %b0+,__tmp_reg__\"         CR_TAB\n+              \"st %b0,__zero_reg__\"         CR_TAB\n+              \"clr __zero_reg__\"            CR_TAB\n+              TINY_SBIW (%I0, %J0, %o0+3));\n+    }\n   *l = 8;\n   return (TINY_ADIW (%I0, %J0, %o0)     CR_TAB\n-\t\t  \"st %b0+,%A1\"                 CR_TAB\n-\t\t  \"st %b0+,%B1\"                 CR_TAB\n-\t\t  \"st %b0+,%C1\"                 CR_TAB\n-\t\t  \"st %b0,%D1\"                  CR_TAB\n-\t\t  TINY_SBIW (%I0, %J0, %o0+3));\n+          \"st %b0+,%A1\"                 CR_TAB\n+          \"st %b0+,%B1\"                 CR_TAB\n+          \"st %b0+,%C1\"                 CR_TAB\n+          \"st %b0,%D1\"                  CR_TAB\n+          TINY_SBIW (%I0, %J0, %o0+3));\n }\n \n static const char*\n@@ -4279,9 +4290,9 @@ avr_out_load_psi_reg_no_disp_tiny (rtx_insn *insn, rtx *op, int *plen)\n     {\n       return avr_asm_len (TINY_ADIW (%E1, %F1, 2)   CR_TAB\n                           \"ld %C0,%1\"               CR_TAB\n-                          \"ld __tmp_reg__,-%1\"     CR_TAB\n+                          \"ld __tmp_reg__,-%1\"      CR_TAB\n                           TINY_SBIW (%E1, %F1, 1)   CR_TAB\n-                          \"ld %A0,%1\"              CR_TAB\n+                          \"ld %A0,%1\"               CR_TAB\n                           \"mov %B0,__tmp_reg__\", op, plen, -8);\n     }\n   else\n@@ -4322,13 +4333,13 @@ avr_out_load_psi_reg_disp_tiny (rtx_insn *insn, rtx *op, int *plen)\n     {\n       avr_asm_len (TINY_ADIW (%I1, %J1, %o1)   CR_TAB\n                           \"ld %A0,%b1+\"              CR_TAB\n-                          \"ld %B0,%b1+\"              CR_TAB  \n+                          \"ld %B0,%b1+\"              CR_TAB\n                           \"ld %C0,%b1\", op, plen, -5);\n \n       if (reg_dest != (reg_base - 2)\n           && !reg_unused_after (insn, XEXP (base, 0)))\n           avr_asm_len (TINY_SBIW (%I1, %J1, %o1+2), op, plen, 2);\n-      \n+\n       return \"\";\n     }\n }\n@@ -4533,7 +4544,7 @@ avr_out_store_psi_reg_disp_tiny (rtx *op, int *plen)\n     }\n   else if (reg_src == reg_base - 2)\n     {\n-      return avr_asm_len (\"mov __tmp_reg__,%C1\"          CR_TAB  \n+      return avr_asm_len (\"mov __tmp_reg__,%C1\"          CR_TAB\n                           TINY_ADIW (%I0, %J0, %o0)      CR_TAB\n                           \"st %b0+,%A1\"                  CR_TAB\n                           \"st %b0+,%B1\"                  CR_TAB\n@@ -4967,7 +4978,7 @@ avr_out_movhi_mr_r_reg_disp_tiny (rtx op[], int *plen)\n                        \"st %b0,__zero_reg__\"          CR_TAB\n                        \"st -%b0,__tmp_reg__\"          CR_TAB\n                        \"clr __zero_reg__\"             CR_TAB\n-                       TINY_SBIW (%I0, %J0, %o0), op, plen, -9) \n+                       TINY_SBIW (%I0, %J0, %o0), op, plen, -9)\n \n         : avr_asm_len (TINY_ADIW (%I0, %J0, %o0+1) CR_TAB\n                        \"st %b0,%B1\"                CR_TAB\n@@ -7362,7 +7373,8 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n       else\n         {\n           if (MINUS == code && !test_hard_reg_class (LD_REGS, op[0]))\n-            avr_asm_len (\"sec\" CR_TAB \"sbc %0,%0\", op, plen, 2);\n+            avr_asm_len (\"sec\" CR_TAB\n+                         \"sbc %0,%0\", op, plen, 2);\n           else\n             avr_asm_len (PLUS == code ? \"sbc %0,%0\" : \"ldi %0,0xff\",\n                          op, plen, 1);\n@@ -7866,109 +7878,120 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n     gcc_unreachable();\n \n   /* If we need to round the fraction part, we might need to save/round it\n-     before clobbering any of it in Step 1.  Also, we might to want to do\n+     before clobbering any of it in Step 1.  Also, we might want to do\n      the rounding now to make use of LD_REGS.  */\n   if (SCALAR_INT_MODE_P (GET_MODE (xop[0]))\n       && SCALAR_ACCUM_MODE_P (GET_MODE (xop[1]))\n       && !TARGET_FRACT_CONV_TRUNC)\n     {\n       bool overlap\n-\t= (src.regno <=\n-\t   (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)\n-\t   && dest.regno - offset -1 >= dest.regno);\n+        = (src.regno <=\n+           (offset ? dest.regno_msb - sign_bytes : dest.regno + zero_bytes - 1)\n+           && dest.regno - offset -1 >= dest.regno);\n       unsigned s0 = dest.regno - offset -1;\n       bool use_src = true;\n       unsigned sn;\n       unsigned copied_msb = src.regno_msb;\n       bool have_carry = false;\n \n       if (src.ibyte > dest.ibyte)\n-\tcopied_msb -= src.ibyte - dest.ibyte;\n+        copied_msb -= src.ibyte - dest.ibyte;\n \n       for (sn = s0; sn <= copied_msb; sn++)\n-\tif (!IN_RANGE (sn, dest.regno, dest.regno_msb)\n-\t    && !reg_unused_after (insn, all_regs_rtx[sn]))\n-\t  use_src = false;\n+        if (!IN_RANGE (sn, dest.regno, dest.regno_msb)\n+            && !reg_unused_after (insn, all_regs_rtx[sn]))\n+          use_src = false;\n       if (use_src && TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0))\n-\t{\n-\t  avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n-\t\t       &all_regs_rtx[src.regno_msb], plen, 2);\n-\t  sn = src.regno;\n-\t  if (sn < s0)\n-\t    {\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))\n-\t\tavr_asm_len (\"cpi %0,1\", &all_regs_rtx[sn], plen, 1);\n-\t      else\n-\t\tavr_asm_len (\"sec\" CR_TAB \"cpc %0,__zero_reg__\",\n-\t\t\t     &all_regs_rtx[sn], plen, 2);\n-\t      have_carry = true;\n-\t    }\n-\t  while (++sn < s0)\n-\t    avr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t  avr_asm_len (have_carry ? \"sbci %0,128\" : \"subi %0,129\",\n-\t\t       &all_regs_rtx[s0], plen, 1);\n-\t  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n-\t    avr_asm_len (\"sbci %0,255\", &all_regs_rtx[sn], plen, 1);\n-\t  avr_asm_len (\"\\n0:\", NULL, plen, 0);\n-\t  frac_rounded = true;\n-\t}\n+        {\n+          avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n+                       &all_regs_rtx[src.regno_msb], plen, 2);\n+          sn = src.regno;\n+          if (sn < s0)\n+            {\n+              if (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], sn))\n+                avr_asm_len (\"cpi %0,1\", &all_regs_rtx[sn], plen, 1);\n+              else\n+                avr_asm_len (\"sec\" CR_TAB\n+                             \"cpc %0,__zero_reg__\",\n+                             &all_regs_rtx[sn], plen, 2);\n+              have_carry = true;\n+            }\n+          while (++sn < s0)\n+            avr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\n+          avr_asm_len (have_carry ? \"sbci %0,128\" : \"subi %0,129\",\n+                       &all_regs_rtx[s0], plen, 1);\n+          for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n+            avr_asm_len (\"sbci %0,255\", &all_regs_rtx[sn], plen, 1);\n+          avr_asm_len (\"\\n0:\", NULL, plen, 0);\n+          frac_rounded = true;\n+        }\n       else if (use_src && overlap)\n-\t{\n-\t  avr_asm_len (\"clr __tmp_reg__\" CR_TAB\n-\t\t       \"sbrc %1,0\" CR_TAB \"dec __tmp_reg__\", xop, plen, 1);\n-\t  sn = src.regno;\n-\t  if (sn < s0)\n-\t    {\n-\t      avr_asm_len (\"add %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t      have_carry = true;\n-\t    }\n-\t  while (++sn < s0)\n-\t    avr_asm_len (\"adc %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t  if (have_carry)\n-\t    avr_asm_len (\"clt\" CR_TAB \"bld __tmp_reg__,7\" CR_TAB\n-\t\t\t \"adc %0,__tmp_reg__\",\n-\t\t\t &all_regs_rtx[s0], plen, 1);\n-\t  else\n-\t    avr_asm_len (\"lsr __tmp_reg\" CR_TAB \"add %0,__tmp_reg__\",\n-\t\t\t &all_regs_rtx[s0], plen, 2);\n-\t  for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n-\t    avr_asm_len (\"adc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t  frac_rounded = true;\n-\t}\n+        {\n+          avr_asm_len (\"clr __tmp_reg__\" CR_TAB\n+                       \"sbrc %1,0\"       CR_TAB\n+                       \"dec __tmp_reg__\", xop, plen, 1);\n+          sn = src.regno;\n+          if (sn < s0)\n+            {\n+              avr_asm_len (\"add %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n+              have_carry = true;\n+            }\n+\n+          while (++sn < s0)\n+            avr_asm_len (\"adc %0,__tmp_reg__\", &all_regs_rtx[sn], plen, 1);\n+\n+          if (have_carry)\n+            avr_asm_len (\"clt\"                CR_TAB\n+                         \"bld __tmp_reg__,7\"  CR_TAB\n+                         \"adc %0,__tmp_reg__\",\n+                         &all_regs_rtx[s0], plen, 1);\n+          else\n+            avr_asm_len (\"lsr __tmp_reg\" CR_TAB\n+                         \"add %0,__tmp_reg__\",\n+                         &all_regs_rtx[s0], plen, 2);\n+          for (sn = src.regno + src.fbyte; sn <= copied_msb; sn++)\n+            avr_asm_len (\"adc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+          frac_rounded = true;\n+        }\n       else if (overlap)\n-\t{\n-\t  bool use_src\n-\t    = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)\n-\t       && (IN_RANGE (s0, dest.regno, dest.regno_msb)\n-\t\t   || reg_unused_after (insn, all_regs_rtx[s0])));\n-\t  xop[2] = all_regs_rtx[s0];\n-\t  unsigned sn = src.regno;\n-\t  if (!use_src || sn == s0)\n-\t    avr_asm_len (\"mov __tmp_reg__,%2\", xop, plen, 1);\n-\t  /* We need to consider to-be-discarded bits\n-\t     if the value is negative.  */\n-\t  if (sn < s0)\n-\t    {\n-\t      avr_asm_len (\"tst %0\" CR_TAB \"brpl 0f\",\n-\t\t\t   &all_regs_rtx[src.regno_msb], plen, 2);\n-\t      /* Test to-be-discarded bytes for any nozero bits.\n-\t\t ??? Could use OR or SBIW to test two registers at once.  */\n-\t      if (sn < s0)\n-\t\tavr_asm_len (\"cp %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t      while (++sn < s0)\n-\t\tavr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n-\t      /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */\n-\t      if (use_src)\n-\t\tavr_asm_len (\"breq 0f\" CR_TAB\n-\t\t\t     \"ori %2,1\" \"\\n0:\\t\" \"mov __tmp_reg__,%2\",\n-\t\t\t     xop, plen, 3);\n-\t      else\n-\t\tavr_asm_len (\"breq 0f\" CR_TAB\n-\t\t\t     \"set\" CR_TAB \"bld __tmp_reg__,0\\n0:\",\n-\t\t\t     xop, plen, 3);\n-\t    }\n-\t  lsb_in_tmp_reg = true;\n-\t}\n+        {\n+          bool use_src\n+            = (TEST_HARD_REG_BIT (reg_class_contents[LD_REGS], s0)\n+               && (IN_RANGE (s0, dest.regno, dest.regno_msb)\n+                   || reg_unused_after (insn, all_regs_rtx[s0])));\n+          xop[2] = all_regs_rtx[s0];\n+          unsigned sn = src.regno;\n+          if (!use_src || sn == s0)\n+            avr_asm_len (\"mov __tmp_reg__,%2\", xop, plen, 1);\n+          /* We need to consider to-be-discarded bits\n+             if the value is negative.  */\n+          if (sn < s0)\n+            {\n+              avr_asm_len (\"tst %0\" CR_TAB\n+                           \"brpl 0f\",\n+                           &all_regs_rtx[src.regno_msb], plen, 2);\n+              /* Test to-be-discarded bytes for any nozero bits.\n+                 ??? Could use OR or SBIW to test two registers at once.  */\n+              if (sn < s0)\n+                avr_asm_len (\"cp %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+\n+              while (++sn < s0)\n+                avr_asm_len (\"cpc %0,__zero_reg__\", &all_regs_rtx[sn], plen, 1);\n+              /* Set bit 0 in __tmp_reg__ if any of the lower bits was set.  */\n+              if (use_src)\n+                avr_asm_len (\"breq 0f\" CR_TAB\n+                             \"ori %2,1\"\n+                             \"\\n0:\\t\" \"mov __tmp_reg__,%2\",\n+                             xop, plen, 3);\n+              else\n+                avr_asm_len (\"breq 0f\" CR_TAB\n+                             \"set\"     CR_TAB\n+                             \"bld __tmp_reg__,0\\n0:\",\n+                             xop, plen, 3);\n+            }\n+          lsb_in_tmp_reg = true;\n+        }\n     }\n \n   /* Step 1:  Clear bytes at the low end and copy payload bits from source\n@@ -8042,7 +8065,7 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n             {\n               /* We are going to override the sign bit.  If we sign-extend,\n                  store the sign in the Carry flag.  This is not needed if\n-                 the destination will be ASHIFT is the remainder because\n+                 the destination will be ASHIFT in the remainder because\n                  the ASHIFT will set Carry without extra instruction.  */\n \n               avr_asm_len (\"lsl %0\", &all_regs_rtx[src.regno_msb], plen, 1);\n@@ -8106,7 +8129,8 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n \t    avr_asm_len (\"cpc __zero_reg__,%0\", &all_regs_rtx[sn++], plen, 1);\n \n \t  /* Overflow goes with set carry.  Clear carry otherwise.  */\n-\t  avr_asm_len (\"brvs 0f\" CR_TAB \"clc\\n0:\", NULL, plen, 2);\n+\t  avr_asm_len (\"brvs 0f\" CR_TAB\n+                       \"clc\\n0:\", NULL, plen, 2);\n \t}\n       /* Likewise, when converting from accumulator types to integer, we\n \t need to round up negative values.  */\n@@ -8155,22 +8179,26 @@ avr_out_fract (rtx_insn *insn, rtx operands[], bool intsigned, int *plen)\n \t      /* Fall back to use __zero_reg__ as a temporary.  */\n \t      avr_asm_len (\"dec __zero_reg__\", NULL, plen, 1);\n \t      if (have_carry)\n-\t\tavr_asm_len (\"clt\" CR_TAB \"bld __zero_reg__,7\", NULL, plen, 2);\n+\t\tavr_asm_len (\"clt\" CR_TAB\n+                             \"bld __zero_reg__,7\", NULL, plen, 2);\n \t      else\n \t\tavr_asm_len (\"lsr __zero_reg__\", NULL, plen, 1);\n-\t      avr_asm_len ((have_carry && lsb_in_tmp_reg\n-\t\t\t   ? \"adc __tmp_reg__,__zero_reg__\"\n-\t\t\t   : have_carry ? \"adc %2,__zero_reg__\"\n-\t\t\t   : lsb_in_tmp_reg ? \"add __tmp_reg__,__zero_reg__\"\n-\t\t\t   : \"add %2,__zero_reg__\"),\n+\t      avr_asm_len (have_carry && lsb_in_tmp_reg\n+                           ? \"adc __tmp_reg__,__zero_reg__\"\n+                           : have_carry ? \"adc %2,__zero_reg__\"\n+                           : lsb_in_tmp_reg ? \"add __tmp_reg__,__zero_reg__\"\n+                           : \"add %2,__zero_reg__\",\n \t\t\t   xop, plen, 1);\n \t      avr_asm_len (\"eor __zero_reg__,__zero_reg__\", NULL, plen, 1);\n \t    }\n-\t  for (d0 = dest.regno + zero_bytes;\n+\n+          for (d0 = dest.regno + zero_bytes;\n \t       d0 <= dest.regno_msb - sign_bytes; d0++)\n \t    avr_asm_len (\"adc %0,__zero_reg__\", &all_regs_rtx[d0], plen, 1);\n-\t  avr_asm_len (lsb_in_tmp_reg\n-\t\t       ? \"\\n0:\\t\" \"lsl __tmp_reg__\" : \"\\n0:\\t\" \"lsl %2\",\n+\n+          avr_asm_len (lsb_in_tmp_reg\n+\t\t       ? \"\\n0:\\t\" \"lsl __tmp_reg__\"\n+                       : \"\\n0:\\t\" \"lsl %2\",\n \t\t       xop, plen, 1);\n \t}\n       else if (MAY_CLOBBER (s0))\n@@ -8412,15 +8440,15 @@ avr_rotate_bytes (rtx operands[])\n \tgcc_assert (size <= MAX_SIZE);\n \t/* Generate list of subreg moves.  */\n \tfor (i = 0; i < size; i++)\n-\t  {\n+          {\n \t    int from = i;\n \t    int to = (from + offset) % size;\n \t    move[i].src = simplify_gen_subreg (move_mode, operands[1],\n-\t\t\t\t\t\tmode, from * move_size);\n+                                               mode, from * move_size);\n \t    move[i].dst = simplify_gen_subreg (move_mode, operands[0],\n-\t\t\t\t\t\tmode, to   * move_size);\n-\t    move[i].links = -1;\n-\t   }\n+                                               mode, to * move_size);\n+            move[i].links = -1;\n+          }\n \t/* Mark dependence where a dst of one move is the src of another move.\n \t   The first move is a conflict as it must wait until second is\n \t   performed.  We ignore moves to self - we catch this later.  */\n@@ -8508,7 +8536,7 @@ avr_adjust_insn_length (rtx_insn *insn, int len)\n      the length need not/must not be adjusted for these insns.\n      It is easier to state this in an insn attribute \"adjust_len\" than\n      to clutter up code here...  */\n-  \n+\n   if (JUMP_TABLE_DATA_P (insn) || recog_memoized (insn) == -1)\n     {\n       return len;\n@@ -9517,8 +9545,10 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n       else\n \taddr_attr = lookup_attribute (\"address\", attr);\n       if (io_low_attr\n-\t  || (io_attr && addr_attr && \n-\t      low_io_address_operand (GEN_INT (TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (addr_attr)))), QImode)))\n+\t  || (io_attr && addr_attr\n+              && low_io_address_operand\n+                  (GEN_INT (TREE_INT_CST_LOW\n+                            (TREE_VALUE (TREE_VALUE (addr_attr)))), QImode)))\n \tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO_LOW;\n       if (io_attr || io_low_attr)\n \tSYMBOL_REF_FLAGS (sym) |= SYMBOL_FLAG_IO;\n@@ -9697,13 +9727,13 @@ avr_adjust_reg_alloc_order (void)\n       32, 33, 34, 35\n   };\n \n-  /*\n-  Select specific register allocation order. Tiny Core (attiny4/5/9/10/20/40)\n-  devices has only 16 registers, so different allocation order should be used\n-  */ \n-  const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1) :\n-             TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2) :\n-                                       (AVR_TINY ? tiny_order_0 : order_0));\n+  /* Select specific register allocation order.\n+     Tiny Core (ATtiny4/5/9/10/20/40) devices have only 16 registers,\n+     so different allocation order should be used.  */\n+\n+  const int *order = (TARGET_ORDER_1 ? (AVR_TINY ? tiny_order_1 : order_1)\n+                      : TARGET_ORDER_2 ? (AVR_TINY ? tiny_order_0 : order_2)\n+                      : (AVR_TINY ? tiny_order_0 : order_0));\n \n   for (i = 0; i < ARRAY_SIZE (order_0); ++i)\n       reg_alloc_order[i] = order[i];\n@@ -11592,47 +11622,53 @@ avr_output_addr_vec_elt (FILE *stream, int value)\n }\n \n static void\n-avr_conditional_register_usage(void) {\n+avr_conditional_register_usage(void)\n+{\n+  if (AVR_TINY)\n+    {\n+      unsigned int i;\n \n-  if (AVR_TINY) {\n-    unsigned int i;\n+      const int tiny_reg_alloc_order[] = {\n+        24, 25,\n+        22, 23,\n+        30, 31,\n+        26, 27,\n+        28, 29,\n+        21, 20, 19, 18,\n+        16, 17,\n+        32, 33, 34, 35,\n+        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n+      };\n \n-    const int tiny_reg_alloc_order[] = {\n-      24, 25,\n-      22, 23,\n-      30, 31,\n-      26, 27,\n-      28, 29,\n-      21, 20, 19, 18,\n-      16, 17,\n-      32, 33, 34, 35,\n-      15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n-    };\n+      /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list\n+         - R0-R15 are not available in Tiny Core devices\n+         - R16 and R17 are fixed registers.  */\n \n-    /* Set R0-R17 as fixed registers. Reset R0-R17 in call used register list\n-    - R0-R15 are not available in Tiny Core devices\n-    - R16 and R17 are fixed registers\n-    */\n-    for (i = 0;  i <= 17;  i++) {\n-      fixed_regs[i] = 1;\n-      call_used_regs[i] = 1;\n-    }\n+      for (i = 0;  i <= 17;  i++)\n+        {\n+          fixed_regs[i] = 1;\n+          call_used_regs[i] = 1;\n+        }\n \n-    /* Set R18 to R21 as callee saved registers\n-    - R18, R19, R20 and R21 are the callee saved registers in Tiny Core devices\n-    */\n-    for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++) {\n-      call_used_regs[i] = 0;\n-    }\n+      /* Set R18 to R21 as callee saved registers\n+         - R18, R19, R20 and R21 are the callee saved registers in\n+           Tiny Core devices  */\n \n-    /*update register allocation order for Tiny Core devices */\n-    for (i=0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++) {\n-      reg_alloc_order[i] = tiny_reg_alloc_order[i];\n-    }\n+      for (i = 18; i <= LAST_CALLEE_SAVED_REG; i++)\n+        {\n+          call_used_regs[i] = 0;\n+        }\n \n-    CLEAR_HARD_REG_SET(reg_class_contents[(int)ADDW_REGS]);\n-    CLEAR_HARD_REG_SET(reg_class_contents[(int)NO_LD_REGS]);\n-  }\n+      /* Update register allocation order for Tiny Core devices */\n+\n+      for (i = 0; i < ARRAY_SIZE (tiny_reg_alloc_order); i++)\n+        {\n+          reg_alloc_order[i] = tiny_reg_alloc_order[i];\n+        }\n+\n+      CLEAR_HARD_REG_SET (reg_class_contents[(int) ADDW_REGS]);\n+      CLEAR_HARD_REG_SET (reg_class_contents[(int) NO_LD_REGS]);\n+    }\n }\n \n /* Implement `TARGET_HARD_REGNO_SCRATCH_OK'.  */\n@@ -11789,19 +11825,20 @@ static bool\n avr_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT size = int_size_in_bytes (type);\n-  HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;                                      \n+  HOST_WIDE_INT ret_size_limit = AVR_TINY ? 4 : 8;\n \n-  /* In avr, there are 8 return registers. But, for Tiny Core \n-  (attiny4/5/9/10/20/40) devices, only 4 registers available.\n-  Return true if size is unknown or greater than the limit */\n-  if ((size == -1) || (size > ret_size_limit))\n-  {\n-    return true;\n-  }\n+  /* In avr, there are 8 return registers. But, for Tiny Core\n+     (ATtiny4/5/9/10/20/40) devices, only 4 registers are available.\n+     Return true if size is unknown or greater than the limit.  */\n+\n+  if (size == -1 || size > ret_size_limit)\n+    {\n+      return true;\n+    }\n   else\n-  {\n-    return false;\n-  }\n+    {\n+      return false;\n+    }\n }\n \n \n@@ -12080,7 +12117,7 @@ avr_convert_to_type (tree type, tree expr)\n     {\n       addr_space_t as_old = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (expr)));\n       addr_space_t as_new = TYPE_ADDR_SPACE (TREE_TYPE (type));\n-        \n+\n       if (avr_log.progmem)\n         avr_edump (\"%?: type = %t\\nexpr = %t\\n\\n\", type, expr);\n \n@@ -12815,7 +12852,7 @@ avr_init_builtins (void)\n \n #define ITYP(T)                                                         \\\n   lang_hooks.types.type_for_size (TYPE_PRECISION (T), TYPE_UNSIGNED (T))\n-  \n+\n #define FX_FTYPE_FX(fx)                                                 \\\n   tree fx##r_ftype_##fx##r                                              \\\n     = build_function_type_list (node_##fx##r, node_##fx##r, NULL);      \\\n@@ -12829,7 +12866,7 @@ avr_init_builtins (void)\n   tree fx##k_ftype_##fx##k_int                                          \\\n     = build_function_type_list (node_##fx##k, node_##fx##k,             \\\n                                 integer_type_node, NULL)\n-  \n+\n #define INT_FTYPE_FX(fx)                                                \\\n   tree int_ftype_##fx##r                                                \\\n     = build_function_type_list (integer_type_node, node_##fx##r, NULL); \\\n@@ -13073,7 +13110,7 @@ avr_expand_builtin (tree exp, rtx target,\n \n       /* Warn about odd rounding.  Rounding points >= FBIT will have\n          no effect.  */\n-      \n+\n       if (TREE_CODE (CALL_EXPR_ARG (exp, 1)) != INTEGER_CST)\n         break;\n "}, {"sha": "2522d6a2e219f05dbcc1d0c951b5eeb7d0043043", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "patch": "@@ -91,8 +91,8 @@ FIXME: DRIVER_SELF_SPECS has changed.\n    there is always __AVR_SP8__ == __AVR_HAVE_8BIT_SP__.  */\n \n #define AVR_HAVE_8BIT_SP                                 \\\n-  ((avr_current_device->dev_attribute & AVR_SHORT_SP) || \\\n-   TARGET_TINY_STACK || avr_sp8)\n+  ((avr_current_device->dev_attribute & AVR_SHORT_SP)    \\\n+   || TARGET_TINY_STACK || avr_sp8)\n \n #define AVR_HAVE_SPH (!avr_sp8)\n \n@@ -310,10 +310,10 @@ enum reg_class {\n #define STATIC_CHAIN_REGNUM ((AVR_TINY) ? 18 :2)\n \n #define ELIMINABLE_REGS {\t\t\t\t\t\\\n-      {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n-      {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n-\t{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\\\n-       ,{FRAME_POINTER_REGNUM+1,STACK_POINTER_REGNUM+1}}\n+    { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },               \\\n+    { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM },               \\\n+    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },             \\\n+    { FRAME_POINTER_REGNUM + 1, STACK_POINTER_REGNUM + 1 } }\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n   OFFSET = avr_initial_elimination_offset (FROM, TO)"}, {"sha": "5d3f6e199117e36b6eb48a2b45392de03ba97c65", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c9ef7adf7be25ebcdb39a638d1901acf9d949ba/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=0c9ef7adf7be25ebcdb39a638d1901acf9d949ba", "patch": "@@ -64,8 +64,8 @@\n    ])\n \n (define_constants\n-  [ (TMP_REGNO_TINY 16)  ; r16 is temp register for AVR_TINY\n-    (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY\n+  [(TMP_REGNO_TINY  16) ; r16 is temp register for AVR_TINY\n+   (ZERO_REGNO_TINY 17) ; r17 is zero register for AVR_TINY\n   ])\n \n (define_c_enum \"unspec\"\n@@ -640,32 +640,31 @@\n         DONE;\n       }\n \n-    /* AVRTC-579\n-    if the source operand expression is out of range for 'lds' instruction\n-      copy source operand expression to register\n-    For tiny core, LDS instruction's memory access range limited to 0x40..0xbf\n-    */\n-    if (!tiny_valid_direct_memory_access_range(src,<MODE>mode))\n+    // AVRTC-579\n+    // If the source operand expression is out of range for LDS instruction\n+    // copy source operand expression to register.\n+    // For tiny core, LDS instruction's memory access range limited to 0x40..0xbf.\n+\n+    if (!tiny_valid_direct_memory_access_range (src, <MODE>mode))\n       {\n-        rtx srcx = XEXP(src,0);\n-        operands[1] = src = replace_equiv_address (src,copy_to_mode_reg (GET_MODE(srcx),srcx));\n-        emit_move_insn(dest,src);\n+        rtx srcx = XEXP (src, 0);\n+        operands[1] = src = replace_equiv_address (src, copy_to_mode_reg (GET_MODE (srcx), srcx));\n+        emit_move_insn (dest, src);\n         DONE;\n       }\n \n-    /* AVRTC-579\n-    if the destination operand expression is out of range for 'sts' instruction\n-      copy destination operand expression to register\n-    For tiny core, STS instruction's memory access range limited to 0x40..0xbf\n-    */\n-    if (!tiny_valid_direct_memory_access_range(dest,<MODE>mode))\n-    {\n-      rtx destx = XEXP(dest,0);\n-      operands[0] = dest = replace_equiv_address (dest,copy_to_mode_reg (GET_MODE(destx),destx));\n-      emit_move_insn(dest,src);\n-      DONE;\n-    }\n+    // AVRTC-579\n+    // If the destination operand expression is out of range for STS instruction\n+    // copy destination operand expression to register.\n+    // For tiny core, STS instruction's memory access range limited to 0x40..0xbf.\n \n+    if (!tiny_valid_direct_memory_access_range (dest, <MODE>mode))\n+      {\n+        rtx destx = XEXP (dest, 0);\n+        operands[0] = dest = replace_equiv_address (dest, copy_to_mode_reg (GET_MODE (destx), destx));\n+        emit_move_insn (dest, src);\n+        DONE;\n+      }\n   })\n \n ;;========================================================================\n@@ -683,12 +682,12 @@\n   [(set (match_operand:ALL1 0 \"nonimmediate_operand\" \"=r    ,d    ,Qm   ,r ,q,r,*r\")\n         (match_operand:ALL1 1 \"nox_general_operand\"   \"r Y00,n Ynn,r Y00,Qm,r,q,i\"))]\n   \"(register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n-   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n-   though access range is checked during define_expand, it is required\n-   here to avoid merging rtls during combine pass */\n-   tiny_valid_direct_memory_access_range(operands[0],QImode) &&\n-   tiny_valid_direct_memory_access_range(operands[1],QImode)\"\n+    || reg_or_0_operand (operands[1], <MODE>mode))\n+   /* Skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+      though access range is checked during define_expand, it is required\n+      here to avoid merging RTXes during combine pass.  */\n+   && tiny_valid_direct_memory_access_range (operands[0], QImode)\n+   && tiny_valid_direct_memory_access_range (operands[1], QImode)\"\n   {\n     return output_movqi (insn, operands, NULL);\n   }\n@@ -782,12 +781,12 @@\n   [(set (match_operand:ALL2 0 \"nonimmediate_operand\" \"=r,r  ,r,m    ,d,*r,q,r\")\n         (match_operand:ALL2 1 \"nox_general_operand\"   \"r,Y00,m,r Y00,i,i ,r,q\"))]\n   \"(register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n-   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n-   though access range is checked during define_expand, it is required\n-   here to avoid merging rtls during combine pass */\n-   tiny_valid_direct_memory_access_range(operands[0],HImode) &&\n-   tiny_valid_direct_memory_access_range(operands[1],HImode)\"\n+    || reg_or_0_operand (operands[1], <MODE>mode))\n+   /* Skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+      though access range is checked during define_expand, it is required\n+      here to avoid merging RTXes during combine pass.  */\n+   && tiny_valid_direct_memory_access_range (operands[0], HImode)\n+   && tiny_valid_direct_memory_access_range (operands[1], HImode)\"\n   {\n     return output_movhi (insn, operands, NULL);\n   }\n@@ -936,12 +935,12 @@\n   [(set (match_operand:ALL4 0 \"nonimmediate_operand\" \"=r,r  ,r ,Qm   ,!d,r\")\n         (match_operand:ALL4 1 \"nox_general_operand\"   \"r,Y00,Qm,r Y00,i ,i\"))]\n   \"(register_operand (operands[0], <MODE>mode)\n-   || reg_or_0_operand (operands[1], <MODE>mode)) &&\n-   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n-   though access range is checked during define_expand, it is required\n-   here to avoid merging rtls during combine pass */\n-   tiny_valid_direct_memory_access_range(operands[0],SImode) &&\n-   tiny_valid_direct_memory_access_range(operands[1],SImode)\"\n+    || reg_or_0_operand (operands[1], <MODE>mode))\n+   /* Skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+      though access range is checked during define_expand, it is required\n+      here to avoid merging RTXes during combine pass.  */\n+   && tiny_valid_direct_memory_access_range (operands[0], SImode)\n+   && tiny_valid_direct_memory_access_range (operands[1], SImode)\"\n   {\n     return output_movsisf (insn, operands, NULL);\n   }\n@@ -956,12 +955,12 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n         (match_operand:SF 1 \"nox_general_operand\"   \"r,G,Qm,rG,F ,F\"))]\n   \"(register_operand (operands[0], SFmode)\n-   || reg_or_0_operand (operands[1], SFmode)) &&\n-   /* skip if operands are out of lds/sts memory access range(0x40..0xbf)\n-   though access range is checked during define_expand, it is required\n-   here to avoid merging rtls during combine pass */\n-   tiny_valid_direct_memory_access_range(operands[0],SFmode) &&\n-   tiny_valid_direct_memory_access_range(operands[1],SFmode)\"\n+    || reg_or_0_operand (operands[1], SFmode))\n+   /* Skip if operands are out of lds/sts memory access range(0x40..0xbf)\n+      though access range is checked during define_expand, it is required\n+      here to avoid merging rtls during combine pass.  */\n+   && tiny_valid_direct_memory_access_range (operands[0], SFmode)\n+   && tiny_valid_direct_memory_access_range (operands[1], SFmode)\"\n   {\n     return output_movsisf (insn, operands, NULL);\n   }\n@@ -2229,10 +2228,10 @@\n         DONE;\n       }\n \n-    /* For small constants we can do better by extending them on the fly.\n-       The constant can be loaded in one instruction and the widening\n-       multiplication is shorter.  First try the unsigned variant because it\n-       allows constraint \"d\" instead of \"a\" for the signed version.  */\n+    /* ; For small constants we can do better by extending them on the fly.\n+       ; The constant can be loaded in one instruction and the widening\n+       ; multiplication is shorter.  First try the unsigned variant because it\n+       ; allows constraint \"d\" instead of \"a\" for the signed version.  */\n \n     if (s9_operand (operands[2], HImode))\n       {\n@@ -3255,7 +3254,7 @@\n \tswap %0\\;lsl %0\\;adc %0,__zero_reg__\n \tswap %0\\;lsl %0\\;adc %0,__zero_reg__\\;lsl %0\\;adc %0,__zero_reg__\n \tbst %0,0\\;ror %0\\;bld %0,7\n-\t\"\n+\t\" ; empty\n   [(set_attr \"length\" \"2,4,4,1,3,5,3,0\")\n    (set_attr \"cc\" \"set_n,set_n,clobber,none,set_n,set_n,clobber,none\")])\n \n@@ -5059,7 +5058,7 @@\n       }\n     else\n       {\n-        operands[7] = gen_rtx_PLUS (HImode, operands[6], \n+        operands[7] = gen_rtx_PLUS (HImode, operands[6],\n                                     gen_rtx_LABEL_REF (VOIDmode, operands[3]));\n         operands[8] = const0_rtx;\n         operands[10] = operands[6];\n@@ -5611,7 +5610,7 @@\n    (clobber (match_scratch:QI 2 \"=&d\"))]\n   \"\"\n   \"ldi %2,lo8(%0)\n-\t1: dec %2\n+1:\tdec %2\n \tbrne 1b\"\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -5625,8 +5624,8 @@\n    (clobber (match_scratch:HI 2 \"=&w,&d\"))]\n   \"\"\n   \"@\n-    ldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\;1: sbiw %A2,1\\;brne 1b\n-    ldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\;1: subi %A2,1\\;sbci %B2,0\\;brne 1b\"\n+\tldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\n1:\tsbiw %A2,1\\;brne 1b\n+\tldi %A2,lo8(%0)\\;ldi %B2,hi8(%0)\\n1:\tsubi %A2,1\\;sbci %B2,0\\;brne 1b\"\n   [(set_attr \"length\" \"4,5\")\n    (set_attr \"isa\" \"no_tiny,tiny\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -5644,7 +5643,7 @@\n   \"ldi %2,lo8(%0)\n \tldi %3,hi8(%0)\n \tldi %4,hlo8(%0)\n-\t1: subi %2,1\n+1:\tsubi %2,1\n \tsbci %3,0\n \tsbci %4,0\n \tbrne 1b\"\n@@ -5666,7 +5665,7 @@\n \tldi %3,hi8(%0)\n \tldi %4,hlo8(%0)\n \tldi %5,hhi8(%0)\n-\t1: subi %2,1\n+1:\tsubi %2,1\n \tsbci %3,0\n \tsbci %4,0\n \tsbci %5,0"}]}