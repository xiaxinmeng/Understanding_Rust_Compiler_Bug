{"sha": "239a0f5ba54e5a19c4445835429ce113a68bebde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM5YTBmNWJhNTRlNWExOWM0NDQ1ODM1NDI5Y2UxMTNhNjhiZWJkZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-12-20T12:13:01Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-12-20T12:13:01Z"}, "message": "Change some regsets to regset_heads\n\nFrom-SVN: r31032", "tree": {"sha": "a57671669fbfd5657118b391b8d79c45adb0f729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a57671669fbfd5657118b391b8d79c45adb0f729"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/239a0f5ba54e5a19c4445835429ce113a68bebde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/239a0f5ba54e5a19c4445835429ce113a68bebde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/239a0f5ba54e5a19c4445835429ce113a68bebde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/239a0f5ba54e5a19c4445835429ce113a68bebde/comments", "author": null, "committer": null, "parents": [{"sha": "1af373f65c4b911f14e0b98d009d00e7c2ff2f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af373f65c4b911f14e0b98d009d00e7c2ff2f69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af373f65c4b911f14e0b98d009d00e7c2ff2f69"}], "stats": {"total": 99, "additions": 53, "deletions": 46}, "files": [{"sha": "74d0201b8e1f51ac712731bb3f813f6271967ea2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -1,3 +1,10 @@\n+1999-12-20  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload.h (struct insn_chain): Change live_throughout and dead_or_set\n+\tto be of type regset_head, not regset.  All users changed by adding\n+\taddress operator.\n+\t* reload1.c (new_insn_chain): Don't allocate regsets, just clear them.\n+\n 1999-12-20  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/rtems.h: New file."}, {"sha": "ada2935b2917e6800aea4011ccf59fd02ee1a401", "filename": "gcc/caller-save.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -379,9 +379,9 @@ save_call_clobbered_regs ()\n \t      /* Use the register life information in CHAIN to compute which\n \t\t regs are live during the call.  */\n \t      REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n-\t\t\t\t       chain->live_throughout);\n+\t\t\t\t       &chain->live_throughout);\n \t      compute_use_by_pseudos (&hard_regs_to_save,\n-\t\t\t\t      chain->live_throughout);\n+\t\t\t\t      &chain->live_throughout);\n \n \t      /* Record all registers set in this call insn.  These don't need\n \t\t to be saved.  N.B. the call insn might set a subreg of a\n@@ -618,7 +618,7 @@ insert_restore (chain, before_p, regno, maxrestore)\n   for (k = 0; k < i; k++)\n     {\n       CLEAR_HARD_REG_BIT (hard_regs_saved, regno + k);\n-      SET_REGNO_REG_SET (new->dead_or_set, regno + k);\n+      SET_REGNO_REG_SET (&new->dead_or_set, regno + k);\n       n_regs_saved--;\n     }\n \n@@ -687,7 +687,7 @@ insert_save (chain, before_p, regno, to_save)\n   for (k = 0; k < numregs; k++)\n     {\n       SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n-      SET_REGNO_REG_SET (new->dead_or_set, regno + k);\n+      SET_REGNO_REG_SET (&new->dead_or_set, regno + k);\n       n_regs_saved++;\n     }\n \n@@ -735,7 +735,7 @@ insert_one_insn (chain, before_p, code, pat)\n       new->insn = emit_insn_before (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets.  */\n-      COPY_REG_SET (new->live_throughout, chain->live_throughout);\n+      COPY_REG_SET (&new->live_throughout, &chain->live_throughout);\n       /* Registers that die in CHAIN->INSN still live in the new insn.  */\n       for (link = REG_NOTES (chain->insn); link; link = XEXP (link, 1))\n \t{\n@@ -754,10 +754,10 @@ insert_one_insn (chain, before_p, code, pat)\n \t\tcontinue;\n \t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n \t\t   i >= 0; i--)\n-\t\tSET_REGNO_REG_SET (new->live_throughout, regno + i);\n+\t\tSET_REGNO_REG_SET (&new->live_throughout, regno + i);\n \t    }\n \t}\n-      CLEAR_REG_SET (new->dead_or_set);\n+      CLEAR_REG_SET (&new->dead_or_set);\n       if (chain->insn == BLOCK_HEAD (chain->block))\n \tBLOCK_HEAD (chain->block) = new->insn;\n     }\n@@ -771,13 +771,13 @@ insert_one_insn (chain, before_p, code, pat)\n       new->insn = emit_insn_after (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets, and observe REG_UNUSED notes.  */\n-      COPY_REG_SET (new->live_throughout, chain->live_throughout);\n+      COPY_REG_SET (&new->live_throughout, &chain->live_throughout);\n       /* Registers that are set in CHAIN->INSN live in the new insn.\n          (Unless there is a REG_UNUSED note for them, but we don't\n \t  look for them here.) */\n       note_stores (PATTERN (chain->insn), add_stored_regs,\n-\t\t   new->live_throughout);\n-      CLEAR_REG_SET (new->dead_or_set);\n+\t\t   &new->live_throughout);\n+      CLEAR_REG_SET (&new->dead_or_set);\n       if (chain->insn == BLOCK_END (chain->block))\n \tBLOCK_END (chain->block) = new->insn;\n     }"}, {"sha": "420d91b308a3da0e074fec771d207ec98f2bc83e", "filename": "gcc/global.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -1743,15 +1743,15 @@ reg_dies (regno, mode, chain)\n \t{\n \t  CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n \t  if (! fixed_regs[regno])\n-\t    SET_REGNO_REG_SET (chain->dead_or_set, regno);\n+\t    SET_REGNO_REG_SET (&chain->dead_or_set, regno);\n \t  regno++;\n \t}\n     }\n   else\n     {\n       CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n       if (reg_renumber[regno] >= 0)\n-\tSET_REGNO_REG_SET (chain->dead_or_set, regno);\n+\tSET_REGNO_REG_SET (&chain->dead_or_set, regno);\n     }\n }\n \n@@ -1809,15 +1809,15 @@ build_insn_chain (first)\n \t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n \t\t\t    c);\n \n-\t      COPY_REG_SET (c->live_throughout, live_relevant_regs);\n+\t      COPY_REG_SET (&c->live_throughout, live_relevant_regs);\n \n \t      /* Mark everything born in this instruction as live.  */\n \n \t      note_stores (PATTERN (first), reg_becomes_live,\n-\t\t\t   c->dead_or_set);\n+\t\t\t   &c->dead_or_set);\n \t    }\n \t  else\n-\t    COPY_REG_SET (c->live_throughout, live_relevant_regs);\n+\t    COPY_REG_SET (&c->live_throughout, live_relevant_regs);\n \n \t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n \t    {"}, {"sha": "ebfdbc5f9d1447e61d81e711cafa1ba1ec47568f", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -225,8 +225,8 @@ struct insn_chain\n   rtx insn;\n   /* Register life information: record all live hard registers, and all\n      live pseudos that have a hard register.  */\n-  regset live_throughout;\n-  regset dead_or_set;\n+  regset_head live_throughout;\n+  regset_head dead_or_set;\n \n   /* Copies of the global variables computed by find_reloads.  */\n   struct reload *rld;"}, {"sha": "366a9a1d8694d7fd73d63383e35824e15de96ac5", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -514,8 +514,8 @@ new_insn_chain ()\n     {\n       c = (struct insn_chain *)\n \tobstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n-      c->live_throughout = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n-      c->dead_or_set = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n+      INIT_REG_SET (&c->live_throughout);\n+      INIT_REG_SET (&c->dead_or_set);\n     }\n   else\n     {\n@@ -1295,8 +1295,8 @@ maybe_fix_stack_asms ()\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (allowed, i))\n \t  {\n-\t    CLEAR_REGNO_REG_SET (chain->live_throughout, i);\n-\t    CLEAR_REGNO_REG_SET (chain->dead_or_set, i);\n+\t    CLEAR_REGNO_REG_SET (&chain->live_throughout, i);\n+\t    CLEAR_REGNO_REG_SET (&chain->dead_or_set, i);\n \t  }\n     }\n \n@@ -1516,21 +1516,21 @@ order_regs_for_reload (chain)\n       /* Test the various reasons why we can't use a register for\n \t spilling in this insn.  */\n       if (fixed_regs[i]\n-\t  || REGNO_REG_SET_P (chain->live_throughout, i)\n-\t  || REGNO_REG_SET_P (chain->dead_or_set, i))\n+\t  || REGNO_REG_SET_P (&chain->live_throughout, i)\n+\t  || REGNO_REG_SET_P (&chain->dead_or_set, i))\n \tSET_HARD_REG_BIT (bad_spill_regs, i);\n     }\n   /* Now find out which pseudos are allocated to it, and update\n      hard_reg_n_uses.  */\n   CLEAR_REG_SET (&pseudos_counted);\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n+    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_pseudo (j);\n      });\n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n+    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_pseudo (j);\n      });\n@@ -1645,12 +1645,12 @@ find_reg (chain, order, dumpfile)\n   rl->regno = best_reg;\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n+    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_spilled_pseudo (best_reg, rl->nregs, j);\n      });\n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n+    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_spilled_pseudo (best_reg, rl->nregs, j);\n      });\n@@ -3496,13 +3496,13 @@ finish_spills (global, dumpfile)\n       for (chain = insns_need_reload; chain; chain = chain->next_need_reload)\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (chain->live_throughout, FIRST_PSEUDO_REGISTER, i,\n+\t    (&chain->live_throughout, FIRST_PSEUDO_REGISTER, i,\n \t     {\n \t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n \t\t\t\t &chain->used_spill_regs);\n \t     });\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, i,\n+\t    (&chain->dead_or_set, FIRST_PSEUDO_REGISTER, i,\n \t     {\n \t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n \t\t\t\t &chain->used_spill_regs);\n@@ -3535,22 +3535,22 @@ finish_spills (global, dumpfile)\n       HARD_REG_SET used_by_pseudos;\n       HARD_REG_SET used_by_pseudos2;\n \n-      AND_COMPL_REG_SET (chain->live_throughout, &spilled_pseudos);\n-      AND_COMPL_REG_SET (chain->dead_or_set, &spilled_pseudos);\n+      AND_COMPL_REG_SET (&chain->live_throughout, &spilled_pseudos);\n+      AND_COMPL_REG_SET (&chain->dead_or_set, &spilled_pseudos);\n \n       /* Mark any unallocated hard regs as available for spills.  That\n \t makes inheritance work somewhat better.  */\n       if (chain->need_reload)\n \t{\n-\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos, chain->live_throughout);\n-\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, chain->dead_or_set);\n+\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos, &chain->live_throughout);\n+\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, &chain->dead_or_set);\n \t  IOR_HARD_REG_SET (used_by_pseudos, used_by_pseudos2);\n \n \t  /* Save the old value for the sanity test below.  */\n \t  COPY_HARD_REG_SET (used_by_pseudos2, chain->used_spill_regs);\n \n-\t  compute_use_by_pseudos (&used_by_pseudos, chain->live_throughout);\n-\t  compute_use_by_pseudos (&used_by_pseudos, chain->dead_or_set);\n+\t  compute_use_by_pseudos (&used_by_pseudos, &chain->live_throughout);\n+\t  compute_use_by_pseudos (&used_by_pseudos, &chain->dead_or_set);\n \t  COMPL_HARD_REG_SET (chain->used_spill_regs, used_by_pseudos);\n \t  AND_HARD_REG_SET (chain->used_spill_regs, used_spill_regs);\n \n@@ -5040,12 +5040,12 @@ choose_reload_regs_init (chain, save_reload_reg_rtx)\n   CLEAR_HARD_REG_SET (reg_used_in_insn);\n   {\n     HARD_REG_SET tmp;\n-    REG_SET_TO_HARD_REG_SET (tmp, chain->live_throughout);\n+    REG_SET_TO_HARD_REG_SET (tmp, &chain->live_throughout);\n     IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n-    REG_SET_TO_HARD_REG_SET (tmp, chain->dead_or_set);\n+    REG_SET_TO_HARD_REG_SET (tmp, &chain->dead_or_set);\n     IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n-    compute_use_by_pseudos (&reg_used_in_insn, chain->live_throughout);\n-    compute_use_by_pseudos (&reg_used_in_insn, chain->dead_or_set);\n+    compute_use_by_pseudos (&reg_used_in_insn, &chain->live_throughout);\n+    compute_use_by_pseudos (&reg_used_in_insn, &chain->dead_or_set);\n   }\n   for (i = 0; i < reload_n_operands; i++)\n     {"}, {"sha": "e5727735d1e609f8547e355b5549e5b7d8ce92d6", "filename": "gcc/stupid.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/239a0f5ba54e5a19c4445835429ce113a68bebde/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=239a0f5ba54e5a19c4445835429ce113a68bebde", "patch": "@@ -162,7 +162,7 @@ find_clobbered_regs (reg, setter, data)\n     nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n   while (nregs-- > 0)\n     {\n-      SET_REGNO_REG_SET (current_chain->live_throughout, regno++);\n+      SET_REGNO_REG_SET (&current_chain->live_throughout, regno++);\n     }\n }\n \f\n@@ -285,7 +285,7 @@ stupid_life_analysis (f, nregs, file)\n \t  chain->insn = insn;\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    if (regs_live[i])\n-\t      SET_REGNO_REG_SET (chain->live_throughout, i);\n+\t      SET_REGNO_REG_SET (&chain->live_throughout, i);\n \t}\n \n       /* Update which hard regs are currently live\n@@ -403,14 +403,14 @@ stupid_life_analysis (f, nregs, file)\n \tcontinue;\n \n       chain = reg_where_dead_chain[i];\n-      SET_REGNO_REG_SET (chain->dead_or_set, i);\n+      SET_REGNO_REG_SET (&chain->dead_or_set, i);\n \n       while ((chain = chain->prev)\n \t     && INSN_SUID (chain->insn) > reg_where_born_exact[i])\n-\tSET_REGNO_REG_SET (chain->live_throughout, i);\n+\tSET_REGNO_REG_SET (&chain->live_throughout, i);\n \n       if (chain)\n-\tSET_REGNO_REG_SET (chain->dead_or_set, i);\n+\tSET_REGNO_REG_SET (&chain->dead_or_set, i);\n     }\n \n   if (file)\n@@ -577,7 +577,7 @@ mark_hard_ref (reg, live_before_p, chain)\n     {\n       if (! fixed_regs[regno+j]\n \t  && (! live_before_p || ! live[regno+j]))\n-\tSET_REGNO_REG_SET (chain->dead_or_set, regno+j);\n+\tSET_REGNO_REG_SET (&chain->dead_or_set, regno+j);\n       regs_ever_live[regno+j] = 1;\n       live[regno+j] = live_before_p;\n     }\n@@ -634,7 +634,7 @@ stupid_mark_refs (x, chain)\n \t\t     they do get stored even though never used again.  */\n \t\t  MARK_LIVE_AFTER (insn, regno+j);\n \n-\t\t  CLEAR_REGNO_REG_SET (chain->live_throughout, regno + j);\n+\t\t  CLEAR_REGNO_REG_SET (&chain->live_throughout, regno + j);\n \n \t\t  /* When a hard reg is clobbered, mark it in use\n \t\t     just before this insn, so it is live all through.  */"}]}