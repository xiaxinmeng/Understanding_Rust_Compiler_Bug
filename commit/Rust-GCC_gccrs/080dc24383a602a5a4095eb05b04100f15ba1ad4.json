{"sha": "080dc24383a602a5a4095eb05b04100f15ba1ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgwZGMyNDM4M2E2MDJhNWE0MDk1ZWIwNWIwNDEwMGYxNWJhMWFkNA==", "commit": {"author": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "visit0r@gcc.gnu.org", "date": "2018-05-04T19:43:57Z"}, "committer": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "visit0r@gcc.gnu.org", "date": "2018-05-04T19:43:57Z"}, "message": "[BRIGFE] phsa-specific optimizations\n\nAdd flag -fassume-phsa that is on by default. If -fno-assume-phsa\nis given, these optimizations are disabled.\n\nWith this flag, gccbrig can generate GENERIC that assumes we are\ntargeting a phsa-runtime based implementation, which allows us\nto expose the work-item context accesses to retrieve WI IDs etc.\nwhich helps optimizers.\n\nFirst optimization that takes advantage of this is to get rid of\nthe setworkitemid calls whenever we have non-inlined calls that\nuse IDs internally.\n\nOther optimizations added in this commit:\n\n- expand absoluteid to similar level of simplicity as workitemid.\nAt the moment absoluteid is the best indexing ID to end up with\nWG vectorization.\n- propagate ID variables closer to their uses. This is mainly\nto avoid known useless casts, which confuse at least scalar\nevolution analysis.\n- use signed long long for storing IDs. Unsigned integers have\ndefined wraparound semantics, which confuse at least scalar\nevolution analysis, leading to unvectorizable WI loops.\n- also refactor some BRIG function generation helpers to brig_function.\n- no point in having the wi-loop as a for-loop. It's really\na do...while and SCEV can analyze it just fine still.\n- add consts to ptrs etc. in BRIG builtin defs.\nImproves optimization opportunities.\n- add qualifiers to generated function parameters.\nConst and restrict on the hidden local/private pointers,\nthe arg buffer and the context pointer help some optimizations.\n\nFrom-SVN: r259957", "tree": {"sha": "a0d2a78948f718293527ac76c53bdee3303d989f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0d2a78948f718293527ac76c53bdee3303d989f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/080dc24383a602a5a4095eb05b04100f15ba1ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/080dc24383a602a5a4095eb05b04100f15ba1ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/080dc24383a602a5a4095eb05b04100f15ba1ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/080dc24383a602a5a4095eb05b04100f15ba1ad4/comments", "author": null, "committer": null, "parents": [{"sha": "1e25c5a9bb7042d7bca5a4fa840666dcb16f4918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e25c5a9bb7042d7bca5a4fa840666dcb16f4918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e25c5a9bb7042d7bca5a4fa840666dcb16f4918"}], "stats": {"total": 2071, "additions": 1257, "deletions": 814}, "files": [{"sha": "47862a80a0dc62d8337a073fd56f3ca9b2f52448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -1,3 +1,9 @@\n+2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* brig-builtins.def: Add consts to ptrs etc. in BRIG builtin defs.\n+\tTo improve optimization opportunities.\n+\t* builtin-types.def: The new needed builtin types for the above.\n+\n 2018-05-04  Richard Biener  <rguenther@suse.de>\n \n \t* bb-reorder.c (sanitize_hot_paths): Release hot_bbs_to_check."}, {"sha": "c2e8d2c034d7b538b4a826a4641ce2034a6b4c33", "filename": "gcc/brig-builtins.def", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig-builtins.def?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -45,25 +45,25 @@ DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_GRIDSIZE, BRIG_OPCODE_GRIDSIZE,\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U32,\n \t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U32,\n-\t\t  \"__hsail_workitemflatabsid_u32\", BT_FN_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\t\t  \"__hsail_workitemflatabsid_u32\", BT_FN_UINT_CONST_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATABSID_U64,\n \t\t  BRIG_OPCODE_WORKITEMFLATABSID, BRIG_TYPE_U64,\n-\t\t  \"__hsail_workitemflatabsid_u64\", BT_FN_ULONG_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\t\t  \"__hsail_workitemflatabsid_u64\", BT_FN_ULONG_CONST_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMFLATID, BRIG_OPCODE_WORKITEMFLATID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workitemflatid\", BT_FN_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\t\t  BRIG_TYPE_U32, \"__hsail_workitemflatid\", BT_FN_UINT_CONST_PTR,\n+\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKITEMID, BRIG_OPCODE_WORKITEMID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workitemid\", BT_FN_UINT_UINT_PTR,\n-\t\t  ATTR_NOTHROW_LEAF_LIST)\n+\t\t  BRIG_TYPE_U32, \"__hsail_workitemid\",\n+\t\t  BT_FN_UINT_UINT_CONST_PTR, ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPID, BRIG_OPCODE_WORKGROUPID,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workgroupid\", BT_FN_UINT_UINT_PTR,\n-\t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n+\t\t  BRIG_TYPE_U32, \"__hsail_workgroupid\",\n+\t\t  BT_FN_UINT_UINT_CONST_PTR, ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKITEMFLATID,\n \t\t  BRIG_OPCODE_CURRENTWORKITEMFLATID,\n@@ -90,11 +90,12 @@ DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_PACKETCOMPLETIONSIG_SIG32,\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE,\n \t\t  BRIG_OPCODE_CURRENTWORKGROUPSIZE, BRIG_TYPE_U32,\n-\t\t  \"__hsail_currentworkgroupsize\", BT_FN_UINT_UINT_PTR,\n+\t\t  \"__hsail_currentworkgroupsize\", BT_FN_UINT_UINT_CONST_PTR,\n \t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_WORKGROUPSIZE, BRIG_OPCODE_WORKGROUPSIZE,\n-\t\t  BRIG_TYPE_U32, \"__hsail_workgroupsize\", BT_FN_UINT_UINT_PTR,\n+\t\t  BRIG_TYPE_U32, \"__hsail_workgroupsize\",\n+\t\t  BT_FN_UINT_UINT_CONST_PTR,\n \t\t  ATTR_PURE_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_BUILTIN (BUILT_IN_HSAIL_DIM, BRIG_OPCODE_DIM,\n@@ -565,7 +566,7 @@ DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_SETWORKITEMID, \"__hsail_setworkitemid\",\n \n DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_WG_FUNC,\n \t\t       \"__hsail_launch_wg_function\",\n-\t\t       BT_FN_VOID_PTR_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\t\t       BT_FN_VOID_PTR_PTR_UINT32, ATTR_NOTHROW_LEAF_LIST)\n \n DEF_HSAIL_INTR_BUILTIN (BUILT_IN_HSAIL_LAUNCH_KERNEL,\n \t\t       \"__hsail_launch_kernel\","}, {"sha": "ce4aea615eb54cb6acaa2f8922d4755f2031faf4", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -1,3 +1,46 @@\n+2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\tAdd flag -fassume-phsa that is on by default. If -fno-assume-phsa\n+\tis given, these optimizations are disabled.  With this flag, gccbrig\n+\tcan generate GENERIC that assumes we are targeting a phsa-runtime\n+\tbased implementation, which allows us to expose the work-item context\n+\taccesses to retrieve WI IDs etc.  which helps optimizers.\n+\tFirst optimization that takes advantage of this is to get rid of\n+\tthe setworkitemid calls whenever we have non-inlined calls that\n+\tuse IDs internally.  Other optimizations added in this commit:\n+\t- expand absoluteid to similar level of simplicity as workitemid.\n+\tAt the moment absoluteid is the best indexing ID to end up with\n+\tWG vectorization.\n+\t- propagate ID variables closer to their uses. This is mainly\n+\tto avoid known useless casts, which confuse at least scalar\n+\tevolution analysis.\n+\t- use signed long long for storing IDs. Unsigned integers have\n+\tdefined wraparound semantics, which confuse at least scalar\n+\tevolution analysis, leading to unvectorizable WI loops.\n+\t- also refactor some BRIG function generation helpers to brig_function.\n+\t- no point in having the wi-loop as a for-loop. It's really\n+\ta do...while and SCEV can analyze it just fine still.\n+\t- add consts to ptrs etc. in BRIG builtin defs.\n+\tImproves optimization opportunities.\n+\t- add qualifiers to generated function parameters.\n+\tConst and restrict on the hidden local/private pointers,\n+\tthe arg buffer and the context pointer help some optimizations.\n+\t* brig/brigfrontend/brig-basic-inst-handler.cc: See above.\n+\t* brig/brigfrontend/brig-branch-inst-handler.cc: See above.\n+\t* brig/brigfrontend/brig-cmp-inst-handler.cc: See above.\n+\t* brig/brigfrontend/brig-code-entry-handler.cc: See above.\n+\t* brig/brigfrontend/brig-code-entry-handler.h: See above.\n+\t* brig/brigfrontend/brig-control-handler.cc: See above.\n+\t* brig/brigfrontend/brig-cvt-inst-handler.cc: See above.\n+\t* brig/brigfrontend/brig-function-handler.cc: See above.\n+\t* brig/brigfrontend/brig-function.cc: See above.\n+\t* brig/brigfrontend/brig-function.h: See above.\n+\t* brig/brigfrontend/brig-label-handler.cc: See above.\n+\t* brig/brigfrontend/brig-lane-inst-handler.cc: See above.\n+\t* brig/brigfrontend/brig-mem-inst-handler.cc: See above.\n+\t* brig/brigfrontend/phsa.h: See above.\n+\t* brig/lang.opt: See above.\n+\n 2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* brig/brigfrontend/brig-function-handler.cc: Skip multiple forward"}, {"sha": "c8224ae6a51209c7b7f4b76983a0a3f2e46f6823", "filename": "gcc/brig/brigfrontend/brig-basic-inst-handler.cc", "status": "modified", "additions": 20, "deletions": 152, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -105,7 +105,8 @@ brig_basic_inst_handler::build_shuffle (tree arith_type,\n   /* Unpack the tightly packed mask elements to BIT_FIELD_REFs\n      from which to construct the mask vector as understood by\n      VEC_PERM_EXPR.  */\n-  tree mask_operand = add_temp_var (\"shuffle_mask\", operands[2]);\n+  tree mask_operand\n+    = m_parent.m_cf->add_temp_var (\"shuffle_mask\", operands[2]);\n \n   tree mask_element_type\n     = build_nonstandard_integer_type (input_mask_element_size, true);\n@@ -219,32 +220,34 @@ brig_basic_inst_handler::build_pack (tree_stl_vec &operands)\n   tree wide_type = build_nonstandard_integer_type (vecsize, 1);\n \n   tree src_vect = build_resize_convert_view (wide_type, operands[0]);\n-  src_vect = add_temp_var (\"src_vect\", src_vect);\n+  src_vect = m_parent.m_cf->add_temp_var (\"src_vect\", src_vect);\n \n   tree scalar = operands[1];\n-  scalar = add_temp_var (\"scalar\", convert_to_integer (wide_type, scalar));\n+  scalar = m_parent.m_cf->add_temp_var (\"scalar\",\n+\t\t\t\t\tconvert_to_integer (wide_type, scalar));\n \n   tree pos = operands[2];\n \n   /* The upper bits of the position can contain garbage.\n      Zero them for well-defined semantics.  */\n   tree t = build2 (BIT_AND_EXPR, TREE_TYPE (pos), operands[2],\n \t\t   build_int_cstu (TREE_TYPE (pos), ecount - 1));\n-  pos = add_temp_var (\"pos\", convert (wide_type, t));\n+  pos = m_parent.m_cf->add_temp_var (\"pos\", convert (wide_type, t));\n \n   tree element_type = TREE_TYPE (TREE_TYPE (operands[0]));\n   size_t element_width = int_size_in_bytes (element_type) * BITS_PER_UNIT;\n   tree ewidth = build_int_cstu (wide_type, element_width);\n \n   tree bitoffset = build2 (MULT_EXPR, wide_type, ewidth, pos);\n-  bitoffset = add_temp_var (\"offset\", bitoffset);\n+  bitoffset = m_parent.m_cf->add_temp_var (\"offset\", bitoffset);\n \n   uint64_t mask_int\n     = element_width == 64 ? (uint64_t) -1 : ((uint64_t) 1 << element_width) - 1;\n \n   tree mask = build_int_cstu (wide_type, mask_int);\n \n-  mask = add_temp_var (\"mask\", convert_to_integer (wide_type, mask));\n+  mask = m_parent.m_cf->add_temp_var (\"mask\",\n+\t\t\t\t      convert_to_integer (wide_type, mask));\n \n   tree clearing_mask\n     = build1 (BIT_NOT_EXPR, wide_type,\n@@ -311,7 +314,8 @@ brig_basic_inst_handler::build_inst_expr (BrigOpcode16_t brig_opcode,\n \t\t\t\t\t  tree arith_type,\n \t\t\t\t\t  tree_stl_vec &operands)\n {\n-  tree_code opcode = get_tree_code_for_hsa_opcode (brig_opcode, brig_type);\n+  tree_code opcode\n+    = brig_function::get_tree_code_for_hsa_opcode (brig_opcode, brig_type);\n \n   BrigType16_t inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n \n@@ -388,8 +392,8 @@ brig_basic_inst_handler::build_inst_expr (BrigOpcode16_t brig_opcode,\n \t     on which cannot be used in general to remain HSAIL compliant.\n \t     Perhaps a builtin call would be better option here.  */\n \t  return build2 (RDIV_EXPR, arith_type, build_one_cst (arith_type),\n-\t\t\t expand_or_call_builtin (BRIG_OPCODE_SQRT, brig_type,\n-\t\t\t\t\t\t arith_type, operands));\n+\t\t\t m_parent.m_cf->expand_or_call_builtin\n+\t\t\t (BRIG_OPCODE_SQRT, brig_type, arith_type, operands));\n \t}\n       else if (brig_opcode == BRIG_OPCODE_NRCP)\n \t{\n@@ -410,8 +414,8 @@ brig_basic_inst_handler::build_inst_expr (BrigOpcode16_t brig_opcode,\n \tgcc_unreachable ();\n     }\n   else if (opcode == CALL_EXPR)\n-    return expand_or_call_builtin (brig_opcode, brig_type, arith_type,\n-\t\t\t\t   operands);\n+    return m_parent.m_cf->expand_or_call_builtin (brig_opcode, brig_type,\n+\t\t\t\t\t\t  arith_type, operands);\n   else if (output_count == 1)\n     {\n       if (input_count == 1)\n@@ -520,7 +524,8 @@ brig_basic_inst_handler::operator () (const BrigBase *base)\n     in_operands[0] = build_lower_element_broadcast (in_operands[0]);\n \n   tree_code opcode\n-    = get_tree_code_for_hsa_opcode (brig_inst->opcode, brig_inst_type);\n+    = brig_function::get_tree_code_for_hsa_opcode (brig_inst->opcode,\n+\t\t\t\t\t\t   brig_inst_type);\n \n   if (p >= BRIG_PACK_PPSAT && p <= BRIG_PACK_PSAT)\n     {\n@@ -566,11 +571,11 @@ brig_basic_inst_handler::operator () (const BrigBase *base)\n       */\n       tree_stl_vec operand0_elements;\n       if (input_count > 0)\n-\tunpack (in_operands[0], operand0_elements);\n+\tm_parent.m_cf->unpack (in_operands[0], operand0_elements);\n \n       tree_stl_vec operand1_elements;\n       if (input_count > 1)\n-\tunpack (in_operands[1], operand1_elements);\n+\tm_parent.m_cf->unpack (in_operands[1], operand1_elements);\n \n       tree_stl_vec result_elements;\n \n@@ -617,7 +622,7 @@ brig_basic_inst_handler::operator () (const BrigBase *base)\n \n \t  result_elements.push_back (convert (scalar_type, scalar_expr));\n \t}\n-      instr_expr = pack (result_elements);\n+      instr_expr = m_parent.m_cf->pack (result_elements);\n     }\n   else\n     {\n@@ -728,140 +733,3 @@ brig_basic_inst_handler::build_lower_element_broadcast (tree vec_operand)\n \t\t vec_operand, mask);\n }\n \n-/* Returns the tree code that should be used to implement the given\n-   HSA instruction opcode (BRIG_OPCODE) for the given type of instruction\n-   (BRIG_TYPE).  In case the opcode cannot be mapped to a TREE node directly,\n-   returns TREE_LIST (if it can be emulated with a simple chain of tree\n-   nodes) or CALL_EXPR if the opcode should be implemented using a builtin\n-   call.  */\n-\n-tree_code\n-brig_basic_inst_handler::get_tree_code_for_hsa_opcode\n-  (BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n-{\n-  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_NOP:\n-      return NOP_EXPR;\n-    case BRIG_OPCODE_ADD:\n-      return PLUS_EXPR;\n-    case BRIG_OPCODE_CMOV:\n-      if (brig_inner_type == brig_type)\n-\treturn COND_EXPR;\n-      else\n-\treturn VEC_COND_EXPR;\n-    case BRIG_OPCODE_SUB:\n-      return MINUS_EXPR;\n-    case BRIG_OPCODE_MUL:\n-    case BRIG_OPCODE_MUL24:\n-      return MULT_EXPR;\n-    case BRIG_OPCODE_MULHI:\n-    case BRIG_OPCODE_MUL24HI:\n-      return MULT_HIGHPART_EXPR;\n-    case BRIG_OPCODE_DIV:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn RDIV_EXPR;\n-      else\n-\treturn TRUNC_DIV_EXPR;\n-    case BRIG_OPCODE_NEG:\n-      return NEGATE_EXPR;\n-    case BRIG_OPCODE_MIN:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn CALL_EXPR;\n-      else\n-\treturn MIN_EXPR;\n-    case BRIG_OPCODE_MAX:\n-      if (gccbrig_is_float_type (brig_inner_type))\n-\treturn CALL_EXPR;\n-      else\n-\treturn MAX_EXPR;\n-    case BRIG_OPCODE_FMA:\n-      return FMA_EXPR;\n-    case BRIG_OPCODE_ABS:\n-      return ABS_EXPR;\n-    case BRIG_OPCODE_SHL:\n-      return LSHIFT_EXPR;\n-    case BRIG_OPCODE_SHR:\n-      return RSHIFT_EXPR;\n-    case BRIG_OPCODE_OR:\n-      return BIT_IOR_EXPR;\n-    case BRIG_OPCODE_XOR:\n-      return BIT_XOR_EXPR;\n-    case BRIG_OPCODE_AND:\n-      return BIT_AND_EXPR;\n-    case BRIG_OPCODE_NOT:\n-      return BIT_NOT_EXPR;\n-    case BRIG_OPCODE_RET:\n-      return RETURN_EXPR;\n-    case BRIG_OPCODE_MOV:\n-    case BRIG_OPCODE_LDF:\n-      return MODIFY_EXPR;\n-    case BRIG_OPCODE_LD:\n-    case BRIG_OPCODE_ST:\n-      return MEM_REF;\n-    case BRIG_OPCODE_BR:\n-      return GOTO_EXPR;\n-    case BRIG_OPCODE_REM:\n-      if (brig_type == BRIG_TYPE_U64 || brig_type == BRIG_TYPE_U32)\n-\treturn TRUNC_MOD_EXPR;\n-      else\n-\treturn CALL_EXPR;\n-    case BRIG_OPCODE_NRCP:\n-    case BRIG_OPCODE_NRSQRT:\n-      /* Implement as 1/f (x).  gcc should pattern detect that and\n-\t use a native instruction, if available, for it.  */\n-      return TREE_LIST;\n-    case BRIG_OPCODE_FLOOR:\n-    case BRIG_OPCODE_CEIL:\n-    case BRIG_OPCODE_SQRT:\n-    case BRIG_OPCODE_NSQRT:\n-    case BRIG_OPCODE_RINT:\n-    case BRIG_OPCODE_TRUNC:\n-    case BRIG_OPCODE_POPCOUNT:\n-    case BRIG_OPCODE_COPYSIGN:\n-    case BRIG_OPCODE_NCOS:\n-    case BRIG_OPCODE_NSIN:\n-    case BRIG_OPCODE_NLOG2:\n-    case BRIG_OPCODE_NEXP2:\n-    case BRIG_OPCODE_NFMA:\n-      /* Class has type B1 regardless of the float type, thus\n-\t the below builtin map search cannot find it.  */\n-    case BRIG_OPCODE_CLASS:\n-    case BRIG_OPCODE_WORKITEMABSID:\n-      return CALL_EXPR;\n-    default:\n-\n-      /* Some BRIG opcodes can use the same builtins for unsigned and\n-\t signed types.  Force these cases to unsigned types.\n-      */\n-\n-      if (brig_opcode == BRIG_OPCODE_BORROW\n-\t  || brig_opcode == BRIG_OPCODE_CARRY\n-\t  || brig_opcode == BRIG_OPCODE_LASTBIT\n-\t  || brig_opcode == BRIG_OPCODE_BITINSERT)\n-\t{\n-\t  if (brig_type == BRIG_TYPE_S32)\n-\t    brig_type = BRIG_TYPE_U32;\n-\t  else if (brig_type == BRIG_TYPE_S64)\n-\t    brig_type = BRIG_TYPE_U64;\n-\t}\n-\n-\n-      builtin_map::const_iterator i\n-\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n-      if (i != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      else if (s_custom_builtins.find\n-\t       (std::make_pair (brig_opcode, brig_inner_type))\n-\t       != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      if (brig_inner_type == BRIG_TYPE_F16\n-\t  && s_custom_builtins.find\n-\t  (std::make_pair (brig_opcode, BRIG_TYPE_F32))\n-\t  != s_custom_builtins.end ())\n-\treturn CALL_EXPR;\n-      break;\n-    }\n-  return TREE_LIST; /* Emulate using a chain of nodes.  */\n-}"}, {"sha": "b6baf13711b88243aba0b4289019701687205c1d", "filename": "gcc/brig/brigfrontend/brig-branch-inst-handler.cc", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -119,10 +119,11 @@ brig_branch_inst_handler::operator () (const BrigBase *base)\n \t memory.  */\n \n       tree group_local_offset\n-\t= add_temp_var (\"group_local_offset\",\n-\t\t\tbuild_int_cst\n-\t\t\t(uint32_type_node,\n-\t\t\t m_parent.m_cf->m_local_group_variables.size()));\n+\t= m_parent.m_cf->add_temp_var (\"group_local_offset\",\n+\t\t\t\t       build_int_cst\n+\t\t\t\t       (uint32_type_node,\n+\t\t\t\t\tm_parent.m_cf->\n+\t\t\t\t\tm_local_group_variables.size()));\n \n       /* TODO: ensure the callee's frame is aligned!  */\n \n@@ -152,6 +153,7 @@ brig_branch_inst_handler::operator () (const BrigBase *base)\n       m_parent.m_cf->m_called_functions.push_back (func_ref);\n       if (DECL_EXTERNAL (func_ref))\n \tm_parent.add_decl_call (call);\n+      m_parent.m_cf->start_new_bb ();\n \n       return base->byteCount;\n     }\n@@ -216,18 +218,21 @@ brig_branch_inst_handler::operator () (const BrigBase *base)\n \t ensure the barrier won't be duplicated or moved out of loops etc.\n \t Like the 'noduplicate' of LLVM.  Same goes for fbarriers.  */\n       m_parent.m_cf->append_statement\n-\t(expand_or_call_builtin (brig_inst->opcode, BRIG_TYPE_NONE, NULL_TREE,\n-\t\t\t\t call_operands));\n+\t(m_parent.m_cf->expand_or_call_builtin (brig_inst->opcode,\n+\t\t\t\t\t\tBRIG_TYPE_NONE, NULL_TREE,\n+\t\t\t\t\t\tcall_operands));\n     }\n   else if (brig_inst->opcode >= BRIG_OPCODE_ARRIVEFBAR\n \t   && brig_inst->opcode <= BRIG_OPCODE_WAITFBAR)\n     {\n       m_parent.m_cf->m_has_barriers = true;\n       m_parent.m_cf->append_statement\n-\t(expand_or_call_builtin (brig_inst->opcode, BRIG_TYPE_NONE,\n-\t\t\t\t uint32_type_node, operands));\n+\t(m_parent.m_cf->expand_or_call_builtin (brig_inst->opcode,\n+\t\t\t\t\t\tBRIG_TYPE_NONE,\n+\t\t\t\t\t\tuint32_type_node, operands));\n     }\n   else\n     gcc_unreachable ();\n+  m_parent.m_cf->start_new_bb ();\n   return base->byteCount;\n }"}, {"sha": "729e3fd0b226b6eccf58007ac69bea805c2513b8", "filename": "gcc/brig/brigfrontend/brig-cmp-inst-handler.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cmp-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -180,17 +180,17 @@ brig_cmp_inst_handler::operator () (const BrigBase *base)\n \t results, we must now truncate the result vector to S16s so it\n \t fits to the destination register.  We can build the target vector\n \t type from the f16 storage type (unsigned ints).  */\n-      expr = add_temp_var (\"wide_cmp_result\", expr);\n+      expr = m_parent.m_cf->add_temp_var (\"wide_cmp_result\", expr);\n       tree_stl_vec wide_elements;\n       tree_stl_vec shrunk_elements;\n-      unpack (expr, wide_elements);\n+      m_parent.m_cf->unpack (expr, wide_elements);\n       for (size_t i = 0; i < wide_elements.size (); ++i)\n \t{\n \t  tree wide = wide_elements.at (i);\n \t  shrunk_elements.push_back\n \t    (convert_to_integer (short_integer_type_node, wide));\n \t}\n-      expr = pack (shrunk_elements);\n+      expr = m_parent.m_cf->pack (shrunk_elements);\n     }\n   build_output_assignment (*inst_base, operands[0], expr);\n "}, {"sha": "4fa37fd7a4b0940dc7434691a94e26a741168ee6", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.cc", "status": "modified", "additions": 24, "deletions": 479, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -41,24 +41,9 @@\n #include \"brig-builtins.h\"\n #include \"fold-const.h\"\n \n-brig_code_entry_handler::builtin_map brig_code_entry_handler::s_custom_builtins;\n-\n brig_code_entry_handler::brig_code_entry_handler (brig_to_generic &parent)\n   : brig_entry_handler (parent)\n {\n-  if (s_custom_builtins.size () > 0) return;\n-\n-  /* Populate the builtin index.  */\n-#undef DEF_HSAIL_ATOMIC_BUILTIN\n-#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n-#undef DEF_HSAIL_INTR_BUILTIN\n-#undef DEF_HSAIL_SAT_BUILTIN\n-#undef DEF_HSAIL_BUILTIN\n-#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n-  s_custom_builtins[std::make_pair (HSAIL_OPCODE, HSAIL_TYPE)]\t\t\\\n-    = builtin_decl_explicit (ENUM);\n-\n-#include \"brig-builtins.def\"\n }\n \n /* Build a tree operand which is a reference to a piece of code.  REF is the\n@@ -301,18 +286,18 @@ brig_code_entry_handler::build_address_operand\n \n \t  tree local_size\n \t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n-\t\t\t\t\t      BRIG_TYPE_U32,\n-\t\t\t\t\t      uint32_type_node, uint32_0),\n-\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n-\t\t\t\t\t      BRIG_TYPE_U32,\n-\t\t\t\t\t      uint32_type_node, uint32_1));\n+\t\t      m_parent.m_cf->expand_or_call_builtin\n+\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n+\t\t       uint32_type_node, uint32_0),\n+\t\t      m_parent.m_cf->expand_or_call_builtin\n+\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n+\t\t       uint32_type_node, uint32_1));\n \n \t  local_size\n \t    = build2 (MULT_EXPR, uint32_type_node,\n-\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE,\n-\t\t\t\t\t      BRIG_TYPE_U32,\n-\t\t\t\t\t      uint32_type_node, uint32_2),\n+\t\t      m_parent.m_cf->expand_or_call_builtin\n+\t\t      (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n+\t\t       uint32_type_node, uint32_2),\n \t\t      local_size);\n \n \t  tree var_region\n@@ -324,9 +309,9 @@ brig_code_entry_handler::build_address_operand\n \t    = build2 (MULT_EXPR, uint32_type_node,\n \t\t      build_int_cst (uint32_type_node,\n \t\t\t\t     m_parent.private_variable_size (var_name)),\n-\t\t      expand_or_call_builtin (BRIG_OPCODE_WORKITEMFLATID,\n-\t\t\t\t\t      BRIG_TYPE_U32,\n-\t\t\t\t\t      uint32_type_node, operands));\n+\t\t      m_parent.m_cf->expand_or_call_builtin\n+\t\t      (BRIG_OPCODE_WORKITEMFLATID, BRIG_TYPE_U32,\n+\t\t       uint32_type_node, operands));\n \n \t  tree var_offset\n \t    = build2 (PLUS_EXPR, uint32_type_node, var_region, pos);\n@@ -336,8 +321,9 @@ brig_code_entry_handler::build_address_operand\n \t     offset to a flat address by adding it as an offset to a (private\n \t     or group) base pointer later on.  Same applies to group_var_offset.  */\n \t  symbol_base\n-\t    = add_temp_var (\"priv_var_offset\",\n-\t\t\t    convert (size_type_node, var_offset));\n+\t    = m_parent.m_cf->add_temp_var (\"priv_var_offset\",\n+\t\t\t\t\t   convert (size_type_node,\n+\t\t\t\t\t\t    var_offset));\n \t}\n       else if (segment == BRIG_SEGMENT_ARG)\n \t{\n@@ -699,138 +685,6 @@ brig_code_entry_handler::get_tree_expr_type_for_hsa_type\n     return gccbrig_tree_type_for_hsa_type (brig_type);\n }\n \n-/* In case the HSA instruction must be implemented using a builtin,\n-   this function is called to get the correct builtin function.\n-   TYPE is the instruction tree type, BRIG_OPCODE the opcode of the\n-   brig instruction and BRIG_TYPE the brig instruction's type.  */\n-\n-tree\n-brig_code_entry_handler::get_builtin_for_hsa_opcode\n-  (tree type, BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n-{\n-  tree builtin = NULL_TREE;\n-  tree builtin_type = type;\n-\n-  /* For vector types, first find the scalar version of the builtin.  */\n-  if (type != NULL_TREE && VECTOR_TYPE_P (type))\n-    builtin_type = TREE_TYPE (type);\n-  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n-\n-  /* Some BRIG opcodes can use the same builtins for unsigned and\n-     signed types.  Force these cases to unsigned types.  */\n-\n-  if (brig_opcode == BRIG_OPCODE_BORROW\n-      || brig_opcode == BRIG_OPCODE_CARRY\n-      || brig_opcode == BRIG_OPCODE_LASTBIT\n-      || brig_opcode == BRIG_OPCODE_BITINSERT)\n-    {\n-      if (brig_type == BRIG_TYPE_S32)\n-\tbrig_type = BRIG_TYPE_U32;\n-      else if (brig_type == BRIG_TYPE_S64)\n-\tbrig_type = BRIG_TYPE_U64;\n-    }\n-\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_FLOOR:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_FLOOR);\n-      break;\n-    case BRIG_OPCODE_CEIL:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_CEIL);\n-      break;\n-    case BRIG_OPCODE_SQRT:\n-    case BRIG_OPCODE_NSQRT:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_SQRT);\n-      break;\n-    case BRIG_OPCODE_RINT:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_RINT);\n-      break;\n-    case BRIG_OPCODE_TRUNC:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_TRUNC);\n-      break;\n-    case BRIG_OPCODE_COPYSIGN:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_COPYSIGN);\n-      break;\n-    case BRIG_OPCODE_NSIN:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_SIN);\n-      break;\n-    case BRIG_OPCODE_NLOG2:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_LOG2);\n-      break;\n-    case BRIG_OPCODE_NEXP2:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_EXP2);\n-      break;\n-    case BRIG_OPCODE_NFMA:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_FMA);\n-      break;\n-    case BRIG_OPCODE_NCOS:\n-      builtin = mathfn_built_in (builtin_type, BUILT_IN_COS);\n-      break;\n-    case BRIG_OPCODE_POPCOUNT:\n-      /* Popcount should be typed by its argument type (the return value\n-\t is always u32).  Let's use a b64 version for also for b32 for now.  */\n-      return builtin_decl_explicit (BUILT_IN_POPCOUNTL);\n-    case BRIG_OPCODE_BORROW:\n-      /* Borrow uses the same builtin for unsigned and signed types.  */\n-      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U32);\n-      else\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U64);\n-    case BRIG_OPCODE_CARRY:\n-      /* Carry also uses the same builtin for unsigned and signed types.  */\n-      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U32);\n-      else\n-\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U64);\n-    default:\n-\n-      /* Use our builtin index for finding a proper builtin for the BRIG\n-\t opcode and BRIG type.  This takes care most of the builtin cases,\n-\t the special cases are handled in the separate 'case' statements\n-\t above.  */\n-      builtin_map::const_iterator i\n-\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n-      if (i != s_custom_builtins.end ())\n-\treturn (*i).second;\n-\n-      if (brig_inner_type != brig_type)\n-\t{\n-\t  /* Try to find a scalar built-in we could use.  */\n-\t  i = s_custom_builtins.find\n-\t    (std::make_pair (brig_opcode, brig_inner_type));\n-\t  if (i != s_custom_builtins.end ())\n-\t    return (*i).second;\n-\t}\n-\n-      /* In case this is an fp16 operation that is promoted to fp32,\n-\t try to find a fp32 scalar built-in.  */\n-      if (brig_inner_type == BRIG_TYPE_F16)\n-\t{\n-\t  i = s_custom_builtins.find\n-\t    (std::make_pair (brig_opcode, BRIG_TYPE_F32));\n-\t  if (i != s_custom_builtins.end ())\n-\t    return (*i).second;\n-\t}\n-      gcc_unreachable ();\n-    }\n-\n-  if (VECTOR_TYPE_P (type) && builtin != NULL_TREE)\n-    {\n-      /* Try to find a vectorized version of the built-in.\n-\t TODO: properly assert that builtin is a mathfn builtin? */\n-      tree vec_builtin\n-\t= targetm.vectorize.builtin_vectorized_function\n-\t(builtin_mathfn_code (builtin), type, type);\n-      if (vec_builtin != NULL_TREE)\n-\treturn vec_builtin;\n-      else\n-\treturn builtin;\n-    }\n-  if (builtin == NULL_TREE)\n-    gcc_unreachable ();\n-  return builtin;\n-}\n-\n /* Return the correct GENERIC type for storing comparison results\n    of operand with the type given in SOURCE_TYPE.  */\n \n@@ -848,264 +702,6 @@ brig_code_entry_handler::get_comparison_result_type (tree source_type)\n     return gccbrig_tree_type_for_hsa_type (BRIG_TYPE_B1);\n }\n \n-/* Returns true in case the given opcode needs to know about work-item context\n-   data.  In such case the context data is passed as a pointer to a work-item\n-   context object, as the last argument in the builtin call.  */\n-\n-bool\n-brig_code_entry_handler::needs_workitem_context_data\n-  (BrigOpcode16_t brig_opcode) const\n-{\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_WORKITEMABSID:\n-    case BRIG_OPCODE_WORKITEMFLATABSID:\n-    case BRIG_OPCODE_WORKITEMFLATID:\n-    case BRIG_OPCODE_CURRENTWORKITEMFLATID:\n-    case BRIG_OPCODE_WORKITEMID:\n-    case BRIG_OPCODE_WORKGROUPID:\n-    case BRIG_OPCODE_WORKGROUPSIZE:\n-    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n-    case BRIG_OPCODE_GRIDGROUPS:\n-    case BRIG_OPCODE_GRIDSIZE:\n-    case BRIG_OPCODE_DIM:\n-    case BRIG_OPCODE_PACKETID:\n-    case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n-    case BRIG_OPCODE_BARRIER:\n-    case BRIG_OPCODE_WAVEBARRIER:\n-    case BRIG_OPCODE_ARRIVEFBAR:\n-    case BRIG_OPCODE_INITFBAR:\n-    case BRIG_OPCODE_JOINFBAR:\n-    case BRIG_OPCODE_LEAVEFBAR:\n-    case BRIG_OPCODE_RELEASEFBAR:\n-    case BRIG_OPCODE_WAITFBAR:\n-    case BRIG_OPCODE_CUID:\n-    case BRIG_OPCODE_MAXCUID:\n-    case BRIG_OPCODE_DEBUGTRAP:\n-    case BRIG_OPCODE_GROUPBASEPTR:\n-    case BRIG_OPCODE_KERNARGBASEPTR:\n-    case BRIG_OPCODE_ALLOCA:\n-      return true;\n-    default:\n-      return false;\n-    };\n-}\n-\n-/* Returns true in case the given opcode that would normally be generated\n-   as a builtin call can be expanded to tree nodes.  */\n-\n-bool\n-brig_code_entry_handler::can_expand_builtin (BrigOpcode16_t brig_opcode) const\n-{\n-  switch (brig_opcode)\n-    {\n-    case BRIG_OPCODE_WORKITEMFLATABSID:\n-    case BRIG_OPCODE_WORKITEMFLATID:\n-    case BRIG_OPCODE_WORKITEMABSID:\n-    case BRIG_OPCODE_WORKGROUPSIZE:\n-    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n-      /* TODO: expand more builtins.  */\n-      return true;\n-    default:\n-      return false;\n-    };\n-}\n-\n-/* Try to expand the given builtin call to reuse a previously generated\n-   variable, if possible.  If not, just call the given builtin.\n-   BRIG_OPCODE and BRIG_TYPE identify the builtin's BRIG opcode/type,\n-   ARITH_TYPE its GENERIC type, and OPERANDS contains the builtin's\n-   input operands.  */\n-\n-tree\n-brig_code_entry_handler::expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t\t BrigType16_t brig_type,\n-\t\t\t\t\t\t tree arith_type,\n-\t\t\t\t\t\t tree_stl_vec &operands)\n-{\n-  if (m_parent.m_cf->m_is_kernel && can_expand_builtin (brig_opcode))\n-    return expand_builtin (brig_opcode, operands);\n-\n-  tree built_in\n-    = get_builtin_for_hsa_opcode (arith_type, brig_opcode, brig_type);\n-\n-  if (!VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (built_in)))\n-      && arith_type != NULL_TREE && VECTOR_TYPE_P (arith_type)\n-      && brig_opcode != BRIG_OPCODE_LERP\n-      && brig_opcode != BRIG_OPCODE_PACKCVT\n-      && brig_opcode != BRIG_OPCODE_SAD\n-      && brig_opcode != BRIG_OPCODE_SADHI)\n-    {\n-      /* Call the scalar built-in for all elements in the vector.  */\n-      tree_stl_vec operand0_elements;\n-      if (operands.size () > 0)\n-\tunpack (operands[0], operand0_elements);\n-\n-      tree_stl_vec operand1_elements;\n-      if (operands.size () > 1)\n-\tunpack (operands[1], operand1_elements);\n-\n-      tree_stl_vec result_elements;\n-\n-      size_t element_count = gccbrig_type_vector_subparts (arith_type);\n-      for (size_t i = 0; i < element_count; ++i)\n-\t{\n-\t  tree_stl_vec call_operands;\n-\t  if (operand0_elements.size () > 0)\n-\t    call_operands.push_back (operand0_elements.at (i));\n-\n-\t  if (operand1_elements.size () > 0)\n-\t    call_operands.push_back (operand1_elements.at (i));\n-\n-\t  result_elements.push_back\n-\t    (expand_or_call_builtin (brig_opcode, brig_type,\n-\t\t\t\t     TREE_TYPE (arith_type),\n-\t\t\t\t     call_operands));\n-\t}\n-      return pack (result_elements);\n-    }\n-\n-  tree_stl_vec call_operands;\n-  tree_stl_vec operand_types;\n-\n-  tree arg_type_chain = TYPE_ARG_TYPES (TREE_TYPE (built_in));\n-\n-  for (size_t i = 0; i < operands.size (); ++i)\n-    {\n-      tree operand_type = TREE_VALUE (arg_type_chain);\n-      call_operands.push_back (convert (operand_type, operands[i]));\n-      operand_types.push_back (operand_type);\n-      arg_type_chain = TREE_CHAIN (arg_type_chain);\n-    }\n-\n-  if (needs_workitem_context_data (brig_opcode))\n-    {\n-      call_operands.push_back (m_parent.m_cf->m_context_arg);\n-      operand_types.push_back (ptr_type_node);\n-      m_parent.m_cf->m_has_unexpanded_dp_builtins = true;\n-    }\n-\n-  size_t operand_count = call_operands.size ();\n-\n-  call_operands.resize (4, NULL_TREE);\n-  operand_types.resize (4, NULL_TREE);\n-  for (size_t i = 0; i < operand_count; ++i)\n-    call_operands.at (i) = build_resize_convert_view (operand_types.at (i),\n-\t\t\t\t\t\t      call_operands.at (i));\n-\n-  tree fnptr = build_fold_addr_expr (built_in);\n-  return build_call_array (TREE_TYPE (TREE_TYPE (built_in)), fnptr,\n-\t\t\t   operand_count, &call_operands[0]);\n-}\n-\n-/* Instead of calling a built-in, reuse a previously returned value known to\n-   be still valid.  This is beneficial especially for the work-item\n-   identification related builtins as not having them as calls can lead to\n-   more easily vectorizable parallel loops for multi work-item work-groups.\n-   BRIG_OPCODE identifies the builtin and OPERANDS store the operands.  */\n-\n-tree\n-brig_code_entry_handler::expand_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t tree_stl_vec &operands)\n-{\n-  tree_stl_vec uint32_0 = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n-\n-  tree_stl_vec uint32_1 = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n-\n-  tree_stl_vec uint32_2 = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n-\n-  if (brig_opcode == BRIG_OPCODE_WORKITEMFLATABSID)\n-    {\n-      tree id0 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_0);\n-      id0 = convert (uint64_type_node, id0);\n-\n-      tree id1 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_1);\n-      id1 = convert (uint64_type_node, id1);\n-\n-      tree id2 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_2);\n-      id2 = convert (uint64_type_node, id2);\n-\n-      tree max0 = convert (uint64_type_node,\n-\t\t\t   m_parent.m_cf->m_grid_size_vars[0]);\n-      tree max1 = convert (uint64_type_node,\n-\t\t\t   m_parent.m_cf->m_grid_size_vars[1]);\n-\n-      tree id2_x_max0_x_max1 = build2 (MULT_EXPR, uint64_type_node, id2, max0);\n-      id2_x_max0_x_max1\n-\t= build2 (MULT_EXPR, uint64_type_node, id2_x_max0_x_max1, max1);\n-\n-      tree id1_x_max0 = build2 (MULT_EXPR, uint64_type_node, id1, max0);\n-\n-      tree sum = build2 (PLUS_EXPR, uint64_type_node, id0, id1_x_max0);\n-      sum = build2 (PLUS_EXPR, uint64_type_node, sum, id2_x_max0_x_max1);\n-\n-      return add_temp_var (\"workitemflatabsid\", sum);\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKITEMABSID)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-\n-      tree local_id_var = m_parent.m_cf->m_local_id_vars[dim];\n-      tree wg_id_var = m_parent.m_cf->m_wg_id_vars[dim];\n-      tree wg_size_var = m_parent.m_cf->m_wg_size_vars[dim];\n-\n-      tree wg_id_x_wg_size = build2 (MULT_EXPR, uint32_type_node,\n-\t\t\t\t     convert (uint32_type_node, wg_id_var),\n-\t\t\t\t     convert (uint32_type_node, wg_size_var));\n-      tree sum\n-\t= build2 (PLUS_EXPR, uint32_type_node, wg_id_x_wg_size, local_id_var);\n-\n-      return add_temp_var (std::string (\"workitemabsid_\")\n-\t\t\t   + (char) ((int) 'x' + dim), sum);\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKITEMFLATID)\n-    {\n-      tree z_x_wgsx_wgsy\n-\t= build2 (MULT_EXPR, uint32_type_node,\n-\t\t  m_parent.m_cf->m_local_id_vars[2],\n-\t\t  m_parent.m_cf->m_wg_size_vars[0]);\n-      z_x_wgsx_wgsy = build2 (MULT_EXPR, uint32_type_node, z_x_wgsx_wgsy,\n-\t\t\t      m_parent.m_cf->m_wg_size_vars[1]);\n-\n-      tree y_x_wgsx\n-\t= build2 (MULT_EXPR, uint32_type_node,\n-\t\t  m_parent.m_cf->m_local_id_vars[1],\n-\t\t  m_parent.m_cf->m_wg_size_vars[0]);\n-\n-      tree sum = build2 (PLUS_EXPR, uint32_type_node, y_x_wgsx, z_x_wgsx_wgsy);\n-      sum = build2 (PLUS_EXPR, uint32_type_node,\n-\t\t    m_parent.m_cf->m_local_id_vars[0],\n-\t\t    sum);\n-      return add_temp_var (\"workitemflatid\", sum);\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_WORKGROUPSIZE)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      return m_parent.m_cf->m_wg_size_vars[dim];\n-    }\n-  else if (brig_opcode == BRIG_OPCODE_CURRENTWORKGROUPSIZE)\n-    {\n-      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n-      return m_parent.m_cf->m_cur_wg_size_vars[dim];\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  return NULL_TREE;\n-}\n-\n-/* Appends and returns a new temp variable and an accompanying assignment\n-   statement that stores the value of the given EXPR and has the given NAME.  */\n-\n-tree\n-brig_code_entry_handler::add_temp_var (std::string name, tree expr)\n-{\n-  tree temp_var = create_tmp_var (TREE_TYPE (expr), name.c_str ());\n-  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (temp_var), temp_var, expr);\n-  m_parent.m_cf->append_statement (assign);\n-  return temp_var;\n-}\n-\n /* Creates a FP32 to FP16 conversion call, assuming the source and destination\n    are FP32 type variables.  */\n \n@@ -1387,7 +983,6 @@ brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n      variable type (can be any type; see get_m_var_declfor_reg @\n      brig-function.cc).  */\n   tree output_type = TREE_TYPE (output);\n-  tree input_type = TREE_TYPE (inst_expr);\n   bool is_fp16 = (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n \t\t && brig_inst.base.kind != BRIG_KIND_INST_MEM\n \t\t && !gccbrig_is_bit_operation (brig_inst.opcode);\n@@ -1396,6 +991,13 @@ brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n   bool ftz = false;\n   const BrigBase *base = &brig_inst.base;\n \n+  if (m_parent.m_cf->is_id_val (inst_expr))\n+    inst_expr = m_parent.m_cf->id_val (inst_expr);\n+\n+  tree input_type = TREE_TYPE (inst_expr);\n+\n+  m_parent.m_cf->add_reg_var_update (output, inst_expr);\n+\n   if (base->kind == BRIG_KIND_INST_MOD)\n     {\n       const BrigInstMod *mod = (const BrigInstMod *) base;\n@@ -1418,13 +1020,13 @@ brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n     {\n       /* Ensure we don't duplicate the arithmetics to the arguments of the bit\n \t field reference operators.  */\n-      inst_expr = add_temp_var (\"before_ftz\", inst_expr);\n+      inst_expr = m_parent.m_cf->add_temp_var (\"before_ftz\", inst_expr);\n       inst_expr = flush_to_zero (is_fp16) (*this, inst_expr);\n     }\n \n   if (is_fp16)\n     {\n-      inst_expr = add_temp_var (\"before_f2h\", inst_expr);\n+      inst_expr = m_parent.m_cf->add_temp_var (\"before_f2h\", inst_expr);\n       tree f2h_output = build_f2h_conversion (inst_expr);\n       tree conv = build_resize_convert_view (output_type, f2h_output);\n       tree assign = build2 (MODIFY_EXPR, output_type, output, conv);\n@@ -1486,62 +1088,6 @@ brig_code_entry_handler::append_statement (tree stmt)\n   m_parent.m_cf->append_statement (stmt);\n }\n \n-/* Unpacks the elements of the vector in VALUE to scalars (bit field\n-   references) in ELEMENTS.  */\n-\n-void\n-brig_code_entry_handler::unpack (tree value, tree_stl_vec &elements)\n-{\n-  size_t vec_size = int_size_in_bytes (TREE_TYPE (value));\n-  size_t element_size\n-    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (value))) * BITS_PER_UNIT;\n-  size_t element_count\n-    = vec_size * BITS_PER_UNIT / element_size;\n-\n-  tree input_element_type = TREE_TYPE (TREE_TYPE (value));\n-\n-  value = add_temp_var (\"unpack_input\", value);\n-\n-  for (size_t i = 0; i < element_count; ++i)\n-    {\n-      tree element\n-\t= build3 (BIT_FIELD_REF, input_element_type, value,\n-\t\t  TYPE_SIZE (input_element_type),\n-\t\t  bitsize_int(i * element_size));\n-\n-      element = add_temp_var (\"scalar\", element);\n-      elements.push_back (element);\n-    }\n-}\n-\n-/* Pack the elements of the scalars in ELEMENTS to the returned vector.  */\n-\n-tree\n-brig_code_entry_handler::pack (tree_stl_vec &elements)\n-{\n-  size_t element_count = elements.size ();\n-\n-  gcc_assert (element_count > 1);\n-\n-  tree output_element_type = TREE_TYPE (elements.at (0));\n-\n-  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n-  for (size_t i = 0; i < element_count; ++i)\n-    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, elements.at (i));\n-\n-  tree vec_type = build_vector_type (output_element_type, element_count);\n-\n-  /* build_constructor creates a vector type which is not a vector_cst\n-     that requires compile time constant elements.  */\n-  tree vec = build_constructor (vec_type, constructor_vals);\n-\n-  /* Add a temp variable for readability.  */\n-  tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n-  tree vec_tmp_assign = build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n-  m_parent.m_cf->append_statement (vec_tmp_assign);\n-  return tmp_var;\n-}\n-\n /* Visits the element(s) in the OPERAND, calling HANDLER to each of them.  */\n \n tree\n@@ -1757,4 +1303,3 @@ brig_code_entry_handler::int_constant_value (tree node)\n     n = TREE_OPERAND (n, 0);\n   return int_cst_value (n);\n }\n-"}, {"sha": "1e082c436c60f18e0974a5ff65145cf6b905c92b", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -35,8 +35,6 @@ class tree_element_unary_visitor;\n class brig_code_entry_handler : public brig_entry_handler\n {\n public:\n-  typedef std::map<std::pair<BrigOpcode16_t, BrigType16_t>, tree> builtin_map;\n-\n   brig_code_entry_handler (brig_to_generic &parent);\n \n   /* Handles the brig_code data at the given pointer and adds it to the\n@@ -51,8 +49,6 @@ class brig_code_entry_handler : public brig_entry_handler\n   tree get_tree_expr_type_for_hsa_type (BrigType16_t brig_type) const;\n   tree get_tree_cst_for_hsa_operand (const BrigOperandConstantBytes *brigConst,\n \t\t\t\t     tree type) const;\n-  tree get_builtin_for_hsa_opcode (tree type, BrigOpcode16_t brig_opcode,\n-\t\t\t\t   BrigType16_t brig_type) const;\n   tree get_comparison_result_type (tree source_type);\n \n   tree build_code_ref (const BrigBase &ref);\n@@ -73,16 +69,6 @@ class brig_code_entry_handler : public brig_entry_handler\n \n   bool needs_workitem_context_data (BrigOpcode16_t brig_opcode) const;\n \n-  void unpack (tree value, tree_stl_vec &elements);\n-  tree pack (tree_stl_vec &elements);\n-\n-  bool can_expand_builtin (BrigOpcode16_t brig_opcode) const;\n-  tree expand_builtin (BrigOpcode16_t brig_opcode, tree_stl_vec &operands);\n-\n-  tree expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n-\t\t\t       BrigType16_t brig_type, tree arith_type,\n-\t\t\t       tree_stl_vec &operands);\n-\n   tree add_temp_var (std::string name, tree expr);\n \n   tree build_f2h_conversion (tree source);\n@@ -100,10 +86,6 @@ class brig_code_entry_handler : public brig_entry_handler\n \n   tree extend_int (tree input, tree dest_type, tree src_type);\n \n-  /* HSAIL-specific builtin functions not yet integrated to gcc.  */\n-\n-  static builtin_map s_custom_builtins;\n-\n private:\n \n   tree_stl_vec build_or_analyze_operands (const BrigInstBase &brig_inst,\n@@ -299,9 +281,6 @@ class brig_basic_inst_handler : public brig_code_entry_handler\n \n   tree build_unpack_lo_or_hi (BrigOpcode16_t brig_opcode, tree arith_type,\n \t\t\t      tree_stl_vec &operands);\n-\n-  tree_code get_tree_code_for_hsa_opcode (BrigOpcode16_t brig_opcode,\n-\t\t\t\t\t  BrigType16_t brig_type) const;\n };\n \n class brig_cvt_inst_handler : public brig_inst_mod_handler"}, {"sha": "82189e149f521be09a845b7378f2010608b41c89", "filename": "gcc/brig/brigfrontend/brig-control-handler.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-control-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -53,45 +53,45 @@ brig_directive_control_handler::operator () (const BrigBase *base)\n     case BRIG_CONTROL_MAXDYNAMICGROUPSIZE:\n       {\n \tm_parent.m_cf->m_descriptor.max_dynamic_group_size\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tbreak;\n       }\n     case BRIG_CONTROL_MAXFLATGRIDSIZE:\n       {\n \tm_parent.m_cf->m_descriptor.max_flat_grid_size\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tbreak;\n       }\n     case BRIG_CONTROL_MAXFLATWORKGROUPSIZE:\n       {\n \tm_parent.m_cf->m_descriptor.max_flat_workgroup_size\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tbreak;\n       }\n     case BRIG_CONTROL_REQUIREDDIM:\n       {\n \tm_parent.m_cf->m_descriptor.required_dim\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tbreak;\n       }\n     case BRIG_CONTROL_REQUIREDGRIDSIZE:\n       {\n \tm_parent.m_cf->m_descriptor.required_grid_size[0]\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tm_parent.m_cf->m_descriptor.required_grid_size[1]\n-\t  = int_constant_value (operands.at (1));\n+\t  = brig_function::int_constant_value (operands.at (1));\n \tm_parent.m_cf->m_descriptor.required_grid_size[2]\n-\t  = int_constant_value (operands.at (2));\n+\t  = brig_function::int_constant_value (operands.at (2));\n \tbreak;\n       }\n     case BRIG_CONTROL_REQUIREDWORKGROUPSIZE:\n       {\n \tm_parent.m_cf->m_descriptor.required_workgroup_size[0]\n-\t  = int_constant_value (operands.at (0));\n+\t  = brig_function::int_constant_value (operands.at (0));\n \tm_parent.m_cf->m_descriptor.required_workgroup_size[1]\n-\t  = int_constant_value (operands.at (1));\n+\t  = brig_function::int_constant_value (operands.at (1));\n \tm_parent.m_cf->m_descriptor.required_workgroup_size[2]\n-\t  = int_constant_value (operands.at (2));\n+\t  = brig_function::int_constant_value (operands.at (2));\n \tbreak;\n       }\n     case BRIG_CONTROL_REQUIRENOPARTIALWORKGROUPS:"}, {"sha": "3b8c9ea01df54d29a7f1e28ff1e75f70f75eace1", "filename": "gcc/brig/brigfrontend/brig-cvt-inst-handler.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -83,6 +83,12 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n   tree &input = operands.at (1);\n   tree &output = operands.at (0);\n \n+  if (m_parent.m_cf->is_id_val (input))\n+    {\n+      input = m_parent.m_cf->id_val (input);\n+      src_type = TREE_TYPE (input);\n+    }\n+\n   size_t conv_src_size = int_size_in_bytes (src_type);\n   size_t conv_dst_size = int_size_in_bytes (dest_type);\n   size_t src_reg_size = int_size_in_bytes (TREE_TYPE (input));"}, {"sha": "f22f065c45ceee7a48542d70555f433663163337", "filename": "gcc/brig/brigfrontend/brig-function-handler.cc", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -93,6 +93,25 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n      represent HSAIL registers.  */\n   tree bind_expr = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, NULL);\n \n+  tree restrict_char_ptr\n+    = build_qualified_type (build_pointer_type (char_type_node),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n+  tree restrict_void_ptr\n+    = build_qualified_type (build_pointer_type (void_type_node),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n+\n+  tree restrict_const_char_ptr\n+    = build_qualified_type (build_pointer_type\n+\t\t\t    (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t   TYPE_QUAL_CONST)),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n+\n+  tree restrict_const_void_ptr\n+    = build_qualified_type (build_pointer_type\n+\t\t\t    (build_qualified_type (void_type_node,\n+\t\t\t\t\t\t   TYPE_QUAL_CONST)),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n+\n   if (is_kernel)\n     {\n       tree name_identifier\n@@ -107,12 +126,11 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \t 3) a void* parameter that contains the first flat address of the group\n \t region allocated to the current work-group.  */\n \n-      tree char_ptr_type_node = build_pointer_type (char_type_node);\n       fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n \t\t\t   build_function_type_list (void_type_node,\n-\t\t\t\t\t\t     char_ptr_type_node,\n-\t\t\t\t\t\t     ptr_type_node,\n-\t\t\t\t\t\t     ptr_type_node, NULL_TREE));\n+\t\t\t\t\t\t     restrict_const_char_ptr,\n+\t\t\t\t\t\t     restrict_void_ptr,\n+\t\t\t\t\t\t     restrict_char_ptr, NULL_TREE));\n \n       SET_DECL_ASSEMBLER_NAME (fndecl, name_identifier);\n \n@@ -125,9 +143,10 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \t= gccbrig_get_target_addr_space_id (BRIG_SEGMENT_KERNARG);\n \n       tree arg_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__args\"), char_ptr_type_node);\n+\t\t\t\t get_identifier (\"__args\"),\n+\t\t\t\t restrict_const_char_ptr);\n       DECL_ARGUMENTS (fndecl) = arg_arg;\n-      DECL_ARG_TYPE (arg_arg) = char_ptr_type_node;\n+      DECL_ARG_TYPE (arg_arg) = restrict_const_char_ptr;\n       DECL_CONTEXT (arg_arg) = fndecl;\n       DECL_ARTIFICIAL (arg_arg) = 1;\n       TREE_READONLY (arg_arg) = 1;\n@@ -189,7 +208,7 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \t      if (arg_decls == NULL_TREE)\n \t\targ_decls = arg_var;\n \t      else\n-\t\tchainon (arg_decls, arg_var);\n+\t\targ_decls = chainon (arg_decls, arg_var);\n \n \t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n \n@@ -230,18 +249,13 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \t      vec_safe_push (args, TREE_TYPE (arg_var));\n \n \t      m_parent.m_cf->add_arg_variable (brigVar, arg_var);\n-\n-\t      if (arg_decls == NULL_TREE)\n-\t\targ_decls = arg_var;\n-\t      else\n-\t\tchainon (arg_decls, arg_var);\n+\t      arg_decls = chainon (arg_decls, arg_var);\n \t    }\n \t}\n-\n-      vec_safe_push (args, ptr_type_node);\n-      vec_safe_push (args, ptr_type_node);\n-      vec_safe_push (args, ptr_type_node);\n-      vec_safe_push (args, ptr_type_node);\n+      vec_safe_push (args, restrict_void_ptr);\n+      vec_safe_push (args, restrict_char_ptr);\n+      vec_safe_push (args, uint32_type_node);\n+      vec_safe_push (args, restrict_char_ptr);\n \n       fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n \t\t\t   build_function_type_vec (ret_type, args));\n@@ -254,26 +268,30 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \n   /* All functions need the hidden __context argument passed on\n      because they might call WI-specific functions which need\n-     the context info.  */\n+     the context info.  Only kernels can write it, if they need\n+     to update the local ids in the work-item loop.  */\n+\n+  tree context_arg_type\n+    = true ? restrict_void_ptr : restrict_const_void_ptr;\n   tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__context\"), ptr_type_node);\n-  if (DECL_ARGUMENTS (fndecl) == NULL_TREE)\n-    DECL_ARGUMENTS (fndecl) = context_arg;\n-  else\n-    chainon (DECL_ARGUMENTS (fndecl), context_arg);\n+\t\t\t\t get_identifier (\"__context\"),\n+\t\t\t\t context_arg_type);\n+  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), context_arg);\n   DECL_CONTEXT (context_arg) = fndecl;\n-  DECL_ARG_TYPE (context_arg) = ptr_type_node;\n+  DECL_ARG_TYPE (context_arg) = context_arg_type;\n   DECL_ARTIFICIAL (context_arg) = 1;\n   TREE_READONLY (context_arg) = 1;\n   TREE_USED (context_arg) = 1;\n+  m_parent.m_cf->m_context_arg = context_arg;\n \n   /* They can also access group memory, so we need to pass the\n      group pointer along too.  */\n   tree group_base_arg\n     = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__group_base_addr\"), ptr_type_node);\n-  chainon (DECL_ARGUMENTS (fndecl), group_base_arg);\n-  DECL_ARG_TYPE (group_base_arg) = ptr_type_node;\n+\t\t  get_identifier (\"__group_base_addr\"),\n+\t\t  restrict_char_ptr);\n+  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), group_base_arg);\n+  DECL_ARG_TYPE (group_base_arg) = restrict_char_ptr;\n   DECL_CONTEXT (group_base_arg) = fndecl;\n   DECL_ARTIFICIAL (group_base_arg) = 1;\n   TREE_READONLY (group_base_arg) = 1;\n@@ -288,7 +306,7 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n   tree group_local_offset_arg\n     = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t  get_identifier (\"__group_local_offset\"), uint32_type_node);\n-  chainon (DECL_ARGUMENTS (fndecl), group_local_offset_arg);\n+  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), group_local_offset_arg);\n   DECL_ARG_TYPE (group_local_offset_arg) = uint32_type_node;\n   DECL_CONTEXT (group_local_offset_arg) = fndecl;\n   DECL_ARTIFICIAL (group_local_offset_arg) = 1;\n@@ -299,24 +317,25 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n   /* Same for private.  */\n   tree private_base_arg\n     = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__private_base_addr\"), ptr_type_node);\n-  chainon (DECL_ARGUMENTS (fndecl), private_base_arg);\n-  DECL_ARG_TYPE (private_base_arg) = ptr_type_node;\n+\t\t  get_identifier (\"__private_base_addr\"), restrict_char_ptr);\n+  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), private_base_arg);\n+  DECL_ARG_TYPE (private_base_arg) = restrict_char_ptr;\n   DECL_CONTEXT (private_base_arg) = fndecl;\n   DECL_ARTIFICIAL (private_base_arg) = 1;\n   TREE_READONLY (private_base_arg) = 1;\n   TREE_USED (private_base_arg) = 1;\n+  m_parent.m_cf->m_private_base_arg = private_base_arg;\n \n   DECL_SAVED_TREE (fndecl) = bind_expr;\n \n-  set_externally_visible (fndecl);\n-\n   if (base->kind == BRIG_KIND_DIRECTIVE_FUNCTION)\n     {\n       TREE_STATIC (fndecl) = 0;\n       TREE_PUBLIC (fndecl) = 1;\n       DECL_EXTERNAL (fndecl) = 0;\n       DECL_DECLARED_INLINE_P (fndecl) = 1;\n+      set_inline (fndecl);\n+      set_externally_visible (fndecl);\n     }\n   else if (base->kind == BRIG_KIND_DIRECTIVE_KERNEL)\n     {\n@@ -330,6 +349,7 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n       TREE_STATIC (fndecl) = 0;\n       TREE_PUBLIC (fndecl) = 1;\n       DECL_EXTERNAL (fndecl) = 1;\n+      set_inline (fndecl);\n     }\n   else if (base->kind == BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION)\n     {\n@@ -371,11 +391,8 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n     }\n \n   m_parent.start_function (fndecl);\n-\n   m_parent.m_cf->m_func_decl = fndecl;\n   m_parent.m_cf->m_current_bind_expr = bind_expr;\n-  m_parent.m_cf->m_context_arg = context_arg;\n-  m_parent.m_cf->m_private_base_arg = private_base_arg;\n \n   if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)\n     {"}, {"sha": "f0c499d47f6d11419a30af67f9485b50fe8811bd", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "modified", "additions": 877, "deletions": 48, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -44,6 +44,12 @@\n #include \"function.h\"\n #include \"brig-to-generic.h\"\n #include \"brig-builtins.h\"\n+#include \"options.h\"\n+#include \"fold-const.h\"\n+#include \"target.h\"\n+#include \"builtins.h\"\n+\n+brig_function::builtin_map brig_function::s_custom_builtins;\n \n brig_function::brig_function (const BrigDirectiveExecutable *exec,\n \t\t\t      brig_to_generic *parent)\n@@ -60,6 +66,20 @@ brig_function::brig_function (const BrigDirectiveExecutable *exec,\n   memset (m_regs, 0,\n \t  BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT * sizeof (BrigOperandRegister *));\n   memset (&m_descriptor, 0, sizeof (phsa_descriptor));\n+\n+  if (s_custom_builtins.size () > 0) return;\n+\n+  /* Populate the builtin index.  */\n+#undef DEF_HSAIL_ATOMIC_BUILTIN\n+#undef DEF_HSAIL_CVT_ZEROI_SAT_BUILTIN\n+#undef DEF_HSAIL_INTR_BUILTIN\n+#undef DEF_HSAIL_SAT_BUILTIN\n+#undef DEF_HSAIL_BUILTIN\n+#define DEF_HSAIL_BUILTIN(ENUM, HSAIL_OPCODE, HSAIL_TYPE, NAME, TYPE, ATTRS) \\\n+  s_custom_builtins[std::make_pair (HSAIL_OPCODE, HSAIL_TYPE)]\t\t\\\n+    = builtin_decl_explicit (ENUM);\n+\n+#include \"brig-builtins.def\"\n }\n \n brig_function::~brig_function ()\n@@ -158,8 +178,7 @@ brig_function::add_id_variables ()\n   tree stmts = BIND_EXPR_BODY (bind_expr);\n \n   /* Initialize the WG limits and local ids.  */\n-\n-  tree_stmt_iterator entry = tsi_start (stmts);\n+  m_kernel_entry = tsi_start (stmts);\n \n   for (int i = 0; i < 3; ++i)\n     {\n@@ -169,7 +188,7 @@ brig_function::add_id_variables ()\n \t to avoid unnecessary casts (the ID functions are 32b).  */\n       m_local_id_vars[i]\n \t= add_local_variable (std::string (\"__local_\") + dim_char,\n-\t\t\t      uint32_type_node);\n+\t\t\t      long_long_integer_type_node);\n \n       tree workitemid_call\n \t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKITEMID), 2,\n@@ -178,54 +197,88 @@ brig_function::add_id_variables ()\n \t\t\tm_context_arg);\n \n       tree id_init = build2 (MODIFY_EXPR, TREE_TYPE (m_local_id_vars[i]),\n-\t\t\t     m_local_id_vars[i], workitemid_call);\n+\t\t\t     m_local_id_vars[i],\n+\t\t\t     convert (TREE_TYPE (m_local_id_vars[i]),\n+\t\t\t\t      workitemid_call));\n \n-      tsi_link_after (&entry, id_init, TSI_NEW_STMT);\n+      append_statement (id_init);\n \n       m_cur_wg_size_vars[i]\n \t= add_local_variable (std::string (\"__cur_wg_size_\") + dim_char,\n-\t\t\t      uint32_type_node);\n+\t\t\t      long_long_integer_type_node);\n \n-      tree cwgz_call\n-\t= call_builtin\n-\t(builtin_decl_explicit (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE),\n-\t 2, uint32_type_node, uint32_type_node,\n-\t build_int_cst (uint32_type_node, i), ptr_type_node, m_context_arg);\n+      tree cwgz_call;\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree_stl_vec operands\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n+\t  cwgz_call\n+\t    = expand_or_call_builtin (BRIG_OPCODE_CURRENTWORKGROUPSIZE,\n+\t\t\t\t      BRIG_TYPE_U32, uint32_type_node,\n+\t\t\t\t      operands);\n+\t}\n+      else\n+\tcwgz_call = call_builtin\n+\t  (builtin_decl_explicit (BUILT_IN_HSAIL_CURRENTWORKGROUPSIZE),\n+\t   2, uint32_type_node, uint32_type_node,\n+\t   build_int_cst (uint32_type_node, i), ptr_type_node, m_context_arg);\n \n       tree limit_init = build2 (MODIFY_EXPR, TREE_TYPE (m_cur_wg_size_vars[i]),\n-\t\t\t\tm_cur_wg_size_vars[i], cwgz_call);\n+\t\t\t\tm_cur_wg_size_vars[i],\n+\t\t\t\tconvert (TREE_TYPE (m_cur_wg_size_vars[i]),\n+\t\t\t\t\t cwgz_call));\n \n-      tsi_link_after (&entry, limit_init, TSI_NEW_STMT);\n+      append_statement (limit_init);\n \n       m_wg_id_vars[i]\n \t= add_local_variable (std::string (\"__workgroupid_\") + dim_char,\n \t\t\t      uint32_type_node);\n \n-      tree wgid_call\n-\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPID),\n-\t\t\t2, uint32_type_node, uint32_type_node,\n-\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\tm_context_arg);\n+      tree wgid_call;\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree_stl_vec operands\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n+\t  wgid_call\n+\t    = expand_or_call_builtin (BRIG_OPCODE_WORKGROUPID, BRIG_TYPE_U32,\n+\t\t\t\t      uint32_type_node, operands);\n+\t}\n+      else\n+\twgid_call\n+\t  = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPID),\n+\t\t\t  2, uint32_type_node, uint32_type_node,\n+\t\t\t  build_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\t  m_context_arg);\n \n       tree wgid_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_id_vars[i]),\n \t\t\t       m_wg_id_vars[i], wgid_call);\n \n-      tsi_link_after (&entry, wgid_init, TSI_NEW_STMT);\n+      append_statement (wgid_init);\n \n       m_wg_size_vars[i]\n \t= add_local_variable (std::string (\"__workgroupsize_\") + dim_char,\n \t\t\t      uint32_type_node);\n \n-      tree wgsize_call\n-\t= call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPSIZE),\n-\t\t\t2, uint32_type_node, uint32_type_node,\n-\t\t\tbuild_int_cst (uint32_type_node, i), ptr_type_node,\n-\t\t\tm_context_arg);\n+      tree wgsize_call;\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree_stl_vec operands\n+\t    = tree_stl_vec (1, build_int_cst (uint32_type_node, i));\n+\t  wgsize_call\n+\t    = expand_or_call_builtin (BRIG_OPCODE_WORKGROUPSIZE, BRIG_TYPE_U32,\n+\t\t\t\t      uint32_type_node, operands);\n+\t}\n+      else\n+\twgsize_call\n+\t  = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_WORKGROUPSIZE),\n+\t\t\t  2, uint32_type_node, uint32_type_node,\n+\t\t\t  build_int_cst (uint32_type_node, i), ptr_type_node,\n+\t\t\t  m_context_arg);\n \n       tree wgsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_wg_size_vars[i]),\n \t\t\t\t m_wg_size_vars[i], wgsize_call);\n \n-      tsi_link_after (&entry, wgsize_init, TSI_NEW_STMT);\n+      append_statement (wgsize_init);\n \n       m_grid_size_vars[i]\n \t= add_local_variable (std::string (\"__gridsize_\") + dim_char,\n@@ -240,10 +293,34 @@ brig_function::add_id_variables ()\n       tree gridsize_init = build2 (MODIFY_EXPR, TREE_TYPE (m_grid_size_vars[i]),\n \t\t\t\t   m_grid_size_vars[i], gridsize_call);\n \n-      tsi_link_after (&entry, gridsize_init, TSI_NEW_STMT);\n+      append_statement (gridsize_init);\n+\n+      m_abs_id_base_vars[i]\n+\t= add_local_variable (std::string (\"__abs_id_base_\") + dim_char,\n+\t\t\t      long_long_integer_type_node);\n+\n+      m_abs_id_vars[i]\n+\t= add_local_variable (std::string (\"__abs_id_\") + dim_char,\n+\t\t\t      long_long_integer_type_node);\n+\n+      tree abs_id_base\n+\t= build2 (MULT_EXPR, long_long_integer_type_node,\n+\t\t  convert (long_long_integer_type_node, m_wg_id_vars[i]),\n+\t\t  convert (long_long_integer_type_node, m_wg_size_vars[i]));\n+      tree abs_id\n+\t= build2 (PLUS_EXPR, long_long_integer_type_node, abs_id_base,\n+\t\t  convert (long_long_integer_type_node, m_local_id_vars[i]));\n+\n+      tree abs_id_base_init\n+\t= build2 (MODIFY_EXPR, TREE_TYPE (m_abs_id_base_vars[i]),\n+\t\t  m_abs_id_base_vars[i], abs_id_base);\n+      append_statement (abs_id_base_init);\n+\n+      tree abs_id_init = build2 (MODIFY_EXPR,\n+\t\t\t\t TREE_TYPE (m_abs_id_vars[i]),\n+\t\t\t\t m_abs_id_vars[i], abs_id);\n+      append_statement (abs_id_init);\n     }\n-\n-  m_kernel_entry = entry;\n }\n \n /* Creates a new local variable with the given NAME and given GENERIC\n@@ -359,6 +436,8 @@ brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n \t\t\t    tree_stmt_iterator *branch_after)\n {\n   tree ivar = m_local_id_vars[dim];\n+  tree abs_id_base_var = m_abs_id_base_vars[dim];\n+  tree abs_id_var = m_abs_id_vars[dim];\n   tree ivar_max = m_cur_wg_size_vars[dim];\n   tree_stmt_iterator entry = *header_entry;\n \n@@ -371,6 +450,12 @@ brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n \t\t\t   build_zero_cst (TREE_TYPE (ivar)));\n   tsi_link_after (&entry, ivar_init, TSI_NEW_STMT);\n \n+  tree abs_id_var_init = build2 (MODIFY_EXPR, TREE_TYPE (abs_id_var),\n+\t\t\t\t abs_id_var,\n+\t\t\t\t convert (TREE_TYPE (abs_id_var),\n+\t\t\t\t\t  abs_id_base_var));\n+  tsi_link_after (&entry, abs_id_var_init, TSI_NEW_STMT);\n+\n   tree loop_body_label\n     = label (std::string (\"__wi_loop_\") + (char) ((int) 'x' + dim));\n   tree loop_body_label_stmt = build_stmt (LABEL_EXPR, loop_body_label);\n@@ -379,16 +464,30 @@ brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n \n   if (m_has_unexpanded_dp_builtins)\n     {\n-      tree id_set_builtin\n-\t= builtin_decl_explicit (BUILT_IN_HSAIL_SETWORKITEMID);\n-      /* Set the local ID to the current wi-loop iteration variable value to\n-\t ensure the builtins see the correct values.  */\n-      tree id_set_call\n-\t= call_builtin (id_set_builtin, 3,\n-\t\t\tvoid_type_node, uint32_type_node,\n-\t\t\tbuild_int_cst (uint32_type_node, dim), uint32_type_node,\n-\t\t\tivar, ptr_type_node, m_context_arg);\n-      tsi_link_after (&entry, id_set_call, TSI_NEW_STMT);\n+      if (!flag_assume_phsa)\n+\t{\n+\t  tree id_set_builtin\n+\t    = builtin_decl_explicit (BUILT_IN_HSAIL_SETWORKITEMID);\n+\t  /* Set the local ID to the current wi-loop iteration variable value\n+\t     to ensure the builtins see the correct values.  */\n+\t  tree id_set_call\n+\t    = call_builtin (id_set_builtin, 3,\n+\t\t\t    void_type_node, uint32_type_node,\n+\t\t\t    build_int_cst (uint32_type_node, dim),\n+\t\t\t    uint32_type_node, convert (uint32_type_node, ivar),\n+\t\t\t    ptr_type_node, m_context_arg);\n+\t  tsi_link_after (&entry, id_set_call, TSI_NEW_STMT);\n+\t}\n+      else\n+\t{\n+\t  tree ptr_type = build_pointer_type (uint32_type_node);\n+\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n+\t\t\t     build_int_cst (ptr_type, dim * 4));\n+\t  tree assign = build2 (MODIFY_EXPR, uint32_type_node, ctx,\n+\t\t\t\tconvert (uint32_type_node, ivar));\n+\n+\t  tsi_link_after (&entry, assign, TSI_NEW_STMT);\n+\t}\n     }\n \n   /* Increment the WI iteration variable.  */\n@@ -397,6 +496,13 @@ brig_function::add_wi_loop (int dim, tree_stmt_iterator *header_entry,\n \n   tsi_link_after (branch_after, incr, TSI_NEW_STMT);\n \n+  /* ...and the abs id variable.  */\n+  tree abs_id_incr = build2 (PREINCREMENT_EXPR, TREE_TYPE (abs_id_var),\n+\t\t\t     abs_id_var,\n+\t\t\t     build_one_cst (TREE_TYPE (abs_id_var)));\n+\n+  tsi_link_after (branch_after, abs_id_incr, TSI_NEW_STMT);\n+\n   /* Append the predicate check with the back edge goto.  */\n   tree condition = build2 (LT_EXPR, TREE_TYPE (ivar), ivar, ivar_max);\n   tree target_goto = build1 (GOTO_EXPR, void_type_node, loop_body_label);\n@@ -549,29 +655,36 @@ brig_function::emit_launcher_and_metadata ()\n   tree name_identifier\n     = get_identifier_with_length (kern_name.c_str (), kern_name.size ());\n \n+  tree restrict_void_ptr\n+    = build_qualified_type (build_pointer_type (void_type_node),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n+  tree restrict_char_ptr\n+    = build_qualified_type (build_pointer_type (char_type_node),\n+\t\t\t    TYPE_QUAL_RESTRICT);\n   tree launcher\n     = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, name_identifier,\n-\t\t  build_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t    ptr_type_node, NULL_TREE));\n+\t\t  build_function_type_list (void_type_node, restrict_void_ptr,\n+\t\t\t\t\t    restrict_char_ptr, NULL_TREE));\n \n   TREE_USED (launcher) = 1;\n   DECL_ARTIFICIAL (launcher) = 1;\n \n   tree context_arg = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t\t\t get_identifier (\"__context\"), ptr_type_node);\n+\t\t\t\t get_identifier (\"__context\"),\n+\t\t\t\t restrict_void_ptr);\n \n   DECL_ARGUMENTS (launcher) = context_arg;\n-  DECL_ARG_TYPE (context_arg) = ptr_type_node;\n+  DECL_ARG_TYPE (context_arg) = restrict_void_ptr;\n   DECL_CONTEXT (context_arg) = launcher;\n   TREE_USED (context_arg) = 1;\n   DECL_ARTIFICIAL (context_arg) = 1;\n \n   tree group_base_addr_arg\n     = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n-\t\t  get_identifier (\"__group_base_addr\"), ptr_type_node);\n+\t\t  get_identifier (\"__group_base_addr\"), restrict_char_ptr);\n \n   chainon (DECL_ARGUMENTS (launcher), group_base_addr_arg);\n-  DECL_ARG_TYPE (group_base_addr_arg) = ptr_type_node;\n+  DECL_ARG_TYPE (group_base_addr_arg) = restrict_char_ptr;\n   DECL_CONTEXT (group_base_addr_arg) = launcher;\n   TREE_USED (group_base_addr_arg) = 1;\n   DECL_ARTIFICIAL (group_base_addr_arg) = 1;\n@@ -618,15 +731,15 @@ brig_function::emit_launcher_and_metadata ()\n     phsail_launch_kernel_call\n       = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_WG_FUNC),\n \t\t      4, void_type_node,\n-\t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n-\t\t      context_arg, ptr_type_node, group_base_addr_arg,\n+\t\t      ptr_type_node, kernel_func_ptr, restrict_void_ptr,\n+\t\t      context_arg, restrict_char_ptr, group_base_addr_arg,\n \t\t      uint32_type_node, group_local_offset_arg);\n   else\n     phsail_launch_kernel_call\n       = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_KERNEL),\n \t\t      4, void_type_node,\n-\t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n-\t\t      context_arg, ptr_type_node, group_base_addr_arg,\n+\t\t      ptr_type_node, kernel_func_ptr, restrict_void_ptr,\n+\t\t      context_arg, restrict_char_ptr, group_base_addr_arg,\n \t\t      uint32_type_node, group_local_offset_arg);\n \n   append_to_statement_list_force (phsail_launch_kernel_call, &stmt_list);\n@@ -771,3 +884,719 @@ brig_function::group_variable_segment_offset (const std::string &name) const\n   gcc_assert (m_parent->m_module_group_variables.has_variable (name));\n   return m_parent->m_module_group_variables.segment_offset (name);\n }\n+\n+/* Try to expand the given builtin call to reuse a previously generated\n+   variable, if possible.  If not, just call the given builtin.\n+   BRIG_OPCODE and BRIG_TYPE identify the builtin's BRIG opcode/type,\n+   ARITH_TYPE its GENERIC type, and OPERANDS contains the builtin's\n+   input operands.  */\n+\n+tree\n+brig_function::expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t\t       BrigType16_t brig_type,\n+\t\t\t\t       tree arith_type,\n+\t\t\t\t       tree_stl_vec &operands)\n+{\n+  if (needs_workitem_context_data (brig_opcode))\n+    m_has_unexpanded_dp_builtins = true;\n+\n+  if (can_expand_builtin (brig_opcode))\n+    return expand_builtin (brig_opcode, operands);\n+\n+  tree built_in\n+    = get_builtin_for_hsa_opcode (arith_type, brig_opcode, brig_type);\n+\n+  if (!VECTOR_TYPE_P (TREE_TYPE (TREE_TYPE (built_in)))\n+      && arith_type != NULL_TREE && VECTOR_TYPE_P (arith_type)\n+      && brig_opcode != BRIG_OPCODE_LERP\n+      && brig_opcode != BRIG_OPCODE_PACKCVT\n+      && brig_opcode != BRIG_OPCODE_SAD\n+      && brig_opcode != BRIG_OPCODE_SADHI)\n+    {\n+      /* Call the scalar built-in for all elements in the vector.  */\n+      tree_stl_vec operand0_elements;\n+      if (operands.size () > 0)\n+\tunpack (operands[0], operand0_elements);\n+\n+      tree_stl_vec operand1_elements;\n+      if (operands.size () > 1)\n+\tunpack (operands[1], operand1_elements);\n+\n+      tree_stl_vec result_elements;\n+\n+      size_t element_count = gccbrig_type_vector_subparts (arith_type);\n+      for (size_t i = 0; i < element_count; ++i)\n+\t{\n+\t  tree_stl_vec call_operands;\n+\t  if (operand0_elements.size () > 0)\n+\t    call_operands.push_back (operand0_elements.at (i));\n+\n+\t  if (operand1_elements.size () > 0)\n+\t    call_operands.push_back (operand1_elements.at (i));\n+\n+\t  result_elements.push_back\n+\t    (expand_or_call_builtin (brig_opcode, brig_type,\n+\t\t\t\t     TREE_TYPE (arith_type),\n+\t\t\t\t     call_operands));\n+\t}\n+      return pack (result_elements);\n+    }\n+\n+  tree_stl_vec call_operands;\n+  tree_stl_vec operand_types;\n+\n+  tree arg_type_chain = TYPE_ARG_TYPES (TREE_TYPE (built_in));\n+\n+  for (size_t i = 0; i < operands.size (); ++i)\n+    {\n+      tree operand_type = TREE_VALUE (arg_type_chain);\n+      call_operands.push_back (convert (operand_type, operands[i]));\n+      operand_types.push_back (operand_type);\n+      arg_type_chain = TREE_CHAIN (arg_type_chain);\n+    }\n+\n+  if (needs_workitem_context_data (brig_opcode))\n+    {\n+      call_operands.push_back (m_context_arg);\n+      operand_types.push_back (ptr_type_node);\n+    }\n+\n+  size_t operand_count = call_operands.size ();\n+\n+  call_operands.resize (4, NULL_TREE);\n+  operand_types.resize (4, NULL_TREE);\n+  for (size_t i = 0; i < operand_count; ++i)\n+    call_operands.at (i) = build_resize_convert_view (operand_types.at (i),\n+\t\t\t\t\t\t      call_operands.at (i));\n+\n+  tree fnptr = build_fold_addr_expr (built_in);\n+  return build_call_array (TREE_TYPE (TREE_TYPE (built_in)), fnptr,\n+\t\t\t   operand_count, &call_operands[0]);\n+}\n+\n+/* Instead of calling a built-in function, use a more efficient mechanism\n+   such as reuse a previously returned value known to be still valid, or\n+   access the work-item context struct directly.  This is beneficial especially\n+   for the work-item identification related builtins as not having them as\n+   unanalyzable black box calls can lead to more easily vectorizable parallel\n+   loops for multi work-item work-groups.  BRIG_OPCODE identifies the builtin\n+   and OPERANDS store the operands.  */\n+\n+tree\n+brig_function::expand_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t       tree_stl_vec &operands)\n+{\n+  tree_stl_vec uint32_0 = tree_stl_vec (1, build_int_cst (uint32_type_node, 0));\n+\n+  tree_stl_vec uint32_1 = tree_stl_vec (1, build_int_cst (uint32_type_node, 1));\n+\n+  tree_stl_vec uint32_2 = tree_stl_vec (1, build_int_cst (uint32_type_node, 2));\n+\n+  if (brig_opcode == BRIG_OPCODE_WORKITEMFLATABSID)\n+    {\n+      tree id0 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_0);\n+      id0 = convert (uint64_type_node, id0);\n+\n+      tree id1 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_1);\n+      id1 = convert (uint64_type_node, id1);\n+\n+      tree id2 = expand_builtin (BRIG_OPCODE_WORKITEMABSID, uint32_2);\n+      id2 = convert (uint64_type_node, id2);\n+\n+      tree max0 = convert (uint64_type_node, m_grid_size_vars[0]);\n+      tree max1 = convert (uint64_type_node, m_grid_size_vars[1]);\n+\n+      tree id2_x_max0_x_max1 = build2 (MULT_EXPR, uint64_type_node, id2, max0);\n+      id2_x_max0_x_max1\n+\t= build2 (MULT_EXPR, uint64_type_node, id2_x_max0_x_max1, max1);\n+\n+      tree id1_x_max0 = build2 (MULT_EXPR, uint64_type_node, id1, max0);\n+\n+      tree sum = build2 (PLUS_EXPR, uint64_type_node, id0, id1_x_max0);\n+      sum = build2 (PLUS_EXPR, uint64_type_node, sum, id2_x_max0_x_max1);\n+\n+      return add_temp_var (\"workitemflatabsid\", sum);\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKITEMABSID)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      return m_abs_id_vars[dim];\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKITEMFLATID)\n+    {\n+\n+      tree wg_size_x = expand_builtin (BRIG_OPCODE_WORKGROUPSIZE, uint32_0);\n+      tree wg_size_y = expand_builtin (BRIG_OPCODE_WORKGROUPSIZE, uint32_1);\n+      tree z_x_wgsx_wgsy\n+\t= build2 (MULT_EXPR, uint32_type_node,\n+\t\t  convert (uint32_type_node,\n+\t\t\t   expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_2)),\n+\t\t  wg_size_x);\n+      z_x_wgsx_wgsy = build2 (MULT_EXPR, uint32_type_node, z_x_wgsx_wgsy,\n+\t\t\t      wg_size_y);\n+\n+      tree y_x_wgsx\n+\t= build2 (MULT_EXPR, uint32_type_node,\n+\t\t  convert (uint32_type_node,\n+\t\t\t   expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_1)),\n+\t\t  wg_size_x);\n+\n+      tree sum = build2 (PLUS_EXPR, uint32_type_node, y_x_wgsx, z_x_wgsx_wgsy);\n+      sum = build2 (PLUS_EXPR, uint32_type_node,\n+\t\t    convert (uint32_type_node,\n+\t\t\t     expand_builtin (BRIG_OPCODE_WORKITEMID, uint32_0)),\n+\t\t    sum);\n+      return add_temp_var (\"workitemflatid\", sum);\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKGROUPSIZE)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree ptr_type = build_pointer_type (uint32_type_node);\n+\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n+\t\t\t     build_int_cst (ptr_type,\n+\t\t\t\t\t    PHSA_CONTEXT_WG_SIZES\n+\t\t\t\t\t    + dim * 4));\n+\t  std::string name (\"wgsize_x\");\n+\t  name [name.length() - 1] += dim;\n+\t  return add_temp_var (name.c_str(), ctx);\n+\t}\n+      else if (m_is_kernel)\n+\t{\n+\t  /* For kernels without phsa we generate certain temps before\n+\t     the WI loop, which means we don't need to rely on LICM to get\n+\t     them moved out.  */\n+\t  return m_wg_size_vars[dim];\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKITEMID)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      if (m_is_kernel)\n+\t{\n+\t  return m_local_id_vars [dim];\n+\t}\n+      else if (flag_assume_phsa)\n+\t{\n+\t  tree ptr_type = build_pointer_type (uint32_type_node);\n+\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n+\t\t\t     build_int_cst (ptr_type,\n+\t\t\t\t\t    PHSA_CONTEXT_OFFS_WI_IDS\n+\t\t\t\t\t    + dim * 4));\n+\t  std::string name (\"wiid_x\");\n+\t  name [name.length() - 1] += dim;\n+\t  return add_temp_var (name.c_str(), ctx);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_WORKGROUPID)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree ptr_type = build_pointer_type (uint32_type_node);\n+\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n+\t\t\t     build_int_cst (ptr_type,\n+\t\t\t\t\t    PHSA_CONTEXT_OFFS_WG_IDS\n+\t\t\t\t\t    + dim * 4));\n+\t  std::string name (\"wgid_x\");\n+\t  name [name.length() - 1] += dim;\n+\t  return add_temp_var (name.c_str(), ctx);\n+\t} else if (m_is_kernel)\n+\treturn m_wg_id_vars [dim];\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (brig_opcode == BRIG_OPCODE_CURRENTWORKGROUPSIZE)\n+    {\n+      HOST_WIDE_INT dim = int_constant_value (operands[0]);\n+      if (flag_assume_phsa)\n+\t{\n+\t  tree ptr_type = build_pointer_type (uint32_type_node);\n+\t  tree ctx = build2 (MEM_REF, uint32_type_node, m_context_arg,\n+\t\t\t     build_int_cst (ptr_type,\n+\t\t\t\t\t    PHSA_CONTEXT_CURRENT_WG_SIZES\n+\t\t\t\t\t    + dim * 4));\n+\t  std::string name (\"curwgsize_x\");\n+\t  name [name.length() - 1] += dim;\n+\t  return add_temp_var (name.c_str(), ctx);\n+\t} else if (m_is_kernel)\n+\treturn m_cur_wg_size_vars[dim];\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns true in case the given opcode that would normally be generated\n+   as a builtin call can be expanded to tree nodes.  */\n+\n+bool\n+brig_function::can_expand_builtin (BrigOpcode16_t brig_opcode) const\n+{\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n+    case BRIG_OPCODE_WORKITEMFLATID:\n+    case BRIG_OPCODE_WORKITEMID:\n+    case BRIG_OPCODE_WORKGROUPID:\n+    case BRIG_OPCODE_WORKGROUPSIZE:\n+      return m_is_kernel || flag_assume_phsa;\n+    case BRIG_OPCODE_WORKITEMFLATABSID:\n+    case BRIG_OPCODE_WORKITEMABSID:\n+      return m_is_kernel;\n+    default:\n+      return false;\n+    };\n+}\n+\n+/* In case the HSA instruction must be implemented using a builtin,\n+   this function is called to get the correct builtin function.\n+   TYPE is the instruction tree type, BRIG_OPCODE the opcode of the\n+   brig instruction and BRIG_TYPE the brig instruction's type.  */\n+\n+tree\n+brig_function::get_builtin_for_hsa_opcode\n+  (tree type, BrigOpcode16_t brig_opcode, BrigType16_t brig_type) const\n+{\n+  tree builtin = NULL_TREE;\n+  tree builtin_type = type;\n+\n+  /* For vector types, first find the scalar version of the builtin.  */\n+  if (type != NULL_TREE && VECTOR_TYPE_P (type))\n+    builtin_type = TREE_TYPE (type);\n+  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+\n+  /* Some BRIG opcodes can use the same builtins for unsigned and\n+     signed types.  Force these cases to unsigned types.  */\n+\n+  if (brig_opcode == BRIG_OPCODE_BORROW\n+      || brig_opcode == BRIG_OPCODE_CARRY\n+      || brig_opcode == BRIG_OPCODE_LASTBIT\n+      || brig_opcode == BRIG_OPCODE_BITINSERT)\n+    {\n+      if (brig_type == BRIG_TYPE_S32)\n+\tbrig_type = BRIG_TYPE_U32;\n+      else if (brig_type == BRIG_TYPE_S64)\n+\tbrig_type = BRIG_TYPE_U64;\n+    }\n+\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_FLOOR:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_FLOOR);\n+      break;\n+    case BRIG_OPCODE_CEIL:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_CEIL);\n+      break;\n+    case BRIG_OPCODE_SQRT:\n+    case BRIG_OPCODE_NSQRT:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_SQRT);\n+      break;\n+    case BRIG_OPCODE_RINT:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_RINT);\n+      break;\n+    case BRIG_OPCODE_TRUNC:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_TRUNC);\n+      break;\n+    case BRIG_OPCODE_COPYSIGN:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_COPYSIGN);\n+      break;\n+    case BRIG_OPCODE_NSIN:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_SIN);\n+      break;\n+    case BRIG_OPCODE_NLOG2:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_LOG2);\n+      break;\n+    case BRIG_OPCODE_NEXP2:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_EXP2);\n+      break;\n+    case BRIG_OPCODE_NFMA:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_FMA);\n+      break;\n+    case BRIG_OPCODE_NCOS:\n+      builtin = mathfn_built_in (builtin_type, BUILT_IN_COS);\n+      break;\n+    case BRIG_OPCODE_POPCOUNT:\n+      /* Popcount should be typed by its argument type (the return value\n+\t is always u32).  Let's use a b64 version for also for b32 for now.  */\n+      return builtin_decl_explicit (BUILT_IN_POPCOUNTL);\n+    case BRIG_OPCODE_BORROW:\n+      /* Borrow uses the same builtin for unsigned and signed types.  */\n+      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U32);\n+      else\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_BORROW_U64);\n+    case BRIG_OPCODE_CARRY:\n+      /* Carry also uses the same builtin for unsigned and signed types.  */\n+      if (brig_type == BRIG_TYPE_S32 || brig_type == BRIG_TYPE_U32)\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U32);\n+      else\n+\treturn builtin_decl_explicit (BUILT_IN_HSAIL_CARRY_U64);\n+    default:\n+\n+      /* Use our builtin index for finding a proper builtin for the BRIG\n+\t opcode and BRIG type.  This takes care most of the builtin cases,\n+\t the special cases are handled in the separate 'case' statements\n+\t above.  */\n+      builtin_map::const_iterator i\n+\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n+      if (i != s_custom_builtins.end ())\n+\treturn (*i).second;\n+\n+      if (brig_inner_type != brig_type)\n+\t{\n+\t  /* Try to find a scalar built-in we could use.  */\n+\t  i = s_custom_builtins.find\n+\t    (std::make_pair (brig_opcode, brig_inner_type));\n+\t  if (i != s_custom_builtins.end ())\n+\t    return (*i).second;\n+\t}\n+\n+      /* In case this is an fp16 operation that is promoted to fp32,\n+\t try to find a fp32 scalar built-in.  */\n+      if (brig_inner_type == BRIG_TYPE_F16)\n+\t{\n+\t  i = s_custom_builtins.find\n+\t    (std::make_pair (brig_opcode, BRIG_TYPE_F32));\n+\t  if (i != s_custom_builtins.end ())\n+\t    return (*i).second;\n+\t}\n+      gcc_unreachable ();\n+    }\n+\n+  if (VECTOR_TYPE_P (type) && builtin != NULL_TREE)\n+    {\n+      /* Try to find a vectorized version of the built-in.\n+\t TODO: properly assert that builtin is a mathfn builtin? */\n+      tree vec_builtin\n+\t= targetm.vectorize.builtin_vectorized_function\n+\t(builtin_mathfn_code (builtin), type, type);\n+      if (vec_builtin != NULL_TREE)\n+\treturn vec_builtin;\n+      else\n+\treturn builtin;\n+    }\n+  if (builtin == NULL_TREE)\n+    gcc_unreachable ();\n+  return builtin;\n+}\n+\n+/* Unpacks the elements of the vector in VALUE to scalars (bit field\n+   references) in ELEMENTS.  */\n+\n+void\n+brig_function::unpack (tree value, tree_stl_vec &elements)\n+{\n+  size_t vec_size = int_size_in_bytes (TREE_TYPE (value));\n+  size_t element_size\n+    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (value))) * BITS_PER_UNIT;\n+  size_t element_count\n+    = vec_size * BITS_PER_UNIT / element_size;\n+\n+  tree input_element_type = TREE_TYPE (TREE_TYPE (value));\n+\n+  value = add_temp_var (\"unpack_input\", value);\n+\n+  for (size_t i = 0; i < element_count; ++i)\n+    {\n+      tree element\n+\t= build3 (BIT_FIELD_REF, input_element_type, value,\n+\t\t  TYPE_SIZE (input_element_type),\n+\t\t  bitsize_int(i * element_size));\n+\n+      element = add_temp_var (\"scalar\", element);\n+      elements.push_back (element);\n+    }\n+}\n+\n+/* Pack the elements of the scalars in ELEMENTS to the returned vector.  */\n+\n+tree\n+brig_function::pack (tree_stl_vec &elements)\n+{\n+  size_t element_count = elements.size ();\n+\n+  gcc_assert (element_count > 1);\n+\n+  tree output_element_type = TREE_TYPE (elements.at (0));\n+\n+  vec<constructor_elt, va_gc> *constructor_vals = NULL;\n+  for (size_t i = 0; i < element_count; ++i)\n+    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, elements.at (i));\n+\n+  tree vec_type = build_vector_type (output_element_type, element_count);\n+\n+  /* build_constructor creates a vector type which is not a vector_cst\n+     that requires compile time constant elements.  */\n+  tree vec = build_constructor (vec_type, constructor_vals);\n+\n+  /* Add a temp variable for readability.  */\n+  tree tmp_var = create_tmp_var (vec_type, \"vec_out\");\n+  tree vec_tmp_assign = build2 (MODIFY_EXPR, TREE_TYPE (tmp_var), tmp_var, vec);\n+  append_statement (vec_tmp_assign);\n+  return tmp_var;\n+}\n+\n+/* Returns true in case the given opcode needs to know about work-item context\n+   data.  In such case the context data is passed as a pointer to a work-item\n+   context object, as the last argument in the builtin call.  */\n+\n+bool\n+brig_function::needs_workitem_context_data\n+(BrigOpcode16_t brig_opcode)\n+{\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_WORKITEMABSID:\n+    case BRIG_OPCODE_WORKITEMFLATABSID:\n+    case BRIG_OPCODE_WORKITEMFLATID:\n+    case BRIG_OPCODE_CURRENTWORKITEMFLATID:\n+    case BRIG_OPCODE_WORKITEMID:\n+    case BRIG_OPCODE_WORKGROUPID:\n+    case BRIG_OPCODE_WORKGROUPSIZE:\n+    case BRIG_OPCODE_CURRENTWORKGROUPSIZE:\n+    case BRIG_OPCODE_GRIDGROUPS:\n+    case BRIG_OPCODE_GRIDSIZE:\n+    case BRIG_OPCODE_DIM:\n+    case BRIG_OPCODE_PACKETID:\n+    case BRIG_OPCODE_PACKETCOMPLETIONSIG:\n+    case BRIG_OPCODE_BARRIER:\n+    case BRIG_OPCODE_WAVEBARRIER:\n+    case BRIG_OPCODE_ARRIVEFBAR:\n+    case BRIG_OPCODE_INITFBAR:\n+    case BRIG_OPCODE_JOINFBAR:\n+    case BRIG_OPCODE_LEAVEFBAR:\n+    case BRIG_OPCODE_RELEASEFBAR:\n+    case BRIG_OPCODE_WAITFBAR:\n+    case BRIG_OPCODE_CUID:\n+    case BRIG_OPCODE_MAXCUID:\n+    case BRIG_OPCODE_DEBUGTRAP:\n+    case BRIG_OPCODE_GROUPBASEPTR:\n+    case BRIG_OPCODE_KERNARGBASEPTR:\n+    case BRIG_OPCODE_ALLOCA:\n+      return true;\n+    default:\n+      return false;\n+    };\n+}\n+\n+/* Appends and returns a new temp variable and an accompanying assignment\n+   statement that stores the value of the given EXPR and has the given NAME.  */\n+\n+tree\n+brig_function::add_temp_var (std::string name, tree expr)\n+{\n+  tree temp_var = create_tmp_var (TREE_TYPE (expr), name.c_str ());\n+  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (temp_var), temp_var, expr);\n+  append_statement (assign);\n+  return temp_var;\n+}\n+\n+/* Returns the integer constant value of the given node.\n+   If it's a cast, looks into the source of the cast.  */\n+\n+HOST_WIDE_INT\n+brig_function::int_constant_value (tree node)\n+{\n+  tree n = node;\n+  if (TREE_CODE (n) == VIEW_CONVERT_EXPR)\n+    n = TREE_OPERAND (n, 0);\n+  return int_cst_value (n);\n+}\n+\n+/* Returns the tree code that should be used to implement the given\n+   HSA instruction opcode (BRIG_OPCODE) for the given type of instruction\n+   (BRIG_TYPE).  In case the opcode cannot be mapped to a TREE node directly,\n+   returns TREE_LIST (if it can be emulated with a simple chain of tree\n+   nodes) or CALL_EXPR if the opcode should be implemented using a builtin\n+   call.  */\n+\n+tree_code\n+brig_function::get_tree_code_for_hsa_opcode\n+  (BrigOpcode16_t brig_opcode, BrigType16_t brig_type)\n+{\n+  BrigType16_t brig_inner_type = brig_type & BRIG_TYPE_BASE_MASK;\n+  switch (brig_opcode)\n+    {\n+    case BRIG_OPCODE_NOP:\n+      return NOP_EXPR;\n+    case BRIG_OPCODE_ADD:\n+      return PLUS_EXPR;\n+    case BRIG_OPCODE_CMOV:\n+      if (brig_inner_type == brig_type)\n+\treturn COND_EXPR;\n+      else\n+\treturn VEC_COND_EXPR;\n+    case BRIG_OPCODE_SUB:\n+      return MINUS_EXPR;\n+    case BRIG_OPCODE_MUL:\n+    case BRIG_OPCODE_MUL24:\n+      return MULT_EXPR;\n+    case BRIG_OPCODE_MULHI:\n+    case BRIG_OPCODE_MUL24HI:\n+      return MULT_HIGHPART_EXPR;\n+    case BRIG_OPCODE_DIV:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn RDIV_EXPR;\n+      else\n+\treturn TRUNC_DIV_EXPR;\n+    case BRIG_OPCODE_NEG:\n+      return NEGATE_EXPR;\n+    case BRIG_OPCODE_MIN:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn CALL_EXPR;\n+      else\n+\treturn MIN_EXPR;\n+    case BRIG_OPCODE_MAX:\n+      if (gccbrig_is_float_type (brig_inner_type))\n+\treturn CALL_EXPR;\n+      else\n+\treturn MAX_EXPR;\n+    case BRIG_OPCODE_FMA:\n+      return FMA_EXPR;\n+    case BRIG_OPCODE_ABS:\n+      return ABS_EXPR;\n+    case BRIG_OPCODE_SHL:\n+      return LSHIFT_EXPR;\n+    case BRIG_OPCODE_SHR:\n+      return RSHIFT_EXPR;\n+    case BRIG_OPCODE_OR:\n+      return BIT_IOR_EXPR;\n+    case BRIG_OPCODE_XOR:\n+      return BIT_XOR_EXPR;\n+    case BRIG_OPCODE_AND:\n+      return BIT_AND_EXPR;\n+    case BRIG_OPCODE_NOT:\n+      return BIT_NOT_EXPR;\n+    case BRIG_OPCODE_RET:\n+      return RETURN_EXPR;\n+    case BRIG_OPCODE_MOV:\n+    case BRIG_OPCODE_LDF:\n+      return MODIFY_EXPR;\n+    case BRIG_OPCODE_LD:\n+    case BRIG_OPCODE_ST:\n+      return MEM_REF;\n+    case BRIG_OPCODE_BR:\n+      return GOTO_EXPR;\n+    case BRIG_OPCODE_REM:\n+      if (brig_type == BRIG_TYPE_U64 || brig_type == BRIG_TYPE_U32)\n+\treturn TRUNC_MOD_EXPR;\n+      else\n+\treturn CALL_EXPR;\n+    case BRIG_OPCODE_NRCP:\n+    case BRIG_OPCODE_NRSQRT:\n+      /* Implement as 1/f (x).  gcc should pattern detect that and\n+\t use a native instruction, if available, for it.  */\n+      return TREE_LIST;\n+    case BRIG_OPCODE_FLOOR:\n+    case BRIG_OPCODE_CEIL:\n+    case BRIG_OPCODE_SQRT:\n+    case BRIG_OPCODE_NSQRT:\n+    case BRIG_OPCODE_RINT:\n+    case BRIG_OPCODE_TRUNC:\n+    case BRIG_OPCODE_POPCOUNT:\n+    case BRIG_OPCODE_COPYSIGN:\n+    case BRIG_OPCODE_NCOS:\n+    case BRIG_OPCODE_NSIN:\n+    case BRIG_OPCODE_NLOG2:\n+    case BRIG_OPCODE_NEXP2:\n+    case BRIG_OPCODE_NFMA:\n+      /* Class has type B1 regardless of the float type, thus\n+\t the below builtin map search cannot find it.  */\n+    case BRIG_OPCODE_CLASS:\n+    case BRIG_OPCODE_WORKITEMABSID:\n+      return CALL_EXPR;\n+    default:\n+\n+      /* Some BRIG opcodes can use the same builtins for unsigned and\n+\t signed types.  Force these cases to unsigned types.\n+      */\n+\n+      if (brig_opcode == BRIG_OPCODE_BORROW\n+\t  || brig_opcode == BRIG_OPCODE_CARRY\n+\t  || brig_opcode == BRIG_OPCODE_LASTBIT\n+\t  || brig_opcode == BRIG_OPCODE_BITINSERT)\n+\t{\n+\t  if (brig_type == BRIG_TYPE_S32)\n+\t    brig_type = BRIG_TYPE_U32;\n+\t  else if (brig_type == BRIG_TYPE_S64)\n+\t    brig_type = BRIG_TYPE_U64;\n+\t}\n+\n+\n+      builtin_map::const_iterator i\n+\t= s_custom_builtins.find (std::make_pair (brig_opcode, brig_type));\n+      if (i != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      else if (s_custom_builtins.find\n+\t       (std::make_pair (brig_opcode, brig_inner_type))\n+\t       != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      if (brig_inner_type == BRIG_TYPE_F16\n+\t  && s_custom_builtins.find\n+\t  (std::make_pair (brig_opcode, BRIG_TYPE_F32))\n+\t  != s_custom_builtins.end ())\n+\treturn CALL_EXPR;\n+      break;\n+    }\n+  return TREE_LIST; /* Emulate using a chain of nodes.  */\n+}\n+\n+/* Inform of an update to the REG_VAR.  */\n+\n+void\n+brig_function::add_reg_var_update (tree reg_var, tree var)\n+{\n+  if (var == m_abs_id_vars[0] || var == m_abs_id_vars[1]\n+      || var == m_abs_id_vars[2] || var == m_local_id_vars[0]\n+      || var == m_local_id_vars[1] || var == m_local_id_vars[2])\n+    m_id_val_defs [reg_var] = var;\n+  else\n+    {\n+      /* Possible overwrite of an ID value.  */\n+\n+      id_val_map::iterator i = m_id_val_defs.find (reg_var);\n+      if (i != m_id_val_defs.end())\n+\tm_id_val_defs.erase (i);\n+    }\n+}\n+\n+/* If the REG_VAR is known to contain an ID value at this point in\n+   the basic block, return true.  */\n+\n+bool\n+brig_function::is_id_val (tree reg_var)\n+{\n+  id_val_map::iterator i = m_id_val_defs.find (reg_var);\n+  return i != m_id_val_defs.end();\n+}\n+\n+/* Return an ID value for the given REG_VAR if its known to contain\n+   one at this point in the BB, NULL_TREE otherwise.  */\n+\n+tree\n+brig_function::id_val (tree reg_var)\n+{\n+  id_val_map::iterator i = m_id_val_defs.find (reg_var);\n+  if (i != m_id_val_defs.end())\n+    return (*i).second;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Informs of starting a new basic block.  Called when generating\n+   a label, a call, a jump, or a return.  */\n+\n+void\n+brig_function::start_new_bb ()\n+{\n+  m_id_val_defs.clear ();\n+}"}, {"sha": "8fde3a5bfa3135a9db545d2db93e87a6df811065", "filename": "gcc/brig/brigfrontend/brig-function.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -105,6 +105,30 @@ class brig_function\n \n   void analyze_calls ();\n \n+  tree expand_builtin (BrigOpcode16_t brig_opcode, tree_stl_vec &operands);\n+\n+  tree expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n+\t\t\t       BrigType16_t brig_type, tree arith_type,\n+\t\t\t       tree_stl_vec &operands);\n+  bool can_expand_builtin (BrigOpcode16_t brig_opcode) const;\n+\n+  tree get_builtin_for_hsa_opcode (tree type, BrigOpcode16_t brig_opcode,\n+\t\t\t\t   BrigType16_t brig_type) const;\n+\n+  void unpack (tree value, tree_stl_vec &elements);\n+  tree pack (tree_stl_vec &elements);\n+  tree add_temp_var (std::string name, tree expr);\n+\n+  static bool needs_workitem_context_data (BrigOpcode16_t brig_opcode);\n+  static HOST_WIDE_INT int_constant_value (tree node);\n+  static tree_code get_tree_code_for_hsa_opcode (BrigOpcode16_t brig_opcode,\n+\t\t\t\t\t\t BrigType16_t brig_type);\n+\n+  void start_new_bb ();\n+  void add_reg_var_update (tree reg_var, tree val);\n+  bool is_id_val (tree reg_var);\n+  tree id_val (tree reg_var);\n+\n   const BrigDirectiveExecutable *m_brig_def;\n \n   bool m_is_kernel;\n@@ -183,6 +207,11 @@ class brig_function\n   tree m_wg_id_vars[3];\n   tree m_wg_size_vars[3];\n   tree m_grid_size_vars[3];\n+  /* Explicitly computed WG base for the absolute IDs which is used\n+     as the initial value when looping that dimension.   We update\n+     the abs id with ++ to make it easy for the vectorizer.  */\n+  tree m_abs_id_base_vars[3];\n+  tree m_abs_id_vars[3];\n \n   /* Set to true in case the kernel contains at least one dispatch packet\n      (work-item ID-related) builtin call that could not be expanded to\n@@ -219,6 +248,20 @@ class brig_function\n   /* Bookkeeping for the different HSA registers and their tree declarations\n      for the currently generated function.  */\n   reg_decl_index_entry *m_regs[BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT];\n+\n+  /* Map for keeping book reads of ID variables, which can be propagated\n+     to uses in address expressions to produce cleaner indexing functions\n+     with unnecessary casts stripped off, etc.  */\n+  typedef std::map<tree, tree> id_val_map;\n+\n+  /* Keeps track of ID values alive in registers in the currently\n+     processed BB.  */\n+  id_val_map m_id_val_defs;\n+\n+  /* HSAIL-specific builtin functions not yet integrated to gcc.  */\n+  typedef std::map<std::pair<BrigOpcode16_t, BrigType16_t>, tree> builtin_map;\n+\n+  static builtin_map s_custom_builtins;\n };\n \n #endif"}, {"sha": "938df82b03aca176bbea8d70295ed3d512119299", "filename": "gcc/brig/brigfrontend/brig-label-handler.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-label-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -31,7 +31,10 @@ brig_directive_label_handler::operator () (const BrigBase *base)\n   std::string label_str ((const char *) (label_name->bytes),\n \t\t\t label_name->byteCount);\n \n+  m_parent.m_cf->start_new_bb ();\n+\n   tree stmt = build_stmt (LABEL_EXPR, m_parent.m_cf->label (label_str));\n   m_parent.m_cf->append_statement (stmt);\n+\n   return base->byteCount;\n }"}, {"sha": "385da33f0893f339e889c154aeebd102bed6d0f2", "filename": "gcc/brig/brigfrontend/brig-lane-inst-handler.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-lane-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -59,7 +59,7 @@ brig_lane_inst_handler::operator () (const BrigBase *base)\n       elements.push_back (zero_cst);\n       elements.push_back (zero_cst);\n \n-      expr = pack (elements);\n+      expr = m_parent.m_cf->pack (elements);\n     }\n   else if (inst.base.opcode == BRIG_OPCODE_ACTIVELANEPERMUTE)\n     {"}, {"sha": "d8374f232fb3e3d725b13609b19c269560c604c9", "filename": "gcc/brig/brigfrontend/brig-mem-inst-handler.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -63,7 +63,7 @@ brig_mem_inst_handler::build_mem_access (const BrigInstBase *brig_inst,\n     {\n       /* Add a temporary variable so there won't be multiple\n \t reads in case of vector unpack.  */\n-      mem_ref = add_temp_var (\"mem_read\", mem_ref);\n+      mem_ref = m_parent.m_cf->add_temp_var (\"mem_read\", mem_ref);\n       return build_output_assignment (*brig_inst, data, mem_ref);\n     }\n   else\n@@ -95,8 +95,9 @@ brig_mem_inst_handler::operator () (const BrigBase *base)\n       inputs.push_back (operands[1]);\n       inputs.push_back (align_opr);\n       tree builtin_call\n-\t= expand_or_call_builtin (BRIG_OPCODE_ALLOCA, BRIG_TYPE_U32,\n-\t\t\t\t  uint32_type_node, inputs);\n+\t= m_parent.m_cf->expand_or_call_builtin (BRIG_OPCODE_ALLOCA,\n+\t\t\t\t\t\t BRIG_TYPE_U32,\n+\t\t\t\t\t\t uint32_type_node, inputs);\n       build_output_assignment (*brig_inst, operands[0], builtin_call);\n       m_parent.m_cf->m_has_allocas = true;\n       return base->byteCount;"}, {"sha": "fe0b9a59406db245976f287b73c8c2f5aaa532d5", "filename": "gcc/brig/brigfrontend/phsa.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fphsa.h?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -58,13 +58,22 @@ typedef struct __attribute__((__packed__))\n \n /* The prefix to use in the ELF section containing descriptor for\n    a function.  */\n+\n #define PHSA_DESC_SECTION_PREFIX \"phsa.desc.\"\n #define PHSA_HOST_DEF_PTR_PREFIX \"__phsa.host_def.\"\n \n /* The frontend error messages are parsed by the host runtime.  Known\n    prefix strings are used to separate the different runtime error\n    codes.  */\n+\n #define PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE \"Incompatible module: \"\n #define PHSA_ERROR_PREFIX_CORRUPTED_MODULE \"Corrupted module: \"\n \n+/* Offsets of attributes in the PHSA context structs.\n+   Used by -fphsa-wi-context-opt.  */\n+#define PHSA_CONTEXT_OFFS_WI_IDS 0\n+#define PHSA_CONTEXT_OFFS_WG_IDS (PHSA_CONTEXT_OFFS_WI_IDS + 3 * 4)\n+#define PHSA_CONTEXT_WG_SIZES (PHSA_CONTEXT_OFFS_WG_IDS + 3 * 4)\n+#define PHSA_CONTEXT_CURRENT_WG_SIZES (PHSA_CONTEXT_WG_SIZES + 3 * 4)\n+\n #endif"}, {"sha": "2cc6cb9c987ff56713b1c0813721d89fec467d86", "filename": "gcc/brig/lang.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbrig%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Flang.opt?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -31,6 +31,11 @@ BRIG Separate Alias(d)\n -dump=\n BRIG Joined Alias(d)\n \n+fassume-phsa\n+BRIG Report Var(flag_assume_phsa) Init(1) Optimization\n+Assume we are finalizing for phsa and its libhsail-rt.  Enables additional\n+phsa-specific optimizations (default).\n+\n L\n BRIG Joined Separate\n ; Not documented"}, {"sha": "5365befd3518e2936f8372b7ee5700c919138a67", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -283,7 +283,9 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT_INT, BT_UINT, BT_INT)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_ULONG, BT_UINT, BT_ULONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_LONG, BT_UINT, BT_LONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_PTR, BT_UINT, BT_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_CONST_PTR, BT_UINT, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_ULONG_PTR, BT_ULONG, BT_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_ULONG_CONST_PTR, BT_ULONG, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_ULONG_ULONG, BT_ULONG, BT_ULONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_ULONGLONG_ULONGLONG, BT_ULONGLONG, BT_ULONGLONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT8_FLOAT, BT_INT8, BT_FLOAT)\n@@ -480,6 +482,7 @@ DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_SIZE_CONST_VPTR, BT_BOOL, BT_SIZE,\n DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_INT_BOOL, BT_BOOL, BT_INT, BT_BOOL)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT_UINT, BT_VOID, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_2 (BT_FN_UINT_UINT_PTR, BT_UINT, BT_UINT, BT_PTR)\n+DEF_FUNCTION_TYPE_2 (BT_FN_UINT_UINT_CONST_PTR, BT_UINT, BT_UINT, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_SIZE, BT_PTR, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_CONST_PTR_CONST_PTR, BT_PTR, BT_CONST_PTR, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRPTR_CONST_PTR, BT_VOID, BT_PTR_PTR, BT_CONST_PTR)\n@@ -569,6 +572,7 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_DOUBLE_DOUBLEPTR_DOUBLEPTR,\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_LONGDOUBLE_LONGDOUBLEPTR_LONGDOUBLEPTR,\n \t\t     BT_VOID, BT_LONGDOUBLE, BT_LONGDOUBLE_PTR, BT_LONGDOUBLE_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_PTR_PTR, BT_VOID, BT_PTR, BT_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_PTR_UINT32, BT_VOID, BT_PTR, BT_PTR, BT_UINT32)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING, BT_PTR_CONST_STRING)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_INT_CONST_STRING_VALIST_ARG,"}, {"sha": "bba9294c2d6430608d50e3a4d3b6ab59e83155a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -1,4 +1,9 @@\n-2018-05-04 Carl Love  <cel@us.ibm.com>\n+2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* testsuite/brig.dg/test/gimple/smoke_test.hsail: Fix the test\n+\tto match the currently produced gimple.\n+\n+2018-05-04  Carl Love  <cel@us.ibm.com>\n \t* gcc.target/powerpc/vsx-vector-6.h (foo): Add test for vec_max,\n \tvec_trunc.\n \t* gcc.target/powerpc/vsx-vector-6-le.c (dg-final): Update xvcmpeqdp,"}, {"sha": "6e2326391daad66f92af1765c77ccfe9b6f4a04d", "filename": "gcc/testsuite/brig.dg/test/gimple/smoke_test.hsail", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -41,15 +41,15 @@ prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n };\n \n /* The kernel function itself should have a fingerprint as follows */\n-/* _Kernel (unsigned char * __args, void * __context, void * __group_base_addr, void * __private_base_addr) */\n-/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(unsigned char \\\\\\* __args, void \\\\\\* __context, void \\\\\\* __group_base_addr, unsigned int __group_local_offset, void \\\\\\* __private_base_addr\\\\\\)\" \"gimple\"} } */\n+/* _Kernel (const unsigned char * restrict __args, void * restrict __context, unsigned char * restrict __group_base_addr, unsigned int __group_local_offset, unsigned char * restrict __private_base_addr) */\n+/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(const unsigned char \\\\\\* restrict __args, void \\\\\\* restrict __context, unsigned char \\\\\\* restrict __group_base_addr, unsigned int __group_local_offset, unsigned char \\\\\\* restrict __private_base_addr\\\\\\)\" \"gimple\"} } */\n \n /* ld_kernarg: mem_read.0 = MEM[(unsigned long *)__args]; */\n /* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = MEM\\\\\\[\\\\\\(unsigned long \\\\\\*\\\\\\)__args\\\\\\];\" \"gimple\"} } */\n \n /* The latter ld_global_u32 should be visible as a pointer dereference (after pointer arithmetics on a temporary var): */\n /* mem_read.2 = *D.1691; */\n-/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = \\\\\\*\\[_0-9\\]+;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]+ = \\\\\\*\\[_0-9\\]+;\" \"gimple\"} } */\n \n /* add_u32s should generate +operators */\n /* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\" \"gimple\"} } */\n@@ -71,8 +71,8 @@ prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n /* { dg-final { scan-tree-dump \"if \\\\\\(__local_z < __cur_wg_size_z\\\\\\) goto __wi_loop_z; else goto\" \"gimple\"} } */\n \n /* The launcher should call __hsail_launch_wg_function in this case: */\n-/* Kernel (void * __context, void * __group_base_addr) */\n-/* { dg-final { scan-tree-dump \"Kernel \\\\\\(void \\\\\\* __context, void \\\\\\* __group_base_addr\\\\\\)\" \"gimple\"} } */\n+/* Kernel (void * restrict __context, unsigned char * restrict __group_base_addr) */\n+/* { dg-final { scan-tree-dump \"Kernel \\\\\\(void \\\\\\* restrict __context, unsigned char \\\\\\* restrict __group_base_addr\\\\\\)\" \"gimple\"} } */\n /* { dg-final { scan-tree-dump \"__hsail_launch_wg_function \\\\\\(_Kernel, __context, __group_base_addr, group_local_offset.*\\\\\\);\" \"gimple\"} }*/\n \n /* The kernel should have the magic metadata section injected to the ELF. */"}, {"sha": "17aeb6e490c9f91632215a2eb5d7703099db1f6c", "filename": "libhsail-rt/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FChangeLog?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -1,3 +1,10 @@\n+2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* include/internal/phsa-rt.h: Whitespace cleanup.\n+\t* include/internal/workitems.h: Store work item ID data to easily\n+\taccessible locations.\n+\t* rt/workitems.c: Same.\n+\n 2018-05-04  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* rt/workitems.c: Fix an alloca stack underflow."}, {"sha": "c09f18d0095e0d5181329a2c95327b1361aca3c3", "filename": "libhsail-rt/include/internal/phsa-rt.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -54,7 +54,6 @@ typedef void (*gccbrigKernelFunc) (unsigned char *, void *, void *, uint32_t,\n */\n typedef struct\n {\n-\n   /* Data set by the HSA Runtime's kernel launcher.  */\n   hsa_kernel_dispatch_packet_t *dp;\n "}, {"sha": "0839853ff122d19d95654a59cb0d2211969e8c59", "filename": "libhsail-rt/include/internal/workitems.h", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -45,11 +45,6 @@\n \n typedef struct\n {\n-  /* The group id of the currently executed WG.  */\n-  size_t x;\n-  size_t y;\n-  size_t z;\n-\n   /* This is 1 in case there are more work groups to execute.\n      If 0, the work-item threads should finish themselves.  */\n   int more_wgs;\n@@ -89,24 +84,59 @@ typedef struct\n      stack frame.  Initialized to point outside the private segment.  */\n   uint32_t alloca_frame_p;\n \n+  /* The group id of the currently executed WG.  This is for fiber based\n+     execution.  The group ids are duplicated also to the per WI context\n+     struct for simplified single pointer access in the GCCBRIG produced\n+     code.\n+   */\n+\n+  uint32_t x;\n+  uint32_t y;\n+  uint32_t z;\n+\n } PHSAWorkGroup;\n \n /* Data identifying a single work-item, passed to the work-item thread in case\n    of a fiber based work-group execution.  */\n \n typedef struct\n {\n+  /* NOTE: These members STARTing here should not be moved as they are\n+     accessed directly by code emitted by BRIG FE.   */\n+\n+  /* The local id of the current WI. */\n+\n+  uint32_t x;\n+  uint32_t y;\n+  uint32_t z;\n+\n+  /* The group id of the currently executed WG.  */\n+\n+  uint32_t group_x;\n+  uint32_t group_y;\n+  uint32_t group_z;\n+\n+  /* The local size of a complete WG.  */\n+\n+  uint32_t wg_size_x;\n+  uint32_t wg_size_y;\n+  uint32_t wg_size_z;\n+\n+  /* The local size of the current WG.  */\n+\n+  uint32_t cur_wg_size_x;\n+  uint32_t cur_wg_size_y;\n+  uint32_t cur_wg_size_z;\n+\n+  /* NOTE: Fixed members END here.  */\n+\n   PHSAKernelLaunchData *launch_data;\n   /* Identifies and keeps book of the currently executed WG of the WI swarm.  */\n   volatile PHSAWorkGroup *wg;\n-  /* The local id of the current WI.  */\n-  size_t x;\n-  size_t y;\n-  size_t z;\n #ifdef HAVE_FIBERS\n   fiber_t fiber;\n #endif\n-} PHSAWorkItem;\n+} __attribute__((packed)) PHSAWorkItem;\n \n \n #endif"}, {"sha": "c846350e1cdb5d22d26fa1b569912cca50cd9e03", "filename": "libhsail-rt/rt/workitems.c", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Frt%2Fworkitems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/080dc24383a602a5a4095eb05b04100f15ba1ad4/libhsail-rt%2Frt%2Fworkitems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fworkitems.c?ref=080dc24383a602a5a4095eb05b04100f15ba1ad4", "patch": "@@ -107,11 +107,20 @@ phsa_work_item_thread (int arg0, int arg1)\n \t the current_work_group_* is set to point to the WG executed next.  */\n       if (!wi->wg->more_wgs)\n \tbreak;\n+\n+      wi->group_x = wg->x;\n+      wi->group_y = wg->y;\n+      wi->group_z = wg->z;\n+\n+      wi->cur_wg_size_x = __hsail_currentworkgroupsize (0, wi);\n+      wi->cur_wg_size_y = __hsail_currentworkgroupsize (1, wi);\n+      wi->cur_wg_size_z = __hsail_currentworkgroupsize (2, wi);\n+\n #ifdef DEBUG_PHSA_RT\n       printf (\n \t\"Running work-item %lu/%lu/%lu for wg %lu/%lu/%lu / %lu/%lu/%lu...\\n\",\n-\twi->x, wi->y, wi->z, wg->x, wg->y, wg->z, l_data->wg_max_x,\n-\tl_data->wg_max_y, l_data->wg_max_z);\n+\twi->x, wi->y, wi->z, wi->group_x, wi->group_y, wi->group_z,\n+\tl_data->wg_max_x, l_data->wg_max_y, l_data->wg_max_z);\n #endif\n \n       if (wi->x < __hsail_currentworkgroupsize (0, wi)\n@@ -180,6 +189,13 @@ phsa_work_item_thread (int arg0, int arg1)\n \t  else\n \t    wg->x++;\n #endif\n+\t  wi->group_x = wg->x;\n+\t  wi->group_y = wg->y;\n+\t  wi->group_z = wg->z;\n+\n+\t  wi->cur_wg_size_x = __hsail_currentworkgroupsize (0, wi);\n+\t  wi->cur_wg_size_y = __hsail_currentworkgroupsize (1, wi);\n+\t  wi->cur_wg_size_z = __hsail_currentworkgroupsize (2, wi);\n \n \t  /* Reinitialize the work-group barrier according to the new WG's\n \t     size, which might not be the same as the previous ones, due\n@@ -233,6 +249,7 @@ phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n   PHSAWorkItem *wi_threads = NULL;\n   PHSAWorkGroup wg;\n   size_t flat_wi_id = 0, x, y, z, max_x, max_y, max_z;\n+  uint32_t group_x, group_y, group_z;\n   fiber_barrier_t wg_start_barrier;\n   fiber_barrier_t wg_completion_barrier;\n   fiber_barrier_t wg_sync_barrier;\n@@ -257,13 +274,13 @@ phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n   wg.initial_group_offset = group_local_offset;\n \n #ifdef EXECUTE_WGS_BACKWARDS\n-  wg.x = context->wg_max_x - 1;\n-  wg.y = context->wg_max_y - 1;\n-  wg.z = context->wg_max_z - 1;\n+  group_x = context->wg_max_x - 1;\n+  group_y = context->wg_max_y - 1;\n+  group_z = context->wg_max_z - 1;\n #else\n-  wg.x = context->wg_min_x;\n-  wg.y = context->wg_min_y;\n-  wg.z = context->wg_min_z;\n+  group_x = context->wg_min_x;\n+  group_y = context->wg_min_y;\n+  group_z = context->wg_min_z;\n #endif\n \n   fiber_barrier_init (&wg_sync_barrier, wg_size);\n@@ -290,6 +307,19 @@ phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n \t  PHSAWorkItem *wi = &wi_threads[flat_wi_id];\n \t  wi->launch_data = context;\n \t  wi->wg = &wg;\n+\n+\t  wg.x = wi->group_x = group_x;\n+\t  wg.y = wi->group_y = group_y;\n+\t  wg.z = wi->group_z = group_z;\n+\n+\t  wi->wg_size_x = context->dp->workgroup_size_x;\n+\t  wi->wg_size_y = context->dp->workgroup_size_y;\n+\t  wi->wg_size_z = context->dp->workgroup_size_z;\n+\n+\t  wi->cur_wg_size_x = __hsail_currentworkgroupsize (0, wi);\n+\t  wi->cur_wg_size_y = __hsail_currentworkgroupsize (1, wi);\n+\t  wi->cur_wg_size_z = __hsail_currentworkgroupsize (2, wi);\n+\n \t  wi->x = x;\n \t  wi->y = y;\n \t  wi->z = z;\n@@ -467,9 +497,17 @@ phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr,\n     for (wg_y = context->wg_min_y; wg_y < context->wg_max_y; ++wg_y)\n       for (wg_x = context->wg_min_x; wg_x < context->wg_max_x; ++wg_x)\n \t{\n-\t  wi.wg->x = wg_x;\n-\t  wi.wg->y = wg_y;\n-\t  wi.wg->z = wg_z;\n+\t  wi.group_x = wg_x;\n+\t  wi.group_y = wg_y;\n+\t  wi.group_z = wg_z;\n+\n+\t  wi.wg_size_x = context->dp->workgroup_size_x;\n+\t  wi.wg_size_y = context->dp->workgroup_size_y;\n+\t  wi.wg_size_z = context->dp->workgroup_size_z;\n+\n+\t  wi.cur_wg_size_x = __hsail_currentworkgroupsize (0, &wi);\n+\t  wi.cur_wg_size_y = __hsail_currentworkgroupsize (1, &wi);\n+\t  wi.cur_wg_size_z = __hsail_currentworkgroupsize (2, &wi);\n \n \t  context->kernel (context->kernarg_addr, &wi, group_base_ptr,\n \t\t\t   group_local_offset, private_base_ptr);\n@@ -564,15 +602,15 @@ __hsail_workitemabsid (uint32_t dim, PHSAWorkItem *context)\n     default:\n     case 0:\n       /* Overflow semantics in the case of WG dim > grid dim.  */\n-      id = ((uint64_t) context->wg->x * dp->workgroup_size_x + context->x)\n+      id = ((uint64_t) context->group_x * dp->workgroup_size_x + context->x)\n \t   % dp->grid_size_x;\n       break;\n     case 1:\n-      id = ((uint64_t) context->wg->y * dp->workgroup_size_y + context->y)\n+      id = ((uint64_t) context->group_y * dp->workgroup_size_y + context->y)\n \t   % dp->grid_size_y;\n       break;\n     case 2:\n-      id = ((uint64_t) context->wg->z * dp->workgroup_size_z + context->z)\n+      id = ((uint64_t) context->group_z * dp->workgroup_size_z + context->z)\n \t   % dp->grid_size_z;\n       break;\n     }\n@@ -590,15 +628,15 @@ __hsail_workitemabsid_u64 (uint32_t dim, PHSAWorkItem *context)\n     default:\n     case 0:\n       /* Overflow semantics in the case of WG dim > grid dim.  */\n-      id = ((uint64_t) context->wg->x * dp->workgroup_size_x + context->x)\n+      id = ((uint64_t) context->group_x * dp->workgroup_size_x + context->x)\n \t   % dp->grid_size_x;\n       break;\n     case 1:\n-      id = ((uint64_t) context->wg->y * dp->workgroup_size_y + context->y)\n+      id = ((uint64_t) context->group_y * dp->workgroup_size_y + context->y)\n \t   % dp->grid_size_y;\n       break;\n     case 2:\n-      id = ((uint64_t) context->wg->z * dp->workgroup_size_z + context->z)\n+      id = ((uint64_t) context->group_z * dp->workgroup_size_z + context->z)\n \t   % dp->grid_size_z;\n       break;\n     }\n@@ -738,19 +776,19 @@ __hsail_currentworkgroupsize (uint32_t dim, PHSAWorkItem *wi)\n     {\n     default:\n     case 0:\n-      if ((uint64_t) wi->wg->x < dp->grid_size_x / dp->workgroup_size_x)\n+      if ((uint64_t) wi->group_x < dp->grid_size_x / dp->workgroup_size_x)\n \twg_size = dp->workgroup_size_x; /* Full WG.  */\n       else\n \twg_size = dp->grid_size_x % dp->workgroup_size_x; /* Partial WG.  */\n       break;\n     case 1:\n-      if ((uint64_t) wi->wg->y < dp->grid_size_y / dp->workgroup_size_y)\n+      if ((uint64_t) wi->group_y < dp->grid_size_y / dp->workgroup_size_y)\n \twg_size = dp->workgroup_size_y; /* Full WG.  */\n       else\n \twg_size = dp->grid_size_y % dp->workgroup_size_y; /* Partial WG.  */\n       break;\n     case 2:\n-      if ((uint64_t) wi->wg->z < dp->grid_size_z / dp->workgroup_size_z)\n+      if ((uint64_t) wi->group_z < dp->grid_size_z / dp->workgroup_size_z)\n \twg_size = dp->workgroup_size_z; /* Full WG.  */\n       else\n \twg_size = dp->grid_size_z % dp->workgroup_size_z; /* Partial WG.  */\n@@ -798,11 +836,11 @@ __hsail_workgroupid (uint32_t dim, PHSAWorkItem *wi)\n     {\n     default:\n     case 0:\n-      return wi->wg->x;\n+      return wi->group_x;\n     case 1:\n-      return wi->wg->y;\n+      return wi->group_y;\n     case 2:\n-      return wi->wg->z;\n+      return wi->group_z;\n     }\n }\n "}]}