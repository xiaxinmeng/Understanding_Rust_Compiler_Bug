{"sha": "9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlNzAzMTNiYzk5OWYwNDRjOGFmZmMxMmUwMWFiNDFiOGNjZDZjNQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-01T07:42:37Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-01T07:42:37Z"}, "message": "cppexp.c: (_cpp_parse_expr): Numerical constants are pushed within the switch statement.\n\n        * cppexp.c: (_cpp_parse_expr): Numerical constants are pushed\n        within the switch statement.  Binary operations break out of\n        the switch naturally.  '(' tokens handled by forcing\n        immediate shift.  ')' handled by forcing immediate reduce to\n        the previous '('.  New error messages.\n\nFrom-SVN: r32854", "tree": {"sha": "53012977ab4e9d966588e6df27ef231ad9086875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53012977ab4e9d966588e6df27ef231ad9086875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee70313bc999f044c8affc12e01ab41b8ccd6c5/comments", "author": null, "committer": null, "parents": [{"sha": "81eace42692969b248028fffcccb67818c251279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81eace42692969b248028fffcccb67818c251279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81eace42692969b248028fffcccb67818c251279"}], "stats": {"total": 138, "additions": 76, "deletions": 62}, "files": [{"sha": "95021a000619eddb57ecac501fa99d6c4f1f148e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee70313bc999f044c8affc12e01ab41b8ccd6c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee70313bc999f044c8affc12e01ab41b8ccd6c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "patch": "@@ -1,3 +1,11 @@\n+2000-04-01  Neil Booth <NeilB@earthling.net>\n+\n+        * cppexp.c: (_cpp_parse_expr): Numerical constants are pushed\n+        within the switch statement.  Binary operations break out of\n+        the switch naturally.  '(' tokens handled by forcing\n+        immediate shift.  ')' handled by forcing immediate reduce to\n+        the previous '('.  New error messages.\n+\t\n 2000-03-31  Geoff Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.c (print_operand): Don't use %l for 'low"}, {"sha": "d8e646c459118cc2faa8b56b433eef71067757ff", "filename": "gcc/cppexp.c", "status": "modified", "additions": 68, "deletions": 62, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee70313bc999f044c8affc12e01ab41b8ccd6c5/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee70313bc999f044c8affc12e01ab41b8ccd6c5/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "patch": "@@ -699,7 +699,7 @@ _cpp_parse_expr (pfile)\n       U_CHAR flags = 0;\n \n       /* Read a token */\n-      op =  lex (pfile, skip_evaluation);\n+      op = lex (pfile, skip_evaluation);\n \n       /* See if the token is an operand, in which case go to set_value.\n \t If the token is an operator, figure out its left and right\n@@ -710,16 +710,29 @@ _cpp_parse_expr (pfile)\n \tcase NAME:\n \t  cpp_ice (pfile, \"lex returns a NAME\");\n \t  goto syntax_error;\n+\tcase ERROR:\n+\t  goto syntax_error;\n+\tdefault:\n+\t  cpp_error (pfile, \"invalid character in #if\");\n+\t  goto syntax_error;\n+\n \tcase INT:  case CHAR:\n-\t  goto set_value;\n-\tcase 0:\n-\t  lprio = 0;  goto maybe_reduce;\n-\tcase '+':  case '-':\n+\tpush_immediate:\n+\t  /* Push a value onto the stack.  */\n \t  if (top->flags & HAVE_VALUE)\n \t    {\n-\t      lprio = PLUS_PRIO;\n-\t      goto binop;\n+\t      cpp_error (pfile, \"suspected missing binary operator in #if\");\n+\t      goto syntax_error;\n \t    }\n+\t  top->value = op.value;\n+\t  top->unsignedp = op.unsignedp;\n+\t  top->flags |= HAVE_VALUE;\n+\t  continue;\n+\n+\tcase '+':  case '-':\n+\t  lprio = PLUS_PRIO;\n+\t  if (top->flags & HAVE_VALUE)\n+\t      break;\n \t  if (top->flags & SIGN_QUALIFIED)\n \t    {\n \t      cpp_error (pfile, \"more than one sign operator given\");\n@@ -730,24 +743,25 @@ _cpp_parse_expr (pfile)\n \tcase '!':  case '~':\n \t  flags |= RIGHT_OPERAND_REQUIRED;\n \t  rprio = UNARY_PRIO;  lprio = rprio + 1;  goto maybe_reduce;\n+\n \tcase '*':  case '/':  case '%':\n-\t  lprio = MUL_PRIO;  goto binop;\n+\t  lprio = MUL_PRIO;  break;\n \tcase '<':  case '>':  case LEQ:  case GEQ:\n-\t  lprio = LESS_PRIO;  goto binop;\n+\t  lprio = LESS_PRIO;  break;\n \tcase EQUAL:  case NOTEQUAL:\n-\t  lprio = EQUAL_PRIO;  goto binop;\n+\t  lprio = EQUAL_PRIO;  break;\n \tcase LSH:  case RSH:\n-\t  lprio = SHIFT_PRIO;  goto binop;\n-\tcase '&':  lprio = AND_PRIO;  goto binop;\n-\tcase '^':  lprio = XOR_PRIO;  goto binop;\n-\tcase '|':  lprio = OR_PRIO;  goto binop;\n-\tcase ANDAND:  lprio = ANDAND_PRIO;  goto binop;\n-\tcase OROR:  lprio = OROR_PRIO;  goto binop;\n+\t  lprio = SHIFT_PRIO;  break;\n+\tcase '&':  lprio = AND_PRIO;  break;\n+\tcase '^':  lprio = XOR_PRIO;  break;\n+\tcase '|':  lprio = OR_PRIO;  break;\n+\tcase ANDAND:  lprio = ANDAND_PRIO;  break;\n+\tcase OROR:  lprio = OROR_PRIO;  break;\n \tcase ',':\n-\t  lprio = COMMA_PRIO;  goto binop;\n+\t  lprio = COMMA_PRIO;  break;\n \tcase '(':\n-\t  lprio = PAREN_OUTER_PRIO;  rprio = PAREN_INNER_PRIO;\n-\t  goto maybe_reduce;\n+\t  lprio = PAREN_OUTER_PRIO;  rprio = PAREN_INNER_PRIO + 1;\n+\t  goto skip_reduction;\n \tcase ')':\n \t  lprio = PAREN_INNER_PRIO;  rprio = PAREN_OUTER_PRIO;\n \t  flags = HAVE_VALUE;\t/* At least, we will have after reduction.  */\n@@ -758,26 +772,11 @@ _cpp_parse_expr (pfile)\n         case '?':\n \t  lprio = COND_PRIO;  rprio = COND_PRIO;\n \t  goto maybe_reduce;\n-\tcase ERROR:\n-\t  goto syntax_error;\n-\tdefault:\n-\t  cpp_error (pfile, \"invalid character in #if\");\n-\t  goto syntax_error;\n-\t}\n-\n-    set_value:\n-      /* Push a value onto the stack.  */\n-      if (top->flags & HAVE_VALUE)\n-\t{\n-\t  cpp_error (pfile, \"syntax error in #if\");\n-\t  goto syntax_error;\n+\tcase 0:\n+\t  lprio = 0;  goto maybe_reduce;\n \t}\n-      top->value = op.value;\n-      top->unsignedp = op.unsignedp;\n-      top->flags |= HAVE_VALUE;\n-      continue;\n \n-    binop:\n+      /* Binary operation.  */\n       flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n       rprio = lprio + 1;\n \n@@ -953,7 +952,7 @@ _cpp_parse_expr (pfile)\n \t      top->value = v2;\n \t      top->unsignedp = unsigned2;\n \t      break;\n-\t    case '(':  case '?':\n+\t    case '?':\n \t      cpp_error (pfile, \"syntax error in #if\");\n \t      goto syntax_error;\n \t    case ':':\n@@ -979,21 +978,22 @@ _cpp_parse_expr (pfile)\n \t\t}\n \t      break;\n \t    case ')':\n-\t      if (! (top[0].flags & HAVE_VALUE)\n-\t\t  || top[0].op != '('\n-\t\t  || (top[-1].flags & HAVE_VALUE))\n+\t      cpp_error (pfile, \"missing '(' in expression\");\n+\t      goto syntax_error;\n+\t    case '(':\n+\t      if (op.op != ')')\n \t\t{\n-\t\t  cpp_error (pfile, \"mismatched parentheses in #if\");\n+\t\t  cpp_error (pfile, \"missing ')' in expression\");\n \t\t  goto syntax_error;\n \t\t}\n-\t      else\n+\t      if (!(top[1].flags & HAVE_VALUE))\n \t\t{\n-\t\t  top--;\n-\t\t  top->value = v1;\n-\t\t  top->unsignedp = unsigned1;\n-\t\t  top->flags |= HAVE_VALUE;\n+\t\t  cpp_error (pfile, \"void expression between '(' and ')'\");\n+\t\t  goto syntax_error;\n \t\t}\n-\t      break;\n+\t      op.value = v2;\n+\t      op.unsignedp = unsigned2;\n+\t      goto push_immediate;\n \t    default:\n \t      if (ISGRAPH (top[1].op))\n \t\tcpp_error (pfile, \"unimplemented operator '%c'\\n\", top[1].op);\n@@ -1002,18 +1002,13 @@ _cpp_parse_expr (pfile)\n \t\t\t   top[1].op);\n \t    }\n \t}\n+\n       if (op.op == 0)\n-\t{\n-\t  if (top != stack)\n-\t    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n-\t  if (!(top->flags & HAVE_VALUE))\n-\t    cpp_error (pfile, \"#if with no expression\");\n-\t  result = (top->value != 0);\n-\t  goto done;\n-\t}\n-      top++;\n-      \n+\tbreak;\n+\n+    skip_reduction:\n       /* Check for and handle stack overflow.  */\n+      top++;\n       if (top == limit)\n \t{\n \t  struct operation *new_stack;\n@@ -1034,6 +1029,8 @@ _cpp_parse_expr (pfile)\n       top->flags = flags;\n       top->rprio = rprio;\n       top->op = op.op;\n+\n+      /* Handle short circuiting.  */\n       if ((op.op == OROR && top[-1].value)\n \t  || (op.op == ANDAND && !top[-1].value)\n \t  || (op.op == '?' && !top[-1].value))\n@@ -1048,13 +1045,22 @@ _cpp_parse_expr (pfile)\n \t    skip_evaluation--;\n \t}\n     }\n- syntax_error:\n-  _cpp_skip_rest_of_line (pfile);\n-  result = 0;\n- done:\n+\n+  if (top != stack)\n+    cpp_ice (pfile, \"unbalanced stack in #if expression\");\n+  if (!(top->flags & HAVE_VALUE))\n+    cpp_error (pfile, \"#if with no expression\");\n+  result = (top->value != 0);\n+\n+ tidy_up:\n   pfile->parsing_if_directive--;\n   CPP_SET_WRITTEN (pfile, old_written);\n   if (stack != init_stack)\n     free (stack);\n   return result;\n+\n+ syntax_error:\n+  _cpp_skip_rest_of_line (pfile);\n+  result = 0;\n+  goto tidy_up;\n }"}]}