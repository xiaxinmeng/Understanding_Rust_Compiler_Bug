{"sha": "97b65a3e66724ccf7c2a2fb8e3f98460665d7016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdiNjVhM2U2NjcyNGNjZjdjMmEyZmI4ZTNmOTg0NjA2NjVkNzAxNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:19:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:19:15Z"}, "message": "Correct errors in comments.\n\n(CONDITIONAL_REGISTER_USAGE): Delete TARGET_NOSAVE support.\n(TARGET_MAC, TARGET_TRYR0, TARGET_NOSAVE, TARGET_SMALLCALL,\nTARGET_PARANOID, TARGET_RETR2, TARGET_SHORTADDR, TARGET_BSR): Delete.\n(TARGET_SWITCHES): Delete above options.\n(OVERRIDE_OPTIONS): Delete TARGET_BSR support.\n(FUNCTION_BOUNDARY): Use 32 bit alignment when not TARGET_SMALLCODE.\n(FIRST_RET_REG): Delete TARGET_RETR2 support.\n(MODE_DISP_OK_[21]): Delete TARGET_TRYR0 support.\n(EXTRA_CONSTRAINT_U): Delete.\n(CONST_COSTS): For logical operations, give L constants cost 1.\n(PRINT_OPERAND_PUNCT_VALID_P): Delete '*', '^', '!'.\n\nFrom-SVN: r8890", "tree": {"sha": "68fc939d49a1a9a5cc2c170928e910ca0aa943d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68fc939d49a1a9a5cc2c170928e910ca0aa943d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97b65a3e66724ccf7c2a2fb8e3f98460665d7016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b65a3e66724ccf7c2a2fb8e3f98460665d7016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b65a3e66724ccf7c2a2fb8e3f98460665d7016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b65a3e66724ccf7c2a2fb8e3f98460665d7016/comments", "author": null, "committer": null, "parents": [{"sha": "5325c0fa5778943372e0ad81912b495b829fe071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5325c0fa5778943372e0ad81912b495b829fe071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5325c0fa5778943372e0ad81912b495b829fe071"}], "stats": {"total": 95, "additions": 26, "deletions": 69}, "files": [{"sha": "41b8b6d3eff0bf44517b2d26dd84bc43b95de6c7", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 26, "deletions": 69, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97b65a3e66724ccf7c2a2fb8e3f98460665d7016/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97b65a3e66724ccf7c2a2fb8e3f98460665d7016/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=97b65a3e66724ccf7c2a2fb8e3f98460665d7016", "patch": "@@ -54,14 +54,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-  /* Experimental calling convention with fewer saved registers */\t\\\n-  if (TARGET_NOSAVE)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      call_used_regs[8] = 1;\t\t\t\t\t\\\n-      call_used_regs[9] = 1;\t\t\t\t\t\\\n-      call_used_regs[10] = 1;\t\t\t\t\t\\\n-      call_used_regs[11] = 1;\t\t\t\t\t\\\n-    }    \t\t\t\t\t\t\t\\\n   /* Hitachi saves and restores mac registers on call */        \\\n   if (TARGET_HITACHI)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n@@ -75,7 +67,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n extern int target_flags;\n #define ISIZE_BIT      \t(1<<1)\n #define FAST_BIT       \t(1<<2)\n-#define MAC_BIT        \t(1<<3)\n #define RTL_BIT        \t(1<<4)\n #define DT_BIT         \t(1<<5)\n #define DALIGN_BIT     \t(1<<6)\n@@ -87,17 +78,10 @@ extern int target_flags;\n #define R_BIT     \t(1<<12)\n #define SPACE_BIT \t(1<<13)\n #define BIGTABLE_BIT  \t(1<<14)\n-#define TRYR0_BIT  \t(1<<15)\n-#define NOSAVE_BIT  \t(1<<16)\n-#define SMALLCALL_BIT  \t(1<<17)\n #define CONSTLEN_2_BIT  (1<<20)\n #define CONSTLEN_3_BIT  (1<<21)\n #define HITACHI_BIT     (1<<22)\n-#define PARANOID_BIT    (1<<23)\n-#define RETR2_BIT       (1<<24)\n #define CONSTLEN_0_BIT  (1<<25)\n-#define BSR_BIT   \t(1<<26)\n-#define SHORTADDR_BIT   (1<<27)\n #define PACKSTRUCT_BIT  (1<<28)\n #define LITTLE_ENDIAN_BIT (1<<29)\n \n@@ -116,15 +100,12 @@ extern int target_flags;\n /* Nonzero if we should generate faster code rather than smaller code */\n #define TARGET_FASTCODE   (target_flags & FAST_BIT)\n \n-/* Nonzero if we should generate faster code rather than smaller code */\n+/* Nonzero if we should generate smaller code rather than faster code */\n #define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n \n /* Nonzero if we should dump out instruction size info */\n #define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n \n-/* Nonzero if we should try to generate mac instructions */\n-#define TARGET_MAC        (target_flags & MAC_BIT)\n-\n /* Nonzero if we should dump the rtl in the assembly file. */\n #define TARGET_DUMP_RTL\t  (target_flags & RTL_BIT)\n \n@@ -140,16 +121,6 @@ extern int target_flags;\n /* Nonzero if combine dumping wanted */\n #define TARGET_CDUMP (target_flags & C_BIT)\n \n-/* Nonzero if trying to use reg+disp for QIs and HIs.  This\n-   doesn't work yet.*/\n-#define TARGET_TRYR0 (target_flags & TRYR0_BIT)\n-\n-/* Nonzero if using no save calling convention */\n-#define TARGET_NOSAVE (target_flags & NOSAVE_BIT)\n-\n-/* Nonzero if using no save calling convention */\n-#define TARGET_SMALLCALL (target_flags & SMALLCALL_BIT)\n-\n /* Select max size of computed constant code sequences to be 3 insns */\n #define TARGET_CLEN3 (target_flags & CONSTLEN_3_BIT)\n \n@@ -159,11 +130,6 @@ extern int target_flags;\n /* Nonzero if using Hitachi's calling convention */\n #define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n \n-#define TARGET_PARANOID \t(target_flags & PARANOID_BIT)\n-#define TARGET_RETR2 \t\t(target_flags & RETR2_BIT)\n-#define TARGET_SHORTADDR\t(target_flags & SHORTADDR_BIT)\n-#define TARGET_BSR\t\t(target_flags & BSR_BIT)\n-\n /* Nonzero if packing structures as small as they'll go (incompatible with Hitachi's compiler) */\n #define TARGET_PACKSTRUCT       (target_flags & PACKSTRUCT_BIT)\n \n@@ -177,26 +143,18 @@ extern int target_flags;\n   {\"3\",\t        (SH3_BIT) },\t\t\t\\\n   {\"3l\",        (SH3_BIT|LITTLE_ENDIAN_BIT)},\t\\\n   {\"R\",  \t(R_BIT) },\t\t\t\\\n-  {\"ac\",  \t(MAC_BIT) },\t\t\t\\\n   {\"b\",\t\t(-LITTLE_ENDIAN_BIT) },  \t\\\n   {\"bigtable\", \t(BIGTABLE_BIT)},\t\t\\\n-  {\"bsr\",       (BSR_BIT) },    \t\t\\\n   {\"c\",  \t(C_BIT) },\t\t\t\\\n   {\"clen0\",     (CONSTLEN_0_BIT) },    \t\t\\\n   {\"clen3\",     (CONSTLEN_3_BIT) },    \t\t\\\n   {\"dalign\",  \t(DALIGN_BIT) },\t\t\t\\\n   {\"hitachi\",\t(HITACHI_BIT) },\t\t\\\n   {\"isize\", \t(ISIZE_BIT) },\t\t\t\\\n   {\"l\",\t\t(LITTLE_ENDIAN_BIT) },  \t\\\n-  {\"nosave\",  \t(NOSAVE_BIT) },\t\t\t\\\n   {\"packstruct\",(PACKSTRUCT_BIT) },    \t\t\\\n-  {\"paranoid\",\t(PARANOID_BIT) },\t\t\\\n   {\"r\",  \t(RTL_BIT) },\t\t\t\\\n-  {\"r2\",\t(RETR2_BIT) },\t\t\t\\\n-  {\"shortaddr\", (SHORTADDR_BIT) },\t     \t\\\n-  {\"smallcall\",\t(SMALLCALL_BIT) },\t\t\\\n   {\"space\", \t(SPACE_BIT) },\t\t\t\\\n-  {\"try-r0\", \t(TRYR0_BIT)},\t\t\t\\\n   {\"\",   \tTARGET_DEFAULT} \t\t\\\n }\n \n@@ -237,8 +195,6 @@ do {\t\t\t\t\t\t\t\t\\\n     max_count_hi = atoi (max_hi);\t\t\t\t\\\n   else      \t\t\t\t\t\t\t\\\n     max_count_hi = 500;\t\t\t\t                \\\n-  if (TARGET_BSR)                                               \\\n-     flag_no_function_cse = 1;                                  \\\n } while (0)\n \n \f\n@@ -293,8 +249,10 @@ do {\t\t\t\t\t\t\t\t\\\n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY  32\n \n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY  16\n+/* Allocation boundary (in *bits*) for the code of a function.\n+   32 bit alignment is faster, because instructions are always fetched as a\n+   pair from a longword boundary.  */\n+#define FUNCTION_BOUNDARY  (TARGET_SMALLCODE ? 16 : 32)\n \n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY  32\n@@ -362,7 +320,8 @@ do {\t\t\t\t\t\t\t\t\\\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator. \n \n-   mach register is fixed 'cause it's only 10 bits wide */\n+   Mach register is fixed 'cause it's only 10 bits wide for SH1.\n+   It is 32 bits wide for SH2.  */\n \n  /*  r0  r1  r2  r3 \n      r4  r5  r6  r7\n@@ -447,7 +406,7 @@ extern int hard_regno_mode_ok[];\n \n /* Definitions for register eliminations.\n \n-   We have two registers that can be eliminated on the m88k.  First, the\n+   We have two registers that can be eliminated on the SH.  First, the\n    frame pointer register can often be eliminated in favor of the stack\n    pointer register.  Secondly, the argument pointer register can always be\n    eliminated; it is replaced with either the stack or frame pointer.  */\n@@ -457,11 +416,6 @@ extern int hard_regno_mode_ok[];\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.  */\n \n-/* This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.  */\n-\n #define ELIMINABLE_REGS\t\t\t\t\\\n {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\\\n@@ -659,7 +613,7 @@ extern enum reg_class reg_class_from_letter[];\n    These two macros are used only in other macro definitions below.  */\n #define NPARM_REGS 4\n #define FIRST_PARM_REG 4\n-#define FIRST_RET_REG  (TARGET_RETR2 ? 2 : 0)\n+#define FIRST_RET_REG  0\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n@@ -920,8 +874,9 @@ extern int current_function_anonymous_args;\n \n #define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64) && (!(INTVAL(X) &3)))\n #define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60) && (!(INTVAL(X) &3)))\n-#define MODE_DISP_OK_2(X,MODE) ((GET_MODE_SIZE(MODE)==2) && ((unsigned)INTVAL(X)<32) && TARGET_TRYR0 && (!INTVAL(X) &1))\n-#define MODE_DISP_OK_1(X,MODE) ((GET_MODE_SIZE(MODE)==1) && ((unsigned)INTVAL(X)<16) && TARGET_TRYR0)\n+/* ??? These two work only if the target is R0, so we do not support them.  */\n+#define MODE_DISP_OK_2(X,MODE) (0)\n+#define MODE_DISP_OK_1(X,MODE) (0)\n \n #ifndef REG_OK_STRICT\n \n@@ -961,10 +916,6 @@ extern int current_function_anonymous_args;\n \t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == LABEL_REF\t\\\n \t&& GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT)))\n \n-/* The U is a label ref */\n-#define EXTRA_CONSTRAINT_U(OP)    \\\n-   (GET_CODE (OP) == LABEL_REF)\n-\n #define IS_INDEX(OP) \t\t\t\t\t\t\t\t\t\\\n   ((GET_CODE (OP) == PLUS && \t\t\t\t\t\t\t\t\\\n     (INDEX_REGISTER_RTX_P (XEXP (OP, 0)) && BASE_REGISTER_RTX_P (XEXP (OP, 1))) ||\t\\\n@@ -974,7 +925,6 @@ extern int current_function_anonymous_args;\n \n #define EXTRA_CONSTRAINT(OP, C)   \\\n      ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)   \\\n-    : (C) == 'U' ? EXTRA_CONSTRAINT_U (OP)   \\\n     : 0)\n \n \f\n@@ -1132,9 +1082,9 @@ extern int current_function_anonymous_args;\n #define STORE_FLAG_VALUE 1\n \n /* Immediate shift counts are truncated by the output routines (or was it\n-   the assembler?).  Shift counts in a register are truncated by ARM.  Note\n+   the assembler?).  Shift counts in a register are truncated by SH.  Note\n    that the native compiler puts too large (> 32) immediate shift counts\n-   into a register and shifts by the register, letting the ARM decide what\n+   into a register and shifts by the register, letting the SH decide what\n    to do instead of doing that itself.  */\n #define SHIFT_COUNT_TRUNCATED 1\n \n@@ -1159,8 +1109,12 @@ extern int current_function_anonymous_args;\n \n #define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n   case CONST_INT:\t\t\t\t\\\n-  if (INTVAL(RTX)==0) return 0; \\\n-    if (CONST_OK_FOR_I (INTVAL(RTX)))           \\\n+    if (INTVAL (RTX) == 0)\t\t\t\\\n+      return 0;\t\t\t\t\t\\\n+    else if (CONST_OK_FOR_I (INTVAL (RTX)))\t\\\n+      return 1;\t\t\t\t\t\\\n+    else if ((OUTER_CODE == AND || OUTER_CODE == IOR || OUTER_CODE == XOR) \\\n+\t     && CONST_OK_FOR_L (INTVAL (RTX)))\t\\\n       return 1;\t\t\t\t\t\\\n     else\t\t\t\t\t\\\n       return 8;\t\t\t\t\t\\\n@@ -1189,8 +1143,9 @@ extern int current_function_anonymous_args;\n     return 100;\n \n \n-/* The multiply and divide insns on the SH are actually function calls\n-   with some special constraints on arguments and register usage.\n+/* The multiply insn on the SH1 and the divide insns on the SH1 and SH2\n+   are actually function calls with some special constraints on arguments\n+   and register usage.\n \n    These macros tell reorg that the references to arguments and \n    register clobbers for insns of type sfunc do not appear to happen \n@@ -1485,7 +1440,7 @@ do { char dstr[30];\t\t\t\t\t\\\n #define PRINT_OPERAND_ADDRESS(STREAM,X)  print_operand_address (STREAM, X)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR)=='!' || (CHAR)=='@')\n+  ((CHAR)=='.' || (CHAR) == '#' || (CHAR)=='@')\n \n \f\n extern struct rtx_def *sh_compare_op0;\n@@ -1529,6 +1484,8 @@ extern int max_count_hi;\n /* Instructions with unfilled delay slots take up an extra two bytes for\n    the nop in the delay slot.  */\n \n+/* ??? Does this catch conditional branches when -m2?  */\n+\n #define ADJUST_INSN_LENGTH(X, LENGTH)\t\t\t\t\\\n   if (((GET_CODE (X) == INSN\t\t\t\t\t\\\n \t&& GET_CODE (PATTERN (X)) != SEQUENCE\t\t\t\\"}]}