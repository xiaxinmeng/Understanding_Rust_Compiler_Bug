{"sha": "bb8d292d395e5ac5aaf96ff44f58822918b94859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI4ZDI5MmQzOTVlNWFjNWFhZjk2ZmY0NGY1ODgyMjkxOGI5NDg1OQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-05-19T09:03:12Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-05-19T09:03:12Z"}, "message": "re PR middle-end/45098 (Missed induction variable optimization)\n\n2011-05-19  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/45098\n\t* tree-ssa-loop-ivopts.c (get_expr_id): Factored new function out of\n\tget_loop_invariant_expr_id.\n\t(get_loop_invariant_expr_id): Use get_expr_id.\n\t(parm_decl_cost): New function.\n\t(determine_use_iv_cost_condition): Use get_expr_id and parm_decl_cost.\n\tImprove bound cost estimation.  Use different inv_expr_id for elim and\n\texpress cases.\n\nFrom-SVN: r173894", "tree": {"sha": "2296fc77fe0552e40381f5d9d1212ee5827ed489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2296fc77fe0552e40381f5d9d1212ee5827ed489"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb8d292d395e5ac5aaf96ff44f58822918b94859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8d292d395e5ac5aaf96ff44f58822918b94859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb8d292d395e5ac5aaf96ff44f58822918b94859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8d292d395e5ac5aaf96ff44f58822918b94859/comments", "author": null, "committer": null, "parents": [{"sha": "a53c50249f684027ef6ca3957b0811e4ecb233e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53c50249f684027ef6ca3957b0811e4ecb233e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53c50249f684027ef6ca3957b0811e4ecb233e7"}], "stats": {"total": 96, "additions": 79, "deletions": 17}, "files": [{"sha": "a22cc926bdd972b36986da38a4ac6b0dde0aba0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8d292d395e5ac5aaf96ff44f58822918b94859/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8d292d395e5ac5aaf96ff44f58822918b94859/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb8d292d395e5ac5aaf96ff44f58822918b94859", "patch": "@@ -1,3 +1,14 @@\n+2011-05-19  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/45098\n+\t* tree-ssa-loop-ivopts.c (get_expr_id): Factored new function out of\n+\tget_loop_invariant_expr_id.\n+\t(get_loop_invariant_expr_id): Use get_expr_id.\n+\t(parm_decl_cost): New function.\n+\t(determine_use_iv_cost_condition): Use get_expr_id and parm_decl_cost.\n+\tImprove bound cost estimation.  Use different inv_expr_id for elim and\n+\texpress cases.\n+\n 2011-05-19  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/45098"}, {"sha": "64647c9e054b37c25ff76d358cf0529126a62d60", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8d292d395e5ac5aaf96ff44f58822918b94859/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8d292d395e5ac5aaf96ff44f58822918b94859/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=bb8d292d395e5ac5aaf96ff44f58822918b94859", "patch": "@@ -3837,6 +3837,28 @@ compare_aff_trees (aff_tree *aff1, aff_tree *aff2)\n   return true;\n }\n \n+/* Stores EXPR in DATA->inv_expr_tab, and assigns it an inv_expr_id.  */\n+\n+static int\n+get_expr_id (struct ivopts_data *data, tree expr)\n+{\n+  struct iv_inv_expr_ent ent;\n+  struct iv_inv_expr_ent **slot;\n+\n+  ent.expr = expr;\n+  ent.hash = iterative_hash_expr (expr, 0);\n+  slot = (struct iv_inv_expr_ent **) htab_find_slot (data->inv_expr_tab,\n+                                                     &ent, INSERT);\n+  if (*slot)\n+    return (*slot)->id;\n+\n+  *slot = XNEW (struct iv_inv_expr_ent);\n+  (*slot)->expr = expr;\n+  (*slot)->hash = ent.hash;\n+  (*slot)->id = data->inv_expr_id++;\n+  return (*slot)->id;\n+}\n+\n /* Returns the pseudo expr id if expression UBASE - RATIO * CBASE\n    requires a new compiler generated temporary.  Returns -1 otherwise.\n    ADDRESS_P is a flag indicating if the expression is for address\n@@ -3849,8 +3871,6 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n {\n   aff_tree ubase_aff, cbase_aff;\n   tree expr, ub, cb;\n-  struct iv_inv_expr_ent ent;\n-  struct iv_inv_expr_ent **slot;\n \n   STRIP_NOPS (ubase);\n   STRIP_NOPS (cbase);\n@@ -3938,18 +3958,7 @@ get_loop_invariant_expr_id (struct ivopts_data *data, tree ubase,\n   aff_combination_scale (&cbase_aff, shwi_to_double_int (-1 * ratio));\n   aff_combination_add (&ubase_aff, &cbase_aff);\n   expr = aff_combination_to_tree (&ubase_aff);\n-  ent.expr = expr;\n-  ent.hash = iterative_hash_expr (expr, 0);\n-  slot = (struct iv_inv_expr_ent **) htab_find_slot (data->inv_expr_tab,\n-                                                     &ent, INSERT);\n-  if (*slot)\n-    return (*slot)->id;\n-\n-  *slot = XNEW (struct iv_inv_expr_ent);\n-  (*slot)->expr = expr;\n-  (*slot)->hash = ent.hash;\n-  (*slot)->id = data->inv_expr_id++;\n-  return  (*slot)->id;\n+  return get_expr_id (data, expr);\n }\n \n \n@@ -4414,6 +4423,23 @@ may_eliminate_iv (struct ivopts_data *data,\n   return true;\n }\n \n+ /* Calculates the cost of BOUND, if it is a PARM_DECL.  A PARM_DECL must\n+    be copied, if is is used in the loop body and DATA->body_includes_call.  */\n+\n+static int\n+parm_decl_cost (struct ivopts_data *data, tree bound)\n+{\n+  tree sbound = bound;\n+  STRIP_NOPS (sbound);\n+\n+  if (TREE_CODE (sbound) == SSA_NAME\n+      && TREE_CODE (SSA_NAME_VAR (sbound)) == PARM_DECL\n+      && gimple_nop_p (SSA_NAME_DEF_STMT (sbound))\n+      && data->body_includes_call)\n+    return COSTS_N_INSNS (1);\n+\n+  return 0;\n+}\n \n /* Determines cost of basing replacement of USE on CAND in a condition.  */\n \n@@ -4424,9 +4450,9 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   tree bound = NULL_TREE;\n   struct iv *cmp_iv;\n   bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n-  comp_cost elim_cost, express_cost, cost;\n+  comp_cost elim_cost, express_cost, cost, bound_cost;\n   bool ok;\n-  int inv_expr_id = -1;\n+  int elim_inv_expr_id = -1, express_inv_expr_id = -1, inv_expr_id;\n   tree *control_var, *bound_cst;\n \n   /* Only consider real candidates.  */\n@@ -4440,6 +4466,21 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   if (may_eliminate_iv (data, use, cand, &bound))\n     {\n       elim_cost = force_var_cost (data, bound, &depends_on_elim);\n+      if (elim_cost.cost == 0)\n+        elim_cost.cost = parm_decl_cost (data, bound);\n+      else if (TREE_CODE (bound) == INTEGER_CST)\n+        elim_cost.cost = 0;\n+      /* If we replace a loop condition 'i < n' with 'p < base + n',\n+\t depends_on_elim will have 'base' and 'n' set, which implies\n+\t that both 'base' and 'n' will be live during the loop.\t More likely,\n+\t 'base + n' will be loop invariant, resulting in only one live value\n+\t during the loop.  So in that case we clear depends_on_elim and set\n+        elim_inv_expr_id instead.  */\n+      if (depends_on_elim && bitmap_count_bits (depends_on_elim) > 1)\n+\t{\n+\t  elim_inv_expr_id = get_expr_id (data, bound);\n+\t  bitmap_clear (depends_on_elim);\n+\t}\n       /* The bound is a loop invariant, so it will be only computed\n \t once.  */\n       elim_cost.cost = adjust_setup_cost (data, elim_cost.cost);\n@@ -4467,23 +4508,33 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n \n   express_cost = get_computation_cost (data, use, cand, false,\n \t\t\t\t       &depends_on_express, NULL,\n-                                       &inv_expr_id);\n+                                       &express_inv_expr_id);\n   fd_ivopts_data = data;\n   walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n+  /* Count the cost of the original bound as well.  */\n+  bound_cost = force_var_cost (data, *bound_cst, NULL);\n+  if (bound_cost.cost == 0)\n+    bound_cost.cost = parm_decl_cost (data, *bound_cst);\n+  else if (TREE_CODE (*bound_cst) == INTEGER_CST)\n+    bound_cost.cost = 0;\n+  express_cost.cost += bound_cost.cost;\n+\n   /* Choose the better approach, preferring the eliminated IV. */\n   if (compare_costs (elim_cost, express_cost) <= 0)\n     {\n       cost = elim_cost;\n       depends_on = depends_on_elim;\n       depends_on_elim = NULL;\n+      inv_expr_id = elim_inv_expr_id;\n     }\n   else\n     {\n       cost = express_cost;\n       depends_on = depends_on_express;\n       depends_on_express = NULL;\n       bound = NULL_TREE;\n+      inv_expr_id = express_inv_expr_id;\n     }\n \n   set_use_iv_cost (data, use, cand, cost, depends_on, bound, inv_expr_id);"}]}