{"sha": "4d9af90d6a216822fe117337fb9836ba656dc3af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5YWY5MGQ2YTIxNjgyMmZlMTE3MzM3ZmI5ODM2YmE2NTZkYzNhZg==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T07:31:22Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T07:31:22Z"}, "message": "arm: Avoid indirection with -mpure-code on v6m (PR96967)\n\nWith -mpure-code on v6m (thumb-1), to avoid a useless indirection when\nbuilding the address of a symbol, we want to consider SYMBOL_REF as a\nlegitimate constant. This way, we build the address using a series of\nupper/lower relocations instead of loading the address from memory.\n\nThis patch also fixes a missing \"clob\" conds attribute for\nthumb1_movsi_insn, needed because that alternative clobbers the flags.\n\n2020-11-02  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\tPR target/96967\n\t* config/arm/arm.c (thumb_legitimate_constant_p): Add support for\n\tdisabled literal pool in thumb-1.\n\t* config/arm/thumb1.md (thumb1_movsi_symbol_ref): Remove.\n\t(*thumb1_movsi_insn): Add support for SYMBOL_REF with -mpure-code.\n\n\tgcc/testsuite\n\tPR target/96967\n\t* gcc.target/arm/pure-code/pr96767.c: New test.", "tree": {"sha": "ba0dcb7edd4d81c1746dd136ae4e85e1e13c582d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba0dcb7edd4d81c1746dd136ae4e85e1e13c582d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d9af90d6a216822fe117337fb9836ba656dc3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9af90d6a216822fe117337fb9836ba656dc3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d9af90d6a216822fe117337fb9836ba656dc3af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9af90d6a216822fe117337fb9836ba656dc3af/comments", "author": null, "committer": null, "parents": [{"sha": "590febb5f6624f78b36402a7c9a9c318978f1efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590febb5f6624f78b36402a7c9a9c318978f1efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590febb5f6624f78b36402a7c9a9c318978f1efa"}], "stats": {"total": 118, "additions": 63, "deletions": 55}, "files": [{"sha": "d2387c332420b3c8f7106a5d5bd501ffa150facd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4d9af90d6a216822fe117337fb9836ba656dc3af", "patch": "@@ -9500,6 +9500,12 @@ thumb_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \t  || CONST_DOUBLE_P (x)\n \t  || CONSTANT_ADDRESS_P (x)\n \t  || (TARGET_HAVE_MOVT && GET_CODE (x) == SYMBOL_REF)\n+\t  /* On Thumb-1 without MOVT/MOVW and literal pool disabled,\n+\t     we build the symbol address with upper/lower\n+\t     relocations.  */\n+\t  || (TARGET_THUMB1\n+\t      && GET_CODE (x) == SYMBOL_REF\n+\t      && arm_disable_literal_pool)\n \t  || flag_pic);\n }\n "}, {"sha": "4bf73bfc374d039085afed0ae534f7c0944bea58", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 47, "deletions": 55, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=4d9af90d6a216822fe117337fb9836ba656dc3af", "patch": "@@ -43,27 +43,6 @@\n \n \n \n-(define_insn \"thumb1_movsi_symbol_ref\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))\n-   ]\n-  \"TARGET_THUMB1\n-   && arm_disable_literal_pool\n-   && GET_CODE (operands[1]) == SYMBOL_REF\"\n-  \"*\n-  output_asm_insn (\\\"movs\\\\t%0, #:upper8_15:%1\\\", operands);\n-  output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n-  output_asm_insn (\\\"adds\\\\t%0, #:upper0_7:%1\\\", operands);\n-  output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n-  output_asm_insn (\\\"adds\\\\t%0, #:lower8_15:%1\\\", operands);\n-  output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n-  output_asm_insn (\\\"adds\\\\t%0, #:lower0_7:%1\\\", operands);\n-  return \\\"\\\";\n-  \"\n-  [(set_attr \"length\" \"14\")\n-   (set_attr \"conds\" \"clob\")]\n-)\n-\n (define_insn \"*thumb1_adddi3\"\n   [(set (match_operand:DI          0 \"register_operand\" \"=l\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n@@ -696,40 +675,53 @@\n       case 7:\n       /* pure-code alternative: build the constant byte by byte,\n \t instead of loading it from a constant pool.  */\n-\t{\n-\t  int i;\n-\t  HOST_WIDE_INT op1 = INTVAL (operands[1]);\n-\t  bool mov_done_p = false;\n-\t  rtx ops[2];\n-\t  ops[0] = operands[0];\n-\n-\t  /* Emit upper 3 bytes if needed.  */\n-\t  for (i = 0; i < 3; i++)\n-\t    {\n-\t       int byte = (op1 >> (8 * (3 - i))) & 0xff;\n-\n-\t      if (byte)\n-\t\t{\n-\t\t  ops[1] = GEN_INT (byte);\n-\t\t  if (mov_done_p)\n-\t\t    output_asm_insn (\"adds\\t%0, %1\", ops);\n-\t\t  else\n-\t\t    output_asm_insn (\"movs\\t%0, %1\", ops);\n-\t\t  mov_done_p = true;\n-\t\t}\n-\n-\t      if (mov_done_p)\n-\t\toutput_asm_insn (\"lsls\\t%0, #8\", ops);\n-\t    }\n+\tif (GET_CODE (operands[1]) == SYMBOL_REF)\n+\t  {\n+\t    output_asm_insn (\\\"movs\\\\t%0, #:upper8_15:%1\\\", operands);\n+\t    output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n+\t    output_asm_insn (\\\"adds\\\\t%0, #:upper0_7:%1\\\", operands);\n+\t    output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n+\t    output_asm_insn (\\\"adds\\\\t%0, #:lower8_15:%1\\\", operands);\n+\t    output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n+\t    output_asm_insn (\\\"adds\\\\t%0, #:lower0_7:%1\\\", operands);\n+\t    return \\\"\\\";\n+\t  }\n+\telse\n+\t  {\n+\t    int i;\n+\t    HOST_WIDE_INT op1 = INTVAL (operands[1]);\n+\t    bool mov_done_p = false;\n+\t    rtx ops[2];\n+\t    ops[0] = operands[0];\n+\n+\t    /* Emit upper 3 bytes if needed.  */\n+\t    for (i = 0; i < 3; i++)\n+\t      {\n+\t\tint byte = (op1 >> (8 * (3 - i))) & 0xff;\n+\n+\t\tif (byte)\n+\t\t  {\n+\t\t    ops[1] = GEN_INT (byte);\n+\t\t    if (mov_done_p)\n+\t\t      output_asm_insn (\"adds\\t%0, %1\", ops);\n+\t\t    else\n+\t\t      output_asm_insn (\"movs\\t%0, %1\", ops);\n+\t\t    mov_done_p = true;\n+\t\t  }\n+\n+\t\tif (mov_done_p)\n+\t\t  output_asm_insn (\"lsls\\t%0, #8\", ops);\n+\t      }\n+\n+\t    /* Emit lower byte if needed.  */\n+\t    ops[1] = GEN_INT (op1 & 0xff);\n+\t    if (!mov_done_p)\n+\t      output_asm_insn (\"movs\\t%0, %1\", ops);\n+\t    else if (op1 & 0xff)\n+\t      output_asm_insn (\"adds\\t%0, %1\", ops);\n+\t    return \"\";\n+\t  }\n \n-\t  /* Emit lower byte if needed.  */\n-\t  ops[1] = GEN_INT (op1 & 0xff);\n-\t  if (!mov_done_p)\n-\t    output_asm_insn (\"movs\\t%0, %1\", ops);\n-\t  else if (op1 & 0xff)\n-\t    output_asm_insn (\"adds\\t%0, %1\", ops);\n-\t  return \"\";\n-\t}\n       case 8: return \"ldr\\t%0, %1\";\n       case 9: return \"str\\t%1, %0\";\n       case 10: return \"mov\\t%0, %1\";\n@@ -740,7 +732,7 @@\n    (set_attr \"pool_range\" \"*,*,*,*,*,*,*, *,1018,*,*\")\n    (set_attr \"arch\" \"t1,t1,v8mb,t1,t1,t1,t1,t1,t1,t1,t1\")\n    (set_attr \"required_for_purecode\" \"no,no,no,no,no,no,no,yes,no,no,no\")\n-   (set_attr \"conds\" \"set,clob,nocond,*,*,nocond,nocond,nocond,nocond,nocond,nocond\")])\n+   (set_attr \"conds\" \"set,clob,nocond,*,*,nocond,nocond,clob,nocond,nocond,nocond\")])\n \n ; Split the load of 64-bit constant into two loads for high and low 32-bit parts respectively\n ; to see if we can load them in fewer instructions or fewer cycles."}, {"sha": "cb3ee682dd182b18901f05480405c9e84eff8b6b", "filename": "gcc/testsuite/gcc.target/arm/pure-code/pr96767.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96767.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9af90d6a216822fe117337fb9836ba656dc3af/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96767.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96767.c?ref=4d9af90d6a216822fe117337fb9836ba656dc3af", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mpure-code\" } */\n+\n+int x;\n+int f1 (void) { return x; }\n+\n+/* We expect only one indirect load like ldr r3, [r3]. In some\n+   configurations there is an additional ldr rX, [sp], #4 which is not\n+   related to what we check here, so make sure not to match it.  */\n+/* { dg-final { scan-assembler-times \"ldr\\tr\\[0-9\\]+, \\\\\\[r\\[0-9\\]+\\\\\\]\" 1 } } */"}]}