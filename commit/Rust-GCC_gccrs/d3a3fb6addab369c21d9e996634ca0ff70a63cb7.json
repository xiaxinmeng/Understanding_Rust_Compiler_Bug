{"sha": "d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhM2ZiNmFkZGFiMzY5YzIxZDllOTk2NjM0Y2EwZmY3MGE2M2NiNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-10-06T19:01:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-10-06T19:01:44Z"}, "message": "cp-tree.h (CLASSTYPE_VFIELD): Remove.\n\n\t* cp-tree.h (CLASSTYPE_VFIELD): Remove.\n\t* call.c (build_vfield_ref): Use TYPE_VFIELD, not\n\tCLASSTYPE_VFIELD.\n\t* class.c (get_vfield_offset): Likewise.\n\t(finish_base_struct): Likewise.\n\t(modify_one_vtable): Likewise.\n\t(fixup_vtable_deltas): Likewise.\n\t(finish_struct_1): Likewise.\n\t* init.c (expand_virtual_init): Likewise.\n\t* search.c (lookup_field_1): Likewise.\n\t(expand_upcast_fixups): Likewise.\n\t* typeck.c (build_component_ref): Likewise.\n\t(build_binary_op_nodefault): Likewise.\n\n\t* dump.c (dqueue_and_dump): Dump TYPE_VFIELD.\n\t* ir.texi: Document TYPE_VFIELD.\n\nFrom-SVN: r29843", "tree": {"sha": "53cc6468d8fe6e06ad4f46094e0dc83f17bafbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53cc6468d8fe6e06ad4f46094e0dc83f17bafbfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/comments", "author": null, "committer": null, "parents": [{"sha": "a4156b889dd6193cdf28e9e3ba2b923d4e04d7f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4156b889dd6193cdf28e9e3ba2b923d4e04d7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4156b889dd6193cdf28e9e3ba2b923d4e04d7f1"}], "stats": {"total": 95, "additions": 59, "deletions": 36}, "files": [{"sha": "3321923e83fec4de9b193325a683f1476d24fb69", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -1,3 +1,22 @@\n+1999-10-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (CLASSTYPE_VFIELD): Remove.\n+\t* call.c (build_vfield_ref): Use TYPE_VFIELD, not\n+\tCLASSTYPE_VFIELD.\n+\t* class.c (get_vfield_offset): Likewise.\n+\t(finish_base_struct): Likewise.\n+\t(modify_one_vtable): Likewise.\n+\t(fixup_vtable_deltas): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t* init.c (expand_virtual_init): Likewise.\n+\t* search.c (lookup_field_1): Likewise.\n+\t(expand_upcast_fixups): Likewise.\n+\t* typeck.c (build_component_ref): Likewise.\n+\t(build_binary_op_nodefault): Likewise.\n+\t\n+\t* dump.c (dqueue_and_dump): Dump TYPE_VFIELD.\n+\t* ir.texi: Document TYPE_VFIELD.\n+\n 1999-10-06  Brendan Kehoe  <brendan@cygnus.com>\n \n \t* decl.c (grokdeclarator): Only warn about non-zero arrays if"}, {"sha": "6eaf61e77fe7b6b7f21bf18c73b4a8088d0fca83", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -112,10 +112,10 @@ build_vfield_ref (datum, type)\n     datum = convert_from_reference (datum);\n \n   if (! TYPE_USES_COMPLEX_INHERITANCE (type))\n-    rval = build (COMPONENT_REF, TREE_TYPE (CLASSTYPE_VFIELD (type)),\n-\t\t  datum, CLASSTYPE_VFIELD (type));\n+    rval = build (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n+\t\t  datum, TYPE_VFIELD (type));\n   else\n-    rval = build_component_ref (datum, DECL_NAME (CLASSTYPE_VFIELD (type)), NULL_TREE, 0);\n+    rval = build_component_ref (datum, DECL_NAME (TYPE_VFIELD (type)), NULL_TREE, 0);\n \n   return rval;\n }"}, {"sha": "dc4053608c393cea66ae6cb3f5f4a954186cdbe3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -605,7 +605,7 @@ get_vfield_offset (binfo)\n {\n   tree tmp\n     = size_binop (FLOOR_DIV_EXPR,\n-\t\t  DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))),\n+\t\t  DECL_FIELD_BITPOS (TYPE_VFIELD (BINFO_TYPE (binfo))),\n \t\t  size_int (BITS_PER_UNIT));\n   tmp = convert (sizetype, tmp);\n   return size_binop (PLUS_EXPR, tmp, BINFO_OFFSET (binfo));\n@@ -1603,7 +1603,7 @@ finish_base_struct (t, b)\n \t      TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n \t      TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n \t      b->has_virtual = CLASSTYPE_VSIZE (basetype);\n-\t      b->vfield = CLASSTYPE_VFIELD (basetype);\n+\t      b->vfield = TYPE_VFIELD (basetype);\n \t      b->vfields = copy_list (CLASSTYPE_VFIELDS (basetype));\n \t      vfields = b->vfields;\n \t      while (vfields)\n@@ -1612,15 +1612,15 @@ finish_base_struct (t, b)\n \t\t      || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields)))\n \t\t    {\n \t\t      tree value = VF_BASETYPE_VALUE (vfields);\n-\t\t      if (DECL_NAME (CLASSTYPE_VFIELD (value))\n-\t\t\t  == DECL_NAME (CLASSTYPE_VFIELD (basetype)))\n+\t\t      if (DECL_NAME (TYPE_VFIELD (value))\n+\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n \t\t\tVF_NORMAL_VALUE (b->vfields) = basetype;\n \t\t      else\n \t\t\tVF_NORMAL_VALUE (b->vfields) = VF_NORMAL_VALUE (vfields);\n \t\t    }\n \t\t  vfields = TREE_CHAIN (vfields);\n \t\t}\n-\t      CLASSTYPE_VFIELD (t) = b->vfield;\n+\t      TYPE_VFIELD (t) = b->vfield;\n \t    }\n \t  else\n \t    {\n@@ -1633,8 +1633,8 @@ finish_base_struct (t, b)\n \t\t    {\n \t\t      tree value = VF_BASETYPE_VALUE (vfields);\n \t\t      b->vfields = tree_cons (base_binfo, value, b->vfields);\n-\t\t      if (DECL_NAME (CLASSTYPE_VFIELD (value))\n-\t\t\t  == DECL_NAME (CLASSTYPE_VFIELD (basetype)))\n+\t\t      if (DECL_NAME (TYPE_VFIELD (value))\n+\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n \t\t\tVF_NORMAL_VALUE (b->vfields) = basetype;\n \t\t      else\n \t\t\tVF_NORMAL_VALUE (b->vfields) = VF_NORMAL_VALUE (vfields);\n@@ -1652,17 +1652,17 @@ finish_base_struct (t, b)\n \t\t  TYPE_BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (basetype);\n \t\t  TYPE_BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (basetype);\n \t\t  b->has_virtual = CLASSTYPE_VSIZE (basetype);\n-\t\t  b->vfield = CLASSTYPE_VFIELD (basetype);\n-\t\t  CLASSTYPE_VFIELD (t) = b->vfield;\n+\t\t  b->vfield = TYPE_VFIELD (basetype);\n+\t\t  TYPE_VFIELD (t) = b->vfield;\n \t\t  /* When we install the first one, set the VF_NORMAL_VALUE\n \t\t     to be the current class, as this it is the most derived\n \t\t     class.  Hopefully, this is not set to something else\n \t\t     later.  (mrs) */\n \t\t  vfields = b->vfields;\n \t\t  while (vfields)\n \t\t    {\n-\t\t      if (DECL_NAME (CLASSTYPE_VFIELD (t))\n-\t\t\t  == DECL_NAME (CLASSTYPE_VFIELD (basetype)))\n+\t\t      if (DECL_NAME (TYPE_VFIELD (t))\n+\t\t\t  == DECL_NAME (TYPE_VFIELD (basetype)))\n \t\t\t{\n \t\t\t  VF_NORMAL_VALUE (vfields) = t;\n \t\t\t  /* There should only be one of them!  And it should\n@@ -2400,7 +2400,7 @@ modify_one_vtable (binfo, t, fndecl)\n       if (binfo == TYPE_BINFO (t))\n \t{\n \t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n-\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (CLASSTYPE_VFIELD (t))), t);\n+\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), t);\n \t}\n       else\n \t{\n@@ -2428,7 +2428,7 @@ modify_one_vtable (binfo, t, fndecl)\n \t{\n \t  tree base_offset, offset;\n \t  tree context = DECL_CLASS_CONTEXT (fndecl);\n-\t  tree vfield = CLASSTYPE_VFIELD (t);\n+\t  tree vfield = TYPE_VFIELD (t);\n \t  tree this_offset;\n \n \t  offset = get_class_offset (context, t, binfo, fndecl);\n@@ -2520,7 +2520,7 @@ fixup_vtable_deltas1 (binfo, t)\n \t{\n \t  tree base_offset, offset;\n \t  tree context = DECL_CLASS_CONTEXT (fndecl);\n-\t  tree vfield = CLASSTYPE_VFIELD (t);\n+\t  tree vfield = TYPE_VFIELD (t);\n \t  tree this_offset;\n \n \t  offset = get_class_offset (context, t, binfo, fndecl);\n@@ -3284,7 +3284,7 @@ finish_struct_1 (t)\n      modified.  Needed at this point to make add_virtual_function\n      and modify_vtable_entries work.  */\n   CLASSTYPE_VFIELDS (t) = vfields;\n-  CLASSTYPE_VFIELD (t) = vfield;\n+  TYPE_VFIELD (t) = vfield;\n \n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n@@ -3753,7 +3753,7 @@ finish_struct_1 (t)\n \t other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n \t them too.  */\n       DECL_ASSEMBLER_NAME (vfield) = get_identifier (VFIELD_BASE);\n-      CLASSTYPE_VFIELD (t) = vfield;\n+      TYPE_VFIELD (t) = vfield;\n       DECL_VIRTUAL_P (vfield) = 1;\n       DECL_ARTIFICIAL (vfield) = 1;\n       DECL_FIELD_CONTEXT (vfield) = t;\n@@ -3923,7 +3923,7 @@ finish_struct_1 (t)\n       DECL_CLASS_CONTEXT (vfield) = t;\n       DECL_FIELD_BITPOS (vfield)\n \t= size_binop (PLUS_EXPR, offset, DECL_FIELD_BITPOS (vfield));\n-      CLASSTYPE_VFIELD (t) = vfield;\n+      TYPE_VFIELD (t) = vfield;\n     }\n     \n #ifdef NOTQUITE\n@@ -4046,7 +4046,7 @@ finish_struct_1 (t)\n \n       layout_type (atype);\n \n-      CLASSTYPE_VFIELD (t) = vfield;\n+      TYPE_VFIELD (t) = vfield;\n \n       /* We may have to grow the vtable.  */\n       if (TREE_TYPE (TYPE_BINFO_VTABLE (t)) != atype)\n@@ -4062,7 +4062,7 @@ finish_struct_1 (t)\n \t}\n     }\n   else if (first_vfn_base_index >= 0)\n-    CLASSTYPE_VFIELD (t) = vfield;\n+    TYPE_VFIELD (t) = vfield;\n   CLASSTYPE_VFIELDS (t) = vfields;\n \n   finish_struct_bits (t, max_has_virtual);"}, {"sha": "0a5d447e332c31ecc82f2abdce2c33cab8ccab89", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -1365,9 +1365,6 @@ struct lang_type\n    1, if D's vtable came from B2.  */\n #define CLASSTYPE_VFIELD_PARENT(NODE)\t(TYPE_LANG_SPECIFIC(NODE)->vfield_parent)\n \n-/* Remove when done merging.  */\n-#define CLASSTYPE_VFIELD(NODE) TYPE_VFIELD(NODE)\n-\n /* The number of virtual functions defined for this\n    _CLASSTYPE node.  */\n #define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)"}, {"sha": "dc767bc8fa77847fd20766034b32869a8ad349a3", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -530,6 +530,7 @@ dequeue_and_dump (di)\n \n \t  dump_child (\"flds\", TYPE_FIELDS (t));\n \t  dump_child (\"fncs\", TYPE_METHODS (t));\n+\t  dump_child (\"vfld\", TYPE_VFIELD (t));\n \t  queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n \t\t\t\tDUMP_BINFO);\n \t}"}, {"sha": "5f395f5ba2b2da0ca7aeb7b118a96cc26b8ae80a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -659,9 +659,9 @@ expand_virtual_init (binfo, decl)\n   /* This code is crusty.  Should be simple, like:\n      vtbl = BINFO_VTABLE (binfo);\n      */\n-  vtype = DECL_CONTEXT (CLASSTYPE_VFIELD (type));\n+  vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n-  vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (CLASSTYPE_VFIELD (type)), binfo));\n+  vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo));\n   assemble_external (vtbl);\n   TREE_USED (vtbl) = 1;\n   vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);"}, {"sha": "dd7a56998512c719019d29411f35d9e53c312f3d", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -655,6 +655,7 @@ list.  In particular, no @code{FIELD_DECL}, @code{LABEL_DECL}, or\n @findex TREE_VIA_PROTECTED\n @findex TREE_VIA_PRIVATE\n @findex TYPE_FIELDS\n+@findex TYPE_VFIELD\n @findex TYPE_METHODS\n \n A class type is represented by either a @code{RECORD_TYPE} or a\n@@ -666,8 +667,8 @@ macro to discern whether or not a particular type is a @code{class} as\n opposed to a @code{struct}.  This macro will be true only for classes\n declared with the @code{class} tag.\n \n-All non-function members are available on the @code{TYPE_FIELDS} list.\n-Given one member, the next can be found by following the\n+Almost all non-function members are available on the @code{TYPE_FIELDS}\n+list.  Given one member, the next can be found by following the\n @code{TREE_CHAIN}.  You should not depend in any way on the order in\n which fields appear on this list.  All nodes on this list will be\n @samp{DECL} nodes. A @code{FIELD_DECL} is used to represent a non-static\n@@ -680,6 +681,11 @@ There are no entries for base classes on this list.  In particular,\n there is no @code{FIELD_DECL} for the ``base-class portion'' of an\n object.\n \n+The @code{TYPE_VFIELD} is a compiler-generated field used to point to\n+virtual function tables.  It does not appear on the @code{TYPE_FIELDS}\n+list.  However, back-ends should handle the @code{TYPE_VFIELD} just like\n+all the entries on the @code{TYPE_FIELDS} list.\n+\n The function members are available on the @code{TYPE_METHODS} list.\n Again, subsequent members are found by following the @code{TREE_CHAIN}\n field.  If a function is overloaded, each of the overloaded functions"}, {"sha": "0a1d758406a996fe8ec273fc1dab93ec017535d9", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -656,7 +656,7 @@ lookup_field_1 (type, name)\n     {\n       /* Give the user what s/he thinks s/he wants.  */\n       if (TYPE_VIRTUAL_P (type))\n-\treturn CLASSTYPE_VFIELD (type);\n+\treturn TYPE_VFIELD (type);\n     }\n   return NULL_TREE;\n }\n@@ -2685,7 +2685,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      /* Update the vtable pointers as necessary.  */\n \t      ref = build_vfield_ref\n \t\t(build_indirect_ref (addr, NULL_PTR),\n-\t\t DECL_CONTEXT (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))));\n+\t\t DECL_CONTEXT (TYPE_VFIELD (BINFO_TYPE (binfo))));\n \t      finish_expr_stmt\n \t\t(build_modify_expr (ref, NOP_EXPR, nvtbl));\n \t    }"}, {"sha": "4bf817858ff248b131ca9e2898ec8315b5da13d3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a3fb6addab369c21d9e996634ca0ff70a63cb7/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d3a3fb6addab369c21d9e996634ca0ff70a63cb7", "patch": "@@ -2094,12 +2094,12 @@ build_component_ref (datum, component, basetype_path, protect)\n     }\n \n   /* Look up component name in the structure type definition.  */\n-  if (CLASSTYPE_VFIELD (basetype)\n-      && DECL_NAME (CLASSTYPE_VFIELD (basetype)) == component)\n+  if (TYPE_VFIELD (basetype)\n+      && DECL_NAME (TYPE_VFIELD (basetype)) == component)\n     /* Special-case this because if we use normal lookups in an ambiguous\n        hierarchy, the compiler will abort (because vptr lookups are\n        not supposed to be ambiguous.  */\n-    field = CLASSTYPE_VFIELD (basetype);\n+    field = TYPE_VFIELD (basetype);\n   else if (TREE_CODE (component) == FIELD_DECL)\n     field = component;\n   else if (TREE_CODE (component) == TYPE_DECL)\n@@ -3697,8 +3697,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t\t\t   DECL_VINDEX (TREE_OPERAND (op1, 0)),\n \t\t\t\t   integer_one_node);\n \t      op1 = integer_zero_node;\n-\t      delta21 = CLASSTYPE_VFIELD (TYPE_METHOD_BASETYPE\n-\t\t\t\t\t  (TREE_TYPE (type1)));\n+\t      delta21 = TYPE_VFIELD (TYPE_METHOD_BASETYPE\n+\t\t\t\t     (TREE_TYPE (type1)));\n \t      delta21 = DECL_FIELD_BITPOS (delta21);\n \t      delta21 = size_binop (FLOOR_DIV_EXPR, delta21,\n \t\t\t\t    size_int (BITS_PER_UNIT));"}]}