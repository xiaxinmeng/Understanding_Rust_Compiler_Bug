{"sha": "4f4f436f0784431645c407e93fafcc6017a77e5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0ZjQzNmYwNzg0NDMxNjQ1YzQwN2U5M2ZhZmNjNjAxN2E3N2U1Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-06-02T22:03:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-06-02T22:03:22Z"}, "message": "jump.c (rtx_unsafe_p): New function.\n\n        * jump.c (rtx_unsafe_p): New function.\n        (jump_optimize): Use it on if/then/else transformations and\n        conditional move transformations.\n\nFrom-SVN: r20200", "tree": {"sha": "9401b2f6edacfc3678ca437b6dd73db6418527d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9401b2f6edacfc3678ca437b6dd73db6418527d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f4f436f0784431645c407e93fafcc6017a77e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4f436f0784431645c407e93fafcc6017a77e5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4f436f0784431645c407e93fafcc6017a77e5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4f436f0784431645c407e93fafcc6017a77e5c/comments", "author": null, "committer": null, "parents": [{"sha": "c0e3b3b3465b7ca7dd5d747da18d368a430b7576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e3b3b3465b7ca7dd5d747da18d368a430b7576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e3b3b3465b7ca7dd5d747da18d368a430b7576"}], "stats": {"total": 110, "additions": 99, "deletions": 11}, "files": [{"sha": "e09d852e68d9978e61faa6aeae4e20cb86736665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4f436f0784431645c407e93fafcc6017a77e5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4f436f0784431645c407e93fafcc6017a77e5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f4f436f0784431645c407e93fafcc6017a77e5c", "patch": "@@ -1,3 +1,9 @@\n+Tue Jun  2 21:59:01 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* jump.c (rtx_unsafe_p): New function.\n+\t(jump_optimize): Use it on if/then/else transformations and\n+\tconditional move transformations.\n+\n Tue Jun  2 22:50:10 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n \t* fold-const.c (fold, case EQ_EXPR): When folding VAR++ == CONST"}, {"sha": "0a4fecdbb83b6cfaaeefbd61a7aefc3f073f44e9", "filename": "gcc/jump.c", "status": "modified", "additions": 93, "deletions": 11, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4f436f0784431645c407e93fafcc6017a77e5c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4f436f0784431645c407e93fafcc6017a77e5c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4f4f436f0784431645c407e93fafcc6017a77e5c", "patch": "@@ -121,6 +121,7 @@ static void redirect_tablejump\t\tPROTO((rtx, rtx));\n #ifndef HAVE_cc0\n static rtx find_insert_position         PROTO((rtx, rtx));\n #endif\n+static int rtx_unsafe_p\t\t\tPROTO((rtx));\n \f\n /* Delete no-op jumps and optimize jumps to jumps\n    and jumps around jumps.\n@@ -771,11 +772,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && GET_CODE (temp2) == INSN\n \t      && (temp4 = single_set (temp2)) != 0\n \t      && rtx_equal_p (SET_DEST (temp4), temp1)\n-\t      && (GET_CODE (SET_SRC (temp4)) == REG\n-\t\t  || GET_CODE (SET_SRC (temp4)) == SUBREG\n-\t\t  || (GET_CODE (SET_SRC (temp4)) == MEM\n-\t\t      && RTX_UNCHANGING_P (SET_SRC (temp4)))\n-\t\t  || CONSTANT_P (SET_SRC (temp4)))\n+\t      && ! rtx_unsafe_p (SET_SRC (temp4))\n \t      && (REG_NOTES (temp2) == 0\n \t\t  || ((REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUAL\n \t\t       || REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUIV)\n@@ -807,6 +804,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      rtx q;\n #endif\n \n+\t      if (!(GET_CODE (SET_SRC (temp4)) == REG\n+\t\t    || GET_CODE (SET_SRC (temp4)) == SUBREG\n+\t\t    || (GET_CODE (SET_SRC (temp4)) == MEM\n+\t\t\t&& RTX_UNCHANGING_P (SET_SRC (temp4)))\n+\t\t    || CONSTANT_P (SET_SRC (temp4))))\n+\t\t{\n+\t\t  fprintf(stderr, \"\\nxyzzy 1\\n\");\n+\t\t  debug_rtx (temp4);\n+\t\t}\n+\n \t      /* Set P to the first jump insn that goes around \"x = a;\".  */\n \t      for (p = temp; nuses && p; p = prev_nonnote_insn (p))\n \t\t{\n@@ -846,7 +853,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  && ! reg_referenced_between_p (temp1, p, NEXT_INSN (temp3))\n \t\t  && ! reg_set_between_p (temp1, p, temp3)\n \t\t  && (GET_CODE (SET_SRC (temp4)) == CONST_INT\n-\t\t      || ! reg_set_between_p (SET_SRC (temp4), p, temp2)))\n+\t\t      || ! modified_between_p (SET_SRC (temp4), p, temp2)))\n \t\t{\n \t\t  emit_insn_after_with_line_notes (PATTERN (temp2), p, temp2);\n \t\t  delete_insn (temp2);\n@@ -1161,11 +1168,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && GET_CODE (temp1 = SET_DEST (PATTERN (temp))) == REG\n \t      && (! SMALL_REGISTER_CLASSES\n \t\t  || REGNO (temp1) >= FIRST_PSEUDO_REGISTER)\n-\t      && (GET_CODE (temp2 = SET_SRC (PATTERN (temp))) == REG\n-\t\t  || (GET_CODE (temp2) == MEM && RTX_UNCHANGING_P (temp2))\n-\t\t  || GET_CODE (temp2) == SUBREG\n-\t\t  /* ??? How about floating point constants?  */\n-\t\t  || CONSTANT_P (temp2))\n+\t      && ! rtx_unsafe_p (temp2 = SET_SRC (PATTERN (temp)))\n \t      /* Allow either form, but prefer the former if both apply. \n \t\t There is no point in using the old value of TEMP1 if\n \t\t it is a register, since cse will alias them.  It can\n@@ -1203,6 +1206,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n #endif\n \t      )\n \t    {\n+\t      if (! (GET_CODE (temp2) == REG\n+\t\t     || (GET_CODE (temp2) == MEM && RTX_UNCHANGING_P (temp2))\n+\t\t     || GET_CODE (temp2) == SUBREG\n+\t\t     /* ??? How about floating point constants?  */\n+\t\t     || CONSTANT_P (temp2)))\n+\t\t{\n+\t\t  fprintf(stderr, \"\\nxyzzy 2\\n\");\n+\t\t  debug_rtx (PATTERN (temp));\n+\t\t}\n+\n #ifdef HAVE_conditional_move\n \t      /* First try a conditional move.  */\n \t      {\n@@ -4783,4 +4796,73 @@ find_insert_position (insn, new)\n \n   return reg_mentioned_p (SET_DEST (single_set (new)), prev) ? 0 : prev;\n }\n+\n+/* Return 1 if the value of X is unsafe to arbitrarily evaluate, i.e.\n+   might fault on some arguments.  This is used in connection with\n+   conditional move optimization.  */\n+\n+static int\n+rtx_unsafe_p (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register int i;\n+  register char *fmt;\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      return ! RTX_UNCHANGING_P (x);\n+\n+    case QUEUED:\n+      return 1;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_STRING:\n+    case CONST:\n+    case PC:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case ADDRESSOF:\n+    case REG:\n+      return 0;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+    case SQRT:\n+      return 1;\n+\n+    default:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+\t  && !flag_fast_math\n+\t  && FLOAT_MODE_P (GET_MODE (x)))\n+\treturn 1;\n+\n+      switch (GET_RTX_CLASS (code))\n+\t{\n+\tcase '<':\n+\tcase '1':\n+\tcase '2':\n+\tcase '3':\n+\tcase 'c':\n+\tcase 'b':\n+\t  break;\n+\n+\tdefault:\n+\t  return 1;\n+\t}\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      if (rtx_unsafe_p (XEXP (x, i)))\n+\treturn 1;\n+\n+  return 0;\n+}\n #endif /* !HAVE_cc0 */"}]}