{"sha": "b1095f9cec18563c97fb5106b30019cff71a86bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEwOTVmOWNlYzE4NTYzYzk3ZmI1MTA2YjMwMDE5Y2ZmNzFhODZiZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-01-08T01:38:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-01-08T01:38:53Z"}, "message": "ggc-page.c (max_alignment): New structure.\n\n\t* ggc-page.c (max_alignment): New structure.\n\t(MAX_ALIGNMENT): New macro.\n\t(init_ggc): Use it to round up the sizes in the\n\textra_order_size_table.\n\nFrom-SVN: r38791", "tree": {"sha": "99d520d9bf01e3e224cd7368050fd3f15ae9b119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99d520d9bf01e3e224cd7368050fd3f15ae9b119"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1095f9cec18563c97fb5106b30019cff71a86bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1095f9cec18563c97fb5106b30019cff71a86bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1095f9cec18563c97fb5106b30019cff71a86bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1095f9cec18563c97fb5106b30019cff71a86bd/comments", "author": null, "committer": null, "parents": [{"sha": "a701949a727ff74cd907540c5a8f28a5204bba4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a701949a727ff74cd907540c5a8f28a5204bba4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a701949a727ff74cd907540c5a8f28a5204bba4e"}], "stats": {"total": 48, "additions": 35, "deletions": 13}, "files": [{"sha": "362a7679fa1976c69ec63f62efb7fcc087f81329", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1095f9cec18563c97fb5106b30019cff71a86bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1095f9cec18563c97fb5106b30019cff71a86bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1095f9cec18563c97fb5106b30019cff71a86bd", "patch": "@@ -1,3 +1,10 @@\n+Sun Jan  7 18:37:43 2001  Mark P Mitchell  <mark@codesourcery.com>\n+\n+\t* ggc-page.c (max_alignment): New structure.\n+\t(MAX_ALIGNMENT): New macro.\n+\t(init_ggc): Use it to round up the sizes in the\n+\textra_order_size_table.\n+\n 2001-01-07  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* config/rs6000/rs6000.h (EPILOGUE_USES): New, mark link register"}, {"sha": "73dc4d1b4c140be3ca138dfa8dd591b49960da6c", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1095f9cec18563c97fb5106b30019cff71a86bd/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1095f9cec18563c97fb5106b30019cff71a86bd/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=b1095f9cec18563c97fb5106b30019cff71a86bd", "patch": "@@ -140,23 +140,12 @@ Boston, MA 02111-1307, USA.  */\n /* The size of an object on a page of the indicated ORDER.  */\n #define OBJECT_SIZE(ORDER) object_size_table[ORDER]\n \n-#ifdef NO_ALIGNMENT_PROBLEM\n-\n /* The number of extra orders, not corresponding to power-of-two sized\n    objects.  */\n \n #define NUM_EXTRA_ORDERS \\\n   (sizeof (extra_order_size_table) / sizeof (extra_order_size_table[0]))\n \n-#else /* !defined(NO_ALIGNMENT_PROBLEM) */\n-\n-/* For now, we can't use this code because we don't ensure that the\n-   objects returned are appropriately aligned.  The problem is that\n-   some tree_list sized things, for example, use */\n-#define NUM_EXTRA_ORDERS 0\n-\n-#endif /* !defined(NO_ALIGNMENT_PROBLEM) */\n-\n /* The Ith entry is the maximum size of an object to be stored in the\n    Ith extra order.  Adding a new entry to this array is the *only*\n    thing you need to do to add a new special allocation size.  */\n@@ -170,6 +159,26 @@ static const size_t extra_order_size_table[] = {\n \n #define NUM_ORDERS (HOST_BITS_PER_PTR + NUM_EXTRA_ORDERS)\n \n+/* We use this structure to determine the alignment required for\n+   allocations.  For power-of-two sized allocations, that's not a\n+   problem, but it does matter for odd-sized allocations.  */\n+\n+struct max_alignment {\n+  char c;\n+  union {\n+    HOST_WIDEST_INT i;\n+#ifdef HAVE_LONG_DOUBLE\n+    long double d;\n+#else\n+    double d;\n+#endif\n+  } u;\n+};\n+\n+/* The biggest alignment required.  */\n+\n+#define MAX_ALIGNMENT (offsetof (struct max_alignment, u))\n+\n /* The Ith entry is the number of objects on a page or order I.  */\n \n static unsigned objects_per_page_table[NUM_ORDERS];\n@@ -878,8 +887,14 @@ init_ggc ()\n   for (order = 0; order < HOST_BITS_PER_PTR; ++order)\n     object_size_table[order] = (size_t) 1 << order;\n   for (order = HOST_BITS_PER_PTR; order < NUM_ORDERS; ++order)\n-    object_size_table[order] = \n-      extra_order_size_table[order - HOST_BITS_PER_PTR];\n+    {\n+      size_t s = extra_order_size_table[order - HOST_BITS_PER_PTR];\n+\n+      /* If S is not a multiple of the MAX_ALIGNMENT, then round it up\n+\t so that we're sure of getting aligned memory.  */\n+      s = CEIL (s, MAX_ALIGNMENT) * MAX_ALIGNMENT;\n+      object_size_table[order] = s;\n+    }\n \n   /* Initialize the objects-per-page table.  */\n   for (order = 0; order < NUM_ORDERS; ++order)"}]}