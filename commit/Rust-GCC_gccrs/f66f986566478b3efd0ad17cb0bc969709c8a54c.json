{"sha": "f66f986566478b3efd0ad17cb0bc969709c8a54c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY2Zjk4NjU2NjQ3OGIzZWZkMGFkMTdjYjBiYzk2OTcwOWM4YTU0Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2008-11-29T21:24:03Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2008-11-29T21:24:03Z"}, "message": "rs6000.c (rs6000_emit_sync): Remove support for operand wrapped in NOT.\n\n        * config/rs6000/rs6000.c (rs6000_emit_sync): Remove support for\n        operand wrapped in NOT.  Emit NAND as (ior (not X) (not Y)).\n        (rs6000_split_atomic_op): Emit NAND as (ior (not X) (not Y)).\n        * config/rs6000/sync.md (sync_nand<mode>): Represent NAND in RTL.\n        Call rs6000_emit_sync with CODE=NOT and unmodified operands.\n        Ignore sub-word case for now.\n        (sync_nand<mode>_internal): Represent NAND in RTL.\n        (sync_old_nand<mode): Same.\n        (sync_old_name<mode>_internal): Same.\n        (sync_new_nand<mode>): Same.\n        (sync_new_nand<mode>_internal): Same.\n        (sync_boolcshort_internal): Expect NAND.\n\nFrom-SVN: r142285", "tree": {"sha": "09743a938c34a4cc92de532103162a9bb775cf70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09743a938c34a4cc92de532103162a9bb775cf70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f66f986566478b3efd0ad17cb0bc969709c8a54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66f986566478b3efd0ad17cb0bc969709c8a54c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f66f986566478b3efd0ad17cb0bc969709c8a54c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66f986566478b3efd0ad17cb0bc969709c8a54c/comments", "author": null, "committer": null, "parents": [{"sha": "71690b03abacd084c2cbc55d6c3c20e8e826c79d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71690b03abacd084c2cbc55d6c3c20e8e826c79d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71690b03abacd084c2cbc55d6c3c20e8e826c79d"}], "stats": {"total": 105, "additions": 56, "deletions": 49}, "files": [{"sha": "392b0249f3ddc9233e0272fe3bf965c95d0fff47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f66f986566478b3efd0ad17cb0bc969709c8a54c", "patch": "@@ -1,3 +1,18 @@\n+2008-11-29  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_sync): Remove support for\n+\toperand wrapped in NOT.  Emit NAND as (ior (not X) (not Y)).\n+\t(rs6000_split_atomic_op): Emit NAND as (ior (not X) (not Y)).\n+\t* config/rs6000/sync.md (sync_nand<mode>): Represent NAND in RTL.\n+\tCall rs6000_emit_sync with CODE=NOT and unmodified operands.\n+\tIgnore sub-word case for now.\n+\t(sync_nand<mode>_internal): Represent NAND in RTL.\n+\t(sync_old_nand<mode): Same.\n+\t(sync_old_name<mode>_internal): Same.\n+\t(sync_new_nand<mode>): Same.\n+\t(sync_new_nand<mode>_internal): Same.\n+\t(sync_boolcshort_internal): Expect NAND.\n+\n 2008-11-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37955"}, {"sha": "e2d8ddc0003692e92a2e228637f190b451b93448", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f66f986566478b3efd0ad17cb0bc969709c8a54c", "patch": "@@ -13826,9 +13826,6 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n   if (sync_p)\n     emit_insn (gen_lwsync ());\n \n-  if (GET_CODE (m) == NOT)\n-    used_m = XEXP (m, 0);\n-  else\n     used_m = m;\n \n   /* If this is smaller than SImode, we'll have to use SImode with\n@@ -13870,10 +13867,7 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n       /* It's safe to keep the old alias set of USED_M, because\n \t the operation is atomic and only affects the original\n \t USED_M.  */\n-      if (GET_CODE (m) == NOT)\n-\tm = gen_rtx_NOT (SImode, used_m);\n-      else\n-\tm = used_m;\n+      m = used_m;\n \n       if (GET_CODE (op) == NOT)\n \t{\n@@ -13893,6 +13887,13 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \t  emit_insn (gen_ashlsi3 (newop, newop, shift));\n \t  break;\n \n+\tcase NOT: /* NAND */\n+\t  newop = expand_binop (SImode, ior_optab,\n+\t\t\t\toldop, GEN_INT (~imask), NULL_RTX,\n+\t\t\t\t1, OPTAB_LIB_WIDEN);\n+\t  emit_insn (gen_rotlsi3 (newop, newop, shift));\n+\t  break;\n+\n \tcase AND:\n \t  newop = expand_binop (SImode, ior_optab,\n \t\t\t\toldop, GEN_INT (~imask), NULL_RTX,\n@@ -13930,19 +13931,6 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \t  gcc_unreachable ();\n \t}\n \n-      if (GET_CODE (m) == NOT)\n-\t{\n-\t  rtx mask, xorm;\n-\n-\t  mask = gen_reg_rtx (SImode);\n-\t  emit_move_insn (mask, GEN_INT (imask));\n-\t  emit_insn (gen_ashlsi3 (mask, mask, shift));\n-\n-\t  xorm = gen_rtx_XOR (SImode, used_m, mask);\n-\t  /* Depending on the value of 'op', the XOR or the operation might\n-\t     be able to be simplified away.  */\n-\t  newop = simplify_gen_binary (code, SImode, xorm, newop);\n-\t}\n       op = newop;\n       used_mode = SImode;\n       before = gen_reg_rtx (used_mode);\n@@ -13960,11 +13948,15 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \tafter = gen_reg_rtx (used_mode);\n     }\n \n-  if ((code == PLUS || code == MINUS || GET_CODE (m) == NOT)\n+  if ((code == PLUS || code == MINUS)\n       && used_mode != mode)\n     the_op = op;  /* Computed above.  */\n   else if (GET_CODE (op) == NOT && GET_CODE (m) != NOT)\n     the_op = gen_rtx_fmt_ee (code, used_mode, op, m);\n+  else if (code == NOT)\n+    the_op = gen_rtx_fmt_ee (IOR, used_mode,\n+\t\t\t     gen_rtx_NOT (used_mode, m),\n+\t\t\t     gen_rtx_NOT (used_mode, op));\n   else\n     the_op = gen_rtx_fmt_ee (code, used_mode, m, op);\n \n@@ -14075,7 +14067,9 @@ rs6000_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n   emit_load_locked (mode, before, mem);\n \n   if (code == NOT)\n-    x = gen_rtx_AND (mode, gen_rtx_NOT (mode, before), val);\n+    x = gen_rtx_IOR (mode,\n+\t\t     gen_rtx_NOT (mode, before),\n+\t\t     gen_rtx_NOT (mode, val));\n   else if (code == AND)\n     x = gen_rtx_UNSPEC (mode, gen_rtvec (2, before, val), UNSPEC_AND);\n   else"}, {"sha": "0adc23cfc04bb36a3825717c485ecf1f4f3bb5dc", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f66f986566478b3efd0ad17cb0bc969709c8a54c/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=f66f986566478b3efd0ad17cb0bc969709c8a54c", "patch": "@@ -210,8 +210,8 @@\n (define_expand \"sync_nand<mode>\"\n   [(parallel [(set (match_operand:INT1 0 \"memory_operand\" \"\")\n \t      (unspec:INT1\n-\t\t[(and:INT1 (not:INT1 (match_dup 0))\n-\t\t   (match_operand:INT1 1 \"gpc_reg_operand\" \"\"))]\n+\t\t[(ior:INT1 (not:INT1 (match_dup 0))\n+\t\t\t   (not:INT1 (match_operand:INT1 1 \"gpc_reg_operand\" \"\")))]\n \t\tUNSPEC_ATOMIC))\n \t      (clobber (scratch:INT1))\n \t      (clobber (scratch:CC))])]\n@@ -220,11 +220,10 @@\n {\n   if (<MODE>mode != SImode && <MODE>mode != DImode)\n     {\n+      FAIL;\n       if (PPC405_ERRATUM77)\n \tFAIL;\n-      rs6000_emit_sync (AND, <MODE>mode,\n-\t\t\tgen_rtx_NOT (<MODE>mode, operands[0]),\n-\t\t\toperands[1],\n+      rs6000_emit_sync (NOT, <MODE>mode, operands[0], operands[1],\n \t\t\tNULL_RTX, NULL_RTX, true);\n       DONE;\n     }\n@@ -233,8 +232,8 @@\n (define_insn_and_split \"*sync_nand<mode>_internal\"\n   [(set (match_operand:GPR 0 \"memory_operand\" \"+Z\")\n \t(unspec:GPR\n-\t  [(and:GPR (not:GPR (match_dup 0))\n-\t     (match_operand:GPR 1 \"gpc_reg_operand\" \"r\"))]\n+\t  [(ior:GPR (not:GPR (match_dup 0))\n+\t\t    (not:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:GPR 2 \"=&r\"))\n    (clobber (match_scratch:CC 3 \"=&x\"))]\n@@ -316,8 +315,8 @@\n \t\t   (match_operand:INT1 1 \"memory_operand\" \"\"))\n \t      (set (match_dup 1)\n \t\t   (unspec:INT1\n-\t\t     [(and:INT1 (not:INT1 (match_dup 1))\n-\t\t\t(match_operand:INT1 2 \"gpc_reg_operand\" \"\"))]\n+\t\t     [(ior:INT1 (not:INT1 (match_dup 1))\n+\t\t\t\t(not:INT1 (match_operand:INT1 2 \"gpc_reg_operand\" \"\")))]\n \t\t     UNSPEC_ATOMIC))\n \t      (clobber (scratch:INT1))\n \t      (clobber (scratch:CC))])]\n@@ -326,11 +325,10 @@\n {\n   if (<MODE>mode != SImode && <MODE>mode != DImode)\n     {\n+      FAIL;\n       if (PPC405_ERRATUM77)\n \tFAIL;\n-      rs6000_emit_sync (AND, <MODE>mode,\n-\t\t\tgen_rtx_NOT (<MODE>mode, operands[1]),\n-\t\t\toperands[2],\n+      rs6000_emit_sync (NOT, <MODE>mode, operands[1], operands[2],\n \t\t\toperands[0], NULL_RTX, true);\n       DONE;\n     }\n@@ -341,8 +339,8 @@\n \t(match_operand:GPR 1 \"memory_operand\" \"+Z\"))\n    (set (match_dup 1)\n \t(unspec:GPR\n-\t  [(and:GPR (not:GPR (match_dup 1))\n-\t     (match_operand:GPR 2 \"gpc_reg_operand\" \"r\"))]\n+\t  [(ior:GPR (not:GPR (match_dup 1))\n+\t\t    (not:GPR (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:GPR 3 \"=&r\"))\n    (clobber (match_scratch:CC 4 \"=&x\"))]\n@@ -424,12 +422,13 @@\n \n (define_expand \"sync_new_nand<mode>\"\n   [(parallel [(set (match_operand:INT1 0 \"gpc_reg_operand\" \"\")\n-\t\t   (and:INT1\n+\t\t   (ior:INT1\n \t\t     (not:INT1 (match_operand:INT1 1 \"memory_operand\" \"\"))\n-\t\t     (match_operand:INT1 2 \"gpc_reg_operand\" \"\")))\n+\t\t     (not:INT1 (match_operand:INT1 2 \"gpc_reg_operand\" \"\"))))\n \t      (set (match_dup 1)\n \t\t   (unspec:INT1\n-\t\t     [(and:INT1 (not:INT1 (match_dup 1)) (match_dup 2))]\n+\t\t     [(ior:INT1 (not:INT1 (match_dup 1))\n+\t\t\t\t(not:INT1 (match_dup 2)))]\n \t\t     UNSPEC_ATOMIC))\n \t      (clobber (scratch:INT1))\n \t      (clobber (scratch:CC))])]\n@@ -438,24 +437,23 @@\n {\n   if (<MODE>mode != SImode && <MODE>mode != DImode)\n     {\n+      FAIL;\n       if (PPC405_ERRATUM77)\n \tFAIL;\n-      rs6000_emit_sync (AND, <MODE>mode,\n-\t\t\tgen_rtx_NOT (<MODE>mode, operands[1]),\n-\t\t\toperands[2],\n+      rs6000_emit_sync (NOT, <MODE>mode, operands[1], operands[2],\n \t\t\tNULL_RTX, operands[0], true);\n       DONE;\n     }\n }\")\n \n (define_insn_and_split \"*sync_new_nand<mode>_internal\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=&r\")\n-\t(and:GPR\n+\t(ior:GPR\n \t  (not:GPR (match_operand:GPR 1 \"memory_operand\" \"+Z\"))\n-\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))\n+\t  (not:GPR (match_operand:GPR 2 \"gpc_reg_operand\" \"r\"))))\n    (set (match_dup 1)\n \t(unspec:GPR\n-\t  [(and:GPR (not:GPR (match_dup 1)) (match_dup 2))]\n+\t  [(ior:GPR (not:GPR (match_dup 1)) (not:GPR (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:GPR 3 \"=&r\"))\n    (clobber (match_scratch:CC 4 \"=&x\"))]\n@@ -580,10 +578,10 @@\n ; Likewise, operand 5 is in practice either <= 2^16 or it is a register.\n (define_insn \"*sync_boolcshort_internal\"\n   [(set (match_operand:SI 2 \"gpc_reg_operand\" \"=&r\")\n-\t(match_operator:SI 4 \"boolean_operator\"\n-\t [(xor:SI (match_operand:SI 0 \"memory_operand\" \"+Z\")\n-\t\t  (match_operand:SI 5 \"logical_operand\" \"rK\"))\n-\t  (match_operand:SI 1 \"gpc_reg_operand\" \"r\")]))\n+\t(match_operator:SI 4 \"boolean_or_operator\"\n+\t [(xor:SI (not:SI (match_operand:SI 0 \"memory_operand\" \"+Z\"))\n+\t\t  (not:SI (match_operand:SI 5 \"logical_operand\" \"rK\")))\n+\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")]))\n    (set (match_operand:SI 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n    (set (match_dup 0) (unspec:SI [(match_dup 4)] UNSPEC_SYNC_OP))\n    (clobber (match_scratch:CC 6 \"=&x\"))]"}]}