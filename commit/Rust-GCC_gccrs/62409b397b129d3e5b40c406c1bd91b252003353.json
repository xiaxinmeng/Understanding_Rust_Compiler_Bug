{"sha": "62409b397b129d3e5b40c406c1bd91b252003353", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0MDliMzk3YjEyOWQzZTViNDBjNDA2YzFiZDkxYjI1MjAwMzM1Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-10T09:21:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-10T09:21:37Z"}, "message": "cp-tree.h (FN_TRY_BLOCK_P): New macro.\n\n\t* cp-tree.h (FN_TRY_BLOCK_P): New macro.\n\t* init.c (perform_member_init): Remove obstack machinations.\n\t(expand_cleanup_for_base): Likewise.\n\t(finish_init_stmts): Mark the statement-expression as used.\n\t* method.c (emit_thunk): Use tree-generating functions, not\n\tRTL.\n\t(do_build_copy_constructor): Likewise.\n\t(do_build_assign_ref): Likewise.\n\t(synthesize_method): Likewise.  Keep track of line numbers.\n\t* pt.c (tsubst_expr): Handle various kinds of try blocks.\n\t* semantics.c (expand_stmts): Remove.\n\t(begin_function_try_block): Set FN_TRY_BLOCK_P.\n\t(finish_function_try_block): Be careful rechaining\n\tfunction try blocks.\n\t(expand_stmt): Loop through all the statements at a given level.\n\t(exapnd_body): Be careful with line-numbers here too.  Prepare for\n\tbeing called directly from the parser.\n\nFrom-SVN: r29263", "tree": {"sha": "f37256f751716adcc44c2b70bf519b5fe2388f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37256f751716adcc44c2b70bf519b5fe2388f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62409b397b129d3e5b40c406c1bd91b252003353", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62409b397b129d3e5b40c406c1bd91b252003353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62409b397b129d3e5b40c406c1bd91b252003353", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62409b397b129d3e5b40c406c1bd91b252003353/comments", "author": null, "committer": null, "parents": [{"sha": "ca5b5533e1a80628f6afca632fcece5395305665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5b5533e1a80628f6afca632fcece5395305665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5b5533e1a80628f6afca632fcece5395305665"}], "stats": {"total": 553, "additions": 327, "deletions": 226}, "files": [{"sha": "8996c44b51235ca0574aebe830f05ea9a9f5fd13", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -1,5 +1,23 @@\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (FN_TRY_BLOCK_P): New macro.\n+\t* init.c (perform_member_init): Remove obstack machinations.\n+\t(expand_cleanup_for_base): Likewise.\n+\t(finish_init_stmts): Mark the statement-expression as used.\n+\t* method.c (emit_thunk): Use tree-generating functions, not\n+\tRTL.\n+\t(do_build_copy_constructor): Likewise.\n+\t(do_build_assign_ref): Likewise.\n+\t(synthesize_method): Likewise.  Keep track of line numbers.\n+\t* pt.c (tsubst_expr): Handle various kinds of try blocks.\n+\t* semantics.c (expand_stmts): Remove.\n+\t(begin_function_try_block): Set FN_TRY_BLOCK_P.\n+\t(finish_function_try_block): Be careful rechaining \n+\tfunction try blocks.\n+\t(expand_stmt): Loop through all the statements at a given level.\n+\t(exapnd_body): Be careful with line-numbers here too.  Prepare for\n+\tbeing called directly from the parser.\n+\n \t* cp-tree.h (finish_function): Adjust prototype.\n \t* decl.c (finish_function): Return the function compiled.\n \t* pt.c (instantiate_decl): Don't play games with obstacks."}, {"sha": "9be527edb5a45d48c1e03813df90821f66fb71ad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -63,6 +63,7 @@ Boston, MA 02111-1307, USA.  */\n       BINFO_PUSHDECLS_MARKED.\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n+      FN_TRY_BLOCK_P (in TRY_BLOCK)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n@@ -2429,6 +2430,8 @@ extern int flag_new_for_scope;\n #define TRY_STMTS(NODE)         TREE_OPERAND (NODE, 0)\n #define TRY_HANDLERS(NODE)      TREE_OPERAND (NODE, 1)\n #define CLEANUP_P(NODE)         TREE_LANG_FLAG_0 (NODE)\n+/* Nonzero if this try block is a function try block.  */\n+#define FN_TRY_BLOCK_P(NODE)    TREE_LANG_FLAG_3 (NODE)\n #define HANDLER_PARMS(NODE)     TREE_OPERAND (NODE, 0)\n #define HANDLER_BODY(NODE)      TREE_OPERAND (NODE, 1)\n #define COMPOUND_BODY(NODE)     TREE_OPERAND (NODE, 0)"}, {"sha": "0d9af2c6bd5ab3f86939d68cda37de783d70d371", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -225,19 +225,13 @@ perform_member_init (member, name, init, explicit)\n     {\n       tree expr;\n \n-      /* All cleanups must be on the function_obstack.  */\n-      push_obstacks_nochange ();\n-      resume_temporary_allocation ();\n-\n       expr = build_component_ref (current_class_ref, name, NULL_TREE,\n \t\t\t\t  explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n       if (expr != error_mark_node)\n \tfinish_subobject (expr);\n-\n-      pop_obstacks ();\n     }\n }\n \n@@ -699,10 +693,6 @@ expand_cleanup_for_base (binfo, flag)\n   if (!TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (binfo)))\n     return;\n \n-  /* All cleanups must be on the function_obstack.  */\n-  push_obstacks_nochange ();\n-  resume_temporary_allocation ();\n-\n   /* Call the destructor.  */\n   expr = (build_scoped_method_call\n \t  (current_class_ref, binfo, dtor_identifier,\n@@ -712,7 +702,6 @@ expand_cleanup_for_base (binfo, flag)\n \t\t\ttruthvalue_conversion (flag),\n \t\t\texpr, integer_zero_node));\n \n-  pop_obstacks ();\n   finish_subobject (expr);\n }\n \n@@ -1009,9 +998,17 @@ finish_init_stmts (stmt_expr, compound_stmt)\n      tree compound_stmt;\n {\n   pop_momentary ();\n-  return finish_stmt_expr (stmt_expr,\n-\t\t\t   finish_compound_stmt (/*has_no_scope=*/1, \n-\t\t\t\t\t\t compound_stmt));\n+  stmt_expr \n+    = finish_stmt_expr (stmt_expr,\n+\t\t\tfinish_compound_stmt (/*has_no_scope=*/1, \n+\t\t\t\t\t      compound_stmt));\n+\n+  /* To avoid spurious warnings about unused values, we set \n+     TREE_USED.  */\n+  if (stmt_expr)\n+    TREE_USED (stmt_expr) = 1;\n+\n+  return stmt_expr;\n }\n \n /* This is like `expand_member_init', only it stores one aggregate"}, {"sha": "5e9c578bf8dfb5846dc339ca5a150693206e582c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -2147,7 +2147,7 @@ emit_thunk (thunk_fndecl)\n       t = tree_cons (NULL_TREE, a, t);\n     t = nreverse (t);\n     t = build_call (function, TREE_TYPE (TREE_TYPE (function)), t);\n-    c_expand_return (t);\n+    finish_return_stmt (t);\n \n     finish_function (lineno, 0);\n \n@@ -2172,7 +2172,6 @@ do_build_copy_constructor (fndecl)\n      tree fndecl;\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n-  tree compound_stmt;\n   tree t;\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n@@ -2249,9 +2248,6 @@ do_build_copy_constructor (fndecl)\n       current_base_init_list = nreverse (current_base_init_list);\n       setup_vtbl_ptr ();\n     }\n-\n-  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n }\n \n static void\n@@ -2290,7 +2286,7 @@ do_build_assign_ref (fndecl)\n \t  p = convert_from_reference (p);\n \t  p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n \t\t\t\t build_expr_list (NULL_TREE, p));\n-\t  expand_expr_stmt (p);\n+\t  finish_expr_stmt (p);\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n@@ -2342,10 +2338,10 @@ do_build_assign_ref (fndecl)\n \t  comp = build (COMPONENT_REF, TREE_TYPE (field), comp, field);\n \t  init = build (COMPONENT_REF, TREE_TYPE (field), init, field);\n \n-\t  expand_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n+\t  finish_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n \t}\n     }\n-  c_expand_return (current_class_ref);\n+  finish_return_stmt (current_class_ref);\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n }\n \n@@ -2355,6 +2351,7 @@ synthesize_method (fndecl)\n {\n   int nested = (current_function_decl != NULL_TREE);\n   tree context = hack_decl_function_context (fndecl);\n+  int need_body = 1;\n \n   if (at_eof)\n     import_export_decl (fndecl);\n@@ -2364,13 +2361,25 @@ synthesize_method (fndecl)\n   else if (nested)\n     push_function_context_to (context);\n \n+  /* Put the function definition at the position where it is needed,\n+     rather than within the body of the class.  That way, an error\n+     during the generation of the implicit body points at the place\n+     where the attempt to generate the function occurs, giving the\n+     user a hint as to why we are attempting to generate the\n+     function. */\n+  DECL_SOURCE_LINE (fndecl) = lineno;\n+  DECL_SOURCE_FILE (fndecl) = input_filename;\n+\n   interface_unknown = 1;\n   start_function (NULL_TREE, fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   store_parm_decls ();\n   clear_last_expr ();\n \n   if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])\n-    do_build_assign_ref (fndecl);\n+    {\n+      do_build_assign_ref (fndecl);\n+      need_body = 0;\n+    }\n   else if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n     ;\n   else\n@@ -2381,13 +2390,16 @@ synthesize_method (fndecl)\n       if (arg_chain != void_list_node)\n \tdo_build_copy_constructor (fndecl);\n       else if (TYPE_NEEDS_CONSTRUCTING (current_class_type))\n-\t{\n-\t  tree compound_stmt;\n+\tsetup_vtbl_ptr ();\n+    }\n \n-\t  setup_vtbl_ptr ();\n-\t  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-\t  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n-\t}\n+  /* If we haven't yet generated the body of the function, just\n+     generate an empty compound statement.  */\n+  if (need_body)\n+    {\n+      tree compound_stmt;\n+      compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+      finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n     }\n \n   finish_function (lineno, 0);"}, {"sha": "a21431796837bc5447c3c4eb45d4f65f6f7db2aa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -7443,16 +7443,32 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case TRY_BLOCK:\n       prep_stmt (t);\n-      stmt = begin_try_block ();\n-      tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n-      finish_try_block (stmt);\n       if (CLEANUP_P (t))\n-\tfinish_cleanup (tsubst_expr (TRY_HANDLERS (t), args,\n-\t\t\t\t     complain, in_decl),\n-\t\t\tstmt);\n+\t{\n+\t  begin_try_block ();\n+\t  tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n+\t  finish_cleanup_try_block (stmt);\n+\t  finish_cleanup (tsubst_expr (TRY_HANDLERS (t), args,\n+\t\t\t\t       complain, in_decl),\n+\t\t\t  stmt);\n+\t}\n       else\n \t{\n-\t  tree handler = TRY_HANDLERS (t);\n+\t  tree handler;\n+\n+\t  if (FN_TRY_BLOCK_P (t))\n+\t    stmt = begin_function_try_block ();\n+\t  else\n+\t    stmt = begin_try_block ();\n+\n+\t  tsubst_expr (TRY_STMTS (t), args, complain, in_decl);\n+\n+\t  if (FN_TRY_BLOCK_P (t))\n+\t    finish_function_try_block (stmt);\n+\t  else\n+\t    finish_try_block (stmt);\n+\n+\t  handler = TRY_HANDLERS (t);\n \t  for (; handler; handler = TREE_CHAIN (handler))\n \t    tsubst_expr (handler, args, complain, in_decl);\n \t  finish_handler_sequence (stmt);"}, {"sha": "d2f6969bc7b701ae03c2eb5fbcde68380f152b22", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 245, "deletions": 190, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62409b397b129d3e5b40c406c1bd91b252003353/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=62409b397b129d3e5b40c406c1bd91b252003353", "patch": "@@ -41,7 +41,6 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n-static void expand_stmts PROTO((tree));\n static void do_pushlevel PROTO((void));\n static tree do_poplevel PROTO((void));\n static void finish_expr_stmt_real PROTO((tree, int));\n@@ -650,6 +649,7 @@ begin_function_try_block ()\n     {\n       tree r = build_min_nt (TRY_BLOCK, NULL_TREE,\n \t\t\t     NULL_TREE);\n+      FN_TRY_BLOCK_P (r) = 1;\n       add_tree (r);\n       return r;\n     }\n@@ -674,6 +674,14 @@ finish_try_block (try_block)\n     expand_start_all_catch ();  \n }\n \n+void\n+finish_cleanup_try_block (try_block)\n+     tree try_block;\n+{\n+  if (building_stmt_tree ())\n+    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+}\n+\n /* Finish an implicitly generated try-block, with a cleanup is given\n    by CLEANUP.  */\n \n@@ -698,7 +706,18 @@ finish_function_try_block (try_block)\n      tree try_block; \n {\n   if (building_stmt_tree ())\n-    RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+    {\n+      if (TREE_CHAIN (try_block) \n+\t  && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n+\t{\n+\t  /* Chain the compound statement after the CTOR_INITIALIZER.  */\n+\t  TREE_CHAIN (TREE_CHAIN (try_block)) = last_tree;\n+\t  /* And make the CTOR_INITIALIZER the body of the try-block.  */\n+\t  RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+\t}\n+      else\n+\tRECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n+    }\n   else\n     {\n       end_protect_partials ();\n@@ -2025,219 +2044,225 @@ expand_cond (t)\n     return t;\n }\n \n-/* Generate RTL for the chain of statements T.  */\n-\n-static void \n-expand_stmts (t)\n-     tree t;\n-{\n-  while (t)\n-    {\n-      expand_stmt (t);\n-      t = TREE_CHAIN (t);\n-    }\n-}\n-\n-/* Generate RTL for the statement T, and its substatements.  */\n+/* Generate RTL for the statement T, and its substatements, and any\n+   other statements at its nesting level.  */\n \n tree\n expand_stmt (t)\n      tree t;\n {\n-  int saved_stmts_are_full_exprs_p;\n   tree rval;\n \n-  if (t == NULL_TREE || t == error_mark_node)\n-    return NULL_TREE;\n+  while (t && t != error_mark_node)\n+    {\n+      int saved_stmts_are_full_exprs_p;\n \n-  /* Assume we'll have nothing to return.  */\n-  rval = NULL_TREE;\n+      /* Assume we'll have nothing to return.  */\n+      rval = NULL_TREE;\n \n-  /* Set up context appropriately for handling this statement.  */\n-  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n-  prep_stmt (t);\n+      /* Set up context appropriately for handling this statement.  */\n+      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n+      prep_stmt (t);\n \n-  switch (TREE_CODE (t))\n-    {\n-    case RETURN_STMT:\n-      finish_return_stmt (RETURN_EXPR (t));\n-      break;\n+      switch (TREE_CODE (t))\n+\t{\n+\tcase RETURN_STMT:\n+\t  finish_return_stmt (RETURN_EXPR (t));\n+\t  break;\n \n-    case EXPR_STMT:\n-      finish_expr_stmt_real (EXPR_STMT_EXPR (t),\n-\t\t\t     EXPR_STMT_ASSIGNS_THIS (t));\n-      break;\n+\tcase EXPR_STMT:\n+\t  finish_expr_stmt_real (EXPR_STMT_EXPR (t),\n+\t\t\t\t EXPR_STMT_ASSIGNS_THIS (t));\n+\t  break;\n \n-    case DECL_STMT:\n-      {\n-\ttree decl;\n-\tint i = suspend_momentary ();\n-\n-\tlineno = STMT_LINENO (t);\n-\temit_line_note (input_filename, lineno);\n-\tdecl = DECL_STMT_DECL (t);\n-\tif (TREE_CODE (decl) == LABEL_DECL)\n-\t  finish_label_decl (DECL_NAME (decl));\n-\telse\n+\tcase DECL_STMT:\n \t  {\n-\t    /* We need to clear DECL_CONTEXT so that maybe_push_decl\n-\t       will push it into the current scope.  */\n-\t    if (DECL_CONTEXT (decl) == current_function_decl)\n-\t      DECL_CONTEXT (decl) = NULL_TREE;\n-\t    /* If we marked this variable as dead when we processed it\n-\t       before, we must undo that now.  The variable has been\n-\t       resuscitated.  */\n-\t    if (TREE_CODE (decl) == VAR_DECL)\n-\t      DECL_DEAD_FOR_LOCAL (decl) = 0;\n-\t    maybe_push_decl (decl);\n-\t    if (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl))\n+\t    tree decl;\n+\t    int i = suspend_momentary ();\n+\n+\t    emit_line_note (input_filename, lineno);\n+\t    decl = DECL_STMT_DECL (t);\n+\t    if (TREE_CODE (decl) == LABEL_DECL)\n+\t      finish_label_decl (DECL_NAME (decl));\n+\t    else\n \t      {\n-\t\tmaybe_inject_for_scope_var (decl);\n-\t\tinitialize_local_var (decl, DECL_INITIAL (decl), 0);\n+\t\t/* If we marked this variable as dead when we processed it\n+\t\t   before, we must undo that now.  The variable has been\n+\t\t   resuscitated.  */\n+\t\tif (TREE_CODE (decl) == VAR_DECL)\n+\t\t  DECL_DEAD_FOR_LOCAL (decl) = 0;\n+\t\t/* We need to clear DECL_CONTEXT so that maybe_push_decl\n+\t\t   will push it into the current scope.  */\n+\t\tif (DECL_CONTEXT (decl) == current_function_decl)\n+\t\t  {\n+\t\t    DECL_CONTEXT (decl) = NULL_TREE;\n+\t\t    maybe_push_decl (decl);\n+\t\t  }\n+\t\t/* If this is a declaration for an automatic local\n+\t\t   variable, initialize it.  Note that we might also see a\n+\t\t   declaration for a namespace-scope object (declared with\n+\t\t   `extern') or an object with static storage duration\n+\t\t   (declared with `static').  We don't have to handle the\n+\t\t   initialization of those objects here; the former can\n+\t\t   never be a definition (only a declaration), and the\n+\t\t   latter is handled in finish_file.  */\n+\t\tif (TREE_CODE (decl) == VAR_DECL \n+\t\t    && !TREE_STATIC (decl)\n+\t\t    && !DECL_EXTERNAL (decl))\n+\t\t  {\n+\t\t    /* Support the old for-scope rules for backwards\n+\t\t       compatibility.  */\n+\t\t    maybe_inject_for_scope_var (decl);\n+\t\t    /* Let the back-end know about this variable.  */\n+\t\t    initialize_local_var (decl, DECL_INITIAL (decl), 0);\n+\t\t  }\n \t      }\n+\t    resume_momentary (i);\n \t  }\n-\tresume_momentary (i);\n-      }\n-      break;\n-\n-    case FOR_STMT:\n-      {\n-\ttree tmp;\n-\n-\tbegin_for_stmt ();\n-\tfor (tmp = FOR_INIT_STMT (t); tmp; tmp = TREE_CHAIN (tmp))\n-\t  expand_stmt (tmp);\n-\tfinish_for_init_stmt (NULL_TREE);\n-\tfinish_for_cond (expand_cond (FOR_COND (t)), NULL_TREE);\n-\ttmp = FOR_EXPR (t);\n-\tfinish_for_expr (tmp, NULL_TREE);\n-\texpand_stmt (FOR_BODY (t));\n-\tfinish_for_stmt (tmp, NULL_TREE);\n-      }\n-      break;\n-\n-    case WHILE_STMT:\n-      {\n-\tbegin_while_stmt ();\n-\tfinish_while_stmt_cond (expand_cond (WHILE_COND (t)), NULL_TREE);\n-\texpand_stmt (WHILE_BODY (t));\n-\tfinish_while_stmt (NULL_TREE);\n-      }\n-      break;\n+\t  break;\n \n-    case DO_STMT:\n-      {\n-\tbegin_do_stmt ();\n-\texpand_stmt (DO_BODY (t));\n-\tfinish_do_body (NULL_TREE);\n-\tfinish_do_stmt (DO_COND (t), NULL_TREE);\n-      }\n-      break;\n-\n-    case IF_STMT:\n-      begin_if_stmt ();\n-      finish_if_stmt_cond (expand_cond (IF_COND (t)), NULL_TREE);\n-      if (THEN_CLAUSE (t))\n-\t{\n-\t  expand_stmt (THEN_CLAUSE (t));\n-\t  finish_then_clause (NULL_TREE);\n-\t}\n-      if (ELSE_CLAUSE (t))\n-\t{\n-\t  begin_else_clause ();\n-\t  expand_stmt (ELSE_CLAUSE (t));\n-\t  finish_else_clause (NULL_TREE);\n-\t}\n-      finish_if_stmt ();\n-      break;\n-\n-    case COMPOUND_STMT:\n-      begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n-      expand_stmts (COMPOUND_BODY (t));\n-      rval = finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n-\t\t\t\t   NULL_TREE);\n-      break;\n-\n-    case BREAK_STMT:\n-      finish_break_stmt ();\n-      break;\n+\tcase FOR_STMT:\n+\t  {\n+\t    tree tmp;\n+\n+\t    begin_for_stmt ();\n+\t    expand_stmt (FOR_INIT_STMT (t));\n+\t    finish_for_init_stmt (NULL_TREE);\n+\t    finish_for_cond (expand_cond (FOR_COND (t)), NULL_TREE);\n+\t    tmp = FOR_EXPR (t);\n+\t    finish_for_expr (tmp, NULL_TREE);\n+\t    expand_stmt (FOR_BODY (t));\n+\t    finish_for_stmt (tmp, NULL_TREE);\n+\t  }\n+\t  break;\n \n-    case CONTINUE_STMT:\n-      finish_continue_stmt ();\n-      break;\n+\tcase WHILE_STMT:\n+\t  {\n+\t    begin_while_stmt ();\n+\t    finish_while_stmt_cond (expand_cond (WHILE_COND (t)), NULL_TREE);\n+\t    expand_stmt (WHILE_BODY (t));\n+\t    finish_while_stmt (NULL_TREE);\n+\t  }\n+\t  break;\n \n-    case SWITCH_STMT:\n-      {\n-\ttree cond;\n+\tcase DO_STMT:\n+\t  {\n+\t    begin_do_stmt ();\n+\t    expand_stmt (DO_BODY (t));\n+\t    finish_do_body (NULL_TREE);\n+\t    finish_do_stmt (DO_COND (t), NULL_TREE);\n+\t  }\n+\t  break;\n \n-\tbegin_switch_stmt ();\n-\tcond = expand_cond (SWITCH_COND (t));\n-\tfinish_switch_cond (cond, NULL_TREE);\n-\texpand_stmt (SWITCH_BODY (t));\n-\tfinish_switch_stmt (cond, NULL_TREE);\n-      }\n-      break;\n+\tcase IF_STMT:\n+\t  begin_if_stmt ();\n+\t  finish_if_stmt_cond (expand_cond (IF_COND (t)), NULL_TREE);\n+\t  if (THEN_CLAUSE (t))\n+\t    {\n+\t      expand_stmt (THEN_CLAUSE (t));\n+\t      finish_then_clause (NULL_TREE);\n+\t    }\n+\t  if (ELSE_CLAUSE (t))\n+\t    {\n+\t      begin_else_clause ();\n+\t      expand_stmt (ELSE_CLAUSE (t));\n+\t      finish_else_clause (NULL_TREE);\n+\t    }\n+\t  finish_if_stmt ();\n+\t  break;\n \n-    case CASE_LABEL:\n-      finish_case_label (CASE_LOW (t), CASE_HIGH (t));\n-      break;\n+\tcase COMPOUND_STMT:\n+\t  begin_compound_stmt (COMPOUND_STMT_NO_SCOPE (t));\n+\t  expand_stmt (COMPOUND_BODY (t));\n+\t  rval = finish_compound_stmt (COMPOUND_STMT_NO_SCOPE (t), \n+\t\t\t\t       NULL_TREE);\n+\t  break;\n \n-    case LABEL_STMT:\n-      finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n-      break;\n+\tcase BREAK_STMT:\n+\t  finish_break_stmt ();\n+\t  break;\n \n-    case GOTO_STMT:\n-      if (TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL)\n-\tfinish_goto_stmt (DECL_NAME (GOTO_DESTINATION (t)));\n-      else\n-\tfinish_goto_stmt (GOTO_DESTINATION (t));\n-      break;\n+\tcase CONTINUE_STMT:\n+\t  finish_continue_stmt ();\n+\t  break;\n \n-    case ASM_STMT:\n-      finish_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t), ASM_OUTPUTS\n-\t\t       (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n-      break;\n+\tcase SWITCH_STMT:\n+\t  {\n+\t    tree cond;\n \n-    case TRY_BLOCK:\n-      if (CLEANUP_P (t))\n-\t{\n-\t  expand_eh_region_start ();\n-\t  expand_stmt (TRY_STMTS (t));\n-\t  finish_cleanup (TRY_HANDLERS (t), NULL_TREE);\n-\t}\n-      else\n-\t{\n-\t  begin_try_block ();\n-\t  expand_stmt (TRY_STMTS (t));\n-\t  finish_try_block (NULL_TREE);\n-\t  expand_stmts (TRY_HANDLERS (t));\n-\t  finish_handler_sequence (NULL_TREE);\n+\t    begin_switch_stmt ();\n+\t    cond = expand_cond (SWITCH_COND (t));\n+\t    finish_switch_cond (cond, NULL_TREE);\n+\t    expand_stmt (SWITCH_BODY (t));\n+\t    finish_switch_stmt (cond, NULL_TREE);\n+\t  }\n+\t  break;\n+\n+\tcase CASE_LABEL:\n+\t  finish_case_label (CASE_LOW (t), CASE_HIGH (t));\n+\t  break;\n+\n+\tcase LABEL_STMT:\n+\t  finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n+\t  break;\n+\n+\tcase GOTO_STMT:\n+\t  if (TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL)\n+\t    finish_goto_stmt (DECL_NAME (GOTO_DESTINATION (t)));\n+\t  else\n+\t    finish_goto_stmt (GOTO_DESTINATION (t));\n+\t  break;\n+\n+\tcase ASM_STMT:\n+\t  finish_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t), ASM_OUTPUTS\n+\t\t\t   (t), ASM_INPUTS (t), ASM_CLOBBERS (t));\n+\t  break;\n+\n+\tcase TRY_BLOCK:\n+\t  if (CLEANUP_P (t))\n+\t    {\n+\t      expand_eh_region_start ();\n+\t      expand_stmt (TRY_STMTS (t));\n+\t      finish_cleanup_try_block (NULL_TREE);\n+\t      finish_cleanup (TRY_HANDLERS (t), NULL_TREE);\n+\t    }\n+\t  else\n+\t    {\n+\t      begin_try_block ();\n+\t      expand_stmt (TRY_STMTS (t));\n+\t      finish_try_block (NULL_TREE);\n+\t      expand_stmt (TRY_HANDLERS (t));\n+\t      finish_handler_sequence (NULL_TREE);\n+\t    }\n+\t  break;\n+\n+\tcase HANDLER:\n+\t  begin_handler ();\n+\t  if (HANDLER_PARMS (t))\n+\t    expand_start_catch_block (DECL_STMT_DECL (HANDLER_PARMS (t)));\n+\t  else\n+\t    expand_start_catch_block (NULL_TREE);\n+\t  finish_handler_parms (NULL_TREE);\n+\t  expand_stmt (HANDLER_BODY (t));\n+\t  finish_handler (NULL_TREE);\n+\t  break;\n+\n+\tcase SUBOBJECT:\n+\t  finish_subobject (SUBOBJECT_CLEANUP (t));\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (19990810);\n+\t  break;\n \t}\n-      break;\n \n-    case HANDLER:\n-      begin_handler ();\n-      if (HANDLER_PARMS (t))\n-\texpand_start_catch_block (DECL_STMT_DECL (HANDLER_PARMS (t)));\n-      else\n-\texpand_start_catch_block (NULL_TREE);\n-      finish_handler_parms (NULL_TREE);\n-      expand_stmt (HANDLER_BODY (t));\n-      finish_handler (NULL_TREE);\n-      break;\n+      /* Restore saved state.  */\n+      stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n \n-    case SUBOBJECT:\n-      finish_subobject (SUBOBJECT_CLEANUP (t));\n-      break;\n-\n-    default:\n-      my_friendly_abort (19990810);\n-      break;\n+      /* Go on to the next statement in this scope.  */\n+      t = TREE_CHAIN (t);\n     }\n \n-  /* Restore saved state.  */\n-  stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n-\n   return rval;\n }\n \n@@ -2247,9 +2272,30 @@ void\n expand_body (fn)\n      tree fn;\n {\n+  int saved_lineno;\n+  char *saved_input_filename;\n   tree t;\n   tree try_block;\n \n+  /* When the parser calls us after finishing the body of a template\n+     function, we don't really want to expand the body.  When we're\n+     processing an in-class definition of an inline function,\n+     PROCESSING_TEMPLATE_DECL will no longer be set here, so we have\n+     to look at the function itself.  */\n+  if (processing_template_decl\n+      || (DECL_LANG_SPECIFIC (fn) \n+\t  && DECL_TEMPLATE_INFO (fn)\n+\t  && uses_template_parms (DECL_TI_ARGS (fn))))\n+    return;\n+\n+  /* Save the current file name and line number.  When we expand the\n+     body of the funciton, we'll set LINENO and INPUT_FILENAME so that\n+     error-mesages come out in the right places.  */\n+  saved_lineno = lineno;\n+  saved_input_filename = input_filename;\n+  lineno = DECL_SOURCE_LINE (fn);\n+  input_filename = DECL_SOURCE_FILE (fn);\n+\n   start_function (NULL_TREE, fn, NULL_TREE, SF_PRE_PARSED | SF_EXPAND);\n   store_parm_decls ();\n \n@@ -2292,13 +2338,22 @@ expand_body (fn)\n   if (try_block)\n     {\n       finish_function_try_block (NULL_TREE);\n-      {\n-\ttree handler = TRY_HANDLERS (try_block);\n-\tfor (; handler; handler = TREE_CHAIN (handler))\n-\t  expand_stmt (handler);\n-      }\n+      expand_stmt (TRY_HANDLERS (try_block));\n       finish_function_handler_sequence (NULL_TREE);\n     }\n \n+  /* Statements should always be full-expressions at the outermost set\n+     of curly braces for a function.  */\n+  my_friendly_assert (stmts_are_full_exprs_p, 19990831);\n+\n+  /* The outermost statement for a function contains the line number\n+     recorded when we finished processing the function.  */\n+  lineno = STMT_LINENO (DECL_SAVED_TREE (fn));\n+\n+  /* Generate code for the function.  */\n   finish_function (lineno, 0);\n+\n+  /* And restore the current source position.  */\n+  lineno = saved_lineno;\n+  input_filename = saved_input_filename;\n }"}]}