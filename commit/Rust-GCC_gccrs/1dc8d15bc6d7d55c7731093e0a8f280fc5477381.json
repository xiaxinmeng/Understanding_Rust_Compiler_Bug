{"sha": "1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjOGQxNWJjNmQ3ZDU1Yzc3MzEwOTNlMGE4ZjI4MGZjNTQ3NzM4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-16T12:54:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-16T12:54:31Z"}, "message": "pr36648.cc: Disable cunrolli\n\n\t* g++.dg/vect/pr36648.cc: Disable cunrolli\n\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Fix estimation\n\tof comparsions in the last iteration.\n\nFrom-SVN: r237527", "tree": {"sha": "937ab4dc403f8ddab97d133b7ac933e2ef9fe060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/937ab4dc403f8ddab97d133b7ac933e2ef9fe060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/comments", "author": null, "committer": null, "parents": [{"sha": "0ae207e94796488449b40fe83263ddcefb4d9479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae207e94796488449b40fe83263ddcefb4d9479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae207e94796488449b40fe83263ddcefb4d9479"}], "stats": {"total": 136, "additions": 75, "deletions": 61}, "files": [{"sha": "087a2f720f4b7b133bca39cde888d4dcb4d50005", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "patch": "@@ -1,3 +1,8 @@\n+2016-06-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-loop-ivcanon.c (tree_estimate_loop_size): Fix estimation\n+\tof comparsions in the last iteration.\n+\n 2016-06-16  Claudiu Zissulescu  <claziss@synopsys.com>\n \t    Joern Rennecke  <joern.rennecke@embecosm.com>\n "}, {"sha": "8eff41d24a7b1ed7d608b8a762fea640a70a315e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "patch": "@@ -1,3 +1,7 @@\n+2016-06-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/vect/pr36648.cc: Disable cunrolli\n+\n 2016-06-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/71554"}, {"sha": "450ac75b60751f282e43f2292b4db506f3c46913", "filename": "gcc/testsuite/g++.dg/vect/pr36648.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr36648.cc?ref=1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target vect_float } */\n+// { dg-additional-options \"-fdisable-tree-cunrolli\" }\n \n struct vector\n {"}, {"sha": "76ecba4b7e8ce37f8fd26ed3b5016b653c267852", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 65, "deletions": 61, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc8d15bc6d7d55c7731093e0a8f280fc5477381/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=1dc8d15bc6d7d55c7731093e0a8f280fc5477381", "patch": "@@ -255,69 +255,73 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel,\n \n \t  /* Look for reasons why we might optimize this stmt away. */\n \n-\t  if (gimple_has_side_effects (stmt))\n-\t    ;\n-\t  /* Exit conditional.  */\n-\t  else if (exit && body[i] == exit->src\n-\t\t   && stmt == last_stmt (exit->src))\n+\t  if (!gimple_has_side_effects (stmt))\n \t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Exit condition will be eliminated \"\n-\t\t\t \"in peeled copies.\\n\");\n-\t      likely_eliminated_peeled = true;\n-\t    }\n-\t  else if (edge_to_cancel && body[i] == edge_to_cancel->src\n-\t\t   && stmt == last_stmt (edge_to_cancel->src))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Exit condition will be eliminated \"\n-\t\t\t \"in last copy.\\n\");\n-\t      likely_eliminated_last = true;\n-\t    }\n-\t  /* Sets of IV variables  */\n-\t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n-\t      && constant_after_peeling (gimple_assign_lhs (stmt), stmt, loop))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Induction variable computation will\"\n-\t\t\t \" be folded away.\\n\");\n-\t      likely_eliminated = true;\n-\t    }\n-\t  /* Assignments of IV variables.  */\n-\t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n-\t\t   && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt,\n-\t\t\t\t\t      loop)\n-\t\t   && (gimple_assign_rhs_class (stmt) != GIMPLE_BINARY_RHS\n-\t\t       || constant_after_peeling (gimple_assign_rhs2 (stmt),\n-\t\t       \t\t\t\t  stmt, loop)))\n-\t    {\n-\t      size->constant_iv = true;\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file,\n-\t\t\t \"   Constant expression will be folded away.\\n\");\n-\t      likely_eliminated = true;\n-\t    }\n-\t  /* Conditionals.  */\n-\t  else if ((gimple_code (stmt) == GIMPLE_COND\n-\t\t    && constant_after_peeling (gimple_cond_lhs (stmt), stmt,\n-\t\t\t\t\t       loop)\n-\t\t    && constant_after_peeling (gimple_cond_rhs (stmt), stmt,\n-\t\t\t\t\t       loop)\n-\t\t    /* We don't simplify all constant compares so make sure\n-\t\t       they are not both constant already.  See PR70288.  */\n-\t\t    && (! is_gimple_min_invariant (gimple_cond_lhs (stmt))\n-\t\t\t|| ! is_gimple_min_invariant (gimple_cond_rhs (stmt))))\n-\t\t   || (gimple_code (stmt) == GIMPLE_SWITCH\n-\t\t       && constant_after_peeling (gimple_switch_index (\n-\t\t\t\t\t\t    as_a <gswitch *> (stmt)),\n+\t      /* Exit conditional.  */\n+\t      if (exit && body[i] == exit->src\n+\t\t  && stmt == last_stmt (exit->src))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"   Exit condition will be eliminated \"\n+\t\t\t     \"in peeled copies.\\n\");\n+\t\t  likely_eliminated_peeled = true;\n+\t\t}\n+\t      if (edge_to_cancel && body[i] == edge_to_cancel->src\n+\t\t  && stmt == last_stmt (edge_to_cancel->src))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"   Exit condition will be eliminated \"\n+\t\t\t     \"in last copy.\\n\");\n+\t\t  likely_eliminated_last = true;\n+\t\t}\n+\t      /* Sets of IV variables  */\n+\t      if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t  && constant_after_peeling (gimple_assign_lhs (stmt), stmt, loop))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"   Induction variable computation will\"\n+\t\t\t     \" be folded away.\\n\");\n+\t\t  likely_eliminated = true;\n+\t\t}\n+\t      /* Assignments of IV variables.  */\n+\t      else if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t       && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t\t       && constant_after_peeling (gimple_assign_rhs1 (stmt),\n \t\t\t\t\t\t  stmt, loop)\n-\t\t       && ! is_gimple_min_invariant\n-\t\t\t       (gimple_switch_index (as_a <gswitch *> (stmt)))))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Constant conditional.\\n\");\n-\t      likely_eliminated = true;\n+\t\t       && (gimple_assign_rhs_class (stmt) != GIMPLE_BINARY_RHS\n+\t\t\t   || constant_after_peeling (gimple_assign_rhs2 (stmt),\n+\t\t\t\t\t\t      stmt, loop)))\n+\t\t{\n+\t\t  size->constant_iv = true;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"   Constant expression will be folded away.\\n\");\n+\t\t  likely_eliminated = true;\n+\t\t}\n+\t      /* Conditionals.  */\n+\t      else if ((gimple_code (stmt) == GIMPLE_COND\n+\t\t\t&& constant_after_peeling (gimple_cond_lhs (stmt), stmt,\n+\t\t\t\t\t\t   loop)\n+\t\t\t&& constant_after_peeling (gimple_cond_rhs (stmt), stmt,\n+\t\t\t\t\t\t   loop)\n+\t\t\t/* We don't simplify all constant compares so make sure\n+\t\t\t   they are not both constant already.  See PR70288.  */\n+\t\t\t&& (! is_gimple_min_invariant (gimple_cond_lhs (stmt))\n+\t\t\t    || ! is_gimple_min_invariant\n+\t\t\t\t (gimple_cond_rhs (stmt))))\n+\t\t       || (gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t\t   && constant_after_peeling (gimple_switch_index (\n+\t\t\t\t\t\t\tas_a <gswitch *>\n+\t\t\t\t\t\t\t  (stmt)),\n+\t\t\t\t\t\t      stmt, loop)\n+\t\t\t   && ! is_gimple_min_invariant\n+\t\t\t\t   (gimple_switch_index\n+\t\t\t\t      (as_a <gswitch *> (stmt)))))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"   Constant conditional.\\n\");\n+\t\t  likely_eliminated = true;\n+\t\t}\n \t    }\n \n \t  size->overall += num;"}]}