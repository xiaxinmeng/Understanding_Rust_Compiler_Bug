{"sha": "2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZlMWQ3NjJkNmYwNDg3NGQ2MWUwMDRhNzQwMGFiMzJlNmU0Y2E2ZQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-05-18T08:19:29Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-05-18T08:19:29Z"}, "message": "Move array-type va_list handling to build_va_arg\n\n2015-05-18  Tom de Vries  <tom@codesourcery.com>\n\n\t* gimplify.c (gimplify_modify_expr): Remove do_deref handling.\n\t(gimplify_va_arg_expr): Remove do_deref handling.  Remove adding of\n\taddress operator to va_list operand.\n\t* tree-stdarg.c (expand_ifn_va_arg_1): Do deref of va_list operand\n\tunconditionally.\n\t* config/i386/i386.c (ix86_gimplify_va_arg): Remove deref on va_list\n\toperand.\n\t* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Same.\n\t* config/s390/s390.c (s390_gimplify_va_arg): Same.\n\t* config/spu/spu.c (spu_gimplify_va_arg_expr): Same.\n\n\t* c-common.c (build_va_arg_1): New function.\n\t(build_va_arg): Add address operator to va_list operand if necessary.\n\nFrom-SVN: r223286", "tree": {"sha": "6fc922cafa797c756299ad1c165a14cb319e70a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fc922cafa797c756299ad1c165a14cb319e70a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/comments", "author": null, "committer": null, "parents": [{"sha": "daf347dddd48faffdc5912c99ea1b52f19be867d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf347dddd48faffdc5912c99ea1b52f19be867d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf347dddd48faffdc5912c99ea1b52f19be867d"}], "stats": {"total": 205, "additions": 143, "deletions": 62}, "files": [{"sha": "9d26fdf836931cf5166bce03eff57beb73bd26a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -1,3 +1,16 @@\n+2015-05-18  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* gimplify.c (gimplify_modify_expr): Remove do_deref handling.\n+\t(gimplify_va_arg_expr): Remove do_deref handling.  Remove adding of\n+\taddress operator to va_list operand.\n+\t* tree-stdarg.c (expand_ifn_va_arg_1): Do deref of va_list operand\n+\tunconditionally.\n+\t* config/i386/i386.c (ix86_gimplify_va_arg): Remove deref on va_list\n+\toperand.\n+\t* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Same.\n+\t* config/s390/s390.c (s390_gimplify_va_arg): Same.\n+\t* config/spu/spu.c (spu_gimplify_va_arg_expr): Same.\n+\n 2015-05-18  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c: Fix whitespace."}, {"sha": "a6abd601b08395b4feccf4ee4cf30e971441e51a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -1,3 +1,8 @@\n+2015-05-18  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* c-common.c (build_va_arg_1): New function.\n+\t(build_va_arg): Add address operator to va_list operand if necessary.\n+\n 2015-05-15  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR c/48956"}, {"sha": "6d8504905d16815a26c834c0c3e45f12ba22734e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 112, "deletions": 15, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -6084,6 +6084,20 @@ set_compound_literal_name (tree decl)\n   DECL_NAME (decl) = get_identifier (name);\n }\n \n+/* build_va_arg helper function.  Return a VA_ARG_EXPR with location LOC, type\n+   TYPE and operand OP.  */\n+\n+static tree\n+build_va_arg_1 (location_t loc, tree type, tree op)\n+{\n+  tree expr = build1 (VA_ARG_EXPR, type, op);\n+  SET_EXPR_LOCATION (expr, loc);\n+  return expr;\n+}\n+\n+/* Return a VA_ARG_EXPR corresponding to a source-level expression\n+   va_arg (EXPR, TYPE) at source location LOC.  */\n+\n tree\n build_va_arg (location_t loc, tree expr, tree type)\n {\n@@ -6092,24 +6106,107 @@ build_va_arg (location_t loc, tree expr, tree type)\n \t\t\t? NULL_TREE\n \t\t\t: targetm.canonical_va_list_type (va_type));\n \n-  if (canon_va_type != NULL)\n+  if (va_type == error_mark_node\n+      || canon_va_type == NULL_TREE)\n     {\n-      /* When the va_arg ap argument is a parm decl with declared type va_list,\n-\t and the va_list type is an array, then grokdeclarator changes the type\n-\t of the parm decl to the corresponding pointer type.  We know that that\n-\t pointer is constant, so there's no need to modify it, so there's no\n-\t need to pass it around using an address operator, so there's no need to\n-\t mark it addressable.  */\n-      if (!(TREE_CODE (canon_va_type) == ARRAY_TYPE\n-\t    && TREE_CODE (va_type) != ARRAY_TYPE))\n-\t/* In gimplify_va_arg_expr we take the address of the ap argument, mark\n-\t   it addressable now.  */\n-\tmark_addressable (expr);\n+      /* Let's handle things neutrallly, if expr:\n+\t - has undeclared type, or\n+\t - is not an va_list type.  */\n+      return build_va_arg_1 (loc, type, expr);\n     }\n \n-  expr = build1 (VA_ARG_EXPR, type, expr);\n-  SET_EXPR_LOCATION (expr, loc);\n-  return expr;\n+  if (TREE_CODE (canon_va_type) != ARRAY_TYPE)\n+    {\n+      /* Case 1: Not an array type.  */\n+\n+      /* Take the address, to get '&ap'.  */\n+      mark_addressable (expr);\n+      expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (expr)), expr);\n+\n+      /* Verify that &ap is still recognized as having va_list type.  */\n+      tree canon_expr_type\n+\t= targetm.canonical_va_list_type (TREE_TYPE (expr));\n+      gcc_assert (canon_expr_type != NULL_TREE);\n+\n+      return build_va_arg_1 (loc, type, expr);\n+    }\n+\n+  /* Case 2: Array type.\n+\n+     Background:\n+\n+     For contrast, let's start with the simple case (case 1).  If\n+     canon_va_type is not an array type, but say a char *, then when\n+     passing-by-value a va_list, the type of the va_list param decl is\n+     the same as for another va_list decl (all ap's are char *):\n+\n+     f2_1 (char * ap)\n+       D.1815 = VA_ARG (&ap, 0B, 1);\n+       return D.1815;\n+\n+     f2 (int i)\n+       char * ap.0;\n+       char * ap;\n+       __builtin_va_start (&ap, 0);\n+       ap.0 = ap;\n+       res = f2_1 (ap.0);\n+       __builtin_va_end (&ap);\n+       D.1812 = res;\n+       return D.1812;\n+\n+     However, if canon_va_type is ARRAY_TYPE, then when passing-by-value a\n+     va_list the type of the va_list param decl (case 2b, struct * ap) is not\n+     the same as for another va_list decl (case 2a, struct ap[1]).\n+\n+     f2_1 (struct  * ap)\n+       D.1844 = VA_ARG (ap, 0B, 0);\n+       return D.1844;\n+\n+     f2 (int i)\n+       struct  ap[1];\n+       __builtin_va_start (&ap, 0);\n+       res = f2_1 (&ap);\n+       __builtin_va_end (&ap);\n+       D.1841 = res;\n+       return D.1841;\n+\n+     Case 2b is different because:\n+     - on the callee side, the parm decl has declared type va_list, but\n+       grokdeclarator changes the type of the parm decl to a pointer to the\n+       array elem type.\n+     - on the caller side, the pass-by-value uses &ap.\n+\n+     We unify these two cases (case 2a: va_list is array type,\n+     case 2b: va_list is pointer to array elem type), by adding '&' for the\n+     array type case, such that we have a pointer to array elem in both\n+     cases.  */\n+\n+  if (TREE_CODE (va_type) == ARRAY_TYPE)\n+    {\n+      /* Case 2a: va_list is array type.  */\n+\n+      /* Take the address, to get '&ap'.  Make sure it's a pointer to array\n+\t elem type.  */\n+      mark_addressable (expr);\n+      expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (canon_va_type)),\n+\t\t     expr);\n+\n+      /* Verify that &ap is still recognized as having va_list type.  */\n+      tree canon_expr_type\n+\t= targetm.canonical_va_list_type (TREE_TYPE (expr));\n+      gcc_assert (canon_expr_type != NULL_TREE);\n+    }\n+  else\n+    {\n+      /* Case 2b: va_list is pointer to array elem type.  */\n+      gcc_assert (POINTER_TYPE_P (va_type));\n+      gcc_assert (TREE_TYPE (va_type) == TREE_TYPE (canon_va_type));\n+\n+      /* Don't take the address.  We've already got '&ap'.  */\n+      ;\n+    }\n+\n+  return build_va_arg_1 (loc, type, expr);\n }\n \n "}, {"sha": "33c876c675d235d2059e5c4ca4bfcc4f32c9d4da", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -9094,8 +9094,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   f_sav = DECL_CHAIN (f_ovf);\n \n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr),\n-\t\tbuild_va_arg_indirect_ref (valist), f_gpr, NULL_TREE);\n-  valist = build_va_arg_indirect_ref (valist);\n+\t\tvalist, f_gpr, NULL_TREE);\n+\n   fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n   ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n   sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n@@ -9315,7 +9315,7 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n \t\t      build_int_cst (TREE_TYPE (fpr), needed_sseregs * 16));\n-\t  gimplify_assign (fpr, t, pre_p);\n+\t  gimplify_assign (unshare_expr (fpr), t, pre_p);\n \t}\n \n       gimple_seq_add_stmt (pre_p, gimple_build_goto (lab_over));"}, {"sha": "66f78a1f329c3c2e72872ad290a41eee04b08712", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -11470,7 +11470,6 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   f_ovf = DECL_CHAIN (f_res);\n   f_sav = DECL_CHAIN (f_ovf);\n \n-  valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n   fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), unshare_expr (valist),\n \t\tf_fpr, NULL_TREE);"}, {"sha": "e9a4e70856c5b366ce253e762453bba641e80a8f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -9747,7 +9747,6 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   f_ovf = DECL_CHAIN (f_fpr);\n   f_sav = DECL_CHAIN (f_ovf);\n \n-  valist = build_va_arg_indirect_ref (valist);\n   gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n   fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n   sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);"}, {"sha": "7a29df8bce1a731011a6ad3a8e40574b819aa2d4", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -4065,7 +4065,6 @@ spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n   f_args = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n   f_skip = DECL_CHAIN (f_args);\n \n-  valist = build_simple_mem_ref (valist);\n   args =\n     build3 (COMPONENT_REF, TREE_TYPE (f_args), valist, f_args, NULL_TREE);\n   skip ="}, {"sha": "7d53aa2c470745a2a6bae80139f7bef7f44d8c3e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -4655,13 +4655,13 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       if (TREE_CODE (call) == CALL_EXPR\n \t  && CALL_EXPR_IFN (call) == IFN_VA_ARG)\n \t{\n+\t  int nargs = call_expr_nargs (call);\n \t  tree type = TREE_TYPE (call);\n \t  tree ap = CALL_EXPR_ARG (call, 0);\n \t  tree tag = CALL_EXPR_ARG (call, 1);\n-\t  tree do_deref = CALL_EXPR_ARG (call, 2);\n \t  tree newcall = build_call_expr_internal_loc (EXPR_LOCATION (call),\n-\t\t\t\t\t\t       IFN_VA_ARG, type, 4, ap,\n-\t\t\t\t\t\t       tag, do_deref,\n+\t\t\t\t\t\t       IFN_VA_ARG, type,\n+\t\t\t\t\t\t       nargs + 1, ap, tag,\n \t\t\t\t\t\t       vlasize);\n \t  tree *call_p = &(TREE_OPERAND (*from_p, 0));\n \t  *call_p = newcall;\n@@ -9312,7 +9312,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n   tree promoted_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n-  tree t, tag, ap, do_deref;\n+  tree t, tag;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Verify that valist is of the proper type.  */\n@@ -9365,35 +9365,8 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n       return GS_ALL_DONE;\n     }\n \n-  /* Transform a VA_ARG_EXPR into an VA_ARG internal function.  */\n-  if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n-    {\n-      if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n-\t{\n-\t  /* Take the address, but don't strip it.  Gimplify_va_arg_internal\n-\t     expects a pointer to array element type.  */\n-\t  ap = build_fold_addr_expr_loc (loc, valist);\n-\t  do_deref = integer_zero_node;\n-\t}\n-      else\n-\t{\n-\t  /* Don't take the address.  Gimplify_va_arg_internal expects a pointer\n-\t     to array element type, and we already have that.\n-\t     See also comment in build_va_arg.  */\n-\t  ap = valist;\n-\t  do_deref = integer_zero_node;\n-\t}\n-    }\n-  else\n-    {\n-      /* No special handling.  Take the address here, note that it needs to be\n-\t stripped before calling gimplify_va_arg_internal. */\n-      ap = build_fold_addr_expr_loc (loc, valist);\n-      do_deref = integer_one_node;\n-    }\n   tag = build_int_cst (build_pointer_type (type), 0);\n-  *expr_p = build_call_expr_internal_loc (loc, IFN_VA_ARG, type, 3, ap, tag,\n-\t\t\t\t\t  do_deref);\n+  *expr_p = build_call_expr_internal_loc (loc, IFN_VA_ARG, type, 2, valist, tag);\n \n   /* Clear the tentatively set PROP_gimple_lva, to indicate that IFN_VA_ARG\n      needs to be expanded.  */"}, {"sha": "794b94a41ba148de18253e6478a393c9a69072f9", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe1d762d6f04874d61e004a7400ab32e6e4ca6e/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=2fe1d762d6f04874d61e004a7400ab32e6e4ca6e", "patch": "@@ -1042,7 +1042,7 @@ expand_ifn_va_arg_1 (function *fun)\n     for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n       {\n \tgimple stmt = gsi_stmt (i);\n-\ttree ap, expr, lhs, type, do_deref;\n+\ttree ap, expr, lhs, type;\n \tgimple_seq pre = NULL, post = NULL;\n \n \tif (!gimple_call_ifn_va_arg_p (stmt))\n@@ -1052,19 +1052,15 @@ expand_ifn_va_arg_1 (function *fun)\n \n \ttype = TREE_TYPE (TREE_TYPE (gimple_call_arg (stmt, 1)));\n \tap = gimple_call_arg (stmt, 0);\n-\tdo_deref = gimple_call_arg (stmt, 2);\n \n-\tif (do_deref == integer_one_node)\n-\t  ap = build_fold_indirect_ref (ap);\n+\t/* Balanced out the &ap, usually added by build_va_arg.  */\n+\tap = build_fold_indirect_ref (ap);\n \n \tpush_gimplify_context (false);\n \n \t/* Make it easier for the backends by protecting the valist argument\n \t   from multiple evaluations.  */\n-\tif (do_deref == integer_one_node)\n-\t  gimplify_expr (&ap, &pre, &post, is_gimple_min_lval, fb_lvalue);\n-\telse\n-\t  gimplify_expr (&ap, &pre, &post, is_gimple_val, fb_rvalue);\n+\tgimplify_expr (&ap, &pre, &post, is_gimple_min_lval, fb_lvalue);\n \n \texpr = targetm.gimplify_va_arg_expr (ap, type, &pre, &post);\n \n@@ -1074,7 +1070,7 @@ expand_ifn_va_arg_1 (function *fun)\n \t    unsigned int nargs = gimple_call_num_args (stmt);\n \t    gcc_assert (useless_type_conversion_p (TREE_TYPE (lhs), type));\n \n-\t    if (nargs == 4)\n+\t    if (nargs == 3)\n \t      {\n \t\t/* We've transported the size of with WITH_SIZE_EXPR here as\n \t\t   the last argument of the internal fn call.  Now reinstate"}]}