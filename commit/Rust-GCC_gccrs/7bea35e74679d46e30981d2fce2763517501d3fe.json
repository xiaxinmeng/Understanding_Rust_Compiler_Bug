{"sha": "7bea35e74679d46e30981d2fce2763517501d3fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlYTM1ZTc0Njc5ZDQ2ZTMwOTgxZDJmY2UyNzYzNTE3NTAxZDNmZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-16T17:00:05Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-16T17:00:05Z"}, "message": "Rework large stack frame support.\n\nFrom-SVN: r2884", "tree": {"sha": "a79262cf2cfa43e9f96bb858e75f351cb3e39b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a79262cf2cfa43e9f96bb858e75f351cb3e39b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bea35e74679d46e30981d2fce2763517501d3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bea35e74679d46e30981d2fce2763517501d3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bea35e74679d46e30981d2fce2763517501d3fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bea35e74679d46e30981d2fce2763517501d3fe/comments", "author": null, "committer": null, "parents": [{"sha": "f49acdb4d6348a0926eda78fc2ac0be9255d602c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f49acdb4d6348a0926eda78fc2ac0be9255d602c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f49acdb4d6348a0926eda78fc2ac0be9255d602c"}], "stats": {"total": 434, "additions": 283, "deletions": 151}, "files": [{"sha": "b4920a747da1551bdc82b40eb7a849c07317501a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 263, "deletions": 131, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bea35e74679d46e30981d2fce2763517501d3fe/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bea35e74679d46e30981d2fce2763517501d3fe/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7bea35e74679d46e30981d2fce2763517501d3fe", "patch": "@@ -3731,6 +3731,72 @@ mips_output_float (stream, value)\n #endif\n }\n \n+\f\n+/* Return TRUE if any register used in the epilogue is used.  This to insure\n+   any insn put into the epilogue delay slots is safe.  */\n+\n+int\n+epilogue_reg_mentioned_p (insn)\n+     rtx insn;\n+{\n+  register char *fmt;\n+  register int i;\n+  register enum rtx_code code;\n+  register int regno;\n+\n+  if (insn == (rtx)0)\n+    return 0;\n+\n+  if (GET_CODE (insn) == LABEL_REF)\n+    return 0;\n+\n+  code = GET_CODE (insn);\n+  switch (code)\n+    {\n+    case REG:\n+      regno = REGNO (insn);\n+      if (regno == STACK_POINTER_REGNUM)\n+\treturn 1;\n+\n+      if (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+\treturn 1;\n+\n+      if (!call_used_regs[regno])\n+\treturn 1;\n+\n+      if (regno != MIPS_TEMP1_REGNUM && regno != MIPS_TEMP2_REGNUM)\n+\treturn 0;\n+\n+      if (!current_frame_info.initialized)\n+\tcompute_frame_size (get_frame_size ());\n+\n+      return (current_frame_info.total_size >= 32768);\n+\n+    case SCRATCH:\n+    case CC0:\n+    case PC:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      return 0;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (insn, i) - 1; j >= 0; j--)\n+\t    if (epilogue_reg_mentioned_p (XVECEXP (insn, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && epilogue_reg_mentioned_p (XEXP (insn, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n \f\n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.\n@@ -3785,22 +3851,22 @@ mips_output_float (stream, value)\n \n */\n \n-unsigned long\n+long\n compute_frame_size (size)\n      int size;\t\t\t/* # of var. bytes allocated */\n {\n   int regno;\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up */\n-  unsigned long var_size;\t/* # bytes that variables take up */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up */\n-  unsigned long extra_size;\t/* # extra bytes */\n-  unsigned int  gp_reg_rounded;\t/* # bytes needed to store gp after rounding */\n-  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs */\n-  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs */\n-  unsigned long mask;\t\t/* mask of saved gp registers */\n-  unsigned long fmask;\t\t/* mask of saved fp registers */\n-  int fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs */\n-  int fp_bits;\t\t\t/* bitmask to use for each fp register */\n+  long total_size;\t\t/* # bytes that the entire frame takes up */\n+  long var_size;\t\t/* # bytes that variables take up */\n+  long args_size;\t\t/* # bytes that outgoing arguments take up */\n+  long extra_size;\t\t/* # extra bytes */\n+  long gp_reg_rounded;\t\t/* # bytes needed to store gp after rounding */\n+  long gp_reg_size;\t\t/* # bytes needed to store gp regs */\n+  long fp_reg_size;\t\t/* # bytes needed to store fp regs */\n+  long mask;\t\t\t/* mask of saved gp registers */\n+  long fmask;\t\t\t/* mask of saved fp registers */\n+  int  fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs */\n+  long fp_bits;\t\t\t/* bitmask to use for each fp register */\n \n   gp_reg_size\t = 0;\n   fp_reg_size\t = 0;\n@@ -3826,7 +3892,7 @@ compute_frame_size (size)\n       if (MUST_SAVE_REGISTER (regno))\n \t{\n \t  gp_reg_size += UNITS_PER_WORD;\n-\t  mask |= 1 << (regno - GP_REG_FIRST);\n+\t  mask |= 1L << (regno - GP_REG_FIRST);\n \t}\n     }\n \n@@ -3900,156 +3966,213 @@ compute_frame_size (size)\n }\n \n \f\n-/* Save/restore registers printing out the instructions to a file.  */\n+/* Common code to emit the insns (or to write the instructions to a file)\n+   to save/restore registers.\n \n-void\n-save_restore (file, gp_op, gp_2word_op, fp_op)\n-     FILE *file;\t\t/* stream to write to */\n-     char *gp_op;\t\t/* operation to do on gp registers */\n-     char *gp_2word_op;\t\t/* 2 word op to do on gp registers */\n-     char *fp_op;\t\t/* operation to do on fp registers */\n+   Other parts of the code assume that MIPS_TEMP1_REGNUM (aka large_reg)\n+   is not modified within save_restore_insns.  */\n+\n+#define BITSET_P(value,bit) (((value) & (1L << (bit))) != 0)\n+\n+static void\n+save_restore_insns (store_p, large_reg, large_offset, file)\n+     int store_p;\t\t/* true if this is prologue */\n+     rtx large_reg;\t\t/* register holding large offset constant or NULL */\n+     long large_offset;\t\t/* large constant offset value */\n+     FILE *file;\t\t/* file to write instructions to instead of making RTL */\n {\n+  long mask\t\t= current_frame_info.mask;\n+  long fmask\t\t= current_frame_info.fmask;\n   int regno;\n-  unsigned long mask\t  = current_frame_info.mask;\n-  unsigned long fmask\t  = current_frame_info.fmask;\n-  unsigned long gp_offset;\n-  unsigned long fp_offset;\n-  unsigned long min_offset;\n-  char *base_reg;\n+  rtx base_reg_rtx;\n+  long base_offset;\n+  long gp_offset;\n+  long fp_offset;\n+  long end_offset;\n+\n+  if (frame_pointer_needed && !BITSET_P (mask, FRAME_POINTER_REGNUM - GP_REG_FIRST))\n+    abort ();\n \n   if (mask == 0 && fmask == 0)\n     return;\n \n-  base_reg   = reg_names[STACK_POINTER_REGNUM];\n-  gp_offset  = current_frame_info.gp_sp_offset;\n-  fp_offset  = current_frame_info.fp_sp_offset;\n-  min_offset = (gp_offset < fp_offset && mask != 0) ? gp_offset : fp_offset;\n-\n-  /* Deal with calling functions with a large structure.  */\n-  if (min_offset >= 32768)\n-    {\n-      char *temp = reg_names[MIPS_TEMP2_REGNUM];\n-      fprintf (file, \"\\tli\\t%s,%ld\\n\", temp, min_offset);\n-      fprintf (file, \"\\taddu\\t%s,%s,%s\\n\", temp, temp, base_reg);\n-      base_reg = temp;\n-      gp_offset = min_offset - gp_offset;\n-      fp_offset = min_offset - fp_offset;\n-    }\n-\n   /* Save registers starting from high to low.  The debuggers prefer\n      at least the return register be stored at func+4, and also it\n      allows us not to need a nop in the epilog if at least one\n      register is reloaded in addition to return address.  */\n \n-  if (mask || frame_pointer_needed)\n+  /* Save GP registers if needed.  */\n+  if (mask)\n     {\n-      for  (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n-\t{\n-\t  if ((mask & (1L << (regno - GP_REG_FIRST))) != 0\n-\t      || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed))\n-\t    {\n-\t      fprintf (file, \"\\t%s\\t%s,%d(%s)\\n\",\n-\t\t       gp_op, reg_names[regno],\n-\t\t       gp_offset, base_reg);\n+      /* Pick which pointer to use as a base register.  For small\n+\t frames, just use the stack pointer.  Otherwise, use a\n+\t temporary register.  Save 2 cycles if the save area is near\n+\t the end of a large frame, by reusing the constant created in\n+\t the prologue/epilogue to adjust the stack frame.  */\n \n-\t      gp_offset -= UNITS_PER_WORD;\n-\t    }\n+      gp_offset  = current_frame_info.gp_sp_offset;\n+      end_offset = gp_offset - (current_frame_info.gp_reg_size - UNITS_PER_WORD);\n+\n+      if (gp_offset < 0 || end_offset < 0)\n+\tfatal (\"gp_offset (%ld) or end_offset (%ld) is less than zero.\",\n+\t       gp_offset, end_offset);\n+\n+      else if (gp_offset < 32768)\n+\t{\n+\t  base_reg_rtx = stack_pointer_rtx;\n+\t  base_offset  = 0;\n \t}\n-    }\n \n-  if (fmask)\n-    {\n-      int fp_inc = (TARGET_FLOAT64) ? 1 : 2;\n+      else if (large_reg != (rtx)0\n+\t       && (((unsigned long)(large_offset - gp_offset))  < 32768)\n+\t       && (((unsigned long)(large_offset - end_offset)) < 32768))\n+\t{\n+\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_offset  = large_offset;\n+\t  if (file == (FILE *)0)\n+\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t  else\n+\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\",\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[REGNO (large_reg)],\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n \n-      for  (regno = FP_REG_LAST-1; regno >= FP_REG_FIRST; regno -= fp_inc)\n+      else\n \t{\n-\t  if ((fmask & (1L << (regno - FP_REG_FIRST))) != 0)\n+\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_offset  = gp_offset;\n+\t  if (file == (FILE *)0)\n \t    {\n-\t      fprintf (file, \"\\t%s\\t%s,%d(%s)\\n\",\n-\t\t       fp_op, reg_names[regno], fp_offset, base_reg);\n-\n-\t      fp_offset -= 2*UNITS_PER_WORD;\n+\t      emit_move_insn (base_reg_rtx, GEN_INT (gp_offset));\n+\t      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n \t    }\n+\t  else\n+\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\taddu\\t%s,%s,%s\\n\",\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     (long)base_offset,\n+\t\t     (long)base_offset,\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n \t}\n-    }\n-}\n-\n-\f\n-/* Common code to emit the insns to save/restore registers.  */\n-\n-static void\n-save_restore_insns (store_p)\n-     int store_p;\t\t/* true if this is prologue */\n-{\n-  int regno;\n-  rtx base_reg_rtx\t\t= stack_pointer_rtx;\n-  unsigned long mask\t\t= current_frame_info.mask;\n-  unsigned long fmask\t\t= current_frame_info.fmask;\n-  unsigned long gp_offset;\n-  unsigned long fp_offset;\n-  unsigned long min_offset;\n-\n-  if (mask == 0 && fmask == 0)\n-    return;\n-\n-  gp_offset  = current_frame_info.gp_sp_offset;\n-  fp_offset  = current_frame_info.fp_sp_offset;\n-  min_offset = (gp_offset < fp_offset && mask != 0) ? gp_offset : fp_offset;\n-\n-  /* Deal with calling functions with a large structure.  */\n-  if (min_offset >= 32768)\n-    {\n-      base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n-      emit_move_insn (base_reg_rtx, GEN_INT (min_offset));\n-      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n-      gp_offset = min_offset - gp_offset;\n-      fp_offset = min_offset - fp_offset;\n-    }\n \n-  /* Save registers starting from high to low.  The debuggers prefer\n-     at least the return register be stored at func+4, and also it\n-     allows us not to need a nop in the epilog if at least one\n-     register is reloaded in addition to return address.  */\n-\n-  if (mask || frame_pointer_needed)\n-    {\n       for  (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n \t{\n-\t  if ((mask & (1L << (regno - GP_REG_FIRST))) != 0\n-\t      || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t  if (BITSET_P (mask, regno - GP_REG_FIRST))\n \t    {\n-\t      rtx reg_rtx = gen_rtx (REG, Pmode, regno);\n-\t      rtx mem_rtx = gen_rtx (MEM, Pmode,\n-\t\t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t\t      GEN_INT (gp_offset)));\n+\t      if (file == (FILE *)0)\n+\t\t{\n+\t\t  rtx reg_rtx = gen_rtx (REG, Pmode, regno);\n+\t\t  rtx mem_rtx = gen_rtx (MEM, Pmode,\n+\t\t\t\t\t gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t\t\t  GEN_INT (gp_offset - base_offset)));\n \n-\t      if (store_p)\n-\t\temit_move_insn (mem_rtx, reg_rtx);\n+\t\t  if (store_p)\n+\t\t    emit_move_insn (mem_rtx, reg_rtx);\n+\t\t  else\n+\t\t    emit_move_insn (reg_rtx, mem_rtx);\n+\t\t}\n \t      else\n-\t\temit_move_insn (reg_rtx, mem_rtx);\n+\t\tfprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n+\t\t\t (store_p) ? \"sw\" : \"lw\",\n+\t\t\t reg_names[regno],\n+\t\t\t gp_offset - base_offset,\n+\t\t\t reg_names[REGNO(base_reg_rtx)]);\n \n \t      gp_offset -= UNITS_PER_WORD;\n \t    }\n \t}\n     }\n+  else\n+    {\n+      base_reg_rtx = (rtx)0;\t\t/* Make sure these are initialzed */\n+      base_offset  = 0;\n+    }\n \n+  /* Save floating point registers if needed.  */\n   if (fmask)\n     {\n       int fp_inc = (TARGET_FLOAT64) ? 1 : 2;\n \n+      /* Pick which pointer to use as a base register.  */\n+      fp_offset  = current_frame_info.fp_sp_offset;\n+      end_offset = fp_offset - (current_frame_info.fp_reg_size - UNITS_PER_WORD);\n+\n+      if (fp_offset < 0 || end_offset < 0)\n+\tfatal (\"fp_offset (%ld) or end_offset (%ld) is less than zero.\",\n+\t       fp_offset, end_offset);\n+\n+      else if (fp_offset < 32768)\n+\t{\n+\t  base_reg_rtx = stack_pointer_rtx;\n+\t  base_offset  = 0;\n+\t}\n+\n+      else if (base_reg_rtx != (rtx)0\n+\t       && (((unsigned long)(base_offset - fp_offset))  < 32768)\n+\t       && (((unsigned long)(base_offset - end_offset)) < 32768))\n+\t{\n+\t  ;\t\t\t/* already set up for gp registers above */\n+\t}\n+\n+      else if (large_reg != (rtx)0\n+\t       && (((unsigned long)(large_offset - fp_offset))  < 32768)\n+\t       && (((unsigned long)(large_offset - end_offset)) < 32768))\n+\t{\n+\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_offset  = large_offset;\n+\t  if (file == (FILE *)0)\n+\t    emit_insn (gen_addsi3 (base_reg_rtx, large_reg, stack_pointer_rtx));\n+\t  else\n+\t    fprintf (file, \"\\taddu\\t%s,%s,%s\\n\",\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[REGNO (large_reg)],\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+\n+      else\n+\t{\n+\t  base_reg_rtx = gen_rtx (REG, Pmode, MIPS_TEMP2_REGNUM);\n+\t  base_offset  = fp_offset;\n+\t  if (file == (FILE *)0)\n+\t    {\n+\t      emit_move_insn (base_reg_rtx, GEN_INT (fp_offset));\n+\t      emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx, stack_pointer_rtx));\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\\taddu\\t%s,%s,%s\\n\",\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     (long)base_offset,\n+\t\t     (long)base_offset,\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[MIPS_TEMP2_REGNUM],\n+\t\t     reg_names[STACK_POINTER_REGNUM]);\n+\t}\n+\n       for  (regno = FP_REG_LAST-1; regno >= FP_REG_FIRST; regno -= fp_inc)\n \t{\n-\t  if ((fmask & (1L << (regno - FP_REG_FIRST))) != 0)\n+\t  if (BITSET_P (fmask, regno - FP_REG_FIRST))\n \t    {\n-\t      rtx reg_rtx = gen_rtx (REG, DFmode, regno);\n-\t      rtx mem_rtx = gen_rtx (MEM, DFmode,\n-\t\t\t\t     gen_rtx (PLUS, Pmode, base_reg_rtx,\n-\t\t\t\t\t      GEN_INT (fp_offset)));\n+\t      if (file == (FILE *)0)\n+\t\t{\n+\t\t  rtx reg_rtx = gen_rtx (REG, DFmode, regno);\n+\t\t  rtx mem_rtx = gen_rtx (MEM, DFmode,\n+\t\t\t\t\t gen_rtx (PLUS, Pmode, base_reg_rtx,\n+\t\t\t\t\t\t  GEN_INT (fp_offset - base_offset)));\n \n-\t      if (store_p)\n-\t\temit_move_insn (mem_rtx, reg_rtx);\n+\t\t  if (store_p)\n+\t\t    emit_move_insn (mem_rtx, reg_rtx);\n+\t\t  else\n+\t\t    emit_move_insn (reg_rtx, mem_rtx);\n+\t\t}\n \t      else\n-\t\temit_move_insn (reg_rtx, mem_rtx);\n+\t\tfprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n+\t\t\t (store_p) ? \"s.d\" : \"l.d\",\n+\t\t\t reg_names[regno],\n+\t\t\t fp_offset - base_offset,\n+\t\t\t reg_names[REGNO(base_reg_rtx)]);\n+\n \n \t      fp_offset -= 2*UNITS_PER_WORD;\n \t    }\n@@ -4065,7 +4188,7 @@ function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  int tsize = current_frame_info.total_size;\n+  long tsize = current_frame_info.total_size;\n \n   ASM_OUTPUT_SOURCE_FILENAME (file, DECL_SOURCE_FILE (current_function_decl));\n \n@@ -4076,6 +4199,7 @@ function_prologue (file, size)\n   fputs (\"\\t.ent\\t\", file);\n   assemble_name (file, current_function_name);\n   fputs (\"\\n\", file);\n+\n   assemble_name (file, current_function_name);\n   fputs (\":\\n\", file);\n \n@@ -4112,14 +4236,15 @@ void\n mips_expand_prologue ()\n {\n   int regno;\n-  int tsize;\n+  long tsize;\n   tree fndecl = current_function_decl; /* current... is tooo long */\n   tree fntype = TREE_TYPE (fndecl);\n   tree fnargs = (TREE_CODE (fntype) != METHOD_TYPE)\n \t\t\t? DECL_ARGUMENTS (fndecl)\n \t\t\t: 0;\n   tree next_arg;\n   tree cur_arg;\n+  rtx tmp_rtx\t = (rtx)0;\n   char *arg_name = (char *)0;\n   CUMULATIVE_ARGS args_so_far;\n \n@@ -4200,14 +4325,14 @@ mips_expand_prologue ()\n \n       if (tsize > 32767)\n \t{\n-\t  rtx tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+\t  tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n \t  emit_move_insn (tmp_rtx, tsize_rtx);\n \t  tsize_rtx = tmp_rtx;\n \t}\n \n       emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n \n-      save_restore_insns (TRUE);\n+      save_restore_insns (TRUE, tmp_rtx, tsize, (FILE *)0);\n \n       if (frame_pointer_needed)\n \temit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n@@ -4228,14 +4353,17 @@ function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  int tsize;\n+  long tsize;\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   char *t1_str = reg_names[MIPS_TEMP1_REGNUM];\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noreorder = !TARGET_MIPS_AS || (epilogue_delay != 0);\n   int noepilogue = FALSE;\n   int load_nop = FALSE;\n   int load_only_r31;\n+  rtx tmp_rtx = (rtx)0;\n+  rtx restore_rtx;\n+  int i;\n \n   /* The epilogue does not depend on any registers, but the stack\n      registers, so we assume that if we have 1 pending nop, it can be\n@@ -4316,13 +4444,16 @@ function_epilogue (file, size)\n \tfprintf (file, \"\\t.set\\tnoreorder\\n\");\n \n       if (tsize > 32767)\n-\tfprintf (file, \"\\tli\\t%s,%d\\n\", t1_str, tsize);\n+\t{\n+\t  fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# %ld\\n\", t1_str, (long)tsize, (long)tsize);\n+\t  tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n+\t}\n \n       if (frame_pointer_needed)\n \tfprintf (file, \"\\tmove\\t%s,%s\\t\\t\\t# sp not trusted here\\n\",\n \t\t sp_str, reg_names[FRAME_POINTER_REGNUM]);\n \n-      save_restore (file, \"lw\", \"ld\", \"l.d\");\n+      save_restore_insns (FALSE, tmp_rtx, tsize, file);\n \n       load_only_r31 = (current_frame_info.mask == (1 << 31)\n \t\t       && current_frame_info.fmask == 0);\n@@ -4469,12 +4600,13 @@ function_epilogue (file, size)\n void\n mips_expand_epilogue ()\n {\n-  int tsize = current_frame_info.total_size;\n+  long tsize = current_frame_info.total_size;\n   rtx tsize_rtx = GEN_INT (tsize);\n+  rtx tmp_rtx = (rtx)0;\n \n   if (tsize > 32767)\n     {\n-      rtx tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+      tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n       emit_move_insn (tmp_rtx, tsize_rtx);\n       tsize_rtx = tmp_rtx;\n     }\n@@ -4484,7 +4616,7 @@ mips_expand_epilogue ()\n       if (frame_pointer_needed)\n \temit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n \n-      save_restore_insns (FALSE);\n+      save_restore_insns (FALSE, tmp_rtx, tsize, (FILE *)0);\n \n       emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n     }"}, {"sha": "6ca50ea799c2a10cccc789453f5d8167300308db", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bea35e74679d46e30981d2fce2763517501d3fe/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bea35e74679d46e30981d2fce2763517501d3fe/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=7bea35e74679d46e30981d2fce2763517501d3fe", "patch": "@@ -126,7 +126,8 @@ extern int\t\tarith32_operand ();\n extern int\t\tarith_operand ();\n extern int\t\tcmp_op ();\n extern int\t\tcmp2_op ();\n-extern unsigned long\tcompute_frame_size ();\n+extern long\t\tcompute_frame_size ();\n+extern int\t\tepilogue_reg_mentioned_p ();\n extern void\t\texpand_block_move ();\n extern int\t\tequality_op ();\n extern int\t\tfcmp_op ();\n@@ -482,7 +483,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 31]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 32]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -1229,6 +1230,7 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    scratch register set, and not used for passing and returning\n    arguments and any other information used in the calling sequence\n    (such as pic).  */\n+\n #define MIPS_TEMP1_REGNUM (GP_REG_FIRST + 8)\n #define MIPS_TEMP2_REGNUM (GP_REG_FIRST + 9)\n \n@@ -1540,21 +1542,21 @@ extern enum reg_class mips_char_to_class[];\n \n struct mips_frame_info\n {\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up */\n-  unsigned long var_size;\t/* # bytes that variables take up */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up */\n-  unsigned long extra_size;\t/* # bytes of extra gunk */\n-  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs */\n-  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs */\n-  unsigned long mask;\t\t/* mask of saved gp registers */\n-  unsigned long fmask;\t\t/* mask of saved fp registers */\n-  long\t\tgp_save_offset;\t/* offset from vfp to store gp registers */\n-  long\t\tfp_save_offset;\t/* offset from vfp to store fp registers */\n-  unsigned long gp_sp_offset;\t/* offset from new sp to store gp registers */\n-  unsigned long fp_sp_offset;\t/* offset from new sp to store fp registers */\n-  int\t\tinitialized;\t/* != 0 if frame size already calculated */\n-  int\t\tnum_gp;\t\t/* number of gp registers saved */\n-  int\t\tnum_fp;\t\t/* number of fp registers saved */\n+  long total_size;\t\t/* # bytes that the entire frame takes up */\n+  long var_size;\t\t/* # bytes that variables take up */\n+  long args_size;\t\t/* # bytes that outgoing arguments take up */\n+  long extra_size;\t\t/* # bytes of extra gunk */\n+  int  gp_reg_size;\t\t/* # bytes needed to store gp regs */\n+  int  fp_reg_size;\t\t/* # bytes needed to store fp regs */\n+  long mask;\t\t\t/* mask of saved gp registers */\n+  long fmask;\t\t\t/* mask of saved fp registers */\n+  long gp_save_offset;\t\t/* offset from vfp to store gp registers */\n+  long fp_save_offset;\t\t/* offset from vfp to store fp registers */\n+  long gp_sp_offset;\t\t/* offset from new sp to store gp registers */\n+  long fp_sp_offset;\t\t/* offset from new sp to store fp registers */\n+  int  initialized;\t\t/* != 0 if frame size already calculated */\n+  int  num_gp;\t\t\t/* number of gp registers saved */\n+  int  num_fp;\t\t\t/* number of fp registers saved */\n };\n \n extern struct mips_frame_info current_frame_info;\n@@ -1896,9 +1898,7 @@ typedef struct mips_args {\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN,N)\t\t\t\t\\\n   (get_attr_dslot (INSN) == DSLOT_NO\t\t\t\t\t\\\n    && get_attr_length (INSN) == 1\t\t\t\t\t\\\n-   && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (INSN))\t\t\\\n-   && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (INSN))\t\t\\\n-   && ! reg_mentioned_p (arg_pointer_rtx, PATTERN (INSN)))\n+   && ! epilogue_reg_mentioned_p (PATTERN (INSN)))\n \n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n "}]}