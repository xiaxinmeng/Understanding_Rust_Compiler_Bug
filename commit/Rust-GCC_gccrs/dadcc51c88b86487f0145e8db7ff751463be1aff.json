{"sha": "dadcc51c88b86487f0145e8db7ff751463be1aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFkY2M1MWM4OGI4NjQ4N2YwMTQ1ZThkYjdmZjc1MTQ2M2JlMWFmZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-08T16:40:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-08T16:40:21Z"}, "message": "compiler: fix undefined symbol error with unexported method\n    \n    When an interface I1 in an imported package has an unexported method,\n    and is then embedded into another interface I2, in a different\n    package, that has other methods, and a type T2 is converted to I2, we\n    failed to ever define the required interface method table.  Naturally\n    T2 must implement the unexported method, and must therefore either be\n    defined in the same package as I1, or embed a type from that package.\n    In this case the compiler was assuming that that package would define\n    the interface method table, but of course, since I2 was not defined in\n    that package, that did not happen.\n    \n    The fix is to only assume that the interface method table will be\n    defined elsewhere in the case where T2 and I2 are defined in the same\n    package.  The compiler ensures that all such interface method tables\n    are created, in Gogo::build_interface_method_tables.  This requires\n    knowing the package in which an interface type is defined, a simple\n    tweak to the importer.\n    \n    Testing this revealed that the special case for stub methods created\n    for the embedded unexported methods of T2 needs to be done for\n    function declarations as it currently is for function definitions, so\n    that the newly created interface method tables use the correct name.\n    \n    Testing that revealed that the code to determine the pkgpath symbol\n    for such stub methods was wrong.  It assumed that one could call\n    pkgpath_for_symbol on the pkgpath to get the pkgpath symbol.  Would\n    that it twere so simple.  Instead, add a function to look up the\n    package, which must be known, and fetch the pkgpath symbol.\n    \n    The test for this is https://golang.org/cl/45085.\n    \n    Reviewed-on: https://go-review.googlesource.com/45086\n\nFrom-SVN: r249024", "tree": {"sha": "e826bea61ab1506b51f9cb5c4f9f593b7e98e3eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e826bea61ab1506b51f9cb5c4f9f593b7e98e3eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dadcc51c88b86487f0145e8db7ff751463be1aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dadcc51c88b86487f0145e8db7ff751463be1aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dadcc51c88b86487f0145e8db7ff751463be1aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dadcc51c88b86487f0145e8db7ff751463be1aff/comments", "author": null, "committer": null, "parents": [{"sha": "77db6c1549c8e8d831a5fa0a246415e7572678e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77db6c1549c8e8d831a5fa0a246415e7572678e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77db6c1549c8e8d831a5fa0a246415e7572678e2"}], "stats": {"total": 90, "additions": 65, "deletions": 25}, "files": [{"sha": "7142db00865fe508b967eecce7827af250bb0f81", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -1,4 +1,4 @@\n-eaf4afbabcd91df55d31955500b6db55b07f6de5\n+4b857cde45939f0e9f3cf89b9e347b6f6ebe0f8f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "eaf492f3501eda0c8b5924a4cff9972535be901c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -15430,27 +15430,32 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n \t\t\t      + \"__\"\n \t\t\t      + this->type_->mangled_name(gogo));\n \n-  // See whether this interface has any hidden methods.\n-  bool has_hidden_methods = false;\n-  for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n-       p != interface_methods->end();\n-       ++p)\n-    {\n-      if (Gogo::is_hidden_name(p->name()))\n+  // Set is_public if we are converting a named type to an interface\n+  // type that is defined in the same package as the named type, and\n+  // the interface has hidden methods.  In that case the interface\n+  // method table will be defined by the package that defines the\n+  // types.\n+  bool is_public = false;\n+  if (this->type_->named_type() != NULL\n+      && (this->type_->named_type()->named_object()->package()\n+\t  == this->itype_->package()))\n+    {\n+      for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n+\t   p != interface_methods->end();\n+\t   ++p)\n \t{\n-\t  has_hidden_methods = true;\n-\t  break;\n+\t  if (Gogo::is_hidden_name(p->name()))\n+\t    {\n+\t      is_public = true;\n+\t      break;\n+\t    }\n \t}\n     }\n \n-  // We already know that the named type is convertible to the\n-  // interface.  If the interface has hidden methods, and the named\n-  // type is defined in a different package, then the interface\n-  // conversion table will be defined by that other package.\n-  if (has_hidden_methods\n-      && this->type_->named_type() != NULL\n+  if (is_public\n       && this->type_->named_type()->named_object()->package() != NULL)\n     {\n+      // The interface conversion table is defined elsewhere.\n       Btype* btype = this->type()->get_backend(gogo);\n       std::string asm_name(go_selectively_encode_id(mangled_name));\n       this->bvar_ =\n@@ -15517,7 +15522,6 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Bexpression* ctor =\n       gogo->backend()->constructor_expression(btype, ctor_bexprs, loc);\n \n-  bool is_public = has_hidden_methods && this->type_->named_type() != NULL;\n   std::string asm_name(go_selectively_encode_id(mangled_name));\n   this->bvar_ = gogo->backend()->immutable_struct(mangled_name, asm_name, false,\n \t\t\t\t\t\t  !is_public, btype, loc);"}, {"sha": "9071bc8f62df1bbfbdc510b87cefb3f25b558195", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -1688,6 +1688,16 @@ Gogo::register_package(const std::string& pkgpath,\n   return package;\n }\n \n+// Return the pkgpath symbol for a package, given the pkgpath.\n+\n+std::string\n+Gogo::pkgpath_symbol_for_package(const std::string& pkgpath)\n+{\n+  Packages::iterator p = this->packages_.find(pkgpath);\n+  go_assert(p != this->packages_.end());\n+  return p->second->pkgpath_symbol();\n+}\n+\n // Start compiling a function.\n \n Named_object*\n@@ -5418,8 +5428,8 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n               // use the pkgpath of the imported package to avoid\n               // a possible name collision.  See bug478 for a test\n               // case.\n-              pkgpath = Gogo::hidden_name_pkgpath(no->name());\n-              pkgpath = Gogo::pkgpath_for_symbol(pkgpath);\n+\t      std::string p = Gogo::hidden_name_pkgpath(no->name());\n+\t      pkgpath = gogo->pkgpath_symbol_for_package(p);\n             }\n \n           asm_name = pkgpath;\n@@ -5514,8 +5524,19 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n       if (this->asm_name_.empty())\n         {\n           asm_name = (no->package() == NULL\n-                                  ? gogo->pkgpath_symbol()\n-                                  : no->package()->pkgpath_symbol());\n+\t\t      ? gogo->pkgpath_symbol()\n+\t\t      : no->package()->pkgpath_symbol());\n+\t  if (this->fntype_->is_method()\n+\t      && Gogo::is_hidden_name(no->name())\n+\t      && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n+\t    {\n+\t      // This is a method created for an unexported method of\n+\t      // an imported embedded type.  Use the pkgpath of the\n+\t      // imported package.  This matches code in\n+\t      // Function::get_or_make_decl, above.\n+\t      std::string p = Gogo::hidden_name_pkgpath(no->name());\n+\t      asm_name = gogo->pkgpath_symbol_for_package(p);\n+\t    }\n           asm_name.append(1, '.');\n           asm_name.append(Gogo::unpack_hidden_name(no->name()));\n           if (this->fntype_->is_method())"}, {"sha": "c3e3f30131de73b8c8ad22488aedfb783147cbd9", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -362,6 +362,10 @@ class Gogo\n   register_package(const std::string& pkgpath,\n \t\t   const std::string& pkgpath_symbol, Location);\n \n+  // Look up a package by pkgpath, and return its pkgpath_symbol.\n+  std::string\n+  pkgpath_symbol_for_package(const std::string&);\n+\n   // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n   // method function should be added to the type of its receiver.\n   Named_object*"}, {"sha": "61a33635c1284a6c9874b51040d4591fa5c0560b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -9816,7 +9816,9 @@ Interface_type::do_import(Import* imp)\n       methods = NULL;\n     }\n \n-  return Type::make_interface_type(methods, imp->location());\n+  Interface_type* ret = Type::make_interface_type(methods, imp->location());\n+  ret->package_ = imp->package();\n+  return ret;\n }\n \n // Make an interface type."}, {"sha": "3f6240b9fd25b9e9bf615b6ea761f7e8f53f6045", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dadcc51c88b86487f0145e8db7ff751463be1aff/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=dadcc51c88b86487f0145e8db7ff751463be1aff", "patch": "@@ -2854,16 +2854,22 @@ class Interface_type : public Type\n   Interface_type(Typed_identifier_list* methods, Location location)\n     : Type(TYPE_INTERFACE),\n       parse_methods_(methods), all_methods_(NULL), location_(location),\n-      interface_btype_(NULL), bmethods_(NULL), assume_identical_(NULL),\n-      methods_are_finalized_(false), bmethods_is_placeholder_(false),\n-      seen_(false)\n+      package_(NULL), interface_btype_(NULL), bmethods_(NULL),\n+      assume_identical_(NULL), methods_are_finalized_(false),\n+      bmethods_is_placeholder_(false), seen_(false)\n   { go_assert(methods == NULL || !methods->empty()); }\n \n   // The location where the interface type was defined.\n   Location\n   location() const\n   { return this->location_; }\n \n+  // The package where the interface type was defined.  Returns NULL\n+  // for the package currently being compiled.\n+  Package*\n+  package() const\n+  { return this->package_; }\n+\n   // Return whether this is an empty interface.\n   bool\n   is_empty() const\n@@ -3008,6 +3014,9 @@ class Interface_type : public Type\n   Typed_identifier_list* all_methods_;\n   // The location where the interface was defined.\n   Location location_;\n+  // The package where the interface was defined.  This is NULL for\n+  // the package being compiled.\n+  Package* package_;\n   // The backend representation of this type during backend conversion.\n   Btype* interface_btype_;\n   // The backend representation of the pointer to the method table."}]}