{"sha": "8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNjNjMwN2M4ODg5YjkyYzk4ZDRiOTA1YmYyZmRkOGZiMjg1YTU3Nw==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2018-08-08T11:25:31Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-08-08T11:25:31Z"}, "message": "S/390: Remove TARGET_CPU_ZARCH\n\nTARGET_CPU_ZARCH allowed to distinguish between g5/g6 and newer\nmachines.  Since the former are now gone, we can assume that\nTARGET_CPU_ZARCH is always true.  As a side-effect, branch splitting\nis now completely gone.  Some parts of literal pool splitting are also\ngone, but it's still there: we need to support it because floating\npoint and vector instructions still cannot use relative addressing.\n\ngcc/ChangeLog:\n\n2018-08-08  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* config/s390/s390.c (s390_loadrelative_operand_p):\n        Remove TARGET_CPU_ZARCH usages.\n\t(s390_rtx_costs): Likewise.\n\t(s390_legitimate_constant_p): Likewise.\n\t(s390_cannot_force_const_mem): Likewise.\n\t(legitimate_reload_constant_p): Likewise.\n\t(s390_preferred_reload_class): Likewise.\n\t(legitimize_pic_address): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t(s390_split_branches): Removed.\n\t(s390_add_execute): Removed.\n\t(s390_dump_pool): Remove TARGET_CPU_ZARCH usages.\n\t(s390_mainpool_start): Likewise.\n\t(s390_mainpool_finish): Likewise.\n\t(s390_mainpool_cancel): Removed.\n\t(s390_chunkify_start): Remove TARGET_CPU_ZARCH usages.\n\t(s390_chunkify_cancel): Likewise.\n\t(s390_return_addr_rtx): Likewise.\n\t(s390_register_info): Remove split_branches_pending_p uages.\n\t(s390_optimize_register_info): Likewise.\n\t(s390_init_frame_layout): Remove TARGET_CPU_ZARCH and\n        split_branches_pending_p usages.\n\t(s390_can_eliminate): Remove TARGET_CPU_ZARCH usages.\n\t(s390_load_got): Likewise.\n\t(s390_expand_split_stack_prologue): Likewise.\n\t(output_asm_nops): Likewise.\n\t(s390_function_profiler): Likewise.\n\t(s390_emit_call): Likewise.\n\t(s390_conditional_register_usage): Likewise.\n\t(s390_optimize_prologue): Likewise.\n\t(s390_reorg): Remove TARGET_CPU_ZARCH and\n        split_branches_pending_p usages.\n\t(s390_option_override_internal): Remove TARGET_CPU_ZARCH\n        usages.\n\t(s390_output_indirect_thunk_function): Likewise.\n\t* config/s390/s390.h (TARGET_CPU_ZARCH): Removed.\n\t(TARGET_CPU_ZARCH_P): Removed.\n\t(struct machine_function): Remove split_branches_pending_p.\n\t* config/s390/s390.md: Remove TARGET_CPU_ZARCH usages.\n\nFrom-SVN: r263394", "tree": {"sha": "77802148c829a7e71284e6ed046b8d836382701a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77802148c829a7e71284e6ed046b8d836382701a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52d4aa4fcfe6c90d45fd37c39c5b2a36650760bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52d4aa4fcfe6c90d45fd37c39c5b2a36650760bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52d4aa4fcfe6c90d45fd37c39c5b2a36650760bd"}], "stats": {"total": 1340, "additions": 181, "deletions": 1159}, "files": [{"sha": "b80246bf182346f90a21391ba7d36374302af058", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "patch": "@@ -1,3 +1,45 @@\n+2018-08-08  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\t* config/s390/s390.c (s390_loadrelative_operand_p):\n+        Remove TARGET_CPU_ZARCH usages.\n+\t(s390_rtx_costs): Likewise.\n+\t(s390_legitimate_constant_p): Likewise.\n+\t(s390_cannot_force_const_mem): Likewise.\n+\t(legitimate_reload_constant_p): Likewise.\n+\t(s390_preferred_reload_class): Likewise.\n+\t(legitimize_pic_address): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t(s390_split_branches): Removed.\n+\t(s390_add_execute): Removed.\n+\t(s390_dump_pool): Remove TARGET_CPU_ZARCH usages.\n+\t(s390_mainpool_start): Likewise.\n+\t(s390_mainpool_finish): Likewise.\n+\t(s390_mainpool_cancel): Removed.\n+\t(s390_chunkify_start): Remove TARGET_CPU_ZARCH usages.\n+\t(s390_chunkify_cancel): Likewise.\n+\t(s390_return_addr_rtx): Likewise.\n+\t(s390_register_info): Remove split_branches_pending_p uages.\n+\t(s390_optimize_register_info): Likewise.\n+\t(s390_init_frame_layout): Remove TARGET_CPU_ZARCH and\n+        split_branches_pending_p usages.\n+\t(s390_can_eliminate): Remove TARGET_CPU_ZARCH usages.\n+\t(s390_load_got): Likewise.\n+\t(s390_expand_split_stack_prologue): Likewise.\n+\t(output_asm_nops): Likewise.\n+\t(s390_function_profiler): Likewise.\n+\t(s390_emit_call): Likewise.\n+\t(s390_conditional_register_usage): Likewise.\n+\t(s390_optimize_prologue): Likewise.\n+\t(s390_reorg): Remove TARGET_CPU_ZARCH and\n+        split_branches_pending_p usages.\n+\t(s390_option_override_internal): Remove TARGET_CPU_ZARCH\n+        usages.\n+\t(s390_output_indirect_thunk_function): Likewise.\n+\t* config/s390/s390.h (TARGET_CPU_ZARCH): Removed.\n+\t(TARGET_CPU_ZARCH_P): Removed.\n+\t(struct machine_function): Remove split_branches_pending_p.\n+\t* config/s390/s390.md: Remove TARGET_CPU_ZARCH usages.\n+\n 2018-08-08  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \t* common/config/s390/s390-common.c (processor_flags_table):"}, {"sha": "9121d83d682b11a5733cde1607298c7299a93645", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 90, "deletions": 706, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "patch": "@@ -3147,7 +3147,7 @@ s390_loadrelative_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n   if ((GET_CODE (addr) == SYMBOL_REF && !CONSTANT_POOL_ADDRESS_P (addr))\n       || (GET_CODE (addr) == UNSPEC\n \t  && (XINT (addr, 1) == UNSPEC_GOTENT\n-\t      || (TARGET_CPU_ZARCH && XINT (addr, 1) == UNSPEC_PLT))))\n+\t      || XINT (addr, 1) == UNSPEC_PLT)))\n     {\n       if (symref)\n \t*symref = addr;\n@@ -3591,8 +3591,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t\t  /* mulsidi case: mr, m */\n \t\t  *total = s390_cost->m;\n \t\telse if (GET_CODE (left) == ZERO_EXTEND\n-\t\t\t && GET_CODE (right) == ZERO_EXTEND\n-\t\t\t && TARGET_CPU_ZARCH)\n+\t\t\t && GET_CODE (right) == ZERO_EXTEND)\n \t\t  /* umulsidi case: ml, mlr */\n \t\t  *total = s390_cost->ml;\n \t\telse\n@@ -3900,7 +3899,7 @@ s390_legitimate_constant_p (machine_mode mode, rtx op)\n     return 1;\n \n   /* Accept immediate LARL operands.  */\n-  if (TARGET_CPU_ZARCH && larl_operand (op, mode))\n+  if (larl_operand (op, mode))\n     return 1;\n \n   /* Thread-local symbols are never legal constants.  This is\n@@ -3974,8 +3973,6 @@ s390_cannot_force_const_mem (machine_mode mode, rtx x)\n \t/* If the literal pool shares the code section, be put\n \t   execute template placeholders into the pool as well.  */\n \tcase UNSPEC_INSN:\n-\t  return TARGET_CPU_ZARCH;\n-\n \tdefault:\n \t  return true;\n \t}\n@@ -4021,8 +4018,7 @@ legitimate_reload_constant_p (rtx op)\n     return true;\n \n   /* Accept larl operands.  */\n-  if (TARGET_CPU_ZARCH\n-      && larl_operand (op, VOIDmode))\n+  if (larl_operand (op, VOIDmode))\n     return true;\n \n   /* Accept floating-point zero operands that fit into a single GPR.  */\n@@ -4129,8 +4125,7 @@ s390_preferred_reload_class (rtx op, reg_class_t rclass)\n \t   handled via secondary reload but this does not happen if\n \t   they are used as literal pool slot replacement in reload\n \t   inheritance (see emit_input_reload_insns).  */\n-\tif (TARGET_CPU_ZARCH\n-\t    && GET_CODE (XEXP (op, 0)) == PLUS\n+\tif (GET_CODE (XEXP (op, 0)) == PLUS\n \t    && GET_CODE (XEXP (XEXP(op, 0), 0)) == SYMBOL_REF\n \t    && GET_CODE (XEXP (XEXP(op, 0), 1)) == CONST_INT)\n \t  {\n@@ -4710,7 +4705,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n        || (SYMBOL_REF_P (addr) && s390_rel_address_ok_p (addr))\n        || (GET_CODE (addr) == UNSPEC &&\n \t   (XINT (addr, 1) == UNSPEC_GOTENT\n-\t    || (TARGET_CPU_ZARCH && XINT (addr, 1) == UNSPEC_PLT))))\n+\t    || XINT (addr, 1) == UNSPEC_PLT)))\n       && GET_CODE (addend) == CONST_INT)\n     {\n       /* This can be locally addressed.  */\n@@ -4719,8 +4714,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n       rtx const_addr = (GET_CODE (addr) == UNSPEC ?\n \t\t\tgen_rtx_CONST (Pmode, addr) : addr);\n \n-      if (TARGET_CPU_ZARCH\n-\t  && larl_operand (const_addr, VOIDmode)\n+      if (larl_operand (const_addr, VOIDmode)\n \t  && INTVAL (addend) < HOST_WIDE_INT_1 << 31\n \t  && INTVAL (addend) >= -(HOST_WIDE_INT_1 << 31))\n \t{\n@@ -4819,13 +4813,13 @@ legitimize_pic_address (rtx orig, rtx reg)\n           new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n           new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new_rtx);\n           new_rtx = gen_const_mem (Pmode, new_rtx);\n-          emit_move_insn (reg, new_rtx);\n-          new_rtx = reg;\n-        }\n-      else if (TARGET_CPU_ZARCH)\n-        {\n-          /* If the GOT offset might be >= 4k, we determine the position\n-             of the GOT entry via a PC-relative LARL (@GOTENT).\n+\t  emit_move_insn (reg, new_rtx);\n+\t  new_rtx = reg;\n+\t}\n+      else\n+\t{\n+\t  /* If the GOT offset might be >= 4k, we determine the position\n+\t     of the GOT entry via a PC-relative LARL (@GOTENT).\n \t     larl temp, sym@GOTENT\n              lg   <target>, 0(temp) */\n \n@@ -4837,39 +4831,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n           new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n           new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \t  emit_move_insn (temp, new_rtx);\n-\n \t  new_rtx = gen_const_mem (Pmode, temp);\n-          emit_move_insn (reg, new_rtx);\n-\n-          new_rtx = reg;\n-        }\n-      else\n-        {\n-          /* If the GOT offset might be >= 4k, we have to load it\n-             from the literal pool (@GOT).\n-\n-\t     lg temp, lit-litbase(r13)\n-             lg <target>, 0(temp)\n-\t     lit:  .long sym@GOT  */\n-\n-          rtx temp = reg ? reg : gen_reg_rtx (Pmode);\n-\n-\t  gcc_assert (REGNO (temp) >= FIRST_PSEUDO_REGISTER\n-\t\t      || REGNO_REG_CLASS (REGNO (temp)) == ADDR_REGS);\n-\n-\t  if (reload_in_progress || reload_completed)\n-\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n-          addr = gen_rtx_CONST (Pmode, addr);\n-          addr = force_const_mem (Pmode, addr);\n-          emit_move_insn (temp, addr);\n+\t  emit_move_insn (reg, new_rtx);\n \n-          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-          new_rtx = gen_const_mem (Pmode, new_rtx);\n-          emit_move_insn (reg, new_rtx);\n-          new_rtx = reg;\n-        }\n+\t  new_rtx = reg;\n+\t}\n     }\n   else if (GET_CODE (addr) == UNSPEC && GET_CODE (addend) == CONST_INT)\n     {\n@@ -4898,36 +4864,10 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  gcc_unreachable ();\n \t  break;\n \n-\t  /* @PLT is OK as is on 64-bit, must be converted to\n-\t     GOT-relative @PLTOFF on 31-bit.  */\n+\t  /* For @PLT larl is used.  This is handled like local\n+\t     symbol refs.  */\n \tcase UNSPEC_PLT:\n-\t  if (!TARGET_CPU_ZARCH)\n-\t    {\n-\t      rtx temp = reg? reg : gen_reg_rtx (Pmode);\n-\n-\t      if (reload_in_progress || reload_completed)\n-\t\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-\t      addr = XVECEXP (addr, 0, 0);\n-\t      addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n-\t\t\t\t     UNSPEC_PLTOFF);\n-\t      if (addend != const0_rtx)\n-\t\taddr = gen_rtx_PLUS (Pmode, addr, addend);\n-\t      addr = gen_rtx_CONST (Pmode, addr);\n-\t      addr = force_const_mem (Pmode, addr);\n-\t      emit_move_insn (temp, addr);\n-\n-\t      new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-\t      if (reg != 0)\n-\t\t{\n-\t\t  s390_load_address (reg, new_rtx);\n-\t\t  new_rtx = reg;\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* On 64 bit larl can be used.  This case is handled like\n-\t       local symbol refs.  */\n-\t    gcc_unreachable ();\n+\t  gcc_unreachable ();\n \t  break;\n \n \t  /* Everything else cannot happen.  */\n@@ -5084,7 +5024,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    temp = gen_reg_rtx (Pmode);\n \t    emit_move_insn (temp, new_rtx);\n \t  }\n-\telse if (TARGET_CPU_ZARCH)\n+\telse\n \t  {\n \t    /* If the GOT offset might be >= 4k, we determine the position\n \t       of the GOT entry via a PC-relative LARL.  */\n@@ -5098,44 +5038,6 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    temp = gen_reg_rtx (Pmode);\n \t    emit_move_insn (temp, new_rtx);\n \t  }\n-\telse if (flag_pic)\n-\t  {\n-\t    /* If the GOT offset might be >= 4k, we have to load it\n-\t       from the literal pool.  */\n-\n-\t    if (reload_in_progress || reload_completed)\n-\t      df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTNTPOFF);\n-\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n-\t    new_rtx = force_const_mem (Pmode, new_rtx);\n-\t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new_rtx);\n-\n-            new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-\t    new_rtx = gen_const_mem (Pmode, new_rtx);\n-\n-\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new_rtx, addr), UNSPEC_TLS_LOAD);\n-\t    temp = gen_reg_rtx (Pmode);\n-\t    emit_insn (gen_rtx_SET (temp, new_rtx));\n-\t  }\n-\telse\n-\t  {\n-\t    /* In position-dependent code, load the absolute address of\n-\t       the GOT entry from the literal pool.  */\n-\n-\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_INDNTPOFF);\n-\t    new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n-\t    new_rtx = force_const_mem (Pmode, new_rtx);\n-\t    temp = gen_reg_rtx (Pmode);\n-\t    emit_move_insn (temp, new_rtx);\n-\n-\t    new_rtx = temp;\n-\t    new_rtx = gen_const_mem (Pmode, new_rtx);\n-\t    new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, new_rtx, addr), UNSPEC_TLS_LOAD);\n-\t    temp = gen_reg_rtx (Pmode);\n-\t    emit_insn (gen_rtx_SET (temp, new_rtx));\n-\t  }\n \n \tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n \tif (reg != 0)\n@@ -5169,7 +5071,6 @@ legitimize_tls_address (rtx addr, rtx reg)\n       switch (XINT (XEXP (addr, 0), 1))\n \t{\n \tcase UNSPEC_INDNTPOFF:\n-\t  gcc_assert (TARGET_CPU_ZARCH);\n \t  new_rtx = addr;\n \t  break;\n \n@@ -8301,95 +8202,6 @@ annotate_constant_pool_refs (rtx *x)\n     }\n }\n \n-/* Split all branches that exceed the maximum distance.\n-   Returns true if this created a new literal pool entry.  */\n-\n-static int\n-s390_split_branches (void)\n-{\n-  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  int new_literal = 0, ret;\n-  rtx_insn *insn;\n-  rtx pat, target;\n-  rtx *label;\n-\n-  /* We need correct insn addresses.  */\n-\n-  shorten_branches (get_insns ());\n-\n-  /* Find all branches that exceed 64KB, and split them.  */\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (! JUMP_P (insn) || tablejump_p (insn, NULL, NULL))\n-\tcontinue;\n-\n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) == PARALLEL)\n-\tpat = XVECEXP (pat, 0, 0);\n-      if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)\n-\tcontinue;\n-\n-      if (GET_CODE (SET_SRC (pat)) == LABEL_REF)\n-\t{\n-\t  label = &SET_SRC (pat);\n-\t}\n-      else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n-\t{\n-\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF)\n-\t    label = &XEXP (SET_SRC (pat), 1);\n-          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF)\n-            label = &XEXP (SET_SRC (pat), 2);\n-\t  else\n-\t    continue;\n-        }\n-      else\n-\tcontinue;\n-\n-      if (get_attr_length (insn) <= 4)\n-\tcontinue;\n-\n-      /* We are going to use the return register as scratch register,\n-\t make sure it will be saved/restored by the prologue/epilogue.  */\n-      cfun_frame_layout.save_return_addr_p = 1;\n-\n-      if (!flag_pic)\n-\t{\n-\t  new_literal = 1;\n-\t  rtx mem = force_const_mem (Pmode, *label);\n-\t  rtx_insn *set_insn = emit_insn_before (gen_rtx_SET (temp_reg, mem),\n-\t\t\t\t\t\t insn);\n-\t  INSN_ADDRESSES_NEW (set_insn, -1);\n-\t  annotate_constant_pool_refs (&PATTERN (set_insn));\n-\n-\t  target = temp_reg;\n-\t}\n-      else\n-\t{\n-\t  new_literal = 1;\n-\t  target = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, *label),\n-\t\t\t\t   UNSPEC_LTREL_OFFSET);\n-\t  target = gen_rtx_CONST (Pmode, target);\n-\t  target = force_const_mem (Pmode, target);\n-\t  rtx_insn *set_insn = emit_insn_before (gen_rtx_SET (temp_reg, target),\n-\t\t\t\t\t\t insn);\n-\t  INSN_ADDRESSES_NEW (set_insn, -1);\n-\t  annotate_constant_pool_refs (&PATTERN (set_insn));\n-\n-          target = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, XEXP (target, 0),\n-\t\t\t\t\t\t\tcfun->machine->base_reg),\n-\t\t\t\t   UNSPEC_LTREL_BASE);\n-\t  target = gen_rtx_PLUS (Pmode, temp_reg, target);\n-\t}\n-\n-      ret = validate_change (insn, label, target, 0);\n-      gcc_assert (ret);\n-    }\n-\n-  return new_literal;\n-}\n-\n-\n /* Find an annotated literal pool symbol referenced in RTX X,\n    and store it at REF.  Will abort if X contains references to\n    more than one such pool symbol; multiple references to the same\n@@ -8772,28 +8584,6 @@ s390_execute_label (rtx insn)\n   return NULL_RTX;\n }\n \n-/* Add execute target for INSN to the constant pool POOL.  */\n-\n-static void\n-s390_add_execute (struct constant_pool *pool, rtx insn)\n-{\n-  struct constant *c;\n-\n-  for (c = pool->execute; c != NULL; c = c->next)\n-    if (INSN_UID (insn) == INSN_UID (c->value))\n-      break;\n-\n-  if (c == NULL)\n-    {\n-      c = (struct constant *) xmalloc (sizeof *c);\n-      c->value = insn;\n-      c->label = gen_label_rtx ();\n-      c->next = pool->execute;\n-      pool->execute = c;\n-      pool->size += 6;\n-    }\n-}\n-\n /* Find execute target for INSN in the constant pool POOL.\n    Return an RTX describing the distance from the start of\n    the pool to the location of the execute target.  */\n@@ -8859,17 +8649,11 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n   int i;\n \n   /* Switch to rodata section.  */\n-  if (TARGET_CPU_ZARCH)\n-    {\n-      insn = emit_insn_after (gen_pool_section_start (), insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-    }\n+  insn = emit_insn_after (gen_pool_section_start (), insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n \n   /* Ensure minimum pool alignment.  */\n-  if (TARGET_CPU_ZARCH)\n-    insn = emit_insn_after (gen_pool_align (GEN_INT (8)), insn);\n-  else\n-    insn = emit_insn_after (gen_pool_align (GEN_INT (4)), insn);\n+  insn = emit_insn_after (gen_pool_align (GEN_INT (8)), insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n   /* Emit pool base label.  */\n@@ -8917,11 +8701,8 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n     }\n \n   /* Switch back to previous section.  */\n-  if (TARGET_CPU_ZARCH)\n-    {\n-      insn = emit_insn_after (gen_pool_section_end (), insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-    }\n+  insn = emit_insn_after (gen_pool_section_end (), insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n \n   insn = emit_barrier_after (insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n@@ -8985,11 +8766,7 @@ s390_mainpool_start (void)\n \t  pool->pool_insn = insn;\n \t}\n \n-      if (!TARGET_CPU_ZARCH && s390_execute_label (insn))\n-\t{\n-\t  s390_add_execute (pool, insn);\n-\t}\n-      else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n+      if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -9041,6 +8818,8 @@ static void\n s390_mainpool_finish (struct constant_pool *pool)\n {\n   rtx base_reg = cfun->machine->base_reg;\n+  rtx set;\n+  rtx_insn *insn;\n \n   /* If the pool is empty, we're done.  */\n   if (pool->size == 0)\n@@ -9057,71 +8836,18 @@ s390_mainpool_finish (struct constant_pool *pool)\n   /* We need correct insn addresses.  */\n   shorten_branches (get_insns ());\n \n-  /* On zSeries, we use a LARL to load the pool register.  The pool is\n+  /* Use a LARL to load the pool register.  The pool is\n      located in the .rodata section, so we emit it after the function.  */\n-  if (TARGET_CPU_ZARCH)\n-    {\n-      rtx set = gen_main_base_64 (base_reg, pool->label);\n-      rtx_insn *insn = emit_insn_after (set, pool->pool_insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-      remove_insn (pool->pool_insn);\n-\n-      insn = get_last_insn ();\n-      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n-      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n-\n-      s390_dump_pool (pool, 0);\n-    }\n-\n-  /* On S/390, if the total size of the function's code plus literal pool\n-     does not exceed 4096 bytes, we use BASR to set up a function base\n-     pointer, and emit the literal pool at the end of the function.  */\n-  else if (INSN_ADDRESSES (INSN_UID (pool->emit_pool_after))\n-\t   + pool->size + 8 /* alignment slop */ < 4096)\n-    {\n-      rtx set = gen_main_base_31_small (base_reg, pool->label);\n-      rtx_insn *insn = emit_insn_after (set, pool->pool_insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-      remove_insn (pool->pool_insn);\n-\n-      insn = emit_label_after (pool->label, insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-\n-      /* emit_pool_after will be set by s390_mainpool_start to the\n-\t last insn of the section where the literal pool should be\n-\t emitted.  */\n-      insn = pool->emit_pool_after;\n-\n-      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n-      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n-\n-      s390_dump_pool (pool, 1);\n-    }\n-\n-  /* Otherwise, we emit an inline literal pool and use BASR to branch\n-     over it, setting up the pool register at the same time.  */\n-  else\n-    {\n-      rtx_code_label *pool_end = gen_label_rtx ();\n-\n-      rtx pat = gen_main_base_31_large (base_reg, pool->label, pool_end);\n-      rtx_insn *insn = emit_jump_insn_after (pat, pool->pool_insn);\n-      JUMP_LABEL (insn) = pool_end;\n-      INSN_ADDRESSES_NEW (insn, -1);\n-      remove_insn (pool->pool_insn);\n-\n-      insn = emit_label_after (pool->label, insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n-\n-      pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n-      INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n-\n-      insn = emit_label_after (pool_end, pool->pool_insn);\n-      INSN_ADDRESSES_NEW (insn, -1);\n+  set = gen_main_base_64 (base_reg, pool->label);\n+  insn = emit_insn_after (set, pool->pool_insn);\n+  INSN_ADDRESSES_NEW (insn, -1);\n+  remove_insn (pool->pool_insn);\n \n-      s390_dump_pool (pool, 1);\n-    }\n+  insn = get_last_insn ();\n+  pool->pool_insn = emit_insn_after (gen_pool (const0_rtx), insn);\n+  INSN_ADDRESSES_NEW (pool->pool_insn, -1);\n \n+  s390_dump_pool (pool, 0);\n \n   /* Replace all literal pool references.  */\n \n@@ -9153,18 +8879,6 @@ s390_mainpool_finish (struct constant_pool *pool)\n   s390_free_pool (pool);\n }\n \n-/* POOL holds the main literal pool as collected by s390_mainpool_start.\n-   We have decided we cannot use this pool, so revert all changes\n-   to the current function that were done by s390_mainpool_start.  */\n-static void\n-s390_mainpool_cancel (struct constant_pool *pool)\n-{\n-  /* We didn't actually change the instruction stream, so simply\n-     free the pool memory.  */\n-  s390_free_pool (pool);\n-}\n-\n-\n /* Chunkify the literal pool.  */\n \n #define S390_POOL_CHUNK_MIN\t0xc00\n@@ -9174,15 +8888,10 @@ static struct constant_pool *\n s390_chunkify_start (void)\n {\n   struct constant_pool *curr_pool = NULL, *pool_list = NULL;\n-  int extra_size = 0;\n   bitmap far_labels;\n   rtx pending_ltrel = NULL_RTX;\n   rtx_insn *insn;\n \n-  rtx (*gen_reload_base) (rtx, rtx) =\n-    TARGET_CPU_ZARCH? gen_reload_base_64 : gen_reload_base_31;\n-\n-\n   /* We need correct insn addresses.  */\n \n   shorten_branches (get_insns ());\n@@ -9191,8 +8900,6 @@ s390_chunkify_start (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      bool section_switch_p = false;\n-\n       /* Check for pending LTREL_BASE.  */\n       if (INSN_P (insn))\n \t{\n@@ -9204,15 +8911,7 @@ s390_chunkify_start (void)\n \t    }\n \t}\n \n-      if (!TARGET_CPU_ZARCH && s390_execute_label (insn))\n-\t{\n-\t  if (!curr_pool)\n-\t    curr_pool = s390_start_pool (&pool_list, insn);\n-\n-\t  s390_add_execute (curr_pool, insn);\n-\t  s390_add_pool_insn (curr_pool, insn);\n-\t}\n-      else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n+      if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -9247,118 +8946,19 @@ s390_chunkify_start (void)\n \t  gcc_assert (!pending_ltrel);\n \t}\n \n-      if (NOTE_P (insn))\n-\tswitch (NOTE_KIND (insn))\n-\t  {\n-\t  case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n-\t    section_switch_p = true;\n-\t    break;\n-\t  case NOTE_INSN_VAR_LOCATION:\n-\t    continue;\n-\t  default:\n-\t    break;\n-\t  }\n+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION)\n+\tcontinue;\n \n       if (!curr_pool\n \t  || INSN_ADDRESSES_SIZE () <= (size_t) INSN_UID (insn)\n-          || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n+\t  || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n \tcontinue;\n \n-      if (TARGET_CPU_ZARCH)\n-\t{\n-\t  if (curr_pool->size < S390_POOL_CHUNK_MAX)\n-\t    continue;\n-\n-\t  s390_end_pool (curr_pool, NULL);\n-\t  curr_pool = NULL;\n-\t}\n-      else\n-\t{\n-          int chunk_size = INSN_ADDRESSES (INSN_UID (insn))\n-\t\t\t   - INSN_ADDRESSES (INSN_UID (curr_pool->first_insn))\n-\t\t\t + extra_size;\n-\n-\t  /* We will later have to insert base register reload insns.\n-\t     Those will have an effect on code size, which we need to\n-\t     consider here.  This calculation makes rather pessimistic\n-\t     worst-case assumptions.  */\n-\t  if (LABEL_P (insn))\n-\t    extra_size += 6;\n-\n-\t  if (chunk_size < S390_POOL_CHUNK_MIN\n-\t      && curr_pool->size < S390_POOL_CHUNK_MIN\n-\t      && !section_switch_p)\n-\t    continue;\n-\n-\t  /* Pool chunks can only be inserted after BARRIERs ...  */\n-\t  if (BARRIER_P (insn))\n-\t    {\n-\t      s390_end_pool (curr_pool, insn);\n-\t      curr_pool = NULL;\n-\t      extra_size = 0;\n-\t    }\n-\n-\t  /* ... so if we don't find one in time, create one.  */\n-          else if (chunk_size > S390_POOL_CHUNK_MAX\n-\t           || curr_pool->size > S390_POOL_CHUNK_MAX\n-\t\t   || section_switch_p)\n-\t    {\n-\t      rtx_insn *label, *jump, *barrier, *next, *prev;\n-\n-\t      if (!section_switch_p)\n-\t\t{\n-\t\t  /* We can insert the barrier only after a 'real' insn.  */\n-\t\t  if (! NONJUMP_INSN_P (insn) && ! CALL_P (insn))\n-\t\t    continue;\n-\t\t  if (get_attr_length (insn) == 0)\n-\t\t    continue;\n-\t\t  /* Don't separate LTREL_BASE from the corresponding\n-\t\t     LTREL_OFFSET load.  */\n-\t\t  if (pending_ltrel)\n-\t\t    continue;\n-\t\t  next = insn;\n-\t\t  do\n-\t\t    {\n-\t\t      insn = next;\n-\t\t      next = NEXT_INSN (insn);\n-\t\t    }\n-\t\t  while (next\n-\t\t\t && NOTE_P (next)\n-\t\t\t && NOTE_KIND (next) == NOTE_INSN_VAR_LOCATION);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (!pending_ltrel);\n-\n-\t\t  /* The old pool has to end before the section switch\n-\t\t     note in order to make it part of the current\n-\t\t     section.  */\n-\t\t  insn = PREV_INSN (insn);\n-\t\t}\n+      if (curr_pool->size < S390_POOL_CHUNK_MAX)\n+\tcontinue;\n \n-\t      label = gen_label_rtx ();\n-\t      prev = insn;\n-\t      if (prev && NOTE_P (prev))\n-\t\tprev = prev_nonnote_insn (prev);\n-\t      if (prev)\n-\t\tjump = emit_jump_insn_after_setloc (gen_jump (label), insn,\n-\t\t\t\t\t\t    INSN_LOCATION (prev));\n-\t      else\n-\t\tjump = emit_jump_insn_after_noloc (gen_jump (label), insn);\n-\t      barrier = emit_barrier_after (jump);\n-\t      insn = emit_label_after (label, barrier);\n-\t      JUMP_LABEL (jump) = label;\n-\t      LABEL_NUSES (label) = 1;\n-\n-\t      INSN_ADDRESSES_NEW (jump, -1);\n-\t      INSN_ADDRESSES_NEW (barrier, -1);\n-\t      INSN_ADDRESSES_NEW (insn, -1);\n-\n-\t      s390_end_pool (curr_pool, barrier);\n-\t      curr_pool = NULL;\n-\t      extra_size = 0;\n-\t    }\n-\t}\n+      s390_end_pool (curr_pool, NULL);\n+      curr_pool = NULL;\n     }\n \n   if (curr_pool)\n@@ -9429,8 +9029,8 @@ s390_chunkify_start (void)\n \n   for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n     {\n-      rtx new_insn = gen_reload_base (cfun->machine->base_reg,\n-\t\t\t\t      curr_pool->label);\n+      rtx new_insn = gen_reload_base_64 (cfun->machine->base_reg,\n+\t\t\t\t\t curr_pool->label);\n       rtx_insn *insn = curr_pool->first_insn;\n       INSN_ADDRESSES_NEW (emit_insn_before (new_insn, insn), -1);\n     }\n@@ -9444,8 +9044,8 @@ s390_chunkify_start (void)\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n \tif (pool)\n \t  {\n-\t    rtx new_insn = gen_reload_base (cfun->machine->base_reg,\n-\t\t\t\t\t    pool->label);\n+\t    rtx new_insn = gen_reload_base_64 (cfun->machine->base_reg,\n+\t\t\t\t\t       pool->label);\n \t    INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n \t  }\n       }\n@@ -9518,66 +9118,6 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n     }\n }\n \n-/* POOL_LIST is a chunk list as prepared by s390_chunkify_start.\n-   We have decided we cannot use this list, so revert all changes\n-   to the current function that were done by s390_chunkify_start.  */\n-\n-static void\n-s390_chunkify_cancel (struct constant_pool *pool_list)\n-{\n-  struct constant_pool *curr_pool = NULL;\n-  rtx_insn *insn;\n-\n-  /* Remove all pool placeholder insns.  */\n-\n-  for (curr_pool = pool_list; curr_pool; curr_pool = curr_pool->next)\n-    {\n-      /* Did we insert an extra barrier?  Remove it.  */\n-      rtx_insn *barrier = PREV_INSN (curr_pool->pool_insn);\n-      rtx_insn *jump = barrier? PREV_INSN (barrier) : NULL;\n-      rtx_insn *label = NEXT_INSN (curr_pool->pool_insn);\n-\n-      if (jump && JUMP_P (jump)\n-\t  && barrier && BARRIER_P (barrier)\n-\t  && label && LABEL_P (label)\n-\t  && GET_CODE (PATTERN (jump)) == SET\n-\t  && SET_DEST (PATTERN (jump)) == pc_rtx\n-\t  && GET_CODE (SET_SRC (PATTERN (jump))) == LABEL_REF\n-\t  && XEXP (SET_SRC (PATTERN (jump)), 0) == label)\n-\t{\n-\t  remove_insn (jump);\n-\t  remove_insn (barrier);\n-\t  remove_insn (label);\n-\t}\n-\n-      remove_insn (curr_pool->pool_insn);\n-    }\n-\n-  /* Remove all base register reload insns.  */\n-\n-  for (insn = get_insns (); insn; )\n-    {\n-      rtx_insn *next_insn = NEXT_INSN (insn);\n-\n-      if (NONJUMP_INSN_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && GET_CODE (SET_SRC (PATTERN (insn))) == UNSPEC\n-\t  && XINT (SET_SRC (PATTERN (insn)), 1) == UNSPEC_RELOAD_BASE)\n-\tremove_insn (insn);\n-\n-      insn = next_insn;\n-    }\n-\n-  /* Free pool list.  */\n-\n-  while (pool_list)\n-    {\n-      struct constant_pool *next = pool_list->next;\n-      s390_free_pool (pool_list);\n-      pool_list = next;\n-    }\n-}\n-\n /* Output the constant pool entry EXP in mode MODE with alignment ALIGN.  */\n \n void\n@@ -9640,16 +9180,7 @@ s390_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n      value of RETURN_REGNUM is actually saved.  */\n \n   if (count == 0)\n-    {\n-      /* On non-z architectures branch splitting could overwrite r14.  */\n-      if (TARGET_CPU_ZARCH)\n-\treturn get_hard_reg_initial_val (Pmode, RETURN_REGNUM);\n-      else\n-\t{\n-\t  cfun_frame_layout.save_return_addr_p = true;\n-\t  return gen_rtx_MEM (Pmode, return_address_pointer_rtx);\n-\t}\n-    }\n+    return get_hard_reg_initial_val (Pmode, RETURN_REGNUM);\n \n   if (TARGET_PACKED_STACK)\n     offset = -2 * UNITS_PER_LONG;\n@@ -10068,7 +9599,6 @@ s390_register_info ()\n   clobbered_regs[RETURN_REGNUM]\n     |= (!crtl->is_leaf\n \t|| TARGET_TPF_PROFILING\n-\t|| cfun->machine->split_branches_pending_p\n \t|| cfun_frame_layout.save_return_addr_p\n \t|| crtl->calls_eh_return);\n \n@@ -10107,7 +9637,6 @@ s390_optimize_register_info ()\n   int i;\n \n   gcc_assert (epilogue_completed);\n-  gcc_assert (!cfun->machine->split_branches_pending_p);\n \n   s390_regs_ever_clobbered (clobbered_regs);\n \n@@ -10275,20 +9804,12 @@ s390_init_frame_layout (void)\n   if (reload_completed)\n     return;\n \n-  /* On S/390 machines, we may need to perform branch splitting, which\n-     will require both base and return address register.  We have no\n-     choice but to assume we're going to need them until right at the\n-     end of the machine dependent reorg phase.  */\n-  if (!TARGET_CPU_ZARCH)\n-    cfun->machine->split_branches_pending_p = true;\n-\n   do\n     {\n       frame_size = cfun_frame_layout.frame_size;\n \n       /* Try to predict whether we'll need the base register.  */\n-      base_used = cfun->machine->split_branches_pending_p\n-\t\t  || crtl->uses_const_pool\n+      base_used = crtl->uses_const_pool\n \t\t  || (!DISP_IN_RANGE (frame_size)\n \t\t      && !CONST_OK_FOR_K (frame_size));\n \n@@ -10740,7 +10261,7 @@ s390_lra_p (void)\n static bool\n s390_can_eliminate (const int from, const int to)\n {\n-  /* On zSeries machines, we have not marked the base register as fixed.\n+  /* We have not marked the base register as fixed.\n      Instead, we have an elimination rule BASE_REGNUM -> BASE_REGNUM.\n      If a function requires the base register, we say here that this\n      elimination cannot be performed.  This will cause reload to free\n@@ -10750,13 +10271,8 @@ s390_can_eliminate (const int from, const int to)\n      to allocate the base register for any other purpose.  */\n   if (from == BASE_REGNUM && to == BASE_REGNUM)\n     {\n-      if (TARGET_CPU_ZARCH)\n-\t{\n-\t  s390_init_frame_layout ();\n-\t  return cfun->machine->base_reg == NULL_RTX;\n-\t}\n-\n-      return false;\n+      s390_init_frame_layout ();\n+      return cfun->machine->base_reg == NULL_RTX;\n     }\n \n   /* Everything else must point into the stack frame.  */\n@@ -11043,27 +10559,7 @@ s390_load_got (void)\n \n   start_sequence ();\n \n-  if (TARGET_CPU_ZARCH)\n-    {\n-      emit_move_insn (got_rtx, s390_got_symbol ());\n-    }\n-  else\n-    {\n-      rtx offset;\n-\n-      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, s390_got_symbol ()),\n-\t\t\t       UNSPEC_LTREL_OFFSET);\n-      offset = gen_rtx_CONST (Pmode, offset);\n-      offset = force_const_mem (Pmode, offset);\n-\n-      emit_move_insn (got_rtx, offset);\n-\n-      offset = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (offset, 0)),\n-\t\t\t       UNSPEC_LTREL_BASE);\n-      offset = gen_rtx_PLUS (Pmode, got_rtx, offset);\n-\n-      emit_move_insn (got_rtx, offset);\n-    }\n+  emit_move_insn (got_rtx, s390_got_symbol ());\n \n   insns = get_insns ();\n   end_sequence ();\n@@ -11955,11 +11451,6 @@ s390_expand_split_stack_prologue (void)\n   rtx tmp;\n \n   gcc_assert (flag_split_stack && reload_completed);\n-  if (!TARGET_CPU_ZARCH)\n-    {\n-      sorry (\"CPUs older than z900 are not supported for -fsplit-stack\");\n-      return;\n-    }\n \n   r1 = gen_rtx_REG (Pmode, 1);\n \n@@ -13124,10 +12615,10 @@ output_asm_nops (const char *user, int hw)\n   asm_fprintf (asm_out_file, \"\\t# NOPs for %s (%d halfwords)\\n\", user, hw);\n   while (hw > 0)\n     {\n-      if (TARGET_CPU_ZARCH && hw >= 3)\n-        {\n-          output_asm_insn (\"brcl\\t0,0\", NULL);\n-          hw -= 3;\n+      if (hw >= 3)\n+\t{\n+\t  output_asm_insn (\"brcl\\t0,0\", NULL);\n+\t  hw -= 3;\n         }\n       else if (hw >= 2)\n         {\n@@ -13201,7 +12692,7 @@ s390_function_profiler (FILE *file, int labelno)\n             output_asm_insn (\".cfi_restore\\t%0\", op);\n         }\n     }\n-  else if (TARGET_CPU_ZARCH)\n+  else\n     {\n       if (flag_nop_mcount)\n         output_asm_nops (\"-mnop-mcount\", /* st */ 2 + /* larl */ 3 +\n@@ -13215,64 +12706,8 @@ s390_function_profiler (FILE *file, int labelno)\n           output_asm_insn (\"brasl\\t%0,%4\", op);\n           output_asm_insn (\"l\\t%0,%1\", op);\n           if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_restore\\t%0\", op);\n-        }\n-    }\n-  else if (!flag_pic)\n-    {\n-      op[6] = gen_label_rtx ();\n-\n-      if (flag_nop_mcount)\n-        output_asm_nops (\"-mnop-mcount\", /* st */ 2 + /* bras */ 2 +\n-                         /* .long */ 2 + /* .long */ 2 + /* l */ 2 +\n-                         /* l */ 2 + /* basr */ 1 + /* l */ 2);\n-      else\n-        {\n-          output_asm_insn (\"st\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n-          output_asm_insn (\"bras\\t%2,%l6\", op);\n-          output_asm_insn (\".long\\t%4\", op);\n-          output_asm_insn (\".long\\t%3\", op);\n-          targetm.asm_out.internal_label (file, \"L\",\n-                                          CODE_LABEL_NUMBER (op[6]));\n-          output_asm_insn (\"l\\t%0,0(%2)\", op);\n-          output_asm_insn (\"l\\t%2,4(%2)\", op);\n-          output_asm_insn (\"basr\\t%0,%0\", op);\n-          output_asm_insn (\"l\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_restore\\t%0\", op);\n-        }\n-    }\n-  else\n-    {\n-      op[5] = gen_label_rtx ();\n-      op[6] = gen_label_rtx ();\n-\n-      if (flag_nop_mcount)\n-        output_asm_nops (\"-mnop-mcount\", /* st */ 2 + /* bras */ 2 +\n-                         /* .long */ 2 + /* .long */ 2 + /* lr */ 1 +\n-                         /* a */ 2 + /* a */ 2 + /* basr */ 1 + /* l */ 2);\n-      else\n-        {\n-          output_asm_insn (\"st\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n-          output_asm_insn (\"bras\\t%2,%l6\", op);\n-          targetm.asm_out.internal_label (file, \"L\",\n-                                          CODE_LABEL_NUMBER (op[5]));\n-          output_asm_insn (\".long\\t%4-%l5\", op);\n-          output_asm_insn (\".long\\t%3-%l5\", op);\n-          targetm.asm_out.internal_label (file, \"L\",\n-                                          CODE_LABEL_NUMBER (op[6]));\n-          output_asm_insn (\"lr\\t%0,%2\", op);\n-          output_asm_insn (\"a\\t%0,0(%2)\", op);\n-          output_asm_insn (\"a\\t%2,4(%2)\", op);\n-          output_asm_insn (\"basr\\t%0,%0\", op);\n-          output_asm_insn (\"l\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_restore\\t%0\", op);\n-        }\n+\t    output_asm_insn (\".cfi_restore\\t%0\", op);\n+\t}\n     }\n \n   if (flag_record_mcount)\n@@ -13871,16 +13306,6 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n \t       optimization is illegal for S/390 so we turn the direct\n \t       call into a indirect call again.  */\n \t    addr_location = force_reg (Pmode, addr_location);\n-        }\n-\n-      /* Unless we can use the bras(l) insn, force the\n-         routine address into a register.  */\n-      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n-        {\n-\t  if (flag_pic)\n-\t    addr_location = legitimize_pic_address (addr_location, 0);\n-\t  else\n-\t    addr_location = force_reg (Pmode, addr_location);\n \t}\n     }\n \n@@ -13971,13 +13396,10 @@ s390_conditional_register_usage (void)\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n     }\n-  if (TARGET_CPU_ZARCH)\n-    {\n-      fixed_regs[BASE_REGNUM] = 0;\n-      call_used_regs[BASE_REGNUM] = 0;\n-      fixed_regs[RETURN_REGNUM] = 0;\n-      call_used_regs[RETURN_REGNUM] = 0;\n-    }\n+  fixed_regs[BASE_REGNUM] = 0;\n+  call_used_regs[BASE_REGNUM] = 0;\n+  fixed_regs[RETURN_REGNUM] = 0;\n+  call_used_regs[RETURN_REGNUM] = 0;\n   if (TARGET_64BIT)\n     {\n       for (i = FPR8_REGNUM; i <= FPR15_REGNUM; i++)\n@@ -14043,14 +13465,10 @@ s390_optimize_prologue (void)\n      can do, so no point in walking the insn list.  */\n \n   if (cfun_frame_layout.first_save_gpr <= BASE_REGNUM\n-      && cfun_frame_layout.last_save_gpr >= BASE_REGNUM\n-      && (TARGET_CPU_ZARCH\n-          || (cfun_frame_layout.first_save_gpr <= RETURN_REGNUM\n-              && cfun_frame_layout.last_save_gpr >= RETURN_REGNUM)))\n+      && cfun_frame_layout.last_save_gpr >= BASE_REGNUM)\n     return;\n \n   /* Search for prologue/epilogue insns and replace them.  */\n-\n   for (insn = get_insns (); insn; insn = next_insn)\n     {\n       int first, last, off;\n@@ -14627,6 +14045,7 @@ static void\n s390_reorg (void)\n {\n   bool pool_overflow = false;\n+  rtx_insn *insn;\n   int hw_before, hw_after;\n \n   if (s390_tune == PROCESSOR_2964_Z13)\n@@ -14683,21 +14102,7 @@ s390_reorg (void)\n \n       /* If literal pool overflowed, start to chunkify it.  */\n       if (pool_overflow)\n-        pool = s390_chunkify_start ();\n-\n-      /* Split out-of-range branches.  If this has created new\n-\t literal pool entries, cancel current chunk list and\n-\t recompute it.  zSeries machines have large branch\n-\t instructions, so we never need to split a branch.  */\n-      if (!TARGET_CPU_ZARCH && s390_split_branches ())\n-        {\n-          if (pool_overflow)\n-            s390_chunkify_cancel (pool);\n-\t  else\n-            s390_mainpool_cancel (pool);\n-\n-          continue;\n-        }\n+\tpool = s390_chunkify_start ();\n \n       /* If we made it up to here, both conditions are satisfied.\n \t Finish up literal pool related changes.  */\n@@ -14706,40 +14111,35 @@ s390_reorg (void)\n       else\n \ts390_mainpool_finish (pool);\n \n-      /* We're done splitting branches.  */\n-      cfun->machine->split_branches_pending_p = false;\n       break;\n     }\n \n   /* Generate out-of-pool execute target insns.  */\n-  if (TARGET_CPU_ZARCH)\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      rtx_insn *insn, *target;\n       rtx label;\n+      rtx_insn *target;\n \n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  label = s390_execute_label (insn);\n-\t  if (!label)\n-\t    continue;\n+      label = s390_execute_label (insn);\n+      if (!label)\n+\tcontinue;\n \n-\t  gcc_assert (label != const0_rtx);\n+      gcc_assert (label != const0_rtx);\n \n-\t  target = emit_label (XEXP (label, 0));\n-\t  INSN_ADDRESSES_NEW (target, -1);\n+      target = emit_label (XEXP (label, 0));\n+      INSN_ADDRESSES_NEW (target, -1);\n \n-\t  if (JUMP_P (insn))\n-\t    {\n-\t      target = emit_jump_insn (s390_execute_target (insn));\n-\t      /* This is important in order to keep a table jump\n-\t\t pointing at the jump table label.  Only this makes it\n-\t\t being recognized as table jump.  */\n-\t      JUMP_LABEL (target) = JUMP_LABEL (insn);\n-\t    }\n-\t  else\n-\t    target = emit_insn (s390_execute_target (insn));\n-\t  INSN_ADDRESSES_NEW (target, -1);\n+      if (JUMP_P (insn))\n+\t{\n+\t  target = emit_jump_insn (s390_execute_target (insn));\n+\t  /* This is important in order to keep a table jump\n+\t     pointing at the jump table label.  Only this makes it\n+\t     being recognized as table jump.  */\n+\t  JUMP_LABEL (target) = JUMP_LABEL (insn);\n \t}\n+      else\n+\ttarget = emit_insn (s390_execute_target (insn));\n+      INSN_ADDRESSES_NEW (target, -1);\n     }\n \n   /* Try to optimize prologue and epilogue further.  */\n@@ -14796,7 +14196,7 @@ s390_reorg (void)\n       /* Output a series of NOPs before the first active insn.  */\n       while (insn && hw_after > 0)\n \t{\n-\t  if (hw_after >= 3 && TARGET_CPU_ZARCH)\n+\t  if (hw_after >= 3)\n \t    {\n \t      emit_insn_before (gen_nop_6_byte (), insn);\n \t      hw_after -= 3;\n@@ -15472,9 +14872,6 @@ s390_option_override_internal (struct gcc_options *opts,\n   if (opts->x_s390_arch == PROCESSOR_NATIVE\n       || opts->x_s390_tune == PROCESSOR_NATIVE)\n     gcc_unreachable ();\n-  if (TARGET_ZARCH_P (opts->x_target_flags) && !TARGET_CPU_ZARCH_P (opts))\n-    error (\"z/Architecture mode not supported on %s\",\n-\t   processor_table[(int)opts->x_s390_arch].name);\n   if (TARGET_64BIT && !TARGET_ZARCH_P (opts->x_target_flags))\n     error (\"64-bit ABI not supported in ESA/390 mode\");\n \n@@ -15503,17 +14900,6 @@ s390_option_override_internal (struct gcc_options *opts,\n \topts->x_s390_function_return_mem = opts->x_s390_function_return;\n     }\n \n-  if (!TARGET_CPU_ZARCH)\n-    {\n-      if (opts->x_s390_indirect_branch_call != indirect_branch_keep\n-\t  || opts->x_s390_indirect_branch_jump != indirect_branch_keep)\n-\terror (\"-mindirect-branch* options require -march=z900 or higher\");\n-      if (opts->x_s390_function_return_reg != indirect_branch_keep\n-\t  || opts->x_s390_function_return_mem != indirect_branch_keep)\n-\terror (\"-mfunction-return* options require -march=z900 or higher\");\n-    }\n-\n-\n   /* Enable hardware transactions if available and not explicitly\n      disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */\n   if (!TARGET_OPT_HTM_P (opts_set->x_target_flags))\n@@ -16656,7 +16042,7 @@ s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)\n       if (!TARGET_CPU_Z10)\n \tfputs (\"\\t.machine pop\\n\", asm_out_file);\n     }\n-  else if (TARGET_CPU_ZARCH)\n+  else\n     {\n       /* larl %r1,1f  */\n       fprintf (asm_out_file, \"\\tlarl\\t%%r%d,1f\\n\",\n@@ -16666,8 +16052,6 @@ s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)\n       fprintf (asm_out_file, \"\\tex\\t0,0(%%r%d)\\n\",\n \t       INDIRECT_BRANCH_THUNK_REGNUM);\n     }\n-  else\n-    gcc_unreachable ();\n \n   /* 0:    j 0b  */\n   fputs (\"0:\\tj\\t0b\\n\", asm_out_file);"}, {"sha": "d0ccc4909bff6503d762acf72eefe9d1c833bf0c", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "patch": "@@ -54,10 +54,6 @@ enum processor_flags\n \t(s390_arch_flags & PF_IEEE_FLOAT)\n #define TARGET_CPU_IEEE_FLOAT_P(opts) \\\n \t(opts->x_s390_arch_flags & PF_IEEE_FLOAT)\n-#define TARGET_CPU_ZARCH \\\n-\t(s390_arch_flags & PF_ZARCH)\n-#define TARGET_CPU_ZARCH_P(opts) \\\n-\t(opts->x_s390_arch_flags & PF_ZARCH)\n #define TARGET_CPU_LONG_DISPLACEMENT \\\n \t(s390_arch_flags & PF_LONG_DISPLACEMENT)\n #define TARGET_CPU_LONG_DISPLACEMENT_P(opts) \\\n@@ -1119,9 +1115,6 @@ struct GTY(()) machine_function\n   /* Literal pool base register.  */\n   rtx base_reg;\n \n-  /* True if we may need to perform branch splitting.  */\n-  bool split_branches_pending_p;\n-\n   bool has_landing_pad_p;\n \n   /* True if the current function may contain a tbegin clobbering"}, {"sha": "e735a17a2b88767220de910639d5c73e8e5317da", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 49, "deletions": 446, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cc6307c8889b92c98d4b905bf2fdd8fb285a577/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "patch": "@@ -481,7 +481,7 @@\n ; mnemonics which only get defined through if_then_else currently\n ; don't get added to the list values automatically and hence need to\n ; be listed here.\n-(define_attr \"mnemonic\" \"b,bas,bc,bcr_flush,unknown\" (const_string \"unknown\"))\n+(define_attr \"mnemonic\" \"b,bas,basr,bc,bcr_flush,unknown\" (const_string \"unknown\"))\n \n ;; Length in bytes.\n \n@@ -525,8 +525,7 @@\n \t      (match_test \"TARGET_DFP\"))\n \t (const_int 1)\n \n-         (and (eq_attr \"cpu_facility\" \"cpu_zarch\")\n-              (match_test \"TARGET_CPU_ZARCH\"))\n+         (eq_attr \"cpu_facility\" \"cpu_zarch\")\n \t (const_int 1)\n \n          (and (eq_attr \"cpu_facility\" \"z10\")\n@@ -1984,7 +1983,7 @@\n (define_insn \"*movsi_larl\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:SI 1 \"larl_operand\" \"X\"))]\n-  \"!TARGET_64BIT && TARGET_CPU_ZARCH\n+  \"!TARGET_64BIT\n    && !FP_REG_P (operands[0])\"\n   \"larl\\t%0,%1\"\n    [(set_attr \"op_type\" \"RIL\")\n@@ -3225,7 +3224,7 @@\n    (use (match_operand 2 \"register_operand\" \"\"))\n    (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n    (clobber (match_operand 3 \"register_operand\" \"\"))]\n-  \"reload_completed && TARGET_CPU_ZARCH\"\n+  \"reload_completed\"\n   [(set (match_dup 3) (label_ref (match_dup 4)))\n    (parallel\n     [(unspec [(match_dup 2) (mem:BLK (match_dup 3))\n@@ -3446,7 +3445,7 @@\n    (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n    (clobber (match_operand 2 \"register_operand\" \"\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"reload_completed && TARGET_CPU_ZARCH\"\n+  \"reload_completed\"\n   [(set (match_dup 2) (label_ref (match_dup 3)))\n    (parallel\n     [(unspec [(match_dup 1) (mem:BLK (match_dup 2))\n@@ -3637,7 +3636,7 @@\n    (use (match_operand 2 \"register_operand\" \"\"))\n    (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n    (clobber (match_operand 3 \"register_operand\" \"\"))]\n-  \"reload_completed && TARGET_CPU_ZARCH\"\n+  \"reload_completed\"\n   [(set (match_dup 3) (label_ref (match_dup 4)))\n    (parallel\n     [(unspec [(match_dup 2) (mem:BLK (match_dup 3))\n@@ -5600,7 +5599,7 @@\n         (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n                  (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -5620,38 +5619,6 @@\n    operands[7] = operand_subword (operands[1], 1, 0, DImode);\n    operands[8] = operand_subword (operands[2], 1, 0, DImode);\")\n \n-(define_insn_and_split \"*adddi3_31\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&d\")\n-        (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n-                 (match_operand:DI 2 \"general_operand\" \"do\") ) )\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_CPU_ZARCH\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel\n-    [(set (match_dup 3) (plus:SI (match_dup 4) (match_dup 5)))\n-     (clobber (reg:CC CC_REGNUM))])\n-   (parallel\n-    [(set (reg:CCL1 CC_REGNUM)\n-          (compare:CCL1 (plus:SI (match_dup 7) (match_dup 8))\n-                        (match_dup 7)))\n-     (set (match_dup 6) (plus:SI (match_dup 7) (match_dup 8)))])\n-   (set (pc)\n-        (if_then_else (ltu (reg:CCL1 CC_REGNUM) (const_int 0))\n-                      (pc)\n-                      (label_ref (match_dup 9))))\n-   (parallel\n-    [(set (match_dup 3) (plus:SI (match_dup 3) (const_int 1)))\n-     (clobber (reg:CC CC_REGNUM))])\n-   (match_dup 9)]\n-  \"operands[3] = operand_subword (operands[0], 0, 0, DImode);\n-   operands[4] = operand_subword (operands[1], 0, 0, DImode);\n-   operands[5] = operand_subword (operands[2], 0, 0, DImode);\n-   operands[6] = operand_subword (operands[0], 1, 0, DImode);\n-   operands[7] = operand_subword (operands[1], 1, 0, DImode);\n-   operands[8] = operand_subword (operands[2], 1, 0, DImode);\n-   operands[9] = gen_label_rtx ();\")\n-\n ;\n ; addsi3 instruction pattern(s).\n ;\n@@ -6102,7 +6069,7 @@\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n                   (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(parallel\n@@ -6121,38 +6088,6 @@\n    operands[7] = operand_subword (operands[1], 1, 0, DImode);\n    operands[8] = operand_subword (operands[2], 1, 0, DImode);\")\n \n-(define_insn_and_split \"*subdi3_31\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n-        (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-                  (match_operand:DI 2 \"general_operand\" \"do\") ) )\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_CPU_ZARCH\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel\n-    [(set (match_dup 3) (minus:SI (match_dup 4) (match_dup 5)))\n-     (clobber (reg:CC CC_REGNUM))])\n-   (parallel\n-    [(set (reg:CCL2 CC_REGNUM)\n-          (compare:CCL2 (minus:SI (match_dup 7) (match_dup 8))\n-                        (match_dup 7)))\n-     (set (match_dup 6) (minus:SI (match_dup 7) (match_dup 8)))])\n-   (set (pc)\n-        (if_then_else (gtu (reg:CCL2 CC_REGNUM) (const_int 0))\n-                      (pc)\n-                      (label_ref (match_dup 9))))\n-   (parallel\n-    [(set (match_dup 3) (plus:SI (match_dup 3) (const_int -1)))\n-     (clobber (reg:CC CC_REGNUM))])\n-   (match_dup 9)]\n-  \"operands[3] = operand_subword (operands[0], 0, 0, DImode);\n-   operands[4] = operand_subword (operands[1], 0, 0, DImode);\n-   operands[5] = operand_subword (operands[2], 0, 0, DImode);\n-   operands[6] = operand_subword (operands[0], 1, 0, DImode);\n-   operands[7] = operand_subword (operands[1], 1, 0, DImode);\n-   operands[8] = operand_subword (operands[2], 1, 0, DImode);\n-   operands[9] = gen_label_rtx ();\")\n-\n ;\n ; subsi3 instruction pattern(s).\n ;\n@@ -6393,7 +6328,7 @@\n           (match_dup 1)))\n    (set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6409,7 +6344,7 @@\n                     (match_operand:GPR 2 \"general_operand\" \"d,T\"))\n           (match_dup 1)))\n    (clobber (match_scratch:GPR 0 \"=d,d\"))]\n-  \"s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6428,7 +6363,7 @@\n           (match_dup 2)))\n    (set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6443,7 +6378,7 @@\n                     (match_operand:GPR 2 \"general_operand\" \"d,T\"))\n           (match_dup 2)))\n    (clobber (match_scratch:GPR 0 \"=d,d\"))]\n-  \"s390_match_ccmode (insn, CCL1mode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6459,7 +6394,7 @@\n           (const_int 0)))\n    (set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n         (plus:GPR (plus:GPR (match_dup 3) (match_dup 1)) (match_dup 2)))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCLmode)\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6472,7 +6407,7 @@\n                             (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0\"))\n                   (match_operand:GPR 2 \"general_operand\" \"d,T\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"@\n    alc<g>r\\t%0,%2\n    alc<g>\\t%0,%2\"\n@@ -6488,7 +6423,7 @@\n           (const_int 0)))\n    (set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n         (minus:GPR (minus:GPR (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"s390_match_ccmode (insn, CCLmode) && TARGET_CPU_ZARCH\"\n+  \"s390_match_ccmode (insn, CCLmode)\"\n   \"@\n    slb<g>r\\t%0,%2\n    slb<g>\\t%0,%2\"\n@@ -6502,7 +6437,7 @@\n                               (match_operand:GPR 2 \"general_operand\" \"d,T\"))\n                    (match_operand:GPR 3 \"s390_slb_comparison\" \"\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"@\n    slb<g>r\\t%0,%2\n    slb<g>\\t%0,%2\"\n@@ -6514,7 +6449,7 @@\n    (match_operand 1 \"comparison_operator\" \"\")\n    (match_operand:GPR 2 \"register_operand\" \"\")\n    (match_operand:GPR 3 \"const_int_operand\" \"\")]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"if (!s390_expand_addcc (GET_CODE (operands[1]),\n \t\t\t   XEXP (operands[1], 0), XEXP (operands[1], 1),\n \t\t\t   operands[0], operands[2],\n@@ -6528,7 +6463,7 @@\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n         (match_operand:GPR 1 \"s390_alc_comparison\" \"\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (const_int 0))\n@@ -6542,7 +6477,7 @@\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n         (match_operand:GPR 1 \"s390_slb_comparison\" \"\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (const_int 0))\n@@ -6561,7 +6496,7 @@\n         (match_operator:SI 1 \"s390_scond_operator\"\n   \t [(match_operand:GPR 2 \"register_operand\" \"\")\n           (match_operand:GPR 3 \"general_operand\" \"\")]))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"if (!s390_expand_addcc (GET_CODE (operands[1]), operands[2], operands[3],\n \t\t\t   operands[0], const0_rtx, const1_rtx)) FAIL; DONE;\")\n \n@@ -6796,7 +6731,7 @@\n \t           (match_operand:<DWH> 1 \"register_operand\"     \"%0,0\"))\n                  (zero_extend:DW\n \t           (match_operand:<DWH> 2 \"nonimmediate_operand\" \" d,T\"))))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"@\n    ml<tg>r\\t%0,%2\n    ml<tg>\\t%0,%2\"\n@@ -7058,7 +6993,7 @@\n \t      (set (match_operand:SI 3 \"general_operand\" \"\")\n \t\t   (umod:SI (match_dup 1) (match_dup 2)))])\n    (clobber (match_dup 4))]\n-  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH\"\n {\n   rtx div_equal, mod_equal, equal;\n   rtx_insn *insn;\n@@ -7101,187 +7036,13 @@\n           (zero_extend:DI\n             (truncate:SI\n               (udiv:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))))]\n-  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH\"\n   \"@\n    dlr\\t%0,%2\n    dl\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RRE,RXY\")\n    (set_attr \"type\"     \"idiv\")])\n \n-(define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n-                 (match_operand:SI 2 \"general_operand\" \"\")))\n-   (clobber (match_dup 3))]\n-  \"!TARGET_ZARCH && !TARGET_CPU_ZARCH\"\n-{\n-  rtx udiv_equal, umod_equal, equal;\n-  rtx_insn *insn;\n-\n-  udiv_equal = gen_rtx_UDIV (SImode, operands[1], operands[2]);\n-  umod_equal = gen_rtx_UMOD (SImode, operands[1], operands[2]);\n-  equal = gen_rtx_IOR (DImode,\n-\t\t       gen_rtx_ASHIFT (DImode,\n-\t\t\t\t       gen_rtx_ZERO_EXTEND (DImode, umod_equal),\n-\t\t\t\t       GEN_INT (32)),\n-\t\t       gen_rtx_ZERO_EXTEND (DImode, udiv_equal));\n-\n-  operands[3] = gen_reg_rtx (DImode);\n-\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-        {\n-          rtx_code_label *label1 = gen_label_rtx ();\n-\n-\t  operands[1] = make_safe_from (operands[1], operands[0]);\n-          emit_move_insn (operands[0], const0_rtx);\n-\t  emit_cmp_and_jump_insns (operands[1], operands[2], LT, NULL_RTX,\n-\t\t\t\t   SImode, 1, label1);\n-          emit_move_insn (operands[0], const1_rtx);\n-          emit_label (label1);\n-        }\n-      else\n-        {\n-          operands[2] = force_reg (SImode, operands[2]);\n-          operands[2] = make_safe_from (operands[2], operands[0]);\n-\n-\t  emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n-\t  insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n-\t\t\t\t\t     operands[2]));\n-  \t  set_unique_reg_note (insn, REG_EQUAL, equal);\n-\n-\t  insn = emit_move_insn (operands[0],\n-\t\t\t\t gen_lowpart (SImode, operands[3]));\n-  \t  set_unique_reg_note (insn, REG_EQUAL, udiv_equal);\n-        }\n-    }\n-  else\n-    {\n-      rtx_code_label *label1 = gen_label_rtx ();\n-      rtx_code_label *label2 = gen_label_rtx ();\n-      rtx_code_label *label3 = gen_label_rtx ();\n-\n-      operands[1] = force_reg (SImode, operands[1]);\n-      operands[1] = make_safe_from (operands[1], operands[0]);\n-      operands[2] = force_reg (SImode, operands[2]);\n-      operands[2] = make_safe_from (operands[2], operands[0]);\n-\n-      emit_move_insn (operands[0], const0_rtx);\n-      emit_cmp_and_jump_insns (operands[2], operands[1], GT, NULL_RTX,\n-\t\t\t       SImode, 1, label3);\n-      emit_cmp_and_jump_insns (operands[2], const0_rtx, LT, NULL_RTX,\n-\t\t\t       SImode, 0, label2);\n-      emit_cmp_and_jump_insns (operands[2], const1_rtx, EQ, NULL_RTX,\n-\t\t\t       SImode, 0, label1);\n-      emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n-      insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n-\t\t\t\t\t operands[2]));\n-      set_unique_reg_note (insn, REG_EQUAL, equal);\n-\n-      insn = emit_move_insn (operands[0],\n-\t\t\t     gen_lowpart (SImode, operands[3]));\n-      set_unique_reg_note (insn, REG_EQUAL, udiv_equal);\n-\n-      emit_jump (label3);\n-      emit_label (label1);\n-      emit_move_insn (operands[0], operands[1]);\n-      emit_jump (label3);\n-      emit_label (label2);\n-      emit_move_insn (operands[0], const1_rtx);\n-      emit_label (label3);\n-    }\n-  emit_move_insn (operands[0], operands[0]);\n-  DONE;\n-})\n-\n-(define_expand \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (umod:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-                 (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n-   (clobber (match_dup 3))]\n-  \"!TARGET_ZARCH && !TARGET_CPU_ZARCH\"\n-{\n-  rtx udiv_equal, umod_equal, equal;\n-  rtx_insn *insn;\n-\n-  udiv_equal = gen_rtx_UDIV (SImode, operands[1], operands[2]);\n-  umod_equal = gen_rtx_UMOD (SImode, operands[1], operands[2]);\n-  equal = gen_rtx_IOR (DImode,\n-\t\t       gen_rtx_ASHIFT (DImode,\n-\t\t\t\t       gen_rtx_ZERO_EXTEND (DImode, umod_equal),\n-\t\t\t\t       GEN_INT (32)),\n-\t\t       gen_rtx_ZERO_EXTEND (DImode, udiv_equal));\n-\n-  operands[3] = gen_reg_rtx (DImode);\n-\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) <= 0)\n-        {\n-          rtx_code_label *label1 = gen_label_rtx ();\n-\n-          operands[1] = make_safe_from (operands[1], operands[0]);\n-\t  emit_move_insn (operands[0], operands[1]);\n-          emit_cmp_and_jump_insns (operands[0], operands[2], LT, NULL_RTX,\n-\t\t\t           SImode, 1, label1);\n-\t  emit_insn (gen_abssi2 (operands[0], operands[2]));\n-          emit_insn (gen_addsi3 (operands[0], operands[0], operands[1]));\n-          emit_label (label1);\n-        }\n-      else\n-        {\n-          operands[2] = force_reg (SImode, operands[2]);\n-          operands[2] = make_safe_from (operands[2], operands[0]);\n-\n-\t  emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n-\t  insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n-\t\t\t\t\t     operands[2]));\n-\t  set_unique_reg_note (insn, REG_EQUAL, equal);\n-\n-\t  insn = emit_move_insn (operands[0],\n-\t\t\t\t gen_highpart (SImode, operands[3]));\n-\t  set_unique_reg_note (insn, REG_EQUAL, umod_equal);\n-        }\n-    }\n-  else\n-    {\n-      rtx_code_label *label1 = gen_label_rtx ();\n-      rtx_code_label *label2 = gen_label_rtx ();\n-      rtx_code_label *label3 = gen_label_rtx ();\n-\n-      operands[1] = force_reg (SImode, operands[1]);\n-      operands[1] = make_safe_from (operands[1], operands[0]);\n-      operands[2] = force_reg (SImode, operands[2]);\n-      operands[2] = make_safe_from (operands[2], operands[0]);\n-\n-      emit_move_insn(operands[0], operands[1]);\n-      emit_cmp_and_jump_insns (operands[2], operands[1], GT, NULL_RTX,\n-\t\t\t       SImode, 1, label3);\n-      emit_cmp_and_jump_insns (operands[2], const0_rtx, LT, NULL_RTX,\n-\t\t\t       SImode, 0, label2);\n-      emit_cmp_and_jump_insns (operands[2], const1_rtx, EQ, NULL_RTX,\n-\t\t\t       SImode, 0, label1);\n-      emit_insn (gen_zero_extendsidi2 (operands[3], operands[1]));\n-      insn = emit_insn (gen_divmoddisi3 (operands[3], operands[3],\n-\t\t\t\t\t operands[2]));\n-      set_unique_reg_note (insn, REG_EQUAL, equal);\n-\n-      insn = emit_move_insn (operands[0],\n-\t\t\t     gen_highpart (SImode, operands[3]));\n-      set_unique_reg_note (insn, REG_EQUAL, umod_equal);\n-\n-      emit_jump (label3);\n-      emit_label (label1);\n-      emit_move_insn (operands[0], const0_rtx);\n-      emit_jump (label3);\n-      emit_label (label2);\n-      emit_insn (gen_subsi3 (operands[0], operands[0], operands[2]));\n-      emit_label (label3);\n-    }\n-  DONE;\n-})\n-\n ;\n ; div(df|sf)3 instruction pattern(s).\n ;\n@@ -8888,15 +8649,15 @@\n   [(set (match_operand:GPR 0 \"register_operand\" \"\")\n         (rotate:GPR (match_operand:GPR 1 \"register_operand\" \"\")\n \t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"\")\n \n ; rll, rllg\n (define_insn \"*rotl<mode>3<addr_style_op><masked_op>\"\n   [(set (match_operand:GPR             0 \"register_operand\"  \"=d\")\n \t(rotate:GPR (match_operand:GPR 1 \"register_operand\"   \"d\")\n \t\t    (match_operand:SI  2 \"nonmemory_operand\" \"an\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"rll<g>\\t%0,%1,<addr_style_op_ops>\"\n   [(set_attr \"op_type\"  \"RSE\")\n    (set_attr \"atype\"    \"reg\")\n@@ -9042,7 +8803,7 @@\n \t\t\t\t\t       (match_operand 2 \"const_int_operand\" \"\")])\n           (label_ref (match_operand 0 \"\" \"\"))\n           (pc)))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (get_attr_length (insn) == 4)\n     return \"j%C1\\t%l0\";\n@@ -9055,27 +8816,6 @@\n         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                       (const_int 4) (const_int 6)))])\n \n-(define_insn \"*cjump_31\"\n-  [(set (pc)\n-        (if_then_else\n-          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM)\n-\t\t\t\t\t       (match_operand 2 \"const_int_operand\" \"\")])\n-          (label_ref (match_operand 0 \"\" \"\"))\n-          (pc)))]\n-  \"!TARGET_CPU_ZARCH\"\n-{\n-  gcc_assert (get_attr_length (insn) == 4);\n-  return \"j%C1\\t%l0\";\n-}\n-  [(set_attr \"op_type\" \"RI\")\n-   (set_attr \"type\"    \"branch\")\n-   (set (attr \"length\")\n-        (if_then_else (not (match_test \"flag_pic\"))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 6))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 8))))])\n-\n (define_insn \"*cjump_long\"\n   [(set (pc)\n         (if_then_else\n@@ -9139,7 +8879,7 @@\n           (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n           (pc)\n           (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (get_attr_length (insn) == 4)\n     return \"j%D1\\t%l0\";\n@@ -9152,26 +8892,6 @@\n         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                       (const_int 4) (const_int 6)))])\n \n-(define_insn \"*icjump_31\"\n-  [(set (pc)\n-        (if_then_else\n-          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n-          (pc)\n-          (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"!TARGET_CPU_ZARCH\"\n-{\n-  gcc_assert (get_attr_length (insn) == 4);\n-  return \"j%D1\\t%l0\";\n-}\n-  [(set_attr \"op_type\" \"RI\")\n-   (set_attr \"type\"    \"branch\")\n-   (set (attr \"length\")\n-        (if_then_else (not (match_test \"flag_pic\"))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 6))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 8))))])\n-\n (define_insn \"*icjump_long\"\n   [(set (pc)\n         (if_then_else\n@@ -9307,7 +9027,7 @@\n    (set (match_operand:GPR 4 \"nonimmediate_operand\" \"\")\n         (plus:GPR (match_dup 1) (match_dup 2)))\n    (clobber (match_scratch:GPR 5 \"\"))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"#\"\n   \"!reload_completed && !reload_in_progress\"\n   [(set (match_dup 7) (match_dup 2)) ; the increment\n@@ -9433,7 +9153,7 @@\n \t\t (subreg:SI (match_dup 2) 0)))\n    (clobber (match_scratch:SI 4 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_ZARCH && TARGET_CPU_ZARCH\"\n+  \"!TARGET_ZARCH\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -9468,9 +9188,7 @@\n    (use (match_operand 1 \"\" \"\"))]       ; label\n   \"\"\n {\n-  if (GET_MODE (operands[0]) == SImode && !TARGET_CPU_ZARCH)\n-    emit_jump_insn (gen_doloop_si31 (operands[1], operands[0], operands[0]));\n-  else if (GET_MODE (operands[0]) == SImode && TARGET_CPU_ZARCH)\n+  if (GET_MODE (operands[0]) == SImode)\n     emit_jump_insn (gen_doloop_si64 (operands[1], operands[0], operands[0]));\n   else if (GET_MODE (operands[0]) == DImode && TARGET_ZARCH)\n     emit_jump_insn (gen_doloop_di (operands[1], operands[0], operands[0]));\n@@ -9491,7 +9209,7 @@\n         (plus:SI (match_dup 1) (const_int -1)))\n    (clobber (match_scratch:SI 3 \"=X,&1,&?d\"))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (which_alternative != 0)\n     return \"#\";\n@@ -9522,77 +9240,6 @@\n         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                       (const_int 4) (const_int 10)))])\n \n-(define_insn_and_split \"doloop_si31\"\n-  [(set (pc)\n-        (if_then_else\n-          (ne (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n-              (const_int 1))\n-          (label_ref (match_operand 0 \"\" \"\"))\n-          (pc)))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,?X,?X\")\n-        (plus:SI (match_dup 1) (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"=X,&1,&?d\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_CPU_ZARCH\"\n-{\n-  if (which_alternative != 0)\n-    return \"#\";\n-  else if (get_attr_length (insn) == 4)\n-    return \"brct\\t%1,%l0\";\n-  else\n-    gcc_unreachable ();\n-}\n-  \"&& reload_completed\n-   && (! REG_P (operands[2])\n-       || ! rtx_equal_p (operands[1], operands[2]))\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (parallel [(set (reg:CCAN CC_REGNUM)\n-                   (compare:CCAN (plus:SI (match_dup 3) (const_int -1))\n-                                 (const_int 0)))\n-              (set (match_dup 3) (plus:SI (match_dup 3) (const_int -1)))])\n-   (set (match_dup 2) (match_dup 3))\n-   (set (pc) (if_then_else (ne (reg:CCAN CC_REGNUM) (const_int 0))\n-                           (label_ref (match_dup 0))\n-                           (pc)))]\n-  \"\"\n-  [(set_attr \"op_type\"  \"RI\")\n-   ; Strictly speaking, the z10 properties are valid for brct only, however, it does not\n-   ; hurt us in the (rare) case of ahi.\n-   (set_attr \"z10prop\"  \"z10_super_E1\")\n-   (set_attr \"type\"  \"branch\")\n-   (set (attr \"length\")\n-        (if_then_else (not (match_test \"flag_pic\"))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 6))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 8))))])\n-\n-(define_insn \"*doloop_si_long\"\n-  [(set (pc)\n-        (if_then_else\n-          (ne (match_operand:SI 1 \"register_operand\" \"d\")\n-              (const_int 1))\n-          (match_operand 0 \"address_operand\" \"ZR\")\n-          (pc)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=1\")\n-        (plus:SI (match_dup 1) (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"=X\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"!TARGET_CPU_ZARCH\"\n-{\n-  if (get_attr_op_type (insn) == OP_TYPE_RR)\n-    return \"bctr\\t%1,%0\";\n-  else\n-    return \"bct\\t%1,%a0\";\n-}\n-  [(set (attr \"op_type\")\n-        (if_then_else (match_operand 0 \"register_operand\" \"\")\n-                      (const_string \"RR\") (const_string \"RX\")))\n-   (set_attr \"type\"  \"branch\")\n-   (set_attr \"atype\" \"agen\")\n-   (set_attr \"z10prop\"  \"z10_c\")\n-   (set_attr \"z196prop\" \"z196_cracked\")])\n-\n (define_insn_and_split \"doloop_di\"\n   [(set (pc)\n         (if_then_else\n@@ -9650,7 +9297,7 @@\n \n (define_insn \"*jump64\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (get_attr_length (insn) == 4)\n     return \"j\\t%l0\";\n@@ -9663,22 +9310,6 @@\n         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                       (const_int 4) (const_int 6)))])\n \n-(define_insn \"*jump31\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"!TARGET_CPU_ZARCH\"\n-{\n-  gcc_assert (get_attr_length (insn) == 4);\n-  return \"j\\t%l0\";\n-}\n-  [(set_attr \"op_type\" \"RI\")\n-   (set_attr \"type\"  \"branch\")\n-   (set (attr \"length\")\n-        (if_then_else (not (match_test \"flag_pic\"))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 6))\n-          (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                        (const_int 4) (const_int 8))))])\n-\n ;\n ; indirect-jump instruction pattern(s).\n ;\n@@ -10147,7 +9778,7 @@\n (define_insn \"*sibcall_brcl\"\n   [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))]\n-  \"SIBLING_CALL_P (insn) && TARGET_CPU_ZARCH\"\n+  \"SIBLING_CALL_P (insn)\"\n   \"jg\\t%0\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"branch\")])\n@@ -10209,7 +9840,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n \t      (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"SIBLING_CALL_P (insn) && TARGET_CPU_ZARCH\"\n+  \"SIBLING_CALL_P (insn)\"\n   \"jg\\t%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"branch\")])\n@@ -10247,7 +9878,7 @@\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n   \"!SIBLING_CALL_P (insn)\n-   && TARGET_CPU_ZARCH\n+\n    && GET_MODE (operands[2]) == Pmode\"\n   \"brasl\\t%2,%0\"\n   [(set_attr \"op_type\" \"RIL\")\n@@ -10353,7 +9984,7 @@\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n   \"!SIBLING_CALL_P (insn)\n-   && TARGET_CPU_ZARCH\n+\n    && GET_MODE (operands[3]) == Pmode\"\n   \"brasl\\t%3,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n@@ -10496,7 +10127,7 @@\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))\n    (use (match_operand 4 \"\" \"\"))]\n   \"!SIBLING_CALL_P (insn)\n-   && TARGET_CPU_ZARCH\n+\n    && GET_MODE (operands[3]) == Pmode\"\n   \"brasl\\t%3,%1%J4\"\n   [(set_attr \"op_type\" \"RIL\")\n@@ -11034,7 +10665,7 @@\n \n (define_insn \"nop_6_byte\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_NOP_6_BYTE)]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"brcl\\t0, 0\"\n   [(set_attr \"op_type\" \"RIL\")])\n \n@@ -11082,28 +10713,10 @@\n }\n   [(set_attr \"length\" \"0\")])\n \n-(define_insn \"main_base_31_small\"\n-  [(set (match_operand 0 \"register_operand\" \"=a\")\n-        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n-  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n-  \"basr\\t%0,0\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"la\")\n-   (set_attr \"z196prop\" \"z196_cracked\")])\n-\n-(define_insn \"main_base_31_large\"\n-  [(set (match_operand 0 \"register_operand\" \"=a\")\n-        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))\n-   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n-  \"bras\\t%0,%2\"\n-  [(set_attr \"op_type\" \"RI\")\n-   (set_attr \"z196prop\" \"z196_cracked\")])\n-\n (define_insn \"main_base_64\"\n   [(set (match_operand 0 \"register_operand\" \"=a\")\n         (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n-  \"TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n+  \"GET_MODE (operands[0]) == Pmode\"\n   \"larl\\t%0,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"larl\")\n@@ -11117,22 +10730,12 @@\n   gcc_unreachable ();\n }\n   [(set (attr \"type\")\n-        (if_then_else (match_test \"TARGET_CPU_ZARCH\")\n-                      (const_string \"larl\") (const_string \"la\")))])\n-\n-(define_insn \"reload_base_31\"\n-  [(set (match_operand 0 \"register_operand\" \"=a\")\n-        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n-  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n-  \"basr\\t%0,0\\;la\\t%0,%1-.(%0)\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"type\" \"la\")\n-   (set_attr \"z196prop\" \"z196_cracked\")])\n+        (const_string \"larl\"))])\n \n (define_insn \"reload_base_64\"\n   [(set (match_operand 0 \"register_operand\" \"=a\")\n         (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n-  \"TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n+  \"GET_MODE (operands[0]) == Pmode\"\n   \"larl\\t%0,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"larl\")\n@@ -11416,7 +11019,7 @@\n (define_insn \"bswap<mode>2\"\n   [(set (match_operand:GPR 0            \"nonimmediate_operand\" \"=d,d,T\")\n \t(bswap:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \" d,T,d\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"@\n    lrv<g>r\\t%0,%1\n    lrv<g>\\t%0,%1\n@@ -11428,7 +11031,7 @@\n (define_insn \"bswaphi2\"\n   [(set (match_operand:HI 0           \"nonimmediate_operand\" \"=d,d,T\")\n \t(bswap:HI (match_operand:HI 1 \"nonimmediate_operand\" \" d,T,d\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"@\n    #\n    lrvh\\t%0,%1\n@@ -11440,7 +11043,7 @@\n (define_split\n   [(set (match_operand:HI 0           \"register_operand\" \"\")\n \t(bswap:HI (match_operand:HI 1 \"register_operand\" \"\")))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   [(set (match_dup 2) (bswap:SI (match_dup 3)))\n    (set (match_dup 2) (lshiftrt:SI (match_dup 2) (const_int 16)))]\n {\n@@ -11878,7 +11481,7 @@\n \t\t     (match_operand 2 \"const_int_operand\" \"X\")\n \t\t     (match_operand 3 \"const_int_operand\" \"X\")]\n \t\t    UNSPECV_SPLIT_STACK_DATA)]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   switch_to_section (targetm.asm_out.function_rodata_section\n \t\t (current_function_decl));\n@@ -11913,7 +11516,7 @@\n (define_expand \"split_stack_call\"\n   [(match_operand 0 \"bras_sym_operand\" \"X\")\n    (match_operand 1 \"\" \"\")]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (TARGET_64BIT)\n     emit_jump_insn (gen_split_stack_call_di (operands[0], operands[1]));\n@@ -11927,7 +11530,7 @@\n    (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n \t\t\t\t    (reg:P 1)]\n \t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"jg\\t%0\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"  \"branch\")])\n@@ -11938,7 +11541,7 @@\n   [(match_operand 0 \"bras_sym_operand\" \"X\")\n    (match_operand 1 \"\" \"\")\n    (match_operand 2 \"\" \"\")]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n {\n   if (TARGET_64BIT)\n     emit_jump_insn (gen_split_stack_cond_call_di (operands[0], operands[1], operands[2]));\n@@ -11956,7 +11559,7 @@\n    (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n \t\t\t\t    (reg:P 1)]\n \t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n-  \"TARGET_CPU_ZARCH\"\n+  \"\"\n   \"jg%C1\\t%0\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"  \"branch\")])"}]}