{"sha": "3f2906e5e4fccc2bc6d848a43be7e569036641e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyOTA2ZTVlNGZjY2MyYmM2ZDg0OGE0M2JlN2U1NjkwMzY2NDFlNg==", "commit": {"author": {"name": "Yizhe", "email": "yizhe@pku.edu.cn", "date": "2021-02-16T12:34:03Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-19T10:34:59Z"}, "message": "Added some doc for BaseRules and BaseType", "tree": {"sha": "bb1b4465a446dffbbfb91707fce4325e7d673fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb1b4465a446dffbbfb91707fce4325e7d673fea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f2906e5e4fccc2bc6d848a43be7e569036641e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2906e5e4fccc2bc6d848a43be7e569036641e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2906e5e4fccc2bc6d848a43be7e569036641e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2906e5e4fccc2bc6d848a43be7e569036641e6/comments", "author": {"login": "YizhePKU", "id": 42838469, "node_id": "MDQ6VXNlcjQyODM4NDY5", "avatar_url": "https://avatars.githubusercontent.com/u/42838469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YizhePKU", "html_url": "https://github.com/YizhePKU", "followers_url": "https://api.github.com/users/YizhePKU/followers", "following_url": "https://api.github.com/users/YizhePKU/following{/other_user}", "gists_url": "https://api.github.com/users/YizhePKU/gists{/gist_id}", "starred_url": "https://api.github.com/users/YizhePKU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YizhePKU/subscriptions", "organizations_url": "https://api.github.com/users/YizhePKU/orgs", "repos_url": "https://api.github.com/users/YizhePKU/repos", "events_url": "https://api.github.com/users/YizhePKU/events{/privacy}", "received_events_url": "https://api.github.com/users/YizhePKU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59ce2a981b15c22ab8311aa241cf5d80eada9fbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ce2a981b15c22ab8311aa241cf5d80eada9fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ce2a981b15c22ab8311aa241cf5d80eada9fbd"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "be13f0db5e251bb05bc1fd42252ad23a3205a661", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2906e5e4fccc2bc6d848a43be7e569036641e6/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2906e5e4fccc2bc6d848a43be7e569036641e6/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=3f2906e5e4fccc2bc6d848a43be7e569036641e6", "patch": "@@ -28,11 +28,33 @@\n namespace Rust {\n namespace TyTy {\n \n+/* Rules specify how to unify two Ty. For example, the result of unifying the\n+   two tuples (u64, A) and (B, i64) would be (u64, i64).\n+\n+   Performing a unification requires a double dispatch. To illustrate, suppose\n+   we want to unify `ty1` and `ty2`. Here's what it looks like:\n+     1. The caller calls `ty1.unify(ty2)`. This is the first dispatch.\n+     2. `ty1` creates a rule specific to its type(e.g. TupleRules).\n+     3. The rule calls `ty2.accept_vis(rule)`. This is the second dispatch.\n+     4. `ty2` calls `rule.visit(*this)`, which will method-overload to the\n+\t      correct implementation at compile time.\n+\n+   The nice thing about Rules is that they seperate unification logic from the\n+   representation of Ty. To support unifying a new Ty, implement its\n+   `accept_vis` and `unify` method to pass the unification request to Rules.\n+   Then, create a new `XXXRules` class and implement one `visit` method for\n+   every Ty it can unify with. */\n class BaseRules : public TyVisitor\n {\n public:\n   virtual ~BaseRules () {}\n \n+  /* Unify two ty. Returns a pointer to the newly-created unified ty, or nullptr\n+     if the two types cannot be unified. The caller is responsible for releasing\n+     the memory of the returned ty.\n+\n+     This method is meant to be used internally by Ty. If you're trying to unify\n+     two ty, you can simply call `unify` on ty themselves. */\n   BaseType *unify (BaseType *other)\n   {\n     other->accept_vis (*this);\n@@ -194,7 +216,13 @@ class BaseRules : public TyVisitor\n   Analysis::Mappings *mappings;\n   Resolver::TypeCheckContext *context;\n \n+  /* Pointer to the Ty that created this rule. */\n   BaseType *base;\n+\n+  /* Temporary storage for the result of a unification.\n+     We could return the result directly instead of storing it in the rule\n+     object, but that involves modifying the visitor pattern to accommodate\n+     the return value, which is too complex. */\n   BaseType *resolved;\n };\n "}, {"sha": "4b0ac86fcb4d894e9c7a8750848c47a3cfa5ae2c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f2906e5e4fccc2bc6d848a43be7e569036641e6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f2906e5e4fccc2bc6d848a43be7e569036641e6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=3f2906e5e4fccc2bc6d848a43be7e569036641e6", "patch": "@@ -63,16 +63,22 @@ class BaseType\n \n   void set_ty_ref (HirId id) { ty_ref = id; }\n \n+  /* Visitor pattern for double dispatch. BaseRules implements TyVisitor. */\n   virtual void accept_vis (TyVisitor &vis) = 0;\n \n   virtual std::string as_string () const = 0;\n \n+  /* Unify two types. Returns a pointer to the newly-created unified ty, or\n+     nullptr if the two ty cannot be unified. The caller is responsible for\n+     releasing the memory of the returned ty. */\n   virtual BaseType *unify (BaseType *other) = 0;\n \n   virtual bool is_unit () const { return kind == TypeKind::UNIT; }\n \n   TypeKind get_kind () const { return kind; }\n \n+  /* Returns a pointer to a clone of this. The caller is responsible for\n+   * releasing the memory of the returned ty. */\n   virtual BaseType *clone () = 0;\n \n   std::set<HirId> get_combined_refs () { return combined; }\n@@ -81,7 +87,7 @@ class BaseType\n \n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n-\t  std::set<HirId> refs = std::set<HirId> ())\n+\t    std::set<HirId> refs = std::set<HirId> ())\n     : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs)\n   {}\n \n@@ -323,7 +329,8 @@ class FnType : public BaseType\n   FnType (HirId ref, HirId ty_ref,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FNDEF, refs), params (params), type (type)\n+    : BaseType (ref, ty_ref, TypeKind::FNDEF, refs), params (params),\n+      type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;"}]}