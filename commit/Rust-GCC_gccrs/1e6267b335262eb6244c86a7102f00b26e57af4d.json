{"sha": "1e6267b335262eb6244c86a7102f00b26e57af4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2MjY3YjMzNTI2MmViNjI0NGM4NmE3MTAyZjAwYjI2ZTU3YWY0ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T07:58:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-02T07:58:46Z"}, "message": "Revert \"tree-optimization/102155 - fix LIM fill_always_executed_in CFG walk\"\n\nThis reverts commit f482bf2af86990329b4df660f8c1eb9e094de9f9.", "tree": {"sha": "a0a7cbfe2331cf9f7e66e2550f5fc04ce7bf5e9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0a7cbfe2331cf9f7e66e2550f5fc04ce7bf5e9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e6267b335262eb6244c86a7102f00b26e57af4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6267b335262eb6244c86a7102f00b26e57af4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6267b335262eb6244c86a7102f00b26e57af4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6267b335262eb6244c86a7102f00b26e57af4d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b387e664cfa4e9dd010a3f64d446308d6d84a5d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b387e664cfa4e9dd010a3f64d446308d6d84a5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b387e664cfa4e9dd010a3f64d446308d6d84a5d2"}], "stats": {"total": 136, "additions": 63, "deletions": 73}, "files": [{"sha": "d9f75d5025ee9f69fbd2ac1c46a31b52338c95de", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 63, "deletions": 73, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6267b335262eb6244c86a7102f00b26e57af4d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6267b335262eb6244c86a7102f00b26e57af4d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=1e6267b335262eb6244c86a7102f00b26e57af4d", "patch": "@@ -3025,88 +3025,92 @@ do_store_motion (void)\n /* Fills ALWAYS_EXECUTED_IN information for basic blocks of LOOP, i.e.\n    for each such basic block bb records the outermost loop for that execution\n    of its header implies execution of bb.  CONTAINS_CALL is the bitmap of\n-   blocks that contain a nonpure call.  The blocks of LOOP start at index\n-   START of the RPO array of size N.  */\n+   blocks that contain a nonpure call.  */\n \n static void\n-fill_always_executed_in_1 (function *fun, class loop *loop,\n-\t\t\t   int *rpo, int start, int n, sbitmap contains_call)\n+fill_always_executed_in_1 (class loop *loop, sbitmap contains_call)\n {\n-  basic_block last = NULL;\n+  basic_block bb = NULL, *bbs, last = NULL;\n+  unsigned i;\n+  edge e;\n   class loop *inn_loop = loop;\n \n-  for (int i = start; i < n; i++)\n+  if (ALWAYS_EXECUTED_IN (loop->header) == NULL)\n     {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n-      /* Stop when we iterated over all blocks in this loop.  */\n-      if (!flow_bb_inside_loop_p (loop, bb))\n-\tbreak;\n+      bbs = get_loop_body_in_dom_order (loop);\n \n-      if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n-\tlast = bb;\n+      for (i = 0; i < loop->num_nodes; i++)\n+\t{\n+\t  edge_iterator ei;\n+\t  bb = bbs[i];\n \n-      if (bitmap_bit_p (contains_call, bb->index))\n-\tbreak;\n+\t  if (dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\t    last = bb;\n \n-      edge_iterator ei;\n-      edge e;\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  /* If there is an exit from this BB.  */\n-\t  if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t  if (bitmap_bit_p (contains_call, bb->index))\n \t    break;\n-\t  /* Or we enter a possibly non-finite loop.  */\n-\t  if (flow_loop_nested_p (bb->loop_father,\n-\t\t\t\t  e->dest->loop_father)\n-\t      && ! finite_loop_p (e->dest->loop_father))\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      /* If there is an exit from this BB.  */\n+\t      if (!flow_bb_inside_loop_p (loop, e->dest))\n+\t\tbreak;\n+\t      /* Or we enter a possibly non-finite loop.  */\n+\t      if (flow_loop_nested_p (bb->loop_father,\n+\t\t\t\t      e->dest->loop_father)\n+\t\t  && ! finite_loop_p (e->dest->loop_father))\n+\t\tbreak;\n+\t    }\n+\t  if (e)\n \t    break;\n-\t}\n-      if (e)\n-\tbreak;\n \n-      /* A loop might be infinite (TODO use simple loop analysis\n-\t to disprove this if possible).  */\n-      if (bb->flags & BB_IRREDUCIBLE_LOOP)\n-\tbreak;\n+\t  /* A loop might be infinite (TODO use simple loop analysis\n+\t     to disprove this if possible).  */\n+\t  if (bb->flags & BB_IRREDUCIBLE_LOOP)\n+\t    break;\n \n-      if (!flow_bb_inside_loop_p (inn_loop, bb))\n-\tbreak;\n+\t  if (!flow_bb_inside_loop_p (inn_loop, bb))\n+\t    break;\n+\n+\t  if (bb->loop_father->header == bb)\n+\t    {\n+\t      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\t\tbreak;\n+\n+\t      /* In a loop that is always entered we may proceed anyway.\n+\t\t But record that we entered it and stop once we leave it.  */\n+\t      inn_loop = bb->loop_father;\n+\t    }\n+\t}\n \n-      if (bb->loop_father->header == bb)\n+      while (1)\n \t{\n-\t  if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\t  SET_ALWAYS_EXECUTED_IN (last, loop);\n+\t  if (last == loop->header)\n \t    break;\n-\n-\t  /* In a loop that is always entered we may proceed anyway.\n-\t     But record that we entered it and stop once we leave it.  */\n-\t  inn_loop = bb->loop_father;\n+\t  last = get_immediate_dominator (CDI_DOMINATORS, last);\n \t}\n-    }\n \n-  while (1)\n-    {\n-      SET_ALWAYS_EXECUTED_IN (last, loop);\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_NOTE, \"bb %d is always executed in loop %d\\n\",\n-\t\t     last->index, loop->num);\n-      if (last == loop->header)\n-\tbreak;\n-      last = get_immediate_dominator (CDI_DOMINATORS, last);\n+      free (bbs);\n     }\n+\n+  for (loop = loop->inner; loop; loop = loop->next)\n+    fill_always_executed_in_1 (loop, contains_call);\n }\n \n /* Fills ALWAYS_EXECUTED_IN information for basic blocks, i.e.\n    for each such basic block bb records the outermost loop for that execution\n    of its header implies execution of bb.  */\n \n static void\n-fill_always_executed_in (function *fun, int *rpo, int n)\n+fill_always_executed_in (void)\n {\n   basic_block bb;\n+  class loop *loop;\n \n-  auto_sbitmap contains_call (last_basic_block_for_fn (fun));\n+  auto_sbitmap contains_call (last_basic_block_for_fn (cfun));\n   bitmap_clear (contains_call);\n-  FOR_EACH_BB_FN (bb, fun)\n+  FOR_EACH_BB_FN (bb, cfun)\n     {\n       gimple_stmt_iterator gsi;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -3119,18 +3123,8 @@ fill_always_executed_in (function *fun, int *rpo, int n)\n \tbitmap_set_bit (contains_call, bb->index);\n     }\n \n-  /* The RPO order we iterate over is one that visits all blocks of a CFG\n-     cycle before leaving it.  That means we can visit a loop once we\n-     run into its header and we can skip it if it was determined as always\n-     entering when proccessing the containing loop.  */\n-  for (int i = 0; i < n; ++i)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i]);\n-      if (bb->loop_father->header == bb\n-\t  && !ALWAYS_EXECUTED_IN (bb))\n-\tfill_always_executed_in_1 (fun, bb->loop_father,\n-\t\t\t\t   rpo, i, n, contains_call);\n-    }\n+  for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n+    fill_always_executed_in_1 (loop, contains_call);\n }\n \n \n@@ -3233,27 +3227,23 @@ loop_invariant_motion_in_fun (function *fun, bool store_motion)\n   /* Gathers information about memory accesses in the loops.  */\n   analyze_memory_references (store_motion);\n \n-  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun) - NUM_FIXED_BLOCKS);\n-  auto_bitmap exit_bbs;\n-  bitmap_set_bit (exit_bbs, EXIT_BLOCK);\n-  edge entry = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (fun));\n-  int n = rev_post_order_and_mark_dfs_back_seme (fun, entry, exit_bbs, true,\n-\t\t\t\t\t\t rpo, NULL);\n-\n   /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n-  fill_always_executed_in (fun, rpo, n);\n+  fill_always_executed_in ();\n+\n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n+  int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n \n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n   for (int i = 0; i < n; ++i)\n     compute_invariantness (BASIC_BLOCK_FOR_FN (fun, rpo[i]));\n-  free (rpo);\n \n   /* Execute store motion.  Force the necessary invariants to be moved\n      out of the loops as well.  */\n   if (store_motion)\n     do_store_motion ();\n \n+  free (rpo);\n   rpo = XNEWVEC (int, last_basic_block_for_fn (fun));\n   n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n "}]}