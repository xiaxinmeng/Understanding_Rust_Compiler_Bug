{"sha": "02424cf671eeee25ca371d17eef4a65c71de8eee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI0MjRjZjY3MWVlZWUyNWNhMzcxZDE3ZWVmNGE2NWM3MWRlOGVlZQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-07-28T22:00:55Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-11T09:31:10Z"}, "message": "Pass pratt parsed location to expr parser functions to fix expr locus\n\nThe pratt parser skips the first token of an expression before\ninvoking the actual expression parsing function. This makes getting\nthe correct starting location of a pratt parsed expression hard. The\n\"correction\" of the location by subtracting an integer is often wrong\n(since there may be arbitrary whitespace or comments between\ntokens). Fix this by passing the location of the skipped token to the\nexpression parsing functions (instead of just providing a pratt_parse\nboolean). Use this location to set the start of the expression (and as\nindicator to not try to parse the first token of the expression).\n\nBefore gccrs would generate the following error message:\n\nreturn.rs:3:22: error: cannot \u2018break\u2019 outside of a loop\n    3 |     let x = 5 - break return (16 + 2);\n      |                      ^~~~~~~~~~~~~~~~~\n\nNow we get:\n\nreturn.rs:3:17: error: cannot \u2018break\u2019 outside of a loop\n    3 |     let x = 5 - break return (16 + 2);\n      |                 ^", "tree": {"sha": "ba6ff3a0b5287855dab4347726cf27d0061912c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba6ff3a0b5287855dab4347726cf27d0061912c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02424cf671eeee25ca371d17eef4a65c71de8eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02424cf671eeee25ca371d17eef4a65c71de8eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02424cf671eeee25ca371d17eef4a65c71de8eee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02424cf671eeee25ca371d17eef4a65c71de8eee/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e10f3d65566101c774a308f8286e2827455941ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10f3d65566101c774a308f8286e2827455941ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10f3d65566101c774a308f8286e2827455941ed"}], "stats": {"total": 249, "additions": 104, "deletions": 145}, "files": [{"sha": "c94c637e45cf841ba92ef192a6afeafb96ffddd1", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 60, "deletions": 117, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02424cf671eeee25ca371d17eef4a65c71de8eee/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02424cf671eeee25ca371d17eef4a65c71de8eee/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=02424cf671eeee25ca371d17eef4a65c71de8eee", "patch": "@@ -6586,7 +6586,7 @@ Parser<ManagedTokenSource>::parse_path_expr_segment ()\n template <typename ManagedTokenSource>\n AST::QualifiedPathInExpression\n Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n-  bool pratt_parse)\n+  Location pratt_parsed_loc)\n {\n   /* Note: the Rust grammar is defined in such a way that it is impossible to\n    * determine whether a prospective qualified path is a\n@@ -6601,7 +6601,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n \n   // parse the qualified path type (required)\n   AST::QualifiedPathType qual_path_type\n-    = parse_qualified_path_type (pratt_parse);\n+    = parse_qualified_path_type (pratt_parsed_loc);\n   if (qual_path_type.is_error ())\n     {\n       // TODO: should this create a parse error?\n@@ -6667,12 +6667,13 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_expression (\n // Parses the type syntactical construction at the start of a qualified path.\n template <typename ManagedTokenSource>\n AST::QualifiedPathType\n-Parser<ManagedTokenSource>::parse_qualified_path_type (bool pratt_parse)\n+Parser<ManagedTokenSource>::parse_qualified_path_type (\n+  Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n+  Location locus = pratt_parsed_loc;\n   /* TODO: should this actually be error? is there anywhere where this could be\n    * valid? */\n-  if (!pratt_parse)\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n       if (!skip_token (LEFT_ANGLE))\n@@ -6681,11 +6682,6 @@ Parser<ManagedTokenSource>::parse_qualified_path_type (bool pratt_parse)\n \t  return AST::QualifiedPathType::create_error ();\n \t}\n     }\n-  else\n-    {\n-      // move back by 1 if pratt parsing due to skipping '<'\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   // parse type (required)\n   std::unique_ptr<AST::Type> type = parse_type ();\n@@ -7311,10 +7307,10 @@ Parser<ManagedTokenSource>::parse_expr_without_block (AST::AttrVec outer_attrs)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BlockExpr>\n Parser<ManagedTokenSource>::parse_block_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t      bool pratt_parse)\n+\t\t\t\t\t      Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n       if (!skip_token (LEFT_CURLY))\n@@ -7323,10 +7319,6 @@ Parser<ManagedTokenSource>::parse_block_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n     }\n-  else\n-    {\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   AST::AttrVec inner_attrs = parse_inner_attributes ();\n \n@@ -7618,21 +7610,14 @@ Parser<ManagedTokenSource>::parse_literal_expr (AST::AttrVec outer_attrs)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ReturnExpr>\n Parser<ManagedTokenSource>::parse_return_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t       bool pratt_parse)\n+\t\t\t\t\t       Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (RETURN_TOK);\n     }\n-  else\n-    {\n-      // minus 7 chars for 6 in return and a space\n-      // or just TODO: pass in location data\n-      locus = lexer.peek_token ()->get_locus () - 7;\n-    }\n \n   // parse expression to return, if it exists\n   ParseRestrictions restrictions;\n@@ -7650,21 +7635,14 @@ Parser<ManagedTokenSource>::parse_return_expr (AST::AttrVec outer_attrs,\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::BreakExpr>\n Parser<ManagedTokenSource>::parse_break_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t      bool pratt_parse)\n+\t\t\t\t\t      Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (BREAK);\n     }\n-  else\n-    {\n-      // minus 6 chars for 5 in return and a space\n-      // or just TODO: pass in location data\n-      locus = lexer.peek_token ()->get_locus () - 6;\n-    }\n \n   // parse label (lifetime) if it exists - create dummy first\n   AST::Lifetime label = AST::Lifetime::error ();\n@@ -7688,21 +7666,14 @@ Parser<ManagedTokenSource>::parse_break_expr (AST::AttrVec outer_attrs,\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ContinueExpr>\n Parser<ManagedTokenSource>::parse_continue_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\t bool pratt_parse)\n+\t\t\t\t\t\t Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (CONTINUE);\n     }\n-  else\n-    {\n-      // minus 9 chars for 8 in return and a space\n-      // or just TODO: pass in location data\n-      locus = lexer.peek_token ()->get_locus () - 9;\n-    }\n \n   // parse label (lifetime) if it exists - create dummy first\n   AST::Lifetime label = AST::Lifetime::error ();\n@@ -7746,11 +7717,11 @@ Parser<ManagedTokenSource>::parse_loop_label ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfExpr>\n Parser<ManagedTokenSource>::parse_if_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t   bool pratt_parse)\n+\t\t\t\t\t   Location pratt_parsed_loc)\n {\n   // TODO: make having outer attributes an error?\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n       if (!skip_token (IF))\n@@ -7759,10 +7730,6 @@ Parser<ManagedTokenSource>::parse_if_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n     }\n-  else\n-    {\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   // detect accidental if let\n   if (lexer.peek_token ()->get_id () == LET)\n@@ -7908,11 +7875,11 @@ Parser<ManagedTokenSource>::parse_if_expr (AST::AttrVec outer_attrs,\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::IfLetExpr>\n Parser<ManagedTokenSource>::parse_if_let_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t       bool pratt_parse)\n+\t\t\t\t\t       Location pratt_parsed_loc)\n {\n   // TODO: make having outer attributes an error?\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n       if (!skip_token (IF))\n@@ -7921,10 +7888,6 @@ Parser<ManagedTokenSource>::parse_if_let_expr (AST::AttrVec outer_attrs,\n \t  return nullptr;\n \t}\n     }\n-  else\n-    {\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   // detect accidental if expr parsed as if let expr\n   if (lexer.peek_token ()->get_id () != LET)\n@@ -8100,10 +8063,10 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::LoopExpr>\n Parser<ManagedTokenSource>::parse_loop_expr (AST::AttrVec outer_attrs,\n \t\t\t\t\t     AST::LoopLabel label,\n-\t\t\t\t\t     bool pratt_parse)\n+\t\t\t\t\t     Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       if (label.is_error ())\n \tlocus = lexer.peek_token ()->get_locus ();\n@@ -8118,9 +8081,7 @@ Parser<ManagedTokenSource>::parse_loop_expr (AST::AttrVec outer_attrs,\n     }\n   else\n     {\n-      if (label.is_error ())\n-\tlocus = lexer.peek_token ()->get_locus () - 1;\n-      else\n+      if (!label.is_error ())\n \tlocus = label.get_locus ();\n     }\n \n@@ -8146,10 +8107,10 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::WhileLoopExpr>\n Parser<ManagedTokenSource>::parse_while_loop_expr (AST::AttrVec outer_attrs,\n \t\t\t\t\t\t   AST::LoopLabel label,\n-\t\t\t\t\t\t   bool pratt_parse)\n+\t\t\t\t\t\t   Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       if (label.is_error ())\n \tlocus = lexer.peek_token ()->get_locus ();\n@@ -8164,9 +8125,7 @@ Parser<ManagedTokenSource>::parse_while_loop_expr (AST::AttrVec outer_attrs,\n     }\n   else\n     {\n-      if (label.is_error ())\n-\tlocus = lexer.peek_token ()->get_locus () - 1;\n-      else\n+      if (!label.is_error ())\n \tlocus = label.get_locus ();\n     }\n \n@@ -8423,21 +8382,14 @@ Parser<ManagedTokenSource>::parse_labelled_loop_expr (AST::AttrVec outer_attrs)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MatchExpr>\n Parser<ManagedTokenSource>::parse_match_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t      bool pratt_parse)\n+\t\t\t\t\t      Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (MATCH_TOK);\n     }\n-  else\n-    {\n-      // TODO: probably just pass in location data as param\n-      // get current pos then move back 6 - 5 for match, 1 for space\n-      locus = lexer.peek_token ()->get_locus () - 6;\n-    }\n \n   /* parse scrutinee expression, which is required (and HACK to prevent struct\n    * expr) */\n@@ -8711,16 +8663,14 @@ Parser<ManagedTokenSource>::parse_async_block_expr (AST::AttrVec outer_attrs)\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::UnsafeBlockExpr>\n Parser<ManagedTokenSource>::parse_unsafe_block_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t\t     bool pratt_parse)\n+\t\t\t\t\t\t     Location pratt_parsed_loc)\n {\n-  Location locus;\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n       skip_token (UNSAFE);\n     }\n-  else\n-    locus = lexer.peek_token ()->get_locus () - 1;\n \n   // parse block expression (required)\n   std::unique_ptr<AST::BlockExpr> block_expr = parse_block_expr ();\n@@ -8744,19 +8694,14 @@ Parser<ManagedTokenSource>::parse_unsafe_block_expr (AST::AttrVec outer_attrs,\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArrayExpr>\n Parser<ManagedTokenSource>::parse_array_expr (AST::AttrVec outer_attrs,\n-\t\t\t\t\t      bool pratt_parse)\n+\t\t\t\t\t      Location pratt_parsed_loc)\n {\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (LEFT_SQUARE);\n     }\n-  else\n-    {\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   // parse optional inner attributes\n   AST::AttrVec inner_attrs = parse_inner_attributes ();\n@@ -8933,20 +8878,15 @@ Parser<ManagedTokenSource>::parse_closure_param ()\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprWithoutBlock>\n Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n-  AST::AttrVec outer_attrs, bool pratt_parse)\n+  AST::AttrVec outer_attrs, Location pratt_parsed_loc)\n {\n   // adjustment to allow Pratt parsing to reuse function without copy-paste\n-  Location locus = Linemap::unknown_location ();\n-  if (!pratt_parse)\n+  Location locus = pratt_parsed_loc;\n+  if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n-\n       skip_token (LEFT_PAREN);\n     }\n-  else\n-    {\n-      locus = lexer.peek_token ()->get_locus () - 1;\n-    }\n \n   // parse optional inner attributes\n   AST::AttrVec inner_attrs = parse_inner_attributes ();\n@@ -12541,7 +12481,7 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \t// qualified path\n \t// HACK: add outer attrs to path\n \tAST::QualifiedPathInExpression path\n-\t  = parse_qualified_path_in_expression (true);\n+\t  = parse_qualified_path_in_expression (tok->get_locus ());\n \tpath.set_outer_attrs (std::move (outer_attrs));\n \treturn std::unique_ptr<AST::QualifiedPathInExpression> (\n \t  new AST::QualifiedPathInExpression (std::move (path)));\n@@ -12584,7 +12524,8 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n \tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL,\n \t\t\t      tok->get_type_hint (), {}, tok->get_locus ()));\n     case LEFT_PAREN:\n-      return parse_grouped_or_tuple_expr (std::move (outer_attrs), true);\n+      return parse_grouped_or_tuple_expr (std::move (outer_attrs),\n+\t\t\t\t\t  tok->get_locus ());\n \n       /*case PLUS: { // unary plus operator\n \t  // invoke parse_expr recursively with appropriate priority, etc. for\n@@ -12816,41 +12757,43 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n       return parse_range_to_inclusive_expr (tok, std::move (outer_attrs));\n     case RETURN_TOK:\n       // FIXME: is this really a null denotation expression?\n-      return parse_return_expr (std::move (outer_attrs), true);\n+      return parse_return_expr (std::move (outer_attrs), tok->get_locus ());\n     case BREAK:\n       // FIXME: is this really a null denotation expression?\n-      return parse_break_expr (std::move (outer_attrs), true);\n+      return parse_break_expr (std::move (outer_attrs), tok->get_locus ());\n     case CONTINUE:\n-      return parse_continue_expr (std::move (outer_attrs), true);\n+      return parse_continue_expr (std::move (outer_attrs), tok->get_locus ());\n     case LEFT_CURLY:\n       // ok - this is an expression with block for once.\n-      return parse_block_expr (std::move (outer_attrs), true);\n+      return parse_block_expr (std::move (outer_attrs), tok->get_locus ());\n     case IF:\n       // if or if let, so more lookahead to find out\n       if (lexer.peek_token (1)->get_id () == LET)\n \t{\n \t  // if let expr\n-\t  return parse_if_let_expr (std::move (outer_attrs), true);\n+\t  return parse_if_let_expr (std::move (outer_attrs), tok->get_locus ());\n \t}\n       else\n \t{\n \t  // if expr\n-\t  return parse_if_expr (std::move (outer_attrs), true);\n+\t  return parse_if_expr (std::move (outer_attrs), tok->get_locus ());\n \t}\n     case LOOP:\n       return parse_loop_expr (std::move (outer_attrs), AST::LoopLabel::error (),\n-\t\t\t      true);\n+\t\t\t      tok->get_locus ());\n     case WHILE:\n       return parse_while_loop_expr (std::move (outer_attrs),\n-\t\t\t\t    AST::LoopLabel::error (), true);\n+\t\t\t\t    AST::LoopLabel::error (),\n+\t\t\t\t    tok->get_locus ());\n     case MATCH_TOK:\n       // also an expression with block\n-      return parse_match_expr (std::move (outer_attrs), true);\n+      return parse_match_expr (std::move (outer_attrs), tok->get_locus ());\n     case LEFT_SQUARE:\n       // array definition expr (not indexing)\n-      return parse_array_expr (std::move (outer_attrs), true);\n+      return parse_array_expr (std::move (outer_attrs), tok->get_locus ());\n     case UNSAFE:\n-      return parse_unsafe_block_expr (std::move (outer_attrs), true);\n+      return parse_unsafe_block_expr (std::move (outer_attrs),\n+\t\t\t\t      tok->get_locus ());\n     default:\n       if (!restrictions.expr_can_be_null)\n \tadd_error (Error (tok->get_locus (),"}, {"sha": "86e0d2a6f83f3abc46fee45aa5bc053b463bf91d", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02424cf671eeee25ca371d17eef4a65c71de8eee/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02424cf671eeee25ca371d17eef4a65c71de8eee/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=02424cf671eeee25ca371d17eef4a65c71de8eee", "patch": "@@ -121,8 +121,14 @@ template <typename ManagedTokenSource> class Parser\n   AST::PathInExpression parse_path_in_expression ();\n   AST::PathExprSegment parse_path_expr_segment ();\n   AST::QualifiedPathInExpression\n-  parse_qualified_path_in_expression (bool pratt_parse = false);\n-  AST::QualifiedPathType parse_qualified_path_type (bool pratt_parse = false);\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  parse_qualified_path_in_expression (Location pratt_parsed_loc\n+\t\t\t\t      = Linemap::unknown_location ());\n+  AST::QualifiedPathType\n+  parse_qualified_path_type (Location pratt_parsed_loc\n+\t\t\t     = Linemap::unknown_location ());\n   AST::QualifiedPathInType parse_qualified_path_in_type ();\n \n   // Token tree or macro related\n@@ -469,32 +475,36 @@ template <typename ManagedTokenSource> class Parser\n   parse_expr_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprWithoutBlock>\n   parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec ());\n-  std::unique_ptr<AST::BlockExpr> parse_block_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t    = AST::AttrVec (),\n-\t\t\t\t\t\t    bool pratt_parse = false);\n-  std::unique_ptr<AST::IfExpr> parse_if_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t      = AST::AttrVec (),\n-\t\t\t\t\t      bool pratt_parse = false);\n-  std::unique_ptr<AST::IfLetExpr> parse_if_let_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t     = AST::AttrVec (),\n-\t\t\t\t\t\t     bool pratt_parse = false);\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::IfExpr>\n+  parse_if_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::IfLetExpr>\n+  parse_if_let_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t     Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::LoopExpr>\n   parse_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t   AST::LoopLabel label = AST::LoopLabel::error (),\n-\t\t   bool pratt_parse = false);\n+\t\t   Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::WhileLoopExpr>\n   parse_while_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t\t AST::LoopLabel label = AST::LoopLabel::error (),\n-\t\t\t bool pratt_parse = false);\n+\t\t\t Location pratt_parsed_loc\n+\t\t\t = Linemap::unknown_location ());\n   std::unique_ptr<AST::WhileLetLoopExpr>\n   parse_while_let_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t\t     AST::LoopLabel label = AST::LoopLabel::error ());\n   std::unique_ptr<AST::ForLoopExpr>\n   parse_for_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t\t       AST::LoopLabel label = AST::LoopLabel::error ());\n-  std::unique_ptr<AST::MatchExpr> parse_match_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t    = AST::AttrVec (),\n-\t\t\t\t\t\t    bool pratt_parse = false);\n+  std::unique_ptr<AST::MatchExpr>\n+  parse_match_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n   AST::MatchArm parse_match_arm ();\n   std::vector<std::unique_ptr<AST::Pattern> >\n   parse_match_arm_patterns (TokenId end_token_id);\n@@ -510,24 +520,30 @@ template <typename ManagedTokenSource> class Parser\n   AST::ClosureParam parse_closure_param ();\n   std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n \t\t\t\t\t\t\t= AST::AttrVec ());\n-  std::unique_ptr<AST::ReturnExpr> parse_return_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t      = AST::AttrVec (),\n-\t\t\t\t\t\t      bool pratt_parse = false);\n-  std::unique_ptr<AST::BreakExpr> parse_break_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t    = AST::AttrVec (),\n-\t\t\t\t\t\t    bool pratt_parse = false);\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  std::unique_ptr<AST::ReturnExpr>\n+  parse_return_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t     Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::BreakExpr>\n+  parse_break_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::ContinueExpr>\n   parse_continue_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t       bool pratt_parse = false);\n+\t\t       Location pratt_parsed_loc\n+\t\t       = Linemap::unknown_location ());\n   std::unique_ptr<AST::UnsafeBlockExpr>\n   parse_unsafe_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t\t   bool pratt_parse = false);\n-  std::unique_ptr<AST::ArrayExpr> parse_array_expr (AST::AttrVec outer_attrs\n-\t\t\t\t\t\t    = AST::AttrVec (),\n-\t\t\t\t\t\t    bool pratt_parse = false);\n+\t\t\t   Location pratt_parsed_loc\n+\t\t\t   = Linemap::unknown_location ());\n+  std::unique_ptr<AST::ArrayExpr>\n+  parse_array_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n   std::unique_ptr<AST::ExprWithoutBlock>\n   parse_grouped_or_tuple_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n-\t\t\t       bool pratt_parse = false);\n+\t\t\t       Location pratt_parsed_loc\n+\t\t\t       = Linemap::unknown_location ());\n   std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n   bool will_be_expr_with_block ();\n "}]}