{"sha": "382b0e9771d77d482f6765454ec884936b62b15b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyYjBlOTc3MWQ3N2Q0ODJmNjc2NTQ1NGVjODg0OTM2YjYyYjE1Yg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-08-19T08:37:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-19T08:37:09Z"}, "message": "[Ada] Incorrect code for -gnateV switch\n\nThis patch corrects the code generated by the -gnateV switch in the case\nof a private type whose full type is a modular type, removing spurious\nrun-time failures.\n\nIn addition, this corrects the initialization of exception occurrences\nin exception handlers to avoid leaving data uninitialized, which caused\n-gnateV to raise spurious errors.\n\n2019-08-19  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb (Attribute_Valid): Correct the handling of\n\tprivate types where the full type is modular. System.Address is\n\tan example. Otherwise, we convert uncheckedly to a signed type,\n\tso we get an incorrect range 0 .. -1, for which all values will\n\tfail.  The 'Valid attribute is illegal for such types, but we\n\tgenerate such illegal attribute_references for 'Valid_Scalars,\n\tand we generate 'Valid_Scalars when the -gnateV switch is used.\n\tRename Btyp --> PBtyp to avoid hiding the outer Btyp, which was\n\tconfusing.\n\t* libgnat/a-except.adb: Set the Exception_Raised component.\n\tOtherwise, we have incorrect reads of invalid data.\n\ngcc/testsuite/\n\n\t* gnat.dg/valid_scalars2.adb: New testcase.\n\nFrom-SVN: r274660", "tree": {"sha": "93eccc1c8fb26b09314c52d73d3b9b33a56dea82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93eccc1c8fb26b09314c52d73d3b9b33a56dea82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/382b0e9771d77d482f6765454ec884936b62b15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382b0e9771d77d482f6765454ec884936b62b15b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382b0e9771d77d482f6765454ec884936b62b15b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382b0e9771d77d482f6765454ec884936b62b15b/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27ebda1930cef2ac484abcca124a4d6230feee08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ebda1930cef2ac484abcca124a4d6230feee08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ebda1930cef2ac484abcca124a4d6230feee08"}], "stats": {"total": 100, "additions": 73, "deletions": 27}, "files": [{"sha": "499a4896b90313dca9370b81f8c28cadc6265fce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=382b0e9771d77d482f6765454ec884936b62b15b", "patch": "@@ -1,3 +1,17 @@\n+2019-08-19  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_attr.adb (Attribute_Valid): Correct the handling of\n+\tprivate types where the full type is modular. System.Address is\n+\tan example. Otherwise, we convert uncheckedly to a signed type,\n+\tso we get an incorrect range 0 .. -1, for which all values will\n+\tfail.  The 'Valid attribute is illegal for such types, but we\n+\tgenerate such illegal attribute_references for 'Valid_Scalars,\n+\tand we generate 'Valid_Scalars when the -gnateV switch is used.\n+\tRename Btyp --> PBtyp to avoid hiding the outer Btyp, which was\n+\tconfusing.\n+\t* libgnat/a-except.adb: Set the Exception_Raised component.\n+\tOtherwise, we have incorrect reads of invalid data.\n+\n 2019-08-19  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* libgnat/a-cgaaso.ads, libgnat/a-cgarso.ads,"}, {"sha": "306c1b56404f44903a4a19502d8ad6e80ba137c3", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=382b0e9771d77d482f6765454ec884936b62b15b", "patch": "@@ -6545,7 +6545,7 @@ package body Exp_Attr is\n       --  See separate sections below for the generated code in each case.\n \n       when Attribute_Valid => Valid : declare\n-         Btyp : Entity_Id := Base_Type (Ptyp);\n+         PBtyp : Entity_Id := Base_Type (Ptyp);\n \n          Save_Validity_Checks_On : constant Boolean := Validity_Checks_On;\n          --  Save the validity checking mode. We always turn off validity\n@@ -6555,7 +6555,7 @@ package body Exp_Attr is\n \n          function Make_Range_Test return Node_Id;\n          --  Build the code for a range test of the form\n-         --    Btyp!(Pref) in Btyp!(Ptyp'First) .. Btyp!(Ptyp'Last)\n+         --    PBtyp!(Pref) in PBtyp!(Ptyp'First) .. PBtyp!(Ptyp'Last)\n \n          ---------------------\n          -- Make_Range_Test --\n@@ -6594,16 +6594,16 @@ package body Exp_Attr is\n \n             return\n               Make_In (Loc,\n-                Left_Opnd  => Unchecked_Convert_To (Btyp, Temp),\n+                Left_Opnd  => Unchecked_Convert_To (PBtyp, Temp),\n                 Right_Opnd =>\n                   Make_Range (Loc,\n                     Low_Bound  =>\n-                      Unchecked_Convert_To (Btyp,\n+                      Unchecked_Convert_To (PBtyp,\n                         Make_Attribute_Reference (Loc,\n                           Prefix         => New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_First)),\n                     High_Bound =>\n-                      Unchecked_Convert_To (Btyp,\n+                      Unchecked_Convert_To (PBtyp,\n                         Make_Attribute_Reference (Loc,\n                           Prefix         => New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_Last))));\n@@ -6631,8 +6631,8 @@ package body Exp_Attr is\n          --  Retrieve the base type. Handle the case where the base type is a\n          --  private enumeration type.\n \n-         if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n-            Btyp := Full_View (Btyp);\n+         if Is_Private_Type (PBtyp) and then Present (Full_View (PBtyp)) then\n+            PBtyp := Full_View (PBtyp);\n          end if;\n \n          --  Floating-point case. This case is handled by the Valid attribute\n@@ -6665,7 +6665,7 @@ package body Exp_Attr is\n             begin\n                --  The C and AAMP back-ends handle Valid for fpt types\n \n-               if Modify_Tree_For_C or else Float_Rep (Btyp) = AAMP then\n+               if Modify_Tree_For_C or else Float_Rep (PBtyp) = AAMP then\n                   Analyze_And_Resolve (Pref, Ptyp);\n                   Set_Etype (N, Standard_Boolean);\n                   Set_Analyzed (N);\n@@ -6758,13 +6758,13 @@ package body Exp_Attr is\n                --  The way we do the range check is simply to create the\n                --  expression: Valid (N) and then Base_Type(Pref) in Typ.\n \n-               if not Subtypes_Statically_Match (Ptyp, Btyp) then\n+               if not Subtypes_Statically_Match (Ptyp, PBtyp) then\n                   Rewrite (N,\n                     Make_And_Then (Loc,\n                       Left_Opnd  => Relocate_Node (N),\n                       Right_Opnd =>\n                         Make_In (Loc,\n-                          Left_Opnd  => Convert_To (Btyp, Pref),\n+                          Left_Opnd  => Convert_To (PBtyp, Pref),\n                           Right_Opnd => New_Occurrence_Of (Ptyp, Loc))));\n                end if;\n             end Float_Valid;\n@@ -6793,24 +6793,24 @@ package body Exp_Attr is\n          --       (X >= type(X)'First and then type(X)'Last <= X)\n \n          elsif Is_Enumeration_Type (Ptyp)\n-           and then Present (Enum_Pos_To_Rep (Btyp))\n+           and then Present (Enum_Pos_To_Rep (PBtyp))\n          then\n             Tst :=\n               Make_Op_Ge (Loc,\n                 Left_Opnd =>\n                   Make_Function_Call (Loc,\n                     Name =>\n-                      New_Occurrence_Of (TSS (Btyp, TSS_Rep_To_Pos), Loc),\n+                      New_Occurrence_Of (TSS (PBtyp, TSS_Rep_To_Pos), Loc),\n                     Parameter_Associations => New_List (\n                       Pref,\n                       New_Occurrence_Of (Standard_False, Loc))),\n                 Right_Opnd => Make_Integer_Literal (Loc, 0));\n \n-            if Ptyp /= Btyp\n+            if Ptyp /= PBtyp\n               and then\n-                (Type_Low_Bound (Ptyp) /= Type_Low_Bound (Btyp)\n+                (Type_Low_Bound (Ptyp) /= Type_Low_Bound (PBtyp)\n                   or else\n-                 Type_High_Bound (Ptyp) /= Type_High_Bound (Btyp))\n+                 Type_High_Bound (Ptyp) /= Type_High_Bound (PBtyp))\n             then\n                --  The call to Make_Range_Test will create declarations\n                --  that need a proper insertion point, but Pref is now\n@@ -6843,16 +6843,16 @@ package body Exp_Attr is\n          --  test has to take this into account, and the proper form of the\n          --  test is:\n \n-         --    Btyp!(Pref) < Btyp!(Ptyp'Range_Length)\n+         --    PBtyp!(Pref) < PBtyp!(Ptyp'Range_Length)\n \n          elsif Has_Biased_Representation (Ptyp) then\n-            Btyp := RTE (RE_Unsigned_32);\n+            PBtyp := RTE (RE_Unsigned_32);\n             Rewrite (N,\n               Make_Op_Lt (Loc,\n                 Left_Opnd =>\n-                  Unchecked_Convert_To (Btyp, Duplicate_Subexpr (Pref)),\n+                  Unchecked_Convert_To (PBtyp, Duplicate_Subexpr (Pref)),\n                 Right_Opnd =>\n-                  Unchecked_Convert_To (Btyp,\n+                  Unchecked_Convert_To (PBtyp,\n                     Make_Attribute_Reference (Loc,\n                       Prefix => New_Occurrence_Of (Ptyp, Loc),\n                       Attribute_Name => Name_Range_Length))));\n@@ -6867,11 +6867,11 @@ package body Exp_Attr is\n          --  the Valid attribute is exactly that this test does not work).\n          --  What will work is:\n \n-         --     Btyp!(X) >= Btyp!(type(X)'First)\n+         --     PBtyp!(X) >= PBtyp!(type(X)'First)\n          --       and then\n-         --     Btyp!(X) <= Btyp!(type(X)'Last)\n+         --     PBtyp!(X) <= PBtyp!(type(X)'Last)\n \n-         --  where Btyp is an integer type large enough to cover the full\n+         --  where PBtyp is an integer type large enough to cover the full\n          --  range of possible stored values (i.e. it is chosen on the basis\n          --  of the size of the type, not the range of the values). We write\n          --  this as two tests, rather than a range check, so that static\n@@ -6895,11 +6895,13 @@ package body Exp_Attr is\n          --  correct, even though a value greater than 127 looks signed to a\n          --  signed comparison.\n \n-         elsif Is_Unsigned_Type (Ptyp) then\n+         elsif Is_Unsigned_Type (Ptyp)\n+           or else (Is_Private_Type (Ptyp) and then Is_Unsigned_Type (Btyp))\n+         then\n             if Esize (Ptyp) <= 32 then\n-               Btyp := RTE (RE_Unsigned_32);\n+               PBtyp := RTE (RE_Unsigned_32);\n             else\n-               Btyp := RTE (RE_Unsigned_64);\n+               PBtyp := RTE (RE_Unsigned_64);\n             end if;\n \n             Rewrite (N, Make_Range_Test);\n@@ -6908,9 +6910,9 @@ package body Exp_Attr is\n \n          else\n             if Esize (Ptyp) <= Esize (Standard_Integer) then\n-               Btyp := Standard_Integer;\n+               PBtyp := Standard_Integer;\n             else\n-               Btyp := Universal_Integer;\n+               PBtyp := Universal_Integer;\n             end if;\n \n             Rewrite (N, Make_Range_Test);"}, {"sha": "8b0a31c27f8895bb9dd968d1d965ce860483ed06", "filename": "gcc/ada/libgnat/a-except.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2Flibgnat%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Fada%2Flibgnat%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-except.adb?ref=382b0e9771d77d482f6765454ec884936b62b15b", "patch": "@@ -1624,6 +1624,7 @@ package body Ada.Exceptions is\n       Target.Machine_Occurrence := System.Null_Address;\n       Target.Msg_Length         := Source.Msg_Length;\n       Target.Num_Tracebacks     := Source.Num_Tracebacks;\n+      Target.Exception_Raised   := Source.Exception_Raised;\n       Target.Pid                := Source.Pid;\n \n       Target.Msg (1 .. Target.Msg_Length) :="}, {"sha": "127a223f2389fbabe87ca054b8d3997caf5c7c6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=382b0e9771d77d482f6765454ec884936b62b15b", "patch": "@@ -1,3 +1,7 @@\n+2019-08-19  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat.dg/valid_scalars2.adb: New testcase.\n+\n 2019-08-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/generic_inst12.adb, gnat.dg/generic_inst12_pkg1.adb,"}, {"sha": "949cb836cae3dbc89289fd3db2ba306d150326da", "filename": "gcc/testsuite/gnat.dg/valid_scalars2.adb", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Ftestsuite%2Fgnat.dg%2Fvalid_scalars2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382b0e9771d77d482f6765454ec884936b62b15b/gcc%2Ftestsuite%2Fgnat.dg%2Fvalid_scalars2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvalid_scalars2.adb?ref=382b0e9771d77d482f6765454ec884936b62b15b", "patch": "@@ -0,0 +1,25 @@\n+--  { dg-do run }\n+--  { dg-options \"-O0 -gnata -gnateV\" }\n+\n+with Ada.Exceptions; use Ada.Exceptions;\n+\n+procedure Valid_Scalars2 is\n+\n+   Traced : Boolean := False;\n+\n+   procedure Trace (E : in Exception_Occurrence) is\n+      pragma Assert (E'Valid_scalars);\n+   begin\n+      Traced := True;\n+   end Trace;\n+\n+begin\n+   raise Program_Error;\n+exception\n+   when E : others =>\n+      pragma Assert (E'Valid_scalars);\n+      Trace (E);\n+      if not Traced then\n+         raise Program_Error;\n+      end if;\n+end Valid_Scalars2;"}]}