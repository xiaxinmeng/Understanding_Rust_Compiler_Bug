{"sha": "c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "node_id": "C_kwDOANBUbNoAKGM2YzAyYjkxMzVlNTRlMTgxZWE2YmRkODg5MmEyNDNjNTBjYjZjN2E", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-03-23T21:18:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-03-24T15:31:03Z"}, "message": "gccrs: Fix bad type inference\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-resolve.cc: don't inject extra inference variables\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-1893.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "0867b84b1a442d56ab257ecf0bcdaea0cc2a83a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0867b84b1a442d56ab257ecf0bcdaea0cc2a83a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d38d01886da81d2c38673887dc8802efd0d5432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d38d01886da81d2c38673887dc8802efd0d5432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d38d01886da81d2c38673887dc8802efd0d5432"}], "stats": {"total": 79, "additions": 60, "deletions": 19}, "files": [{"sha": "2d5917a59f4e5475984c2f78d5ba9900ec124d82", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "patch": "@@ -472,7 +472,7 @@ AssociatedImplTrait::setup_associated_types (\n   TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), {},\n \t\t\t\t\t\t      locus, param_subst_cb);\n   TyTy::BaseType *impl_self_infer\n-    = (associated_self->needs_generic_substitutions ())\n+    = (!associated_self->is_concrete ())\n \t? SubstMapperInternal::Resolve (associated_self, infer_arguments)\n \t: associated_self;\n \n@@ -495,19 +495,6 @@ AssociatedImplTrait::setup_associated_types (\n       impl_trait_predicate_args.push_back (r);\n     }\n \n-  // we need to unify the receiver with the impl-block Self so that we compute\n-  // the type correctly as our receiver may be generic and we are inferring its\n-  // generic arguments and this Self might be the concrete version or vice\n-  // versa.\n-  auto result = unify_site_and (get_impl_block ()->get_mappings ().get_hirid (),\n-\t\t\t\tTyTy::TyWithLocation (receiver),\n-\t\t\t\tTyTy::TyWithLocation (impl_self_infer),\n-\t\t\t\timpl_predicate.get_locus (),\n-\t\t\t\ttrue /*emit-errors*/, true /*commit-if-ok*/,\n-\t\t\t\ttrue /*infer*/, true /*cleanup-on-fail*/);\n-  rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n-  TyTy::BaseType *self_result = result;\n-\n   // unify the bounds arguments\n   std::vector<TyTy::BaseType *> hrtb_bound_arguments;\n   for (const auto &arg : bound.get_substs ())\n@@ -520,22 +507,34 @@ AssociatedImplTrait::setup_associated_types (\n       hrtb_bound_arguments.push_back (r);\n     }\n \n-  if (impl_trait_predicate_args.size () != hrtb_bound_arguments.size ())\n-    return self_result;\n-\n+  rust_assert (impl_trait_predicate_args.size ()\n+\t       == hrtb_bound_arguments.size ());\n   for (size_t i = 0; i < impl_trait_predicate_args.size (); i++)\n     {\n       TyTy::BaseType *a = impl_trait_predicate_args.at (i);\n       TyTy::BaseType *b = hrtb_bound_arguments.at (i);\n \n-      result\n+      TyTy::BaseType *result\n \t= unify_site_and (a->get_ref (), TyTy::TyWithLocation (a),\n \t\t\t  TyTy::TyWithLocation (b), impl_predicate.get_locus (),\n \t\t\t  true /*emit-errors*/, true /*commit-if-ok*/,\n-\t\t\t  true /*infer*/, true /*cleanup-on-fail*/);\n+\t\t\t  false /*infer*/, true /*cleanup-on-fail*/);\n       rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n     }\n \n+  // we need to unify the receiver with the impl-block Self so that we compute\n+  // the type correctly as our receiver may be generic and we are inferring its\n+  // generic arguments and this Self might be the concrete version or vice\n+  // versa.\n+  auto result = unify_site_and (get_impl_block ()->get_mappings ().get_hirid (),\n+\t\t\t\tTyTy::TyWithLocation (receiver),\n+\t\t\t\tTyTy::TyWithLocation (impl_self_infer),\n+\t\t\t\timpl_predicate.get_locus (),\n+\t\t\t\ttrue /*emit-errors*/, true /*commit-if-ok*/,\n+\t\t\t\tfalse /*infer*/, true /*cleanup-on-fail*/);\n+  rust_assert (result->get_kind () != TyTy::TypeKind::ERROR);\n+  TyTy::BaseType *self_result = result;\n+\n   // create the argument list\n   std::vector<TyTy::SubstitutionArg> associated_arguments;\n   for (auto &p : substitutions)"}, {"sha": "ff8bef79bbc053aa434a8b39f76648422d8ec6a6", "filename": "gcc/testsuite/rust/compile/issue-1893.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6c02b9135e54e181ea6bdd8892a243c50cb6c7a/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1893.rs?ref=c6c02b9135e54e181ea6bdd8892a243c50cb6c7a", "patch": "@@ -0,0 +1,42 @@\n+pub enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+pub enum Result<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+\n+pub trait TryFrom<T> {\n+    /// The type returned in the event of a conversion error.\n+    type Error;\n+\n+    /// Performs the conversion.\n+    fn try_from(value: T) -> Result<Self, Self::Error>;\n+}\n+\n+pub trait From<T> {\n+    fn from(_: T) -> Self;\n+}\n+\n+impl<T> From<T> for T {\n+    fn from(t: T) -> T {\n+        t\n+    }\n+}\n+\n+impl<T, U> TryFrom<U> for T\n+where\n+    T: From<U>,\n+{\n+    type Error = !;\n+\n+    fn try_from(value: U) -> Result<Self, Self::Error> {\n+        Result::Ok(T::from(value))\n+    }\n+}\n+\n+pub fn test(n: usize) {\n+    let _a = <usize>::try_from(n);\n+}"}]}