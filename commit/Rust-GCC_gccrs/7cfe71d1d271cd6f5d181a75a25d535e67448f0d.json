{"sha": "7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NmZTcxZDFkMjcxY2Q2ZjVkMTgxYTc1YTI1ZDUzNWU2NzQ0OGYwZA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-06-03T17:08:34Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-06-03T17:08:34Z"}, "message": "Rename variables and cleanup comments.\n\n2019-06-03  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tRename variables and cleanup comments.\n\t* include/bits/hashtable_policy.h\n\t* include/bits/hashtable.h\n\nFrom-SVN: r271876", "tree": {"sha": "1ea644fde00139bb8a6519efcb5095e245b77de6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ea644fde00139bb8a6519efcb5095e245b77de6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/comments", "author": null, "committer": null, "parents": [{"sha": "dff0e6f3cdfdc05736240f640b32dfc0ee86b104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff0e6f3cdfdc05736240f640b32dfc0ee86b104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff0e6f3cdfdc05736240f640b32dfc0ee86b104"}], "stats": {"total": 323, "additions": 168, "deletions": 155}, "files": [{"sha": "5a7054e3aeb6c337b0f051b6c54400f8d48a31fd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "patch": "@@ -1,3 +1,9 @@\n+2019-06-03  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tRename variables and cleanup comments.\n+\t* include/bits/hashtable_policy.h\n+\t* include/bits/hashtable.h\n+\n 2019-06-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/xml/manual/status_cxx2020.xml: Add missing row for P0920R2."}, {"sha": "e2e3f016a3560908a2af356d5a9320ca71c8a87a", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 112, "deletions": 108, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "patch": "@@ -253,7 +253,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n \t\t\t\t\t    _RehashPolicy, _Traits>;\n \n-      using __reuse_or_alloc_node_type =\n+      using __reuse_or_alloc_node_gen_t =\n \t__detail::_ReuseOrAllocNode<__node_alloc_type>;\n \n       // Metaprogramming for picking apart hash caching.\n@@ -278,9 +278,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    \"Cache the hash code or qualify your functors involved\"\n \t\t    \" in hash code and bucket index computation with noexcept\");\n \n-      // Following two static assertions are necessary to guarantee\n-      // that local_iterator will be default constructible.\n-\n       // When hash codes are cached local iterator inherits from H2 functor\n       // which must then be default constructible.\n       static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,\n@@ -331,7 +328,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _RehashPolicy\t\t_M_rehash_policy;\n \n       // A single bucket used when only need for 1 bucket. Especially\n-      // interesting in move semantic to leave hashtable with only 1 buckets\n+      // interesting in move semantic to leave hashtable with only 1 bucket\n       // which is not allocated so that we can have those operations noexcept\n       // qualified.\n       // Note that we can't leave hashtable with 0 bucket without adding\n@@ -350,24 +347,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_base_alloc() { return *this; }\n \n       __bucket_type*\n-      _M_allocate_buckets(size_type __n)\n+      _M_allocate_buckets(size_type __bkt_count)\n       {\n-\tif (__builtin_expect(__n == 1, false))\n+\tif (__builtin_expect(__bkt_count == 1, false))\n \t  {\n \t    _M_single_bucket = nullptr;\n \t    return &_M_single_bucket;\n \t  }\n \n-\treturn __hashtable_alloc::_M_allocate_buckets(__n);\n+\treturn __hashtable_alloc::_M_allocate_buckets(__bkt_count);\n       }\n \n       void\n-      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)\n+      _M_deallocate_buckets(__bucket_type* __bkts, size_type __bkt_count)\n       {\n \tif (_M_uses_single_bucket(__bkts))\n \t  return;\n \n-\t__hashtable_alloc::_M_deallocate_buckets(__bkts, __n);\n+\t__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);\n       }\n \n       void\n@@ -394,32 +391,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_assign(const _Hashtable&, const _NodeGenerator&);\n \n       void\n-      _M_move_assign(_Hashtable&&, std::true_type);\n+      _M_move_assign(_Hashtable&&, true_type);\n \n       void\n-      _M_move_assign(_Hashtable&&, std::false_type);\n+      _M_move_assign(_Hashtable&&, false_type);\n \n       void\n       _M_reset() noexcept;\n \n       _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t\t const _Equal& __eq, const _ExtractKey& __exk,\n \t\t const allocator_type& __a)\n-\t: __hashtable_base(__exk, __h1, __h2, __h, __eq),\n-\t  __hashtable_alloc(__node_alloc_type(__a))\n+      : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n+\t__hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n     public:\n       // Constructor, destructor, assignment, swap\n       _Hashtable() = default;\n-      _Hashtable(size_type __bucket_hint,\n+      _Hashtable(size_type __bkt_count_hint,\n \t\t const _H1&, const _H2&, const _Hash&,\n \t\t const _Equal&, const _ExtractKey&,\n \t\t const allocator_type&);\n \n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __first, _InputIterator __last,\n-\t\t   size_type __bucket_hint,\n+\t\t   size_type __bkt_count_hint,\n \t\t   const _H1&, const _H2&, const _Hash&,\n \t\t   const _Equal&, const _ExtractKey&,\n \t\t   const allocator_type&);\n@@ -435,34 +432,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Use delegating constructors.\n       explicit\n       _Hashtable(const allocator_type& __a)\n-\t: __hashtable_alloc(__node_alloc_type(__a))\n+      : __hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n       explicit\n-      _Hashtable(size_type __n,\n+      _Hashtable(size_type __bkt_count_hint,\n \t\t const _H1& __hf = _H1(),\n \t\t const key_equal& __eql = key_equal(),\n \t\t const allocator_type& __a = allocator_type())\n-      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,\n+      : _Hashtable(__bkt_count_hint, __hf, _H2(), _Hash(), __eql,\n \t\t   __key_extract(), __a)\n       { }\n \n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __f, _InputIterator __l,\n-\t\t   size_type __n = 0,\n+\t\t   size_type __bkt_count_hint = 0,\n \t\t   const _H1& __hf = _H1(),\n \t\t   const key_equal& __eql = key_equal(),\n \t\t   const allocator_type& __a = allocator_type())\n-\t: _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,\n+\t: _Hashtable(__f, __l, __bkt_count_hint, __hf, _H2(), _Hash(), __eql,\n \t\t     __key_extract(), __a)\n \t{ }\n \n       _Hashtable(initializer_list<value_type> __l,\n-\t\t size_type __n = 0,\n+\t\t size_type __bkt_count_hint = 0,\n \t\t const _H1& __hf = _H1(),\n \t\t const key_equal& __eql = key_equal(),\n \t\t const allocator_type& __a = allocator_type())\n-      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,\n+      : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,\n+\t\t   __hf, _H2(), _Hash(), __eql,\n \t\t   __key_extract(), __a)\n       { }\n \n@@ -485,7 +483,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable&\n       operator=(initializer_list<value_type> __l)\n       {\n-\t__reuse_or_alloc_node_type __roan(_M_begin(), *this);\n+\t__reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);\n \t_M_before_begin._M_nxt = nullptr;\n \tclear();\n \tthis->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());\n@@ -557,46 +555,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return max_size(); }\n \n       size_type\n-      bucket_size(size_type __n) const\n-      { return std::distance(begin(__n), end(__n)); }\n+      bucket_size(size_type __bkt) const\n+      { return std::distance(begin(__bkt), end(__bkt)); }\n \n       size_type\n       bucket(const key_type& __k) const\n       { return _M_bucket_index(__k, this->_M_hash_code(__k)); }\n \n       local_iterator\n-      begin(size_type __n)\n+      begin(size_type __bkt)\n       {\n-\treturn local_iterator(*this, _M_bucket_begin(__n),\n-\t\t\t      __n, _M_bucket_count);\n+\treturn local_iterator(*this, _M_bucket_begin(__bkt),\n+\t\t\t      __bkt, _M_bucket_count);\n       }\n \n       local_iterator\n-      end(size_type __n)\n-      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }\n+      end(size_type __bkt)\n+      { return local_iterator(*this, nullptr, __bkt, _M_bucket_count); }\n \n       const_local_iterator\n-      begin(size_type __n) const\n+      begin(size_type __bkt) const\n       {\n-\treturn const_local_iterator(*this, _M_bucket_begin(__n),\n-\t\t\t\t    __n, _M_bucket_count);\n+\treturn const_local_iterator(*this, _M_bucket_begin(__bkt),\n+\t\t\t\t    __bkt, _M_bucket_count);\n       }\n \n       const_local_iterator\n-      end(size_type __n) const\n-      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }\n+      end(size_type __bkt) const\n+      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }\n \n       // DR 691.\n       const_local_iterator\n-      cbegin(size_type __n) const\n+      cbegin(size_type __bkt) const\n       {\n-\treturn const_local_iterator(*this, _M_bucket_begin(__n),\n-\t\t\t\t    __n, _M_bucket_count);\n+\treturn const_local_iterator(*this, _M_bucket_begin(__bkt),\n+\t\t\t\t    __bkt, _M_bucket_count);\n       }\n \n       const_local_iterator\n-      cend(size_type __n) const\n-      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }\n+      cend(size_type __bkt) const\n+      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }\n \n       float\n       load_factor() const noexcept\n@@ -686,22 +684,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n-\t_M_emplace(std::true_type, _Args&&... __args);\n+\t_M_emplace(true_type, _Args&&... __args);\n \n       template<typename... _Args>\n \titerator\n-\t_M_emplace(std::false_type __uk, _Args&&... __args)\n+\t_M_emplace(false_type __uk, _Args&&... __args)\n \t{ return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }\n \n       // Emplace with hint, useless when keys are unique.\n       template<typename... _Args>\n \titerator\n-\t_M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)\n+\t_M_emplace(const_iterator, true_type __uk, _Args&&... __args)\n \t{ return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }\n \n       template<typename... _Args>\n \titerator\n-\t_M_emplace(const_iterator, std::false_type, _Args&&... __args);\n+\t_M_emplace(const_iterator, false_type, _Args&&... __args);\n \n       template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n@@ -733,10 +731,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  const _NodeGenerator&, false_type);\n \n       size_type\n-      _M_erase(std::true_type, const key_type&);\n+      _M_erase(true_type, const key_type&);\n \n       size_type\n-      _M_erase(std::false_type, const key_type&);\n+      _M_erase(false_type, const key_type&);\n \n       iterator\n       _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);\n@@ -777,8 +775,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       clear() noexcept;\n \n-      // Set number of buckets to be appropriate for container of n element.\n-      void rehash(size_type __n);\n+      // Set number of buckets keeping it appropriate for container's number\n+      // of elements.\n+      void rehash(size_type __bkt_count);\n \n       // DR 1189.\n       // reserve, if present, comes from _Rehash_base.\n@@ -918,14 +917,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       // Helper rehash method used when keys are unique.\n-      void _M_rehash_aux(size_type __n, std::true_type);\n+      void _M_rehash_aux(size_type __bkt_count, true_type);\n \n       // Helper rehash method used when keys can be non-unique.\n-      void _M_rehash_aux(size_type __n, std::false_type);\n+      void _M_rehash_aux(size_type __bkt_count, false_type);\n \n       // Unconditionally change size of bucket array to n, restore\n       // hash policy state to __state on exception.\n-      void _M_rehash(size_type __n, const __rehash_state& __state);\n+      void _M_rehash(size_type __bkt_count, const __rehash_state& __state);\n     };\n \n \n@@ -950,17 +949,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _Hashtable(size_type __bucket_hint,\n+    _Hashtable(size_type __bkt_count_hint,\n \t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t       const _Equal& __eq, const _ExtractKey& __exk,\n \t       const allocator_type& __a)\n-      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n+    : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n     {\n-      auto __bkt = _M_rehash_policy._M_next_bkt(__bucket_hint);\n-      if (__bkt > _M_bucket_count)\n+      auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);\n+      if (__bkt_count > _M_bucket_count)\n \t{\n-\t  _M_buckets = _M_allocate_buckets(__bkt);\n-\t  _M_bucket_count = __bkt;\n+\t  _M_buckets = _M_allocate_buckets(__bkt_count);\n+\t  _M_bucket_count = __bkt_count;\n \t}\n     }\n \n@@ -972,17 +971,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _Hashtable(_InputIterator __f, _InputIterator __l,\n-\t\t size_type __bucket_hint,\n+\t\t size_type __bkt_count_hint,\n \t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n \t\t const _Equal& __eq, const _ExtractKey& __exk,\n \t\t const allocator_type& __a)\n-\t: _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n+      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n       {\n \tauto __nb_elems = __detail::__distance_fw(__f, __l);\n \tauto __bkt_count =\n \t  _M_rehash_policy._M_next_bkt(\n \t    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),\n-\t\t     __bucket_hint));\n+\t\t     __bkt_count_hint));\n \n \tif (__bkt_count > _M_bucket_count)\n \t  {\n@@ -1044,7 +1043,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Reuse allocated buckets and nodes.\n       _M_assign_elements(__ht,\n-\t[](const __reuse_or_alloc_node_type& __roan, const __node_type* __n)\n+\t[](const __reuse_or_alloc_node_gen_t& __roan, const __node_type* __n)\n \t{ return __roan(__n->_M_v()); });\n       return *this;\n     }\n@@ -1078,7 +1077,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __hashtable_base::operator=(std::forward<_Ht>(__ht));\n \t    _M_element_count = __ht._M_element_count;\n \t    _M_rehash_policy = __ht._M_rehash_policy;\n-\t    __reuse_or_alloc_node_type __roan(_M_begin(), *this);\n+\t    __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);\n \t    _M_before_begin._M_nxt = nullptr;\n \t    _M_assign(__ht,\n \t\t      [&__node_gen, &__roan](__node_type* __n)\n@@ -1175,7 +1174,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_move_assign(_Hashtable&& __ht, std::true_type)\n+    _M_move_assign(_Hashtable&& __ht, true_type)\n     {\n       this->_M_deallocate_nodes(_M_begin());\n       _M_deallocate_buckets();\n@@ -1207,15 +1206,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_move_assign(_Hashtable&& __ht, std::false_type)\n+    _M_move_assign(_Hashtable&& __ht, false_type)\n     {\n       if (__ht._M_node_allocator() == this->_M_node_allocator())\n-\t_M_move_assign(std::move(__ht), std::true_type());\n+\t_M_move_assign(std::move(__ht), true_type());\n       else\n \t{\n \t  // Can't move memory, move elements then.\n \t  _M_assign_elements(std::move(__ht),\n-\t\t[](const __reuse_or_alloc_node_type& __roan, __node_type* __n)\n+\t\t[](const __reuse_or_alloc_node_gen_t& __roan, __node_type* __n)\n \t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n \t  __ht.clear();\n \t}\n@@ -1415,8 +1414,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __n = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__n, __k, __code);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      __node_type* __p = _M_find_node(__bkt, __k, __code);\n       return __p ? iterator(__p) : end();\n     }\n \n@@ -1431,8 +1430,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> const_iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __n = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__n, __k, __code);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      __node_type* __p = _M_find_node(__bkt, __k, __code);\n       return __p ? const_iterator(__p) : end();\n     }\n \n@@ -1447,8 +1446,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __n = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_bucket_begin(__n);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      __node_type* __p = _M_bucket_begin(__bkt);\n       if (!__p)\n \treturn 0;\n \n@@ -1462,7 +1461,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // found a non-equivalent value after an equivalent one it\n \t    // means that we won't find any new equivalent value.\n \t    break;\n-\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n+\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)\n \t    break;\n \t}\n       return __result;\n@@ -1479,13 +1478,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> pair<iterator, iterator>\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __n = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__n, __k, __code);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      __node_type* __p = _M_find_node(__bkt, __k, __code);\n \n       if (__p)\n \t{\n \t  __node_type* __p1 = __p->_M_next();\n-\t  while (__p1 && _M_bucket_index(__p1) == __n\n+\t  while (__p1 && _M_bucket_index(__p1) == __bkt\n \t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next();\n \n@@ -1506,13 +1505,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> pair<const_iterator, const_iterator>\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __n = _M_bucket_index(__k, __code);\n-      __node_type* __p = _M_find_node(__n, __k, __code);\n+      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      __node_type* __p = _M_find_node(__bkt, __k, __code);\n \n       if (__p)\n \t{\n \t  __node_type* __p1 = __p->_M_next();\n-\t  while (__p1 && _M_bucket_index(__p1) == __n\n+\t  while (__p1 && _M_bucket_index(__p1) == __bkt\n \t\t && this->_M_equals(__k, __code, __p1))\n \t    __p1 = __p1->_M_next();\n \n@@ -1522,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn std::make_pair(end(), end());\n     }\n \n-  // Find the node whose key compares equal to k in the bucket n.\n+  // Find the node whose key compares equal to k in the bucket bkt.\n   // Return nullptr if no node is found.\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n@@ -1531,11 +1530,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_find_before_node(size_type __n, const key_type& __k,\n+    _M_find_before_node(size_type __bkt, const key_type& __k,\n \t\t\t__hash_code __code) const\n     -> __node_base*\n     {\n-      __node_base* __prev_p = _M_buckets[__n];\n+      __node_base* __prev_p = _M_buckets[__bkt];\n       if (!__prev_p)\n \treturn nullptr;\n \n@@ -1545,7 +1544,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (this->_M_equals(__k, __code, __p))\n \t    return __prev_p;\n \n-\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)\n+\t  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)\n \t    break;\n \t  __prev_p = __p;\n \t}\n@@ -1631,11 +1630,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_emplace(std::true_type, _Args&&... __args)\n+      _M_emplace(true_type, _Args&&... __args)\n       -> pair<iterator, bool>\n       {\n \t// First build the node to get access to the hash code\n-\t__node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);\n+\t__node_type* __node\n+\t  = this->_M_allocate_node(std::forward<_Args>(__args)...);\n \tconst key_type& __k = this->_M_extract()(__node->_M_v());\n \t__hash_code __code;\n \t__try\n@@ -1669,7 +1669,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)\n+      _M_emplace(const_iterator __hint, false_type, _Args&&... __args)\n       -> iterator\n       {\n \t// First build the node to get its hash code.\n@@ -1711,7 +1711,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (__do_rehash.first)\n \t    {\n \t      _M_rehash(__do_rehash.second, __saved_state);\n-\t      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);\n+\t      __bkt\n+\t\t= _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);\n \t    }\n \n \t  this->_M_store_code(__node, __code);\n@@ -1896,7 +1897,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_erase(std::true_type, const key_type& __k)\n+    _M_erase(true_type, const key_type& __k)\n     -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n@@ -1920,7 +1921,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_erase(std::false_type, const key_type& __k)\n+    _M_erase(false_type, const key_type& __k)\n     -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n@@ -2038,16 +2039,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    rehash(size_type __n)\n+    rehash(size_type __bkt_count)\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n-      std::size_t __buckets\n+      __bkt_count\n \t= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),\n-\t\t   __n);\n-      __buckets = _M_rehash_policy._M_next_bkt(__buckets);\n+\t\t   __bkt_count);\n+      __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);\n \n-      if (__buckets != _M_bucket_count)\n-\t_M_rehash(__buckets, __saved_state);\n+      if (__bkt_count != _M_bucket_count)\n+\t_M_rehash(__bkt_count, __saved_state);\n       else\n \t// No rehash, restore previous state to keep it consistent with\n \t// container state.\n@@ -2061,11 +2062,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_rehash(size_type __n, const __rehash_state& __state)\n+    _M_rehash(size_type __bkt_count, const __rehash_state& __state)\n     {\n       __try\n \t{\n-\t  _M_rehash_aux(__n, __unique_keys());\n+\t  _M_rehash_aux(__bkt_count, __unique_keys());\n \t}\n       __catch(...)\n \t{\n@@ -2084,16 +2085,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_rehash_aux(size_type __n, std::true_type)\n+    _M_rehash_aux(size_type __bkt_count, true_type)\n     {\n-      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n       __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n       std::size_t __bbegin_bkt = 0;\n       while (__p)\n \t{\n \t  __node_type* __next = __p->_M_next();\n-\t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n+\t  std::size_t __bkt\n+\t    = __hash_code_base::_M_bucket_index(__p, __bkt_count);\n \t  if (!__new_buckets[__bkt])\n \t    {\n \t      __p->_M_nxt = _M_before_begin._M_nxt;\n@@ -2112,7 +2114,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       _M_deallocate_buckets();\n-      _M_bucket_count = __n;\n+      _M_bucket_count = __bkt_count;\n       _M_buckets = __new_buckets;\n     }\n \n@@ -2125,9 +2127,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_rehash_aux(size_type __n, std::false_type)\n+    _M_rehash_aux(size_type __bkt_count, false_type)\n     {\n-      __bucket_type* __new_buckets = _M_allocate_buckets(__n);\n+      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n \n       __node_type* __p = _M_begin();\n       _M_before_begin._M_nxt = nullptr;\n@@ -2139,7 +2141,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       while (__p)\n \t{\n \t  __node_type* __next = __p->_M_next();\n-\t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n+\t  std::size_t __bkt\n+\t    = __hash_code_base::_M_bucket_index(__p, __bkt_count);\n \n \t  if (__prev_p && __prev_bkt == __bkt)\n \t    {\n@@ -2166,7 +2169,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    {\n \t\t      std::size_t __next_bkt\n \t\t\t= __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n-\t\t\t\t\t\t\t    __n);\n+\t\t\t\t\t\t\t    __bkt_count);\n \t\t      if (__next_bkt != __prev_bkt)\n \t\t\t__new_buckets[__next_bkt] = __prev_p;\n \t\t    }\n@@ -2196,13 +2199,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__check_bucket && __prev_p->_M_nxt)\n \t{\n \t  std::size_t __next_bkt\n-\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);\n+\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n+\t\t\t\t\t\t__bkt_count);\n \t  if (__next_bkt != __prev_bkt)\n \t    __new_buckets[__next_bkt] = __prev_p;\n \t}\n \n       _M_deallocate_buckets();\n-      _M_bucket_count = __n;\n+      _M_bucket_count = __bkt_count;\n       _M_buckets = __new_buckets;\n     }\n "}, {"sha": "878154ae2106b67b75f1360f5640817e5e9995ba", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cfe71d1d271cd6f5d181a75a25d535e67448f0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=7cfe71d1d271cd6f5d181a75a25d535e67448f0d", "patch": "@@ -111,7 +111,7 @@ namespace __detail\n \n     public:\n       _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)\n-\t: _M_nodes(__nodes), _M_h(__h) { }\n+      : _M_nodes(__nodes), _M_h(__h) { }\n       _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;\n \n       ~_ReuseOrAllocNode()\n@@ -159,7 +159,7 @@ namespace __detail\n \n     public:\n       _AllocNode(__hashtable_alloc& __h)\n-\t: _M_h(__h) { }\n+      : _M_h(__h) { }\n \n       template<typename _Arg>\n \t__node_type*\n@@ -181,8 +181,8 @@ namespace __detail\n    *  @tparam _Cache_hash_code  Boolean value. True if the value of\n    *  the hash function is stored along with the value. This is a\n    *  time-space tradeoff.  Storing it may improve lookup speed by\n-   *  reducing the number of times we need to call the _Equal\n-   *  function.\n+   *  reducing the number of times we need to call the _Hash or _Equal\n+   *  functors.\n    *\n    *  @tparam _Constant_iterators  Boolean value. True if iterator and\n    *  const_iterator are both constant iterator types. This is true\n@@ -444,7 +444,7 @@ namespace __detail\n   /// smallest prime that keeps the load factor small enough.\n   struct _Prime_rehash_policy\n   {\n-    using __has_load_factor = std::true_type;\n+    using __has_load_factor = true_type;\n \n     _Prime_rehash_policy(float __z = 1.0) noexcept\n     : _M_max_load_factor(__z), _M_next_resize(0) { }\n@@ -521,7 +521,7 @@ namespace __detail\n   /// operations.\n   struct _Power2_rehash_policy\n   {\n-    using __has_load_factor = std::true_type;\n+    using __has_load_factor = true_type;\n \n     _Power2_rehash_policy(float __z = 1.0) noexcept\n     : _M_max_load_factor(__z), _M_next_resize(0) { }\n@@ -705,15 +705,15 @@ namespace __detail\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n \n       if (!__p)\n \t{\n \t  __p = __h->_M_allocate_node(std::piecewise_construct,\n \t\t\t\t      std::tuple<const key_type&>(__k),\n \t\t\t\t      std::tuple<>());\n-\t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n+\t  return __h->_M_insert_unique_node(__bkt, __code, __p)->second;\n \t}\n \n       return __p->_M_v().second;\n@@ -730,15 +730,15 @@ namespace __detail\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n \n       if (!__p)\n \t{\n \t  __p = __h->_M_allocate_node(std::piecewise_construct,\n \t\t\t\t      std::forward_as_tuple(std::move(__k)),\n \t\t\t\t      std::tuple<>());\n-\t  return __h->_M_insert_unique_node(__n, __code, __p)->second;\n+\t  return __h->_M_insert_unique_node(__bkt, __code, __p)->second;\n \t}\n \n       return __p->_M_v().second;\n@@ -755,8 +755,8 @@ namespace __detail\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n \n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n@@ -774,8 +774,8 @@ namespace __detail\n     {\n       const __hashtable* __h = static_cast<const __hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __n = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__n, __k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n \n       if (!__p)\n \t__throw_out_of_range(__N(\"_Map_base::at\"));\n@@ -1041,7 +1041,7 @@ namespace __detail\n \t   typename _H1, typename _H2, typename _Hash,\n \t   typename _RehashPolicy, typename _Traits,\n \t   typename =\n-\t     __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>>\n+\t     __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>\n     struct _Rehash_base;\n \n   /// Specialization when rehash policy doesn't provide load factor management.\n@@ -1051,7 +1051,7 @@ namespace __detail\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t      _H1, _H2, _Hash, _RehashPolicy, _Traits,\n-\t\t      std::false_type>\n+\t\t      false_type>\n     {\n     };\n \n@@ -1062,7 +1062,7 @@ namespace __detail\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t_H1, _H2, _Hash, _RehashPolicy, _Traits,\n-\t\t\tstd::true_type>\n+\t\t\ttrue_type>\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t     _Equal, _H1, _H2, _Hash,\n@@ -1109,7 +1109,7 @@ namespace __detail\n \n       template<typename _OtherTp>\n \t_Hashtable_ebo_helper(_OtherTp&& __tp)\n-\t  : _Tp(std::forward<_OtherTp>(__tp))\n+\t: _Tp(std::forward<_OtherTp>(__tp))\n \t{ }\n \n       const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }\n@@ -1124,7 +1124,7 @@ namespace __detail\n \n       template<typename _OtherTp>\n \t_Hashtable_ebo_helper(_OtherTp&& __tp)\n-\t  : _M_tp(std::forward<_OtherTp>(__tp))\n+\t: _M_tp(std::forward<_OtherTp>(__tp))\n \t{ }\n \n       const _Tp& _M_cget() const { return _M_tp; }\n@@ -1199,14 +1199,15 @@ namespace __detail\n       { return 0; }\n \n       std::size_t\n-      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const\n-      { return _M_ranged_hash()(__k, __n); }\n+      _M_bucket_index(const _Key& __k, __hash_code,\n+\t\t      std::size_t __bkt_count) const\n+      { return _M_ranged_hash()(__k, __bkt_count); }\n \n       std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n+      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n \tnoexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),\n \t\t\t\t\t\t   (std::size_t)0)) )\n-      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }\n+      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __bkt_count); }\n \n       void\n       _M_store_code(__node_type*, __hash_code) const\n@@ -1290,15 +1291,16 @@ namespace __detail\n       }\n \n       std::size_t\n-      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const\n-      { return _M_h2()(__c, __n); }\n+      _M_bucket_index(const _Key&, __hash_code __c,\n+\t\t      std::size_t __bkt_count) const\n+      { return _M_h2()(__c, __bkt_count); }\n \n       std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n+      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n \tnoexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))\n \t\t  && noexcept(declval<const _H2&>()((__hash_code)0,\n \t\t\t\t\t\t    (std::size_t)0)) )\n-      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }\n+      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __bkt_count); }\n \n       void\n       _M_store_code(__node_type*, __hash_code) const\n@@ -1375,14 +1377,14 @@ namespace __detail\n \n       std::size_t\n       _M_bucket_index(const _Key&, __hash_code __c,\n-\t\t      std::size_t __n) const\n-      { return _M_h2()(__c, __n); }\n+\t\t      std::size_t __bkt_count) const\n+      { return _M_h2()(__c, __bkt_count); }\n \n       std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __n) const\n+      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n \tnoexcept( noexcept(declval<const _H2&>()((__hash_code)0,\n \t\t\t\t\t\t (std::size_t)0)) )\n-      { return _M_h2()(__p->_M_hash_code, __n); }\n+      { return _M_h2()(__p->_M_hash_code, __bkt_count); }\n \n       void\n       _M_store_code(__node_type* __n, __hash_code __c) const\n@@ -1615,9 +1617,9 @@ namespace __detail\n       _Local_iterator() = default;\n \n       _Local_iterator(const __hash_code_base& __base,\n-\t\t      _Hash_node<_Value, __cache>* __p,\n+\t\t      _Hash_node<_Value, __cache>* __n,\n \t\t      std::size_t __bkt, std::size_t __bkt_count)\n-\t: __base_type(__base, __p, __bkt, __bkt_count)\n+      : __base_type(__base, __n, __bkt, __bkt_count)\n       { }\n \n       reference\n@@ -1667,16 +1669,16 @@ namespace __detail\n       _Local_const_iterator() = default;\n \n       _Local_const_iterator(const __hash_code_base& __base,\n-\t\t\t    _Hash_node<_Value, __cache>* __p,\n+\t\t\t    _Hash_node<_Value, __cache>* __n,\n \t\t\t    std::size_t __bkt, std::size_t __bkt_count)\n-\t: __base_type(__base, __p, __bkt, __bkt_count)\n+      : __base_type(__base, __n, __bkt, __bkt_count)\n       { }\n \n       _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,\n \t\t\t\t\t\t  _H1, _H2, _Hash,\n \t\t\t\t\t\t  __constant_iterators,\n \t\t\t\t\t\t  __cache>& __x)\n-\t: __base_type(__x)\n+      : __base_type(__x)\n       { }\n \n       reference\n@@ -1999,7 +2001,7 @@ namespace __detail\n \n       template<typename _Alloc>\n \t_Hashtable_alloc(_Alloc&& __a)\n-\t  : __ebo_node_alloc(std::forward<_Alloc>(__a))\n+\t: __ebo_node_alloc(std::forward<_Alloc>(__a))\n \t{ }\n \n       __node_alloc_type&\n@@ -2025,18 +2027,19 @@ namespace __detail\n       _M_deallocate_nodes(__node_type* __n);\n \n       __bucket_type*\n-      _M_allocate_buckets(std::size_t __n);\n+      _M_allocate_buckets(std::size_t __bkt_count);\n \n       void\n-      _M_deallocate_buckets(__bucket_type*, std::size_t __n);\n+      _M_deallocate_buckets(__bucket_type*, std::size_t __bkt_count);\n     };\n \n   // Definitions of class template _Hashtable_alloc's out-of-line member\n   // functions.\n   template<typename _NodeAlloc>\n     template<typename... _Args>\n-      typename _Hashtable_alloc<_NodeAlloc>::__node_type*\n+      auto\n       _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)\n+      -> __node_type*\n       {\n \tauto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);\n \t__node_type* __n = std::__to_address(__nptr);\n@@ -2087,25 +2090,25 @@ namespace __detail\n \n   template<typename _NodeAlloc>\n     typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*\n-    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)\n+    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)\n     {\n       __bucket_alloc_type __alloc(_M_node_allocator());\n \n-      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);\n+      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __bkt_count);\n       __bucket_type* __p = std::__to_address(__ptr);\n-      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));\n+      __builtin_memset(__p, 0, __bkt_count * sizeof(__bucket_type));\n       return __p;\n     }\n \n   template<typename _NodeAlloc>\n     void\n     _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,\n-\t\t\t\t\t\t\tstd::size_t __n)\n+\t\t\t\t\t\t\tstd::size_t __bkt_count)\n     {\n       typedef typename __bucket_alloc_traits::pointer _Ptr;\n       auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);\n       __bucket_alloc_type __alloc(_M_node_allocator());\n-      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);\n+      __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);\n     }\n \n  //@} hashtable-detail"}]}