{"sha": "8c4e33d2032ab150748ea2fe1df2b1c00652a338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0ZTMzZDIwMzJhYjE1MDc0OGVhMmZlMWRmMmIxYzAwNjUyYTMzOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T10:04:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-13T11:01:24Z"}, "message": "libstdc++: Add -pthread options to std::future polling test\n\nFor linux targets this test doesn't need -lpthread because it only uses\natomics, but for all other targets std::call_once still needs pthreads.\nAdd the necessary test directives to make that work.\n\nThe timings in this test might be too fragile or too target-specific, so\nit might need to be adjusted in future, or restricted to only run on\nspecific targets. For now I've increased the allowed ratio between\nwait_for calls before and after the future is made ready, because it was\nfailing with -O3 -march=native sometimes.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/30_threads/future/members/poll.cc: Require gthreads\n\tand add -pthread for targets that require it. Relax required\n\tratio of wait_for calls before/after the future is ready.", "tree": {"sha": "85eb37e427e50f2c729db2a920a869dd82f39d4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85eb37e427e50f2c729db2a920a869dd82f39d4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4e33d2032ab150748ea2fe1df2b1c00652a338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4e33d2032ab150748ea2fe1df2b1c00652a338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4e33d2032ab150748ea2fe1df2b1c00652a338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4e33d2032ab150748ea2fe1df2b1c00652a338/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54bbde550ec557e48a67ca1f4036e46710bcfeda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bbde550ec557e48a67ca1f4036e46710bcfeda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bbde550ec557e48a67ca1f4036e46710bcfeda"}], "stats": {"total": 40, "additions": 21, "deletions": 19}, "files": [{"sha": "fff9bea899c901010c002428863db4ac8ce6521f", "filename": "libstdc++-v3/testsuite/30_threads/future/members/poll.cc", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4e33d2032ab150748ea2fe1df2b1c00652a338/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4e33d2032ab150748ea2fe1df2b1c00652a338/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc?ref=8c4e33d2032ab150748ea2fe1df2b1c00652a338", "patch": "@@ -17,6 +17,8 @@\n \n // { dg-options \"-O3\" }\n // { dg-do run { target c++11 } }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-require-gthreads \"\" }\n \n #include <future>\n #include <chrono>\n@@ -51,31 +53,31 @@ int main()\n \n   start = chrono::high_resolution_clock::now();\n   for(int i = 0; i < iterations; i++)\n-    f.wait_until(chrono::system_clock::time_point());\n+    f.wait_until(chrono::system_clock::time_point::min());\n   stop = chrono::high_resolution_clock::now();\n-  double wait_until_sys_epoch __attribute__((unused))\n-    = print(\"wait_until(system_clock epoch)\", stop - start);\n+  double wait_until_sys_min __attribute__((unused))\n+    = print(\"wait_until(system_clock minimum)\", stop - start);\n \n   start = chrono::high_resolution_clock::now();\n   for(int i = 0; i < iterations; i++)\n-    f.wait_until(chrono::steady_clock::time_point());\n+    f.wait_until(chrono::steady_clock::time_point::min());\n   stop = chrono::high_resolution_clock::now();\n-  double wait_until_steady_epoch __attribute__((unused))\n-    = print(\"wait_until(steady_clock epoch\", stop - start);\n+  double wait_until_steady_min __attribute__((unused))\n+    = print(\"wait_until(steady_clock minimum)\", stop - start);\n \n   start = chrono::high_resolution_clock::now();\n   for(int i = 0; i < iterations; i++)\n-    f.wait_until(chrono::system_clock::time_point::min());\n+    f.wait_until(chrono::system_clock::time_point());\n   stop = chrono::high_resolution_clock::now();\n-  double wait_until_sys_min __attribute__((unused))\n-    = print(\"wait_until(system_clock minimum)\", stop - start);\n+  double wait_until_sys_epoch __attribute__((unused))\n+    = print(\"wait_until(system_clock epoch)\", stop - start);\n \n   start = chrono::high_resolution_clock::now();\n   for(int i = 0; i < iterations; i++)\n-    f.wait_until(chrono::steady_clock::time_point::min());\n+    f.wait_until(chrono::steady_clock::time_point());\n   stop = chrono::high_resolution_clock::now();\n-  double wait_until_steady_min __attribute__((unused))\n-    = print(\"wait_until(steady_clock minimum)\", stop - start);\n+  double wait_until_steady_epoch __attribute__((unused))\n+    = print(\"wait_until(steady_clock epoch\", stop - start);\n \n   p.set_value(1);\n \n@@ -85,19 +87,19 @@ int main()\n   stop = chrono::high_resolution_clock::now();\n   double ready = print(\"wait_for when ready\", stop - start);\n \n-  // polling before ready with wait_for(0s) should be almost as fast as\n+  // Polling before ready with wait_for(0s) should be almost as fast as\n   // after the result is ready.\n-  VERIFY( wait_for_0 < (ready * 10) );\n+  VERIFY( wait_for_0 < (ready * 30) );\n+\n+  // Polling before ready using wait_until(min) should not be terribly slow.\n+  VERIFY( wait_until_sys_min < (ready * 100) );\n+  VERIFY( wait_until_steady_min < (ready * 100) );\n \n   // The following two tests fail with GCC 11, see\n   // https://gcc.gnu.org/pipermail/libstdc++/2020-November/051422.html\n #if 0\n-  // polling before ready using wait_until(epoch) should not be terribly slow.\n+  // Polling before ready using wait_until(epoch) should not be terribly slow.\n   VERIFY( wait_until_sys_epoch < (ready * 100) );\n   VERIFY( wait_until_steady_epoch < (ready * 100) );\n #endif\n-\n-  // polling before ready using wait_until(min) should not be terribly slow.\n-  VERIFY( wait_until_sys_min < (ready * 100) );\n-  VERIFY( wait_until_steady_min < (ready * 100) );\n }"}]}