{"sha": "1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY5MmRhODcxNzljMzUzZWNmOGU1YTE5YzYwZmNkNzhiMjdjM2E2Yw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-12-11T10:22:43Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-12-11T10:22:43Z"}, "message": "m32r.c: Convert to ISO-C\n\n* config/m32r/m32r.c: Convert to ISO-C\n* doc/invoke.texi: Replace Mitsubishi with Renesas.\n* config/m32r/m32r.h: Ditto.\n* config/m32r/m32r.c: Ditto.\n* config/m32r/m32r.md: Ditto.\n\nFrom-SVN: r74533", "tree": {"sha": "f50ddf057c320c7fc9ea5a3f8a772b1f5b2b976f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50ddf057c320c7fc9ea5a3f8a772b1f5b2b976f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/comments", "author": null, "committer": null, "parents": [{"sha": "645112ddccf26d5b22cb8add2eb624f731d1514c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/645112ddccf26d5b22cb8add2eb624f731d1514c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/645112ddccf26d5b22cb8add2eb624f731d1514c"}], "stats": {"total": 560, "additions": 221, "deletions": 339}, "files": [{"sha": "7264d56b840e84650f8028af5c5737925465f53a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "patch": "@@ -1,3 +1,14 @@\n+2003-12-12  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/m32r/m32r.c: Convert to ISO-C\n+\n+2003-12-12  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>\n+\n+\t* doc/invoke.texi: Replace Mitsubishi with Renesas.\n+\t* config/m32r/m32r.h: Ditto.\n+\t* config/m32r/m32r.c: Ditto.\n+\t* config/m32r/m32r.md: Ditto.\n+\n 2003-12-11  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* basic-block.h (BLOCK_HEAD, BLOCK_END): Remove."}, {"sha": "c7c197defe3480d2de2c96bfb076596524095d24", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 184, "deletions": 313, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "patch": "@@ -1,23 +1,23 @@\n-/* Subroutines used for code generation on the Mitsubishi M32R cpu.\n+/* Subroutines used for code generation on the Renesas M32R cpu.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -92,51 +92,51 @@ static void init_idents (void);\n static bool m32r_rtx_costs (rtx, int, int, int *);\n \f\n /* Initialize the GCC target structure.  */\n-#undef TARGET_ATTRIBUTE_TABLE\n+#undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n \n-#undef TARGET_ASM_ALIGNED_HI_OP\n+#undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n+#undef  TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE m32r_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#undef  TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE m32r_output_function_epilogue\n \n-#undef TARGET_ASM_FILE_START\n+#undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START m32r_file_start\n \n-#undef TARGET_SCHED_ADJUST_COST\n+#undef  TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST m32r_adjust_cost\n-#undef TARGET_SCHED_ADJUST_PRIORITY\n+#undef  TARGET_SCHED_ADJUST_PRIORITY\n #define TARGET_SCHED_ADJUST_PRIORITY m32r_adjust_priority\n-#undef TARGET_SCHED_ISSUE_RATE\n+#undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE m32r_issue_rate\n-#undef TARGET_SCHED_VARIABLE_ISSUE\n+#undef  TARGET_SCHED_VARIABLE_ISSUE\n #define TARGET_SCHED_VARIABLE_ISSUE m32r_variable_issue\n-#undef TARGET_SCHED_INIT\n+#undef  TARGET_SCHED_INIT\n #define TARGET_SCHED_INIT m32r_sched_init\n-#undef TARGET_SCHED_REORDER\n+#undef  TARGET_SCHED_REORDER\n #define TARGET_SCHED_REORDER m32r_sched_reorder\n \n-#undef TARGET_ENCODE_SECTION_INFO\n+#undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO m32r_encode_section_info\n-#undef TARGET_IN_SMALL_DATA_P\n+#undef  TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P m32r_in_small_data_p\n \n-#undef TARGET_RTX_COSTS\n+#undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m32r_rtx_costs\n-#undef TARGET_ADDRESS_COST\n+#undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n \n void\n-m32r_init ()\n+m32r_init (void)\n {\n   init_reg_tables ();\n \n@@ -213,7 +213,7 @@ unsigned int m32r_mode_class [NUM_MACHINE_MODES];\n enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n static void\n-init_reg_tables ()\n+init_reg_tables (void)\n {\n   int i;\n \n@@ -278,8 +278,7 @@ init_reg_tables ()\n \tmedium: addresses use 32 bits, use bl to make calls\n \tlarge: addresses use 32 bits, use seth/add3/jl to make calls\n \n-\tGrep for MODEL in m32r.h for more info.\n-*/\n+\tGrep for MODEL in m32r.h for more info.  */\n \n static tree small_ident1;\n static tree small_ident2;\n@@ -289,7 +288,7 @@ static tree large_ident1;\n static tree large_ident2;\n \n static void\n-init_idents ()\n+init_idents (void)\n {\n   if (small_ident1 == 0)\n     {\n@@ -314,12 +313,9 @@ const struct attribute_spec m32r_attribute_table[] =\n /* Handle an \"model\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-m32r_handle_model_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node ATTRIBUTE_UNUSED;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+m32r_handle_model_attribute (tree *node ATTRIBUTE_UNUSED, tree name,\n+\t\t\t     tree args, int flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool *no_add_attrs)\n {\n   tree arg;\n \n@@ -351,10 +347,7 @@ m32r_handle_model_attribute (node, name, args, flags, no_add_attrs)\n */\n \n static void\n-m32r_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+m32r_encode_section_info (tree decl, rtx rtl, int first)\n {\n   int extra_flags = 0;\n   tree model_attr;\n@@ -411,8 +404,7 @@ m32r_encode_section_info (decl, rtl, first)\n    the object doesn't fit the linker will give an error.  */\n \n static bool\n-m32r_in_small_data_p (decl)\n-     tree decl;\n+m32r_in_small_data_p (tree decl)\n {\n   tree section;\n \n@@ -446,7 +438,7 @@ m32r_in_small_data_p (decl)\n /* Do anything needed before RTL is emitted for each function.  */\n \n void\n-m32r_init_expanders ()\n+m32r_init_expanders (void)\n {\n   /* ??? At one point there was code here.  The function is left in\n      to make it easy to experiment.  */\n@@ -455,9 +447,7 @@ m32r_init_expanders ()\n /* Acceptable arguments to the call insn.  */\n \n int\n-call_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_address_operand (rtx op, enum machine_mode mode)\n {\n   return symbolic_operand (op, mode);\n \n@@ -466,9 +456,7 @@ call_address_operand (op, mode)\n }\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -479,9 +467,7 @@ call_operand (op, mode)\n /* Returns 1 if OP is a symbol reference.  */\n \n int\n-symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (op))\n     {\n@@ -498,9 +484,7 @@ symbolic_operand (op, mode)\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n-small_data_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_data_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! TARGET_SDATA_USE)\n     return 0;\n@@ -521,9 +505,7 @@ small_data_operand (op, mode)\n /* Return 1 if OP is a symbol that can use 24 bit addressing.  */\n \n int\n-addr24_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx sym;\n \n@@ -555,9 +537,7 @@ addr24_operand (op, mode)\n /* Return 1 if OP is a symbol that needs 32 bit addressing.  */\n \n int\n-addr32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+addr32_operand (rtx op, enum machine_mode mode)\n {\n   rtx sym;\n \n@@ -581,9 +561,7 @@ addr32_operand (op, mode)\n /* Return 1 if OP is a function that can be called with the `bl' insn.  */\n \n int\n-call26_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+call26_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SYMBOL_REF)\n     return SYMBOL_REF_MODEL (op) != M32R_MODEL_LARGE;\n@@ -594,9 +572,7 @@ call26_operand (op, mode)\n /* Returns 1 if OP is an acceptable operand for seth/add3.  */\n \n int\n-seth_add3_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+seth_add3_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       || GET_CODE (op) == LABEL_REF)\n@@ -615,9 +591,7 @@ seth_add3_operand (op, mode)\n /* Return true if OP is a signed 8 bit immediate value.  */\n \n int\n-int8_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+int8_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -628,9 +602,7 @@ int8_operand (op, mode)\n    useful in comparisons.  */\n \n int\n-cmp_int16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cmp_int16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -640,9 +612,7 @@ cmp_int16_operand (op, mode)\n /* Return true if OP is an unsigned 16 bit immediate value.  */\n \n int\n-uint16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+uint16_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -652,9 +622,7 @@ uint16_operand (op, mode)\n /* Return true if OP is a register or signed 16 bit value.  */\n \n int\n-reg_or_int16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_int16_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n@@ -666,9 +634,7 @@ reg_or_int16_operand (op, mode)\n /* Return true if OP is a register or an unsigned 16 bit value.  */\n \n int\n-reg_or_uint16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_uint16_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n@@ -683,9 +649,7 @@ reg_or_uint16_operand (op, mode)\n    because that is special cased.  */\n \n int\n-reg_or_eq_int16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_eq_int16_operand (rtx op, enum machine_mode mode)\n {\n   HOST_WIDE_INT value;\n \n@@ -702,9 +666,7 @@ reg_or_eq_int16_operand (op, mode)\n /* Return true if OP is a register or signed 16 bit value for compares.  */\n \n int\n-reg_or_cmp_int16_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_cmp_int16_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n@@ -716,9 +678,7 @@ reg_or_cmp_int16_operand (op, mode)\n /* Return true if OP is a register or the constant 0.  */\n \n int\n-reg_or_zero_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_zero_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n@@ -732,9 +692,7 @@ reg_or_zero_operand (op, mode)\n /* Return true if OP is a const_int requiring two instructions to load.  */\n \n int\n-two_insn_const_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+two_insn_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -749,9 +707,7 @@ two_insn_const_operand (op, mode)\n    move source.  */\n \n int\n-move_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_src_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -809,9 +765,7 @@ move_src_operand (op, mode)\n    move source.  */\n \n int\n-move_double_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_double_src_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -841,9 +795,7 @@ move_double_src_operand (op, mode)\n /* Return true if OP is an acceptable argument for a move destination.  */\n \n int\n-move_dest_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+move_dest_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -870,8 +822,7 @@ move_dest_operand (op, mode)\n    It is used by the 'G' CONST_DOUBLE_OK_FOR_LETTER.  */\n \n int\n-easy_di_const (op)\n-     rtx op;\n+easy_di_const (rtx op)\n {\n   rtx high_rtx, low_rtx;\n   HOST_WIDE_INT high, low;\n@@ -891,8 +842,7 @@ easy_di_const (op)\n    It is used by the 'H' CONST_DOUBLE_OK_FOR_LETTER.  */\n \n int\n-easy_df_const (op)\n-     rtx op;\n+easy_df_const (rtx op)\n {\n   REAL_VALUE_TYPE r;\n   long l[2];\n@@ -909,9 +859,7 @@ easy_df_const (op)\n /* Return 1 if OP is an EQ or NE comparison operator.  */\n \n int\n-eqne_comparison_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+eqne_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -923,9 +871,7 @@ eqne_comparison_operator (op, mode)\n /* Return 1 if OP is a signed comparison operator.  */\n \n int\n-signed_comparison_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+signed_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -939,9 +885,7 @@ signed_comparison_operator (op, mode)\n    This is used in insn length calcs.  */\n \n int\n-memreg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n }\n@@ -950,9 +894,7 @@ memreg_operand (op, mode)\n    operation.  */\n \n int\n-extend_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+extend_operand (rtx op, enum machine_mode mode)\n {\n   rtx addr;\n \n@@ -978,9 +920,7 @@ extend_operand (op, mode)\n    Allow const_int 0 as well, which is a placeholder for NOP slots.  */\n \n int\n-small_insn_p (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_insn_p (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n     return 1;\n@@ -994,9 +934,7 @@ small_insn_p (op, mode)\n /* Return nonzero if the operand is an insn that is a large insn.  */\n \n int\n-large_insn_p (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+large_insn_p (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (! INSN_P (op))\n     return 0;\n@@ -1009,8 +947,7 @@ large_insn_p (op, mode)\n    in this function.  */\n \n int\n-m32r_pass_by_reference (type)\n-     tree type;\n+m32r_pass_by_reference (tree type)\n {\n   int size = int_size_in_bytes (type);\n \n@@ -1028,12 +965,10 @@ m32r_pass_by_reference (type)\n    than being subsumed into the following branch instruction.  */\n \n rtx\n-gen_compare (code, x, y, need_compare)\n-     enum rtx_code code;\n-     rtx x, y;\n-     int need_compare;\n+gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n {\n-  enum rtx_code compare_code, branch_code;\n+  enum rtx_code compare_code;\n+  enum rtx_code branch_code;\n   rtx cc_reg = gen_rtx_REG (CCmode, CARRY_REGNUM);\n   int must_swap = 0;\n \n@@ -1060,7 +995,7 @@ gen_compare (code, x, y, need_compare)\n \t{\n \tcase EQ:\n \t  if (GET_CODE (y) == CONST_INT\n-\t      && CMP_INT16_P (INTVAL (y))\t\t/* reg equal to small const.  */\n+\t      && CMP_INT16_P (INTVAL (y))\t\t/* Reg equal to small const.  */\n \t      && y != const0_rtx)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\t\t\n@@ -1069,14 +1004,14 @@ gen_compare (code, x, y, need_compare)\n \t      x = tmp;\n \t      y = const0_rtx;\n \t    }\n-\t  else if (CONSTANT_P (y))\t\t\t/* reg equal to const.  */\n+\t  else if (CONSTANT_P (y))\t\t\t/* Reg equal to const.  */\n \t    {\n \t      rtx tmp = force_reg (GET_MODE (x), y);\n \t      y = tmp;\n \t    }\n \n-\t  if (register_operand (y, SImode) \t\t/* reg equal to reg.  */\n-\t      || y == const0_rtx) \t   \t\t/* req equal to zero. */\n+\t  if (register_operand (y, SImode) \t\t/* Reg equal to reg.  */\n+\t      || y == const0_rtx) \t   \t\t/* Reg equal to zero.  */\n \t    {\n \t      emit_insn (gen_cmp_eqsi_insn (x, y));\n \t\t\n@@ -1088,7 +1023,7 @@ gen_compare (code, x, y, need_compare)\n \t  if (register_operand (y, SImode)\n \t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n \t    {\n-\t      rtx tmp = gen_reg_rtx (SImode);\t      /* reg compared to reg. */\n+\t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg compared to reg.  */\n \t      \n \t      switch (code)\n \t\t{\n@@ -1128,7 +1063,7 @@ gen_compare (code, x, y, need_compare)\n \t  if (register_operand (y, SImode)\n \t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n \t    {\n-\t      rtx tmp = gen_reg_rtx (SImode);\t      /* reg (unsigned) compared to reg. */\n+\t      rtx tmp = gen_reg_rtx (SImode);\t      /* Reg (unsigned) compared to reg.  */\n \t      \n \t      switch (code)\n \t\t{\n@@ -1170,31 +1105,33 @@ gen_compare (code, x, y, need_compare)\n     }\n   else\n     {\n-      /* reg/reg equal comparison */\n+      /* Reg/reg equal comparison.  */\n       if (compare_code == EQ\n \t  && register_operand (y, SImode))\n \treturn gen_rtx (code, CCmode, x, y);\n       \n-      /* reg/zero signed comparison */\n+      /* Reg/zero signed comparison.  */\n       if ((compare_code == EQ || compare_code == LT)\n \t  && y == const0_rtx)\n \treturn gen_rtx (code, CCmode, x, y);\n       \n-      /* reg/smallconst equal comparison */\n+      /* Reg/smallconst equal comparison.  */\n       if (compare_code == EQ\n \t  && GET_CODE (y) == CONST_INT\n \t  && CMP_INT16_P (INTVAL (y)))\n \t{\n \t  rtx tmp = gen_reg_rtx (SImode);\n+\n \t  emit_insn (gen_cmp_ne_small_const_insn (tmp, x, y));\n \t  return gen_rtx (code, CCmode, tmp, const0_rtx);\n \t}\n       \n-      /* reg/const equal comparison */\n+      /* Reg/const equal comparison.  */\n       if (compare_code == EQ\n \t  && CONSTANT_P (y))\n \t{\n \t  rtx tmp = force_reg (GET_MODE (x), y);\n+\n \t  return gen_rtx (code, CCmode, x, tmp);\n \t}\n     }\n@@ -1237,8 +1174,7 @@ gen_compare (code, x, y, need_compare)\n /* Split a 2 word move (DI or DF) into component parts.  */\n \n rtx\n-gen_split_move_double (operands)\n-     rtx operands[];\n+gen_split_move_double (rtx operands[])\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n   rtx dest = operands[0];\n@@ -1258,7 +1194,7 @@ gen_split_move_double (operands)\n     {\n       int dregno = REGNO (dest);\n \n-      /* reg = reg */\n+      /* Reg = reg.  */\n       if (GET_CODE (src) == REG)\n \t{\n \t  int sregno = REGNO (src);\n@@ -1277,7 +1213,7 @@ gen_split_move_double (operands)\n \t\t\t\t  operand_subword (src,  !reverse, TRUE, mode)));\n \t}\n \n-      /* reg = constant */\n+      /* Reg = constant.  */\n       else if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n \t{\n \t  rtx words[2];\n@@ -1291,7 +1227,7 @@ gen_split_move_double (operands)\n \t\t\t\t  words[1]));\n \t}\n \n-      /* reg = mem */\n+      /* Reg = mem.  */\n       else if (GET_CODE (src) == MEM)\n \t{\n \t  /* If the high-address word is used in the address, we must load it\n@@ -1320,12 +1256,11 @@ gen_split_move_double (operands)\n \t\t\t\t  adjust_address (src, SImode,\n \t\t\t\t\t\t  !reverse * UNITS_PER_WORD)));\n \t}\n-\n       else\n \tabort ();\n     }\n \n-  /* mem = reg */\n+  /* Mem = reg.  */\n   /* We used to optimize loads from single registers as\n \n \tst r1,r3; st r2,+r3\n@@ -1360,11 +1295,8 @@ gen_split_move_double (operands)\n /* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n {\n   int ret;\n   unsigned int size =\n@@ -1391,12 +1323,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n    and mode MODE, and we rely on this fact.  */\n \n void\n-m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int *pretend_size;\n-     int no_rtl;\n+m32r_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t     tree type, int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n \n@@ -1432,8 +1360,7 @@ m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n /* Implement `va_arg'.  */\n \n rtx\n-m32r_va_arg (valist, type)\n-     tree valist, type;\n+m32r_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize;\n   tree t;\n@@ -1447,7 +1374,6 @@ m32r_va_arg (valist, type)\n       tree type_ptr, type_ptr_ptr;\n \n       /* Pass by reference.  */\n-\n       type_ptr = build_pointer_type (type);\n       type_ptr_ptr = build_pointer_type (type_ptr);\n \n@@ -1463,7 +1389,6 @@ m32r_va_arg (valist, type)\n   else\n     {\n       /* Pass by value.  */\n-\n       if (size < UNITS_PER_WORD)\n \t{\n \t  /* Care for bigendian correction on the aligned address.  */\n@@ -1492,11 +1417,8 @@ m32r_va_arg (valist, type)\n }\n \f\n static int\n-m32r_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx link ATTRIBUTE_UNUSED;\n-     rtx dep_insn ATTRIBUTE_UNUSED;\n-     int cost;\n+m32r_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link ATTRIBUTE_UNUSED,\n+\t\t  rtx dep_insn ATTRIBUTE_UNUSED, int cost)\n {\n   return cost;\n }\n@@ -1505,8 +1427,7 @@ m32r_adjust_cost (insn, link, dep_insn, cost)\n /* Return true if INSN is real instruction bearing insn.  */\n \n static int\n-m32r_is_insn (insn)\n-     rtx insn;\n+m32r_is_insn (rtx insn)\n {\n   return (INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) != USE\n@@ -1518,9 +1439,7 @@ m32r_is_insn (insn)\n    short instructions are scheduled ahead of the long ones.  */\n \n static int\n-m32r_adjust_priority (insn, priority)\n-     rtx insn;\n-     int priority;\n+m32r_adjust_priority (rtx insn, int priority)\n {\n   if (m32r_is_insn (insn)\n       && get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n@@ -1533,10 +1452,9 @@ m32r_adjust_priority (insn, priority)\n /* Initialize for scheduling a group of instructions.  */\n \n static void\n-m32r_sched_init (stream, verbose, max_ready)\n-     FILE * stream ATTRIBUTE_UNUSED;\n-     int verbose ATTRIBUTE_UNUSED;\n-     int max_ready ATTRIBUTE_UNUSED;\n+m32r_sched_init (FILE * stream ATTRIBUTE_UNUSED,\n+\t\t int verbose ATTRIBUTE_UNUSED,\n+\t\t int max_ready ATTRIBUTE_UNUSED)\n {\n   m32r_sched_odd_word_p = FALSE;\n }\n@@ -1545,12 +1463,8 @@ m32r_sched_init (stream, verbose, max_ready)\n /* Reorder the schedulers priority list if needed */\n \n static int\n-m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n-     FILE * stream;\n-     int verbose;\n-     rtx * ready;\n-     int *n_readyp;\n-     int clock ATTRIBUTE_UNUSED;\n+m32r_sched_reorder (FILE * stream, int verbose, rtx * ready,\n+\t\t    int *n_readyp, int clock ATTRIBUTE_UNUSED)\n {\n   int n_ready = *n_readyp;\n \n@@ -1568,11 +1482,11 @@ m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n \n   if (n_ready > 1)\n     {\n-      rtx * long_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * long_head = alloca (sizeof (rtx) * n_ready);\n       rtx * long_tail = long_head;\n-      rtx * short_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * short_head = alloca (sizeof (rtx) * n_ready);\n       rtx * short_tail = short_head;\n-      rtx * new_head = (rtx *) alloca (sizeof (rtx) * n_ready);\n+      rtx * new_head = alloca (sizeof (rtx) * n_ready);\n       rtx * new_tail = new_head + (n_ready - 1);\n       int   i;\n \n@@ -1611,19 +1525,19 @@ m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n \t}\n \n       /* If we are on an odd word, emit a single short instruction if\n-\t we can */\n+\t we can.  */\n       if (m32r_sched_odd_word_p && short_head != short_tail)\n \t*new_tail-- = *short_head++;\n \n-      /* Now dump out all of the long instructions */\n+      /* Now dump out all of the long instructions.  */\n       while (long_head != long_tail)\n \t*new_tail-- = *long_head++;\n \n-      /* Now dump out all of the short instructions */\n+      /* Now dump out all of the short instructions.  */\n       while (short_head != short_tail)\n \t*new_tail-- = *short_head++;\n \n-      if (new_tail+1 != new_head)\n+      if (new_tail + 1 != new_head)\n \tabort ();\n \n       memcpy (ready, new_head, sizeof (rtx) * n_ready);\n@@ -1657,22 +1571,20 @@ m32r_sched_reorder (stream, verbose, ready, n_readyp, clock)\n    This is sort of a lie.  The m32r can issue only 1 long insn at\n    once, but it can issue 2 short insns.  The default therefore is\n    set at 2, but this can be overridden by the command line option\n-   -missue-rate=1 */\n+   -missue-rate=1.  */\n+\n static int\n-m32r_issue_rate ()\n+m32r_issue_rate (void)\n {\n   return ((TARGET_LOW_ISSUE_RATE) ? 1 : 2);\n }\n \n /* If we have a machine that can issue a variable # of instructions\n    per cycle, indicate how many more instructions can be issued\n    after the current one.  */\n+\n static int\n-m32r_variable_issue (stream, verbose, insn, how_many)\n-     FILE * stream;\n-     int verbose;\n-     rtx insn;\n-     int how_many;\n+m32r_variable_issue (FILE * stream, int verbose, rtx insn, int how_many)\n {\n   int orig_odd_word_p = m32r_sched_odd_word_p;\n   int short_p = FALSE;\n@@ -1709,10 +1621,7 @@ m32r_variable_issue (stream, verbose, insn, how_many)\n /* Cost functions.  */\n \n static bool\n-m32r_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n+m32r_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n {\n   switch (code)\n     {\n@@ -1736,6 +1645,7 @@ m32r_rtx_costs (x, code, outer_code, total)\n     case CONST_DOUBLE:\n       {\n \trtx high, low;\n+\n \tsplit_double (x, &high, &low);\n \t*total = COSTS_N_INSNS (!INT16_P (INTVAL (high))\n \t\t\t        + !INT16_P (INTVAL (low)));\n@@ -1764,8 +1674,7 @@ m32r_rtx_costs (x, code, outer_code, total)\n    call with DECL = NULL_TREE.  */\n \n enum m32r_function_type\n-m32r_compute_function_type (decl)\n-     tree decl;\n+m32r_compute_function_type (tree decl)\n {\n   /* Cached value.  */\n   static enum m32r_function_type fn_type = M32R_FUNCTION_UNKNOWN;\n@@ -1838,23 +1747,22 @@ m32r_compute_function_type (decl)\n    containing anonymous args separately but that complicates things too\n    much (so it's not done).\n 3) The return address is saved after the register save area so as to have as\n-   many insns as possible between the restoration of `lr' and the `jmp lr'.\n-*/\n+   many insns as possible between the restoration of `lr' and the `jmp lr'.  */\n \n /* Structure to be filled in by m32r_compute_frame_size with register\n    save masks, and offsets for the current function.  */\n struct m32r_frame_info\n {\n-  unsigned int total_size;\t/* # bytes that the entire frame takes up */\n-  unsigned int extra_size;\t/* # bytes of extra stuff */\n-  unsigned int pretend_size;\t/* # bytes we push and pretend caller did */\n-  unsigned int args_size;\t/* # bytes that outgoing arguments take up */\n-  unsigned int reg_size;\t/* # bytes needed to store regs */\n-  unsigned int var_size;\t/* # bytes that variables take up */\n-  unsigned int gmask;\t\t/* mask of saved gp registers */\n-  unsigned int save_fp;\t\t/* nonzero if fp must be saved */\n-  unsigned int save_lr;\t\t/* nonzero if lr (return addr) must be saved */\n-  int          initialized;\t/* nonzero if frame size already calculated */\n+  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned int extra_size;\t/* # bytes of extra stuff.  */\n+  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n+  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n+  unsigned int var_size;\t/* # bytes that variables take up.  */\n+  unsigned int gmask;\t\t/* Mask of saved gp registers.  */\n+  unsigned int save_fp;\t\t/* Nonzero if fp must be saved.  */\n+  unsigned int save_lr;\t\t/* Nonzero if lr (return addr) must be saved.  */\n+  int          initialized;\t/* Nonzero if frame size already calculated.  */\n };\n \n /* Current frame information calculated by m32r_compute_frame_size.  */\n@@ -1864,7 +1772,7 @@ static struct m32r_frame_info current_frame_info;\n static struct m32r_frame_info zero_frame_info;\n \n #define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n-#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+#define RETURN_ADDR_MASK   (1 << (RETURN_ADDR_REGNUM))\n \n /* Tell prologue and epilogue if register REGNO should be saved / restored.\n    The return address and frame pointer are treated separately.\n@@ -1874,19 +1782,18 @@ static struct m32r_frame_info zero_frame_info;\n  && (regs_ever_live[regno] && (!call_used_regs[regno] || interrupt_p)))\n \n #define MUST_SAVE_FRAME_POINTER (regs_ever_live[FRAME_POINTER_REGNUM])\n-#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM] || current_function_profile)\n+#define MUST_SAVE_RETURN_ADDR   (regs_ever_live[RETURN_ADDR_REGNUM] || current_function_profile)\n \n-#define SHORT_INSN_SIZE 2\t/* size of small instructions */\n-#define LONG_INSN_SIZE 4\t/* size of long instructions */\n+#define SHORT_INSN_SIZE 2\t/* Size of small instructions.  */\n+#define LONG_INSN_SIZE 4\t/* Size of long instructions.  */\n \n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.\n \n    SIZE is the size needed for local variables.  */\n \n unsigned int\n-m32r_compute_frame_size (size)\n-     int size;\t\t\t/* # of var. bytes allocated.  */\n+m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n@@ -1909,7 +1816,6 @@ m32r_compute_frame_size (size)\n   interrupt_p = M32R_INTERRUPT_P (fn_type);\n \n   /* Calculate space needed for registers.  */\n-\n   for (regno = 0; regno < M32R_MAX_INT_REGS; regno++)\n     {\n       if (MUST_SAVE_REGISTER (regno, interrupt_p))\n@@ -1951,7 +1857,7 @@ m32r_compute_frame_size (size)\n    function.  If not specified, 0 is used.  */\n \n int\n-m32r_first_insn_address ()\n+m32r_first_insn_address (void)\n {\n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n@@ -1962,7 +1868,7 @@ m32r_first_insn_address ()\n /* Expand the m32r prologue as a series of insns.  */\n \n void\n-m32r_expand_prologue ()\n+m32r_expand_prologue (void)\n {\n   int regno;\n   int frame_size;\n@@ -1989,7 +1895,6 @@ m32r_expand_prologue ()\n     }\n \n   /* Save any registers we need to and set up fp.  */\n-\n   if (current_frame_info.save_fp)\n     emit_insn (gen_movsi_push (stack_pointer_rtx, frame_pointer_rtx));\n \n@@ -2014,13 +1919,14 @@ m32r_expand_prologue ()\n \t\t   + current_frame_info.reg_size));\n \n   if (frame_size == 0)\n-    ; /* nothing to do */\n+    ; /* Nothing to do.  */\n   else if (frame_size <= 32768)\n     emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t   GEN_INT (-frame_size)));\n   else\n     {\n       rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+\n       emit_insn (gen_movsi (tmp, GEN_INT (frame_size)));\n       emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n     }\n@@ -2038,18 +1944,13 @@ m32r_expand_prologue ()\n    m32r_compute_frame_size which calculates the prolog size.  */\n \n static void\n-m32r_output_function_prologue (file, size)\n-     FILE * file;\n-     HOST_WIDE_INT size;\n+m32r_output_function_prologue (FILE * file, HOST_WIDE_INT size)\n {\n   enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n \n   /* If this is an interrupt handler, mark it as such.  */\n   if (M32R_INTERRUPT_P (fn_type))\n-    {\n-      fprintf (file, \"\\t%s interrupt handler\\n\",\n-\t       ASM_COMMENT_START);\n-    }\n+    fprintf (file, \"\\t%s interrupt handler\\n\", ASM_COMMENT_START);\n \n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (size);\n@@ -2068,9 +1969,7 @@ m32r_output_function_prologue (file, size)\n    and regs. */\n \n static void\n-m32r_output_function_epilogue (file, size)\n-     FILE * file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+m32r_output_function_epilogue (FILE * file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   int regno;\n   int noepilogue = FALSE;\n@@ -2111,7 +2010,7 @@ m32r_output_function_epilogue (file, size)\n \t{\n \t  unsigned int reg_offset = var_size + args_size;\n \t  if (reg_offset == 0)\n-\t    ; /* nothing to do */\n+\t    ; /* Nothing to do.  */\n \t  else if (reg_offset < 128)\n \t    fprintf (file, \"\\taddi %s,%s%d\\n\",\n \t\t     sp_str, IMMEDIATE_PREFIX, reg_offset);\n@@ -2127,6 +2026,7 @@ m32r_output_function_epilogue (file, size)\n       else if (frame_pointer_needed)\n \t{\n \t  unsigned int reg_offset = var_size + args_size;\n+\n \t  if (reg_offset == 0)\n \t    fprintf (file, \"\\tmv %s,%s\\n\", sp_str, fp_str);\n \t  else if (reg_offset < 32768)\n@@ -2167,11 +2067,6 @@ m32r_output_function_epilogue (file, size)\n \tfprintf (file, \"\\tjmp %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n     }\n \n-#if 0 /* no longer needed */\n-  /* Ensure the function cleanly ends on a 32 bit boundary.  */\n-  fprintf (file, \"\\t.fillinsn\\n\");\n-#endif\n-\n   /* Reset state info for each function.  */\n   current_frame_info = zero_frame_info;\n   m32r_compute_function_type (NULL_TREE);\n@@ -2181,7 +2076,7 @@ m32r_output_function_epilogue (file, size)\n    epilogue.  */\n \n int\n-direct_return ()\n+direct_return (void)\n {\n   if (!reload_completed)\n     return FALSE;\n@@ -2193,14 +2088,14 @@ direct_return ()\n }\n \n \f\n-/* PIC */\n+/* PIC.  */\n \n /* Emit special PIC prologues and epilogues.  */\n \n void\n-m32r_finalize_pic ()\n+m32r_finalize_pic (void)\n {\n-  /* nothing to do */\n+  /* Nothing to do.  */\n }\n \f\n /* Nested function support.  */\n@@ -2210,15 +2105,14 @@ m32r_finalize_pic ()\n    CXT is an RTX for the static chain value for the function.  */\n \n void\n-m32r_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp ATTRIBUTE_UNUSED;\n-     rtx fnaddr ATTRIBUTE_UNUSED;\n-     rtx cxt ATTRIBUTE_UNUSED;\n+m32r_initialize_trampoline (rtx tramp ATTRIBUTE_UNUSED,\n+\t\t\t    rtx fnaddr ATTRIBUTE_UNUSED,\n+\t\t\t    rtx cxt ATTRIBUTE_UNUSED)\n {\n }\n \f\n static void\n-m32r_file_start ()\n+m32r_file_start (void)\n {\n   default_file_start ();\n \n@@ -2233,10 +2127,7 @@ m32r_file_start ()\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n \n void\n-m32r_print_operand (file, x, code)\n-     FILE * file;\n-     rtx    x;\n-     int    code;\n+m32r_print_operand (FILE * file, rtx x, int code)\n {\n   rtx addr;\n \n@@ -2281,11 +2172,11 @@ m32r_print_operand (file, x, code)\n \toutput_operand_lossage (\"invalid operand to %%R code\");\n       return;\n \n-    case 'H' : /* High word */\n-    case 'L' : /* Low word */\n+    case 'H' : /* High word.  */\n+    case 'L' : /* Low word.  */\n       if (GET_CODE (x) == REG)\n \t{\n-\t  /* L = least significant word, H = most significant word */\n+\t  /* L = least significant word, H = most significant word.  */\n \t  if ((WORDS_BIG_ENDIAN != 0) ^ (code == 'L'))\n \t    fputs (reg_names[REGNO (x)], file);\n \t  else\n@@ -2317,8 +2208,8 @@ m32r_print_operand (file, x, code)\n \treturn;\n       }\n \n-    case 'B' : /* Bottom half */\n-    case 'T' : /* Top half */\n+    case 'B' : /* Bottom half.  */\n+    case 'T' : /* Top half.  */\n       /* Output the argument to a `seth' insn (sets the Top half-word).\n \t For constants output arguments to a seth/or3 pair to set Top and\n \t Bottom halves.  For symbols output arguments to a seth/add3 pair to\n@@ -2393,12 +2284,6 @@ m32r_print_operand (file, x, code)\n       fputs (IMMEDIATE_PREFIX, file);\n       return;\n \n-#if 0 /* ??? no longer used */\n-    case '@' :\n-      fputs (reg_names[SDA_REGNUM], file);\n-      return;\n-#endif\n-\n     case 0 :\n       /* Do nothing special.  */\n       break;\n@@ -2469,13 +2354,11 @@ m32r_print_operand (file, x, code)\n /* Print a memory address as an operand to reference that memory location.  */\n \n void\n-m32r_print_operand_address (file, addr)\n-     FILE * file;\n-     rtx    addr;\n+m32r_print_operand_address (FILE * file, rtx addr)\n {\n-  register rtx base;\n-  register rtx index = 0;\n-  int          offset = 0;\n+  rtx base;\n+  rtx index = 0;\n+  int offset = 0;\n \n   switch (GET_CODE (addr))\n     {\n@@ -2542,15 +2425,15 @@ m32r_print_operand_address (file, addr)\n       fputs (reg_names[REGNO (XEXP (addr, 0))], file);\n       break;\n \n-    case PRE_INC :\t/* Assume SImode */\n+    case PRE_INC :\t/* Assume SImode.  */\n       fprintf (file, \"+%s\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n-    case PRE_DEC :\t/* Assume SImode */\n+    case PRE_DEC :\t/* Assume SImode.  */\n       fprintf (file, \"-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n-    case POST_INC :\t/* Assume SImode */\n+    case POST_INC :\t/* Assume SImode.  */\n       fprintf (file, \"%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n@@ -2561,10 +2444,9 @@ m32r_print_operand_address (file, addr)\n }\n \n /* Return true if the operands are the constants 0 and 1.  */\n+\n int\n-zero_and_one (operand1, operand2)\n-     rtx operand1;\n-     rtx operand2;\n+zero_and_one (rtx operand1, rtx operand2)\n {\n   return\n        GET_CODE (operand1) == CONST_INT\n@@ -2574,12 +2456,11 @@ zero_and_one (operand1, operand2)\n }\n \n /* Return nonzero if the operand is suitable for use in a conditional move sequence.  */\n+\n int\n-conditional_move_operand (operand, mode)\n-     rtx operand;\n-     enum machine_mode mode;\n+conditional_move_operand (rtx operand, enum machine_mode mode)\n {\n-  /* Only defined for simple integers so far... */\n+  /* Only defined for simple integers so far...  */\n   if (mode != SImode && mode != HImode && mode != QImode)\n     return FALSE;\n \n@@ -2603,11 +2484,10 @@ conditional_move_operand (operand, mode)\n     }\n }\n \n-/* Return true if the code is a test of the carry bit */\n+/* Return true if the code is a test of the carry bit.  */\n+\n int\n-carry_compare_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+carry_compare_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx x;\n \n@@ -2633,10 +2513,9 @@ carry_compare_operand (op, mode)\n    conditional_move_operand() function above.  The destination is operand[0].\n    The condition is operand [1].  The 'true' value is operand [2] and the\n    'false' value is operand [3].  */\n+\n char *\n-emit_cond_move (operands, insn)\n-     rtx * operands;\n-     rtx   insn ATTRIBUTE_UNUSED;\n+emit_cond_move (rtx * operands, rtx insn ATTRIBUTE_UNUSED)\n {\n   static char buffer [100];\n   const char * dest = reg_names [REGNO (operands [0])];\n@@ -2671,10 +2550,9 @@ emit_cond_move (operands, insn)\n \n /* Returns true if the registers contained in the two\n    rtl expressions are different. */\n+\n int\n-m32r_not_same_reg (a, b)\n-     rtx a;\n-     rtx b;\n+m32r_not_same_reg (rtx a, rtx b)\n {\n   int reg_a = -1;\n   int reg_b = -2;\n@@ -2696,11 +2574,9 @@ m32r_not_same_reg (a, b)\n \n \f\n /* Use a library function to move some bytes.  */\n+\n static void\n-block_move_call (dest_reg, src_reg, bytes_rtx)\n-     rtx dest_reg;\n-     rtx src_reg;\n-     rtx bytes_rtx;\n+block_move_call (rtx dest, rtx src_reg, rtx bytes_rtx)\n {\n   /* We want to pass the size as Pmode, which will normally be SImode\n      but will be DImode if we are using 64 bit longs and pointers.  */\n@@ -2738,8 +2614,7 @@ block_move_call (dest_reg, src_reg, bytes_rtx)\n    operands[3] is the alignment.  */\n \n void\n-m32r_expand_block_move (operands)\n-     rtx operands[];\n+m32r_expand_block_move (rtx operands[])\n {\n   rtx           orig_dst  = operands[0];\n   rtx           orig_src  = operands[1];\n@@ -2830,9 +2705,7 @@ m32r_expand_block_move (operands)\n    operands[4] is a temp register.  */\n \n void\n-m32r_output_block_move (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n+m32r_output_block_move (rtx insn ATTRIBUTE_UNUSED, rtx operands[])\n {\n   HOST_WIDE_INT bytes = INTVAL (operands[2]);\n   int\t\tfirst_time;\n@@ -2947,10 +2820,9 @@ m32r_output_block_move (insn, operands)\n \n /* Return true if op is an integer constant, less than or equal to\n    MAX_MOVE_BYTES.  */\n+\n int\n-m32r_block_immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+m32r_block_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != CONST_INT\n       || INTVAL (op) > MAX_MOVE_BYTES\n@@ -2963,9 +2835,8 @@ m32r_block_immediate_operand (op, mode)\n /* Return true if using NEW_REG in place of OLD_REG is ok.  */\n \n int\n-m32r_hard_regno_rename_ok (old_reg, new_reg)\n-     unsigned int old_reg ATTRIBUTE_UNUSED;\n-     unsigned int new_reg;\n+m32r_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n+\t\t\t   unsigned int new_reg)\n {\n   /* Interrupt routines can't clobber any register that isn't already used.  */\n   if (lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (current_function_decl))"}, {"sha": "63ff8e8fab258df952d76634f97a469b30b23946", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "patch": "@@ -1,23 +1,23 @@\n-/* Definitions of target machine for GNU compiler, Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+/* Definitions of target machine for GNU compiler, Renesas M32R cpu.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n /* Things to do:\n - longlong.h?"}, {"sha": "1c76aa3665f206d908786d251df9562c0c7cb13e", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "patch": "@@ -1,17 +1,17 @@\n-;; Machine description of the Mitsubishi M32R cpu for GNU C compiler\n-;; Copyright (C) 1996, 1997, 1998, 1999, 2001 Free Software Foundation, Inc.\n+;; Machine description of the Renesas M32R cpu for GNU C compiler\n+;; Copyright (C) 1996, 1997, 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n \n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n \n ;; You should have received a copy of the GNU General Public License\n ;; along with GCC; see the file COPYING.  If not, write to"}, {"sha": "b5a217d4999605c05ebe24cd8d99c2ef8efe461a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f92da87179c353ecf8e5a19c60fcd78b27c3a6c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1f92da87179c353ecf8e5a19c60fcd78b27c3a6c", "patch": "@@ -6837,7 +6837,7 @@ This option makes symbolic debugging impossible.\n @subsection M32R/D Options\n @cindex M32R/D options\n \n-These @option{-m} options are defined for Mitsubishi M32R/D architectures:\n+These @option{-m} options are defined for Renesas M32R/D architectures:\n \n @table @gcctabopt\n @item -m32r2"}]}