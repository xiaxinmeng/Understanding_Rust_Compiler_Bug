{"sha": "c24a67383e85adf65cdf582bc566d73546ed84fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0YTY3MzgzZTg1YWRmNjVjZGY1ODJiYzU2NmQ3MzU0NmVkODRmYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-25T22:53:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-25T22:53:25Z"}, "message": "re PR debug/49841 (AIX bootstrap failure in dwarf2cfi.c:maybe_record_trace_start)\n\nPR debug/49841\n\t* config/rs6000/rs6000.c (rs6000_frame_related): Return the insn.\n\t(emit_frame_save): Likewise.\n\t(rs6000_emit_prologue): Move the FRAME_RELATED_EXPR from the save\n\tinsn onto a dummy blockage insn after the join label.\n\nFrom-SVN: r176773", "tree": {"sha": "1f65027b1779ceddef16afda97eb43758ace77a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f65027b1779ceddef16afda97eb43758ace77a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24a67383e85adf65cdf582bc566d73546ed84fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24a67383e85adf65cdf582bc566d73546ed84fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24a67383e85adf65cdf582bc566d73546ed84fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24a67383e85adf65cdf582bc566d73546ed84fc/comments", "author": null, "committer": null, "parents": [{"sha": "200e10dc9b0a088d6350f87bbdc99c42047c4090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200e10dc9b0a088d6350f87bbdc99c42047c4090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200e10dc9b0a088d6350f87bbdc99c42047c4090"}], "stats": {"total": 44, "additions": 36, "deletions": 8}, "files": [{"sha": "c86e6da40349f3d70c2b8a67d7b31fecb56df82a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24a67383e85adf65cdf582bc566d73546ed84fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24a67383e85adf65cdf582bc566d73546ed84fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c24a67383e85adf65cdf582bc566d73546ed84fc", "patch": "@@ -1,3 +1,11 @@\n+2011-07-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR debug/49841\n+\t* config/rs6000/rs6000.c (rs6000_frame_related): Return the insn.\n+\t(emit_frame_save): Likewise.\n+\t(rs6000_emit_prologue): Move the FRAME_RELATED_EXPR from the save\n+\tinsn onto a dummy blockage insn after the join label.\n+\n 2011-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (dw_trace_info): Add ID member."}, {"sha": "fa367fea54cfd363993e1c0d76ed6e1d20960745", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24a67383e85adf65cdf582bc566d73546ed84fc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24a67383e85adf65cdf582bc566d73546ed84fc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c24a67383e85adf65cdf582bc566d73546ed84fc", "patch": "@@ -872,10 +872,7 @@ static bool rs6000_legitimate_address_p (enum machine_mode, rtx, bool);\n static bool rs6000_debug_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx rs6000_generate_compare (rtx, enum machine_mode);\n static void rs6000_emit_stack_tie (void);\n-static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n static bool spe_func_has_64bit_regs_p (void);\n-static void emit_frame_save (rtx, rtx, enum machine_mode, unsigned int,\n-\t\t\t     int, HOST_WIDE_INT);\n static rtx gen_frame_mem_offset (enum machine_mode, rtx, int);\n static unsigned rs6000_hash_constant (rtx);\n static unsigned toc_hash_function (const void *);\n@@ -19317,7 +19314,7 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n    deduce these equivalences by itself so it wasn't necessary to hold\n    its hand so much.  */\n \n-static void\n+static rtx\n rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \t\t      rtx reg2, rtx rreg)\n {\n@@ -19390,6 +19387,8 @@ rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val,\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n   add_reg_note (insn, REG_FRAME_RELATED_EXPR, real);\n+\n+  return insn;\n }\n \n /* Returns an insn that has a vrsave set operation with the\n@@ -19454,7 +19453,7 @@ generate_set_vrsave (rtx reg, rs6000_stack_t *info, int epiloguep)\n /* Save a register into the frame, and emit RTX_FRAME_RELATED_P notes.\n    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */\n \n-static void\n+static rtx\n emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \t\t unsigned int regno, int offset, HOST_WIDE_INT total_size)\n {\n@@ -19492,7 +19491,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \n   insn = emit_move_insn (mem, reg);\n \n-  rs6000_frame_related (insn, frame_ptr, total_size, replacea, replaceb);\n+  return rs6000_frame_related (insn, frame_ptr, total_size, replacea, replaceb);\n }\n \n /* Emit an offset memory reference suitable for a frame store, while\n@@ -20288,6 +20287,7 @@ rs6000_emit_prologue (void)\n   if (TARGET_AIX && crtl->calls_eh_return)\n     {\n       rtx tmp_reg, tmp_reg_si, hi, lo, compare_result, toc_save_done, jump;\n+      rtx save_insn, join_insn, note;\n       long toc_restore_insn;\n \n       gcc_assert (frame_reg_rtx == frame_ptr_rtx\n@@ -20322,9 +20322,29 @@ rs6000_emit_prologue (void)\n       JUMP_LABEL (jump) = toc_save_done;\n       LABEL_NUSES (toc_save_done) += 1;\n \n-      emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, TOC_REGNUM,\n-\t\t       sp_offset + 5 * reg_size, info->total_size);\n+      save_insn = emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode,\n+\t\t\t\t   TOC_REGNUM, sp_offset + 5 * reg_size,\n+\t\t\t\t   info->total_size);\n+\n       emit_label (toc_save_done);\n+\n+      /* ??? If we leave SAVE_INSN as marked as saving R2, then we'll\n+\t have a CFG that has different saves along different paths.\n+\t Move the note to a dummy blockage insn, which describes that\n+\t R2 is unconditionally saved after the label.  */\n+      /* ??? An alternate representation might be a special insn pattern\n+\t containing both the branch and the store.  That might let the\n+\t code that minimizes the number of DW_CFA_advance opcodes better\n+\t freedom in placing the annotations.  */\n+      note = find_reg_note (save_insn, REG_FRAME_RELATED_EXPR, NULL);\n+      gcc_assert (note);\n+      remove_note (save_insn, note);\n+      RTX_FRAME_RELATED_P (save_insn) = 0;\n+\n+      join_insn = emit_insn (gen_blockage ());\n+      REG_NOTES (join_insn) = note;\n+      RTX_FRAME_RELATED_P (join_insn) = 1;\n+\n       if (using_static_chain_p)\n \temit_move_insn (tmp_reg, gen_rtx_REG (Pmode, 0));\n     }"}]}