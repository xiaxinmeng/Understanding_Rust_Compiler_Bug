{"sha": "029b38ff0437ff2ea5fc84c8e026d6f055727194", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5YjM4ZmYwNDM3ZmYyZWE1ZmM4NGM4ZTAyNmQ2ZjA1NTcyNzE5NA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-05-14T00:44:02Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-05-14T00:44:02Z"}, "message": "reload.c (remove_replacements): New function.\n\n\t* reload.c (remove_replacements): New function.\n\t* reload.h (remove_replacements): Declare.\n\t* reload1.c (choose_reload_regs): Disable some reloads that\n\tbelong to inherited reloads.\n\nFrom-SVN: r19735", "tree": {"sha": "051fe061feaa27120cdc1d7f7ca4ce4be1c132a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/051fe061feaa27120cdc1d7f7ca4ce4be1c132a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/029b38ff0437ff2ea5fc84c8e026d6f055727194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029b38ff0437ff2ea5fc84c8e026d6f055727194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029b38ff0437ff2ea5fc84c8e026d6f055727194", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029b38ff0437ff2ea5fc84c8e026d6f055727194/comments", "author": null, "committer": null, "parents": [{"sha": "f824910ea1f3cb4ec56581a1f752c0c777720d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f824910ea1f3cb4ec56581a1f752c0c777720d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f824910ea1f3cb4ec56581a1f752c0c777720d49"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "807e2b9cff1e3d1ea840560b101caab8f38b427b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=029b38ff0437ff2ea5fc84c8e026d6f055727194", "patch": "@@ -1,3 +1,10 @@\n+Thu May 14 08:41:46 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload.c (remove_replacements): New function.\n+\t* reload.h (remove_replacements): Declare.\n+\t* reload1.c (choose_reload_regs): Disable some reloads that\n+\tbelong to inherited reloads.\n+\n Thu May 14 02:17:17 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload1.c (merge_assigned_reloads):  When merging, reset"}, {"sha": "ef62ef92f442f97e53935b01ebc4019f01e3c2bf", "filename": "gcc/reload.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=029b38ff0437ff2ea5fc84c8e026d6f055727194", "patch": "@@ -1506,6 +1506,21 @@ transfer_replacements (to, from)\n       replacements[i].what = to;\n }\n \f\n+/* Remove all replacements in reload FROM.  */\n+void\n+remove_replacements (from)\n+     int from;\n+{\n+  int i, j;\n+\n+  for (i = 0, j = 0; i < n_replacements; i++)\n+    {\n+      if (replacements[i].what == from)\n+        continue;\n+      replacements[j++] = replacements[i];\n+    }\n+}\n+\f\n /* If there is only one output reload, and it is not for an earlyclobber\n    operand, try to combine it with a (logically unrelated) input reload\n    to reduce the number of reload registers needed."}, {"sha": "d99b0c128a5d04b36b8b1cdbd1c1cef1d3e2ae9a", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=029b38ff0437ff2ea5fc84c8e026d6f055727194", "patch": "@@ -157,6 +157,9 @@ extern void clear_secondary_mem PROTO((void));\n    reload TO.  */\n extern void transfer_replacements PROTO((int, int));\n \n+/* Remove all replacements in reload FROM.  */\n+extern void remove_replacements PROTO((int));\n+\n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n    autoincrement and autodecrement.  */"}, {"sha": "f6d9a0f04523e653599e69b8b62841d7b21f484c", "filename": "gcc/reload1.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/029b38ff0437ff2ea5fc84c8e026d6f055727194/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=029b38ff0437ff2ea5fc84c8e026d6f055727194", "patch": "@@ -5799,6 +5799,47 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t\t\t reload_opnum[r],\n \t\t\t\t\t reload_when_needed[r]))\n \treload_inherited[r] = 0;\n+      /* If we can inherit a RELOAD_FOR_INPUT, then we do not need its related\n+\t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads.\n+\t ??? This could be extended to other reload types, but these are\n+         more tricky to handle:\n+\t RELOAD_FOR_OTHER_ADDRESS reloads might have been merged, so we\n+\t can't eliminate them without a check that *all* references are\n+\t now unused due to inheritance.\n+\t While RELOAD_FOR_INPADDR_ADDRESS and RELOAD_FOR_OUTADDR_ADDRESS are\n+\t not merged, we can't be sure that we have eliminated the use of\n+\t that particular reload if we have seen just one\n+\t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_OUTPUT_ADDRESS being inherited,\n+\t since there might be multiple of the latter two reloads for a single\n+\t operand.\n+\t RELOAD_FOR_OPADDR_ADDR reloads for different operands are not\n+\t merged, but might share the same register by courtesy of\n+\t reload_reg_free_for_value_p.  reload_reg_used_in_op_addr_reload\n+\t does not differentiate by opnum, thus calling clear_reload_reg_in_use\n+\t for one of these reloads would mark the register as free even though\n+\t another RELOAD_FOR_OPADDR_ADDR reload might still use it.  */\n+      else if (reload_inherited[r] && reload_when_needed[r] == RELOAD_FOR_INPUT)\n+\t{\n+\t  for (i = 0; i < n_reloads; i++)\n+\t    {\n+\t      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n+\t\t  && reload_opnum[i] == reload_opnum[r]\n+\t\t  && reload_in[i] && reload_reg_rtx[i])\n+\t\t{\n+\t\t  int regno = true_regnum (reload_reg_rtx[i]);\n+\n+\t\t  reload_in[i] = 0;\n+\t\t  if (spill_reg_order[regno] >= 0)\n+\t\t    clear_reload_reg_in_use (regno, reload_opnum[i],\n+\t\t\t\t\t     reload_when_needed[i],\n+\t\t\t\t\t     reload_mode[i]);\n+\t\t  reload_reg_rtx[i] = 0;\n+\t\t  reload_spill_index[i] = -1;\n+\t\t  remove_replacements (i);\n+\t\t}\n+\t    }\n+\t}\n \n       /* If we found a better place to reload from,\n \t validate it in the same fashion, if it is a reload reg.  */"}]}