{"sha": "a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0ZGJmMmMyNjI4YzgzNzczYTFlYjZjOWNlZDFhNDlhM2E1ZjQ1ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-09T22:31:23Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-09T22:31:23Z"}, "message": "x\n\nFrom-SVN: r13258", "tree": {"sha": "85d261767b8a92bfcd79dacffefca2f442d5cf06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85d261767b8a92bfcd79dacffefca2f442d5cf06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/comments", "author": null, "committer": null, "parents": [{"sha": "19f5ce60f80423710b14e915da94b6f42ab25801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19f5ce60f80423710b14e915da94b6f42ab25801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19f5ce60f80423710b14e915da94b6f42ab25801"}], "stats": {"total": 1502, "additions": 1001, "deletions": 501}, "files": [{"sha": "ddb4ad59f6ecff028fa399996596bc3b0f89422c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -1078,14 +1078,14 @@ sublibobjc.a: cc1obj specs stmp-int-hdrs libgcc2.ready\n # linked using GCC on systems using COFF or ELF, for the sake of C++\n # constructors.\n $(T)crtbegin.o: crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n-\t  $(MULTILIB_CFLAGS) -finhibit-size-directive -fno-inline-functions \\\n-\t  -g0 -c $(srcdir)/crtstuff.c -DCRT_BEGIN -o $(T)crtbegin$(objext)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n+\t  -finhibit-size-directive -fno-inline-functions $(CRTSTUFF_T_CFLAGS) \\\n+\t  -c $(srcdir)/crtstuff.c -DCRT_BEGIN -o $(T)crtbegin$(objext)\n \n $(T)crtend.o: crtstuff.c $(GCC_PASSES) $(CONFIG_H) gbl-ctors.h\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n-\t  $(MULTILIB_CFLAGS) -finhibit-size-directive -fno-inline-functions \\\n-\t  -g0 -c $(srcdir)/crtstuff.c -DCRT_END -o $(T)crtend$(objext)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n+\t  -finhibit-size-directive -fno-inline-functions $(CRTSTUFF_T_CFLAGS) \\\n+\t  -c $(srcdir)/crtstuff.c -DCRT_END -o $(T)crtend$(objext)\n \n # On some systems we also want to install versions of these files\n # compiled using PIC for use in shared libraries."}, {"sha": "c3a3b2d858004aaf62067e61355b9a08f0d7b6c4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -4940,7 +4940,7 @@ compute_frame_size (size)\n \t\t\t      + gp_reg_rounded + fp_reg_size\n \t\t\t      - fp_inc * UNITS_PER_FPREG);\n       current_frame_info.fp_sp_offset = offset;\n-      current_frame_info.fp_save_offset = offset - total_size + UNITS_PER_WORD;\n+      current_frame_info.fp_save_offset = offset - total_size;\n     }\n   else\n     {\n@@ -5066,7 +5066,25 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t\t\t\t\t  GEN_INT (gp_offset - base_offset)));\n \n \t\t  if (store_p)\n-\t\t    emit_move_insn (mem_rtx, reg_rtx);\n+\t\t    {\n+\t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n+\n+\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t\t{\n+\t\t\t  int offset = (gp_offset\n+\t\t\t\t\t- current_frame_info.total_size);\n+\t\t\t  if (regno == GP_REG_FIRST + 31)\n+\t\t\t    REG_NOTES (insn)\n+\t\t\t      = gen_rtx (EXPR_LIST, REG_RETURN_SAVE,\n+\t\t\t\t\t GEN_INT (offset), REG_NOTES (insn));\n+\t\t\t  else\n+\t\t\t    REG_NOTES (insn)\n+\t\t\t      = gen_rtx (EXPR_LIST, REG_SAVE,\n+\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode, reg_rtx,\n+\t\t\t\t\t\t  GEN_INT (offset)),\n+\t\t\t\t\t REG_NOTES (insn));\n+\t\t\t}\n+\t\t    }\n \t\t  else if (!TARGET_ABICALLS || mips_abi != ABI_32\n \t\t\t   || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n@@ -5179,7 +5197,20 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t\t\t\t\t  GEN_INT (fp_offset - base_offset)));\n \n \t\t  if (store_p)\n-\t\t    emit_move_insn (mem_rtx, reg_rtx);\n+\t\t    {\n+\t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n+\n+\t\t      if (write_symbols == DWARF2_DEBUG)\n+\t\t\t{\n+\t\t\t  int offset = (gp_offset\n+\t\t\t\t\t- current_frame_info.total_size);\n+\t\t\t  REG_NOTES (insn)\n+\t\t\t    = gen_rtx (EXPR_LIST, REG_SAVE,\n+\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode, reg_rtx,\n+\t\t\t\t\t\tGEN_INT (offset)),\n+\t\t\t\t       REG_NOTES (insn));\n+\t\t\t}\n+\t\t    }\n \t\t  else\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n \t\t}\n@@ -5405,6 +5436,8 @@ mips_expand_prologue ()\n       /* If we are doing svr4-abi, sp move is done by function_prologue.  */\n       if (!TARGET_ABICALLS || mips_abi != ABI_32)\n \t{\n+\t  rtx insn;\n+\n \t  if (tsize > 32767)\n \t    {\n \t      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n@@ -5413,21 +5446,37 @@ mips_expand_prologue ()\n \t    }\n \n \t  if (TARGET_LONG64)\n-\t    emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   tsize_rtx));\n+\t    insn = emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\t  tsize_rtx));\n \t  else\n-\t    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t   tsize_rtx));\n+\t    insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\t  tsize_rtx));\n+\n+\t  if (write_symbols == DWARF2_DEBUG)\n+\t    REG_NOTES (insn)\n+\t      = gen_rtx (EXPR_LIST, REG_FRAME,\n+\t\t\t gen_rtx (PLUS, VOIDmode, stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (tsize)),\n+\t\t\t REG_NOTES (insn));\n \t}\n \n       save_restore_insns (TRUE, tmp_rtx, tsize, (FILE *)0);\n \n       if (frame_pointer_needed)\n \t{\n+\t  rtx insn;\n+\n \t  if (TARGET_64BIT)\n-\t    emit_insn (gen_movdi (frame_pointer_rtx, stack_pointer_rtx));\n+\t    insn= emit_insn (gen_movdi (frame_pointer_rtx, stack_pointer_rtx));\n \t  else\n-\t    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\t    insn= emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\n+\t  if (write_symbols == DWARF2_DEBUG)\n+\t    REG_NOTES (insn)\n+\t      = gen_rtx (EXPR_LIST, REG_FRAME,\n+\t\t\t gen_rtx (PLUS, VOIDmode, frame_pointer_rtx,\n+\t\t\t\t  GEN_INT (tsize)),\n+\t\t\t REG_NOTES (insn));\n \t}\n \n       if (TARGET_ABICALLS && mips_abi != ABI_32)"}, {"sha": "85a63f06e2e707ce8f12cda82228d33af1465811", "filename": "gcc/config/mips/t-iris6", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fconfig%2Fmips%2Ft-iris6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fconfig%2Fmips%2Ft-iris6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-iris6?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -17,3 +17,4 @@ INSTALL_LIBGCC = install-multilib\n # end labels to the .ctors and .dtors section when we link using gcc.\n \n EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o\n+CRTSTUFF_T_CFLAGS=-g1"}, {"sha": "89026303cfcdd257633b9158572fcd53f1780be7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 599, "deletions": 310, "changes": 909, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -198,8 +198,7 @@ typedef struct dw_fde_struct\n   {\n     unsigned long dw_fde_offset;\n     char *dw_fde_begin;\n-    char *dw_fde_end_prolog;\n-    char *dw_fde_begin_epilogue;\n+    char *dw_fde_current_label;\n     char *dw_fde_end;\n     dw_cfi_ref dw_fde_cfi;\n   }\n@@ -294,23 +293,12 @@ extern char *language_string;\n #define DWARF_ARANGES_HEADER_SIZE \\\n   (DWARF_ROUND (2 * DWARF_OFFSET_SIZE + 4, PTR_SIZE * 2) - DWARF_OFFSET_SIZE)\n \n-/* Length of the target-dependent instructions in the\n-   Common Information Entry (CIE).\n-   ??? This should be computed when the frame info is genericized.  */\n-#ifdef MIPS_DEBUGGING_INFO\n-#define DWARF_CIE_INSN_SIZE (2*3)\n-#endif\n-\n-#ifndef DWARF_CIE_INSN_SIZE\n-#define DWARF_CIE_INSN_SIZE 0\n-#endif\n-\n /* Fixed size portion of the CIE (including the length field).  */\n-#define DWARF_CIE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 5 + DWARF_CIE_INSN_SIZE)\n+#define DWARF_CIE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 5)\n \n-/* Fixed size of the Common Information Entry in the call frame\n-   information (.debug_frame) section rounded up to a word boundary.  */\n-#define DWARF_CIE_SIZE DWARF_ROUND (DWARF_CIE_HEADER_SIZE, PTR_SIZE)\n+/* The un-padded size of the CIE.  Initialized in calc_fde_sizes, used\n+   in output_call_frame_info.  */\n+static unsigned cie_size;\n \n /* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n #define DWARF_CIE_DATA_ALIGNMENT -4\n@@ -355,6 +343,9 @@ static unsigned long next_fde_offset;\n /* Record the root of the DIE's built for the current compilation unit.  */\n dw_die_ref comp_unit_die;\n \n+/* The number of DIEs with a NULL parent waiting to be relocated.  */\n+static int limbo_die_count;\n+\n /* Pointer to an array of filenames referenced by this compilation unit.  */\n static char **file_table;\n \n@@ -381,21 +372,6 @@ static char *primary_filename;\n    assigns numbers to the blocks in the same way.  */\n static unsigned next_block_number = 2;\n \n-/* A pointer to the base of a list of references to DIE's that describe\n-   types.  The table is indexed by TYPE_UID() which is a unique number,\n-   indentifying each type.  */\n-static dw_die_ref *type_die_table;\n-\n-/* Number of elements currently allocated for type_die_table.  */\n-static unsigned type_die_table_allocated;\n-\n-/* Number of elements in type_die_table currently in use.  */\n-static unsigned type_die_table_in_use;\n-\n-/* Size (in elements) of increments by which we may expand the\n-   type_die_table.  */\n-#define TYPE_DIE_TABLE_INCREMENT 4096\n-\n /* A pointer to the base of a table of references to DIE's that describe\n    declarations.  The table is indexed by DECL_UID() which is a unique\n    number, indentifying each decl.  */\n@@ -481,6 +457,9 @@ static unsigned fde_table_in_use;\n    fde_table.  */\n #define FDE_TABLE_INCREMENT 256\n \n+/* A list of call frame insns for the CIE.  */\n+static dw_cfi_ref cie_cfi_head;\n+\n /* A pointer to the base of a table that contains a list of publicly\n    accessible names.  */\n static pubname_ref pubname_table;\n@@ -509,6 +488,26 @@ static unsigned arange_table_in_use;\n    arange_table.  */\n #define ARANGE_TABLE_INCREMENT 64\n \n+/* A pointer to the base of a list of pending types which we haven't\n+   generated DIEs for yet, but which we will have to come back to\n+   later on.  */\n+\n+static tree *pending_types_list;\n+\n+/* Number of elements currently allocated for the pending_types_list.  */\n+\n+static unsigned pending_types_allocated;\n+\n+/* Number of elements of pending_types_list currently in use.  */\n+\n+static unsigned pending_types;\n+\n+/* Size (in elements) of increments by which we may expand the pending\n+   types list.  Actually, a single hunk of space of this size should\n+   be enough for most typical programs.\t */\n+\n+#define PENDING_TYPES_INCREMENT 64\n+\n /* The number of the current function definition for which debugging\n    information is being generated.  These numbers range from 1 up to the\n    maximum number of function definitions contained within the current\n@@ -522,10 +521,6 @@ static unsigned current_funcdef_number = 1;\n    associated with the current function (body) definition.  */\n static unsigned current_funcdef_fde;\n \n-/* Record the size of the frame, so that the DW_AT_frame_base\n-   attribute can be set properly in gen_subprogram_die.  */\n-static long int current_funcdef_frame_size = 0;\n-\n /* Record whether the function being analyzed contains inlined functions.  */\n static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n@@ -544,6 +539,7 @@ static void gen_decl_die ();\n static unsigned lookup_filename ();\n static int constant_size PROTO((long unsigned));\n static enum dwarf_form value_format PROTO((dw_val_ref));\n+static unsigned reg_number ();\n \n /* Definitions of defaults for assembler-dependent names of various\n    pseudo-ops and section names.\n@@ -823,9 +819,14 @@ char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #endif\n \n /* The DWARF 2 CFA column which tracks the return address.  Normally this\n-   is the first column after all of the hard registers.  */\n+   is the column for PC, or the first column after all of the hard\n+   registers.  */\n #ifndef DWARF_FRAME_RETURN_COLUMN\n-#define DWARF_FRAME_RETURN_COLUMN \tFIRST_PSEUDO_REGISTER\n+#ifdef PC_REGNUM\n+#define DWARF_FRAME_RETURN_COLUMN \tDWARF_FRAME_REGNUM (PC_REGNUM)\n+#else\n+#define DWARF_FRAME_RETURN_COLUMN \tFIRST_PSEUDO_REGISTER + 1\n+#endif\n #endif\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.  By\n@@ -1851,13 +1852,12 @@ block_ultimate_origin (block)\n    of a virtual function may refer to a base class, so we check the 'this'\n    parameter.  */\n \n-tree\n+static tree\n decl_class_context (decl)\n      tree decl;\n {\n   tree context = NULL_TREE;\n-  if (TREE_CODE (decl) != FUNCTION_DECL\n-      || ! DECL_VIRTUAL_P (decl))\n+  if (TREE_CODE (decl) != FUNCTION_DECL || ! DECL_VINDEX (decl))\n     context = DECL_CONTEXT (decl);\n   else\n     context = TYPE_MAIN_VARIANT\n@@ -2325,9 +2325,9 @@ new_die (tag_value, parent_die)\n       die->die_attr = NULL;\n       die->die_attr_last = NULL;\n       if (parent_die != NULL)\n-\t{\n-\t  add_child_die (parent_die, die);\n-\t}\n+\tadd_child_die (parent_die, die);\n+      else\n+\t++limbo_die_count;\n     }\n   return die;\n }\n@@ -2337,9 +2337,7 @@ inline dw_die_ref\n lookup_type_die (type)\n      register tree type;\n {\n-  register unsigned type_id = TYPE_UID (type);\n-  return (type_id < type_die_table_in_use)\n-    ? type_die_table[type_id] : NULL;\n+  return (dw_die_ref) TYPE_SYMTAB_POINTER (type);\n }\n \n /* Equate a DIE to a given type specifier.  */\n@@ -2348,25 +2346,7 @@ equate_type_number_to_die (type, type_die)\n      register tree type;\n      register dw_die_ref type_die;\n {\n-  register unsigned type_id = TYPE_UID (type);\n-  register unsigned num_allocated;\n-  if (type_id >= type_die_table_allocated)\n-    {\n-      num_allocated = (((type_id + 1)\n-\t\t\t+ TYPE_DIE_TABLE_INCREMENT - 1)\n-\t\t       / TYPE_DIE_TABLE_INCREMENT)\n-\t* TYPE_DIE_TABLE_INCREMENT;\n-      type_die_table = (dw_die_ref *) xrealloc (type_die_table,\n-\t\t\t\t       sizeof (dw_die_ref) * num_allocated);\n-      bzero (&type_die_table[type_die_table_allocated],\n-\t  (num_allocated - type_die_table_allocated) * sizeof (dw_die_ref));\n-      type_die_table_allocated = num_allocated;\n-    }\n-  if (type_id >= type_die_table_in_use)\n-    {\n-      type_die_table_in_use = (type_id + 1);\n-    }\n-  type_die_table[type_id] = type_die;\n+  TYPE_SYMTAB_POINTER (type) = (char *) type_die;\n }\n \n /* Return the DIE associated with a given declaration.  */\n@@ -3657,6 +3637,212 @@ output_compilation_unit_header ()\n   fputc ('\\n', asm_out_file);\n }\n \n+/* Extract the register and offset values from RTL.  If no register number\n+   is specified, return -1 to indicate frame-relative addressing.  */\n+static void\n+decode_cfi_rtl (rtl, regp, offsetp)\n+     register rtx rtl;\n+     register unsigned long *regp;\n+     register long *offsetp;\n+{\n+  switch (GET_CODE (rtl))\n+    {\n+    case REG:\n+      *regp = reg_number (rtl);\n+      *offsetp = 0;\n+      break;\n+    case PLUS:\n+      *regp = reg_number (XEXP (rtl, 0));\n+      *offsetp = INTVAL (XEXP (rtl, 1));\n+      break;\n+    case CONST_INT:\n+      *regp = (unsigned long) -1;\n+      *offsetp = INTVAL (rtl);\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Add CFI to the current fde at the PC value indicated by LABEL if specified,\n+   or to the CIE if LABEL is NULL.  */\n+static void\n+add_fde_cfi (label, cfi)\n+     register char * label;\n+     register dw_cfi_ref cfi;\n+{\n+  if (label)\n+    {\n+      register dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n+      if (fde->dw_fde_current_label == NULL\n+\t  || strcmp (label, fde->dw_fde_current_label) != 0)\n+\t{\n+\t  register dw_cfi_ref xcfi;\n+\n+\t  fde->dw_fde_current_label = label = xstrdup (label);\n+\n+\t  /* Set the location counter to the new label.  */\n+\t  xcfi = new_cfi ();\n+\t  xcfi->dw_cfi_opc = DW_CFA_advance_loc4;\n+\t  xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n+\t  add_cfi (&fde->dw_fde_cfi, xcfi);\n+\t}\n+      add_cfi (&fde->dw_fde_cfi, cfi);\n+    }\n+  else\n+    add_cfi (&cie_cfi_head, cfi);\n+}\n+\n+/* Subroutine of lookup_cfa.  */\n+inline void\n+lookup_cfa_1 (cfi, regp, offsetp)\n+     register dw_cfi_ref cfi;\n+     register unsigned long *regp;\n+     register long *offsetp;\n+{\n+  switch (cfi->dw_cfi_opc)\n+    {\n+    case DW_CFA_def_cfa_offset:\n+      *offsetp = cfi->dw_cfi_oprnd1.dw_cfi_offset;\n+      break;\n+    case DW_CFA_def_cfa_register:\n+      *regp = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      break;\n+    case DW_CFA_def_cfa:\n+      *regp = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      *offsetp = cfi->dw_cfi_oprnd2.dw_cfi_offset;\n+      break;\n+    }\n+}\n+\n+/* Find the previous value for the CFA.  */\n+static void\n+lookup_cfa (regp, offsetp)\n+     register unsigned long *regp;\n+     register long *offsetp;\n+{\n+  register dw_cfi_ref cfi;\n+  *regp = (unsigned long) -1;\n+  *offsetp = 0;\n+\n+  for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n+    lookup_cfa_1 (cfi, regp, offsetp);\n+  if (fde_table_in_use)\n+    {\n+      register dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n+      for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n+\tlookup_cfa_1 (cfi, regp, offsetp);\n+    }\n+}\n+\n+/* Entry point to update the canonical frame address (CFA).\n+   LABEL is passed to add_fde_cfi.  RTL is either:\n+\n+   a REG:  The frame is at 0(REG).\n+   a PLUS of a REG and a CONST_INT:  The frame is at CONST(REG).  */\n+void\n+dwarf2out_def_cfa (label, rtl)\n+     register char * label;\n+     register rtx rtl;\n+{\n+  register dw_cfi_ref cfi;\n+  unsigned long reg, old_reg;\n+  long offset, old_offset;\n+\n+  decode_cfi_rtl (rtl, &reg, &offset);\n+  lookup_cfa (&old_reg, &old_offset);\n+\n+  if (reg == old_reg && offset == old_offset)\n+    return;\n+\n+  cfi = new_cfi ();\n+\n+  if (reg == old_reg)\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n+      cfi->dw_cfi_oprnd1.dw_cfi_offset = offset;\n+    }\n+#ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n+  else if (offset == old_offset && old_reg != (unsigned long) -1)\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+    }\n+#endif\n+  else\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_def_cfa;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n+    }\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Add the CFI for saving a register.  REG is the CFA column number.\n+   LABEL is passed to add_fde_cfi.\n+   RTL is either:\n+\n+   a REG:  The register is saved in REG.\n+   a CONST_INT:  The register is saved at an offset of CONST\n+     from the CFA.  */\n+static void\n+reg_save (label, reg, rtl)\n+     register char * label;\n+     register unsigned long reg;\n+     register rtx rtl;\n+{\n+  register dw_cfi_ref cfi;\n+  unsigned long sreg;\n+  long offset;\n+\n+  cfi = new_cfi ();\n+\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+\n+  decode_cfi_rtl (rtl, &sreg, &offset);\n+  offset /= DWARF_CIE_DATA_ALIGNMENT;\n+\n+  if (sreg == (unsigned long) -1)\n+    {\n+      if (reg & ~0x3f)\n+\t/* The register number won't fit in 6 bits, so we have to use\n+\t   the long form.  */\n+\tcfi->dw_cfi_opc = DW_CFA_offset_extended;\n+      else\n+\tcfi->dw_cfi_opc = DW_CFA_offset;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n+    }\n+  else\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_register;\n+      cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg;\n+    }\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Entry point for saving a register.  REG is the GCC register number.\n+   LABEL and RTL are passed to reg_save.  */\n+void\n+dwarf2out_reg_save (label, reg, rtl)\n+     register char * label;\n+     register unsigned long reg;\n+     register rtx rtl;\n+{\n+  reg_save (label, DWARF_FRAME_REGNUM (reg), rtl);\n+}\n+\n+/* Entry point for saving the return address.\n+   LABEL and RTL are passed to reg_save.  */\n+void\n+dwarf2out_return_save (label, rtl)\n+     register char * label;\n+     register rtx rtl;\n+{\n+  reg_save (label, DWARF_FRAME_RETURN_COLUMN, rtl);\n+}\n+\n /* Return the size of a Call Frame Instruction.  */\n static unsigned long\n size_of_cfi (cfi)\n@@ -3741,7 +3927,16 @@ calc_fde_sizes ()\n   register unsigned long i;\n   register dw_fde_ref fde;\n   register unsigned long fde_size;\n+  register dw_cfi_ref cfi;\n   unsigned long fde_pad;\n+\n+  cie_size = DWARF_CIE_HEADER_SIZE;\n+  for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n+    cie_size += size_of_cfi (cfi);\n+\n+  /* Initialize the beginning FDE offset.  */\n+  next_fde_offset = DWARF_ROUND (cie_size, PTR_SIZE);\n+\n   for (i = 0; i < fde_table_in_use; ++i)\n     {\n       fde = &fde_table[i];\n@@ -3816,14 +4011,16 @@ output_cfi (cfi, fde)\n \tcase DW_CFA_advance_loc2:\n           ASM_OUTPUT_DWARF_DELTA2 (asm_out_file,\n \t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-      \t\t\t\t fde->dw_fde_begin);\n+      \t\t\t\t fde->dw_fde_current_label);\n           fputc ('\\n', asm_out_file);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n \tcase DW_CFA_advance_loc4:\n           ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n \t\t\t\t cfi->dw_cfi_oprnd1.dw_cfi_addr,\n-      \t\t\t\t fde->dw_fde_begin);\n+      \t\t\t\t fde->dw_fde_current_label);\n           fputc ('\\n', asm_out_file);\n+\t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n #ifdef MIPS_DEBUGGING_INFO\n \tcase DW_CFA_MIPS_advance_loc8:\n@@ -3873,12 +4070,14 @@ output_call_frame_info ()\n   register unsigned long i, j;\n   register dw_fde_ref fde;\n   register unsigned long fde_size;\n-  dw_cfi_node cfi_node;\n   register dw_cfi_ref cfi;\n   unsigned long fde_pad;\n \n+  /* (re-)initialize the beginning FDE offset.  */\n+  next_fde_offset = DWARF_ROUND (cie_size, PTR_SIZE);\n+\n   /* Output the CIE. */\n-  ASM_OUTPUT_DWARF_DATA (asm_out_file, DWARF_CIE_SIZE - DWARF_OFFSET_SIZE);\n+  ASM_OUTPUT_DWARF_DATA (asm_out_file, next_fde_offset - DWARF_OFFSET_SIZE);\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Common Information Entry\",\n@@ -3933,31 +4132,11 @@ output_call_frame_info ()\n     }\n   fputc ('\\n', asm_out_file);\n \n-  /* Output the CFA instructions common to all FDE's. */\n-\n-#ifdef MIPS_DEBUGGING_INFO\n-\n-  bzero (&cfi_node, sizeof (dw_cfi_node));\n-  cfi = &cfi_node;\n-\n-  /* On entry, the Call Frame Address is in the stack pointer register.  */\n-  cfi->dw_cfi_opc = DW_CFA_def_cfa;\n-  cfi->dw_cfi_oprnd1.dw_cfi_reg_num\n-    = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n-  cfi->dw_cfi_oprnd2.dw_cfi_offset = 0;\n-  output_cfi (cfi);\n-\n-  /* Set the RA on entry to be the contents of r31.  */\n-  cfi->dw_cfi_opc = DW_CFA_register;\n-  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_RETURN_COLUMN;\n-  cfi->dw_cfi_oprnd2.dw_cfi_reg_num\n-    = DWARF_FRAME_REGNUM (GP_REG_FIRST + 31);\n-  output_cfi (cfi);\n-\n-#endif\n+  for (cfi = cie_cfi_head; cfi != NULL; cfi = cfi->dw_cfi_next)\n+    output_cfi (cfi);\n \n   /* Pad the CIE out to an address sized boundary.  */\n-  for (i = DWARF_CIE_HEADER_SIZE; i < DWARF_CIE_SIZE; ++i)\n+  for (i = next_fde_offset - cie_size; i; --i)\n     {\n       /* Pad out to a pointer size boundary */\n       ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_CFA_nop);\n@@ -4006,10 +4185,9 @@ output_call_frame_info ()\n \n       /* Loop through the Call Frame Instructions associated with\n \t this FDE.  */\n+      fde->dw_fde_current_label = fde->dw_fde_begin;\n       for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n-\t{\n-\t  output_cfi (cfi, fde);\n-\t}\n+\toutput_cfi (cfi, fde);\n \n       /* Pad to a double word boundary.  */\n       for (j = 0; j < fde_pad; ++j)\n@@ -4404,37 +4582,34 @@ output_line_info ()\n \t    }\n \t  fputc ('\\n', asm_out_file);\n \t}\n-      if (line_info->dw_line_num != current_line)\n+      line_offset = line_info->dw_line_num - current_line;\n+      line_delta = line_offset - DWARF_LINE_BASE;\n+      current_line = line_info->dw_line_num;\n+      if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n \t{\n-\t  line_offset = line_info->dw_line_num - current_line;\n-\t  line_delta = line_offset - DWARF_LINE_BASE;\n-\t  current_line = line_info->dw_line_num;\n-\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n+\t\t\t\t  DWARF_LINE_OPCODE_BASE + line_delta);\n+\t  if (flag_verbose_asm)\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n-\t\t\t\t      DWARF_LINE_OPCODE_BASE + line_delta);\n-\t      if (flag_verbose_asm)\n-\t\t{\n-\t\t  fprintf (asm_out_file,\n-\t\t\t   \"\\t%s line %d\", ASM_COMMENT_START, current_line);\n-\t\t}\n-\t      fputc ('\\n', asm_out_file);\n+\t      fprintf (asm_out_file,\n+\t\t       \"\\t%s line %d\", ASM_COMMENT_START, current_line);\n \t    }\n-\t  else\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      else\n+\t{\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n+\t  if (flag_verbose_asm)\n \t    {\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n-\t      if (flag_verbose_asm)\n-\t\t{\n-\t\t  fprintf (asm_out_file,\n-\t\t\t   \"\\t%s advance to line %d\",\n-\t\t\t   ASM_COMMENT_START, current_line);\n-\t\t}\n-\t      fputc ('\\n', asm_out_file);\n-\t      output_sleb128 (line_offset);\n-\t      fputc ('\\n', asm_out_file);\n-\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n-\t      fputc ('\\n', asm_out_file);\n+\t      fprintf (asm_out_file,\n+\t\t       \"\\t%s advance to line %d\",\n+\t\t       ASM_COMMENT_START, current_line);\n \t    }\n+\t  fputc ('\\n', asm_out_file);\n+\t  output_sleb128 (line_offset);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t  fputc ('\\n', asm_out_file);\n \t}\n       strcpy (prev_line_label, line_label);\n     }\n@@ -4771,15 +4946,36 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n   if (code != ERROR_MARK)\n     {\n-      /* Take the MAIN_VARIANT here to avoid C typedef types. */\n-      type = build_type_variant (TYPE_MAIN_VARIANT (type),\n-\t\t\t\t is_const_type, is_volatile_type);\n+      type = build_type_variant (type, is_const_type, is_volatile_type);\n \n       mod_type_die = lookup_type_die (type);\n       if (mod_type_die)\n \treturn mod_type_die;\n \n-      if (is_const_type)\n+      /* Handle C typedef types. */\n+      if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t  && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+\t{\n+\t  tree dtype = TREE_TYPE (TYPE_NAME (type));\n+\t  if (type == dtype)\n+\t    {\n+\t      /* For a named type, use the typedef.  */\n+\t      gen_type_die (type, context_die);\n+\t      mod_type_die = lookup_type_die (type);\n+\t    }\n+\t  else if (is_const_type < TYPE_READONLY (dtype)\n+\t\t   || is_volatile_type < TYPE_VOLATILE (dtype))\n+\t    /* cv-unqualified version of named type.  Just use the unnamed\n+\t       type to which it refers.  */\n+\t    mod_type_die = modified_type_die\n+\t      (DECL_ORIGINAL_TYPE (TYPE_NAME (type)),\n+\t       is_const_type, is_volatile_type);\n+\t  /* else cv-qualified version of named type; fall through.  */\n+\t}\n+\n+      if (mod_type_die)\n+\t/* OK */;\n+      else if (is_const_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die);\n \t  sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n@@ -4828,13 +5024,9 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t     might simply be a *copy* of some original type node (where the\n \t     copy was created to help us keep track of typedef names) and\n \t     that copy might have a different TYPE_UID from the original\n-\t     ..._TYPE node.  (Note that when `equate_type_number_to_die' is\n-\t     labeling a given type DIE for future reference, it always only\n-\t     handles DIEs representing *main variants*, and it never even\n-\t     knows about non-main-variants.).  */\n+\t     ..._TYPE node.  */\n \t  mod_type_die = lookup_type_die (type_main_variant (type));\n-\t  if (mod_type_die == NULL)\n-\t    abort ();\n+\t  assert (mod_type_die != NULL);\n \t}\n     }\n   if (sub_die != NULL)\n@@ -5841,11 +6033,15 @@ add_pure_or_virtual_attribute (die, func_decl)\n      register dw_die_ref die;\n      register tree func_decl;\n {\n-  if (DECL_VIRTUAL_P (func_decl))\n+  if (DECL_VINDEX (func_decl))\n     {\n       add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n       add_AT_loc (die, DW_AT_vtable_elem_location, new_loc_descr\n \t\t  (DW_OP_constu, TREE_INT_CST_LOW (DECL_VINDEX (func_decl))));\n+      /* GNU extension: Record what type this method came from originally.  */\n+      if (debug_info_level > DINFO_LEVEL_TERSE)\n+\tadd_AT_die_ref (die, DW_AT_containing_type,\n+\t\t\tlookup_type_die (DECL_CONTEXT (func_decl)));\n     }\n }\n \f\n@@ -5901,14 +6097,15 @@ scope_die_for (t, context_die)\n \n   /* Function-local tags and functions get stuck in limbo until they are\n      fixed up by decls_for_scope.  */\n-  if (context_die == NULL)\n+  if (context_die == NULL\n+      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n     return NULL;\n \n   /* Walk back up the declaration tree looking for a place to define\n      this type.  */\n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n     containing_scope = TYPE_CONTEXT (t);\n-  else if (TREE_CODE (t) == FUNCTION_DECL && DECL_VIRTUAL_P (t))\n+  else if (TREE_CODE (t) == FUNCTION_DECL && DECL_VINDEX (t))\n     containing_scope = decl_class_context (t);\n   else\n     containing_scope = DECL_CONTEXT (t);\n@@ -5999,14 +6196,13 @@ type_tag (type)\n       /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n          a TYPE_DECL node, regardless of whether or not a `typedef' was\n          involved.  */\n-      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t       && ! DECL_IGNORED_P (TYPE_NAME (type)))\n \tt = DECL_NAME (TYPE_NAME (type));\n \n       /* Now get the name as a string, or invent one.  */\n       if (t != 0)\n-\t{\n-\t  name = IDENTIFIER_POINTER (t);\n-\t}\n+\tname = IDENTIFIER_POINTER (t);\n     }\n   return (name == 0 || *name == '\\0') ? 0 : name;\n }\n@@ -6145,6 +6341,43 @@ gen_entry_point_die (decl, context_die)\n     }\n }\n \n+/* Remember a type in the pending_types_list.  */\n+\n+static void\n+pend_type (type)\n+     register tree type;\n+{\n+  if (pending_types == pending_types_allocated)\n+    {\n+      pending_types_allocated += PENDING_TYPES_INCREMENT;\n+      pending_types_list\n+\t= (tree *) xrealloc (pending_types_list,\n+\t\t\t     sizeof (tree) * pending_types_allocated);\n+    }\n+  pending_types_list[pending_types++] = type;\n+}\n+\n+/* Output any pending types (from the pending_types list) which we can output\n+   now (taking into account the scope that we are working on now).\n+\n+   For each type output, remove the given type from the pending_types_list\n+   *before* we try to output it.  */\n+\n+static void\n+output_pending_types_for_scope (context_die)\n+     register dw_die_ref context_die;\n+{\n+  register tree type;\n+\n+  while (pending_types)\n+    {\n+      --pending_types;\n+      type = pending_types_list[pending_types];\n+      gen_type_die (type, context_die);\n+      assert (TREE_ASM_WRITTEN (type));\n+    }\n+}\n+\n /* Generate a DIE to represent an inlined instance of an enumeration type.  */\n static void\n gen_inlined_enumeration_type_die (type, context_die)\n@@ -6241,7 +6474,7 @@ gen_enumeration_type_die (type, context_die)\n    it's the latter, then this function is only being called to output a\n    DW_TAG_formal_parameter DIE to stand as a placeholder for some formal\n    argument type of some subprogram type.  */\n-static void\n+static dw_die_ref\n gen_formal_parameter_die (node, context_die)\n      register tree node;\n      register dw_die_ref context_die;\n@@ -6255,9 +6488,7 @@ gen_formal_parameter_die (node, context_die)\n     case 'd':\n       origin = decl_ultimate_origin (node);\n       if (origin != NULL)\n-\t{\n-\t  add_abstract_origin_attribute (parm_die, origin);\n-\t}\n+\tadd_abstract_origin_attribute (parm_die, origin);\n       else\n \t{\n \t  add_name_and_src_coords_attributes (parm_die, node);\n@@ -6269,13 +6500,9 @@ gen_formal_parameter_die (node, context_die)\n \t    add_AT_flag (parm_die, DW_AT_artificial, 1);\n \t}\n       if (DECL_ABSTRACT (node))\n-\t{\n-\t  equate_decl_number_to_die (node, parm_die);\n-\t}\n+\tequate_decl_number_to_die (node, parm_die);\n       else\n-\t{\n-\t  add_location_or_const_value_attribute (parm_die, node);\n-\t}\n+\tadd_location_or_const_value_attribute (parm_die, node);\n       break;\n \n       /* We were called with some kind of a ..._TYPE node.  */\n@@ -6287,6 +6514,7 @@ gen_formal_parameter_die (node, context_die)\n     default:\n       abort ();\n     }\n+  return parm_die;\n }\n \n /* Generate a special type of DIE used as a stand-in for a trailing ellipsis\n@@ -6334,12 +6562,17 @@ gen_formal_types_die (function_or_method_type, context_die)\n      DW_TAG_formal_parameter DIE for each one.  */\n   for (link = first_parm_type; link; link = TREE_CHAIN (link))\n     {\n+      register dw_die_ref parm_die;\n+      \n       formal_type = TREE_VALUE (link);\n       if (formal_type == void_type_node)\n \tbreak;\n \n       /* Output a (nameless) DIE to represent the formal parameter itself.  */\n-      gen_formal_parameter_die (formal_type, context_die);\n+      parm_die = gen_formal_parameter_die (formal_type, context_die);\n+      if (TREE_CODE (function_or_method_type) == METHOD_TYPE\n+\t  && link == first_parm_type)\n+\tadd_AT_flag (parm_die, DW_AT_artificial, 1);\n     }\n \n   /* If this function type has an ellipsis, add a\n@@ -6375,8 +6608,10 @@ gen_subprogram_die (decl, context_die)\n   register unsigned fp_reg;\n   register tree fn_arg_types;\n   register tree outer_scope;\n-  dw_die_ref old_die = lookup_decl_die (decl);\n-  int declaration = (current_function_decl != decl);\n+  register dw_die_ref old_die = lookup_decl_die (decl);\n+  register int declaration = (current_function_decl != decl\n+\t\t\t      || context_die->die_tag == DW_TAG_structure_type\n+\t\t\t      || context_die->die_tag == DW_TAG_union_type);\n \n   if (origin != NULL)\n     {\n@@ -6387,12 +6622,19 @@ gen_subprogram_die (decl, context_die)\n     {\n       register unsigned file_index\n \t= lookup_filename (DECL_SOURCE_FILE (decl));\n-      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n-\tabort ();\n+\n+      assert (get_AT_flag (old_die, DW_AT_declaration) == 1);\n \n       /* If the definition comes from the same place as the declaration,\n-\t use the old DIE.  */\n-      if (get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n+\t maybe use the old DIE.  We always want the DIE for this function\n+\t that has the *_pc attributes to be under comp_unit_die so the\n+\t debugger can find it.  For inlines, that is the concrete instance,\n+\t so we can use the old DIE here.  For non-inline methods, we want a\n+\t specification DIE at toplevel, so we need a new DIE.  For local\n+\t class methods, this does not apply.  */\n+      if ((DECL_ABSTRACT (decl) || old_die->die_parent == comp_unit_die\n+\t   || context_die == NULL)\n+\t  && get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n \t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n \t      == DECL_SOURCE_LINE (decl)))\n \t{\n@@ -6438,9 +6680,24 @@ gen_subprogram_die (decl, context_die)\n       add_pure_or_virtual_attribute (subr_die, decl);\n       if (DECL_ARTIFICIAL (decl))\n \tadd_AT_flag (subr_die, DW_AT_artificial, 1);\n+      if (TREE_PROTECTED (decl))\n+\tadd_AT_unsigned (subr_die, DW_AT_accessibility, DW_ACCESS_protected);\n+      else if (TREE_PRIVATE (decl))\n+\tadd_AT_unsigned (subr_die, DW_AT_accessibility, DW_ACCESS_private);\n     }\n \n-  if (DECL_ABSTRACT (decl))\n+  if (declaration)\n+    {\n+      add_AT_flag (subr_die, DW_AT_declaration, 1);\n+\n+      /* The first time we see a member function, it is in the context of\n+         the class to which it belongs.  We make sure of this by emitting\n+         the class first.  The next time is the definition, which is\n+         handled above.  The two may come from the same source text.  */\n+      if (decl_class_context (decl))\n+\tequate_decl_number_to_die (decl, subr_die);\n+    }\n+  else if (DECL_ABSTRACT (decl))\n     {\n       if (DECL_DEFER_OUTPUT (decl))\n \t{\n@@ -6460,17 +6717,6 @@ gen_subprogram_die (decl, context_die)\n \n       equate_decl_number_to_die (decl, subr_die);\n     }\n-  else if (declaration)\n-    {\n-      add_AT_flag (subr_die, DW_AT_declaration, 1);\n-\n-      /* The first time we see a member function, it is in the context of\n-         the class to which it belongs.  We make sure of this by emitting\n-         the class first.  The next time is the definition, which is\n-         handled above.  The two may come from the same source text.  */\n-      if (decl_class_context (decl))\n-\tequate_decl_number_to_die (decl, subr_die);\n-    }\n   else if (!DECL_EXTERNAL (decl))\n     {\n       if (origin == NULL)\n@@ -6503,16 +6749,6 @@ gen_subprogram_die (decl, context_die)\n       if (current_function_needs_context)\n \tadd_AT_loc (subr_die, DW_AT_static_link,\n \t\t    loc_descriptor (lookup_static_chain (decl)));\n-\n-#ifdef DWARF_GNU_EXTENSIONS\n-      ASM_GENERATE_INTERNAL_LABEL (label_id, BODY_BEGIN_LABEL,\n-\t\t\t\t   current_funcdef_number);\n-      add_AT_lbl_id (subr_die, DW_AT_body_begin, label_id);\n-      ASM_GENERATE_INTERNAL_LABEL (label_id, BODY_END_LABEL,\n-\t\t\t\t   current_funcdef_number);\n-      add_AT_lbl_id (subr_die, DW_AT_body_end, label_id);\n-#endif\n-\n     }\n \n   /* Now output descriptions of the arguments for this function. This gets\n@@ -6631,16 +6867,17 @@ gen_variable_die (decl, context_die)\n   dw_die_ref old_die = lookup_decl_die (decl);\n   int declaration\n     = (DECL_EXTERNAL (decl)\n-       || current_function_decl != decl_function_context (decl));\n+       || current_function_decl != decl_function_context (decl)\n+       || context_die->die_tag == DW_TAG_structure_type\n+       || context_die->die_tag == DW_TAG_union_type);\n \n   if (origin != NULL)\n     {\n       add_abstract_origin_attribute (var_die, origin);\n     }\n   else if (old_die)\n     {\n-      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n-\tabort ();\n+      assert (get_AT_flag (old_die, DW_AT_declaration) == 1);\n       add_AT_die_ref (var_die, DW_AT_specification, old_die);\n       if (DECL_NAME (decl))\n \t{\n@@ -6664,6 +6901,10 @@ gen_variable_die (decl, context_die)\n \tadd_AT_flag (var_die, DW_AT_external, 1);\n       if (DECL_ARTIFICIAL (decl))\n \tadd_AT_flag (var_die, DW_AT_artificial, 1);\n+      if (TREE_PROTECTED (decl))\n+\tadd_AT_unsigned (var_die, DW_AT_accessibility, DW_ACCESS_protected);\n+      else if (TREE_PRIVATE (decl))\n+\tadd_AT_unsigned (var_die, DW_AT_accessibility, DW_ACCESS_private);\n     }\n \n   if (declaration)\n@@ -6792,9 +7033,14 @@ gen_field_die (decl, context_die)\n       add_bit_size_attribute (decl_die, decl);\n       add_bit_offset_attribute (decl_die, decl);\n     }\n-  add_data_member_location_attribute (decl_die, decl);\n+  if (TREE_CODE (DECL_FIELD_CONTEXT (decl)) != UNION_TYPE)\n+    add_data_member_location_attribute (decl_die, decl);\n   if (DECL_ARTIFICIAL (decl))\n     add_AT_flag (decl_die, DW_AT_artificial, 1);\n+  if (TREE_PROTECTED (decl))\n+    add_AT_unsigned (decl_die, DW_AT_accessibility, DW_ACCESS_protected);\n+  else if (TREE_PRIVATE (decl))\n+    add_AT_unsigned (decl_die, DW_AT_accessibility, DW_ACCESS_private);\n }\n \n #if 0\n@@ -6985,8 +7231,7 @@ gen_struct_or_union_type_die (type, context_die)\n       && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't')\n     nested = 1;\n \n-  if (! type_die || nested)\n-    scope_die = scope_die_for (type, context_die);\n+  scope_die = scope_die_for (type, context_die);\n \n   if (! type_die || (nested && scope_die == comp_unit_die))\n     /* First occurrence of type or toplevel definition of nested class.  */\n@@ -7003,13 +7248,16 @@ gen_struct_or_union_type_die (type, context_die)\n   else\n     remove_AT (type_die, DW_AT_declaration);\n \n+  /* If we're not in the right context to be defining this type, defer to\n+     avoid tricky recursion.  */\n+  if (TYPE_SIZE (type) && decl_scope_depth > 0 && scope_die == comp_unit_die)\n+    {\n+      add_AT_flag (type_die, DW_AT_declaration, 1);\n+      pend_type (type);\n+    }\n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n-  if (TYPE_SIZE (type)\n-      /* If we're getting a reference to one nested class from another\n-\t nested class, don't recurse.  */\n-      && ! (nested && scope_die != context_die\n-\t    && scope_die == lookup_type_die (TYPE_CONTEXT (type))))\n+  else if (TYPE_SIZE (type))\n     {\n       /* Prevent infinite recursion in cases where the type of some member of \n          this type is expressed in terms of this type itself.  */\n@@ -7018,6 +7266,14 @@ gen_struct_or_union_type_die (type, context_die)\n       push_decl_scope (type);\n       gen_member_die (type, type_die);\n       pop_decl_scope ();\n+      /* GNU extension: Record what type our vtable lives in.  */\n+      if (TYPE_VFIELD (type))\n+\t{\n+\t  tree vtype = DECL_FCONTEXT (TYPE_VFIELD (type));\n+\t  gen_type_die (vtype, context_die);\n+\t  add_AT_die_ref (type_die, DW_AT_containing_type,\n+\t\t\t  lookup_type_die (vtype));\n+\t}\n     }\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n@@ -7035,7 +7291,7 @@ gen_subroutine_type_die (type, context_die)\n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n-  gen_formal_types_die (type, context_die);\n+  gen_formal_types_die (type, subr_die);\n }\n \n /* Generate a DIE for a type definition */\n@@ -7044,25 +7300,33 @@ gen_typedef_die (decl, context_die)\n      register tree decl;\n      register dw_die_ref context_die;\n {\n-  register tree origin = decl_ultimate_origin (decl);\n   register dw_die_ref type_die;\n+  register tree origin;\n+\n+  if (TREE_ASM_WRITTEN (decl))\n+    return;\n+  TREE_ASM_WRITTEN (decl) = 1;\n+\n   type_die = new_die (DW_TAG_typedef, scope_die_for (decl, context_die));\n+  origin = decl_ultimate_origin (decl);\n   if (origin != NULL)\n-    {\n-      add_abstract_origin_attribute (type_die, origin);\n-    }\n+    add_abstract_origin_attribute (type_die, origin);\n   else\n     {\n+      register tree type;\n       add_name_and_src_coords_attributes (type_die, decl);\n-      add_type_attribute (type_die, TREE_TYPE (decl),\n-\t\t\t  TREE_READONLY (decl),\n-\t\t\t  TREE_THIS_VOLATILE (decl),\n-\t\t\t  context_die);\n+      if (DECL_ORIGINAL_TYPE (decl))\n+\t{\n+\t  type = DECL_ORIGINAL_TYPE (decl);\n+\t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n+\t}\n+      else\n+\ttype = TREE_TYPE (decl);\n+      add_type_attribute (type_die, type, TREE_READONLY (decl),\n+\t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n     }\n   if (DECL_ABSTRACT (decl))\n-    {\n-      equate_decl_number_to_die (decl, type_die);\n-    }\n+    equate_decl_number_to_die (decl, type_die);\n }\n \n /* Generate a type description DIE.  */\n@@ -7086,6 +7350,14 @@ gen_type_die (type, context_die)\n       return;\n     }\n \n+  if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+      && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n+    { \n+      TREE_ASM_WRITTEN (type) = 1;\n+      gen_decl_die (TYPE_NAME (type), context_die);\n+      return;\n+    }\n+\n   switch (TREE_CODE (type))\n     {\n     case ERROR_MARK:\n@@ -7152,12 +7424,27 @@ gen_type_die (type, context_die)\n       if (TYPE_CONTEXT (type)\n \t  && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'\n \t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n-\tgen_type_die (TYPE_CONTEXT (type), context_die);\n-      else if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t{\n+\t  gen_type_die (TYPE_CONTEXT (type), context_die);\n+\n+\t  if (TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+\t    return;\n+\n+\t  /* If that failed, attach ourselves to the stub.  */\n+\t  push_decl_scope (TYPE_CONTEXT (type));\n+\t  context_die = lookup_type_die (TYPE_CONTEXT (type));\n+\t}\n+\n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n \tgen_enumeration_type_die (type, context_die);\n       else\n \tgen_struct_or_union_type_die (type, context_die);\n \n+      if (TYPE_CONTEXT (type)\n+\t  && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'\n+\t  && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+\tpop_decl_scope ();\n+\n       /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n \t it up if it is ever completed.  gen_*_type_die will set it for us\n \t when appropriate.  */\n@@ -7347,18 +7634,19 @@ decls_for_scope (stmt, context_die, depth)\n   for (decl = BLOCK_VARS (stmt);\n        decl != NULL; decl = TREE_CHAIN (decl))\n     {\n+      register dw_die_ref die;\n+\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  register dw_die_ref die = lookup_decl_die (decl);\n-\t  add_child_die (context_die, die);\n-\t}\n+\tdie = lookup_decl_die (decl);\n       else if (TREE_CODE (decl) == TYPE_DECL && TYPE_DECL_IS_STUB (decl))\n+\tdie = lookup_type_die (TREE_TYPE (decl));\n+      else\n+\tdie = NULL;\n+\n+      if (die && die->die_parent == NULL)\n \t{\n-\t  register dw_die_ref die = lookup_type_die (TREE_TYPE (decl));\n-\t  if (die)\n-\t    add_child_die (context_die, die);\n-\t  else\n-\t    gen_decl_die (decl, context_die);\n+\t  add_child_die (context_die, die);\n+\t  --limbo_die_count;\n \t}\n       else\n \tgen_decl_die (decl, context_die);\n@@ -7374,6 +7662,23 @@ decls_for_scope (stmt, context_die, depth)\n     }\n }\n \n+/* Is this a typedef we can avoid emitting?  */\n+inline int\n+is_redundant_typedef (decl)\n+     register tree decl;\n+{\n+  if (TYPE_DECL_IS_STUB (decl))\n+    return 1;\n+  if (DECL_ARTIFICIAL (decl)\n+      && DECL_CONTEXT (decl)\n+      && is_tagged_type (DECL_CONTEXT (decl))\n+      && TREE_CODE (TYPE_NAME (DECL_CONTEXT (decl))) == TYPE_DECL\n+      && DECL_NAME (decl) == DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))))\n+    /* Also ignore the artificial member typedef for the class name.  */\n+    return 1;\n+  return 0;\n+}\n+\n /* Generate Dwarf debug information for a decl described by DECL.  */\n static void\n gen_decl_die (decl, context_die)\n@@ -7417,10 +7722,21 @@ gen_decl_die (decl, context_die)\n \t  break;\n \t}\n \n-      /* Before we describe the FUNCTION_DECL itself, make sure that we have\n-         described its return type.  */\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n-\tgen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n+\t{\n+\t  /* Before we describe the FUNCTION_DECL itself, make sure that we\n+\t     have described its return type.  */\n+\t  gen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n+\n+\t  /* And its containing type.  */\n+\t  origin = decl_class_context (decl);\n+\t  if (origin)\n+\t    gen_type_die (origin, context_die);\n+\n+\t  /* And its virtual context.  */\n+\t  if (DECL_VINDEX (decl))\n+\t    gen_type_die (DECL_CONTEXT (decl), context_die);\n+\t}\n \n       /* Now output a DIE to represent the function itself.  */\n       gen_subprogram_die (decl, context_die);\n@@ -7444,9 +7760,10 @@ gen_decl_die (decl, context_die)\n \t  gen_tagged_type_instantiation_die (TREE_TYPE (decl), context_die);\n \t  break;\n \t}\n-      gen_type_die (TREE_TYPE (decl), context_die);\n \n-      if (! TYPE_DECL_IS_STUB (decl))\n+      if (is_redundant_typedef (decl))\n+\tgen_type_die (TREE_TYPE (decl), context_die);\n+      else\n \t{\n \t  /* Output a DIE to represent the typedef itself.  */\n \t  gen_typedef_die (decl, context_die);\n@@ -7472,6 +7789,11 @@ gen_decl_die (decl, context_die)\n          object.  */\n       gen_type_die (TREE_TYPE (decl), context_die);\n \n+      /* And its containing type.  */\n+      origin = decl_class_context (decl);\n+      if (origin)\n+\tgen_type_die (origin, context_die);\n+\n       /* Now output the DIE to represent the data object itself.  This gets\n          complicated because of the possibility that the VAR_DECL really\n          represents an inlined instance of a formal parameter for an inline\n@@ -7488,8 +7810,9 @@ gen_decl_die (decl, context_die)\n       break;\n \n     case FIELD_DECL:\n-      /* Ignore the nameless fields that are used to skip bits.  */\n-      if (DECL_NAME (decl) != 0)\n+      /* Ignore the nameless fields that are used to skip bits, but\n+\t handle C++ anonymous unions.  */\n+      if (DECL_NAME (decl) != 0 || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE)\n \t{\n \t  gen_type_die (member_declared_type (decl), context_die);\n \t  gen_field_die (decl, context_die);\n@@ -7610,7 +7933,15 @@ dwarf2out_decl (decl)\n       /* Don't bother trying to generate any DIEs to represent any of the\n          normal built-in types for the language we are compiling.  */\n       if (DECL_SOURCE_LINE (decl) == 0)\n-\treturn;\n+\t{\n+\t  /* OK, we need to generate one for `bool' so GDB knows what type\n+             comparisons have.  */\n+\t  if ((get_AT_unsigned (comp_unit_die, DW_AT_language)\n+\t       == DW_LANG_C_plus_plus)\n+\t      && TREE_CODE (TREE_TYPE (decl)) == BOOLEAN_TYPE)\n+\t    modified_type_die (TREE_TYPE (decl), 0, 0, NULL);\n+\t  return;\n+\t}\n \n       /* If we are in terse mode, don't generate any DIEs for types.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n@@ -7628,6 +7959,7 @@ dwarf2out_decl (decl)\n     }\n \n   gen_decl_die (decl, context_die);\n+  output_pending_types_for_scope (comp_unit_die);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_INITIAL (decl) != NULL)\n@@ -7700,8 +8032,7 @@ dwarf2out_begin_prologue ()\n   /* Add the new FDE at the end of the fde_table.  */\n   fde = &fde_table[fde_table_in_use++];\n   fde->dw_fde_begin = xstrdup (label);\n-  fde->dw_fde_end_prolog = NULL;\n-  fde->dw_fde_begin_epilogue = NULL;\n+  fde->dw_fde_current_label = NULL;\n   fde->dw_fde_end = NULL;\n   fde->dw_fde_cfi = NULL;\n }\n@@ -7712,100 +8043,51 @@ dwarf2out_begin_prologue ()\n void\n dwarf2out_begin_function ()\n {\n+#ifdef MIPS_DEBUGGING_INFO\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register long int offset;\n   register dw_fde_ref fde;\n   register dw_cfi_ref cfi;\n+  register int regno, fp_inc;\n \n   function_section (current_function_decl);\n   ASM_GENERATE_INTERNAL_LABEL (label, BODY_BEGIN_LABEL,\n \t\t\t       current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n \n-  /* Record the end-of-prolog location in the FDE.  */\n-  fde = &fde_table[fde_table_in_use - 1];\n-  fde->dw_fde_end_prolog = xstrdup (label);\n-\n-#ifdef MIPS_DEBUGGING_INFO\n-\n-  /* Set the location counter to the end of the function prolog.  */\n-  cfi = new_cfi ();\n-  cfi->dw_cfi_opc = DW_CFA_advance_loc4;\n-  cfi->dw_cfi_oprnd1.dw_cfi_addr = xstrdup (label);\n-  add_cfi (&fde->dw_fde_cfi, cfi);\n-\n   /* Define the CFA as an offset from either the frame pointer\n      or the stack pointer.  */\n-  cfi = new_cfi ();\n-  cfi->dw_cfi_opc = DW_CFA_def_cfa;\n-  cfi->dw_cfi_oprnd1.dw_cfi_reg_num\n-    = DWARF_FRAME_REGNUM (frame_pointer_needed ? FRAME_POINTER_REGNUM\n-\t\t\t  : STACK_POINTER_REGNUM);\n-  offset = current_frame_info.total_size;\n-  cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n-  add_cfi (&fde->dw_fde_cfi, cfi);\n-\n-  /* record the frame size for later definition of the DW_AT_frame_base\n-     attribute.  */\n-  current_funcdef_frame_size = offset;\n-\n-  /* Define the rule for restoring the stack pointer.  */\n-  if (frame_pointer_needed)\n-    {\n-      /* Restore the stack register from the frame pointer.  */\n-      cfi = new_cfi ();\n-      cfi->dw_cfi_opc = DW_CFA_register;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num\n-\t= DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n-      cfi->dw_cfi_oprnd2.dw_cfi_reg_num\n-\t= DWARF_FRAME_REGNUM (FRAME_POINTER_REGNUM);\n-      add_cfi (&fde->dw_fde_cfi, cfi);\n-    }\n-\n-  /* If RA is saved on the stack, define it here.  */\n-  if (regs_ever_live[31])\n-    {\n-      offset = current_frame_info.gp_save_offset / DWARF_CIE_DATA_ALIGNMENT;\n-      assert (offset >= 0);\n-      cfi = new_cfi ();\n-      cfi->dw_cfi_opc = DW_CFA_offset_extended;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_RETURN_COLUMN;\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n-      add_cfi (&fde->dw_fde_cfi, cfi);\n-    }\n+  dwarf2out_def_cfa\n+    (label, gen_rtx (PLUS, VOIDmode,\n+\t\t     gen_rtx (REG, VOIDmode,\n+\t\t\t      (frame_pointer_needed ? FRAME_POINTER_REGNUM\n+\t\t\t       : STACK_POINTER_REGNUM)),\n+\t\t     GEN_INT (current_frame_info.total_size)));\n+\n+  /* Record the locations of the return address and any callee-saved regs.  */\n+  offset = current_frame_info.gp_save_offset / DWARF_CIE_DATA_ALIGNMENT;\n+  for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; --regno)\n+    if (current_frame_info.mask & (1<<regno))\n+      {\n+\tassert (offset >= 0);\n \n-  /* If FP is saved on the stack, define it here.  */\n-  if (current_frame_info.mask & (1 << 30))\n-    {\n-      offset = (current_frame_info.gp_save_offset\n-\t         - (((current_frame_info.mask >> 31) & 1) * UNITS_PER_WORD))\n-               / DWARF_CIE_DATA_ALIGNMENT;\n-      assert (offset >= 0);\n-      cfi = new_cfi ();\n-      cfi->dw_cfi_opc = DW_CFA_offset;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num\n-\t= DWARF_FRAME_REGNUM (FRAME_POINTER_REGNUM);\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n-      add_cfi (&fde->dw_fde_cfi, cfi);\n-    }\n+\tif (regno == 31)\n+\t  dwarf2out_return_save (label, GEN_INT (offset));\n+\telse\n+\t  dwarf2out_reg_save (label, regno, GEN_INT (offset));\n+\toffset -= UNITS_PER_WORD / DWARF_CIE_DATA_ALIGNMENT;\n+      }\n \n+  fp_inc = (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT) ? 1 : 2;\n+  offset = current_frame_info.fp_save_offset / DWARF_CIE_DATA_ALIGNMENT;\n+  for (regno = FP_REG_LAST - 1; regno >= FP_REG_FIRST; regno -= fp_inc)\n+    if (current_frame_info.fmask & (1 << (regno - FP_REG_FIRST)))\n+      {\n+\tassert (offset >= 0);\n+\tdwarf2out_reg_save (label, regno, GEN_INT (offset));\n+\toffset -= (fp_inc * UNITS_PER_FPREG) / DWARF_CIE_DATA_ALIGNMENT;\n+      }\n #endif\n-\n-}\n-\n-/* Output a marker (i.e. a label) for the point in the generated code where\n-   the real body of the function ends (just before the epilogue code).  */\n-void\n-dwarf2out_end_function ()\n-{\n-  dw_fde_ref fde;\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  function_section (current_function_decl);\n-  ASM_GENERATE_INTERNAL_LABEL (label, BODY_END_LABEL, current_funcdef_number);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n-  /* Record the ending code location in the FDE.  */\n-  fde = &fde_table[fde_table_in_use - 1];\n-  fde->dw_fde_begin_epilogue = xstrdup(label);\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code\n@@ -7998,13 +8280,6 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   /* skip the first entry - file numbers begin at 1 */\n   file_table_in_use = 1;\n \n-  /* Allocate the initial hunk of the type_die_table.  */\n-  type_die_table\n-    = (dw_die_ref *) xmalloc (TYPE_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n-  bzero (type_die_table, TYPE_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n-  type_die_table_allocated = TYPE_DIE_TABLE_INCREMENT;\n-  type_die_table_in_use = 0;\n-\n   /* Allocate the initial hunk of the decl_die_table.  */\n   decl_die_table\n     = (dw_die_ref *) xmalloc (DECL_DIE_TABLE_INCREMENT * sizeof (dw_die_ref));\n@@ -8052,6 +8327,16 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   gen_compile_unit_die (main_input_filename);\n \n   ASM_GENERATE_INTERNAL_LABEL (text_end_label, TEXT_END_LABEL, 0);\n+\n+  /* Generate the CFA instructions common to all FDE's.  Do it now for the\n+     sake of lookup_cfa.  */\n+#ifdef MIPS_DEBUGGING_INFO\n+  /* On entry, the Call Frame Address is in the stack pointer register.  */\n+  dwarf2out_def_cfa (NULL, gen_rtx (REG, VOIDmode, STACK_POINTER_REGNUM));\n+\n+  /* Set the RA on entry to be the contents of r31.  */\n+  dwarf2out_return_save (NULL, gen_rtx (REG, VOIDmode, GP_REG_FIRST + 31));\n+#endif\n }\n \n /* Output stuff that dwarf requires at the end of every file,\n@@ -8107,8 +8392,7 @@ dwarf2out_finish ()\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n   calc_die_sizes (comp_unit_die);\n \n-  /* Initialize the beginning FDE offset - and calculate sizes/offsets.  */\n-  next_fde_offset = DWARF_CIE_SIZE;\n+  /* calculate sizes/offsets for FDEs.  */\n   calc_fde_sizes ();\n \n   /* Output debugging information.  */\n@@ -8127,15 +8411,20 @@ dwarf2out_finish ()\n \n   if (fde_table_in_use)\n     {\n+#ifdef MIPS_DEBUGGING_INFO /* Not currently useful otherwise.  */\n       /* Output call frame information.  */\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n       output_call_frame_info ();\n+#endif\n \n       /* Output the address range information.  */\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_SECTION (asm_out_file, ARANGES_SECTION);\n       output_aranges ();\n     }\n+\n+  /* The only DIE we should have with a parent of NULL is comp_unit_die.  */\n+  assert (limbo_die_count == 1);\n }\n #endif /* DWARF2_DEBUGGING_INFO */"}, {"sha": "1d2939458895cb84e5c11b1bb4f8b86088325f9d", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 223, "deletions": 112, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -97,6 +97,21 @@ extern char *rindex ();\n \n #define TYPE_USED_FOR_FUNCTION(tagged_type) (TYPE_SIZE (tagged_type) == 0)\n \n+/* Define a macro which returns non-zero for a TYPE_DECL which was\n+   implicitly generated for a tagged type.\n+\n+   Note that unlike the gcc front end (which generates a NULL named\n+   TYPE_DECL node for each complete tagged type, each array type, and\n+   each function type node created) the g++ front end generates a\n+   _named_ TYPE_DECL node for each tagged type node created.\n+   These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n+   generate a DW_TAG_typedef DIE for them.  */\n+#define TYPE_DECL_IS_STUB(decl)\t\t\t\t\\\n+  (DECL_NAME (decl) == NULL\t\t\t\t\\\n+   || (DECL_ARTIFICIAL (decl)\t\t\t\t\\\n+       && is_tagged_type (TREE_TYPE (decl))\t\t\\\n+       && decl == TYPE_STUB_DECL (TREE_TYPE (decl))))\n+\n extern int flag_traditional;\n extern char *version_string;\n extern char *language_string;\n@@ -284,6 +299,12 @@ static unsigned current_funcdef_number = 1;\n \n static tree dwarf_last_decl;\n \n+/* A flag indicating that we are emitting the member declarations of a\n+   class, so member functions and variables should not be entirely emitted.\n+   This is a kludge to avoid passing a second argument to output_*_die.  */\n+\n+static int in_class;\n+\n /* Forward declarations for functions defined in this file.  */\n \n static char *dwarf_tag_name\t\tPROTO((unsigned));\n@@ -1169,6 +1190,27 @@ block_ultimate_origin (block)\n     }\n }\n \n+/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT\n+   of a virtual function may refer to a base class, so we check the 'this'\n+   parameter.  */\n+\n+static tree\n+decl_class_context (decl)\n+     tree decl;\n+{\n+  tree context = NULL_TREE;\n+  if (TREE_CODE (decl) != FUNCTION_DECL || ! DECL_VINDEX (decl))\n+    context = DECL_CONTEXT (decl);\n+  else\n+    context = TYPE_MAIN_VARIANT\n+      (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n+\n+  if (context && TREE_CODE_CLASS (TREE_CODE (context)) != 't')\n+    context = NULL_TREE;\n+\n+  return context;\n+}\n+\n static void\n output_unsigned_leb128 (value)\n      register unsigned long value;\n@@ -3007,8 +3049,8 @@ type_tag (type)\n       /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n          a TYPE_DECL node, regardless of whether or not a `typedef' was\n          involved.  */\n-      else\n-\tif (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t       && ! DECL_IGNORED_P (TYPE_NAME (type)))\n \t  t = DECL_NAME (TYPE_NAME (type));\n \n       /* Now get the name as a string, or invent one.  */\n@@ -3302,17 +3344,21 @@ output_global_subroutine_die (arg)\n     equate_decl_number_to_die_number (decl);\n   else\n     {\n-      if (! DECL_EXTERNAL (decl))\n+      if (! DECL_EXTERNAL (decl) && ! in_class\n+\t  && decl == current_function_decl)\n \t{\n \t  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n \t  low_pc_attribute (function_start_label (decl));\n \t  sprintf (label, FUNC_END_LABEL_FMT, current_funcdef_number);\n \t  high_pc_attribute (label);\n-\t  sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n-\t  body_begin_attribute (label);\n-\t  sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n-\t  body_end_attribute (label);\n+\t  if (use_gnu_debug_info_extensions)\n+\t    {\n+\t      sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+\t      body_begin_attribute (label);\n+\t      sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n+\t      body_end_attribute (label);\n+\t    }\n \t}\n     }\n }\n@@ -3342,7 +3388,8 @@ output_global_variable_die (arg)\n     equate_decl_number_to_die_number (decl);\n   else\n     {\n-      if (!DECL_EXTERNAL (decl))\n+      if (! DECL_EXTERNAL (decl) && ! in_class\n+\t  && current_function_decl == decl_function_context (decl))\n \tlocation_or_const_value_attribute (decl);\n     }\n }\n@@ -3566,7 +3613,7 @@ output_compile_unit_die (arg)\n       comp_dir_attribute (wd);\n   }\n \n-  if (debug_info_level >= DINFO_LEVEL_NORMAL)\n+  if (debug_info_level >= DINFO_LEVEL_NORMAL && use_gnu_debug_info_extensions)\n     {\n       sf_names_attribute (SFNAMES_BEGIN_LABEL);\n       src_info_attribute (SRCINFO_BEGIN_LABEL);\n@@ -3681,10 +3728,13 @@ output_local_subroutine_die (arg)\n \t  low_pc_attribute (function_start_label (decl));\n \t  sprintf (label, FUNC_END_LABEL_FMT, current_funcdef_number);\n \t  high_pc_attribute (label);\n-\t  sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n-\t  body_begin_attribute (label);\n-\t  sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n-\t  body_end_attribute (label);\n+\t  if (use_gnu_debug_info_extensions)\n+\t    {\n+\t      sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n+\t      body_begin_attribute (label);\n+\t      sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n+\t      body_end_attribute (label);\n+\t    }\n \t}\n     }\n }\n@@ -3990,7 +4040,9 @@ type_ok_for_scope (type, scope)\n      (for C and C++ anyway) will be array types and function types.  */\n \n   return is_tagged_type (type)\n-\t ? (TYPE_CONTEXT (type) == scope)\n+\t ? (TYPE_CONTEXT (type) == scope\n+\t    || (scope == NULL_TREE && is_tagged_type (TYPE_CONTEXT (type))\n+\t\t&& TREE_ASM_WRITTEN (TYPE_CONTEXT (type))))\n \t : (scope == NULL_TREE || ! is_tagged_type (scope));\n }\n \n@@ -4058,6 +4110,17 @@ output_type (type, containing_scope)\n   if (TREE_ASM_WRITTEN (type))\n     return;\n \n+  /* If this is a nested type whose containing class hasn't been\n+     written out yet, writing it out will cover this one, too.  */\n+\n+  if (TYPE_CONTEXT (type)\n+      && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'\n+      && ! TREE_ASM_WRITTEN (TYPE_CONTEXT (type)))\n+    {\n+      output_type (TYPE_CONTEXT (type), containing_scope);\n+      return;\n+    }\n+\n   /* Don't generate any DIEs for this type now unless it is OK to do so\n      (based upon what `type_ok_for_scope' tells us).  */\n \n@@ -4168,13 +4231,9 @@ output_type (type, containing_scope)\n \t   time, we will certainly know as much about each file-scope tagged\n \t   type as we are ever going to know, so at that point in time, we\n \t   can safely generate correct Dwarf descriptions for these file-\n-\t   scope tagged types.\n-\n-\t   This loses for C++ nested types that are defined after their\n-\t   containing class, but I don't see a good way to fix it.  I doubt\n-\t   many people will be using DWARF 1 for C++ in any case.  */\n+\t   scope tagged types.  */\n \n-\tif (TYPE_SIZE (type) == 0 && TYPE_CONTEXT (type) == NULL && !finalizing)\n+\tif (TYPE_SIZE (type) == 0 && !finalizing)\n \t  return;\t/* EARLY EXIT!  Avoid setting TREE_ASM_WRITTEN.  */\n \n \t/* Prevent infinite recursion in cases where the type of some\n@@ -4233,6 +4292,8 @@ output_type (type, containing_scope)\n \t\t  output_die (output_inheritance_die, TREE_VEC_ELT (bases, i));\n \t      }\n \n+\t    ++in_class;\n+\n \t    {\n \t      register tree normal_member;\n \n@@ -4255,6 +4316,8 @@ output_type (type, containing_scope)\n \t\toutput_decl (func_member, type);\n \t    }\n \n+\t    --in_class;\n+\n \t    /* RECORD_TYPEs, UNION_TYPEs, and QUAL_UNION_TYPEs are themselves\n \t       scopes (at least in C++) so we must now output any nested\n \t       pending types which are local just to this type.  */\n@@ -4458,6 +4521,24 @@ output_decls_for_scope (stmt, depth)\n   }\n }\n \n+/* Is this a typedef we can avoid emitting?  */\n+\n+inline int\n+is_redundant_typedef (decl)\n+     register tree decl;\n+{\n+  if (TYPE_DECL_IS_STUB (decl))\n+    return 1;\n+  if (DECL_ARTIFICIAL (decl)\n+      && DECL_CONTEXT (decl)\n+      && is_tagged_type (DECL_CONTEXT (decl))\n+      && TREE_CODE (TYPE_NAME (DECL_CONTEXT (decl))) == TYPE_DECL\n+      && DECL_NAME (decl) == DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))))\n+    /* Also ignore the artificial member typedef for the class name.  */\n+    return 1;\n+  return 0;\n+}\n+\n /* Output Dwarf .debug information for a decl described by DECL.  */\n \n static void\n@@ -4518,6 +4599,13 @@ output_decl (decl, containing_scope)\n \n       output_type (TREE_TYPE (TREE_TYPE (decl)), containing_scope);\n \n+      {\n+\t/* And its containing type.  */\n+\tregister tree origin = decl_class_context (decl);\n+\tif (origin)\n+\t  output_type (origin, containing_scope);\n+      }\n+\n       /* If the following DIE will represent a function definition for a\n \t function with \"extern\" linkage, output a special \"pubnames\" DIE\n \t label just ahead of the actual DIE.  A reference to this label\n@@ -4554,7 +4642,7 @@ output_decl (decl, containing_scope)\n \t we need to do here (and all we *can* do here) is to describe\n \t the *types* of its formal parameters.  */\n \n-      if (DECL_INITIAL (decl) == NULL_TREE)\n+      if (decl != current_function_decl || in_class)\n \toutput_formal_types (TREE_TYPE (decl));\n       else\n \t{\n@@ -4644,45 +4732,45 @@ output_decl (decl, containing_scope)\n                 output_die (output_unspecified_parameters_die, decl);\n               }\n \t  }\n-\t}\n \n-      /* Output Dwarf info for all of the stuff within the body of the\n-\t function (if it has one - it may be just a declaration).  */\n+\t  /* Output Dwarf info for all of the stuff within the body of the\n+\t     function (if it has one - it may be just a declaration).  */\n \n-      {\n-\tregister tree outer_scope = DECL_INITIAL (decl);\n-\n-\tif (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n \t  {\n-\t    /* Note that here, `outer_scope' is a pointer to the outermost\n-\t       BLOCK node created to represent a function.\n-\t       This outermost BLOCK actually represents the outermost\n-\t       binding contour for the function, i.e. the contour in which\n-\t       the function's formal parameters and labels get declared.\n-\n-\t       Curiously, it appears that the front end doesn't actually\n-\t       put the PARM_DECL nodes for the current function onto the\n-\t       BLOCK_VARS list for this outer scope.  (They are strung\n-\t       off of the DECL_ARGUMENTS list for the function instead.)\n-\t       The BLOCK_VARS list for the `outer_scope' does provide us\n-\t       with a list of the LABEL_DECL nodes for the function however,\n-\t       and we output DWARF info for those here.\n-\n-\t       Just within the `outer_scope' there will be a BLOCK node\n-\t       representing the function's outermost pair of curly braces,\n-\t       and any blocks used for the base and member initializers of\n-\t       a C++ constructor function.  */\n-\n-\t    output_decls_for_scope (outer_scope, 0);\n-\n-\t    /* Finally, force out any pending types which are local to the\n-\t       outermost block of this function definition.  These will\n-\t       all have a TYPE_CONTEXT which points to the FUNCTION_DECL\n-\t       node itself.  */\n-\n-\t    output_pending_types_for_scope (decl);\n+\t    register tree outer_scope = DECL_INITIAL (decl);\n+\n+\t    if (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n+\t      {\n+\t\t/* Note that here, `outer_scope' is a pointer to the outermost\n+\t\t   BLOCK node created to represent a function.\n+\t\t   This outermost BLOCK actually represents the outermost\n+\t\t   binding contour for the function, i.e. the contour in which\n+\t\t   the function's formal parameters and labels get declared.\n+\n+\t\t   Curiously, it appears that the front end doesn't actually\n+\t\t   put the PARM_DECL nodes for the current function onto the\n+\t\t   BLOCK_VARS list for this outer scope.  (They are strung\n+\t\t   off of the DECL_ARGUMENTS list for the function instead.)\n+\t\t   The BLOCK_VARS list for the `outer_scope' does provide us\n+\t\t   with a list of the LABEL_DECL nodes for the function however,\n+\t\t   and we output DWARF info for those here.\n+\n+\t\t   Just within the `outer_scope' there will be a BLOCK node\n+\t\t   representing the function's outermost pair of curly braces,\n+\t\t   and any blocks used for the base and member initializers of\n+\t\t   a C++ constructor function.  */\n+\n+\t\toutput_decls_for_scope (outer_scope, 0);\n+\n+\t\t/* Finally, force out any pending types which are local to the\n+\t\t   outermost block of this function definition.  These will\n+\t\t   all have a TYPE_CONTEXT which points to the FUNCTION_DECL\n+\t\t   node itself.  */\n+\n+\t\toutput_pending_types_for_scope (decl);\n+\t      }\n \t  }\n-      }\n+\t}\n \n       /* Generate a terminator for the list of stuff `owned' by this\n \t function.  */\n@@ -4699,33 +4787,27 @@ output_decl (decl, containing_scope)\n \t a return type or a formal parameter type of some function.  */\n \n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\tif (DECL_NAME (decl) != NULL\n-\t    || ! TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n+\tif (! TYPE_DECL_IS_STUB (decl)\n+\t    || (! TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)) && ! in_class))\n           return;\n \n-      /* In the special case of a null-named TYPE_DECL node (representing\n-\t the declaration of some type tag), if the given TYPE_DECL is\n+      /* In the special case of a TYPE_DECL node representing\n+\t the declaration of some type tag, if the given TYPE_DECL is\n \t marked as having been instantiated from some other (original)\n \t TYPE_DECL node (e.g. one which was generated within the original\n \t definition of an inline function) we have to generate a special\n \t (abbreviated) TAG_structure_type, TAG_union_type, or\n \t TAG_enumeration-type DIE here.  */\n \n-      if (! DECL_NAME (decl) && DECL_ABSTRACT_ORIGIN (decl))\n+      if (TYPE_DECL_IS_STUB (decl) && DECL_ABSTRACT_ORIGIN (decl))\n \t{\n \t  output_tagged_type_instantiation (TREE_TYPE (decl));\n \t  return;\n \t}\n \n       output_type (TREE_TYPE (decl), containing_scope);\n \n-      /* Note that unlike the gcc front end (which generates a NULL named\n-\t TYPE_DECL node for each complete tagged type, each array type,\n-\t and each function type node created) the g++ front end generates\n-\t a *named* TYPE_DECL node for each tagged type node created.\n-\t These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to\n-\t generate a DW_TAG_typedef DIE for them.  */\n-      if (DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n+      if (! is_redundant_typedef (decl))\n \t/* Output a DIE to represent the typedef itself.  */\n \toutput_die (output_typedef_die, decl);\n       break;\n@@ -4755,6 +4837,13 @@ output_decl (decl, containing_scope)\n \n       output_type (TREE_TYPE (decl), containing_scope);\n \n+      {\n+\t/* And its containing type.  */\n+\tregister tree origin = decl_class_context (decl);\n+\tif (origin)\n+\t  output_type (origin, containing_scope);\n+      }\n+\n       /* If the following DIE will represent a data object definition for a\n \t data object with \"extern\" linkage, output a special \"pubnames\" DIE\n \t label just ahead of the actual DIE.  A reference to this label\n@@ -5076,6 +5165,8 @@ dwarfout_begin_function ()\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+  if (! use_gnu_debug_info_extensions)\n+    return;\n   function_section (current_function_decl);\n   sprintf (label, BODY_BEGIN_LABEL_FMT, current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n@@ -5089,6 +5180,8 @@ dwarfout_end_function ()\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n+  if (! use_gnu_debug_info_extensions)\n+    return;\n   function_section (current_function_decl);\n   sprintf (label, BODY_END_LABEL_FMT, current_funcdef_number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n@@ -5263,7 +5356,7 @@ dwarfout_line (filename, line)\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n       static unsigned last_line_entry_num = 0;\n       static unsigned prev_file_entry_num = (unsigned) -1;\n-      register unsigned this_file_entry_num = lookup_filename (filename);\n+      register unsigned this_file_entry_num;\n \n       function_section (current_function_decl);\n       sprintf (label, LINE_CODE_LABEL_FMT, ++last_line_entry_num);\n@@ -5272,6 +5365,11 @@ dwarfout_line (filename, line)\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, LINE_SECTION);\n \n+      if (use_gnu_debug_info_extensions)\n+\tthis_file_entry_num = lookup_filename (filename);\n+      else\n+\tthis_file_entry_num = (unsigned) -1;\n+\n       if (this_file_entry_num != prev_file_entry_num)\n         {\n           char line_entry_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -5307,6 +5405,9 @@ generate_macinfo_entry (type_and_offset, string)\n      register char *type_and_offset;\n      register char *string;\n {\n+  if (! use_gnu_debug_info_extensions)\n+    return;\n+\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_PUSH_SECTION (asm_out_file, MACINFO_SECTION);\n   fprintf (asm_out_file, \"\\t%s\\t%s\\n\", UNALIGNED_INT_ASM_OP, type_and_offset);\n@@ -5466,32 +5567,36 @@ dwarfout_init (asm_out_file, main_input_filename)\n \n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n-      /* Output a starting label and an initial (compilation directory)\n-\t entry for the .debug_sfnames section.  The starting label will be\n-\t referenced by the initial entry in the .debug_srcinfo section.  */\n+      if (use_gnu_debug_info_extensions)\n+\t{\n+\t  /* Output a starting label and an initial (compilation directory)\n+\t     entry for the .debug_sfnames section.  The starting label will be\n+\t     referenced by the initial entry in the .debug_srcinfo section.  */\n     \n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_PUSH_SECTION (asm_out_file, SFNAMES_SECTION);\n-      ASM_OUTPUT_LABEL (asm_out_file, SFNAMES_BEGIN_LABEL);\n-      {\n-\tregister char *pwd;\n-\tregister unsigned len;\n-\tregister char *dirname;\n-\n-\tpwd = getpwd ();\n-\tif (!pwd)\n-\t  pfatal_with_name (\"getpwd\");\n-\tlen = strlen (pwd);\n-\tdirname = (char *) xmalloc (len + 2);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, SFNAMES_SECTION);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, SFNAMES_BEGIN_LABEL);\n+\t  {\n+\t    register char *pwd;\n+\t    register unsigned len;\n+\t    register char *dirname;\n+\n+\t    pwd = getpwd ();\n+\t    if (!pwd)\n+\t      pfatal_with_name (\"getpwd\");\n+\t    len = strlen (pwd);\n+\t    dirname = (char *) xmalloc (len + 2);\n     \n-\tstrcpy (dirname, pwd);\n-\tstrcpy (dirname + len, \"/\");\n-        ASM_OUTPUT_DWARF_STRING (asm_out_file, dirname);\n-        free (dirname);\n-      }\n-      ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\t    strcpy (dirname, pwd);\n+\t    strcpy (dirname + len, \"/\");\n+\t    ASM_OUTPUT_DWARF_STRING (asm_out_file, dirname);\n+\t    free (dirname);\n+\t  }\n+\t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\t}\n     \n-      if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n+      if (debug_info_level >= DINFO_LEVEL_VERBOSE\n+\t  && use_gnu_debug_info_extensions)\n \t{\n           /* Output a starting label for the .debug_macinfo section.  This\n \t     label will be referenced by the AT_mac_info attribute in the\n@@ -5512,21 +5617,24 @@ dwarfout_init (asm_out_file, main_input_filename)\n       ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n     \n-      /* Generate the initial entry for the .debug_srcinfo section.  */\n-    \n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_PUSH_SECTION (asm_out_file, SRCINFO_SECTION);\n-      ASM_OUTPUT_LABEL (asm_out_file, SRCINFO_BEGIN_LABEL);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, LINE_BEGIN_LABEL);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, SFNAMES_BEGIN_LABEL);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n-      ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_END_LABEL);\n+      if (use_gnu_debug_info_extensions)\n+\t{\n+\t  /* Generate the initial entry for the .debug_srcinfo section.  */\n+\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, SRCINFO_SECTION);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, SRCINFO_BEGIN_LABEL);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, LINE_BEGIN_LABEL);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, SFNAMES_BEGIN_LABEL);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_END_LABEL);\n #ifdef DWARF_TIMESTAMPS\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, time (NULL));\n+\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, time (NULL));\n #else\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, -1);\n+\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, -1);\n #endif\n-      ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\t}\n     \n       /* Generate the initial entry for the .debug_pubnames section.  */\n     \n@@ -5664,14 +5772,17 @@ dwarfout_finish ()\n       ASM_OUTPUT_LABEL (asm_out_file, LINE_END_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n     \n-      /* Output a terminating entry for the .debug_srcinfo section.  */\n-    \n-      fputc ('\\n', asm_out_file);\n-      ASM_OUTPUT_PUSH_SECTION (asm_out_file, SRCINFO_SECTION);\n-      ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n-\t\t\t       LINE_LAST_ENTRY_LABEL, LINE_BEGIN_LABEL);\n-      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, -1);\n-      ASM_OUTPUT_POP_SECTION (asm_out_file);\n+      if (use_gnu_debug_info_extensions)\n+\t{\n+\t  /* Output a terminating entry for the .debug_srcinfo section.  */\n+\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, SRCINFO_SECTION);\n+\t  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n+\t\t\t\t   LINE_LAST_ENTRY_LABEL, LINE_BEGIN_LABEL);\n+\t  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, -1);\n+\t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\t}\n \n       if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n \t{"}, {"sha": "40a0911982a1aaa07e99b40219502223834c23e1", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -1066,11 +1066,6 @@ final_end_function (first, file, optimize)\n     dwarfout_end_function ();\n #endif\n \n-#ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG)\n-    dwarf2out_end_function ();\n-#endif\n-\n #ifdef XCOFF_DEBUGGING_INFO\n   if (write_symbols == XCOFF_DEBUG)\n     xcoffout_end_function (file, high_function_linenum);"}, {"sha": "a10f4d9ebeced47e11b1aa004fbbc158acee4978", "filename": "gcc/toplev.c", "status": "modified", "additions": 57, "deletions": 19, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -2776,15 +2776,6 @@ rest_of_type_compilation (type, toplev)\n   if (write_symbols == SDB_DEBUG)\n     TIMEVAR (symout_time, sdbout_symbol (TYPE_STUB_DECL (type), !toplev));\n #endif\n-#ifdef DWARF_DEBUGGING_INFO\n-  /* Don't write out function-scope types here.  */\n-  if (write_symbols == DWARF_DEBUG && toplev)\n-    TIMEVAR (symout_time, dwarfout_file_scope_decl (TYPE_STUB_DECL (type), 0));\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-  if (write_symbols == DWARF2_DEBUG)\n-    TIMEVAR (symout_time, dwarf2out_decl (TYPE_STUB_DECL (type)));\n-#endif\n }\n \n /* This is called from finish_function (within yyparse)\n@@ -3904,19 +3895,11 @@ main (argc, argv, envp)\n \t\t{ \"gstabs+\", DBX_DEBUG, 1 },\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n-\t\t{ \"gdwarf-1\", DWARF_DEBUG, 0 },\n-\t\t{ \"gdwarf-1+\", DWARF_DEBUG, 1 },\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t\t{ \"gdwarf-2\", DWARF2_DEBUG, 0 },\n-#endif\n-#if defined (DWARF_DEBUGGING_INFO) || defined (DWARF2_DEBUGGING_INFO)\n-#if PREFERRED_DEBUGGING_TYPE == DWARF_DEBUG || !defined (DWARF2_DEBUGGING_INFO)\n \t\t{ \"gdwarf\", DWARF_DEBUG, 0 },\n \t\t{ \"gdwarf+\", DWARF_DEBUG, 1 },\n-#else\n-\t\t{ \"gdwarf\", DWARF2_DEBUG, 0 },\n #endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+\t\t{ \"gdwarf-2\", DWARF2_DEBUG, 0 },\n #endif\n #ifdef XCOFF_DEBUGGING_INFO\n \t\t{ \"gxcoff\", XCOFF_DEBUG, 0 },\n@@ -4398,3 +4381,58 @@ debug_undef (lineno, buffer)\n     dwarf2out_undef (lineno, buffer);\n #endif /* DWARF2_DEBUGGING_INFO */\n }\n+\n+/* Record the relative location of the current stack frame at the PC value\n+   indicated by LABEL if specified, or at the beginning of the function\n+   if LABEL is NULL.  RTL is either:\n+\n+   a REG:  The frame is at 0(REG).\n+   a PLUS of a REG and a CONST_INT:  The frame is at CONST(REG).  */\n+\n+void\n+debug_frame (label, rtl)\n+     char *label;\n+     rtx rtl;\n+{\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG)\n+    dwarf2out_def_cfa (label, rtl);\n+#endif\n+}\n+\n+/* Record that REGNO, a callee-saved register, has been saved somewhere.\n+   LABEL is as for debug_frame.  RTL is either:\n+\n+   a REG:  The register is saved in REG.\n+   a CONST_INT:  The register is saved at an offset of CONST\n+     from the frame.  */\n+\n+void\n+debug_reg_save (label, regno, rtl)\n+     char *label;\n+     unsigned regno;\n+     rtx rtl;\n+{\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG)\n+    dwarf2out_reg_save (label, regno, rtl);\n+#endif\n+}\n+\n+/* Record the location of the return address for the current frame.\n+   LABEL is as for debug_frame.  RTL is either:\n+\n+   a REG:  The return address is saved in REG.\n+   a CONST_INT:  The return address is saved at an offset of CONST\n+     from the frame.  */\n+\n+void\n+debug_return_save (label, rtl)\n+     char *label;\n+     rtx rtl;\n+{\n+#ifdef DWARF2_DEBUGGING_INFO\n+  if (write_symbols == DWARF2_DEBUG)\n+    dwarf2out_return_save (label, rtl);\n+#endif\n+}"}, {"sha": "fde0e9daf309ee546b12ec5a5599a0244cc64ddb", "filename": "gcc/tree.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -1268,6 +1268,45 @@ get_identifier (text)\n   return idp;\t\t\t/* <-- return if created */\n }\n \n+/* If an identifier with the name TEXT (a null-terminated string) has\n+   previously been referred to, return that node; otherwise return\n+   NULL_TREE.  */\n+\n+tree\n+maybe_get_identifier (text)\n+     register char *text;\n+{\n+  register int hi;\n+  register int i;\n+  register tree idp;\n+  register int len, hash_len;\n+\n+  /* Compute length of text in len.  */\n+  for (len = 0; text[len]; len++);\n+\n+  /* Decide how much of that length to hash on */\n+  hash_len = len;\n+  if (warn_id_clash && len > id_clash_len)\n+    hash_len = id_clash_len;\n+\n+  /* Compute hash code */\n+  hi = hash_len * 613 + (unsigned) text[0];\n+  for (i = 1; i < hash_len; i += 2)\n+    hi = ((hi * 613) + (unsigned) (text[i]));\n+\n+  hi &= (1 << HASHBITS) - 1;\n+  hi %= MAX_HASH_TABLE;\n+  \n+  /* Search table for identifier */\n+  for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n+    if (IDENTIFIER_LENGTH (idp) == len\n+\t&& IDENTIFIER_POINTER (idp)[0] == text[0]\n+\t&& !bcmp (IDENTIFIER_POINTER (idp), text, len))\n+      return idp;\t\t/* <-- return if found */\n+\n+  return NULL_TREE;\n+}\n+\n /* Enable warnings on similar identifiers (if requested).\n    Done after the built-in identifiers are created.  */\n "}, {"sha": "a8c15df11e81c532074abd8ad4dda630a6f5249f", "filename": "gcc/varasm.c", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a94dbf2c2628c83773a1eb6c9ced1a49a3a5f45e", "patch": "@@ -1174,26 +1174,16 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t\t see comment in compile_file.  */\n \t      && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n \t    sdbout_symbol (decl, 0);\n-#endif\n-#ifdef DWARF_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF_DEBUG && top_level\n-\t      && DECL_CONTEXT (decl))\n-\t    dwarfout_file_scope_decl (decl, 0);\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG && top_level\n-\t      && DECL_CONTEXT (decl))\n-\t    dwarf2out_decl (decl);\n #endif\n \t}\n \n-      /* Only output DWARF debugging information for record-scope variables\n-\t here.  In the case of function-scope variables, the information\n-\t for them is output when we do our recursive traversal of the tree\n-\t representation for the entire containing function.  In the case of\n-\t file-scope variables, we output information for all of them at the\n-\t very end of compilation while we are doing our final traversal of\n-\t the chain of file-scope declarations.  */\n+      /* Don't output any DWARF debugging information for variables here.\n+\t In the case of local variables, the information for them is output\n+\t when we do our recursive traversal of the tree representation for\n+\t the entire containing function.  In the case of file-scope variables,\n+\t we output information for all of them at the very end of compilation\n+\t while we are doing our final traversal of the chain of file-scope\n+\t declarations.  */\n \n       return;\n     }\n@@ -1308,24 +1298,14 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n \t  && (TREE_PUBLIC (decl) == 0 || DECL_INITIAL (decl) == 0))\n \tsdbout_symbol (decl, 0);\n #endif\n-#ifdef DWARF_DEBUGGING_INFO\n-      if (write_symbols == DWARF_DEBUG && top_level\n-\t  && DECL_CONTEXT (decl))\n-\tdwarfout_file_scope_decl (decl, 0);\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-      if (write_symbols == DWARF2_DEBUG && top_level\n-\t  && DECL_CONTEXT (decl))\n-\tdwarf2out_decl (decl);\n-#endif\n \n-      /* Only output DWARF debugging information for record-scope variables\n-\t here.  In the case of function-scope variables, the information\n-\t for them is output when we do our recursive traversal of the tree\n-\t representation for the entire containing function.  In the case of\n-\t file-scope variables, we output information for all of them at the\n-\t very end of compilation while we are doing our final traversal of\n-\t the chain of file-scope declarations.  */\n+      /* Don't output any DWARF debugging information for variables here.\n+\t In the case of local variables, the information for them is output\n+\t when we do our recursive traversal of the tree representation for\n+\t the entire containing function.  In the case of file-scope variables,\n+\t we output information for all of them at the very end of compilation\n+\t while we are doing our final traversal of the chain of file-scope\n+\t declarations.  */\n \n #if 0 /* ??? We should either delete this or add a comment describing what\n \t it was intended to do and why we shouldn't delete it.  */\n@@ -1729,15 +1709,13 @@ assemble_name (file, name)\n      char *name;\n {\n   char *real_name;\n-  int save_warn_id_clash = warn_id_clash;\n+  tree id;\n \n   STRIP_NAME_ENCODING (real_name, name);\n \n-  /* Don't warn about an identifier name length clash on this name, since\n-     it can be a user symbol suffixed by a number.  */\n-  warn_id_clash = 0;\n-  TREE_SYMBOL_REFERENCED (get_identifier (real_name)) = 1;\n-  warn_id_clash = save_warn_id_clash;\n+  id = maybe_get_identifier (real_name);\n+  if (id)\n+    TREE_SYMBOL_REFERENCED (id) = 1;\n \n   if (name[0] == '*')\n     {"}]}