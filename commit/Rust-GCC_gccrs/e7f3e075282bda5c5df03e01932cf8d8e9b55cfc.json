{"sha": "e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmM2UwNzUyODJiZGE1YzVkZjAzZTAxOTMyY2Y4ZDhlOWI1NWNmYw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T22:57:57Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T22:57:57Z"}, "message": "Adjust how variable vector extraction is done.\n\n2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (get_vector_offset): New helper function\n\tto calculate the offset in memory from the start of a vector of a\n\tparticular element.  Add code to keep the element number in\n\tbounds if the element number is variable.\n\t(rs6000_adjust_vec_address): Move calculation of offset of the\n\tvector element to get_vector_offset.\n\t(rs6000_split_vec_extract_var): Do not do the initial AND of\n\telement here, move the code to get_vector_offset.", "tree": {"sha": "0073eea9642e6ef159c21a3d7d3edab8c3651cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0073eea9642e6ef159c21a3d7d3edab8c3651cfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc/comments", "author": null, "committer": null, "parents": [{"sha": "87fbd5347b33883006dc77e779b9edc590fcd2f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87fbd5347b33883006dc77e779b9edc590fcd2f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87fbd5347b33883006dc77e779b9edc590fcd2f0"}], "stats": {"total": 93, "additions": 60, "deletions": 33}, "files": [{"sha": "f1208496ccc377e27d1067605e7dd24b08639ced", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "patch": "@@ -1,3 +1,14 @@\n+2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (get_vector_offset): New helper function\n+\tto calculate the offset in memory from the start of a vector of a\n+\tparticular element.  Add code to keep the element number in\n+\tbounds if the element number is variable.\n+\t(rs6000_adjust_vec_address): Move calculation of offset of the\n+\tvector element to get_vector_offset.\n+\t(rs6000_split_vec_extract_var): Do not do the initial AND of\n+\telement here, move the code to get_vector_offset.\n+\n 2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_adjust_vec_address): Add some"}, {"sha": "e79bff865e070e77f7971b7ed6b348739b60e05d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "patch": "@@ -6750,10 +6750,54 @@ hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n   return addr_mask;\n }\n \n+/* Return the offset within a memory object (MEM) of a vector type to a given\n+   element within the vector (ELEMENT) with an element size (SCALAR_SIZE).  If\n+   the element is constant, we return a constant integer.\n+\n+   Otherwise, we use a base register temporary to calculate the offset after\n+   masking it to fit within the bounds of the vector and scaling it.  The\n+   masking is required by the 64-bit ELF version 2 ABI for the vec_extract\n+   built-in function.  */\n+\n+static rtx\n+get_vector_offset (rtx mem, rtx element, rtx base_tmp, unsigned scalar_size)\n+{\n+  if (CONST_INT_P (element))\n+    return GEN_INT (INTVAL (element) * scalar_size);\n+\n+  /* All insns should use the 'Q' constraint (address is a single register) if\n+     the element number is not a constant.  */\n+  rtx addr = XEXP (mem, 0);\n+  gcc_assert (satisfies_constraint_Q (addr));\n+\n+  /* Mask the element to make sure the element number is between 0 and the\n+     maximum number of elements - 1 so that we don't generate an address\n+     outside the vector.  */\n+  rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (GET_MODE (mem)) - 1);\n+  rtx and_op = gen_rtx_AND (Pmode, element, num_ele_m1);\n+  emit_insn (gen_rtx_SET (base_tmp, and_op));\n+\n+  /* Shift the element to get the byte offset from the element number.  */\n+  int shift = exact_log2 (scalar_size);\n+  gcc_assert (shift >= 0);\n+\n+  if (shift > 0)\n+    {\n+      rtx shift_op = gen_rtx_ASHIFT (Pmode, base_tmp, GEN_INT (shift));\n+      emit_insn (gen_rtx_SET (base_tmp, shift_op));\n+    }\n+\n+  return base_tmp;\n+}\n+\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n-   that is valid for reads or writes to a given register (SCALAR_REG).  */\n+   that is valid for reads or writes to a given register (SCALAR_REG).\n+\n+   This function is expected to be called after reload is completed when we are\n+   splitting insns.  The temporary BASE_TMP might be set multiple times with\n+   this code.  */\n \n rtx\n rs6000_adjust_vec_address (rtx scalar_reg,\n@@ -6764,7 +6808,6 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n {\n   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);\n   rtx addr = XEXP (mem, 0);\n-  rtx element_offset;\n   rtx new_addr;\n   bool valid_addr_p;\n \n@@ -6776,30 +6819,7 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n \n   /* Calculate what we need to add to the address to get the element\n      address.  */\n-  if (CONST_INT_P (element))\n-    element_offset = GEN_INT (INTVAL (element) * scalar_size);\n-  else\n-    {\n-      /* All insns should use the 'Q' constraint (address is a single register)\n-\t if the element number is not a constant.  */\n-      gcc_assert (REG_P (addr) || SUBREG_P (addr));\n-\n-      int byte_shift = exact_log2 (scalar_size);\n-      gcc_assert (byte_shift >= 0);\n-\n-      if (byte_shift == 0)\n-\telement_offset = element;\n-\n-      else\n-\t{\n-\t  if (TARGET_POWERPC64)\n-\t    emit_insn (gen_ashldi3 (base_tmp, element, GEN_INT (byte_shift)));\n-\t  else\n-\t    emit_insn (gen_ashlsi3 (base_tmp, element, GEN_INT (byte_shift)));\n-\n-\t  element_offset = base_tmp;\n-\t}\n-    }\n+  rtx element_offset = get_vector_offset (mem, element, base_tmp, scalar_size);\n \n   /* Create the new address pointing to the element within the vector.  If we\n      are adding 0, we don't have to change the address.  */\n@@ -6935,13 +6955,9 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n      systems.  */\n   if (MEM_P (src))\n     {\n-      int num_elements = GET_MODE_NUNITS (mode);\n-      rtx num_ele_m1 = GEN_INT (num_elements - 1);\n-\n-      emit_insn (gen_anddi3 (element, element, num_ele_m1));\n-      gcc_assert (REG_P (tmp_gpr));\n-      emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,\n-\t\t\t\t\t\t       tmp_gpr, scalar_mode));\n+      emit_move_insn (dest,\n+\t\t      rs6000_adjust_vec_address (dest, src, element, tmp_gpr,\n+\t\t\t\t\t\t scalar_mode));\n       return;\n     }\n "}]}