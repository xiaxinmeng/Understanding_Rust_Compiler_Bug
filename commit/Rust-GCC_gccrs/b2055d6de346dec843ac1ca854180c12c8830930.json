{"sha": "b2055d6de346dec843ac1ca854180c12c8830930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwNTVkNmRlMzQ2ZGVjODQzYWMxY2E4NTQxODBjMTJjODgzMDkzMA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-10T01:05:19Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-10T01:05:19Z"}, "message": "Update to new runtimes.\n\nFrom-SVN: r4076", "tree": {"sha": "b37c8fb1bb56d48efaeff040e8ebfffe66132e77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b37c8fb1bb56d48efaeff040e8ebfffe66132e77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2055d6de346dec843ac1ca854180c12c8830930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2055d6de346dec843ac1ca854180c12c8830930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2055d6de346dec843ac1ca854180c12c8830930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2055d6de346dec843ac1ca854180c12c8830930/comments", "author": null, "committer": null, "parents": [{"sha": "3e676e9922ee91afec02fa7b8f598cce3cdc9f97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e676e9922ee91afec02fa7b8f598cce3cdc9f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e676e9922ee91afec02fa7b8f598cce3cdc9f97"}], "stats": {"total": 494, "additions": 340, "deletions": 154}, "files": [{"sha": "4eb005f4b3afac1c0429b2dbefe5c470b8f72bb6", "filename": "gcc/objc/Makefile.in", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMakefile.in?ref=b2055d6de346dec843ac1ca854180c12c8830930", "patch": "@@ -1,3 +1,23 @@\n+#  GNU Objective C Runtime Makefile\n+#  Copyright (C) 1993 Free Software Foundation, Inc.\n+#\n+#  Author: Kresten Krab Thorup\n+#\n+#  This file is part of GNU CC.\n+#\n+#  GNU CC is free software; you can redistribute it and/or modify it under the\n+#  terms of the GNU General Public License as published by the Free Software\n+#  Foundation; either version 2, or (at your option) any later version.\n+#\n+#  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+#  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+#  details.\n+#\n+#  You should have received a copy of the GNU General Public License along with\n+#  GNU CC; see the file COPYING.  If not, write to the Free Software\n+#  Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+#\n # This makefile is run by the parent dir's makefile.\n # thisdir1=`pwd`; \\\n # srcdir1=`cd $(srcdir); pwd`; \\\n@@ -30,21 +50,48 @@ SUBDIR_INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/config\n all:\n \tcd ..; $(MAKE) sublibobjc.a\n \n-libobjc.a: core.o hash.o object.o\n-\t-rm -f libobjc.a\n-\t$(AR) rc libobjc.a object.o core.o hash.o\n-# ranlib is run in the parent directory's makefile.\n+OBJS = hash.o sarray.o objc-class.o objc-msg.o objc-init.o objc-archive.o \\\n+\tobjc-sel.o objc-object.o objc-misc.o Object.o Protocol.o\n \n-OBJC_H = objc.h objc-proto.h record.h $(srcdir)/assert.h $(srcdir)/gstdarg.h\n-HASH_H = hash.h mutex.h\n+all: libobjc.a\n \n-core.o: core.c $(OBJC_H) $(HASH_H) $(srcdir)/gstddef.h\n-hash.o: hash.c $(OBJC_H) $(HASH_H) $(srcdir)/gstddef.h\n-object.o: object.m object.h $(OBJC_H)\n-\t$(GCC_FOR_TARGET) -c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n+runtime.h: hash.h list.h sarray.h objc.h objc-api.h\n+\n+Object.m: Object.h\n+\n+Object.h: objc.h objc-api.h \n+\n+sarray.c: sarray.h\n+\n+hash.c: hash.h\n+\n+objc-class.c: runtime.h\n+\n+objc-msg.c: runtime.h\n+\n+objc-init.c: runtime.h\n+\n+objc-sel.c: runtime.h\n+\n+objc-object.c: runtime.h\n+\n+objc-class.o: objc-class.c\n+\n+objc-msg.o: objc-msg.c\n+\n+objc-init.o: objc-init.c\n+\n+objc-sel.o: objc-sel.c\n+\n+objc-object.o: objc-object.c\n+\n+libobjc.a: $(OBJS)\n+\t-rm -f libobjc.a\n+\t$(AR) rc libobjc.a $(OBJS)\n+# ranlib is run in the parent directory's makefile.\n \n mostlyclean:\n-\t-rm -f core.o hash.o object.o libobjc.a\n+\t-rm -f $(OBJS) libobjc.a\n clean: mostlyclean\n distclean: mostlyclean\n extraclean: mostlyclean"}, {"sha": "8c0de99a867f1f71d30e22d62bffbd111353a1b0", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=b2055d6de346dec843ac1ca854180c12c8830930", "patch": "@@ -1,5 +1,5 @@\n-/* Hash tables for Objective C method dispatch.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+/* Hash tables for Objective C internal structures\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -23,15 +23,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n-#include \"tconfig.h\"\n-#include \"gstddef.h\"\n-#include \"gstdarg.h\"\n #include \"assert.h\"\n \n-#include \"hash.h\"\n-#include \"objc.h\"\n-#include \"objc-proto.h\"\n+#include <objc/hash.h>\n+#include <objc/objc.h>\n \n+#include \"runtime.h\"\t\t/* for DEBUG_PRINTF */\n \n /* These two macros determine when a hash table is full and\n    by how much it should be expanded respectively."}, {"sha": "00a168f7ec1533d185bca6c6bd4115e7b33aeb04", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=b2055d6de346dec843ac1ca854180c12c8830930", "patch": "@@ -1,5 +1,5 @@\n /* Hash tables for Objective C method dispatch.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "da1407ea96fbaaecae299598b86dbfb9ee60dfcd", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 276, "deletions": 134, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2055d6de346dec843ac1ca854180c12c8830930/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=b2055d6de346dec843ac1ca854180c12c8830930", "patch": "@@ -1,5 +1,5 @@\n /* Basic data types for Objective C.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -22,21 +22,30 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the resulting executable to be covered by the GNU General Public License.\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n- \n \n #ifndef __objc_INCLUDE_GNU\n #define __objc_INCLUDE_GNU\n \n-/* If someone is using a c++ compiler then adjust the types in the\n-   file back to C.  */\n-#ifdef __cplusplus\n-extern \"C\" {\n+\n+/*\n+** Hash-cache or sparse arrays?\n+*/ \n+#define OBJC_SPARSE_LOOKUP \t/* use sparse-arrays for lookup */\n+/* #define OBJC_HASH_LOOKUP */ /* use hash-cache for lookup */\n+\n+#ifdef OBJC_SPARSE_LOOKUP\n+extern const char* __objc_sparse_lookup_id;\n+#endif\n+\n+#ifdef OBJC_HASH_LOOKUP\n+extern const char* __objc_hash_lookup_id;\n #endif\n \n-#include  \"record.h\"\n-\f\n-/* This duplicates the beginning of object.h.\n-   Except that we use Class_t for a pointer, whereas it uses Class.  */\n+\n+#include <stddef.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+\n \n #define nil (id)0                               /* id of Nil instance */\n #define Nil (Class_t)0                          /* id of Nil class */\n@@ -48,21 +57,41 @@ typedef char  BOOL;\n #define NO    (BOOL)0\n \n \n-/* Definition of a selector.  Selectors are really of type char*. The\n-   run-time hashes the string's address to locate the method.  If the\n-   method isn't in the hash table then a search is made through the\n-   class hierarchy using strcmp to locate the method.  */\n-typedef void *SEL;\n+/* For functions which return Method_t */\n+#define METHOD_NULL\t(Method_t)0\n+\n+\n \n-/* ObjC uses this typedef for untyped instances.  */\n+/*\n+** Definition of a selector.  Selectors are really of type unsigned int.\n+** The runtime does this mapping from SEL's to names internally in the\n+** sel_... operations.  You should never use the fact that it is actually\n+** an integer, since other Objective-C implementations use other conventions.\n+*/\n+typedef void* SEL;\n \n+/*\n+** ObjC uses this typedef for untyped instances.\n+*/\n typedef struct objc_object {\n   struct objc_class*  class_pointer;\n } *id;\n \n-/* Prototype for method functions. */\n typedef id (*IMP)(id, SEL, ...); \n-\f\n+\n+/*\n+** Method descriptor returned by introspective Object methods.\n+** This is really just the first part of the more complete objc_method\n+** structure defined below and used internally by the runtime.\n+*/\n+struct objc_method_description\n+{\n+    SEL name;\t\t\t/* this is a selector, not a string */\n+    char *types;\t\t/* type encoding */\n+};\n+\n+\n+\n /* Filer types used to describe Ivars and Methods.  */\n #define _C_ID       '@'\n #define _C_CLASS    '#'\n@@ -82,40 +111,31 @@ typedef id (*IMP)(id, SEL, ...);\n #define _C_UNDEF    '?'\n #define _C_PTR      '^'\n #define _C_CHARPTR  '*'\n+#define _C_ATOM     '%'\n #define _C_ARY_B    '['\n #define _C_ARY_E    ']'\n #define _C_UNION_B  '('\n #define _C_UNION_E  ')'\n #define _C_STRUCT_B '{'\n #define _C_STRUCT_E '}'\n \n-/* These definitions are masks used with the \"info\" member variable in\n-   the lass and meta class structures.  */\n-#define CLS_CLASS         0x1L                  /* The structure is of type\n-                                                  class (Class_t). */\n-#define CLS_META          0x2L                  /* The structure is of type\n-                                                  meta class (MetaClass_t). */\n-#define CLS_INITIALIZED   0x4L                  /* Class is initialized. A\n-                                                  +initialize method is the\n-                                                  first message sent to a\n-                                                  class.  It isn't guaranteed\n-                                                  to be sent only once. */\n-#define CLS_RTI           0x8L                  /* The class has been initialized\n-\t\t\t\t\t\t   within the run time library. */\n-\n-/* Set this variable nonzero to print a line describing each\n-   message that is sent.  */\n+\n+\n+/*\n+** Set this variable nonzero to print a line describing each\n+** message that is sent.\n+*/\n extern BOOL objc_trace;\n \n \n /*\n- * Whereas a Module (defined further down) is the root (typically) of a file,\n- * a Symtab is the root of the class and category definitions within the\n- * module.  \n- *\n- * A Symtab contains a variable length array of pointers to classes and\n- * categories  defined in the module. \n- */\n+** Whereas a Module (defined further down) is the root (typically) of a file,\n+** a Symtab is the root of the class and category definitions within the\n+** module.  \n+** \n+** A Symtab contains a variable length array of pointers to classes and\n+** categories  defined in the module. \n+*/\n typedef struct objc_symtab {\n   unsigned long sel_ref_cnt;                     /* Unknown. */\n   SEL       *refs;                              /* Unknown. */\n@@ -132,14 +152,14 @@ typedef struct objc_symtab {\n \n \n /*\n- * The compiler generates one of these structures for each module that\n- * composes the executable (eg main.m).  \n- *\n- * This data structure is the root of the definition tree for the module.  \n- *\n- * A collect program runs between ld stages and creates a ObjC ctor array. \n- * That array holds a pointer to each module structure of the executable. \n- */\n+** The compiler generates one of these structures for each module that\n+** composes the executable (eg main.m).  \n+** \n+** This data structure is the root of the definition tree for the module.  \n+** \n+** A collect program runs between ld stages and creates a ObjC ctor array. \n+** That array holds a pointer to each module structure of the executable. \n+*/\n typedef struct objc_module {\n   unsigned long version;                        /* Compiler revision. */\n   unsigned long size;                           /* sizeof(Module). */\n@@ -155,9 +175,9 @@ typedef struct objc_module {\n \n \n /*\n- * The compiler generates one of these structures for a class that has\n- * instance variables defined in its specification. \n- */\n+** The compiler generates one of these structures for a class that has\n+** instance variables defined in its specification. \n+*/\n typedef struct objc_ivar* Ivar_t;\n typedef struct objc_ivar_list {\n   int   ivar_count;                             /* Number of structures (Ivar) \n@@ -182,13 +202,13 @@ typedef struct objc_ivar_list {\n \n \n /*\n- * The compiler generates one (or more) of these structures for a class that\n- * has methods defined in its specification. \n- *\n- * The implementation of a class can be broken into separate pieces in a file\n- * and categories can break them across modules. To handle this problem is a\n- * singly linked list of methods. \n- */\n+** The compiler generates one (or more) of these structures for a class that\n+** has methods defined in its specification. \n+** \n+** The implementation of a class can be broken into separate pieces in a file\n+** and categories can break them across modules. To handle this problem is a\n+** singly linked list of methods. \n+*/\n typedef struct objc_method Method;\n typedef Method* Method_t;\n typedef struct objc_method_list {\n@@ -201,7 +221,7 @@ typedef struct objc_method_list {\n     SEL         method_name;                  /* This variable is the method's \n                                                 name.  It is a char*. \n                                                   The unique integer passed to \n-                                                objc_msgSend is a char* too.  \n+                                                objc_msg_send is a char* too.  \n                                                 It is compared against \n                                                 method_name using strcmp. */\n     const char* method_types;                 /* Description of the method's\n@@ -214,47 +234,52 @@ typedef struct objc_method_list {\n } MethodList, *MethodList_t;\n \n \n+#include <objc/sarray.h>\n+\n+#ifdef OBJC_HASH_LOOKUP\n+\n /*\n- * The compiler generates one of these structures for each class.  \n- *\n- * This structure is the definition for meta classes. By definition a meta\n- * class is the class's class.  Its most relevant contribution is that its\n- * method list contain the class's factory methods. \n- *\n- * This structure is generated by the compiler in the executable and used by\n- * the run-time during normal messaging operations.  Therefore some members\n- * change type. The compiler generates \"char* const\" and places a string in\n- * the following member variables:  class_pointer and super_class. \n- */\n-typedef struct objc_metaClass {     \n-  struct objc_metaClass*  class_pointer;      /* Pointer to Object meta class. */\n-  struct objc_metaClass*  super_class;        /* Pointer to meta class's\n-                                                super class. NULL for \n-                                                Object. */\n-  const char*             name;               /* Name of the meta class. */\n-  long                    version;            /* Unknown. */\n-  long                    info;               /* Bit mask.  See class masks \n-                                                defined above. */\n-  long                    instance_size;      /* Always 0 except for Object.\n-                                                Should be ignored. */\n-  IvarList_t              ivars;              /* Always NULL except for \n-                                                Object.  Should be ignored. */\n-  MethodList_t            methods;            /* Linked List of factory methods \n-                                                for the class. */\n-  struct record **        cache;              /* Pointer to factory method dispatch table. */\n-} MetaClass, *MetaClass_t;\n+** This data structure is used for the hash lookup mechanism.  When\n+** enabled, the runtime keeps a such cache of buckets for each class.\n+*/\n+typedef struct objc_cache* Cache_t;\n+typedef struct objc_bucket* Bucket_t;\n+typedef struct objc_bucket Bucket;\n+struct objc_cache {\n+  unsigned int mask;\t\t/* total = mask+1 */\n+  unsigned int occupied;\n+  struct objc_bucket {\n+    SEL method_selector;\n+    IMP method_imp;\n+  } buckets[1];\n+} Cache;\n \n+#endif\n+\n+/*\n+** The compiler generates one of these structures for each class.  \n+**\n+** This structure is the definition for meta classes. By definition a meta\n+** class is the class's class.  Its most relevant contribution is that its\n+** method list contain the class's factory methods. \n+**\n+** This structure is generated by the compiler in the executable and used by\n+** the run-time during normal messaging operations.  Therefore some members\n+** change type. The compiler generates \"char* const\" and places a string in\n+** the following member variables:  class_pointer and super_class. \n+*/\n+typedef struct objc_class *MetaClass_t;\n \n /*\n- * The compiler generates one of these structures for each class.  \n- *\n- * This structure is the definition for classes. \n- *\n- * This structure is generated by the compiler in the executable and used by\n- * the run-time during normal messaging operations.  Therefore some members\n- * change type. The compiler generates \"char* const\" and places a string in\n- * the following member variables:  super_class. \n- */\n+** The compiler generates one of these structures for each class.  \n+** \n+** This structure is the definition for classes. \n+** \n+** This structure is generated by the compiler in the executable and used by\n+** the run-time during normal messaging operations.  Therefore some members\n+** change type. The compiler generates \"char* const\" and places a string in\n+** the following member variables:  super_class. \n+*/\n typedef struct objc_class {     \n   MetaClass_t         class_pointer;          /* Pointer to the class's\n                                                 meta class. */\n@@ -279,14 +304,91 @@ typedef struct objc_class {\n   MethodList_t        methods;                /* Linked list of instance\n                                                 methods defined for the \n                                                 class. */\n-  struct record **    cache;                  /* Pointer to instance method dispatch table. */\n-} Class, *Class_t;\n+#ifdef OBJC_HASH_LOOKUP\n+  Cache_t\t     cache;                   /* Pointer to method cache */\n+#else\n+  struct sarray *    dtable;                  /* Pointer to instance \n+\t\t\t\t\t         method dispatch table. */  \n+#endif\n+\n+  struct objc_class* subclass_list;           /* Subclasses */\n+  struct objc_class* sibling_class;\n+\n+  struct objc_protocol_list *protocols;\t      /* Protocols conformed to */\n+\n+} Class, *Class_t, MetaClass;\n+\n+/* Protocol support */\n+\n+#ifndef __OBJC__\n+typedef struct objc_protocol {\n+  char *protocol_name;\n+  struct objc_protocol_list *protocol_list;\n+  struct objc_method_description_list *instance_methods, *class_methods; \n+} Protocol; \n+\n+#else\n+\n+@class Protocol;\n+#endif \n+\n+struct objc_protocol_list {\n+  struct objc_protocol_list *next;\n+  int count;\n+  Protocol *list[1];\n+};\n+\n \n+/*\n+** This is used to assure consistent access to the info field of \n+** classes\n+*/\n+#ifndef HOST_BITS_PER_LONG\n+#define HOST_BITS_PER_LONG  (sizeof(long)*8)\n+#endif \n+\n+#define __CLS_INFO(cls) ((cls)->info)\n+#define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n+#define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n+\n+/* The structure is of type MetaClass_t */\n+#define _CLS_META 0x2L\n+#define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n+\n+\n+/* The structure is of type Class_t */\n+#define _CLS_CLASS 0x1L\n+#define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n+\n+/*\n+** The class is initialized within the runtime.  This means that \n+** it has had correct super and sublinks assigned\n+*/\n+#define _CLS_RESOLV 0x8L\n+#define CLS_ISRESOLV(cls) __CLS_ISINFO(cls, _CLS_RESOLV)\n+#define CLS_SETRESOLV(cls) __CLS_SETINFO(cls, _CLS_RESOLV)\n+\n+/*\n+** The class has been send a +initialize message or a such is not \n+** defined for this class\n+*/\n+#define _CLS_INITIALIZED 0x04L\n+#define CLS_ISINITIALIZED(cls) __CLS_ISINFO(cls, _CLS_INITIALIZED)\n+#define CLS_SETINITIALIZED(cls) __CLS_SETINFO(cls, _CLS_INITIALIZED)\n \n /*\n- * The compiler generates one of these structures for each category.  A class\n- * may have many categories and contain both instance and factory methods.  \n- */\n+** The class number of this class.  This must be the same for both the \n+** class and it's meta class object\n+*/\n+#define CLS_GETNUMBER(cls) (__CLS_INFO(cls) >> (HOST_BITS_PER_LONG/2))\n+#define CLS_SETNUMBER(cls, num) \\\n+  ({ assert(CLS_GETNUMBER(cls)==0); \\\n+     __CLS_SETINFO(cls, ((num) << (HOST_BITS_PER_LONG/2))); })\n+\n+/*\n+** The compiler generates one of these structures for each category.  A class\n+** may have many categories and contain both instance and factory methods.  \n+*/\n typedef struct objc_category {\n   const char*   category_name;                /* Name of the category.  Name\n                                                 contained in the () of the\n@@ -301,52 +403,92 @@ typedef struct objc_category {\n                                                 methods defined in the\n                                                 category.  NULL indicates no\n                                                 class methods defined. */\n+  struct objc_protocol_list *protocols;\t      /* List of Protocols \n+\t\t\t\t\t         conformed to */\n } Category, *Category_t;\n \n+/*\n+** Well...\n+*/\n+\n+typedef struct objc_typed_stream TypedStream;\n+\n \n /*\n- * Structure used when a message is send to a class's super class.  The\n- * compiler generates one of these structures and passes it to\n- * objc_msgSuper. \n- */\n+** Structure used when a message is send to a class's super class.  The\n+** compiler generates one of these structures and passes it to\n+** objc_msg_super.\n+*/\n typedef struct objc_super {\n-  id      receiver;                           /* Id of the object sending\n+  id      self;                           /* Id of the object sending\n                                                 the message. */\n   Class_t class;                              /* Object's super class. */\n } Super, *Super_t;\n \n-/*\n- * _objc_alloc points to the function, called through class_createInstance,\n- * used to allocate memory for new instances. \n- */\n-extern id (*_objc_alloc)(Class_t);\n-/*\n- * _objc_dealloc points to the function, called through object_dispose, used to\n- * free instances. \n- */\n-extern id (*_objc_dealloc)(id);\n-/*\n- * _objc_realloc points to the function, called through object_realloc, used to\n- * reallocate memory for an object \n- */\n-extern id (*_objc_realloc)(id, unsigned int);\n+IMP objc_msg_lookup_super(Super_t super, SEL sel);\n \n-/*\n- * _objc_copy points to the function, called through object_copy,\n- * used to create an exact copy of an object. \n- */\n-extern  id (*_objc_copy)(id);\n+typedef void* retval_t;\t\t/* return value */\n+typedef void(*apply_t)(void);\t/* function pointer */\n \n-/*\n- * _objc_error points to the function that the run-time system calls\n- * to handle an error.  By default, it prints formatted error messages to the\n- * standard error stream and calls abort to produce a core file. \n- */\n-extern void (*_objc_error)(id object, const char *fmt, va_list ap);\n+#if defined(REG_ARGS) || defined(STACK_ARGS)\n+\n+typedef struct {\n+  char* arg_pointer;\n+#ifdef STRUCT_RETURN\n+  void* struct_return;\n+#endif\n+#ifdef REG_ARGS\n+  void* regs[2];\n+#endif\n+} *arglist_t;\n+\n+#ifdef REG_ARGS\n+#define __objc_frame_receiver(FRAME)  (FRAME)->regs[0]\n+#define __objc_frame_selector(FRAME)  ((SEL)(FRAME)->regs[1])\n+\n+#else\n+#define __objc_frame_receiver(FRAME) ((id*)(FRAME)->arg_pointer)[0]\n+#define __objc_frame_selector(FRAME) ((SEL*)(FRAME)->arg_pointer)[1]\n+#endif\n+#else\n+\n+typedef void* arglist_t;\n+\n+#endif\n+\n+retval_t objc_msg_sendv(id, SEL, size_t, arglist_t);\n+\n+#ifdef __OBJC__\n+\n+static id nil_method(id rcv, SEL op, ...) { return rcv; }\n+\n+#ifdef OBJC_HASH_LOOKUP\n \n+#include <objc/cache.h>\n \n-#ifdef __cplusplus\n+extern __inline__ IMP\n+objc_msg_lookup(id receiver, SEL op)\n+{\n+  if(receiver)\n+    return cache_get(receiver->class_pointer, op);\n+  else\n+    return nil_method;\n }\n+\n+#else /* not OBJC_HASH_LOOKUP => OBJC_SPARSE_LOOKUP */\n+\n+extern __inline__ IMP\n+objc_msg_lookup(id receiver, SEL op)\n+{\n+  if(receiver)\n+    return sarray_get(receiver->class_pointer->dtable, (unsigned int) op);\n+  else\n+    return nil_method;\n+}\n+#endif /* not OBJC_HASH_LOOKUP */\n+\n+#else\n+ IMP objc_msg_lookup(id, SEL);\n #endif\n \n "}]}