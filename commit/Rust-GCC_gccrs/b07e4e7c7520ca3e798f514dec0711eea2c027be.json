{"sha": "b07e4e7c7520ca3e798f514dec0711eea2c027be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3ZTRlN2M3NTIwY2EzZTc5OGY1MTRkZWMwNzExZWVhMmMwMjdiZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-03T10:24:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-03-03T10:24:33Z"}, "message": "sccvn: Improve handling of load masked with integer constant [PR93582]\n\nAs mentioned in the PR and discussed on IRC, the following patch is the\npatch that fixes the originally reported issue.\nWe have there because of the premature bitfield comparison -> BIT_FIELD_REF\noptimization:\n  s$s4_19 = 0;\n  s.s4 = s$s4_19;\n  _10 = BIT_FIELD_REF <s, 8, 0>;\n  _13 = _10 & 8;\nand no other s fields are initialized.  If they would be all initialized with\nconstants, then my earlier PR93582 bitfield handling patches would handle it\nalready, but if at least one bit we ignore after the BIT_AND_EXPR masking\nis not initialized or is initialized earlier to non-constant, we aren't able\nto look through it until combine, which is too late for the warnings on the\ndead code.\nThis patch handles BIT_AND_EXPR where the first operand is a SSA_NAME\ninitialized with a memory load and second operand is INTEGER_CST, by trying\na partial def lookup after pushing the ranges of 0 bits in the mask as\nartificial initializers.  In the above case on little-endian, we push\noffset 0 size 3 {} partial def and offset 4 size 4 (the result is unsigned\nchar) and then perform normal partial def handling.\nMy initial version of the patch failed miserably during bootstrap, because\ndata->finish (...) called vn_reference_lookup_or_insert_for_pieces\nwhich I believe tried to remember the masked value rather than real for the\nreference, or for failed lookup visit_reference_op_load called\nvn_reference_insert.  The following version makes sure we aren't calling\neither of those functions in the masked case, as we don't know anything\nbetter about the reference from whatever has been discovered when the load\nstmt has been visited, the patch just calls vn_nary_op_insert_stmt on\nfailure with the lhs (apparently calling it with the INTEGER_CST doesn't\nwork).\n\n2020-03-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/93582\n\t* tree-ssa-sccvn.h (vn_reference_lookup): Add mask argument.\n\t* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add mask and masked_result\n\tmembers, initialize them in the constructor and if mask is non-NULL,\n\tartificially push_partial_def {} for the portions of the mask that\n\tcontain zeros.\n\t(vn_walk_cb_data::finish): If mask is non-NULL, set masked_result to\n\tval and return (void *)-1.  Formatting fix.\n\t(vn_reference_lookup_pieces): Adjust vn_walk_cb_data initialization.\n\tFormatting fix.\n\t(vn_reference_lookup): Add mask argument.  If non-NULL, don't call\n\tfully_constant_vn_reference_p nor vn_reference_lookup_1 and return\n\tdata.mask_result.\n\t(visit_nary_op): Handle BIT_AND_EXPR of a memory load and INTEGER_CST\n\tmask.\n\t(visit_stmt): Formatting fix.\n\n\t* gcc.dg/tree-ssa/pr93582-10.c: New test.\n\t* gcc.dg/pr93582.c: New test.\n\t* gcc.c-torture/execute/pr93582.c: New test.", "tree": {"sha": "a5d64750934541bcffea6ff2ac9382921ef0089e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5d64750934541bcffea6ff2ac9382921ef0089e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b07e4e7c7520ca3e798f514dec0711eea2c027be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07e4e7c7520ca3e798f514dec0711eea2c027be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b07e4e7c7520ca3e798f514dec0711eea2c027be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07e4e7c7520ca3e798f514dec0711eea2c027be/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6fd7ce6dc4b6baa11920387d62dc001980aa70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6fd7ce6dc4b6baa11920387d62dc001980aa70"}], "stats": {"total": 304, "additions": 264, "deletions": 40}, "files": [{"sha": "2023cd3c871f84cd6f179993cadb8244de8a384d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -1,3 +1,22 @@\n+2020-03-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93582\n+\t* tree-ssa-sccvn.h (vn_reference_lookup): Add mask argument.\n+\t* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add mask and masked_result\n+\tmembers, initialize them in the constructor and if mask is non-NULL,\n+\tartificially push_partial_def {} for the portions of the mask that\n+\tcontain zeros.\n+\t(vn_walk_cb_data::finish): If mask is non-NULL, set masked_result to\n+\tval and return (void *)-1.  Formatting fix.\n+\t(vn_reference_lookup_pieces): Adjust vn_walk_cb_data initialization.\n+\tFormatting fix.\n+\t(vn_reference_lookup): Add mask argument.  If non-NULL, don't call\n+\tfully_constant_vn_reference_p nor vn_reference_lookup_1 and return\n+\tdata.mask_result.\n+\t(visit_nary_op): Handle BIT_AND_EXPR of a memory load and INTEGER_CST\n+\tmask.\n+\t(visit_stmt): Formatting fix.\n+\n 2020-03-03  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/93946"}, {"sha": "7c4c852ad5d6ac0f2b1cc7200f88c7400314a41a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -1,3 +1,10 @@\n+2020-03-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/93582\n+\t* gcc.dg/tree-ssa/pr93582-10.c: New test.\n+\t* gcc.dg/pr93582.c: New test.\n+\t* gcc.c-torture/execute/pr93582.c: New test.\n+\n 2020-03-03  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/93946"}, {"sha": "54f5897383226737010a8a99dc52162e3dbf05ac", "filename": "gcc/testsuite/gcc.c-torture/execute/pr93582.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93582.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93582.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr93582.c?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -0,0 +1,22 @@\n+/* PR tree-optimization/93582 */\n+\n+short a;\n+int b, c;\n+\n+__attribute__((noipa)) void\n+foo (void)\n+{\n+  b = c;\n+  a &= 7;\n+}\n+\n+int\n+main ()\n+{\n+  c = 27;\n+  a = 14;\n+  foo ();\n+  if (b != 27 || a != 6)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "38bf012d0cf669774f61e02059363293e1e05cdc", "filename": "gcc/testsuite/gcc.dg/pr93582.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93582.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93582.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr93582.c?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -0,0 +1,57 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+\n+struct S {\n+  unsigned int s1:1;\n+  unsigned int s2:1;\n+  unsigned int s3:1;\n+  unsigned int s4:1;\n+  unsigned int s5:4;\n+  unsigned char s6;\n+  unsigned short s7;\n+  unsigned short s8;\n+};\n+struct T {\n+  int t1;\n+  int t2;\n+};\n+\n+static inline int\n+bar (struct S *x)\n+{\n+  if (x->s4)\n+    return ((struct T *)(x + 1))->t1 + ((struct T *)(x + 1))->t2;\t/* { dg-bogus \"array subscript 1 is outside array bounds of\" } */\n+  else\n+    return 0;\n+}\n+\n+int\n+foo (int x, int y)\n+{\n+  struct S s;\t\t\t\t\t\t\t\t/* { dg-bogus \"while referencing\" } */\n+  s.s6 = x;\n+  s.s7 = y & 0x1FFF;\n+  s.s4 = 0;\n+  return bar (&s);\n+}\n+\n+static inline int\n+qux (struct S *x)\n+{\n+  int s4 = x->s4;\n+  if (s4)\n+    return ((struct T *)(x + 1))->t1 + ((struct T *)(x + 1))->t2;\n+  else\n+    return 0;\n+}\n+\n+int\n+baz (int x, int y)\n+{\n+  struct S s;\n+  s.s6 = x;\n+  s.s7 = y & 0x1FFF;\n+  s.s4 = 0;\n+  return qux (&s);\n+}"}, {"sha": "43b52bc522a7b45fa71e876cb1ca9c472f455e18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93582-10.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93582-10.c?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -0,0 +1,29 @@\n+/* PR tree-optimization/93582 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-final { scan-tree-dump \"return 72876566;\" \"fre1\" { target le } } } */\n+/* { dg-final { scan-tree-dump \"return 559957376;\" \"fre1\" { target be } } } */\n+\n+union U {\n+  struct S { int a : 12, b : 5, c : 10, d : 5; } s;\n+  unsigned int i;\n+};\n+struct A { char a[12]; union U u; };\n+void bar (struct A *);\n+\n+unsigned\n+foo (void)\n+{\n+  struct A a;\n+  bar (&a);\n+  a.u.s.a = 1590;\n+  a.u.s.c = -404;\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+#define M 0x67e0a5f\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+#define M 0xa5f067e0\n+#else\n+#define M 0\n+#endif\n+  return a.u.i & M;\n+}"}, {"sha": "9853e9fedaea7be768f1ca9226badadb670152ee", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 129, "deletions": 39, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -1682,16 +1682,55 @@ struct pd_data\n struct vn_walk_cb_data\n {\n   vn_walk_cb_data (vn_reference_t vr_, tree orig_ref_, tree *last_vuse_ptr_,\n-\t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_)\n+\t\t   vn_lookup_kind vn_walk_kind_, bool tbaa_p_, tree mask_)\n     : vr (vr_), last_vuse_ptr (last_vuse_ptr_), last_vuse (NULL_TREE),\n-      vn_walk_kind (vn_walk_kind_), tbaa_p (tbaa_p_),\n-      saved_operands (vNULL), first_set (-2), first_base_set (-2),\n-      known_ranges (NULL)\n-   {\n-     if (!last_vuse_ptr)\n-       last_vuse_ptr = &last_vuse;\n-     ao_ref_init (&orig_ref, orig_ref_);\n-   }\n+      mask (mask_), masked_result (NULL_TREE), vn_walk_kind (vn_walk_kind_),\n+      tbaa_p (tbaa_p_), saved_operands (vNULL), first_set (-2),\n+      first_base_set (-2), known_ranges (NULL)\n+  {\n+    if (!last_vuse_ptr)\n+      last_vuse_ptr = &last_vuse;\n+    ao_ref_init (&orig_ref, orig_ref_);\n+    if (mask)\n+      {\n+\twide_int w = wi::to_wide (mask);\n+\tunsigned int pos = 0, prec = w.get_precision ();\n+\tpd_data pd;\n+\tpd.rhs = build_constructor (NULL_TREE, NULL);\n+\t/* When bitwise and with a constant is done on a memory load,\n+\t   we don't really need all the bits to be defined or defined\n+\t   to constants, we don't really care what is in the position\n+\t   corresponding to 0 bits in the mask.\n+\t   So, push the ranges of those 0 bits in the mask as artificial\n+\t   zero stores and let the partial def handling code do the\n+\t   rest.  */\n+\twhile (pos < prec)\n+\t  {\n+\t    int tz = wi::ctz (w);\n+\t    if (pos + tz > prec)\n+\t      tz = prec - pos;\n+\t    if (tz)\n+\t      {\n+\t\tif (BYTES_BIG_ENDIAN)\n+\t\t  pd.offset = prec - pos - tz;\n+\t\telse\n+\t\t  pd.offset = pos;\n+\t\tpd.size = tz;\n+\t\tvoid *r = push_partial_def (pd, 0, 0, prec);\n+\t\tgcc_assert (r == NULL_TREE);\n+\t      }\n+\t    pos += tz;\n+\t    if (pos == prec)\n+\t      break;\n+\t    w = wi::lrshift (w, tz);\n+\t    tz = wi::ctz (wi::bit_not (w));\n+\t    if (pos + tz > prec)\n+\t      tz = prec - pos;\n+\t    pos += tz;\n+\t    w = wi::lrshift (w, tz);\n+\t  }\n+      }\n+  }\n   ~vn_walk_cb_data ();\n   void *finish (alias_set_type, alias_set_type, tree);\n   void *push_partial_def (const pd_data& pd,\n@@ -1701,6 +1740,8 @@ struct vn_walk_cb_data\n   ao_ref orig_ref;\n   tree *last_vuse_ptr;\n   tree last_vuse;\n+  tree mask;\n+  tree masked_result;\n   vn_lookup_kind vn_walk_kind;\n   bool tbaa_p;\n   vec<vn_reference_op_s> saved_operands;\n@@ -1733,9 +1774,15 @@ vn_walk_cb_data::finish (alias_set_type set, alias_set_type base_set, tree val)\n       set = first_set;\n       base_set = first_base_set;\n     }\n-  return vn_reference_lookup_or_insert_for_pieces\n-      (last_vuse, set, base_set, vr->type,\n-       saved_operands.exists () ? saved_operands : vr->operands, val);\n+  if (mask)\n+    {\n+      masked_result = val;\n+      return (void *) -1;\n+    }\n+  vec<vn_reference_op_s> &operands\n+    = saved_operands.exists () ? saved_operands : vr->operands;\n+  return vn_reference_lookup_or_insert_for_pieces (last_vuse, set, base_set,\n+\t\t\t\t\t\t   vr->type, operands, val);\n }\n \n /* pd_range splay-tree helpers.  */\n@@ -3382,13 +3429,14 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n     {\n       ao_ref r;\n       unsigned limit = param_sccvn_max_alias_queries_per_access;\n-      vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true);\n-      if (ao_ref_init_from_vn_reference (&r, set, base_set, type, vr1.operands))\n-\t*vnresult =\n-\t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, true,\n-\t\t\t\t\t\t  vn_reference_lookup_2,\n-\t\t\t\t\t\t  vn_reference_lookup_3,\n-\t\t\t\t\t\t  vuse_valueize, limit, &data);\n+      vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true, NULL_TREE);\n+      if (ao_ref_init_from_vn_reference (&r, set, base_set, type,\n+\t\t\t\t\t vr1.operands))\n+\t*vnresult\n+\t  = ((vn_reference_t)\n+\t     walk_non_aliased_vuses (&r, vr1.vuse, true, vn_reference_lookup_2,\n+\t\t\t\t     vn_reference_lookup_3, vuse_valueize,\n+\t\t\t\t     limit, &data));\n       gcc_checking_assert (vr1.operands == shared_lookup_references);\n     }\n \n@@ -3404,15 +3452,19 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set,\n    was NULL..  VNRESULT will be filled in with the vn_reference_t\n    stored in the hashtable if one exists.  When TBAA_P is false assume\n    we are looking up a store and treat it as having alias-set zero.\n-   *LAST_VUSE_PTR will be updated with the VUSE the value lookup succeeded.  */\n+   *LAST_VUSE_PTR will be updated with the VUSE the value lookup succeeded.\n+   MASK is either NULL_TREE, or can be an INTEGER_CST if the result of the\n+   load is bitwise anded with MASK and so we are only interested in a subset\n+   of the bits and can ignore if the other bits are uninitialized or\n+   not initialized with constants.  */\n \n tree\n vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n-\t\t     vn_reference_t *vnresult, bool tbaa_p, tree *last_vuse_ptr)\n+\t\t     vn_reference_t *vnresult, bool tbaa_p,\n+\t\t     tree *last_vuse_ptr, tree mask)\n {\n   vec<vn_reference_op_s> operands;\n   struct vn_reference_s vr1;\n-  tree cst;\n   bool valuezied_anything;\n \n   if (vnresult)\n@@ -3427,11 +3479,11 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n   vr1.set = ao_ref_alias_set (&op_ref);\n   vr1.base_set = ao_ref_base_alias_set (&op_ref);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n-  if ((cst = fully_constant_vn_reference_p (&vr1)))\n-    return cst;\n+  if (mask == NULL_TREE)\n+    if (tree cst = fully_constant_vn_reference_p (&vr1))\n+      return cst;\n \n-  if (kind != VN_NOWALK\n-      && vr1.vuse)\n+  if (kind != VN_NOWALK && vr1.vuse)\n     {\n       vn_reference_t wvnresult;\n       ao_ref r;\n@@ -3443,25 +3495,31 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n \t\t\t\t\t     vr1.type, vr1.operands))\n \tao_ref_init (&r, op);\n       vn_walk_cb_data data (&vr1, r.ref ? NULL_TREE : op,\n-\t\t\t    last_vuse_ptr, kind, tbaa_p);\n-      wvnresult =\n-\t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, tbaa_p,\n-\t\t\t\t\t\tvn_reference_lookup_2,\n-\t\t\t\t\t\tvn_reference_lookup_3,\n-\t\t\t\t\t\tvuse_valueize, limit, &data);\n+\t\t\t    last_vuse_ptr, kind, tbaa_p, mask);\n+\n+      wvnresult\n+\t= ((vn_reference_t)\n+\t   walk_non_aliased_vuses (&r, vr1.vuse, tbaa_p, vn_reference_lookup_2,\n+\t\t\t\t   vn_reference_lookup_3, vuse_valueize, limit,\n+\t\t\t\t   &data));\n       gcc_checking_assert (vr1.operands == shared_lookup_references);\n       if (wvnresult)\n \t{\n+\t  gcc_assert (mask == NULL_TREE);\n \t  if (vnresult)\n \t    *vnresult = wvnresult;\n \t  return wvnresult->result;\n \t}\n+      else if (mask)\n+\treturn data.masked_result;\n \n       return NULL_TREE;\n     }\n \n   if (last_vuse_ptr)\n     *last_vuse_ptr = vr1.vuse;\n+  if (mask)\n+    return NULL_TREE;\n   return vn_reference_lookup_1 (&vr1, vnresult);\n }\n \n@@ -4675,7 +4733,39 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t}\n \t    }\n \t}\n-    default:;\n+      break;\n+    case BIT_AND_EXPR:\n+      if (INTEGRAL_TYPE_P (type)\n+\t  && TREE_CODE (rhs1) == SSA_NAME\n+\t  && TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST\n+\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs1)\n+\t  && default_vn_walk_kind != VN_NOWALK\n+\t  && CHAR_BIT == 8\n+\t  && BITS_PER_UNIT == 8\n+\t  && BYTES_BIG_ENDIAN == WORDS_BIG_ENDIAN\n+\t  && !integer_all_onesp (gimple_assign_rhs2 (stmt))\n+\t  && !integer_zerop (gimple_assign_rhs2 (stmt)))\n+\t{\n+\t  gassign *ass = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (rhs1));\n+\t  if (ass\n+\t      && !gimple_has_volatile_ops (ass)\n+\t      && vn_get_stmt_kind (ass) == VN_REFERENCE)\n+\t    {\n+\t      tree last_vuse = gimple_vuse (ass);\n+\t      tree op = gimple_assign_rhs1 (ass);\n+\t      tree result = vn_reference_lookup (op, gimple_vuse (ass),\n+\t\t\t\t\t\t default_vn_walk_kind,\n+\t\t\t\t\t\t NULL, true, &last_vuse,\n+\t\t\t\t\t\t gimple_assign_rhs2 (stmt));\n+\t      if (result\n+\t\t  && useless_type_conversion_p (TREE_TYPE (result),\n+\t\t\t\t\t\tTREE_TYPE (op)))\n+\t\treturn set_ssa_val_to (lhs, result);\n+\t    }\n+\t}\n+      break;\n+    default:\n+      break;\n     }\n \n   bool changed = set_ssa_val_to (lhs, lhs);\n@@ -5192,14 +5282,14 @@ visit_stmt (gimple *stmt, bool backedges_varying_p = false)\n \t      switch (vn_get_stmt_kind (ass))\n \t\t{\n \t\tcase VN_NARY:\n-\t\tchanged = visit_nary_op (lhs, ass);\n-\t\tbreak;\n+\t\t  changed = visit_nary_op (lhs, ass);\n+\t\t  break;\n \t\tcase VN_REFERENCE:\n-\t\tchanged = visit_reference_op_load (lhs, rhs1, ass);\n-\t\tbreak;\n+\t\t  changed = visit_reference_op_load (lhs, rhs1, ass);\n+\t\t  break;\n \t\tdefault:\n-\t\tchanged = defs_to_varying (ass);\n-\t\tbreak;\n+\t\t  changed = defs_to_varying (ass);\n+\t\t  break;\n \t\t}\n \t    }\n \t}"}, {"sha": "d68e7c0ffa314b754e18b818d72c28bf7d518dbe", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07e4e7c7520ca3e798f514dec0711eea2c027be/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=b07e4e7c7520ca3e798f514dec0711eea2c027be", "patch": "@@ -257,7 +257,7 @@ tree vn_reference_lookup_pieces (tree, alias_set_type, alias_set_type, tree,\n \t\t\t\t vec<vn_reference_op_s> ,\n \t\t\t\t vn_reference_t *, vn_lookup_kind);\n tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool,\n-\t\t\t  tree * = NULL);\n+\t\t\t  tree * = NULL, tree = NULL_TREE);\n void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);\n vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, alias_set_type,\n \t\t\t\t\t   tree, vec<vn_reference_op_s>,"}]}