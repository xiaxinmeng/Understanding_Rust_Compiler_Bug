{"sha": "ad7715f324194274f98b65b631f38750c94be717", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ3NzE1ZjMyNDE5NDI3NGY5OGI2NWI2MzFmMzg3NTBjOTRiZTcxNw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-09-30T15:48:51Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-09-30T15:48:51Z"}, "message": "Use 64bit integer for LTO symbol ID.\n\ngcc/lto\n\n2011-09-30  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Andi Kleen  <ak@linux.intel.com>\n\n\tPR lto/50568\n\t* lto.c (lto_splay_tree_delete_id): New.\n\t(lto_splay_tree_compare_ids): Likewise.\n\t(lto_splay_tree_lookup): Likewise.\n\t(lto_splay_tree_id_equal_p): Likewise.\n\t(lto_splay_tree_insert): Likewise.\n\t(lto_splay_tree_new): Likewise.\n\t(lto_resolution_read): Change id to unsigned HOST_WIDE_INT.\n\tUse lto_splay_tree_id_equal_p and lto_splay_tree_lookup.\n\t(create_subid_section_table): Use lto_splay_tree_lookup and\n\tlto_splay_tree_insert.\n\t(lto_file_read): Use lto_splay_tree_new.\n\nlto-plugin/\n\n2011-09-30  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Andi Kleen  <ak@linux.intel.com>\n\n\tPR lto/50568\n\t* lto-plugin.c (sym_aux): Change id to unsigned long long.\n\t(plugin_symtab): Likewise.\n\t(dump_symtab): Likewise.\n\t(resolve_conflicts): Likewise.\n\t(process_symtab): Likewise.\n\nCo-Authored-By: Andi Kleen <ak@linux.intel.com>\n\nFrom-SVN: r179395", "tree": {"sha": "b1c7697f32847eac92ce0179e818e846546c227b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1c7697f32847eac92ce0179e818e846546c227b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad7715f324194274f98b65b631f38750c94be717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7715f324194274f98b65b631f38750c94be717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7715f324194274f98b65b631f38750c94be717", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7715f324194274f98b65b631f38750c94be717/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11e69edcdc7031f74bf09d582851caf909a4a198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e69edcdc7031f74bf09d582851caf909a4a198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e69edcdc7031f74bf09d582851caf909a4a198"}], "stats": {"total": 124, "additions": 110, "deletions": 14}, "files": [{"sha": "6ca8f5b7b1def9b05d3ab88282890023aa271c03", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7715f324194274f98b65b631f38750c94be717/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7715f324194274f98b65b631f38750c94be717/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ad7715f324194274f98b65b631f38750c94be717", "patch": "@@ -1,3 +1,19 @@\n+2011-09-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR lto/50568\n+\t* lto.c (lto_splay_tree_delete_id): New.\n+\t(lto_splay_tree_compare_ids): Likewise.\n+\t(lto_splay_tree_lookup): Likewise.\n+\t(lto_splay_tree_id_equal_p): Likewise.\n+\t(lto_splay_tree_insert): Likewise.\n+\t(lto_splay_tree_new): Likewise.\n+\t(lto_resolution_read): Change id to unsigned HOST_WIDE_INT.\n+\tUse lto_splay_tree_id_equal_p and lto_splay_tree_lookup.\n+\t(create_subid_section_table): Use lto_splay_tree_lookup and\n+\tlto_splay_tree_insert.\n+\t(lto_file_read): Use lto_splay_tree_new.\n+\n 2011-09-26   Andi Kleen <ak@linux.intel.com>\n \n \t* lto.c (lto_resolution_read): Remove id dumping."}, {"sha": "778e33eee01c16c4945c5c11bf0a1a290bf219a7", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 76, "deletions": 8, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7715f324194274f98b65b631f38750c94be717/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7715f324194274f98b65b631f38750c94be717/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=ad7715f324194274f98b65b631f38750c94be717", "patch": "@@ -93,6 +93,71 @@ lto_obj_create_section_hash_table (void)\n   return htab_create (37, hash_name, eq_name, free_with_string);\n }\n \n+/* Delete an allocated integer KEY in the splay tree.  */\n+\n+static void\n+lto_splay_tree_delete_id (splay_tree_key key)\n+{\n+  free ((void *) key);\n+}\n+\n+/* Compare splay tree node ids A and B.  */\n+\n+static int\n+lto_splay_tree_compare_ids (splay_tree_key a, splay_tree_key b)\n+{\n+  unsigned HOST_WIDE_INT ai;\n+  unsigned HOST_WIDE_INT bi;\n+\n+  ai = *(unsigned HOST_WIDE_INT *) a;\n+  bi = *(unsigned HOST_WIDE_INT *) b;\n+\n+  if (ai < bi)\n+    return -1;\n+  else if (ai > bi)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Look up splay tree node by ID in splay tree T.  */\n+\n+static splay_tree_node\n+lto_splay_tree_lookup (splay_tree t, unsigned HOST_WIDE_INT id)\n+{\n+  return splay_tree_lookup (t, (splay_tree_key) &id);\n+}\n+\n+/* Check if KEY has ID.  */\n+\n+static bool\n+lto_splay_tree_id_equal_p (splay_tree_key key, unsigned HOST_WIDE_INT id)\n+{\n+  return *(unsigned HOST_WIDE_INT *) key == id;\n+}\n+\n+/* Insert a splay tree node into tree T with ID as key and FILE_DATA as value. \n+   The ID is allocated separately because we need HOST_WIDE_INTs which may\n+   be wider than a splay_tree_key. */\n+\n+static void\n+lto_splay_tree_insert (splay_tree t, unsigned HOST_WIDE_INT id,\n+\t\t       struct lto_file_decl_data *file_data)\n+{\n+  unsigned HOST_WIDE_INT *idp = XCNEW (unsigned HOST_WIDE_INT);\n+  *idp = id;\n+  splay_tree_insert (t, (splay_tree_key) idp, (splay_tree_value) file_data);\n+}\n+\n+/* Create a splay tree.  */\n+\n+static splay_tree\n+lto_splay_tree_new (void)\n+{\n+  return splay_tree_new (lto_splay_tree_compare_ids,\n+\t \t         lto_splay_tree_delete_id,\n+\t\t\t NULL);\n+}\n+\n /* Read the constructors and inits.  */\n \n static void\n@@ -944,14 +1009,16 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n   for (i = 0; i < num_symbols; i++)\n     {\n       int t;\n-      unsigned index, id;\n+      unsigned index;\n+      unsigned HOST_WIDE_INT id;\n       char r_str[27];\n       enum ld_plugin_symbol_resolution r = (enum ld_plugin_symbol_resolution) 0;\n       unsigned int j;\n       unsigned int lto_resolution_str_len =\n \tsizeof (lto_resolution_str) / sizeof (char *);\n \n-      t = fscanf (resolution, \"%u %x %26s %*[^\\n]\\n\", &index, &id, r_str);\n+      t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE \" %26s %*[^\\n]\\n\", \n+\t\t  &index, &id, r_str);\n       if (t != 3)\n         internal_error (\"invalid line in the resolution file\");\n       if (index > max_index)\n@@ -968,11 +1035,12 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n       if (j == lto_resolution_str_len)\n \tinternal_error (\"invalid resolution in the resolution file\");\n \n-      if (!(nd && nd->key == id))\n+      if (!(nd && lto_splay_tree_id_equal_p (nd->key, id)))\n \t{\n-\t  nd = splay_tree_lookup (file_ids, id);\n+\t  nd = lto_splay_tree_lookup (file_ids, id);\n \t  if (nd == NULL)\n-\t    internal_error (\"resolution sub id %x not in object file\", id);\n+\t    internal_error (\"resolution sub id \" HOST_WIDE_INT_PRINT_HEX_PURE\n+\t\t\t    \" not in object file\", id);\n \t}\n \n       file_data = (struct lto_file_decl_data *)nd->value;\n@@ -1015,7 +1083,7 @@ create_subid_section_table (void **slot, void *data)\n     return 1;\n   \n   /* Find hash table of sub module id */\n-  nd = splay_tree_lookup (file_ids, id);\n+  nd = lto_splay_tree_lookup (file_ids, id);\n   if (nd != NULL)\n     {\n       file_data = (struct lto_file_decl_data *)nd->value;\n@@ -1026,7 +1094,7 @@ create_subid_section_table (void **slot, void *data)\n       memset(file_data, 0, sizeof (struct lto_file_decl_data));\n       file_data->id = id;\n       file_data->section_hash_table = lto_obj_create_section_hash_table ();;\n-      splay_tree_insert (file_ids, id, (splay_tree_value)file_data);\n+      lto_splay_tree_insert (file_ids, id, file_data);\n     }\n \n   /* Copy section into sub module hash table */\n@@ -1104,7 +1172,7 @@ lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n \n   /* Find all sub modules in the object and put their sections into new hash\n      tables in a splay tree. */\n-  file_ids = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n+  file_ids = lto_splay_tree_new ();\n   htab_traverse (section_hash_table, create_subid_section_table, file_ids);\n   \n   /* Add resolutions to file ids */"}, {"sha": "7b0f3bc8b274a7bcabf41bf9d0fbf1b761493e77", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7715f324194274f98b65b631f38750c94be717/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7715f324194274f98b65b631f38750c94be717/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=ad7715f324194274f98b65b631f38750c94be717", "patch": "@@ -1,3 +1,13 @@\n+2011-09-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Andi Kleen  <ak@linux.intel.com>\n+\n+\tPR lto/50568\n+\t* lto-plugin.c (sym_aux): Change id to unsigned long long.\n+\t(plugin_symtab): Likewise.\n+\t(dump_symtab): Likewise.\n+\t(resolve_conflicts): Likewise.\n+\t(process_symtab): Likewise.\n+\n 2011-08-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR bootstrap/49907"}, {"sha": "9323bd201ed30486c7b68538045fc240450ddb8f", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7715f324194274f98b65b631f38750c94be717/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7715f324194274f98b65b631f38750c94be717/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=ad7715f324194274f98b65b631f38750c94be717", "patch": "@@ -80,12 +80,13 @@ along with this program; see the file COPYING3.  If not see\n \n /* The part of the symbol table the plugin has to keep track of. Note that we\n    must keep SYMS until all_symbols_read is called to give the linker time to\n-   copy the symbol information. */\n+   copy the symbol information. \n+   The id must be 64bit to minimze collisions. */\n \n struct sym_aux\n {\n   uint32_t slot;\n-  unsigned id;\n+  unsigned long long id;\n   unsigned next_conflict;\n };\n \n@@ -94,7 +95,7 @@ struct plugin_symtab\n   int nsyms;\n   struct sym_aux *aux;\n   struct ld_plugin_symbol *syms;\n-  unsigned id;\n+  unsigned long long id;\n };\n \n /* Encapsulates object file data during symbol scan.  */\n@@ -359,7 +360,8 @@ dump_symtab (FILE *f, struct plugin_symtab *symtab)\n       \n       assert (resolution != LDPR_UNKNOWN);\n \n-      fprintf (f, \"%u %x %s %s\\n\", (unsigned int) slot, symtab->aux[j].id,\n+      fprintf (f, \"%u %llx %s %s\\n\",\n+               (unsigned int) slot, symtab->aux[j].id,\n \t       lto_resolution_str[resolution], \n \t       symtab->syms[j].name);\n     }\n@@ -759,7 +761,7 @@ resolve_conflicts (struct plugin_symtab *t, struct plugin_symtab *conflicts)\n \t    {\n \t      SWAP (struct ld_plugin_symbol, *orig, *s);\n \t      SWAP (uint32_t, orig_aux->slot, aux->slot);\n-\t      SWAP (unsigned, orig_aux->id, aux->id);\n+\t      SWAP (unsigned long long, orig_aux->id, aux->id);\n \t      /* Don't swap conflict chain pointer */\n \t    } \n \n@@ -809,7 +811,7 @@ process_symtab (void *data, const char *name, off_t offset, off_t length)\n \n   s = strrchr (name, '.');\n   if (s)\n-    sscanf (s, \".%x\", &obj->out->id);\n+    sscanf (s, \".%llx\", &obj->out->id);\n   secdata = xmalloc (length);\n   offset += obj->file->offset;\n   if (offset != lseek (obj->file->fd, offset, SEEK_SET)"}]}