{"sha": "71af73bb7f9d65a10c37ab6368e880b3b1774889", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhZjczYmI3ZjlkNjVhMTBjMzdhYjYzNjhlODgwYjNiMTc3NDg4OQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-02-06T02:37:27Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-02-06T02:37:27Z"}, "message": "(mul_cost, div_cost): New variables.\n\n(mul_widen_cost, mul_highpart_cost): New variables.\n(init_expmed): Init new variables.\n(expand_mult_highpart): New argument, MAX_COST.\nUse new argument in several places.  Simplify code that tries\nwidening multiply variants.\n(expand_divmod): New variables MAX_COST, EXTRA_COST.\nInitialize MAX_COST dependent on REM_FLAG.\nCalculate and pass cost in all calls of expand_mult_highpart.\n\nFrom-SVN: r8868", "tree": {"sha": "463bc1173c25e3f3ea283870fc7b8a14d731f758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/463bc1173c25e3f3ea283870fc7b8a14d731f758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71af73bb7f9d65a10c37ab6368e880b3b1774889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71af73bb7f9d65a10c37ab6368e880b3b1774889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71af73bb7f9d65a10c37ab6368e880b3b1774889", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71af73bb7f9d65a10c37ab6368e880b3b1774889/comments", "author": null, "committer": null, "parents": [{"sha": "6697c6bf7f30841df630ede04050e1c9e2383ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6697c6bf7f30841df630ede04050e1c9e2383ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6697c6bf7f30841df630ede04050e1c9e2383ed9"}], "stats": {"total": 163, "additions": 113, "deletions": 50}, "files": [{"sha": "7ba833bb808066542e264e49d99de2590e0202b1", "filename": "gcc/expmed.c", "status": "modified", "additions": 113, "deletions": 50, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71af73bb7f9d65a10c37ab6368e880b3b1774889/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71af73bb7f9d65a10c37ab6368e880b3b1774889/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=71af73bb7f9d65a10c37ab6368e880b3b1774889", "patch": "@@ -61,11 +61,16 @@ static int sdiv_pow2_cheap, smod_pow2_cheap;\n #define MAX_BITS_PER_WORD BITS_PER_WORD\n #endif\n \n-/* Cost of various pieces of RTL.  */\n+/* Cost of various pieces of RTL.  Note that some of these are indexed by shift count,\n+   and some by mode.  */\n static int add_cost, negate_cost, zero_cost;\n static int shift_cost[MAX_BITS_PER_WORD];\n static int shiftadd_cost[MAX_BITS_PER_WORD];\n static int shiftsub_cost[MAX_BITS_PER_WORD];\n+static int mul_cost[NUM_MACHINE_MODES];\n+static int div_cost[NUM_MACHINE_MODES];\n+static int mul_widen_cost[NUM_MACHINE_MODES];\n+static int mul_highpart_cost[NUM_MACHINE_MODES];\n \n void\n init_expmed ()\n@@ -77,6 +82,7 @@ init_expmed ()\n   rtx shift_insn, shiftadd_insn, shiftsub_insn;\n   int dummy;\n   int m;\n+  enum machine_mode mode, wider_mode;\n \n   start_sequence ();\n \n@@ -138,6 +144,32 @@ init_expmed ()\n     = (rtx_cost (gen_rtx (MOD, word_mode, reg, GEN_INT (32)), SET)\n        <= 2 * add_cost);\n \n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      reg = gen_rtx (REG, mode, 10000);\n+      div_cost[(int) mode] = rtx_cost (gen_rtx (UDIV, mode, reg, reg), SET);\n+      mul_cost[(int) mode] = rtx_cost (gen_rtx (MULT, mode, reg, reg), SET);\n+      wider_mode = GET_MODE_WIDER_MODE (mode);\n+      if (wider_mode != VOIDmode)\n+\t{\n+\t  mul_widen_cost[(int) wider_mode]\n+\t    = rtx_cost (gen_rtx (MULT, wider_mode,\n+\t\t\t\t gen_rtx (ZERO_EXTEND, wider_mode, reg),\n+\t\t\t\t gen_rtx (ZERO_EXTEND, wider_mode, reg)),\n+\t\t\tSET);\n+\t  mul_highpart_cost[(int) mode]\n+\t    = rtx_cost (gen_rtx (TRUNCATE, mode,\n+\t\t\t\t gen_rtx (LSHIFTRT, wider_mode,\n+\t\t\t\t\t  gen_rtx (MULT, wider_mode,\n+\t\t\t\t\t\t   gen_rtx (ZERO_EXTEND, wider_mode, reg),\n+\t\t\t\t\t\t   gen_rtx (ZERO_EXTEND, wider_mode, reg)),\n+\t\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (mode)))),\n+\t\t\tSET);\n+\t}\n+    }\n+\n   /* Free the objects we just allocated.  */\n   end_sequence ();\n   obfree (free_point);\n@@ -2470,14 +2502,17 @@ expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n \n    MODE is the mode of operation and result.\n \n-   UNSIGNEDP nonzero means unsigned multiply.  */\n+   UNSIGNEDP nonzero means unsigned multiply.\n+\n+   MAX_COST is the total allowed cost for the expanded RTL.  */\n \n rtx\n-expand_mult_highpart (mode, op0, cnst1, target, unsignedp)\n+expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n      enum machine_mode mode;\n      register rtx op0, target;\n      unsigned HOST_WIDE_INT cnst1;\n      int unsignedp;\n+     int max_cost;\n {\n   enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n   optab mul_highpart_optab;\n@@ -2504,7 +2539,8 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp)\n \n   /* expand_mult handles constant multiplication of word_mode\n      or narrower.  It does a poor job for large modes.  */\n-  if (size < BITS_PER_WORD)\n+  if (size < BITS_PER_WORD\n+      && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)\n     {\n       /* We have to do this, since expand_binop doesn't do conversion for\n \t multiply.  Maybe change expand_binop to handle widening multiply?  */\n@@ -2521,55 +2557,63 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp)\n \n   /* Firstly, try using a multiplication insn that only generates the needed\n      high part of the product, and in the sign flavor of unsignedp.  */\n-  mul_highpart_optab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n-  target = expand_binop (mode, mul_highpart_optab,\n-\t\t\t op0, op1, target, unsignedp, OPTAB_DIRECT);\n-  if (target)\n-    return target;\n+  if (mul_highpart_cost[(int) mode] < max_cost)\n+    {\n+      mul_highpart_optab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n+      target = expand_binop (mode, mul_highpart_optab,\n+\t\t\t     op0, op1, target, unsignedp, OPTAB_DIRECT);\n+      if (target)\n+\treturn target;\n+    }\n \n   /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n      Need to adjust the result after the multiplication.  */\n-  mul_highpart_optab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n-  target = expand_binop (mode, mul_highpart_optab,\n-\t\t\t op0, op1, target, unsignedp, OPTAB_DIRECT);\n-  if (target)\n-    /* We used the wrong signedness.  Adjust the result.  */\n-    return expand_mult_highpart_adjust (mode, target, op0,\n-\t\t\t\t\top1, target, unsignedp);\n-\n-  /* Thirdly, we try to use a widening multiplication, or a wider mode\n-     multiplication.  */\n+  if (mul_highpart_cost[(int) mode] + 2 * shift_cost[size-1] + 4 * add_cost < max_cost)\n+    {\n+      mul_highpart_optab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n+      target = expand_binop (mode, mul_highpart_optab,\n+\t\t\t     op0, op1, target, unsignedp, OPTAB_DIRECT);\n+      if (target)\n+\t/* We used the wrong signedness.  Adjust the result.  */\n+\treturn expand_mult_highpart_adjust (mode, target, op0,\n+\t\t\t\t\t    op1, target, unsignedp);\n+    }\n \n+  /* Try widening multiplication.  */\n   moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n-  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n-    ;\n-  else if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n-    moptab = smul_optab;\n-  else\n+  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+      && mul_widen_cost[(int) wider_mode] < max_cost)\n+    goto try;\n+\n+  /* Try widening the mode and perform a non-widening multiplication.  */\n+  moptab = smul_optab;\n+  if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+      && mul_cost[(int) wider_mode] + shift_cost[size-1] < max_cost)\n+    goto try;\n+\n+  /* Try widening multiplication of opposite signedness, and adjust.  */\n+  moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n+  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n+      && (mul_widen_cost[(int) wider_mode]\n+\t  + 2 * shift_cost[size-1] + 4 * add_cost < max_cost))\n     {\n-      /* Try widening multiplication of opposite signedness, and adjust.  */\n-      moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n-      if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+      tem = expand_binop (wider_mode, moptab, op0, wide_op1,\n+\t\t\t  NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n+      if (tem != 0)\n \t{\n-\t  tem = expand_binop (wider_mode, moptab, op0, wide_op1,\n-\t\t\t      NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n-\t  if (tem != 0)\n-\t    {\n-\t      /* Extract the high half of the just generated product.  */\n-\t      tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n-\t\t\t\t  build_int_2 (size, 0), NULL_RTX, 1);\n-\t      tem = convert_modes (mode, wider_mode, tem, unsignedp);\n-\t      /* We used the wrong signedness.  Adjust the result.  */\n-\t      return expand_mult_highpart_adjust (mode, tem, op0, op1,\n-\t\t\t\t\t\t  target, unsignedp);\n-\t    }\n+\t  /* Extract the high half of the just generated product.  */\n+\t  tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n+\t\t\t      build_int_2 (size, 0), NULL_RTX, 1);\n+\t  tem = convert_modes (mode, wider_mode, tem, unsignedp);\n+\t  /* We used the wrong signedness.  Adjust the result.  */\n+\t  return expand_mult_highpart_adjust (mode, tem, op0, op1,\n+\t\t\t\t\t      target, unsignedp);\n \t}\n-\n-      /* As a last resort, try widening the mode and perform a\n-\t non-widening multiplication.  */\n-      moptab = smul_optab;\n     }\n \n+  return 0;\n+\n+ try:\n   /* Pass NULL_RTX as target since TARGET has wrong mode.  */\n   tem = expand_binop (wider_mode, moptab, op0, wide_op1,\n \t\t      NULL_RTX, unsignedp, OPTAB_WIDEN);\n@@ -2617,6 +2661,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   rtx insn, set;\n   optab optab1, optab2;\n   int op1_is_constant, op1_is_pow2;\n+  int max_cost, extra_cost;\n \n   op1_is_constant = GET_CODE (op1) == CONST_INT;\n   op1_is_pow2 = (op1_is_constant\n@@ -2721,11 +2766,14 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   size = GET_MODE_BITSIZE (compute_mode);\n #if 0\n   /* It should be possible to restrict the precision to GET_MODE_BITSIZE\n-     (mode), and thereby get better code when OP1 is a constant.  Do that for\n-     GCC 2.7.  It will require going over all usages of SIZE below.  */\n+     (mode), and thereby get better code when OP1 is a constant.  Do that\n+     later.  It will require going over all usages of SIZE below.  */\n   size = GET_MODE_BITSIZE (mode);\n #endif\n \n+  max_cost = div_cost[(int) compute_mode]\n+    - (rem_flag ? mul_cost[(int) compute_mode] + add_cost : 0);\n+\n   /* Now convert to the best mode to use.  */\n   if (compute_mode != mode)\n     {\n@@ -2826,8 +2874,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t      {\n \t\t\trtx t1, t2, t3, t4;\n \n+\t\t\textra_cost = (shift_cost[post_shift - 1]\n+\t\t\t\t      + shift_cost[1] + 2 * add_cost);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n-\t\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\t\t\t\t   NULL_RTX, 1,\n+\t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n \t\t\tt2 = force_operand (gen_rtx (MINUS, compute_mode,\n@@ -2850,8 +2901,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t   build_int_2 (pre_shift, 0),\n \t\t\t\t\t   NULL_RTX, 1);\n+\t\t\textra_cost = (shift_cost[pre_shift]\n+\t\t\t\t      + shift_cost[post_shift]);\n \t\t\tt2 = expand_mult_highpart (compute_mode, t1, ml,\n-\t\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\t\t\t\t   NULL_RTX, 1,\n+\t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t2 == 0)\n \t\t\t  goto fail1;\n \t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n@@ -2952,8 +3006,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t      {\n \t\t\trtx t1, t2, t3;\n \n+\t\t\textra_cost = (shift_cost[post_shift]\n+\t\t\t\t      + shift_cost[size - 1] + add_cost);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n-\t\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\t\t\t\t   NULL_RTX, 0,\n+\t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n \t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n@@ -2972,8 +3029,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\trtx t1, t2, t3, t4;\n \n \t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n+\t\t\textra_cost = (shift_cost[post_shift]\n+\t\t\t\t      + shift_cost[size - 1] + 2 * add_cost);\n \t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n-\t\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\t\t\t\t   NULL_RTX, 0,\n+\t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n \t\t\tt2 = force_operand (gen_rtx (PLUS, compute_mode, t1, op0),\n@@ -3047,8 +3107,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t\t       build_int_2 (size - 1, 0), NULL_RTX, 0);\n \t\t    t2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t       NULL_RTX, 0, OPTAB_WIDEN);\n+\t\t    extra_cost = (shift_cost[post_shift]\n+\t\t\t\t  + shift_cost[size - 1] + 2 * add_cost);\n \t\t    t3 = expand_mult_highpart (compute_mode, t2, ml,\n-\t\t\t\t\t       NULL_RTX, 1);\n+\t\t\t\t\t       NULL_RTX, 1,\n+\t\t\t\t\t       max_cost - extra_cost);\n \t\t    if (t3 != 0)\n \t\t      {\n \t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, t3,"}]}