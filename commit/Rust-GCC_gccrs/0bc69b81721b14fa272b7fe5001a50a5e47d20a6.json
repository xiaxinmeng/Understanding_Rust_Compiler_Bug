{"sha": "0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJjNjliODE3MjFiMTRmYTI3MmI3ZmU1MDAxYTUwYTVlNDdkMjBhNg==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2013-11-16T11:53:21Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2013-11-16T11:53:21Z"}, "message": "arc.c (arc_predicate_delay_insns): New function.\n\n        * config/arc/arc.c (arc_predicate_delay_insns): New function.\n        (pass_data_arc_predicate_delay_insns): New pass_data instance.\n        (pass_arc_predicate_delay_insns): New subclass of rtl_opt_class.\n        (make_pass_arc_predicate_delay_insns): New function.\n        (arc_init): Register pass_arc_predicate_delay_insns if\n        flag_delayed_branch is active.\n\nFrom-SVN: r204901", "tree": {"sha": "717533fb7cc33432e184f9fdd368145c60ee4751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717533fb7cc33432e184f9fdd368145c60ee4751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc69b81721b14fa272b7fe5001a50a5e47d20a6/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "036def0f2388da95505fcbadb538d7c45ff3231e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036def0f2388da95505fcbadb538d7c45ff3231e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036def0f2388da95505fcbadb538d7c45ff3231e"}], "stats": {"total": 125, "additions": 125, "deletions": 0}, "files": [{"sha": "5cb07b7882f02ae38eb711f492b886a3c9ecf3d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc69b81721b14fa272b7fe5001a50a5e47d20a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc69b81721b14fa272b7fe5001a50a5e47d20a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "patch": "@@ -1,3 +1,12 @@\n+2013-11-16  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* config/arc/arc.c (arc_predicate_delay_insns): New function.\n+\t(pass_data_arc_predicate_delay_insns): New pass_data instance.\n+\t(pass_arc_predicate_delay_insns): New subclass of rtl_opt_class.\n+\t(make_pass_arc_predicate_delay_insns): New function.\n+\t(arc_init): Register pass_arc_predicate_delay_insns if\n+\tflag_delayed_branch is active.\n+\n 2013-11-16  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config/arc/constraints.md (Rcq): Simplify register number test."}, {"sha": "f813c90763df3ea4c44e3c7196fc6d117733e3d3", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc69b81721b14fa272b7fe5001a50a5e47d20a6/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc69b81721b14fa272b7fe5001a50a5e47d20a6/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=0bc69b81721b14fa272b7fe5001a50a5e47d20a6", "patch": "@@ -632,6 +632,44 @@ make_pass_arc_ifcvt (gcc::context *ctxt)\n   return new pass_arc_ifcvt (ctxt);\n }\n \n+static unsigned arc_predicate_delay_insns (void);\n+\n+namespace {\n+\n+const pass_data pass_data_arc_predicate_delay_insns =\n+{\n+  RTL_PASS,\n+  \"arc_predicate_delay_insns\",\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  false,\t\t\t\t/* has_gate */\n+  true,\t\t\t\t\t/* has_execute */\n+  TV_IFCVT2,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_arc_predicate_delay_insns : public rtl_opt_pass\n+{\n+public:\n+  pass_arc_predicate_delay_insns(gcc::context *ctxt)\n+  : rtl_opt_pass(pass_data_arc_predicate_delay_insns, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  unsigned int execute () { return arc_predicate_delay_insns (); }\n+};\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_arc_predicate_delay_insns (gcc::context *ctxt)\n+{\n+  return new pass_arc_predicate_delay_insns (ctxt);\n+}\n+\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n \n void\n@@ -752,6 +790,16 @@ arc_init (void)\n       register_pass (&arc_ifcvt4_info);\n       register_pass (&arc_ifcvt5_info);\n     }\n+\n+  if (flag_delayed_branch)\n+    {\n+      opt_pass *pass_arc_predicate_delay_insns\n+\t= make_pass_arc_predicate_delay_insns (g);\n+      struct register_pass_info arc_predicate_delay_info\n+\t= { pass_arc_predicate_delay_insns, \"dbr\", 1, PASS_POS_INSERT_AFTER };\n+\n+      register_pass (&arc_predicate_delay_info);\n+    }\n }\n \n /* Check ARC options, generate derived target attributes.  */\n@@ -8297,6 +8345,74 @@ arc_ifcvt (void)\n   return 0;\n }\n \n+/* Find annulled delay insns and convert them to use the appropriate predicate.\n+   This allows branch shortening to size up these insns properly.  */\n+\n+static unsigned\n+arc_predicate_delay_insns (void)\n+{\n+  for (rtx insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat, jump, dlay, src, cond, *patp;\n+      int reverse;\n+\n+      if (!NONJUMP_INSN_P (insn)\n+\t  || GET_CODE (pat = PATTERN (insn)) != SEQUENCE)\n+\tcontinue;\n+      jump = XVECEXP (pat, 0, 0);\n+      dlay = XVECEXP (pat, 0, 1);\n+      if (!JUMP_P (jump) || !INSN_ANNULLED_BRANCH_P (jump))\n+\tcontinue;\n+      /* If the branch insn does the annulling, leave the delay insn alone.  */\n+      if (!TARGET_AT_DBR_CONDEXEC && !INSN_FROM_TARGET_P (dlay))\n+\tcontinue;\n+      /* ??? Could also leave DLAY un-conditionalized if its target is dead\n+\t on the other path.  */\n+      gcc_assert (GET_CODE (PATTERN (jump)) == SET);\n+      gcc_assert (SET_DEST (PATTERN (jump)) == pc_rtx);\n+      src = SET_SRC (PATTERN (jump));\n+      gcc_assert (GET_CODE (src) == IF_THEN_ELSE);\n+      cond = XEXP (src, 0);\n+      if (XEXP (src, 2) == pc_rtx)\n+\treverse = 0;\n+      else if (XEXP (src, 1) == pc_rtx)\n+\treverse = 1;\n+      else\n+\tgcc_unreachable ();\n+      if (!INSN_FROM_TARGET_P (dlay) != reverse)\n+\t{\n+\t  enum machine_mode ccm = GET_MODE (XEXP (cond, 0));\n+\t  enum rtx_code code = reverse_condition (GET_CODE (cond));\n+\t  if (code == UNKNOWN || ccm == CC_FP_GTmode || ccm == CC_FP_GEmode)\n+\t    code = reverse_condition_maybe_unordered (GET_CODE (cond));\n+\n+\t  cond = gen_rtx_fmt_ee (code, GET_MODE (cond),\n+\t\t\t\t copy_rtx (XEXP (cond, 0)),\n+\t\t\t\t copy_rtx (XEXP (cond, 1)));\n+\t}\n+      else\n+\tcond = copy_rtx (cond);\n+      patp = &PATTERN (dlay);\n+      pat = *patp;\n+      /* dwarf2out.c:dwarf2out_frame_debug_expr doesn't know\n+\t what to do with COND_EXEC.  */\n+      if (RTX_FRAME_RELATED_P (dlay))\n+\t{\n+\t  /* As this is the delay slot insn of an anulled branch,\n+\t     dwarf2out.c:scan_trace understands the anulling semantics\n+\t     without the COND_EXEC.  */\n+\t  rtx note = alloc_reg_note (REG_FRAME_RELATED_EXPR, pat,\n+\t\t\t\t     REG_NOTES (dlay));\n+\t  validate_change (dlay, &REG_NOTES (dlay), note, 1);\n+\t}\n+      pat = gen_rtx_COND_EXEC (VOIDmode, cond, pat);\n+      validate_change (dlay, patp, pat, 1);\n+      if (!apply_change_group ())\n+\tgcc_unreachable ();\n+    }\n+  return 0;\n+}\n+\n /* For ARC600: If a write to a core reg >=32 appears in a delay slot\n   (other than of a forward brcc), it creates a hazard when there is a read\n   of the same register at the branch target.  We can't know what is at the"}]}