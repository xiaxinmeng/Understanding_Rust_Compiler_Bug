{"sha": "ee289e459419e5ddfd82482a68e82ce6d20a2cee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUyODllNDU5NDE5ZTVkZGZkODI0ODJhNjhlODJjZTZkMjBhMmNlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-03-20T16:51:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-03-20T16:51:41Z"}, "message": "re PR target/52607 (v4df __builtin_shuffle with {0,2,1,3} or {1,3,0,2})\n\n\tPR target/52607\n\t* config/i386/i386.c (expand_vec_perm_vperm2f128): New function.\n\t(ix86_expand_vec_perm_const_1): Call it.\n\nFrom-SVN: r185579", "tree": {"sha": "118eecb0eead897948da6584e6b78540fcea1060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/118eecb0eead897948da6584e6b78540fcea1060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee289e459419e5ddfd82482a68e82ce6d20a2cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee289e459419e5ddfd82482a68e82ce6d20a2cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee289e459419e5ddfd82482a68e82ce6d20a2cee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee289e459419e5ddfd82482a68e82ce6d20a2cee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5069d626e754ca7dd2d269dbb57d83e3a0eca38"}], "stats": {"total": 127, "additions": 127, "deletions": 0}, "files": [{"sha": "439e15205a3cd1f9dddf3abbc843d4ff3fd0e6f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee289e459419e5ddfd82482a68e82ce6d20a2cee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee289e459419e5ddfd82482a68e82ce6d20a2cee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee289e459419e5ddfd82482a68e82ce6d20a2cee", "patch": "@@ -1,5 +1,9 @@\n 2012-03-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/52607\n+\t* config/i386/i386.c (expand_vec_perm_vperm2f128): New function.\n+\t(ix86_expand_vec_perm_const_1): Call it.\n+\n \t* config/i386/i386.c (vselect_insn): New variable.\n \t(init_vselect_insn): New function.\n \t(expand_vselect, expand_vselect_insn): Add testing_p argument."}, {"sha": "a21f2da95b76cbd4496e99a5131b20e663760b8f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee289e459419e5ddfd82482a68e82ce6d20a2cee/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee289e459419e5ddfd82482a68e82ce6d20a2cee/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ee289e459419e5ddfd82482a68e82ce6d20a2cee", "patch": "@@ -36629,6 +36629,126 @@ expand_vec_perm_vpermq_perm_1 (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to expand\n+   a vector permutation using two instructions, vperm2f128 resp.\n+   vperm2i128 followed by any single in-lane permutation.  */\n+\n+static bool\n+expand_vec_perm_vperm2f128 (struct expand_vec_perm_d *d)\n+{\n+  struct expand_vec_perm_d dfirst, dsecond;\n+  unsigned i, j, nelt = d->nelt, nelt2 = nelt / 2, perm;\n+  bool ok;\n+\n+  if (!TARGET_AVX\n+      || GET_MODE_SIZE (d->vmode) != 32\n+      || (d->vmode != V8SFmode && d->vmode != V4DFmode && !TARGET_AVX2))\n+    return false;\n+\n+  dsecond = *d;\n+  if (d->op0 == d->op1)\n+    dsecond.op1 = gen_reg_rtx (d->vmode);\n+  dsecond.testing_p = true;\n+\n+  /* ((perm << 2)|perm) & 0x33 is the vperm2[fi]128\n+     immediate.  For perm < 16 the second permutation uses\n+     d->op0 as first operand, for perm >= 16 it uses d->op1\n+     as first operand.  The second operand is the result of\n+     vperm2[fi]128.  */\n+  for (perm = 0; perm < 32; perm++)\n+    {\n+      /* Ignore permutations which do not move anything cross-lane.  */\n+      if (perm < 16)\n+\t{\n+\t  /* The second shuffle for e.g. V4DFmode has\n+\t     0123 and ABCD operands.\n+\t     Ignore AB23, as 23 is already in the second lane\n+\t     of the first operand.  */\n+\t  if ((perm & 0xc) == (1 << 2)) continue;\n+\t  /* And 01CD, as 01 is in the first lane of the first\n+\t     operand.  */\n+\t  if ((perm & 3) == 0) continue;\n+\t  /* And 4567, as then the vperm2[fi]128 doesn't change\n+\t     anything on the original 4567 second operand.  */\n+\t  if ((perm & 0xf) == ((3 << 2) | 2)) continue;\n+\t}\n+      else\n+\t{\n+\t  /* The second shuffle for e.g. V4DFmode has\n+\t     4567 and ABCD operands.\n+\t     Ignore AB67, as 67 is already in the second lane\n+\t     of the first operand.  */\n+\t  if ((perm & 0xc) == (3 << 2)) continue;\n+\t  /* And 45CD, as 45 is in the first lane of the first\n+\t     operand.  */\n+\t  if ((perm & 3) == 2) continue;\n+\t  /* And 0123, as then the vperm2[fi]128 doesn't change\n+\t     anything on the original 0123 first operand.  */\n+\t  if ((perm & 0xf) == (1 << 2)) continue;\n+\t}\n+\n+      for (i = 0; i < nelt; i++)\n+\t{\n+\t  j = d->perm[i] / nelt2;\n+\t  if (j == ((perm >> (2 * (i >= nelt2))) & 3))\n+\t    dsecond.perm[i] = nelt + (i & nelt2) + (d->perm[i] & (nelt2 - 1));\n+\t  else if (j == (unsigned) (i >= nelt2) + 2 * (perm >= 16))\n+\t    dsecond.perm[i] = d->perm[i] & (nelt - 1);\n+\t  else\n+\t    break;\n+\t}\n+\n+      if (i == nelt)\n+\t{\n+\t  start_sequence ();\n+\t  ok = expand_vec_perm_1 (&dsecond);\n+\t  end_sequence ();\n+\t}\n+      else\n+\tok = false;\n+\n+      if (ok)\n+\t{\n+\t  if (d->testing_p)\n+\t    return true;\n+\n+\t  /* Found a usable second shuffle.  dfirst will be\n+\t     vperm2f128 on d->op0 and d->op1.  */\n+\t  dsecond.testing_p = false;\n+\t  dfirst = *d;\n+\t  if (d->op0 == d->op1)\n+\t    dfirst.target = dsecond.op1;\n+\t  else\n+\t    dfirst.target = gen_reg_rtx (d->vmode);\n+\t  for (i = 0; i < nelt; i++)\n+\t    dfirst.perm[i] = (i & (nelt2 - 1))\n+\t\t\t     + ((perm >> (2 * (i >= nelt2))) & 3) * nelt2;\n+\n+\t  ok = expand_vec_perm_1 (&dfirst);\n+\t  gcc_assert (ok);\n+\n+\t  /* And dsecond is some single insn shuffle, taking\n+\t     d->op0 and result of vperm2f128 (if perm < 16) or\n+\t     d->op1 and result of vperm2f128 (otherwise).  */\n+\t  dsecond.op1 = dfirst.target;\n+\t  if (perm >= 16)\n+\t    dsecond.op0 = dfirst.op1;\n+\n+\t  ok = expand_vec_perm_1 (&dsecond);\n+\t  gcc_assert (ok);\n+\n+\t  return true;\n+\t}\n+\n+      /* For d->op0 == d->op1 the only useful vperm2f128 permutation\n+\t is 0x10.  */\n+      if (d->op0 == d->op1)\n+\treturn false;\n+    }\n+\n+  return false;\n+}\n+\n /* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n    a two vector permutation using 2 intra-lane interleave insns\n    and cross-lane shuffle for 32-byte vectors.  */\n@@ -37416,6 +37536,9 @@ ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_vpermq_perm_1 (d))\n     return true;\n \n+  if (expand_vec_perm_vperm2f128 (d))\n+    return true;\n+\n   /* Try sequences of three instructions.  */\n \n   if (expand_vec_perm_pshufb2 (d))"}]}