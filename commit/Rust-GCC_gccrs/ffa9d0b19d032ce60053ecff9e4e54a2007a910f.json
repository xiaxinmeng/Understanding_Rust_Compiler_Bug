{"sha": "ffa9d0b19d032ce60053ecff9e4e54a2007a910f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhOWQwYjE5ZDAzMmNlNjAwNTNlY2ZmOWU0ZTU0YTIwMDdhOTEwZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-10-24T00:24:13Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-10-24T00:24:13Z"}, "message": "(mips_abicalls): New variable.\n\n(override_options): Set mips_abicalls.  Allow '^' as print operand\npunctuation character.\n(print_operand): Add support for '^'.\n(mips_asm_file_start): Use ABICALLS_ASM_OP instead of \".abicalls\".\n(compute_frame_size): Handle TARGET_ABICALLS case.\n(mips_expand_prologue): Likewise.\n\nFrom-SVN: r5874", "tree": {"sha": "87da93f3a16d83e3833ec77c7df388935a5c77e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87da93f3a16d83e3833ec77c7df388935a5c77e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa9d0b19d032ce60053ecff9e4e54a2007a910f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa9d0b19d032ce60053ecff9e4e54a2007a910f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa9d0b19d032ce60053ecff9e4e54a2007a910f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa9d0b19d032ce60053ecff9e4e54a2007a910f/comments", "author": null, "committer": null, "parents": [{"sha": "b8232327261f524f3d69e51219035fbfa2a82093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8232327261f524f3d69e51219035fbfa2a82093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8232327261f524f3d69e51219035fbfa2a82093"}], "stats": {"total": 123, "additions": 85, "deletions": 38}, "files": [{"sha": "59c08d488770054bbd30321c3f75f7523fb3a0b3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 85, "deletions": 38, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa9d0b19d032ce60053ecff9e4e54a2007a910f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa9d0b19d032ce60053ecff9e4e54a2007a910f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ffa9d0b19d032ce60053ecff9e4e54a2007a910f", "patch": "@@ -190,6 +190,9 @@ int mips_isa;\n char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n char *mips_isa_string;\t\t/* for -mips{1,2,3} */\n \n+/* Generating calls to position independent functions?  */\n+enum attr_abicalls mips_abicalls;\n+\n /* Array to RTX class classification.  At present, we care about\n    whether the operator is an add-type operator, or a divide/modulus,\n    and if divide/modulus, whether it is unsigned.  This is for the\n@@ -2900,6 +2903,11 @@ override_options ()\n   if (TARGET_HALF_PIC)\n     HALF_PIC_INIT ();\n \n+  if (TARGET_ABICALLS)\n+    mips_abicalls = ABICALLS_YES;\n+  else\n+    mips_abicalls = ABICALLS_NO;\n+\n   /* -mrnames says to use the MIPS software convention for register\n      names instead of the hardware names (ie, a0 instead of $4).\n      We do this by switching the names in mips_reg_names, which the\n@@ -2970,6 +2978,7 @@ override_options ()\n   mips_print_operand_punct['>'] = TRUE;\n   mips_print_operand_punct['{'] = TRUE;\n   mips_print_operand_punct['}'] = TRUE;\n+  mips_print_operand_punct['^'] = TRUE;\n \n   mips_char_to_class['d'] = GR_REGS;\n   mips_char_to_class['f'] = ((TARGET_HARD_FLOAT) ? FP_REGS : NO_REGS);\n@@ -3120,7 +3129,8 @@ mips_debugger_offset (addr, offset)\n    '#'\tPrint nop if in a .set noreorder section.\n    '?'\tPrint 'l' if we are to use a branch likely instead of normal branch.\n    '@'\tPrint the name of the assembler temporary register (at or $1).\n-   '.'\tPrint the name of the register with a hard-wired zero (zero or $0).  */\n+   '.'\tPrint the name of the register with a hard-wired zero (zero or $0).\n+   '^'\tPrint the name of the pic call-through register (t9 or $25).  */\n \n void\n print_operand (file, op, letter)\n@@ -3147,6 +3157,10 @@ print_operand (file, op, letter)\n \t  fputs (reg_names [GP_REG_FIRST + 1], file);\n \t  break;\n \n+\tcase '^':\n+\t  fputs (reg_names [PIC_FUNCTION_ADDR_REGNUM], file);\n+\t  break;\n+\n \tcase '.':\n \t  fputs (reg_names [GP_REG_FIRST + 0], file);\n \t  break;\n@@ -3663,11 +3677,12 @@ mips_asm_file_start (stream)\n   if (TARGET_MIPS_AS && optimize && flag_delayed_branch)\n     fprintf (stream, \"\\t.set\\tnobopt\\n\");\n \n-  /* Generate the pseudo ops that the Pyramid based System V.4 wants.  */\n+  /* Generate the pseudo ops that System V.4 wants.  */\n #ifndef ABICALLS_ASM_OP\n #define ABICALLS_ASM_OP \".abicalls\"\n #endif\n   if (TARGET_ABICALLS)\n+    /* ??? but do not want this (or want pic0) if -non-shared? */\n     fprintf (stream, \"\\t%s\\n\", ABICALLS_ASM_OP);\n \n   if (TARGET_GP_OPT)\n@@ -3888,12 +3903,8 @@ epilogue_reg_mentioned_p (insn)\n  \t|  4 words to save     \t|\t|  4 words to save\t|\n \t|  arguments passed\t|\t|  arguments passed\t|\n \t|  in registers, even\t|\t|  in registers, even\t|\n-    SP->|  if not passed.       |   FP->|  if not passed.\t|\n+    SP->|  if not passed.       |  VFP->|  if not passed.\t|\n \t+-----------------------+       +-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  GP save for V.4 abi\t|\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n \t\t\t\t\t|\t\t        |\n                                         |  fp register save     |\n \t\t\t\t\t|\t\t\t|\n@@ -3911,6 +3922,10 @@ epilogue_reg_mentioned_p (insn)\n         \t\t\t\t|\t\t\t|\n \t\t\t\t\t+-----------------------+\n \t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t|  GP save for V.4 abi\t|\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n                                         |  arguments on stack   |\n         \t\t\t\t|\t\t        |\n \t\t\t\t\t+-----------------------+\n@@ -3993,6 +4008,15 @@ compute_frame_size (size)\n \n   if (total_size == extra_size)\n     total_size = extra_size = 0;\n+  else if (TARGET_ABICALLS)\n+    {\n+      /* Add the context-pointer to the saved registers.  */\n+      gp_reg_size += UNITS_PER_WORD;\n+      mask |= 1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST);\n+      total_size -= gp_reg_rounded;\n+      gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n+      total_size += gp_reg_rounded;\n+    }\n \n   /* Save other computed information.  */\n   current_frame_info.total_size  = total_size;\n@@ -4009,7 +4033,8 @@ compute_frame_size (size)\n \n   if (mask)\n     {\n-      unsigned long offset = args_size + var_size + gp_reg_size - UNITS_PER_WORD;\n+      unsigned long offset = args_size + extra_size + var_size\n+\t\t\t     + gp_reg_size - UNITS_PER_WORD;\n       current_frame_info.gp_sp_offset = offset;\n       current_frame_info.gp_save_offset = offset - total_size;\n     }\n@@ -4022,7 +4047,8 @@ compute_frame_size (size)\n \n   if (fmask)\n     {\n-      unsigned long offset = args_size + var_size + gp_reg_rounded + fp_reg_size - 2*UNITS_PER_WORD;\n+      unsigned long offset = args_size + extra_size + var_size\n+\t\t\t     + gp_reg_rounded + fp_reg_size - 2*UNITS_PER_WORD;\n       current_frame_info.fp_sp_offset = offset;\n       current_frame_info.fp_save_offset = offset - total_size + UNITS_PER_WORD;\n     }\n@@ -4141,16 +4167,21 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n \t\t  if (store_p)\n \t\t    emit_move_insn (mem_rtx, reg_rtx);\n-\t\t  else\n+\t\t  else if (!TARGET_ABICALLS\n+\t\t\t   || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n \t\t}\n \t      else\n-\t\tfprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n-\t\t\t (store_p) ? \"sw\" : \"lw\",\n-\t\t\t reg_names[regno],\n-\t\t\t gp_offset - base_offset,\n-\t\t\t reg_names[REGNO(base_reg_rtx)]);\n+\t\t{\n+\t\t  if (store_p || !TARGET_ABICALLS\n+\t\t      || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n+\t\t    fprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n+\t\t\t     (store_p) ? \"sw\" : \"lw\",\n+\t\t\t     reg_names[regno],\n+\t\t\t     gp_offset - base_offset,\n+\t\t\t     reg_names[REGNO(base_reg_rtx)]);\n \n+\t\t}\n \t      gp_offset -= UNITS_PER_WORD;\n \t    }\n \t}\n@@ -4274,16 +4305,7 @@ function_prologue (file, size)\n   assemble_name (file, current_function_name);\n   fputs (\":\\n\", file);\n \n-  if (TARGET_ABICALLS)\n-    fprintf (file,\n-\t     \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n-\t     reg_names[ GP_REG_FIRST + 25 ]);\n-\n-  tsize = current_frame_info.total_size;\n-  if (tsize > 0 && TARGET_ABICALLS)\n-    fprintf (file, \"\\t.cprestore %d\\n\", tsize + STARTING_FRAME_OFFSET);\n-\n-  fprintf (file, \"\\t.frame\\t%s,%d,%s\\t\\t# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n+  fprintf (file, \"\\t.frame\\t%s,%d,%s\\t\\t# vars= %d, regs= %d/%d, args= %d, extra= %d\\n\",\n \t   reg_names[ (frame_pointer_needed) ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM ],\n \t   tsize,\n \t   reg_names[31 + GP_REG_FIRST],\n@@ -4298,6 +4320,19 @@ function_prologue (file, size)\n \t   current_frame_info.gp_save_offset,\n \t   current_frame_info.fmask,\n \t   current_frame_info.fp_save_offset);\n+\n+  if (TARGET_ABICALLS)\n+    {\n+      char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+\n+      fprintf (file, \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n+\t       reg_names[PIC_FUNCTION_ADDR_REGNUM]);\n+      if (tsize > 0)\n+\t{\n+\t  fprintf (file, \"\\tsubu\\t%s,%s,%d\\n\", sp_str, sp_str, tsize);\n+\t  fprintf (file, \"\\t.cprestore %d\\n\", current_frame_info.args_size);\n+\t}\n+    }\n }\n \n \f\n@@ -4405,6 +4440,8 @@ mips_expand_prologue ()\n \t}\n     }\n \n+  tsize = compute_frame_size (get_frame_size ());\n+\n   /* If this function is a varargs function, store any registers that\n      would normally hold arguments ($4 - $7) on the stack.  */\n   if ((TYPE_ARG_TYPES (fntype) != 0\n@@ -4413,30 +4450,40 @@ mips_expand_prologue ()\n \t  && ((arg_name[0] == '_' && strcmp (arg_name, \"__builtin_va_alist\") == 0)\n \t      || (arg_name[0] == 'v' && strcmp (arg_name, \"va_alist\") == 0))))\n     {\n+      int offset = (regno - GP_ARG_FIRST) * UNITS_PER_WORD;\n+      rtx ptr = stack_pointer_rtx;\n+\n+      /* If we are doing svr4-abi, sp has already been decremented by tsize. */\n+      if (TARGET_ABICALLS)\n+\toffset += tsize;\n+\n       for (; regno <= GP_ARG_LAST; regno++)\n \t{\n-\t  rtx ptr = stack_pointer_rtx;\n-\t  if (regno != GP_ARG_FIRST)\n-\t    ptr = gen_rtx (PLUS, Pmode, ptr,\n-\t\t\t   GEN_INT ((regno - GP_ARG_FIRST) * UNITS_PER_WORD));\n-\n-\t  emit_move_insn (gen_rtx (MEM, Pmode, ptr), gen_rtx (REG, Pmode, regno));\n+\t  if (offset != 0)\n+\t    ptr = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (offset));\n+\t  emit_move_insn (gen_rtx (MEM, Pmode, ptr),\n+\t\t\t  gen_rtx (REG, Pmode, regno));\n+\t  offset += UNITS_PER_WORD;\n \t}\n     }\n \n-  tsize = compute_frame_size (get_frame_size ());\n   if (tsize > 0)\n     {\n       rtx tsize_rtx = GEN_INT (tsize);\n \n-      if (tsize > 32767)\n+      /* If we are doing svr4-abi, sp move is done by function_prologue.  */\n+      if (!TARGET_ABICALLS)\n \t{\n-\t  tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n-\t  emit_move_insn (tmp_rtx, tsize_rtx);\n-\t  tsize_rtx = tmp_rtx;\n-\t}\n+\t  if (tsize > 32767)\n+\t    {\n+\t      tmp_rtx = gen_rtx (REG, SImode, MIPS_TEMP1_REGNUM);\n+\t      emit_move_insn (tmp_rtx, tsize_rtx);\n+\t      tsize_rtx = tmp_rtx;\n+\t    }\n \n-      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n+\t  emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t tsize_rtx));\n+\t}\n \n       save_restore_insns (TRUE, tmp_rtx, tsize, (FILE *)0);\n "}]}