{"sha": "c7532b2de4f303ee8fb994411ddf25dc4de45831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1MzJiMmRlNGYzMDNlZThmYjk5NDQxMWRkZjI1ZGM0ZGU0NTgzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T14:51:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-22T14:51:40Z"}, "message": "[multiple changes]\n\n2010-10-22  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_rm.texi: Add chapter on Ada 2012 support.\n\n2010-10-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch12.adb: Minor reformatting.\n\n2010-10-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_dist.adb: Mark missing case of nested package when expanding\n\tstubs.\n\n2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* par-ch10.adb: Discard incomplete with_clause.\n\n2010-10-22  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Enable_Range_Check): Remove code suppressing range check\n\tif static predicate present, not needed.\n\t* exp_attr.adb (Expand_Pred_Succ): Check Suppress_Assignment_Checks flag\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Check\n\tSuppress_Assignment_Checks flag.\n\t* exp_ch4.adb (Expand_N_In): Make some corrections for proper handling\n\tof ranges when predicates are present.\n\t* exp_ch5.adb (Expand_Predicated_Loop): New procedure\n\t(Expand_N_Assignment_Statement): Check Suppress_Assignment_Checks flag\n\t(Expand_N_Loop_Statement): Handle loops over predicated types\n\t* sem_case.adb (Analyze_Choices): Remove extra blank in error message.\n\t* sem_ch13.adb (Build_Predicate_Function.Add_Call): Suppress info\n\tmessage for inheritance if within a generic instance, not useful there!\n\t(Build_Static_Predicate): Optimize test in predicate function\n\tbased on static ranges determined.\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): Error for loop through\n\tsubtype with non-static predicate.\n\t* sinfo.ads, sinfo.adb (Suppress_Assignment_Checks): New flag.\n\nFrom-SVN: r165834", "tree": {"sha": "38cfcc39f78d32f0add42722075410891f22b133", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38cfcc39f78d32f0add42722075410891f22b133"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7532b2de4f303ee8fb994411ddf25dc4de45831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7532b2de4f303ee8fb994411ddf25dc4de45831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7532b2de4f303ee8fb994411ddf25dc4de45831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7532b2de4f303ee8fb994411ddf25dc4de45831/comments", "author": null, "committer": null, "parents": [{"sha": "41787e1db8b690bc4ba27ad31042fb3722da348a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41787e1db8b690bc4ba27ad31042fb3722da348a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41787e1db8b690bc4ba27ad31042fb3722da348a"}], "stats": {"total": 2379, "additions": 2200, "deletions": 179}, "files": [{"sha": "22b8675d3ba050f7330357428243a5cb3b9cfd5c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -1,3 +1,41 @@\n+2010-10-22  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_rm.texi: Add chapter on Ada 2012 support.\n+\n+2010-10-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch12.adb: Minor reformatting.\n+\n+2010-10-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_dist.adb: Mark missing case of nested package when expanding\n+\tstubs.\n+\n+2010-10-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* par-ch10.adb: Discard incomplete with_clause.\n+\n+2010-10-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Enable_Range_Check): Remove code suppressing range check\n+\tif static predicate present, not needed.\n+\t* exp_attr.adb (Expand_Pred_Succ): Check Suppress_Assignment_Checks flag\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Check\n+\tSuppress_Assignment_Checks flag.\n+\t* exp_ch4.adb (Expand_N_In): Make some corrections for proper handling\n+\tof ranges when predicates are present.\n+\t* exp_ch5.adb (Expand_Predicated_Loop): New procedure\n+\t(Expand_N_Assignment_Statement): Check Suppress_Assignment_Checks flag\n+\t(Expand_N_Loop_Statement): Handle loops over predicated types\n+\t* sem_case.adb (Analyze_Choices): Remove extra blank in error message.\n+\t* sem_ch13.adb (Build_Predicate_Function.Add_Call): Suppress info\n+\tmessage for inheritance if within a generic instance, not useful there!\n+\t(Build_Static_Predicate): Optimize test in predicate function\n+\tbased on static ranges determined.\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme): Error for loop through\n+\tsubtype with non-static predicate.\n+\t* sinfo.ads, sinfo.adb (Suppress_Assignment_Checks): New flag.\n+\n 2010-10-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* uname.adb (Get_Unit_Name.Add_Node_Name): If encountering an error"}, {"sha": "46a28543cf85abef2ab47057c34eca13a89ec97d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -3749,6 +3749,15 @@ package body Checks is\n          return;\n       end if;\n \n+      --  Do not set range check flag if parent is assignment statement or\n+      --  object declaration with Suppress_Assignment_Checks flag set\n+\n+      if Nkind_In (Parent (N), N_Assignment_Statement, N_Object_Declaration)\n+        and then Suppress_Assignment_Checks (Parent (N))\n+      then\n+         return;\n+      end if;\n+\n       --  Check for various cases where we should suppress the range check\n \n       --  No check if range checks suppressed for type of node"}, {"sha": "ca0ae7feed4bba7236b9f237ea6bef08bad51fac", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -5407,9 +5407,13 @@ package body Exp_Attr is\n \n    --  These checks are not generated for modular types, since the proper\n    --  semantics for Succ and Pred on modular types is to wrap, not raise CE.\n+   --  We also suppress these checks if we are the right side of an assignment\n+   --  statement or the expression of an object declaration, where the flag\n+   --  Suppress_Assignment_Checks is set for the assignment/declaration.\n \n    procedure Expand_Pred_Succ (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n+      P    : constant Node_Id    := Parent (N);\n       Cnam : Name_Id;\n \n    begin\n@@ -5419,18 +5423,22 @@ package body Exp_Attr is\n          Cnam := Name_Last;\n       end if;\n \n-      Insert_Action (N,\n-        Make_Raise_Constraint_Error (Loc,\n-          Condition =>\n-            Make_Op_Eq (Loc,\n-              Left_Opnd =>\n-                Duplicate_Subexpr_Move_Checks (First (Expressions (N))),\n-              Right_Opnd =>\n-                Make_Attribute_Reference (Loc,\n-                  Prefix =>\n-                    New_Reference_To (Base_Type (Etype (Prefix (N))), Loc),\n-                  Attribute_Name => Cnam)),\n-          Reason => CE_Overflow_Check_Failed));\n+      if not Nkind_In (P, N_Assignment_Statement, N_Object_Declaration)\n+        or else not Suppress_Assignment_Checks (P)\n+      then\n+         Insert_Action (N,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd =>\n+                   Duplicate_Subexpr_Move_Checks (First (Expressions (N))),\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix =>\n+                       New_Reference_To (Base_Type (Etype (Prefix (N))), Loc),\n+                     Attribute_Name => Cnam)),\n+             Reason => CE_Overflow_Check_Failed));\n+      end if;\n    end Expand_Pred_Succ;\n \n    -------------------"}, {"sha": "7c3c0e768182a498592305010602f8a64506aa90", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -4516,7 +4516,8 @@ package body Exp_Ch3 is\n       --  there is an initializing expression, or for default initialization\n       --  when we have at least one case of an explicit default initial value.\n \n-      if Present (Predicate_Function (Typ))\n+      if not Suppress_Assignment_Checks (N)\n+        and then Present (Predicate_Function (Typ))\n         and then\n           (Present (Expr)\n             or else\n@@ -5029,7 +5030,11 @@ package body Exp_Ch3 is\n \n                   if Do_Range_Check (Expr) then\n                      Set_Do_Range_Check (Expr, False);\n-                     Generate_Range_Check (Expr, Typ, CE_Range_Check_Failed);\n+\n+                     if not Suppress_Assignment_Checks (N) then\n+                        Generate_Range_Check\n+                          (Expr, Typ, CE_Range_Check_Failed);\n+                     end if;\n                   end if;\n                end if;\n             end if;"}, {"sha": "086e4036bc968a75fa9e1681cfddc16e25213c6d", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -4398,23 +4398,17 @@ package body Exp_Ch4 is\n \n       procedure Substitute_Valid_Check is\n       begin\n-         --  Don't do this for type with predicates, since we don't care in\n-         --  this case if it gets optimized away, the critical test is the\n-         --  call to the predicate function\n-\n-         if not Has_Predicates (Ltyp) then\n-            Rewrite (N,\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => Relocate_Node (Lop),\n-                Attribute_Name => Name_Valid));\n+         Rewrite (N,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Relocate_Node (Lop),\n+             Attribute_Name => Name_Valid));\n \n-            Analyze_And_Resolve (N, Restyp);\n+         Analyze_And_Resolve (N, Restyp);\n \n-            Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n-            Error_Msg_N -- CODEFIX\n-              (\"\\?use ''Valid attribute instead\", N);\n-            return;\n-         end if;\n+         Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n+         Error_Msg_N -- CODEFIX\n+           (\"\\?use ''Valid attribute instead\", N);\n+         return;\n       end Substitute_Valid_Check;\n \n    --  Start of processing for Expand_N_In\n@@ -4437,15 +4431,18 @@ package body Exp_Ch4 is\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n       --  test and give a warning. For floating point types however, this is a\n       --  standard way to check for finite numbers, and using 'Valid would\n-      --  typically be a pessimization.\n+      --  typically be a pessimization. Also skip this test for predicated\n+      --  types, since it is perfectly reasonable to check if a value meets\n+      --  its predicate.\n \n       if Is_Scalar_Type (Ltyp)\n         and then not Is_Floating_Point_Type (Ltyp)\n         and then Nkind (Rop) in N_Has_Entity\n         and then Ltyp = Entity (Rop)\n         and then Comes_From_Source (N)\n         and then VM_Target = No_VM\n-        and then No (Predicate_Function (Rtyp))\n+        and then not (Is_Discrete_Type (Ltyp)\n+                       and then Present (Predicate_Function (Ltyp)))\n       then\n          Substitute_Valid_Check;\n          return;\n@@ -4688,22 +4685,25 @@ package body Exp_Ch4 is\n             --  type if they come from the original type definition. Also this\n             --  way we get all the processing above for an explicit range.\n \n-            --  Don't do this for a type with predicates, since we would lose\n-            --  the predicate from this rewriting (test goes to base type).\n+               --  Don't do this for predicated types, since in this case we\n+               --  want to check the predicate!\n \n-            elsif Is_Scalar_Type (Typ) and then not Has_Predicates (Typ) then\n-               Rewrite (Rop,\n-                 Make_Range (Loc,\n-                   Low_Bound =>\n-                     Make_Attribute_Reference (Loc,\n-                       Attribute_Name => Name_First,\n-                       Prefix => New_Reference_To (Typ, Loc)),\n+            elsif Is_Scalar_Type (Typ) then\n+               if No (Predicate_Function (Typ)) then\n+                  Rewrite (Rop,\n+                    Make_Range (Loc,\n+                      Low_Bound =>\n+                        Make_Attribute_Reference (Loc,\n+                          Attribute_Name => Name_First,\n+                          Prefix => New_Reference_To (Typ, Loc)),\n+\n+                      High_Bound =>\n+                        Make_Attribute_Reference (Loc,\n+                          Attribute_Name => Name_Last,\n+                          Prefix => New_Reference_To (Typ, Loc))));\n+                  Analyze_And_Resolve (N, Restyp);\n+               end if;\n \n-                   High_Bound =>\n-                     Make_Attribute_Reference (Loc,\n-                       Attribute_Name => Name_Last,\n-                       Prefix => New_Reference_To (Typ, Loc))));\n-               Analyze_And_Resolve (N, Restyp);\n                goto Leave;\n \n             --  Ada 2005 (AI-216): Program_Error is raised when evaluating\n@@ -4843,24 +4843,33 @@ package body Exp_Ch4 is\n \n    <<Leave>>\n \n-      --  If a predicate is present, then we do the predicate test\n+      --  If a predicate is present, then we do the predicate test, but we\n+      --  most certainly want to omit this if we are within the predicate\n+      --  function itself, since otherwise we have an infinite recursion!\n \n-      if Present (Predicate_Function (Rtyp)) then\n-         Rewrite (N,\n-           Make_And_Then (Loc,\n-             Left_Opnd  => Relocate_Node (N),\n-             Right_Opnd => Make_Predicate_Call (Rtyp, Lop)));\n+      declare\n+         PFunc : constant Entity_Id := Predicate_Function (Rtyp);\n \n-         --  Analyze new expression, mark left operand as analyzed to\n-         --  avoid infinite recursion adding predicate calls.\n+      begin\n+         if Present (PFunc)\n+           and then Current_Scope /= PFunc\n+         then\n+            Rewrite (N,\n+              Make_And_Then (Loc,\n+                Left_Opnd  => Relocate_Node (N),\n+                Right_Opnd => Make_Predicate_Call (Rtyp, Lop)));\n \n-         Set_Analyzed (Left_Opnd (N));\n-         Analyze_And_Resolve (N, Standard_Boolean);\n+            --  Analyze new expression, mark left operand as analyzed to\n+            --  avoid infinite recursion adding predicate calls.\n \n-         --  All done, skip attempt at compile time determination of result\n+            Set_Analyzed (Left_Opnd (N));\n+            Analyze_And_Resolve (N, Standard_Boolean);\n \n-         return;\n-      end if;\n+            --  All done, skip attempt at compile time determination of result\n+\n+            return;\n+         end if;\n+      end;\n    end Expand_N_In;\n \n    --------------------------------"}, {"sha": "5d27a9f1c5f5a8f6bb9ac90f86e8b7f12ca5015e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 347, "deletions": 111, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -107,6 +107,9 @@ package body Exp_Ch5 is\n    --  Expand loop over arrays and containers that uses the form \"for X of C\"\n    --  with an optional subtype mark, or \"for Y in C\".\n \n+   procedure Expand_Predicated_Loop (N : Node_Id);\n+   --  Expand for loop over predicated subtype\n+\n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment, that\n    --  is to say, finalization of the target before, adjustment of the target\n@@ -1623,16 +1626,21 @@ package body Exp_Ch5 is\n          end;\n       end if;\n \n-      --  First deal with generation of range check if required\n+      --  Deal with assignment checks unless suppressed\n \n-      if Do_Range_Check (Rhs) then\n-         Set_Do_Range_Check (Rhs, False);\n-         Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n-      end if;\n+      if not Suppress_Assignment_Checks (N) then\n \n-      --  Generate predicate check if required\n+         --  First deal with generation of range check if required\n+\n+         if Do_Range_Check (Rhs) then\n+            Set_Do_Range_Check (Rhs, False);\n+            Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n+         end if;\n \n-      Apply_Predicate_Check (Rhs, Typ);\n+         --  Then generate predicate check if required\n+\n+         Apply_Predicate_Check (Rhs, Typ);\n+      end if;\n \n       --  Check for a special case where a high level transformation is\n       --  required. If we have either of:\n@@ -2960,8 +2968,9 @@ package body Exp_Ch5 is\n    --  2. Deal with while condition for C/Fortran boolean\n    --  3. Deal with loops with a non-standard enumeration type range\n    --  4. Deal with while loops where Condition_Actions is set\n-   --  5. Deal with loops with iterators over arrays and containers\n-   --  6. Insert polling call if required\n+   --  5. Deal with loops over predicated subtypes\n+   --  6. Deal with loops with iterators over arrays and containers\n+   --  7. Insert polling call if required\n \n    procedure Expand_N_Loop_Statement (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -2990,33 +2999,15 @@ package body Exp_Ch5 is\n       --  Nothing more to do for plain loop with no iteration scheme\n \n       if No (Isc) then\n-         return;\n-      end if;\n+         null;\n+\n+      --  Case of for loop (Loop_Parameter_Specfication present)\n \n       --  Note: we do not have to worry about validity checking of the for loop\n       --  range bounds here, since they were frozen with constant declarations\n       --  and it is during that process that the validity checking is done.\n \n-      --  Handle the case where we have a for loop with the range type being an\n-      --  enumeration type with non-standard representation. In this case we\n-      --  expand:\n-\n-      --    for x in [reverse] a .. b loop\n-      --       ...\n-      --    end loop;\n-\n-      --  to\n-\n-      --    for xP in [reverse] integer\n-      --                          range etype'Pos (a) .. etype'Pos (b) loop\n-      --       declare\n-      --          x : constant etype := Pos_To_Rep (xP);\n-      --       begin\n-      --          ...\n-      --       end;\n-      --    end loop;\n-\n-      if Present (Loop_Parameter_Specification (Isc)) then\n+      elsif Present (Loop_Parameter_Specification (Isc)) then\n          declare\n             LPS     : constant Node_Id   := Loop_Parameter_Specification (Isc);\n             Loop_Id : constant Entity_Id := Defining_Identifier (LPS);\n@@ -3026,95 +3017,129 @@ package body Exp_Ch5 is\n             New_Id  : Entity_Id;\n \n          begin\n-            if not Is_Enumeration_Type (Btype)\n-              or else No (Enum_Pos_To_Rep (Btype))\n-            then\n-               return;\n-            end if;\n-\n-            New_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_External_Name (Chars (Loop_Id), 'P'));\n-\n-            --  If the type has a contiguous representation, successive values\n-            --  can be generated as offsets from the first literal.\n-\n-            if Has_Contiguous_Rep (Btype) then\n-               Expr :=\n-                  Unchecked_Convert_To (Btype,\n-                    Make_Op_Add (Loc,\n-                      Left_Opnd =>\n-                         Make_Integer_Literal (Loc,\n-                           Enumeration_Rep (First_Literal (Btype))),\n-                      Right_Opnd => New_Reference_To (New_Id, Loc)));\n-            else\n-               --  Use the constructed array Enum_Pos_To_Rep\n+            --  Deal with loop over predicates\n \n-               Expr :=\n-                 Make_Indexed_Component (Loc,\n-                   Prefix => New_Reference_To (Enum_Pos_To_Rep (Btype), Loc),\n-                   Expressions => New_List (New_Reference_To (New_Id, Loc)));\n-            end if;\n-\n-            Rewrite (N,\n-              Make_Loop_Statement (Loc,\n-                Identifier => Identifier (N),\n-\n-                Iteration_Scheme =>\n-                  Make_Iteration_Scheme (Loc,\n-                    Loop_Parameter_Specification =>\n-                      Make_Loop_Parameter_Specification (Loc,\n-                        Defining_Identifier => New_Id,\n-                        Reverse_Present => Reverse_Present (LPS),\n-\n-                        Discrete_Subtype_Definition =>\n-                          Make_Subtype_Indication (Loc,\n-\n-                            Subtype_Mark =>\n-                              New_Reference_To (Standard_Natural, Loc),\n-\n-                            Constraint =>\n-                              Make_Range_Constraint (Loc,\n-                                Range_Expression =>\n-                                  Make_Range (Loc,\n-\n-                                    Low_Bound =>\n-                                      Make_Attribute_Reference (Loc,\n-                                        Prefix =>\n-                                          New_Reference_To (Btype, Loc),\n+            if Is_Discrete_Type (Ltype)\n+              and then Present (Predicate_Function (Ltype))\n+            then\n+               Expand_Predicated_Loop (N);\n+\n+            --  Handle the case where we have a for loop with the range type\n+            --  being an enumeration type with non-standard representation.\n+            --  In this case we expand:\n+\n+            --    for x in [reverse] a .. b loop\n+            --       ...\n+            --    end loop;\n+\n+            --  to\n+\n+            --    for xP in [reverse] integer\n+            --      range etype'Pos (a) .. etype'Pos (b)\n+            --    loop\n+            --       declare\n+            --          x : constant etype := Pos_To_Rep (xP);\n+            --       begin\n+            --          ...\n+            --       end;\n+            --    end loop;\n+\n+            elsif Is_Enumeration_Type (Btype)\n+              and then Present (Enum_Pos_To_Rep (Btype))\n+            then\n+               New_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name (Chars (Loop_Id), 'P'));\n \n-                                        Attribute_Name => Name_Pos,\n+               --  If the type has a contiguous representation, successive\n+               --  values can be generated as offsets from the first literal.\n \n-                                        Expressions => New_List (\n-                                          Relocate_Node\n-                                            (Type_Low_Bound (Ltype)))),\n+               if Has_Contiguous_Rep (Btype) then\n+                  Expr :=\n+                     Unchecked_Convert_To (Btype,\n+                       Make_Op_Add (Loc,\n+                         Left_Opnd =>\n+                            Make_Integer_Literal (Loc,\n+                              Enumeration_Rep (First_Literal (Btype))),\n+                         Right_Opnd => New_Reference_To (New_Id, Loc)));\n+               else\n+                  --  Use the constructed array Enum_Pos_To_Rep\n \n-                                    High_Bound =>\n-                                      Make_Attribute_Reference (Loc,\n-                                        Prefix =>\n-                                          New_Reference_To (Btype, Loc),\n+                  Expr :=\n+                    Make_Indexed_Component (Loc,\n+                      Prefix      =>\n+                        New_Reference_To (Enum_Pos_To_Rep (Btype), Loc),\n+                      Expressions =>\n+                        New_List (New_Reference_To (New_Id, Loc)));\n+               end if;\n \n-                                        Attribute_Name => Name_Pos,\n+               Rewrite (N,\n+                 Make_Loop_Statement (Loc,\n+                   Identifier => Identifier (N),\n \n-                                        Expressions => New_List (\n-                                          Relocate_Node\n-                                            (Type_High_Bound (Ltype))))))))),\n+                   Iteration_Scheme =>\n+                     Make_Iteration_Scheme (Loc,\n+                       Loop_Parameter_Specification =>\n+                         Make_Loop_Parameter_Specification (Loc,\n+                           Defining_Identifier => New_Id,\n+                           Reverse_Present => Reverse_Present (LPS),\n \n-                Statements => New_List (\n-                  Make_Block_Statement (Loc,\n-                    Declarations => New_List (\n-                      Make_Object_Declaration (Loc,\n-                        Defining_Identifier => Loop_Id,\n-                        Constant_Present    => True,\n-                        Object_Definition   => New_Reference_To (Ltype, Loc),\n-                        Expression          => Expr)),\n+                           Discrete_Subtype_Definition =>\n+                             Make_Subtype_Indication (Loc,\n+\n+                               Subtype_Mark =>\n+                                 New_Reference_To (Standard_Natural, Loc),\n+\n+                               Constraint =>\n+                                 Make_Range_Constraint (Loc,\n+                                   Range_Expression =>\n+                                     Make_Range (Loc,\n+\n+                                       Low_Bound =>\n+                                         Make_Attribute_Reference (Loc,\n+                                           Prefix =>\n+                                             New_Reference_To (Btype, Loc),\n+\n+                                           Attribute_Name => Name_Pos,\n+\n+                                           Expressions => New_List (\n+                                             Relocate_Node\n+                                               (Type_Low_Bound (Ltype)))),\n+\n+                                       High_Bound =>\n+                                         Make_Attribute_Reference (Loc,\n+                                           Prefix =>\n+                                             New_Reference_To (Btype, Loc),\n+\n+                                           Attribute_Name => Name_Pos,\n+\n+                                           Expressions => New_List (\n+                                             Relocate_Node\n+                                               (Type_High_Bound\n+                                                  (Ltype))))))))),\n+\n+                   Statements => New_List (\n+                     Make_Block_Statement (Loc,\n+                       Declarations => New_List (\n+                         Make_Object_Declaration (Loc,\n+                           Defining_Identifier => Loop_Id,\n+                           Constant_Present    => True,\n+                           Object_Definition   =>\n+                             New_Reference_To (Ltype, Loc),\n+                           Expression          => Expr)),\n+\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Statements (N)))),\n+\n+                   End_Label => End_Label (N)));\n+               Analyze (N);\n \n-                    Handled_Statement_Sequence =>\n-                      Make_Handled_Sequence_Of_Statements (Loc,\n-                        Statements => Statements (N)))),\n+            --  Nothing to do with other cases of for loops\n \n-                End_Label => End_Label (N)));\n-            Analyze (N);\n+            else\n+               null;\n+            end if;\n          end;\n \n       --  Second case, if we have a while loop with Condition_Actions set, then\n@@ -3162,13 +3187,224 @@ package body Exp_Ch5 is\n             Analyze (N);\n          end;\n \n+      --  Here to deal with iterator case\n+\n       elsif Present (Isc)\n         and then Present (Iterator_Specification (Isc))\n       then\n          Expand_Iterator_Loop (N);\n       end if;\n    end Expand_N_Loop_Statement;\n \n+   ----------------------------\n+   -- Expand_Predicated_Loop --\n+   ----------------------------\n+\n+   --  Note: the expander can handle generation of loops over predicated\n+   --  subtypes for both the dynamic and static cases. Depending on what\n+   --  we decide is allowed in Ada 2012 mode and/or extentions allowed\n+   --  mode, the semantic analyzer may disallow one or both forms.\n+\n+   procedure Expand_Predicated_Loop (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Isc     : constant Node_Id    := Iteration_Scheme (N);\n+      LPS     : constant Node_Id    := Loop_Parameter_Specification (Isc);\n+      Loop_Id : constant Entity_Id  := Defining_Identifier (LPS);\n+      Ltype   : constant Entity_Id  := Etype (Loop_Id);\n+      Stat    : constant List_Id    := Static_Predicate (Ltype);\n+      Stmts   : constant List_Id    := Statements (N);\n+\n+   begin\n+      --  Case of iteration over non-static predicate. In this case we\n+      --  generate the sequence:\n+\n+      --     for J in Ltype'First .. Ltype'Last loop\n+      --        if Ltype_Predicate_Function (J) then\n+      --           body;\n+      --        end if;\n+      --     end loop;\n+\n+      if No (Stat) then\n+\n+         --  The analyzer already expanded the First/Last, so all we have\n+         --  to do is wrap the body within the predicate function test.\n+\n+         Set_Statements (N, New_List (\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Predicate_Call (Ltype, New_Occurrence_Of (Loop_Id, Loc)),\n+             Then_Statements => Stmts)));\n+         Analyze (First (Statements (N)));\n+\n+      --  For expansion over a static predicate we generate the following\n+\n+      --     declare\n+      --        J : Ltype := min-val;\n+      --     begin\n+      --        loop\n+      --           body\n+      --           case J is\n+      --              when endpoint => J := startpoint;\n+      --              when endpoint => J := startpoint;\n+      --              ...\n+      --              when max-val  => exit;\n+      --              when others   => J := Lval'Succ (J);\n+      --           end case;\n+      --        end loop;\n+      --     end;\n+\n+      --  To make this a little clearer, let's take a specific example:\n+\n+      --        type Int is range 1 .. 10;\n+      --        subtype L is Int with\n+      --          predicate => L in 3 | 10 | 5 .. 7;\n+      --          ...\n+      --        for L in StaticP loop\n+      --           Put_Line (\"static:\" & J'Img);\n+      --        end loop;\n+\n+      --  In this case, the loop is transformed into\n+\n+      --     begin\n+      --        J : L := 3;\n+      --        loop\n+      --           body\n+      --           case J is\n+      --              when 3  => J := 5;\n+      --              when 7  => J := 10;\n+      --              when 10 => exit;\n+      --              when others  => J := L'Succ (J);\n+      --           end case;\n+      --        end loop;\n+      --     end;\n+\n+      else\n+         Static_Predicate : declare\n+            S    : Node_Id;\n+            D    : Node_Id;\n+            P    : Node_Id;\n+            Alts : List_Id;\n+            Cstm : Node_Id;\n+\n+            function Lo_Val (N : Node_Id) return Node_Id;\n+            --  Given static expression or static range, returns an identifier\n+            --  whose value is the low bound of the expression value or range.\n+\n+            function Hi_Val (N : Node_Id) return Node_Id;\n+            --  Given static expression or static range, returns an identifier\n+            --  whose value is the high bound of the expression value or range.\n+\n+            ------------\n+            -- Hi_Val --\n+            ------------\n+\n+            function Hi_Val (N : Node_Id) return Node_Id is\n+            begin\n+               if Is_Static_Expression (N) then\n+                  return New_Copy (N);\n+               else\n+                  pragma Assert (Nkind (N) = N_Range);\n+                  return New_Copy (High_Bound (N));\n+               end if;\n+            end Hi_Val;\n+\n+            ------------\n+            -- Lo_Val --\n+            ------------\n+\n+            function Lo_Val (N : Node_Id) return Node_Id is\n+            begin\n+               if Is_Static_Expression (N) then\n+                  return New_Copy (N);\n+               else\n+                  pragma Assert (Nkind (N) = N_Range);\n+                  return New_Copy (Low_Bound (N));\n+               end if;\n+            end Lo_Val;\n+\n+         --  Start of processing for Static_Predicate\n+\n+         begin\n+            --  Convert loop identifier to normal variable and reanalyze it so\n+            --  that this conversion works. We have to use the same defining\n+            --  identifier, since there may be references in the loop body.\n+\n+            Set_Analyzed (Loop_Id, False);\n+            Set_Ekind    (Loop_Id, E_Variable);\n+\n+            --  Loop to create branches of case statement\n+\n+            Alts := New_List;\n+            P := First (Stat);\n+            while Present (P) loop\n+               if No (Next (P)) then\n+                  S := Make_Exit_Statement (Loc);\n+               else\n+                  S :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                      Expression => Lo_Val (Next (P)));\n+                  Set_Suppress_Assignment_Checks (S);\n+               end if;\n+\n+               Append_To (Alts,\n+                 Make_Case_Statement_Alternative (Loc,\n+                   Statements       => New_List (S),\n+                   Discrete_Choices => New_List (Hi_Val (P))));\n+\n+               Next (P);\n+            end loop;\n+\n+            --  Add others choice\n+\n+            S :=\n+               Make_Assignment_Statement (Loc,\n+                 Name       => New_Occurrence_Of (Loop_Id, Loc),\n+                 Expression =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ltype, Loc),\n+                     Attribute_Name => Name_Succ,\n+                     Expressions    => New_List (\n+                       New_Occurrence_Of (Loop_Id, Loc))));\n+            Set_Suppress_Assignment_Checks (S);\n+\n+            Append_To (Alts,\n+              Make_Case_Statement_Alternative (Loc,\n+                Discrete_Choices => New_List (Make_Others_Choice (Loc)),\n+                Statements       => New_List (S)));\n+\n+            --  Construct case statement and append to body statements\n+\n+            Cstm :=\n+              Make_Case_Statement (Loc,\n+                Expression   => New_Occurrence_Of (Loop_Id, Loc),\n+                Alternatives => Alts);\n+            Append_To (Stmts, Cstm);\n+\n+            --  Rewrite the loop\n+\n+            D :=\n+               Make_Object_Declaration (Loc,\n+                 Defining_Identifier => Loop_Id,\n+                 Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n+                 Expression          => Lo_Val (First (Stat)));\n+            Set_Suppress_Assignment_Checks (D);\n+\n+            Rewrite (N,\n+              Make_Block_Statement (Loc,\n+                Declarations               => New_List (D),\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (\n+                      Make_Loop_Statement (Loc,\n+                        Statements => Stmts,\n+                        End_Label  => Empty)))));\n+\n+            Analyze (N);\n+         end Static_Predicate;\n+      end if;\n+   end Expand_Predicated_Loop;\n+\n    ------------------------------\n    -- Make_Tag_Ctrl_Assignment --\n    ------------------------------"}, {"sha": "fb91ce7a47a7efe41610a44d30fd3759349cfb9e", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -986,6 +986,8 @@ package body Exp_Dist is\n             Current_Subprogram_Number := Current_Subprogram_Number + 1;\n          end if;\n \n+         --  Need to handle the case of nested packages???\n+\n          Next (Current_Declaration);\n       end loop;\n    end Add_Calling_Stubs_To_Declarations;\n@@ -3916,6 +3918,8 @@ package body Exp_Dist is\n                Current_Subprogram_Number := Current_Subprogram_Number + 1;\n             end if;\n \n+            --  Need to handle case of a nested package???\n+\n             Next (Current_Declaration);\n          end loop;\n \n@@ -6903,6 +6907,8 @@ package body Exp_Dist is\n                Current_Subprogram_Number := Current_Subprogram_Number + 1;\n             end if;\n \n+            --  Need to handle case of a nested package???\n+\n             Next (Current_Declaration);\n          end loop;\n "}, {"sha": "93a56d374d6d9eb7ee250a3e9d4dc9f128e1bd6a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1616, "deletions": 0, "changes": 1616, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -81,6 +81,7 @@ AdaCore\n * Interfacing to Other Languages::\n * Specialized Needs Annexes::\n * Implementation of Specific Ada Features::\n+* Implementation of Ada 2012 Features::\n * Obsolescent Features::\n * GNU Free Documentation License::\n * Index::\n@@ -470,6 +471,8 @@ Implementation of Specific Ada Features\n * The Size of Discriminated Records with Default Discriminants::\n * Strict Conformance to the Ada Reference Manual::\n \n+Implementation of Ada 2012 Features\n+\n Obsolescent Features\n \n GNU Free Documentation License\n@@ -586,6 +589,10 @@ of the specialized needs annexes.\n to GNAT's implementation of machine code insertions, tasking, and several\n other features.\n \n+@item\n+@ref{Implementation of Ada 2012 Features}, describes the status of the\n+GNAT implementation of the Ada 2012 language standard.\n+\n @item\n @ref{Obsolescent Features} documents implementation dependent features,\n including pragmas and attributes, which are considered obsolescent, since\n@@ -16336,6 +16343,1615 @@ machines that are not fully compliant with this standard, such as Alpha, the\n behavior (although at the cost of a significant performance penalty), so\n infinite and and NaN values are properly generated.\n \n+\n+@node Implementation of Ada 2012 Features\n+@chapter Implementation of Ada 2012 Features\n+@cindex Ada 2012 implementation status\n+\n+This chapter contains a complete list of Ada 2012 features that have been\n+implemented as of GNAT version 6.4. Generally, these features are only\n+available if the @option{-gnat12} (Ada 2012 features enabled) flag is set\n+@cindex @option{-gnat12} option\n+or if the configuration pragma @code{Ada_2012} is used.\n+@cindex pragma @code{Ada_2012}\n+@cindex configuration pragma @code{Ada_2012}\n+@cindex @code{Ada_2012} configuration pragma\n+However, new pragmas, attributes, and restrictions are\n+unconditionally available, since the Ada 95 standard allows the addition of\n+new pragmas, attributes, and restrictions (there are exceptions, which are\n+documented in the individual descriptions), and also certain packages\n+were made available in earlier versions of Ada.\n+\n+An ISO date (YYYY-MM-DD) appears in parentheses on the description line.\n+This date shows the implementation date of the feature. Any wavefront\n+subsequent to this date will contain the indicated feature, as will any\n+subsequent releases. A date of 0000-00-00 means that GNAT has always\n+implemented the feature, or implemented it as soon as it appeared as a\n+binding interpretation.\n+\n+Each feature corresponds to an Ada Issue (``AI'') approved by the Ada\n+standardization group (ISO/IEC JTC1/SC22/WG9) for inclusion in Ada 2012.\n+The features are ordered based on the relevant sections of the Ada\n+Reference Manual (``RM'').  When a given AI relates to multiple points\n+in the RM, the earliest is used.\n+\n+A complete description of the AIs may be found in\n+@url{www.ada-auth.org/ai05-summary.html}.\n+\n+@itemize @bullet\n+\n+@item\n+@emph{AI-0176 Quantified expressions (2010-09-29)}\n+@cindex AI-0176 (Ada 2012 feature)\n+\n+@noindent\n+  Both universally and existentially quantified expressions are implemented.\n+  They use the new syntax for iterators proposed in AI05-139-2, as well as\n+  the standard Ada loop syntax.\n+\n+@noindent\n+  RM References:  1.01.04 (12)   2.09 (2/2)   4.04 (7)   4.05.09 (0)\n+\n+@item\n+@emph{AI-0079 Allow @i{other_format} characters in source (2010-07-10)}\n+@cindex AI-0079 (Ada 2012 feature)\n+\n+@noindent\n+  Wide characters in the unicode category @i{other_format} are now allowed in\n+  source programs between tokens, but not within a token such as an identifier.\n+\n+@noindent\n+  RM References:  2.01 (4/2)   2.02 (7)\n+\n+@item\n+@emph{AI-0091 Do not allow @i{other_format} in identifiers (0000-00-00)}\n+@cindex AI-0091 (Ada 2012 feature)\n+\n+@noindent\n+  Wide characters in the unicode category @i{other_format} are not permitted\n+  within  an identifier, since this can be a security problem. The error\n+  message for this case has been improved to be more specific, but GNAT has\n+  never allowed such characters to appear in identifiers.\n+\n+@noindent\n+  RM References:  2.03 (3.1/2)   2.03 (4/2)   2.03 (5/2)   2.03 (5.1/2)   2.03 (5.2/2)   2.03 (5.3/2)   2.09 (2/2)\n+\n+@item\n+@emph{AI-0100 Placement of pragmas  (2010-07-01)}\n+@cindex AI-0100 (Ada 2012 feature)\n+\n+@noindent\n+  This AI is an earlier version of AI-163. It simplifies the rules\n+  for legal placement of pragmas. In the case of lists that allow pragmas, if\n+  the list may have no elements, then the list may consist solely of pragmas.\n+\n+@noindent\n+  RM References:  2.08 (7)\n+\n+@item\n+@emph{AI-0163 Pragmas in place of null (2010-07-01)}\n+@cindex AI-0163 (Ada 2012 feature)\n+\n+@noindent\n+  A statement sequence may be composed entirely of pragmas. It is no longer\n+  necessary to add a dummy @code{null} statement to make the sequence legal.\n+\n+@noindent\n+  RM References:  2.08 (7)   2.08 (16)\n+\n+\n+@item\n+@emph{AI-0080 ``View of'' not needed if clear from context (0000-00-00)}\n+@cindex AI-0080 (Ada 2012 feature)\n+\n+@noindent\n+  This is an editorial change only, described as non-testable in the AI.\n+\n+@noindent\n+  RM References:  3.01 (7)\n+\n+\n+@item\n+@emph{AI-0183 Aspect specifications (2010-08-16)}\n+@cindex AI-0183 (Ada 2012 feature)\n+\n+@noindent\n+  Aspect specifications have been fully implemented except for pre and post-\n+  conditions, and type invariants, which have their own separate AI's. All\n+  forms of declarations listed in the AI are supported. The following is a\n+  list of the aspects supported (with GNAT implementation aspects marked)\n+\n+@multitable {@code{Preelaborable_Initialization}} {--GNAT}\n+@item @code{Ada_2005} @tab                      -- GNAT\n+@item @code{Ada_2012} @tab                      -- GNAT\n+@item @code{Address} @tab\n+@item @code{Alignment} @tab\n+@item @code{Atomic} @tab\n+@item @code{Atomic_Components} @tab\n+@item @code{Bit_Order} @tab\n+@item @code{Component_Size} @tab\n+@item @code{Discard_Names} @tab\n+@item @code{External_Tag} @tab\n+@item @code{Favor_Top_Level} @tab               -- GNAT\n+@item @code{Inline} @tab\n+@item @code{Inline_Always} @tab                 -- GNAT\n+@item @code{Invariant} @tab\n+@item @code{Machine_Radix} @tab\n+@item @code{No_Return} @tab\n+@item @code{Object_Size} @tab                   -- GNAT\n+@item @code{Pack} @tab\n+@item @code{Persistent_BSS} @tab                -- GNAT\n+@item @code{Post} @tab\n+@item @code{Pre} @tab\n+@item @code{Predicate} @tab\n+@item @code{Preelaborable_Initialization} @tab\n+@item @code{Pure_Function} @tab                 -- GNAT\n+@item @code{Shared} @tab                        -- GNAT\n+@item @code{Size} @tab\n+@item @code{Storage_Pool} @tab\n+@item @code{Storage_Size} @tab\n+@item @code{Stream_Size} @tab\n+@item @code{Suppress} @tab\n+@item @code{Suppress_Debug_Info} @tab           -- GNAT\n+@item @code{Unchecked_Union} @tab\n+@item @code{Universal_Aliasing} @tab            -- GNAT\n+@item @code{Unmodified} @tab                    -- GNAT\n+@item @code{Unreferenced} @tab                  -- GNAT\n+@item @code{Unreferenced_Objects} @tab          -- GNAT\n+@item @code{Unsuppress} @tab\n+@item @code{Value_Size} @tab                    -- GNAT\n+@item @code{Volatile} @tab\n+@item @code{Volatile_Components}\n+@item @code{Warnings} @tab                      -- GNAT\n+@end multitable\n+\n+@noindent\n+  Note that for aspects with an expression, e.g. @code{Size}, the expression is\n+  treated like a default expression (visibility is analyzed at the point of\n+  occurrence of the aspect, but evaluation of the expression occurs at the\n+  freeze point of the entity involved.\n+\n+@noindent\n+  RM References:  3.02.01 (3)   3.02.02 (2)   3.03.01 (2/2)   3.08 (6)\n+  3.09.03 (1.1/2)   6.01 (2/2)   6.07 (2/2)   9.05.02 (2/2)   7.01 (3)   7.03\n+  (2)   7.03 (3)   9.01 (2/2)   9.01 (3/2)   9.04 (2/2)   9.04 (3/2)\n+  9.05.02 (2/2)   11.01 (2)   12.01 (3)   12.03 (2/2)   12.04 (2/2)   12.05 (2)\n+  12.06 (2.1/2)   12.06 (2.2/2)   12.07 (2)   13.01 (0.1/2)   13.03 (5/1)\n+  13.03.01 (0)\n+\n+\n+@item\n+@emph{AI-0128 Inequality is a primitive operation (0000-00-00)}\n+@cindex AI-0128 (Ada 2012 feature)\n+\n+@noindent\n+  If an equality operator (\"=\") is declared for a type, then the implicitly\n+  declared inequality operator (\"/=\") is a primitive operation of the type.\n+  This is the only reasonable interpretation, and is the one always implemented\n+  by GNAT, but the RM was not entirely clear in making this point.\n+\n+@noindent\n+  RM References:  3.02.03 (6)   6.06 (6)\n+\n+@item\n+@emph{AI-0003 Qualified expressions as names (2010-07-11)}\n+@cindex AI-0003 (Ada 2012 feature)\n+\n+@noindent\n+   In Ada 2012, a qualified expression is considered to be syntatically a name,\n+   meaning that constructs such as @code{A'(F(X)).B} are now legal. This is\n+   useful in disambiguating some cases of overloading.\n+\n+@noindent\n+  RM References:  3.03 (11)   3.03 (21)   4.01 (2)   4.04 (7)   4.07 (3)\n+  5.04 (7)\n+\n+@item\n+@emph{AI-0120 Constant instance of protected object (0000-00-00)}\n+@cindex AI-0120 (Ada 2012 feature)\n+\n+@noindent\n+  This is an RM editorial change only. The section that lists objects that are\n+  constant failed to include the current instance of a protected object\n+  within a protected function. This has always been treated as a constant\n+  in GNAT.\n+\n+@noindent\n+  RM References:  3.03 (21)\n+\n+@item\n+@emph{AI-0008 General access to constrained objects (0000-00-00)}\n+@cindex AI-0008 (Ada 2012 feature)\n+\n+@noindent\n+  The wording in the RM implied that if you have a general access to a\n+  constrained object, it could be used to modify the discriminants. This was\n+  obviously not intended. @code{Constraint_Error} should be raised, and GNAT\n+  has always done so in this situation.\n+\n+@noindent\n+  RM References:  3.03 (23)   3.10.02 (26/2)   4.01 (9)   6.04.01 (17)   8.05.01 (5/2)\n+\n+\n+@item\n+@emph{AI-0093 Additional rules use immutably limited (0000-00-00)}\n+@cindex AI-0093 (Ada 2012 feature)\n+\n+@noindent\n+  This is an editorial change only, to make more widespread use of the Ada 2012\n+  ``immutably limited''.\n+\n+@noindent\n+  RM References:  3.03 (23.4/3)\n+\n+\n+\n+@item\n+@emph{AI-0096 Deriving from formal private types (2010-07-20)}\n+@cindex AI-0096 (Ada 2012 feature)\n+\n+@noindent\n+  In general it is illegal for a type derived from a formal limited type to be\n+  nonlimited.  This AI makes an exception to this rule: derivation is legal\n+  if it appears in the private part of the generic, and the formal type is not\n+  tagged. If the type is tagged, the legality check must be applied to the\n+  private part of the package.\n+\n+@noindent\n+  RM References:  3.04 (5.1/2)   6.02 (7)\n+\n+\n+@item\n+@emph{AI-0181 Soft hyphen is a non-graphic character (2010-07-23)}\n+@cindex AI-0181 (Ada 2012 feature)\n+\n+@noindent\n+  From Ada 2005 on, soft hyphen is considered a non-graphic character, which\n+  means that it has a special name (@code{SOFT_HYPHEN}) in conjunction with the\n+  @code{Image} and @code{Value} attributes for the character types. Strictly\n+  speaking this is an inconsistency with Ada 95, but in practice the use of\n+  these attributes is so obscure that it will not cause problems.\n+\n+@noindent\n+  RM References:  3.05.02 (2/2)   A.01 (35/2)   A.03.03 (21)\n+\n+\n+@item\n+@emph{AI-0182 Additional forms for @code{Character'Value} (0000-00-00)}\n+@cindex AI-0182 (Ada 2012 feature)\n+\n+@noindent\n+  This AI allows @code{Character'Value} to accept the string @code{'?'} where\n+  @code{?} is any character including non-graphic control characters. GNAT has\n+  always accepted such strings. It also allows strings such as\n+  @code{HEX_00000041} to be accepted, but GNAT does not take advantage of this\n+  permission and raises @code{Constraint_Error}, as is certainly still\n+  permitted.\n+\n+@noindent\n+  RM References:  3.05 (56/2)\n+\n+\n+@item\n+@emph{AI-0214 Defaulted discriminants for limited tagged (2010-10-01)}\n+@cindex AI-0214 (Ada 2012 feature)\n+\n+@noindent\n+  Ada 2012 relaxes the restriction that forbids discriminants of tagged types\n+  to have default expressions by allowing them when the type is limited. It\n+  is often useful to define a default value for a discriminant even though\n+  it can't be changed by assignment.\n+\n+@noindent\n+  RM References:  3.07 (9.1/2)   3.07.02 (3)\n+\n+\n+@item\n+@emph{AI-0102 Some implicit conversions are illegal (0000-00-00)}\n+@cindex AI-0102 (Ada 2012 feature)\n+\n+@noindent\n+  It is illegal to assign an anonymous access constant to an anonymous access\n+  variable. The RM did not have a clear rule to prevent this, but GNAT has\n+  always generated an error for this usage.\n+\n+@noindent\n+  RM References:  3.07 (16)   3.07.01 (9)   6.04.01 (6)   8.06 (27/2)\n+\n+\n+@item\n+@emph{AI-0158 Generalizing membership tests (2010-09-16)}\n+@cindex AI-0158 (Ada 2012 feature)\n+\n+@noindent\n+  This AI extends the syntax of membership tests to simplify complex conditions\n+  that can be expressed as membership in a subset of values of any type. It\n+  introduces syntax for a list of expressions that may be used in loop contexts\n+  as well.\n+\n+@noindent\n+  RM References:  3.08.01 (5)   4.04 (3)   4.05.02 (3)   4.05.02 (5)   4.05.02 (27)\n+\n+\n+@item\n+@emph{AI-0173 Testing if tags represent abstract types (2010-07-03)}\n+@cindex AI-0173 (Ada 2012 feature)\n+\n+@noindent\n+  The function @code{Ada.Tags.Type_Is_Abstract} returns @code{True} if invoked\n+  with the tag of an abstract type, and @code{False} otherwise.\n+\n+@noindent\n+  RM References:  3.09 (7.4/2)   3.09 (12.4/2)\n+\n+\n+\n+@item\n+@emph{AI-0076 function with controlling result (0000-00-00)}\n+@cindex AI-0076 (Ada 2012 feature)\n+\n+@noindent\n+  This is an editorial change only. The RM defines calls with controlling\n+  results, but uses the term ``function with controlling result'' without an\n+  explicit definition.\n+\n+@noindent\n+  RM References:  3.09.02 (2/2)\n+\n+\n+@item\n+@emph{AI-0126 Dispatching with no declared operation (0000-00-00)}\n+@cindex AI-0126 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies dispatching rules, and simply confirms that dispatching\n+  executes the operation of the parent type when there is no explicitly or\n+  implicitly declared operation for the descendant type. This has always been\n+  the case in all versions of GNAT.\n+\n+@noindent\n+  RM References:  3.09.02 (20/2)   3.09.02 (20.1/2)   3.09.02 (20.2/2)\n+\n+\n+@item\n+@emph{AI-0097 Treatment of abstract null extension (2010-07-19)}\n+@cindex AI-0097 (Ada 2012 feature)\n+\n+@noindent\n+  The RM as written implied that in some cases it was possible to create an\n+  object of an abstract type, by having an abstract extension inherit a non-\n+  abstract constructor from its parent type. This mistake has been corrected\n+  in GNAT and in the RM, and this construct is now illegal.\n+\n+@noindent\n+  RM References:  3.09.03 (4/2)\n+\n+\n+@item\n+@emph{AI-0203 Extended return cannot be abstract (0000-00-00)}\n+@cindex AI-0203 (Ada 2012 feature)\n+\n+@noindent\n+  A return_subtype_indication cannot denote an abstract subtype. GNAT has never\n+  permitted such usage.\n+\n+@noindent\n+  RM References:  3.09.03 (8/3)\n+\n+\n+@item\n+@emph{AI-0198 Inheriting abstract operators  (0000-00-00)}\n+@cindex AI-0198 (Ada 2012 feature)\n+\n+@noindent\n+  This AI resolves a conflict between two rules involving inherited abstract\n+  operations and predefined operators. If a derived numeric type inherits\n+  an abstract operator, it overrides the predefined one. This interpretation\n+  was always the one implemented in GNAT.\n+\n+@noindent\n+  RM References:  3.09.03 (4/3)\n+\n+@item\n+@emph{AI-0073 Functions returning abstract types (2010-07-10)}\n+@cindex AI-0073 (Ada 2012 feature)\n+\n+@noindent\n+  This AI covers a number of issues regarding returning abstract types. In\n+  particular generic fucntions cannot have abstract result types or access\n+  result types designated an abstract type. There are some other cases which\n+  are detailed in the AI. Note that this binding interpretation has not been\n+  retrofitted to operate before Ada 2012 mode, since it caused a significant\n+  number of regressions.\n+\n+@noindent\n+  RM References:  3.09.03 (8)   3.09.03 (10)   6.05 (8/2)\n+\n+\n+@item\n+@emph{AI-0070 Elaboration of interface types (0000-00-00)}\n+@cindex AI-0070 (Ada 2012 feature)\n+\n+@noindent\n+  This is an editorial change only, there are no testable consequences short of\n+  checking for the absence of generated code for an interface declaration.\n+\n+@noindent\n+  RM References:  3.09.04 (18/2)\n+\n+\n+@item\n+@emph{AI-0208 Characteristics of incomplete views (0000-00-00)}\n+@cindex AI-0208 (Ada 2012 feature)\n+\n+@noindent\n+  The wording in the Ada 2005 RM concerning characteristics of incomplete views\n+  was incorrect and implied that some programs intended to be legal were now\n+  illegal. GNAT had never considered such programs illegal, so it has always\n+  implemented the intent of this AI.\n+\n+@noindent\n+  RM References:  3.10.01 (2.4/2)   3.10.01 (2.6/2)\n+\n+\n+@item\n+@emph{AI-0162 Incomplete type completed by partial view (2010-09-15)}\n+@cindex AI-0162 (Ada 2012 feature)\n+\n+@noindent\n+  Incomplete types are made more useful by allowing them to be completed by\n+  private types and private extensions.\n+\n+@noindent\n+  RM References:  3.10.01 (2.5/2)   3.10.01 (2.6/2)   3.10.01 (3)   3.10.01 (4/2)\n+\n+\n+\n+@item\n+@emph{AI-0098 Anonymous subprogram access restrictions (0000-00-00)}\n+@cindex AI-0098 (Ada 2012 feature)\n+\n+@noindent\n+  An unintentional omission in the RM implied some inconsistent restrictions on\n+  the use of anonymous access to subprogram values. These restrictions were not\n+  intentional, and have never been enforced by GNAT.\n+\n+@noindent\n+  RM References:  3.10.01 (6)   3.10.01 (9.2/2)\n+\n+\n+@item\n+@emph{AI-0199 Aggregate with anonymous access components (2010-07-14)}\n+@cindex AI-0199 (Ada 2012 feature)\n+\n+@noindent\n+  A choice list in a record aggregate can include several components of\n+  (distinct) anonymous access types as long as they have matching designated\n+  subtypes.\n+\n+@noindent\n+  RM References:  4.03.01 (16)\n+\n+\n+@item\n+@emph{AI-0220 Needed components for aggregates (0000-00-00)}\n+@cindex AI-0220 (Ada 2012 feature)\n+\n+@noindent\n+  This AI addresses a wording problem in the RM that appears to permit some\n+  complex cases of aggregates with non-static discriminants. GNAT has always\n+  implemented the intended semantics.\n+\n+@noindent\n+  RM References:  4.03.01 (17)\n+\n+@item\n+@emph{AI-0147 Conditional expressions (2009-03-29)}\n+@cindex AI-0147 (Ada 2012 feature)\n+\n+@noindent\n+  Conditional expressions are permitted. The form of such an expression is:\n+\n+@smallexample\n+    (@b{if} @i{expr} @b{then} @i{expr} @{@b{elsif} @i{expr} @b{then} @i{expr}@} [@b{else} @i{expr}])\n+@end smallexample\n+\n+  The parentheses can be omitted in contexts where parentheses are present\n+  anyway, such as subprogram arguments and pragma arguments. If the @b{else}\n+  clause is omitted, @b{else True} is assumed;\n+  thus @code{(@b{if} A @b{then} B)} is a way to conveniently represent\n+  @emph{(A implies B)} in standard logic.\n+\n+@noindent\n+  RM References:  4.03.03 (15)   4.04 (1)   4.04 (7)   4.05.07 (0)   4.07 (2)\n+  4.07 (3)   4.09 (12)   4.09 (33)   5.03 (3)   5.03 (4)   7.05 (2.1/2)\n+\n+\n+@item\n+@emph{AI-0037 Out-of-range box associations in aggregate (0000-00-00)}\n+@cindex AI-0037 (Ada 2012 feature)\n+\n+@noindent\n+  This AI confirms that an association of the form @code{Indx => <>} in an\n+  array aggregate must raise @code{Constraint_Error} if @code{Indx}\n+  is out of range. The RM specified a range check on other associations, but\n+  not when the value of the association was defaulted. GNAT has always inserted\n+  a constraint check on the index value.\n+\n+@noindent\n+  RM References:  4.03.03 (29)\n+\n+\n+@item\n+@emph{AI-0123 Composability of equality (2010-04-13)}\n+@cindex AI-0123 (Ada 2012 feature)\n+\n+@noindent\n+  Equality of untagged record composes, so that the predefined equality for a\n+  composite type that includes a component of some untagged record type\n+  @code{R} uses the equality operation of @code{R} (which may be user-defined\n+  or predefined). This makes the behavior of untagged records identical to that\n+  of tagged types in this respect.\n+\n+  This change is an incompatibility with previous versions of Ada, but it\n+  corrects a non-uniformity that was often a source of confusion. Analysis of\n+  a large number of industrial programs indicates that in those rare cases\n+  where a composite type had an untagged record component with a user-defined\n+  equality, either there was no use of the composite equality, or else the code\n+  expected the same composability as for tagged types, and thus had a bug that\n+  would be fixed by this change.\n+\n+@noindent\n+  RM References:  4.05.02 (9.7/2)   4.05.02 (14)   4.05.02 (15)   4.05.02 (24)\n+  8.05.04 (8)\n+\n+\n+@item\n+@emph{AI-0088 The value of exponentiation (0000-00-00)}\n+@cindex AI-0088 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the equivalence rule given for the dynamic semantics of\n+  exponentiation: the value of the operation can be obtained by repeated\n+  multiplication, but the operation can be implemented otherwise (for example\n+  using the familiar divide-by-two-and-square algorithm, even if this is less\n+  accurate), and does not imply repeated reads of a volatile base.\n+\n+@noindent\n+  RM References:  4.05.06 (11)\n+\n+@item\n+@emph{AI-0188 Case expressions (2010-01-09)}\n+@cindex AI-0188 (Ada 2012 feature)\n+\n+@noindent\n+  Case expressions are permitted. This allows use of constructs such as:\n+@smallexample\n+  X := (@b{case} Y @b{is when} 1 => 2, @b{when} 2 => 3, @b{when others} => 31)\n+@end smallexample\n+\n+@noindent\n+  RM References:  4.05.07 (0)   4.05.08 (0)   4.09 (12)   4.09 (33)\n+\n+@item\n+@emph{AI-0104 Null exclusion and uninitialized allocator (2010-07-15)}\n+@cindex AI-0104 (Ada 2012 feature)\n+\n+@noindent\n+  The assignment @code{Ptr := @b{new not null} Some_Ptr;} will raise\n+  @code{Constraint_Error} because the default value of the allocated object is\n+  @b{null}. This useless construct is illegal in Ada 2012.\n+\n+@noindent\n+  RM References:  4.08 (2)\n+\n+@item\n+@emph{AI-0157 Allocation/Deallocation from empty pool (2010-07-11)}\n+@cindex AI-0157 (Ada 2012 feature)\n+\n+@noindent\n+  Allocation and Deallocation from an empty storage pool (i.e. allocation or\n+  deallocation of a pointer for which a static storage size clause of zero\n+  has been given) is now illegal and is detected as such. GNAT\n+  previously gave a warning but not an error.\n+\n+@noindent\n+  RM References:  4.08 (5.3/2)   13.11.02 (4)   13.11.02 (17)\n+\n+@item\n+@emph{AI-0179 Statement not required after label (2010-04-10)}\n+@cindex AI-0179 (Ada 2012 feature)\n+\n+@noindent\n+  It is not necessary to have a statement following a label, so a label\n+  can appear at the end of a statement sequence without the need for putting a\n+  null statement afterwards, but it is not allowable to have only labels and\n+  no real statements in a statement sequence.\n+\n+@noindent\n+  RM References:  5.01 (2)\n+\n+\n+@item\n+@emph{AI-139-2 Syntactic sugar for iterators (2010-09-29)}\n+@cindex AI-139-2 (Ada 2012 feature)\n+\n+@noindent\n+  The new syntax for iterating over arrays and containers is now implemented.\n+  Iteration over containers is for now limited to read-only iterators. Only\n+  default iterators are supported, with the syntax:  @code{@b{for} Elem @b{of} C}.\n+\n+@noindent\n+  RM References:  5.05\n+\n+@item\n+@emph{AI-0134 Profiles must match for full conformance (0000-00-00)}\n+@cindex AI-0134 (Ada 2012 feature)\n+\n+@noindent\n+  For full conformance, the profiles of anonymous-access-to-subprogram\n+  parameters must match. GNAT has always enforced this rule.\n+\n+@noindent\n+  RM References:  6.03.01 (18)\n+\n+@item\n+@emph{AI-0207 Mode conformance and access constant (0000-00-00)}\n+@cindex AI-0207 (Ada 2012 feature)\n+\n+@noindent\n+  This AI confirms that access_to_constant indication must match for mode\n+  conformance. This was implemented in GNAT when the qualifier was originally\n+  introduced in Ada 2005.\n+\n+@noindent\n+  RM References:  6.03.01 (16/2)\n+\n+\n+@item\n+@emph{AI-0046 Null exclusion match for full conformance (2010-07-17)}\n+@cindex AI-0046 (Ada 2012 feature)\n+\n+@noindent\n+  For full conformance, in the case of access parameters, the null exclusion\n+  must match (either both or neither must have @code{@b{not null}}).\n+\n+@noindent\n+  RM References:  6.03.02 (18)\n+\n+\n+@item\n+@emph{AI-0118 The association of parameter associations (0000-00-00)}\n+@cindex AI-0118 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the rules for named associations in subprogram calls and\n+  generic instantiations. The rules have been in place since Ada 83.\n+\n+@noindent\n+  RM References:  6.04.01 (2)   12.03 (9)\n+\n+\n+@item\n+@emph{AI-0196 Null exclusion tests for out parameters (0000-00-00)}\n+@cindex AI-0196 (Ada 2012 feature)\n+\n+@noindent\n+  Null exclusion checks are not made for @code{@b{out}} parameters when\n+  evaluating the actual parameters. GNAT has never generated these checks.\n+\n+@noindent\n+  RM References:  6.04.01 (13)\n+\n+@item\n+@emph{AI-0015 Constant return objects (0000-00-00)}\n+@cindex AI-0015 (Ada 2012 feature)\n+\n+@noindent\n+  The return object declared in an @i{extended_return_statement} may be\n+  declared constant. This was always intended, and GNAT has always allowed it.\n+\n+@noindent\n+  RM References:  6.05 (2.1/2)   3.03 (10/2)   3.03 (21)   6.05 (5/2)\n+  6.05 (5.7/2)\n+\n+\n+@item\n+@emph{AI-0032 Extended return for class-wide functions (0000-00-00)}\n+@cindex AI-0032 (Ada 2012 feature)\n+\n+@noindent\n+  If a function returns a class-wide type, the object of an extended return\n+  statement can be declared with a specific type that is covered by the class-\n+  wide type. This has been implemented in GNAT since the introduction of\n+  extended returns. Note AI-0103 complements this AI by imposing matching\n+  rules for constrained return types.\n+\n+@noindent\n+  RM References:  6.05 (5.2/2)   6.05 (5.3/2)   6.05 (5.6/2)   6.05 (5.8/2)\n+  6.05 (8/2)\n+\n+@item\n+@emph{AI-0103 Static matching for extended return (2010-07-23)}\n+@cindex AI-0103 (Ada 2012 feature)\n+\n+@noindent\n+  If the return subtype of a function is an elementary type or a constrained\n+  type, the subtype indication in an extended return statement must match\n+  statically this return subtype.\n+\n+@noindent\n+  RM References:  6.05 (5.2/2)\n+\n+\n+@item\n+@emph{AI-0058 Abnormal completion of an extended return (0000-00-00)}\n+@cindex AI-0058 (Ada 2012 feature)\n+\n+@noindent\n+  The RM had some incorrect wording implying wrong treatment of abnormal\n+  completion in an extended return. GNAT has always implemented the intended\n+  correct semantics as described by this AI.\n+\n+@noindent\n+  RM References:  6.05 (22/2)\n+\n+\n+@item\n+@emph{AI-0050 Raising Constraingt_Errpr early for function call (0000-00-00)}\n+@cindex AI-0050 (Ada 2012 feature)\n+\n+@noindent\n+  The implementation permissions for raising @code{Constraing_Error} early on a function call when it was clear an exception would be raised were over-permissive and allowed mishandling of discriminants in some cases. GNAT did\n+  not take advantage of these incorrect permissions in any case.\n+\n+@noindent\n+  RM References:  6.05 (24/2)\n+\n+\n+@item\n+@emph{AI-0125 Nonoverridable operations of an ancestor (2010-09-28)}\n+@cindex AI-0125 (Ada 2012 feature)\n+\n+@noindent\n+  In Ada 2012, the declaration of a primitive operation of a type extension\n+  or private extension can also override an inherited primitive that is not\n+  visible at the point of this declaration.\n+\n+@noindent\n+  RM References:  7.03.01 (6)   8.03 (23)   8.03.01 (5/2)   8.03.01 (6/2)\n+\n+@item\n+@emph{AI-0062 Null exclusions and deferred constants (0000-00-00)}\n+@cindex AI-0062 (Ada 2012 feature)\n+\n+@noindent\n+  A full constant may have a null exclusion even if its associated deferred\n+  constant does not. GNAT has always allowed this.\n+\n+@noindent\n+  RM References:  7.04 (6/2)   7.04 (7.1/2)\n+\n+\n+@item\n+@emph{AI-0178 Incomplete views are limited (0000-00-00)}\n+@cindex AI-0178 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the role of incomplete views and plugs an omission in the\n+  RM. GNAT always correctly restricted the use of incomplete views and types.\n+\n+@noindent\n+  RM References:  7.05 (3/2)   7.05 (6/2)\n+\n+@item\n+@emph{AI-0087 Actual for formal nonlimited derived type (2010-07-15)}\n+@cindex AI-0087 (Ada 2012 feature)\n+\n+@noindent\n+  The actual for a formal nonlimited derived type cannot be limited. In\n+  particular, a formal derived type that extends a limited interface but which\n+  is not explicitly limited cannot be instantiated with a limited type.\n+\n+@noindent\n+  RM References:  7.05 (5/2)   12.05.01 (5.1/2)\n+\n+@item\n+@emph{AI-0099 Tag determines whether finalization needed (0000-00-00)}\n+@cindex AI-0099 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies that ``needs finalization'' is part of dynamic semantics,\n+  and therefore depends on the run-time charateristics of an object (i.e. its\n+  tag) and not on its nominal type. As the AI indicates: ``we do not expect\n+  this to affect any implementation''.\n+\n+@noindent\n+  RM References:  7.06.01 (6)   7.06.01 (7)   7.06.01 (8)   7.06.01 (9/2)\n+\n+\n+\n+@item\n+@emph{AI-0064 Redundant finalization rule (0000-00-00)}\n+@cindex AI-0064 (Ada 2012 feature)\n+\n+@noindent\n+  This is an editorial change only. The intended behavior is already checked\n+  by an existing ACATS test, which GNAT has always executed correctly.\n+\n+@noindent\n+  RM References:  7.06.01 (17.1/1)\n+\n+@item\n+@emph{AI-0026 Missing rules for Unchecked_Union (2010-07-07)}\n+@cindex AI-0026 (Ada 2012 feature)\n+\n+@noindent\n+  Record representation clauses concerning Unchecked_Union types cannot mention\n+  the discriminant of the type. The type of a component declared in the variant\n+  part of an Unchecked_Union cannot be controlled, have controlled components,\n+  nor have protected or task parts. If an Unchecked_Union type is declared\n+  within the body of a generic unit or its descendants, then the type of a\n+  component declared in the variant part cannot be a formal private type or a\n+  formal private extension declared within the same generic unit.\n+\n+@noindent\n+  RM References:  7.06 (9.4/2)   B.03.03 (9/2)   B.03.03 (10/2)\n+\n+\n+@item\n+@emph{AI-0205 Extended return declares visible name (0000-00-00)}\n+@cindex AI-0205 (Ada 2012 feature)\n+\n+@noindent\n+  This AI corrects a simple omission in the RM. Return objects have always\n+  been visible within an extended return statement.\n+\n+@noindent\n+  RM References:  8.03 (17)\n+\n+\n+@item\n+@emph{AI-0042 Overriding versus implemented-by (0000-00-00)}\n+@cindex AI-0042 (Ada 2012 feature)\n+\n+@noindent\n+  This AI fixes a wording gap in the RM. An operation of a synchronized\n+  interface can be implemented by a protected or task entry, but the abstract\n+  operation is not being overridden in the usual sense, and it must be stated\n+  separately that this implementation is legal. This has always been the case\n+  in GNAT.\n+\n+@noindent\n+  RM References:  9.01 (9.2/2)   9.04 (11.1/2)\n+\n+@item\n+@emph{AI-0030 Requeue on synchronized interfaces (2010-07-19)}\n+@cindex AI-0030 (Ada 2012 feature)\n+\n+@noindent\n+  Requeue is permitted to a protected, synchronized or task interface primitive\n+  providing it is known that the overriding operation is an entry. Otherwise\n+  the requeue statement has the same effect as a procedure call. Use of pragma\n+  @code{Implemented} provides a way to impose a static requirement on the\n+  overriding operation by adhering to one of the implementation kinds: entry,\n+  protected procedure or any of the above.\n+\n+@noindent\n+  RM References:  9.05 (9)   9.05.04 (2)   9.05.04 (3)   9.05.04 (5)\n+  9.05.04 (6)   9.05.04 (7)   9.05.04 (12)\n+\n+\n+@item\n+@emph{AI-0201 Independence of atomic object components (2010-07-22)}\n+@cindex AI-0201 (Ada 2012 feature)\n+\n+@noindent\n+  If an Atomic object has a pragma @code{Pack} or a @code{Component_Size}\n+  attribute, then individual components may not be addressable by independent\n+  tasks. However, if the representation clause has no effect (is confirming),\n+  then independence is not compromised. Furthermore, in GNAT, specification of\n+  other appropriately addressable component sizes (e.g. 16 for 8-bit\n+  characters) also preserves independence. GNAT now gives very clear warnings\n+  both for the declaration of such a type, and for any assignment to its components.\n+\n+@noindent\n+  RM References:  9.10 (1/3)   C.06 (22/2)   C.06 (23/2)\n+\n+@item\n+@emph{AI-0009 Pragma Independent[_Components] (2010-07-23)}\n+@cindex AI-0009 (Ada 2012 feature)\n+\n+@noindent\n+  This AI introduces the new pragmas @code{Independent} and\n+  @code{Independent_Components},\n+  which control guaranteeing independence of access to objects and components.\n+  The AI also requires independence not unaffected by confirming rep clauses.\n+\n+@noindent\n+  RM References:  9.10 (1)   13.01 (15/1)   13.02 (9)   13.03 (13)   C.06 (2)\n+  C.06 (4)   C.06 (6)   C.06 (9)   C.06 (13)   C.06 (14)\n+\n+\n+@item\n+@emph{AI-0072 Task signalling using 'Terminated (0000-00-00)}\n+@cindex AI-0072 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies that task signalling for reading @code{'Terminated} only\n+  occurs if the result is True. GNAT semantics has always been consistent with\n+  this notion of task signalling.\n+\n+@noindent\n+  RM References:  9.10 (6.1/1)\n+\n+@item\n+@emph{AI-0108 Limited incomplete view and discriminants (0000-00-00)}\n+@cindex AI-0108 (Ada 2012 feature)\n+\n+@noindent\n+  This AI confirms that an incomplete type from a limited view does not have\n+  discriminants. This has always been the case in GNAT.\n+\n+@noindent\n+  RM References:  10.01.01 (12.3/2)\n+\n+@item\n+@emph{AI-0129 Limited views and incomplete types (0000-00-00)}\n+@cindex AI-0129 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the description of limited views: a limited view of a\n+  package includes only one view of a type that has an incomplete declaration\n+  and a full declaration (there is no possible ambiguity in a client package).\n+  This AI also fixes an omission: a nested package in the private part has no\n+  limited view. GNAT always implemented this correctly.\n+\n+@noindent\n+  RM References:  10.01.01 (12.2/2)   10.01.01 (12.3/2)\n+\n+\n+\n+@item\n+@emph{AI-0077 Limited withs and scope of declarations (0000-00-00)}\n+@cindex AI-0077 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies that a declaration does not include a context clause,\n+  and confirms that it is illegal to have a context in which both a limited\n+  and a nonlimited view of a package are accessible. Such double visibility\n+  was always rejected by GNAT.\n+\n+@noindent\n+  RM References:  10.01.02 (12/2)   10.01.02 (21/2)   10.01.02 (22/2)\n+\n+@item\n+@emph{AI-0122 Private with and children of generics (0000-00-00)}\n+@cindex AI-0122 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the visibility of private children of generic units within\n+  instantiations of a parent. GNAT has always handled this correctly.\n+\n+@noindent\n+  RM References:  10.01.02 (12/2)\n+\n+\n+\n+@item\n+@emph{AI-0040 Limited with clauses on descendant (0000-00-00)}\n+@cindex AI-0040 (Ada 2012 feature)\n+\n+@noindent\n+  This AI confirms that a limited with clause in a child unit cannot name\n+  an ancestor of the unit. This has always been checked in GNAT.\n+\n+@noindent\n+  RM References:  10.01.02 (20/2)\n+\n+@item\n+@emph{AI-0132 Placement of library unit pragmas (0000-00-00)}\n+@cindex AI-0132 (Ada 2012 feature)\n+\n+@noindent\n+  This AI fills a gap in the description of library unit pragmas. The pragma\n+  clearly must apply to a library unit, even if it does not carry the name\n+  of the enclosing unit. GNAT has always enforced the required check.\n+\n+@noindent\n+  RM References:  10.01.05 (7)\n+\n+\n+@item\n+@emph{AI-0034 Categorization of limited views (0000-00-00)}\n+@cindex AI-0034 (Ada 2012 feature)\n+\n+@noindent\n+  The RM makes certain limited with clauses illegal because of categorization\n+  considerations, when the corresponding normal with would be legal. This is\n+  not intended, and GNAT has always implemented the recommended behavior.\n+\n+@noindent\n+  RM References:  10.02.01 (11/1)   10.02.01 (17/2)\n+\n+\n+@item\n+@emph{AI-0035 Inconsistencies with Pure units (0000-00-00)}\n+@cindex AI-0035 (Ada 2012 feature)\n+\n+@noindent\n+  This AI remedies some inconsistencies in the legality rules for Pure units.\n+  Derived access types are legal in a pure unit (on the assumption that the\n+  rule for a zero storage pool size has been enforced on the ancestor type).\n+  The rules are enforced in generic instances and in subunits. GNAT has always\n+  implemented the recommended behavior.\n+\n+@noindent\n+  RM References:  10.02.01 (15.1/2)   10.02.01 (15.4/2)   10.02.01 (15.5/2)   10.02.01 (17/2)\n+\n+\n+@item\n+@emph{AI-0219 Pure permissions and limited parameters (2010-05-25)}\n+@cindex AI-0219 (Ada 2012 feature)\n+\n+@noindent\n+  This AI refines the rules for the cases with limited parameters which do not\n+  allow the implementations to omit ``redundant''. GNAT now properly conforms\n+  to the requirements of this binding interpretation.\n+\n+@noindent\n+  RM References:  10.02.01 (18/2)\n+\n+@item\n+@emph{AI-0043 Rules about raising exceptions (0000-00-00)}\n+@cindex AI-0043 (Ada 2012 feature)\n+\n+@noindent\n+  This AI covers various omissions in the RM regarding the raising of\n+  exceptions. GNAT has always implemented the intended semantics.\n+\n+@noindent\n+  RM References:  11.04.01 (10.1/2)   11 (2)\n+\n+\n+@item\n+@emph{AI-0200 Mismatches in formal package declarations (0000-00-00)}\n+@cindex AI-0200 (Ada 2012 feature)\n+\n+@noindent\n+  This AI plugs a gap in the RM which appeared to allow some obviously intended\n+  illegal instantiations. GNAT has never allowed these instantiations.\n+\n+@noindent\n+  RM References:  12.07 (16)\n+\n+\n+@item\n+@emph{AI-0112 Detection of duplicate pragmas (2010-07-24)}\n+@cindex AI-0112 (Ada 2012 feature)\n+\n+@noindent\n+  This AI concerns giving names to various representation aspects, but the\n+  practical effect is simply to make the use of duplicate\n+  @code{Atomic}[@code{_Components}],\n+  @code{Volatile}[@code{_Components}] and\n+  @code{Independent}[@code{_Components}] pragmas illegal, and GNAT\n+  now performs this required check.\n+\n+@noindent\n+  RM References:  13.01 (8)\n+\n+@item\n+@emph{AI-0106 No representation pragmas on generic formals (0000-00-00)}\n+@cindex AI-0106 (Ada 2012 feature)\n+\n+@noindent\n+  The RM appeared to allow representation pragmas on generic formal parameters,\n+  but this was not intended, and GNAT has never permitted this usage.\n+\n+@noindent\n+  RM References:  13.01 (9.1/1)\n+\n+\n+@item\n+@emph{AI-0012 Pack/Component_Size for aliased/atomic (2010-07-15)}\n+@cindex AI-0012 (Ada 2012 feature)\n+\n+@noindent\n+  It is now illegal to give an inappropriate component size or a pragma\n+  @code{Pack} that attempts to change the component size in the case of atomic\n+  or aliased components. Previously GNAT ignored such an attempt with a\n+  warning.\n+\n+@noindent\n+  RM References:  13.02 (6.1/2)   13.02 (7)   C.06 (10)   C.06 (11)   C.06 (21)\n+\n+\n+@item\n+@emph{AI-0039 Stream attributes cannot be dynamic (0000-00-00)}\n+@cindex AI-0039 (Ada 2012 feature)\n+\n+@noindent\n+  The RM permitted the use of dynamic expressions (such as @code{ptr.@b{all})}\n+  for stream attributes, but these were never useful and are now illegal. GNAT\n+  has always regarded such expressions as illegal.\n+\n+@noindent\n+  RM References:  13.03 (4)   13.03 (6)   13.13.02 (38/2)\n+\n+\n+@item\n+@emph{AI-0095 Address of intrinsic subprograms (0000-00-00)}\n+@cindex AI-0095 (Ada 2012 feature)\n+\n+@noindent\n+  The prefix of @code{'Address} cannot statically denote a subprogram with\n+  convention @code{Intrinsic}. The use of the @code{Address} attribute raises\n+  @code{Program_Error} if the prefix denotes a subprogram with convention\n+  @code{Intrinsic}.\n+\n+@noindent\n+  RM References:  13.03 (11/1)\n+\n+\n+@item\n+@emph{AI-0116 Alignment of class-wide objects (0000-00-00)}\n+@cindex AI-0116 (Ada 2012 feature)\n+\n+@noindent\n+  This AI requires that the alignment of a class-wide object be no greater\n+  than the alignment of any type in the class. GNAT has always followed this\n+  recommendation.\n+\n+@noindent\n+  RM References:  13.03 (29)   13.11 (16)\n+\n+\n+@item\n+@emph{AI-0146 Type invariants (2009-09-21)}\n+@cindex AI-0146 (Ada 2012 feature)\n+\n+@noindent\n+  Type invariants may be specified for private types using the aspect notation.\n+  Aspect @code{Invariant} may be specified for any private type,\n+  @code{Invariant'Class} can\n+  only be specified for tagged types, and is inherited by any descendent of the\n+  tagged types. The invariant is a boolean expression that is tested for being\n+  true in the following situations: conversions to the private type, object\n+  declarations for the private type that are default initialized, and\n+  [@b{in}] @b{out}\n+  parameters and returned result on return from any primitive operation for\n+  the type that is visible to a client.\n+\n+@noindent\n+  RM References:  13.03.03 (00)\n+\n+@item\n+@emph{AI-0078 Relax Unchecked_Conversion alignment rules (0000-00-00)}\n+@cindex AI-0078 (Ada 2012 feature)\n+\n+@noindent\n+  In Ada 2012, compilers are required to support unchecked conversion where the\n+  target alignment is a multiple of the source alignment. GNAT always supported\n+  this case (and indeed all cases of differing alignments, doing copies where\n+  required if the alignment was reduced).\n+\n+@noindent\n+  RM References:  13.09 (7)\n+\n+\n+@item\n+@emph{AI-0195 Invalid value handling is implementation defined (2010-07-03)}\n+@cindex AI-0195 (Ada 2012 feature)\n+\n+@noindent\n+  The handling of invalid values is now designated to be implementation\n+  defined. This is a documentation change only, requiring Annex M in the GNAT\n+  Reference Manual to document this handling.\n+  In GNAT, checks for invalid values are made\n+  only when necessary to avoid erroneous behavior. Operations like assignments\n+  which cannot cause erroneous behavior ignore the possibility of invalid\n+  values and do not do a check. The date given above applies only to the\n+  documentation change, this behavior has always been implemented by GNAT.\n+\n+@noindent\n+  RM References:  13.09.01 (10)\n+\n+@item\n+@emph{AI-0193 Alignment of allocators (2010-09-16)}\n+@cindex AI-0193 (Ada 2012 feature)\n+\n+@noindent\n+  This AI introduces a new attribute @code{Max_Alignment_For_Allocation},\n+  analogous to @code{Max_Size_In_Storage_Elements}, but for alignment instead\n+  of size.\n+\n+@noindent\n+  RM References:  13.11 (16)   13.11 (21)   13.11.01 (0)   13.11.01 (1)\n+  13.11.01 (2)   13.11.01 (3)\n+\n+\n+@item\n+@emph{AI-0177 Parameterized expressions (2010-07-10)}\n+@cindex AI-0177 (Ada 2012 feature)\n+\n+@noindent\n+  The new Ada 2012 notion of parameterized expressions is implemented. The form\n+  is:\n+@smallexample\n+  @i{function specification} @b{is} (@i{expression})\n+@end smallexample\n+\n+@noindent\n+  This is exactly equivalent to the\n+  corresponding function body that returns the expression, but it can appear\n+  in a package spec. Note that the expression must be parenthesized.\n+\n+@noindent\n+  RM References:  13.11.01 (3/2)\n+\n+@item\n+@emph{AI-0033 Attach/Interrupt_Handler in generic (2010-07-24)}\n+@cindex AI-0033 (Ada 2012 feature)\n+\n+@noindent\n+  Neither of these two pragmas may appear within a generic template, because\n+  the generic might be instantiated at other than the library level.\n+\n+@noindent\n+  RM References:  13.11.02 (16)   C.03.01 (7/2)   C.03.01 (8/2)\n+\n+\n+@item\n+@emph{AI-0161 Restriction No_Default_Stream_Attributes (2010-09-11)}\n+@cindex AI-0161 (Ada 2012 feature)\n+\n+@noindent\n+  A new restriction @code{No_Default_Stream_Attributes} prevents the use of any\n+  of the default stream attributes for elementary types. If this restriction is\n+  in force, then it is necessary to provide explicit subprograms for any\n+  stream attributes used.\n+\n+@noindent\n+  RM References:  13.12.01 (4/2)   13.13.02 (40/2)   13.13.02 (52/2)\n+\n+@item\n+@emph{AI-0194 Value of Stream_Size attribute (0000-00-00)}\n+@cindex AI-0194 (Ada 2012 feature)\n+\n+@noindent\n+  The @code{Stream_Size} attribute returns the default number of bits in the\n+  stream representation of the given type.\n+  This value is not affected by the presence\n+  of stream subprogram attributes for the type. GNAT has always implemented\n+  this interpretation.\n+\n+@noindent\n+  RM References:  13.13.02 (1.2/2)\n+\n+@item\n+@emph{AI-0109 Redundant check in S'Class'Input (0000-00-00)}\n+@cindex AI-0109 (Ada 2012 feature)\n+\n+@noindent\n+  This AI is an editorial change only. It removes the need for a tag check\n+  that can never fail.\n+\n+@noindent\n+  RM References:  13.13.02 (34/2)\n+\n+@item\n+@emph{AI-0007 Stream read and private scalar types (0000-00-00)}\n+@cindex AI-0007 (Ada 2012 feature)\n+\n+@noindent\n+  The RM as written appeared to limit the possibilities of declaring read\n+  attribute procedures for private scalar types. This limitation was not\n+  intended, and has never been enforced by GNAT.\n+\n+@noindent\n+  RM References:  13.13.02 (50/2)   13.13.02 (51/2)\n+\n+\n+@item\n+@emph{AI-0065 Remote access types and external streaming (0000-00-00)}\n+@cindex AI-0065 (Ada 2012 feature)\n+\n+@noindent\n+  This AI clarifies the fact that all remote access types support external\n+  streaming. This fixes an obvious oversight in the definition of the\n+  language, and GNAT always implemented the intended correct rules.\n+\n+@noindent\n+  RM References:  13.13.02 (52/2)\n+\n+@item\n+@emph{AI-0019 Freezing of primitives for tagged types (0000-00-00)}\n+@cindex AI-0019 (Ada 2012 feature)\n+\n+@noindent\n+  The RM suggests that primitive subprograms of a specific tagged type are\n+  frozen when the tagged type is frozen. This would be an incompatible change\n+  and is not intended. GNAT has never attempted this kind of freezing and its\n+  behavior is consistent with the recommendation of this AI.\n+\n+@noindent\n+  RM References:  13.14 (2)   13.14 (3/1)   13.14 (8.1/1)   13.14 (10)   13.14 (14)   13.14 (15.1/2)\n+\n+@item\n+@emph{AI-0017 Freezing and incomplete types (0000-00-00)}\n+@cindex AI-0017 (Ada 2012 feature)\n+\n+@noindent\n+  So-called ``Taft-amendment types'' (i.e., types that are completed in package\n+  bodies) are not frozen by the occurrence of bodies in the\n+  enclosing declarative part. GNAT always implemented this properly.\n+\n+@noindent\n+  RM References:  13.14 (3/1)\n+\n+\n+@item\n+@emph{AI-0060 Extended definition of remote access types (0000-00-00)}\n+@cindex AI-0060 (Ada 2012 feature)\n+\n+@noindent\n+  This AI extends the definition of remote access types to include access\n+  to limited, synchronized, protected or task class-wide interface types.\n+  GNAT already implemented this extension.\n+\n+@noindent\n+  RM References:  A (4)   E.02.02 (9/1)   E.02.02 (9.2/1)   E.02.02 (14/2)   E.02.02 (18)\n+\n+@item\n+@emph{AI-0114 Classification of letters (0000-00-00)}\n+@cindex AI-0114 (Ada 2012 feature)\n+\n+@noindent\n+  The code points 170 (@code{FEMININE ORDINAL INDICATOR}),\n+  181 (@code{MICRO SIGN}), and\n+  186 (@code{MASCULINE ORDINAL INDICATOR}) are technically considered\n+  lower case letters by Unicode.\n+  However, they are not allowed in identifiers, and they\n+  return @code{False} to @code{Ada.Characters.Handling.Is_Letter/Is_Lower}.\n+  This behavior is consistent with that defined in Ada 95.\n+\n+@noindent\n+  RM References:  A.03.02 (59)   A.04.06 (7)\n+\n+\n+@item\n+@emph{AI-0185 Ada.Wide_[Wide_]Characters.Handling (2010-07-06)}\n+@cindex AI-0185 (Ada 2012 feature)\n+\n+@noindent\n+  Two new packages @code{Ada.Wide_[Wide_]Characters.Handling} provide\n+  classification functions for @code{Wide_Character} and\n+  @code{Wide_Wide_Character}, as well as providing\n+  case folding routines for @code{Wide_[Wide_]Character} and\n+  @code{Wide_[Wide_]String}.\n+\n+@noindent\n+  RM References:  A.03.05 (0)   A.03.06 (0)\n+\n+\n+@item\n+@emph{AI-0031 Add From parameter to Find_Token (2010-07-25)}\n+@cindex AI-0031 (Ada 2012 feature)\n+\n+@noindent\n+  A new version of @code{Find_Token} is added to all relevant string packages,\n+  with an extra parameter @code{From}. Instead of starting at the first\n+  character of the string, the search for a matching Token starts at the\n+  character indexed by the value of @code{From}.\n+  These procedures are available in all versions of Ada\n+  but if used in versions earlier than Ada 2012 they will generate a warning\n+  that an Ada 2012 subprogram is being used.\n+\n+@noindent\n+  RM References:  A.04.03 (16)   A.04.03 (67)   A.04.03 (68/1)   A.04.04 (51)\n+  A.04.05 (46)\n+\n+\n+@item\n+@emph{AI-0056 Index on null string returns zero (0000-00-00)}\n+@cindex AI-0056 (Ada 2012 feature)\n+\n+@noindent\n+  The wording in the Ada 2005 RM implied an incompatible handling of the\n+  @code{Index} functions, resulting in raising an exception instead of\n+  returning zero in some situations.\n+  This was not intended and has been corrected.\n+  GNAT always returned zero, and is thus consistent with this AI.\n+\n+@noindent\n+  RM References:  A.04.03 (56.2/2)   A.04.03 (58.5/2)\n+\n+\n+@item\n+@emph{AI-0137 String encoding package (2010-03-25)}\n+@cindex AI-0137 (Ada 2012 feature)\n+\n+@noindent\n+  The packages @code{Ada.Strings.UTF_Encoding}, together with its child\n+  packages, @code{Conversions}, @code{Strings}, @code{Wide_Strings},\n+  and @code{Wide_Wide_Strings} have been\n+  implemented. These packages (whose documentation can be found in the spec\n+  files @file{a-stuten.ads}, @file{a-suenco.ads}, @file{a-suenst.ads},\n+  @file{a-suewst.ads}, @file{a-suezst.ads}) allow encoding and decoding of\n+  @code{String}, @code{Wide_String}, and @code{Wide_Wide_String}\n+  values using UTF coding schemes (including UTF-8, UTF-16LE, UTF-16BE, and\n+  UTF-16), as well as conversions between the different UTF encodings. With\n+  the exception of @code{Wide_Wide_Strings}, these packages are available in\n+  Ada 95 and Ada 2005 mode as well as Ada 2012 mode.\n+  The @code{Wide_Wide_Strings package}\n+  is available in Ada 2005 mode as well as Ada 2012 mode (but not in Ada 95\n+  mode since it uses @code{Wide_Wide_Character}).\n+\n+@noindent\n+  RM References:  A.04.11\n+\n+@item\n+@emph{AI-0038 Minor errors in Text_IO (0000-00-00)}\n+@cindex AI-0038 (Ada 2012 feature)\n+\n+@noindent\n+  These are minor errors in the description on three points. The intent on\n+  all these points has always been clear, and GNAT has always implemented the\n+  correct intended semantics.\n+\n+@noindent\n+  RM References:  A.10.05 (37)   A.10.07 (8/1)   A.10.07 (10)   A.10.07 (12)   A.10.08 (10)   A.10.08 (24)\n+\n+@item\n+@emph{AI-0044 Restrictions on container instantiations (0000-00-00)}\n+@cindex AI-0044 (Ada 2012 feature)\n+\n+@noindent\n+  This AI places restrictions on allowed instantiations of generic containers.\n+  These restrictions are not checked by the compiler, so there is nothing to\n+  change in the implementation. This affects only the RM documentation.\n+\n+@noindent\n+  RM References:  A.18 (4/2)   A.18.02 (231/2)   A.18.03 (145/2)   A.18.06 (56/2)   A.18.08 (66/2)   A.18.09 (79/2)   A.18.26 (5/2)   A.18.26 (9/2)\n+\n+@item\n+@emph{AI-0127 Adding Locale Capabilities (2010-09-29)}\n+@cindex AI-0127 (Ada 2012 feature)\n+\n+@noindent\n+  This package provides an interface for identifying the current locale.\n+\n+@noindent\n+  RM References:  A.19    A.19.01    A.19.02    A.19.03    A.19.05    A.19.06\n+  A.19.07    A.19.08    A.19.09    A.19.10    A.19.11    A.19.12    A.19.13\n+\n+\n+\n+@item\n+@emph{AI-0002 Export C with unconstrained arrays (0000-00-00)}\n+@cindex AI-0002 (Ada 2012 feature)\n+\n+@noindent\n+  The compiler is not required to support exporting an Ada subprogram with\n+  convention C if there are parameters or a return type of an unconstrained\n+  array type (such as @code{String}). GNAT allows such declarations but\n+  generates warnings. It is possible, but complicated, to write the\n+  corresponding C code and certainly such code would be specific to GNAT and\n+  non-portable.\n+\n+@noindent\n+  RM References:  B.01 (17)   B.03 (62)   B.03 (71.1/2)\n+\n+\n+@item\n+@emph{AI-0216 No_Task_Hierarchy forbids local tasks (0000-00-00)}\n+@cindex AI-0216 (Ada 2012 feature)\n+\n+@noindent\n+  It is clearly the intention that @code{No_Task_Hierarchy} is intended to\n+  forbid tasks declared locally within subprograms, or functions returning task\n+  objects, and that is the implementation that GNAT has always provided.\n+  However the language in the RM was not sufficiently clear on this point.\n+  Thus this is a docmentation change in the RM only.\n+\n+@noindent\n+  RM References:  D.07 (3/3)\n+\n+@item\n+@emph{AI-0211 No_Relative_Delays forbids Set_Handler use (2010-07-09)}\n+@cindex AI-0211 (Ada 2012 feature)\n+\n+@noindent\n+  The restriction @code{No_Relative_Delays} forbids any calls to the subprogram\n+  @code{Ada.Real_Time.Timing_Events.Set_Handler}.\n+\n+@noindent\n+  RM References:  D.07 (5)   D.07 (10/2)   D.07 (10.4/2)   D.07 (10.7/2)\n+\n+@item\n+@emph{AI-0190 pragma Default_Storage_Pool (2010-09-15)}\n+@cindex AI-0190 (Ada 2012 feature)\n+\n+@noindent\n+  This AI introduces a new pragma @code{Default_Storage_Pool}, which can be\n+  used to control storage pools globally.\n+  In particular, you can force every access\n+  type that is used for allocation (@b{new}) to have an explicit storage pool,\n+  or you can declare a pool globally to be used for all access types that lack\n+  an explicit one.\n+\n+@noindent\n+  RM References:  D.07 (8)\n+\n+@item\n+@emph{AI-0189 No_Allocators_After_Elaboration (2010-01-23)}\n+@cindex AI-0189 (Ada 2012 feature)\n+\n+@noindent\n+  This AI introduces a new restriction @code{No_Allocators_After_Elaboration},\n+  which says that no dynamic allocation will occur once elaboration is\n+  completed.\n+  In general this requires a run-time check, which is not required, and which\n+  GNAT does not attempt. But the static cases of allocators in a task body or\n+  in the body of the main program are detected and flagged at compile or bind\n+  time.\n+\n+@noindent\n+  RM References:  D.07 (19.1/2)   H.04 (23.3/2)\n+\n+@item\n+@emph{AI-0171 Pragma CPU and Ravenscar Profile (2010-09-24)}\n+@cindex AI-0171 (Ada 2012 feature)\n+\n+@noindent\n+  A new package @code{System.Multiprocessors} is added, together with the\n+  definition of pragma @code{CPU} for controlling task affinity. A new no\n+  dependence restriction, on @code{System.Multiprocessors.Dispatching_Domains},\n+  is added to the Ravenscar profile.\n+\n+@noindent\n+  RM References:  D.13.01 (4/2)   D.16\n+\n+\n+@item\n+@emph{AI-0210 Correct Timing_Events metric (0000-00-00)}\n+@cindex AI-0210 (Ada 2012 feature)\n+\n+@noindent\n+  This is a documentation only issue regarding wording of metric requirements,\n+  that does not affect the implementation of the compiler.\n+\n+@noindent\n+  RM References:  D.15 (24/2)\n+\n+\n+@item\n+@emph{AI-0206 Remote types packages and preelaborate (2010-07-24)}\n+@cindex AI-0206 (Ada 2012 feature)\n+\n+@noindent\n+  Remote types packages are now allowed to depend on preelaborated packages.\n+  This was formerly considered illegal.\n+\n+@noindent\n+  RM References:  E.02.02 (6)\n+\n+\n+\n+@item\n+@emph{AI-0152 Restriction No_Anonymous_Allocators (2010-09-08)}\n+@cindex AI-0152 (Ada 2012 feature)\n+\n+@noindent\n+  Restriction @code{No_Anonymous_Allocators} prevents the use of allocators\n+  where the type of the returned value is an anonymous access type.\n+\n+@noindent\n+  RM References:  H.04 (8/1)\n+@end itemize\n+\n+\n @node Obsolescent Features\n @chapter Obsolescent Features\n "}, {"sha": "37992b600599e1acf7f992ab847ea57e1de18471", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -913,6 +913,10 @@ package body Ch10 is\n                   --  place where such an \"error\" should be caught.\n \n                   Set_Name (With_Node, P_Qualified_Simple_Name);\n+                  if Name (With_Node) = Error then\n+                     Remove (With_Node);\n+                  end if;\n+\n                   Set_First_Name (With_Node, First_Flag);\n                   Set_Limited_Present (With_Node, Has_Limited);\n                   Set_Private_Present (With_Node, Has_Private);"}, {"sha": "fe97c6bb3ca4efede8e2ac52d4057493dacab994", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -866,8 +866,8 @@ package body Sem_Case is\n                              or else No (Static_Predicate (E))\n                            then\n                               Bad_Predicated_Subtype_Use\n-                                (\"cannot use subtype&  with non-static \"\n-                                 & \"predicate as case alternative\", N, E);\n+                                (\"cannot use subtype& with non-static \"\n+                                 & \"predicate as case alternative\", Choice, E);\n \n                               --  Static predicate case\n "}, {"sha": "0cec74f7c426266bfcedff83ee20cf34b2139b6f", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -1375,7 +1375,7 @@ package body Sem_Ch12 is\n                when N_Use_Package_Clause |\n                     N_Use_Type_Clause    =>\n                   if Nkind (Original_Node (I_Node)) =\n-                    N_Formal_Package_Declaration\n+                                     N_Formal_Package_Declaration\n                   then\n                      Append (New_Copy_Tree (Formal), Assoc);\n                   else"}, {"sha": "37f9a3e7d48a409b8fae4097a6d7da388f75abe8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -3890,10 +3890,12 @@ package body Sem_Ch13 is\n \n             --  Output info message on inheritance if required. Note we do not\n             --  give this information for generic actual types, since it is\n-            --  unwelcome noise in that case in instantiations.\n+            --  unwelcome noise in that case in instantiations. We also\n+            --  generally suppress the message in instantiations.\n \n             if Opt.List_Inherited_Aspects\n               and then not Is_Generic_Actual_Type (Typ)\n+              and then Instantiation_Depth (Sloc (Typ)) = 0\n             then\n                Error_Msg_Sloc := Sloc (Predicate_Function (T));\n                Error_Msg_Node_2 := T;\n@@ -4317,6 +4319,43 @@ package body Sem_Ch13 is\n          --  now we can store the result as the predicate list.\n \n          Set_Static_Predicate (Typ, Plist);\n+\n+         --  The processing for static predicates coalesced ranges and also\n+         --  eliminated duplicates. We might as well replace the alternatives\n+         --  list of the right operand of the membership test with the static\n+         --  predicate list, which will be more efficient.\n+\n+         declare\n+            New_Alts : constant List_Id := New_List;\n+            Old_Node : Node_Id;\n+            New_Node : Node_Id;\n+\n+         begin\n+            Old_Node := First (Plist);\n+            while Present (Old_Node) loop\n+               New_Node := New_Copy (Old_Node);\n+\n+               if Nkind (New_Node) = N_Range then\n+                  Set_Low_Bound  (New_Node, New_Copy (Low_Bound  (Old_Node)));\n+                  Set_High_Bound (New_Node, New_Copy (High_Bound (Old_Node)));\n+               end if;\n+\n+               Append_To (New_Alts, New_Node);\n+               Next (Old_Node);\n+            end loop;\n+\n+            --  Now update the membership test node\n+\n+            pragma Assert (Nkind (Expr) = N_In);\n+\n+            if List_Length (New_Alts) = 1 then\n+               Set_Right_Opnd   (Expr, First (New_Alts));\n+               Set_Alternatives (Expr, No_List);\n+            else\n+               Set_Alternatives (Expr, New_Alts);\n+               Set_Right_Opnd   (Expr, Empty);\n+            end if;\n+         end;\n       end Build_Static_Predicate;\n \n    --  Start of processing for Build_Predicate_Function"}, {"sha": "9265257a9efc963cbb9a81da95313a0b82af30bb", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -1832,18 +1832,34 @@ package body Sem_Ch5 is\n                   return;\n                end if;\n \n-               --  The subtype indication may denote the completion of an\n-               --  incomplete type declaration.\n+               --  Some additional checks if we are iterating through a type\n \n                if Is_Entity_Name (DS)\n                  and then Present (Entity (DS))\n                  and then Is_Type (Entity (DS))\n-                 and then Ekind (Entity (DS)) = E_Incomplete_Type\n                then\n-                  Set_Entity (DS, Get_Full_View (Entity (DS)));\n-                  Set_Etype  (DS, Entity (DS));\n+                  --  The subtype indication may denote the completion of an\n+                  --  incomplete type declaration.\n+\n+                  if Ekind (Entity (DS)) = E_Incomplete_Type then\n+                     Set_Entity (DS, Get_Full_View (Entity (DS)));\n+                     Set_Etype  (DS, Entity (DS));\n+                  end if;\n+\n+                  --  Attempt to iterate through non-static predicate\n+\n+                  if Is_Discrete_Type (Entity (DS))\n+                    and then Present (Predicate_Function (Entity (DS)))\n+                    and then No (Static_Predicate (Entity (DS)))\n+                  then\n+                     Bad_Predicated_Subtype_Use\n+                       (\"cannot use subtype& with non-static \"\n+                        & \"predicate for loop iteration\", DS, Entity (DS));\n+                  end if;\n                end if;\n \n+               --  Error if not discrete type\n+\n                if not Is_Discrete_Type (Etype (DS)) then\n                   Wrong_Type (DS, Any_Discrete);\n                   Set_Etype (DS, Any_Type);"}, {"sha": "64d06083292bfb2239be5a69c5d2f2a772b5f7c7", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -2851,6 +2851,15 @@ package body Sinfo is\n       return Node5 (N);\n    end Subtype_Indication;\n \n+   function Suppress_Assignment_Checks\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Object_Declaration);\n+      return Flag18 (N);\n+   end Suppress_Assignment_Checks;\n+\n    function Suppress_Loop_Warnings\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5886,6 +5895,15 @@ package body Sinfo is\n       Set_List2_With_Parent (N, Val);\n    end Set_Subtype_Marks;\n \n+   procedure Set_Suppress_Assignment_Checks\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Assignment_Statement\n+        or else NT (N).Nkind = N_Object_Declaration);\n+      Set_Flag18 (N, Val);\n+   end Set_Suppress_Assignment_Checks;\n+\n    procedure Set_Suppress_Loop_Warnings\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "4a267fc852b6959211d7cffd2966b66612835f80", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7532b2de4f303ee8fb994411ddf25dc4de45831/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=c7532b2de4f303ee8fb994411ddf25dc4de45831", "patch": "@@ -1733,6 +1733,13 @@ package Sinfo is\n    --    value of a type whose size is not known at compile time on the\n    --    secondary stack.\n \n+   --  Suppress_Assignment_Checks (Flag18-Sem)\n+   --    Used in genererated N_Assignment_Statement nodes to suppress predicate\n+   --    and range checks in cases where the generated code knows that the\n+   --    value being assigned is in range and satisifies any predicate. Also\n+   --    can be set in N_Object_Declaration nodes, to similarly suppress any\n+   --    checks on the initializing value.\n+\n    --  Suppress_Loop_Warnings (Flag17-Sem)\n    --    Used in N_Loop_Statement node to indicate that warnings within the\n    --    body of the loop should be suppressed. This is set when the range\n@@ -2331,6 +2338,7 @@ package Sinfo is\n       --  Exception_Junk (Flag8-Sem)\n       --  Is_Subprogram_Descriptor (Flag16-Sem)\n       --  Has_Init_Expression (Flag14)\n+      --  Suppress_Assignment_Checks (Flag18-Sem)\n \n       -------------------------------------\n       -- 3.3.1  Defining Identifier List --\n@@ -4052,9 +4060,10 @@ package Sinfo is\n       --  Backwards_OK (Flag6-Sem)\n       --  No_Ctrl_Actions (Flag7-Sem)\n       --  Componentwise_Assignment (Flag14-Sem)\n+      --  Suppress_Assignment_Checks (Flag18-Sem)\n \n       --  Note: if a range check is required, then the Do_Range_Check flag\n-      --  is set in the Expression (right hand side), with the check being\n+      --  is set in the Expression (right hand side), with the check b6ing\n       --  done against the type of the Name (left hand side).\n \n       --  Note: the back end places some restrictions on the form of the\n@@ -8844,6 +8853,9 @@ package Sinfo is\n    function Subtype_Marks\n      (N : Node_Id) return List_Id;    -- List2\n \n+   function Suppress_Assignment_Checks\n+     (N : Node_Id) return Boolean;    -- Flag18\n+\n    function Suppress_Loop_Warnings\n      (N : Node_Id) return Boolean;    -- Flag17\n \n@@ -9804,6 +9816,9 @@ package Sinfo is\n    procedure Set_Subtype_Marks\n      (N : Node_Id; Val : List_Id);            -- List2\n \n+   procedure Set_Suppress_Assignment_Checks\n+     (N : Node_Id; Val : Boolean := True);    -- Flag18\n+\n    procedure Set_Suppress_Loop_Warnings\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n@@ -11899,6 +11914,7 @@ package Sinfo is\n    pragma Inline (Subtype_Indication);\n    pragma Inline (Subtype_Mark);\n    pragma Inline (Subtype_Marks);\n+   pragma Inline (Suppress_Assignment_Checks);\n    pragma Inline (Suppress_Loop_Warnings);\n    pragma Inline (Synchronized_Present);\n    pragma Inline (Tagged_Present);\n@@ -12215,6 +12231,7 @@ package Sinfo is\n    pragma Inline (Set_Subtype_Indication);\n    pragma Inline (Set_Subtype_Mark);\n    pragma Inline (Set_Subtype_Marks);\n+   pragma Inline (Set_Suppress_Assignment_Checks);\n    pragma Inline (Set_Suppress_Loop_Warnings);\n    pragma Inline (Set_Synchronized_Present);\n    pragma Inline (Set_Tagged_Present);"}]}