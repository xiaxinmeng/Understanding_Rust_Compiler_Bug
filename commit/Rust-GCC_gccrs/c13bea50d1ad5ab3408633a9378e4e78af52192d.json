{"sha": "c13bea50d1ad5ab3408633a9378e4e78af52192d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzYmVhNTBkMWFkNWFiMzQwODYzM2E5Mzc4ZTRlNzhhZjUyMTkyZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-24T16:32:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-01-24T16:32:11Z"}, "message": "valarray_meta.h: Remove, split into ...\n\n\t* include/bits/valarray_meta.h: Remove, split into ...\n\t* include/bits/valarray_before.h: ... this, and ...\n\t* include/bits/valarray_after.h: ... this.\n\t* include/std/std_valarray.h: Adjust.\n\t* include/Makefile.am (bits_headers): Adjust.\n\t* include/Makefile.in: Regenerate.\n\nFrom-SVN: r61706", "tree": {"sha": "f24e7464989470b7268fe1bd677148e78915d019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f24e7464989470b7268fe1bd677148e78915d019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13bea50d1ad5ab3408633a9378e4e78af52192d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13bea50d1ad5ab3408633a9378e4e78af52192d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13bea50d1ad5ab3408633a9378e4e78af52192d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13bea50d1ad5ab3408633a9378e4e78af52192d/comments", "author": null, "committer": null, "parents": [{"sha": "e12825cd4853b560d81955e2b6711fc7484bcf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12825cd4853b560d81955e2b6711fc7484bcf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e12825cd4853b560d81955e2b6711fc7484bcf02"}], "stats": {"total": 1371, "additions": 713, "deletions": 658}, "files": [{"sha": "5eb8397c52b0d56b95c89a6780ab57105f7d002f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=c13bea50d1ad5ab3408633a9378e4e78af52192d", "patch": "@@ -97,7 +97,8 @@ bits_headers = \\\n \t${bits_srcdir}/type_traits.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n-\t${bits_srcdir}/valarray_meta.h \\\n+\t${bits_srcdir}/valarray_before.h \\\n+\t${bits_srcdir}/valarray_after.h \\\n \t${bits_srcdir}/vector.tcc\n \n backward_srcdir = ${glibcpp_srcdir}/include/backward"}, {"sha": "501238a4d695442c7039c7231cc09a7e486c4e2a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=c13bea50d1ad5ab3408633a9378e4e78af52192d", "patch": "@@ -215,7 +215,8 @@ bits_headers = \\\n \t${bits_srcdir}/type_traits.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n-\t${bits_srcdir}/valarray_meta.h \\\n+\t${bits_srcdir}/valarray_before.h \\\n+\t${bits_srcdir}/valarray_after.h \\\n \t${bits_srcdir}/vector.tcc\n \n "}, {"sha": "687e6d21321178cdc5b6f95c98a66a12a71ad22b", "filename": "libstdc++-v3/include/bits/valarray_after.h", "status": "renamed", "additions": 4, "deletions": 654, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_after.h?ref=c13bea50d1ad5ab3408633a9378e4e78af52192d", "patch": "@@ -1,6 +1,6 @@\n // The template and inlines for the -*- C++ -*- internal _Meta class.\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,663 +34,14 @@\n  *  You should not attempt to use it directly.\n  */\n \n-#ifndef _CPP_VALARRAY_META_H\n-#define _CPP_VALARRAY_META_H 1\n+#ifndef _CPP_VALARRAY_AFTER_H\n+#define _CPP_VALARRAY_AFTER_H 1\n \n #pragma GCC system_header\n \n-#include <bits/slice_array.h>\n-\n namespace std\n {\n-  //\n-  // Implementing a loosened valarray return value is tricky.\n-  // First we need to meet 26.3.1/3: we should not add more than\n-  // two levels of template nesting. Therefore we resort to template\n-  // template to \"flatten\" loosened return value types.\n-  // At some point we use partial specialization to remove one level\n-  // template nesting due to _Expr<>\n-  //\n   \n-  // This class is NOT defined. It doesn't need to.\n-  template<typename _Tp1, typename _Tp2> class _Constant;\n-\n-  // Implementations of unary functions applied to valarray<>s.\n-  // I use hard-coded object functions here instead of a generic\n-  // approach like pointers to function:\n-  //    1) correctness: some functions take references, others values.\n-  //       we can't deduce the correct type afterwards.\n-  //    2) efficiency -- object functions can be easily inlined\n-  //    3) be Koenig-lookup-friendly\n-\n-  struct __abs\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return abs(__t); }\n-  };\n-\n-  struct __cos\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return cos(__t); }\n-  };\n-\n-  struct __acos\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return acos(__t); }\n-  };\n-\n-  struct __cosh\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return cosh(__t); }\n-  };\n-\n-  struct __sin\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sin(__t); }\n-  };\n-\n-  struct __asin\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return asin(__t); }\n-  };\n-\n-  struct __sinh\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sinh(__t); }\n-  };\n-\n-  struct __tan\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return tan(__t); }\n-  };\n-\n-  struct __atan\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return atan(__t); }\n-  };\n-\n-  struct __tanh\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return tanh(__t); }\n-  };\n-\n-  struct __exp\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return exp(__t); }\n-  };\n-\n-  struct __log\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return log(__t); }\n-  };\n-\n-  struct __log10\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return log10(__t); }\n-  };\n-\n-  struct __sqrt\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return sqrt(__t); }\n-  };\n-\n-  // In the past, we used to tailor operator applications semantics\n-  // to the specialization of standard function objects (i.e. plus<>, etc.)\n-  // That is incorrect.  Therefore we provide our own surrogates.\n-\n-  struct __unary_plus\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return +__t; }\n-  };\n-\n-  struct __negate\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return -__t; }\n-  };\n-\n-  struct __bitwise_not\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __t) const { return ~__t; }\n-  };\n-\n-  struct __plus\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x + __y; }\n-  };\n-\n-  struct __minus\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x - __y; }\n-  };\n-\n-  struct __multiplies\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x * __y; }\n-  };\n-\n-  struct __divides\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x / __y; }\n-  };\n-\n-  struct __modulus\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x % __y; }\n-  };\n-\n-  struct __bitwise_xor\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x ^ __y; }\n-  };\n-\n-  struct __bitwise_and\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x & __y; }\n-  };\n-\n-  struct __bitwise_or\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x | __y; }\n-  };\n-\n-  struct __shift_left\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x << __y; }\n-  };\n-\n-  struct __shift_right\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x >> __y; }\n-  };\n-\n-  struct __logical_and\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x && __y; }\n-  };\n-\n-  struct __logical_or\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x || __y; }\n-  };\n-\n-  struct __logical_not\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x) const { return !__x; }\n-  };\n-\n-  struct __equal_to\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x == __y; }\n-  };\n-\n-  struct __not_equal_to\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x == __y; }\n-  };\n-\n-  struct __less\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x < __y; }\n-  };\n-\n-  struct __greater\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x > __y; }\n-  };\n-\n-  struct __less_equal\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x <= __y; }\n-  };\n-\n-  struct __greater_equal\n-  {\n-    template<typename _Tp>\n-      bool operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x >= __y; }\n-  };\n-\n-  // The few binary functions we miss.\n-  struct __atan2\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return atan2(__x, __y); }\n-  };\n-\n-  struct __pow\n-  {\n-    template<typename _Tp>\n-      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n-      { return pow(__x, __y); }\n-  };\n-\n-\n-  // We need these bits in order to recover the return type of\n-  // some functions/operators now that we're no longer using\n-  // function templates.\n-  template<typename, typename _Tp>\n-    struct __fun\n-    {\n-      typedef _Tp result_type;\n-    };\n-\n-  // several specializations for relational operators.\n-  template<typename _Tp>\n-    struct __fun<__logical_not, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__logical_and, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__logical_or, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__less, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__greater, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__less_equal, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__greater_equal, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__equal_to, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-  template<typename _Tp>\n-    struct __fun<__not_equal_to, _Tp>\n-    {\n-      typedef bool result_type;\n-    };\n-\n-    //\n-    // Apply function taking a value/const reference closure\n-    //\n-\n-  template<typename _Dom, typename _Arg>\n-    class _FunBase \n-    {\n-    public:\n-      typedef typename _Dom::value_type value_type;\n-      \n-      _FunBase(const _Dom& __e, value_type __f(_Arg))\n-\t: _M_expr(__e), _M_func(__f) {}\n-\n-      value_type operator[](size_t __i) const\n-      { return _M_func (_M_expr[__i]); }\n-\n-      size_t size() const { return _M_expr.size ();}\n-\n-    private:\n-        const _Dom& _M_expr;\n-        value_type (*_M_func)(_Arg);\n-    };\n-\n-  template<class _Dom>\n-    struct _ValFunClos<_Expr,_Dom> : _FunBase<_Dom, typename _Dom::value_type> \n-    {\n-      typedef _FunBase<_Dom, typename _Dom::value_type> _Base;\n-      typedef typename _Base::value_type value_type;\n-      typedef value_type _Tp;\n-    \n-      _ValFunClos(const _Dom& __e, _Tp __f(_Tp)) : _Base(__e, __f) {}\n-    };\n-\n-  template<typename _Tp>\n-    struct _ValFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, _Tp>\n-    {\n-      typedef _FunBase<valarray<_Tp>, _Tp> _Base;\n-      typedef _Tp value_type;\n-      \n-      _ValFunClos(const valarray<_Tp>& __v, _Tp __f(_Tp)) : _Base(__v, __f) {}\n-    };\n-\n-  template<class _Dom>\n-    struct _RefFunClos<_Expr,_Dom> :\n-        _FunBase<_Dom, const typename _Dom::value_type&> \n-    {\n-      typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;\n-      typedef typename _Base::value_type value_type;\n-      typedef value_type _Tp;\n-      \n-      _RefFunClos(const _Dom& __e, _Tp __f(const _Tp&))\n-\t: _Base(__e, __f) {}\n-    };\n-\n-  template<typename _Tp>\n-    struct _RefFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, const _Tp&> \n-    {\n-      typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;\n-      typedef _Tp value_type;\n-      \n-      _RefFunClos(const valarray<_Tp>& __v, _Tp __f(const _Tp&))\n-\t: _Base(__v, __f) {}\n-    };\n-    \n-  //\n-  // Unary expression closure.\n-  //\n-\n-  template<class _Oper, class _Arg>\n-    class _UnBase\n-    {\n-    public:\n-      typedef typename _Arg::value_type _Vt;\n-      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n-\n-      _UnBase(const _Arg& __e) : _M_expr(__e) {}\n-\n-      value_type operator[](size_t __i) const\n-      { return _M_expr[__i]; }\n-\n-      size_t size() const { return _M_expr.size(); }\n-\n-    private:\n-      const _Arg& _M_expr;\n-    };\n-\n-  template<class _Oper, class _Dom>\n-    struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom>\n-    {\n-      typedef _Dom _Arg;\n-      typedef _UnBase<_Oper, _Dom> _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _UnClos(const _Arg& __e) : _Base(__e) {}\n-    };\n-\n-  template<class _Oper, typename _Tp>\n-    struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> > \n-    {\n-      typedef valarray<_Tp> _Arg;\n-      typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _UnClos(const _Arg& __e) : _Base(__e) {}\n-    };\n-\n-\n-  //\n-  // Binary expression closure.\n-  //\n-\n-  template<class _Oper, class _FirstArg, class _SecondArg>\n-    class _BinBase \n-    {\n-    public:\n-        typedef typename _FirstArg::value_type _Vt;\n-        typedef typename __fun<_Oper, _Vt>::result_type value_type;\n-\n-      _BinBase(const _FirstArg& __e1, const _SecondArg& __e2)\n-\t: _M_expr1(__e1), _M_expr2(__e2) {}\n-      \n-      value_type operator[](size_t __i) const\n-      { return _Oper()(_M_expr1[__i], _M_expr2[__i]); }\n-\n-      size_t size() const { return _M_expr1.size(); }\n-        \n-    private:\n-      const _FirstArg& _M_expr1;\n-      const _SecondArg& _M_expr2;\n-    };\n-\n-\n-  template<class _Oper, class _Clos>\n-    class _BinBase2\n-    {\n-    public:\n-      typedef typename _Clos::value_type _Vt;\n-      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n-\n-      _BinBase2(const _Clos& __e, const _Vt& __t)\n-\t: _M_expr1(__e), _M_expr2(__t) {}\n-\n-      value_type operator[](size_t __i) const\n-      { return _Oper()(_M_expr1[__i], _M_expr2); }\n-\n-      size_t size() const { return _M_expr1.size(); }\n-\n-    private:\n-      const _Clos& _M_expr1;\n-      const _Vt& _M_expr2;\n-    };\n-\n-  template<class _Oper, class _Clos>\n-    class _BinBase1\n-    {\n-    public:\n-      typedef typename _Clos::value_type _Vt;\n-      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n-\n-      _BinBase1(const _Vt& __t, const _Clos& __e)\n-\t: _M_expr1(__t), _M_expr2(__e) {}\n-\n-      value_type operator[](size_t __i) const\n-      { return _Oper()(_M_expr1, _M_expr2[__i]); }\n-      \n-      size_t size() const { return _M_expr2.size(); }\n-\n-    private:\n-      const _Vt& _M_expr1;\n-      const _Clos& _M_expr2;\n-    };\n-    \n-  template<class _Oper, class _Dom1, class _Dom2>\n-    struct _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>\n-        : _BinBase<_Oper,_Dom1,_Dom2> \n-    {\n-      typedef _BinBase<_Oper,_Dom1,_Dom2> _Base;\n-      typedef typename _Base::value_type value_type;\n-        \n-      _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}\n-    };\n-\n-  template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_ValArray,_ValArray,_Tp,_Tp>\n-      : _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > \n-    {\n-      typedef _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > _Base;\n-      typedef _Tp value_type;\n-\n-      _BinClos(const valarray<_Tp>& __v, const valarray<_Tp>& __w)\n-\t: _Base(__v, __w) {}\n-    };\n-\n-  template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Expr,_ValArray,_Dom,typename _Dom::value_type>\n-      : _BinBase<_Oper,_Dom,valarray<typename _Dom::value_type> > \n-    {\n-      typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)\n-\t: _Base(__e1, __e2) {}\n-    };\n-\n-  template<class _Oper, class _Dom>\n-    struct  _BinClos<_Oper,_ValArray,_Expr,typename _Dom::value_type,_Dom>\n-      : _BinBase<_Oper,valarray<typename _Dom::value_type>,_Dom> \n-    {\n-      typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase<_Oper,valarray<_Tp>,_Dom> _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const valarray<_Tp>& __e1, const _Dom& __e2)\n-\t: _Base(__e1, __e2) {}\n-    };\n-\n-  template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Expr,_Constant,_Dom,typename _Dom::value_type>\n-      : _BinBase2<_Oper,_Dom> \n-    {\n-      typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase2<_Oper,_Dom> _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const _Dom& __e1, const _Tp& __e2) : _Base(__e1, __e2) {}\n-    };\n-\n-  template<class _Oper, class _Dom>\n-    struct _BinClos<_Oper,_Constant,_Expr,typename _Dom::value_type,_Dom>\n-      : _BinBase1<_Oper,_Dom> \n-    {\n-      typedef typename _Dom::value_type _Tp;\n-      typedef _BinBase1<_Oper,_Dom> _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const _Tp& __e1, const _Dom& __e2) : _Base(__e1, __e2) {}\n-    };\n-    \n-  template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_ValArray,_Constant,_Tp,_Tp>\n-      : _BinBase2<_Oper,valarray<_Tp> > \n-    {\n-      typedef _BinBase2<_Oper,valarray<_Tp> > _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const valarray<_Tp>& __v, const _Tp& __t) : _Base(__v, __t) {}\n-    };\n-\n-  template<class _Oper, typename _Tp>\n-    struct _BinClos<_Oper,_Constant,_ValArray,_Tp,_Tp>\n-      : _BinBase1<_Oper,valarray<_Tp> > \n-    {\n-      typedef _BinBase1<_Oper,valarray<_Tp> > _Base;\n-      typedef typename _Base::value_type value_type;\n-      \n-      _BinClos(const _Tp& __t, const valarray<_Tp>& __v) : _Base(__t, __v) {}\n-    };\n-        \n-\n-    //\n-    // slice_array closure.\n-    //\n-    template<typename _Dom>  class _SBase {\n-    public:\n-        typedef typename _Dom::value_type value_type;\n-\n-        _SBase (const _Dom& __e, const slice& __s)\n-                : _M_expr (__e), _M_slice (__s) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }\n-        size_t size() const { return _M_slice.size (); }\n-\n-    private:\n-        const _Dom& _M_expr;\n-        const slice& _M_slice;\n-    };\n-\n-    template<typename _Tp> class _SBase<_Array<_Tp> > {\n-    public:\n-        typedef _Tp value_type;\n-\n-        _SBase (_Array<_Tp> __a, const slice& __s)\n-                : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),\n-                  _M_stride (__s.stride()) {}\n-        value_type operator[] (size_t __i) const\n-        { return _M_array._M_data[__i * _M_stride]; }\n-        size_t size() const { return _M_size; }\n-\n-    private:\n-        const _Array<_Tp> _M_array;\n-        const size_t _M_size;\n-        const size_t _M_stride;\n-    };\n-\n-    template<class _Dom> struct  _SClos<_Expr,_Dom> : _SBase<_Dom> {\n-        typedef _SBase<_Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-        \n-        _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}\n-    };\n-\n-    template<typename _Tp>\n-    struct _SClos<_ValArray,_Tp> : _SBase<_Array<_Tp> > {\n-        typedef  _SBase<_Array<_Tp> > _Base;\n-        typedef _Tp value_type;\n-\n-        _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}\n-    };\n-\n     //\n     // gslice_array closure.\n     //\n@@ -744,7 +95,6 @@ namespace std\n     //\n     // indirect_array closure\n     //\n-\n     template<class _Dom> class _IBase {\n     public:\n         typedef typename _Dom::value_type value_type;\n@@ -1142,7 +492,7 @@ _DEFINE_EXPR_BINARY_FUNCTION(pow)\n } // std::\n \n \n-#endif /* _CPP_VALARRAY_META_H */\n+#endif /* _CPP_VALARRAY_AFTER_H */\n \n // Local Variables:\n // mode:c++", "previous_filename": "libstdc++-v3/include/bits/valarray_meta.h"}, {"sha": "13b534949873611f10748a74086f1441b0dce91c", "filename": "libstdc++-v3/include/bits/valarray_before.h", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_before.h?ref=c13bea50d1ad5ab3408633a9378e4e78af52192d", "patch": "@@ -0,0 +1,701 @@\n+// The template and inlines for the -*- C++ -*- internal _Meta class.\n+\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+/** @file valarray_meta.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _CPP_VALARRAY_BEFORE_H\n+#define _CPP_VALARRAY_BEFORE_H 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/slice_array.h>\n+\n+namespace std\n+{\n+  //\n+  // Implementing a loosened valarray return value is tricky.\n+  // First we need to meet 26.3.1/3: we should not add more than\n+  // two levels of template nesting. Therefore we resort to template\n+  // template to \"flatten\" loosened return value types.\n+  // At some point we use partial specialization to remove one level\n+  // template nesting due to _Expr<>\n+  //\n+  \n+  // This class is NOT defined. It doesn't need to.\n+  template<typename _Tp1, typename _Tp2> class _Constant;\n+\n+  // Implementations of unary functions applied to valarray<>s.\n+  // I use hard-coded object functions here instead of a generic\n+  // approach like pointers to function:\n+  //    1) correctness: some functions take references, others values.\n+  //       we can't deduce the correct type afterwards.\n+  //    2) efficiency -- object functions can be easily inlined\n+  //    3) be Koenig-lookup-friendly\n+\n+  struct __abs\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return abs(__t); }\n+  };\n+\n+  struct __cos\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return cos(__t); }\n+  };\n+\n+  struct __acos\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return acos(__t); }\n+  };\n+\n+  struct __cosh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return cosh(__t); }\n+  };\n+\n+  struct __sin\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sin(__t); }\n+  };\n+\n+  struct __asin\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return asin(__t); }\n+  };\n+\n+  struct __sinh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sinh(__t); }\n+  };\n+\n+  struct __tan\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return tan(__t); }\n+  };\n+\n+  struct __atan\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return atan(__t); }\n+  };\n+\n+  struct __tanh\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return tanh(__t); }\n+  };\n+\n+  struct __exp\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return exp(__t); }\n+  };\n+\n+  struct __log\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return log(__t); }\n+  };\n+\n+  struct __log10\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return log10(__t); }\n+  };\n+\n+  struct __sqrt\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return sqrt(__t); }\n+  };\n+\n+  // In the past, we used to tailor operator applications semantics\n+  // to the specialization of standard function objects (i.e. plus<>, etc.)\n+  // That is incorrect.  Therefore we provide our own surrogates.\n+\n+  struct __unary_plus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return +__t; }\n+  };\n+\n+  struct __negate\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return -__t; }\n+  };\n+\n+  struct __bitwise_not\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __t) const { return ~__t; }\n+  };\n+\n+  struct __plus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x + __y; }\n+  };\n+\n+  struct __minus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x - __y; }\n+  };\n+\n+  struct __multiplies\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x * __y; }\n+  };\n+\n+  struct __divides\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x / __y; }\n+  };\n+\n+  struct __modulus\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x % __y; }\n+  };\n+\n+  struct __bitwise_xor\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x ^ __y; }\n+  };\n+\n+  struct __bitwise_and\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x & __y; }\n+  };\n+\n+  struct __bitwise_or\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x | __y; }\n+  };\n+\n+  struct __shift_left\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x << __y; }\n+  };\n+\n+  struct __shift_right\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x >> __y; }\n+  };\n+\n+  struct __logical_and\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x && __y; }\n+  };\n+\n+  struct __logical_or\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x || __y; }\n+  };\n+\n+  struct __logical_not\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x) const { return !__x; }\n+  };\n+\n+  struct __equal_to\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+  };\n+\n+  struct __not_equal_to\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+  };\n+\n+  struct __less\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+  };\n+\n+  struct __greater\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x > __y; }\n+  };\n+\n+  struct __less_equal\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x <= __y; }\n+  };\n+\n+  struct __greater_equal\n+  {\n+    template<typename _Tp>\n+      bool operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x >= __y; }\n+  };\n+\n+  // The few binary functions we miss.\n+  struct __atan2\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return atan2(__x, __y); }\n+  };\n+\n+  struct __pow\n+  {\n+    template<typename _Tp>\n+      _Tp operator()(const _Tp& __x, const _Tp& __y) const\n+      { return pow(__x, __y); }\n+  };\n+\n+\n+  // We need these bits in order to recover the return type of\n+  // some functions/operators now that we're no longer using\n+  // function templates.\n+  template<typename, typename _Tp>\n+    struct __fun\n+    {\n+      typedef _Tp result_type;\n+    };\n+\n+  // several specializations for relational operators.\n+  template<typename _Tp>\n+    struct __fun<__logical_not, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__logical_and, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__logical_or, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__less, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__greater, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__less_equal, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__greater_equal, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__equal_to, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __fun<__not_equal_to, _Tp>\n+    {\n+      typedef bool result_type;\n+    };\n+\n+    //\n+    // Apply function taking a value/const reference closure\n+    //\n+\n+  template<typename _Dom, typename _Arg>\n+    class _FunBase \n+    {\n+    public:\n+      typedef typename _Dom::value_type value_type;\n+      \n+      _FunBase(const _Dom& __e, value_type __f(_Arg))\n+\t: _M_expr(__e), _M_func(__f) {}\n+\n+      value_type operator[](size_t __i) const\n+      { return _M_func (_M_expr[__i]); }\n+\n+      size_t size() const { return _M_expr.size ();}\n+\n+    private:\n+        const _Dom& _M_expr;\n+        value_type (*_M_func)(_Arg);\n+    };\n+\n+  template<class _Dom>\n+    struct _ValFunClos<_Expr,_Dom> : _FunBase<_Dom, typename _Dom::value_type> \n+    {\n+      typedef _FunBase<_Dom, typename _Dom::value_type> _Base;\n+      typedef typename _Base::value_type value_type;\n+      typedef value_type _Tp;\n+    \n+      _ValFunClos(const _Dom& __e, _Tp __f(_Tp)) : _Base(__e, __f) {}\n+    };\n+\n+  template<typename _Tp>\n+    struct _ValFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, _Tp>\n+    {\n+      typedef _FunBase<valarray<_Tp>, _Tp> _Base;\n+      typedef _Tp value_type;\n+      \n+      _ValFunClos(const valarray<_Tp>& __v, _Tp __f(_Tp)) : _Base(__v, __f) {}\n+    };\n+\n+  template<class _Dom>\n+    struct _RefFunClos<_Expr,_Dom> :\n+        _FunBase<_Dom, const typename _Dom::value_type&> \n+    {\n+      typedef _FunBase<_Dom, const typename _Dom::value_type&> _Base;\n+      typedef typename _Base::value_type value_type;\n+      typedef value_type _Tp;\n+      \n+      _RefFunClos(const _Dom& __e, _Tp __f(const _Tp&))\n+\t: _Base(__e, __f) {}\n+    };\n+\n+  template<typename _Tp>\n+    struct _RefFunClos<_ValArray,_Tp> : _FunBase<valarray<_Tp>, const _Tp&> \n+    {\n+      typedef _FunBase<valarray<_Tp>, const _Tp&> _Base;\n+      typedef _Tp value_type;\n+      \n+      _RefFunClos(const valarray<_Tp>& __v, _Tp __f(const _Tp&))\n+\t: _Base(__v, __f) {}\n+    };\n+    \n+  //\n+  // Unary expression closure.\n+  //\n+\n+  template<class _Oper, class _Arg>\n+    class _UnBase\n+    {\n+    public:\n+      typedef typename _Arg::value_type _Vt;\n+      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n+\n+      _UnBase(const _Arg& __e) : _M_expr(__e) {}\n+\n+      value_type operator[](size_t __i) const\n+      { return _M_expr[__i]; }\n+\n+      size_t size() const { return _M_expr.size(); }\n+\n+    private:\n+      const _Arg& _M_expr;\n+    };\n+\n+  template<class _Oper, class _Dom>\n+    struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom>\n+    {\n+      typedef _Dom _Arg;\n+      typedef _UnBase<_Oper, _Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _UnClos(const _Arg& __e) : _Base(__e) {}\n+    };\n+\n+  template<class _Oper, typename _Tp>\n+    struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> > \n+    {\n+      typedef valarray<_Tp> _Arg;\n+      typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _UnClos(const _Arg& __e) : _Base(__e) {}\n+    };\n+\n+\n+  //\n+  // Binary expression closure.\n+  //\n+\n+  template<class _Oper, class _FirstArg, class _SecondArg>\n+    class _BinBase \n+    {\n+    public:\n+        typedef typename _FirstArg::value_type _Vt;\n+        typedef typename __fun<_Oper, _Vt>::result_type value_type;\n+\n+      _BinBase(const _FirstArg& __e1, const _SecondArg& __e2)\n+\t: _M_expr1(__e1), _M_expr2(__e2) {}\n+      \n+      value_type operator[](size_t __i) const\n+      { return _Oper()(_M_expr1[__i], _M_expr2[__i]); }\n+\n+      size_t size() const { return _M_expr1.size(); }\n+        \n+    private:\n+      const _FirstArg& _M_expr1;\n+      const _SecondArg& _M_expr2;\n+    };\n+\n+\n+  template<class _Oper, class _Clos>\n+    class _BinBase2\n+    {\n+    public:\n+      typedef typename _Clos::value_type _Vt;\n+      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n+\n+      _BinBase2(const _Clos& __e, const _Vt& __t)\n+\t: _M_expr1(__e), _M_expr2(__t) {}\n+\n+      value_type operator[](size_t __i) const\n+      { return _Oper()(_M_expr1[__i], _M_expr2); }\n+\n+      size_t size() const { return _M_expr1.size(); }\n+\n+    private:\n+      const _Clos& _M_expr1;\n+      const _Vt& _M_expr2;\n+    };\n+\n+  template<class _Oper, class _Clos>\n+    class _BinBase1\n+    {\n+    public:\n+      typedef typename _Clos::value_type _Vt;\n+      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n+\n+      _BinBase1(const _Vt& __t, const _Clos& __e)\n+\t: _M_expr1(__t), _M_expr2(__e) {}\n+\n+      value_type operator[](size_t __i) const\n+      { return _Oper()(_M_expr1, _M_expr2[__i]); }\n+      \n+      size_t size() const { return _M_expr2.size(); }\n+\n+    private:\n+      const _Vt& _M_expr1;\n+      const _Clos& _M_expr2;\n+    };\n+    \n+  template<class _Oper, class _Dom1, class _Dom2>\n+    struct _BinClos<_Oper, _Expr, _Expr, _Dom1, _Dom2>\n+        : _BinBase<_Oper,_Dom1,_Dom2> \n+    {\n+      typedef _BinBase<_Oper,_Dom1,_Dom2> _Base;\n+      typedef typename _Base::value_type value_type;\n+        \n+      _BinClos(const _Dom1& __e1, const _Dom2& __e2) : _Base(__e1, __e2) {}\n+    };\n+\n+  template<class _Oper, typename _Tp>\n+    struct _BinClos<_Oper,_ValArray,_ValArray,_Tp,_Tp>\n+      : _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > \n+    {\n+      typedef _BinBase<_Oper,valarray<_Tp>,valarray<_Tp> > _Base;\n+      typedef _Tp value_type;\n+\n+      _BinClos(const valarray<_Tp>& __v, const valarray<_Tp>& __w)\n+\t: _Base(__v, __w) {}\n+    };\n+\n+  template<class _Oper, class _Dom>\n+    struct _BinClos<_Oper,_Expr,_ValArray,_Dom,typename _Dom::value_type>\n+      : _BinBase<_Oper,_Dom,valarray<typename _Dom::value_type> > \n+    {\n+      typedef typename _Dom::value_type _Tp;\n+      typedef _BinBase<_Oper,_Dom,valarray<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const _Dom& __e1, const valarray<_Tp>& __e2)\n+\t: _Base(__e1, __e2) {}\n+    };\n+\n+  template<class _Oper, class _Dom>\n+    struct  _BinClos<_Oper,_ValArray,_Expr,typename _Dom::value_type,_Dom>\n+      : _BinBase<_Oper,valarray<typename _Dom::value_type>,_Dom> \n+    {\n+      typedef typename _Dom::value_type _Tp;\n+      typedef _BinBase<_Oper,valarray<_Tp>,_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const valarray<_Tp>& __e1, const _Dom& __e2)\n+\t: _Base(__e1, __e2) {}\n+    };\n+\n+  template<class _Oper, class _Dom>\n+    struct _BinClos<_Oper,_Expr,_Constant,_Dom,typename _Dom::value_type>\n+      : _BinBase2<_Oper,_Dom> \n+    {\n+      typedef typename _Dom::value_type _Tp;\n+      typedef _BinBase2<_Oper,_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const _Dom& __e1, const _Tp& __e2) : _Base(__e1, __e2) {}\n+    };\n+\n+  template<class _Oper, class _Dom>\n+    struct _BinClos<_Oper,_Constant,_Expr,typename _Dom::value_type,_Dom>\n+      : _BinBase1<_Oper,_Dom> \n+    {\n+      typedef typename _Dom::value_type _Tp;\n+      typedef _BinBase1<_Oper,_Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const _Tp& __e1, const _Dom& __e2) : _Base(__e1, __e2) {}\n+    };\n+    \n+  template<class _Oper, typename _Tp>\n+    struct _BinClos<_Oper,_ValArray,_Constant,_Tp,_Tp>\n+      : _BinBase2<_Oper,valarray<_Tp> > \n+    {\n+      typedef _BinBase2<_Oper,valarray<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const valarray<_Tp>& __v, const _Tp& __t) : _Base(__v, __t) {}\n+    };\n+\n+  template<class _Oper, typename _Tp>\n+    struct _BinClos<_Oper,_Constant,_ValArray,_Tp,_Tp>\n+      : _BinBase1<_Oper,valarray<_Tp> > \n+    {\n+      typedef _BinBase1<_Oper,valarray<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _BinClos(const _Tp& __t, const valarray<_Tp>& __v) : _Base(__t, __v) {}\n+    };\n+        \n+\n+    //\n+    // slice_array closure.\n+    //\n+    template<typename _Dom>  class _SBase {\n+    public:\n+        typedef typename _Dom::value_type value_type;\n+\n+        _SBase (const _Dom& __e, const slice& __s)\n+                : _M_expr (__e), _M_slice (__s) {}\n+        value_type operator[] (size_t __i) const\n+        { return _M_expr[_M_slice.start () + __i * _M_slice.stride ()]; }\n+        size_t size() const { return _M_slice.size (); }\n+\n+    private:\n+        const _Dom& _M_expr;\n+        const slice& _M_slice;\n+    };\n+\n+    template<typename _Tp> class _SBase<_Array<_Tp> > {\n+    public:\n+        typedef _Tp value_type;\n+\n+        _SBase (_Array<_Tp> __a, const slice& __s)\n+                : _M_array (__a._M_data+__s.start()), _M_size (__s.size()),\n+                  _M_stride (__s.stride()) {}\n+        value_type operator[] (size_t __i) const\n+        { return _M_array._M_data[__i * _M_stride]; }\n+        size_t size() const { return _M_size; }\n+\n+    private:\n+        const _Array<_Tp> _M_array;\n+        const size_t _M_size;\n+        const size_t _M_stride;\n+    };\n+\n+    template<class _Dom> struct  _SClos<_Expr,_Dom> : _SBase<_Dom> {\n+        typedef _SBase<_Dom> _Base;\n+        typedef typename _Base::value_type value_type;\n+        \n+        _SClos (const _Dom& __e, const slice& __s) : _Base (__e, __s) {}\n+    };\n+\n+    template<typename _Tp>\n+    struct _SClos<_ValArray,_Tp> : _SBase<_Array<_Tp> > {\n+        typedef  _SBase<_Array<_Tp> > _Base;\n+        typedef _Tp value_type;\n+\n+        _SClos (_Array<_Tp> __a, const slice& __s) : _Base (__a, __s) {}\n+    };\n+\n+} // std::\n+\n+\n+#endif /* _CPP_VALARRAY_BEFORE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "31b84399c724468be9a601b96ce22b641531c54a", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13bea50d1ad5ab3408633a9378e4e78af52192d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=c13bea50d1ad5ab3408633a9378e4e78af52192d", "patch": "@@ -90,7 +90,7 @@ namespace std\n } // namespace std\n \n #include <bits/valarray_array.h>\n-#include <bits/valarray_meta.h>\n+#include <bits/valarray_before.h>\n   \n namespace std\n {\n@@ -229,7 +229,9 @@ namespace std\n     { return _M_data[__i]; }\n \n } // std::\n-      \n+\n+#include <bits/valarray_after.h>\n+\n #include <bits/slice_array.h>\n #include <bits/gslice.h>\n #include <bits/gslice_array.h>"}]}