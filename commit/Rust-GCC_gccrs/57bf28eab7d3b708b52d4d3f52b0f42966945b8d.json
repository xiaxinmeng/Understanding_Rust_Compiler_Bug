{"sha": "57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdiZjI4ZWFiN2QzYjcwOGI1MmQ0ZDNmNTJiMGY0Mjk2Njk0NWI4ZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-10-28T16:57:12Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-28T16:57:12Z"}, "message": "re PR fortran/54958 (Wrongly rejects ac-implied-DO variables which also occur with INTENT(IN))\n\n2012-10-28  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54958\n        * gfortran.h (gfc_resolve_iterator_expr,\n        gfc_check_vardef_context): Update prototype.\n        * expr.c (gfc_check_vardef_context): Add own_scope\n        argument and honour it.\n        * resolve.c (gfc_resolve_iterator_expr): Add own_scope\n        argument and honour it.\n        (resolve_deallocate_expr, resolve_allocate_expr,\n        resolve_data_variables, resolve_transfer\n        resolve_lock_unlock, resolve_code): Update calls.\n        * array.c (resolve_array_list): Ditto.\n        * check.c (gfc_check_atomic_def, gfc_check_atomic_ref): Ditto.\n        * interface.c (compare_actual_formal): Ditto.\n        * intrinsic.c (check_arglist): Ditto.\n        * io.c (resolve_tag, gfc_resolve_dt, gfc_resolve_inquire):\n        * Ditto.\n\n2012-10-28  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54958\n        * gfortran.dg/do_check_6.f90: New.\n\nFrom-SVN: r192896", "tree": {"sha": "c44e73e72c315e9062bb21c9d63b806af2cd111c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c44e73e72c315e9062bb21c9d63b806af2cd111c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "036e1775739f9449a055adae2cb262e17336f74d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036e1775739f9449a055adae2cb262e17336f74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036e1775739f9449a055adae2cb262e17336f74d"}], "stats": {"total": 186, "additions": 150, "deletions": 36}, "files": [{"sha": "08cac6c9a99999a936f607527c8cf234d7645331", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -1,3 +1,21 @@\n+2012-10-28  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54958\n+\t* gfortran.h (gfc_resolve_iterator_expr,\n+\tgfc_check_vardef_context): Update prototype.\n+\t* expr.c (gfc_check_vardef_context): Add own_scope\n+\targument and honour it.\n+\t* resolve.c (gfc_resolve_iterator_expr): Add own_scope\n+\targument and honour it.\n+\t(resolve_deallocate_expr, resolve_allocate_expr,\n+\tresolve_data_variables, resolve_transfer\n+\tresolve_lock_unlock, resolve_code): Update calls.\n+\t* array.c (resolve_array_list): Ditto.\n+\t* check.c (gfc_check_atomic_def, gfc_check_atomic_ref): Ditto.\n+\t* interface.c (compare_actual_formal): Ditto.\n+\t* intrinsic.c (check_arglist): Ditto.\n+\t* io.c (resolve_tag, gfc_resolve_dt, gfc_resolve_inquire): Ditto.\n+\n 2012-10-27  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* trans.c (gfc_allocate_allocatable):  Revert accidental"}, {"sha": "349151755c0ac32bc2f96112b887566e69a476bf", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -1816,7 +1816,7 @@ resolve_array_list (gfc_constructor_base base)\n \t  gfc_symbol *iter_var;\n \t  locus iter_var_loc;\n \t \n-\t  if (gfc_resolve_iterator (iter, false) == FAILURE)\n+\t  if (gfc_resolve_iterator (iter, false, true) == FAILURE)\n \t    t = FAILURE;\n \n \t  /* Check for bounds referencing the iterator variable.  */"}, {"sha": "a4902385070b1624615a6ff097a4b9d410672420", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -1046,7 +1046,7 @@ gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value)\n   if (scalar_check (atom, 0) == FAILURE || scalar_check (value, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (atom, false, false, NULL) == FAILURE)\n+  if (gfc_check_vardef_context (atom, false, false, false, NULL) == FAILURE)\n     {\n       gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n \t\t \"definable\", gfc_current_intrinsic, &atom->where);\n@@ -1063,7 +1063,7 @@ gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom)\n   if (scalar_check (value, 0) == FAILURE || scalar_check (atom, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (value, false, false, NULL) == FAILURE)\n+  if (gfc_check_vardef_context (value, false, false, false, NULL) == FAILURE)\n     {\n       gfc_error (\"VALUE argument of the %s intrinsic function at %L shall be \"\n \t\t \"definable\", gfc_current_intrinsic, &value->where);"}, {"sha": "211f304164cfc0f63743c6336d8d4aae5b16da30", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -4634,13 +4634,15 @@ gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n    (F2008, 16.6.7) or pointer association context (F2008, 16.6.8).\n    This is called from the various places when resolving\n    the pieces that make up such a context.\n+   If own_scope is true (applies to, e.g., ac-implied-do/data-implied-do\n+   variables), some checks are not performed.\n \n    Optionally, a possible error message can be suppressed if context is NULL\n    and just the return status (SUCCESS / FAILURE) be requested.  */\n \n gfc_try\n gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n-\t\t\t  const char* context)\n+\t\t\t  bool own_scope, const char* context)\n {\n   gfc_symbol* sym = NULL;\n   bool is_pointer;\n@@ -4725,7 +4727,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n      assignment to a pointer component from pointer-assignment to a pointer\n      component.  Note that (normal) assignment to procedure pointers is not\n      possible.  */\n-  check_intentin = true;\n+  check_intentin = !own_scope;\n   ptr_component = (sym->ts.type == BT_CLASS && CLASS_DATA (sym))\n \t\t  ? CLASS_DATA (sym)->attr.class_pointer : sym->attr.pointer;\n   for (ref = e->ref; ref && check_intentin; ref = ref->next)\n@@ -4760,7 +4762,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n     }\n \n   /* PROTECTED and use-associated.  */\n-  if (sym->attr.is_protected && sym->attr.use_assoc  && check_intentin)\n+  if (sym->attr.is_protected && sym->attr.use_assoc && check_intentin)\n     {\n       if (pointer && is_pointer)\n \t{\n@@ -4782,7 +4784,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \n   /* Variable not assignable from a PURE procedure but appears in\n      variable definition context.  */\n-  if (!pointer && gfc_pure (NULL) && gfc_impure_variable (sym))\n+  if (!pointer && !own_scope && gfc_pure (NULL) && gfc_impure_variable (sym))\n     {\n       if (context)\n \tgfc_error (\"Variable '%s' can not appear in a variable definition\"\n@@ -4856,7 +4858,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t}\n \n       /* Target must be allowed to appear in a variable definition context.  */\n-      if (gfc_check_vardef_context (assoc->target, pointer, false, NULL)\n+      if (gfc_check_vardef_context (assoc->target, pointer, false, false, NULL)\n \t  == FAILURE)\n \t{\n \t  if (context)"}, {"sha": "fabc16a85e0e4c24d1a6439a803970192c673b27", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -2784,7 +2784,7 @@ bool gfc_has_ultimate_allocatable (gfc_expr *);\n bool gfc_has_ultimate_pointer (gfc_expr *);\n \n gfc_expr* gfc_build_intrinsic_call (const char*, locus, unsigned, ...);\n-gfc_try gfc_check_vardef_context (gfc_expr*, bool, bool, const char*);\n+gfc_try gfc_check_vardef_context (gfc_expr*, bool, bool, bool, const char*);\n \n \n /* st.c */\n@@ -2805,7 +2805,7 @@ int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_implicit_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n-gfc_try gfc_resolve_iterator (gfc_iterator *, bool);\n+gfc_try gfc_resolve_iterator (gfc_iterator *, bool, bool);\n gfc_try find_forall_index (gfc_expr *, gfc_symbol *, int);\n gfc_try gfc_resolve_index (gfc_expr *, int);\n gfc_try gfc_resolve_dim_arg (gfc_expr *);"}, {"sha": "d90fc73e8dde220e70bb7555d08e2c0e4664d91d", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -2713,10 +2713,10 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (((f->sym->ts.type == BT_CLASS && f->sym->attr.class_ok\n \t\t&& CLASS_DATA (f->sym)->attr.class_pointer)\n \t       || (f->sym->ts.type != BT_CLASS && f->sym->attr.pointer))\n-\t      && gfc_check_vardef_context (a->expr, true, false, context)\n+\t      && gfc_check_vardef_context (a->expr, true, false, false, context)\n \t\t   == FAILURE)\n \t    return 0;\n-\t  if (gfc_check_vardef_context (a->expr, false, false, context)\n+\t  if (gfc_check_vardef_context (a->expr, false, false, false, context)\n \t\t== FAILURE)\n \t    return 0;\n \t}"}, {"sha": "95a0f500bc25043c574ea94ce8f69b0148085c8e", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -3646,8 +3646,8 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t\t\t\t : NULL);\n \n \t  /* No pointer arguments for intrinsics.  */\n-\t  if (gfc_check_vardef_context (actual->expr, false, false, context)\n-\t\t== FAILURE)\n+\t  if (gfc_check_vardef_context (actual->expr, false, false, false,\n+\t\t\t\t\tcontext) == FAILURE)\n \t    return FAILURE;\n \t}\n     }"}, {"sha": "bd84f1fc48ad11b543bc609ea3be6b39b60961fe", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -1534,7 +1534,7 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n       char context[64];\n \n       sprintf (context, _(\"%s tag\"), tag->name);\n-      if (gfc_check_vardef_context (e, false, false, context) == FAILURE)\n+      if (gfc_check_vardef_context (e, false, false, false, context) == FAILURE)\n \treturn FAILURE;\n     }\n   \n@@ -2867,7 +2867,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n       /* If we are writing, make sure the internal unit can be changed.  */\n       gcc_assert (k != M_PRINT);\n       if (k == M_WRITE\n-\t  && gfc_check_vardef_context (e, false, false,\n+\t  && gfc_check_vardef_context (e, false, false, false,\n \t\t\t\t       _(\"internal unit in WRITE\")) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -2897,7 +2897,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t  gfc_try t;\n \n \t  e = gfc_get_variable_expr (gfc_find_sym_in_symtree (n->sym));\n-\t  t = gfc_check_vardef_context (e, false, false, NULL);\n+\t  t = gfc_check_vardef_context (e, false, false, false, NULL);\n \t  gfc_free_expr (e);\n \n \t  if (t == FAILURE)\n@@ -4063,7 +4063,8 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n     { \\\n       char context[64]; \\\n       sprintf (context, _(\"%s tag with INQUIRE\"), (tag)->name); \\\n-      if (gfc_check_vardef_context ((expr), false, false, context) == FAILURE) \\\n+      if (gfc_check_vardef_context ((expr), false, false, false, \\\n+\t\t\t\t    context) == FAILURE) \\\n \treturn FAILURE; \\\n     }\n   INQUIRE_RESOLVE_TAG (&tag_iomsg, inquire->iomsg);"}, {"sha": "e39a137fd4f5d778dfbdcfe48731b65c05927717", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -6683,16 +6683,19 @@ gfc_resolve_iterator_expr (gfc_expr *expr, bool real_ok,\n \n \n /* Resolve the expressions in an iterator structure.  If REAL_OK is\n-   false allow only INTEGER type iterators, otherwise allow REAL types.  */\n+   false allow only INTEGER type iterators, otherwise allow REAL types.\n+   Set own_scope to true for ac-implied-do and data-implied-do as those\n+   have a separate scope such that, e.g., a INTENT(IN) doesn't apply.  */\n \n gfc_try\n-gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n+gfc_resolve_iterator (gfc_iterator *iter, bool real_ok, bool own_scope)\n {\n   if (gfc_resolve_iterator_expr (iter->var, real_ok, \"Loop variable\")\n       == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (iter->var, false, false, _(\"iterator variable\"))\n+  if (gfc_check_vardef_context (iter->var, false, false, own_scope,\n+\t\t\t\t_(\"iterator variable\"))\n       == FAILURE)\n     return FAILURE;\n \n@@ -6961,10 +6964,10 @@ resolve_deallocate_expr (gfc_expr *e)\n     }\n \n   if (pointer\n-      && gfc_check_vardef_context (e, true, true, _(\"DEALLOCATE object\"))\n+      && gfc_check_vardef_context (e, true, true, false, _(\"DEALLOCATE object\"))\n \t == FAILURE)\n     return FAILURE;\n-  if (gfc_check_vardef_context (e, false, true, _(\"DEALLOCATE object\"))\n+  if (gfc_check_vardef_context (e, false, true, false, _(\"DEALLOCATE object\"))\n       == FAILURE)\n     return FAILURE;\n \n@@ -7307,9 +7310,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   e2 = remove_last_array_ref (e);\n   t = SUCCESS;\n   if (t == SUCCESS && pointer)\n-    t = gfc_check_vardef_context (e2, true, true, _(\"ALLOCATE object\"));\n+    t = gfc_check_vardef_context (e2, true, true, false, _(\"ALLOCATE object\"));\n   if (t == SUCCESS)\n-    t = gfc_check_vardef_context (e2, false, true, _(\"ALLOCATE object\"));\n+    t = gfc_check_vardef_context (e2, false, true, false, _(\"ALLOCATE object\"));\n   gfc_free_expr (e2);\n   if (t == FAILURE)\n     goto failure;\n@@ -7489,7 +7492,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   /* Check the stat variable.  */\n   if (stat)\n     {\n-      gfc_check_vardef_context (stat, false, false, _(\"STAT variable\"));\n+      gfc_check_vardef_context (stat, false, false, false, _(\"STAT variable\"));\n \n       if ((stat->ts.type != BT_INTEGER\n \t   && !(stat->ref && (stat->ref->type == REF_ARRAY\n@@ -7532,7 +7535,8 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \tgfc_warning (\"ERRMSG at %L is useless without a STAT tag\",\n \t\t     &errmsg->where);\n \n-      gfc_check_vardef_context (errmsg, false, false, _(\"ERRMSG variable\"));\n+      gfc_check_vardef_context (errmsg, false, false, false,\n+\t\t\t\t_(\"ERRMSG variable\"));\n \n       if ((errmsg->ts.type != BT_CHARACTER\n \t   && !(errmsg->ref\n@@ -8618,7 +8622,7 @@ resolve_transfer (gfc_code *code)\n      code->ext.dt may be NULL if the TRANSFER is related to\n      an INQUIRE statement -- but in this case, we are not reading, either.  */\n   if (code->ext.dt && code->ext.dt->dt_io_kind->value.iokind == M_READ\n-      && gfc_check_vardef_context (exp, false, false, _(\"item in READ\"))\n+      && gfc_check_vardef_context (exp, false, false, false, _(\"item in READ\"))\n \t == FAILURE)\n     return;\n \n@@ -8739,7 +8743,7 @@ resolve_lock_unlock (gfc_code *code)\n \t       &code->expr2->where);\n \n   if (code->expr2\n-      && gfc_check_vardef_context (code->expr2, false, false,\n+      && gfc_check_vardef_context (code->expr2, false, false, false,\n \t\t\t\t   _(\"STAT variable\")) == FAILURE)\n     return;\n \n@@ -8751,7 +8755,7 @@ resolve_lock_unlock (gfc_code *code)\n \t       &code->expr3->where);\n \n   if (code->expr3\n-      && gfc_check_vardef_context (code->expr3, false, false,\n+      && gfc_check_vardef_context (code->expr3, false, false, false,\n \t\t\t\t   _(\"ERRMSG variable\")) == FAILURE)\n     return;\n \n@@ -8763,7 +8767,7 @@ resolve_lock_unlock (gfc_code *code)\n \t       \"variable\", &code->expr4->where);\n \n   if (code->expr4\n-      && gfc_check_vardef_context (code->expr4, false, false,\n+      && gfc_check_vardef_context (code->expr4, false, false, false,\n \t\t\t\t   _(\"ACQUIRED_LOCK variable\")) == FAILURE)\n     return;\n }\n@@ -9700,7 +9704,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n-\t  if (gfc_check_vardef_context (code->expr1, false, false,\n+\t  if (gfc_check_vardef_context (code->expr1, false, false, false,\n \t\t\t\t\t_(\"assignment\")) == FAILURE)\n \t    break;\n \n@@ -9739,10 +9743,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t       array ref may be present on the LHS and fool gfc_expr_attr\n \t       used in gfc_check_vardef_context.  Remove it.  */\n \t    e = remove_last_array_ref (code->expr1);\n-\t    t = gfc_check_vardef_context (e, true, false,\n+\t    t = gfc_check_vardef_context (e, true, false, false,\n \t\t\t\t\t  _(\"pointer assignment\"));\n \t    if (t == SUCCESS)\n-\t      t = gfc_check_vardef_context (e, false, false,\n+\t      t = gfc_check_vardef_context (e, false, false, false,\n \t\t\t\t\t    _(\"pointer assignment\"));\n \t    gfc_free_expr (e);\n \t    if (t == FAILURE)\n@@ -9804,7 +9808,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (code->ext.iterator != NULL)\n \t    {\n \t      gfc_iterator *iter = code->ext.iterator;\n-\t      if (gfc_resolve_iterator (iter, true) != FAILURE)\n+\t      if (gfc_resolve_iterator (iter, true, false) != FAILURE)\n \t\tgfc_resolve_do_iterator (code, iter->var->symtree->n.sym);\n \t    }\n \t  break;\n@@ -13563,7 +13567,7 @@ resolve_data_variables (gfc_data_variable *d)\n \t}\n       else\n \t{\n-\t  if (gfc_resolve_iterator (&d->iter, false) == FAILURE)\n+\t  if (gfc_resolve_iterator (&d->iter, false, true) == FAILURE)\n \t    return FAILURE;\n \n \t  if (resolve_data_variables (d->list) == FAILURE)"}, {"sha": "1bd66fa2fd5a45f398b0050174317c9f21108af9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -1,3 +1,8 @@\n+2012-10-28  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54958\n+\t* gfortran.dg/do_check_6.f90: New.\n+\n 2012-10-27  Dominique Dhumieres  <dominiq@lps.ens.fr>\n \t    Jack Howarth <howarth@bromo.med.uc.edu>\n "}, {"sha": "2e18f219f83a2a0116924021d2d3fb15d5586920", "filename": "gcc/testsuite/gfortran.dg/do_check_6.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57bf28eab7d3b708b52d4d3f52b0f42966945b8d/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_6.f90?ref=57bf28eab7d3b708b52d4d3f52b0f42966945b8d", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do compile }\n+!\n+! PR fortran/54958\n+!\n+module m\n+  integer, protected :: i\n+  integer :: j\n+end module m\n+\n+subroutine test1()\n+  use m\n+  implicit none\n+  integer :: A(5)\n+  ! Valid: data-implied-do (has a scope of the statement or construct)\n+  DATA (A(i), i=1,5)/5*42/ ! OK\n+\n+  ! Valid: ac-implied-do (has a scope of the statement or construct)\n+  print *, [(i, i=1,5 )] ! OK\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  forall (i = 1:5) ! OK\n+  end forall\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  do concurrent (i = 1:5) ! OK\n+  end do\n+\n+  ! Invalid: io-implied-do\n+  print *, (i, i=1,5 ) ! { dg-error \"PROTECTED and can not appear in a variable definition context .iterator variable.\" }\n+\n+  ! Invalid: do-variable in a do-stmt\n+  do i = 1, 5 ! { dg-error \"PROTECTED and can not appear in a variable definition context .iterator variable.\" }\n+  end do\n+end subroutine test1\n+\n+subroutine test2(i)\n+  implicit none\n+  integer, intent(in) :: i\n+  integer :: A(5)\n+  ! Valid: data-implied-do (has a scope of the statement or construct)\n+  DATA (A(i), i=1,5)/5*42/ ! OK\n+\n+  ! Valid: ac-implied-do (has a scope of the statement or construct)\n+  print *, [(i, i=1,5 )] ! OK\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  forall (i = 1:5) ! OK\n+  end forall\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  do concurrent (i = 1:5) ! OK\n+  end do\n+\n+  ! Invalid: io-implied-do\n+  print *, (i, i=1,5 ) ! { dg-error \"INTENT.IN. in variable definition context .iterator variable.\" }\n+\n+  ! Invalid: do-variable in a do-stmt\n+  do i = 1, 5 ! { dg-error \"INTENT.IN. in variable definition context .iterator variable.\" }\n+  end do\n+end subroutine test2\n+\n+pure subroutine test3()\n+  use m\n+  implicit none\n+  integer :: A(5)\n+  !DATA (A(j), j=1,5)/5*42/ ! Not allowed in pure\n+\n+  ! Valid: ac-implied-do (has a scope of the statement or construct)\n+  A = [(j, j=1,5 )] ! OK\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  forall (j = 1:5) ! OK\n+  end forall\n+\n+  ! Valid: index-name (has a scope of the statement or construct)\n+  do concurrent (j = 1:5) ! OK\n+  end do\n+\n+  ! print *, (j, j=1,5 ) ! I/O not allowed in PURE\n+\n+  ! Invalid: do-variable in a do-stmt\n+  do j = 1, 5 ! { dg-error \"variable definition context .iterator variable. at .1. in PURE procedure\" }\n+  end do\n+end subroutine test3"}]}