{"sha": "91d6f071fbbd5bc53d43902bb2259788b121ebfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkNmYwNzFmYmJkNWJjNTNkNDM5MDJiYjIyNTk3ODhiMTIxZWJmYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-02-21T03:24:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-02-21T03:24:03Z"}, "message": "runtime: Use a better heap location on arm64 systems.\n\nBefore this, the heap location used on a 64-bit system was not\navailable to user-space on arm64, so the \"32-bit\" strategy ended up\nbeing used.  So use somewhere that is available, and for bonus points\nis far away from where the kernel allocates address space by default.\n\nFrom-SVN: r207977", "tree": {"sha": "0e13770b6a813bbeb58ab023ca5029957226f017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e13770b6a813bbeb58ab023ca5029957226f017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d6f071fbbd5bc53d43902bb2259788b121ebfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d6f071fbbd5bc53d43902bb2259788b121ebfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d6f071fbbd5bc53d43902bb2259788b121ebfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d6f071fbbd5bc53d43902bb2259788b121ebfa/comments", "author": null, "committer": null, "parents": [{"sha": "cc73e54dc6f39bd07b18e8e01ce7577741f8d087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc73e54dc6f39bd07b18e8e01ce7577741f8d087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc73e54dc6f39bd07b18e8e01ce7577741f8d087"}], "stats": {"total": 30, "additions": 27, "deletions": 3}, "files": [{"sha": "7120457a5b7f31911ab717e3e46d1f1807d9c9da", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d6f071fbbd5bc53d43902bb2259788b121ebfa/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d6f071fbbd5bc53d43902bb2259788b121ebfa/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=91d6f071fbbd5bc53d43902bb2259788b121ebfa", "patch": "@@ -27,6 +27,31 @@ package runtime\n #define KindPtr GO_PTR\n #define KindNoPointers GO_NO_POINTERS\n \n+// GCCGO SPECIFIC CHANGE\n+//\n+// There is a long comment in runtime_mallocinit about where to put the heap\n+// on a 64-bit system.  It makes assumptions that are not valid on linux/arm64\n+// -- it assumes user space can choose the lower 47 bits of a pointer, but on\n+// linux/arm64 we can only choose the lower 39 bits.  This means the heap is\n+// roughly a quarter of the available address space and we cannot choose a bit\n+// pattern that all pointers will have -- luckily the GC is mostly precise\n+// these days so this doesn't matter all that much.  The kernel (as of 3.13)\n+// will allocate address space starting either down from 0x7fffffffff or up\n+// from 0x2000000000, so we put the heap roughly in the middle of these two\n+// addresses to minimize the chance that a non-heap allocation will get in the\n+// way of the heap.\n+//\n+// This all means that there isn't much point in trying 256 different\n+// locations for the heap on such systems.\n+#ifdef __aarch64__\n+#define HeapBase(i) ((void*)(uintptr)(0x40ULL<<32))\n+#define HeapBaseOptions 1\n+#else\n+#define HeapBase(i) ((void*)(uintptr)(i<<40|0x00c0ULL<<32))\n+#define HeapBaseOptions 0x80\n+#endif\n+// END GCCGO SPECIFIC CHANGE\n+\n // Mark mheap as 'no pointers', it does not contain interesting pointers but occupies ~45K.\n MHeap runtime_mheap;\n \n@@ -423,9 +448,8 @@ runtime_mallocinit(void)\n \t\tbitmap_size = arena_size / (sizeof(void*)*8/4);\n \t\tspans_size = arena_size / PageSize * sizeof(runtime_mheap.spans[0]);\n \t\tspans_size = ROUND(spans_size, PageSize);\n-\t\tfor(i = 0; i <= 0x7f; i++) {\n-\t\t\tp = (void*)(uintptr)(i<<40 | 0x00c0ULL<<32);\n-\t\t\tp = runtime_SysReserve(p, bitmap_size + spans_size + arena_size);\n+\t\tfor(i = 0; i < HeapBaseOptions; i++) {\n+\t\t\tp = runtime_SysReserve(HeapBase(i), bitmap_size + spans_size + arena_size);\n \t\t\tif(p != nil)\n \t\t\t\tbreak;\n \t\t}"}]}