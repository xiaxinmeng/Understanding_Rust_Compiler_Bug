{"sha": "84a43794dff072e156da165a54164c831e1c2b4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRhNDM3OTRkZmYwNzJlMTU2ZGExNjVhNTQxNjRjODMxZTFjMmI0ZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-01T19:33:01Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-02-01T19:33:01Z"}, "message": "Initial revision\n\nFrom-SVN: r11151", "tree": {"sha": "057cd1ef159e1ea2e622716f56bca59b08e5be98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/057cd1ef159e1ea2e622716f56bca59b08e5be98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84a43794dff072e156da165a54164c831e1c2b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a43794dff072e156da165a54164c831e1c2b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a43794dff072e156da165a54164c831e1c2b4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a43794dff072e156da165a54164c831e1c2b4e/comments", "author": null, "committer": null, "parents": [{"sha": "9e9ff70986960f763c364b25c47de7da238eb5e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9ff70986960f763c364b25c47de7da238eb5e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9ff70986960f763c364b25c47de7da238eb5e2"}], "stats": {"total": 1138, "additions": 1138, "deletions": 0}, "files": [{"sha": "64b96bfcd8e907754ac647d02a912245b6c57887", "filename": "gcc/cp/rtti.c", "status": "added", "additions": 1138, "deletions": 0, "changes": 1138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84a43794dff072e156da165a54164c831e1c2b4e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84a43794dff072e156da165a54164c831e1c2b4e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=84a43794dff072e156da165a54164c831e1c2b4e", "patch": "@@ -0,0 +1,1138 @@\n+/* RunTime Type Identification\n+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+\n+#undef NULL\n+#define NULL 0\n+\n+extern tree define_function ();\n+extern tree build_t_desc_overload ();\n+extern struct obstack *permanent_obstack;\n+\n+/* in c-common.c */\n+extern tree combine_strings PROTO((tree));\n+\f\n+/* Given the expression EXP of type `class *', return the head\n+   of the object pointed to by EXP.  */\n+tree\n+build_headof (exp)\n+     tree exp;\n+{\n+  tree type = TREE_TYPE (exp);\n+  tree vptr, offset;\n+\n+  if (TREE_CODE (type) != POINTER_TYPE)\n+    {\n+      error (\"`headof' applied to non-pointer type\");\n+      return error_mark_node;\n+    }\n+  type = TREE_TYPE (type);\n+\n+  if (!TYPE_VIRTUAL_P (type) || CLASSTYPE_VFIELD (type) == NULL_TREE)\n+    return exp;\n+\n+  vptr = fold (size_binop (PLUS_EXPR, \n+\t   size_binop (FLOOR_DIV_EXPR, \n+  \t     DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (type)),\n+\t     size_int (BITS_PER_UNIT)),\n+ \t   exp)); \n+  vptr = build1 (INDIRECT_REF, build_pointer_type (vtable_entry_type), vptr);\n+\n+  if (flag_vtable_thunks)\n+    offset = build_array_ref (vptr, integer_zero_node);\n+  else\n+    offset = build_component_ref (build_array_ref (vptr, integer_zero_node),\n+\t\t\t\t  delta_identifier,\n+\t\t\t\t  NULL_TREE, 0);\n+\n+  type = build_type_variant (ptr_type_node, TREE_READONLY (exp),\n+\t\t\t     TREE_THIS_VOLATILE (exp));\n+  return build (PLUS_EXPR, type, exp,\n+\t\tconvert (ptrdiff_type_node, offset));\n+}\n+\f\n+/* Return the type_info node associated with the expression EXP.  If EXP is\n+   a reference to a polymorphic class, return the dynamic type; otherwise\n+   return the static type of the expression.  */\n+tree\n+build_typeid (exp)\n+     tree exp;\n+{\n+  tree type;\n+\n+  if (!flag_rtti)\n+    cp_error (\"cannot take typeid of object when -frtti is not specified\");\n+\n+  if (exp == error_mark_node)\n+    return error_mark_node;\n+\n+  type = TREE_TYPE (exp);\n+\n+  /* Strip top-level cv-qualifiers.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  /* if b is an instance of B, typeid(b) == typeid(B).  Do this before\n+     reference trickiness.  */\n+  if (TREE_CODE (exp) == VAR_DECL && TREE_CODE (type) == RECORD_TYPE)\n+    return get_typeid (type);\n+\n+  /* peel back references, so they match. */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* Peel off cv qualifiers. */\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    type = build_reference_type (type);\n+\n+  /* If exp is a reference to polymorphic type, get the real type_info.  */\n+  if (TREE_CODE (type) == REFERENCE_TYPE && TYPE_VIRTUAL_P (TREE_TYPE (type)))\n+    {\n+      /* build reference to type_info from vtable.  */\n+      tree t;\n+\n+      if (flag_vtable_thunks)\n+\tt = build_vfn_ref ((tree *) NULL_TREE, exp, integer_one_node);\n+      else\n+\tt = build_vfn_ref ((tree *) NULL_TREE, exp, integer_zero_node);\n+\n+      TREE_TYPE (t) = build_pointer_type (__class_desc_type_node);\n+      t = build_indirect_ref (t, NULL);\n+      return t;\n+    }\n+\n+  /* otherwise return the type_info for the static type of the expr.  */\n+  return get_typeid (type);\n+}\n+\n+/* Return the type_info object for TYPE, creating it if necessary.  */\n+tree\n+get_typeid (type)\n+     tree type;\n+{\n+  tree t, td;\n+\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+  \n+  /* Is it useful (and/or correct) to have different typeids for `T &'\n+     and `T'?  */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  td = build_t_desc (type, 1);\n+  if (td == error_mark_node)\n+    return error_mark_node;\n+\n+  t = TREE_OPERAND (td, 0);\n+  return t;\n+}\n+\n+/* Get a bad_cast node for the program to throw...\n+\n+   See libstdc++::exception{,.cc} for __bad_cast_object */\n+tree\n+get_bad_cast_node ()\n+{\n+  static tree t;\n+  if (t == NULL_TREE\n+      && (t = lookup_name (get_identifier (\"__bad_cast_object\"), 0))\n+         == NULL_TREE)\n+    {\n+      error (\"you must #include <typeinfo>\");\n+      return error_mark_node;\n+    }\n+  return t;\n+}\n+\n+/* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n+   paper.  */\n+tree\n+build_dynamic_cast (type, expr)\n+     tree type, expr;\n+{\n+  enum tree_code tc = TREE_CODE (type);\n+  tree exprtype = TREE_TYPE (expr);\n+  enum tree_code ec = TREE_CODE (exprtype);\n+  tree retval;\n+\n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+  \n+  switch (tc)\n+    {\n+    case POINTER_TYPE:\n+      if (ec == REFERENCE_TYPE)\n+\t{\n+\t  expr = convert_from_reference (expr);\n+\t  exprtype = TREE_TYPE (expr);\n+\t  ec = TREE_CODE (exprtype);\n+\t}\n+      if (ec != POINTER_TYPE)\n+\tgoto fail;\n+      if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n+\tgoto fail;\n+      if (TYPE_SIZE (TREE_TYPE (exprtype)) == 0)\n+\tgoto fail;\n+      if (TREE_READONLY (TREE_TYPE (exprtype)) &&\n+\t  ! TYPE_READONLY (TREE_TYPE (type)))\n+\tgoto fail;\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+\tbreak;\n+      /* else fall through */\n+    case REFERENCE_TYPE:\n+      if (TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t  && TYPE_SIZE (TREE_TYPE (type)) != NULL_TREE)\n+\tbreak;\n+      /* else fall through */\n+    default:\n+      goto fail;\n+    }\n+\n+  /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n+  if (ec == RECORD_TYPE)\n+    {\n+      exprtype = build_type_variant (exprtype, TREE_READONLY (expr),\n+\t\t\t\t     TREE_THIS_VOLATILE (expr));\n+      exprtype = build_reference_type (exprtype);\n+      expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n+\t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n+      ec = REFERENCE_TYPE;\n+    }\n+\n+  if (tc == REFERENCE_TYPE)\n+    {\n+      if (ec != REFERENCE_TYPE)\n+\tgoto fail;\n+      if (TREE_CODE (TREE_TYPE (exprtype)) != RECORD_TYPE)\n+\tgoto fail;\n+      if (TYPE_SIZE (TREE_TYPE (exprtype)) == 0)\n+\tgoto fail;\n+      if (TREE_READONLY (TREE_TYPE (exprtype)) &&\n+\t  ! TYPE_READONLY (TREE_TYPE (type)))\n+\tgoto fail;\n+    }\n+\n+  /* If *type is an unambiguous accessible base class of *exprtype,\n+     convert statically.  */\n+  {\n+    int distance;\n+    tree path;\n+\n+    distance = get_base_distance (TREE_TYPE (type), TREE_TYPE (exprtype), 1,\n+\t\t\t\t  &path);\n+    if (distance >= 0)\n+      return build_vbase_path (PLUS_EXPR, type, expr, path, 0);\n+  }\n+\n+  /* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */\n+  if (TYPE_VIRTUAL_P (TREE_TYPE (exprtype)))\n+    {\n+      /* if TYPE is `void *', return pointer to complete object.  */\n+      if (tc == POINTER_TYPE\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n+\t{\n+\t  /* if b is an object, dynamic_cast<void *>(&b) == (void *)&b.  */\n+\t  if (TREE_CODE (expr) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (expr, 0)) == VAR_DECL\n+\t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE)\n+\t    return build1 (NOP_EXPR, type, expr);\n+\n+\t  return build_headof (expr);\n+\t}\n+      else\n+\t{\n+\t  tree retval;\n+          tree result, td1, td2, elems, tmp1, expr1;\n+\n+ \t  /* If we got here, we can't convert statically.  Therefore,\n+\t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n+\t  if (ec == REFERENCE_TYPE)\n+\t    {\n+\t      if (TREE_CODE (expr) == VAR_DECL\n+\t\t  && TREE_CODE (TREE_TYPE (expr)) == RECORD_TYPE)\n+\t\t{\n+\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n+\t\t\t      expr, type);\n+\t\t  return build_throw (get_bad_cast_node ());\n+\t\t}\n+\t    }\n+\t  /* Ditto for dynamic_cast<D*>(&b).  */\n+\t  else if (TREE_CODE (expr) == ADDR_EXPR)\n+\t    {\n+\t      tree op = TREE_OPERAND (expr, 0);\n+\t      if (TREE_CODE (op) == VAR_DECL\n+\t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n+\t\t{\n+\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n+\t\t\t      expr, type);\n+\t\t  retval = build_int_2 (0, 0); \n+\t\t  TREE_TYPE (retval) = type; \n+\t\t  return retval;\n+\t\t}\n+\t    }\n+\n+\t  expr1 = expr;\n+\t  if (tc == REFERENCE_TYPE)\n+\t    expr1 = build_unary_op (ADDR_EXPR, expr1, 0);\n+\n+\t  /* Build run-time conversion.  */\n+\t  expr1 = build_headof (expr1);\n+\n+\t  if (ec == POINTER_TYPE)\n+\t    td1 = build_typeid (build_indirect_ref (expr, NULL_PTR));\n+\t  else\n+\t    td1 = build_typeid (expr);\n+\t  \n+\t  if (tc == POINTER_TYPE)\n+\t    td2 = get_typeid (TREE_TYPE (type));\n+\t  else\n+\t    td2 = get_typeid (TYPE_MAIN_VARIANT (TREE_TYPE (type)));\n+\n+          elems = tree_cons (NULL_TREE, td2,\n+            tree_cons (NULL_TREE, build_int_2 (1, 0),\n+\t      tree_cons (NULL_TREE, expr1, NULL_TREE)));\n+          result = build_method_call (td1,\n+            get_identifier (\"__rtti_match\"), elems, NULL_TREE, LOOKUP_NORMAL);\n+\n+\t  if (tc == REFERENCE_TYPE)\n+\t    {\n+\t      expr1 = build_throw (get_bad_cast_node ());\n+\t      expr1 = build_compound_expr (tree_cons (NULL_TREE, expr1,\n+\t\t\t\t\t\t      build_tree_list (NULL_TREE, convert (type, integer_zero_node))));\n+\t      TREE_TYPE (expr1) = type;\n+\t      result = save_expr (result);\n+\t      return build (COND_EXPR, type, result, result, expr1);\n+\t    }\n+\n+\t  /* Now back to the type we want from a void*. */\n+\t  result = convert (type, result);\n+          return result;\n+\t}\n+    }\n+\n+ fail:\n+  cp_error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'\",\n+\t    expr, exprtype, type);\n+  return error_mark_node;\n+}\n+\f\n+/* Build and initialize various sorts of descriptors.  Every descriptor\n+   node has a name associated with it (the name created by mangling).\n+   For this reason, we use the identifier as our access to the __*_desc\n+   nodes, instead of sticking them directly in the types.  Otherwise we\n+   would burden all built-in types (and pointer types) with slots that\n+   we don't necessarily want to use.\n+\n+   For each descriptor we build, we build a variable that contains\n+   the descriptor's information.  When we need this info at runtime,\n+   all we need is access to these variables.\n+\n+   Note: these constructors always return the address of the descriptor\n+   info, since that is simplest for their mutual interaction.  */\n+\n+static tree\n+build_generic_desc (tdecl, type, elems)\n+     tree tdecl;\n+     tree type;\n+     tree elems;\n+{\n+  tree init = elems;\n+  int toplev = global_bindings_p ();\n+\n+  TREE_CONSTANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n+  TREE_READONLY (init) = 1;\n+\n+  TREE_TYPE (tdecl) = type;\n+  DECL_INITIAL (tdecl) = init;\n+  TREE_STATIC (tdecl) = 1;\n+  DECL_SIZE (tdecl) = NULL_TREE;\n+  layout_decl (tdecl, 0);\n+  if (! toplev)\n+    push_to_top_level ();\n+  cp_finish_decl (tdecl, init, NULL_TREE, 0, 0);\n+  if (! toplev)\n+    pop_from_top_level ();\n+\n+  if (! TREE_USED (tdecl))\n+    {\n+      assemble_external (tdecl);\n+      TREE_USED (tdecl) = 1;\n+    }\n+\n+  return IDENTIFIER_AS_DESC (DECL_NAME (tdecl));\n+}\n+\n+/* Build an initializer for a __bltn_desc node.  */\n+static tree\n+build_bltn_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{\n+  tree elems, t;\n+\n+  if (type == boolean_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_BOOL\"),\n+\t\t      0, 0);\n+  else if (type == char_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_CHAR\"),\n+\t\t      0, 0);\n+  else if (type == short_integer_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_SHORT\"),\n+\t\t      0, 0);\n+  else if (type == integer_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_INT\"),\n+\t\t      0, 0);\n+  else if (type == long_integer_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_LONG\"),\n+\t\t      0, 0);\n+  else if (type == long_long_integer_type_node)\n+    t = lookup_field (__bltn_desc_type_node, \n+\t\t      get_identifier(\"_RTTI_BI_LONGLONG\"), 0, 0);\n+  else if (type == float_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_FLOAT\"),\n+\t\t      0, 0);\n+  else if (type == double_type_node)\n+    t = lookup_field (__bltn_desc_type_node, \n+\t\t      get_identifier(\"_RTTI_BI_DOUBLE\"), 0, 0);\n+  else if (type == long_double_type_node)\n+    t = lookup_field (__bltn_desc_type_node, \n+\t\t      get_identifier(\"_RTTI_BI_LDOUBLE\"), 0, 0);\n+  else if (type == unsigned_char_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_UCHAR\"),\n+\t\t      0, 0);\n+  else if (type == short_unsigned_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_USHORT\"),\n+\t\t      0, 0);\n+  else if (type == unsigned_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_UINT\"),\n+\t\t      0, 0);\n+  else if (type == long_unsigned_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_ULONG\"),\n+\t\t      0, 0);\n+  else if (type == long_long_unsigned_type_node)\n+    t = lookup_field (__bltn_desc_type_node, \n+\t\t      get_identifier(\"_RTTI_BI_ULONGLONG\"), 0, 0);\n+  else if (type == signed_char_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_SCHAR\"),\n+\t\t      0, 0);\n+  else if (type == wchar_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_WCHAR\"),\n+\t\t      0, 0);\n+  else if (type == void_type_node)\n+    t = lookup_field (__bltn_desc_type_node, get_identifier(\"_RTTI_BI_VOID\"),\n+\t\t      0, 0);\n+  else\n+    {\n+      cp_compiler_error (\"type `%T' not handled as a built-in type\");\n+    }\n+\n+  elems = tree_cons (NULL_TREE, t, NULL_TREE);\n+  return build_generic_desc (tdecl, __bltn_desc_type_node, elems);\n+}\n+\n+/* Build an initializer for a __user_desc node.  */\n+static tree\n+build_user_desc (tdecl)\n+     tree tdecl;\n+{\n+  tree elems, name_string, t;\n+  tree tname = DECL_NAME (tdecl);\n+\n+  name_string = combine_strings (build_string \n+    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+  elems = name_string;\n+  return build_generic_desc (tdecl, __user_desc_type_node, elems);\n+}\n+\n+/* Build an initializer for a __class_type_info node. */\n+static tree\n+build_class_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{\n+  tree tname = DECL_NAME (tdecl);\n+  tree name_string;\n+\n+  int i = CLASSTYPE_N_BASECLASSES (type);\n+  int n_base = i;\n+  int base_cnt = 0;\n+  tree binfos = TYPE_BINFO_BASETYPES (type);\n+  tree vb = CLASSTYPE_VBASECLASSES (type);\n+  tree base, elems, access, offset, isvir;\n+  tree base_list, off_list, acc_list, isvir_list;\n+  tree t;\n+  static tree acc_pub = NULL_TREE;\n+  static tree acc_pro = NULL_TREE;\n+  static tree acc_pri = NULL_TREE;\n+\n+  if (acc_pub == NULL_TREE) \n+    {\n+      acc_pub = lookup_field (__class_desc_type_node, \n+                                get_identifier(\"_RTTI_ACCESS_PUBLIC\"), 0, 0);\n+      acc_pro = lookup_field (__class_desc_type_node,\n+                                get_identifier(\"_RTTI_ACCESS_PROTECTED\"), 0, 0);\n+      acc_pri = lookup_field (__class_desc_type_node,\n+                                get_identifier(\"_RTTI_ACCESS_PRIVATE\"), 0, 0);\n+    }\n+\n+  base_list = build_tree_list (NULL_TREE, integer_zero_node);\n+  off_list = build_tree_list (NULL_TREE, integer_zero_node);\n+  acc_list = build_tree_list (NULL_TREE, integer_zero_node);\n+  isvir_list = build_tree_list (NULL_TREE, integer_zero_node);\n+  while (--i >= 0)\n+    {\n+      tree binfo = TREE_VEC_ELT (binfos, i);\n+\n+      base = build_t_desc (BINFO_TYPE (binfo), 1);\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\t{\n+\t  tree t = BINFO_TYPE (binfo);\n+\t  char *name;\n+\t  tree field;\n+\t  int off;\n+\n+\t  name = (char *) alloca (TYPE_NAME_LENGTH (t)+sizeof (VBASE_NAME)+1);\n+\t  sprintf (name, VBASE_NAME_FORMAT, TYPE_NAME_STRING (t));\n+\t  field = lookup_field (type, get_identifier (name), 0, 0);\n+\t  offset = size_binop (FLOOR_DIV_EXPR, \n+\t\tDECL_FIELD_BITPOS (field), size_int (BITS_PER_UNIT));\n+\t}\n+      else\n+\toffset = BINFO_OFFSET (binfo);\n+\n+      if (TREE_VIA_PUBLIC (binfo))\n+        access = acc_pub;\n+      else if (TREE_VIA_PROTECTED (binfo))\n+\taccess = acc_pro;\n+      else\n+\taccess = acc_pri;\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\tisvir = build_int_2 (1, 0);\n+      else\n+\tisvir = build_int_2 (0, 0);\n+\n+      base_list = tree_cons (NULL_TREE, base, base_list);\n+      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n+      acc_list = tree_cons (NULL_TREE, access, acc_list);\n+      off_list = tree_cons (NULL_TREE, offset, off_list);\n+      base_cnt++;\n+    }\n+#if 0\n+  i = n_base;\n+  while (vb)\n+    {\n+      tree b;\n+      access = acc_pub;\n+      while (--i >= 0)\n+\t{\n+\t  b = TREE_VEC_ELT (binfos, i);\n+\t  if (BINFO_TYPE (vb) == BINFO_TYPE (b) && TREE_VIA_VIRTUAL (b))\n+\t    {\n+\t      if (TREE_VIA_PUBLIC (b))\n+\t\taccess = acc_pub;\n+\t      else if (TREE_VIA_PROTECTED (b))\n+\t\taccess = acc_pro;\n+\t      else\n+\t\taccess = acc_pri;\n+\t      break;\n+\t    }\n+\t}\n+      base = build_t_desc (BINFO_TYPE (vb), 1);\n+      offset = BINFO_OFFSET (vb);\n+      isvir = build_int_2 (1, 0);\n+\n+      base_list = tree_cons (NULL_TREE, base, base_list);\n+      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n+      acc_list = tree_cons (NULL_TREE, access, acc_list);\n+      off_list = tree_cons (NULL_TREE, offset, off_list);\n+\n+      base_cnt++;\n+      vb = TREE_CHAIN (vb);\n+    }\n+#endif\n+  base_list = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), \n+\t\t\t    base_list, 0);\n+  off_list = finish_table (NULL_TREE, integer_type_node, \n+\t\t\t    off_list, 0);\n+  isvir_list = finish_table (NULL_TREE, integer_type_node, \n+\t\t\t    isvir_list, 0);\n+  acc_list = finish_table (NULL_TREE, __access_mode_type_node, \n+\t\t\t    acc_list, 0);\n+\n+\n+  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+\n+  elems = tree_cons (NULL_TREE, name_string,\n+\t    tree_cons (NULL_TREE, default_conversion (base_list),\n+\t      tree_cons (NULL_TREE, default_conversion (off_list),\n+\t\ttree_cons (NULL_TREE, default_conversion (isvir_list),\n+\t\t  tree_cons (NULL_TREE, default_conversion (acc_list),\n+\t      \t    tree_cons (NULL_TREE, build_int_2 (base_cnt, 0), NULL_TREE))))));\n+\n+  return build_generic_desc (tdecl, __class_desc_type_node, elems);\n+}\n+\n+/* Build an initializer for a __pointer_type_info node.  */\n+static tree\n+build_ptr_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{\n+  tree t, elems;\n+\n+  t = TREE_TYPE (type);\n+  t = build_t_desc (t, 1);\n+  t = build_indirect_ref (t, NULL);\n+  elems = tree_cons (NULL_TREE, t, NULL_TREE);\n+  return build_generic_desc (tdecl, __ptr_desc_type_node,  elems);\n+}\n+\n+/* Build an initializer for a __attr_type_info node.  */\n+static tree\n+build_attr_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{\n+  tree elems, t, attrval;\n+\n+  if (TYPE_READONLY (type))\n+    {\n+      if (TYPE_VOLATILE (type))\n+\tattrval = lookup_field (__attr_desc_type_node, \n+\t\t\t\tget_identifier(\"_RTTI_ATTR_CONSTVOL\"), 0, 0);\n+      else\n+\tattrval = lookup_field (__attr_desc_type_node, \n+\t\t\t\tget_identifier(\"_RTTI_ATTR_CONST\"), 0, 0);\n+    }\n+  else\n+    {\n+      if (TYPE_VOLATILE (type))\n+\tattrval = lookup_field (__attr_desc_type_node, \n+\t\t\t\tget_identifier(\"_RTTI_ATTR_VOLATILE\"), 0, 0);\n+    }\n+  t = build_t_desc (TYPE_MAIN_VARIANT (type), 1);\n+  t = build_indirect_ref (t , NULL);\n+  elems = tree_cons (NULL_TREE, attrval, tree_cons (NULL_TREE, t, NULL_TREE));\n+  return build_generic_desc (tdecl, __attr_desc_type_node,  elems);\n+}\n+\n+/* Build an initializer for a __func_type_info node.  */\n+static tree\n+build_func_desc (tdecl)\n+     tree tdecl;\n+{\n+  tree elems, name_string;\n+  tree tname = DECL_NAME (tdecl);\n+\n+  name_string = combine_strings (build_string \n+    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+  elems = name_string; \n+  return build_generic_desc (tdecl, __func_desc_type_node,  elems);\n+}\n+\n+/* Build an initializer for a __ptmf_type_info node.  */\n+static tree\n+build_ptmf_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{ \n+  tree elems, name_string;\n+  tree tname = DECL_NAME (tdecl);\n+\n+  name_string = combine_strings (build_string \n+    (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+  elems = name_string; \n+  return build_generic_desc (tdecl, __ptmf_desc_type_node,  elems);\n+}\n+\n+/* Build an initializer for a __ptmd_type_info node.  */\n+static tree\n+build_ptmd_desc (tdecl, type)\n+     tree tdecl;\n+     tree type;\n+{\n+  tree tc, t, elems;\n+  tc = build_t_desc (TYPE_OFFSET_BASETYPE (type), 1);\n+  tc = build_indirect_ref (tc , NULL);\n+  t = build_t_desc (TREE_TYPE (type), 1);\n+  t = build_indirect_ref (t , NULL);\n+  elems = tree_cons (NULL_TREE, tc,\n+\t    tree_cons (NULL_TREE, t, NULL_TREE));\n+  return build_generic_desc (tdecl, __ptmd_desc_type_node,  elems);\n+}\n+\n+struct uninst_st {\n+  tree type;\n+  struct uninst_st *next;\n+};\n+typedef struct uninst_st uninst_node;\n+static uninst_node * uninst_desc = (uninst_node *)NULL;\n+\n+static void\n+add_uninstantiated_desc (type)\n+     tree type;\n+{\n+  uninst_node *t;\n+\n+  t = (uninst_node *) xmalloc (sizeof (struct uninst_st));\n+  t->type = type;\n+  t->next = uninst_desc;\n+  uninst_desc = t;\n+}\n+\n+/* We may choose to link the emitting of certain high use TDs for certain\n+   objects, we do that here.  Return the type to link against if such a\n+   link exists, otherwise just return TYPE.  */\n+\n+tree\n+get_def_to_follow (type)\n+     tree type;\n+{\n+#if 0\n+  /* For now we don't lay out T&, T* TDs with the main TD for the object.  */\n+  /* Let T* and T& be written only when T is written (if T is an aggr).\n+     We do this for const, but not for volatile, since volatile\n+     is rare and const is not.  */\n+  if (!TYPE_VOLATILE (taggr)\n+      && (TREE_CODE (taggr) == POINTER_TYPE\n+\t  || TREE_CODE (taggr) == REFERENCE_TYPE)\n+      && IS_AGGR_TYPE (TREE_TYPE (taggr)))\n+    taggr = TREE_TYPE (taggr);\n+#endif\n+  return type;\n+}\n+\n+/* build a general type_info node. */\n+tree\n+build_t_desc (type, definition)\n+     tree type;\n+     int definition;\n+{\n+  tree tdecl;\n+  tree tname, name_string;\n+  tree elems;\n+  tree t, tt, taggr;\n+\n+  if (__ptmd_desc_type_node == NULL_TREE)\n+    {\n+      init_type_desc();\n+      if (__ptmd_desc_type_node)\n+\t{\n+          for ( ; uninst_desc; uninst_desc = uninst_desc->next )\n+\t    build_t_desc (uninst_desc->type, 1);\n+\t}\n+    }\n+  if (__t_desc_type_node == NULL_TREE)\n+    {\n+      static int warned = 0;\n+      if (! warned)\n+\t{\n+\t  cp_error (\"failed to build type descriptor node of '%T', maybe <typeinfo> not included\", type);\n+\t}\n+      warned = 1;\n+      return error_mark_node;\n+    }\n+  if (__ptmd_desc_type_node == NULL_TREE)\n+    {\n+      add_uninstantiated_desc (type);\n+      definition = 0;\n+    }\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  tname = build_t_desc_overload (type);\n+\n+  if (!IDENTIFIER_AS_DESC (tname))\n+    {\n+      tdecl = build_decl (VAR_DECL, tname, __t_desc_type_node);\n+      DECL_EXTERNAL (tdecl) = 1;\n+      TREE_PUBLIC (tdecl) = 1;\n+      tdecl = pushdecl_top_level (tdecl);\n+      SET_IDENTIFIER_AS_DESC (tname, build_unary_op (ADDR_EXPR, tdecl, 0));\n+      if (!definition)\n+\tcp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+    }\n+  else\n+    tdecl = TREE_OPERAND (IDENTIFIER_AS_DESC (tname), 0);\n+\n+  /* If it's not a definition, don't do anything more.  */\n+  if (!definition)\n+    return IDENTIFIER_AS_DESC (tname);\n+\n+  /* If it has already been written, don't to anything more.  */\n+  /* Should this be on tdecl? */\n+  if (TREE_ASM_WRITTEN (IDENTIFIER_AS_DESC (tname)))\n+    return IDENTIFIER_AS_DESC (tname);\n+\n+  /* If we previously defined it, return the defined result.  */\n+  if (DECL_INITIAL (tdecl))\n+    return IDENTIFIER_AS_DESC (tname);\n+    \n+  taggr = get_def_to_follow (type);\n+\n+  /* If we know that we don't need to write out this type's\n+     vtable, then don't write out it's type_info.  Somebody\n+     else will take care of that.  */\n+  if (IS_AGGR_TYPE (taggr) && CLASSTYPE_VFIELD (taggr))\n+    {\n+      /* Let's play follow the vtable. */\n+      TREE_PUBLIC (tdecl) = CLASSTYPE_INTERFACE_KNOWN (taggr);\n+      DECL_EXTERNAL (tdecl) = CLASSTYPE_INTERFACE_ONLY (taggr);\n+    }\n+  else\n+    {\n+      DECL_EXTERNAL (tdecl) = 0;\n+      TREE_PUBLIC (tdecl) = (definition > 1);\n+    }\n+\n+  if (DECL_EXTERNAL (tdecl))\n+    return IDENTIFIER_AS_DESC (tname);\n+\n+  /* Show that we are defining the t_desc for this type.  */\n+  DECL_INITIAL (tdecl) = error_mark_node;\n+  t = DECL_CONTEXT (tdecl);\n+  if ( t && TREE_CODE_CLASS (TREE_CODE (t)) == 't') \n+    pushclass (t, 2);\n+\n+  if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n+    t = build_attr_desc (tdecl, type);\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    t = build_ptr_desc (tdecl, type);\n+  else if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n+\t{\n+\t  type = TREE_TYPE (type);\n+\t  t = build_ptmd_desc (tdecl, type);\n+\t}\n+      else\n+\t{\n+\t  t = build_ptr_desc (tdecl, type);\n+\t}\n+    }\n+  else if (TYPE_BUILT_IN (type))\n+    t = build_bltn_desc (tdecl, type);\n+  else if (IS_AGGR_TYPE (type))\n+    {\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\t{\n+\t  t = build_ptmf_desc (tdecl, type);\n+\t}\n+      else\n+\t{\n+\t  t = build_class_desc (tdecl, type);\n+\t}\n+    }\n+  else if (TREE_CODE (type) == FUNCTION_TYPE)\n+    t = build_func_desc (tdecl);\n+  else \n+    t = build_user_desc (tdecl);\n+\n+  pop_obstacks ();\n+  return t;\n+}\n+\n+#if 0\n+/* This is the old dossier type descriptor generation code, it's much\n+   more extended than rtti. It's reserved for later use. */\n+/* Build an initializer for a __t_desc node.  So that we can take advantage\n+   of recursion, we accept NULL for TYPE.\n+   DEFINITION is greater than zero iff we must define the type descriptor\n+   (as opposed to merely referencing it).  1 means treat according to\n+   #pragma interface/#pragma implementation rules.  2 means define as\n+   global and public, no matter what.  */\n+tree\n+build_t_desc (type, definition)\n+     tree type;\n+     int definition;\n+{\n+  tree tdecl;\n+  tree tname, name_string;\n+  tree elems, fields;\n+  tree parents, vbases, offsets, ivars, methods, target_type;\n+  int method_count = 0, field_count = 0;\n+\n+  if (type == NULL_TREE)\n+    return NULL_TREE;\n+\n+  tname = build_t_desc_overload (type);\n+  if (IDENTIFIER_AS_DESC (tname)\n+      && (!definition || TREE_ASM_WRITTEN (IDENTIFIER_AS_DESC (tname))))\n+    return IDENTIFIER_AS_DESC (tname);\n+\n+  tdecl = lookup_name (tname, 0);\n+  if (tdecl == NULL_TREE)\n+    {\n+      tdecl = build_decl (VAR_DECL, tname, __t_desc_type_node);\n+      DECL_EXTERNAL (tdecl) = 1;\n+      TREE_PUBLIC (tdecl) = 1;\n+      tdecl = pushdecl_top_level (tdecl);\n+    }\n+  /* If we previously defined it, return the defined result.  */\n+  else if (definition && DECL_INITIAL (tdecl))\n+    return IDENTIFIER_AS_DESC (tname);\n+\n+  if (definition)\n+    {\n+      tree taggr = type;\n+      /* Let T* and T& be written only when T is written (if T is an aggr).\n+         We do this for const, but not for volatile, since volatile\n+\t is rare and const is not.  */\n+      if (!TYPE_VOLATILE (taggr)\n+\t  && (TREE_CODE (taggr) == POINTER_TYPE\n+\t      || TREE_CODE (taggr) == REFERENCE_TYPE)\n+\t  && IS_AGGR_TYPE (TREE_TYPE (taggr)))\n+\ttaggr = TREE_TYPE (taggr);\n+\n+      /* If we know that we don't need to write out this type's\n+\t vtable, then don't write out it's dossier.  Somebody\n+\t else will take care of that.  */\n+      if (IS_AGGR_TYPE (taggr) && CLASSTYPE_VFIELD (taggr))\n+\t{\n+\t  if (CLASSTYPE_VTABLE_NEEDS_WRITING (taggr))\n+\t    {\n+\t      TREE_PUBLIC (tdecl) = ! CLASSTYPE_INTERFACE_ONLY (taggr)\n+\t\t&& CLASSTYPE_INTERFACE_KNOWN (taggr);\n+\t      DECL_EXTERNAL (tdecl) = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (write_virtuals != 0)\n+\t\tTREE_PUBLIC (tdecl) = 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  DECL_EXTERNAL (tdecl) = 0;\n+\t  TREE_PUBLIC (tdecl) = (definition > 1);\n+\t}\n+    }\n+  SET_IDENTIFIER_AS_DESC (tname, build_unary_op (ADDR_EXPR, tdecl, 0));\n+\n+  if (!definition || DECL_EXTERNAL (tdecl))\n+    {\n+      /* That's it!  */\n+      cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+      return IDENTIFIER_AS_DESC (tname);\n+    }\n+\n+  /* Show that we are defining the t_desc for this type.  */\n+  DECL_INITIAL (tdecl) = error_mark_node;\n+\n+  parents = build_tree_list (NULL_TREE, integer_zero_node);\n+  vbases = build_tree_list (NULL_TREE, integer_zero_node);\n+  offsets = build_tree_list (NULL_TREE, integer_zero_node);\n+  methods = NULL_TREE;\n+  ivars = NULL_TREE;\n+\n+  if (TYPE_LANG_SPECIFIC (type))\n+    {\n+      int i = CLASSTYPE_N_BASECLASSES (type);\n+      tree method_vec = CLASSTYPE_METHOD_VEC (type);\n+      tree *meth, *end;\n+      tree binfos = TYPE_BINFO_BASETYPES (type);\n+      tree vb = CLASSTYPE_VBASECLASSES (type);\n+\n+      while (--i >= 0)\n+\tparents = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (TREE_VEC_ELT (binfos, i)), 0), parents);\n+\n+      while (vb)\n+\t{\n+\t  vbases = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (vb), 0), vbases);\n+\t  offsets = tree_cons (NULL_TREE, BINFO_OFFSET (vb), offsets);\n+\t  vb = TREE_CHAIN (vb);\n+\t}\n+\n+      if (method_vec)\n+\tfor (meth = TREE_VEC_END (method_vec),\n+\t     end = &TREE_VEC_ELT (method_vec, 0); meth-- != end; )\n+\t  if (*meth)\n+\t    {\n+\t      methods = tree_cons (NULL_TREE, build_m_desc (*meth), methods);\n+\t      method_count++;\n+\t    }\n+    }\n+\n+  if (IS_AGGR_TYPE (type))\n+    {\n+      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+\tif (TREE_CODE (fields) == FIELD_DECL\n+\t    || TREE_CODE (fields) == VAR_DECL)\n+\t  {\n+\t    ivars = tree_cons (NULL_TREE, build_i_desc (fields), ivars);\n+\t    field_count++;\n+\t  }\n+      ivars = nreverse (ivars);\n+    }\n+\n+  parents = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), parents, 0);\n+  vbases = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), vbases, 0);\n+  offsets = finish_table (NULL_TREE, integer_type_node, offsets, 0);\n+  if (methods == NULL_TREE)\n+    methods = null_pointer_node;\n+  else\n+    methods = build_unary_op (ADDR_EXPR,\n+\t\t\t      finish_table (NULL_TREE, __m_desc_type_node, methods, 0),\n+\t\t\t      0);\n+  if (ivars == NULL_TREE)\n+    ivars = null_pointer_node;\n+  else\n+    ivars = build_unary_op (ADDR_EXPR,\n+\t\t\t    finish_table (NULL_TREE, __i_desc_type_node, ivars, 0),\n+\t\t\t    0);\n+  if (TREE_TYPE (type))\n+    target_type = build_t_desc (TREE_TYPE (type), definition);\n+  else\n+    target_type = integer_zero_node;\n+\n+  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n+\n+  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n+\t   tree_cons (NULL_TREE,\n+\t\t      TYPE_SIZE(type)? size_in_bytes(type) : integer_zero_node,\n+\t     /* really should use bitfield initialization here.  */\n+\t     tree_cons (NULL_TREE, integer_zero_node,\n+\t      tree_cons (NULL_TREE, target_type,\n+\t       tree_cons (NULL_TREE, build_int_2 (field_count, 2),\n+\t\ttree_cons (NULL_TREE, build_int_2 (method_count, 2),\n+\t\t tree_cons (NULL_TREE, ivars,\n+\t\t  tree_cons (NULL_TREE, methods,\n+\t\t   tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, parents, 0),\n+\t\t    tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, vbases, 0),\n+\t\t     build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, offsets, 0))))))))))));\n+  return build_generic_desc (tdecl, elems);\n+}\n+\n+/* Build an initializer for a __i_desc node.  */\n+tree\n+build_i_desc (decl)\n+     tree decl;\n+{\n+  tree elems, name_string;\n+  tree taggr;\n+\n+  name_string = DECL_NAME (decl);\n+  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));\n+\n+  /* Now decide whether this ivar should cause it's type to get\n+     def'd or ref'd in this file.  If the type we are looking at\n+     has a proxy definition, we look at the proxy (i.e., a\n+     `foo *' is equivalent to a `foo').  */\n+  taggr = TREE_TYPE (decl);\n+\n+  if ((TREE_CODE (taggr) == POINTER_TYPE\n+       || TREE_CODE (taggr) == REFERENCE_TYPE)\n+      && TYPE_VOLATILE (taggr) == 0)\n+    taggr = TREE_TYPE (taggr);\n+\n+  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n+\t     tree_cons (NULL_TREE, DECL_FIELD_BITPOS (decl),\n+\t\tbuild_tree_list (NULL_TREE, build_t_desc (TREE_TYPE (decl),\n+\t\t\t\t\t\t\t  ! IS_AGGR_TYPE (taggr)))));\n+  taggr = build (CONSTRUCTOR, __i_desc_type_node, NULL_TREE, elems);\n+  TREE_CONSTANT (taggr) = 1;\n+  TREE_STATIC (taggr) = 1;\n+  TREE_READONLY (taggr) = 1;\n+  return taggr;\n+}\n+\n+/* Build an initializer for a __m_desc node.  */\n+tree\n+build_m_desc (decl)\n+     tree decl;\n+{\n+  tree taggr, elems, name_string;\n+  tree parm_count, req_count, vindex, vcontext;\n+  tree parms;\n+  int p_count, r_count;\n+  tree parm_types = NULL_TREE;\n+\n+  for (parms = TYPE_ARG_TYPES (TREE_TYPE (decl)), p_count = 0, r_count = 0;\n+       parms != NULL_TREE; parms = TREE_CHAIN (parms), p_count++)\n+    {\n+      taggr = TREE_VALUE (parms);\n+      if ((TREE_CODE (taggr) == POINTER_TYPE\n+\t   || TREE_CODE (taggr) == REFERENCE_TYPE)\n+\t  && TYPE_VOLATILE (taggr) == 0)\n+\ttaggr = TREE_TYPE (taggr);\n+\n+      parm_types = tree_cons (NULL_TREE, build_t_desc (TREE_VALUE (parms),\n+\t\t\t\t\t\t       ! IS_AGGR_TYPE (taggr)),\n+\t\t\t      parm_types);\n+      if (TREE_PURPOSE (parms) == NULL_TREE)\n+\tr_count++;\n+    }\n+\n+  parm_types = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node),\n+\t\t\t     nreverse (parm_types), 0);\n+  parm_count = build_int_2 (p_count, 0);\n+  req_count = build_int_2 (r_count, 0);\n+\n+  if (DECL_VINDEX (decl))\n+    vindex = DECL_VINDEX (decl);\n+  else\n+    vindex = integer_zero_node;\n+  if (DECL_CONTEXT (decl)\n+      && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n+    vcontext = build_t_desc (DECL_CONTEXT (decl), 0);\n+  else\n+    vcontext = integer_zero_node;\n+  name_string = DECL_NAME (decl);\n+  if (name_string == NULL)\n+      name_string = DECL_ASSEMBLER_NAME (decl);\n+  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));\n+\n+  /* Now decide whether the return type of this mvar\n+     should cause it's type to get def'd or ref'd in this file.\n+     If the type we are looking at has a proxy definition,\n+     we look at the proxy (i.e., a `foo *' is equivalent to a `foo').  */\n+  taggr = TREE_TYPE (TREE_TYPE (decl));\n+\n+  if ((TREE_CODE (taggr) == POINTER_TYPE\n+       || TREE_CODE (taggr) == REFERENCE_TYPE)\n+      && TYPE_VOLATILE (taggr) == 0)\n+    taggr = TREE_TYPE (taggr);\n+\n+  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n+\t     tree_cons (NULL_TREE, vindex,\n+\t\ttree_cons (NULL_TREE, vcontext,\n+\t\t   tree_cons (NULL_TREE, build_t_desc (TREE_TYPE (TREE_TYPE (decl)),\n+\t\t\t\t\t\t       ! IS_AGGR_TYPE (taggr)),\n+\t\t      tree_cons (NULL_TREE, build_c_cast (build_pointer_type (default_function_type), build_unary_op (ADDR_EXPR, decl, 0), 0),\n+\t\t\t tree_cons (NULL_TREE, parm_count,\n+\t\t\t    tree_cons (NULL_TREE, req_count,\n+\t\t\t       build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, parm_types, 0)))))))));\n+\n+  taggr = build (CONSTRUCTOR, __m_desc_type_node, NULL_TREE, elems);\n+  TREE_CONSTANT (taggr) = 1;\n+  TREE_STATIC (taggr) = 1;\n+  TREE_READONLY (taggr) = 1;\n+  return taggr;\n+}\n+#endif /* dossier */"}]}