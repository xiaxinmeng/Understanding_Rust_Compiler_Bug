{"sha": "6a6ac079858f2140567a8640718094213366a05b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2YWMwNzk4NThmMjE0MDU2N2E4NjQwNzE4MDk0MjEzMzY2YTA1Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-12-16T10:33:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:33:17Z"}, "message": "[Ada] Implement RM C.6(19) clause entirely in the front-end\n\n2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Requires_Atomic_Or_Volatile_Copy): New predicate.\n\t(Expand_Actuals): Use it to decide whether to add call by copy\n\tcode as per the RM C.6(19) clause.\n\t* fe.h (Is_Atomic_Object): Remove.\n\t(Is_Volatile_Object): Likewise.\n\t* sem_util.ads (Is_Atomic_Object): Remove WARNING note.\n\t(Is_Volatile_Object): Likewise.\n\t* gcc-interface/trans.c (atomic_or_volatile_copy_required_p): Delete.\n\t(Call_to_gnu): Do not implement the  RM C.6(19) clause.\n\nFrom-SVN: r279414", "tree": {"sha": "27bfe9ac195f06d79ca7c50bf3d556df4772ea61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27bfe9ac195f06d79ca7c50bf3d556df4772ea61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a6ac079858f2140567a8640718094213366a05b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a6ac079858f2140567a8640718094213366a05b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a6ac079858f2140567a8640718094213366a05b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a6ac079858f2140567a8640718094213366a05b/comments", "author": null, "committer": null, "parents": [{"sha": "4efe11c6bcb6ba19745e98fae8887e3b4a978965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4efe11c6bcb6ba19745e98fae8887e3b4a978965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4efe11c6bcb6ba19745e98fae8887e3b4a978965"}], "stats": {"total": 144, "additions": 68, "deletions": 76}, "files": [{"sha": "0f843f3b66eefd9f9fc6a0288195a889ae944b97", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6a6ac079858f2140567a8640718094213366a05b", "patch": "@@ -1,3 +1,15 @@\n+2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Requires_Atomic_Or_Volatile_Copy): New predicate.\n+\t(Expand_Actuals): Use it to decide whether to add call by copy\n+\tcode as per the RM C.6(19) clause.\n+\t* fe.h (Is_Atomic_Object): Remove.\n+\t(Is_Volatile_Object): Likewise.\n+\t* sem_util.ads (Is_Atomic_Object): Remove WARNING note.\n+\t(Is_Volatile_Object): Likewise.\n+\t* gcc-interface/trans.c (atomic_or_volatile_copy_required_p): Delete.\n+\t(Call_to_gnu): Do not implement the  RM C.6(19) clause.\n+\n 2019-12-16  Ghjuvan Lacambre  <lacambre@adacore.com>\n \n \t* sem_ch12.adb (Validate_Access_Subprogram_Instance): Add"}, {"sha": "62934c3d44e2de6373a9189d84443698bb2b39b9", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6a6ac079858f2140567a8640718094213366a05b", "patch": "@@ -1287,6 +1287,10 @@ package body Exp_Ch6 is\n       --  the context of a call. Now we need to complete the expansion, so we\n       --  unmark the analyzed bits in all prefixes.\n \n+      function Requires_Atomic_Or_Volatile_Copy return Boolean;\n+      --  Returns whether a copy is required as per RM C.6(19) and gives a\n+      --  warning in this case.\n+\n       ---------------------------\n       -- Add_Call_By_Copy_Code --\n       ---------------------------\n@@ -1938,6 +1942,43 @@ package body Exp_Ch6 is\n          end loop;\n       end Reset_Packed_Prefix;\n \n+      ----------------------------------------\n+      --  Requires_Atomic_Or_Volatile_Copy  --\n+      ----------------------------------------\n+\n+      function Requires_Atomic_Or_Volatile_Copy return Boolean is\n+      begin\n+         --  If the formal is already passed by copy, no need to do anything\n+\n+         if Is_By_Copy_Type (E_Formal) then\n+            return False;\n+         end if;\n+\n+         --  Check for atomicity mismatch\n+\n+         if Is_Atomic_Object (Actual) and then not Is_Atomic (E_Formal)\n+         then\n+            if Comes_From_Source (N) then\n+               Error_Msg_N\n+                 (\"?atomic actual passed by copy (RM C.6(19))\", Actual);\n+            end if;\n+            return True;\n+         end if;\n+\n+         --  Check for volatility mismatch\n+\n+         if Is_Volatile_Object (Actual) and then not Is_Volatile (E_Formal)\n+         then\n+            if Comes_From_Source (N) then\n+               Error_Msg_N\n+                 (\"?volatile actual passed by copy (RM C.6(19))\", Actual);\n+            end if;\n+            return True;\n+         end if;\n+\n+         return False;\n+      end Requires_Atomic_Or_Volatile_Copy;\n+\n    --  Start of processing for Expand_Actuals\n \n    begin\n@@ -2125,27 +2166,10 @@ package body Exp_Ch6 is\n             then\n                Add_Call_By_Copy_Code;\n \n-            --  If the actual is not a scalar and is marked for volatile\n-            --  treatment, whereas the formal is not volatile, then pass\n-            --  by copy unless it is a by-reference type.\n+            --  We may need to force a copy because of atomicity or volatility\n+            --  considerations.\n \n-            --  Note: we use Is_Volatile here rather than Treat_As_Volatile,\n-            --  because this is the enforcement of a language rule that applies\n-            --  only to \"real\" volatile variables, not e.g. to the address\n-            --  clause overlay case.\n-\n-            elsif Is_Entity_Name (Actual)\n-              and then Is_Volatile (Entity (Actual))\n-              and then not Is_By_Reference_Type (E_Actual)\n-              and then not Is_Scalar_Type (Etype (Entity (Actual)))\n-              and then not Is_Volatile (E_Formal)\n-            then\n-               Add_Call_By_Copy_Code;\n-\n-            elsif Nkind (Actual) = N_Indexed_Component\n-              and then Is_Entity_Name (Prefix (Actual))\n-              and then Has_Volatile_Components (Entity (Prefix (Actual)))\n-            then\n+            elsif Requires_Atomic_Or_Volatile_Copy then\n                Add_Call_By_Copy_Code;\n \n             --  Add call-by-copy code for the case of scalar out parameters\n@@ -2323,6 +2347,12 @@ package body Exp_Ch6 is\n             elsif Is_Possibly_Unaligned_Slice (Actual) then\n                Add_Call_By_Copy_Code;\n \n+            --  We may need to force a copy because of atomicity or volatility\n+            --  considerations.\n+\n+            elsif Requires_Atomic_Or_Volatile_Copy then\n+               Add_Call_By_Copy_Code;\n+\n             --  An unusual case: a current instance of an enclosing task can be\n             --  an actual, and must be replaced by a reference to self.\n "}, {"sha": "74eb2ad3e1d6191268b1e910a4a4c02fcc0cbd10", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=6a6ac079858f2140567a8640718094213366a05b", "patch": "@@ -281,17 +281,13 @@ extern Boolean Is_OK_Static_Expression\t(Node_Id);\n \n #define Defining_Entity\t\t\tsem_util__defining_entity\n #define First_Actual\t\t\tsem_util__first_actual\n-#define Is_Atomic_Object\t\tsem_util__is_atomic_object\n #define Is_Variable_Size_Record \tsem_util__is_variable_size_record\n-#define Is_Volatile_Object\t\tsem_util__is_volatile_object\n #define Next_Actual\t\t\tsem_util__next_actual\n #define Requires_Transient_Scope\tsem_util__requires_transient_scope\n \n extern Entity_Id Defining_Entity\t(Node_Id);\n extern Node_Id First_Actual\t\t(Node_Id);\n-extern Boolean Is_Atomic_Object \t(Node_Id);\n extern Boolean Is_Variable_Size_Record \t(Entity_Id Id);\n-extern Boolean Is_Volatile_Object \t(Node_Id);\n extern Node_Id Next_Actual\t\t(Node_Id);\n extern Boolean Requires_Transient_Scope\t(Entity_Id);\n "}, {"sha": "e1b09bedeb1d1467971a28021874d97177a45f98", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6a6ac079858f2140567a8640718094213366a05b", "patch": "@@ -5008,35 +5008,6 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n   return gnu_temp;\n }\n \n-/* Return whether ACTUAL parameter corresponding to FORMAL_TYPE must be passed\n-   by copy in a call as per RM C.6(19).  Note that we use the same predicates\n-   as in the front-end for RM C.6(12) because it's purely a legality issue.  */\n-\n-static bool\n-atomic_or_volatile_copy_required_p (Node_Id actual, Entity_Id formal_type)\n-{\n-  /* We should not have a scalar type here because such a type is passed\n-     by copy.  But the Interlocked routines in System.Aux_DEC force some\n-     of the their scalar parameters to be passed by reference so we need\n-     to preserve that if we do not want to break the interface.  */\n-  if (Is_Scalar_Type (formal_type))\n-    return false;\n-\n-  if (Is_Atomic_Object (actual) && !Is_Atomic (formal_type))\n-    {\n-      post_error (\"?atomic actual passed by copy (RM C.6(19))\", actual);\n-      return true;\n-    }\n-\n-  if (Is_Volatile_Object (actual) && !Is_Volatile (formal_type))\n-    {\n-      post_error (\"?volatile actual passed by copy (RM C.6(19))\", actual);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n    or an N_Procedure_Call_Statement, to a GCC tree, which is returned.\n    GNU_RESULT_TYPE_P is a pointer to where we should place the result type.\n@@ -5254,18 +5225,13 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      = build_compound_expr (TREE_TYPE (gnu_name), init, gnu_name);\n \t}\n \n-      /* If we are passing a non-addressable actual parameter by reference,\n-\t pass the address of a copy and, in the In Out or Out case, set up\n-\t to copy back after the call.  We also need to do that if the actual\n-\t parameter is atomic or volatile but the formal parameter is not.  */\n+      /* If we are passing a non-addressable parameter by reference, pass the\n+\t address of a copy.  In the In Out or Out case, set up to copy back\n+\t out after the call.  */\n       if (is_by_ref_formal_parm\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n-\t  && (!addressable_p (gnu_name, gnu_name_type)\n-\t      || (Comes_From_Source (gnat_node)\n-\t\t  && atomic_or_volatile_copy_required_p (gnat_actual,\n-\t\t\t\t\t\t\t gnat_formal_type))))\n+\t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n-\t  const bool atomic_p = atomic_access_required_p (gnat_actual, &sync);\n \t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n \n \t  /* Do not issue warnings for CONSTRUCTORs since this is not a copy\n@@ -5335,9 +5301,6 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    }\n \n \t  /* Create an explicit temporary holding the copy.  */\n-\t  if (atomic_p)\n-\t    gnu_name = build_atomic_load (gnu_name, sync);\n-\n \t  /* Do not initialize it for the _Init parameter of an initialization\n \t     procedure since no data is meant to be passed in.  */\n \t  if (Ekind (gnat_formal) == E_Out_Parameter\n@@ -5367,13 +5330,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t     (TREE_OPERAND (TREE_OPERAND (gnu_orig, 1), 1)))\n \t\tgnu_orig = TREE_OPERAND (gnu_orig, 2);\n \n-\t      if (atomic_p)\n-\t\tgnu_stmt\n-\t\t  = build_atomic_store (gnu_orig, gnu_temp, sync);\n-\t      else\n-\t\tgnu_stmt\n-\t\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig,\n-\t\t\t\t     gnu_temp);\n+\t      gnu_stmt\n+\t\t= build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig, gnu_temp);\n \t      set_expr_location_from_node (gnu_stmt, gnat_node);\n \n \t      append_to_statement_list (gnu_stmt, &gnu_after_list);"}, {"sha": "89fa579a0cc44f0af72ae6a4f02ccded861f1f55", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6ac079858f2140567a8640718094213366a05b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=6a6ac079858f2140567a8640718094213366a05b", "patch": "@@ -1533,8 +1533,6 @@ package Sem_Util is\n    --  Determine whether arbitrary node N denotes a reference to an atomic\n    --  object as per Ada RM C.6(7) and the crucial remark in C.6(8).\n \n-   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n-\n    function Is_Atomic_Object_Entity (Id : Entity_Id) return Boolean;\n    --  Determine whether arbitrary entity Id denotes an atomic object as per\n    --  Ada RM C.6(12).\n@@ -2108,8 +2106,6 @@ package Sem_Util is\n    --  for something actually declared as volatile, not for an object that gets\n    --  treated as volatile (see Einfo.Treat_As_Volatile).\n \n-   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n-\n    generic\n       with procedure Handle_Parameter (Formal : Entity_Id; Actual : Node_Id);\n    procedure Iterate_Call_Parameters (Call : Node_Id);"}]}