{"sha": "f8521984eeb6a3c4bf2ea69065d54613f4a70092", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg1MjE5ODRlZWI2YTNjNGJmMmVhNjkwNjVkNTQ2MTNmNGE3MDA5Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-07-24T16:59:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-07-24T16:59:32Z"}, "message": "c-decl.c: Search-and-replace change 'binding level' to 'scope' in commentary.\n\n\t* c-decl.c: Search-and-replace change 'binding level' to\n\t'scope' in commentary.\n\t(struct binding_level): Now struct c_scope.\n\t(current_binding_level): Now current_scope.\n\t(free_binding_level): Now scope_freelist.\n\t(current_function_level): Now current_function_scope.\n\t(global_binding_level): Now global_scope.\n\t(make_binding_level): Now make_scope.\n\t(pop_binding_level): Now pop_scope.\n\nFrom-SVN: r69747", "tree": {"sha": "68621b262e303ebe35459d4647f6e1db76c75908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68621b262e303ebe35459d4647f6e1db76c75908"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8521984eeb6a3c4bf2ea69065d54613f4a70092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8521984eeb6a3c4bf2ea69065d54613f4a70092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8521984eeb6a3c4bf2ea69065d54613f4a70092", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8521984eeb6a3c4bf2ea69065d54613f4a70092/comments", "author": null, "committer": null, "parents": [{"sha": "d7541133fe0d17a7e150d61717a64718fa0b9006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7541133fe0d17a7e150d61717a64718fa0b9006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7541133fe0d17a7e150d61717a64718fa0b9006"}], "stats": {"total": 460, "additions": 232, "deletions": 228}, "files": [{"sha": "50ae6251715b216f37d26b6f9f2673951af1bdea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8521984eeb6a3c4bf2ea69065d54613f4a70092/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8521984eeb6a3c4bf2ea69065d54613f4a70092/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8521984eeb6a3c4bf2ea69065d54613f4a70092", "patch": "@@ -1,3 +1,15 @@\n+2003-07-24  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c: Search-and-replace change 'binding level' to\n+\t'scope' in commentary.\n+\t(struct binding_level): Now struct c_scope.\n+\t(current_binding_level): Now current_scope.\n+\t(free_binding_level): Now scope_freelist.\n+\t(current_function_level): Now current_function_scope.\n+\t(global_binding_level): Now global_scope.\n+\t(make_binding_level): Now make_scope.\n+\t(pop_binding_level): Now pop_scope.\n+\n 2003-07-24  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* configure.in (libgcc_visibility): Add missing whitespace.\n@@ -6,7 +18,7 @@\n \n \t* libgcc-std.ver (GCC_3.3.1): Export __gcc_personality_sj0,\n \t__gcc_personality_v0.\n-\t\n+\n 2003-07-24  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* Makefile.in: Replace pwd by ${PWD_COMMAND}."}, {"sha": "62a4bd5884c32aad3000bd0ddd9df01f36f3f04c", "filename": "gcc/c-decl.c", "status": "modified", "additions": 219, "deletions": 227, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8521984eeb6a3c4bf2ea69065d54613f4a70092/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8521984eeb6a3c4bf2ea69065d54613f4a70092/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f8521984eeb6a3c4bf2ea69065d54613f4a70092", "patch": "@@ -152,7 +152,7 @@ static int warn_about_return_type;\n \n static int current_extern_inline;\n \f\n-/* For each binding contour we allocate a binding_level structure\n+/* For each binding contour we allocate a c_scope structure\n  * which records the names defined in that contour.\n  * Contours include:\n  *  0) the global one\n@@ -161,11 +161,11 @@ static int current_extern_inline;\n  *  2) one for each compound statement,\n  *     to record its declarations.\n  *\n- * The current meaning of a name can be found by searching the levels from\n- * the current one out to the global one.\n+ * The current meaning of a name can be found by searching the nested\n+ * scopes from the current one out to the global one.\n  */\n \n-struct binding_level GTY(())\n+struct c_scope GTY(())\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n        and typedef types.  These are in the reverse of the order supplied.\n@@ -180,30 +180,30 @@ struct binding_level GTY(())\n      */\n     tree tags;\n \n-    /* For each level, a list of shadowed outer-level definitions\n-       to be restored when this level is popped.\n+    /* For each scope, a list of shadowed outer-scope definitions\n+       to be restored when this scope is popped.\n        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n     tree shadowed;\n \n-    /* For each level, a list of shadowed outer-level tag definitions\n-       to be restored when this level is popped.\n+    /* For each scope, a list of shadowed outer-scope tag definitions\n+       to be restored when this scope is popped.\n        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n        whose TREE_VALUE is its old definition (a kind of ..._TYPE node).  */\n     tree shadowed_tags;\n \n-    /* For each level (except not the global one),\n-       a chain of BLOCK nodes for all the levels\n+    /* For each scope (except not the global one),\n+       a chain of BLOCK nodes for all the scopes\n        that were entered and exited one level down.  */\n     tree blocks;\n \n     /* The scope containing this one.  */\n-    struct binding_level *outer;\n+    struct c_scope *outer;\n \n     /* The next outermost function scope.  */\n-    struct binding_level *outer_function;\n+    struct c_scope *outer_function;\n \n-    /* True if we are currently filling this level with parameter\n+    /* True if we are currently filling this scope with parameter\n        declarations.  */\n     bool parm_flag : 1;\n \n@@ -212,10 +212,10 @@ struct binding_level GTY(())\n        declared in the outermost block.  */\n     bool function_body : 1;\n \n-    /* True means make a BLOCK for this level regardless of all else.  */\n+    /* True means make a BLOCK for this scope regardless of all else.  */\n     bool keep : 1;\n \n-    /* True means make a BLOCK if this level has any subblocks.  */\n+    /* True means make a BLOCK if this scope has any subblocks.  */\n     bool keep_if_subblocks : 1;\n \n     /* List of decls in `names' that have incomplete structure or\n@@ -228,32 +228,29 @@ struct binding_level GTY(())\n     tree parm_order;\n   };\n \n-#define NULL_BINDING_LEVEL (struct binding_level *) NULL\n+/* The scope currently in effect.  */\n \n-/* The binding level currently in effect.  */\n+static GTY(()) struct c_scope *current_scope;\n \n-static GTY(()) struct binding_level *current_binding_level;\n+/* A chain of c_scope structures awaiting reuse.  */\n \n-/* A chain of binding_level structures awaiting reuse.  */\n-\n-static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n+static GTY((deletable (\"\"))) struct c_scope *scope_freelist;\n \n /* The innermost function scope.  Ordinary (not explicitly declared)\n    labels, bindings to error_mark_node, and the lazily-created\n    bindings of __func__ and its friends get this scope.  */\n-static GTY(()) struct binding_level *current_function_level;\n+static GTY(()) struct c_scope *current_function_scope;\n \n-/* The outermost binding level, for names of file scope.\n-   This is created when the compiler is started and exists\n-   through the entire run.  */\n+/* The outermost scope, corresponding to the C \"file scope\".  This is\n+   created when the compiler is started and exists through the entire run.  */\n \n-static GTY(()) struct binding_level *global_binding_level;\n+static GTY(()) struct c_scope *global_scope;\n \n-/* True means unconditionally make a BLOCK for the next level pushed.  */\n+/* True means unconditionally make a BLOCK for the next scope pushed.  */\n \n static bool keep_next_level_flag;\n \n-/* True means make a BLOCK for the next level pushed if it has subblocks.  */\n+/* True means make a BLOCK for the next scope pushed if it has subblocks.  */\n \n static bool keep_next_if_subblocks;\n \n@@ -263,12 +260,12 @@ tree static_ctors, static_dtors;\n \n /* Forward declarations.  */\n \n-static struct binding_level *make_binding_level (void);\n-static void pop_binding_level (void);\n+static struct c_scope *make_scope (void);\n+static void pop_scope (void);\n static int duplicate_decls (tree, tree, int, int);\n static int redeclaration_error_message (tree, tree);\n static tree make_label (tree, location_t);\n-static void bind_label (tree, tree, struct binding_level *);\n+static void bind_label (tree, tree, struct c_scope *);\n static void implicit_decl_warning (tree);\n static void storedecls (tree);\n static void storetags (tree);\n@@ -316,7 +313,7 @@ c_print_identifier (FILE *file, tree node, int indent)\n }\n \f\n /* Hook called at end of compilation to assume 1 elt\n-   for a top-level tentative array defn that wasn't complete before.  */\n+   for a file-scope tentative array defn that wasn't complete before.  */\n \n void\n c_finish_incomplete_decl (tree decl)\n@@ -339,46 +336,46 @@ c_finish_incomplete_decl (tree decl)\n     }\n }\n \f\n-/* Reuse or create a struct for this binding level.  */\n+/* Reuse or create a struct for this scope.  */\n \n-static struct binding_level *\n-make_binding_level (void)\n+static struct c_scope *\n+make_scope (void)\n {\n-  struct binding_level *result;\n-  if (free_binding_level)\n+  struct c_scope *result;\n+  if (scope_freelist)\n     {\n-      result = free_binding_level;\n-      free_binding_level = result->outer;\n+      result = scope_freelist;\n+      scope_freelist = result->outer;\n     }\n   else\n-    result = ggc_alloc_cleared (sizeof (struct binding_level));\n+    result = ggc_alloc_cleared (sizeof (struct c_scope));\n \n   return result;\n }\n \n-/* Remove the topmost binding level from the stack and add it to the\n-   free list, updating current_function_level if necessary.  */\n+/* Remove the topmost scope from the stack and add it to the\n+   free list, updating current_function_scope if necessary.  */\n \n static void\n-pop_binding_level (void)\n+pop_scope (void)\n {\n-  struct binding_level *scope = current_binding_level;\n+  struct c_scope *scope = current_scope;\n \n-  current_binding_level = scope->outer;\n+  current_scope = scope->outer;\n   if (scope->function_body)\n-    current_function_level = scope->outer_function;\n+    current_function_scope = scope->outer_function;\n \n-  memset (scope, 0, sizeof (struct binding_level));\n-  scope->outer = free_binding_level;\n-  free_binding_level = scope;\n+  memset (scope, 0, sizeof (struct c_scope));\n+  scope->outer = scope_freelist;\n+  scope_freelist = scope;\n }\n \n-/* Nonzero if we are currently in the global binding level.  */\n+/* Nonzero if we are currently in the global scope.  */\n \n int\n global_bindings_p (void)\n {\n-  return current_binding_level == global_binding_level;\n+  return current_scope == global_scope;\n }\n \n void\n@@ -387,23 +384,23 @@ keep_next_level (void)\n   keep_next_level_flag = true;\n }\n \n-/* Identify this binding level as a level of parameters.  */\n+/* Identify this scope as currently being filled with parameters.  */\n \n void\n declare_parm_level (void)\n {\n-  current_binding_level->parm_flag = true;\n+  current_scope->parm_flag = true;\n }\n \n /* Nonzero if currently making parm declarations.  */\n \n int\n in_parm_level_p (void)\n {\n-  return current_binding_level->parm_flag;\n+  return current_scope->parm_flag;\n }\n \n-/* Enter a new binding level.  */\n+/* Enter a new scope.  */\n \n void\n pushlevel (int dummy ATTRIBUTE_UNUSED)\n@@ -412,40 +409,40 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n     {\n       /* This is the transition from the parameters to the top level\n \t of the function body.  These are the same scope\n-\t (C99 6.2.1p4,6) so we do not push another binding level.\n+\t (C99 6.2.1p4,6) so we do not push another scope structure.\n \n \t XXX Note kludge - keep_next_if_subblocks is set only by\n \t store_parm_decls, which in turn is called when and only\n \t when we are about to encounter the opening curly brace for\n \t the function body.  */\n-      current_binding_level->parm_flag         = false;\n-      current_binding_level->function_body     = true;\n-      current_binding_level->keep             |= keep_next_level_flag;\n-      current_binding_level->keep_if_subblocks = true;\n-      current_binding_level->outer_function    = current_function_level;\n-      current_function_level                   = current_binding_level;\n+      current_scope->parm_flag         = false;\n+      current_scope->function_body     = true;\n+      current_scope->keep             |= keep_next_level_flag;\n+      current_scope->keep_if_subblocks = true;\n+      current_scope->outer_function    = current_function_scope;\n+      current_function_scope           = current_scope;\n \n       keep_next_level_flag = false;\n       keep_next_if_subblocks = false;\n     }\n   else\n     {\n-      struct binding_level *newlevel = make_binding_level ();\n+      struct c_scope *scope = make_scope ();\n \n-      newlevel->keep        = keep_next_level_flag;\n-      newlevel->outer       = current_binding_level;\n-      current_binding_level = newlevel;\n-      keep_next_level_flag  = false;\n+      scope->keep          = keep_next_level_flag;\n+      scope->outer         = current_scope;\n+      current_scope        = scope;\n+      keep_next_level_flag = false;\n     }\n }\n \n-/* Exit a binding level.\n-   Pop the level off, and restore the state of the identifier-decl mappings\n-   that were in effect when this level was entered.\n+/* Exit a scope.  Restore the state of the identifier-decl mappings\n+   that were in effect when this scope was entered.\n \n-   If KEEP is nonzero, this level had explicit declarations, so\n-   and create a \"block\" (a BLOCK node) for the level\n-   to record its declarations and subblocks for symbol table output.\n+   If KEEP is KEEP_YES (1), this scope had explicit declarations, so\n+   create a BLOCK node to record its declarations and subblocks for\n+   debugging output.  If KEEP is KEEP_MAYBE, do so only if the names\n+   or tags lists are nonempty.\n \n    If FUNCTIONBODY is nonzero, this level is the body of a function,\n    so create a block as if KEEP were set and also clear out all\n@@ -460,17 +457,17 @@ poplevel (int keep, int reverse, int functionbody)\n   tree link;\n   tree block;\n   tree decl;\n-  tree decls = current_binding_level->names;\n-  tree tags = current_binding_level->tags;\n-  tree subblocks = current_binding_level->blocks;\n+  tree decls = current_scope->names;\n+  tree tags = current_scope->tags;\n+  tree subblocks = current_scope->blocks;\n \n-  functionbody |= current_binding_level->function_body;\n+  functionbody |= current_scope->function_body;\n \n   if (keep == KEEP_MAYBE)\n-    keep = (current_binding_level->names || current_binding_level->tags);\n+    keep = (current_scope->names || current_scope->tags);\n   \n-  keep |= (current_binding_level->keep || functionbody\n-\t   || (subblocks && current_binding_level->keep_if_subblocks));\n+  keep |= (current_scope->keep || functionbody\n+\t   || (subblocks && current_scope->keep_if_subblocks));\n \n   /* We used to warn about unused variables in expand_end_bindings,\n      i.e. while generating RTL.  But in function-at-a-time mode we may\n@@ -479,10 +476,10 @@ poplevel (int keep, int reverse, int functionbody)\n      No warnings when the global scope is popped because the global\n      scope isn't popped for the last translation unit, so the warnings\n      are done in c_write_global_declaration.  */\n-  if (current_binding_level != global_binding_level)\n+  if (current_scope != global_scope)\n     warn_about_unused_variables (decls);\n \n-  /* Clear out the name-meanings declared on this level.\n+  /* Clear out the name-meanings declared in this scope.\n      Propagate TREE_ADDRESSABLE from nested functions to their\n      containing functions.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n@@ -510,7 +507,7 @@ poplevel (int keep, int reverse, int functionbody)\n       else if (DECL_NAME (link) != 0)\n \t{\n \t  if (DECL_EXTERNAL (link) \n-\t      && current_binding_level != global_binding_level)\n+\t      && current_scope != global_scope)\n \t    /* External decls stay in the symbol-value slot but are\n \t       inaccessible.  */\n \t    C_DECL_INVISIBLE (link) = 1;\n@@ -527,29 +524,29 @@ poplevel (int keep, int reverse, int functionbody)\n \tTREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (link)) = 1;\n     }\n \n-  /* Clear out the tag-meanings declared on this level.  */\n+  /* Clear out the tag-meanings declared in this scope.  */\n   for (link = tags; link; link = TREE_CHAIN (link))\n     if (TREE_PURPOSE (link))\n       IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = 0;\n \n-  /* Restore all name- and label-meanings of the outer levels\n-     that were shadowed by this level.  */\n+  /* Restore all name- and label-meanings from outer scopes that were\n+     shadowed by this scope.  */\n \n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+  for (link = current_scope->shadowed; link; link = TREE_CHAIN (link))\n     if (TREE_VALUE (link) && TREE_CODE (TREE_VALUE (link)) == LABEL_DECL)\n       IDENTIFIER_LABEL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n     else\n       IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n-  /* Restore all tag-meanings of the outer levels\n-     that were shadowed by this level.  */\n+  /* Restore all tag-meanings from outer scopes that were shadowed by\n+     this scope.  */\n \n-  for (link = current_binding_level->shadowed_tags; link;\n+  for (link = current_scope->shadowed_tags; link;\n        link = TREE_CHAIN (link))\n     IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \n-  /* If this is the top level block of a function, remove all\n-     PARM_DECLs from current_binding_level->names; they are already\n+  /* If this is the outermost block of a function, remove all\n+     PARM_DECLs from current_scope->names; they are already\n      stored in DECL_ARGUMENTS of cfun->decl in proper order, should\n      not be put in BLOCK_VARS, and furthermore reversing them will\n      cause trouble later.  They are all together at the end of the\n@@ -570,15 +567,14 @@ poplevel (int keep, int reverse, int functionbody)\n     }\n \n   /* Get the decls in the order they were written.\n-     Usually current_binding_level->names is in reverse order.\n+     Usually current_scope->names is in reverse order.\n      But parameter decls were previously put in forward order.  */\n \n   if (reverse)\n     decls = nreverse (decls);\n \n-  /* If there were any declarations or structure tags in that level,\n-     or if this level is a function body,\n-     create a BLOCK to record them for the life of this function.  */\n+  /* If appropriate, create a BLOCK to record the decls for the life\n+     of this function.  */\n \n   block = 0;\n   if (keep)\n@@ -613,37 +609,36 @@ poplevel (int keep, int reverse, int functionbody)\n     for (link = tags; link; link = TREE_CHAIN (link))\n       TYPE_CONTEXT (TREE_VALUE (link)) = decl;\n \n-  /* Pop the current level, and free the structure for reuse.  */\n-  pop_binding_level ();\n+  /* Pop the current scope, and free the structure for reuse.  */\n+  pop_scope ();\n \n   /* Dispose of the block that we just made inside some higher level.  */\n   if (functionbody)\n     DECL_INITIAL (current_function_decl) = block;\n-  else if (block && current_binding_level)\n-    current_binding_level->blocks\n-      = chainon (current_binding_level->blocks, block);\n-  /* If we did not make a block for the level just exited,\n-     any blocks made for inner levels\n-     (since they cannot be recorded as subblocks in that level)\n-     must be carried forward so they will later become subblocks\n+  else if (block && current_scope)\n+    current_scope->blocks\n+      = chainon (current_scope->blocks, block);\n+  /* If we did not make a block for the scope just exited, any blocks\n+     made for inner scopes (since they cannot be recorded as subblocks\n+     here) must be carried forward so they will later become subblocks\n      of something else.  */\n   else if (! block && subblocks)\n-    current_binding_level->blocks\n-      = chainon (current_binding_level->blocks, subblocks);\n+    current_scope->blocks\n+      = chainon (current_scope->blocks, subblocks);\n \n   return block;\n }\n \n-/* Insert BLOCK at the end of the list of subblocks of the\n-   current binding level.  This is used when a BIND_EXPR is expanded,\n-   to handle the BLOCK node inside the BIND_EXPR.  */\n+/* Insert BLOCK at the end of the list of subblocks of the current\n+   scope.  This is used when a BIND_EXPR is expanded, to handle the\n+   BLOCK node inside the BIND_EXPR.  */\n \n void\n insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n-  current_binding_level->blocks\n-    = chainon (current_binding_level->blocks, block);\n+  current_scope->blocks\n+    = chainon (current_scope->blocks, block);\n }\n \n /* Set the BLOCK node for the innermost scope (the one we are\n@@ -665,7 +660,7 @@ set_block (tree block ATTRIBUTE_UNUSED)\n void\n pushtag (tree name, tree type)\n {\n-  struct binding_level *b = current_binding_level;\n+  struct c_scope *b = current_scope;\n \n   if (name)\n     {\n@@ -683,7 +678,7 @@ pushtag (tree name, tree type)\n   b->tags = tree_cons (name, type, b->tags);\n \n   /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the\n-     tagged type we just added to the current binding level.  This fake\n+     tagged type we just added to the current scope.  This fake\n      NULL-named TYPE_DECL node helps dwarfout.c to know when it needs\n      to output a representation of a tagged type, and it also gives\n      us a convenient place to record the \"scope start\" address for the\n@@ -705,7 +700,7 @@ pushtag (tree name, tree type)\n    Otherwise, return 0.\n \n    When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external declaration,\n-   and OLDDECL is in an outer binding level and should thus not be changed.  */\n+   and OLDDECL is in an outer scope and should thus not be changed.  */\n \n static int\n duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n@@ -1060,7 +1055,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \n           locus = &DECL_SOURCE_LOCATION (olddecl);\n           if (DECL_INITIAL (olddecl)\n-              && current_binding_level == global_binding_level)\n+              && current_scope == global_scope)\n             error (\"%H'%D' previously defined here\", locus, olddecl);\n           else\n             error (\"%H'%D' previously declared here\", locus, olddecl);\n@@ -1074,7 +1069,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t  warning (\"%Hredefinition of '%D'\", locus, newdecl);\n           locus = &DECL_SOURCE_LOCATION (olddecl);\n           if (DECL_INITIAL (olddecl)\n-              && current_binding_level == global_binding_level)\n+              && current_scope == global_scope)\n             warning (\"%H'%D' previously defined here\", locus, olddecl);\n           else\n             warning (\"%H'%D' previously declared here\", locus, olddecl);\n@@ -1544,7 +1539,7 @@ warn_if_shadowing (tree x, tree old)\n \t declarator in a declaration, as opposed to a definition,\n \t but there is no way to tell it's not a definition.  */\n       || (TREE_CODE (x) == PARM_DECL\n-\t  && current_binding_level->outer->parm_flag))\n+\t  && current_scope->outer->parm_flag))\n     return;\n \n   name = IDENTIFIER_POINTER (DECL_NAME (x));\n@@ -1634,7 +1629,7 @@ tree\n pushdecl (tree x)\n {\n   tree name = DECL_NAME (x);\n-  struct binding_level *scope = current_binding_level;\n+  struct c_scope *scope = current_scope;\n \n #ifdef ENABLE_CHECKING\n   if (error_mark_node == 0)\n@@ -1661,7 +1656,7 @@ pushdecl (tree x)\n       tree old;\n \n       if (warn_nested_externs\n-\t  && scope != global_binding_level\n+\t  && scope != global_scope\n \t  && DECL_EXTERNAL (x)\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n \twarning (\"nested extern declaration of `%s'\",\n@@ -1670,7 +1665,7 @@ pushdecl (tree x)\n       old = lookup_name_current_level (name);\n       if (old && duplicate_decls (x, old, 0, false))\n \treturn old;\n-      if (DECL_EXTERNAL (x) || scope == global_binding_level)\n+      if (DECL_EXTERNAL (x) || scope == global_scope)\n \t{\n \t  /* Find and check against a previous, not-in-scope, external\n \t     decl for this identifier.  (C99 s???: If two declarations\n@@ -1679,7 +1674,7 @@ pushdecl (tree x)\n \t  tree ext = any_external_decl (name);\n \t  if (ext)\n \t    {\n-\t      if (duplicate_decls (x, ext, scope != global_binding_level, \n+\t      if (duplicate_decls (x, ext, scope != global_scope, \n \t\t\t\t   false))\n \t\tx = copy_node (ext);\n \t    }\n@@ -1692,10 +1687,10 @@ pushdecl (tree x)\n \n       /* If storing a local value, there may already be one\n \t (inherited).  If so, record it for restoration when this\n-\t binding level ends.  Take care not to do this if we are\n-\t replacing an older decl in the same binding level (i.e.\n-\t duplicate_decls returned false, above).  */\n-      if (scope != global_binding_level\n+\t scope ends.  Take care not to do this if we are replacing an\n+\t older decl in the same scope (i.e.  duplicate_decls returned\n+\t false, above).  */\n+      if (scope != global_scope\n \t  && IDENTIFIER_SYMBOL_VALUE (name)\n \t  && IDENTIFIER_SYMBOL_VALUE (name) != old)\n \t{\n@@ -1704,11 +1699,11 @@ pushdecl (tree x)\n \t\t\t\t       scope->shadowed);\n \t}\n \n-      /* Install the new declaration in the requested binding level.  */\n+      /* Install the new declaration in the requested scope.  */\n       IDENTIFIER_SYMBOL_VALUE (name) = x;\n       C_DECL_INVISIBLE (x) = 0;\n \n-      /* Keep list of variables in this level with incomplete type.\n+      /* Keep list of variables in this scope with incomplete type.\n \t If the input is erroneous, we can have error_mark in the type\n \t slot (e.g. \"f(void a, ...)\") - that doesn't count as an\n \t incomplete type.  */\n@@ -1762,8 +1757,8 @@ pushdecl_top_level (tree x)\n \n   DECL_CONTEXT (x) = current_file_decl;\n   IDENTIFIER_SYMBOL_VALUE (name) = x;\n-  TREE_CHAIN (x) = global_binding_level->names;\n-  global_binding_level->names = x;\n+  TREE_CHAIN (x) = global_scope->names;\n+  global_scope->names = x;\n   return x;\n }\n \n@@ -1777,7 +1772,7 @@ pushdecl_top_level (tree x)\n static void\n pushdecl_function_level (tree x, tree name)\n {\n-  struct binding_level *scope = current_function_level;\n+  struct c_scope *scope = current_function_scope;\n \n   if (x == error_mark_node)\n     scope->shadowed = tree_cons (name, IDENTIFIER_SYMBOL_VALUE (name),\n@@ -1820,11 +1815,11 @@ implicitly_declare (tree functionid)\n \t  C_DECL_IMPLICIT (decl) = 1;\n \t}\n       /* If this function is global, then it must already be in the\n-\t global binding level, so there's no need to push it again.  */\n-      if (current_binding_level == global_binding_level)\n+\t global scope, so there's no need to push it again.  */\n+      if (current_scope == global_scope)\n \treturn decl;\n       /* If this is a local declaration, make a copy; we can't have\n-\t the same DECL listed in two different binding levels.  */\n+\t the same DECL listed in two different scopes.  */\n       return pushdecl (copy_node (decl));\n     }\n \n@@ -1897,7 +1892,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n     }\n   else if (C_DECL_FILE_SCOPE (newdecl))\n     {\n-      /* Objects declared at top level:  */\n+      /* Objects declared at file scope:  */\n       /* If at least one is a reference, it's ok.  */\n       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n@@ -1910,7 +1905,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \treturn 3;\n       return 0;\n     }\n-  else if (current_binding_level->parm_flag\n+  else if (current_scope->parm_flag\n \t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl))\n     return 0;\n   else\n@@ -1977,7 +1972,7 @@ make_label (tree name, location_t location)\n    set up the binding of name to LABEL_DECL in the given SCOPE.  */\n \n static void\n-bind_label (tree name, tree label, struct binding_level *scope)\n+bind_label (tree name, tree label, struct c_scope *scope)\n {\n   if (IDENTIFIER_LABEL_VALUE (name))\n     scope->shadowed = tree_cons (name, IDENTIFIER_LABEL_VALUE (name),\n@@ -2025,7 +2020,7 @@ lookup_label (tree name)\n \n   /* Ordinary labels go in the current function scope, which is\n      not necessarily the current label scope.  */\n-  bind_label (name, label, current_function_level);\n+  bind_label (name, label, current_function_scope);\n   return label;\n }\n \n@@ -2045,7 +2040,7 @@ declare_label (tree name)\n \n   /* Check to make sure that the label hasn't already been declared\n      at this scope */\n-  for (dup = current_binding_level->names; dup; dup = TREE_CHAIN (dup))\n+  for (dup = current_scope->names; dup; dup = TREE_CHAIN (dup))\n     if (dup == label)\n       {\n \terror (\"duplicate label declaration `%s'\", IDENTIFIER_POINTER (name));\n@@ -2060,7 +2055,7 @@ declare_label (tree name)\n   C_DECLARED_LABEL_FLAG (label) = 1;\n \n   /* Declared labels go in the current scope.  */\n-  bind_label (name, label, current_binding_level);\n+  bind_label (name, label, current_scope);\n   return label;\n }\n \n@@ -2108,7 +2103,7 @@ define_label (location_t location, tree name)\n \n       /* Ordinary labels go in the current function scope, which is\n \t not necessarily the current label scope.  */\n-      bind_label (name, label, current_function_level);\n+      bind_label (name, label, current_function_scope);\n     }\n \n   if (warn_traditional && !in_system_header && lookup_name (name))\n@@ -2121,46 +2116,46 @@ define_label (location_t location, tree name)\n   return label;\n }\n \f\n-/* Return the list of declarations of the current level.\n+/* Return the list of declarations of the current scope.\n    Note that this list is in reverse order unless/until\n    you nreverse it; and when you do nreverse it, you must\n    store the result back using `storedecls' or you will lose.  */\n \n tree\n getdecls (void)\n {\n-  return current_binding_level->names;\n+  return current_scope->names;\n }\n \n-/* Return the list of type-tags (for structs, etc) of the current level.  */\n+/* Return the list of type-tags (for structs, etc) of the current scope.  */\n \n tree\n gettags (void)\n {\n-  return current_binding_level->tags;\n+  return current_scope->tags;\n }\n \n-/* Store the list of declarations of the current level.\n+/* Store the list of declarations of the current scope.\n    This is done for the parameter declarations of a function being defined,\n    after they are modified in the light of any missing parameters.  */\n \n static void\n storedecls (tree decls)\n {\n-  current_binding_level->names = decls;\n+  current_scope->names = decls;\n }\n \n-/* Similarly, store the list of tags of the current level.  */\n+/* Similarly, store the list of tags of the current scope.  */\n \n static void\n storetags (tree tags)\n {\n-  current_binding_level->tags = tags;\n+  current_scope->tags = tags;\n }\n \f\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n-   If THISLEVEL_ONLY is nonzero, searches only the current_binding_level.\n+   If THISLEVEL_ONLY is nonzero, searches only the current_scope.\n    CODE says which kind of type the caller wants;\n    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n    If the wrong kind of type is found, an error is reported.  */\n@@ -2178,8 +2173,8 @@ lookup_tag (enum tree_code code, tree name, int thislevel_only)\n      thislevel_only was set or it might be a type clash.  */\n   if (thislevel_only || TREE_CODE (tag) != code)\n     {\n-      if (current_binding_level == global_binding_level\n-\t  || purpose_member (name, current_binding_level->tags))\n+      if (current_scope == global_scope\n+\t  || purpose_member (name, current_scope->tags))\n \tthislevel = 1;\n     }\n \n@@ -2218,7 +2213,7 @@ pending_xref_error (void)\n }\n \n \f\n-/* Look up NAME in the current binding level and its superiors\n+/* Look up NAME in the current scope and its superiors\n    in the namespace of variables, functions and typedefs.\n    Return a ..._DECL node of some kind representing its definition,\n    or return 0 if it is undefined.  */\n@@ -2234,7 +2229,7 @@ lookup_name (tree name)\n   return decl;\n }\n \n-/* Similar to `lookup_name' but look only at the current binding level.  */\n+/* Similar to `lookup_name' but look only at the current scope.  */\n \n static tree\n lookup_name_current_level (tree name)\n@@ -2244,19 +2239,19 @@ lookup_name_current_level (tree name)\n   if (decl == 0 || decl == error_mark_node || C_DECL_INVISIBLE (decl))\n     return 0;\n \n-  if (current_binding_level == global_binding_level)\n+  if (current_scope == global_scope)\n     return decl;\n \n   /* Scan the current scope for a decl with name NAME.  */\n-  if (chain_member (decl, current_binding_level->names))\n+  if (chain_member (decl, current_scope->names))\n     return decl;\n \n   return 0;\n }\n \f\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *) 0).\n-   Initialize the global binding level.\n+   Initialize the global scope.\n    Make definitions for built-in primitive functions.  */\n \n void\n@@ -2270,12 +2265,13 @@ c_init_decl_processing (void)\n   c_parse_init ();\n \n   current_function_decl = NULL;\n-  current_binding_level = NULL_BINDING_LEVEL;\n-  free_binding_level = NULL_BINDING_LEVEL;\n+  current_scope = NULL;\n+  current_function_scope = NULL;\n+  scope_freelist = NULL;\n \n-  /* Make the binding_level structure for global names.  */\n+  /* Make the c_scope structure for global names.  */\n   pushlevel (0);\n-  global_binding_level = current_binding_level;\n+  global_scope = current_scope;\n   /* Declarations from c_common_nodes_and_builtins must not be associated\n      with this input file, lest we get differences between using and not\n      using preprocessed headers.  */\n@@ -2318,7 +2314,7 @@ c_init_decl_processing (void)\n   make_fname_decl = c_make_fname_decl;\n   start_fname_decls ();\n \n-  builtin_decls = global_binding_level->names;\n+  builtin_decls = global_scope->names;\n }\n \n /* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the\n@@ -2670,7 +2666,7 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n   if (initialized)\n     {\n       DECL_EXTERNAL (decl) = 0;\n-      if (current_binding_level == global_binding_level)\n+      if (current_scope == global_scope)\n \tTREE_STATIC (decl) = 1;\n \n       /* Tell `pushdecl' this is an initialized decl\n@@ -2713,12 +2709,12 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n     warning (\"%Hinline function '%D' given attribute noinline\",\n              &DECL_SOURCE_LOCATION (decl), decl);\n \n-  /* Add this decl to the current binding level.\n+  /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n   tem = pushdecl (decl);\n \n   /* For a local variable, define the RTL now.  */\n-  if (current_binding_level != global_binding_level\n+  if (current_scope != global_scope\n       /* But not if this is a duplicate decl\n \t and we preserved the rtl from the previous one\n \t (which may or may not happen).  */\n@@ -2749,7 +2745,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n   const char *asmspec = 0;\n \n   /* If a name was specified, get the string.  */\n-  if (current_binding_level == global_binding_level)\n+  if (current_scope == global_scope)\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n@@ -2887,7 +2883,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     }\n \n   /* If #pragma weak was used, mark the decl weak now.  */\n-  if (current_binding_level == global_binding_level)\n+  if (current_scope == global_scope)\n     maybe_apply_pragma_weak (decl);\n \n   /* Output the assembler code and/or RTL code for variables and functions,\n@@ -2971,7 +2967,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n   /* At the end of a declaration, throw away any variable type sizes\n      of types defined inside that declaration.  There is no use\n      computing them in the following function definition.  */\n-  if (current_binding_level == global_binding_level)\n+  if (current_scope == global_scope)\n     get_pending_sizes ();\n \n   /* Install a cleanup (aka destructor) if one was given.  */\n@@ -3011,7 +3007,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n }\n \n /* Given a parsed parameter declaration,\n-   decode it into a PARM_DECL and push that on the current binding level.\n+   decode it into a PARM_DECL and push that on the current scope.\n    Also, for the sake of forward parm decls,\n    record the given order of parms in `parm_order'.  */\n \n@@ -3031,10 +3027,10 @@ push_parm_decl (tree parm)\n \n   immediate_size_expand = old_immediate_size_expand;\n \n-  current_binding_level->parm_order\n-    = tree_cons (NULL_TREE, decl, current_binding_level->parm_order);\n+  current_scope->parm_order\n+    = tree_cons (NULL_TREE, decl, current_scope->parm_order);\n \n-  /* Add this decl to the current binding level.  */\n+  /* Add this decl to the current scope.  */\n   finish_decl (decl, NULL_TREE, NULL_TREE);\n }\n \n@@ -3045,7 +3041,7 @@ push_parm_decl (tree parm)\n void\n clear_parm_order (void)\n {\n-  current_binding_level->parm_order = NULL_TREE;\n+  current_scope->parm_order = NULL_TREE;\n }\n \f\n static GTY(()) int compound_literal_number;\n@@ -3066,7 +3062,7 @@ build_compound_literal (tree type, tree init)\n   tree stmt;\n   DECL_EXTERNAL (decl) = 0;\n   TREE_PUBLIC (decl) = 0;\n-  TREE_STATIC (decl) = (current_binding_level == global_binding_level);\n+  TREE_STATIC (decl) = (current_scope == global_scope);\n   DECL_CONTEXT (decl) = current_function_decl;\n   TREE_USED (decl) = 1;\n   TREE_TYPE (decl) = type;\n@@ -3311,15 +3307,11 @@ grokdeclarator (tree declarator, tree declspecs,\n   if (funcdef_flag && innermost_code != CALL_EXPR)\n     return 0;\n \n-  /* Anything declared one level down from the top level\n-     must be one of the parameters of a function\n-     (because the body is at least two levels down).  */\n-\n   /* If this looks like a function definition, make it one,\n      even if it occurs where parms are expected.\n      Then store_parm_decls will reject it and not use it as a parm.  */\n   if (decl_context == NORMAL && !funcdef_flag\n-      && current_binding_level->parm_flag)\n+      && current_scope->parm_flag)\n     decl_context = PARM;\n \n   /* Look through the decl specs and record which ones appear.\n@@ -3660,7 +3652,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\t    | (1 << (int) RID_THREAD))))\n       {\n \tif (specbits & 1 << (int) RID_AUTO\n-\t    && (pedantic || current_binding_level == global_binding_level))\n+\t    && (pedantic || current_scope == global_scope))\n \t  pedwarn (\"function definition declared `auto'\");\n \tif (specbits & 1 << (int) RID_REGISTER)\n \t  error (\"function definition declared `register'\");\n@@ -3697,16 +3689,16 @@ grokdeclarator (tree declarator, tree declspecs,\n       }\n     else if (specbits & 1 << (int) RID_EXTERN && initialized && ! funcdef_flag)\n       {\n-\t/* `extern' with initialization is invalid if not at top level.  */\n-\tif (current_binding_level == global_binding_level)\n+\t/* `extern' with initialization is invalid if not at file scope.  */\n+\tif (current_scope == global_scope)\n \t  warning (\"`%s' initialized and declared `extern'\", name);\n \telse\n \t  error (\"`%s' has both `extern' and initializer\", name);\n       }\n-    else if (current_binding_level == global_binding_level)\n+    else if (current_scope == global_scope)\n       {\n \tif (specbits & 1 << (int) RID_AUTO)\n-\t  error (\"top-level declaration of `%s' specifies `auto'\", name);\n+\t  error (\"file-scope declaration of `%s' specifies `auto'\", name);\n       }\n     else\n       {\n@@ -4169,7 +4161,7 @@ grokdeclarator (tree declarator, tree declspecs,\n   if (VOID_TYPE_P (type) && decl_context != PARM\n       && ! ((decl_context != FIELD && TREE_CODE (type) != FUNCTION_TYPE)\n \t    && ((specbits & (1 << (int) RID_EXTERN))\n-\t\t|| (current_binding_level == global_binding_level\n+\t\t|| (current_scope == global_scope\n \t\t    && !(specbits\n \t\t\t & ((1 << (int) RID_STATIC) | (1 << (int) RID_REGISTER)))))))\n     {\n@@ -4306,19 +4298,19 @@ grokdeclarator (tree declarator, tree declspecs,\n \t   That is a case not specified by ANSI C,\n \t   and we use it for forward declarations for nested functions.  */\n \tint extern_ref = (!(specbits & (1 << (int) RID_AUTO))\n-\t\t\t  || current_binding_level == global_binding_level);\n+\t\t\t  || current_scope == global_scope);\n \n \tif (specbits & (1 << (int) RID_AUTO)\n-\t    && (pedantic || current_binding_level == global_binding_level))\n+\t    && (pedantic || current_scope == global_scope))\n \t  pedwarn (\"invalid storage class for function `%s'\", name);\n \tif (specbits & (1 << (int) RID_REGISTER))\n \t  error (\"invalid storage class for function `%s'\", name);\n \tif (specbits & (1 << (int) RID_THREAD))\n \t  error (\"invalid storage class for function `%s'\", name);\n-\t/* Function declaration not at top level.\n+\t/* Function declaration not at file scope.\n \t   Storage classes other than `extern' are not allowed\n \t   and `extern' makes no difference.  */\n-\tif (current_binding_level != global_binding_level\n+\tif (current_scope != global_scope\n \t    && (specbits & ((1 << (int) RID_STATIC) | (1 << (int) RID_INLINE)))\n \t    && pedantic)\n \t  pedwarn (\"invalid storage class for function `%s'\", name);\n@@ -4401,7 +4393,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t/* It is invalid to create an `extern' declaration for a\n \t   variable if there is a global declaration that is\n \t   `static'.  */\n-\tif (extern_ref && current_binding_level != global_binding_level)\n+\tif (extern_ref && current_scope != global_scope)\n \t  {\n \t    tree global_decl;\n \n@@ -4423,17 +4415,17 @@ grokdeclarator (tree declarator, tree declspecs,\n \n \tDECL_EXTERNAL (decl) = extern_ref;\n \n-\t/* At top level, the presence of a `static' or `register' storage\n+\t/* At file scope, the presence of a `static' or `register' storage\n \t   class specifier, or the absence of all storage class specifiers\n \t   makes this declaration a definition (perhaps tentative).  Also,\n \t   the absence of both `static' and `register' makes it public.  */\n-\tif (current_binding_level == global_binding_level)\n+\tif (current_scope == global_scope)\n \t  {\n \t    TREE_PUBLIC (decl) = !(specbits & ((1 << (int) RID_STATIC)\n \t\t\t\t\t       | (1 << (int) RID_REGISTER)));\n \t    TREE_STATIC (decl) = !extern_ref;\n \t  }\n-\t/* Not at top level, only `static' makes a static definition.  */\n+\t/* Not at file scope, only `static' makes a static definition.  */\n \telse\n \t  {\n \t    TREE_STATIC (decl) = (specbits & (1 << (int) RID_STATIC)) != 0;\n@@ -4575,7 +4567,7 @@ get_parm_info (int void_at_end)\n   tree tags = gettags ();\n   tree parms = getdecls ();\n   tree new_parms = 0;\n-  tree order = current_binding_level->parm_order;\n+  tree order = current_scope->parm_order;\n \n   /* Just `void' (and no ellipsis) is special.  There are really no parms.\n      But if the `void' is qualified (by `const' or `volatile') or has a\n@@ -4629,7 +4621,7 @@ get_parm_info (int void_at_end)\n   new_parms = chainon (order ? nreverse (TREE_VALUE (order)) : 0,\n \t\t       new_parms);\n \n-  /* Store the parmlist in the binding level since the old one\n+  /* Store the parmlist in the scope structure since the old one\n      is no longer a valid list.  (We have changed the chain pointers.)  */\n   storedecls (new_parms);\n \n@@ -4672,7 +4664,7 @@ parmlist_tags_warning (void)\n   tree elt;\n   static int already;\n \n-  for (elt = current_binding_level->tags; elt; elt = TREE_CHAIN (elt))\n+  for (elt = current_scope->tags; elt; elt = TREE_CHAIN (elt))\n     {\n       enum tree_code code = TREE_CODE (TREE_VALUE (elt));\n       /* An anonymous union parm type is meaningful as a GNU extension.\n@@ -4722,10 +4714,10 @@ xref_tag (enum tree_code code, tree name)\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n-     wrong type in the same binding level, we will have had an error\n-     message already; if in a different binding level and declaring\n+     wrong type in the same scope, we will have had an error\n+     message already; if in a different scope and declaring\n      a name, pending_xref_error will give an error message; but if in a\n-     different binding level and not declaring a name, this tag should\n+     different scope and not declaring a name, this tag should\n      shadow the previous declaration of a different type of tag, and\n      this would not work properly if we return the reference found.\n      (For example, with \"struct foo\" in an outer scope, \"union foo;\"\n@@ -4757,14 +4749,14 @@ xref_tag (enum tree_code code, tree name)\n   return ref;\n }\n \f\n-/* Make sure that the tag NAME is defined *in the current binding level*\n+/* Make sure that the tag NAME is defined *in the current scope*\n    at least as a forward reference.\n    CODE says which kind of tag NAME ought to be.  */\n \n tree\n start_struct (enum tree_code code, tree name)\n {\n-  /* If there is already a tag defined at this binding level\n+  /* If there is already a tag defined at this scope\n      (as a forward reference), just return it.  */\n \n   tree ref = 0;\n@@ -4928,7 +4920,7 @@ tree\n finish_struct (tree t, tree fieldlist, tree attributes)\n {\n   tree x;\n-  int toplevel = global_binding_level == current_binding_level;\n+  int toplevel = global_scope == current_scope;\n   int saw_named_field;\n \n   /* If this type was previously laid out as a forward reference,\n@@ -5200,11 +5192,11 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n   /* If this structure or union completes the type of any previous\n      variable declaration, lay it out and output its rtl.  */\n \n-  if (current_binding_level->incomplete_list != NULL_TREE)\n+  if (current_scope->incomplete_list != NULL_TREE)\n     {\n       tree prev = NULL_TREE;\n \n-      for (x = current_binding_level->incomplete_list; x; x = TREE_CHAIN (x))\n+      for (x = current_scope->incomplete_list; x; x = TREE_CHAIN (x))\n         {\n \t  tree decl = TREE_VALUE (x);\n \n@@ -5222,7 +5214,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t      if (prev)\n \t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n \t      else\n-\t        current_binding_level->incomplete_list = TREE_CHAIN (x);\n+\t        current_scope->incomplete_list = TREE_CHAIN (x);\n \t    }\n \t  else if (!COMPLETE_TYPE_P (TREE_TYPE (decl))\n \t\t   && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n@@ -5246,7 +5238,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t\t  if (prev)\n \t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n \t\t  else\n-\t\t    current_binding_level->incomplete_list = TREE_CHAIN (x);\n+\t\t    current_scope->incomplete_list = TREE_CHAIN (x);\n \t\t}\n \t    }\n \t}\n@@ -5325,7 +5317,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n   tree pair, tem;\n   tree minnode = 0, maxnode = 0, enum_value_type;\n   int precision, unsign;\n-  int toplevel = (global_binding_level == current_binding_level);\n+  int toplevel = (global_scope == current_scope);\n \n   if (in_parm_level_p ())\n     warning (\"enum defined inside parms\");\n@@ -5646,7 +5638,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n #endif\n \n   /* If #pragma weak was used, mark the decl weak now.  */\n-  if (current_binding_level == global_binding_level)\n+  if (current_scope == global_scope)\n     maybe_apply_pragma_weak (decl1);\n \n   /* Warn for unlikely, improbable, or stupid declarations of `main'.  */\n@@ -5804,15 +5796,15 @@ store_parm_decls (void)\n                  &DECL_SOURCE_LOCATION (fndecl));\n \t  /* Get rid of the erroneous decls; don't keep them on\n \t     the list of parms, since they might not be PARM_DECLs.  */\n-\t  for (decl = current_binding_level->names;\n+\t  for (decl = current_scope->names;\n \t       decl; decl = TREE_CHAIN (decl))\n \t    if (DECL_NAME (decl))\n \t      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = 0;\n-\t  for (link = current_binding_level->shadowed;\n+\t  for (link = current_scope->shadowed;\n \t       link; link = TREE_CHAIN (link))\n \t    IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-\t  current_binding_level->names = 0;\n-\t  current_binding_level->shadowed = 0;\n+\t  current_scope->names = 0;\n+\t  current_scope->shadowed = 0;\n \t}\n \n       specparms = nreverse (specparms);\n@@ -6108,7 +6100,7 @@ store_parm_decls (void)\n       storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n     }\n \n-  /* Make sure the binding level for the top of the function body\n+  /* Make sure the scope for the top of the function body\n      gets a BLOCK if there are any in the function.\n      Otherwise, the dbx output is wrong.  */\n \n@@ -6171,12 +6163,12 @@ finish_function (int nested, int can_defer_p)\n         void foo(void) { }\n      (the argument list is irrelevant) the compstmt rule will not\n      bother calling pushlevel/poplevel, which means we get here with\n-     the binding_level stack out of sync.  Detect this situation by\n-     noticing that the current_binding_level is still as\n+     the scope stack out of sync.  Detect this situation by\n+     noticing that current_scope is still as\n      store_parm_decls left it, and do a dummy push/pop to get back to\n      consistency.  Note that the call to pushlevel does not actually\n-     push another binding level - see there for details.  */\n-  if (current_binding_level->parm_flag && keep_next_if_subblocks)\n+     push another scope - see there for details.  */\n+  if (current_scope->parm_flag && keep_next_if_subblocks)\n     {\n       pushlevel (0);\n       poplevel (1, 0, 1);\n@@ -6581,7 +6573,7 @@ struct language_function GTY(())\n   int returns_abnormally;\n   int warn_about_return_type;\n   int extern_inline;\n-  struct binding_level *binding_level;\n+  struct c_scope *scope;\n };\n \n /* Save and reinitialize the variables\n@@ -6601,7 +6593,7 @@ c_push_function_context (struct function *f)\n   p->returns_abnormally = current_function_returns_abnormally;\n   p->warn_about_return_type = warn_about_return_type;\n   p->extern_inline = current_extern_inline;\n-  p->binding_level = current_binding_level;\n+  p->scope = current_scope;\n }\n \n /* Restore the variables used during compilation of a C function.  */\n@@ -6628,7 +6620,7 @@ c_pop_function_context (struct function *f)\n   current_function_returns_abnormally = p->returns_abnormally;\n   warn_about_return_type = p->warn_about_return_type;\n   current_extern_inline = p->extern_inline;\n-  current_binding_level = p->binding_level;\n+  current_scope = p->scope;\n \n   f->language = NULL;\n }\n@@ -6736,7 +6728,7 @@ identifier_global_value\t(tree t)\n     return decl;\n \n   /* Shadowed by something else; find the true global value.  */\n-  for (decl = global_binding_level->names; decl; decl = TREE_CHAIN (decl))\n+  for (decl = global_scope->names; decl; decl = TREE_CHAIN (decl))\n     if (DECL_NAME (decl) == t)\n       return decl;\n \n@@ -6787,7 +6779,7 @@ make_pointer_declarator (tree type_quals_attrs, tree target)\n }\n \n /* A wrapper around lhd_set_decl_assembler_name that gives static\n-   variables their C names if they are at the top level and only one\n+   variables their C names if they are at file scope and only one\n    translation unit is being compiled, for backwards compatibility\n    with certain bizzare assembler hacks (like crtstuff.c).  */\n \n@@ -6835,7 +6827,7 @@ merge_translation_unit_decls (void)\n   /* Create the BLOCK that poplevel would have created, but don't\n      actually call poplevel since that's expensive.  */\n   block = make_node (BLOCK);\n-  BLOCK_VARS (block) = current_binding_level->names;\n+  BLOCK_VARS (block) = current_scope->names;\n   TREE_USED (block) = 1;\n   DECL_INITIAL (current_file_decl) = block;\n \n@@ -6958,16 +6950,16 @@ c_reset_state (void)\n   tree link;\n   tree file_scope_decl;\n   \n-  /* Pop the global binding level.  */\n-  if (current_binding_level != global_binding_level)\n-      current_binding_level = global_binding_level;\n+  /* Pop the global scope.  */\n+  if (current_scope != global_scope)\n+      current_scope = global_scope;\n   file_scope_decl = current_file_decl;\n   DECL_INITIAL (file_scope_decl) = poplevel (1, 0, 0);\n   truly_local_externals = NULL_TREE;\n \n   /* Start a new global binding level.  */\n   pushlevel (0);\n-  global_binding_level = current_binding_level;\n+  global_scope = current_scope;\n   current_file_decl = build_decl (TRANSLATION_UNIT_DECL, NULL, NULL);\n   TREE_CHAIN (current_file_decl) = file_scope_decl;\n "}]}