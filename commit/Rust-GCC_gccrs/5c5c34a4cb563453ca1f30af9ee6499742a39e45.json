{"sha": "5c5c34a4cb563453ca1f30af9ee6499742a39e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1YzM0YTRjYjU2MzQ1M2NhMWYzMGFmOWVlNjQ5OTc0MmEzOWU0NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-01-26T20:14:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-01-26T20:14:10Z"}, "message": "sparc.c (sparc_emit_float_lib_cmp): Handle TARGET_ARCH32 again.\n\n\t* config/sparc/sparc.c (sparc_emit_float_lib_cmp): Handle\n\tTARGET_ARCH32 again. Handle ORDERED, UN* and LTGT comparisons\n\tusing _Qp_cmp/_Q_cmp and testing the return value.\n\t(print_operand): Call reverse_condition_maybe_unordered if\n\twe are handling CCFPmode or CCFPEmode.\n\tHandle ORDERED, UN* and LTGT comparisons.\n\t* config/sparc/sparc.md (cmptf): Use even on TARGET_ARCH32\n\tif not TARGET_HARD_QUAD.\n\t(seq, sne, sgt, slt, sge, sle, beq, bne, bgt, blt, bge, ble,\n\tbunordered, bordered, bungt, bunlt, buneq, bunge, bunle, bltgt):\n\tCall sparc_emit_float_lib_cmp even on TARGET_ARCH32.\n\tAdjust gen_b* calls so that they reflect return comparison of\n\tsparc_emit_float_lib_cmp.\n\nFrom-SVN: r31631", "tree": {"sha": "8e4067bc28c66c251c9d71f70e3f4bc0a717fbde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e4067bc28c66c251c9d71f70e3f4bc0a717fbde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c5c34a4cb563453ca1f30af9ee6499742a39e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5c34a4cb563453ca1f30af9ee6499742a39e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5c34a4cb563453ca1f30af9ee6499742a39e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5c34a4cb563453ca1f30af9ee6499742a39e45/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec8b18a48b948790ec93684bdaff9433baedba13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8b18a48b948790ec93684bdaff9433baedba13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8b18a48b948790ec93684bdaff9433baedba13"}], "stats": {"total": 218, "additions": 159, "deletions": 59}, "files": [{"sha": "69cdb8774cfff39d674c467a199f20c5837b2ff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c5c34a4cb563453ca1f30af9ee6499742a39e45", "patch": "@@ -1,3 +1,19 @@\n+2000-01-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_float_lib_cmp): Handle\n+\tTARGET_ARCH32 again. Handle ORDERED, UN* and LTGT comparisons\n+\tusing _Qp_cmp/_Q_cmp and testing the return value.\n+\t(print_operand): Call reverse_condition_maybe_unordered if\n+\twe are handling CCFPmode or CCFPEmode.\n+\tHandle ORDERED, UN* and LTGT comparisons.\n+\t* config/sparc/sparc.md (cmptf): Use even on TARGET_ARCH32\n+\tif not TARGET_HARD_QUAD.\n+\t(seq, sne, sgt, slt, sge, sle, beq, bne, bgt, blt, bge, ble,\n+\tbunordered, bordered, bungt, bunlt, buneq, bunge, bunle, bltgt):\n+\tCall sparc_emit_float_lib_cmp even on TARGET_ARCH32.\n+\tAdjust gen_b* calls so that they reflect return comparison of\n+\tsparc_emit_float_lib_cmp.\n+\n 2000-01-26  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* config/alpha/alpha.c (alpha_emit_xfloating_cvt): Do not assume"}, {"sha": "d6b80b28399b505c6658cdcfed00eb571e6f797f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 119, "deletions": 27, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5c5c34a4cb563453ca1f30af9ee6499742a39e45", "patch": "@@ -4822,67 +4822,144 @@ sparc_emit_float_lib_cmp (x, y, comparison)\n      rtx x, y;\n      enum rtx_code comparison;\n {\n-  const char *qpfunc;\n-  rtx slot0, slot1, result;\n+  char *qpfunc;\n+  rtx cmp = const0_rtx;\n+  rtx slot0, slot1, result, tem, tem2;\n+  enum machine_mode mode;\n \n   switch (comparison)\n     {\n     case EQ:\n-      qpfunc = \"_Qp_feq\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_feq\" : \"_Q_feq\";\n       break;\n \n     case NE:\n-      qpfunc = \"_Qp_fne\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_fne\" : \"_Q_fne\";\n       break;\n \n     case GT:\n-      qpfunc = \"_Qp_fgt\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_fgt\" : \"_Q_fgt\";\n       break;\n \n     case GE:\n-      qpfunc = \"_Qp_fge\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_fge\" : \"_Q_fge\";\n       break;\n \n     case LT:\n-      qpfunc = \"_Qp_flt\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_flt\" : \"_Q_flt\";\n       break;\n \n     case LE:\n-      qpfunc = \"_Qp_fle\";\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_fle\" : \"_Q_fle\";\n+      break;\n+\n+    case ORDERED:\n+    case UNORDERED:\n+    case UNGT:\n+    case UNLT:\n+    case UNEQ:\n+    case UNGE:\n+    case UNLE:\n+    case LTGT:\n+      qpfunc = (TARGET_ARCH64) ? \"_Qp_cmp\" : \"_Q_cmp\";\n       break;\n \n     default:\n       abort();\n       break;\n     }\n \n-  if (GET_CODE (x) != MEM)\n+  if (TARGET_ARCH64)\n     {\n-      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      emit_insn (gen_rtx_SET (VOIDmode, slot0, x));\n-    }\n+      if (GET_CODE (x) != MEM)\n+\t{\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, x));\n+\t}\n+      else\n+\tslot0 = x;\n+\n+      if (GET_CODE (y) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, y));\n+\t}\n+      else\n+\tslot1 = y;\n \n-  if (GET_CODE (y) != MEM)\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), 1,\n+\t\t\t DImode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode);\n+\n+      mode = DImode;\n+    }\n+  else\n     {\n-      slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n-      emit_insn (gen_rtx_SET (VOIDmode, slot1, y));\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), 1,\n+\t\t\t SImode, 2,\n+\t\t\t x, TFmode, y, TFmode);\n+\n+      mode = SImode;\n     }\n \n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, qpfunc), 1,\n-                     DImode, 2,\n-                     XEXP (slot0, 0), Pmode,\n-                     XEXP (slot1, 0), Pmode);\n \n   /* Immediately move the result of the libcall into a pseudo\n      register so reload doesn't clobber the value if it needs\n      the return register for a spill reg.  */\n-  result = gen_reg_rtx (DImode);\n-  emit_move_insn (result, hard_libcall_value (DImode));\n+  result = gen_reg_rtx (mode);\n+  emit_move_insn (result, hard_libcall_value (mode));\n \n-  emit_cmp_insn (result, const0_rtx, comparison,\n-                 NULL_RTX, DImode, 0, 0);\n+  switch (comparison)\n+    {\n+    default:\n+      emit_cmp_insn (result, const0_rtx, NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    case ORDERED:\n+    case UNORDERED:\n+      emit_cmp_insn (result, GEN_INT(3),\n+\t\t     (comparison == UNORDERED) ? EQ : NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    case UNGT:\n+    case UNGE:\n+      emit_cmp_insn (result, const1_rtx,\n+\t\t     (comparison == UNGT) ? GT : NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    case UNLE:\n+      emit_cmp_insn (result, const2_rtx, NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    case UNLT:\n+      tem = gen_reg_rtx (mode);\n+      if (TARGET_ARCH32)\n+\temit_insn (gen_andsi3 (tem, result, const1_rtx));\n+      else\n+\temit_insn (gen_anddi3 (tem, result, const1_rtx));\n+      emit_cmp_insn (tem, const0_rtx, NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    case UNEQ:\n+    case LTGT:\n+      tem = gen_reg_rtx (mode);\n+      if (TARGET_ARCH32)\n+\temit_insn (gen_addsi3 (tem, result, const1_rtx));\n+      else\n+\temit_insn (gen_adddi3 (tem, result, const1_rtx));\n+      tem2 = gen_reg_rtx (mode);\n+      if (TARGET_ARCH32)\n+\temit_insn (gen_andsi3 (tem2, tem, const2_rtx));\n+      else\n+\temit_insn (gen_anddi3 (tem2, tem, const2_rtx));\n+      emit_cmp_insn (tem2, const0_rtx,\n+\t\t     (comparison == UNEQ) ? EQ : NE,\n+\t\t     NULL_RTX, mode, 0, 0);\n+      break;\n+    }\n }\n-          \n+\n /* Return the string to output a conditional branch to LABEL, testing\n    register REG.  LABEL is the operand number of the label; REG is the\n    operand number of the reg.  OP is the conditional expression.  The mode\n@@ -5449,9 +5526,16 @@ print_operand (file, x, code)\n     case 'c' :\n     case 'C':\n       {\n-\tenum rtx_code rc = (code == 'c'\n-\t\t\t    ? reverse_condition (GET_CODE (x))\n-\t\t\t    : GET_CODE (x));\n+\tenum rtx_code rc = GET_CODE (x);\n+\t\n+\tif (code == 'c')\n+\t  {\n+\t    enum machine_mode mode = GET_MODE (XEXP (x, 0));\n+\t    if (mode == CCFPmode || mode == CCFPEmode)\n+\t      rc = reverse_condition_maybe_unordered (GET_CODE (x));\n+\t    else\n+\t      rc = reverse_condition (GET_CODE (x));\n+\t  }\n \tswitch (rc)\n \t  {\n \t  case NE: fputs (\"ne\", file); break;\n@@ -5464,6 +5548,14 @@ print_operand (file, x, code)\n \t  case GTU: fputs (\"gu\", file); break;\n \t  case LEU: fputs (\"leu\", file); break;\n \t  case LTU: fputs (\"lu\", file); break;\n+\t  case LTGT: fputs (\"lg\", file); break;\n+\t  case UNORDERED: fputs (\"u\", file); break;\n+\t  case ORDERED: fputs (\"o\", file); break;\n+\t  case UNLT: fputs (\"ul\", file); break;\n+\t  case UNLE: fputs (\"ule\", file); break;\n+\t  case UNGT: fputs (\"ug\", file); break;\n+\t  case UNGE: fputs (\"uge\", file); break;\n+\t  case UNEQ: fputs (\"ue\", file); break;\n \t  default: output_operand_lossage (code == 'c'\n \t\t\t\t\t   ? \"Invalid %%c operand\"\n \t\t\t\t\t   : \"Invalid %%C operand\");"}, {"sha": "40fe3a86d8f1fe09c09d812e04763ea2d171f033", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5c34a4cb563453ca1f30af9ee6499742a39e45/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=5c5c34a4cb563453ca1f30af9ee6499742a39e45", "patch": "@@ -627,7 +627,7 @@\n   [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n \t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"TARGET_FPU\"\n   \"\n {\n   sparc_compare_op0 = operands[0];\n@@ -855,7 +855,7 @@\n       emit_insn (pat);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -908,7 +908,7 @@\n       emit_insn (pat);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -929,7 +929,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -950,7 +950,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -971,7 +971,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -992,7 +992,7 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n       emit_jump_insn (gen_sne (operands[0]));\n@@ -1626,7 +1626,7 @@\n       emit_v9_brxx_insn (EQ, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1650,7 +1650,7 @@\n       emit_v9_brxx_insn (NE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1674,7 +1674,7 @@\n       emit_v9_brxx_insn (GT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1708,7 +1708,7 @@\n       emit_v9_brxx_insn (LT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1742,7 +1742,7 @@\n       emit_v9_brxx_insn (GE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1776,7 +1776,7 @@\n       emit_v9_brxx_insn (LE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n-  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1803,12 +1803,11 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1,\n \t\t\t\tUNORDERED);\n-      emit_jump_insn (gen_bne (operands[0]));\n+      emit_jump_insn (gen_beq (operands[0]));\n       DONE;\n     }\n   operands[1] = gen_compare_reg (UNORDERED, sparc_compare_op0,\n@@ -1823,8 +1822,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, ORDERED);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1842,11 +1840,10 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGT);\n-      emit_jump_insn (gen_bne (operands[0]));\n+      emit_jump_insn (gen_bgt (operands[0]));\n       DONE;\n     }\n   operands[1] = gen_compare_reg (UNGT, sparc_compare_op0, sparc_compare_op1);\n@@ -1860,8 +1857,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLT);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1878,11 +1874,10 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNEQ);\n-      emit_jump_insn (gen_bne (operands[0]));\n+      emit_jump_insn (gen_beq (operands[0]));\n       DONE;\n     }\n   operands[1] = gen_compare_reg (UNEQ, sparc_compare_op0, sparc_compare_op1);\n@@ -1896,8 +1891,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGE);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1914,8 +1908,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLE);\n       emit_jump_insn (gen_bne (operands[0]));\n@@ -1932,8 +1925,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sparc_compare_op0) == TFmode\n-      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n       sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LTGT);\n       emit_jump_insn (gen_bne (operands[0]));"}]}