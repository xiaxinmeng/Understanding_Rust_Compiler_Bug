{"sha": "84568e14b534a808707d9e0894c6021792ca633d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1NjhlMTRiNTM0YTgwODcwN2Q5ZTA4OTRjNjAyMTc5MmNhNjMzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-14T22:43:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-14T22:43:54Z"}, "message": "sched-deps.c (trye_dependency_cache, [...]): Trun to vectors of bitmaps\n\n\t* sched-deps.c (trye_dependency_cache, anti_dependency_cache,\n\toutptu_dependency_cache, forward_dependency_cahe): Trun to vectors of\n\tbitmaps\n\t(cache_size): New variable\n\t(add_dependence): Update use; canonize early memory locations\n\t(sched_analyze_1): Likewise.\n\t(sched_analyze_2): Likewise.\n\t(init_dependency_caches): Initialize bitmaps.\n\t(free_dependency_caches): Free bitmaps\n\nFrom-SVN: r75888", "tree": {"sha": "b171cfbc71f9d4eb6a53813a08d172fb6ccef693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b171cfbc71f9d4eb6a53813a08d172fb6ccef693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84568e14b534a808707d9e0894c6021792ca633d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84568e14b534a808707d9e0894c6021792ca633d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84568e14b534a808707d9e0894c6021792ca633d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84568e14b534a808707d9e0894c6021792ca633d/comments", "author": null, "committer": null, "parents": [{"sha": "3a1797641a5b8e06d3d7b48ea16240264aba3e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1797641a5b8e06d3d7b48ea16240264aba3e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a1797641a5b8e06d3d7b48ea16240264aba3e9d"}], "stats": {"total": 109, "additions": 72, "deletions": 37}, "files": [{"sha": "00062dee7872c04637c5e9c865b3be94b6a08a5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84568e14b534a808707d9e0894c6021792ca633d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84568e14b534a808707d9e0894c6021792ca633d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84568e14b534a808707d9e0894c6021792ca633d", "patch": "@@ -1,3 +1,16 @@\n+2004-01-14  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR c++/10776\n+\t* sched-deps.c (trye_dependency_cache, anti_dependency_cache,\n+\toutptu_dependency_cache, forward_dependency_cahe): Trun to vectors of\n+\tbitmaps\n+\t(cache_size): New variable\n+\t(add_dependence): Update use; canonize early memory locations\n+\t(sched_analyze_1): Likewise.\n+\t(sched_analyze_2): Likewise.\n+\t(init_dependency_caches): Initialize bitmaps.\n+\t(free_dependency_caches): Free bitmaps\n+\n 2004-01-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* calls.c: Replace STRICT_ARGUMENT_NAMING in comments with"}, {"sha": "82fef76507dcc2c05dc26fa84e9fad74b1608a4b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84568e14b534a808707d9e0894c6021792ca633d/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84568e14b534a808707d9e0894c6021792ca633d/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=84568e14b534a808707d9e0894c6021792ca633d", "patch": "@@ -80,16 +80,17 @@ static enum reg_pending_barrier_mode reg_pending_barrier;\n    has enough entries to represent a dependency on any other insn in\n    the insn chain.  All bitmap for true dependencies cache is\n    allocated then the rest two ones are also allocated.  */\n-static sbitmap *true_dependency_cache;\n-static sbitmap *anti_dependency_cache;\n-static sbitmap *output_dependency_cache;\n+static bitmap_head *true_dependency_cache;\n+static bitmap_head *anti_dependency_cache;\n+static bitmap_head *output_dependency_cache;\n+int cache_size;\n \n /* To speed up checking consistency of formed forward insn\n    dependencies we use the following cache.  Another possible solution\n    could be switching off checking duplication of insns in forward\n    dependencies.  */\n #ifdef ENABLE_CHECKING\n-static sbitmap *forward_dependency_cache;\n+static bitmap_head *forward_dependency_cache;\n #endif\n \n static int deps_may_trap_p (rtx);\n@@ -244,13 +245,14 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n \n       if (anti_dependency_cache == NULL || output_dependency_cache == NULL)\n \tabort ();\n-      if (TEST_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem)))\n+      if (bitmap_bit_p (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\tINSN_LUID (elem)))\n \t/* Do nothing (present_set_type is already 0).  */\n \t;\n-      else if (TEST_BIT (anti_dependency_cache[INSN_LUID (insn)],\n+      else if (bitmap_bit_p (&anti_dependency_cache[INSN_LUID (insn)],\n \t\t\t INSN_LUID (elem)))\n \tpresent_dep_type = REG_DEP_ANTI;\n-      else if (TEST_BIT (output_dependency_cache[INSN_LUID (insn)],\n+      else if (bitmap_bit_p (&output_dependency_cache[INSN_LUID (insn)],\n \t\t\t INSN_LUID (elem)))\n \tpresent_dep_type = REG_DEP_OUTPUT;\n       else\n@@ -271,12 +273,12 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n \t  if (true_dependency_cache != NULL)\n \t    {\n \t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tRESET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n+\t\tbitmap_clear_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t  INSN_LUID (elem));\n \t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT\n \t\t       && output_dependency_cache)\n-\t\tRESET_BIT (output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n+\t\tbitmap_clear_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\t  INSN_LUID (elem));\n \t      else\n \t\tabort ();\n \t    }\n@@ -293,14 +295,14 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n \t  if (true_dependency_cache != NULL)\n \t    {\n \t      if ((int) REG_NOTE_KIND (link) == 0)\n-\t\tSET_BIT (true_dependency_cache[INSN_LUID (insn)],\n-\t\t\t INSN_LUID (elem));\n+\t\tbitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\tINSN_LUID (elem));\n \t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tSET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t INSN_LUID (elem));\n+\t\tbitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\tINSN_LUID (elem));\n \t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\tSET_BIT (output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t INSN_LUID (elem));\n+\t\tbitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)],\n+\t\t\t\tINSN_LUID (elem));\n \t    }\n #endif\n \t  return 0;\n@@ -319,11 +321,11 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n   if (true_dependency_cache != NULL)\n     {\n       if ((int) dep_type == 0)\n-\tSET_BIT (true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+\tbitmap_set_bit (&true_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n       else if (dep_type == REG_DEP_ANTI)\n-\tSET_BIT (anti_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+\tbitmap_set_bit (&anti_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n       else if (dep_type == REG_DEP_OUTPUT)\n-\tSET_BIT (output_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n+\tbitmap_set_bit (&output_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n     }\n #endif\n   return 1;\n@@ -395,7 +397,7 @@ add_insn_mem_dependence (struct deps *deps, rtx *insn_list, rtx *mem_list,\n       mem = shallow_copy_rtx (mem);\n       XEXP (mem, 0) = cselib_subst_to_values (XEXP (mem, 0));\n     }\n-  link = alloc_EXPR_LIST (VOIDmode, mem, *mem_list);\n+  link = alloc_EXPR_LIST (VOIDmode, canon_rtx (mem), *mem_list);\n   *mem_list = link;\n \n   deps->pending_lists_length++;\n@@ -543,6 +545,7 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n \t  cselib_lookup (XEXP (t, 0), Pmode, 1);\n \t  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t}\n+      XEXP (t, 0) = canon_rtx (XEXP (t, 0));\n \n       if (deps->pending_lists_length > MAX_PENDING_LIST_LENGTH)\n \t{\n@@ -684,6 +687,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t    cselib_lookup (XEXP (t, 0), Pmode, 1);\n \t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n \t  }\n+        XEXP (t, 0) = canon_rtx (XEXP (t, 0));\n \tpending = deps->pending_read_insns;\n \tpending_mem = deps->pending_read_mems;\n \twhile (pending)\n@@ -1345,14 +1349,14 @@ add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n   if (GET_CODE (from) == NOTE\n       || INSN_DELETED_P (from)\n       || (forward_dependency_cache != NULL\n-\t  && TEST_BIT (forward_dependency_cache[INSN_LUID (from)],\n-\t\t       INSN_LUID (to)))\n+\t  && bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n+\t\t\t   INSN_LUID (to)))\n       || (forward_dependency_cache == NULL\n \t  && find_insn_list (to, INSN_DEPEND (from))))\n     abort ();\n   if (forward_dependency_cache != NULL)\n-    SET_BIT (forward_dependency_cache[INSN_LUID (from)],\n-\t     INSN_LUID (to));\n+    bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],\n+\t\t  INSN_LUID (to));\n #endif\n \n   new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n@@ -1457,16 +1461,23 @@ init_dependency_caches (int luid)\n      what we consider \"very high\".  */\n   if (luid / n_basic_blocks > 100 * 5)\n     {\n-      true_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (true_dependency_cache, luid);\n-      anti_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (anti_dependency_cache, luid);\n-      output_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (output_dependency_cache, luid);\n+      int i;\n+      true_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+      anti_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+      output_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+#ifdef ENABLE_CHECKING\n+      forward_dependency_cache = xmalloc (luid * sizeof (bitmap_head));\n+#endif\n+      for (i = 0; i < luid; i++)\n+\t{\n+\t  bitmap_initialize (&true_dependency_cache[i], 0);\n+\t  bitmap_initialize (&anti_dependency_cache[i], 0);\n+\t  bitmap_initialize (&output_dependency_cache[i], 0);\n #ifdef ENABLE_CHECKING\n-      forward_dependency_cache = sbitmap_vector_alloc (luid, luid);\n-      sbitmap_vector_zero (forward_dependency_cache, luid);\n+\t  bitmap_initialize (&forward_dependency_cache[i], 0);\n #endif\n+\t}\n+      cache_size = luid;\n     }\n }\n \n@@ -1477,14 +1488,25 @@ free_dependency_caches (void)\n {\n   if (true_dependency_cache)\n     {\n-      sbitmap_vector_free (true_dependency_cache);\n+      int i;\n+\n+      for (i = 0; i < cache_size; i++)\n+\t{\n+\t  bitmap_clear (&true_dependency_cache[i]);\n+\t  bitmap_clear (&anti_dependency_cache[i]);\n+\t  bitmap_clear (&output_dependency_cache[i]);\n+#ifdef ENABLE_CHECKING\n+\t  bitmap_clear (&forward_dependency_cache[i]);\n+#endif\n+\t}\n+      free (true_dependency_cache);\n       true_dependency_cache = NULL;\n-      sbitmap_vector_free (anti_dependency_cache);\n+      free (anti_dependency_cache);\n       anti_dependency_cache = NULL;\n-      sbitmap_vector_free (output_dependency_cache);\n+      free (output_dependency_cache);\n       output_dependency_cache = NULL;\n #ifdef ENABLE_CHECKING\n-      sbitmap_vector_free (forward_dependency_cache);\n+      free (forward_dependency_cache);\n       forward_dependency_cache = NULL;\n #endif\n     }"}]}