{"sha": "6da879de228e86b6a571e93f311462259f246f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRhODc5ZGUyMjhlODZiNmE1NzFlOTNmMzExNDYyMjU5ZjI0NmY5MQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-03-27T15:31:13Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-03-27T15:31:13Z"}, "message": "md5.h: Remove definition and uses of __P.\n\ninclude/\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\t* md5.h: Remove definition and uses of __P.\n\t* dyn-string.h: Remove uses of PARAMS.\n\t* fibheap.h: Likewise.\n\t* floatformat.h: Likewise.\n\t* hashtab.h: Likewise.\n\nlibiberty/\n\n2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\tConvert libiberty to use ISO C prototype style 4/n.\n\t* hashtab.c (higher_prime_index, hash_pointer, eq_pointer,\n\thtab_size, htab_elements, htab_mod_1, htab_mod, htab_mod_m2,\n\thtab_create_alloc, htab_set_functions_ex, htab_create,\n\thtab_try_create, htab_delete, htab_empty,\n\tfind_empty_slot_for_expand, htab_expand, htab_find_with_hash,\n\thtab_find, htab_find_slot_with_hash, htab_find_slot,\n\thtab_remove_elt, htab_remove_elt_with_hash, htab_clear_slot,\n\thtab_traverse_noresize, htab_traverse, htab_collisions,\n\thtab_hash_string, iterative_hash): Use ISO C prototype.\n\t* hex.c (hex_init): Likewise.\n\t* index.c (index): Likewise.\n\t* insque.c (insque, remque): Likewise.\n\t* lbasename.c (lbasename): Likewise.\n\t* lrealpath.c (lrealpath): Likewise.\n\t* make-relative-prefix.c (save_string, split_directories,\n\tfree_split_directories, make_relative_prefix): Likewise.\n\t* make-temp-file.c (try, choose_tmpdir, make_temp_file): Likewise.\n\t* md5.c (md5_init_ctx, md5_read_ctx, md5_finish_ctx, md5_stream,\n\tmd5_buffer, md5_process_bytes, md5_process_block): Likewise.\n\t* memchr.c (memchr): Likewise.\n\t* memcpy.c (memcpy): Likewise.\n\t* memmove.c (memmove): Likewise.\n\t* gettimeofday.c (gettimeofday): Likewise.\n\t* getruntime.c (get_run_time): Likewise.\n\t* getpwd.c (getpwd, getpwd): Likewise.\n\t* getpagesize.c (getpagesize): Likewise.\n\t* getopt1.c (getopt_long, getopt_long_only, main): Likewise.\n\t* getopt.c (my_index, exchange, _getopt_initialize,\n\t_getopt_internal, getopt, main): Likewise.\n\t* getcwd.c (getcwd): Likewise.\n\t* fnmatch.c (fnmatch): Likewise.\n\t* floatformat.c (floatformat_always_valid,\n\tfloatformat_i387_ext_is_valid, get_field, floatformat_to_double,\n\tput_field, floatformat_from_double, floatformat_is_valid,\n\tieee_test, main): Likewise.\n\t* fibheap.c (fibheap_new, fibnode_new, fibheap_compare,\n\tfibheap_comp_data, fibheap_insert, fibheap_min, fibheap_min_key,\n\tfibheap_union, fibheap_extract_min, fibheap_replace_key_data,\n\tfibheap_replace_key, fibheap_replace_data, fibheap_delete_node,\n\tfibheap_delete, fibheap_empty, fibheap_extr_min_node,\n\tfibheap_ins_root, fibheap_rem_root, fibheap_consolidate,\n\tfibheap_link, fibheap_cut, fibheap_cascading_cut,\n\tfibnode_insert_after, fibnode_remove): Likewise.\n\t* ffs.c (ffs): Likewise.\n\t* fdmatch.c (fdmatch): Likewise.\n\t* dyn-string.c (dyn_string_init, dyn_string_new,\n\tdyn_string_delete, dyn_string_release, dyn_string_resize,\n\tdyn_string_clear, dyn_string_copy, dyn_string_copy_cstr,\n\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert,\n\tdyn_string_insert_cstr, dyn_string_insert_char,\n\tdyn_string_append, dyn_string_append_cstr,\n\tdyn_string_append_char, dyn_string_substring, dyn_string_eq):\n\tLikewise.\n\nFrom-SVN: r97113", "tree": {"sha": "0872026e71fbe1b4f55f00b32edbefbb1c754623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0872026e71fbe1b4f55f00b32edbefbb1c754623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6da879de228e86b6a571e93f311462259f246f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da879de228e86b6a571e93f311462259f246f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da879de228e86b6a571e93f311462259f246f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da879de228e86b6a571e93f311462259f246f91/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c295d7b3697d6724aaf59498475df26d8debd1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c295d7b3697d6724aaf59498475df26d8debd1c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c295d7b3697d6724aaf59498475df26d8debd1c6"}], "stats": {"total": 872, "additions": 339, "deletions": 533}, "files": [{"sha": "87372e54ebe89593987628ccd92e5f8cb594b386", "filename": "include/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -1,3 +1,11 @@\n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* md5.h: Remove definition and uses of __P.\n+\t* dyn-string.h: Remove uses of PARAMS.\n+\t* fibheap.h: Likewise.\n+\t* floatformat.h: Likewise.\n+\t* hashtab.h: Likewise.\n+\n 2005-03-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* demangle.h: Remove uses of PARAMS."}, {"sha": "a351ec3bdcc16d7440567188326ceca46836b5e8", "filename": "include/dyn-string.h", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdyn-string.h?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -40,24 +40,21 @@ typedef struct dyn_string\n   (strcmp ((DS1)->s, (DS2)->s))\n \n \n-extern int dyn_string_init              PARAMS ((struct dyn_string *, int));\n-extern dyn_string_t dyn_string_new      PARAMS ((int));\n-extern void dyn_string_delete           PARAMS ((dyn_string_t));\n-extern char *dyn_string_release         PARAMS ((dyn_string_t));\n-extern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));\n-extern void dyn_string_clear            PARAMS ((dyn_string_t));\n-extern int dyn_string_copy              PARAMS ((dyn_string_t, dyn_string_t));\n-extern int dyn_string_copy_cstr         PARAMS ((dyn_string_t, const char *));\n-extern int dyn_string_prepend           PARAMS ((dyn_string_t, dyn_string_t));\n-extern int dyn_string_prepend_cstr      PARAMS ((dyn_string_t, const char *));\n-extern int dyn_string_insert            PARAMS ((dyn_string_t, int,\n-\t\t\t\t\t\t dyn_string_t));\n-extern int dyn_string_insert_cstr       PARAMS ((dyn_string_t, int,\n-\t\t\t\t\t\t const char *));\n-extern int dyn_string_insert_char       PARAMS ((dyn_string_t, int, int));\n-extern int dyn_string_append            PARAMS ((dyn_string_t, dyn_string_t));\n-extern int dyn_string_append_cstr       PARAMS ((dyn_string_t, const char *));\n-extern int dyn_string_append_char       PARAMS ((dyn_string_t, int));\n-extern int dyn_string_substring         PARAMS ((dyn_string_t, \n-\t\t\t\t\t\t dyn_string_t, int, int));\n-extern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));\n+extern int dyn_string_init (struct dyn_string *, int);\n+extern dyn_string_t dyn_string_new (int);\n+extern void dyn_string_delete (dyn_string_t);\n+extern char *dyn_string_release (dyn_string_t);\n+extern dyn_string_t dyn_string_resize (dyn_string_t, int);\n+extern void dyn_string_clear (dyn_string_t);\n+extern int dyn_string_copy (dyn_string_t, dyn_string_t);\n+extern int dyn_string_copy_cstr (dyn_string_t, const char *);\n+extern int dyn_string_prepend (dyn_string_t, dyn_string_t);\n+extern int dyn_string_prepend_cstr (dyn_string_t, const char *);\n+extern int dyn_string_insert (dyn_string_t, int, dyn_string_t);\n+extern int dyn_string_insert_cstr (dyn_string_t, int, const char *);\n+extern int dyn_string_insert_char (dyn_string_t, int, int);\n+extern int dyn_string_append (dyn_string_t, dyn_string_t);\n+extern int dyn_string_append_cstr (dyn_string_t, const char *);\n+extern int dyn_string_append_char (dyn_string_t, int);\n+extern int dyn_string_substring (dyn_string_t,  dyn_string_t, int, int);\n+extern int dyn_string_eq (dyn_string_t, dyn_string_t);"}, {"sha": "bfd82da2cb08f449a48c45275d1c6bf0c4f289a2", "filename": "include/fibheap.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2Ffibheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2Ffibheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Ffibheap.h?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -68,19 +68,19 @@ typedef struct fibnode\n #endif\n } *fibnode_t;\n \n-extern fibheap_t fibheap_new PARAMS ((void));\n-extern fibnode_t fibheap_insert PARAMS ((fibheap_t, fibheapkey_t, void *));\n-extern int fibheap_empty PARAMS ((fibheap_t));\n-extern fibheapkey_t fibheap_min_key PARAMS ((fibheap_t));\n-extern fibheapkey_t fibheap_replace_key PARAMS ((fibheap_t, fibnode_t,\n-\t\t\t\t\t\t fibheapkey_t));\n-extern void *fibheap_replace_key_data PARAMS ((fibheap_t, fibnode_t,\n-\t\t\t\t\t       fibheapkey_t, void *));\n-extern void *fibheap_extract_min PARAMS ((fibheap_t));\n-extern void *fibheap_min PARAMS ((fibheap_t));\n-extern void *fibheap_replace_data PARAMS ((fibheap_t, fibnode_t, void *));\n-extern void *fibheap_delete_node PARAMS ((fibheap_t, fibnode_t));\n-extern void fibheap_delete PARAMS ((fibheap_t));\n-extern fibheap_t fibheap_union PARAMS ((fibheap_t, fibheap_t));\n+extern fibheap_t fibheap_new (void);\n+extern fibnode_t fibheap_insert (fibheap_t, fibheapkey_t, void *);\n+extern int fibheap_empty (fibheap_t);\n+extern fibheapkey_t fibheap_min_key (fibheap_t);\n+extern fibheapkey_t fibheap_replace_key (fibheap_t, fibnode_t,\n+                                         fibheapkey_t);\n+extern void *fibheap_replace_key_data (fibheap_t, fibnode_t,\n+                                       fibheapkey_t, void *);\n+extern void *fibheap_extract_min (fibheap_t);\n+extern void *fibheap_min (fibheap_t);\n+extern void *fibheap_replace_data (fibheap_t, fibnode_t, void *);\n+extern void *fibheap_delete_node (fibheap_t, fibnode_t);\n+extern void fibheap_delete (fibheap_t);\n+extern fibheap_t fibheap_union (fibheap_t, fibheap_t);\n \n #endif /* _FIBHEAP_H_ */"}, {"sha": "40911b33694245eef77c137464f131f1a6fcf3c6", "filename": "include/floatformat.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2Ffloatformat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2Ffloatformat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Ffloatformat.h?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -82,7 +82,7 @@ struct floatformat\n   const char *name;\n \n   /* Validator method.  */\n-  int (*is_valid) PARAMS ((const struct floatformat *fmt, const char *from));\n+  int (*is_valid) (const struct floatformat *fmt, const char *from);\n };\n \n /* floatformats for IEEE single and double, big and little endian.  */\n@@ -116,18 +116,17 @@ extern const struct floatformat floatformat_ia64_quad_little;\n    Store the double in *TO.  */\n \n extern void\n-floatformat_to_double PARAMS ((const struct floatformat *, const char *, double *));\n+floatformat_to_double (const struct floatformat *, const char *, double *);\n \n /* The converse: convert the double *FROM to FMT\n    and store where TO points.  */\n \n extern void\n-floatformat_from_double PARAMS ((const struct floatformat *,\n-\t\t\t\t const double *, char *));\n+floatformat_from_double (const struct floatformat *, const double *, char *);\n \n /* Return non-zero iff the data at FROM is a valid number in format FMT.  */\n \n extern int\n-floatformat_is_valid PARAMS ((const struct floatformat *fmt, const char *from));\n+floatformat_is_valid (const struct floatformat *fmt, const char *from);\n \n #endif\t/* defined (FLOATFORMAT_H) */"}, {"sha": "c75b23c8f0584aad6e70ba6bcbdc6a7acf718473", "filename": "include/hashtab.h", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2Fhashtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2Fhashtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhashtab.h?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -48,38 +48,38 @@ typedef unsigned int hashval_t;\n /* Callback function pointer types.  */\n \n /* Calculate hash of a table entry.  */\n-typedef hashval_t (*htab_hash) PARAMS ((const void *));\n+typedef hashval_t (*htab_hash) (const void *);\n \n /* Compare a table entry with a possible entry.  The entry already in\n    the table always comes first, so the second element can be of a\n    different type (but in this case htab_find and htab_find_slot\n    cannot be used; instead the variants that accept a hash value\n    must be used).  */\n-typedef int (*htab_eq) PARAMS ((const void *, const void *));\n+typedef int (*htab_eq) (const void *, const void *);\n \n /* Cleanup function called whenever a live element is removed from\n    the hash table.  */\n-typedef void (*htab_del) PARAMS ((void *));\n+typedef void (*htab_del) (void *);\n   \n /* Function called by htab_traverse for each live element.  The first\n    arg is the slot of the element (which can be passed to htab_clear_slot\n    if desired), the second arg is the auxiliary pointer handed to\n    htab_traverse.  Return 1 to continue scan, 0 to stop.  */\n-typedef int (*htab_trav) PARAMS ((void **, void *));\n+typedef int (*htab_trav) (void **, void *);\n \n /* Memory-allocation function, with the same functionality as calloc().\n    Iff it returns NULL, the hash table implementation will pass an error\n    code back to the user, so if your code doesn't handle errors,\n    best if you use xcalloc instead.  */\n-typedef PTR (*htab_alloc) PARAMS ((size_t, size_t));\n+typedef PTR (*htab_alloc) (size_t, size_t);\n \n /* We also need a free() routine.  */\n-typedef void (*htab_free) PARAMS ((PTR));\n+typedef void (*htab_free) (PTR);\n \n /* Memory allocation and deallocation; variants which take an extra\n    argument.  */\n-typedef PTR (*htab_alloc_with_arg) PARAMS ((void *, size_t, size_t));\n-typedef void (*htab_free_with_arg) PARAMS ((void *, void *));\n+typedef PTR (*htab_alloc_with_arg) (void *, size_t, size_t);\n+typedef void (*htab_free_with_arg) (void *, void *);\n \n /* Hash tables are of the following type.  The structure\n    (implementation) of this type is not needed for using the hash\n@@ -139,45 +139,43 @@ enum insert_option {NO_INSERT, INSERT};\n \n /* The prototypes of the package functions. */\n \n-extern htab_t\thtab_create_alloc\tPARAMS ((size_t, htab_hash,\n-\t\t\t\t\t\t htab_eq, htab_del,\n-\t\t\t\t\t\t htab_alloc, htab_free));\n+extern htab_t\thtab_create_alloc  (size_t, htab_hash,\n+                                    htab_eq, htab_del,\n+                                    htab_alloc, htab_free);\n \n-extern htab_t\thtab_create_alloc_ex\tPARAMS ((size_t, htab_hash,\n-\t\t\t\t\t\t    htab_eq, htab_del,\n-\t\t\t\t\t\t    PTR, htab_alloc_with_arg,\n-\t\t\t\t\t\t    htab_free_with_arg));\n+extern htab_t\thtab_create_alloc_ex (size_t, htab_hash,\n+                                      htab_eq, htab_del,\n+                                      PTR, htab_alloc_with_arg,\n+                                      htab_free_with_arg);\n \n /* Backward-compatibility functions.  */\n-extern htab_t htab_create PARAMS ((size_t, htab_hash, htab_eq, htab_del));\n-extern htab_t htab_try_create PARAMS ((size_t, htab_hash, htab_eq, htab_del));\n-\n-extern void\thtab_set_functions_ex\tPARAMS ((htab_t, htab_hash,\n-\t\t\t\t\t\t htab_eq, htab_del,\n-\t\t\t\t\t\t PTR, htab_alloc_with_arg,\n-\t\t\t\t\t\t htab_free_with_arg));\n-\n-extern void\thtab_delete\tPARAMS ((htab_t));\n-extern void\thtab_empty\tPARAMS ((htab_t));\n-\n-extern PTR\thtab_find\tPARAMS ((htab_t, const void *));\n-extern PTR     *htab_find_slot\tPARAMS ((htab_t, const void *,\n-\t\t\t\t\t enum insert_option));\n-extern PTR\thtab_find_with_hash\t  PARAMS ((htab_t, const void *,\n-\t\t\t\t\t\t   hashval_t));\n-extern PTR     *htab_find_slot_with_hash  PARAMS ((htab_t, const void *,\n-\t\t\t\t\t\t   hashval_t,\n-\t\t\t\t\t\t   enum insert_option));\n-extern void\thtab_clear_slot\tPARAMS ((htab_t, void **));\n-extern void\thtab_remove_elt\tPARAMS ((htab_t, void *));\n-extern void\thtab_remove_elt_with_hash PARAMS ((htab_t, void *, hashval_t));\n-\n-extern void\thtab_traverse\tPARAMS ((htab_t, htab_trav, void *));\n-extern void\thtab_traverse_noresize\tPARAMS ((htab_t, htab_trav, void *));\n-\n-extern size_t\thtab_size\tPARAMS ((htab_t));\n-extern size_t\thtab_elements\tPARAMS ((htab_t));\n-extern double\thtab_collisions\tPARAMS ((htab_t));\n+extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);\n+extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);\n+\n+extern void\thtab_set_functions_ex (htab_t, htab_hash,\n+                                       htab_eq, htab_del,\n+                                       PTR, htab_alloc_with_arg,\n+                                       htab_free_with_arg);\n+\n+extern void\thtab_delete (htab_t);\n+extern void\thtab_empty (htab_t);\n+\n+extern PTR\thtab_find (htab_t, const void *);\n+extern PTR     *htab_find_slot (htab_t, const void *, enum insert_option);\n+extern PTR\thtab_find_with_hash (htab_t, const void *, hashval_t);\n+extern PTR     *htab_find_slot_with_hash (htab_t, const void *,\n+                                          hashval_t,\n+                                          enum insert_option);\n+extern void\thtab_clear_slot\t(htab_t, void **);\n+extern void\thtab_remove_elt\t(htab_t, void *);\n+extern void\thtab_remove_elt_with_hash (htab_t, void *, hashval_t);\n+\n+extern void\thtab_traverse (htab_t, htab_trav, void *);\n+extern void\thtab_traverse_noresize (htab_t, htab_trav, void *);\n+\n+extern size_t\thtab_size (htab_t);\n+extern size_t\thtab_elements (htab_t);\n+extern double\thtab_collisions\t(htab_t);\n \n /* A hash function for pointers.  */\n extern htab_hash htab_hash_pointer;\n@@ -186,10 +184,10 @@ extern htab_hash htab_hash_pointer;\n extern htab_eq htab_eq_pointer;\n \n /* A hash function for null-terminated strings.  */\n-extern hashval_t htab_hash_string PARAMS ((const PTR));\n+extern hashval_t htab_hash_string (const PTR);\n \n /* An iterative hash function for arbitrary data.  */\n-extern hashval_t iterative_hash PARAMS ((const PTR, size_t, hashval_t));\n+extern hashval_t iterative_hash (const PTR, size_t, hashval_t);\n /* Shorthand for hashing something with an intrinsic size.  */\n #define iterative_hash_object(OB,INIT) iterative_hash (&OB, sizeof (OB), INIT)\n "}, {"sha": "4cdad889a100aa36a2bdf7120cd6836751d19935", "filename": "include/md5.h", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/include%2Fmd5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/include%2Fmd5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fmd5.h?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -66,13 +66,6 @@ typedef u_int32_t md5_uint32;\n # endif\n #endif\n \n-#undef __P\n-#if defined (__STDC__) && __STDC__\n-#define\t__P(x) x\n-#else\n-#define\t__P(x) ()\n-#endif\n-\n /* Structure to save state of computation between the single steps.  */\n struct md5_ctx\n {\n@@ -93,21 +86,21 @@ struct md5_ctx\n \n /* Initialize structure containing state of computation.\n    (RFC 1321, 3.3: Step 3)  */\n-extern void md5_init_ctx __P ((struct md5_ctx *ctx));\n+extern void md5_init_ctx (struct md5_ctx *ctx);\n \n /* Starting with the result of former calls of this function (or the\n    initialization function update the context for the next LEN bytes\n    starting at BUFFER.\n    It is necessary that LEN is a multiple of 64!!! */\n-extern void md5_process_block __P ((const void *buffer, size_t len,\n-\t\t\t\t    struct md5_ctx *ctx));\n+extern void md5_process_block (const void *buffer, size_t len,\n+                               struct md5_ctx *ctx);\n \n /* Starting with the result of former calls of this function (or the\n    initialization function update the context for the next LEN bytes\n    starting at BUFFER.\n    It is NOT required that LEN is a multiple of 64.  */\n-extern void md5_process_bytes __P ((const void *buffer, size_t len,\n-\t\t\t\t    struct md5_ctx *ctx));\n+extern void md5_process_bytes (const void *buffer, size_t len,\n+                               struct md5_ctx *ctx);\n \n /* Process the remaining bytes in the buffer and put result from CTX\n    in first 16 bytes following RESBUF.  The result is always in little\n@@ -116,7 +109,7 @@ extern void md5_process_bytes __P ((const void *buffer, size_t len,\n \n    IMPORTANT: On some systems it is required that RESBUF is correctly\n    aligned for a 32 bits value.  */\n-extern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));\n+extern void *md5_finish_ctx (struct md5_ctx *ctx, void *resbuf);\n \n \n /* Put result from CTX in first 16 bytes following RESBUF.  The result is\n@@ -125,18 +118,18 @@ extern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));\n \n    IMPORTANT: On some systems it is required that RESBUF is correctly\n    aligned for a 32 bits value.  */\n-extern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));\n+extern void *md5_read_ctx (const struct md5_ctx *ctx, void *resbuf);\n \n \n /* Compute MD5 message digest for bytes read from STREAM.  The\n    resulting message digest number will be written into the 16 bytes\n    beginning at RESBLOCK.  */\n-extern int md5_stream __P ((FILE *stream, void *resblock));\n+extern int md5_stream (FILE *stream, void *resblock);\n \n /* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The\n    result is always in little endian byte order, so that a byte-wise\n    output yields to the wanted ASCII representation of the message\n    digest.  */\n-extern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));\n+extern void *md5_buffer (const char *buffer, size_t len, void *resblock);\n \n #endif"}, {"sha": "e6cfb1558587508619377b83cf07f45c89fd9112", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -1,3 +1,60 @@\n+2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert libiberty to use ISO C prototype style 4/n.\n+\t* hashtab.c (higher_prime_index, hash_pointer, eq_pointer, \n+\thtab_size, htab_elements, htab_mod_1, htab_mod, htab_mod_m2, \n+\thtab_create_alloc, htab_set_functions_ex, htab_create, \n+\thtab_try_create, htab_delete, htab_empty, \n+\tfind_empty_slot_for_expand, htab_expand, htab_find_with_hash, \n+\thtab_find, htab_find_slot_with_hash, htab_find_slot, \n+\thtab_remove_elt, htab_remove_elt_with_hash, htab_clear_slot, \n+\thtab_traverse_noresize, htab_traverse, htab_collisions, \n+\thtab_hash_string, iterative_hash): Use ISO C prototype.\n+\t* hex.c (hex_init): Likewise.\n+\t* index.c (index): Likewise.\n+\t* insque.c (insque, remque): Likewise. \n+\t* lbasename.c (lbasename): Likewise.\n+\t* lrealpath.c (lrealpath): Likewise.\n+\t* make-relative-prefix.c (save_string, split_directories, \n+\tfree_split_directories, make_relative_prefix): Likewise.\n+\t* make-temp-file.c (try, choose_tmpdir, make_temp_file): Likewise. \n+\t* md5.c (md5_init_ctx, md5_read_ctx, md5_finish_ctx, md5_stream, \n+\tmd5_buffer, md5_process_bytes, md5_process_block): Likewise.\n+\t* memchr.c (memchr): Likewise.\n+\t* memcpy.c (memcpy): Likewise.\n+\t* memmove.c (memmove): Likewise.\n+\t* gettimeofday.c (gettimeofday): Likewise.\n+\t* getruntime.c (get_run_time): Likewise.\n+\t* getpwd.c (getpwd, getpwd): Likewise.\n+\t* getpagesize.c (getpagesize): Likewise.\n+\t* getopt1.c (getopt_long, getopt_long_only, main): Likewise.\n+\t* getopt.c (my_index, exchange, _getopt_initialize, \n+\t_getopt_internal, getopt, main): Likewise.\n+\t* getcwd.c (getcwd): Likewise.\n+\t* fnmatch.c (fnmatch): Likewise.\n+\t* floatformat.c (floatformat_always_valid, \n+\tfloatformat_i387_ext_is_valid, get_field, floatformat_to_double, \n+\tput_field, floatformat_from_double, floatformat_is_valid, \n+\tieee_test, main): Likewise.\n+\t* fibheap.c (fibheap_new, fibnode_new, fibheap_compare, \n+\tfibheap_comp_data, fibheap_insert, fibheap_min, fibheap_min_key, \n+\tfibheap_union, fibheap_extract_min, fibheap_replace_key_data, \n+\tfibheap_replace_key, fibheap_replace_data, fibheap_delete_node, \n+\tfibheap_delete, fibheap_empty, fibheap_extr_min_node, \n+\tfibheap_ins_root, fibheap_rem_root, fibheap_consolidate, \n+\tfibheap_link, fibheap_cut, fibheap_cascading_cut, \n+\tfibnode_insert_after, fibnode_remove): Likewise.\n+\t* ffs.c (ffs): Likewise.\n+\t* fdmatch.c (fdmatch): Likewise.\n+\t* dyn-string.c (dyn_string_init, dyn_string_new, \n+\tdyn_string_delete, dyn_string_release, dyn_string_resize, \n+\tdyn_string_clear, dyn_string_copy, dyn_string_copy_cstr, \n+\tdyn_string_prepend, dyn_string_prepend_cstr, dyn_string_insert, \n+\tdyn_string_insert_cstr, dyn_string_insert_char, \n+\tdyn_string_append, dyn_string_append_cstr, \n+\tdyn_string_append_char, dyn_string_substring, dyn_string_eq):\n+\tLikewise. \n+\n 2005-03-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert libiberty to use ISO C prototype style 3/n."}, {"sha": "b6f5d4b0bf4c0e80c15e9eab2ffb172f15ba8a5c", "filename": "libiberty/dyn-string.c", "status": "modified", "additions": 19, "deletions": 55, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fdyn-string.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -56,9 +56,7 @@ Boston, MA 02111-1307, USA.  */\n    fails, returns 0.  Otherwise returns 1.  */\n \n int\n-dyn_string_init (ds_struct_ptr, space)\n-     struct dyn_string *ds_struct_ptr;\n-     int space;\n+dyn_string_init (struct dyn_string *ds_struct_ptr, int space)\n {\n   /* We need at least one byte in which to store the terminating NUL.  */\n   if (space == 0)\n@@ -85,8 +83,7 @@ dyn_string_init (ds_struct_ptr, space)\n    returns the newly allocated string.  */\n \n dyn_string_t \n-dyn_string_new (space)\n-     int space;\n+dyn_string_new (int space)\n {\n   dyn_string_t result;\n #ifdef RETURN_ON_ALLOCATION_FAILURE\n@@ -108,8 +105,7 @@ dyn_string_new (space)\n /* Free the memory used by DS.  */\n \n void \n-dyn_string_delete (ds)\n-     dyn_string_t ds;\n+dyn_string_delete (dyn_string_t ds)\n {\n   free (ds->s);\n   free (ds);\n@@ -120,8 +116,7 @@ dyn_string_delete (ds)\n    DS is then set to the empty string.  Deletes DS itself.  */\n \n char*\n-dyn_string_release (ds)\n-     dyn_string_t ds;\n+dyn_string_release (dyn_string_t ds)\n {\n   /* Store the old buffer.  */\n   char* result = ds->s;\n@@ -141,9 +136,7 @@ dyn_string_release (ds)\n    operation fails, deletes DS and returns NULL.  */\n \n dyn_string_t \n-dyn_string_resize (ds, space)\n-     dyn_string_t ds;\n-     int space;\n+dyn_string_resize (dyn_string_t ds, int space)\n {\n   int new_allocated = ds->allocated;\n \n@@ -176,8 +169,7 @@ dyn_string_resize (ds, space)\n /* Sets the contents of DS to the empty string.  */\n \n void\n-dyn_string_clear (ds)\n-     dyn_string_t ds;\n+dyn_string_clear (dyn_string_t ds)\n {\n   /* A dyn_string always has room for at least the NUL terminator.  */\n   ds->s[0] = '\\0';\n@@ -189,9 +181,7 @@ dyn_string_clear (ds)\n    RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n \n int\n-dyn_string_copy (dest, src)\n-     dyn_string_t dest;\n-     dyn_string_t src;\n+dyn_string_copy (dyn_string_t dest, dyn_string_t src)\n {\n   if (dest == src)\n     abort ();\n@@ -211,9 +201,7 @@ dyn_string_copy (dest, src)\n    and returns 0.  */\n \n int\n-dyn_string_copy_cstr (dest, src)\n-     dyn_string_t dest;\n-     const char *src;\n+dyn_string_copy_cstr (dyn_string_t dest, const char *src)\n {\n   int length = strlen (src);\n   /* Make room in DEST.  */\n@@ -232,9 +220,7 @@ dyn_string_copy_cstr (dest, src)\n    returns 0.  */\n \n int\n-dyn_string_prepend (dest, src)\n-     dyn_string_t dest;\n-     dyn_string_t src;\n+dyn_string_prepend (dyn_string_t dest, dyn_string_t src)\n {\n   return dyn_string_insert (dest, 0, src);\n }\n@@ -244,9 +230,7 @@ dyn_string_prepend (dest, src)\n    if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0. */\n \n int\n-dyn_string_prepend_cstr (dest, src)\n-     dyn_string_t dest;\n-     const char *src;\n+dyn_string_prepend_cstr (dyn_string_t dest, const char *src)\n {\n   return dyn_string_insert_cstr (dest, 0, src);\n }\n@@ -257,10 +241,7 @@ dyn_string_prepend_cstr (dest, src)\n    and returns 0.  */\n \n int\n-dyn_string_insert (dest, pos, src)\n-     dyn_string_t dest;\n-     int pos;\n-     dyn_string_t src;\n+dyn_string_insert (dyn_string_t dest, int pos, dyn_string_t src)\n {\n   int i;\n \n@@ -285,10 +266,7 @@ dyn_string_insert (dest, pos, src)\n    and returns 0.  */\n \n int\n-dyn_string_insert_cstr (dest, pos, src)\n-     dyn_string_t dest;\n-     int pos;\n-     const char *src;\n+dyn_string_insert_cstr (dyn_string_t dest, int pos, const char *src)\n {\n   int i;\n   int length = strlen (src);\n@@ -310,10 +288,7 @@ dyn_string_insert_cstr (dest, pos, src)\n    RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n \n int\n-dyn_string_insert_char (dest, pos, c)\n-     dyn_string_t dest;\n-     int pos;\n-     int c;\n+dyn_string_insert_char (dyn_string_t dest, int pos, int c)\n {\n   int i;\n \n@@ -334,9 +309,7 @@ dyn_string_insert_char (dest, pos, c)\n    returns 0.  */\n \n int\n-dyn_string_append (dest, s)\n-     dyn_string_t dest;\n-     dyn_string_t s;\n+dyn_string_append (dyn_string_t dest, dyn_string_t s)\n {\n   if (dyn_string_resize (dest, dest->length + s->length) == 0)\n     return 0;\n@@ -350,9 +323,7 @@ dyn_string_append (dest, s)\n    deletes DEST and returns 0.  */\n \n int\n-dyn_string_append_cstr (dest, s)\n-     dyn_string_t dest;\n-     const char *s;\n+dyn_string_append_cstr (dyn_string_t dest, const char *s)\n {\n   int len = strlen (s);\n \n@@ -369,9 +340,7 @@ dyn_string_append_cstr (dest, s)\n    if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n \n int\n-dyn_string_append_char (dest, c)\n-     dyn_string_t dest;\n-     int c;\n+dyn_string_append_char (dyn_string_t dest, int c)\n {\n   /* Make room for the extra character.  */\n   if (dyn_string_resize (dest, dest->length + 1) == NULL)\n@@ -392,11 +361,8 @@ dyn_string_append_char (dest, c)\n    deletes DEST and returns 0.  */\n \n int\n-dyn_string_substring (dest, src, start, end)\n-     dyn_string_t dest;\n-     dyn_string_t src;\n-     int start;\n-     int end;\n+dyn_string_substring (dyn_string_t dest, dyn_string_t src,\n+                      int start, int end)\n {\n   int i;\n   int length = end - start;\n@@ -421,9 +387,7 @@ dyn_string_substring (dest, src, start, end)\n /* Returns non-zero if DS1 and DS2 have the same contents.  */\n \n int\n-dyn_string_eq (ds1, ds2)\n-     dyn_string_t ds1;\n-     dyn_string_t ds2;\n+dyn_string_eq (dyn_string_t ds1, dyn_string_t ds2)\n {\n   /* If DS1 and DS2 have different lengths, they must not be the same.  */\n   if (ds1->length != ds2->length)"}, {"sha": "76ad36f1de8f158877486f712feb4b43f04dce15", "filename": "libiberty/fdmatch.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffdmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffdmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffdmatch.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -46,9 +46,7 @@ BUGS\n #include <sys/types.h>\n #include <sys/stat.h>\n \n-int fdmatch (fd1, fd2)\n-\tint fd1;\n-\tint fd2;\n+int fdmatch (int fd1, int fd2)\n {\n   struct stat sbuf1;\n   struct stat sbuf2;"}, {"sha": "603cbe8ed994536776e2031b7afa6ca521e54ecc", "filename": "libiberty/ffs.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fffs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fffs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fffs.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -11,8 +11,7 @@ value 1).  If @var{valu} is zero, zero is returned.\n */\n \n int\n-ffs (valu)\n-  register int valu;\n+ffs (register int valu)\n {\n   register int bit;\n "}, {"sha": "e1d818c28939f3a628dae5c689f6d8fe86a5ba69", "filename": "libiberty/fibheap.c", "status": "modified", "additions": 38, "deletions": 83, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffibheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffibheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffibheap.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -37,32 +37,31 @@ Boston, MA 02111-1307, USA.  */\n \n #define FIBHEAPKEY_MIN\tLONG_MIN\n \n-static void fibheap_ins_root PARAMS ((fibheap_t, fibnode_t));\n-static void fibheap_rem_root PARAMS ((fibheap_t, fibnode_t));\n-static void fibheap_consolidate PARAMS ((fibheap_t));\n-static void fibheap_link PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n-static void fibheap_cut PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n-static void fibheap_cascading_cut PARAMS ((fibheap_t, fibnode_t));\n-static fibnode_t fibheap_extr_min_node PARAMS ((fibheap_t));\n-static int fibheap_compare PARAMS ((fibheap_t, fibnode_t, fibnode_t));\n-static int fibheap_comp_data PARAMS ((fibheap_t, fibheapkey_t, void *,\n-\t\t\t\t      fibnode_t));\n-static fibnode_t fibnode_new PARAMS ((void));\n-static void fibnode_insert_after PARAMS ((fibnode_t, fibnode_t));\n+static void fibheap_ins_root (fibheap_t, fibnode_t);\n+static void fibheap_rem_root (fibheap_t, fibnode_t);\n+static void fibheap_consolidate (fibheap_t);\n+static void fibheap_link (fibheap_t, fibnode_t, fibnode_t);\n+static void fibheap_cut (fibheap_t, fibnode_t, fibnode_t);\n+static void fibheap_cascading_cut (fibheap_t, fibnode_t);\n+static fibnode_t fibheap_extr_min_node (fibheap_t);\n+static int fibheap_compare (fibheap_t, fibnode_t, fibnode_t);\n+static int fibheap_comp_data (fibheap_t, fibheapkey_t, void *, fibnode_t);\n+static fibnode_t fibnode_new (void);\n+static void fibnode_insert_after (fibnode_t, fibnode_t);\n #define fibnode_insert_before(a, b) fibnode_insert_after (a->left, b)\n-static fibnode_t fibnode_remove PARAMS ((fibnode_t));\n+static fibnode_t fibnode_remove (fibnode_t);\n \n \f\n /* Create a new fibonacci heap.  */\n fibheap_t\n-fibheap_new ()\n+fibheap_new (void)\n {\n   return (fibheap_t) xcalloc (1, sizeof (struct fibheap));\n }\n \n /* Create a new fibonacci heap node.  */\n static fibnode_t\n-fibnode_new ()\n+fibnode_new (void)\n {\n   fibnode_t node;\n \n@@ -74,10 +73,7 @@ fibnode_new ()\n }\n \n static inline int\n-fibheap_compare (heap, a, b)\n-     fibheap_t heap ATTRIBUTE_UNUSED;\n-     fibnode_t a;\n-     fibnode_t b;\n+fibheap_compare (fibheap_t heap ATTRIBUTE_UNUSED, fibnode_t a, fibnode_t b)\n {\n   if (a->key < b->key)\n     return -1;\n@@ -87,11 +83,7 @@ fibheap_compare (heap, a, b)\n }\n \n static inline int\n-fibheap_comp_data (heap, key, data, b)\n-     fibheap_t heap;\n-     fibheapkey_t key;\n-     void *data;\n-     fibnode_t b;\n+fibheap_comp_data (fibheap_t heap, fibheapkey_t key, void *data, fibnode_t b)\n {\n   struct fibnode a;\n \n@@ -103,10 +95,7 @@ fibheap_comp_data (heap, key, data, b)\n \n /* Insert DATA, with priority KEY, into HEAP.  */\n fibnode_t\n-fibheap_insert (heap, key, data)\n-     fibheap_t heap;\n-     fibheapkey_t key;\n-     void *data;\n+fibheap_insert (fibheap_t heap, fibheapkey_t key, void *data)\n {\n   fibnode_t node;\n \n@@ -132,8 +121,7 @@ fibheap_insert (heap, key, data)\n \n /* Return the data of the minimum node (if we know it).  */\n void *\n-fibheap_min (heap)\n-     fibheap_t heap;\n+fibheap_min (fibheap_t heap)\n {\n   /* If there is no min, we can't easily return it.  */\n   if (heap->min == NULL)\n@@ -143,8 +131,7 @@ fibheap_min (heap)\n \n /* Return the key of the minimum node (if we know it).  */\n fibheapkey_t\n-fibheap_min_key (heap)\n-     fibheap_t heap;\n+fibheap_min_key (fibheap_t heap)\n {\n   /* If there is no min, we can't easily return it.  */\n   if (heap->min == NULL)\n@@ -154,9 +141,7 @@ fibheap_min_key (heap)\n \n /* Union HEAPA and HEAPB into a new heap.  */\n fibheap_t\n-fibheap_union (heapa, heapb)\n-     fibheap_t heapa;\n-     fibheap_t heapb;\n+fibheap_union (fibheap_t heapa, fibheap_t heapb)\n {\n   fibnode_t a_root, b_root, temp;\n \n@@ -190,8 +175,7 @@ fibheap_union (heapa, heapb)\n \n /* Extract the data of the minimum node from HEAP.  */\n void *\n-fibheap_extract_min (heap)\n-     fibheap_t heap;\n+fibheap_extract_min (fibheap_t heap)\n {\n   fibnode_t z;\n   void *ret = NULL;\n@@ -211,11 +195,8 @@ fibheap_extract_min (heap)\n \n /* Replace both the KEY and the DATA associated with NODE.  */\n void *\n-fibheap_replace_key_data (heap, node, key, data)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     fibheapkey_t key;\n-     void *data;\n+fibheap_replace_key_data (fibheap_t heap, fibnode_t node,\n+                          fibheapkey_t key, void *data)\n {\n   void *odata;\n   fibheapkey_t okey;\n@@ -253,20 +234,14 @@ fibheap_replace_key_data (heap, node, key, data)\n \n /* Replace the DATA associated with NODE.  */\n void *\n-fibheap_replace_data (heap, node, data)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     void *data;\n+fibheap_replace_data (fibheap_t heap, fibnode_t node, void *data)\n {\n   return fibheap_replace_key_data (heap, node, node->key, data);\n }\n \n /* Replace the KEY associated with NODE.  */\n fibheapkey_t\n-fibheap_replace_key (heap, node, key)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     fibheapkey_t key;\n+fibheap_replace_key (fibheap_t heap, fibnode_t node, fibheapkey_t key)\n {\n   int okey = node->key;\n   fibheap_replace_key_data (heap, node, key, node->data);\n@@ -275,9 +250,7 @@ fibheap_replace_key (heap, node, key)\n \n /* Delete NODE from HEAP.  */\n void *\n-fibheap_delete_node (heap, node)\n-     fibheap_t heap;\n-     fibnode_t node;\n+fibheap_delete_node (fibheap_t heap, fibnode_t node)\n {\n   void *ret = node->data;\n \n@@ -290,8 +263,7 @@ fibheap_delete_node (heap, node)\n \n /* Delete HEAP.  */\n void\n-fibheap_delete (heap)\n-     fibheap_t heap;\n+fibheap_delete (fibheap_t heap)\n {\n   while (heap->min != NULL)\n     free (fibheap_extr_min_node (heap));\n@@ -301,16 +273,14 @@ fibheap_delete (heap)\n \n /* Determine if HEAP is empty.  */\n int\n-fibheap_empty (heap)\n-     fibheap_t heap;\n+fibheap_empty (fibheap_t heap)\n {\n   return heap->nodes == 0;\n }\n \n /* Extract the minimum node of the heap.  */\n static fibnode_t\n-fibheap_extr_min_node (heap)\n-     fibheap_t heap;\n+fibheap_extr_min_node (fibheap_t heap)\n {\n   fibnode_t ret = heap->min;\n   fibnode_t x, y, orig;\n@@ -346,9 +316,7 @@ fibheap_extr_min_node (heap)\n \n /* Insert NODE into the root list of HEAP.  */\n static void\n-fibheap_ins_root (heap, node)\n-     fibheap_t heap;\n-     fibnode_t node;\n+fibheap_ins_root (fibheap_t heap, fibnode_t node)\n {\n   /* If the heap is currently empty, the new node becomes the singleton\n      circular root list.  */\n@@ -367,9 +335,7 @@ fibheap_ins_root (heap, node)\n \n /* Remove NODE from the rootlist of HEAP.  */\n static void\n-fibheap_rem_root (heap, node)\n-     fibheap_t heap;\n-     fibnode_t node;\n+fibheap_rem_root (fibheap_t heap, fibnode_t node)\n {\n   if (node->left == node)\n     heap->root = NULL;\n@@ -379,8 +345,7 @@ fibheap_rem_root (heap, node)\n \n /* Consolidate the heap.  */\n static void\n-fibheap_consolidate (heap)\n-     fibheap_t heap;\n+fibheap_consolidate (fibheap_t heap)\n {\n   fibnode_t a[1 + 8 * sizeof (long)];\n   fibnode_t w;\n@@ -427,10 +392,8 @@ fibheap_consolidate (heap)\n \n /* Make NODE a child of PARENT.  */\n static void\n-fibheap_link (heap, node, parent)\n-     fibheap_t heap ATTRIBUTE_UNUSED;\n-     fibnode_t node;\n-     fibnode_t parent;\n+fibheap_link (fibheap_t heap ATTRIBUTE_UNUSED,\n+              fibnode_t node, fibnode_t parent)\n {\n   if (parent->child == NULL)\n     parent->child = node;\n@@ -443,10 +406,7 @@ fibheap_link (heap, node, parent)\n \n /* Remove NODE from PARENT's child list.  */\n static void\n-fibheap_cut (heap, node, parent)\n-     fibheap_t heap;\n-     fibnode_t node;\n-     fibnode_t parent;\n+fibheap_cut (fibheap_t heap, fibnode_t node, fibnode_t parent)\n {\n   fibnode_remove (node);\n   parent->degree--;\n@@ -456,9 +416,7 @@ fibheap_cut (heap, node, parent)\n }\n \n static void\n-fibheap_cascading_cut (heap, y)\n-     fibheap_t heap;\n-     fibnode_t y;\n+fibheap_cascading_cut (fibheap_t heap, fibnode_t y)\n {\n   fibnode_t z;\n \n@@ -478,9 +436,7 @@ fibheap_cascading_cut (heap, y)\n }\n \n static void\n-fibnode_insert_after (a, b)\n-     fibnode_t a;\n-     fibnode_t b;\n+fibnode_insert_after (fibnode_t a, fibnode_t b)\n {\n   if (a == a->right)\n     {\n@@ -499,8 +455,7 @@ fibnode_insert_after (a, b)\n }\n \n static fibnode_t\n-fibnode_remove (node)\n-     fibnode_t node;\n+fibnode_remove (fibnode_t node)\n {\n   fibnode_t ret;\n "}, {"sha": "c950b79f7e40e1fc6cc2c9a9346dfc13f67fa5c0", "filename": "libiberty/floatformat.c", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffloatformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffloatformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffloatformat.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -46,18 +46,17 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define NAN (0.0 / 0.0)\n #endif\n \n-static unsigned long get_field PARAMS ((const unsigned char *,\n-\t\t\t\t\tenum floatformat_byteorders,\n-\t\t\t\t\tunsigned int,\n-\t\t\t\t\tunsigned int,\n-\t\t\t\t\tunsigned int));\n-static int floatformat_always_valid PARAMS ((const struct floatformat *fmt,\n-\t\t\t\t\t     const char *from));\n+static unsigned long get_field (const unsigned char *,\n+                                enum floatformat_byteorders,\n+                                unsigned int,\n+                                unsigned int,\n+                                unsigned int);\n+static int floatformat_always_valid (const struct floatformat *fmt,\n+                                     const char *from);\n \n static int\n-floatformat_always_valid (fmt, from)\n-     const struct floatformat *fmt ATTRIBUTE_UNUSED;\n-     const char *from ATTRIBUTE_UNUSED;\n+floatformat_always_valid (const struct floatformat *fmt ATTRIBUTE_UNUSED,\n+                          const char *from ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -108,12 +107,10 @@ const struct floatformat floatformat_ieee_double_littlebyte_bigword =\n   floatformat_always_valid\n };\n \n-static int floatformat_i387_ext_is_valid PARAMS ((const struct floatformat *fmt, const char *from));\n+static int floatformat_i387_ext_is_valid (const struct floatformat *fmt, const char *from);\n \n static int\n-floatformat_i387_ext_is_valid (fmt, from)\n-     const struct floatformat *fmt;\n-     const char *from;\n+floatformat_i387_ext_is_valid (const struct floatformat *fmt, const char *from)\n {\n   /* In the i387 double-extended format, if the exponent is all ones,\n      then the integer bit must be set.  If the exponent is neither 0\n@@ -220,12 +217,8 @@ const struct floatformat floatformat_ia64_quad_little =\n /* Extract a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static unsigned long\n-get_field (data, order, total_len, start, len)\n-     const unsigned char *data;\n-     enum floatformat_byteorders order;\n-     unsigned int total_len;\n-     unsigned int start;\n-     unsigned int len;\n+get_field (const unsigned char *data, enum floatformat_byteorders order,\n+           unsigned int total_len, unsigned int start, unsigned int len)\n {\n   unsigned long result;\n   unsigned int cur_byte;\n@@ -273,10 +266,8 @@ get_field (data, order, total_len, start, len)\n    Store the double in *TO.  */\n \n void\n-floatformat_to_double (fmt, from, to)\n-     const struct floatformat *fmt;\n-     const char *from;\n-     double *to;\n+floatformat_to_double (const struct floatformat *fmt,\n+                       const char *from, double *to)\n {\n   const unsigned char *ufrom = (const unsigned char *)from;\n   double dto;\n@@ -381,22 +372,18 @@ floatformat_to_double (fmt, from, to)\n   *to = dto;\n }\n \f\n-static void put_field PARAMS ((unsigned char *, enum floatformat_byteorders,\n-\t\t\t       unsigned int,\n-\t\t\t       unsigned int,\n-\t\t\t       unsigned int,\n-\t\t\t       unsigned long));\n+static void put_field (unsigned char *, enum floatformat_byteorders,\n+                       unsigned int,\n+                       unsigned int,\n+                       unsigned int,\n+                       unsigned long);\n \n /* Set a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static void\n-put_field (data, order, total_len, start, len, stuff_to_put)\n-     unsigned char *data;\n-     enum floatformat_byteorders order;\n-     unsigned int total_len;\n-     unsigned int start;\n-     unsigned int len;\n-     unsigned long stuff_to_put;\n+put_field (unsigned char *data, enum floatformat_byteorders order,\n+           unsigned int total_len, unsigned int start, unsigned int len,\n+           unsigned long stuff_to_put)\n {\n   unsigned int cur_byte;\n   int cur_bitshift;\n@@ -443,10 +430,8 @@ put_field (data, order, total_len, start, len, stuff_to_put)\n    restrictions.  */\n \n void\n-floatformat_from_double (fmt, from, to)\n-     const struct floatformat *fmt;\n-     const double *from;\n-     char *to;\n+floatformat_from_double (const struct floatformat *fmt,\n+                         const double *from, char *to)\n {\n   double dfrom;\n   int exponent;\n@@ -541,9 +526,7 @@ floatformat_from_double (fmt, from, to)\n /* Return non-zero iff the data at FROM is a valid number in format FMT.  */\n \n int\n-floatformat_is_valid (fmt, from)\n-     const struct floatformat *fmt;\n-     const char *from;\n+floatformat_is_valid (const struct floatformat *fmt, const char *from)\n {\n   return fmt->is_valid (fmt, from);\n }\n@@ -556,8 +539,7 @@ floatformat_is_valid (fmt, from)\n /* This is to be run on a host which uses IEEE floating point.  */\n \n void\n-ieee_test (n)\n-     double n;\n+ieee_test (double n)\n {\n   double result;\n \n@@ -597,7 +579,7 @@ ieee_test (n)\n }\n \n int\n-main ()\n+main (void)\n {\n   ieee_test (0.0);\n   ieee_test (0.5);"}, {"sha": "7424f91a374f5d371477c177898b06f64909cf18", "filename": "libiberty/fnmatch.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffnmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Ffnmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffnmatch.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -65,10 +65,7 @@ extern int errno;\n /* Match STRING against the filename pattern PATTERN, returning zero if\n    it matches, nonzero if not.  */\n int\n-fnmatch (pattern, string, flags)\n-     const char *pattern;\n-     const char *string;\n-     int flags;\n+fnmatch (const char *pattern, const char *string, int flags)\n {\n   register const char *p = pattern, *n = string;\n   register unsigned char c;"}, {"sha": "28f26eb179ff37fae4965070aee983a414e2966a", "filename": "libiberty/getcwd.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetcwd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetcwd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetcwd.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -38,9 +38,7 @@ extern int errno;\n #endif\n \n char *\n-getcwd (buf, len)\n-  char *buf;\n-  size_t len;\n+getcwd (char *buf, size_t len)\n {\n   char ourbuf[MAXPATHLEN];\n   char *result;"}, {"sha": "785c7aad2fc56e395d6cf5b25fe69b129cb1de59", "filename": "libiberty/getopt.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetopt.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -217,9 +217,7 @@ extern char *getenv ();\n #endif\n \n static char *\n-my_index (str, chr)\n-     const char *str;\n-     int chr;\n+my_index (const char *str, int chr)\n {\n   while (*str)\n     {\n@@ -307,8 +305,7 @@ static void exchange (char **);\n #endif\n \n static void\n-exchange (argv)\n-     char **argv;\n+exchange (char **argv)\n {\n   int bottom = first_nonopt;\n   int middle = last_nonopt;\n@@ -392,10 +389,7 @@ exchange (argv)\n static const char *_getopt_initialize (int, char *const *, const char *);\n #endif\n static const char *\n-_getopt_initialize (argc, argv, optstring)\n-     int argc;\n-     char *const *argv;\n-     const char *optstring;\n+_getopt_initialize (int argc, char *const *argv, const char *optstring)\n {\n   /* Start processing options with ARGV-element 1 (since ARGV-element 0\n      is the program name); the sequence of previously skipped\n@@ -514,13 +508,9 @@ _getopt_initialize (argc, argv, optstring)\n    long-named options.  */\n \n int\n-_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n-     int argc;\n-     char *const *argv;\n-     const char *optstring;\n-     const struct option *longopts;\n-     int *longind;\n-     int long_only;\n+_getopt_internal (int argc, char *const *argv, const char *optstring,\n+                  const struct option *longopts,\n+                  int *longind, int long_only)\n {\n   optarg = NULL;\n \n@@ -970,10 +960,7 @@ _getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n }\n \n int\n-getopt (argc, argv, optstring)\n-     int argc;\n-     char *const *argv;\n-     const char *optstring;\n+getopt (int argc, char *const *argv, const char *optstring)\n {\n   return _getopt_internal (argc, argv, optstring,\n \t\t\t   (const struct option *) 0,\n@@ -989,9 +976,7 @@ getopt (argc, argv, optstring)\n    the above definition of `getopt'.  */\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int c;\n   int digit_optind = 0;"}, {"sha": "d423aef10eeb92997d1076c6aa82ff58044ec509", "filename": "libiberty/getopt1.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetopt1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetopt1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetopt1.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -66,12 +66,8 @@\n #endif\n \n int\n-getopt_long (argc, argv, options, long_options, opt_index)\n-     int argc;\n-     char *const *argv;\n-     const char *options;\n-     const struct option *long_options;\n-     int *opt_index;\n+getopt_long (int argc,  char *const *argv,  const char *options,\n+             const struct option *long_options, int *opt_index)\n {\n   return _getopt_internal (argc, argv, options, long_options, opt_index, 0);\n }\n@@ -82,12 +78,8 @@ getopt_long (argc, argv, options, long_options, opt_index)\n    instead.  */\n \n int\n-getopt_long_only (argc, argv, options, long_options, opt_index)\n-     int argc;\n-     char *const *argv;\n-     const char *options;\n-     const struct option *long_options;\n-     int *opt_index;\n+getopt_long_only (int argc, char *const *argv, const struct option *options,\n+                  const struct option *long_options, int *opt_index)\n {\n   return _getopt_internal (argc, argv, options, long_options, opt_index, 1);\n }\n@@ -100,9 +92,7 @@ getopt_long_only (argc, argv, options, long_options, opt_index)\n #include <stdio.h>\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int c;\n   int digit_optind = 0;"}, {"sha": "1c3a26304eae2344ba92f46966b2bb2b24116e7d", "filename": "libiberty/getpagesize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetpagesize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetpagesize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetpagesize.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -61,7 +61,7 @@ BUGS\n #endif /* GNU_OUR_PAGESIZE */\n \n int\n-getpagesize ()\n+getpagesize (void)\n {\n   return (GNU_OUR_PAGESIZE);\n }\n@@ -76,7 +76,7 @@ getpagesize ()\n #endif\n extern unsigned long lib$getsyi(const unsigned short *,...);\n \n-int getpagesize ()\n+int getpagesize (void)\n {\n   long pagsiz = 0L;\n   unsigned short itmcod = SYI$_PAGE_SIZE;"}, {"sha": "e57ef47e947d67fa46eda615d2ff356e2d75a48c", "filename": "libiberty/getpwd.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetpwd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetpwd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetpwd.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -67,7 +67,7 @@ extern char *getwd ();\n    yield 0 and set errno.  */\n \n char *\n-getpwd ()\n+getpwd (void)\n {\n   static char *pwd;\n   static int failure_errno;\n@@ -114,7 +114,7 @@ getpwd ()\n #endif\n \n char *\n-getpwd ()\n+getpwd (void)\n {\n   static char *pwd = 0;\n "}, {"sha": "c5aa018d2ccd5b10ff94b27be194b3294ec93ae1", "filename": "libiberty/getruntime.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgetruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgetruntime.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -90,7 +90,7 @@ process started.\n */\n \n long\n-get_run_time ()\n+get_run_time (void)\n {\n #if defined (HAVE_GETRUSAGE) && defined (HAVE_SYS_RESOURCE_H)\n   struct rusage rusage;"}, {"sha": "a7f7836d24eec905dd16c95c6d5131001eaa8119", "filename": "libiberty/gettimeofday.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgettimeofday.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fgettimeofday.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fgettimeofday.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -19,9 +19,7 @@ that @var{tz} be NULL.  Returns 0 on success, -1 on failure.\n */ \n \n int\n-gettimeofday (tp, tz)\n-     struct timeval *tp;\n-     void *tz;\n+gettimeofday (struct timeval *tp, void *tz)\n {\n   if (tz)\n     abort ();"}, {"sha": "d2b9c74815791e8386444fdc1b5ff8b826b29d29", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 44, "deletions": 104, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -73,14 +73,14 @@ Boston, MA 02111-1307, USA.  */\n \n #define DELETED_ENTRY  ((PTR) 1)\n \n-static unsigned int higher_prime_index PARAMS ((unsigned long));\n-static hashval_t htab_mod_1 PARAMS ((hashval_t, hashval_t, hashval_t, int));\n-static hashval_t htab_mod PARAMS ((hashval_t, htab_t));\n-static hashval_t htab_mod_m2 PARAMS ((hashval_t, htab_t));\n-static hashval_t hash_pointer PARAMS ((const void *));\n-static int eq_pointer PARAMS ((const void *, const void *));\n-static int htab_expand PARAMS ((htab_t));\n-static PTR *find_empty_slot_for_expand  PARAMS ((htab_t, hashval_t));\n+static unsigned int higher_prime_index (unsigned long);\n+static hashval_t htab_mod_1 (hashval_t, hashval_t, hashval_t, int);\n+static hashval_t htab_mod (hashval_t, htab_t);\n+static hashval_t htab_mod_m2 (hashval_t, htab_t);\n+static hashval_t hash_pointer (const void *);\n+static int eq_pointer (const void *, const void *);\n+static int htab_expand (htab_t);\n+static PTR *find_empty_slot_for_expand (htab_t, hashval_t);\n \n /* At some point, we could make these be NULL, and modify the\n    hash-table routines to handle NULL specially; that would avoid\n@@ -176,8 +176,7 @@ static struct prime_ent const prime_tab[] = {\n    nearest prime number which is greater than N, and near a power of two. */\n \n static unsigned int\n-higher_prime_index (n)\n-     unsigned long n;\n+higher_prime_index (unsigned long n)\n {\n   unsigned int low = 0;\n   unsigned int high = sizeof(prime_tab) / sizeof(prime_tab[0]);\n@@ -204,46 +203,39 @@ higher_prime_index (n)\n /* Returns a hash code for P.  */\n \n static hashval_t\n-hash_pointer (p)\n-     const PTR p;\n+hash_pointer (const PTR p)\n {\n   return (hashval_t) ((long)p >> 3);\n }\n \n /* Returns non-zero if P1 and P2 are equal.  */\n \n static int\n-eq_pointer (p1, p2)\n-     const PTR p1;\n-     const PTR p2;\n+eq_pointer (const PTR p1, const PTR p2)\n {\n   return p1 == p2;\n }\n \n /* Return the current size of given hash table. */\n \n inline size_t\n-htab_size (htab)\n-     htab_t htab;\n+htab_size (htab_t htab)\n {\n   return htab->size;\n }\n \n /* Return the current number of elements in given hash table. */\n \n inline size_t\n-htab_elements (htab)\n-     htab_t htab;\n+htab_elements (htab_t htab)\n {\n   return htab->n_elements - htab->n_deleted;\n }\n \n /* Return X % Y.  */\n \n static inline hashval_t\n-htab_mod_1 (x, y, inv, shift)\n-     hashval_t x, y, inv;\n-     int shift;\n+htab_mod_1 (hashval_t x, hashval_t y, hashval_t inv, int shift)\n {\n   /* The multiplicative inverses computed above are for 32-bit types, and\n      requires that we be able to compute a highpart multiply.  */\n@@ -271,9 +263,7 @@ htab_mod_1 (x, y, inv, shift)\n /* Compute the primary hash for HASH given HTAB's current size.  */\n \n static inline hashval_t\n-htab_mod (hash, htab)\n-     hashval_t hash;\n-     htab_t htab;\n+htab_mod (hashval_t hash, htab_t htab)\n {\n   const struct prime_ent *p = &prime_tab[htab->size_prime_index];\n   return htab_mod_1 (hash, p->prime, p->inv, p->shift);\n@@ -282,9 +272,7 @@ htab_mod (hash, htab)\n /* Compute the secondary hash for HASH given HTAB's current size.  */\n \n static inline hashval_t\n-htab_mod_m2 (hash, htab)\n-     hashval_t hash;\n-     htab_t htab;\n+htab_mod_m2 (hashval_t hash, htab_t htab)\n {\n   const struct prime_ent *p = &prime_tab[htab->size_prime_index];\n   return 1 + htab_mod_1 (hash, p->prime - 2, p->inv_m2, p->shift);\n@@ -296,13 +284,8 @@ htab_mod_m2 (hash, htab)\n    created hash table, or NULL if memory allocation fails.  */\n \n htab_t\n-htab_create_alloc (size, hash_f, eq_f, del_f, alloc_f, free_f)\n-     size_t size;\n-     htab_hash hash_f;\n-     htab_eq eq_f;\n-     htab_del del_f;\n-     htab_alloc alloc_f;\n-     htab_free free_f;\n+htab_create_alloc (size_t size, htab_hash hash_f, htab_eq eq_f,\n+                   htab_del del_f, htab_alloc alloc_f, htab_free free_f)\n {\n   htab_t result;\n   unsigned int size_prime_index;\n@@ -374,14 +357,9 @@ htab_create_alloc_ex (size, hash_f, eq_f, del_f, alloc_arg, alloc_f,\n /* Update the function pointers and allocation parameter in the htab_t.  */\n \n void\n-htab_set_functions_ex (htab, hash_f, eq_f, del_f, alloc_arg, alloc_f, free_f)\n-     htab_t htab;\n-     htab_hash hash_f;\n-     htab_eq eq_f;\n-     htab_del del_f;\n-     PTR alloc_arg;\n-     htab_alloc_with_arg alloc_f;\n-     htab_free_with_arg free_f;\n+htab_set_functions_ex (htab_t htab, htab_hash hash_f, htab_eq eq_f,\n+                       htab_del del_f, PTR alloc_arg,\n+                       htab_alloc_with_arg alloc_f, htab_free_with_arg free_f)\n {\n   htab->hash_f = hash_f;\n   htab->eq_f = eq_f;\n@@ -395,21 +373,13 @@ htab_set_functions_ex (htab, hash_f, eq_f, del_f, alloc_arg, alloc_f, free_f)\n \n #undef htab_create\n htab_t\n-htab_create (size, hash_f, eq_f, del_f)\n-     size_t size;\n-     htab_hash hash_f;\n-     htab_eq eq_f;\n-     htab_del del_f;\n+htab_create (size_t size, htab_hash hash_f, htab_eq eq_f, htab_del del_f)\n {\n   return htab_create_alloc (size, hash_f, eq_f, del_f, xcalloc, free);\n }\n \n htab_t\n-htab_try_create (size, hash_f, eq_f, del_f)\n-     size_t size;\n-     htab_hash hash_f;\n-     htab_eq eq_f;\n-     htab_del del_f;\n+htab_try_create (size_t size, htab_hash hash_f, htab_eq eq_f, htab_del del_f)\n {\n   return htab_create_alloc (size, hash_f, eq_f, del_f, calloc, free);\n }\n@@ -418,8 +388,7 @@ htab_try_create (size, hash_f, eq_f, del_f)\n    Naturally the hash table must already exist. */\n \n void\n-htab_delete (htab)\n-     htab_t htab;\n+htab_delete (htab_t htab)\n {\n   size_t size = htab_size (htab);\n   PTR *entries = htab->entries;\n@@ -445,8 +414,7 @@ htab_delete (htab)\n /* This function clears all entries in the given hash table.  */\n \n void\n-htab_empty (htab)\n-     htab_t htab;\n+htab_empty (htab_t htab)\n {\n   size_t size = htab_size (htab);\n   PTR *entries = htab->entries;\n@@ -468,9 +436,7 @@ htab_empty (htab)\n    HASH is the hash value for the element to be inserted.  */\n \n static PTR *\n-find_empty_slot_for_expand (htab, hash)\n-     htab_t htab;\n-     hashval_t hash;\n+find_empty_slot_for_expand (htab_t htab, hashval_t hash)\n {\n   hashval_t index = htab_mod (hash, htab);\n   size_t size = htab_size (htab);\n@@ -506,8 +472,7 @@ find_empty_slot_for_expand (htab, hash)\n    expanded.  If all goes well, it will return a non-zero value.  */\n \n static int\n-htab_expand (htab)\n-     htab_t htab;\n+htab_expand (htab_t htab)\n {\n   PTR *oentries;\n   PTR *olimit;\n@@ -575,10 +540,7 @@ htab_expand (htab)\n    element.  It cannot be used to insert or delete an element.  */\n \n PTR\n-htab_find_with_hash (htab, element, hash)\n-     htab_t htab;\n-     const PTR element;\n-     hashval_t hash;\n+htab_find_with_hash (htab_t htab, const PTR element, hashval_t hash)\n {\n   hashval_t index, hash2;\n   size_t size;\n@@ -612,9 +574,7 @@ htab_find_with_hash (htab, element, hash)\n    element.  */\n \n PTR\n-htab_find (htab, element)\n-     htab_t htab;\n-     const PTR element;\n+htab_find (htab_t htab, const PTR element)\n {\n   return htab_find_with_hash (htab, element, (*htab->hash_f) (element));\n }\n@@ -628,11 +588,8 @@ htab_find (htab, element)\n    allocation fails.  */\n \n PTR *\n-htab_find_slot_with_hash (htab, element, hash, insert)\n-     htab_t htab;\n-     const PTR element;\n-     hashval_t hash;\n-     enum insert_option insert;\n+htab_find_slot_with_hash (htab_t htab, const PTR element,\n+                          hashval_t hash, enum insert_option insert)\n {\n   PTR *first_deleted_slot;\n   hashval_t index, hash2;\n@@ -699,10 +656,7 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n    element.  */\n \n PTR *\n-htab_find_slot (htab, element, insert)\n-     htab_t htab;\n-     const PTR element;\n-     enum insert_option insert;\n+htab_find_slot (htab_t htab, const PTR element, enum insert_option insert)\n {\n   return htab_find_slot_with_hash (htab, element, (*htab->hash_f) (element),\n \t\t\t\t   insert);\n@@ -713,9 +667,7 @@ htab_find_slot (htab, element, insert)\n    element in the hash table, this function does nothing.  */\n \n void\n-htab_remove_elt (htab, element)\n-     htab_t htab;\n-     PTR element;\n+htab_remove_elt (htab_t htab, PTR element)\n {\n   htab_remove_elt_with_hash (htab, element, (*htab->hash_f) (element));\n }\n@@ -726,10 +678,7 @@ htab_remove_elt (htab, element)\n    function does nothing.  */\n \n void\n-htab_remove_elt_with_hash (htab, element, hash)\n-     htab_t htab;\n-     PTR element;\n-     hashval_t hash;\n+htab_remove_elt_with_hash (htab_t htab, PTR element, hashval_t hash)\n {\n   PTR *slot;\n \n@@ -749,9 +698,7 @@ htab_remove_elt_with_hash (htab, element, hash)\n    again.  */\n \n void\n-htab_clear_slot (htab, slot)\n-     htab_t htab;\n-     PTR *slot;\n+htab_clear_slot (htab_t htab, PTR *slot)\n {\n   if (slot < htab->entries || slot >= htab->entries + htab_size (htab)\n       || *slot == EMPTY_ENTRY || *slot == DELETED_ENTRY)\n@@ -770,10 +717,7 @@ htab_clear_slot (htab, slot)\n    argument.  */\n \n void\n-htab_traverse_noresize (htab, callback, info)\n-     htab_t htab;\n-     htab_trav callback;\n-     PTR info;\n+htab_traverse_noresize (htab_t htab, htab_trav callback, PTR info)\n {\n   PTR *slot;\n   PTR *limit;\n@@ -796,10 +740,7 @@ htab_traverse_noresize (htab, callback, info)\n    too empty to improve effectivity of subsequent calls.  */\n \n void\n-htab_traverse (htab, callback, info)\n-     htab_t htab;\n-     htab_trav callback;\n-     PTR info;\n+htab_traverse (htab_t htab, htab_trav callback, PTR info)\n {\n   if (htab_elements (htab) * 8 < htab_size (htab))\n     htab_expand (htab);\n@@ -811,8 +752,7 @@ htab_traverse (htab, callback, info)\n    hash table. */\n \n double\n-htab_collisions (htab)\n-     htab_t htab;\n+htab_collisions (htab_t htab)\n {\n   if (htab->searches == 0)\n     return 0.0;\n@@ -846,8 +786,7 @@ htab_collisions (htab)\n    function they just started using for Perl's hashes.  */\n \n hashval_t\n-htab_hash_string (p)\n-     const PTR p;\n+htab_hash_string (const PTR p)\n {\n   const unsigned char *str = (const unsigned char *) p;\n   hashval_t r = 0;\n@@ -936,10 +875,11 @@ acceptable.  Do NOT use for cryptographic purposes.\n --------------------------------------------------------------------\n */\n \n-hashval_t iterative_hash (k_in, length, initval)\n-     const PTR k_in;               /* the key */\n-     register size_t  length;      /* the length of the key */\n-     register hashval_t  initval;  /* the previous hash, or an arbitrary value */\n+hashval_t\n+iterative_hash (const PTR k_in /* the key */,\n+                register size_t  length /* the length of the key */,\n+                register hashval_t initval /* the previous hash, or\n+                                              an arbitrary value */)\n {\n   register const unsigned char *k = (const unsigned char *)k_in;\n   register hashval_t a,b,c,len;"}, {"sha": "9e4e306a7d48288827037287bf6cff114882ba3c", "filename": "libiberty/hex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fhex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fhex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhex.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -153,7 +153,7 @@ unsigned char _hex_value[_hex_array_size];\n #endif /* not ASCII */\n \n void\n-hex_init ()\n+hex_init (void)\n {\n #ifndef HEX_TABLE_INITIALIZED\n   int i;"}, {"sha": "c37edca024ea735aa0e0d6808319cc6c37cd424e", "filename": "libiberty/index.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Findex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Findex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Findex.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -12,12 +12,10 @@ deprecated in new programs in favor of @code{strchr}.\n \n */\n \n-extern char * strchr();\n+extern char * strchr(const char *, int);\n \n char *\n-index (s, c)\n-  char *s;\n-  int c;\n+index (char *s, int c)\n {\n   return strchr (s, c);\n }"}, {"sha": "3473bb92b31f91f6c55e5e8c1c23308f7b62e322", "filename": "libiberty/insque.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Finsque.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Finsque.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Finsque.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -33,9 +33,7 @@ struct qelem {\n \n \n void\n-insque (elem, pred)\n-  struct qelem *elem;\n-  struct qelem *pred;\n+insque (struct qelem *elem, struct qelem *pred)\n {\n   elem -> q_forw = pred -> q_forw;\n   pred -> q_forw -> q_back = elem;\n@@ -45,8 +43,7 @@ insque (elem, pred)\n \n \n void\n-remque (elem)\n-  struct qelem *elem;\n+remque (struct qelem *elem)\n {\n   elem -> q_forw -> q_back = elem -> q_back;\n   elem -> q_back -> q_forw = elem -> q_forw;"}, {"sha": "4afe890013efc67f419ded9c1e9322b7ab4de2bd", "filename": "libiberty/lbasename.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Flbasename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Flbasename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Flbasename.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -43,8 +43,7 @@ and a path ending in @code{/} returns the empty string after it.\n #include \"filenames.h\"\n \n const char *\n-lbasename (name)\n-     const char *name;\n+lbasename (const char *name)\n {\n   const char *base;\n "}, {"sha": "24795fa99e7a8ced8b3ede4198f6625b66227609", "filename": "libiberty/lrealpath.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Flrealpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Flrealpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Flrealpath.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -73,8 +73,7 @@ extern char *canonicalize_file_name (const char *);\n #endif\n \n char *\n-lrealpath (filename)\n-     const char *filename;\n+lrealpath (const char *filename)\n {\n   /* Method 1: The system has a compile time upper bound on a filename\n      path.  Use that and realpath() to canonicalize the name.  This is"}, {"sha": "3d40c5f22206dfa7ac2af5246c3e7f26b785056f", "filename": "libiberty/make-relative-prefix.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmake-relative-prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmake-relative-prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-relative-prefix.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -95,14 +95,12 @@ relative prefix can be found, return @code{NULL}.\n \n #define DIR_UP \"..\"\n \n-static char *save_string PARAMS ((const char *, int));\n-static char **split_directories\tPARAMS ((const char *, int *));\n-static void free_split_directories PARAMS ((char **));\n+static char *save_string (const char *, int);\n+static char **split_directories\t(const char *, int *);\n+static void free_split_directories (char **);\n \n static char *\n-save_string (s, len)\n-     const char *s;\n-     int len;\n+save_string (const char *s, int len)\n {\n   char *result = malloc (len + 1);\n \n@@ -114,9 +112,7 @@ save_string (s, len)\n /* Split a filename into component directories.  */\n \n static char **\n-split_directories (name, ptr_num_dirs)\n-     const char *name;\n-     int *ptr_num_dirs;\n+split_directories (const char *name, int *ptr_num_dirs)\n {\n   int num_dirs = 0;\n   char **dirs;\n@@ -201,8 +197,7 @@ split_directories (name, ptr_num_dirs)\n /* Release storage held by split directories.  */\n \n static void\n-free_split_directories (dirs)\n-     char **dirs;\n+free_split_directories (char **dirs)\n {\n   int i = 0;\n \n@@ -223,10 +218,8 @@ free_split_directories (dirs)\n    If no relative prefix can be found, return NULL.  */\n \n char *\n-make_relative_prefix (progname, bin_prefix, prefix)\n-     const char *progname;\n-     const char *bin_prefix;\n-     const char *prefix;\n+make_relative_prefix (const char *progname,\n+                      const char *bin_prefix, const char *prefix)\n {\n   char **prog_dirs, **bin_dirs, **prefix_dirs;\n   int prog_num, bin_num, prefix_num;"}, {"sha": "71fb7037f4628595d0cde8dc35300b9f36da4598", "filename": "libiberty/make-temp-file.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmake-temp-file.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmake-temp-file.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-temp-file.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -43,7 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #include \"libiberty.h\"\n-extern int mkstemps PARAMS ((char *, int));\n+extern int mkstemps (char *, int);\n \n /* '/' works just fine on MS-DOS based systems.  */\n #ifndef DIR_SEPARATOR\n@@ -61,11 +61,10 @@ extern int mkstemps PARAMS ((char *, int));\n    If success, DIR is returned.\n    Otherwise NULL is returned.  */\n \n-static inline const char *try PARAMS ((const char *, const char *));\n+static inline const char *try (const char *, const char *);\n \n static inline const char *\n-try (dir, base)\n-     const char *dir, *base;\n+try (const char *dir, const char *base)\n {\n   if (base != 0)\n     return base;\n@@ -95,7 +94,7 @@ files in.\n */\n \n char *\n-choose_tmpdir ()\n+choose_tmpdir (void)\n {\n   const char *base = 0;\n   char *tmpdir;\n@@ -146,8 +145,7 @@ string is @code{malloc}ed, and the temporary file has been created.\n */\n \n char *\n-make_temp_file (suffix)\n-     const char *suffix;\n+make_temp_file (const char *suffix)\n {\n   const char *base = choose_tmpdir ();\n   char *temp_filename;"}, {"sha": "4468c7742c10e80cc2da6315074a5cddedc92694", "filename": "libiberty/md5.c", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmd5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmd5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmd5.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -62,8 +62,7 @@ static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };\n /* Initialize structure containing state of computation.\n    (RFC 1321, 3.3: Step 3)  */\n void\n-md5_init_ctx (ctx)\n-     struct md5_ctx *ctx;\n+md5_init_ctx (struct md5_ctx *ctx)\n {\n   ctx->A = (md5_uint32) 0x67452301;\n   ctx->B = (md5_uint32) 0xefcdab89;\n@@ -80,9 +79,7 @@ md5_init_ctx (ctx)\n    IMPORTANT: On some systems it is required that RESBUF is correctly\n    aligned for a 32 bits value.  */\n void *\n-md5_read_ctx (ctx, resbuf)\n-     const struct md5_ctx *ctx;\n-     void *resbuf;\n+md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n {\n   ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);\n   ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);\n@@ -98,9 +95,7 @@ md5_read_ctx (ctx, resbuf)\n    IMPORTANT: On some systems it is required that RESBUF is correctly\n    aligned for a 32 bits value.  */\n void *\n-md5_finish_ctx (ctx, resbuf)\n-     struct md5_ctx *ctx;\n-     void *resbuf;\n+md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n {\n   /* Take yet unprocessed bytes into account.  */\n   md5_uint32 bytes = ctx->buflen;\n@@ -129,9 +124,7 @@ md5_finish_ctx (ctx, resbuf)\n    resulting message digest number will be written into the 16 bytes\n    beginning at RESBLOCK.  */\n int\n-md5_stream (stream, resblock)\n-     FILE *stream;\n-     void *resblock;\n+md5_stream (FILE *stream, void *resblock)\n {\n   /* Important: BLOCKSIZE must be a multiple of 64.  */\n #define BLOCKSIZE 4096\n@@ -186,10 +179,7 @@ md5_stream (stream, resblock)\n    output yields to the wanted ASCII representation of the message\n    digest.  */\n void *\n-md5_buffer (buffer, len, resblock)\n-     const char *buffer;\n-     size_t len;\n-     void *resblock;\n+md5_buffer (const char *buffer, size_t len, void *resblock)\n {\n   struct md5_ctx ctx;\n \n@@ -205,10 +195,7 @@ md5_buffer (buffer, len, resblock)\n \n \n void\n-md5_process_bytes (buffer, len, ctx)\n-     const void *buffer;\n-     size_t len;\n-     struct md5_ctx *ctx;\n+md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n {\n   /* When we already have some bits in our internal buffer concatenate\n      both inputs first.  */\n@@ -263,10 +250,7 @@ md5_process_bytes (buffer, len, ctx)\n    It is assumed that LEN % 64 == 0.  */\n \n void\n-md5_process_block (buffer, len, ctx)\n-     const void *buffer;\n-     size_t len;\n-     struct md5_ctx *ctx;\n+md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n {\n   md5_uint32 correct_words[16];\n   const md5_uint32 *words = (const md5_uint32 *) buffer;"}, {"sha": "451f817d3203fdfe420d2caee873619ede70bea7", "filename": "libiberty/memchr.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemchr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemchr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemchr.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -15,17 +15,10 @@ returned.\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n PTR\n-memchr (src_void, c, length)\n-     register const PTR src_void;\n-     int c;\n-     size_t length;\n+memchr (register const PTR src_void, int c, size_t length)\n {\n   const unsigned char *src = (const unsigned char *)src_void;\n   "}, {"sha": "39edfca98a6dad4e5fe3a0ea83598442510c6e9b", "filename": "libiberty/memcmp.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemcmp.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -16,17 +16,10 @@ as if comparing unsigned char arrays.\n */\n \n #include <ansidecl.h>\n-#ifdef ANSI_PROTOTYPES\n #include <stddef.h>\n-#else\n-#define size_t unsigned long\n-#endif\n \n int\n-memcmp (str1, str2, count)\n-     const PTR str1;\n-     const PTR str2;\n-     size_t count;\n+memcmp (const PTR str1, const PTR str2, size_t count)\n {\n   register const unsigned char *s1 = (const unsigned char*)str1;\n   register const unsigned char *s2 = (const unsigned char*)str2;"}, {"sha": "8a97b85b06a517c3338338d602a132c6e6930dfb", "filename": "libiberty/memcpy.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemcpy.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -19,13 +19,10 @@ Copies @var{length} bytes from memory region @var{in} to region\n #define size_t unsigned long\n #endif\n \n-void bcopy PARAMS((const void*, void*, size_t));\n+void bcopy (const void*, void*, size_t);\n \n PTR\n-memcpy (out, in, length)\n-     PTR out;\n-     const PTR in;\n-     size_t length;\n+memcpy (PTR out, const PTR in, size_t length)\n {\n     bcopy(in, out, length);\n     return out;"}, {"sha": "30801f2d1c44db8c54bc45d6d2fdf37fad2b63e6", "filename": "libiberty/memmove.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da879de228e86b6a571e93f311462259f246f91/libiberty%2Fmemmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmemmove.c?ref=6da879de228e86b6a571e93f311462259f246f91", "patch": "@@ -19,13 +19,10 @@ Copies @var{count} bytes from memory area @var{from} to memory area\n #define size_t unsigned long\n #endif\n \n-void bcopy PARAMS ((const void*, void*, size_t));\n+void bcopy (const void*, void*, size_t);\n \n PTR\n-memmove (s1, s2, n)\n-     PTR s1;\n-     const PTR s2;\n-     size_t n;\n+memmove (PTR s1, const PTR s2, size_t n)\n {\n   bcopy (s2, s1, n);\n   return s1;"}]}