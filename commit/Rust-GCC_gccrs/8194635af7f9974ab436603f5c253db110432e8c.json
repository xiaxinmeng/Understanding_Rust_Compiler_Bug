{"sha": "8194635af7f9974ab436603f5c253db110432e8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5NDYzNWFmN2Y5OTc0YWI0MzY2MDNmNWMyNTNkYjExMDQzMmU4Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-01-04T19:22:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-01-04T19:22:44Z"}, "message": "re PR tree-optimization/67955 (tree-dse does not use pointer info)\n\n\tPR tree-optimizatin/67955\n\t* tree-ssa-alias.c (same_addr_size_stores_p): Check offsets first.\n\tAllow any SSA_VAR_P as the base objects.  Use integer_zerop.  Verify\n\tthe points-to solution does not include pt_null.  Use DECL_PT_UID\n\tunconditionally.\n\n\tPR tree-optimization/67955\n\t* gcc.dg/tree-ssa/ssa-dse-28.c: New test.\n\nFrom-SVN: r244067", "tree": {"sha": "c37c49ade4a80b43b518dcb118ddd3258e2f5b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c37c49ade4a80b43b518dcb118ddd3258e2f5b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8194635af7f9974ab436603f5c253db110432e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8194635af7f9974ab436603f5c253db110432e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8194635af7f9974ab436603f5c253db110432e8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8194635af7f9974ab436603f5c253db110432e8c/comments", "author": null, "committer": null, "parents": [{"sha": "baf9ebc8cc9c34becea5be1146c48e2cb99d2ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baf9ebc8cc9c34becea5be1146c48e2cb99d2ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baf9ebc8cc9c34becea5be1146c48e2cb99d2ea5"}], "stats": {"total": 58, "additions": 47, "deletions": 11}, "files": [{"sha": "3a7ad9d5ffdf0036c8fd93ed2b38e6d9655c74ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194635af7f9974ab436603f5c253db110432e8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194635af7f9974ab436603f5c253db110432e8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8194635af7f9974ab436603f5c253db110432e8c", "patch": "@@ -1,3 +1,11 @@\n+2017-01-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimizatin/67955\n+\t* tree-ssa-alias.c (same_addr_size_stores_p): Check offsets first.\n+\tAllow any SSA_VAR_P as the base objects.  Use integer_zerop.  Verify\n+\tthe points-to solution does not include pt_null.  Use DECL_PT_UID\n+\tunconditionally.\n+\n 2017-01-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (HI/SImode test with imm to QImode splitters):"}, {"sha": "0cbc8ccda8d63cbe66e843d77ad6b813bdfeec2c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8194635af7f9974ab436603f5c253db110432e8c", "patch": "@@ -1,3 +1,8 @@\n+2017-01-03  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/67955\n+\t* gcc.dg/tree-ssa/ssa-dse-28.c: New test.\n+\n 2017-01-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/77545"}, {"sha": "d35377ba96b7360935ea8136abeee46a807acb96", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-28.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-28.c?ref=8194635af7f9974ab436603f5c253db110432e8c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse-details -fexceptions -fnon-call-exceptions -fno-isolate-erroneous-paths-dereference\" } */\n+\n+\n+int foo (int *p, int b)\n+{\n+  int *q;\n+  int i = 1;\n+  if (b)\n+    q = &i;\n+  else\n+    q = (void *)0;\n+  *q = 2;\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Deleted dead store\" \"dse1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Deleted dead store\" \"dse2\"} } */\n+/* { dg-final { scan-tree-dump-not \"Deleted dead store\" \"dse3\"} } */\n+"}, {"sha": "871fa121fd07734dbca4ae31a48a26dfa7716a98", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8194635af7f9974ab436603f5c253db110432e8c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8194635af7f9974ab436603f5c253db110432e8c", "patch": "@@ -2326,9 +2326,13 @@ same_addr_size_stores_p (tree base1, HOST_WIDE_INT offset1, HOST_WIDE_INT size1,\n \t\t\t tree base2, HOST_WIDE_INT offset2, HOST_WIDE_INT size2,\n \t\t\t HOST_WIDE_INT max_size2)\n {\n-  /* For now, just handle VAR_DECL.  */\n-  bool base1_obj_p = VAR_P (base1);\n-  bool base2_obj_p = VAR_P (base2);\n+  /* Offsets need to be 0.  */\n+  if (offset1 != 0\n+      || offset2 != 0)\n+    return false;\n+\n+  bool base1_obj_p = SSA_VAR_P (base1);\n+  bool base2_obj_p = SSA_VAR_P (base2);\n \n   /* We need one object.  */\n   if (base1_obj_p == base2_obj_p)\n@@ -2356,13 +2360,9 @@ same_addr_size_stores_p (tree base1, HOST_WIDE_INT offset1, HOST_WIDE_INT size1,\n   if (size1 != size2)\n     return false;\n \n-  /* Offsets need to be 0.  */\n-  if (offset1 != 0\n-      || offset2 != 0)\n-    return false;\n \n   /* Check that memref is a store to pointer with singleton points-to info.  */\n-  if (!tree_int_cst_equal (TREE_OPERAND (memref, 1), integer_zero_node))\n+  if (!integer_zerop (TREE_OPERAND (memref, 1)))\n     return false;\n   tree ptr = TREE_OPERAND (memref, 0);\n   if (TREE_CODE (ptr) != SSA_NAME)\n@@ -2373,10 +2373,13 @@ same_addr_size_stores_p (tree base1, HOST_WIDE_INT offset1, HOST_WIDE_INT size1,\n       || !pt_solution_singleton_or_null_p (&pi->pt, &pt_uid))\n     return false;\n \n+  /* If the solution has a singleton and NULL, then we can not\n+     be sure that the two stores hit the same address.  */\n+  if (pi->pt.null)\n+    return false;\n+\n   /* Check that ptr points relative to obj.  */\n-  unsigned int obj_uid = (DECL_PT_UID_SET_P (obj)\n-\t\t\t  ? DECL_PT_UID (obj)\n-\t\t\t  : DECL_UID (obj));\n+  unsigned int obj_uid = DECL_PT_UID (obj);\n   if (obj_uid != pt_uid)\n     return false;\n "}]}