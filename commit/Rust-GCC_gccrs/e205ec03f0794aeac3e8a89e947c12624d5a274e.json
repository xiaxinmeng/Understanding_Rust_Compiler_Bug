{"sha": "e205ec03f0794aeac3e8a89e947c12624d5a274e", "node_id": "C_kwDOANBUbNoAKGUyMDVlYzAzZjA3OTRhZWFjM2U4YTg5ZTk0N2MxMjYyNGQ1YTI3NGU", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-15T11:25:07Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-12-15T11:26:06Z"}, "message": "libgfortran's ISO_Fortran_binding.c: Use GCC11 version for backward-only code [PR108056]\n\nSince GCC 12, the conversion between the array descriptors formats - the\ninternal (GFC) and the C binding one (CFI) - moved to the compiler itself\nsuch that the cfi_desc_to_gfc_desc/gfc_desc_to_cfi_desc functions are only\nused with older code (GCC 9 to 11).  The newly added checks caused asserts\nas older code did not pass the proper values (e.g. real(4) as effective\nargument arrived as BT_ASSUME type as the effective type got lost inbetween).\n\nAs proposed in the PR, revert to the GCC 11 version - known bugs is better\nthan some fixes and new issues. Still, GCC 12 is much better in terms of\nTS29113 support and should really be used.\n\nThis patch uses the current libgomp version of the GCC 11 branch, except\nit fixes the GFC version number (which is 0), uses calloc instead of malloc,\nand sets the lower bound to 1 instead of keeping it as is for\nCFI_attribute_other.\n\nlibgfortran/ChangeLog:\n\n\tPR libfortran/108056\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc,\n\tgfc_desc_to_cfi_desc): Mostly revert to GCC 11 version for\n\tthose backward-compatiblity-only functions.", "tree": {"sha": "e211bec5bf44428c64577937c4b46c032debace6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e211bec5bf44428c64577937c4b46c032debace6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e205ec03f0794aeac3e8a89e947c12624d5a274e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e205ec03f0794aeac3e8a89e947c12624d5a274e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e205ec03f0794aeac3e8a89e947c12624d5a274e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e205ec03f0794aeac3e8a89e947c12624d5a274e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c263c3eba8953c341cd8ac2d0a5f2b8f38623016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c263c3eba8953c341cd8ac2d0a5f2b8f38623016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c263c3eba8953c341cd8ac2d0a5f2b8f38623016"}], "stats": {"total": 193, "additions": 64, "deletions": 129}, "files": [{"sha": "e63a717a69b7626f7c3cf18fa77a917a7b8458bb", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 22, "deletions": 129, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e205ec03f0794aeac3e8a89e947c12624d5a274e/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e205ec03f0794aeac3e8a89e947c12624d5a274e/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=e205ec03f0794aeac3e8a89e947c12624d5a274e", "patch": "@@ -39,60 +39,31 @@ export_proto(cfi_desc_to_gfc_desc);\n void\n cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n {\n-  signed char type;\n-  size_t size;\n   int n;\n+  index_type kind;\n   CFI_cdesc_t *s = *s_ptr;\n \n   if (!s)\n     return;\n \n-  /* Verify descriptor.  */\n-  switch (s->attribute)\n-    {\n-    case CFI_attribute_pointer:\n-    case CFI_attribute_allocatable:\n-      break;\n-    case CFI_attribute_other:\n-      if (s->base_addr)\n-\tbreak;\n-      runtime_error (\"Nonallocatable, nonpointer actual argument to BIND(C) \"\n-\t\t     \"dummy argument where the effective argument is either \"\n-\t\t     \"not allocated or not associated\");\n-      break;\n-    default:\n-      runtime_error (\"Invalid attribute type %d in CFI_cdesc_t descriptor\",\n-\t\t     (int) s->attribute);\n-      break;\n-    }\n   GFC_DESCRIPTOR_DATA (d) = s->base_addr;\n+  GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);\n+  kind = (index_type)((s->type - (s->type & CFI_type_mask)) >> CFI_type_kind_shift);\n \n   /* Correct the unfortunate difference in order with types.  */\n-  type = (signed char)(s->type & CFI_type_mask);\n-  switch (type)\n-    {\n-    case CFI_type_Character:\n-      type = BT_CHARACTER;\n-      break;\n-    case CFI_type_struct:\n-      type = BT_DERIVED;\n-      break;\n-    case CFI_type_cptr:\n-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n-\t CFI_type_cptr and CFI_type_cfunptr.  */\n-      type = BT_VOID;\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  GFC_DESCRIPTOR_TYPE (d) = type;\n-  GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+  if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)\n+    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n+  else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)\n+    GFC_DESCRIPTOR_TYPE (d) = BT_CHARACTER;\n+\n+  if (!s->rank || s->dim[0].sm == (CFI_index_t)s->elem_len)\n+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n+  else if (GFC_DESCRIPTOR_TYPE (d) != BT_DERIVED)\n+    GFC_DESCRIPTOR_SIZE (d) = kind;\n+  else\n+    GFC_DESCRIPTOR_SIZE (d) = s->elem_len;\n \n   d->dtype.version = 0;\n-\n-  if (s->rank < 0 || s->rank > CFI_MAX_RANK)\n-    internal_error (NULL, \"Invalid rank in descriptor\");\n   GFC_DESCRIPTOR_RANK (d) = (signed char)s->rank;\n \n   d->dtype.attribute = (signed short)s->attribute;\n@@ -131,7 +102,6 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n {\n   int n;\n   CFI_cdesc_t *d;\n-  signed char type, kind;\n \n   /* Play it safe with allocation of the flexible array member 'dim'\n      by setting the length to CFI_MAX_RANK. This should not be necessary\n@@ -142,99 +112,22 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n   else\n     d = *d_ptr;\n \n-  /* Verify descriptor.  */\n-  switch (s->dtype.attribute)\n-    {\n-    case CFI_attribute_pointer:\n-    case CFI_attribute_allocatable:\n-      break;\n-    case CFI_attribute_other:\n-      if (s->base_addr)\n-\tbreak;\n-      runtime_error (\"Nonallocatable, nonpointer actual argument to BIND(C) \"\n-\t\t     \"dummy argument where the effective argument is either \"\n-\t\t     \"not allocated or not associated\");\n-      break;\n-    default:\n-      internal_error (NULL, \"Invalid attribute in gfc_array descriptor\");\n-      break;\n-    }\n   d->base_addr = GFC_DESCRIPTOR_DATA (s);\n   d->elem_len = GFC_DESCRIPTOR_SIZE (s);\n-  if (d->elem_len <= 0)\n-    internal_error (NULL, \"Invalid size in descriptor\");\n-\n   d->version = CFI_VERSION;\n-\n   d->rank = (CFI_rank_t)GFC_DESCRIPTOR_RANK (s);\n-  if (d->rank < 0 || d->rank > CFI_MAX_RANK)\n-    internal_error (NULL, \"Invalid rank in descriptor\");\n-\n   d->attribute = (CFI_attribute_t)s->dtype.attribute;\n \n-  type = GFC_DESCRIPTOR_TYPE (s);\n-  switch (type)\n-    {\n-    case BT_CHARACTER:\n-      d->type = CFI_type_Character;\n-      break;\n-    case BT_DERIVED:\n-      d->type = CFI_type_struct;\n-      break;\n-    case BT_VOID:\n-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n-\t CFI_type_cptr and CFI_type_cfunptr.  */\n-      d->type = CFI_type_cptr;\n-      break;\n-    default:\n-      d->type = (CFI_type_t)type;\n-      break;\n-    }\n-\n-  switch (d->type)\n-    {\n-    case CFI_type_Integer:\n-    case CFI_type_Logical:\n-    case CFI_type_Real:\n-      kind = (signed char)d->elem_len;\n-      break;\n-    case CFI_type_Complex:\n-      kind = (signed char)(d->elem_len >> 1);\n-      break;\n-    case CFI_type_Character:\n-      /* FIXME: we can't distinguish between kind/len because\n-\t the GFC descriptor only encodes the elem_len..\n-\t Until PR92482 is fixed, assume elem_len refers to the\n-\t character size and not the string length.  */\n-      kind = (signed char)d->elem_len;\n-      break;\n-    case CFI_type_struct:\n-    case CFI_type_cptr:\n-    case CFI_type_other:\n-      /* FIXME: PR 100915.  GFC descriptors do not distinguish between\n-\t CFI_type_cptr and CFI_type_cfunptr.  */\n-      kind = 0;\n-      break;\n-    default:\n-      internal_error (NULL, \"Invalid type in descriptor\");\n-    }\n-\n-  if (kind < 0)\n-    internal_error (NULL, \"Invalid kind in descriptor\");\n-\n-  /* FIXME: This is PR100917.  Because the GFC descriptor encodes only the\n-     elem_len and not the kind, we get into trouble with long double kinds\n-     that do not correspond directly to the elem_len, specifically the\n-     kind 10 80-bit long double on x86 targets.  On x86_64, this has size\n-     16 and cannot be differentiated from true _Float128.  Prefer the\n-     standard long double type over the GNU extension in that case.  */\n-  if (d->type == CFI_type_Real && kind == sizeof (long double))\n-    d->type = CFI_type_long_double;\n-  else if (d->type == CFI_type_Complex && kind == sizeof (long double))\n-    d->type = CFI_type_long_double_Complex;\n+  if (GFC_DESCRIPTOR_TYPE (s) == BT_CHARACTER)\n+    d->type = CFI_type_Character;\n+  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)\n+    d->type = CFI_type_struct;\n   else\n+    d->type = (CFI_type_t)GFC_DESCRIPTOR_TYPE (s);\n+\n+  if (GFC_DESCRIPTOR_TYPE (s) != BT_DERIVED)\n     d->type = (CFI_type_t)(d->type\n-\t\t\t   + ((CFI_type_t)kind << CFI_type_kind_shift));\n+\t\t+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));\n \n   if (d->base_addr)\n     /* Full pointer or allocatable arrays retain their lower_bounds.  */"}, {"sha": "ddb507ba8e40fc278aa5a2ad66e3c688f178b22f", "filename": "libgomp/testsuite/libgomp.fortran/allocate-4.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e205ec03f0794aeac3e8a89e947c12624d5a274e/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e205ec03f0794aeac3e8a89e947c12624d5a274e/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fallocate-4.f90?ref=e205ec03f0794aeac3e8a89e947c12624d5a274e", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+\n+\n+subroutine test()\n+use iso_c_binding, only: c_intptr_t\n+implicit none\n+integer, parameter :: omp_allocator_handle_kind = 1 !! <<<\n+integer (kind=omp_allocator_handle_kind), &\n+                 parameter :: omp_high_bw_mem_alloc = 4\n+integer :: q, x,y,z\n+integer, parameter :: cnst(2) = [64, 101]\n+\n+!$omp parallel allocate( omp_high_bw_mem_alloc : x)  firstprivate(x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( allocator (omp_high_bw_mem_alloc) : x)  firstprivate(x) ! { dg-error \"Expected integer expression of the 'omp_allocator_handle_kind' kind\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align (q) : x)  firstprivate(x) ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align (32) : x)  firstprivate(x) ! OK\n+!$omp end parallel\n+\n+!$omp parallel allocate( align(q) : x) firstprivate(x) ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align(cnst(1)) : x ) firstprivate(x) ! OK\n+!$omp end parallel\n+\n+!$omp parallel allocate( align(cnst(2)) : x) firstprivate(x)  ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align( 31) :x) firstprivate(x)  ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align (32.0): x) firstprivate(x)  ! { dg-error \"32:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+\n+!$omp parallel allocate( align(cnst ) : x ) firstprivate(x)  ! { dg-error \"31:ALIGN modifier requires at \\\\(1\\\\) a scalar positive constant integer alignment expression that is a power of two\" }\n+!$omp end parallel\n+end"}]}