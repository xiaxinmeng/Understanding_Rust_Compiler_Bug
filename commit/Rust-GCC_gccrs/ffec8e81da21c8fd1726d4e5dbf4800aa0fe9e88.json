{"sha": "ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlYzhlODFkYTIxYzhmZDE3MjZkNGU1ZGJmNDgwMGFhMGZlOWU4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:51:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-17T09:51:08Z"}, "message": "[multiple changes]\n\n2009-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenation): Do not use calls at -Os.\n\n2009-04-17  Pascal Obry  <obry@adacore.com>\n\n\t* mingw32.h: Add S2WSC and WS2SC macros to convert to/from\n\tCurrentCodePage.\n\n\t* adaint.h: Encoding_Unspecified is now defined. Corresponds to the\n\tvalue when no encoding form paramter is set on Text_IO services.\n\n\t* adaint.c: CurrentCodePage new variable on Windows.\n\tUse new macros S2WSC and WS2SC instead of the UTF-8 oriented\n\tones.\n\n\t* mkdir.c: Use new macros S2WSC and WS2SC instead of the UTF-8 oriented\n\tones.\n\n\t* initialize.c: Initialize CurrentCodePage depending on GNAT_CODE_PAGE\n\tenvironment variable value. Default is UTF-8.\n\n\t* s-crtl.ads: Filename_Encoding add Unspecified in the enumeration type.\n\tfopen and freopen encoding parameter is now set to Unspecified.\n\tThe default value is in this case UTF-8 (as it was before) but\n\tuse the new macros that convert to/from the code page set\n\tat runtime (CurrentCodePage).\n\n\t* s-fileio.adb: When no encoding specified use Unspecified value.\n\n2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* atree.adb, atree.ads: Remove dead code.\n\nFrom-SVN: r146235", "tree": {"sha": "764f35cd7165193222fc6482634c43fce750c1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/764f35cd7165193222fc6482634c43fce750c1af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/comments", "author": null, "committer": null, "parents": [{"sha": "432e3422d04283b2012498781115b032830ba6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432e3422d04283b2012498781115b032830ba6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432e3422d04283b2012498781115b032830ba6e1"}], "stats": {"total": 1173, "additions": 115, "deletions": 1058}, "files": [{"sha": "5f3d5c56257035b4b54485c6965718b8ec0012e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -1,3 +1,37 @@\n+2009-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenation): Do not use calls at -Os.\n+\n+2009-04-17  Pascal Obry  <obry@adacore.com>\n+\n+\t* mingw32.h: Add S2WSC and WS2SC macros to convert to/from\n+\tCurrentCodePage.\n+\n+\t* adaint.h: Encoding_Unspecified is now defined. Corresponds to the\n+\tvalue when no encoding form paramter is set on Text_IO services.\n+\n+\t* adaint.c: CurrentCodePage new variable on Windows.\n+\tUse new macros S2WSC and WS2SC instead of the UTF-8 oriented\n+\tones.\n+\n+\t* mkdir.c: Use new macros S2WSC and WS2SC instead of the UTF-8 oriented\n+\tones.\n+\n+\t* initialize.c: Initialize CurrentCodePage depending on GNAT_CODE_PAGE\n+\tenvironment variable value. Default is UTF-8.\n+\n+\t* s-crtl.ads: Filename_Encoding add Unspecified in the enumeration type.\n+\tfopen and freopen encoding parameter is now set to Unspecified.\n+\tThe default value is in this case UTF-8 (as it was before) but\n+\tuse the new macros that convert to/from the code page set\n+\tat runtime (CurrentCodePage).\n+\n+\t* s-fileio.adb: When no encoding specified use Unspecified value.\n+\n+2009-04-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* atree.adb, atree.ads: Remove dead code.\n+\n 2009-04-17  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "1b6bb7ff67b25e2de8ef4305813434e3c2528331", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -82,6 +82,9 @@\n #include <Rtapi.h>\n #else\n #include \"mingw32.h\"\n+\n+/* Current code page to use, set in initialize.c.  */\n+UINT CurrentCodePage;\n #endif\n \n #include <sys/utime.h>\n@@ -482,8 +485,8 @@ __gnat_try_lock (char *dir, char *file)\n   TCHAR wfile[GNAT_MAX_PATH_LEN];\n   TCHAR wdir[GNAT_MAX_PATH_LEN];\n \n-  S2WSU (wdir, dir, GNAT_MAX_PATH_LEN);\n-  S2WSU (wfile, file, GNAT_MAX_PATH_LEN);\n+  S2WSC (wdir, dir, GNAT_MAX_PATH_LEN);\n+  S2WSC (wfile, file, GNAT_MAX_PATH_LEN);\n \n   _stprintf (wfull_path, _T(\"%s%c%s\"), wdir, _T(DIR_SEPARATOR), wfile);\n   fd = _topen (wfull_path, O_CREAT | O_EXCL, 0600);\n@@ -585,7 +588,7 @@ __gnat_get_current_dir (char *dir, int *length)\n \n   _tgetcwd (wdir, *length);\n \n-  WS2SU (dir, wdir, GNAT_MAX_PATH_LEN);\n+  WS2SC (dir, wdir, GNAT_MAX_PATH_LEN);\n \n #elif defined (VMS)\n    /* Force Unix style, which is what GNAT uses internally.  */\n@@ -662,7 +665,7 @@ __gnat_os_filename (char *filename, char *w_filename ATTRIBUTE_UNUSED,\n \t\t    char *encoding ATTRIBUTE_UNUSED, int *e_length)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (CROSS_DIRECTORY_STRUCTURE)\n-  WS2SU (os_name, (TCHAR *)w_filename, o_length);\n+  WS2SC (os_name, (TCHAR *)w_filename, o_length);\n   *o_length = strlen (os_name);\n   strcpy (encoding, \"encoding=utf8\");\n   *e_length = strlen (encoding);\n@@ -682,7 +685,7 @@ __gnat_unlink (char *path)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     return _tunlink (wpath);\n   }\n #else\n@@ -699,8 +702,8 @@ __gnat_rename (char *from, char *to)\n   {\n     TCHAR wfrom[GNAT_MAX_PATH_LEN], wto[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wfrom, from, GNAT_MAX_PATH_LEN);\n-    S2WSU (wto, to, GNAT_MAX_PATH_LEN);\n+    S2WSC (wfrom, from, GNAT_MAX_PATH_LEN);\n+    S2WSC (wto, to, GNAT_MAX_PATH_LEN);\n     return _trename (wfrom, wto);\n   }\n #else\n@@ -717,7 +720,7 @@ __gnat_chdir (char *path)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     return _tchdir (wpath);\n   }\n #else\n@@ -734,7 +737,7 @@ __gnat_rmdir (char *path)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     return _trmdir (wpath);\n   }\n #else\n@@ -751,7 +754,9 @@ __gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED)\n \n   S2WS (wmode, mode, 10);\n \n-  if (encoding == Encoding_UTF8)\n+  if (encoding == Encoding_Unspecified)\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n+  else if (encoding == Encoding_UTF8)\n     S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n   else\n     S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n@@ -773,7 +778,9 @@ __gnat_freopen (char *path, char *mode, FILE *stream, int encoding ATTRIBUTE_UNU\n \n   S2WS (wmode, mode, 10);\n \n-  if (encoding == Encoding_UTF8)\n+  if (encoding == Encoding_Unspecified)\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n+  else if (encoding == Encoding_UTF8)\n     S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n   else\n     S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n@@ -805,7 +812,7 @@ __gnat_open_read (char *path, int fmode)\n  {\n    TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-   S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+   S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n    fd = _topen (wpath, O_RDONLY | o_fmode, 0444);\n  }\n #else\n@@ -846,7 +853,7 @@ __gnat_open_rw (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_RDWR | o_fmode, PERM);\n   }\n #else\n@@ -872,7 +879,7 @@ __gnat_open_create (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM);\n   }\n #else\n@@ -894,7 +901,7 @@ __gnat_create_output_file (char *path)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM);\n   }\n #else\n@@ -920,7 +927,7 @@ __gnat_open_append (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM);\n   }\n #else\n@@ -948,7 +955,7 @@ __gnat_open_new (char *path, int fmode)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n-    S2WSU (wpath, path, GNAT_MAX_PATH_LEN);\n+    S2WSC (wpath, path, GNAT_MAX_PATH_LEN);\n     fd = _topen (wpath, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM);\n   }\n #else\n@@ -1101,7 +1108,7 @@ DIR* __gnat_opendir (char *name)\n #elif defined (__MINGW32__)\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n   return (DIR*)_topendir (wname);\n \n #else\n@@ -1125,7 +1132,7 @@ __gnat_readdir (DIR *dirp, char *buffer, int *len)\n \n   if (dirent != NULL)\n     {\n-      WS2SU (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n+      WS2SC (buffer, dirent->d_name, GNAT_MAX_PATH_LEN);\n       *len = strlen (buffer);\n \n       return buffer;\n@@ -1231,7 +1238,7 @@ __gnat_file_time_name (char *name)\n   time_t ret = -1;\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n \n   HANDLE h = CreateFile\n     (wname, GENERIC_READ, FILE_SHARE_READ, 0,\n@@ -1368,7 +1375,7 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n   } t_write;\n   TCHAR wname[GNAT_MAX_PATH_LEN];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN);\n \n   HANDLE h  = CreateFile\n     (wname, GENERIC_WRITE, FILE_SHARE_WRITE, NULL,\n@@ -1631,7 +1638,7 @@ __gnat_stat (char *name, struct stat *statbuf)\n   int name_len;\n   TCHAR last_char;\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n   name_len = _tcslen (wname);\n \n   if (name_len > GNAT_MAX_PATH_LEN)\n@@ -1667,7 +1674,7 @@ __gnat_file_exists (char *name)\n   offset the _stat() routine fails on specific files like CON:  */\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n   return GetFileAttributes (wname) != INVALID_FILE_ATTRIBUTES;\n #else\n   struct stat statbuf;\n@@ -1851,7 +1858,7 @@ __gnat_is_readable_file (char *name)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   GENERIC_MAPPING GenericMapping;\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n   GenericMapping.GenericRead = GENERIC_READ;\n@@ -1875,7 +1882,7 @@ __gnat_is_writable_file (char *name)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   GENERIC_MAPPING GenericMapping;\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n   GenericMapping.GenericWrite = GENERIC_WRITE;\n@@ -1901,7 +1908,7 @@ __gnat_is_executable_file (char *name)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   GENERIC_MAPPING GenericMapping;\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n   GenericMapping.GenericExecute = GENERIC_EXECUTE;\n@@ -1924,7 +1931,7 @@ __gnat_set_writable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_WRITE);\n   SetFileAttributes\n@@ -1946,7 +1953,7 @@ __gnat_set_executable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n@@ -1966,7 +1973,7 @@ __gnat_set_non_writable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   __gnat_set_OWNER_ACL\n     (wname, DENY_ACCESS,\n@@ -1991,7 +1998,7 @@ __gnat_set_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n@@ -2010,7 +2017,7 @@ __gnat_set_non_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n   __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n@@ -2285,7 +2292,7 @@ win32_no_block_spawn (char *command, char *args[])\n     int wsize = csize * 2;\n     TCHAR *wcommand = (TCHAR *) xmalloc (wsize);\n \n-    S2WSU (wcommand, full_command, wsize);\n+    S2WSC (wcommand, full_command, wsize);\n \n     free (full_command);\n \n@@ -2581,7 +2588,7 @@ __gnat_locate_exec_on_path (char *exec_name)\n \n   apath_val = alloca (EXPAND_BUFFER_SIZE);\n \n-  WS2SU (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n+  WS2SC (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n   return __gnat_locate_exec (exec_name, apath_val);\n \n #else"}, {"sha": "2ecaf7305288aa8d6be03d5e265a9cbc4c23c0c9", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -39,8 +39,9 @@\n #include <dirent.h>\n \n /*  Constants used for the form parameter encoding values  */\n-#define Encoding_UTF8 0\n-#define Encoding_8bits 1\n+#define Encoding_UTF8 0         /* UTF-8 */\n+#define Encoding_8bits 1        /* Standard 8bits, CP_ACP on Windows. */\n+#define Encoding_Unspecified 2  /* Based on GNAT_CODE_PAGE env variable. */\n \n typedef long OS_Time; /* Type corresponding to GNAT.OS_Lib.OS_Time */\n "}, {"sha": "79f2ffda5b5b6d67d25b37471a847ae756d96368", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 0, "deletions": 972, "changes": 972, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -38,13 +38,10 @@ pragma Style_Checks (All_Checks);\n \n with Debug;   use Debug;\n with Nlists;  use Nlists;\n-with Elists;  use Elists;\n with Output;  use Output;\n with Sinput;  use Sinput;\n with Tree_IO; use Tree_IO;\n \n-with GNAT.HTable; use GNAT.HTable;\n-\n package body Atree is\n \n    ---------------\n@@ -414,35 +411,6 @@ package body Atree is\n       Table_Increment      => Alloc.Orig_Nodes_Increment,\n       Table_Name           => \"Orig_Nodes\");\n \n-   ----------------------------------------\n-   -- Global_Variables for New_Copy_Tree --\n-   ----------------------------------------\n-\n-   --  These global variables are used by New_Copy_Tree. See description\n-   --  of the body of this subprogram for details. Global variables can be\n-   --  safely used by New_Copy_Tree, since there is no case of a recursive\n-   --  call from the processing inside New_Copy_Tree.\n-\n-   NCT_Hash_Threshhold : constant := 20;\n-   --  If there are more than this number of pairs of entries in the\n-   --  map, then Hash_Tables_Used will be set, and the hash tables will\n-   --  be initialized and used for the searches.\n-\n-   NCT_Hash_Tables_Used : Boolean := False;\n-   --  Set to True if hash tables are in use\n-\n-   NCT_Table_Entries : Nat;\n-   --  Count entries in table to see if threshhold is reached\n-\n-   NCT_Hash_Table_Setup : Boolean := False;\n-   --  Set to True if hash table contains data. We set this True if we\n-   --  setup the hash table with data, and leave it set permanently\n-   --  from then on, this is a signal that second and subsequent users\n-   --  of the hash table must clear the old entries before reuse.\n-\n-   subtype NCT_Header_Num is Int range 0 .. 511;\n-   --  Defines range of headers in hash tables (512 headers)\n-\n    --------------------------\n    -- Paren_Count Handling --\n    --------------------------\n@@ -986,12 +954,6 @@ package body Atree is\n       Dummy := New_Node (N_Error, No_Location);\n       Set_Name1 (Error, Error_Name);\n       Set_Error_Posted (Error, True);\n-\n-      --  Set global variables for New_Copy_Tree\n-\n-      NCT_Hash_Tables_Used := False;\n-      NCT_Table_Entries    := 0;\n-      NCT_Hash_Table_Setup := False;\n    end Initialize;\n \n    --------------------------\n@@ -1067,940 +1029,6 @@ package body Atree is\n       return New_Id;\n    end New_Copy;\n \n-   -------------------\n-   -- New_Copy_Tree --\n-   -------------------\n-\n-   --  Our approach here requires a two pass traversal of the tree. The\n-   --  first pass visits all nodes that eventually will be copied looking\n-   --  for defining Itypes. If any defining Itypes are found, then they are\n-   --  copied, and an entry is added to the replacement map. In the second\n-   --  phase, the tree is copied, using the replacement map to replace any\n-   --  Itype references within the copied tree.\n-\n-   --  The following hash tables are used if the Map supplied has more\n-   --  than hash threshhold entries to speed up access to the map. If\n-   --  there are fewer entries, then the map is searched sequentially\n-   --  (because setting up a hash table for only a few entries takes\n-   --  more time than it saves.\n-\n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n-   --  Hash function used for hash operations\n-\n-   -------------------\n-   -- New_Copy_Hash --\n-   -------------------\n-\n-   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n-   begin\n-      return Nat (E) mod (NCT_Header_Num'Last + 1);\n-   end New_Copy_Hash;\n-\n-   ---------------\n-   -- NCT_Assoc --\n-   ---------------\n-\n-   --  The hash table NCT_Assoc associates old entities in the table\n-   --  with their corresponding new entities (i.e. the pairs of entries\n-   --  presented in the original Map argument are Key-Element pairs).\n-\n-   package NCT_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n-     Element    => Entity_Id,\n-     No_Element => Empty,\n-     Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n-\n-   ---------------------\n-   -- NCT_Itype_Assoc --\n-   ---------------------\n-\n-   --  The hash table NCT_Itype_Assoc contains entries only for those\n-   --  old nodes which have a non-empty Associated_Node_For_Itype set.\n-   --  The key is the associated node, and the element is the new node\n-   --  itself (NOT the associated node for the new node).\n-\n-   package NCT_Itype_Assoc is new Simple_HTable (\n-     Header_Num => NCT_Header_Num,\n-     Element    => Entity_Id,\n-     No_Element => Empty,\n-     Key        => Entity_Id,\n-     Hash       => New_Copy_Hash,\n-     Equal      => Types.\"=\");\n-\n-   --  Start of processing for New_Copy_Tree function\n-\n-   function New_Copy_Tree1\n-     (Source    : Node_Id;\n-      Map       : Elist_Id := No_Elist;\n-      New_Sloc  : Source_Ptr := No_Location;\n-      New_Scope : Entity_Id := Empty) return Node_Id\n-   is\n-      Actual_Map : Elist_Id := Map;\n-      --  This is the actual map for the copy. It is initialized with the\n-      --  given elements, and then enlarged as required for Itypes that are\n-      --  copied during the first phase of the copy operation. The visit\n-      --  procedures add elements to this map as Itypes are encountered.\n-      --  The reason we cannot use Map directly, is that it may well be\n-      --  (and normally is) initialized to No_Elist, and if we have mapped\n-      --  entities, we have to reset it to point to a real Elist.\n-\n-      function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n-      --  Called during second phase to map entities into their corresponding\n-      --  copies using Actual_Map. If the argument is not an entity, or is not\n-      --  in Actual_Map, then it is returned unchanged.\n-\n-      procedure Build_NCT_Hash_Tables;\n-      --  Builds hash tables (number of elements >= threshold value)\n-\n-      function Copy_Elist_With_Replacement\n-        (Old_Elist : Elist_Id) return Elist_Id;\n-      --  Called during second phase to copy element list doing replacements\n-\n-      procedure Copy_Itype_With_Replacement (New_Itype : Entity_Id);\n-      --  Called during the second phase to process a copied Itype. The actual\n-      --  copy happened during the first phase (so that we could make the entry\n-      --  in the mapping), but we still have to deal with the descendents of\n-      --  the copied Itype and copy them where necessary.\n-\n-      function Copy_List_With_Replacement (Old_List : List_Id) return List_Id;\n-      --  Called during second phase to copy list doing replacements\n-\n-      function Copy_Node_With_Replacement (Old_Node : Node_Id) return Node_Id;\n-      --  Called during second phase to copy node doing replacements\n-\n-      procedure Visit_Elist (E : Elist_Id);\n-      --  Called during first phase to visit all elements of an Elist\n-\n-      procedure Visit_Field (F : Union_Id; N : Node_Id);\n-      --  Visit a single field, recursing to call Visit_Node or Visit_List\n-      --  if the field is a syntactic descendent of the current node (i.e.\n-      --  its parent is Node N).\n-\n-      procedure Visit_Itype (Old_Itype : Entity_Id);\n-      --  Called during first phase to visit subsidiary fields of a defining\n-      --  Itype, and also create a copy and make an entry in the replacement\n-      --  map for the new copy.\n-\n-      procedure Visit_List (L : List_Id);\n-      --  Called during first phase to visit all elements of a List\n-\n-      procedure Visit_Node (N : Node_Or_Entity_Id);\n-      --  Called during first phase to visit a node and all its subtrees\n-\n-      -----------\n-      -- Assoc --\n-      -----------\n-\n-      function Assoc (N : Node_Or_Entity_Id) return Node_Id is\n-         E   : Elmt_Id;\n-         Ent : Entity_Id;\n-\n-      begin\n-         if not Has_Extension (N) or else No (Actual_Map) then\n-            return N;\n-\n-         elsif NCT_Hash_Tables_Used then\n-            Ent := NCT_Assoc.Get (Entity_Id (N));\n-\n-            if Present (Ent) then\n-               return Ent;\n-            else\n-               return N;\n-            end if;\n-\n-         --  No hash table used, do serial search\n-\n-         else\n-            E := First_Elmt (Actual_Map);\n-            while Present (E) loop\n-               if Node (E) = N then\n-                  return Node (Next_Elmt (E));\n-               else\n-                  E := Next_Elmt (Next_Elmt (E));\n-               end if;\n-            end loop;\n-         end if;\n-\n-         return N;\n-      end Assoc;\n-\n-      ---------------------------\n-      -- Build_NCT_Hash_Tables --\n-      ---------------------------\n-\n-      procedure Build_NCT_Hash_Tables is\n-         Elmt : Elmt_Id;\n-         Ent  : Entity_Id;\n-      begin\n-         if NCT_Hash_Table_Setup then\n-            NCT_Assoc.Reset;\n-            NCT_Itype_Assoc.Reset;\n-         end if;\n-\n-         Elmt := First_Elmt (Actual_Map);\n-         while Present (Elmt) loop\n-            Ent := Node (Elmt);\n-\n-            --  Get new entity, and associate old and new\n-\n-            Next_Elmt (Elmt);\n-            NCT_Assoc.Set (Ent, Node (Elmt));\n-\n-            if Is_Type (Ent) then\n-               declare\n-                  Anode : constant Entity_Id :=\n-                            Associated_Node_For_Itype (Ent);\n-\n-               begin\n-                  if Present (Anode) then\n-\n-                     --  Enter a link between the associated node of the\n-                     --  old Itype and the new Itype, for updating later\n-                     --  when node is copied.\n-\n-                     NCT_Itype_Assoc.Set (Anode, Node (Elmt));\n-                  end if;\n-               end;\n-            end if;\n-\n-            Next_Elmt (Elmt);\n-         end loop;\n-\n-         NCT_Hash_Tables_Used := True;\n-         NCT_Hash_Table_Setup := True;\n-      end Build_NCT_Hash_Tables;\n-\n-      ---------------------------------\n-      -- Copy_Elist_With_Replacement --\n-      ---------------------------------\n-\n-      function Copy_Elist_With_Replacement\n-        (Old_Elist : Elist_Id) return Elist_Id\n-      is\n-         M         : Elmt_Id;\n-         New_Elist : Elist_Id;\n-\n-      begin\n-         if No (Old_Elist) then\n-            return No_Elist;\n-\n-         else\n-            New_Elist := New_Elmt_List;\n-\n-            M := First_Elmt (Old_Elist);\n-            while Present (M) loop\n-               Append_Elmt (Copy_Node_With_Replacement (Node (M)), New_Elist);\n-               Next_Elmt (M);\n-            end loop;\n-         end if;\n-\n-         return New_Elist;\n-      end Copy_Elist_With_Replacement;\n-\n-      ---------------------------------\n-      -- Copy_Itype_With_Replacement --\n-      ---------------------------------\n-\n-      --  This routine exactly parallels its phase one analog Visit_Itype,\n-      --  and like that routine, knows far too many semantic details about\n-      --  the descendents of Itypes and whether they need copying or not.\n-\n-      procedure Copy_Itype_With_Replacement (New_Itype : Entity_Id) is\n-      begin\n-         --  Translate Next_Entity, Scope and Etype fields, in case they\n-         --  reference entities that have been mapped into copies.\n-\n-         Set_Next_Entity (New_Itype, Assoc (Next_Entity (New_Itype)));\n-         Set_Etype       (New_Itype, Assoc (Etype       (New_Itype)));\n-\n-         if Present (New_Scope) then\n-            Set_Scope    (New_Itype, New_Scope);\n-         else\n-            Set_Scope    (New_Itype, Assoc (Scope       (New_Itype)));\n-         end if;\n-\n-         --  Copy referenced fields\n-\n-         if Is_Discrete_Type (New_Itype) then\n-            Set_Scalar_Range (New_Itype,\n-              Copy_Node_With_Replacement (Scalar_Range (New_Itype)));\n-\n-         elsif Has_Discriminants (Base_Type (New_Itype)) then\n-            Set_Discriminant_Constraint (New_Itype,\n-              Copy_Elist_With_Replacement\n-                (Discriminant_Constraint (New_Itype)));\n-\n-         elsif Is_Array_Type (New_Itype) then\n-            if Present (First_Index (New_Itype)) then\n-               Set_First_Index (New_Itype,\n-                 First (Copy_List_With_Replacement\n-                         (List_Containing (First_Index (New_Itype)))));\n-            end if;\n-\n-            if Is_Packed (New_Itype) then\n-               Set_Packed_Array_Type (New_Itype,\n-                 Copy_Node_With_Replacement\n-                   (Packed_Array_Type (New_Itype)));\n-            end if;\n-         end if;\n-      end Copy_Itype_With_Replacement;\n-\n-      --------------------------------\n-      -- Copy_List_With_Replacement --\n-      --------------------------------\n-\n-      function Copy_List_With_Replacement\n-        (Old_List : List_Id) return List_Id\n-      is\n-         New_List : List_Id;\n-         E        : Node_Id;\n-\n-      begin\n-         if Old_List = No_List then\n-            return No_List;\n-\n-         else\n-            New_List := Empty_List;\n-\n-            E := First (Old_List);\n-            while Present (E) loop\n-               Append (Copy_Node_With_Replacement (E), New_List);\n-               Next (E);\n-            end loop;\n-\n-            return New_List;\n-         end if;\n-      end Copy_List_With_Replacement;\n-\n-      --------------------------------\n-      -- Copy_Node_With_Replacement --\n-      --------------------------------\n-\n-      function Copy_Node_With_Replacement\n-        (Old_Node : Node_Id) return Node_Id\n-      is\n-         New_Node : Node_Id;\n-\n-         procedure Adjust_Named_Associations\n-           (Old_Node : Node_Id;\n-            New_Node : Node_Id);\n-         --  If a call node has named associations, these are chained through\n-         --  the First_Named_Actual, Next_Named_Actual links. These must be\n-         --  propagated separately to the new parameter list, because these\n-         --  are not syntactic fields.\n-\n-         function Copy_Field_With_Replacement\n-           (Field : Union_Id) return Union_Id;\n-         --  Given Field, which is a field of Old_Node, return a copy of it\n-         --  if it is a syntactic field (i.e. its parent is Node), setting\n-         --  the parent of the copy to poit to New_Node. Otherwise returns\n-         --  the field (possibly mapped if it is an entity).\n-\n-         -------------------------------\n-         -- Adjust_Named_Associations --\n-         -------------------------------\n-\n-         procedure Adjust_Named_Associations\n-           (Old_Node : Node_Id;\n-            New_Node : Node_Id)\n-         is\n-            Old_E : Node_Id;\n-            New_E : Node_Id;\n-\n-            Old_Next : Node_Id;\n-            New_Next : Node_Id;\n-\n-         begin\n-            Old_E := First (Parameter_Associations (Old_Node));\n-            New_E := First (Parameter_Associations (New_Node));\n-            while Present (Old_E) loop\n-               if Nkind (Old_E) = N_Parameter_Association\n-                 and then Present (Next_Named_Actual (Old_E))\n-               then\n-                  if First_Named_Actual (Old_Node)\n-                    =  Explicit_Actual_Parameter (Old_E)\n-                  then\n-                     Set_First_Named_Actual\n-                       (New_Node, Explicit_Actual_Parameter (New_E));\n-                  end if;\n-\n-                  --  Now scan parameter list from the beginning,to locate\n-                  --  next named actual, which can be out of order.\n-\n-                  Old_Next := First (Parameter_Associations (Old_Node));\n-                  New_Next := First (Parameter_Associations (New_Node));\n-\n-                  while Nkind (Old_Next) /= N_Parameter_Association\n-                    or else  Explicit_Actual_Parameter (Old_Next)\n-                      /= Next_Named_Actual (Old_E)\n-                  loop\n-                     Next (Old_Next);\n-                     Next (New_Next);\n-                  end loop;\n-\n-                  Set_Next_Named_Actual\n-                    (New_E, Explicit_Actual_Parameter (New_Next));\n-               end if;\n-\n-               Next (Old_E);\n-               Next (New_E);\n-            end loop;\n-         end Adjust_Named_Associations;\n-\n-         ---------------------------------\n-         -- Copy_Field_With_Replacement --\n-         ---------------------------------\n-\n-         function Copy_Field_With_Replacement\n-           (Field : Union_Id) return Union_Id\n-         is\n-         begin\n-            if Field = Union_Id (Empty) then\n-               return Field;\n-\n-            elsif Field in Node_Range then\n-               declare\n-                  Old_N : constant Node_Id := Node_Id (Field);\n-                  New_N : Node_Id;\n-\n-               begin\n-                  --  If syntactic field, as indicated by the parent pointer\n-                  --  being set, then copy the referenced node recursively.\n-\n-                  if Parent (Old_N) = Old_Node then\n-                     New_N := Copy_Node_With_Replacement (Old_N);\n-\n-                     if New_N /= Old_N then\n-                        Set_Parent (New_N, New_Node);\n-                     end if;\n-\n-                  --  For semantic fields, update possible entity reference\n-                  --  from the replacement map.\n-\n-                  else\n-                     New_N := Assoc (Old_N);\n-                  end if;\n-\n-                  return Union_Id (New_N);\n-               end;\n-\n-            elsif Field in List_Range then\n-               declare\n-                  Old_L : constant List_Id := List_Id (Field);\n-                  New_L : List_Id;\n-\n-               begin\n-                  --  If syntactic field, as indicated by the parent pointer,\n-                  --  then recursively copy the entire referenced list.\n-\n-                  if Parent (Old_L) = Old_Node then\n-                     New_L := Copy_List_With_Replacement (Old_L);\n-                     Set_Parent (New_L, New_Node);\n-\n-                  --  For semantic list, just returned unchanged\n-\n-                  else\n-                     New_L := Old_L;\n-                  end if;\n-\n-                  return Union_Id (New_L);\n-               end;\n-\n-            --  Anything other than a list or a node is returned unchanged\n-\n-            else\n-               return Field;\n-            end if;\n-         end Copy_Field_With_Replacement;\n-\n-      --  Start of processing for Copy_Node_With_Replacement\n-\n-      begin\n-         if Old_Node <= Empty_Or_Error then\n-            return Old_Node;\n-\n-         elsif Has_Extension (Old_Node) then\n-            return Assoc (Old_Node);\n-\n-         else\n-            New_Node := New_Copy (Old_Node);\n-\n-            --  If the node we are copying is the associated node of a\n-            --  previously copied Itype, then adjust the associated node\n-            --  of the copy of that Itype accordingly.\n-\n-            if Present (Actual_Map) then\n-               declare\n-                  E   : Elmt_Id;\n-                  Ent : Entity_Id;\n-\n-               begin\n-                  --  Case of hash table used\n-\n-                  if NCT_Hash_Tables_Used then\n-                     Ent := NCT_Itype_Assoc.Get (Old_Node);\n-\n-                     if Present (Ent) then\n-                        Set_Associated_Node_For_Itype (Ent, New_Node);\n-                     end if;\n-\n-                  --  Case of no hash table used\n-\n-                  else\n-                     E := First_Elmt (Actual_Map);\n-                     while Present (E) loop\n-                        if Is_Itype (Node (E))\n-                          and then\n-                            Old_Node = Associated_Node_For_Itype (Node (E))\n-                        then\n-                           Set_Associated_Node_For_Itype\n-                             (Node (Next_Elmt (E)), New_Node);\n-                        end if;\n-\n-                        E := Next_Elmt (Next_Elmt (E));\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Recursively copy descendents\n-\n-            Set_Field1\n-              (New_Node, Copy_Field_With_Replacement (Field1 (New_Node)));\n-            Set_Field2\n-              (New_Node, Copy_Field_With_Replacement (Field2 (New_Node)));\n-            Set_Field3\n-              (New_Node, Copy_Field_With_Replacement (Field3 (New_Node)));\n-            Set_Field4\n-              (New_Node, Copy_Field_With_Replacement (Field4 (New_Node)));\n-            Set_Field5\n-              (New_Node, Copy_Field_With_Replacement (Field5 (New_Node)));\n-\n-            --  Adjust Sloc of new node if necessary\n-\n-            if New_Sloc /= No_Location then\n-               Set_Sloc (New_Node, New_Sloc);\n-\n-               --  If we adjust the Sloc, then we are essentially making\n-               --  a completely new node, so the Comes_From_Source flag\n-               --  should be reset to the proper default value.\n-\n-               Nodes.Table (New_Node).Comes_From_Source :=\n-                 Default_Node.Comes_From_Source;\n-            end if;\n-\n-            --  If the node is call and has named associations,\n-            --  set the corresponding links in the copy.\n-\n-            if (Nkind (Old_Node) = N_Function_Call\n-                 or else Nkind (Old_Node) = N_Entry_Call_Statement\n-                 or else\n-                   Nkind (Old_Node) = N_Procedure_Call_Statement)\n-              and then Present (First_Named_Actual (Old_Node))\n-            then\n-               Adjust_Named_Associations (Old_Node, New_Node);\n-            end if;\n-\n-            --  Reset First_Real_Statement for Handled_Sequence_Of_Statements.\n-            --  The replacement mechanism applies to entities, and is not used\n-            --  here. Eventually we may need a more general graph-copying\n-            --  routine. For now, do a sequential search to find desired node.\n-\n-            if Nkind (Old_Node) = N_Handled_Sequence_Of_Statements\n-              and then Present (First_Real_Statement (Old_Node))\n-            then\n-               declare\n-                  Old_F  : constant Node_Id := First_Real_Statement (Old_Node);\n-                  N1, N2 : Node_Id;\n-\n-               begin\n-                  N1 := First (Statements (Old_Node));\n-                  N2 := First (Statements (New_Node));\n-\n-                  while N1 /= Old_F loop\n-                     Next (N1);\n-                     Next (N2);\n-                  end loop;\n-\n-                  Set_First_Real_Statement (New_Node, N2);\n-               end;\n-            end if;\n-         end if;\n-\n-         --  All done, return copied node\n-\n-         return New_Node;\n-      end Copy_Node_With_Replacement;\n-\n-      -----------------\n-      -- Visit_Elist --\n-      -----------------\n-\n-      procedure Visit_Elist (E : Elist_Id) is\n-         Elmt : Elmt_Id;\n-      begin\n-         if Present (E) then\n-            Elmt := First_Elmt (E);\n-\n-            while Elmt /= No_Elmt loop\n-               Visit_Node (Node (Elmt));\n-               Next_Elmt (Elmt);\n-            end loop;\n-         end if;\n-      end Visit_Elist;\n-\n-      -----------------\n-      -- Visit_Field --\n-      -----------------\n-\n-      procedure Visit_Field (F : Union_Id; N : Node_Id) is\n-      begin\n-         if F = Union_Id (Empty) then\n-            return;\n-\n-         elsif F in Node_Range then\n-\n-            --  Copy node if it is syntactic, i.e. its parent pointer is\n-            --  set to point to the field that referenced it (certain\n-            --  Itypes will also meet this criterion, which is fine, since\n-            --  these are clearly Itypes that do need to be copied, since\n-            --  we are copying their parent.)\n-\n-            if Parent (Node_Id (F)) = N then\n-               Visit_Node (Node_Id (F));\n-               return;\n-\n-            --  Another case, if we are pointing to an Itype, then we want\n-            --  to copy it if its associated node is somewhere in the tree\n-            --  being copied.\n-\n-            --  Note: the exclusion of self-referential copies is just an\n-            --  optimization, since the search of the already copied list\n-            --  would catch it, but it is a common case (Etype pointing\n-            --  to itself for an Itype that is a base type).\n-\n-            elsif Has_Extension (Node_Id (F))\n-              and then Is_Itype (Entity_Id (F))\n-              and then Node_Id (F) /= N\n-            then\n-               declare\n-                  P : Node_Id;\n-\n-               begin\n-                  P := Associated_Node_For_Itype (Node_Id (F));\n-                  while Present (P) loop\n-                     if P = Source then\n-                        Visit_Node (Node_Id (F));\n-                        return;\n-                     else\n-                        P := Parent (P);\n-                     end if;\n-                  end loop;\n-\n-                  --  An Itype whose parent is not being copied definitely\n-                  --  should NOT be copied, since it does not belong in any\n-                  --  sense to the copied subtree.\n-\n-                  return;\n-               end;\n-            end if;\n-\n-         elsif F in List_Range\n-           and then Parent (List_Id (F)) = N\n-         then\n-            Visit_List (List_Id (F));\n-            return;\n-         end if;\n-      end Visit_Field;\n-\n-      -----------------\n-      -- Visit_Itype --\n-      -----------------\n-\n-      --  Note: we are relying on far too much semantic knowledge in this\n-      --  routine, it really should just do a blind replacement of all\n-      --  fields, or at least a more blind replacement. For example, we\n-      --  do not deal with corresponding record types, and that works\n-      --  because we have no Itypes of task types, but nowhere is there\n-      --  a guarantee that this will always be the case. ???\n-\n-      procedure Visit_Itype (Old_Itype : Entity_Id) is\n-         New_Itype : Entity_Id;\n-         E         : Elmt_Id;\n-         Ent       : Entity_Id;\n-\n-      begin\n-         --  Itypes that describe the designated type of access to subprograms\n-         --  have the structure of subprogram declarations, with signatures,\n-         --  etc. Either we duplicate the signatures completely, or choose to\n-         --  share such itypes, which is fine because their elaboration will\n-         --  have no side effects. In any case, this is additional semantic\n-         --  information that seems awkward to have in atree.\n-\n-         if Ekind (Old_Itype) = E_Subprogram_Type then\n-            return;\n-         end if;\n-\n-         New_Itype := New_Copy (Old_Itype);\n-\n-         --  The new Itype has all the attributes of the old one, and\n-         --  we just copy the contents of the entity. However, the back-end\n-         --  needs different names for debugging purposes, so we create a\n-         --  new internal name for it in all cases.\n-\n-         --  Set_Chars (New_Itype, New_Internal_Name ('T'));\n-\n-         --  If our associated node is an entity that has already been copied,\n-         --  then set the associated node of the copy to point to the right\n-         --  copy. If we have copied an Itype that is itself the associated\n-         --  node of some previously copied Itype, then we set the right\n-         --  pointer in the other direction.\n-\n-         if Present (Actual_Map) then\n-\n-            --  Case of hash tables used\n-\n-            if NCT_Hash_Tables_Used then\n-\n-               Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n-\n-               if Present (Ent) then\n-                  Set_Associated_Node_For_Itype (New_Itype, Ent);\n-               end if;\n-\n-               Ent := NCT_Itype_Assoc.Get (Old_Itype);\n-               if Present (Ent) then\n-                  Set_Associated_Node_For_Itype (Ent, New_Itype);\n-\n-               --  If the hash table has no association for this Itype and\n-               --  its associated node, enter one now.\n-\n-               else\n-                  NCT_Itype_Assoc.Set\n-                    (Associated_Node_For_Itype (Old_Itype), New_Itype);\n-               end if;\n-\n-            --  Case of hash tables not used\n-\n-            else\n-               E := First_Elmt (Actual_Map);\n-               while Present (E) loop\n-                  if Associated_Node_For_Itype (Old_Itype) = Node (E) then\n-                     Set_Associated_Node_For_Itype\n-                       (New_Itype, Node (Next_Elmt (E)));\n-                  end if;\n-\n-                  if Is_Type (Node (E))\n-                    and then\n-                      Old_Itype = Associated_Node_For_Itype (Node (E))\n-                  then\n-                     Set_Associated_Node_For_Itype\n-                       (Node (Next_Elmt (E)), New_Itype);\n-                  end if;\n-\n-                  E := Next_Elmt (Next_Elmt (E));\n-               end loop;\n-            end if;\n-         end if;\n-\n-         if Present (Freeze_Node (New_Itype)) then\n-            Set_Is_Frozen (New_Itype, False);\n-            Set_Freeze_Node (New_Itype, Empty);\n-         end if;\n-\n-         --  Add new association to map\n-\n-         if No (Actual_Map) then\n-            Actual_Map := New_Elmt_List;\n-         end if;\n-\n-         Append_Elmt (Old_Itype, Actual_Map);\n-         Append_Elmt (New_Itype, Actual_Map);\n-\n-         if NCT_Hash_Tables_Used then\n-            NCT_Assoc.Set (Old_Itype, New_Itype);\n-\n-         else\n-            NCT_Table_Entries := NCT_Table_Entries + 1;\n-\n-            if NCT_Table_Entries > NCT_Hash_Threshhold then\n-               Build_NCT_Hash_Tables;\n-            end if;\n-         end if;\n-\n-         --  If a record subtype is simply copied, the entity list will be\n-         --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n-\n-         if Ekind (Old_Itype) = E_Record_Subtype\n-           or else Ekind (Old_Itype) = E_Class_Wide_Subtype\n-         then\n-            Set_Cloned_Subtype (New_Itype, Old_Itype);\n-         end if;\n-\n-         --  Visit descendents that eventually get copied\n-\n-         Visit_Field (Union_Id (Etype (Old_Itype)), Old_Itype);\n-\n-         if Is_Discrete_Type (Old_Itype) then\n-            Visit_Field (Union_Id (Scalar_Range (Old_Itype)), Old_Itype);\n-\n-         elsif Has_Discriminants (Base_Type (Old_Itype)) then\n-            --  ??? This should involve call to Visit_Field\n-            Visit_Elist (Discriminant_Constraint (Old_Itype));\n-\n-         elsif Is_Array_Type (Old_Itype) then\n-            if Present (First_Index (Old_Itype)) then\n-               Visit_Field (Union_Id (List_Containing\n-                                (First_Index (Old_Itype))),\n-                            Old_Itype);\n-            end if;\n-\n-            if Is_Packed (Old_Itype) then\n-               Visit_Field (Union_Id (Packed_Array_Type (Old_Itype)),\n-                            Old_Itype);\n-            end if;\n-         end if;\n-         Get_Name_String (Chars (Old_Itype));\n-         Add_Char_To_Name_Buffer ('c');\n-         Add_Nat_To_Name_Buffer (Int (Associated_Node_For_Itype (New_Itype)));\n-         Set_Chars (New_Itype, Name_Enter);\n-      end Visit_Itype;\n-\n-      ----------------\n-      -- Visit_List --\n-      ----------------\n-\n-      procedure Visit_List (L : List_Id) is\n-         N : Node_Id;\n-      begin\n-         if L /= No_List then\n-            N := First (L);\n-\n-            while Present (N) loop\n-               Visit_Node (N);\n-               Next (N);\n-            end loop;\n-         end if;\n-      end Visit_List;\n-\n-      ----------------\n-      -- Visit_Node --\n-      ----------------\n-\n-      procedure Visit_Node (N : Node_Or_Entity_Id) is\n-\n-      --  Start of processing for Visit_Node\n-\n-      begin\n-         --  Handle case of an Itype, which must be copied\n-\n-         if Has_Extension (N)\n-           and then Is_Itype (N)\n-         then\n-            --  Nothing to do if already in the list. This can happen with an\n-            --  Itype entity that appears more than once in the tree.\n-            --  Note that we do not want to visit descendents in this case.\n-\n-            --  Test for already in list when hash table is used\n-\n-            if NCT_Hash_Tables_Used then\n-               if Present (NCT_Assoc.Get (Entity_Id (N))) then\n-                  return;\n-               end if;\n-\n-            --  Test for already in list when hash table not used\n-\n-            else\n-               declare\n-                  E : Elmt_Id;\n-               begin\n-                  if Present (Actual_Map) then\n-                     E := First_Elmt (Actual_Map);\n-                     while Present (E) loop\n-                        if Node (E) = N then\n-                           return;\n-                        else\n-                           E := Next_Elmt (Next_Elmt (E));\n-                        end if;\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n-\n-            Visit_Itype (N);\n-         end if;\n-\n-         --  Visit descendents\n-\n-         Visit_Field (Field1 (N), N);\n-         Visit_Field (Field2 (N), N);\n-         Visit_Field (Field3 (N), N);\n-         Visit_Field (Field4 (N), N);\n-         Visit_Field (Field5 (N), N);\n-      end Visit_Node;\n-\n-   --  Start of processing for New_Copy_Tree\n-\n-   begin\n-      Actual_Map := Map;\n-\n-      --  See if we should use hash table\n-\n-      if No (Actual_Map) then\n-         NCT_Hash_Tables_Used := False;\n-\n-      else\n-         declare\n-            Elmt : Elmt_Id;\n-\n-         begin\n-            NCT_Table_Entries := 0;\n-\n-            Elmt := First_Elmt (Actual_Map);\n-            while Present (Elmt) loop\n-               NCT_Table_Entries := NCT_Table_Entries + 1;\n-               Next_Elmt (Elmt);\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            if NCT_Table_Entries > NCT_Hash_Threshhold then\n-               Build_NCT_Hash_Tables;\n-            else\n-               NCT_Hash_Tables_Used := False;\n-            end if;\n-         end;\n-      end if;\n-\n-      --  Hash table set up if required, now start phase one by visiting\n-      --  top node (we will recursively visit the descendents).\n-\n-      Visit_Node (Source);\n-\n-      --  Now the second phase of the copy can start. First we process\n-      --  all the mapped entities, copying their descendents.\n-\n-      if Present (Actual_Map) then\n-         declare\n-            Elmt      : Elmt_Id;\n-            New_Itype : Entity_Id;\n-         begin\n-            Elmt := First_Elmt (Actual_Map);\n-            while Present (Elmt) loop\n-               Next_Elmt (Elmt);\n-               New_Itype := Node (Elmt);\n-               Copy_Itype_With_Replacement (New_Itype);\n-               Next_Elmt (Elmt);\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Now we can copy the actual tree\n-\n-      return Copy_Node_With_Replacement (Source);\n-   end New_Copy_Tree1;\n-\n    ----------------\n    -- New_Entity --\n    ----------------"}, {"sha": "ae6a1ac7588e8d252df6e9aa2a18debd9d2dfd69", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -430,46 +430,6 @@ package Atree is\n    --  Source to be Empty, in which case Relocate_Node simply returns\n    --  Empty as the result.\n \n-   function New_Copy_Tree1\n-     (Source    : Node_Id;\n-      Map       : Elist_Id   := No_Elist;\n-      New_Sloc  : Source_Ptr := No_Location;\n-      New_Scope : Entity_Id  := Empty) return Node_Id;\n-   --  Given a node that is the root of a subtree, Copy_Tree copies the entire\n-   --  syntactic subtree, including recursively any descendents whose parent\n-   --  field references a copied node (descendents not linked to a copied node\n-   --  by the parent field are not copied, instead the copied tree references\n-   --  the same descendent as the original in this case, which is appropriate\n-   --  for non-syntactic fields such as Etype). The parent pointers in the\n-   --  copy are properly set. Copy_Tree (Empty/Error) returns Empty/Error.\n-   --  The one exception to the rule of not copying semantic fields is that\n-   --  any implicit types attached to the subtree are duplicated, so that\n-   --  the copy contains a distinct set of implicit type entities. The Map\n-   --  argument, if set to a non-empty Elist, specifies a set of mappings\n-   --  to be applied to entities in the tree. The map has the form:\n-   --\n-   --     old entity 1\n-   --     new entity to replace references to entity 1\n-   --     old entity 2\n-   --     new entity to replace references to entity 2\n-   --     ...\n-   --\n-   --  The call destroys the contents of Map in this case\n-   --\n-   --  The parameter New_Sloc, if set to a value other than No_Location, is\n-   --  used as the Sloc value for all nodes in the new copy. If New_Sloc is\n-   --  set to its default value No_Location, then the Sloc values of the\n-   --  nodes in the copy are simply copied from the corresponding original.\n-   --\n-   --  The Comes_From_Source indication is unchanged if New_Sloc is set to\n-   --  the default No_Location value, but is reset if New_Sloc is given, since\n-   --  in this case the result clearly is neither a source node or an exact\n-   --  copy of a source node.\n-   --\n-   --  The parameter New_Scope, if set to a value other than Empty, is the\n-   --  value to use as the Scope for any Itypes that are copied. The most\n-   --  typical value for this parameter, if given, is Current_Scope.\n-\n    function Copy_Separate_Tree (Source : Node_Id) return Node_Id;\n    --  Given a node that is the root of a subtree, Copy_Separate_Tree copies\n    --  the entire syntactic subtree, including recursively any descendants"}, {"sha": "874350bc07d1bed249698b062cd2678a9d9eb65f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -2822,7 +2822,7 @@ package body Exp_Ch4 is\n \n       --    There are nine or fewer retained (non-null) operands\n \n-      --    The optimization level is -O0 or -Os\n+      --    The optimization level is -O0\n \n       --    The corresponding System.Concat_n.Str_Concat_n routine is\n       --    available in the run time.\n@@ -2835,9 +2835,7 @@ package body Exp_Ch4 is\n \n       if Atyp = Standard_String\n         and then NN in 2 .. 9\n-        and then (Opt.Optimization_Level = 0\n-                   or else Opt.Optimize_Size /= 0\n-                   or else Debug_Flag_Dot_CC)\n+        and then (Opt.Optimization_Level = 0 or else Debug_Flag_Dot_CC)\n         and then not Debug_Flag_Dot_C\n       then\n          declare"}, {"sha": "ef51f709857db18c194f3286c3701ae0f0f4517f", "filename": "gcc/ada/initialize.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Finitialize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Finitialize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finitialize.c?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -81,6 +81,22 @@ __gnat_initialize (void *eh)\n       given that we have set Max_Digits etc with this in mind */\n    __gnat_init_float ();\n \n+#ifdef GNAT_UNICODE_SUPPORT\n+   /* Set current code page for filenames handling. */\n+   {\n+     char *codepage = getenv (\"GNAT_CODE_PAGE\");\n+\n+     /* Default code page is UTF-8.  */\n+     CurrentCodePage = CP_UTF8;\n+\n+     if (codepage != NULL)\n+       if (strcmp (codepage, \"CP_ACP\") == 0)\n+\t CurrentCodePage = CP_ACP;\n+       else if (strcmp (codepage, \"CP_UTF8\") == 0)\n+\t CurrentCodePage = CP_UTF8;\n+   }\n+#endif\n+\n    /* Adjust gnat_argv to support Unicode characters. */\n    {\n      char arg_utf8[MAX_PATH];\n@@ -97,7 +113,7 @@ __gnat_initialize (void *eh)\n \n \t for (k=0; k<wargc; k++)\n \t   {\n-\t     WS2SU (arg_utf8, wargv[k], MAX_PATH);\n+\t     WS2SC (arg_utf8, wargv[k], MAX_PATH);\n \t     gnat_argv[k] = (char *) xmalloc (strlen (arg_utf8) + 1);\n \t     strcpy (gnat_argv[k], arg_utf8);\n \t   }"}, {"sha": "c4034c0033dd0ee869813e541db8164f129402f8", "filename": "gcc/ada/mingw32.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmingw32.h?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -62,6 +62,7 @@\n #endif\n \n #include <tchar.h>\n+#include <windows.h>\n \n /* After including this file it is possible to use the character t as prefix\n    to routines. If GNAT_UNICODE_SUPPORT is defined then the unicode enabled\n@@ -71,10 +72,22 @@\n    the proper translations using the UTF-8 encoding.  */\n \n #ifdef GNAT_UNICODE_SUPPORT\n+\n+extern UINT CurrentCodePage;\n+\n+/*  Macros to convert to/from the code page speficied in CurrentCodePage.  */\n+#define S2WSC(wstr,str,len) \\\n+   MultiByteToWideChar (CurrentCodePage,0,str,-1,wstr,len)\n+#define WS2SC(str,wstr,len) \\\n+   WideCharToMultiByte (CurrentCodePage,0,wstr,-1,str,len,NULL,NULL)\n+\n+/*  Macros to convert to/from UTF-8 code page.  */\n #define S2WSU(wstr,str,len) \\\n    MultiByteToWideChar (CP_UTF8,0,str,-1,wstr,len)\n #define WS2SU(str,wstr,len) \\\n    WideCharToMultiByte (CP_UTF8,0,wstr,-1,str,len,NULL,NULL)\n+\n+/*  Macros to convert to/from Windows default code page.  */\n #define S2WS(wstr,str,len) \\\n    MultiByteToWideChar (CP_ACP,0,str,-1,wstr,len)\n #define WS2S(str,wstr,len) \\"}, {"sha": "debd8067779bd982aa9b65e1ce49f1f96de9a9fc", "filename": "gcc/ada/mkdir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fmkdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fmkdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmkdir.c?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -65,7 +65,7 @@ __gnat_mkdir (char *dir_name)\n #elif defined (__MINGW32__)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  S2WSU (wname, dir_name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, dir_name, GNAT_MAX_PATH_LEN + 2);\n   return _tmkdir (wname);\n #else\n   return mkdir (dir_name, S_IRWXU | S_IRWXG | S_IRWXO);"}, {"sha": "5a9902dd65702b09aca27f66f059c3898c801768", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -55,8 +55,8 @@ package System.CRTL is\n \n    type size_t is mod 2 ** Standard'Address_Size;\n \n-   type Filename_Encoding is (UTF8, ASCII_8bits);\n-   for Filename_Encoding use (UTF8 => 0, ASCII_8bits => 1);\n+   type Filename_Encoding is (UTF8, ASCII_8bits, Unspecified);\n+   for Filename_Encoding use (UTF8 => 0, ASCII_8bits => 1, Unspecified => 2);\n    pragma Convention (C, Filename_Encoding);\n    --  Describes the filename's encoding\n \n@@ -90,7 +90,7 @@ package System.CRTL is\n    function fopen\n      (filename : chars;\n       mode     : chars;\n-      encoding : Filename_Encoding := UTF8) return FILEs;\n+      encoding : Filename_Encoding := Unspecified) return FILEs;\n    pragma Import (C, fopen, \"__gnat_fopen\");\n \n    function fputc (C : int; stream : FILEs) return int;\n@@ -106,7 +106,7 @@ package System.CRTL is\n      (filename : chars;\n       mode     : chars;\n       stream   : FILEs;\n-      encoding : Filename_Encoding := UTF8) return FILEs;\n+      encoding : Filename_Encoding := Unspecified) return FILEs;\n    pragma Import (C, freopen, \"__gnat_freopen\");\n \n    function fseek"}, {"sha": "b3084775ff1f3f641c7e5772d0860bd8aec827a2", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=ffec8e81da21c8fd1726d4e5dbf4800aa0fe9e88", "patch": "@@ -809,7 +809,7 @@ package body System.File_IO is\n          Form_Parameter (Formstr, \"encoding\", V1, V2);\n \n          if V1 = 0 then\n-            Encoding := System.CRTL.UTF8;\n+            Encoding := System.CRTL.Unspecified;\n \n          elsif Formstr (V1 .. V2) = \"utf8\" then\n             Encoding := System.CRTL.UTF8;"}]}