{"sha": "4b2a6628644b2ce15d877c1e85d14e314965a296", "node_id": "C_kwDOANBUbNoAKDRiMmE2NjI4NjQ0YjJjZTE1ZDg3N2MxZTg1ZDE0ZTMxNDk2NWEyOTY", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-05-08T21:36:34Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-05-09T19:56:52Z"}, "message": "c++: Implement P2324R2, labels at the end of compound-stmts [PR103539]\n\nThis patch implements C++23 <https://wg21.link/p2324r2>, which allows\nlabels at the end of a compound statement.   Its C FE counterpart was\nalready implemented in r11-4813.\n\nIn cp_parser_statement I rely on in_compound to determine whether we're\nin a compound-statement, so that the patch doesn't accidentally allow\n\n  void fn(int c) {\n    if (c)\n  label:\n  }\n\nStrangely, in_compound was reset after seeing a label (this is tested in\nc-c++-common/gomp/pr63326.c), so I've made a modifiable copy specific\nfor OpenMP #pragma purposes.\n\n\tPR c++/103539\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_statement): Constify the in_compound parameter.\n\tCreate a modifiable copy.  Allow labels at the end of compound\n\tstatements.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp23/label1.C: New test.\n\t* g++.dg/cpp23/label2.C: New test.", "tree": {"sha": "93a5aedf0e767c9074643cee8c8e02a69cf1f689", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a5aedf0e767c9074643cee8c8e02a69cf1f689"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b2a6628644b2ce15d877c1e85d14e314965a296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2a6628644b2ce15d877c1e85d14e314965a296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b2a6628644b2ce15d877c1e85d14e314965a296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b2a6628644b2ce15d877c1e85d14e314965a296/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c97f7fd2382aa77f36567207e949447db90a1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c97f7fd2382aa77f36567207e949447db90a1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c97f7fd2382aa77f36567207e949447db90a1fb"}], "stats": {"total": 184, "additions": 175, "deletions": 9}, "files": [{"sha": "84b45cf47ecf4ca7460f24fd6cbc518a5f8dc07f", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=4b2a6628644b2ce15d877c1e85d14e314965a296", "patch": "@@ -12174,7 +12174,7 @@ cp_parser_handle_directive_omp_attributes (cp_parser *parser, tree *pattrs,\n      atomic-statement\n \n   IN_COMPOUND is true when the statement is nested inside a\n-  cp_parser_compound_statement; this matters for certain pragmas.\n+  cp_parser_compound_statement.\n \n   If IF_P is not NULL, *IF_P is set to indicate whether the statement\n   is a (possibly labeled) if statement which is not enclosed in braces\n@@ -12184,14 +12184,17 @@ cp_parser_handle_directive_omp_attributes (cp_parser *parser, tree *pattrs,\n \n static void\n cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n-\t\t     bool in_compound, bool *if_p, vec<tree> *chain,\n+\t\t     const bool in_compound, bool *if_p, vec<tree> *chain,\n \t\t     location_t *loc_after_labels)\n {\n   tree statement, std_attrs = NULL_TREE;\n   cp_token *token;\n   location_t statement_location, attrs_loc;\n   bool in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n   bool has_std_attrs;\n+  /* A copy of IN_COMPOUND which is set to false after seeing a label.\n+     This matters for certain pragmas.  */\n+  bool in_compound_for_pragma = in_compound;\n \n  restart:\n   if (if_p != NULL)\n@@ -12286,7 +12289,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t     Parse the label, and then use tail recursion to parse\n \t     the statement.  */\n \t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n-\t  in_compound = false;\n+\t  in_compound_for_pragma = false;\n \t  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n \t  goto restart;\n \n@@ -12370,7 +12373,21 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t     the statement.  */\n \n \t  cp_parser_label_for_labeled_statement (parser, std_attrs);\n-\t  in_compound = false;\n+\n+\t  /* If there's no statement, it's not a labeled-statement, just\n+\t     a label.  That's allowed in C++23, but only if we're at the\n+\t     end of a compound-statement.  */\n+\t  if (in_compound\n+\t      && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\t    {\n+\t      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t      if (cxx_dialect < cxx23)\n+\t\tpedwarn (loc, OPT_Wc__23_extensions,\n+\t\t\t \"label at end of compound statement only available \"\n+\t\t\t \"with %<-std=c++2b%> or %<-std=gnu++2b%>\");\n+\t      return;\n+\t    }\n+\t  in_compound_for_pragma = false;\n \t  in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n \t  goto restart;\n \t}\n@@ -12393,7 +12410,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t the context of a compound, accept the pragma as a \"statement\" and\n \t return so that we can check for a close brace.  Otherwise we\n \t require a real statement and must go back and read one.  */\n-      if (in_compound)\n+      if (in_compound_for_pragma)\n \tcp_parser_pragma (parser, pragma_compound, if_p);\n       else if (!cp_parser_pragma (parser, pragma_stmt, if_p))\n \tdo_restart = true;\n@@ -12544,9 +12561,13 @@ attr_chainon (tree attrs, tree attr)\n \n /* Parse the label for a labeled-statement, i.e.\n \n-   identifier :\n-   case constant-expression :\n-   default :\n+   label:\n+     attribute-specifier-seq[opt] identifier :\n+     attribute-specifier-seq[opt] case constant-expression :\n+     attribute-specifier-seq[opt] default :\n+\n+   labeled-statement:\n+     label statement\n \n    GNU Extension:\n    case constant-expression ... constant-expression : statement\n@@ -12766,7 +12787,11 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n /* Parse a compound-statement.\n \n    compound-statement:\n-     { statement-seq [opt] }\n+     { statement-seq [opt] label-seq [opt] }\n+\n+   label-seq:\n+     label\n+     label-seq label\n \n    GNU extension:\n "}, {"sha": "14657652f4a1b743ec1235158d2ac8f9eed30b8b", "filename": "gcc/testsuite/g++.dg/cpp23/label1.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel1.C?ref=4b2a6628644b2ce15d877c1e85d14e314965a296", "patch": "@@ -0,0 +1,89 @@\n+// P2324R2 - Labels at the end of compound statements\n+// PR c++/103539\n+// { dg-do compile }\n+// Test good cases.\n+\n+void\n+p2324 ()\n+{\n+first:\n+  int x; \n+second:\n+  x = 1;\n+last:\n+} // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+\n+void\n+fn1 ()\n+{\n+  l1:\n+} // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+\n+void\n+fn2 ()\n+{\n+  if (1)\n+    {\n+l1:\n+    } // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+}\n+\n+void\n+fn3 ()\n+{\n+  {\n+    {\n+label:\n+    } // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+  }\n+}\n+\n+void\n+fn4 ()\n+{\n+  switch (1)\n+    {\n+lab:\n+    } // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+}\n+\n+void\n+fn5 ()\n+{\n+l1:\n+l2:\n+l3:\n+} // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+\n+void\n+fn6 ()\n+{\n+  ;\n+l1:\n+l2:\n+l3:\n+} // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+\n+\n+#if __cplusplus >= 201103L\n+void\n+fn7 ()\n+{\n+  auto l = [](){\n+    lab:\n+  }; // { dg-error \"label at end of compound statement only available with\" \"\" { target { c++20_down && c++11 } } }\n+}\n+#endif\n+\n+void\n+fn8 ()\n+{\n+  try\n+    {\n+lab1:\n+    } // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+  catch (int)\n+    {\n+lab2:\n+    } // { dg-error \"label at end of compound statement only available with\" \"\" { target c++20_down } }\n+}"}, {"sha": "3457e71ace2e3568faf60035a1d38ff99d37c68a", "filename": "gcc/testsuite/g++.dg/cpp23/label2.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b2a6628644b2ce15d877c1e85d14e314965a296/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Flabel2.C?ref=4b2a6628644b2ce15d877c1e85d14e314965a296", "patch": "@@ -0,0 +1,52 @@\n+// P2324R2 - Labels at the end of compound statements\n+// PR c++/103539\n+// { dg-do compile { target c++23 } }\n+// Test bad cases.\n+\n+void\n+fn1 ()\n+{\n+  /* A selection-statement wants a statement, but a mere label isn't a statement.  */\n+  if (1)\n+lab:\n+} // { dg-error \"expected\" }\n+\n+void\n+fn2 ()\n+{\n+  if (0)\n+    {\n+    }\n+  else\n+lab:\n+} // { dg-error \"expected\" }\n+\n+void\n+fn3 ()\n+{\n+  do\n+lab:\n+  while (0); // { dg-error \"expected\" }\n+} // { dg-error \"expected\" }\n+\n+void\n+fn4 ()\n+{\n+  for (;;)\n+lab:\n+} // { dg-error \"expected\" }\n+\n+void\n+fn5 ()\n+{\n+  switch (1)\n+  lab:\n+} // { dg-error \"expected\" }\n+\n+void\n+fn6 ()\n+{\n+  if (1)\n+lab1:\n+lab2:\n+} // { dg-error \"expected\" }"}]}