{"sha": "513d5564225f8baa2ddeafde9edb9e10b62e30ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEzZDU1NjQyMjVmOGJhYTJkZGVhZmRlOWVkYjllMTBiNjJlMzBjZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-10-06T14:14:14Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-10-06T14:14:14Z"}, "message": "Add sanopt support for UBSAN_PTR.\n\n2017-10-06  Martin Liska  <mliska@suse.cz>\n\n\t* sanopt.c (struct sanopt_tree_triplet_hash): Remove inline\n\tkeyword for member functions.\n\t(struct sanopt_tree_couple): New struct.\n\t(struct sanopt_tree_couple_hash): New function.\n\t(struct sanopt_ctx): Add new hash_map.\n\t(has_dominating_ubsan_ptr_check): New function.\n\t(record_ubsan_ptr_check_stmt): Likewise.\n\t(maybe_optimize_ubsan_ptr_ifn): Likewise.\n\t(sanopt_optimize_walker): Handle IFN_UBSAN_PTR.\n\t(pass_sanopt::execute): Handle also SANITIZE_POINTER_OVERFLOW.\n2017-10-06  Martin Liska  <mliska@suse.cz>\n\n\t* c-c++-common/ubsan/ptr-overflow-sanitization-1.c: New test.\n\nFrom-SVN: r253492", "tree": {"sha": "520b8fb34932f46c3db23ec5f105b3abe2443dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/520b8fb34932f46c3db23ec5f105b3abe2443dff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/513d5564225f8baa2ddeafde9edb9e10b62e30ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513d5564225f8baa2ddeafde9edb9e10b62e30ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/513d5564225f8baa2ddeafde9edb9e10b62e30ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513d5564225f8baa2ddeafde9edb9e10b62e30ce/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "549d24e9f70e33aac90ddaebf95a63409b058327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549d24e9f70e33aac90ddaebf95a63409b058327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/549d24e9f70e33aac90ddaebf95a63409b058327"}], "stats": {"total": 365, "additions": 352, "deletions": 13}, "files": [{"sha": "b56f7e637e08f13bba4e692f274aca2a48bdad3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=513d5564225f8baa2ddeafde9edb9e10b62e30ce", "patch": "@@ -1,3 +1,16 @@\n+2017-10-06  Martin Liska  <mliska@suse.cz>\n+\n+\t* sanopt.c (struct sanopt_tree_triplet_hash): Remove inline\n+\tkeyword for member functions.\n+\t(struct sanopt_tree_couple): New struct.\n+\t(struct sanopt_tree_couple_hash): New function.\n+\t(struct sanopt_ctx): Add new hash_map.\n+\t(has_dominating_ubsan_ptr_check): New function.\n+\t(record_ubsan_ptr_check_stmt): Likewise.\n+\t(maybe_optimize_ubsan_ptr_ifn): Likewise.\n+\t(sanopt_optimize_walker): Handle IFN_UBSAN_PTR.\n+\t(pass_sanopt::execute): Handle also SANITIZE_POINTER_OVERFLOW.\n+\n 2017-10-06  Sudakshina Das  <sudi.das@arm.com>\n \n \tPR target/82440"}, {"sha": "997bcfd3df71fc058524e5456caac1314066afea", "filename": "gcc/sanopt.c", "status": "modified", "additions": 255, "deletions": 13, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=513d5564225f8baa2ddeafde9edb9e10b62e30ce", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n+#include \"varasm.h\"\n \n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n@@ -105,7 +106,7 @@ struct sanopt_tree_triplet_hash : typed_noop_remove <sanopt_tree_triplet>\n   typedef sanopt_tree_triplet value_type;\n   typedef sanopt_tree_triplet compare_type;\n \n-  static inline hashval_t\n+  static hashval_t\n   hash (const sanopt_tree_triplet &ref)\n   {\n     inchash::hash hstate (0);\n@@ -115,39 +116,94 @@ struct sanopt_tree_triplet_hash : typed_noop_remove <sanopt_tree_triplet>\n     return hstate.end ();\n   }\n \n-  static inline bool\n+  static bool\n   equal (const sanopt_tree_triplet &ref1, const sanopt_tree_triplet &ref2)\n   {\n     return operand_equal_p (ref1.t1, ref2.t1, 0)\n \t   && operand_equal_p (ref1.t2, ref2.t2, 0)\n \t   && operand_equal_p (ref1.t3, ref2.t3, 0);\n   }\n \n-  static inline void\n+  static void\n   mark_deleted (sanopt_tree_triplet &ref)\n   {\n     ref.t1 = reinterpret_cast<tree> (1);\n   }\n \n-  static inline void\n+  static void\n   mark_empty (sanopt_tree_triplet &ref)\n   {\n     ref.t1 = NULL;\n   }\n \n-  static inline bool\n+  static bool\n   is_deleted (const sanopt_tree_triplet &ref)\n   {\n-    return ref.t1 == (void *) 1;\n+    return ref.t1 == reinterpret_cast<tree> (1);\n   }\n \n-  static inline bool\n+  static bool\n   is_empty (const sanopt_tree_triplet &ref)\n   {\n     return ref.t1 == NULL;\n   }\n };\n \n+/* Tree couple for ptr_check_map.  */\n+struct sanopt_tree_couple\n+{\n+  tree ptr;\n+  bool pos_p;\n+};\n+\n+/* Traits class for tree triplet hash maps below.  */\n+\n+struct sanopt_tree_couple_hash : typed_noop_remove <sanopt_tree_couple>\n+{\n+  typedef sanopt_tree_couple value_type;\n+  typedef sanopt_tree_couple compare_type;\n+\n+  static hashval_t\n+  hash (const sanopt_tree_couple &ref)\n+  {\n+    inchash::hash hstate (0);\n+    inchash::add_expr (ref.ptr, hstate);\n+    hstate.add_int (ref.pos_p);\n+    return hstate.end ();\n+  }\n+\n+  static bool\n+  equal (const sanopt_tree_couple &ref1, const sanopt_tree_couple &ref2)\n+  {\n+    return operand_equal_p (ref1.ptr, ref2.ptr, 0)\n+\t   && ref1.pos_p == ref2.pos_p;\n+  }\n+\n+  static void\n+  mark_deleted (sanopt_tree_couple &ref)\n+  {\n+    ref.ptr = reinterpret_cast<tree> (1);\n+  }\n+\n+  static void\n+  mark_empty (sanopt_tree_couple &ref)\n+  {\n+    ref.ptr = NULL;\n+  }\n+\n+  static bool\n+  is_deleted (const sanopt_tree_couple &ref)\n+  {\n+    return ref.ptr == reinterpret_cast<tree> (1);\n+  }\n+\n+  static bool\n+  is_empty (const sanopt_tree_couple &ref)\n+  {\n+    return ref.ptr == NULL;\n+  }\n+};\n+\n /* This is used to carry various hash maps and variables used\n    in sanopt_optimize_walker.  */\n \n@@ -166,6 +222,10 @@ struct sanopt_ctx\n      that virtual table pointer.  */\n   hash_map<sanopt_tree_triplet_hash, auto_vec<gimple *> > vptr_check_map;\n \n+  /* This map maps a couple (tree and boolean) to a vector of UBSAN_PTR\n+     call statements that check that pointer overflow.  */\n+  hash_map<sanopt_tree_couple_hash, auto_vec<gimple *> > ptr_check_map;\n+\n   /* Number of IFN_ASAN_CHECK statements.  */\n   int asan_num_accesses;\n \n@@ -344,6 +404,179 @@ maybe_optimize_ubsan_null_ifn (struct sanopt_ctx *ctx, gimple *stmt)\n   return remove;\n }\n \n+/* Return true when pointer PTR for a given CUR_OFFSET is already sanitized\n+   in a given sanitization context CTX.  */\n+\n+static bool\n+has_dominating_ubsan_ptr_check (sanopt_ctx *ctx, tree ptr,\n+\t\t\t\toffset_int &cur_offset)\n+{\n+  bool pos_p = !wi::neg_p (cur_offset);\n+  sanopt_tree_couple couple;\n+  couple.ptr = ptr;\n+  couple.pos_p = pos_p;\n+\n+  auto_vec<gimple *> &v = ctx->ptr_check_map.get_or_insert (couple);\n+  gimple *g = maybe_get_dominating_check (v);\n+  if (!g)\n+    return false;\n+\n+  /* We already have recorded a UBSAN_PTR check for this pointer.  Perhaps we\n+     can drop this one.  But only if this check doesn't specify larger offset.\n+     */\n+  tree offset = gimple_call_arg (g, 1);\n+  gcc_assert (TREE_CODE (offset) == INTEGER_CST);\n+  offset_int ooffset = wi::sext (wi::to_offset (offset), POINTER_SIZE);\n+\n+  if (pos_p)\n+    {\n+      if (wi::les_p (cur_offset, ooffset))\n+\treturn true;\n+    }\n+  else if (!pos_p && wi::les_p (ooffset, cur_offset))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Record UBSAN_PTR check of given context CTX.  Register pointer PTR on\n+   a given OFFSET that it's handled by GIMPLE STMT.  */\n+\n+static void\n+record_ubsan_ptr_check_stmt (sanopt_ctx *ctx, gimple *stmt, tree ptr,\n+\t\t\t     const offset_int &offset)\n+{\n+  sanopt_tree_couple couple;\n+  couple.ptr = ptr;\n+  couple.pos_p = !wi::neg_p (offset);\n+\n+  auto_vec<gimple *> &v = ctx->ptr_check_map.get_or_insert (couple);\n+  v.safe_push (stmt);\n+}\n+\n+/* Optimize away redundant UBSAN_PTR calls.  */\n+\n+static bool\n+maybe_optimize_ubsan_ptr_ifn (sanopt_ctx *ctx, gimple *stmt)\n+{\n+  HOST_WIDE_INT bitsize, bitpos;\n+  machine_mode mode;\n+  int volatilep = 0, reversep, unsignedp = 0;\n+  tree offset;\n+\n+  gcc_assert (gimple_call_num_args (stmt) == 2);\n+  tree ptr = gimple_call_arg (stmt, 0);\n+  tree off = gimple_call_arg (stmt, 1);\n+\n+  if (TREE_CODE (off) != INTEGER_CST)\n+    return false;\n+\n+  if (integer_zerop (off))\n+    return true;\n+\n+  offset_int cur_offset = wi::sext (wi::to_offset (off), POINTER_SIZE);\n+  if (has_dominating_ubsan_ptr_check (ctx, ptr, cur_offset))\n+    return true;\n+\n+  tree base = ptr;\n+  if (TREE_CODE (base) == ADDR_EXPR)\n+    {\n+      base = TREE_OPERAND (base, 0);\n+\n+      base = get_inner_reference (base, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t  &unsignedp, &reversep, &volatilep);\n+      if (offset == NULL_TREE && DECL_P (base))\n+\t{\n+\t  gcc_assert (!DECL_REGISTER (base));\n+\t  offset_int expr_offset = bitpos / BITS_PER_UNIT;\n+\t  offset_int total_offset = expr_offset + cur_offset;\n+\t  if (total_offset != wi::sext (total_offset, POINTER_SIZE))\n+\t    {\n+\t      record_ubsan_ptr_check_stmt (ctx, stmt, ptr, cur_offset);\n+\t      return false;\n+\t    }\n+\n+\t  /* If BASE is a fixed size automatic variable or\n+\t     global variable defined in the current TU, we don't have\n+\t     to instrument anything if offset is within address\n+\t     of the variable.  */\n+\t  if ((VAR_P (base)\n+\t       || TREE_CODE (base) == PARM_DECL\n+\t       || TREE_CODE (base) == RESULT_DECL)\n+\t      && DECL_SIZE_UNIT (base)\n+\t      && TREE_CODE (DECL_SIZE_UNIT (base)) == INTEGER_CST\n+\t      && (!is_global_var (base) || decl_binds_to_current_def_p (base)))\n+\t    {\n+\t      offset_int base_size = wi::to_offset (DECL_SIZE_UNIT (base));\n+\t      if (bitpos >= 0\n+\t\t  && wi::les_p (total_offset, base_size))\n+\t\t{\n+\t\t  if (!wi::neg_p (total_offset)\n+\t\t      && wi::les_p (total_offset, base_size))\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\n+\t  /* Following expression: UBSAN_PTR (&MEM_REF[ptr + x], y) can be\n+\t     handled as follows:\n+\n+\t     1) sign (x) == sign (y), then check for dominating check of (x + y)\n+\t     2) sign (x) != sign (y), then first check if we have a dominating\n+\t\tcheck for ptr + x.  If so, then we have 2 situations:\n+\t\ta) sign (x) == sign (x + y), here we are done, example:\n+\t\t   UBSAN_PTR (&MEM_REF[ptr + 100], -50)\n+\t\tb) check for dominating check of ptr + x + y.\n+\t     */\n+\n+\t  bool sign_cur_offset = !wi::neg_p (cur_offset);\n+\t  bool sign_expr_offset = bitpos >= 0;\n+\n+\t  tree base_addr\n+\t    = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (base)), base);\n+\n+\t  bool add = false;\n+\t  if (sign_cur_offset == sign_expr_offset)\n+\t    {\n+\t      if (has_dominating_ubsan_ptr_check (ctx, base_addr, total_offset))\n+\t\treturn true;\n+\t      else\n+\t\tadd = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!has_dominating_ubsan_ptr_check (ctx, base_addr, expr_offset))\n+\t\t; /* Don't record base_addr + expr_offset, it's not a guarding\n+\t\t     check.  */\n+\t      else\n+\t\t{\n+\t\t  bool sign_total_offset = !wi::neg_p (total_offset);\n+\t\t  if (sign_expr_offset == sign_total_offset)\n+\t\t    return true;\n+\t\t  else\n+\t\t    {\n+\t\t      if (has_dominating_ubsan_ptr_check (ctx, base_addr,\n+\t\t\t\t\t\t\t  total_offset))\n+\t\t\treturn true;\n+\t\t      else\n+\t\t\tadd = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Record a new dominating check for base_addr + total_offset.  */\n+\t  if (add && !operand_equal_p (base, base_addr, 0))\n+\t    record_ubsan_ptr_check_stmt (ctx, stmt, base_addr,\n+\t\t\t\t\t total_offset);\n+\t}\n+    }\n+\n+  /* For this PTR we don't have any UBSAN_PTR stmts recorded, so there's\n+     nothing to optimize yet.  */\n+  record_ubsan_ptr_check_stmt (ctx, stmt, ptr, cur_offset);\n+\n+  return false;\n+}\n+\n /* Optimize away redundant UBSAN_VPTR calls.  The second argument\n    is the value loaded from the virtual table, so rely on FRE to find out\n    when we can actually optimize.  */\n@@ -586,6 +819,9 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \t  case IFN_UBSAN_VPTR:\n \t    remove = maybe_optimize_ubsan_vptr_ifn (ctx, stmt);\n \t    break;\n+\t  case IFN_UBSAN_PTR:\n+\t    remove = maybe_optimize_ubsan_ptr_ifn (ctx, stmt);\n+\t    break;\n \t  case IFN_ASAN_CHECK:\n \t    if (asan_check_optimize)\n \t      remove = maybe_optimize_asan_check_ifn (ctx, stmt);\n@@ -604,15 +840,22 @@ sanopt_optimize_walker (basic_block bb, struct sanopt_ctx *ctx)\n \t  /* Drop this check.  */\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"Optimizing out\\n  \");\n+\t      fprintf (dump_file, \"Optimizing out: \");\n \t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  unlink_stmt_vdef (stmt);\n \t  gsi_remove (&gsi, true);\n \t}\n       else\n-\tgsi_next (&gsi);\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Leaving: \");\n+\t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+\t    }\n+\n+\t  gsi_next (&gsi);\n+\t}\n     }\n \n   if (asan_check_optimize)\n@@ -1008,7 +1251,7 @@ pass_sanopt::execute (function *fun)\n   if (optimize\n       && (flag_sanitize\n \t  & (SANITIZE_NULL | SANITIZE_ALIGNMENT\n-\t     | SANITIZE_ADDRESS | SANITIZE_VPTR)))\n+\t     | SANITIZE_ADDRESS | SANITIZE_VPTR | SANITIZE_POINTER_OVERFLOW)))\n     asan_num_accesses = sanopt_optimize (fun, &contains_asan_mark);\n   else if (flag_sanitize & SANITIZE_ADDRESS)\n     {\n@@ -1103,9 +1346,8 @@ pass_sanopt::execute (function *fun)\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"Expanded\\n  \");\n+\t      fprintf (dump_file, \"Expanded: \");\n \t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-\t      fprintf (dump_file, \"\\n\");\n \t    }\n \n \t  if (!no_next)"}, {"sha": "3172683aa4a7e2700464af2d2a773f94ee63c80c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=513d5564225f8baa2ddeafde9edb9e10b62e30ce", "patch": "@@ -1,3 +1,7 @@\n+2017-10-06  Martin Liska  <mliska@suse.cz>\n+\n+\t* c-c++-common/ubsan/ptr-overflow-sanitization-1.c: New test.\n+\n 2017-10-06  Sudakshina Das  <sudi.das@arm.com>\n \n \t* gcc.target/aarch64/bic_imm_1.c: New test."}, {"sha": "42c14523764aeac251af401658bdedd7b9cb518a", "filename": "gcc/testsuite/c-c++-common/ubsan/ptr-overflow-sanitization-1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-sanitization-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/513d5564225f8baa2ddeafde9edb9e10b62e30ce/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-sanitization-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fptr-overflow-sanitization-1.c?ref=513d5564225f8baa2ddeafde9edb9e10b62e30ce", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O -fsanitize=pointer-overflow\" } */\n+/* { dg-skip-if \"\" { *-*-* } \"-flto\" } */\n+\n+#define SMAX   __PTRDIFF_MAX__\n+\n+void foo(void)\n+{\n+  char *p;\n+  char *p2;\n+  char b[1];\n+  char c[1];\n+\n+  p = b + SMAX; /* pointer overflow check is needed */\n+  p = b;\n+  p++;\n+  p2 = p + 1000;\n+  p2 = p + 999;\n+\n+  p = b + SMAX;\n+  p2 = p + 1; /* pointer overflow check is needed */\n+\n+  p = b;\n+  p--; /* pointer overflow check is needed */\n+  p2 = p + 1;\n+  p2 = p + 2;\n+\n+  p = b - SMAX; /* pointer overflow check is needed */\n+  p2 = p + (SMAX - 2); /* b - 2: pointer overflow check is needed */\n+  p2 = p + (SMAX - 1); /* b - 1: pointer overflow check is needed */\n+  p2 = p + SMAX; /* b: pointer overflow check is needed */\n+  p2++; /* b + 1 */\n+\n+  p = c;\n+  p++; /* c + 1 */\n+  p = c - SMAX; /* pointer overflow check is needed */\n+  p2 = p + SMAX; /* c: pointer overflow check is needed */\n+  p2++; /* c + 1 */\n+}\n+\n+void bar(char *ptr)\n+{\n+  char *p = ptr - 1000; /* pointer overflow check is needed */\n+  p = ptr + 1000; /* pointer overflow check is needed */\n+  p -= 2000; /* pointer overflow check is needed */\n+}\n+\n+void baz(char *ptr)\n+{\n+  char **p = &ptr;\n+  char **p2 = p + 20; /* pointer overflow check is needed */\n+  p2--;\n+}\n+\n+void positive_and_positive (char *ptr)\n+{\n+  char **p = &ptr;\n+  char **p2 = p + 100; /* pointer overflow check is needed */\n+  p2 = p + 10;\n+  p += 50; \n+}\n+\n+void negative_to_positive (char *ptr)\n+{\n+  char **p = &ptr;\n+  char **p2 = p + 20; /* pointer overflow check is needed */\n+  p2 = p - 10; /* pointer overflow check is needed */\n+  p2 += 15;\n+}\n+\n+void negative_to_negative (char *ptr)\n+{\n+  char **p = &ptr;\n+  char **p2 = p - 20; /* pointer overflow check is needed */\n+  p2 = p - 20;\n+  p2 += 5;\n+}\n+\n+\n+/* { dg-final { scan-assembler-times \"call\\\\s+__ubsan_handle_pointer_overflow\" 17 } } */"}]}