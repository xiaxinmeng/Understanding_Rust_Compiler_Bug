{"sha": "6489e31865fc0fc677fb8439e0d77623ebb13368", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4OWUzMTg2NWZjMGZjNjc3ZmI4NDM5ZTBkNzc2MjNlYmIxMzM2OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-12-10T12:31:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-12-10T12:31:39Z"}, "message": "re PR middle-end/38474 (compile time explosion in dataflow_set_preserve_mem_locs at -O3)\n\n2013-12-10  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/38474\n\t* tree-ssa-structalias.c (solution_set_expand): Expand into\n\ta different possibly cached bitmap and return the result.\n\t(set_union_with_increment): Pass in a shared expanded bitmap\n\tand adjust.\n\t(do_sd_constraint): Likewise.\n\t(do_ds_constraint): Likewise.\n\t(do_complex_constraint): Likewise.\n\t(solve_graph): Manage the shared expanded bitmap.\n\n\t* gcc.dg/ipa/ipa-pta-14.c: Un-XFAIL.\n\nFrom-SVN: r205857", "tree": {"sha": "ddcc1a290c05be75d206b91131a34693c71c87d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcc1a290c05be75d206b91131a34693c71c87d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6489e31865fc0fc677fb8439e0d77623ebb13368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6489e31865fc0fc677fb8439e0d77623ebb13368", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6489e31865fc0fc677fb8439e0d77623ebb13368", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6489e31865fc0fc677fb8439e0d77623ebb13368/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ce9450f162cef332dbd6534e7c3e246caee70c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce9450f162cef332dbd6534e7c3e246caee70c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce9450f162cef332dbd6534e7c3e246caee70c6"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "969aec8a06dcdc675c9c5b3488d1a7cbe934fb87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6489e31865fc0fc677fb8439e0d77623ebb13368", "patch": "@@ -1,3 +1,15 @@\n+2013-12-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/38474\n+\t* tree-ssa-structalias.c (solution_set_expand): Expand into\n+\ta different possibly cached bitmap and return the result.\n+\t(set_union_with_increment): Pass in a shared expanded bitmap\n+\tand adjust.\n+\t(do_sd_constraint): Likewise.\n+\t(do_ds_constraint): Likewise.\n+\t(do_complex_constraint): Likewise.\n+\t(solve_graph): Manage the shared expanded bitmap.\n+\n 2013-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vectorizer.h (struct _loop_vec_info): Add scalar_loop field."}, {"sha": "618d171dfebd28e4db9122f5bb5617d7df56e649", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6489e31865fc0fc677fb8439e0d77623ebb13368", "patch": "@@ -1,3 +1,8 @@\n+2013-12-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/38474\n+\t* gcc.dg/ipa/ipa-pta-14.c: Un-XFAIL.\n+\n 2013-12-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vect/vect-cond-11.c: New test."}, {"sha": "b62b08ff03af7f69b50bf10f7e77ad0e47fc7b46", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-pta-14.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-pta-14.c?ref=6489e31865fc0fc677fb8439e0d77623ebb13368", "patch": "@@ -21,9 +21,8 @@ int main()\n   void *p;\n   a.p = (void *)&c;\n   p = foo(&a, &a);\n-  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { xfail *-*-* } } } */\n-  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a\\[^ \\]* a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { target { ! keeps_null_pointer_checks } } } } */\n-  /* { dg-final { scan-ipa-dump \"foo.result = { NONLOCAL a\\[^ \\]* a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { target { keeps_null_pointer_checks } } } } */\n+  /* { dg-final { scan-ipa-dump \"foo.result = { NULL a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { target { ! keeps_null_pointer_checks } } } } */\n+  /* { dg-final { scan-ipa-dump \"foo.result = { NONLOCAL a\\[^ \\]* c\\[^ \\]* }\" \"pta\" { target { keeps_null_pointer_checks } } } } */\n   ((struct X *)p)->p = (void *)0;\n   if (a.p != (void *)0)\n     abort ();"}, {"sha": "924a0deec435f615b0fb6be4fa0bd23f3879c0d1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6489e31865fc0fc677fb8439e0d77623ebb13368/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6489e31865fc0fc677fb8439e0d77623ebb13368", "patch": "@@ -917,12 +917,17 @@ constraint_set_union (vec<constraint_t> *to,\n \n /* Expands the solution in SET to all sub-fields of variables included.  */\n \n-static void\n-solution_set_expand (bitmap set)\n+static bitmap\n+solution_set_expand (bitmap set, bitmap *expanded)\n {\n   bitmap_iterator bi;\n   unsigned j;\n \n+  if (*expanded)\n+    return *expanded;\n+\n+  *expanded = BITMAP_ALLOC (&iteration_obstack);\n+\n   /* In a first pass expand to the head of the variables we need to\n      add all sub-fields off.  This avoids quadratic behavior.  */\n   EXECUTE_IF_SET_IN_BITMAP (set, 0, j, bi)\n@@ -931,51 +936,52 @@ solution_set_expand (bitmap set)\n       if (v->is_artificial_var\n \t  || v->is_full_var)\n \tcontinue;\n-      bitmap_set_bit (set, v->head);\n+      bitmap_set_bit (*expanded, v->head);\n     }\n \n   /* In the second pass now expand all head variables with subfields.  */\n-  EXECUTE_IF_SET_IN_BITMAP (set, 0, j, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (*expanded, 0, j, bi)\n     {\n       varinfo_t v = get_varinfo (j);\n-      if (v->is_artificial_var\n-\t  || v->is_full_var\n-\t  || v->head != j)\n+      if (v->head != j)\n \tcontinue;\n       for (v = vi_next (v); v != NULL; v = vi_next (v))\n-\tbitmap_set_bit (set, v->id);\n+\tbitmap_set_bit (*expanded, v->id);\n     }\n+\n+  /* And finally set the rest of the bits from SET.  */\n+  bitmap_ior_into (*expanded, set);\n+\n+  return *expanded;\n }\n \n-/* Union solution sets TO and FROM, and add INC to each member of FROM in the\n+/* Union solution sets TO and DELTA, and add INC to each member of DELTA in the\n    process.  */\n \n static bool\n-set_union_with_increment  (bitmap to, bitmap from, HOST_WIDE_INT inc)\n+set_union_with_increment  (bitmap to, bitmap delta, HOST_WIDE_INT inc,\n+\t\t\t   bitmap *expanded_delta)\n {\n   bool changed = false;\n   bitmap_iterator bi;\n   unsigned int i;\n \n-  /* If the solution of FROM contains anything it is good enough to transfer\n+  /* If the solution of DELTA contains anything it is good enough to transfer\n      this to TO.  */\n-  if (bitmap_bit_p (from, anything_id))\n+  if (bitmap_bit_p (delta, anything_id))\n     return bitmap_set_bit (to, anything_id);\n \n   /* If the offset is unknown we have to expand the solution to\n      all subfields.  */\n   if (inc == UNKNOWN_OFFSET)\n     {\n-      bitmap tmp = BITMAP_ALLOC (&iteration_obstack);\n-      bitmap_copy (tmp, from);\n-      solution_set_expand (tmp);\n-      changed |= bitmap_ior_into (to, tmp);\n-      BITMAP_FREE (tmp);\n+      delta = solution_set_expand (delta, expanded_delta);\n+      changed |= bitmap_ior_into (to, delta);\n       return changed;\n     }\n \n   /* For non-zero offset union the offsetted solution into the destination.  */\n-  EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (delta, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n \n@@ -1576,7 +1582,7 @@ topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \n static void\n do_sd_constraint (constraint_graph_t graph, constraint_t c,\n-\t\t  bitmap delta)\n+\t\t  bitmap delta, bitmap *expanded_delta)\n {\n   unsigned int lhs = c->lhs.var;\n   bool flag = false;\n@@ -1601,7 +1607,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n      dereferenced at all valid offsets.  */\n   if (roffset == UNKNOWN_OFFSET)\n     {\n-      solution_set_expand (delta);\n+      delta = solution_set_expand (delta, expanded_delta);\n       /* No further offset processing is necessary.  */\n       roffset = 0;\n     }\n@@ -1663,7 +1669,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n    as the starting solution for x.  */\n \n static void\n-do_ds_constraint (constraint_t c, bitmap delta)\n+do_ds_constraint (constraint_t c, bitmap delta, bitmap *expanded_delta)\n {\n   unsigned int rhs = c->rhs.var;\n   bitmap sol = get_varinfo (rhs)->solution;\n@@ -1699,7 +1705,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n      dereferenced at all valid offsets.  */\n   if (loff == UNKNOWN_OFFSET)\n     {\n-      solution_set_expand (delta);\n+      delta = solution_set_expand (delta, expanded_delta);\n       loff = 0;\n     }\n \n@@ -1761,7 +1767,8 @@ do_ds_constraint (constraint_t c, bitmap delta)\n    constraint (IE *x = &y, x = *y, *x = y, and x = y with offsets involved).  */\n \n static void\n-do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n+do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta,\n+\t\t       bitmap *expanded_delta)\n {\n   if (c->lhs.type == DEREF)\n     {\n@@ -1772,14 +1779,14 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       else\n \t{\n \t  /* *x = y */\n-\t  do_ds_constraint (c, delta);\n+\t  do_ds_constraint (c, delta, expanded_delta);\n \t}\n     }\n   else if (c->rhs.type == DEREF)\n     {\n       /* x = *y */\n       if (!(get_varinfo (c->lhs.var)->is_special_var))\n-\tdo_sd_constraint (graph, c, delta);\n+\tdo_sd_constraint (graph, c, delta, expanded_delta);\n     }\n   else\n     {\n@@ -1790,7 +1797,8 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n \t\t\t   && c->rhs.offset != 0 && c->lhs.offset == 0);\n       tmp = get_varinfo (c->lhs.var)->solution;\n \n-      flag = set_union_with_increment (tmp, delta, c->rhs.offset);\n+      flag = set_union_with_increment (tmp, delta, c->rhs.offset,\n+\t\t\t\t       expanded_delta);\n \n       if (flag)\n \tbitmap_set_bit (changed, c->lhs.var);\n@@ -2709,6 +2717,7 @@ solve_graph (constraint_graph_t graph)\n \t      solution_empty = bitmap_empty_p (solution);\n \n \t      /* Process the complex constraints */\n+\t      bitmap expanded_pts = NULL;\n \t      FOR_EACH_VEC_ELT (complex, j, c)\n \t\t{\n \t\t  /* XXX: This is going to unsort the constraints in\n@@ -2723,8 +2732,9 @@ solve_graph (constraint_graph_t graph)\n \t\t     is a constraint where the lhs side is receiving\n \t\t     some set from elsewhere.  */\n \t\t  if (!solution_empty || c->lhs.type != DEREF)\n-\t\t    do_complex_constraint (graph, c, pts);\n+\t\t    do_complex_constraint (graph, c, pts, &expanded_pts);\n \t\t}\n+\t      BITMAP_FREE (expanded_pts);\n \n \t      solution_empty = bitmap_empty_p (solution);\n "}]}