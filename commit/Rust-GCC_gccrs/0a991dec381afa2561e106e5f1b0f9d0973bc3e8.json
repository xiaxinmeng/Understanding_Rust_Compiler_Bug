{"sha": "0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE5OTFkZWMzODFhZmEyNTYxZTEwNmU1ZjFiMGY5ZDA5NzNiYzNlOA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-09-08T09:17:27Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-09-08T09:17:27Z"}, "message": "re PR fortran/37199 (array assignment from function writes out of bounds)\n\n2008-09-08  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37199\n\t* trans-expr.c (gfc_add_interface_mapping): Set new_sym->as.\n\t(gfc_map_intrinsic_function): Added checks against NULL bounds in\n\tarray specs.\n\n2008-09-08  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37199\n\t* gfortran.dg/array_function_2.f90: New test.\n\nFrom-SVN: r140102", "tree": {"sha": "d2b35b25ee4f70d2f8a4bc9b8f0394d80a7f55c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2b35b25ee4f70d2f8a4bc9b8f0394d80a7f55c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10c17e8fd0cf9fe6471f4841472337364f54b1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c17e8fd0cf9fe6471f4841472337364f54b1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c17e8fd0cf9fe6471f4841472337364f54b1e1"}], "stats": {"total": 65, "additions": 61, "deletions": 4}, "files": [{"sha": "39b68d817f379cd1333a3397cf02f094c94b897e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "patch": "@@ -1,3 +1,10 @@\n+2008-09-08  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37199\n+\t* trans-expr.c (gfc_add_interface_mapping): Set new_sym->as.\n+\t(gfc_map_intrinsic_function): Added checks against NULL bounds in\n+\tarray specs.\n+\n 2008-09-08  Tobias Burnus  <burnus@net.b.de>\n \n \tPR fortran/37400"}, {"sha": "216b3df1c96f3ad37a0a8ede45366e7595e69795", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "patch": "@@ -1618,6 +1618,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   /* Create a new symbol to represent the actual argument.  */\n   new_sym = gfc_new_symbol (sym->name, NULL);\n   new_sym->ts = sym->ts;\n+  new_sym->as = gfc_copy_array_spec (sym->as);\n   new_sym->attr.referenced = 1;\n   new_sym->attr.dimension = sym->attr.dimension;\n   new_sym->attr.pointer = sym->attr.pointer;\n@@ -1798,8 +1799,9 @@ gfc_apply_interface_mapping_to_ref (gfc_interface_mapping * mapping,\n \n \n /* Convert intrinsic function calls into result expressions.  */\n+\n static bool\n-gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping * mapping)\n+gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n {\n   gfc_symbol *sym;\n   gfc_expr *new_expr;\n@@ -1813,7 +1815,7 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping * mapping)\n   else\n     arg2 = NULL;\n \n-  sym  = arg1->symtree->n.sym;\n+  sym = arg1->symtree->n.sym;\n \n   if (sym->attr.dummy)\n     return false;\n@@ -1850,6 +1852,13 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping * mapping)\n       for (; d < dup; d++)\n \t{\n \t  gfc_expr *tmp;\n+\n+\t  if (!sym->as->upper[d] || !sym->as->lower[d])\n+\t    {\n+\t      gfc_free_expr (new_expr);\n+\t      return false;\n+\t    }\n+\n \t  tmp = gfc_add (gfc_copy_expr (sym->as->upper[d]), gfc_int_expr (1));\n \t  tmp = gfc_subtract (tmp, gfc_copy_expr (sym->as->lower[d]));\n \t  if (new_expr)\n@@ -1875,9 +1884,15 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping * mapping)\n \tgcc_unreachable ();\n \n       if (expr->value.function.isym->id == GFC_ISYM_LBOUND)\n-\tnew_expr = gfc_copy_expr (sym->as->lower[d]);\n+\t{\n+\t  if (sym->as->lower[d])\n+\t    new_expr = gfc_copy_expr (sym->as->lower[d]);\n+\t}\n       else\n-\tnew_expr = gfc_copy_expr (sym->as->upper[d]);\n+\t{\n+\t  if (sym->as->upper[d])\n+\t    new_expr = gfc_copy_expr (sym->as->upper[d]);\n+\t}\n       break;\n \n     default:"}, {"sha": "ec3132ff13e66968944bd1f1c47aa3d71d4cbc21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "patch": "@@ -1,3 +1,8 @@\n+2008-09-08  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37199\n+\t* gfortran.dg/array_function_2.f90: New test.\n+\n 2008-09-08  Tobias Burnus  <burnus@net.b.de>\n \n \tPR fortran/37400"}, {"sha": "a9374116a418ea29b0e5087995bb4ad1229676e1", "filename": "gcc/testsuite/gfortran.dg/array_function_2.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_function_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a991dec381afa2561e106e5f1b0f9d0973bc3e8/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_function_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_function_2.f90?ref=0a991dec381afa2561e106e5f1b0f9d0973bc3e8", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+\n+! PR fortran/37199\n+! We used to produce wrong (segfaulting) code for this one because the\n+! temporary array for the function result had wrong bounds.\n+\n+! Contributed by Gavin Salam <salam@lpthe.jussieu.fr>\n+\n+program bounds_issue\n+  implicit none\n+  integer, parameter  :: dp = kind(1.0d0)\n+  real(dp), pointer :: pdf0(:,:), dpdf(:,:)\n+\n+  allocate(pdf0(0:282,-6:7))\n+  allocate(dpdf(0:282,-6:7))  ! with dpdf(0:283,-6:7) [illegal] error disappears\n+  !write(0,*) lbound(dpdf), ubound(dpdf)\n+  dpdf = tmp_PConv(pdf0)\n+\n+contains\n+  function tmp_PConv(q_in) result(Pxq)\n+    real(dp),      intent(in) :: q_in(0:,-6:)\n+    real(dp)                  :: Pxq(0:ubound(q_in,dim=1),-6:7)\n+    Pxq = 0d0\n+    !write(0,*) lbound(q_in), ubound(q_in)\n+    !write(0,*) lbound(Pxq),  ubound(Pxq)\n+    return\n+  end function tmp_PConv\n+\n+end program bounds_issue"}]}