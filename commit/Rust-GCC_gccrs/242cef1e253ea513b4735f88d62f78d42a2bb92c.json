{"sha": "242cef1e253ea513b4735f88d62f78d42a2bb92c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQyY2VmMWUyNTNlYTUxM2I0NzM1Zjg4ZDYyZjc4ZDQyYTJiYjkyYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-11T20:14:39Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-11T20:14:39Z"}, "message": "Whitespace changes.\n\nFrom-SVN: r5740", "tree": {"sha": "41111a4039311a5ff5c8cf9cf998a417082b15bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41111a4039311a5ff5c8cf9cf998a417082b15bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/242cef1e253ea513b4735f88d62f78d42a2bb92c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242cef1e253ea513b4735f88d62f78d42a2bb92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/242cef1e253ea513b4735f88d62f78d42a2bb92c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242cef1e253ea513b4735f88d62f78d42a2bb92c/comments", "author": null, "committer": null, "parents": [{"sha": "7b18c3db9c48b2ac5306e9ca9b4a7329c2f09b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b18c3db9c48b2ac5306e9ca9b4a7329c2f09b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b18c3db9c48b2ac5306e9ca9b4a7329c2f09b67"}], "stats": {"total": 252, "additions": 127, "deletions": 125}, "files": [{"sha": "5fa8ca9781efcf40e9e0072ffb5cb41a8755a972", "filename": "gcc/real.c", "status": "modified", "additions": 127, "deletions": 125, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242cef1e253ea513b4735f88d62f78d42a2bb92c/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242cef1e253ea513b4735f88d62f78d42a2bb92c/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=242cef1e253ea513b4735f88d62f78d42a2bb92c", "patch": "@@ -2043,151 +2043,153 @@ emulm (a, b)\n /* Multiply significand of e-type number b\n by 16-bit quantity a, e-type result to c. */\n \n-void m16m( a, b, c )\n-unsigned short a;\n-unsigned short b[], c[];\n+void\n+m16m (a, b, c)\n+     unsigned short a;\n+     unsigned short b[], c[];\n {\n-register unsigned short *pp;\n-register unsigned long carry;\n-unsigned short *ps;\n-unsigned short p[NI];\n-unsigned long aa, m;\n-int i;\n-\n-aa = a;\n-pp = &p[NI-2];\n-*pp++ = 0;\n-*pp = 0;\n-ps = &b[NI-1];\n-\n-for( i=M+1; i<NI; i++ )\n+  register unsigned short *pp;\n+  register unsigned long carry;\n+  unsigned short *ps;\n+  unsigned short p[NI];\n+  unsigned long aa, m;\n+  int i;\n+\n+  aa = a;\n+  pp = &p[NI-2];\n+  *pp++ = 0;\n+  *pp = 0;\n+  ps = &b[NI-1];\n+\n+  for (i=M+1; i<NI; i++)\n+    {\n+      if (*ps == 0)\n \t{\n-\tif( *ps == 0 )\n-\t\t{\n-\t\t--ps;\n-\t\t--pp;\n-\t\t*(pp-1) = 0;\n-\t\t}\n-\telse\n-\t\t{\n-\t\tm = (unsigned long) aa * *ps--;\n-\t\tcarry = (m & 0xffff) + *pp;\n-\t\t*pp-- = (unsigned short )carry;\n-\t\tcarry = (carry >> 16) + (m >> 16) + *pp;\n-\t\t*pp = (unsigned short )carry;\n-\t\t*(pp-1) = carry >> 16;\n-\t\t}\n+\t  --ps;\n+\t  --pp;\n+\t  *(pp-1) = 0;\n \t}\n-for( i=M; i<NI; i++ )\n-\tc[i] = p[i];\n+      else\n+\t{\n+\t  m = (unsigned long) aa * *ps--;\n+\t  carry = (m & 0xffff) + *pp;\n+\t  *pp-- = (unsigned short)carry;\n+\t  carry = (carry >> 16) + (m >> 16) + *pp;\n+\t  *pp = (unsigned short)carry;\n+\t  *(pp-1) = carry >> 16;\n+\t}\n+    }\n+  for (i=M; i<NI; i++)\n+    c[i] = p[i];\n }\n \n \n /* Divide significands. Neither the numerator nor the denominator\n-is permitted to have its high guard word nonzero.  */\n+   is permitted to have its high guard word nonzero.  */\n \n-\n-int edivm( den, num )\n-unsigned short den[], num[];\n+int\n+edivm (den, num)\n+     unsigned short den[], num[];\n {\n-int i;\n-register unsigned short *p;\n-unsigned long tnum;\n-unsigned short j, tdenm, tquot;\n-unsigned short tprod[NI+1];\n+  int i;\n+  register unsigned short *p;\n+  unsigned long tnum;\n+  unsigned short j, tdenm, tquot;\n+  unsigned short tprod[NI+1];\n \n-p = &equot[0];\n-*p++ = num[0];\n-*p++ = num[1];\n+  p = &equot[0];\n+  *p++ = num[0];\n+  *p++ = num[1];\n \n-for( i=M; i<NI; i++ )\n-\t{\n-\t*p++ = 0;\n-\t}\n-eshdn1( num );\n-tdenm = den[M+1];\n-for( i=M; i<NI; i++ )\n-\t{\n-\t/* Find trial quotient digit (the radix is 65536). */\n-\ttnum = (((unsigned long) num[M]) << 16) + num[M+1];\n-\n-\t/* Do not execute the divide instruction if it will overflow. */\n-        if( (tdenm * 0xffffL) < tnum )\n-\t\ttquot = 0xffff;\n-\telse\n-\t\ttquot = tnum / tdenm;\n-\t/* Multiply denominator by trial quotient digit. */\n-\tm16m( tquot, den, tprod );\n-\t/* The quotient digit may have been overestimated. */\n-\tif( ecmpm( tprod, num ) > 0 )\n-\t\t{\n-\t\ttquot -= 1;\n-\t\tesubm( den, tprod );\n-\t\tif( ecmpm( tprod, num ) > 0 )\n-\t\t\t{\n-\t\t\ttquot -= 1;\n-\t\t\tesubm( den, tprod );\n-\t\t\t}\n-\t\t}\n-\tesubm( tprod, num );\n-\tequot[i] = tquot;\n-\teshup6(num);\n-\t}\n-/* test for nonzero remainder after roundoff bit */\n-p = &num[M];\n-j = 0;\n-for( i=M; i<NI; i++ )\n+  for (i=M; i<NI; i++)\n+    {\n+      *p++ = 0;\n+    }\n+  eshdn1 (num);\n+  tdenm = den[M+1];\n+  for (i=M; i<NI; i++)\n+    {\n+      /* Find trial quotient digit (the radix is 65536). */\n+      tnum = (((unsigned long) num[M]) << 16) + num[M+1];\n+\n+      /* Do not execute the divide instruction if it will overflow. */\n+      if ((tdenm * 0xffffL) < tnum)\n+\ttquot = 0xffff;\n+      else\n+\ttquot = tnum / tdenm;\n+      /* Multiply denominator by trial quotient digit. */\n+      m16m (tquot, den, tprod);\n+      /* The quotient digit may have been overestimated. */\n+      if (ecmpm (tprod, num) > 0)\n \t{\n-\tj |= *p++;\n+\t  tquot -= 1;\n+\t  esubm (den, tprod);\n+\t  if (ecmpm (tprod, num) > 0)\n+\t    {\n+\t      tquot -= 1;\n+\t      esubm (den, tprod);\n+\t    }\n \t}\n-if( j )\n-\tj = 1;\n+      esubm (tprod, num);\n+      equot[i] = tquot;\n+      eshup6(num);\n+    }\n+  /* test for nonzero remainder after roundoff bit */\n+  p = &num[M];\n+  j = 0;\n+  for (i=M; i<NI; i++)\n+    {\n+      j |= *p++;\n+    }\n+  if (j)\n+    j = 1;\n \n-for( i=0; i<NI; i++ )\n-\tnum[i] = equot[i];\n+  for (i=0; i<NI; i++)\n+    num[i] = equot[i];\n \n-return( (int )j );\n+  return ((int)j);\n }\n \n \n \n /* Multiply significands */\n-int emulm( a, b )\n-unsigned short a[], b[];\n+int\n+emulm (a, b)\n+     unsigned short a[], b[];\n {\n-unsigned short *p, *q;\n-unsigned short pprod[NI];\n-unsigned short j;\n-int i;\n-\n-equot[0] = b[0];\n-equot[1] = b[1];\n-for( i=M; i<NI; i++ )\n-\tequot[i] = 0;\n-\n-j = 0;\n-p = &a[NI-1];\n-q = &equot[NI-1];\n-for( i=M+1; i<NI; i++ )\n+  unsigned short *p, *q;\n+  unsigned short pprod[NI];\n+  unsigned short j;\n+  int i;\n+\n+  equot[0] = b[0];\n+  equot[1] = b[1];\n+  for (i=M; i<NI; i++)\n+    equot[i] = 0;\n+\n+  j = 0;\n+  p = &a[NI-1];\n+  q = &equot[NI-1];\n+  for (i=M+1; i<NI; i++)\n+    {\n+      if (*p == 0)\n \t{\n-\tif( *p == 0 )\n-\t\t{\n-\t\t--p;\n-\t\t}\n-\telse\n-\t\t{\n-\t\tm16m( *p--, b, pprod );\n-\t\teaddm(pprod, equot);\n-\t\t}\n-\tj |= *q;\n-\teshdn6(equot);\n+\t  --p;\n+\t}\n+      else\n+\t{\n+\t  m16m (*p--, b, pprod);\n+\t  eaddm(pprod, equot);\n \t}\n+      j |= *q;\n+      eshdn6(equot);\n+    }\n \n-for( i=0; i<NI; i++ )\n-\tb[i] = equot[i];\n+  for (i=0; i<NI; i++)\n+    b[i] = equot[i];\n \n-/* return flag for lost nonzero bits */\n-return( (int)j );\n+  /* return flag for lost nonzero bits */\n+  return ((int)j);\n }\n #endif\n \n@@ -4476,7 +4478,7 @@ etoasc (x, string, ndigs)\n     }\n   else\n     {\n-      *s++ = (char )digit + '0';\n+      *s++ = (char)digit + '0';\n       *s++ = '.';\n     }\n   /* Generate digits after the decimal point. */\n@@ -5082,10 +5084,10 @@ eremain (a, b, c)\n   unsigned EMUSHORT den[NI], num[NI];\n \n #ifdef NANS\n-  if ( eisinf (b)\n-       || (ecmp (a, ezero) == 0)\n-       || eisnan (a)\n-       || eisnan (b))\n+  if (eisinf (b)\n+      || (ecmp (a, ezero) == 0)\n+      || eisnan (a)\n+      || eisnan (b))\n     {\n       enan (c);\n       return;"}]}