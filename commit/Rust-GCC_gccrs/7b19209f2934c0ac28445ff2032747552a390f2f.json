{"sha": "7b19209f2934c0ac28445ff2032747552a390f2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxOTIwOWYyOTM0YzBhYzI4NDQ1ZmYyMDMyNzQ3NTUyYTM5MGYyZg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-08T15:33:58Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-10-08T15:33:58Z"}, "message": "bitmap.h (bitmap_and_into): Update prototype.\n\n\t* bitmap.h (bitmap_and_into): Update prototype.\n\t* bitmap.c (bitmap_and_into): Return true if the target bitmap\n\tchanged, false otherwise.\n\n\t* df.h (df_dump_insn_problem_function): New function type.\n\t(struct df_problem): Add two functions, to dump just before and\n\tjust after an insn.\n\t(DF_RD_PRUNE_DEAD_DEFS): New changable flag.\n\t(df_dump_insn_top, df_dump_insn_bottom): New prototypes.\n\t* df-core (df_dump_region): Use dump_bb.\n\t(df_dump_bb_problem_data): New function.\n\t(df_dump_top, df_dump_bottom): Rewrite using df_dump_bb_problem_data.\n\t(df_dump_insn_problem_data): New function.\n\t(df_dump_insn_top, df_dump_insn_bottom): New functions.\n\t* df-scan.c (problem_SCAN): Add NULL fields for new members.\n\t* df-problems.c (df_rd_local_compute): Ignore hard registers if\n\tDF_NO_HARD_REGS is in effect.\n\t(df_rd_transfer_function): If DF_RD_PRUNE_DEAD_DEFS is in effect,\n\tprune reaching defs using the LR problem.\n\t(df_rd_start_dump): Fix dumping of DEFs map.\n\t(df_rd_dump_defs_set): New function.\n\t(df_rd_top_dump, df_rd_bottom_dump): Use it.\n\t(problem_RD): Add NULL fields for new members.\n\t(problem_LR, problem_LIVE): Likewise.\n\t(df_chain_bb_dump): New function.\n\t(df_chain_top_dump): Dump only for artificial DEFs and USEs,\n\tusing df_chain_bb_dump.\n\t(df_chain_bottom_dump): Likewise.\n\t(df_chain_insn_top_dump, df_chain_insn_bottom_dump): New functions.\n\t(problem_CHAIN): Add them as new members.\n\t(problem_WORD_LR, problem_NOTE): Add NULL fields for new members.\n\t(problem_MD): Likewise.\n\t* cfgrtl.c (rtl_dump_bb): Use df_dump_insn_top and df_dump_insn_bottom.\n\t(print_rtl_with_bb): Likewise.\n\n\t* dce.c (init_dce): Use DF_RD_PRUNE_DEAD_DEFS.\n\t* loop-invariant.c (find_defs): Likewise.\n\t* loop-iv.c (iv_analysis_loop_init): Likewise.\n\t* ree.c (find_and_remove_re): Likewise.\n\t* web.c (web_main): Likewise.\n\nFrom-SVN: r192213", "tree": {"sha": "dc4fd0ce62886f374accbfc584455a9e48228637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc4fd0ce62886f374accbfc584455a9e48228637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b19209f2934c0ac28445ff2032747552a390f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b19209f2934c0ac28445ff2032747552a390f2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b19209f2934c0ac28445ff2032747552a390f2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b19209f2934c0ac28445ff2032747552a390f2f/comments", "author": null, "committer": null, "parents": [{"sha": "76cee070fd46483d818ffee61b7ec12be062afda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76cee070fd46483d818ffee61b7ec12be062afda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76cee070fd46483d818ffee61b7ec12be062afda"}], "stats": {"total": 495, "additions": 371, "deletions": 124}, "files": [{"sha": "39e23bdc22c1b4cfd87017ef4681f15c08f1f6b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -1,3 +1,46 @@\n+2012-10-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* bitmap.h (bitmap_and_into): Update prototype.\n+\t* bitmap.c (bitmap_and_into): Return true if the target bitmap\n+\tchanged, false otherwise.\n+\n+\t* df.h (df_dump_insn_problem_function): New function type.\n+\t(struct df_problem): Add two functions, to dump just before and\n+\tjust after an insn.\n+\t(DF_RD_PRUNE_DEAD_DEFS): New changable flag.\n+\t(df_dump_insn_top, df_dump_insn_bottom): New prototypes.\n+\t* df-core (df_dump_region): Use dump_bb.\n+\t(df_dump_bb_problem_data): New function.\n+\t(df_dump_top, df_dump_bottom): Rewrite using df_dump_bb_problem_data.\n+\t(df_dump_insn_problem_data): New function.\n+\t(df_dump_insn_top, df_dump_insn_bottom): New functions.\n+\t* df-scan.c (problem_SCAN): Add NULL fields for new members.\n+\t* df-problems.c (df_rd_local_compute): Ignore hard registers if\n+\tDF_NO_HARD_REGS is in effect.\n+\t(df_rd_transfer_function): If DF_RD_PRUNE_DEAD_DEFS is in effect,\n+\tprune reaching defs using the LR problem.\n+\t(df_rd_start_dump): Fix dumping of DEFs map.\n+\t(df_rd_dump_defs_set): New function.\n+\t(df_rd_top_dump, df_rd_bottom_dump): Use it.\n+\t(problem_RD): Add NULL fields for new members.\n+\t(problem_LR, problem_LIVE): Likewise.\n+\t(df_chain_bb_dump): New function.\n+\t(df_chain_top_dump): Dump only for artificial DEFs and USEs,\n+\tusing df_chain_bb_dump.\n+\t(df_chain_bottom_dump): Likewise.\n+\t(df_chain_insn_top_dump, df_chain_insn_bottom_dump): New functions.\n+\t(problem_CHAIN): Add them as new members.\n+\t(problem_WORD_LR, problem_NOTE): Add NULL fields for new members.\n+\t(problem_MD): Likewise.\n+\t* cfgrtl.c (rtl_dump_bb): Use df_dump_insn_top and df_dump_insn_bottom.\n+\t(print_rtl_with_bb): Likewise.\n+\n+\t* dce.c (init_dce): Use DF_RD_PRUNE_DEAD_DEFS.\n+\t* loop-invariant.c (find_defs): Likewise.\n+\t* loop-iv.c (iv_analysis_loop_init): Likewise.\n+\t* ree.c (find_and_remove_re): Likewise.\n+\t* web.c (web_main): Likewise.\n+\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n \t* config/rs6000/rs6000.c (rs6000_code_end): Protect the use of\n@@ -319,7 +362,7 @@\n \n 2012-10-04  Jeff Law  <law@redhat.com>\n \n-\t* PR target/50356\n+\tPR target/50356\n \t* config/h8300/h8300.c (h8300_rtx_costs): Fix typo in CONST_INT case.\n \n 2012-10-04  Jason Merrill  <jason@redhat.com>\n@@ -329,8 +372,8 @@\n \n 2012-10-04  Basile Starynkevitch  <basile@starynkevitch.net>\n \n-        * gengtype.c (walk_type): Emit mark_hook when inside a\n-          struct of a union member.\n+\t* gengtype.c (walk_type): Emit mark_hook when inside a\n+\tstruct of a union member.\n \n 2012-10-04  Georg-Johann Lay  <avr@gjlay.de>\n "}, {"sha": "76f70fcdb84ab26fa036942fee17b8bc1d151e19", "filename": "gcc/bitmap.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -916,17 +916,18 @@ bitmap_and (bitmap dst, const_bitmap a, const_bitmap b)\n     dst->indx = dst->current->indx;\n }\n \n-/* A &= B.  */\n+/* A &= B.  Return true if A changed.  */\n \n-void\n+bool\n bitmap_and_into (bitmap a, const_bitmap b)\n {\n   bitmap_element *a_elt = a->first;\n   const bitmap_element *b_elt = b->first;\n   bitmap_element *next;\n+  bool changed = false;\n \n   if (a == b)\n-    return;\n+    return false;\n \n   while (a_elt && b_elt)\n     {\n@@ -935,6 +936,7 @@ bitmap_and_into (bitmap a, const_bitmap b)\n \t  next = a_elt->next;\n \t  bitmap_element_free (a, a_elt);\n \t  a_elt = next;\n+\t  changed = true;\n \t}\n       else if (b_elt->indx < a_elt->indx)\n \tb_elt = b_elt->next;\n@@ -947,7 +949,8 @@ bitmap_and_into (bitmap a, const_bitmap b)\n \t  for (ix = 0; ix < BITMAP_ELEMENT_WORDS; ix++)\n \t    {\n \t      BITMAP_WORD r = a_elt->bits[ix] & b_elt->bits[ix];\n-\n+\t      if (a_elt->bits[ix] != r)\n+\t\tchanged = true;\n \t      a_elt->bits[ix] = r;\n \t      ior |= r;\n \t    }\n@@ -958,9 +961,17 @@ bitmap_and_into (bitmap a, const_bitmap b)\n \t  b_elt = b_elt->next;\n \t}\n     }\n-  bitmap_elt_clear_from (a, a_elt);\n+\n+  if (a_elt)\n+    {\n+      changed = true;\n+      bitmap_elt_clear_from (a, a_elt);\n+    }\n+\n   gcc_checking_assert (!a->current == !a->first\n \t\t       && (!a->current || a->indx == a->current->indx));\n+\n+  return changed;\n }\n \n "}, {"sha": "3e369b077c61fc09bca0a338ad46a97f045c291c", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -224,7 +224,7 @@ extern unsigned long bitmap_count_bits (const_bitmap);\n    are three operand versions that to not destroy the source bitmaps.\n    The operations supported are &, & ~, |, ^.  */\n extern void bitmap_and (bitmap, const_bitmap, const_bitmap);\n-extern void bitmap_and_into (bitmap, const_bitmap);\n+extern bool bitmap_and_into (bitmap, const_bitmap);\n extern bool bitmap_and_compl (bitmap, const_bitmap, const_bitmap);\n extern bool bitmap_and_compl_into (bitmap, const_bitmap);\n #define bitmap_compl_and(DST, A, B) bitmap_and_compl (DST, B, A)"}, {"sha": "7946a3fe9f4df9a6a1224e41b39ccda23e8637d5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -1856,11 +1856,14 @@ rtl_dump_bb (FILE *outf, basic_block bb, int indent, int flags)\n     for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb)); insn != last;\n \t insn = NEXT_INSN (insn))\n       {\n+\tif (flags & TDF_DETAILS)\n+\t  df_dump_insn_top (insn, outf);\n \tif (! (flags & TDF_SLIM))\n \t  print_rtl_single (outf, insn);\n \telse\n \t  dump_insn_slim (outf, insn);\n-\n+\tif (flags & TDF_DETAILS)\n+\t  df_dump_insn_bottom (insn, outf);\n       }\n \n   if (df && (flags & TDF_DETAILS))\n@@ -1941,10 +1944,14 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first, int flags)\n \t\tfprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n \t    }\n \n+\t  if (flags & TDF_DETAILS)\n+\t    df_dump_insn_top (tmp_rtx, outf);\n \t  if (! (flags & TDF_SLIM))\n \t    print_rtl_single (outf, tmp_rtx);\n \t  else\n \t    dump_insn_slim (outf, tmp_rtx);\n+\t  if (flags & TDF_DETAILS)\n+\t    df_dump_insn_bottom (tmp_rtx, outf);\n \n \t  if (flags & TDF_BLOCKS)\n \t    {"}, {"sha": "9a42da761c2b1077fa46329fff3628de4fcc4295", "filename": "gcc/dce.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -704,7 +704,10 @@ init_dce (bool fast)\n   if (!df_in_progress)\n     {\n       if (!fast)\n-\tdf_chain_add_problem (DF_UD_CHAIN);\n+\t{\n+\t  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n+\t  df_chain_add_problem (DF_UD_CHAIN);\n+\t}\n       df_analyze ();\n     }\n "}, {"sha": "34f1ea351c10d5acd41dc0c05075fed004bafdb7", "filename": "gcc/df-core.c", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -1994,10 +1994,7 @@ df_dump_region (FILE *file)\n       EXECUTE_IF_SET_IN_BITMAP (df->blocks_to_analyze, 0, bb_index, bi)\n \t{\n \t  basic_block bb = BASIC_BLOCK (bb_index);\n-\n-\t  df_print_bb_index (bb, file);\n-\t  df_dump_top (bb, file);\n-\t  df_dump_bottom (bb, file);\n+\t  dump_bb (file, bb, 0, TDF_DETAILS);\n \t}\n       fprintf (file, \"\\n\");\n     }\n@@ -2035,10 +2032,9 @@ df_dump_start (FILE *file)\n }\n \n \n-/* Dump the top of the block information for BB.  */\n-\n-void\n-df_dump_top (basic_block bb, FILE *file)\n+/* Dump the top or bottom of the block information for BB.  */\n+static void\n+df_dump_bb_problem_data (basic_block bb, FILE *file, bool top)\n {\n   int i;\n \n@@ -2050,18 +2046,39 @@ df_dump_top (basic_block bb, FILE *file)\n       struct dataflow *dflow = df->problems_in_order[i];\n       if (dflow->computed)\n \t{\n-\t  df_dump_bb_problem_function bbfun = dflow->problem->dump_top_fun;\n+\t  df_dump_bb_problem_function bbfun;\n+\n+\t  if (top)\n+\t    bbfun = dflow->problem->dump_top_fun;\n+\t  else\n+\t    bbfun = dflow->problem->dump_bottom_fun;\n+\n \t  if (bbfun)\n \t    bbfun (bb, file);\n \t}\n     }\n }\n \n+/* Dump the top of the block information for BB.  */\n+\n+void\n+df_dump_top (basic_block bb, FILE *file)\n+{\n+  df_dump_bb_problem_data (bb, file, /*top=*/true);\n+}\n \n /* Dump the bottom of the block information for BB.  */\n \n void\n df_dump_bottom (basic_block bb, FILE *file)\n+{\n+  df_dump_bb_problem_data (bb, file, /*top=*/false);\n+}\n+\n+\n+/* Dump information about INSN just before or after dumping INSN itself.  */\n+static void\n+df_dump_insn_problem_data (const_rtx insn, FILE *file, bool top)\n {\n   int i;\n \n@@ -2073,13 +2090,35 @@ df_dump_bottom (basic_block bb, FILE *file)\n       struct dataflow *dflow = df->problems_in_order[i];\n       if (dflow->computed)\n \t{\n-\t  df_dump_bb_problem_function bbfun = dflow->problem->dump_bottom_fun;\n-\t  if (bbfun)\n-\t    bbfun (bb, file);\n+\t  df_dump_insn_problem_function insnfun;\n+\n+\t  if (top)\n+\t    insnfun = dflow->problem->dump_insn_top_fun;\n+\t  else\n+\t    insnfun = dflow->problem->dump_insn_bottom_fun;\n+\n+\t  if (insnfun)\n+\t    insnfun (insn, file);\n \t}\n     }\n }\n \n+/* Dump information about INSN before dumping INSN itself.  */\n+\n+void\n+df_dump_insn_top (const_rtx insn, FILE *file)\n+{\n+  df_dump_insn_problem_data (insn,  file, /*top=*/true);\n+}\n+\n+/* Dump information about INSN after dumping INSN itself.  */\n+\n+void\n+df_dump_insn_bottom (const_rtx insn, FILE *file)\n+{\n+  df_dump_insn_problem_data (insn,  file, /*top=*/false);\n+}\n+\n \n static void\n df_ref_dump (df_ref ref, FILE *file)"}, {"sha": "53e77388f0249c1d3039213c48d7bbb7c2ba9a34", "filename": "gcc/df-problems.c", "status": "modified", "additions": 212, "deletions": 95, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -152,6 +152,17 @@ df_print_bb_index (basic_block bb, FILE *file)\n    pseudo reaches.  In and out bitvectors are built for each basic\n    block.  The id field in the ref is used to index into these sets.\n    See df.h for details.\n+\n+   If the DF_RD_PRUNE_DEAD_DEFS changable flag is set, only DEFs reaching\n+   existing uses are included in the global reaching DEFs set, or in other\n+   words only DEFs that are still live.  This is a kind of pruned version\n+   of the traditional reaching definitions problem that is much less\n+   complex to compute and produces enough information to compute UD-chains.\n+   In this context, live must be interpreted in the DF_LR sense: Uses that\n+   are upward exposed but maybe not initialized on all paths through the\n+   CFG.  For a USE that is not reached by a DEF on all paths, we still want\n+   to make those DEFs that do reach the USE visible, and pruning based on\n+   DF_LIVE would make that impossible.\n    ----------------------------------------------------------------------------*/\n \n /* This problem plays a large number of games for the sake of\n@@ -239,8 +250,7 @@ df_rd_alloc (bitmap all_blocks)\n   df_grow_bb_info (df_rd);\n \n   /* Because of the clustering of all use sites for the same pseudo,\n-     we have to process all of the blocks before doing the\n-     analysis.  */\n+     we have to process all of the blocks before doing the analysis.  */\n \n   EXECUTE_IF_SET_IN_BITMAP (all_blocks, 0, bb_index, bi)\n     {\n@@ -450,12 +460,16 @@ df_rd_local_compute (bitmap all_blocks)\n   /* Set up the knockout bit vectors to be applied across EH_EDGES.  */\n   EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, regno, bi)\n     {\n-      if (DF_DEFS_COUNT (regno) > DF_SPARSE_THRESHOLD)\n-\tbitmap_set_bit (sparse_invalidated, regno);\n-      else\n-\tbitmap_set_range (dense_invalidated,\n-\t\t\t  DF_DEFS_BEGIN (regno),\n-\t\t\t  DF_DEFS_COUNT (regno));\n+      if (! HARD_REGISTER_NUM_P (regno)\n+\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t{\n+\t  if (DF_DEFS_COUNT (regno) > DF_SPARSE_THRESHOLD)\n+\t    bitmap_set_bit (sparse_invalidated, regno);\n+\t  else\n+\t    bitmap_set_range (dense_invalidated,\n+\t\t\t      DF_DEFS_BEGIN (regno),\n+\t\t\t      DF_DEFS_COUNT (regno));\n+\t}\n     }\n \n   bitmap_clear (&seen_in_block);\n@@ -534,13 +548,13 @@ df_rd_transfer_function (int bb_index)\n   bitmap gen = &bb_info->gen;\n   bitmap kill = &bb_info->kill;\n   bitmap sparse_kill = &bb_info->sparse_kill;\n+  bool changed = false;\n \n   if (bitmap_empty_p (sparse_kill))\n-    return  bitmap_ior_and_compl (out, gen, in, kill);\n+    changed = bitmap_ior_and_compl (out, gen, in, kill);\n   else\n     {\n       struct df_rd_problem_data *problem_data;\n-      bool changed = false;\n       bitmap_head tmp;\n \n       /* Note that TMP is _not_ a temporary bitmap if we end up replacing\n@@ -564,11 +578,31 @@ df_rd_transfer_function (int bb_index)\n \t  bb_info->out = tmp;\n \t}\n       else\n-\t  bitmap_clear (&tmp);\n-      return changed;\n+\tbitmap_clear (&tmp);\n     }\n-}\n \n+  if (df->changeable_flags & DF_RD_PRUNE_DEAD_DEFS)\n+    {\n+      /* Create a mask of DEFs for all registers live at the end of this\n+\t basic block, and mask out DEFs of registers that are not live.\n+\t Computing the mask looks costly, but the benefit of the pruning\n+\t outweighs the cost.  */\n+      struct df_rd_bb_info *bb_info = df_rd_get_bb_info (bb_index);\n+      bitmap regs_live_out = &df_lr_get_bb_info (bb_index)->out;\n+      bitmap live_defs = BITMAP_ALLOC (&df_bitmap_obstack);\n+      unsigned int regno;\n+      bitmap_iterator bi;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (regs_live_out, 0, regno, bi)\n+\tbitmap_set_range (live_defs,\n+\t\t\t  DF_DEFS_BEGIN (regno),\n+\t\t\t  DF_DEFS_COUNT (regno));\n+      changed |= bitmap_and_into (&bb_info->out, live_defs);\n+      BITMAP_FREE (live_defs);\n+    }\n+\n+  return changed;\n+}\n \n /* Free all storage associated with the problem.  */\n \n@@ -604,23 +638,66 @@ df_rd_start_dump (FILE *file)\n   if (!df_rd->block_info)\n     return;\n \n-  fprintf (file, \";; Reaching defs:\\n\\n\");\n+  fprintf (file, \";; Reaching defs:\\n\");\n \n-  fprintf (file, \"  sparse invalidated \\t\");\n+  fprintf (file, \";;  sparse invalidated \\t\");\n   dump_bitmap (file, &problem_data->sparse_invalidated_by_call);\n-  fprintf (file, \"  dense invalidated \\t\");\n+  fprintf (file, \";;  dense invalidated \\t\");\n   dump_bitmap (file, &problem_data->dense_invalidated_by_call);\n \n+  fprintf (file, \";;  reg->defs[] map:\\t\");\n   for (regno = 0; regno < m; regno++)\n     if (DF_DEFS_COUNT (regno))\n       fprintf (file, \"%d[%d,%d] \", regno,\n \t       DF_DEFS_BEGIN (regno),\n-\t       DF_DEFS_COUNT (regno));\n+\t       DF_DEFS_BEGIN (regno) + DF_DEFS_COUNT (regno) - 1);\n   fprintf (file, \"\\n\");\n-\n }\n \n \n+static void\n+df_rd_dump_defs_set (bitmap defs_set, const char *prefix, FILE *file)\n+{\n+  bitmap_head tmp;\n+  unsigned int regno;\n+  unsigned int m = DF_REG_SIZE(df);\n+  bool first_reg = true;\n+\n+  fprintf (file, \"%s\\t(%d) \", prefix, (int) bitmap_count_bits (defs_set));\n+\n+  bitmap_initialize (&tmp, &df_bitmap_obstack);\n+  for (regno = 0; regno < m; regno++)\n+    {\n+      if (HARD_REGISTER_NUM_P (regno)\n+\t  && (df->changeable_flags & DF_NO_HARD_REGS))\n+\tcontinue;\n+      bitmap_set_range (&tmp, DF_DEFS_BEGIN (regno), DF_DEFS_COUNT (regno));\n+      bitmap_and_into (&tmp, defs_set);\n+      if (! bitmap_empty_p (&tmp))\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned int ix;\n+\t  bool first_def = true;\n+\n+\t  if (! first_reg)\n+\t    fprintf (file, \",\");\n+\t  first_reg = false;\n+\n+\t  fprintf (file, \"%u[\", regno);\n+\t  EXECUTE_IF_SET_IN_BITMAP (&tmp, 0, ix, bi)\n+\t    {\n+\t      fprintf (file, \"%s%u\", first_def ? \"\" : \",\", ix);\n+\t      first_def = false;\n+\t    }\n+\t  fprintf (file, \"]\");\n+\t}\n+      bitmap_clear (&tmp);\n+    }\n+\n+  fprintf (file, \"\\n\");\n+  bitmap_clear (&tmp);\n+}\n+\n /* Debugging info at top of bb.  */\n \n static void\n@@ -630,16 +707,13 @@ df_rd_top_dump (basic_block bb, FILE *file)\n   if (!bb_info)\n     return;\n \n-  fprintf (file, \";; rd  in  \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->in));\n-  dump_bitmap (file, &bb_info->in);\n-  fprintf (file, \";; rd  gen \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->gen));\n-  dump_bitmap (file, &bb_info->gen);\n-  fprintf (file, \";; rd  kill\\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->kill));\n-  dump_bitmap (file, &bb_info->kill);\n+  df_rd_dump_defs_set (&bb_info->in, \";; rd  in  \", file);\n+  df_rd_dump_defs_set (&bb_info->gen, \";; rd  gen \", file);\n+  df_rd_dump_defs_set (&bb_info->kill, \";; rd  kill\", file);\n }\n \n \n-/* Debugging info at top of bb.  */\n+/* Debugging info at bottom of bb.  */\n \n static void\n df_rd_bottom_dump (basic_block bb, FILE *file)\n@@ -648,8 +722,7 @@ df_rd_bottom_dump (basic_block bb, FILE *file)\n   if (!bb_info)\n     return;\n \n-  fprintf (file, \";; rd  out \\t(%d)\\n\", (int) bitmap_count_bits (&bb_info->out));\n-  dump_bitmap (file, &bb_info->out);\n+  df_rd_dump_defs_set (&bb_info->out, \";; rd  out \", file);\n }\n \n /* All of the information associated with every instance of the problem.  */\n@@ -673,6 +746,8 @@ static struct df_problem problem_RD =\n   df_rd_start_dump,           /* Debugging.  */\n   df_rd_top_dump,             /* Debugging start block.  */\n   df_rd_bottom_dump,          /* Debugging end block.  */\n+  NULL,                       /* Debugging start insn.  */\n+  NULL,                       /* Debugging end insn.  */\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n@@ -1209,6 +1284,8 @@ static struct df_problem problem_LR =\n   NULL,                       /* Debugging.  */\n   df_lr_top_dump,             /* Debugging start block.  */\n   df_lr_bottom_dump,          /* Debugging end block.  */\n+  NULL,                       /* Debugging start insn.  */\n+  NULL,                       /* Debugging end insn.  */\n   df_lr_verify_solution_start,/* Incremental solution verify start.  */\n   df_lr_verify_solution_end,  /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n@@ -1738,6 +1815,8 @@ static struct df_problem problem_LIVE =\n   NULL,                         /* Debugging.  */\n   df_live_top_dump,             /* Debugging start block.  */\n   df_live_bottom_dump,          /* Debugging end block.  */\n+  NULL,                         /* Debugging start insn.  */\n+  NULL,                         /* Debugging end insn.  */\n   df_live_verify_solution_start,/* Incremental solution verify start.  */\n   df_live_verify_solution_end,  /* Incremental solution verify end.  */\n   &problem_LR,                  /* Dependent problem.  */\n@@ -2140,112 +2219,142 @@ df_chain_free (void)\n /* Debugging info.  */\n \n static void\n-df_chain_top_dump (basic_block bb, FILE *file)\n+df_chain_bb_dump (basic_block bb, FILE *file, bool top)\n {\n+  /* Artificials are only hard regs.  */\n+  if (df->changeable_flags & DF_NO_HARD_REGS)\n+    return;\n+  if (df_chain_problem_p (DF_UD_CHAIN))\n+    {\n+      fprintf (file,\n+\t       \";;  UD chains for artificial uses at %s\\n\",\n+\t       top ? \"top\" : \"bottom\");\n+      df_ref *use_rec = df_get_artificial_uses (bb->index);\n+      if (*use_rec)\n+\t{\n+\t  while (*use_rec)\n+\t    {\n+\t      df_ref use = *use_rec;\n+\t      if ((top && (DF_REF_FLAGS (use) & DF_REF_AT_TOP))\n+\t\t  || (!top && !(DF_REF_FLAGS (use) & DF_REF_AT_TOP)))\n+\t\t{\n+\t\t  fprintf (file, \";;   reg %d \", DF_REF_REGNO (use));\n+\t\t  df_chain_dump (DF_REF_CHAIN (use), file);\n+\t\t  fprintf (file, \"\\n\");\n+\t\t}\n+\t      use_rec++;\n+\t    }\n+\t}\n+    }\n   if (df_chain_problem_p (DF_DU_CHAIN))\n     {\n-      rtx insn;\n+      fprintf (file,\n+\t       \";;  DU chains for artificial defs at %s\\n\",\n+\t       top ? \"top\" : \"bottom\");\n       df_ref *def_rec = df_get_artificial_defs (bb->index);\n       if (*def_rec)\n \t{\n-\n-\t  fprintf (file, \";;  DU chains for artificial defs\\n\");\n \t  while (*def_rec)\n \t    {\n \t      df_ref def = *def_rec;\n-\t      fprintf (file, \";;   reg %d \", DF_REF_REGNO (def));\n-\t      df_chain_dump (DF_REF_CHAIN (def), file);\n-\t      fprintf (file, \"\\n\");\n-\t      def_rec++;\n-\t    }\n-\t}\n \n-      FOR_BB_INSNS (bb, insn)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-\t      def_rec = DF_INSN_INFO_DEFS (insn_info);\n-\t      if (*def_rec)\n+\t      if ((top && (DF_REF_FLAGS (def) & DF_REF_AT_TOP))\n+\t\t  || (!top && !(DF_REF_FLAGS (def) & DF_REF_AT_TOP)))\n \t\t{\n-\t\t  fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\",\n-\t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-\n-\t\t  while (*def_rec)\n-\t\t    {\n-\t\t      df_ref def = *def_rec;\n-\t\t      fprintf (file, \";;      reg %d \", DF_REF_REGNO (def));\n-\t\t      if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n-\t\t\tfprintf (file, \"read/write \");\n-\t\t      df_chain_dump (DF_REF_CHAIN (def), file);\n-\t\t      fprintf (file, \"\\n\");\n-\t\t      def_rec++;\n-\t\t    }\n+\t\t  fprintf (file, \";;   reg %d \", DF_REF_REGNO (def));\n+\t\t  df_chain_dump (DF_REF_CHAIN (def), file);\n+\t\t  fprintf (file, \"\\n\");\n \t\t}\n+\t      def_rec++;\n \t    }\n \t}\n     }\n }\n \n+static void\n+df_chain_top_dump (basic_block bb, FILE *file)\n+{\n+  df_chain_bb_dump (bb, file, /*top=*/true);\n+}\n \n static void\n df_chain_bottom_dump (basic_block bb, FILE *file)\n {\n-  if (df_chain_problem_p (DF_UD_CHAIN))\n-    {\n-      rtx insn;\n-      df_ref *use_rec = df_get_artificial_uses (bb->index);\n+  df_chain_bb_dump (bb, file, /*top=*/false);\n+}\n \n-      if (*use_rec)\n+static void\n+df_chain_insn_top_dump (const_rtx insn, FILE *file)\n+{\n+  if (df_chain_problem_p (DF_UD_CHAIN) && INSN_P (insn))\n+    {\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      df_ref *use_rec = DF_INSN_INFO_USES (insn_info);\n+      df_ref *eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n+      fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\",\n+\t       DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n+      if (*use_rec || *eq_use_rec)\n \t{\n-\t  fprintf (file, \";;  UD chains for artificial uses\\n\");\n \t  while (*use_rec)\n \t    {\n \t      df_ref use = *use_rec;\n-\t      fprintf (file, \";;   reg %d \", DF_REF_REGNO (use));\n-\t      df_chain_dump (DF_REF_CHAIN (use), file);\n-\t      fprintf (file, \"\\n\");\n+\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n+\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t\t{\n+\t\t  fprintf (file, \";;      reg %d \", DF_REF_REGNO (use));\n+\t\t  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n+\t\t    fprintf (file, \"read/write \");\n+\t\t  df_chain_dump (DF_REF_CHAIN (use), file);\n+\t\t  fprintf (file, \"\\n\");\n+\t\t}\n \t      use_rec++;\n \t    }\n+\t  while (*eq_use_rec)\n+\t    {\n+\t      df_ref use = *eq_use_rec;\n+\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (use))\n+\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n+\t\t{\n+\t\t  fprintf (file, \";;   eq_note reg %d \", DF_REF_REGNO (use));\n+\t\t  df_chain_dump (DF_REF_CHAIN (use), file);\n+\t\t  fprintf (file, \"\\n\");\n+\t\t}\n+\t      eq_use_rec++;\n+\t    }\n \t}\n+    }\n+}\n \n-      FOR_BB_INSNS (bb, insn)\n+static void\n+df_chain_insn_bottom_dump (const_rtx insn, FILE *file)\n+{\n+  if (df_chain_problem_p (DF_DU_CHAIN) && INSN_P (insn))\n+    {\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      df_ref *def_rec = DF_INSN_INFO_DEFS (insn_info);\n+      fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\",\n+\t       DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n+      if (*def_rec)\n \t{\n-\t  if (INSN_P (insn))\n+\t  while (*def_rec)\n \t    {\n-\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n-\t      df_ref *eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n-\t      use_rec = DF_INSN_INFO_USES (insn_info);\n-\t      if (*use_rec || *eq_use_rec)\n+\t      df_ref def = *def_rec;\n+\t      if (! HARD_REGISTER_NUM_P (DF_REF_REGNO (def))\n+\t\t  || !(df->changeable_flags & DF_NO_HARD_REGS))\n \t\t{\n-\t\t  fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\",\n-\t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n-\n-\t\t  while (*use_rec)\n-\t\t    {\n-\t\t      df_ref use = *use_rec;\n-\t\t      fprintf (file, \";;      reg %d \", DF_REF_REGNO (use));\n-\t\t      if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n-\t\t\tfprintf (file, \"read/write \");\n-\t\t      df_chain_dump (DF_REF_CHAIN (use), file);\n-\t\t      fprintf (file, \"\\n\");\n-\t\t      use_rec++;\n-\t\t    }\n-\t\t  while (*eq_use_rec)\n-\t\t    {\n-\t\t      df_ref use = *eq_use_rec;\n-\t\t      fprintf (file, \";;   eq_note reg %d \", DF_REF_REGNO (use));\n-\t\t      df_chain_dump (DF_REF_CHAIN (use), file);\n-\t\t      fprintf (file, \"\\n\");\n-\t\t      eq_use_rec++;\n-\t\t    }\n+\t\t  fprintf (file, \";;      reg %d \", DF_REF_REGNO (def));\n+\t\t  if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n+\t\t    fprintf (file, \"read/write \");\n+\t\t  df_chain_dump (DF_REF_CHAIN (def), file);\n+\t\t  fprintf (file, \"\\n\");\n \t\t}\n+\t      def_rec++;\n \t    }\n \t}\n+      fprintf (file, \"\\n\");\n     }\n }\n \n-\n static struct df_problem problem_CHAIN =\n {\n   DF_CHAIN,                   /* Problem id.  */\n@@ -2265,6 +2374,8 @@ static struct df_problem problem_CHAIN =\n   NULL,                       /* Debugging.  */\n   df_chain_top_dump,          /* Debugging start block.  */\n   df_chain_bottom_dump,       /* Debugging end block.  */\n+  df_chain_insn_top_dump,     /* Debugging start insn.  */\n+  df_chain_insn_bottom_dump,  /* Debugging end insn.  */\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   &problem_RD,                /* Dependent problem.  */\n@@ -2643,9 +2754,11 @@ static struct df_problem problem_WORD_LR =\n   NULL,                            /* Debugging.  */\n   df_word_lr_top_dump,             /* Debugging start block.  */\n   df_word_lr_bottom_dump,          /* Debugging end block.  */\n+  NULL,                            /* Debugging start insn.  */\n+  NULL,                            /* Debugging end insn.  */\n   NULL,                            /* Incremental solution verify start.  */\n   NULL,                            /* Incremental solution verify end.  */\n-  NULL,                       /* Dependent problem.  */\n+  NULL,                            /* Dependent problem.  */\n   sizeof (struct df_word_lr_bb_info),/* Size of entry of block_info array.  */\n   TV_DF_WORD_LR,                   /* Timing variable.  */\n   false                            /* Reset blocks on dropping out of blocks_to_analyze.  */\n@@ -3330,6 +3443,8 @@ static struct df_problem problem_NOTE =\n   NULL,                       /* Debugging.  */\n   NULL,                       /* Debugging start block.  */\n   NULL,                       /* Debugging end block.  */\n+  NULL,                       /* Debugging start insn.  */\n+  NULL,                       /* Debugging end insn.  */\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   &problem_LR,                /* Dependent problem.  */\n@@ -4382,6 +4497,8 @@ static struct df_problem problem_MD =\n   NULL,                       /* Debugging.  */\n   df_md_top_dump,             /* Debugging start block.  */\n   df_md_bottom_dump,          /* Debugging end block.  */\n+  NULL,                       /* Debugging start insn.  */\n+  NULL,                       /* Debugging end insn.  */\n   NULL,\t\t\t      /* Incremental solution verify start.  */\n   NULL,\t\t\t      /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */"}, {"sha": "23da115f1789d26e6f6e4792f00a8f3a471e588b", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -510,6 +510,8 @@ static struct df_problem problem_SCAN =\n   df_scan_start_dump,         /* Debugging.  */\n   df_scan_start_block,        /* Debugging start block.  */\n   NULL,                       /* Debugging end block.  */\n+  NULL,                       /* Debugging start insn.  */\n+  NULL,                       /* Debugging end insn.  */\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */"}, {"sha": "e7031d0bb2fa70fd8552f96aebde1f7dfdda197b", "filename": "gcc/df.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -239,6 +239,9 @@ typedef void (*df_dump_problem_function) (FILE *);\n /* Function to dump top or bottom of basic block results to FILE.  */\n typedef void (*df_dump_bb_problem_function) (basic_block, FILE *);\n \n+/* Function to dump before or after an insn to FILE.  */\n+typedef void (*df_dump_insn_problem_function) (const_rtx, FILE *);\n+\n /* Function to dump top or bottom of basic block results to FILE.  */\n typedef void (*df_verify_solution_start) (void);\n \n@@ -268,6 +271,8 @@ struct df_problem {\n   df_dump_problem_function dump_start_fun;\n   df_dump_bb_problem_function dump_top_fun;\n   df_dump_bb_problem_function dump_bottom_fun;\n+  df_dump_insn_problem_function dump_insn_top_fun;\n+  df_dump_insn_problem_function dump_insn_bottom_fun;\n   df_verify_solution_start verify_start_fun;\n   df_verify_solution_end verify_end_fun;\n   struct df_problem *dependent_problem;\n@@ -463,7 +468,12 @@ enum df_changeable_flags\n   rescans to be batched.  */\n   DF_DEFER_INSN_RESCAN    = 1 << 5,\n \n-  DF_VERIFY_SCHEDULED     = 1 << 6\n+  /* Compute the reaching defs problem as \"live and reaching defs\" (LR&RD).\n+     A DEF is reaching and live at insn I if DEF reaches I and REGNO(DEF)\n+     is in LR_IN of the basic block containing I.  */\n+  DF_RD_PRUNE_DEAD_DEFS   = 1 << 6,\n+\n+  DF_VERIFY_SCHEDULED     = 1 << 7\n };\n \n /* Two of these structures are inline in df, one for the uses and one\n@@ -773,7 +783,9 @@ struct df_scan_bb_info\n \n \n /* Reaching definitions.  All bitmaps are indexed by the id field of\n-   the ref except sparse_kill which is indexed by regno.  */\n+   the ref except sparse_kill which is indexed by regno.  For the\n+   LR&RD problem, the kill set is not complete: It does not contain\n+   DEFs killed because the set register has died in the LR set.  */\n struct df_rd_bb_info\n {\n   /* Local sets to describe the basic blocks.   */\n@@ -918,6 +930,8 @@ extern void df_dump_region (FILE *);\n extern void df_dump_start (FILE *);\n extern void df_dump_top (basic_block, FILE *);\n extern void df_dump_bottom (basic_block, FILE *);\n+extern void df_dump_insn_top (const_rtx, FILE *);\n+extern void df_dump_insn_bottom (const_rtx, FILE *);\n extern void df_refs_chain_dump (df_ref *, bool, FILE *);\n extern void df_regs_chain_dump (df_ref,  FILE *);\n extern void df_insn_debug (rtx, bool, FILE *);"}, {"sha": "a420569fd43daaed07c366329e29430a4331a1bd", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -659,20 +659,28 @@ find_defs (struct loop *loop, basic_block *body)\n   for (i = 0; i < loop->num_nodes; i++)\n     bitmap_set_bit (blocks, body[i]->index);\n \n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"*****starting processing of loop %d ******\\n\",\n+\t       loop->num);\n+    }\n+\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n   df_set_blocks (blocks);\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_analyze ();\n+  check_invariant_table_size ();\n \n   if (dump_file)\n     {\n       df_dump_region (dump_file);\n-      fprintf (dump_file, \"*****starting processing of loop  ******\\n\");\n-      print_rtl_with_bb (dump_file, get_insns (), dump_flags);\n-      fprintf (dump_file, \"*****ending processing of loop  ******\\n\");\n+      fprintf (dump_file,\n+\t       \"*****ending processing of loop %d ******\\n\",\n+\t       loop->num);\n     }\n-  check_invariant_table_size ();\n \n   BITMAP_FREE (blocks);\n }"}, {"sha": "e5c72596a32be4902b985967aca8ea74d0a8dc8f", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -293,6 +293,7 @@ iv_analysis_loop_init (struct loop *loop)\n      the problem back.  */\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_chain_add_problem (DF_UD_CHAIN);\n   df_note_add_problem ();\n   df_set_blocks (blocks);"}, {"sha": "167efa3fe1dd242570c96f2b3c2f98278908217f", "filename": "gcc/ree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -868,6 +868,7 @@ find_and_remove_re (void)\n \n   /* Construct DU chain to get all reaching definitions of each\n      extension instruction.  */\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);"}, {"sha": "f60b4b6ad84ea3c080af00b8b5a5dec405f825c3", "filename": "gcc/web.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b19209f2934c0ac28445ff2032747552a390f2f/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=7b19209f2934c0ac28445ff2032747552a390f2f", "patch": "@@ -313,6 +313,7 @@ web_main (void)\n   rtx insn;\n \n   df_set_flags (DF_NO_HARD_REGS + DF_EQ_NOTES);\n+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_chain_add_problem (DF_UD_CHAIN);\n   df_analyze ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);"}]}