{"sha": "893479def2f2b98d16e7311fe3bfff58ed003467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzNDc5ZGVmMmYyYjk4ZDE2ZTczMTFmZTNiZmZmNThlZDAwMzQ2Nw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2014-10-22T14:26:56Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2014-10-22T14:26:56Z"}, "message": "cfgbuild.h: New.\n\n\n\n2014-10-22  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* cfgbuild.h: New.  Add prototypes for cfgbuild.c.\n\t* cfgcleanup.h: New.  Add prototypes for cfgcleanup.c.\n\t* cfgloopmanip.h: New.  Add prototypes for cfgloopmanip.c.\n\t* dominance.h: New.  Add prototypes for dominance.c.\n\t* cfgloop.h: Move some prototypes/enum to cfgloopmanip.h and include it.\n\t* cfghooks.h: (struct profile_record) Relocate here.\n\tRelocate 2 prototypes from basic-block.h.\n\t* basic-block.h: Move prototypes and struct to new header files.\n\tInclude cfgbuild.h, cfgcleanup.h, and dominance.h.\n\t* rtl.h: Move a few prototypes to new header files.\n\t* cfgcleanup.c (merge_memattrs): Make static.\n\t* genopinit.c (main): Add predict.h to list of includes.\n\t* predict.h: Update prototype list to match predict.c.\n\t* predict.c (maybe_hot_count_p): Export.\n\t(cgraph_edge::maybe_hot_p): Move to cgraph.c.\n\t(cgraph_node::optimize_for_size_p): Move to cgraph.h.\n\t* cgraph.h (cgraph_node::optimize_for_size_p): Relocate here.\n\t* cgraph.c (cgraph_edge::maybe_hot_p): Relocate here.\n\t* profile.h: Adjust prototypes.\n\t* ifcvt.h: New.  Relocate struct ce_if_block here.\n\t* ifcvt.c: Include ifcvt.h.\n\n\t* config/frv/frv.c: Include ifcvt.h.\n\t* config/frv/frv-protos.h: Add 'struct' to ce_if_block * parameters.\n\nFrom-SVN: r216559", "tree": {"sha": "9d61392a70f0091f38c55c6d45211065e1032b6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d61392a70f0091f38c55c6d45211065e1032b6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893479def2f2b98d16e7311fe3bfff58ed003467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893479def2f2b98d16e7311fe3bfff58ed003467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893479def2f2b98d16e7311fe3bfff58ed003467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893479def2f2b98d16e7311fe3bfff58ed003467/comments", "author": null, "committer": null, "parents": [{"sha": "4a7fca26b4c148457bef6da0975f1122aa106271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7fca26b4c148457bef6da0975f1122aa106271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7fca26b4c148457bef6da0975f1122aa106271"}], "stats": {"total": 696, "additions": 409, "deletions": 287}, "files": [{"sha": "be45d7ecd2b6246e6966e9a35398332a211c98cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -1,3 +1,29 @@\n+2014-10-22  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* cfgbuild.h: New.  Add prototypes for cfgbuild.c.\n+\t* cfgcleanup.h: New.  Add prototypes for cfgcleanup.c.\n+\t* cfgloopmanip.h: New.  Add prototypes for cfgloopmanip.c.\n+\t* dominance.h: New.  Add prototypes for dominance.c.\n+\t* cfgloop.h: Move some prototypes/enum to cfgloopmanip.h and include it.\n+\t* cfghooks.h: (struct profile_record) Relocate here.\n+\tRelocate 2 prototypes from basic-block.h.\n+\t* basic-block.h: Move prototypes and struct to new header files.\n+\tInclude cfgbuild.h, cfgcleanup.h, and dominance.h.\n+\t* rtl.h: Move a few prototypes to new header files.\n+\t* cfgcleanup.c (merge_memattrs): Make static.\n+\t* genopinit.c (main): Add predict.h to list of includes.\n+\t* predict.h: Update prototype list to match predict.c.\n+\t* predict.c (maybe_hot_count_p): Export.\n+\t(cgraph_edge::maybe_hot_p): Move to cgraph.c.\n+\t(cgraph_node::optimize_for_size_p): Move to cgraph.h.\n+\t* cgraph.h (cgraph_node::optimize_for_size_p): Relocate here.\n+\t* cgraph.c (cgraph_edge::maybe_hot_p): Relocate here.\n+\t* profile.h: Adjust prototypes.\n+\t* ifcvt.h: New.  Relocate struct ce_if_block here.\n+\t* ifcvt.c: Include ifcvt.h.\n+\t* config/frv/frv.c: Include ifcvt.h.\n+\t* config/frv/frv-protos.h: Add 'struct' to ce_if_block * parameters.\n+\n 2014-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* lra.c (lra): Remove call to recog_init."}, {"sha": "7731c79952e996e708cd6d8a3522f89d0c21652a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 171, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -33,6 +33,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfg.h\"\n #include \"cfganal.h\"\n #include \"lcm.h\"\n+#include \"cfgbuild.h\"\n+#include \"cfgcleanup.h\"\n+#include \"dominance.h\"\n \n /* Use gcov_type to hold basic block counters.  Should be at least\n    64bit.  Although a counter cannot be negative, we use a signed\n@@ -85,38 +88,6 @@ enum cfg_edge_flags {\n #define EDGE_COMPLEX \\\n   (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_PRESERVE)\n \n-/* Structure to gather statistic about profile consistency, per pass.\n-   An array of this structure, indexed by pass static number, is allocated\n-   in passes.c.  The structure is defined here so that different CFG modes\n-   can do their book-keeping via CFG hooks.\n-\n-   For every field[2], field[0] is the count before the pass runs, and\n-   field[1] is the post-pass count.  This allows us to monitor the effect\n-   of each individual pass on the profile consistency.\n-   \n-   This structure is not supposed to be used by anything other than passes.c\n-   and one CFG hook per CFG mode.  */\n-struct profile_record\n-{\n-  /* The number of basic blocks where sum(freq) of the block's predecessors\n-     doesn't match reasonably well with the incoming frequency.  */\n-  int num_mismatched_freq_in[2];\n-  /* Likewise for a basic block's successors.  */\n-  int num_mismatched_freq_out[2];\n-  /* The number of basic blocks where sum(count) of the block's predecessors\n-     doesn't match reasonably well with the incoming frequency.  */\n-  int num_mismatched_count_in[2];\n-  /* Likewise for a basic block's successors.  */\n-  int num_mismatched_count_out[2];\n-  /* A weighted cost of the run-time of the function body.  */\n-  gcov_type time[2];\n-  /* A weighted cost of the size of the function body.  */\n-  int size[2];\n-  /* True iff this pass actually was run.  */\n-  bool run;\n-};\n-\n-\n struct GTY(()) rtl_bb_info {\n   /* The first insn of the block is embedded into bb->il.x.  */\n   /* The last insn of the block.  */\n@@ -249,15 +220,6 @@ enum cfg_bb_flags\n #define BB_COPY_PARTITION(dstbb, srcbb) \\\n   BB_SET_PARTITION (dstbb, BB_PARTITION (srcbb))\n \n-/* State of dominance information.  */\n-\n-enum dom_state\n-{\n-  DOM_NONE,\t\t/* Not computed at all.  */\n-  DOM_NO_FAST_QUERY,\t/* The data is OK, but the fast query data are not usable.  */\n-  DOM_OK\t\t/* Everything is ok.  */\n-};\n-\n /* What sort of profiling information we have.  */\n enum profile_status_d\n {\n@@ -383,31 +345,6 @@ struct GTY(()) control_flow_graph {\n /* The two blocks that are always in the cfg.  */\n #define NUM_FIXED_BLOCKS (2)\n \n-\n-extern edge redirect_edge_succ_nodup (edge, basic_block);\n-\n-/* Structure to group all of the information to process IF-THEN and\n-   IF-THEN-ELSE blocks for the conditional execution support.  This\n-   needs to be in a public file in case the IFCVT macros call\n-   functions passing the ce_if_block data structure.  */\n-\n-struct ce_if_block\n-{\n-  basic_block test_bb;\t\t\t/* First test block.  */\n-  basic_block then_bb;\t\t\t/* THEN block.  */\n-  basic_block else_bb;\t\t\t/* ELSE block or NULL.  */\n-  basic_block join_bb;\t\t\t/* Join THEN/ELSE blocks.  */\n-  basic_block last_test_bb;\t\t/* Last bb to hold && or || tests.  */\n-  int num_multiple_test_blocks;\t\t/* # of && and || basic blocks.  */\n-  int num_and_and_blocks;\t\t/* # of && blocks.  */\n-  int num_or_or_blocks;\t\t\t/* # of || blocks.  */\n-  int num_multiple_test_insns;\t\t/* # of insns in && and || blocks.  */\n-  int and_and_p;\t\t\t/* Complex test is &&.  */\n-  int num_then_insns;\t\t\t/* # of insns in THEN block.  */\n-  int num_else_insns;\t\t\t/* # of insns in ELSE block.  */\n-  int pass;\t\t\t\t/* Pass number.  */\n-};\n-\n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n \n@@ -649,97 +586,6 @@ ei_cond (edge_iterator ei, edge *p)\n #define CLEANUP_CFGLAYOUT\t32\t/* Do cleanup in cfglayout mode.  */\n #define CLEANUP_CFG_CHANGED\t64      /* The caller changed the CFG.  */\n \n-extern void dump_flow_info (FILE *, int);\n-\n-/* In predict.c */\n-extern bool maybe_hot_count_p (struct function *, gcov_type);\n-extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n-extern bool maybe_hot_edge_p (edge);\n-extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n-extern bool probably_never_executed_edge_p (struct function *, edge);\n-extern bool optimize_bb_for_size_p (const_basic_block);\n-extern bool optimize_bb_for_speed_p (const_basic_block);\n-extern bool optimize_edge_for_size_p (edge);\n-extern bool optimize_edge_for_speed_p (edge);\n-extern bool optimize_loop_for_size_p (struct loop *);\n-extern bool optimize_loop_for_speed_p (struct loop *);\n-extern bool optimize_loop_nest_for_size_p (struct loop *);\n-extern bool optimize_loop_nest_for_speed_p (struct loop *);\n-extern bool gimple_predicted_by_p (const_basic_block, enum br_predictor);\n-extern bool rtl_predicted_by_p (const_basic_block, enum br_predictor);\n-extern void gimple_predict_edge (edge, enum br_predictor, int);\n-extern void rtl_predict_edge (edge, enum br_predictor, int);\n-extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n-extern void guess_outgoing_edge_probabilities (basic_block);\n-extern void remove_predictions_associated_with_edge (edge);\n-extern bool edge_probability_reliable_p (const_edge);\n-extern bool br_prob_note_reliable_p (const_rtx);\n-extern bool predictable_edge_p (edge);\n-\n-/* In cfgbuild.c.  */\n-extern void find_many_sub_basic_blocks (sbitmap);\n-extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n-\n-enum replace_direction { dir_none, dir_forward, dir_backward, dir_both };\n-\n-/* In cfgcleanup.c.  */\n-extern bool cleanup_cfg (int);\n-extern int flow_find_cross_jump (basic_block, basic_block, rtx_insn **,\n-\t\t\t\t rtx_insn **, enum replace_direction*);\n-extern int flow_find_head_matching_sequence (basic_block, basic_block,\n-\t\t\t\t\t     rtx_insn **, rtx_insn **, int);\n-\n-extern bool delete_unreachable_blocks (void);\n-\n-extern bool inside_basic_block_p (const rtx_insn *);\n-extern bool control_flow_insn_p (const rtx_insn *);\n-extern rtx_insn *get_last_bb_insn (basic_block);\n-\n-/* In dominance.c */\n-\n-enum cdi_direction\n-{\n-  CDI_DOMINATORS = 1,\n-  CDI_POST_DOMINATORS = 2\n-};\n-\n-extern enum dom_state dom_info_state (function *, enum cdi_direction);\n-extern enum dom_state dom_info_state (enum cdi_direction);\n-extern void set_dom_info_availability (enum cdi_direction, enum dom_state);\n-extern bool dom_info_available_p (function *, enum cdi_direction);\n-extern bool dom_info_available_p (enum cdi_direction);\n-extern void calculate_dominance_info (enum cdi_direction);\n-extern void free_dominance_info (function *, enum cdi_direction);\n-extern void free_dominance_info (enum cdi_direction);\n-extern basic_block nearest_common_dominator (enum cdi_direction,\n-\t\t\t\t\t     basic_block, basic_block);\n-extern basic_block nearest_common_dominator_for_set (enum cdi_direction,\n-\t\t\t\t\t\t     bitmap);\n-extern void set_immediate_dominator (enum cdi_direction, basic_block,\n-\t\t\t\t     basic_block);\n-extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n-extern bool dominated_by_p (enum cdi_direction, const_basic_block, const_basic_block);\n-extern vec<basic_block> get_dominated_by (enum cdi_direction, basic_block);\n-extern vec<basic_block> get_dominated_by_region (enum cdi_direction,\n-\t\t\t\t\t\t\t basic_block *,\n-\t\t\t\t\t\t\t unsigned);\n-extern vec<basic_block> get_dominated_to_depth (enum cdi_direction,\n-\t\t\t\t\t\t\tbasic_block, int);\n-extern vec<basic_block> get_all_dominated_blocks (enum cdi_direction,\n-\t\t\t\t\t\t\t  basic_block);\n-extern void add_to_dominance_info (enum cdi_direction, basic_block);\n-extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n-basic_block recompute_dominator (enum cdi_direction, basic_block);\n-extern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n-\t\t\t\t\t   basic_block);\n-extern void iterate_fix_dominators (enum cdi_direction,\n-\t\t\t\t    vec<basic_block> , bool);\n-extern void verify_dominators (enum cdi_direction);\n-extern basic_block first_dom_son (enum cdi_direction, basic_block);\n-extern basic_block next_dom_son (enum cdi_direction, basic_block);\n-unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);\n-unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n-\n #include \"cfghooks.h\"\n \n /* Return true if BB is in a transaction.  */\n@@ -794,20 +640,6 @@ find_fallthru_edge (vec<edge, va_gc> *edges)\n   return e;\n }\n \n-/* In cfgloopmanip.c.  */\n-extern edge mfb_kj_edge;\n-extern bool mfb_keep_just (edge);\n-\n-/* In cfgexpand.c.  */\n-extern void rtl_profile_for_bb (basic_block);\n-extern void rtl_profile_for_edge (edge);\n-extern void default_rtl_profile (void);\n-\n-/* In profile.c.  */\n-typedef struct gcov_working_set_info gcov_working_set_t;\n-extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n-extern void add_working_set (gcov_working_set_t *);\n-\n /* Check tha probability is sane.  */\n \n static inline void"}, {"sha": "373361919c24e9a0ce32fc752a5b6b08518971de", "filename": "gcc/cfgbuild.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgbuild.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgbuild.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -0,0 +1,28 @@\n+/* Control flow graph building header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CFGBUILD_H\n+#define GCC_CFGBUILD_H\n+\n+extern bool inside_basic_block_p (const rtx_insn *);\n+extern bool control_flow_insn_p (const rtx_insn *);\n+extern void rtl_make_eh_edge (sbitmap, basic_block, rtx);\n+extern void find_many_sub_basic_blocks (sbitmap);\n+\n+#endif /* GCC_CFGBUILD_H */"}, {"sha": "f4f5aa13c1b30aebf8fc526321caee7e20a074a1", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -872,7 +872,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n /* Removes the memory attributes of MEM expression\n    if they are not equal.  */\n \n-void\n+static void\n merge_memattrs (rtx x, rtx y)\n {\n   int i;"}, {"sha": "cb5c8a6d5317c4b942be55a463f620917311b494", "filename": "gcc/cfgcleanup.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgcleanup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgcleanup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -0,0 +1,34 @@\n+/* Control flow optimization header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef GCC_CFGCLEANUP_H\n+#define GCC_CFGCLEANUP_H\n+\n+enum replace_direction { dir_none, dir_forward, dir_backward, dir_both };\n+\n+extern int flow_find_cross_jump (basic_block, basic_block, rtx_insn **,\n+\t\t\t\t rtx_insn **, enum replace_direction*);\n+extern int flow_find_head_matching_sequence (basic_block, basic_block,\n+\t\t\t\t\t     rtx_insn **, rtx_insn **, int);\n+extern bool delete_unreachable_blocks (void);\n+extern void delete_dead_jumptables (void);\n+extern bool cleanup_cfg (int);\n+\n+#endif /* GCC_CFGCLEANUP_H */"}, {"sha": "06a06db4c5a8a3d0234552973e57a988e4fd49a3", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -23,6 +23,38 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Only basic-block.h includes this.  */\n \n+/* Structure to gather statistic about profile consistency, per pass.\n+   An array of this structure, indexed by pass static number, is allocated\n+   in passes.c.  The structure is defined here so that different CFG modes\n+   can do their book-keeping via CFG hooks.\n+\n+   For every field[2], field[0] is the count before the pass runs, and\n+   field[1] is the post-pass count.  This allows us to monitor the effect\n+   of each individual pass on the profile consistency.\n+   \n+   This structure is not supposed to be used by anything other than passes.c\n+   and one CFG hook per CFG mode.  */\n+struct profile_record\n+{\n+  /* The number of basic blocks where sum(freq) of the block's predecessors\n+     doesn't match reasonably well with the incoming frequency.  */\n+  int num_mismatched_freq_in[2];\n+  /* Likewise for a basic block's successors.  */\n+  int num_mismatched_freq_out[2];\n+  /* The number of basic blocks where sum(count) of the block's predecessors\n+     doesn't match reasonably well with the incoming frequency.  */\n+  int num_mismatched_count_in[2];\n+  /* Likewise for a basic block's successors.  */\n+  int num_mismatched_count_out[2];\n+  /* A weighted cost of the run-time of the function body.  */\n+  gcov_type time[2];\n+  /* A weighted cost of the size of the function body.  */\n+  int size[2];\n+  /* True iff this pass actually was run.  */\n+  bool run;\n+};\n+\n+\n struct cfg_hooks\n {\n   /* Name of the corresponding ir.  */\n@@ -156,9 +188,11 @@ struct cfg_hooks\n extern void verify_flow_info (void);\n extern void dump_bb (FILE *, basic_block, int, int);\n extern void dump_bb_for_graph (pretty_printer *, basic_block);\n+extern void dump_flow_info (FILE *, int);\n \n extern edge redirect_edge_and_branch (edge, basic_block);\n extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n+extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern bool can_remove_branch_p (const_edge);\n extern void remove_branch (edge);\n extern void remove_edge (edge);"}, {"sha": "83c9905bc02fa9bfb2fd8607a9d7b44b4798083f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"input.h\"\n #include \"function.h\"\n+#include \"cfgloopmanip.h\"\n \n /* Structure to hold decision about unrolling/peeling.  */\n enum lpt_dec\n@@ -271,8 +272,6 @@ void rescan_loop_exit (edge, bool, bool);\n /* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n extern void flow_loop_tree_node_remove (struct loop *);\n-extern void place_new_loop (struct function *, struct loop *);\n-extern void add_loop (struct loop *, struct loop *);\n extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n extern bool flow_bb_inside_loop_p (const struct loop *, const_basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n@@ -310,15 +309,6 @@ extern void remove_bb_from_loops (basic_block);\n extern void cancel_loop_tree (struct loop *);\n extern void delete_loop (struct loop *);\n \n-enum\n-{\n-  CP_SIMPLE_PREHEADERS = 1,\n-  CP_FALLTHRU_PREHEADERS = 2\n-};\n-\n-basic_block create_preheader (struct loop *, int);\n-extern void create_preheaders (int);\n-extern void force_single_succ_latches (void);\n \n extern void verify_loop_structure (void);\n \n@@ -328,37 +318,8 @@ gcov_type expected_loop_iterations_unbounded (const struct loop *);\n extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n \n-\n-/* Loop manipulation.  */\n-extern bool can_duplicate_loop_p (const struct loop *loop);\n-\n-#define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n-\t\t\t\t\t   duplicate_loop_to_header_edge.  */\n-#define DLTHE_RECORD_COPY_NUMBER 2\t/* Record copy number in the aux\n-\t\t\t\t\t   field of newly create BB.  */\n-#define DLTHE_FLAG_COMPLETTE_PEEL 4\t/* Update frequencies expecting\n-\t\t\t\t\t   a complete peeling.  */\n-\n-extern edge create_empty_if_region_on_edge (edge, tree);\n-extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n-\t\t\t\t\t       tree *, tree *, struct loop *);\n-extern struct loop * duplicate_loop (struct loop *, struct loop *);\n-extern void copy_loop_info (struct loop *loop, struct loop *target);\n-extern void duplicate_subloops (struct loop *, struct loop *);\n-extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n-\t\t\t\t\t   unsigned, sbitmap, edge,\n- \t\t\t\t\t   vec<edge> *, int);\n-extern struct loop *loopify (edge, edge,\n-\t\t\t     basic_block, edge, edge, bool,\n-\t\t\t     unsigned, unsigned);\n-struct loop * loop_version (struct loop *, void *,\n-\t\t\t    basic_block *, unsigned, unsigned, unsigned, bool);\n-extern bool remove_path (edge);\n-extern void unloop (struct loop *, bool *, bitmap);\n-extern void scale_loop_frequencies (struct loop *, int, int);\n void mark_loop_for_removal (loop_p);\n \n-\n /* Induction variable analysis.  */\n \n /* The description of induction variable.  The things are a bit complicated\n@@ -742,7 +703,6 @@ enum\n \n extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n-extern void scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound);\n extern vec<basic_block> get_loop_hot_path (const struct loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/"}, {"sha": "cbf8e7cdf36e5ac85f5af0ca4133e94d8a5f8e9e", "filename": "gcc/cfgloopmanip.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -0,0 +1,63 @@\n+/* Loop manipulation header.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CFGLOOPMANIP_H\n+#define GCC_CFGLOOPMANIP_H\n+\n+enum\n+{\n+  CP_SIMPLE_PREHEADERS = 1,\n+  CP_FALLTHRU_PREHEADERS = 2\n+};\n+\n+#define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n+\t\t\t\t\t   duplicate_loop_to_header_edge.  */\n+#define DLTHE_RECORD_COPY_NUMBER 2\t/* Record copy number in the aux\n+\t\t\t\t\t   field of newly create BB.  */\n+#define DLTHE_FLAG_COMPLETTE_PEEL 4\t/* Update frequencies expecting\n+\t\t\t\t\t   a complete peeling.  */\n+extern edge mfb_kj_edge;\n+\n+extern bool remove_path (edge);\n+extern void place_new_loop (struct function *, struct loop *);\n+extern void add_loop (struct loop *, struct loop *);\n+extern void scale_loop_frequencies (struct loop *, int, int);\n+extern void scale_loop_profile (struct loop *, int, gcov_type);\n+extern edge create_empty_if_region_on_edge (edge, tree);\n+extern struct loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n+\t\t\t\t\t       tree *, tree *, struct loop *);\n+extern struct loop *loopify (edge, edge,\n+\t\t\t     basic_block, edge, edge, bool,\n+\t\t\t     unsigned, unsigned);\n+extern void unloop (struct loop *, bool *, bitmap);\n+extern void copy_loop_info (struct loop *loop, struct loop *target);\n+extern struct loop * duplicate_loop (struct loop *, struct loop *);\n+extern void duplicate_subloops (struct loop *, struct loop *);\n+extern bool can_duplicate_loop_p (const struct loop *loop);\n+extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n+\t\t\t\t\t   unsigned, sbitmap, edge,\n+ \t\t\t\t\t   vec<edge> *, int);\n+extern bool mfb_keep_just (edge);\n+basic_block create_preheader (struct loop *, int);\n+extern void create_preheaders (int);\n+extern void force_single_succ_latches (void);\n+struct loop * loop_version (struct loop *, void *,\n+\t\t\t    basic_block *, unsigned, unsigned, unsigned, bool);\n+\n+#endif /* GCC_CFGLOOPMANIP_H */"}, {"sha": "e6af33dcb4cb5e77faa169c527c6d121f2d3da71", "filename": "gcc/cgraph.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -64,6 +64,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"expr.h\"\n #include \"tree-dfa.h\"\n+#include \"profile.h\"\n+#include \"params.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -2310,6 +2312,38 @@ cgraph_edge::cannot_lead_to_return_p (void)\n     return callee->cannot_return_p ();\n }\n \n+/* Return true if the call can be hot.  */\n+\n+bool\n+cgraph_edge::maybe_hot_p (void)\n+{\n+  if (profile_info && flag_branch_probabilities\n+      && !maybe_hot_count_p (NULL, count))\n+    return false;\n+  if (caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n+      || (callee\n+\t  && callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n+    return false;\n+  if (caller->frequency > NODE_FREQUENCY_UNLIKELY_EXECUTED\n+      && (callee\n+\t  && callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE))\n+    return false;\n+  if (optimize_size) return false;\n+  if (caller->frequency == NODE_FREQUENCY_HOT)\n+    return true;\n+  if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+      && frequency < CGRAPH_FREQ_BASE * 3 / 2)\n+    return false;\n+  if (flag_guess_branch_prob)\n+    {\n+      if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0\n+\t  || frequency <= (CGRAPH_FREQ_BASE\n+\t\t\t\t / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n+        return false;\n+    }\n+  return true;\n+}\n+\n /* Return true when function can be removed from callgraph\n    if all direct calls are eliminated.  */\n "}, {"sha": "be1f10e416510c26617c7ea971e3ddc8b16f95a5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -2708,6 +2708,19 @@ cgraph_node::mark_force_output (void)\n   gcc_checking_assert (!global.inlined_to);\n }\n \n+/* Return true if function should be optimized for size.  */\n+\n+inline bool\n+cgraph_node::optimize_for_size_p (void)\n+{\n+  if (optimize_size)\n+    return true;\n+  if (frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+    return true;\n+  else\n+    return false;\n+}\n+\n inline symtab_node * symtab_node::get_create (tree node)\n {\n   if (TREE_CODE (node) == VAR_DECL)"}, {"sha": "7bf8c7a991ce360b4b69e714d069a206873bf58f", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -62,14 +62,14 @@ extern rtx frv_split_abs\t\t(rtx *);\n extern void frv_split_double_load\t(rtx, rtx);\n extern void frv_split_double_store\t(rtx, rtx);\n #ifdef BB_HEAD\n-extern void frv_ifcvt_init_extra_fields\t(ce_if_block *);\n-extern void frv_ifcvt_modify_tests\t(ce_if_block *, rtx *, rtx *);\n+extern void frv_ifcvt_init_extra_fields\t(struct ce_if_block *);\n+extern void frv_ifcvt_modify_tests\t(struct ce_if_block *, rtx *, rtx *);\n extern void frv_ifcvt_modify_multiple_tests\n-\t\t\t\t\t(ce_if_block *, basic_block,\n+\t\t\t\t\t(struct ce_if_block *, basic_block,\n \t\t\t\t\t rtx *, rtx *);\n-extern rtx frv_ifcvt_modify_insn\t(ce_if_block *, rtx, rtx);\n-extern void frv_ifcvt_modify_final\t(ce_if_block *);\n-extern void frv_ifcvt_modify_cancel\t(ce_if_block *);\n+extern rtx frv_ifcvt_modify_insn\t(struct ce_if_block *, rtx, rtx);\n+extern void frv_ifcvt_modify_final\t(struct ce_if_block *);\n+extern void frv_ifcvt_modify_cancel\t(struct ce_if_block *);\n #endif\n extern enum reg_class frv_secondary_reload_class\n \t\t\t\t\t(enum reg_class,"}, {"sha": "e2cfb12c60ac508da9bffcf3a893d896d630a01a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"dumpfile.h\"\n #include \"builtins.h\"\n+#include \"ifcvt.h\"\n \n #ifndef FRV_INLINE\n #define FRV_INLINE inline"}, {"sha": "0c83ba56892b51455bacc8e684fdd90a12b968ba", "filename": "gcc/dominance.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -0,0 +1,78 @@\n+/* Calculate (post)dominators header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DOMINANCE_H\n+#define GCC_DOMINANCE_H\n+\n+enum cdi_direction\n+{\n+  CDI_DOMINATORS = 1,\n+  CDI_POST_DOMINATORS = 2\n+};\n+\n+/* State of dominance information.  */\n+\n+enum dom_state\n+{\n+  DOM_NONE,\t\t/* Not computed at all.  */\n+  DOM_NO_FAST_QUERY,\t/* The data is OK, but the fast query data are not usable.  */\n+  DOM_OK\t\t/* Everything is ok.  */\n+};\n+\n+extern void calculate_dominance_info (enum cdi_direction);\n+extern void free_dominance_info (function *, enum cdi_direction);\n+extern void free_dominance_info (enum cdi_direction);\n+extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n+extern void set_immediate_dominator (enum cdi_direction, basic_block,\n+\t\t\t\t     basic_block);\n+extern vec<basic_block> get_dominated_by (enum cdi_direction, basic_block);\n+extern vec<basic_block> get_dominated_by_region (enum cdi_direction,\n+\t\t\t\t\t\t\t basic_block *,\n+\t\t\t\t\t\t\t unsigned);\n+extern vec<basic_block> get_dominated_to_depth (enum cdi_direction,\n+\t\t\t\t\t\t\tbasic_block, int);\n+extern vec<basic_block> get_all_dominated_blocks (enum cdi_direction,\n+\t\t\t\t\t\t\t  basic_block);\n+extern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n+\t\t\t\t\t   basic_block);\n+extern basic_block nearest_common_dominator (enum cdi_direction,\n+\t\t\t\t\t     basic_block, basic_block);\n+extern basic_block nearest_common_dominator_for_set (enum cdi_direction,\n+\t\t\t\t\t\t     bitmap);\n+extern bool dominated_by_p (enum cdi_direction, const_basic_block,\n+\t\t\t    const_basic_block);\n+unsigned bb_dom_dfs_in (enum cdi_direction, basic_block);\n+unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n+extern void verify_dominators (enum cdi_direction);\n+basic_block recompute_dominator (enum cdi_direction, basic_block);\n+extern void iterate_fix_dominators (enum cdi_direction,\n+\t\t\t\t    vec<basic_block> , bool);\n+extern void add_to_dominance_info (enum cdi_direction, basic_block);\n+extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n+extern basic_block first_dom_son (enum cdi_direction, basic_block);\n+extern basic_block next_dom_son (enum cdi_direction, basic_block);\n+extern enum dom_state dom_info_state (function *, enum cdi_direction);\n+extern enum dom_state dom_info_state (enum cdi_direction);\n+extern void set_dom_info_availability (enum cdi_direction, enum dom_state);\n+extern bool dom_info_available_p (function *, enum cdi_direction);\n+extern bool dom_info_available_p (enum cdi_direction);\n+\n+\n+\n+#endif /* GCC_DOMINANCE_H */"}, {"sha": "7be502626e32fe7ca2fb0ba7adf7f377e401a462", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -408,6 +408,7 @@ main (int argc, char **argv)\n \t   \"#include \\\"stor-layout.h\\\"\\n\"\n \t   \"#include \\\"calls.h\\\"\\n\"\n \t   \"#include \\\"rtl.h\\\"\\n\"\n+\t   \"#include \\\"predict.h\\\"\\n\"\n \t   \"#include \\\"tm_p.h\\\"\\n\"\n \t   \"#include \\\"flags.h\\\"\\n\"\n \t   \"#include \\\"insn-config.h\\\"\\n\""}, {"sha": "a28f5c13992f0a52c292390cd31111fb0ec8ec9c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -47,6 +47,7 @@\n #include \"df.h\"\n #include \"dbgcnt.h\"\n #include \"shrink-wrap.h\"\n+#include \"ifcvt.h\"\n \n #ifndef HAVE_conditional_move\n #define HAVE_conditional_move 0"}, {"sha": "54d831d88709289885dac4fb266ee02ef86b53b5", "filename": "gcc/ifcvt.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fifcvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fifcvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -0,0 +1,43 @@\n+/* If-conversion header file.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_IFCVT_H\n+#define GCC_IFCVT_H\n+\n+/* Structure to group all of the information to process IF-THEN and\n+   IF-THEN-ELSE blocks for the conditional execution support.  */\n+\n+struct ce_if_block\n+{\n+  basic_block test_bb;\t\t\t/* First test block.  */\n+  basic_block then_bb;\t\t\t/* THEN block.  */\n+  basic_block else_bb;\t\t\t/* ELSE block or NULL.  */\n+  basic_block join_bb;\t\t\t/* Join THEN/ELSE blocks.  */\n+  basic_block last_test_bb;\t\t/* Last bb to hold && or || tests.  */\n+  int num_multiple_test_blocks;\t\t/* # of && and || basic blocks.  */\n+  int num_and_and_blocks;\t\t/* # of && blocks.  */\n+  int num_or_or_blocks;\t\t\t/* # of || blocks.  */\n+  int num_multiple_test_insns;\t\t/* # of insns in && and || blocks.  */\n+  int and_and_p;\t\t\t/* Complex test is &&.  */\n+  int num_then_insns;\t\t\t/* # of insns in THEN block.  */\n+  int num_else_insns;\t\t\t/* # of insns in ELSE block.  */\n+  int pass;\t\t\t\t/* Pass number.  */\n+};\n+\n+#endif /* GCC_IFCVT_H */"}, {"sha": "ec0c16926d9953ff03a16c737d3118007499338f", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -190,39 +190,6 @@ maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n   return maybe_hot_frequency_p (fun, bb->frequency);\n }\n \n-/* Return true if the call can be hot.  */\n-\n-bool\n-cgraph_edge::maybe_hot_p (void)\n-{\n-  if (profile_info && flag_branch_probabilities\n-      && !maybe_hot_count_p (NULL, count))\n-    return false;\n-  if (caller->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      || (callee\n-\t  && callee->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n-    return false;\n-  if (caller->frequency > NODE_FREQUENCY_UNLIKELY_EXECUTED\n-      && (callee\n-\t  && callee->frequency <= NODE_FREQUENCY_EXECUTED_ONCE))\n-    return false;\n-  if (optimize_size)\n-    return false;\n-  if (caller->frequency == NODE_FREQUENCY_HOT)\n-    return true;\n-  if (caller->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && frequency < CGRAPH_FREQ_BASE * 3 / 2)\n-    return false;\n-  if (flag_guess_branch_prob)\n-    {\n-      if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0\n-\t  || frequency <= (CGRAPH_FREQ_BASE\n-\t\t\t\t / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n-        return false;\n-    }\n-  return true;\n-}\n-\n /* Return true in case BB can be CPU intensive and should be optimized\n    for maximal performance.  */\n \n@@ -234,8 +201,6 @@ maybe_hot_edge_p (edge e)\n   return maybe_hot_frequency_p (cfun, EDGE_FREQUENCY (e));\n }\n \n-\n-\n /* Return true if profile COUNT and FREQUENCY, or function FUN static\n    node frequency reflects never being executed.  */\n    \n@@ -304,19 +269,6 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n   return probably_never_executed (fun, e->count, EDGE_FREQUENCY (e));\n }\n \n-/* Return true if function should be optimized for size.  */\n-\n-bool\n-cgraph_node::optimize_for_size_p (void)\n-{\n-  if (optimize_size)\n-    return true;\n-  if (frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-    return true;\n-  else\n-    return false;\n-}\n-\n /* Return true when current function should always be optimized for size.  */\n \n bool"}, {"sha": "61a5d1c46f15feda9253a70ffb10c7ff306bc1a9", "filename": "gcc/predict.h", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -45,17 +45,48 @@ enum prediction\n    TAKEN\n };\n \n+extern gcov_type get_hot_bb_threshold (void);\n+extern void set_hot_bb_threshold (gcov_type);\n+extern bool maybe_hot_count_p (struct function *, gcov_type);\n+extern bool maybe_hot_bb_p (struct function *, const_basic_block);\n+extern bool maybe_hot_edge_p (edge);\n+extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n+extern bool probably_never_executed_edge_p (struct function *, edge);\n+extern bool optimize_function_for_size_p (struct function *);\n+extern bool optimize_function_for_speed_p (struct function *);\n+extern bool optimize_bb_for_size_p (const_basic_block);\n+extern bool optimize_bb_for_speed_p (const_basic_block);\n+extern bool optimize_edge_for_size_p (edge);\n+extern bool optimize_edge_for_speed_p (edge);\n+extern bool optimize_insn_for_size_p (void);\n+extern bool optimize_insn_for_speed_p (void);\n+extern bool optimize_loop_for_size_p (struct loop *);\n+extern bool optimize_loop_for_speed_p (struct loop *);\n+extern bool optimize_loop_nest_for_speed_p (struct loop *);\n+extern bool optimize_loop_nest_for_size_p (struct loop *);\n+extern bool predictable_edge_p (edge);\n+extern void rtl_profile_for_bb (basic_block);\n+extern void rtl_profile_for_edge (edge);\n+extern void default_rtl_profile (void);\n+extern bool rtl_predicted_by_p (const_basic_block, enum br_predictor);\n+extern bool gimple_predicted_by_p (const_basic_block, enum br_predictor);\n+extern bool edge_probability_reliable_p (const_edge);\n+extern bool br_prob_note_reliable_p (const_rtx);\n extern void predict_insn_def (rtx_insn *, enum br_predictor, enum prediction);\n-extern int counts_to_freqs (void);\n+extern void rtl_predict_edge (edge, enum br_predictor, int);\n+extern void gimple_predict_edge (edge, enum br_predictor, int);\n+extern void remove_predictions_associated_with_edge (edge);\n+extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n+extern void invert_br_probabilities (rtx);\n+extern void guess_outgoing_edge_probabilities (basic_block);\n+extern void tree_estimate_probability (void);\n extern void handle_missing_profiles (void);\n+extern int counts_to_freqs (void);\n+extern bool expensive_function_p (int);\n extern void estimate_bb_frequencies (bool);\n-extern const char *predictor_name (enum br_predictor);\n-extern tree build_predict_expr (enum br_predictor, enum prediction);\n-extern void tree_estimate_probability (void);\n extern void compute_function_frequency (void);\n+extern tree build_predict_expr (enum br_predictor, enum prediction);\n+extern const char *predictor_name (enum br_predictor);\n extern void rebuild_frequencies (void);\n \n-extern bool optimize_function_for_size_p (struct function *);\n-extern bool optimize_function_for_speed_p (struct function *);\n-\n #endif  /* GCC_PREDICT_H */"}, {"sha": "c34a0c74c4791ac19095c7172e99e94f21510353", "filename": "gcc/profile.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -37,6 +37,10 @@ struct edge_profile_info\n \n #define EDGE_INFO(e)  ((struct edge_profile_info *) (e)->aux)\n \n+typedef struct gcov_working_set_info gcov_working_set_t;\n+extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n+extern void add_working_set (gcov_working_set_t *);\n+\n /* Smoothes the initial assigned basic block and edge counts using\n    a minimum cost flow algorithm. */\n extern void mcf_smooth_cfg (void);\n@@ -52,8 +56,4 @@ extern void get_working_sets (void);\n    profile.c.  */\n extern const struct gcov_ctr_summary *profile_info;\n \n-/* In predict.c.  */\n-extern gcov_type get_hot_bb_threshold (void);\n-extern void set_hot_bb_threshold (gcov_type);\n-\n #endif /* PROFILE_H */"}, {"sha": "ddd39c920cc8f16e90b4026b2a4598d04f14976d", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893479def2f2b98d16e7311fe3bfff58ed003467/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=893479def2f2b98d16e7311fe3bfff58ed003467", "patch": "@@ -3388,9 +3388,6 @@ extern void dump_combine_stats (FILE *);\n extern void dump_combine_total_stats (FILE *);\n extern rtx make_compound_operation (rtx, enum rtx_code);\n \n-/* In cfgcleanup.c  */\n-extern void delete_dead_jumptables (void);\n-\n /* In sched-rgn.c.  */\n extern void schedule_insns (void);\n \n@@ -3531,10 +3528,6 @@ extern int stack_regs_mentioned (const_rtx insn);\n /* In toplev.c */\n extern GTY(()) rtx stack_limit_rtx;\n \n-/* In predict.c */\n-extern void invert_br_probabilities (rtx);\n-extern bool expensive_function_p (int);\n-\n /* In var-tracking.c */\n extern unsigned int variable_tracking_main (void);\n \n@@ -3577,8 +3570,6 @@ extern void insn_locations_init (void);\n extern void insn_locations_finalize (void);\n extern void set_curr_insn_location (location_t);\n extern location_t curr_insn_location (void);\n-extern bool optimize_insn_for_size_p (void);\n-extern bool optimize_insn_for_speed_p (void);\n \n /* rtl-error.c */\n extern void _fatal_insn_not_found (const_rtx, const char *, int, const char *)"}]}