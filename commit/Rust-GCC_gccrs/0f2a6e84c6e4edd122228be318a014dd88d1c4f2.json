{"sha": "0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyYTZlODRjNmU0ZWRkMTIyMjI4YmUzMThhMDE0ZGQ4OGQxYzRmMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-03T22:58:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-03T22:58:48Z"}, "message": "runtime: remove __go_alloc and __go_free\n    \n    Move allocg and handling of allgs slice from C to Go.\n    \n    Reviewed-on: https://go-review.googlesource.com/34797\n\nFrom-SVN: r244036", "tree": {"sha": "3478fe1adc6005eb49dda8f1c31857b5324fb886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3478fe1adc6005eb49dda8f1c31857b5324fb886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/comments", "author": null, "committer": null, "parents": [{"sha": "c65f76af364733b576d738af315811a68d23886d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65f76af364733b576d738af315811a68d23886d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65f76af364733b576d738af315811a68d23886d"}], "stats": {"total": 795, "additions": 352, "deletions": 443}, "files": [{"sha": "1efd7ee659c51e48942ffe8fa20f2f1e75555493", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -1,4 +1,4 @@\n-eac28020ee4b2532d4cd43f448fe612e84e0a108\n+dfe446c5a54ca0febabb81b542cc4e634c6f5c30\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "cc0a673c8b412f17d71338d94fcbbfa1f8ce383c", "filename": "libgo/go/runtime/mprof.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fmprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fmprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmprof.go?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -556,7 +556,7 @@ func GoroutineProfile(p []StackRecord) (n int, ok bool) {\n \tstopTheWorld(\"profile\")\n \n \tn = 1\n-\tfor _, gp1 := range allgs() {\n+\tfor _, gp1 := range allgs {\n \t\tif isOK(gp1) {\n \t\t\tn++\n \t\t}\n@@ -571,7 +571,7 @@ func GoroutineProfile(p []StackRecord) (n int, ok bool) {\n \t\tr = r[1:]\n \n \t\t// Save other goroutines.\n-\t\tfor _, gp1 := range allgs() {\n+\t\tfor _, gp1 := range allgs {\n \t\t\tif isOK(gp1) {\n \t\t\t\tif len(r) == 0 {\n \t\t\t\t\t// Should be impossible, but better to return a"}, {"sha": "78cc6ee7d8a1113e571b82eaa126144b79fd930a", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 204, "deletions": 1, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -11,22 +11,58 @@ import (\n \n // Functions temporarily called by C code.\n //go:linkname newextram runtime.newextram\n+//go:linkname checkdead runtime.checkdead\n+//go:linkname schedtrace runtime.schedtrace\n+//go:linkname allgadd runtime.allgadd\n \n // Functions temporarily in C that have not yet been ported.\n func allocm(*p, bool, *unsafe.Pointer, *uintptr) *m\n func malg(bool, bool, *unsafe.Pointer, *uintptr) *g\n-func allgadd(*g)\n \n // C functions for ucontext management.\n func setGContext()\n func makeGContext(*g, unsafe.Pointer, uintptr)\n+func getTraceback(me, gp *g)\n \n // main_init_done is a signal used by cgocallbackg that initialization\n // has been completed. It is made before _cgo_notify_runtime_init_done,\n // so all cgo calls can rely on it existing. When main_init is complete,\n // it is closed, meaning cgocallbackg can reliably receive from it.\n var main_init_done chan bool\n \n+var (\n+\tallgs    []*g\n+\tallglock mutex\n+)\n+\n+func allgadd(gp *g) {\n+\tif readgstatus(gp) == _Gidle {\n+\t\tthrow(\"allgadd: bad status Gidle\")\n+\t}\n+\n+\tlock(&allglock)\n+\tallgs = append(allgs, gp)\n+\tallglen = uintptr(len(allgs))\n+\n+\t// Grow GC rescan list if necessary.\n+\tif len(allgs) > cap(work.rescan.list) {\n+\t\tlock(&work.rescan.lock)\n+\t\tl := work.rescan.list\n+\t\t// Let append do the heavy lifting, but keep the\n+\t\t// length the same.\n+\t\twork.rescan.list = append(l[:cap(l)], 0)[:len(l)]\n+\t\tunlock(&work.rescan.lock)\n+\t}\n+\tunlock(&allglock)\n+}\n+\n+// All reads and writes of g's status go through readgstatus, casgstatus\n+// castogscanstatus, casfrom_Gscanstatus.\n+//go:nosplit\n+func readgstatus(gp *g) uint32 {\n+\treturn atomic.Load(&gp.atomicstatus)\n+}\n+\n // If asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus\n // and casfrom_Gscanstatus instead.\n // casgstatus will loop if the g->atomicstatus is in a Gscan status until the routine that\n@@ -328,3 +364,170 @@ func lockextra(nilokay bool) *m {\n func unlockextra(mp *m) {\n \tatomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))\n }\n+\n+// Check for deadlock situation.\n+// The check is based on number of running M's, if 0 -> deadlock.\n+func checkdead() {\n+\t// For -buildmode=c-shared or -buildmode=c-archive it's OK if\n+\t// there are no running goroutines. The calling program is\n+\t// assumed to be running.\n+\tif islibrary || isarchive {\n+\t\treturn\n+\t}\n+\n+\t// If we are dying because of a signal caught on an already idle thread,\n+\t// freezetheworld will cause all running threads to block.\n+\t// And runtime will essentially enter into deadlock state,\n+\t// except that there is a thread that will call exit soon.\n+\tif panicking > 0 {\n+\t\treturn\n+\t}\n+\n+\t// -1 for sysmon\n+\trun := sched.mcount - sched.nmidle - sched.nmidlelocked - 1\n+\tif run > 0 {\n+\t\treturn\n+\t}\n+\tif run < 0 {\n+\t\tprint(\"runtime: checkdead: nmidle=\", sched.nmidle, \" nmidlelocked=\", sched.nmidlelocked, \" mcount=\", sched.mcount, \"\\n\")\n+\t\tthrow(\"checkdead: inconsistent counts\")\n+\t}\n+\n+\tgrunning := 0\n+\tlock(&allglock)\n+\tfor i := 0; i < len(allgs); i++ {\n+\t\tgp := allgs[i]\n+\t\tif isSystemGoroutine(gp) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ts := readgstatus(gp)\n+\t\tswitch s &^ _Gscan {\n+\t\tcase _Gwaiting:\n+\t\t\tgrunning++\n+\t\tcase _Grunnable,\n+\t\t\t_Grunning,\n+\t\t\t_Gsyscall:\n+\t\t\tunlock(&allglock)\n+\t\t\tprint(\"runtime: checkdead: find g \", gp.goid, \" in status \", s, \"\\n\")\n+\t\t\tthrow(\"checkdead: runnable g\")\n+\t\t}\n+\t}\n+\tunlock(&allglock)\n+\tif grunning == 0 { // possible if main goroutine calls runtime\u00b7Goexit()\n+\t\tthrow(\"no goroutines (main called runtime.Goexit) - deadlock!\")\n+\t}\n+\n+\t// Maybe jump time forward for playground.\n+\tgp := timejump()\n+\tif gp != nil {\n+\t\t// Temporarily commented out for gccgo.\n+\t\t// For gccgo this code will never run anyhow.\n+\t\t// casgstatus(gp, _Gwaiting, _Grunnable)\n+\t\t// globrunqput(gp)\n+\t\t// _p_ := pidleget()\n+\t\t// if _p_ == nil {\n+\t\t// \tthrow(\"checkdead: no p for timer\")\n+\t\t// }\n+\t\t// mp := mget()\n+\t\t// if mp == nil {\n+\t\t// \t// There should always be a free M since\n+\t\t// \t// nothing is running.\n+\t\t// \tthrow(\"checkdead: no m for timer\")\n+\t\t// }\n+\t\t// nmp.nextp.set(_p_)\n+\t\t// notewakeup(&mp.park)\n+\t\t// return\n+\t}\n+\n+\tgetg().m.throwing = -1 // do not dump full stacks\n+\tthrow(\"all goroutines are asleep - deadlock!\")\n+}\n+\n+var starttime int64\n+\n+func schedtrace(detailed bool) {\n+\tnow := nanotime()\n+\tif starttime == 0 {\n+\t\tstarttime = now\n+\t}\n+\n+\tgomaxprocs := int32(GOMAXPROCS(0))\n+\n+\tlock(&sched.lock)\n+\tprint(\"SCHED \", (now-starttime)/1e6, \"ms: gomaxprocs=\", gomaxprocs, \" idleprocs=\", sched.npidle, \" threads=\", sched.mcount, \" spinningthreads=\", sched.nmspinning, \" idlethreads=\", sched.nmidle, \" runqueue=\", sched.runqsize)\n+\tif detailed {\n+\t\tprint(\" gcwaiting=\", sched.gcwaiting, \" nmidlelocked=\", sched.nmidlelocked, \" stopwait=\", sched.stopwait, \" sysmonwait=\", sched.sysmonwait, \"\\n\")\n+\t}\n+\t// We must be careful while reading data from P's, M's and G's.\n+\t// Even if we hold schedlock, most data can be changed concurrently.\n+\t// E.g. (p->m ? p->m->id : -1) can crash if p->m changes from non-nil to nil.\n+\tfor i := int32(0); i < gomaxprocs; i++ {\n+\t\t_p_ := allp[i]\n+\t\tif _p_ == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tmp := _p_.m.ptr()\n+\t\th := atomic.Load(&_p_.runqhead)\n+\t\tt := atomic.Load(&_p_.runqtail)\n+\t\tif detailed {\n+\t\t\tid := int32(-1)\n+\t\t\tif mp != nil {\n+\t\t\t\tid = mp.id\n+\t\t\t}\n+\t\t\tprint(\"  P\", i, \": status=\", _p_.status, \" schedtick=\", _p_.schedtick, \" syscalltick=\", _p_.syscalltick, \" m=\", id, \" runqsize=\", t-h, \" gfreecnt=\", _p_.gfreecnt, \"\\n\")\n+\t\t} else {\n+\t\t\t// In non-detailed mode format lengths of per-P run queues as:\n+\t\t\t// [len1 len2 len3 len4]\n+\t\t\tprint(\" \")\n+\t\t\tif i == 0 {\n+\t\t\t\tprint(\"[\")\n+\t\t\t}\n+\t\t\tprint(t - h)\n+\t\t\tif i == gomaxprocs-1 {\n+\t\t\t\tprint(\"]\\n\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif !detailed {\n+\t\tunlock(&sched.lock)\n+\t\treturn\n+\t}\n+\n+\tfor mp := allm(); mp != nil; mp = mp.alllink {\n+\t\t_p_ := mp.p.ptr()\n+\t\tgp := mp.curg\n+\t\tlockedg := mp.lockedg\n+\t\tid1 := int32(-1)\n+\t\tif _p_ != nil {\n+\t\t\tid1 = _p_.id\n+\t\t}\n+\t\tid2 := int64(-1)\n+\t\tif gp != nil {\n+\t\t\tid2 = gp.goid\n+\t\t}\n+\t\tid3 := int64(-1)\n+\t\tif lockedg != nil {\n+\t\t\tid3 = lockedg.goid\n+\t\t}\n+\t\tprint(\"  M\", mp.id, \": p=\", id1, \" curg=\", id2, \" mallocing=\", mp.mallocing, \" throwing=\", mp.throwing, \" preemptoff=\", mp.preemptoff, \"\"+\" locks=\", mp.locks, \" dying=\", mp.dying, \" helpgc=\", mp.helpgc, \" spinning=\", mp.spinning, \" blocked=\", mp.blocked, \" lockedg=\", id3, \"\\n\")\n+\t}\n+\n+\tlock(&allglock)\n+\tfor gi := 0; gi < len(allgs); gi++ {\n+\t\tgp := allgs[gi]\n+\t\tmp := gp.m\n+\t\tlockedm := gp.lockedm\n+\t\tid1 := int32(-1)\n+\t\tif mp != nil {\n+\t\t\tid1 = mp.id\n+\t\t}\n+\t\tid2 := int32(-1)\n+\t\tif lockedm != nil {\n+\t\t\tid2 = lockedm.id\n+\t\t}\n+\t\tprint(\"  G\", gp.goid, \": status=\", readgstatus(gp), \"(\", gp.waitreason, \") m=\", id1, \" lockedm=\", id2, \"\\n\")\n+\t}\n+\tunlock(&allglock)\n+\tunlock(&sched.lock)\n+}"}, {"sha": "571972c1a83400b7a3c517346c2a63b3839d0dab", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -755,9 +755,13 @@ const _TracebackMaxFrames = 100\n \n var (\n \t//\temptystring string\n-\t//\tallglen     uintptr\n+\n+\tallglen uintptr\n+\n \t//\tallm        *m\n-\t//\tallp        [_MaxGomaxprocs + 1]*p\n+\n+\tallp [_MaxGomaxprocs + 1]*p\n+\n \t//\tgomaxprocs  int32\n \n \tpanicking uint32"}, {"sha": "3d184083d55009442b13bb319a4cee917a35aa30", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -476,22 +476,13 @@ func UnlockOSThread()\n func lockOSThread()\n func unlockOSThread()\n func allm() *m\n-func allgs() []*g\n-\n-//go:nosplit\n-func readgstatus(gp *g) uint32 {\n-\treturn atomic.Load(&gp.atomicstatus)\n-}\n \n // Temporary for gccgo until we port malloc.go\n func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer\n \n // Temporary for gccgo until we port mheap.go\n func setprofilebucket(p unsafe.Pointer, b *bucket)\n \n-// Currently in proc.c.\n-func tracebackothers(*g)\n-\n // Temporary for gccgo until we port mgc.go.\n func setgcpercent(int32) int32\n \n@@ -530,9 +521,7 @@ func getZerobase() *uintptr {\n // Temporary for gccgo until we port proc.go.\n func sigprof()\n func mcount() int32\n-func gcount() int32\n func goexit1()\n-func schedtrace(bool)\n func freezetheworld()\n \n // Get signal trampoline, written in C.\n@@ -562,6 +551,30 @@ func getCgoHasExtraM() *bool {\n \treturn &cgoHasExtraM\n }\n \n+// Temporary for gccgo until we port proc.go.\n+//go:linkname getAllP runtime.getAllP\n+func getAllP() **p {\n+\treturn &allp[0]\n+}\n+\n+// Temporary for gccgo until we port proc.go.\n+//go:linkname allocg runtime.allocg\n+func allocg() *g {\n+\treturn new(g)\n+}\n+\n+// Temporary for gccgo until we port the garbage collector.\n+//go:linkname getallglen runtime.getallglen\n+func getallglen() uintptr {\n+\treturn allglen\n+}\n+\n+// Temporary for gccgo until we port the garbage collector.\n+//go:linkname getallg runtime.getallg\n+func getallg(i int) *g {\n+\treturn allgs[i]\n+}\n+\n // Throw and rethrow an exception.\n func throwException()\n func rethrowException()\n@@ -579,3 +592,27 @@ func getPanicking() uint32 {\n \n // Temporary for gccgo until we port mcache.go.\n func allocmcache() *mcache\n+\n+// Temporary for gccgo until we port mgc.go.\n+// This is just so that allgadd will compile.\n+var work struct {\n+\trescan struct {\n+\t\tlock mutex\n+\t\tlist []guintptr\n+\t}\n+}\n+\n+// gcount is temporary for gccgo until more of proc.go is ported.\n+// This is a copy of the C function we used to use.\n+func gcount() int32 {\n+\tn := int32(0)\n+\tlock(&allglock)\n+\tfor _, gp := range allgs {\n+\t\ts := readgstatus(gp)\n+\t\tif s == _Grunnable || s == _Grunning || s == _Gsyscall || s == _Gwaiting {\n+\t\t\tn++\n+\t\t}\n+\t}\n+\tunlock(&allglock)\n+\treturn n\n+}"}, {"sha": "611aba91a4d5717c399ce49738a2fbc163aa964a", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -171,3 +171,58 @@ func isSystemGoroutine(gp *g) bool {\n \t// FIXME.\n \treturn false\n }\n+\n+func tracebackothers(me *g) {\n+\tvar tb tracebackg\n+\ttb.gp = me\n+\n+\tlevel, _, _ := gotraceback()\n+\n+\t// Show the current goroutine first, if we haven't already.\n+\tg := getg()\n+\tgp := g.m.curg\n+\tif gp != nil && gp != me {\n+\t\tprint(\"\\n\")\n+\t\tgoroutineheader(gp)\n+\t\tgp.traceback = &tb\n+\t\tgetTraceback(me, gp)\n+\t\tprinttrace(tb.locbuf[:tb.c], nil)\n+\t\tprintcreatedby(gp)\n+\t}\n+\n+\tlock(&allglock)\n+\tfor _, gp := range allgs {\n+\t\tif gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp) && level < 2 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tprint(\"\\n\")\n+\t\tgoroutineheader(gp)\n+\n+\t\t// gccgo's only mechanism for doing a stack trace is\n+\t\t// _Unwind_Backtrace.  And that only works for the\n+\t\t// current thread, not for other random goroutines.\n+\t\t// So we need to switch context to the goroutine, get\n+\t\t// the backtrace, and then switch back.\n+\t\t//\n+\t\t// This means that if g is running or in a syscall, we\n+\t\t// can't reliably print a stack trace.  FIXME.\n+\n+\t\t// Note: gp.m == g.m occurs when tracebackothers is\n+\t\t// called from a signal handler initiated during a\n+\t\t// systemstack call. The original G is still in the\n+\t\t// running state, and we want to print its stack.\n+\t\tif gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {\n+\t\t\tprint(\"\\tgoroutine running on other thread; stack unavailable\\n\")\n+\t\t\tprintcreatedby(gp)\n+\t\t} else if readgstatus(gp)&^_Gscan == _Gsyscall {\n+\t\t\tprint(\"\\tgoroutine in C code; stack unavailable\\n\")\n+\t\t\tprintcreatedby(gp)\n+\t\t} else {\n+\t\t\tgp.traceback = &tb\n+\t\t\tgetTraceback(me, gp)\n+\t\t\tprinttrace(tb.locbuf[:tb.c], nil)\n+\t\t\tprintcreatedby(gp)\n+\t\t}\n+\t}\n+\tunlock(&allglock)\n+}"}, {"sha": "8e07e90178c0a26b82ff976a3f8deeaf4eda13a7", "filename": "libgo/runtime/go-libmain.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-libmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-libmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-libmain.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -13,7 +13,6 @@\n #include <unistd.h>\n \n #include \"runtime.h\"\n-#include \"go-alloc.h\"\n #include \"array.h\"\n #include \"arch.h\"\n #include \"malloc.h\""}, {"sha": "dba808526038b22b331992c0910b017842e761b8", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -15,7 +15,6 @@\n #endif\n \n #include \"runtime.h\"\n-#include \"go-alloc.h\"\n #include \"array.h\"\n #include \"arch.h\"\n #include \"malloc.h\""}, {"sha": "da44074a5d5428f4ccf13602114e91992198f437", "filename": "libgo/runtime/go-new.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-new.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-new.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -4,7 +4,6 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n-#include \"go-alloc.h\"\n #include \"runtime.h\"\n #include \"arch.h\"\n #include \"malloc.h\""}, {"sha": "6a9a7f35a1a66891e055c81efed762f535dea270", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -9,7 +9,6 @@\n #include <stdlib.h>\n \n #include \"runtime.h\"\n-#include \"go-alloc.h\"\n #include \"go-assert.h\"\n #include \"go-type.h\"\n "}, {"sha": "4c9fb49c9942e5ff3c0aa394585a25e4ca59c024", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -14,7 +14,6 @@\n #include \"unwind-pe.h\"\n \n #include \"runtime.h\"\n-#include \"go-alloc.h\"\n \n /* The code for a Go exception.  */\n "}, {"sha": "c050541db9d8ec91a0d3599ba72fe05a33e15950", "filename": "libgo/runtime/heapdump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fheapdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fheapdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fheapdump.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -311,8 +311,8 @@ dumpgs(void)\n \tuint32 i;\n \n \t// goroutines & stacks\n-\tfor(i = 0; i < runtime_allglen; i++) {\n-\t\tgp = runtime_allg[i];\n+\tfor(i = 0; i < runtime_getallglen(); i++) {\n+\t\tgp = runtime_getallg(i);\n \t\tswitch(gp->atomicstatus){\n \t\tdefault:\n \t\t\truntime_printf(\"unexpected G.status %d\\n\", gp->atomicstatus);"}, {"sha": "1e6704c6290a124052bc6c0e25017d0e773d9815", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -10,7 +10,6 @@ package runtime\n #include <stddef.h>\n #include <errno.h>\n #include <stdlib.h>\n-#include \"go-alloc.h\"\n #include \"runtime.h\"\n #include \"arch.h\"\n #include \"malloc.h\"\n@@ -308,107 +307,6 @@ runtime_profilealloc(void *v, uintptr size)\n \truntime_MProf_Malloc(v, size);\n }\n \n-void*\n-__go_alloc(uintptr size)\n-{\n-\treturn runtime_mallocgc(size, 0, FlagNoInvokeGC);\n-}\n-\n-// Free the object whose base pointer is v.\n-void\n-__go_free(void *v)\n-{\n-\tM *m;\n-\tint32 sizeclass;\n-\tMSpan *s;\n-\tMCache *c;\n-\tuintptr size;\n-\n-\tif(v == nil)\n-\t\treturn;\n-\t\n-\t// If you change this also change mgc0.c:/^sweep,\n-\t// which has a copy of the guts of free.\n-\n-\tm = runtime_m();\n-\tif(m->mallocing)\n-\t\truntime_throw(\"malloc/free - deadlock\");\n-\tm->mallocing = 1;\n-\n-\tif(!runtime_mlookup(v, nil, nil, &s)) {\n-\t\truntime_printf(\"free %p: not an allocated block\\n\", v);\n-\t\truntime_throw(\"free runtime_mlookup\");\n-\t}\n-\tsize = s->elemsize;\n-\tsizeclass = s->sizeclass;\n-\t// Objects that are smaller than TinySize can be allocated using tiny alloc,\n-\t// if then such object is combined with an object with finalizer, we will crash.\n-\tif(size < TinySize)\n-\t\truntime_throw(\"freeing too small block\");\n-\n-\tif(runtime_debug.allocfreetrace)\n-\t\truntime_tracefree(v, size);\n-\n-\t// Ensure that the span is swept.\n-\t// If we free into an unswept span, we will corrupt GC bitmaps.\n-\truntime_MSpan_EnsureSwept(s);\n-\n-\tif(s->specials != nil)\n-\t\truntime_freeallspecials(s, v, size);\n-\n-\tc = m->mcache;\n-\tif(sizeclass == 0) {\n-\t\t// Large object.\n-\t\ts->needzero = 1;\n-\t\t// Must mark v freed before calling unmarkspan and MHeap_Free:\n-\t\t// they might coalesce v into other spans and change the bitmap further.\n-\t\truntime_markfreed(v);\n-\t\truntime_unmarkspan(v, 1<<PageShift);\n-\t\t// NOTE(rsc,dvyukov): The original implementation of efence\n-\t\t// in CL 22060046 used SysFree instead of SysFault, so that\n-\t\t// the operating system would eventually give the memory\n-\t\t// back to us again, so that an efence program could run\n-\t\t// longer without running out of memory. Unfortunately,\n-\t\t// calling SysFree here without any kind of adjustment of the\n-\t\t// heap data structures means that when the memory does\n-\t\t// come back to us, we have the wrong metadata for it, either in\n-\t\t// the MSpan structures or in the garbage collection bitmap.\n-\t\t// Using SysFault here means that the program will run out of\n-\t\t// memory fairly quickly in efence mode, but at least it won't\n-\t\t// have mysterious crashes due to confused memory reuse.\n-\t\t// It should be possible to switch back to SysFree if we also \n-\t\t// implement and then call some kind of MHeap_DeleteSpan.\n-\t\tif(runtime_debug.efence)\n-\t\t\truntime_SysFault((void*)(s->start<<PageShift), size);\n-\t\telse\n-\t\t\truntime_MHeap_Free(&runtime_mheap, s, 1);\n-\t\tc->local_nlargefree++;\n-\t\tc->local_largefree += size;\n-\t} else {\n-\t\t// Small object.\n-\t\tif(size > 2*sizeof(uintptr))\n-\t\t\t((uintptr*)v)[1] = (uintptr)0xfeedfeedfeedfeedll;\t// mark as \"needs to be zeroed\"\n-\t\telse if(size > sizeof(uintptr))\n-\t\t\t((uintptr*)v)[1] = 0;\n-\t\t// Must mark v freed before calling MCache_Free:\n-\t\t// it might coalesce v and other blocks into a bigger span\n-\t\t// and change the bitmap further.\n-\t\tc->local_nsmallfree[sizeclass]++;\n-\t\tc->local_cachealloc -= size;\n-\t\tif(c->alloc[sizeclass] == s) {\n-\t\t\t// We own the span, so we can just add v to the freelist\n-\t\t\truntime_markfreed(v);\n-\t\t\t((MLink*)v)->next = s->freelist;\n-\t\t\ts->freelist = v;\n-\t\t\ts->ref--;\n-\t\t} else {\n-\t\t\t// Someone else owns this span.  Add to free queue.\n-\t\t\truntime_MCache_Free(c, v, sizeclass, size);\n-\t\t}\n-\t}\n-\tm->mallocing = 0;\n-}\n-\n int32\n runtime_mlookup(void *v, byte **base, uintptr *size, MSpan **sp)\n {\n@@ -628,9 +526,6 @@ runtime_mallocinit(void)\n \t// Initialize the rest of the allocator.\t\n \truntime_MHeap_Init(&runtime_mheap);\n \truntime_m()->mcache = runtime_allocmcache();\n-\n-\t// See if it works.\n-\truntime_free(runtime_malloc(TinySize));\n }\n \n void*"}, {"sha": "5d6275a63570e7aafd66b4bb22900f1a440b7aea", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -1279,7 +1279,6 @@ markroot(ParFor *desc, uint32 i)\n \t\t// For gccgo we use this for all the other global roots.\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_m0, sizeof runtime_m0, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_g0, sizeof runtime_g0, 0});\n-\t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_allg, sizeof runtime_allg, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_allm, sizeof runtime_allm, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&runtime_allp, sizeof runtime_allp, 0});\n \t\tenqueue1(&wbuf, (Obj){(byte*)&work, sizeof work, 0});\n@@ -1334,9 +1333,9 @@ markroot(ParFor *desc, uint32 i)\n \n \tdefault:\n \t\t// the rest is scanning goroutine stacks\n-\t\tif(i - RootCount >= runtime_allglen)\n+\t\tif(i - RootCount >= runtime_getallglen())\n \t\t\truntime_throw(\"markroot: bad index\");\n-\t\tgp = runtime_allg[i - RootCount];\n+\t\tgp = runtime_getallg(i - RootCount);\n \t\t// remember when we've first observed the G blocked\n \t\t// needed only to output in traceback\n \t\tif((gp->atomicstatus == _Gwaiting || gp->atomicstatus == _Gsyscall) && gp->waitsince == 0)\n@@ -2243,7 +2242,7 @@ gc(struct gc_args *args)\n \twork.nwait = 0;\n \twork.ndone = 0;\n \twork.nproc = runtime_gcprocs();\n-\truntime_parforsetup(work.markfor, work.nproc, RootCount + runtime_allglen, false, &markroot_funcval);\n+\truntime_parforsetup(work.markfor, work.nproc, RootCount + runtime_getallglen(), false, &markroot_funcval);\n \tif(work.nproc > 1) {\n \t\truntime_noteclear(&work.alldone);\n \t\truntime_helpgc(work.nproc);"}, {"sha": "c2f10b9a987f025ccf7d3d6a05d8e2256842ff47", "filename": "libgo/runtime/parfor.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fparfor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fparfor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fparfor.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -5,6 +5,7 @@\n // Parallel for algorithm.\n \n #include \"runtime.h\"\n+#include \"malloc.h\"\n #include \"arch.h\"\n \n struct ParForThread\n@@ -27,7 +28,7 @@ runtime_parforalloc(uint32 nthrmax)\n \n \t// The ParFor object is followed by CacheLineSize padding\n \t// and then nthrmax ParForThread.\n-\tdesc = (ParFor*)runtime_malloc(sizeof(ParFor) + CacheLineSize + nthrmax * sizeof(ParForThread));\n+\tdesc = (ParFor*)runtime_mallocgc(sizeof(ParFor) + CacheLineSize + nthrmax * sizeof(ParForThread), 0, FlagNoInvokeGC);\n \tdesc->thr = (ParForThread*)((byte*)(desc+1) + CacheLineSize);\n \tdesc->nthrmax = nthrmax;\n \treturn desc;"}, {"sha": "8a7a2d76ae6b283e5afd7f4bdc43fcacdb2f01f0", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 22, "deletions": 300, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -361,6 +361,10 @@ enum\n extern Sched* runtime_getsched() __asm__ (GOSYM_PREFIX \"runtime.getsched\");\n extern bool* runtime_getCgoHasExtraM()\n   __asm__ (GOSYM_PREFIX \"runtime.getCgoHasExtraM\");\n+extern P** runtime_getAllP()\n+  __asm__ (GOSYM_PREFIX \"runtime.getAllP\");\n+extern G* allocg(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.allocg\");\n \n Sched*\truntime_sched;\n int32\truntime_gomaxprocs;\n@@ -374,11 +378,6 @@ int32\truntime_ncpu;\n bool\truntime_precisestack;\n static int32\tnewprocs;\n \n-static\tLock allglock;\t// the following vars are protected by this lock or by stoptheworld\n-G**\truntime_allg;\n-uintptr runtime_allglen;\n-static\tuintptr allgcap;\n-\n bool\truntime_isarchive;\n \n void* runtime_mstart(void*);\n@@ -403,7 +402,6 @@ static void startlockedm(G*);\n static void sysmon(void);\n static uint32 retake(int64);\n static void incidlelocked(int32);\n-static void checkdead(void);\n static void exitsyscall0(G*);\n static void park0(G*);\n static void goexit0(G*);\n@@ -421,6 +419,8 @@ static bool exitsyscallfast(void);\n \n void allgadd(G*)\n   __asm__(GOSYM_PREFIX \"runtime.allgadd\");\n+void checkdead(void)\n+  __asm__(GOSYM_PREFIX \"runtime.checkdead\");\n \n bool runtime_isstarted;\n \n@@ -482,7 +482,7 @@ runtime_schedinit(void)\n \t\t\tn = _MaxGomaxprocs;\n \t\tprocs = n;\n \t}\n-\truntime_allp = runtime_malloc((_MaxGomaxprocs+1)*sizeof(runtime_allp[0]));\n+\truntime_allp = runtime_getAllP();\n \tprocresize(procs);\n \n \t// Can not enable GC until all roots are registered.\n@@ -586,85 +586,25 @@ runtime_main(void* dummy __attribute__((unused)))\n \t\t*(int32*)0 = 0;\n }\n \n-void\n-runtime_tracebackothers(G * volatile me)\n-{\n-\tG * volatile gp;\n-\tTraceback tb;\n-\tint32 traceback;\n-\tSlice slice;\n-\tvolatile uintptr i;\n-\n-\ttb.gp = me;\n-\ttraceback = runtime_gotraceback(nil);\n-\t\n-\t// Show the current goroutine first, if we haven't already.\n-\tif((gp = g->m->curg) != nil && gp != me) {\n-\t\truntime_printf(\"\\n\");\n-\t\truntime_goroutineheader(gp);\n-\t\tgp->traceback = &tb;\n-\n-#ifdef USING_SPLIT_STACK\n-\t\t__splitstack_getcontext(&me->stackcontext[0]);\n-#endif\n-\t\tgetcontext(ucontext_arg(&me->context[0]));\n-\n-\t\tif(gp->traceback != nil) {\n-\t\t  runtime_gogo(gp);\n-\t\t}\n-\n-\t\tslice.__values = &tb.locbuf[0];\n-\t\tslice.__count = tb.c;\n-\t\tslice.__capacity = tb.c;\n-\t\truntime_printtrace(slice, nil);\n-\t\truntime_printcreatedby(gp);\n-\t}\n-\n-\truntime_lock(&allglock);\n-\tfor(i = 0; i < runtime_allglen; i++) {\n-\t\tgp = runtime_allg[i];\n-\t\tif(gp == me || gp == g->m->curg || gp->atomicstatus == _Gdead)\n-\t\t\tcontinue;\n-\t\tif(gp->issystem && traceback < 2)\n-\t\t\tcontinue;\n-\t\truntime_printf(\"\\n\");\n-\t\truntime_goroutineheader(gp);\n-\n-\t\t// Our only mechanism for doing a stack trace is\n-\t\t// _Unwind_Backtrace.  And that only works for the\n-\t\t// current thread, not for other random goroutines.\n-\t\t// So we need to switch context to the goroutine, get\n-\t\t// the backtrace, and then switch back.\n-\n-\t\t// This means that if g is running or in a syscall, we\n-\t\t// can't reliably print a stack trace.  FIXME.\n-\n-\t\tif(gp->atomicstatus == _Grunning) {\n-\t\t\truntime_printf(\"\\tgoroutine running on other thread; stack unavailable\\n\");\n-\t\t\truntime_printcreatedby(gp);\n-\t\t} else if(gp->atomicstatus == _Gsyscall) {\n-\t\t\truntime_printf(\"\\tgoroutine in C code; stack unavailable\\n\");\n-\t\t\truntime_printcreatedby(gp);\n-\t\t} else {\n-\t\t\tgp->traceback = &tb;\n+void getTraceback(G*, G*) __asm__(GOSYM_PREFIX \"runtime.getTraceback\");\n \n+// getTraceback stores a traceback of gp in the g's traceback field\n+// and then returns to me.  We expect that gp's traceback is not nil.\n+// It works by saving me's current context, and checking gp's traceback field.\n+// If gp's traceback field is not nil, it starts running gp.\n+// In places where we call getcontext, we check the traceback field.\n+// If it is not nil, we collect a traceback, and then return to the\n+// goroutine stored in the traceback field, which is me.\n+void getTraceback(G* me, G* gp)\n+{\n #ifdef USING_SPLIT_STACK\n-\t\t\t__splitstack_getcontext(&me->stackcontext[0]);\n+\t__splitstack_getcontext(&me->stackcontext[0]);\n #endif\n-\t\t\tgetcontext(ucontext_arg(&me->context[0]));\n+\tgetcontext(ucontext_arg(&me->stackcontext[0]));\n \n-\t\t\tif(gp->traceback != nil) {\n-\t\t\t\truntime_gogo(gp);\n-\t\t\t}\n-\n-\t\t\tslice.__values = &tb.locbuf[0];\n-\t\t\tslice.__count = tb.c;\n-\t\t\tslice.__capacity = tb.c;\n-\t\t\truntime_printtrace(slice, nil);\n-\t\t\truntime_printcreatedby(gp);\n-\t\t}\n+\tif (gp->traceback != nil) {\n+\t\truntime_gogo(gp);\n \t}\n-\truntime_unlock(&allglock);\n }\n \n static void\n@@ -1067,22 +1007,6 @@ runtime_allocm(P *p, bool allocatestack, byte** ret_g0_stack, uintptr* ret_g0_st\n \treturn mp;\n }\n \n-static G*\n-allocg(void)\n-{\n-\tG *gp;\n-\t// static Type *gtype;\n-\t\n-\t// if(gtype == nil) {\n-\t// \tEface e;\n-\t// \truntime_gc_g_ptr(&e);\n-\t// \tgtype = ((PtrType*)e.__type_descriptor)->__element_type;\n-\t// }\n-\t// gp = runtime_cnew(gtype);\n-\tgp = runtime_malloc(sizeof(G));\n-\treturn gp;\n-}\n-\n void setGContext(void) __asm__ (GOSYM_PREFIX \"runtime.setGContext\");\n \n // setGContext sets up a new goroutine context for the current g.\n@@ -2129,6 +2053,7 @@ __go_go(void (*fn)(void*), void* arg)\n \n \t\tnewg = runtime_malg(true, false, &sp, &malsize);\n \t\tspsize = (size_t)malsize;\n+\t\tnewg->atomicstatus = _Gdead;\n \t\tallgadd(newg);\n \t}\n \n@@ -2152,31 +2077,6 @@ __go_go(void (*fn)(void*), void* arg)\n \treturn newg;\n }\n \n-void\n-allgadd(G *gp)\n-{\n-\tG **new;\n-\tuintptr cap;\n-\n-\truntime_lock(&allglock);\n-\tif(runtime_allglen >= allgcap) {\n-\t\tcap = 4096/sizeof(new[0]);\n-\t\tif(cap < 2*allgcap)\n-\t\t\tcap = 2*allgcap;\n-\t\tnew = runtime_malloc(cap*sizeof(new[0]));\n-\t\tif(new == nil)\n-\t\t\truntime_throw(\"runtime: cannot allocate memory\");\n-\t\tif(runtime_allg != nil) {\n-\t\t\truntime_memmove(new, runtime_allg, runtime_allglen*sizeof(new[0]));\n-\t\t\truntime_free(runtime_allg);\n-\t\t}\n-\t\truntime_allg = new;\n-\t\tallgcap = cap;\n-\t}\n-\truntime_allg[runtime_allglen++] = gp;\n-\truntime_unlock(&allglock);\n-}\n-\n // Put on gfree list.\n // If local list is too long, transfer a batch to the global list.\n static void\n@@ -2351,29 +2251,6 @@ runtime_lockedOSThread(void)\n \treturn g->lockedm != nil && g->m->lockedg != nil;\n }\n \n-int32\n-runtime_gcount(void)\n-{\n-\tG *gp;\n-\tint32 n, s;\n-\tuintptr i;\n-\n-\tn = 0;\n-\truntime_lock(&allglock);\n-\t// TODO(dvyukov): runtime.NumGoroutine() is O(N).\n-\t// We do not want to increment/decrement centralized counter in newproc/goexit,\n-\t// just to make runtime.NumGoroutine() faster.\n-\t// Compromise solution is to introduce per-P counters of active goroutines.\n-\tfor(i = 0; i < runtime_allglen; i++) {\n-\t\tgp = runtime_allg[i];\n-\t\ts = gp->atomicstatus;\n-\t\tif(s == _Grunnable || s == _Grunning || s == _Gsyscall || s == _Gwaiting)\n-\t\t\tn++;\n-\t}\n-\truntime_unlock(&allglock);\n-\treturn n;\n-}\n-\n int32\n runtime_mcount(void)\n {\n@@ -2638,59 +2515,6 @@ incidlelocked(int32 v)\n \truntime_unlock(&runtime_sched->lock);\n }\n \n-// Check for deadlock situation.\n-// The check is based on number of running M's, if 0 -> deadlock.\n-static void\n-checkdead(void)\n-{\n-\tG *gp;\n-\tint32 run, grunning, s;\n-\tuintptr i;\n-\n-\t// For -buildmode=c-shared or -buildmode=c-archive it's OK if\n-\t// there are no running goroutines.  The calling program is\n-\t// assumed to be running.\n-\tif(runtime_isarchive) {\n-\t\treturn;\n-\t}\n-\n-\t// -1 for sysmon\n-\trun = runtime_sched->mcount - runtime_sched->nmidle - runtime_sched->nmidlelocked - 1;\n-\tif(run > 0)\n-\t\treturn;\n-\t// If we are dying because of a signal caught on an already idle thread,\n-\t// freezetheworld will cause all running threads to block.\n-\t// And runtime will essentially enter into deadlock state,\n-\t// except that there is a thread that will call runtime_exit soon.\n-\tif(runtime_panicking() > 0)\n-\t\treturn;\n-\tif(run < 0) {\n-\t\truntime_printf(\"runtime: checkdead: nmidle=%d nmidlelocked=%d mcount=%d\\n\",\n-\t\t\truntime_sched->nmidle, runtime_sched->nmidlelocked, runtime_sched->mcount);\n-\t\truntime_throw(\"checkdead: inconsistent counts\");\n-\t}\n-\tgrunning = 0;\n-\truntime_lock(&allglock);\n-\tfor(i = 0; i < runtime_allglen; i++) {\n-\t\tgp = runtime_allg[i];\n-\t\tif(gp->isbackground)\n-\t\t\tcontinue;\n-\t\ts = gp->atomicstatus;\n-\t\tif(s == _Gwaiting)\n-\t\t\tgrunning++;\n-\t\telse if(s == _Grunnable || s == _Grunning || s == _Gsyscall) {\n-\t\t\truntime_unlock(&allglock);\n-\t\t\truntime_printf(\"runtime: checkdead: find g %D in status %d\\n\", gp->goid, s);\n-\t\t\truntime_throw(\"checkdead: runnable g\");\n-\t\t}\n-\t}\n-\truntime_unlock(&allglock);\n-\tif(grunning == 0)  // possible if main goroutine calls runtime_Goexit()\n-\t\truntime_throw(\"no goroutines (main called runtime.Goexit) - deadlock!\");\n-\tg->m->throwing = -1;  // do not dump full stacks\n-\truntime_throw(\"all goroutines are asleep - deadlock!\");\n-}\n-\n static void\n sysmon(void)\n {\n@@ -2832,94 +2656,6 @@ preemptall(void)\n \treturn false;\n }\n \n-void\n-runtime_schedtrace(bool detailed)\n-{\n-\tstatic int64 starttime;\n-\tint64 now;\n-\tint64 id1, id2, id3;\n-\tint32 i, t, h;\n-\tuintptr gi;\n-\tconst char *fmt;\n-\tM *mp, *lockedm;\n-\tG *gp, *lockedg;\n-\tP *p;\n-\n-\tnow = runtime_nanotime();\n-\tif(starttime == 0)\n-\t\tstarttime = now;\n-\n-\truntime_lock(&runtime_sched->lock);\n-\truntime_printf(\"SCHED %Dms: gomaxprocs=%d idleprocs=%d threads=%d idlethreads=%d runqueue=%d\",\n-\t\t(now-starttime)/1000000, runtime_gomaxprocs, runtime_sched->npidle, runtime_sched->mcount,\n-\t\truntime_sched->nmidle, runtime_sched->runqsize);\n-\tif(detailed) {\n-\t\truntime_printf(\" gcwaiting=%d nmidlelocked=%d nmspinning=%d stopwait=%d sysmonwait=%d\\n\",\n-\t\t\truntime_sched->gcwaiting, runtime_sched->nmidlelocked, runtime_sched->nmspinning,\n-\t\t\truntime_sched->stopwait, runtime_sched->sysmonwait);\n-\t}\n-\t// We must be careful while reading data from P's, M's and G's.\n-\t// Even if we hold schedlock, most data can be changed concurrently.\n-\t// E.g. (p->m ? p->m->id : -1) can crash if p->m changes from non-nil to nil.\n-\tfor(i = 0; i < runtime_gomaxprocs; i++) {\n-\t\tp = runtime_allp[i];\n-\t\tif(p == nil)\n-\t\t\tcontinue;\n-\t\tmp = (M*)p->m;\n-\t\th = runtime_atomicload(&p->runqhead);\n-\t\tt = runtime_atomicload(&p->runqtail);\n-\t\tif(detailed)\n-\t\t\truntime_printf(\"  P%d: status=%d schedtick=%d syscalltick=%d m=%d runqsize=%d gfreecnt=%d\\n\",\n-\t\t\t\ti, p->status, p->schedtick, p->syscalltick, mp ? mp->id : -1, t-h, p->gfreecnt);\n-\t\telse {\n-\t\t\t// In non-detailed mode format lengths of per-P run queues as:\n-\t\t\t// [len1 len2 len3 len4]\n-\t\t\tfmt = \" %d\";\n-\t\t\tif(runtime_gomaxprocs == 1)\n-\t\t\t\tfmt = \" [%d]\\n\";\n-\t\t\telse if(i == 0)\n-\t\t\t\tfmt = \" [%d\";\n-\t\t\telse if(i == runtime_gomaxprocs-1)\n-\t\t\t\tfmt = \" %d]\\n\";\n-\t\t\truntime_printf(fmt, t-h);\n-\t\t}\n-\t}\n-\tif(!detailed) {\n-\t\truntime_unlock(&runtime_sched->lock);\n-\t\treturn;\n-\t}\n-\tfor(mp = runtime_allm; mp; mp = mp->alllink) {\n-\t\tp = (P*)mp->p;\n-\t\tgp = mp->curg;\n-\t\tlockedg = mp->lockedg;\n-\t\tid1 = -1;\n-\t\tif(p)\n-\t\t\tid1 = p->id;\n-\t\tid2 = -1;\n-\t\tif(gp)\n-\t\t\tid2 = gp->goid;\n-\t\tid3 = -1;\n-\t\tif(lockedg)\n-\t\t\tid3 = lockedg->goid;\n-\t\truntime_printf(\"  M%d: p=%D curg=%D mallocing=%d throwing=%d gcing=%d\"\n-\t\t\t\" locks=%d dying=%d helpgc=%d spinning=%d blocked=%d lockedg=%D\\n\",\n-\t\t\tmp->id, id1, id2,\n-\t\t\tmp->mallocing, mp->throwing, mp->gcing, mp->locks, mp->dying, mp->helpgc,\n-\t\t\tmp->spinning, mp->blocked, id3);\n-\t}\n-\truntime_lock(&allglock);\n-\tfor(gi = 0; gi < runtime_allglen; gi++) {\n-\t\tgp = runtime_allg[gi];\n-\t\tmp = gp->m;\n-\t\tlockedm = gp->lockedm;\n-\t\truntime_printf(\"  G%D: status=%d(%S) m=%d lockedm=%d\\n\",\n-\t\t\tgp->goid, gp->atomicstatus, gp->waitreason, mp ? mp->id : -1,\n-\t\t\tlockedm ? lockedm->id : -1);\n-\t}\n-\truntime_unlock(&allglock);\n-\truntime_unlock(&runtime_sched->lock);\n-}\n-\n // Put mp on midle list.\n // Sched must be locked.\n static void\n@@ -3357,20 +3093,6 @@ runtime_go_allm()\n \treturn &runtime_allm;\n }\n \n-extern Slice runtime_go_allgs(void)\n-  __asm__ (GOSYM_PREFIX \"runtime.allgs\");\n-\n-Slice\n-runtime_go_allgs()\n-{\n-\tSlice s;\n-\n-\ts.__values = runtime_allg;\n-\ts.__count = runtime_allglen;\n-\ts.__capacity = allgcap;\n-\treturn s;\n-}\n-\n intgo NumCPU(void) __asm__ (GOSYM_PREFIX \"runtime.NumCPU\");\n \n intgo"}, {"sha": "c8f490f20de7d25b342bea6c567b8fd119aa4ace", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -7,6 +7,7 @@\n #include \"go-assert.h\"\n #include <complex.h>\n #include <signal.h>\n+#include <stdint.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -22,8 +23,6 @@\n #include <sys/mman.h>\n #endif\n \n-#include \"go-alloc.h\"\n-\n #define _STRINGIFY2_(x) #x\n #define _STRINGIFY_(x) _STRINGIFY2_(x)\n #define GOSYM_PREFIX _STRINGIFY_(__USER_LABEL_PREFIX__)\n@@ -233,8 +232,10 @@ enum\n  */\n extern\tuintptr* runtime_getZerobase(void)\n   __asm__(GOSYM_PREFIX \"runtime.getZerobase\");\n-extern\tG**\truntime_allg;\n-extern\tuintptr runtime_allglen;\n+extern G* runtime_getallg(intgo)\n+  __asm__(GOSYM_PREFIX \"runtime.getallg\");\n+extern uintptr runtime_getallglen(void)\n+  __asm__(GOSYM_PREFIX \"runtime.getallglen\");\n extern\tG*\truntime_lastg;\n extern\tM*\truntime_allm;\n extern\tP**\truntime_allp;\n@@ -309,13 +310,9 @@ MCache*\truntime_allocmcache(void)\n void\truntime_freemcache(MCache*);\n void\truntime_mallocinit(void);\n void\truntime_mprofinit(void);\n-#define runtime_malloc(s) __go_alloc(s)\n-#define runtime_free(p) __go_free(p)\n #define runtime_getcallersp(p) __builtin_frame_address(0)\n int32\truntime_mcount(void)\n   __asm__ (GOSYM_PREFIX \"runtime.mcount\");\n-int32\truntime_gcount(void)\n-  __asm__ (GOSYM_PREFIX \"runtime.gcount\");\n void\truntime_mcall(void(*)(G*));\n uint32\truntime_fastrand1(void) __asm__ (GOSYM_PREFIX \"runtime.fastrand1\");\n int32\truntime_timediv(int64, int32, int32*)"}, {"sha": "67d5ee2a424b8650fb496ce8e818e950cad06315", "filename": "libgo/runtime/runtime_c.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fruntime_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a6e84c6e4edd122228be318a014dd88d1c4f2/libgo%2Fruntime%2Fruntime_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime_c.c?ref=0f2a6e84c6e4edd122228be318a014dd88d1c4f2", "patch": "@@ -25,7 +25,8 @@ extern volatile intgo runtime_MemProfileRate\n \n struct gotraceback_ret {\n \tint32 level;\n-\tbool crash;\n+\tbool  all;\n+\tbool  crash;\n };\n \n extern struct gotraceback_ret gotraceback(void)"}]}