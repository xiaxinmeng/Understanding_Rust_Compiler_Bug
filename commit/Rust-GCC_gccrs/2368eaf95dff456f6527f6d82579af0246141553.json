{"sha": "2368eaf95dff456f6527f6d82579af0246141553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM2OGVhZjk1ZGZmNDU2ZjY1MjdmNmQ4MjU3OWFmMDI0NjE0MTU1Mw==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2018-04-14T14:45:59Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2018-04-14T14:45:59Z"}, "message": "re PR fortran/81773 ([Coarray] Get with vector index on lhs leads to incorrect caf_get_by_ref() call.)\n\ngcc/fortran/ChangeLog:\n\n2018-04-14  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/81773\n\tPR fortran/83606\n\t* dependency.c (gfc_dep_resolver): Coarray indexes are to be ignored\n\tduring dependency computation.  They define no data dependency.\n\t* trans-array.c (conv_array_index_offset): The stride can not be set\n\there, prevent fail.\n\t* trans-intrinsic.c (conv_caf_send): Add creation of temporary array\n\tfor caf_get's result and copying to the array with vectorial\n\tindexing.\n\ngcc/testsuite/ChangeLog:\n\n2018-04-14  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/81773\n\tPR fortran/83606\n\t* gfortran.dg/coarray/get_to_indexed_array_1.f90: New test.\n\t* gfortran.dg/coarray/get_to_indirect_array.f90: New test.\n\nFrom-SVN: r259385", "tree": {"sha": "fea7ba6185a86b35c94ad0bdbf56b296b7bebc09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fea7ba6185a86b35c94ad0bdbf56b296b7bebc09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2368eaf95dff456f6527f6d82579af0246141553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2368eaf95dff456f6527f6d82579af0246141553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2368eaf95dff456f6527f6d82579af0246141553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2368eaf95dff456f6527f6d82579af0246141553/comments", "author": null, "committer": null, "parents": [{"sha": "acd1559a0e07edca7e130e5fbc2d230ac8ba841c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd1559a0e07edca7e130e5fbc2d230ac8ba841c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd1559a0e07edca7e130e5fbc2d230ac8ba841c"}], "stats": {"total": 224, "additions": 197, "deletions": 27}, "files": [{"sha": "9d126868cc9ea6536e7a21726335b9b5c46185ac", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -1,3 +1,15 @@\n+2018-04-14  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/81773\n+\tPR fortran/83606\n+\t* dependency.c (gfc_dep_resolver): Coarray indexes are to be ignored\n+\tduring dependency computation.  They define no data dependency.\n+\t* trans-array.c (conv_array_index_offset): The stride can not be set\n+\there, prevent fail.\n+\t* trans-intrinsic.c (conv_caf_send): Add creation of temporary array\n+\tfor caf_get's result and copying to the array with vectorial\n+\tindexing.\n+\n 2018-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/85387"}, {"sha": "3e14ddc25d86300a19fb844f0deee618b890a609", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -2238,8 +2238,9 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t    break;\n \n \t  /* Exactly matching and forward overlapping ranges don't cause a\n-\t     dependency.  */\n-\t  if (fin_dep < GFC_DEP_BACKWARD)\n+\t     dependency, when they are not part of a coarray ref.  */\n+\t  if (fin_dep < GFC_DEP_BACKWARD\n+\t      && lref->u.ar.codimen == 0 && rref->u.ar.codimen == 0)\n \t    return 0;\n \n \t  /* Keep checking.  We only have a dependency if"}, {"sha": "b68e77d52818c32603cd642c80d54ef75328e91a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -3215,7 +3215,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n     }\n \n   /* Multiply by the stride.  */\n-  if (!integer_onep (stride))\n+  if (stride != NULL && !integer_onep (stride))\n     index = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t     index, stride);\n "}, {"sha": "00edd447bb2a1d6f6980eefe0c6c32a230709dda", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 114, "deletions": 24, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -1907,34 +1907,124 @@ conv_caf_send (gfc_code *code) {\n     }\n   else\n     {\n-      /* If has_vector, pass descriptor for whole array and the\n-         vector bounds separately.  */\n-      gfc_array_ref *ar, ar2;\n-      bool has_vector = false;\n+      bool has_vector = gfc_has_vector_subscript (lhs_expr);\n \n-      if (gfc_is_coindexed (lhs_expr) && gfc_has_vector_subscript (lhs_expr))\n+      if (gfc_is_coindexed (lhs_expr) || !has_vector)\n \t{\n-          has_vector = true;\n-          ar = gfc_find_array_ref (lhs_expr);\n-\t  ar2 = *ar;\n-\t  memset (ar, '\\0', sizeof (*ar));\n-\t  ar->as = ar2.as;\n-\t  ar->type = AR_FULL;\n+\t  /* If has_vector, pass descriptor for whole array and the\n+\t     vector bounds separately.  */\n+\t  gfc_array_ref *ar, ar2;\n+\t  bool has_tmp_lhs_array = false;\n+\t  if (has_vector)\n+\t    {\n+\t      has_tmp_lhs_array = true;\n+\t      ar = gfc_find_array_ref (lhs_expr);\n+\t      ar2 = *ar;\n+\t      memset (ar, '\\0', sizeof (*ar));\n+\t      ar->as = ar2.as;\n+\t      ar->type = AR_FULL;\n+\t    }\n+\t  lhs_se.want_pointer = 1;\n+\t  gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n+\t  /* Using gfc_conv_expr_descriptor, we only get the descriptor, but\n+\t     that has the wrong type if component references are done.  */\n+\t  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);\n+\t  tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);\n+\t  gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n+\t\t\t  gfc_get_dtype_rank_type (has_vector ? ar2.dimen\n+\t\t\t\t\t\t\t      : lhs_expr->rank,\n+\t\t\t\t\t\t   lhs_type));\n+\t  if (has_tmp_lhs_array)\n+\t    {\n+\t      vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);\n+\t      *ar = ar2;\n+\t    }\n \t}\n-      lhs_se.want_pointer = 1;\n-      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n-      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n-         has the wrong type if component references are done.  */\n-      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);\n-      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);\n-      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),\n-                      gfc_get_dtype_rank_type (has_vector ? ar2.dimen\n-\t\t\t\t\t\t\t  : lhs_expr->rank,\n-\t\t      lhs_type));\n-      if (has_vector)\n+      else\n \t{\n-\t  vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);\n-\t  *ar = ar2;\n+\t  /* Special casing for arr1 ([...]) = arr2[...], i.e. caf_get to\n+\t     indexed array expression.  This is rewritten to:\n+\n+\t     tmp_array = arr2[...]\n+\t     arr1 ([...]) = tmp_array\n+\n+\t     because using the standard gfc_conv_expr (lhs_expr) did the\n+\t     assignment with lhs and rhs exchanged.  */\n+\n+\t  gfc_ss *lss_for_tmparray, *lss_real;\n+\t  gfc_loopinfo loop;\n+\t  gfc_se se;\n+\t  stmtblock_t body;\n+\t  tree tmparr_desc, src;\n+\t  tree index = gfc_index_zero_node;\n+\t  tree stride = gfc_index_zero_node;\n+\t  int n;\n+\n+\t  /* Walk both sides of the assignment, once to get the shape of the\n+\t     temporary array to create right.  */\n+\t  lss_for_tmparray = gfc_walk_expr (lhs_expr);\n+\t  /* And a second time to be able to create an assignment of the\n+\t     temporary to the lhs_expr.  gfc_trans_create_temp_array replaces\n+\t     the tree in the descriptor with the one for the temporary\n+\t     array.  */\n+\t  lss_real = gfc_walk_expr (lhs_expr);\n+\t  gfc_init_loopinfo (&loop);\n+\t  gfc_add_ss_to_loop (&loop, lss_for_tmparray);\n+\t  gfc_add_ss_to_loop (&loop, lss_real);\n+\t  gfc_conv_ss_startstride (&loop);\n+\t  gfc_conv_loop_setup (&loop, &lhs_expr->where);\n+\t  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);\n+\t  gfc_trans_create_temp_array (&lhs_se.pre, &lhs_se.post,\n+\t\t\t\t       lss_for_tmparray, lhs_type, NULL_TREE,\n+\t\t\t\t       false, true, false,\n+\t\t\t\t       &lhs_expr->where);\n+\t  tmparr_desc = lss_for_tmparray->info->data.array.descriptor;\n+\t  gfc_start_scalarized_body (&loop, &body);\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_copy_loopinfo_to_se (&se, &loop);\n+\t  se.ss = lss_real;\n+\t  gfc_conv_expr (&se, lhs_expr);\n+\t  gfc_add_block_to_block (&body, &se.pre);\n+\n+\t  /* Walk over all indexes of the loop.  */\n+\t  for (n = loop.dimen - 1; n > 0; --n)\n+\t    {\n+\t      tmp = loop.loopvar[n];\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp, loop.from[n]);\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp, index);\n+\n+\t      stride = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\tloop.to[n - 1], loop.from[n - 1]);\n+\t      stride = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\tstride, gfc_index_one_node);\n+\n+\t      index = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       gfc_array_index_type, tmp, stride);\n+\t    }\n+\n+\t  index = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t   index, loop.from[0]);\n+\n+\t  index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t   loop.loopvar[0], index);\n+\n+\t  src = build_fold_indirect_ref (gfc_conv_array_data (tmparr_desc));\n+\t  src = gfc_build_array_ref (src, index, NULL);\n+\t  /* Now create the assignment of lhs_expr = tmp_array.  */\n+\t  gfc_add_modify (&body, se.expr, src);\n+\t  gfc_add_block_to_block (&body, &se.post);\n+\t  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, tmparr_desc);\n+\t  gfc_trans_scalarizing_loops (&loop, &body);\n+\t  gfc_add_block_to_block (&loop.pre, &loop.post);\n+\t  gfc_add_expr_to_block (&lhs_se.post, gfc_finish_block (&loop.pre));\n+\t  gfc_free_ss (lss_for_tmparray);\n+\t  gfc_free_ss (lss_real);\n \t}\n     }\n "}, {"sha": "1369288a803f53eeafe33613673ee776c602e05b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -1,3 +1,10 @@\n+2018-04-14  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/81773\n+\tPR fortran/83606\n+\t* gfortran.dg/coarray/get_to_indexed_array_1.f90: New test.\n+\t* gfortran.dg/coarray/get_to_indirect_array.f90: New test.\n+\n 2018-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/85387"}, {"sha": "04714711707c1450aadcb84d9e8518cdf7d50949", "filename": "gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indexed_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indexed_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indexed_array_1.f90?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+\n+! Test that index vector on lhs of caf-expression works correctly.\n+\n+program pr81773\n+\n+  integer, parameter :: ndim = 5\n+  integer :: i\n+  integer :: vec(ndim) = -1\n+  integer :: res(ndim)[*] = [ (i, i=1, ndim) ]\n+  type T\n+    integer :: padding\n+    integer :: dest(ndim)\n+    integer :: src(ndim)\n+  end type\n+\n+  type(T) :: dest\n+  type(T), allocatable :: caf[:]\n+\n+  vec([ndim, 3, 1]) = res(1:3)[1]\n+  if (any (vec /= [ 3, -1, 2, -1, 1])) stop 1\n+\n+  dest = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] )\n+  dest%dest([ 4,3,2 ]) = res(3:5)[1]\n+  if (any (dest%dest /= [-1, 5, 4, 3, -1])) stop 2\n+\n+  vec(:) = -1\n+  allocate(caf[*], source = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] ))\n+  vec([ 5,3,2 ]) = caf[1]%src(2:4)\n+  if (any (vec /= [ -1, 0, 1, -1, 2])) stop 3\n+end\n+"}, {"sha": "efb783536375d26774d66aadcd2084560715a013", "filename": "gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indirect_array.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2368eaf95dff456f6527f6d82579af0246141553/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indirect_array.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_to_indirect_array.f90?ref=2368eaf95dff456f6527f6d82579af0246141553", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+!\n+! Test that pr81773/fortran is fixed.\n+\n+program get_to_indexed_array\n+\n+  integer, parameter :: ndim = 5\n+  integer :: i\n+  integer :: vec(1:ndim) = 0\n+  integer :: indx(1:2) = [3, 2]\n+  integer :: mat(1:ndim, 1:ndim) = 0\n+  integer :: res(1:ndim)[*]=[ (i, i=1, ndim) ]\n+\n+  ! No sync needed, because this test always is running on single image\n+  vec([ndim , 1]) = res(1:2)[1]\n+  if (vec(1) /= res(2) .or. vec(ndim) /= res(1)) then\n+    print *,\"vec: \", vec, \" on image: \", this_image()\n+    stop 1\n+  end if\n+\n+  mat(2:3,[indx(:)]) = reshape(res(1:4)[1], [2, 2])\n+  if (any(mat(2:3, 3:2:-1) /= reshape(res(1:4), [2,2]))) then\n+    print *, \"mat: \", mat, \" on image: \", this_image()\n+    stop 2\n+  end if\n+end\n+\n+! vim:ts=2:sts=2:sw=2:"}]}