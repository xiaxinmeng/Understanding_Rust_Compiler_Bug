{"sha": "f8d0706b24ff84eb0adfa161819e71a80f5a918a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhkMDcwNmIyNGZmODRlYjBhZGZhMTYxODE5ZTcxYTgwZjVhOTE4YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-26T14:21:29Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-26T14:21:29Z"}, "message": "tree-vect-loop-manip.c (create_intersect_range_checks_index): Pass in parameter loop, rather than loop_vinfo.\n\n\t* tree-vect-loop-manip.c (create_intersect_range_checks_index): Pass\n\tin parameter loop, rather than loop_vinfo.\n\t(create_intersect_range_checks): Ditto.\n\t(vect_create_cond_for_alias_checks): Update call to above functions.\n\nFrom-SVN: r248513", "tree": {"sha": "926b9aaa290a1a890a2cfbd9563fadb005c0567a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/926b9aaa290a1a890a2cfbd9563fadb005c0567a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8d0706b24ff84eb0adfa161819e71a80f5a918a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d0706b24ff84eb0adfa161819e71a80f5a918a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d0706b24ff84eb0adfa161819e71a80f5a918a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d0706b24ff84eb0adfa161819e71a80f5a918a/comments", "author": null, "committer": null, "parents": [{"sha": "cb4fe4013684c2984b309f799373837af582b24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4fe4013684c2984b309f799373837af582b24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4fe4013684c2984b309f799373837af582b24a"}], "stats": {"total": 27, "additions": 17, "deletions": 10}, "files": [{"sha": "67ae170be68460c134f3b6c8d15a4f91b2824b7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0706b24ff84eb0adfa161819e71a80f5a918a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0706b24ff84eb0adfa161819e71a80f5a918a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8d0706b24ff84eb0adfa161819e71a80f5a918a", "patch": "@@ -1,3 +1,10 @@\n+2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-loop-manip.c (create_intersect_range_checks_index): Pass\n+\tin parameter loop, rather than loop_vinfo.\n+\t(create_intersect_range_checks): Ditto.\n+\t(vect_create_cond_for_alias_checks): Update call to above functions.\n+\n 2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/80815"}, {"sha": "62b1fe8e42d0b7c204b9d4af5f385320f82aa29b", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8d0706b24ff84eb0adfa161819e71a80f5a918a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8d0706b24ff84eb0adfa161819e71a80f5a918a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f8d0706b24ff84eb0adfa161819e71a80f5a918a", "patch": "@@ -2044,11 +2044,11 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n     *cond_expr = part_cond_expr;\n }\n \n-/* Given two data references and segment lengths described by DR_A and DR_B,\n-   create expression checking if the two addresses ranges intersect with\n-   each other based on index of the two addresses.  This can only be done\n-   if DR_A and DR_B referring to the same (array) object and the index is\n-   the only difference.  For example:\n+/* Given LOOP's two data references and segment lengths described by DR_A\n+   and DR_B, create expression checking if the two addresses ranges intersect\n+   with each other based on index of the two addresses.  This can only be\n+   done if DR_A and DR_B referring to the same (array) object and the index\n+   is the only difference.  For example:\n \n                        DR_A                           DR_B\n       data-ref         arr[i]                         arr[j]\n@@ -2070,7 +2070,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n    Note evolution step of index needs to be considered in comparison.  */\n \n static bool\n-create_intersect_range_checks_index (loop_vec_info loop_vinfo, tree *cond_expr,\n+create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n \t\t\t\t     const dr_with_seg_len& dr_a,\n \t\t\t\t     const dr_with_seg_len& dr_b)\n {\n@@ -2109,7 +2109,6 @@ create_intersect_range_checks_index (loop_vec_info loop_vinfo, tree *cond_expr,\n   unsigned HOST_WIDE_INT niter_len2 = (seg_len2 + abs_step - 1) / abs_step;\n \n   unsigned int i;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n     {\n       tree access1 = DR_ACCESS_FN (dr_a.dr, i);\n@@ -2186,12 +2185,12 @@ create_intersect_range_checks_index (loop_vec_info loop_vinfo, tree *cond_expr,\n      || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n \n static void\n-create_intersect_range_checks (loop_vec_info loop_vinfo, tree *cond_expr,\n+create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n \t\t\t       const dr_with_seg_len& dr_a,\n \t\t\t       const dr_with_seg_len& dr_b)\n {\n   *cond_expr = NULL_TREE;\n-  if (create_intersect_range_checks_index (loop_vinfo, cond_expr, dr_a, dr_b))\n+  if (create_intersect_range_checks_index (loop, cond_expr, dr_a, dr_b))\n     return;\n \n   tree segment_length_a = dr_a.seg_len;\n@@ -2263,6 +2262,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n   if (comp_alias_ddrs.is_empty ())\n     return;\n \n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   for (size_t i = 0, s = comp_alias_ddrs.length (); i < s; ++i)\n     {\n       const dr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n@@ -2279,7 +2279,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n \t}\n \n       /* Create condition expression for each pair data references.  */\n-      create_intersect_range_checks (loop_vinfo, &part_cond_expr, dr_a, dr_b);\n+      create_intersect_range_checks (loop, &part_cond_expr, dr_a, dr_b);\n       if (*cond_expr)\n \t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t  *cond_expr, part_cond_expr);"}]}