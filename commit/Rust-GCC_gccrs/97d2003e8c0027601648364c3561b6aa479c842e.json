{"sha": "97d2003e8c0027601648364c3561b6aa479c842e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdkMjAwM2U4YzAwMjc2MDE2NDgzNjRjMzU2MWI2YWE0NzljODQyZQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-10T17:55:45Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "Add generated NodeId's to the AST\n\nNodeIds are going to be used for Hir->Ast lookups later on.", "tree": {"sha": "8bb1986fe2d890cadcddaa0ead2bac84cc195352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb1986fe2d890cadcddaa0ead2bac84cc195352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97d2003e8c0027601648364c3561b6aa479c842e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97d2003e8c0027601648364c3561b6aa479c842e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97d2003e8c0027601648364c3561b6aa479c842e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97d2003e8c0027601648364c3561b6aa479c842e/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c89617fc9525b726a494d4b44d19178049169a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c89617fc9525b726a494d4b44d19178049169a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c89617fc9525b726a494d4b44d19178049169a0"}], "stats": {"total": 771, "additions": 481, "deletions": 290}, "files": [{"sha": "ebd2b2a337d5dd923671ab42d65f608c241c3753", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 274, "deletions": 254, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=97d2003e8c0027601648364c3561b6aa479c842e", "patch": "@@ -1,266 +1,286 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_FULL_DECLS_H\n #define RUST_AST_FULL_DECLS_H\n-// Forward declarations for all AST classes. Useful for not having to include all definitions.\n+\n+// Forward declarations for all AST classes. Useful for not having to include\n+// all definitions.\n \n namespace Rust {\n-    namespace AST {\n-        // rust-ast.h\n-        class AttrInput;\n-        class TokenTree;\n-        class MacroMatch;\n-        class Token;\n-        struct Literal;\n-        class DelimTokenTree;\n-        class PathSegment;\n-        class SimplePathSegment;\n-        class SimplePath;\n-        struct Attribute;\n-        class MetaItemInner;\n-        class AttrInputMetaItemContainer;\n-        class MetaItem;\n-        class Stmt;\n-        class Item;\n-        class Expr;\n-        class ExprWithoutBlock;\n-        class IdentifierExpr;\n-        class Pattern;\n-        class Type;\n-        class TypeNoBounds;\n-        class TypeParamBound;\n-        class Lifetime;\n-        class GenericParam;\n-        class LifetimeParam;\n-        class MacroItem;\n-        class TraitItem;\n-        class InherentImplItem;\n-        class TraitImplItem;\n-        class MacroInvocationSemi;\n-        struct Crate;\n-        class PathExpr;\n+namespace AST {\n+// rust-ast.h\n+class AttrInput;\n+class TokenTree;\n+class MacroMatch;\n+class Token;\n+struct Literal;\n+class DelimTokenTree;\n+class PathSegment;\n+class SimplePathSegment;\n+class SimplePath;\n+struct Attribute;\n+class MetaItemInner;\n+class AttrInputMetaItemContainer;\n+class MetaItem;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class IdentifierExpr;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+class MacroItem;\n+class TraitItem;\n+class InherentImplItem;\n+class TraitImplItem;\n+class MacroInvocationSemi;\n+struct Crate;\n+class PathExpr;\n \n-        // rust-path.h\n-        class PathIdentSegment;\n-        struct GenericArgsBinding;\n-        struct GenericArgs;\n-        class PathExprSegment;\n-        class PathPattern;\n-        class PathInExpression;\n-        class TypePathSegment;\n-        class TypePathSegmentGeneric;\n-        struct TypePathFunction;\n-        class TypePathSegmentFunction;\n-        class TypePath;\n-        struct QualifiedPathType;\n-        class QualifiedPathInExpression;\n-        class QualifiedPathInType;\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n \n-        // rust-expr.h\n-        class ExprWithBlock;\n-        class LiteralExpr;\n-        class AttrInputLiteral;\n-        class MetaItemLitExpr;\n-        class MetaItemPathLit;\n-        class OperatorExpr;\n-        class BorrowExpr;\n-        class DereferenceExpr;\n-        class ErrorPropagationExpr;\n-        class NegationExpr;\n-        class ArithmeticOrLogicalExpr;\n-        class ComparisonExpr;\n-        class LazyBooleanExpr;\n-        class TypeCastExpr;\n-        class AssignmentExpr;\n-        class CompoundAssignmentExpr;\n-        class GroupedExpr;\n-        class ArrayElems;\n-        class ArrayElemsValues;\n-        class ArrayElemsCopied;\n-        class ArrayExpr;\n-        class ArrayIndexExpr;\n-        class TupleExpr;\n-        class TupleIndexExpr;\n-        class StructExpr;\n-        class StructExprStruct;\n-        struct StructBase;\n-        class StructExprField;\n-        class StructExprFieldIdentifier;\n-        class StructExprFieldWithVal;\n-        class StructExprFieldIdentifierValue;\n-        class StructExprFieldIndexValue;\n-        class StructExprStructFields;\n-        class StructExprStructBase;\n-        class StructExprTuple;\n-        class StructExprUnit;\n-        class EnumVariantExpr;\n-        class EnumExprField;\n-        class EnumExprFieldIdentifier;\n-        class EnumExprFieldWithVal;\n-        class EnumExprFieldIdentifierValue;\n-        class EnumExprFieldIndexValue;\n-        class EnumExprStruct;\n-        class EnumExprTuple;\n-        class EnumExprFieldless;\n-        class CallExpr;\n-        class MethodCallExpr;\n-        class FieldAccessExpr;\n-        struct ClosureParam;\n-        class ClosureExpr;\n-        class ClosureExprInner;\n-        class BlockExpr;\n-        class ClosureExprInnerTyped;\n-        class ContinueExpr;\n-        class BreakExpr;\n-        class RangeExpr;\n-        class RangeFromToExpr;\n-        class RangeFromExpr;\n-        class RangeToExpr;\n-        class RangeFullExpr;\n-        class RangeFromToInclExpr;\n-        class RangeToInclExpr;\n-        class ReturnExpr;\n-        class UnsafeBlockExpr;\n-        class LoopLabel;\n-        class BaseLoopExpr;\n-        class LoopExpr;\n-        class WhileLoopExpr;\n-        class WhileLetLoopExpr;\n-        class ForLoopExpr;\n-        class IfExpr;\n-        class IfExprConseqElse;\n-        class IfExprConseqIf;\n-        class IfLetExpr;\n-        class IfExprConseqIfLet;\n-        class IfLetExprConseqElse;\n-        class IfLetExprConseqIf;\n-        class IfLetExprConseqIfLet;\n-        struct MatchArm;\n-        // class MatchCase;\n-        // class MatchCaseBlockExpr;\n-        // class MatchCaseExpr;\n-        struct MatchCase;\n-        class MatchExpr;\n-        class AwaitExpr;\n-        class AsyncBlockExpr;\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class MetaItemLitExpr;\n+class MetaItemPathLit;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class StructExprTuple;\n+class StructExprUnit;\n+class EnumVariantExpr;\n+class EnumExprField;\n+class EnumExprFieldIdentifier;\n+class EnumExprFieldWithVal;\n+class EnumExprFieldIdentifierValue;\n+class EnumExprFieldIndexValue;\n+class EnumExprStruct;\n+class EnumExprTuple;\n+class EnumExprFieldless;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n \n-        // rust-stmt.h\n-        class EmptyStmt;\n-        class LetStmt;\n-        class ExprStmt;\n-        class ExprStmtWithoutBlock;\n-        class ExprStmtWithBlock;\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n \n-        // rust-item.h\n-        class TypeParam;\n-        class WhereClauseItem;\n-        class LifetimeWhereClauseItem;\n-        class TypeBoundWhereClauseItem;\n-        struct WhereClause;\n-        struct SelfParam;\n-        struct FunctionQualifiers;\n-        struct FunctionParam;\n-        struct Visibility;\n-        class Method;\n-        class VisItem;\n-        class Module;\n-        class ModuleBodied;\n-        class ModuleNoBody;\n-        class ExternCrate;\n-        class UseTree;\n-        class UseTreeGlob;\n-        class UseTreeList;\n-        class UseTreeRebind;\n-        class UseDeclaration;\n-        class Function;\n-        class TypeAlias;\n-        class Struct;\n-        struct StructField;\n-        class StructStruct;\n-        struct TupleField;\n-        class TupleStruct;\n-        class EnumItem;\n-        class EnumItemTuple;\n-        class EnumItemStruct;\n-        class EnumItemDiscriminant;\n-        class Enum;\n-        class Union;\n-        class ConstantItem;\n-        class StaticItem;\n-        struct TraitFunctionDecl;\n-        class TraitItemFunc;\n-        struct TraitMethodDecl;\n-        class TraitItemMethod;\n-        class TraitItemConst;\n-        class TraitItemType;\n-        class Trait;\n-        class Impl;\n-        class InherentImpl;\n-        class TraitImpl;\n-        class ExternalItem;\n-        class ExternalStaticItem;\n-        struct NamedFunctionParam;\n-        class ExternalFunctionItem;\n-        class ExternBlock;\n+// rust-item.h\n+class TypeParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class Method;\n+class VisItem;\n+class Module;\n+class ModuleBodied;\n+class ModuleNoBody;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+struct TraitMethodDecl;\n+class TraitItemMethod;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class Impl;\n+class InherentImpl;\n+class TraitImpl;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n \n-        // rust-macro.h\n-        class MacroMatchFragment;\n-        class MacroMatchRepetition;\n-        class MacroMatcher;\n-        struct MacroTranscriber;\n-        struct MacroRule;\n-        class MacroRulesDefinition;\n-        class MacroInvocation;\n-        class MetaItemPath;\n-        class MetaItemSeq;\n-        class MetaWord;\n-        class MetaNameValueStr;\n-        class MetaListPaths;\n-        class MetaListNameValueStr;\n+// rust-macro.h\n+class MacroMatchFragment;\n+class MacroMatchRepetition;\n+class MacroMatcher;\n+struct MacroTranscriber;\n+struct MacroRule;\n+class MacroRulesDefinition;\n+class MacroInvocation;\n+class MetaItemPath;\n+class MetaItemSeq;\n+class MetaWord;\n+class MetaNameValueStr;\n+class MetaListPaths;\n+class MetaListNameValueStr;\n \n-        // rust-pattern.h\n-        class LiteralPattern;\n-        class IdentifierPattern;\n-        class WildcardPattern;\n-        class RangePatternBound;\n-        class RangePatternBoundLiteral;\n-        class RangePatternBoundPath;\n-        class RangePatternBoundQualPath;\n-        class RangePattern;\n-        class ReferencePattern;\n-        struct StructPatternEtc;\n-        class StructPatternField;\n-        class StructPatternFieldTuplePat;\n-        class StructPatternFieldIdentPat;\n-        class StructPatternFieldIdent;\n-        struct StructPatternElements;\n-        class StructPattern;\n-        class TupleStructItems;\n-        class TupleStructItemsNoRange;\n-        class TupleStructItemsRange;\n-        class TupleStructPattern;\n-        class TuplePatternItems;\n-        class TuplePatternItemsMultiple;\n-        class TuplePatternItemsRanged;\n-        class TuplePattern;\n-        class GroupedPattern;\n-        class SlicePattern;\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+struct StructPatternElements;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n \n-        // rust-type.h\n-        class TraitBound;\n-        class ImplTraitType;\n-        class TraitObjectType;\n-        class ParenthesisedType;\n-        class ImplTraitTypeOneBound;\n-        class TraitObjectTypeOneBound;\n-        class TupleType;\n-        class NeverType;\n-        class RawPointerType;\n-        class ReferenceType;\n-        class ArrayType;\n-        class SliceType;\n-        class InferredType;\n-        struct MaybeNamedParam;\n-        class BareFunctionType;\n-    }\n-}\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TraitObjectTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace AST\n+} // namespace Rust\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "fe60ae00e4e426b40937227ba6ce425556fc5548", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 120, "deletions": 8, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=97d2003e8c0027601648364c3561b6aa479c842e", "patch": "@@ -1,18 +1,31 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_BASE_H\n #define RUST_AST_BASE_H\n // Base for AST used in gccrs, basically required by all specific ast things\n \n #include \"rust-system.h\"\n-\n-// STL imports\n-#include <memory>\n-#include <string>\n-#include <vector>\n+#include \"rust-hir-map.h\"\n \n // gccrs imports\n // required for AST::Token\n #include \"rust-token.h\"\n-\n #include \"rust-location.h\"\n \n namespace Rust {\n@@ -253,6 +266,95 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool\n+  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n+  {\n+    // this should never be called - should be converted first\n+    return false;\n+  }\n+\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n /* TODO: move applicable stuff into here or just don't include it because\n  * nothing uses it A segment of a path (maybe) */\n class PathSegment\n@@ -473,7 +575,7 @@ struct Attribute\n   std::string as_string () const;\n \n   // TODO: does this require visitor pattern as not polymorphic?\n-  \n+\n   const SimplePath &get_path () const { return path; }\n   SimplePath &get_path () { return path; }\n \n@@ -768,10 +870,15 @@ class Stmt\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+  NodeId get_node_id () const { return node_id; }\n \n protected:\n+  Stmt () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n@@ -848,10 +955,13 @@ class Expr\n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // Constructor\n   Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs))\n+    : outer_attrs (std::move (outer_attribs)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -863,6 +973,8 @@ class Expr\n   {\n     outer_attrs = std::move (outer_attrs_to_set);\n   }\n+\n+  NodeId node_id;\n };\n \n // AST node for an expression without an accompanying block - abstract"}, {"sha": "864ee1ddaf2f6b360c11b0bf648957394551d33a", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=97d2003e8c0027601648364c3561b6aa479c842e", "patch": "@@ -1647,7 +1647,8 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n \n public:\n   StructExprFieldIdentifierValue (Identifier field_identifier,\n-\t\t\t\t  std::unique_ptr<Expr> field_value, Location locus)\n+\t\t\t\t  std::unique_ptr<Expr> field_value,\n+\t\t\t\t  Location locus)\n     : StructExprFieldWithVal (std::move (field_value)),\n       field_name (std::move (field_identifier)), locus (locus)\n   {}\n@@ -1679,7 +1680,8 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n public:\n   StructExprFieldIndexValue (TupleIndex tuple_index,\n \t\t\t     std::unique_ptr<Expr> field_value, Location locus)\n-    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index), locus (locus)\n+    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -2039,7 +2041,8 @@ class EnumExprFieldIdentifierValue : public EnumExprFieldWithVal\n \n public:\n   EnumExprFieldIdentifierValue (Identifier field_name,\n-\t\t\t\tstd::unique_ptr<Expr> field_value, Location locus)\n+\t\t\t\tstd::unique_ptr<Expr> field_value,\n+\t\t\t\tLocation locus)\n     : EnumExprFieldWithVal (std::move (field_value)),\n       field_name (std::move (field_name)), locus (locus)\n   {}\n@@ -2071,7 +2074,8 @@ class EnumExprFieldIndexValue : public EnumExprFieldWithVal\n public:\n   EnumExprFieldIndexValue (TupleIndex field_index,\n \t\t\t   std::unique_ptr<Expr> field_value, Location locus)\n-    : EnumExprFieldWithVal (std::move (field_value)), index (field_index), locus (locus)\n+    : EnumExprFieldWithVal (std::move (field_value)), index (field_index),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -2325,6 +2329,20 @@ class CallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { function = nullptr; }\n   bool is_marked_for_strip () const override { return function == nullptr; }\n \n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto it = params.begin (); it != params.end (); it++)\n+      {\n+\tif (!cb (it->get ()))\n+\t  return;\n+      }\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  CallExpr *clone_expr_impl () const override { return new CallExpr (*this); }\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<std::unique_ptr<Expr> > &get_params () const\n   {\n@@ -2793,13 +2811,16 @@ class BlockExpr : public ExprWithBlock\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Can be completely empty, so have to have a separate flag.\n-  void mark_for_strip () override\n-  {\n-    marked_for_strip = true;\n-  }\n-  bool is_marked_for_strip () const override\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n+  void iterate_stmts (std::function<bool (Stmt *)> cb)\n   {\n-    return marked_for_strip;\n+    for (auto it = statements.begin (); it != statements.end (); it++)\n+      {\n+\tif (!cb (it->get ()))\n+\t  return;\n+      }\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way."}, {"sha": "4b3a2d58ae14f65d84f5c71d555880e02c1f8469", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=97d2003e8c0027601648364c3561b6aa479c842e", "patch": "@@ -1,23 +1,23 @@\n-#ifndef RUST_AST_ITEM_H\n-#define RUST_AST_ITEM_H\n-/*\n-Copyright (C) 2009-2020 Free Software Foundation, Inc.\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+// This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. */\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_ITEM_H\n+#define RUST_AST_ITEM_H\n \n #include \"rust-ast.h\"\n #include \"rust-path.h\"\n@@ -504,11 +504,13 @@ struct FunctionParam\n \t\t std::unique_ptr<Type> param_type,\n \t\t std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), locus (locus),\n-      param_name (std::move (param_name)), type (std::move (param_type))\n+      param_name (std::move (param_name)), type (std::move (param_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor uses clone\n-  FunctionParam (FunctionParam const &other) : locus (other.locus)\n+  FunctionParam (FunctionParam const &other)\n+    : locus (other.locus), node_id (other.node_id)\n   {\n     // guard to prevent nullptr dereference\n     if (other.param_name != nullptr)\n@@ -521,6 +523,7 @@ struct FunctionParam\n   FunctionParam &operator= (FunctionParam const &other)\n   {\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent nullptr dereference\n     if (other.param_name != nullptr)\n@@ -569,6 +572,10 @@ struct FunctionParam\n     rust_assert (type != nullptr);\n     return type;\n   }\n+  NodeId get_node_id () const { return node_id; }\n+\n+protected:\n+  NodeId node_id;\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -3320,6 +3327,7 @@ class Trait : public VisItem\n \t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n+\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),"}, {"sha": "20138b627deade0a78241424c7189042cfc7e8a9", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97d2003e8c0027601648364c3561b6aa479c842e/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=97d2003e8c0027601648364c3561b6aa479c842e", "patch": "@@ -240,6 +240,8 @@ class PathExprSegment\n     rust_assert (has_generic_args ());\n     return generic_args;\n   }\n+\n+  PathIdentSegment &get_ident_segment () { return segment_name; }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -276,6 +278,15 @@ class PathPattern : public Pattern\n   // TODO: this seems kinda dodgy\n   std::vector<PathExprSegment> &get_segments () { return segments; }\n   const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+\n+  void iterate_path_segments (std::function<bool (PathExprSegment &)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n };\n \n /* AST node representing a path-in-expression pattern (path that allows generic\n@@ -328,6 +339,7 @@ class PathInExpression : public PathPattern, public PathExpr\n   // Invalid if path is empty (error state), so base stripping on that.\n   void mark_for_strip () override { remove_all_segments (); }\n   bool is_marked_for_strip () const override { return is_error (); }\n+  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -404,6 +416,13 @@ class TypePathSegment\n \n   // not pure virtual as class not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n+\n+  bool get_separating_scope_resolution () const\n+  {\n+    return has_separating_scope_resolution;\n+  }\n+\n+  PathIdentSegment get_ident_segment () { return ident_segment; };\n };\n \n // Segment used in type path with generic args\n@@ -689,6 +708,17 @@ class TypePath : public TypeNoBounds\n   {\n     return segments;\n   }\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n };\n \n struct QualifiedPathType"}]}