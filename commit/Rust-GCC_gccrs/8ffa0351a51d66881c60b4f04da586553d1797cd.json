{"sha": "8ffa0351a51d66881c60b4f04da586553d1797cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZmYTAzNTFhNTFkNjY4ODFjNjBiNGYwNGRhNTg2NTUzZDE3OTdjZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-09-07T15:57:45Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-09-07T15:57:45Z"}, "message": "regrename.c (struct du_head): Make nregs signed.\n\n\t* regrename.c (struct du_head): Make nregs signed.\n\t(closed_chains): Remove.\n\t(create_new_chain): Return the new chain.\n\t(chain_from_id): New static function.\n\t(dump_def_use_chain): Change argument to be an int, indicating\n\tthe first ID to print.  All callers changed.\n\t(merge_overlapping_regs): Use chain_from_id.  Assert that\n\tchains don't conflict with themselves.\n\t(rename_chains): Take no argument.  Iterate over id_to_chain\n\trather to find chains to rename.  Clear tick before the main\n\tloop.\n\t(struct incoming_reg_info): New struct.\n\t(struct bb_rename_info): New struct.\n\t(init_rename_info, set_incoming_from_chain, merge_chains): New\n\tstatic functions.\n\t(regrename_analyze): New static function, broken out of\n\tregrename_optimize.  Record and make use of open chain information\n\tat basic block boundaries, and merge chains where possible.\n\t(scan_rtx_reg): Make this_nregs signed.  Don't update\n\tclosed_chains.\n\t(build_def_use): Return a bool to indicate success.  All callers\n\tchanged.  Don't initialize global data here.\n\t(regrename_optimize): Move most code out of here into\n\tregrename_analyze.\n\t* regs.h (add_range_to_hard_reg_set, remove_range_from_hard_reg_set,\n\trange_overlaps_hard_reg_set_p, range_in_hard_reg_set_p): New\n\tstatic inline functions.\n\t* vec.h (FOR_EACH_VEC_ELT_FROM): New macro.\n\nFrom-SVN: r178645", "tree": {"sha": "311cb1866ca2c6ce990c341341238f8fc2166d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/311cb1866ca2c6ce990c341341238f8fc2166d1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ffa0351a51d66881c60b4f04da586553d1797cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffa0351a51d66881c60b4f04da586553d1797cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ffa0351a51d66881c60b4f04da586553d1797cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ffa0351a51d66881c60b4f04da586553d1797cd/comments", "author": null, "committer": null, "parents": [{"sha": "a81462f103bd6707e6ac02695bdc515097721156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81462f103bd6707e6ac02695bdc515097721156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81462f103bd6707e6ac02695bdc515097721156"}], "stats": {"total": 624, "additions": 549, "deletions": 75}, "files": [{"sha": "f17dcea885bfcac2ca72ae86f24f4e170518f311", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ffa0351a51d66881c60b4f04da586553d1797cd", "patch": "@@ -1,3 +1,34 @@\n+2011-09-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* regrename.c (struct du_head): Make nregs signed.\n+\t(closed_chains): Remove.\n+\t(create_new_chain): Return the new chain.\n+\t(chain_from_id): New static function.\n+\t(dump_def_use_chain): Change argument to be an int, indicating\n+\tthe first ID to print.  All callers changed.\n+\t(merge_overlapping_regs): Use chain_from_id.  Assert that\n+\tchains don't conflict with themselves.\n+\t(rename_chains): Take no argument.  Iterate over id_to_chain\n+\trather to find chains to rename.  Clear tick before the main\n+\tloop.\n+\t(struct incoming_reg_info): New struct.\n+\t(struct bb_rename_info): New struct.\n+\t(init_rename_info, set_incoming_from_chain, merge_chains): New\n+\tstatic functions.\n+\t(regrename_analyze): New static function, broken out of\n+\tregrename_optimize.  Record and make use of open chain information\n+\tat basic block boundaries, and merge chains where possible.\n+\t(scan_rtx_reg): Make this_nregs signed.  Don't update\n+\tclosed_chains.\n+\t(build_def_use): Return a bool to indicate success.  All callers\n+\tchanged.  Don't initialize global data here.\n+\t(regrename_optimize): Move most code out of here into\n+\tregrename_analyze.\n+\t* regs.h (add_range_to_hard_reg_set, remove_range_from_hard_reg_set,\n+\trange_overlaps_hard_reg_set_p, range_in_hard_reg_set_p): New\n+\tstatic inline functions.\n+\t* vec.h (FOR_EACH_VEC_ELT_FROM): New macro.\n+\n 2011-09-07  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/50301"}, {"sha": "bfff1033018ccdf824e757e5df93fdc5ab5e9cfe", "filename": "gcc/regrename.c", "status": "modified", "additions": 469, "deletions": 75, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=8ffa0351a51d66881c60b4f04da586553d1797cd", "patch": "@@ -47,18 +47,24 @@\n \n      1. Local def/use chains are built: within each basic block, chains are\n \topened and closed; if a chain isn't closed at the end of the block,\n-\tit is dropped.\n+\tit is dropped.  We pre-open chains if we have already examined a\n+\tpredecessor block and found chains live at the end which match\n+\tlive registers at the start of the new block.\n \n-     2. For each chain, the set of possible renaming registers is computed.\n+     2. We try to combine the local chains across basic block boundaries by\n+        comparing chains that were open at the start or end of a block to\n+\tthose in successor/predecessor blocks.\n+\n+     3. For each chain, the set of possible renaming registers is computed.\n \tThis takes into account the renaming of previously processed chains.\n \tOptionally, a preferred class is computed for the renaming register.\n \n-     3. The best renaming register is computed for the chain in the above set,\n+     4. The best renaming register is computed for the chain in the above set,\n \tusing a round-robin allocation.  If a preferred class exists, then the\n \tround-robin allocation is done within the class first, if possible.\n \tThe round-robin allocation of renaming registers itself is global.\n \n-     4. If a renaming register has been found, it is substituted in the chain.\n+     5. If a renaming register has been found, it is substituted in the chain.\n \n   Targets can parameterize the pass by specifying a preferred class for the\n   renaming register for a given (super)class of registers to be renamed.  */\n@@ -75,8 +81,9 @@ struct du_head\n   struct du_head *next_chain;\n   /* The first and last elements of this chain.  */\n   struct du_chain *first, *last;\n-  /* Describes the register being tracked.  */\n-  unsigned regno, nregs;\n+  /* Describe the register being tracked, register number and count.  */\n+  unsigned regno;\n+  int nregs;\n \n   /* A unique id to be used as an index into the conflicts bitmaps.  */\n   unsigned id;\n@@ -140,6 +147,7 @@ static struct obstack rename_obstack;\n static void do_replace (struct du_head *, int);\n static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n \t\t      enum op_type);\n+static bool build_def_use (basic_block);\n \n typedef struct du_head *du_head_p;\n DEF_VEC_P (du_head_p);\n@@ -151,9 +159,8 @@ static unsigned current_id;\n /* A mapping of unique id numbers to chains.  */\n static VEC(du_head_p, heap) *id_to_chain;\n \n-/* List of currently open chains, and closed chains that can be renamed.  */\n+/* List of currently open chains.  */\n static struct du_head *open_chains;\n-static struct du_head *closed_chains;\n \n /* Bitmap of open chains.  The bits set always match the list found in\n    open_chains.  */\n@@ -166,14 +173,33 @@ static HARD_REG_SET live_in_chains;\n    between this and live_in_chains is empty.  */\n static HARD_REG_SET live_hard_regs;\n \n-/* Dump all def/use chains in CHAINS to DUMP_FILE.  */\n+/* Return the chain corresponding to id number ID.  Take into account that\n+   chains may have been merged.  */\n+static du_head_p\n+chain_from_id (unsigned int id)\n+{\n+  du_head_p first_chain = VEC_index (du_head_p, id_to_chain, id);\n+  du_head_p chain = first_chain;\n+  while (chain->id != id)\n+    {\n+      id = chain->id;\n+      chain = VEC_index (du_head_p, id_to_chain, id);\n+    }\n+  first_chain->id = id;\n+  return chain;\n+}\n+\n+/* Dump all def/use chains, starting at id FROM.  */\n \n static void\n-dump_def_use_chain (struct du_head *head)\n+dump_def_use_chain (int from)\n {\n-  while (head)\n+  du_head_p head;\n+  int i;\n+  FOR_EACH_VEC_ELT_FROM (du_head_p, id_to_chain, i, head, from)\n     {\n       struct du_chain *this_du = head->first;\n+\n       fprintf (dump_file, \"Register %s (%d):\",\n \t       reg_names[head->regno], head->nregs);\n       while (this_du)\n@@ -215,7 +241,7 @@ mark_conflict (struct du_head *chains, unsigned id)\n    and record its occurrence in *LOC, which is being written to in INSN.\n    This access requires a register of class CL.  */\n \n-static void\n+static du_head_p\n create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n \t\t  rtx insn, enum reg_class cl)\n {\n@@ -224,7 +250,6 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   int nregs;\n \n   head->next_chain = open_chains;\n-  open_chains = head;\n   head->regno = this_regno;\n   head->nregs = this_nregs;\n   head->need_caller_save_reg = 0;\n@@ -264,7 +289,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   if (insn == NULL_RTX)\n     {\n       head->first = head->last = NULL;\n-      return;\n+      return head;\n     }\n \n   this_du = XOBNEW (&rename_obstack, struct du_chain);\n@@ -274,6 +299,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   this_du->loc = loc;\n   this_du->insn = insn;\n   this_du->cl = cl;\n+  return head;\n }\n \n /* For a def-use chain HEAD, find which registers overlap its lifetime and\n@@ -287,8 +313,9 @@ merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n   IOR_HARD_REG_SET (*pset, head->hard_conflicts);\n   EXECUTE_IF_SET_IN_BITMAP (&head->conflicts, 0, i, bi)\n     {\n-      du_head_p other = VEC_index (du_head_p, id_to_chain, i);\n+      du_head_p other = chain_from_id (i);\n       unsigned j = other->nregs;\n+      gcc_assert (other != head);\n       while (j-- > 0)\n \tSET_HARD_REG_BIT (*pset, other->regno + j);\n     }\n@@ -341,12 +368,15 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n   return true;\n }\n \n-/* Process the closed chains starting with ALL_CHAINS and rename\n-   registers if possible.  */\n+/* Perform register renaming on the current function.  */\n static void\n-rename_chains (du_head_p all_chains)\n+rename_chains (void)\n {\n   HARD_REG_SET unavailable;\n+  du_head_p this_head;\n+  int i;\n+\n+  memset (tick, 0, sizeof tick);\n \n   CLEAR_HARD_REG_SET (unavailable);\n   /* Don't clobber traceback for noreturn functions.  */\n@@ -358,11 +388,10 @@ rename_chains (du_head_p all_chains)\n #endif\n     }\n \n-  while (all_chains)\n+  FOR_EACH_VEC_ELT (du_head_p, id_to_chain, i, this_head)\n     {\n       int new_reg, best_new_reg, best_nregs;\n       int n_uses;\n-      struct du_head *this_head = all_chains;\n       struct du_chain *tmp;\n       HARD_REG_SET this_unavailable;\n       int reg = this_head->regno;\n@@ -371,8 +400,6 @@ rename_chains (du_head_p all_chains)\n       enum reg_class preferred_class;\n       bool has_preferred_class;\n \n-      all_chains = this_head->next_chain;\n-\n       if (this_head->cannot_rename)\n \tcontinue;\n \n@@ -488,14 +515,425 @@ rename_chains (du_head_p all_chains)\n     }\n }\n \n+/* A structure to record information for each hard register at the start of\n+   a basic block.  */\n+struct incoming_reg_info {\n+  /* Holds the number of registers used in the chain that gave us information\n+     about this register.  Zero means no information known yet, while a\n+     negative value is used for something that is part of, but not the first\n+     register in a multi-register value.  */\n+  int nregs;\n+  /* Set to true if we have accesses that conflict in the number of registers\n+     used.  */\n+  bool unusable;\n+};\n+\n+/* A structure recording information about each basic block.  It is saved\n+   and restored around basic block boundaries.\n+   A pointer to such a structure is stored in each basic block's aux field\n+   during regrename_analyze, except for blocks we know can't be optimized\n+   (such as entry and exit blocks).  */\n+struct bb_rename_info\n+{\n+  /* The basic block corresponding to this structure.  */\n+  basic_block bb;\n+  /* Copies of the global information.  */\n+  bitmap_head open_chains_set;\n+  bitmap_head incoming_open_chains_set;\n+  struct incoming_reg_info incoming[FIRST_PSEUDO_REGISTER];\n+};\n+\n+/* Initialize a rename_info structure P for basic block BB, which starts a new\n+   scan.  */\n+static void\n+init_rename_info (struct bb_rename_info *p, basic_block bb)\n+{\n+  int i;\n+  df_ref *def_rec;\n+  HARD_REG_SET start_chains_set;\n+\n+  p->bb = bb;\n+  bitmap_initialize (&p->open_chains_set, &bitmap_default_obstack);\n+  bitmap_initialize (&p->incoming_open_chains_set, &bitmap_default_obstack);\n+\n+  open_chains = NULL;\n+  bitmap_clear (&open_chains_set);\n+\n+  CLEAR_HARD_REG_SET (live_in_chains);\n+  REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_in (bb));\n+  for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n+    {\n+      df_ref def = *def_rec;\n+      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n+\tSET_HARD_REG_BIT (live_hard_regs, DF_REF_REGNO (def));\n+    }\n+\n+  /* Open chains based on information from (at least one) predecessor\n+     block.  This gives us a chance later on to combine chains across\n+     basic block boundaries.  Inconsistencies (in access sizes) will\n+     be caught normally and dealt with conservatively by disabling the\n+     chain for renaming, and there is no risk of losing optimization\n+     opportunities by opening chains either: if we did not open the\n+     chains, we'd have to track the live register as a hard reg, and\n+     we'd be unable to rename it in any case.  */\n+  CLEAR_HARD_REG_SET (start_chains_set);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      struct incoming_reg_info *iri = p->incoming + i;\n+      if (iri->nregs > 0 && !iri->unusable\n+\t  && range_in_hard_reg_set_p (live_hard_regs, i, iri->nregs))\n+\t{\n+\t  SET_HARD_REG_BIT (start_chains_set, i);\n+\t  remove_range_from_hard_reg_set (&live_hard_regs, i, iri->nregs);\n+\t}\n+    }\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      struct incoming_reg_info *iri = p->incoming + i;\n+      if (TEST_HARD_REG_BIT (start_chains_set, i))\n+\t{\n+\t  du_head_p chain;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"opening incoming chain\\n\");\n+\t  chain = create_new_chain (i, iri->nregs, NULL, NULL_RTX, NO_REGS);\n+\t  bitmap_set_bit (&p->incoming_open_chains_set, chain->id);\n+\t}\n+    }\n+}\n+\n+/* Record in RI that the block corresponding to it has an incoming\n+   live value, described by CHAIN.  */\n+static void\n+set_incoming_from_chain (struct bb_rename_info *ri, du_head_p chain)\n+{\n+  int i;\n+  int incoming_nregs = ri->incoming[chain->regno].nregs;\n+  int nregs;\n+\n+  /* If we've recorded the same information before, everything is fine.  */\n+  if (incoming_nregs == chain->nregs)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"reg %d/%d already recorded\\n\",\n+\t\t chain->regno, chain->nregs);\n+      return;\n+    }\n+\n+  /* If we have no information for any of the involved registers, update\n+     the incoming array.  */\n+  nregs = chain->nregs;\n+  while (nregs-- > 0)\n+    if (ri->incoming[chain->regno + nregs].nregs != 0\n+\t|| ri->incoming[chain->regno + nregs].unusable)\n+      break;\n+  if (nregs < 0)\n+    {\n+      nregs = chain->nregs;\n+      ri->incoming[chain->regno].nregs = nregs;\n+      while (nregs-- > 1)\n+\tri->incoming[chain->regno + nregs].nregs = -nregs;\n+      if (dump_file)\n+\tfprintf (dump_file, \"recorded reg %d/%d\\n\",\n+\t\t chain->regno, chain->nregs);\n+      return;\n+    }\n+\n+  /* There must be some kind of conflict.  Prevent both the old and\n+     new ranges from being used.  */\n+  if (incoming_nregs < 0)\n+    ri->incoming[chain->regno + incoming_nregs].unusable = true;\n+  for (i = 0; i < chain->nregs; i++)\n+    ri->incoming[chain->regno + i].unusable = true;\n+}\n+\n+/* Merge the two chains C1 and C2 so that all conflict information is\n+   recorded and C1, and the id of C2 is changed to that of C1.  */\n+static void\n+merge_chains (du_head_p c1, du_head_p c2)\n+{\n+  if (c1 == c2)\n+    return;\n+\n+  if (c2->first != NULL)\n+    {\n+      if (c1->first == NULL)\n+\tc1->first = c2->first;\n+      else\n+\tc1->last->next_use = c2->first;\n+      c1->last = c2->last;\n+    }\n+\n+  c2->first = c2->last = NULL;\n+  c2->id = c1->id;\n+\n+  IOR_HARD_REG_SET (c1->hard_conflicts, c2->hard_conflicts);\n+  bitmap_ior_into (&c1->conflicts, &c2->conflicts);\n+\n+  c1->need_caller_save_reg |= c2->need_caller_save_reg;\n+  c1->cannot_rename |= c2->cannot_rename;\n+}\n+\n+/* Analyze the current function and build chains for renaming.  */\n+\n+static void\n+regrename_analyze (void)\n+{\n+  struct bb_rename_info *rename_info;\n+  int i;\n+  basic_block bb;\n+  int n_bbs;\n+  int *inverse_postorder;\n+\n+  inverse_postorder = XNEWVEC (int, last_basic_block);\n+  n_bbs = pre_and_rev_post_order_compute (NULL, inverse_postorder, false);\n+\n+  /* Gather some information about the blocks in this function.  */\n+  rename_info = XCNEWVEC (struct bb_rename_info, n_basic_blocks);\n+  i = 0;\n+  FOR_EACH_BB (bb)\n+    {\n+      struct bb_rename_info *ri = rename_info + i;\n+      ri->bb = bb;\n+      bb->aux = ri;\n+      i++;\n+    }\n+\n+  current_id = 0;\n+  id_to_chain = VEC_alloc (du_head_p, heap, 0);\n+  bitmap_initialize (&open_chains_set, &bitmap_default_obstack);\n+\n+  /* The order in which we visit blocks ensures that whenever\n+     possible, we only process a block after at least one of its\n+     predecessors, which provides a \"seeding\" effect to make the logic\n+     in set_incoming_from_chain and init_rename_info useful.  */\n+\n+  for (i = 0; i < n_bbs; i++)\n+    {\n+      basic_block bb1 = BASIC_BLOCK (inverse_postorder[i]);\n+      struct bb_rename_info *this_info;\n+      bool success;\n+      edge e;\n+      edge_iterator ei;\n+      int old_length = VEC_length (du_head_p, id_to_chain);\n+\n+      this_info = (struct bb_rename_info *) bb1->aux;\n+      if (this_info == NULL)\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nprocessing block %d:\\n\", bb1->index);\n+\n+      init_rename_info (this_info, bb1);\n+\n+      success = build_def_use (bb1);\n+      if (!success)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"failed\\n\");\n+\t  bb1->aux = NULL;\n+\t  VEC_truncate (du_head_p, id_to_chain, old_length);\n+\t  current_id = old_length;\n+\t  bitmap_clear (&this_info->incoming_open_chains_set);\n+\t  open_chains = NULL;\n+\t  continue;\n+\t}\n+\n+      if (dump_file)\n+\tdump_def_use_chain (old_length);\n+      bitmap_copy (&this_info->open_chains_set, &open_chains_set);\n+\n+      /* Add successor blocks to the worklist if necessary, and record\n+\t data about our own open chains at the end of this block, which\n+\t will be used to pre-open chains when processing the successors.  */\n+      FOR_EACH_EDGE (e, ei, bb1->succs)\n+\t{\n+\t  struct bb_rename_info *dest_ri;\n+\t  struct du_head *chain;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"successor block %d\\n\", e->dest->index);\n+\n+\t  if (e->flags & (EDGE_EH | EDGE_ABNORMAL))\n+\t    continue;\n+\t  dest_ri = (struct bb_rename_info *)e->dest->aux;\n+\t  if (dest_ri == NULL)\n+\t    continue;\n+\t  for (chain = open_chains; chain; chain = chain->next_chain)\n+\t    set_incoming_from_chain (dest_ri, chain);\n+\t}\n+    }\n+\n+  free (inverse_postorder);\n+\n+  /* Now, combine the chains data we have gathered across basic block\n+     boundaries.\n+\n+     For every basic block, there may be chains open at the start, or at the\n+     end.  Rather than exclude them from renaming, we look for open chains\n+     with matching registers at the other side of the CFG edge.\n+\n+     For a given chain using register R, open at the start of block B, we\n+     must find an open chain using R on the other side of every edge leading\n+     to B, if the register is live across this edge.  In the code below,\n+     N_PREDS_USED counts the number of edges where the register is live, and\n+     N_PREDS_JOINED counts those where we found an appropriate chain for\n+     joining.\n+\n+     We perform the analysis for both incoming and outgoing edges, but we\n+     only need to merge once (in the second part, after verifying outgoing\n+     edges).  */\n+  FOR_EACH_BB (bb)\n+    {\n+      struct bb_rename_info *bb_ri = (struct bb_rename_info *) bb->aux;\n+      unsigned j;\n+      bitmap_iterator bi;\n+\n+      if (bb_ri == NULL)\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"processing bb %d in edges\\n\", bb->index);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (&bb_ri->incoming_open_chains_set, 0, j, bi)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  struct du_head *chain = chain_from_id (j);\n+\t  int n_preds_used = 0, n_preds_joined = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      struct bb_rename_info *src_ri;\n+\t      unsigned k;\n+\t      bitmap_iterator bi2;\n+\t      HARD_REG_SET live;\n+\t      bool success = false;\n+\n+\t      REG_SET_TO_HARD_REG_SET (live, df_get_live_out (e->src));\n+\t      if (!range_overlaps_hard_reg_set_p (live, chain->regno,\n+\t\t\t\t\t\t  chain->nregs))\n+\t\tcontinue;\n+\t      n_preds_used++;\n+\n+\t      if (e->flags & (EDGE_EH | EDGE_ABNORMAL))\n+\t\tcontinue;\n+\n+\t      src_ri = (struct bb_rename_info *)e->src->aux;\n+\t      if (src_ri == NULL)\n+\t\tcontinue;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (&src_ri->open_chains_set,\n+\t\t\t\t\t0, k, bi2)\n+\t\t{\n+\t\t  struct du_head *outgoing_chain = chain_from_id (k);\n+\n+\t\t  if (outgoing_chain->regno == chain->regno\n+\t\t      && outgoing_chain->nregs == chain->nregs)\n+\t\t    {\n+\t\t      n_preds_joined++;\n+\t\t      success = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!success && dump_file)\n+\t\tfprintf (dump_file, \"failure to match with pred block %d\\n\",\n+\t\t\t e->src->index);\n+\t    }\n+\t  if (n_preds_joined < n_preds_used)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"cannot rename chain %d\\n\", j);\n+\t      chain->cannot_rename = 1;\n+\t    }\n+\t}\n+    }\n+  FOR_EACH_BB (bb)\n+    {\n+      struct bb_rename_info *bb_ri = (struct bb_rename_info *) bb->aux;\n+      unsigned j;\n+      bitmap_iterator bi;\n+\n+      if (bb_ri == NULL)\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"processing bb %d out edges\\n\", bb->index);\n+\n+      EXECUTE_IF_SET_IN_BITMAP (&bb_ri->open_chains_set, 0, j, bi)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  struct du_head *chain = chain_from_id (j);\n+\t  int n_succs_used = 0, n_succs_joined = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      bool printed = false;\n+\t      struct bb_rename_info *dest_ri;\n+\t      unsigned k;\n+\t      bitmap_iterator bi2;\n+\t      HARD_REG_SET live;\n+\n+\t      REG_SET_TO_HARD_REG_SET (live, df_get_live_in (e->dest));\n+\t      if (!range_overlaps_hard_reg_set_p (live, chain->regno,\n+\t\t\t\t\t\t  chain->nregs))\n+\t\tcontinue;\n+\t      \n+\t      n_succs_used++;\n+\n+\t      dest_ri = (struct bb_rename_info *)e->dest->aux;\n+\t      if (dest_ri == NULL)\n+\t\tcontinue;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (&dest_ri->incoming_open_chains_set,\n+\t\t\t\t\t0, k, bi2)\n+\t\t{\n+\t\t  struct du_head *incoming_chain = chain_from_id (k);\n+\n+\t\t  if (incoming_chain->regno == chain->regno\n+\t\t      && incoming_chain->nregs == chain->nregs)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\t{\n+\t\t\t  if (!printed)\n+\t\t\t    fprintf (dump_file,\n+\t\t\t\t     \"merging blocks for edge %d -> %d\\n\",\n+\t\t\t\t     e->src->index, e->dest->index);\n+\t\t\t  printed = true;\n+\t\t\t  fprintf (dump_file,\n+\t\t\t\t   \"  merging chains %d (->%d) and %d (->%d) [%s]\\n\",\n+\t\t\t\t   k, incoming_chain->id, j, chain->id, \n+\t\t\t\t   reg_names[incoming_chain->regno]);\n+\t\t\t}\n+\n+\t\t      merge_chains (chain, incoming_chain);\n+\t\t      n_succs_joined++;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (n_succs_joined < n_succs_used)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"cannot rename chain %d\\n\",\n+\t\t\t j);\n+\t      chain->cannot_rename = 1;\n+\t    }\n+\t}\n+    }\n+\n+  free (rename_info);\n+\n+  FOR_EACH_BB (bb)\n+    bb->aux = NULL;\n+}\n+\n static void\n do_replace (struct du_head *head, int reg)\n {\n   struct du_chain *chain;\n   unsigned int base_regno = head->regno;\n \n-  gcc_assert (! DEBUG_INSN_P (head->first->insn));\n-\n   for (chain = head->first; chain; chain = chain->next_use)\n     {\n       unsigned int regno = ORIGINAL_REGNO (*chain->loc);\n@@ -591,7 +1029,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n   rtx x = *loc;\n   enum machine_mode mode = GET_MODE (x);\n   unsigned this_regno = REGNO (x);\n-  unsigned this_nregs = hard_regno_nregs[this_regno][mode];\n+  int this_nregs = hard_regno_nregs[this_regno][mode];\n \n   if (action == mark_write)\n     {\n@@ -691,8 +1129,6 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \n \t  if (subset && !superset)\n \t    head->cannot_rename = 1;\n-\t  head->next_chain = closed_chains;\n-\t  closed_chains = head;\n \t  bitmap_clear_bit (&open_chains_set, head->id);\n \n \t  nregs = head->nregs;\n@@ -1078,28 +1514,14 @@ record_out_operands (rtx insn, bool earlyclobber)\n \n /* Build def/use chain.  */\n \n-static struct du_head *\n+static bool\n build_def_use (basic_block bb)\n {\n   rtx insn;\n-  df_ref *def_rec;\n   unsigned HOST_WIDE_INT untracked_operands;\n \n-  open_chains = closed_chains = NULL;\n-\n   fail_current_block = false;\n \n-  current_id = 0;\n-  bitmap_initialize (&open_chains_set, &bitmap_default_obstack);\n-  CLEAR_HARD_REG_SET (live_in_chains);\n-  REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_in (bb));\n-  for (def_rec = df_get_artificial_defs (bb->index); *def_rec; def_rec++)\n-    {\n-      df_ref def = *def_rec;\n-      if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n-\tSET_HARD_REG_BIT (live_hard_regs, DF_REF_REGNO (def));\n-    }\n-\n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n       if (NONDEBUG_INSN_P (insn))\n@@ -1338,59 +1760,31 @@ build_def_use (basic_block bb)\n \tbreak;\n     }\n \n-  bitmap_clear (&open_chains_set);\n-\n   if (fail_current_block)\n-    return NULL;\n+    return false;\n \n-  /* Since we close every chain when we find a REG_DEAD note, anything that\n-     is still open lives past the basic block, so it can't be renamed.  */\n-  return closed_chains;\n+  return true;\n }\n \f\n /* Perform register renaming on the current function.  */\n \n static unsigned int\n regrename_optimize (void)\n {\n-  basic_block bb;\n-  char *first_obj;\n-\n   df_set_flags (DF_LR_RUN_DCE);\n   df_note_add_problem ();\n   df_analyze ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n-  memset (tick, 0, sizeof tick);\n-\n   gcc_obstack_init (&rename_obstack);\n-  first_obj = XOBNEWVAR (&rename_obstack, char, 0);\n \n-  FOR_EACH_BB (bb)\n-    {\n-      struct du_head *all_chains = 0;\n+  regrename_analyze ();\n \n-      id_to_chain = VEC_alloc (du_head_p, heap, 0);\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\nBasic block %d:\\n\", bb->index);\n-\n-      all_chains = build_def_use (bb);\n-\n-      if (dump_file)\n-\tdump_def_use_chain (all_chains);\n-\n-      rename_chains (all_chains);\n-\n-      free_chain_data ();\n-      obstack_free (&rename_obstack, first_obj);\n-    }\n+  rename_chains ();\n \n+  free_chain_data ();\n   obstack_free (&rename_obstack, NULL);\n \n-  if (dump_file)\n-    fputc ('\\n', dump_file);\n-\n   return 0;\n }\n \f"}, {"sha": "328b839ffaca304ff4659519fd18eca7fdbfa7a1", "filename": "gcc/regs.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=8ffa0351a51d66881c60b4f04da586553d1797cd", "patch": "@@ -397,4 +397,48 @@ overlaps_hard_reg_set_p (const HARD_REG_SET regs, enum machine_mode mode,\n   return false;\n }\n \n+/* Like add_to_hard_reg_set, but use a REGNO/NREGS range instead of\n+   REGNO and MODE.  */\n+\n+static inline void\n+add_range_to_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n+\t\t\t   int nregs)\n+{\n+  while (nregs-- > 0)\n+    SET_HARD_REG_BIT (*regs, regno + nregs);\n+}\n+\n+/* Likewise, but remove the registers.  */\n+\n+static inline void\n+remove_range_from_hard_reg_set (HARD_REG_SET *regs, unsigned int regno,\n+\t\t\t\tint nregs)\n+{\n+  while (nregs-- > 0)\n+    CLEAR_HARD_REG_BIT (*regs, regno + nregs);\n+}\n+\n+/* Like overlaps_hard_reg_set_p, but use a REGNO/NREGS range instead of\n+   REGNO and MODE.  */\n+static inline bool\n+range_overlaps_hard_reg_set_p (const HARD_REG_SET set, unsigned regno,\n+\t\t\t       int nregs)\n+{\n+  while (nregs-- > 0)\n+    if (TEST_HARD_REG_BIT (set, regno + nregs))\n+      return true;\n+  return false;\n+}\n+\n+/* Like in_hard_reg_set_p, but use a REGNO/NREGS range instead of\n+   REGNO and MODE.  */\n+static inline bool\n+range_in_hard_reg_set_p (const HARD_REG_SET set, unsigned regno, int nregs)\n+{\n+  while (nregs-- > 0)\n+    if (!TEST_HARD_REG_BIT (set, regno + nregs))\n+      return false;\n+  return true;\n+}\n+\n #endif /* GCC_REGS_H */"}, {"sha": "789e8e2d4df6444cf89d2b3dbbbd276ce32f5dba", "filename": "gcc/vec.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ffa0351a51d66881c60b4f04da586553d1797cd/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=8ffa0351a51d66881c60b4f04da586553d1797cd", "patch": "@@ -195,6 +195,11 @@ along with GCC; see the file COPYING3.  If not see\n #define FOR_EACH_VEC_ELT(T, V, I, P)\t\t\\\n   for (I = 0; VEC_iterate (T, (V), (I), (P)); ++(I))\n \n+/* Likewise, but start from FROM rather than 0.  */\n+\n+#define FOR_EACH_VEC_ELT_FROM(T, V, I, P, FROM)\t\t\\\n+  for (I = (FROM); VEC_iterate (T, (V), (I), (P)); ++(I))\n+\n /* Convenience macro for reverse iteration.  */\n \n #define FOR_EACH_VEC_ELT_REVERSE(T,V,I,P) \\"}]}