{"sha": "e658434c30adf83a498773944003d4e6e6c32335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY1ODQzNGMzMGFkZjgzYTQ5ODc3Mzk0NDAwM2Q0ZTZlNmMzMjMzNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-03T20:27:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-03T20:27:23Z"}, "message": "Add prototypes for static functions.\n\n(uses_reg_or_mem): New function.\n(find_basic_block): Some cleanups; eliminate shadowed variables.\nLook for REG_LABEL notes in all insns and allow for multiple such.\nDon't delete labels in forced_labels.\nGeneralize test for computed jumps.\n(find_auto_inc): OFFSET should be HOST_WIDE_INT.\n(mark_used_regs): Put decls of parms in parm order.\n(find_use_as_address): PLUSCONST should be HOST_WIDE_INT.\n\nFrom-SVN: r6477", "tree": {"sha": "fa7d026f44aa8ef26aa48c50c5449085cc0b347a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa7d026f44aa8ef26aa48c50c5449085cc0b347a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e658434c30adf83a498773944003d4e6e6c32335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e658434c30adf83a498773944003d4e6e6c32335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e658434c30adf83a498773944003d4e6e6c32335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e658434c30adf83a498773944003d4e6e6c32335/comments", "author": null, "committer": null, "parents": [{"sha": "896389552ba444585e6718a98d1d6a4267b7b17e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896389552ba444585e6718a98d1d6a4267b7b17e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896389552ba444585e6718a98d1d6a4267b7b17e"}], "stats": {"total": 287, "additions": 173, "deletions": 114}, "files": [{"sha": "44eafc0a09b7a8d150166cb114dd7722393973cd", "filename": "gcc/flow.c", "status": "modified", "additions": 173, "deletions": 114, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e658434c30adf83a498773944003d4e6e6c32335/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e658434c30adf83a498773944003d4e6e6c32335/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e658434c30adf83a498773944003d4e6e6c32335", "patch": "@@ -279,20 +279,26 @@ static rtx last_mem_set;\n static HARD_REG_SET elim_reg_set;\n \n /* Forward declarations */\n-static void find_basic_blocks ();\n-static void life_analysis ();\n-static void mark_label_ref ();\n-void allocate_for_life_analysis (); /* Used also in stupid_life_analysis */\n-static void init_regset_vector ();\n-static void propagate_block ();\n-static void mark_set_regs ();\n-static void mark_used_regs ();\n-static int insn_dead_p ();\n-static int libcall_dead_p ();\n-static int try_pre_increment ();\n-static int try_pre_increment_1 ();\n-static rtx find_use_as_address ();\n-void dump_flow_info ();\n+static void find_basic_blocks\t\tPROTO((rtx, rtx));\n+static int uses_reg_or_mem\t\tPROTO((rtx));\n+static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n+static void life_analysis\t\tPROTO((rtx, int));\n+void allocate_for_life_analysis\t\tPROTO((void));\n+static void init_regset_vector\t\tPROTO((regset *, regset, int, int));\n+static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n+\t\t\t\t\t       regset, int));\n+static int insn_dead_p\t\t\tPROTO((rtx, regset, int));\n+static int libcall_dead_p\t\tPROTO((rtx, regset, rtx, rtx));\n+static void mark_set_regs\t\tPROTO((regset, regset, rtx,\n+\t\t\t\t\t       rtx, regset));\n+static void mark_set_1\t\t\tPROTO((regset, regset, rtx,\n+\t\t\t\t\t       rtx, regset));\n+static void find_auto_inc\t\tPROTO((regset, rtx, rtx));\n+static void mark_used_regs\t\tPROTO((regset, regset, rtx, int, rtx));\n+static int try_pre_increment_1\t\tPROTO((rtx));\n+static int try_pre_increment\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n+static rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n+void dump_flow_info\t\t\tPROTO((FILE *));\n \f\n /* Find basic blocks of the current function and perform data flow analysis.\n    F is the first insn of the function and NREGS the number of register numbers\n@@ -403,6 +409,9 @@ find_basic_blocks (f, nonlocal_label_list)\n   /* List of label_refs to all labels whose addresses are taken\n      and used as data.  */\n   rtx label_value_list = 0;\n+  rtx x, note;\n+  enum rtx_code prev_code, code;\n+  int depth;\n \n   block_live_static = block_live;\n   bzero (block_live, n_basic_blocks);\n@@ -412,105 +421,97 @@ find_basic_blocks (f, nonlocal_label_list)\n   if (n_basic_blocks > 0)\n     block_live[0] = 1;\n \n-  /* Initialize the ref chain of each label to 0.  */\n-  /* Record where all the blocks start and end and their depth in loops.  */\n-  /* For each insn, record the block it is in.  */\n-  /* Also mark as reachable any blocks headed by labels that\n-     must not be deleted.  */\n+  /* Initialize the ref chain of each label to 0.  Record where all the\n+     blocks start and end and their depth in loops.  For each insn, record\n+     the block it is in.   Also mark as reachable any blocks headed by labels\n+     that must not be deleted.  */\n \n-  {\n-    register RTX_CODE prev_code = JUMP_INSN;\n-    register RTX_CODE code;\n-    int depth = 1;\n+  for (insn = f, i = -1, prev_code = JUMP_INSN, depth = 1;\n+       insn; insn = NEXT_INSN (insn))\n+    {\n+      code = GET_CODE (insn);\n+      if (code == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    depth++;\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    depth--;\n+\t}\n \n-    for (insn = f, i = -1; insn; insn = NEXT_INSN (insn))\n-      {\n-\tcode = GET_CODE (insn);\n-\tif (code == NOTE)\n-\t  {\n-\t    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t      depth++;\n-\t    else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t      depth--;\n-\t  }\n-\t/* A basic block starts at label, or after something that can jump.  */\n-\telse if (code == CODE_LABEL\n-\t\t || (GET_RTX_CLASS (code) == 'i'\n-\t\t     && (prev_code == JUMP_INSN\n-\t\t\t || (prev_code == CALL_INSN\n-\t\t\t     && nonlocal_label_list != 0\n-\t\t\t     /* Ignore if CLOBBER since we consider this\n-\t\t\t\tpart of the CALL.  See below.  */\n-\t\t\t     && ! (code == INSN\n-\t\t\t\t   && GET_CODE (PATTERN (insn)) == CLOBBER))\n-\t\t\t || prev_code == BARRIER)))\n-\t  {\n-\t    basic_block_head[++i] = insn;\n-\t    basic_block_end[i] = insn;\n-\t    basic_block_loop_depth[i] = depth;\n-\t    if (code == CODE_LABEL)\n-\t      {\n+      /* A basic block starts at label, or after something that can jump.  */\n+      else if (code == CODE_LABEL\n+\t       || (GET_RTX_CLASS (code) == 'i'\n+\t\t   && (prev_code == JUMP_INSN\n+\t\t       || (prev_code == CALL_INSN\n+\t\t\t   && nonlocal_label_list != 0\n+\t\t\t   /* Ignore if CLOBBER since we consider this\n+\t\t\t      part of the CALL.  See below.  */\n+\t\t\t   && ! (code == INSN\n+\t\t\t\t && GET_CODE (PATTERN (insn)) == CLOBBER))\n+\t\t       || prev_code == BARRIER)))\n+\t{\n+\t  basic_block_head[++i] = insn;\n+\t  basic_block_end[i] = insn;\n+\t  basic_block_loop_depth[i] = depth;\n+\n+\t  if (code == CODE_LABEL)\n+\t    {\n \t\tLABEL_REFS (insn) = insn;\n \t\t/* Any label that cannot be deleted\n \t\t   is considered to start a reachable block.  */\n \t\tif (LABEL_PRESERVE_P (insn))\n \t\t  block_live[i] = 1;\n \t      }\n-\t  }\n-\telse if (GET_RTX_CLASS (code) == 'i')\n-\t  {\n-\t    basic_block_end[i] = insn;\n-\t    basic_block_loop_depth[i] = depth;\n-\t  }\n+\t}\n \n-\t/* Make a list of all labels referred to other than by jumps.  */\n-\tif (code == INSN || code == CALL_INSN)\n-\t  {\n-\t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n-\t    if (note != 0)\n+      else if (GET_RTX_CLASS (code) == 'i')\n+\t{\n+\t  basic_block_end[i] = insn;\n+\t  basic_block_loop_depth[i] = depth;\n+\n+\t  /* Make a list of all labels referred to other than by jumps.  */\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n \t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n \t\t\t\t\t  label_value_list);\n \t  }\n \n-\tBLOCK_NUM (insn) = i;\n+      BLOCK_NUM (insn) = i;\n \n-\t/* Don't separate a CALL_INSN from following CLOBBER insns.  This is\n-\t   a kludge that will go away when each CALL_INSN records its\n-\t   USE and CLOBBERs.  */\n+      /* Don't separate a CALL_INSN from following CLOBBER insns.  This is a\n+\t kludge that will go away when each CALL_INSN records its USE and\n+\t CLOBBERs.  */\n \n-\tif (code != NOTE\n-\t    && ! (prev_code == CALL_INSN && code == INSN\n-\t\t  && GET_CODE (PATTERN (insn)) == CLOBBER))\n-\t  prev_code = code;\n-      }\n-    if (i + 1 != n_basic_blocks)\n-      abort ();\n-  }\n+      if (code != NOTE\n+\t  && ! (prev_code == CALL_INSN && code == INSN\n+\t\t&& GET_CODE (PATTERN (insn)) == CLOBBER))\n+\tprev_code = code;\n+    }\n+\n+  if (i + 1 != n_basic_blocks)\n+    abort ();\n \n   /* Don't delete the labels (in this function)\n      that are referenced by non-jump instructions.  */\n-  {\n-    register rtx x;\n-    for (x = label_value_list; x; x = XEXP (x, 1))\n-      if (! LABEL_REF_NONLOCAL_P (x))\n-\tblock_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n-  }\n+\n+  for (x = label_value_list; x; x = XEXP (x, 1))\n+    if (! LABEL_REF_NONLOCAL_P (x))\n+      block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n+\n+  for (x = forced_labels; x; x = XEXP (x, 1))\n+    if (! LABEL_REF_NONLOCAL_P (x))\n+      block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n \n   /* Record which basic blocks control can drop in to.  */\n \n-  {\n-    register int i;\n-    for (i = 0; i < n_basic_blocks; i++)\n-      {\n-\tregister rtx insn = PREV_INSN (basic_block_head[i]);\n-\t/* TEMP1 is used to avoid a bug in Sequent's compiler.  */\n-\tregister int temp1;\n-\twhile (insn && GET_CODE (insn) == NOTE)\n-\t  insn = PREV_INSN (insn);\n-\ttemp1 = insn && GET_CODE (insn) != BARRIER;\n-\tbasic_block_drops_in[i] = temp1;\n-      }\n-  }\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      for (insn = PREV_INSN (basic_block_head[i]);\n+\t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n+\t;\n+\n+      basic_block_drops_in[i] = insn && GET_CODE (insn) != BARRIER;\n+    }\n \n   /* Now find which basic blocks can actually be reached\n      and put all jump insns' LABEL_REFS onto the ref-chains\n@@ -520,25 +521,53 @@ find_basic_blocks (f, nonlocal_label_list)\n     {\n       int something_marked = 1;\n \n-      /* Find all indirect jump insns and mark them as possibly jumping\n-\t to all the labels whose addresses are explicitly used.\n-\t This is because, when there are computed gotos,\n-\t we can't tell which labels they jump to, of all the possibilities.  */\n+      /* Find all indirect jump insns and mark them as possibly jumping to all\n+\t the labels whose addresses are explicitly used.  This is because,\n+\t when there are computed gotos, we can't tell which labels they jump\n+\t to, of all the possibilities.\n+\n+\t Tablejumps and casesi insns are OK and we can recognize them by\n+\t a (use (label_ref)).  */\n \n       for (insn = f; insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == JUMP_INSN\n-\t    && GET_CODE (PATTERN (insn)) == SET\n-\t    && SET_DEST (PATTERN (insn)) == pc_rtx\n-\t    && (GET_CODE (SET_SRC (PATTERN (insn))) == REG\n-\t\t|| GET_CODE (SET_SRC (PATTERN (insn))) == MEM))\n+\tif (GET_CODE (insn) == JUMP_INSN)\n \t  {\n-\t    rtx x;\n-\t    for (x = label_value_list; x; x = XEXP (x, 1))\n-\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n-\t\t\t      insn, 0);\n-\t    for (x = forced_labels; x; x = XEXP (x, 1))\n-\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t    rtx pat = PATTERN (insn);\n+\t    int computed_jump = 0;\n+\n+\t    if (GET_CODE (pat) == PARALLEL)\n+\t      {\n+\t\tint len = XVECLEN (pat, 0);\n+\t\tint has_use_labelref = 0;\n+\n+\t\tfor (i = len - 1; i >= 0; i--)\n+\t\t  if (GET_CODE (XVECEXP (pat, 0, i)) == USE\n+\t\t      && (GET_CODE (XEXP (XVECEXP (pat, 0, i), 0))\n+\t\t\t  == LABEL_REF))\n+\t\t    has_use_labelref = 1;\n+\n+\t\tif (! has_use_labelref)\n+\t\t  for (i = len - 1; i >= 0; i--)\n+\t\t    if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t\t\t&& SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx\n+\t\t\t&& uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))\n+\t\t      computed_jump = 1;\n+\t      }\n+\t    else if (GET_CODE (pat) == SET\n+\t\t     && SET_DEST (pat) == pc_rtx\n+\t\t     && uses_reg_or_mem (SET_SRC (pat)))\n+\t      computed_jump = 1;\n+\t\t    \n+\t    if (computed_jump)\n+\t      {\n+\t\tfor (x = label_value_list; x; x = XEXP (x, 1))\n+\t\t  mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t\t  insn, 0);\n+\n+\t\tfor (x = forced_labels; x; x = XEXP (x, 1))\n+\t\t  mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n \t\t\t      insn, 0);\n+\t      }\n \t  }\n \n       /* Find all call insns and mark them as possibly jumping\n@@ -547,13 +576,13 @@ find_basic_blocks (f, nonlocal_label_list)\n       for (insn = f; insn; insn = NEXT_INSN (insn))\n \tif (GET_CODE (insn) == CALL_INSN)\n \t  {\n-\t    rtx x;\n \t    for (x = nonlocal_label_list; x; x = XEXP (x, 1))\n \t      /* Don't try marking labels that\n \t\t were deleted as unreferenced.  */\n \t      if (GET_CODE (XEXP (x, 0)) == CODE_LABEL)\n \t\tmark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n \t\t\t\tinsn, 0);\n+\n \t    /* ??? This could be made smarter:\n \t       in some cases it's possible to tell that certain\n \t       calls will not do a nonlocal goto.\n@@ -654,6 +683,38 @@ find_basic_blocks (f, nonlocal_label_list)\n     }\n }\n \f\n+/* Return 1 if X contain a REG or MEM that is not in the constant pool.  */\n+\n+static int\n+uses_reg_or_mem (x)\n+     rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  char *fmt;\n+\n+  if (code == REG\n+      || (code == MEM\n+\t  && ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t\t&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))))\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e'\n+\t  && uses_reg_or_mem (XEXP (x, i)))\n+\treturn 1;\n+\n+      if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (uses_reg_or_mem (XVECEXP (x, i, j)))\n+\t    return 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n /* Check expression X for label references;\n    if one is found, add INSN to the label's chain of references.\n \n@@ -1169,7 +1230,7 @@ init_regset_vector (vector, space, nelts, bytes_per_elt)\n       p += bytes_per_elt / sizeof (*p);\n     }\n }\n-\f\n+\n /* Compute the registers live at the beginning of a basic block\n    from those live at the end.\n \n@@ -1727,8 +1788,6 @@ regno_clobbered_at_setjmp (regno)\n    in propagate_block.  In this case, various info about register\n    usage is stored, LOG_LINKS fields of insns are set up.  */\n \n-static void mark_set_1 ();\n-\n static void\n mark_set_regs (needed, dead, x, insn, significant)\n      regset needed;\n@@ -1968,7 +2027,7 @@ find_auto_inc (needed, x, insn)\n      rtx insn;\n {\n   rtx addr = XEXP (x, 0);\n-  int offset = 0;\n+  HOST_WIDE_INT offset = 0;\n   rtx set;\n \n   /* Here we detect use of an index register which might be good for\n@@ -2144,8 +2203,8 @@ mark_used_regs (needed, live, x, final, insn)\n      regset needed;\n      regset live;\n      rtx x;\n-     rtx insn;\n      int final;\n+     rtx insn;\n {\n   register RTX_CODE code;\n   register int regno;\n@@ -2577,7 +2636,7 @@ static rtx\n find_use_as_address (x, reg, plusconst)\n      register rtx x;\n      rtx reg;\n-     int plusconst;\n+     HOST_WIDE_INT plusconst;\n {\n   enum rtx_code code = GET_CODE (x);\n   char *fmt = GET_RTX_FORMAT (code);"}]}