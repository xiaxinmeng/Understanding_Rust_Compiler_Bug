{"sha": "753b4679bc46f6806cf45d9afc3783c6d3b63589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUzYjQ2NzliYzQ2ZjY4MDZjZjQ1ZDlhZmMzNzgzYzZkM2I2MzU4OQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-08-26T12:27:33Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-09-03T18:30:06Z"}, "message": "c++: Fix P0960 in member init list and array [PR92812]\n\nThis patch nails down the remaining P0960 case in PR92812:\n\n  struct A {\n    int ar[2];\n    A(): ar(1, 2) {} // doesn't work without this patch\n  };\n\nNote that when the target object is not of array type, this already\nworks:\n\n  struct S { int x, y; };\n  struct A {\n    S s;\n    A(): s(1, 2) { } // OK in C++20\n  };\n\nbecause build_new_method_call_1 takes care of the P0960 magic.\n\nIt proved to be quite hairy.  When the ()-list has more than one\nelement, we can always create a CONSTRUCTOR, because the code was\npreviously invalid.  But when the ()-list has just one element, it\ngets all kinds of difficult.  As usual, we have to handle a(\"foo\")\nso as not to wrap the STRING_CST in a CONSTRUCTOR.  Always turning\nx(e) into x{e} would run into trouble as in c++/93790.  Another\nissue was what to do about x({e}): previously, this would trigger\n\"list-initializer for non-class type must not be parenthesized\".\nI figured I'd make this work in C++20, so that given\n\n  struct S { int x, y; };\n\nyou can do\n\n   S a[2];\n   [...]\n   A(): a({1, 2}) // initialize a[0] with {1, 2} and a[1] with {}\n\nIt also turned out that, as an extension, we support compound literals:\n\n  F (): m((S[1]) { 1, 2 })\n\nso this has to keep working as before.  Moreover, make sure not to trigger\nin compiler-generated code, like =default, where array assignment is allowed.\n\nI've factored out a function that turns a TREE_LIST into a CONSTRUCTOR\nto simplify handling of P0960.\n\nparen-init35.C also tests this with vector types.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/92812\n\t* cp-tree.h (do_aggregate_paren_init): Declare.\n\t* decl.c (do_aggregate_paren_init): New.\n\t(grok_reference_init): Use it.\n\t(check_initializer): Likewise.\n\t* init.c (perform_member_init): Handle initializing an array from\n\ta ()-list.  Use do_aggregate_paren_init.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/92812\n\t* g++.dg/cpp0x/constexpr-array23.C: Adjust dg-error.\n\t* g++.dg/cpp0x/initlist69.C: Likewise.\n\t* g++.dg/diagnostic/mem-init1.C: Likewise.\n\t* g++.dg/init/array28.C: Likewise.\n\t* g++.dg/cpp2a/paren-init33.C: New test.\n\t* g++.dg/cpp2a/paren-init34.C: New test.\n\t* g++.dg/cpp2a/paren-init35.C: New test.\n\t* g++.old-deja/g++.brendan/crash60.C: Adjust dg-error.\n\t* g++.old-deja/g++.law/init10.C: Likewise.\n\t* g++.old-deja/g++.other/array3.C: Likewise.", "tree": {"sha": "73c4f9354bfad6c843c92c04369b8ea5d6668a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73c4f9354bfad6c843c92c04369b8ea5d6668a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/753b4679bc46f6806cf45d9afc3783c6d3b63589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/753b4679bc46f6806cf45d9afc3783c6d3b63589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/753b4679bc46f6806cf45d9afc3783c6d3b63589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/753b4679bc46f6806cf45d9afc3783c6d3b63589/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6641d6d3fe79113f8d9f3ced355aea79bffda822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6641d6d3fe79113f8d9f3ced355aea79bffda822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6641d6d3fe79113f8d9f3ced355aea79bffda822"}], "stats": {"total": 286, "additions": 239, "deletions": 47}, "files": [{"sha": "708de83eb466e68da9eaed328fbe219db6b5a616", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -6582,6 +6582,7 @@ extern bool check_array_designated_initializer  (constructor_elt *,\n extern bool check_for_uninitialized_const_var   (tree, bool, tsubst_flags_t);\n extern tree build_explicit_specifier\t\t(tree, tsubst_flags_t);\n extern void do_push_parm_decls\t\t\t(tree, tree, tree *);\n+extern tree do_aggregate_paren_init\t\t(tree, tree);\n \n /* in decl2.c */\n extern void record_mangling\t\t\t(tree, bool);"}, {"sha": "31d68745844eea0102773f6cabb92a23ed9a8965", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -5557,6 +5557,37 @@ start_decl_1 (tree decl, bool initialized)\n   maybe_push_cleanup_level (type);\n }\n \n+/* Given a parenthesized list of values INIT, create a CONSTRUCTOR to handle\n+   C++20 P0960.  TYPE is the type of the object we're initializing.  */\n+\n+tree\n+do_aggregate_paren_init (tree init, tree type)\n+{\n+  tree val = TREE_VALUE (init);\n+\n+  if (TREE_CHAIN (init) == NULL_TREE)\n+    {\n+      /* If the list has a single element and it's a string literal,\n+\t then it's the initializer for the array as a whole.  */\n+      if (TREE_CODE (type) == ARRAY_TYPE\n+\t  && char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+\t  && TREE_CODE (tree_strip_any_location_wrapper (val))\n+\t     == STRING_CST)\n+\treturn val;\n+      /* Handle non-standard extensions like compound literals.  This also\n+\t prevents triggering aggregate parenthesized-initialization in\n+\t compiler-generated code for =default.  */\n+      else if (same_type_ignoring_top_level_qualifiers_p (type,\n+\t\t\t\t\t\t\t  TREE_TYPE (val)))\n+\treturn val;\n+    }\n+\n+  init = build_constructor_from_list (init_list_type_node, init);\n+  CONSTRUCTOR_IS_DIRECT_INIT (init) = true;\n+  CONSTRUCTOR_IS_PAREN_INIT (init) = true;\n+  return init;\n+}\n+\n /* Handle initialization of references.  DECL, TYPE, and INIT have the\n    same meaning as in cp_finish_decl.  *CLEANUP must be NULL on entry,\n    but will be set to a new CLEANUP_STMT if a temporary is created\n@@ -5604,11 +5635,7 @@ grok_reference_init (tree decl, tree type, tree init, int flags)\n \t  /* If the list had more than one element, the code is ill-formed\n \t     pre-C++20, so we can build a constructor right away.  */\n \t  else\n-\t    {\n-\t      init = build_constructor_from_list (init_list_type_node, init);\n-\t      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;\n-\t      CONSTRUCTOR_IS_PAREN_INIT (init) = true;\n-\t    }\n+\t    init = do_aggregate_paren_init (init, ttype);\n \t}\n       else\n \tinit = build_x_compound_expr_from_list (init, ELK_INIT,\n@@ -6794,30 +6821,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t       && TREE_CODE (type) == ARRAY_TYPE\n \t       && !DECL_DECOMPOSITION_P (decl)\n \t       && (cxx_dialect >= cxx20))\n-\t{\n-\t  /* [dcl.init.string] \"An array of ordinary character type [...]\n-\t     can be initialized by an ordinary string literal [...] by an\n-\t     appropriately-typed string literal enclosed in braces\" only\n-\t     talks about braces, but GCC has always accepted\n-\n-\t       char a[](\"foobar\");\n-\n-\t     so we continue to do so.  */\n-\t  tree val = TREE_VALUE (init);\n-\t  if (TREE_CHAIN (init) == NULL_TREE\n-\t      && char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n-\t      && TREE_CODE (tree_strip_any_location_wrapper (val))\n-\t\t == STRING_CST)\n-\t    /* If the list has a single element and it's a string literal,\n-\t       then it's the initializer for the array as a whole.  */\n-\t    init = val;\n-\t  else\n-\t    {\n-\t      init = build_constructor_from_list (init_list_type_node, init);\n-\t      CONSTRUCTOR_IS_DIRECT_INIT (init) = true;\n-\t      CONSTRUCTOR_IS_PAREN_INIT (init) = true;\n-\t    }\n-\t}\n+\tinit = do_aggregate_paren_init (init, type);\n       else if (TREE_CODE (init) == TREE_LIST\n \t       && TREE_TYPE (init) != unknown_type_node\n \t       && !MAYBE_CLASS_TYPE_P (type))"}, {"sha": "3268ae4ad3f164e6e2f32c0cfb39f83348a847ff", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -809,13 +809,25 @@ perform_member_init (tree member, tree init)\n       return;\n     }\n \n-  if (init && TREE_CODE (init) == TREE_LIST\n-      && (DIRECT_LIST_INIT_P (TREE_VALUE (init))\n-\t  /* FIXME C++20 parenthesized aggregate init (PR 92812).  */\n-\t  || !(/* cxx_dialect >= cxx20 ? CP_AGGREGATE_TYPE_P (type) */\n-\t       /* :  */CLASS_TYPE_P (type))))\n-    init = build_x_compound_expr_from_list (init, ELK_MEM_INIT,\n-\t\t\t\t\t    tf_warning_or_error);\n+  if (init && TREE_CODE (init) == TREE_LIST)\n+    {\n+      /* A(): a{e} */\n+      if (DIRECT_LIST_INIT_P (TREE_VALUE (init)))\n+\tinit = build_x_compound_expr_from_list (init, ELK_MEM_INIT,\n+\t\t\t\t\t\ttf_warning_or_error);\n+      /* We are trying to initialize an array from a ()-list.  If we\n+\t should attempt to do so, conjure up a CONSTRUCTOR.  */\n+      else if (TREE_CODE (type) == ARRAY_TYPE\n+\t       /* P0960 is a C++20 feature.  */\n+\t       && cxx_dialect >= cxx20)\n+\tinit = do_aggregate_paren_init (init, type);\n+      else if (!CLASS_TYPE_P (type))\n+\tinit = build_x_compound_expr_from_list (init, ELK_MEM_INIT,\n+\t\t\t\t\t\ttf_warning_or_error);\n+      /* If we're initializing a class from a ()-list, leave the TREE_LIST\n+\t alone: we might call an appropriate constructor, or (in C++20)\n+\t do aggregate-initialization.  */\n+    }\n \n   if (init == void_type_node)\n     {"}, {"sha": "1829fa7a6535422deeb4abd42f97433f740d03e2", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array23.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array23.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -9,9 +9,9 @@ struct A\n };\n \n struct B\n-{\t\t\t\t// This should really be target { ! c++2a }\n-  typedef A W[4];\t\t// { dg-error \"paren\" \"\" { target *-*-* } .+1 }\n-  constexpr B () : w ({ A::z, A::z, A::z, A::z }) {} // { dg-error \"constant\" }\n+{\n+  typedef A W[4];\t\t// { dg-error \"paren\" \"\" { target { ! c++20 } } .+1 }\n+  constexpr B () : w ({ A::z, A::z, A::z, A::z }) {} // { dg-error \"constant|could not convert\" }\n   W w;\n };\n "}, {"sha": "893a4e92cd3153b77c37dce98507761884919afb", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist69.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist69.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist69.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist69.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -6,14 +6,14 @@ struct ca {\n   T elem[1];\n \n   ca(const T (&s)[1]): elem{{s}} { }\t   // { dg-error \"invalid\" }\n-  ca(const T (&s)[1],int): elem({{s}}) { } // { dg-error \"paren|invalid\" }\n+  ca(const T (&s)[1],int): elem({{s}}) { } // { dg-error \"paren|invalid|too many\" }\n   ca(const T (&s)[1],char): elem(s) { }\t   // { dg-error \"array\" }\n   ca(const T (&s)[1],double): elem{s} { }  // { dg-error \"invalid\" }\n \n   ca(const T &v): elem{{v}} { }\t      // OK\n   ca(const T &v,int): elem{{{v}}} { } // { dg-error \"braces\" }\n   ca(const T &v,char): elem{v} { }    // OK\n-  ca(const T &v,double): elem({v}) { } // { dg-error \"paren\" }\n+  ca(const T &v,double): elem({v}) { } // { dg-error \"paren\" \"\" { target { ! c++20 } } }\n };\n \n int main() {"}, {"sha": "43f323e8f146c964470624d962bf2f7dc92fa7ef", "filename": "gcc/testsuite/g++.dg/cpp2a/paren-init33.C", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init33.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -0,0 +1,128 @@\n+// PR c++/92812\n+// { dg-do run { target c++20 } }\n+// { dg-options \"-Wall -Wextra\" }\n+// Initializing arrays in a member init list using ()-init, valid cases.\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n+\n+struct S { int x, y; };\n+struct N { int x, y; N(int, int); };\n+\n+static S s{10, 11};\n+\n+struct A {\n+  S s1;\n+  S s2;\n+  S a1[2];\n+  S a2[2];\n+  S a3[2];\n+  S a4[2];\n+  S a5[2];\n+  S a6[2];\n+  A() : s1(1, 2),\n+\ts2(1), // { dg-warning \"missing initializer for member\" }\n+\ta1({1}), // { dg-warning \"missing initializer for member\" }\n+\ta2({1, 2}),\n+\ta3({}, {}),\n+\ta4(),\n+\ta5(s),\n+\ta6(s, s)\n+    { }\n+};\n+\n+struct C {\n+  int a1[2];\n+  int a2[2];\n+  int a3[2];\n+  int a4[2];\n+  int a5[2];\n+  C() : a1(1),\n+\ta2(1, 2),\n+\ta3({1}),\n+\ta4({}, {}),\n+\ta5()\n+    { }\n+};\n+\n+struct D {\n+  N n;\n+  // Not an aggregate, should work pre-C++20 too.\n+  D() : n(1, 2) { }\n+};\n+\n+struct E {\n+  char a1[4];\n+  char a2[4];\n+  E() : a1(\"ab\"),\n+\ta2(\"abc\")\n+    { }\n+};\n+\n+// Compound literal.\n+struct F {\n+  F ();\n+  S m[1];\n+};\n+\n+F::F () : m(__extension__(S[1]) { 1, 2 })\n+{\n+}\n+\n+struct B { int i; };\n+struct Der : B { };\n+Der d;\n+struct G {\n+  B b1[1];\n+  B b2[2];\n+  G(): b1(d),\n+       b2(d, d)\n+    { }\n+};\n+\n+// Variation of c++/93790.\n+struct Empty { };\n+struct Empty_refwrap {\n+  Empty& r;\n+  Empty_refwrap(Empty &e) : r(e) { }\n+  operator Empty&() { return r; }\n+};\n+\n+Empty empty;\n+Empty_refwrap empty_refwrap(empty);\n+\n+struct H {\n+  Empty &e;\n+  // Turning this into {empty_refwrap} would break things.\n+  H() : e(empty_refwrap) { }\n+};\n+\n+int\n+main ()\n+{\n+  A a;\n+  assert (a.s1.x == 1 && a.s1.y == 2);\n+  assert (a.s2.x == 1 && a.s2.y == 0);\n+  assert (a.a1[0].x == 1 && a.a1[0].y == 0\n+\t  && a.a1[1].x == 0 && a.a1[1].y == 0);\n+  assert (a.a2[0].x == 1 && a.a2[0].y == 2\n+\t  && a.a2[1].x == 0 && a.a2[1].y == 0);\n+  assert (a.a3[0].x == 0 && a.a3[0].y == 0\n+\t  && a.a3[1].x == 0 && a.a3[1].y == 0);\n+  assert (a.a4[0].x == 0 && a.a4[0].y == 0\n+\t  && a.a4[1].x == 0 && a.a4[1].y == 0);\n+  assert (a.a5[0].x == 10 && a.a5[0].y == 11\n+\t  && a.a5[1].x == 0 && a.a5[1].y == 0);\n+  assert (a.a6[0].x == 10 && a.a6[0].y == 11\n+\t  && a.a6[1].x == 10 && a.a6[1].y == 11);\n+\n+  C c;\n+  assert (c.a1[0] == 1 && c.a1[1] == 0);\n+  assert (c.a2[0] == 1 && c.a2[1] == 2);\n+  assert (c.a3[0] == 1 && c.a3[1] == 0);\n+  assert (c.a4[0] == 0 && c.a4[1] == 0);\n+  assert (c.a5[0] == 0 && c.a5[1] == 0);\n+\n+  E e;\n+  assert (__builtin_strcmp (e.a1, \"ab\") == 0\n+\t  && __builtin_strcmp (e.a2, \"abc\") == 0);\n+}"}, {"sha": "24942764cb706a0e209b0708ff63c201eaf1a760", "filename": "gcc/testsuite/g++.dg/cpp2a/paren-init34.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init34.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/92812\n+// { dg-do compile { target c++20 } }\n+// Initializing arrays in a member init list using ()-init, invalid cases.\n+\n+struct S { int x, y; };\n+struct N { int x, y; N(int, int); };\n+\n+struct A {\n+  N a[2];\n+  A() : a(1, 2) { } // { dg-error \"could not convert\" }\n+};\n+\n+struct B {\n+  S a[2];\n+  B() : a(1) // { dg-error \"could not convert\" }\n+    { }\n+};\n+\n+// Copy-initialization does not consider explicit ctors.\n+struct E { explicit E(int); };\n+\n+struct C {\n+  E a[2];\n+  C() : a(4, 5) { } // { dg-error \"could not convert\" }\n+};"}, {"sha": "4f1892742c4ab2919a7f7be3b36e5b41298a7b21", "filename": "gcc/testsuite/g++.dg/cpp2a/paren-init35.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fparen-init35.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/92812\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options \"-Wno-psabi\" }\n+// Paren-init in a member init list with vector types.\n+\n+typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+__m128 m;\n+__m128 g(m);\n+__m128 ag[](m, m, m);\n+__m128 ag2[]({}, {}, {});\n+\n+struct A {\n+  __m128 a1;\n+  __m128 a2[2];\n+  __m128 a3[2];\n+  A() : a1(m),\n+\ta2(m, m),\n+\ta3({}, m)\n+    { }\n+};"}, {"sha": "8ea5264b0e05e369442c0c816cfb88e26d73c9f1", "filename": "gcc/testsuite/g++.dg/diagnostic/mem-init1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmem-init1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmem-init1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmem-init1.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -4,7 +4,7 @@\n struct A {\n     A()\n     : a()       // { dg-error \"reference type\" }\n-    , b(1)      // { dg-error \"incompatible\" }\n+    , b(1)      // { dg-error \"incompatible\" \"\" { target { ! c++20 } } }\n     , c(0)      // { dg-bogus \"\" }\n     {}\n \n@@ -17,7 +17,7 @@ template<typename T, typename U>\n struct B {\n     B()\n     : a()       // { dg-error \"reference type\" }\n-    , b(1)      // { dg-error \"incompatible\" }\n+    , b(1)      // { dg-error \"incompatible\" \"\" { target { ! c++20 } } }\n     , c(0)      // { dg-bogus \"\" }\n     {}\n "}, {"sha": "a75c36215f97dce10ac4062a7b57787e6fd6e17e", "filename": "gcc/testsuite/g++.dg/init/array28.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray28.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -2,6 +2,6 @@\n \n struct Foo { explicit Foo(int) { } };\n struct Goo {\n-  Goo() : x(Foo(4), Foo(5)) { } // { dg-error \"\" }\n+  Goo() : x(Foo(4), Foo(5)) { } // { dg-error \"\" \"\" { target { ! c++20 } } }\n   Foo x[2];\n };"}, {"sha": "1f5629b51340d5b8adbb279266f0a16fac8741f9", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash60.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash60.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash60.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash60.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -9,4 +9,4 @@ public:\n \n // Note that we mistakenly initialize the array data member as if it\n // was scalar\n-X::X () : f (0) {}// { dg-error \"\" } .*\n+X::X () : f (0) {}// { dg-error \"\" \"\" { target { ! c++20 } } }"}, {"sha": "1a020ec730be97076e8f6e2597d727a8bd52c6d8", "filename": "gcc/testsuite/g++.old-deja/g++.law/init10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Finit10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Finit10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Finit10.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -20,7 +20,7 @@ public:\n         b();\n };\n \n-b::b() : three(this)  // { dg-error \"array\" }\n+b::b() : three(this)  // { dg-error \"array|could not convert\" }\n {\n }\n "}, {"sha": "6eeeb4f3888dc6743d1b9c0d66d2898593e5da52", "filename": "gcc/testsuite/g++.old-deja/g++.other/array3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/753b4679bc46f6806cf45d9afc3783c6d3b63589/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Farray3.C?ref=753b4679bc46f6806cf45d9afc3783c6d3b63589", "patch": "@@ -20,6 +20,7 @@ class B\n };\n \n B::B (const A a[])\n-  : ary(a)        // { dg-error \"array\" }\n+\t\t  // { dg-error \"could not convert|invalid conversion\" \"\" { target { c++20 } } .+1 }\n+  : ary(a)        // { dg-error \"array\" \"\" { target { ! c++20 } } }\n {\n }"}]}