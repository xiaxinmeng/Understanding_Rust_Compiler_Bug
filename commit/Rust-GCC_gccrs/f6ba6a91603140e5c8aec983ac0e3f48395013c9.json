{"sha": "f6ba6a91603140e5c8aec983ac0e3f48395013c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZiYTZhOTE2MDMxNDBlNWM4YWVjOTgzYWMwZTNmNDgzOTUwMTNjOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:18:22Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:18:22Z"}, "message": "(LONG_DOUBLE_TYPE_SIZE): Set to 96, for XFmode support.\n\n(ASM_OUTPUT_LONG_DOUBLE_OPERAND) New macro.\n(ASM_OUTPUT_FLOAT, ASM_OUTPUT_DOUBLE): Use REAL_VALUE_... macros.\n(ASM_OUTPUT_DOUBLE_OPERAND): Likewise.\n(ASM_OUTPUT_FLOAT_OPERAND): Likewise.  Also, new argument CODE.\n(ASM_OUTPUT_FLOAT): Delete special def for CROSS_COMPILE.\n(ASM_OUTPUT_LONG_DOUBLE): New macro.\n(PRINT_OPERAND_EXTRACT_FLOAT): Definitions deleted.\n(PRINT_OPERAND_PRINT_FLOAT): Definitions deleted.\n\nFrom-SVN: r3972", "tree": {"sha": "620e6dcf2a224699d8febfa53d13bf5ad7d07626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/620e6dcf2a224699d8febfa53d13bf5ad7d07626"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6ba6a91603140e5c8aec983ac0e3f48395013c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ba6a91603140e5c8aec983ac0e3f48395013c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ba6a91603140e5c8aec983ac0e3f48395013c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ba6a91603140e5c8aec983ac0e3f48395013c9/comments", "author": null, "committer": null, "parents": [{"sha": "c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1cfb2ae9ba507a30f76b6d73bede24446e4d876"}], "stats": {"total": 105, "additions": 64, "deletions": 41}, "files": [{"sha": "3c5cd62a29782f64b998f65614cfe9fb55489579", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ba6a91603140e5c8aec983ac0e3f48395013c9/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ba6a91603140e5c8aec983ac0e3f48395013c9/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=f6ba6a91603140e5c8aec983ac0e3f48395013c9", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n-   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -141,6 +141,15 @@ extern int target_flags;\n \f\n /* target machine storage layout */\n \n+/* Define for XFmode extended real floating point support.\n+   This will automatically cause REAL_ARITHMETIC to be defined.  */\n+#define LONG_DOUBLE_TYPE_SIZE 96\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+/* #define REAL_ARITHMETIC */\n+\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is true for 68020 insns such as bfins and bfexts.\n@@ -1522,31 +1531,36 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*%s%s%d\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n \n+/* This is how to output a `long double' extended real constant. */\n+  \n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\t\t\\\n+do { long l[3];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (FILE, \"\\t.long 0x%x,0x%x,0x%x\\n\", l[0], l[1], l[2]);\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (FILE, \"\\t.long 0x%lx,0x%lx,0x%lx\\n\", l[0], l[1], l[2]);\t\\\n+   } while (0)\n+  \n /* This is how to output an assembler line defining a `double' constant.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.double 0r%.20g\\n\", (VALUE))\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+  do { char dstr[30];\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\\\n+       fprintf (FILE, \"\\t.double 0r%s\\n\", dstr);\t\t\\\n+     } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n-/* Sun's assembler can't handle floating constants written as floating.\n-   However, when cross-compiling, always use that in case format differs.  */\n-\n-#ifdef CROSS_COMPILE\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.float 0r%.10g\\n\", (VALUE))\n-\n-#else\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-do { union { float f; long l;} tem;\t\t\t\\\n-     tem.f = (VALUE);\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.long 0x%x\\n\", tem.l);\t\\\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+do { long l;\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\\\n+       fprintf (FILE, \"\\t.long 0x%x\\n\", l);\t\t\\\n+     else\t\t\t\t\t\t\\\n+       fprintf (FILE, \"\\t.long 0x%lx\\n\", l);\t\t\\\n    } while (0)\n \n-#endif /* not CROSS_COMPILE */\n-\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n@@ -1649,13 +1663,41 @@ do { union { float f; long l;} tem;\t\t\t\\\n \n /* Output a float value (represented as a C double) as an immediate operand.\n    This macro is a 68k-specific macro.  */\n-#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\t\t\t\\\n-  asm_fprintf (FILE, \"%I0r%.9g\", (VALUE))\n+\n+#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\\\n+ do {\t\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          char dstr[30];\t\t\t\t\t\\\n+          REAL_VALUE_TO_DECIMAL (VALUE, \"%.9g\", dstr);\t\t\\\n+          asm_fprintf ((FILE), \"%I0r%s\", dstr);\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          long l;\t\t\t\t\t\t\\\n+          REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+          if (sizeof (int) == sizeof (long))\t\t\t\\\n+            asm_fprintf ((FILE), \"%I0x%x\", l);\t\t\t\\\n+          else\t\t\t\t\t\t\t\\\n+            asm_fprintf ((FILE), \"%I0x%lx\", l);\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+     } while (0)\n \n /* Output a double value (represented as a C double) as an immediate operand.\n    This macro is a 68k-specific macro.  */\n #define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n-  asm_fprintf (FILE, \"%I0r%.20g\", (VALUE))\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n+    } while (0)\n+\n+/* Note, long double immediate operands are not actually\n+   generated by m68k.md.  */\n+#define ASM_OUTPUT_LONG_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\\\n+ do { char dstr[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+      asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n+    } while (0)\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n@@ -1692,25 +1734,6 @@ do { union { float f; long l;} tem;\t\t\t\\\n    || (CODE) == '+' || (CODE) == '@' || (CODE) == '!'\t\t\t\\\n    || (CODE) == '$' || (CODE) == '&' || (CODE) == '/')\n \n-#ifdef HOST_WORDS_BIG_ENDIAN\n-#define PRINT_OPERAND_EXTRACT_FLOAT(X)\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\n-#else\n-#define PRINT_OPERAND_EXTRACT_FLOAT(X)\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_HIGH (X); u.i[1] = CONST_DOUBLE_LOW (X);\n-#endif\n-\n-#ifdef CROSS_COMPILE\n-#define PRINT_OPERAND_PRINT_FLOAT(CODE, FILE)   \\\n-  ASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\n-#else\n-#define PRINT_OPERAND_PRINT_FLOAT(CODE, FILE)   \\\n-{ if (CODE == 'f')\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    asm_fprintf (FILE, \"%I0x%x\", u1.i); }\n-#endif\n-\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL\n    expression."}]}