{"sha": "6ae361ae458d4056d6c36fa42f1775c417457b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFlMzYxYWU0NThkNDA1NmQ2YzM2ZmE0MmYxNzc1YzQxNzQ1N2IxMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-23T22:38:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-23T22:38:58Z"}, "message": "compiler: record pointer var values to remove write barriers\n    \n    Record when a local pointer variable is set to a value such that\n    indirecting through the pointer does not require a write barrier.  Use\n    that to eliminate write barriers when indirecting through that local\n    pointer variable.  Only keep this information per-block, so it's not\n    all that applicable.\n    \n    This reduces the number of write barriers generated when compiling the\n    runtime package from 553 to 524.\n    \n    The point of this is to eliminate a bad write barrier in the bytes\n    function in runtime/print.go.  Mark that function nowritebarrier so\n    that the problem does not recur.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/191581\n\nFrom-SVN: r274890", "tree": {"sha": "2abbeb7a9dc1276b8a53259a89738319fdee0f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2abbeb7a9dc1276b8a53259a89738319fdee0f45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ae361ae458d4056d6c36fa42f1775c417457b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae361ae458d4056d6c36fa42f1775c417457b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae361ae458d4056d6c36fa42f1775c417457b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae361ae458d4056d6c36fa42f1775c417457b10/comments", "author": null, "committer": null, "parents": [{"sha": "457dac402027dd7e14543fbd59a75858422cf6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457dac402027dd7e14543fbd59a75858422cf6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457dac402027dd7e14543fbd59a75858422cf6c6"}], "stats": {"total": 129, "additions": 102, "deletions": 27}, "files": [{"sha": "73c75342feaed23a1edc03d6e7d23eea3c603e98", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6ae361ae458d4056d6c36fa42f1775c417457b10", "patch": "@@ -1,4 +1,4 @@\n-82d27f0f140f33406cf59c0fb262f6dba3077f8e\n+c9ca1c6bf887c752cc75cf1ddaec8ddd1ec962d4\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "90a39a222b0347b3fed21cd2eb313b76642bfb06", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6ae361ae458d4056d6c36fa42f1775c417457b10", "patch": "@@ -9039,7 +9039,7 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \t  // directly before the write barrier pass.\n \t  Statement* assign;\n \t  if (assign_lhs != NULL\n-\t      || !gogo->assign_needs_write_barrier(lhs))\n+\t      || !gogo->assign_needs_write_barrier(lhs, NULL))\n \t    assign = Statement::make_assignment(lhs, elem, loc);\n \t  else\n \t    {"}, {"sha": "087e89057ac8e961b96581732385ae4e8762a1fb", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=6ae361ae458d4056d6c36fa42f1775c417457b10", "patch": "@@ -771,7 +771,14 @@ class Gogo\n   // Return whether an assignment that sets LHS to RHS needs a write\n   // barrier.\n   bool\n-  assign_needs_write_barrier(Expression* lhs);\n+  assign_needs_write_barrier(Expression* lhs,\n+                             Unordered_set(const Named_object*)*);\n+\n+  // Return whether EXPR is the address of a variable that can be set\n+  // without a write barrier.  That is, if this returns true, then an\n+  // assignment to *EXPR does not require a write barrier.\n+  bool\n+  is_nonwb_pointer(Expression* expr, Unordered_set(const Named_object*)*);\n \n   // Return an assignment that sets LHS to RHS using a write barrier.\n   // This returns an if statement that checks whether write barriers"}, {"sha": "41d8f94c0744197d014f1cb393c8d14be19c6da7", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 91, "deletions": 24, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae361ae458d4056d6c36fa42f1775c417457b10/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=6ae361ae458d4056d6c36fa42f1775c417457b10", "patch": "@@ -402,13 +402,20 @@ class Write_barriers : public Traverse\n {\n  public:\n   Write_barriers(Gogo* gogo)\n-    : Traverse(traverse_functions | traverse_variables | traverse_statements),\n-      gogo_(gogo), function_(NULL), statements_added_()\n+    : Traverse(traverse_functions\n+\t       | traverse_blocks\n+\t       | traverse_variables\n+\t       | traverse_statements),\n+      gogo_(gogo), function_(NULL), statements_added_(),\n+      nonwb_pointers_()\n   { }\n \n   int\n   function(Named_object*);\n \n+  int\n+  block(Block*);\n+\n   int\n   variable(Named_object*);\n \n@@ -422,6 +429,9 @@ class Write_barriers : public Traverse\n   Function* function_;\n   // Statements introduced.\n   Statement_inserter::Statements statements_added_;\n+  // Within a single block, pointer variables that point to values\n+  // that do not need write barriers.\n+  Unordered_set(const Named_object*) nonwb_pointers_;\n };\n \n // Traverse a function.  Just record it for later.\n@@ -439,6 +449,16 @@ Write_barriers::function(Named_object* no)\n   return TRAVERSE_SKIP_COMPONENTS;\n }\n \n+// Traverse a block.  Clear anything we know about local pointer\n+// variables.\n+\n+int\n+Write_barriers::block(Block*)\n+{\n+  this->nonwb_pointers_.clear();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Insert write barriers for a global variable: ensure that variable\n // initialization is handled correctly.  This is rarely needed, since\n // we currently don't enable background GC until after all global\n@@ -533,7 +553,16 @@ Write_barriers::statement(Block* block, size_t* pindex, Statement* s)\n \t// local variables get declaration statements, and local\n \t// variables on the stack do not require write barriers.\n \tif (!var->is_in_heap())\n-\t  break;\n+          {\n+\t    // If this is a pointer variable, and assigning through\n+\t    // the initializer does not require a write barrier,\n+\t    // record that fact.\n+\t    if (var->type()->points_to() != NULL\n+\t\t&& this->gogo_->is_nonwb_pointer(init, &this->nonwb_pointers_))\n+\t      this->nonwb_pointers_.insert(no);\n+\n+\t    break;\n+          }\n \n \t// Nothing to do if the variable does not contain any pointers.\n \tif (!var->type()->has_pointer())\n@@ -578,15 +607,27 @@ Write_barriers::statement(Block* block, size_t* pindex, Statement* s)\n       {\n \tAssignment_statement* as = s->assignment_statement();\n \n-\tif (as->omit_write_barrier())\n-\t  break;\n-\n \tExpression* lhs = as->lhs();\n \tExpression* rhs = as->rhs();\n \n+\t// Keep track of variables whose values do not escape.\n+\tVar_expression* lhsve = lhs->var_expression();\n+\tif (lhsve != NULL && lhsve->type()->points_to() != NULL)\n+\t  {\n+\t    Named_object* no = lhsve->named_object();\n+\t    if (this->gogo_->is_nonwb_pointer(rhs, &this->nonwb_pointers_))\n+\t      this->nonwb_pointers_.insert(no);\n+\t    else\n+\t      this->nonwb_pointers_.erase(no);\n+\t  }\n+\n+\tif (as->omit_write_barrier())\n+\t  break;\n+\n \t// We may need to emit a write barrier for the assignment.\n \n-\tif (!this->gogo_->assign_needs_write_barrier(lhs))\n+\tif (!this->gogo_->assign_needs_write_barrier(lhs,\n+\t\t\t\t\t\t     &this->nonwb_pointers_))\n \t  break;\n \n \t// Change the assignment to use a write barrier.\n@@ -667,9 +708,13 @@ Gogo::write_barrier_variable()\n }\n \n // Return whether an assignment that sets LHS needs a write barrier.\n+// NONWB_POINTERS is a set of variables that point to values that do\n+// not need write barriers.\n \n bool\n-Gogo::assign_needs_write_barrier(Expression* lhs)\n+Gogo::assign_needs_write_barrier(\n+    Expression* lhs,\n+    Unordered_set(const Named_object*)* nonwb_pointers)\n {\n   // Nothing to do if the variable does not contain any pointers.\n   if (!lhs->type()->has_pointer())\n@@ -738,22 +783,10 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n   // Nothing to do for an assignment to *(convert(&x)) where\n   // x is local variable or a temporary variable.\n   Unary_expression* ue = lhs->unary_expression();\n-  if (ue != NULL && ue->op() == OPERATOR_MULT)\n-    {\n-      Expression* expr = ue->operand();\n-      while (true)\n-        {\n-          if (expr->conversion_expression() != NULL)\n-            expr = expr->conversion_expression()->expr();\n-          else if (expr->unsafe_conversion_expression() != NULL)\n-            expr = expr->unsafe_conversion_expression()->expr();\n-          else\n-            break;\n-        }\n-      ue = expr->unary_expression();\n-      if (ue != NULL && ue->op() == OPERATOR_AND)\n-        return this->assign_needs_write_barrier(ue->operand());\n-    }\n+  if (ue != NULL\n+      && ue->op() == OPERATOR_MULT\n+      && this->is_nonwb_pointer(ue->operand(), nonwb_pointers))\n+    return false;\n \n   // For a struct assignment, we don't need a write barrier if all the\n   // pointer types can not be in the heap.\n@@ -784,6 +817,40 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n   return true;\n }\n \n+// Return whether EXPR is the address of a variable that can be set\n+// without a write barrier.  That is, if this returns true, then an\n+// assignment to *EXPR does not require a write barrier.\n+// NONWB_POINTERS is a set of variables that point to values that do\n+// not need write barriers.\n+\n+bool\n+Gogo::is_nonwb_pointer(Expression* expr,\n+\t\t       Unordered_set(const Named_object*)* nonwb_pointers)\n+{\n+  while (true)\n+    {\n+      if (expr->conversion_expression() != NULL)\n+\texpr = expr->conversion_expression()->expr();\n+      else if (expr->unsafe_conversion_expression() != NULL)\n+\texpr = expr->unsafe_conversion_expression()->expr();\n+      else\n+\tbreak;\n+    }\n+\n+  Var_expression* ve = expr->var_expression();\n+  if (ve != NULL\n+      && nonwb_pointers != NULL\n+      && nonwb_pointers->find(ve->named_object()) != nonwb_pointers->end())\n+    return true;\n+\n+  Unary_expression* ue = expr->unary_expression();\n+  if (ue == NULL || ue->op() != OPERATOR_AND)\n+    return false;\n+  if (this->assign_needs_write_barrier(ue->operand(), nonwb_pointers))\n+    return false;\n+  return true;\n+}\n+\n // Return a statement that sets LHS to RHS using a write barrier.\n // ENCLOSING is the enclosing block.\n "}, {"sha": "14d546d6d33c7fb5b42380b0a280a360f6feaa69", "filename": "libgo/go/runtime/print.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae361ae458d4056d6c36fa42f1775c417457b10/libgo%2Fgo%2Fruntime%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae361ae458d4056d6c36fa42f1775c417457b10/libgo%2Fgo%2Fruntime%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fprint.go?ref=6ae361ae458d4056d6c36fa42f1775c417457b10", "patch": "@@ -35,6 +35,7 @@ import (\n // should use printhex instead of printuint (decimal).\n type hex uint64\n \n+//go:nowritebarrier\n func bytes(s string) (ret []byte) {\n \trp := (*slice)(unsafe.Pointer(&ret))\n \tsp := stringStructOf(&s)"}]}