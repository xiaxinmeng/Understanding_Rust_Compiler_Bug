{"sha": "fb47dc28d2d38f56af65e9f244af8870bd568b0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0N2RjMjhkMmQzOGY1NmFmNjVlOWYyNDRhZjg4NzBiZDU2OGIwYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T23:22:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-02-03T23:22:18Z"}, "message": "Rewrite convulated code to avoid adding r0.\n\n2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (reg_to_non_prefixed): Add forward\n\treference.\n\t(hard_reg_and_mode_to_addr_mask): Delete.\n\t(rs6000_adjust_vec_address): If the original vector address\n\twas REG+REG or REG+OFFSET and the element is not zero, do the add\n\tof the elements in the original address before adding the offset\n\tfor the vector element.  Use address_to_insn_form to validate the\n\taddress using the register being loaded, rather than guessing\n\twhether the address is a DS-FORM or DQ-FORM address.", "tree": {"sha": "3e22fbe2ecb20967b7861997e22c3b67ac37fd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e22fbe2ecb20967b7861997e22c3b67ac37fd52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb47dc28d2d38f56af65e9f244af8870bd568b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb47dc28d2d38f56af65e9f244af8870bd568b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb47dc28d2d38f56af65e9f244af8870bd568b0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb47dc28d2d38f56af65e9f244af8870bd568b0b/comments", "author": null, "committer": null, "parents": [{"sha": "e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f3e075282bda5c5df03e01932cf8d8e9b55cfc"}], "stats": {"total": 136, "additions": 41, "deletions": 95}, "files": [{"sha": "927968f7169b81b7cc0516c904c13ac81398f3b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb47dc28d2d38f56af65e9f244af8870bd568b0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb47dc28d2d38f56af65e9f244af8870bd568b0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb47dc28d2d38f56af65e9f244af8870bd568b0b", "patch": "@@ -1,3 +1,15 @@\n+2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (reg_to_non_prefixed): Add forward\n+\treference.\n+\t(hard_reg_and_mode_to_addr_mask): Delete.\n+\t(rs6000_adjust_vec_address): If the original vector address\n+\twas REG+REG or REG+OFFSET and the element is not zero, do the add\n+\tof the elements in the original address before adding the offset\n+\tfor the vector element.  Use address_to_insn_form to validate the\n+\taddress using the register being loaded, rather than guessing\n+\twhether the address is a DS-FORM or DQ-FORM address.\n+\n 2020-02-03  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/rs6000.c (get_vector_offset): New helper function"}, {"sha": "0cd9cd174a59e13a64acf465c1b235a4a7b09a23", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 95, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb47dc28d2d38f56af65e9f244af8870bd568b0b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb47dc28d2d38f56af65e9f244af8870bd568b0b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fb47dc28d2d38f56af65e9f244af8870bd568b0b", "patch": "@@ -1169,6 +1169,7 @@ static bool rs6000_secondary_reload_move (enum rs6000_reg_type,\n \t\t\t\t\t  machine_mode,\n \t\t\t\t\t  secondary_reload_info *,\n \t\t\t\t\t  bool);\n+static enum non_prefixed_form reg_to_non_prefixed (rtx reg, machine_mode mode);\n rtl_opt_pass *make_pass_analyze_swaps (gcc::context*);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n@@ -6726,30 +6727,6 @@ rs6000_expand_vector_extract (rtx target, rtx vec, rtx elt)\n     }\n }\n \n-/* Helper function to return an address mask based on a physical register.  */\n-\n-static addr_mask_type\n-hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n-{\n-  unsigned int r = reg_or_subregno (reg);\n-  addr_mask_type addr_mask;\n-\n-  gcc_assert (HARD_REGISTER_NUM_P (r));\n-  if (INT_REGNO_P (r))\n-    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_GPR];\n-\n-  else if (FP_REGNO_P (r))\n-    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_FPR];\n-\n-  else if (ALTIVEC_REGNO_P (r))\n-    addr_mask = reg_addr[mode].addr_mask[RELOAD_REG_VMX];\n-\n-  else\n-    gcc_unreachable ();\n-\n-  return addr_mask;\n-}\n-\n /* Return the offset within a memory object (MEM) of a vector type to a given\n    element within the vector (ELEMENT) with an element size (SCALAR_SIZE).  If\n    the element is constant, we return a constant integer.\n@@ -6809,7 +6786,6 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);\n   rtx addr = XEXP (mem, 0);\n   rtx new_addr;\n-  bool valid_addr_p;\n \n   gcc_assert (!reg_mentioned_p (base_tmp, addr));\n   gcc_assert (!reg_mentioned_p (base_tmp, element));\n@@ -6837,68 +6813,34 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n     {\n       rtx op0 = XEXP (addr, 0);\n       rtx op1 = XEXP (addr, 1);\n-      rtx insn;\n \n       gcc_assert (REG_P (op0) || SUBREG_P (op0));\n       if (CONST_INT_P (op1) && CONST_INT_P (element_offset))\n \t{\n+\t  /* op0 should never be r0, because r0+offset is not valid.  But it\n+\t     doesn't hurt to make sure it is not r0.  */\n+\t  gcc_assert (reg_or_subregno (op0) != 0);\n+\n+\t  /* D-FORM address with constant element number.  */\n \t  HOST_WIDE_INT offset = INTVAL (op1) + INTVAL (element_offset);\n \t  rtx offset_rtx = GEN_INT (offset);\n-\n-\t  /* 16-bit offset.  */\n-\t  if (SIGNED_INTEGER_16BIT_P (offset)\n-\t      && (scalar_size < 8 || (offset & 0x3) == 0))\n-\t    new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n-\n-\t  /* 34-bit offset if we have prefixed addresses.  */\n-\t  else if (TARGET_PREFIXED_ADDR && SIGNED_INTEGER_34BIT_P (offset))\n-\t    new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n-\n-\t  else\n-\t    {\n-\t      /* Offset overflowed, move offset to the temporary (which will\n-\t\t likely be split), and do X-FORM addressing.  */\n-\t      emit_move_insn (base_tmp, offset_rtx);\n-\t      new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n-\t    }\n+\t  new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n \t}\n       else\n \t{\n-\t  bool op1_reg_p = (REG_P (op1) || SUBREG_P (op1));\n-\t  bool ele_reg_p = (REG_P (element_offset) || SUBREG_P (element_offset));\n-\n-\t  /* Note, ADDI requires the register being added to be a base\n-\t     register.  If the register was R0, load it up into the temporary\n-\t     and do the add.  */\n-\t  if (op1_reg_p\n-\t      && (ele_reg_p || reg_or_subregno (op1) != FIRST_GPR_REGNO))\n-\t    {\n-\t      insn = gen_add3_insn (base_tmp, op1, element_offset);\n-\t      gcc_assert (insn != NULL_RTX);\n-\t      emit_insn (insn);\n-\t    }\n-\n-\t  else if (ele_reg_p\n-\t\t   && reg_or_subregno (element_offset) != FIRST_GPR_REGNO)\n-\t    {\n-\t      insn = gen_add3_insn (base_tmp, element_offset, op1);\n-\t      gcc_assert (insn != NULL_RTX);\n-\t      emit_insn (insn);\n-\t    }\n+\t  /* If we don't have a D-FORM address with a constant element number,\n+\t     add the two elements in the current address.  Then add the offset.\n \n-\t  /* Make sure we don't overwrite the temporary if the element being\n-\t     extracted is variable, and we've put the offset into base_tmp\n-\t     previously.  */\n-\t  else if (reg_mentioned_p (base_tmp, element_offset))\n-\t    emit_insn (gen_add2_insn (base_tmp, op1));\n-\n-\t  else\n-\t    {\n-\t      emit_move_insn (base_tmp, op1);\n-\t      emit_insn (gen_add2_insn (base_tmp, element_offset));\n-\t    }\n-\n-\t  new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n+\t     Previously, we tried to add the offset to OP1 and change the\n+\t     address to an X-FORM format adding OP0 and BASE_TMP, but it became\n+\t     complicated because we had to verify that op1 was not GPR0 and we\n+\t     had a constant element offset (due to the way ADDI is defined).\n+\t     By doing the add of OP0 and OP1 first, and then adding in the\n+\t     offset, it has the benefit that if D-FORM instructions are\n+\t     allowed, the offset is part of the memory access to the vector\n+\t     element. */\n+\t  emit_insn (gen_rtx_SET (base_tmp, gen_rtx_PLUS (Pmode, op0, op1)));\n+\t  new_addr = gen_rtx_PLUS (Pmode, base_tmp, element_offset);\n \t}\n     }\n \n@@ -6908,27 +6850,19 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n       new_addr = gen_rtx_PLUS (Pmode, base_tmp, element_offset);\n     }\n \n-  /* If we have a PLUS, we need to see whether the particular register class\n-     allows for D-FORM or X-FORM addressing.  */\n-  if (GET_CODE (new_addr) == PLUS)\n-    {\n-      rtx op1 = XEXP (new_addr, 1);\n-      addr_mask_type addr_mask\n-\t= hard_reg_and_mode_to_addr_mask (scalar_reg, scalar_mode);\n+    /* If the address isn't valid, move the address into the temporary base\n+       register.  Some reasons it could not be valid include:\n \n-      if (REG_P (op1) || SUBREG_P (op1))\n-\tvalid_addr_p = (addr_mask & RELOAD_REG_INDEXED) != 0;\n-      else\n-\tvalid_addr_p = (addr_mask & RELOAD_REG_OFFSET) != 0;\n-    }\n+       The address offset overflowed the 16 or 34 bit offset size;\n+       We need to use a DS-FORM load, and the bottom 2 bits are non-zero;\n+       We need to use a DQ-FORM load, and the bottom 4 bits are non-zero;\n+       Only X_FORM loads can be done, and the address is D_FORM.  */\n \n-  else if (REG_P (new_addr) || SUBREG_P (new_addr))\n-    valid_addr_p = true;\n-\n-  else\n-    valid_addr_p = false;\n+  enum insn_form iform\n+    = address_to_insn_form (new_addr, scalar_mode,\n+\t\t\t    reg_to_non_prefixed (scalar_reg, scalar_mode));\n \n-  if (!valid_addr_p)\n+  if (iform == INSN_FORM_BAD)\n     {\n       emit_move_insn (base_tmp, new_addr);\n       new_addr = base_tmp;"}]}