{"sha": "07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlNGQ5NGVlYThlNWRkZDNkZDk3ODY1MzQwYzgwMWYwZDg1NzBjYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-07-06T04:08:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-06T04:08:07Z"}, "message": "h8300-proto.h: Fix formatting.\n\n        * h8300-proto.h: Fix formatting.\n        * h8300.c: Likewise.\n        * h8300.h: Likewise.\n\nFrom-SVN: r34882", "tree": {"sha": "a62c61392d3ff378c0f9b294543ef9e25fb7dbbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a62c61392d3ff378c0f9b294543ef9e25fb7dbbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/comments", "author": null, "committer": null, "parents": [{"sha": "768ff52f7e510a5bbbf58847608d0953359c2d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768ff52f7e510a5bbbf58847608d0953359c2d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768ff52f7e510a5bbbf58847608d0953359c2d95"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "4db578b280f31df868b577a6b6df185b84c128f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "patch": "@@ -1,3 +1,9 @@\n+2000-07-05  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* h8300-proto.h: Fix formatting.\n+\t* h8300.c: Likewise.\n+\t* h8300.h: Likewise.\n+\n 2000-07-05  Jim Wilson  <wilson@cygnus.com>\n \n \t* config/ia64/ia64.h (HARD_REGNO_MODE_OK): If FR_REGNO_P, disallow"}, {"sha": "d5d460b03c4f192f9dd0c1b5d62fe7b858142cb4", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #ifdef RTX_CODE\n extern const char *emit_a_shift PARAMS ((rtx, rtx *));\n extern const char *output_adds_subs PARAMS ((rtx *));\n-extern const char * output_simode_bld PARAMS ((int, int, rtx[]));\n+extern const char *output_simode_bld PARAMS ((int, int, rtx[]));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern const char *byte_reg PARAMS ((rtx, int));\n extern int const_costs PARAMS ((rtx, enum rtx_code));"}, {"sha": "4eb304ee010e476af9dc7bcbc1edda56c66eaa34", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "patch": "@@ -67,23 +67,23 @@ int monitor;\n int pragma_saveall;\n \n static const char *const names_big[] =\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"};\n+{ \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\" };\n \n static const char *const names_extended[] =\n-{\"er0\", \"er1\", \"er2\", \"er3\", \"er4\", \"er5\", \"er6\", \"er7\"};\n+{ \"er0\", \"er1\", \"er2\", \"er3\", \"er4\", \"er5\", \"er6\", \"er7\" };\n \n static const char *const names_upper_extended[] =\n-{\"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\"};\n+{ \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\" };\n \n /* Points to one of the above.  */\n /* ??? The above could be put in an array indexed by CPU_TYPE.  */\n const char * const *h8_reg_names;\n \n /* Various operations needed by the following, indexed by CPU_TYPE.  */\n \n-static const char *const h8_push_ops[2] = {\"push\", \"push.l\"};\n-static const char *const h8_pop_ops[2] = {\"pop\", \"pop.l\"};\n-static const char *const h8_mov_ops[2] = {\"mov.w\", \"mov.l\"};\n+static const char *const h8_push_ops[2] = { \"push\", \"push.l\" };\n+static const char *const h8_pop_ops[2] = { \"pop\", \"pop.l\" };\n+static const char *const h8_mov_ops[2] = { \"mov.w\", \"mov.l\" };\n \n const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n \n@@ -124,7 +124,7 @@ byte_reg (x, b)\n \n #define WORD_REG_USED(regno)\t\t\t\t\t\\\n   (regno < 7\t\t\t\t\t\t\t\\\n-   /* No need to save registers if this function will not return.*/\\\n+   /* No need to save registers if this function will not return.  */\\\n    && ! TREE_THIS_VOLATILE (current_function_decl)\t\t\\\n    && (pragma_saveall\t\t\t\t\t\t\\\n        /* Save any call saved register that was used.  */\t\\\n@@ -153,7 +153,7 @@ dosize (file, op, size)\n      with an immediate value.   */\n   if (size > 4 && size <= 8 && (TARGET_H8300H || TARGET_H8300S))\n     {\n-      /* Crank the size down to <= 4 */\n+      /* Crank the size down to <= 4.  */\n       fprintf (file, \"\\t%ss\\t#%d,sp\\n\", op, 4);\n       size -= 4;\n     }\n@@ -210,9 +210,9 @@ dosize (file, op, size)\n \n /* Output assembly language code for the function prologue.  */\n static int push_order[FIRST_PSEUDO_REGISTER] =\n-{0, 1, 2, 3, 4, 5, 6, -1, -1, -1};\n+{ 0, 1, 2, 3, 4, 5, 6, -1, -1, -1 };\n static int pop_order[FIRST_PSEUDO_REGISTER] =\n-{6, 5, 4, 3, 2, 1, 0, -1, -1, -1};\n+{ 6, 5, 4, 3, 2, 1, 0, -1, -1, -1 };\n \n /* This is what the stack looks like after the prolog of \n    a function with a frame has been set up:\n@@ -281,18 +281,18 @@ function_prologue (file, size)\n \n   if (frame_pointer_needed)\n     {\n-      /* Push fp */\n+      /* Push fp.  */\n       fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op,\n \t       h8_reg_names[FRAME_POINTER_REGNUM]);\n       fprintf (file, \"\\t%s\\t%s,%s\\n\", h8_mov_op,\n \t       h8_reg_names[STACK_POINTER_REGNUM],\n \t       h8_reg_names[FRAME_POINTER_REGNUM]);\n     }\n \n-  /* leave room for locals */\n+  /* Leave room for locals.  */\n   dosize (file, \"sub\", fsize);\n \n-  /* Push the rest of the registers */\n+  /* Push the rest of the registers.  */\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n     {\n       int regno = push_order[idx];\n@@ -323,7 +323,7 @@ function_prologue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\", \n+\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n \t\t\t       h8_reg_names[regno],\n \t\t\t       h8_reg_names[fourth_regno]);\n \t\t      idx += 3;\n@@ -344,7 +344,7 @@ function_prologue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\", \n+\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n \t\t\t       h8_reg_names[regno],\n \t\t\t       h8_reg_names[third_regno]);\n \t\t      idx += 2;\n@@ -360,7 +360,7 @@ function_prologue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\", \n+\t\t      fprintf (file, \"\\tstm.l %s-%s,@-sp\\n\",\n \t\t\t       h8_reg_names[regno],\n \t\t\t       h8_reg_names[second_regno]);\n \t\t      idx += 1;\n@@ -393,18 +393,18 @@ function_epilogue (file, size)\n       goto out;\n     }\n \n-  /* monitor epilogues are the same as interrupt function epilogues.\n+  /* Monitor epilogues are the same as interrupt function epilogues.\n      Just make a note that we're in an monitor epilogue.  */\n   if (monitor)\n-    fprintf(file, \";monitor epilogue\\n\");\n+    fprintf (file, \";monitor epilogue\\n\");\n \n   /* If the last insn was a BARRIER, we don't have to write any code.  */\n   if (GET_CODE (insn) == NOTE)\n     insn = prev_nonnote_insn (insn);\n   if (insn && GET_CODE (insn) == BARRIER)\n     goto out;\n \n-  /* Pop the saved registers. */\n+  /* Pop the saved registers.  */\n   for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n     {\n       int regno = pop_order[idx];\n@@ -435,7 +435,7 @@ function_epilogue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\", \n+\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n \t\t\t       h8_reg_names[fourth_regno],\n \t\t\t       h8_reg_names[regno]);\n \t\t      idx += 3;\n@@ -456,7 +456,7 @@ function_epilogue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\", \n+\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n \t\t\t       h8_reg_names[third_regno],\n \t\t\t       h8_reg_names[regno]);\n \t\t      idx += 2;\n@@ -472,7 +472,7 @@ function_epilogue (file, size)\n \t\t      && (!frame_pointer_needed\n \t\t\t  || second_regno != FRAME_POINTER_REGNUM))\n \t\t    {\n-\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\", \n+\t\t      fprintf (file, \"\\tldm.l @sp+,%s-%s\\n\",\n \t\t\t       h8_reg_names[second_regno],\n \t\t\t       h8_reg_names[regno]);\n \t\t      idx += 1;\n@@ -484,12 +484,13 @@ function_epilogue (file, size)\n \t}\n     }\n \n-  /* deallocate locals */\n+  /* Deallocate locals.  */\n   dosize (file, \"add\", fsize);\n \n-  /* pop frame pointer if we had one. */\n+  /* Pop frame pointer if we had one.  */\n   if (frame_pointer_needed)\n-    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[FRAME_POINTER_REGNUM]);\n+    fprintf (file, \"\\t%s\\t%s\\n\",\n+\t     h8_pop_op, h8_reg_names[FRAME_POINTER_REGNUM]);\n \n   /* If this is a monitor function, there is one register still left on\n      the stack.  */\n@@ -501,7 +502,7 @@ function_epilogue (file, size)\n   else\n     fprintf (file, \"\\trts\\n\");\n \n-out:\n+ out:\n   interrupt_handler = 0;\n   os_task = 0;\n   monitor = 0;\n@@ -789,15 +790,11 @@ bit_operand (op, mode)\n   if (GET_CODE (op) == SUBREG)\n     return 1;\n   if (!rtx_equal_function_value_matters)\n-    {\n-      /* We're building rtl */\n-      return GET_CODE (op) == MEM;\n-    }\n+    /* We're building rtl.  */\n+    return GET_CODE (op) == MEM;\n   else\n-    {\n-      return (GET_CODE (op) == MEM\n-\t      && EXTRA_CONSTRAINT (op, 'U'));\n-    }\n+    return (GET_CODE (op) == MEM\n+\t    && EXTRA_CONSTRAINT (op, 'U'));\n }\n \n int\n@@ -1395,11 +1392,11 @@ print_operand (file, x, code)\n \t     area), then specify a symbolic address as \"foo:8\",\n \t     otherwise if operand is still in eight bit section, use\n \t     \"foo:16\".  */\n- \t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t      && SYMBOL_REF_FLAG (XEXP (x, 0)))\n \t    fprintf (file, (code == 'R' ? \":8\" : \":16\"));\n \t  else if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n-\t      && TINY_DATA_NAME_P (XSTR (XEXP (x, 0), 0)))\n+\t\t   && TINY_DATA_NAME_P (XSTR (XEXP (x, 0), 0)))\n \t    fprintf (file, \":16\");\n \t  break;\n \n@@ -1476,7 +1473,7 @@ print_operand_address (file, addr)\n \tif (TARGET_H8300)\n \t  n = (int) (short) n;\n \tif (n < 0)\n-\t  /* ??? Why the special case for -ve values? */\n+\t  /* ??? Why the special case for -ve values?  */\n \t  fprintf (file, \"-%d\", -n);\n \telse\n \t  fprintf (file, \"%d\", n);\n@@ -1540,8 +1537,8 @@ do_movsi (operands)\n }\n \n /* Function for INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET).\n-   Define the offset between two registers, one to be eliminated, and the other\n-   its replacement, at the start of a routine.  */\n+   Define the offset between two registers, one to be eliminated, and\n+   the other its replacement, at the start of a routine.  */\n \n int\n initial_offset (from, to)\n@@ -1622,7 +1619,7 @@ notice_update_cc (body, insn)\n     }\n }\n \n-/* Recognize valid operators for bit instructions */\n+/* Recognize valid operators for bit instructions.  */\n \n int\n bit_operator (x, mode)\n@@ -1668,7 +1665,6 @@ bit_operator (x, mode)\n \n      * There other oddballs.  Not worth explaining.  SHIFT_SPECIAL\n \n-\n    Here are some thoughts on what the absolutely positively best code is.\n    \"Best\" here means some rational trade-off between code size and speed,\n    where speed is more preferred but not at the expense of generating 20 insns.\n@@ -1725,7 +1721,6 @@ bit_operator (x, mode)\n    7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n             ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n-\n    H8/300H HImode shifts\n    1-4    - do them inline\n    5-6    - loop\n@@ -1834,8 +1829,8 @@ expand_a_shift (mode, code, operands)\n {\n   emit_move_insn (operands[0], operands[1]);\n \n-  /* need a loop to get all the bits we want  - we generate the\n-     code at emit time, but need to allocate a scratch reg now  */\n+  /* Need a loop to get all the bits we want  - we generate the\n+     code at emit time, but need to allocate a scratch reg now.  */\n \n   emit_insn (gen_rtx_PARALLEL\n \t     (VOIDmode,\n@@ -1895,8 +1890,7 @@ struct shift_insn\n /* Assembler instruction shift table.\n \n    These tables are used to look up the basic shifts.\n-   They are indexed by cpu, shift_type, and mode.\n-*/\n+   They are indexed by cpu, shift_type, and mode.  */\n \n static const struct shift_insn shift_one[2][3][3] =\n {\n@@ -2509,7 +2503,7 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p,\n \t    {\n \t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n \t      if (TARGET_H8300S)\n-\t        *assembler2_p = rotate_two[shift_type][shift_mode];\n+\t\t*assembler2_p = rotate_two[shift_type][shift_mode];\n \t      else\n \t\t*assembler2_p = NULL;\n \t      *cc_valid_p = 0;\n@@ -2541,10 +2535,10 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p,\n \t      else\n \t\t{\n \t\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n-\t      if (TARGET_H8300S)\n-\t        *assembler2_p = rotate_two[shift_type][shift_mode];\n-\t      else\n-\t\t*assembler2_p = NULL;\n+\t\t  if (TARGET_H8300S)\n+\t\t    *assembler2_p = rotate_two[shift_type][shift_mode];\n+\t\t  else\n+\t\t    *assembler2_p = NULL;\n \t\t  *cc_valid_p = 0;\n \t\t  return SHIFT_ROT_AND;\n \t\t}\n@@ -2610,7 +2604,7 @@ emit_a_shift (insn, operands)\n \n   if (GET_CODE (operands[2]) != CONST_INT)\n     {\n-      /* Indexing by reg, so have to loop and test at top */\n+      /* Indexing by reg, so have to loop and test at top.  */\n       output_asm_insn (\"mov.b\t%X2,%X4\", operands);\n       fprintf (asm_out_file, \"\\tble\t.Lle%d\\n\", loopend_lab);\n \n@@ -2961,7 +2955,7 @@ h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n       DECL_SECTION_NAME (decl) = build_string (6, \".tiny\");\n       return 1;\n     }\n-      \n+\n   return 0;\n }\n \n@@ -3105,8 +3099,8 @@ h8300_adjust_insn_length (insn, length)\n   if (GET_CODE (pat) == PARALLEL\n       && GET_CODE (XVECEXP (pat, 0, 0)) == SET\n       && (GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == ASHIFTRT\n-          || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == LSHIFTRT\n-          || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == ASHIFT))\n+\t  || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == LSHIFTRT\n+\t  || GET_CODE (SET_SRC (XVECEXP (pat, 0, 0))) == ASHIFT))\n     {\n       rtx src = SET_SRC (XVECEXP (pat, 0, 0));\n       enum machine_mode mode = GET_MODE (src);\n@@ -3118,7 +3112,7 @@ h8300_adjust_insn_length (insn, length)\n       shift = INTVAL (XEXP (src, 1));\n       /* According to ANSI, negative shift is undefined.  It is\n          considered to be zero in this case (see function\n-         emit_a_shift above). */\n+         emit_a_shift above).  */\n       if (shift < 0)\n \tshift = 0;\n \n@@ -3144,6 +3138,6 @@ h8300_adjust_insn_length (insn, length)\n \n       /* XXX ??? Could check for more shift/rotate cases here.  */\n     }\n-    \n+\n   return 0;\n }"}, {"sha": "5d35d27be77df38a2b8deff37bd861eca4aa2ce9", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07e4d94eea8e5ddd3dd97865340c801f0d8570ca/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=07e4d94eea8e5ddd3dd97865340c801f0d8570ca", "patch": "@@ -31,7 +31,7 @@ extern int cpu_type;\n \n /* Various globals defined in h8300.c.  */\n \n-extern const char *h8_push_op,*h8_pop_op,*h8_mov_op;\n+extern const char *h8_push_op, *h8_pop_op, *h8_mov_op;\n extern const char * const *h8_reg_names;\n \n /* Names to predefine in the preprocessor for this target machine.  */\n@@ -157,7 +157,7 @@ do {\t\t\t\t\\\n    Calls through a register are cheaper than calls to named\n    functions; however, the register pressure this causes makes\n    CSEing of function addresses generally a lose.  */\n-#define NO_FUNCTION_CSE \n+#define NO_FUNCTION_CSE\n \f\n /* Target machine storage layout */\n \n@@ -177,7 +177,7 @@ do {\t\t\t\t\\\n /* Define this if most significant word of a multiword number is lowest\n    numbered.  \n    This is true on an H8/300 (actually we can make it up, but we choose to\n-   be consistent).  */ \n+   be consistent).  */\n #define WORDS_BIG_ENDIAN 1\n \n /* Number of bits in an addressable storage unit */\n@@ -354,7 +354,7 @@ do {\t\t\t\t\\\n \n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n-   \n+\n enum reg_class {\n   NO_REGS, GENERAL_REGS, MAC_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n@@ -604,7 +604,11 @@ enum reg_class {\n    function if any.  */\n \n #define CUMULATIVE_ARGS struct cum_arg\n-struct cum_arg { int nbytes; struct rtx_def * libcall; };\n+struct cum_arg\n+{\n+  int nbytes;\n+  struct rtx_def *libcall;\n+};\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -761,7 +765,7 @@ struct cum_arg { int nbytes; struct rtx_def * libcall; };\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n- \n+\n #define REGNO_OK_FOR_INDEX_P(regno) 0\n \n #define REGNO_OK_FOR_BASE_P(regno) \\\n@@ -840,7 +844,7 @@ struct cum_arg { int nbytes; struct rtx_def * libcall; };\n         && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF \\\n         && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT) \\\n         && (TARGET_H8300S || SYMBOL_REF_FLAG (XEXP (XEXP (OP, 0), 0)))))\n- \n+\n #define EXTRA_CONSTRAINT(OP, C) \\\n  ((C) == 'U' ? OK_FOR_U (OP) : 0)\n \f\n@@ -857,7 +861,7 @@ struct cum_arg { int nbytes; struct rtx_def * libcall; };\n    REG, REG+CONSTANT_ADDRESS or CONSTANT_ADDRESS.  */\n \n /* Accept either REG or SUBREG where a register is valid.  */\n-  \n+\n #define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\\\n   ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n    || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\\\n@@ -1002,7 +1006,7 @@ h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n   case ROTATE:\t\t\\\n   case ROTATERT:\t\\\n     if (GET_MODE (RTX) == HImode) return 2; \\\n-    return 8; \n+    return 8;\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n \n@@ -1073,7 +1077,7 @@ h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\\\n-ctors_section() \t\t\t\t\t\t\\\n+ctors_section () \t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   if (in_section != in_ctors)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -1083,7 +1087,7 @@ ctors_section() \t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\\\n-dtors_section() \t\t\t\t\t\t\\\n+dtors_section () \t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   if (in_section != in_dtors)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -1093,7 +1097,7 @@ dtors_section() \t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\\\n-readonly_data() \t\t\t\t\t\t\\\n+readonly_data () \t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   if (in_section != in_readonly_data)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -1102,8 +1106,6 @@ readonly_data() \t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n-\n-\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n   do { ctors_section();\t\t\t\t\\\n        fprintf(FILE, \"\\t%s\\t_%s\\n\", ASM_WORD_OP, NAME); } while (0)\n@@ -1112,7 +1114,7 @@ readonly_data() \t\t\t\t\t\t\\\n   do { dtors_section();\t\t\t\t\\\n        fprintf(FILE, \"\\t%s\\t_%s\\n\", ASM_WORD_OP, NAME); } while (0)\n \n-#undef DO_GLOBAL_CTORS_BODY                     \n+#undef DO_GLOBAL_CTORS_BODY\n #define DO_GLOBAL_CTORS_BODY\t\t\t\\\n {\t\t\t\t\t\t\\\n   typedef (*pfunc)();\t\t\t\t\\\n@@ -1123,9 +1125,9 @@ readonly_data() \t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       (*--p)();\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\n+}\n \n-#undef DO_GLOBAL_DTORS_BODY\t\t\t \n+#undef DO_GLOBAL_DTORS_BODY\n #define DO_GLOBAL_DTORS_BODY                    \\\n {\t\t\t\t\t\t\\\n   typedef (*pfunc)();\t\t\t\t\\\n@@ -1136,7 +1138,7 @@ readonly_data() \t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       (*p)();\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t \n+}\n \n #define TINY_DATA_NAME_P(NAME) (*(NAME) == '&')\n \n@@ -1210,7 +1212,7 @@ readonly_data() \t\t\t\t\t\t\\\n #define ASM_OUTPUT_LABELREF(FILE,NAME)  \\\n   asm_fprintf ((FILE), \"%U%s\", (NAME) + (TINY_DATA_NAME_P (NAME) ? 1 : 0))\n \n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\n \n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n@@ -1251,7 +1253,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-\n /* This is how to output an assembler line defining a `float' constant.  */\n #define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n do { char dstr[30];\t\t\t\t\t\\\n@@ -1424,4 +1425,3 @@ do { char dstr[30];\t\t\t\t\t\\\n   } while (0)\n \n #define MOVE_RATIO 3\n-"}]}