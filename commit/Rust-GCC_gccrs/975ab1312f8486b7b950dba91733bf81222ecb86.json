{"sha": "975ab1312f8486b7b950dba91733bf81222ecb86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc1YWIxMzEyZjg0ODZiN2I5NTBkYmE5MTczM2JmODEyMjJlY2I4Ng==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-09T09:09:51Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-09T09:09:51Z"}, "message": "c4x.h: Tidy up comments.\n\n\t* config/c4x.h: Tidy up comments.\n\t* config/c4x.c: Likewise.\n\nFrom-SVN: r31292", "tree": {"sha": "ed52e9a2aa220b54a71bf4dbd6e13adba14c13e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed52e9a2aa220b54a71bf4dbd6e13adba14c13e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/975ab1312f8486b7b950dba91733bf81222ecb86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975ab1312f8486b7b950dba91733bf81222ecb86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/975ab1312f8486b7b950dba91733bf81222ecb86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975ab1312f8486b7b950dba91733bf81222ecb86/comments", "author": null, "committer": null, "parents": [{"sha": "e746974d67e718d074d397ab9a7671a30c6012de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e746974d67e718d074d397ab9a7671a30c6012de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e746974d67e718d074d397ab9a7671a30c6012de"}], "stats": {"total": 549, "additions": 285, "deletions": 264}, "files": [{"sha": "8a39bcc9daadf14fd9f1ef7c3ce45fe7069036ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=975ab1312f8486b7b950dba91733bf81222ecb86", "patch": "@@ -1,3 +1,8 @@\n+2000-01-09  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x.h: Tidy up comments.\n+\t* config/c4x.c: Likewise.\n+\n Sun Jan  9 01:02:55 EST 2000  John Wehle  (john@feith.com)\n \n \t* fold-const.c (lshift_double, rshift_double): Handle"}, {"sha": "2bbb757e65daf5045ec9fcaeab5dda611f0779e5", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 151, "deletions": 137, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=975ab1312f8486b7b950dba91733bf81222ecb86", "patch": "@@ -57,76 +57,76 @@ static char *float_reg_names[] = FLOAT_REGISTER_NAMES;\n \n enum reg_class c4x_regclass_map[FIRST_PSEUDO_REGISTER] =\n {\n-                                /* Reg          Modes           Saved  */\n-  R0R1_REGS,\t\t\t/* R0           QI, QF, HF      No  */\n-  R0R1_REGS,\t\t\t/* R1           QI, QF, HF      No  */\n-  R2R3_REGS,\t\t\t/* R2           QI, QF, HF      No  */\n-  R2R3_REGS,\t\t\t/* R3           QI, QF, HF      No  */\n-  EXT_LOW_REGS,\t\t\t/* R4           QI, QF, HF      QI  */\n-  EXT_LOW_REGS,\t\t\t/* R5           QI, QF, HF      QI  */\n-  EXT_LOW_REGS,\t\t\t/* R6           QI, QF, HF      QF  */\n-  EXT_LOW_REGS,\t\t\t/* R7           QI, QF, HF      QF  */\n-  ADDR_REGS,\t\t\t/* AR0          QI              No  */\n-  ADDR_REGS,\t\t\t/* AR1          QI              No  */\n-  ADDR_REGS,\t\t\t/* AR2          QI              No  */\n-  ADDR_REGS,\t\t\t/* AR3          QI              QI  */\n-  ADDR_REGS,\t\t\t/* AR4          QI              QI  */\n-  ADDR_REGS,\t\t\t/* AR5          QI              QI  */\n-  ADDR_REGS,\t\t\t/* AR6          QI              QI  */\n-  ADDR_REGS,\t\t\t/* AR7          QI              QI  */\n-  DP_REG,\t\t\t/* DP           QI              No  */\n-  INDEX_REGS,\t\t\t/* IR0          QI              No  */\n-  INDEX_REGS,\t\t\t/* IR1          QI              No  */\n-  BK_REG,\t\t\t/* BK           QI              QI  */\n-  SP_REG,\t\t\t/* SP           QI              No  */\n-  ST_REG,\t\t\t/* ST           CC              No  */\n-  NO_REGS,\t\t\t/* DIE/IE                       No  */\n-  NO_REGS,\t\t\t/* IIE/IF                       No  */\n-  NO_REGS,\t\t\t/* IIF/IOF                      No  */\n-  INT_REGS,\t\t\t/* RS           QI              No  */\n-  INT_REGS,\t\t\t/* RE           QI              No  */\n-  RC_REG,\t\t\t/* RC           QI              No  */\n-  EXT_REGS,\t\t\t/* R8           QI, QF, HF      QI  */\n-  EXT_REGS,\t\t\t/* R9           QI, QF, HF      No  */\n-  EXT_REGS,\t\t\t/* R10          QI, QF, HF      No  */\n-  EXT_REGS,\t\t\t/* R11          QI, QF, HF      No  */\n+                                /* Reg          Modes           Saved.  */\n+  R0R1_REGS,\t\t\t/* R0           QI, QF, HF      No.  */\n+  R0R1_REGS,\t\t\t/* R1           QI, QF, HF      No.  */\n+  R2R3_REGS,\t\t\t/* R2           QI, QF, HF      No.  */\n+  R2R3_REGS,\t\t\t/* R3           QI, QF, HF      No.  */\n+  EXT_LOW_REGS,\t\t\t/* R4           QI, QF, HF      QI.  */\n+  EXT_LOW_REGS,\t\t\t/* R5           QI, QF, HF      QI.  */\n+  EXT_LOW_REGS,\t\t\t/* R6           QI, QF, HF      QF.  */\n+  EXT_LOW_REGS,\t\t\t/* R7           QI, QF, HF      QF.  */\n+  ADDR_REGS,\t\t\t/* AR0          QI              No.  */\n+  ADDR_REGS,\t\t\t/* AR1          QI              No.  */\n+  ADDR_REGS,\t\t\t/* AR2          QI              No.  */\n+  ADDR_REGS,\t\t\t/* AR3          QI              QI.  */\n+  ADDR_REGS,\t\t\t/* AR4          QI              QI.  */\n+  ADDR_REGS,\t\t\t/* AR5          QI              QI.  */\n+  ADDR_REGS,\t\t\t/* AR6          QI              QI.  */\n+  ADDR_REGS,\t\t\t/* AR7          QI              QI.  */\n+  DP_REG,\t\t\t/* DP           QI              No.  */\n+  INDEX_REGS,\t\t\t/* IR0          QI              No.  */\n+  INDEX_REGS,\t\t\t/* IR1          QI              No.  */\n+  BK_REG,\t\t\t/* BK           QI              QI.  */\n+  SP_REG,\t\t\t/* SP           QI              No.  */\n+  ST_REG,\t\t\t/* ST           CC              No.  */\n+  NO_REGS,\t\t\t/* DIE/IE                       No.  */\n+  NO_REGS,\t\t\t/* IIE/IF                       No.  */\n+  NO_REGS,\t\t\t/* IIF/IOF                      No.  */\n+  INT_REGS,\t\t\t/* RS           QI              No.  */\n+  INT_REGS,\t\t\t/* RE           QI              No.  */\n+  RC_REG,\t\t\t/* RC           QI              No.  */\n+  EXT_REGS,\t\t\t/* R8           QI, QF, HF      QI.  */\n+  EXT_REGS,\t\t\t/* R9           QI, QF, HF      No.  */\n+  EXT_REGS,\t\t\t/* R10          QI, QF, HF      No.  */\n+  EXT_REGS,\t\t\t/* R11          QI, QF, HF      No.  */\n };\n \n enum machine_mode c4x_caller_save_map[FIRST_PSEUDO_REGISTER] =\n {\n-                                /* Reg          Modes           Saved  */\n-  HFmode,\t\t\t/* R0           QI, QF, HF      No  */\n-  HFmode,\t\t\t/* R1           QI, QF, HF      No  */\n-  HFmode,\t\t\t/* R2           QI, QF, HF      No  */\n-  HFmode,\t\t\t/* R3           QI, QF, HF      No  */\n-  QFmode,\t\t\t/* R4           QI, QF, HF      QI  */\n-  QFmode,\t\t\t/* R5           QI, QF, HF      QI  */\n-  QImode,\t\t\t/* R6           QI, QF, HF      QF  */\n-  QImode,\t\t\t/* R7           QI, QF, HF      QF  */\n-  QImode,\t\t\t/* AR0          QI              No  */\n-  QImode,\t\t\t/* AR1          QI              No  */\n-  QImode,\t\t\t/* AR2          QI              No  */\n-  QImode,\t\t\t/* AR3          QI              QI  */\n-  QImode,\t\t\t/* AR4          QI              QI  */\n-  QImode,\t\t\t/* AR5          QI              QI  */\n-  QImode,\t\t\t/* AR6          QI              QI  */\n-  QImode,\t\t\t/* AR7          QI              QI  */\n-  VOIDmode,\t\t\t/* DP           QI              No  */\n-  QImode,\t\t\t/* IR0          QI              No  */\n-  QImode,\t\t\t/* IR1          QI              No  */\n-  QImode,\t\t\t/* BK           QI              QI  */\n-  VOIDmode,\t\t\t/* SP           QI              No  */\n-  VOIDmode,\t\t\t/* ST           CC              No  */\n-  VOIDmode,\t\t\t/* DIE/IE                       No  */\n-  VOIDmode,\t\t\t/* IIE/IF                       No  */\n-  VOIDmode,\t\t\t/* IIF/IOF                      No  */\n-  QImode,\t\t\t/* RS           QI              No  */\n-  QImode,\t\t\t/* RE           QI              No  */\n-  VOIDmode,\t\t\t/* RC           QI              No  */\n-  QFmode,\t\t\t/* R8           QI, QF, HF      QI  */\n-  HFmode,\t\t\t/* R9           QI, QF, HF      No  */\n-  HFmode,\t\t\t/* R10          QI, QF, HF      No  */\n-  HFmode,\t\t\t/* R11          QI, QF, HF      No  */\n+                                /* Reg          Modes           Saved.  */\n+  HFmode,\t\t\t/* R0           QI, QF, HF      No.  */\n+  HFmode,\t\t\t/* R1           QI, QF, HF      No.  */\n+  HFmode,\t\t\t/* R2           QI, QF, HF      No.  */\n+  HFmode,\t\t\t/* R3           QI, QF, HF      No.  */\n+  QFmode,\t\t\t/* R4           QI, QF, HF      QI.  */\n+  QFmode,\t\t\t/* R5           QI, QF, HF      QI.  */\n+  QImode,\t\t\t/* R6           QI, QF, HF      QF.  */\n+  QImode,\t\t\t/* R7           QI, QF, HF      QF.  */\n+  QImode,\t\t\t/* AR0          QI              No.  */\n+  QImode,\t\t\t/* AR1          QI              No.  */\n+  QImode,\t\t\t/* AR2          QI              No.  */\n+  QImode,\t\t\t/* AR3          QI              QI.  */\n+  QImode,\t\t\t/* AR4          QI              QI.  */\n+  QImode,\t\t\t/* AR5          QI              QI.  */\n+  QImode,\t\t\t/* AR6          QI              QI.  */\n+  QImode,\t\t\t/* AR7          QI              QI.  */\n+  VOIDmode,\t\t\t/* DP           QI              No.  */\n+  QImode,\t\t\t/* IR0          QI              No.  */\n+  QImode,\t\t\t/* IR1          QI              No.  */\n+  QImode,\t\t\t/* BK           QI              QI.  */\n+  VOIDmode,\t\t\t/* SP           QI              No.  */\n+  VOIDmode,\t\t\t/* ST           CC              No.  */\n+  VOIDmode,\t\t\t/* DIE/IE                       No.  */\n+  VOIDmode,\t\t\t/* IIE/IF                       No.  */\n+  VOIDmode,\t\t\t/* IIF/IOF                      No.  */\n+  QImode,\t\t\t/* RS           QI              No.  */\n+  QImode,\t\t\t/* RE           QI              No.  */\n+  VOIDmode,\t\t\t/* RC           QI              No.  */\n+  QFmode,\t\t\t/* R8           QI, QF, HF      QI.  */\n+  HFmode,\t\t\t/* R9           QI, QF, HF      No.  */\n+  HFmode,\t\t\t/* R10          QI, QF, HF      No.  */\n+  HFmode,\t\t\t/* R11          QI, QF, HF      No.  */\n };\n \n \n@@ -149,6 +149,7 @@ static tree pure_tree = NULL_TREE;\n static tree noreturn_tree = NULL_TREE;\n static tree interrupt_tree = NULL_TREE;\n \n+\n /* Called to register all of our global variables with the garbage\n    collector.  */\n \n@@ -236,6 +237,7 @@ c4x_override_options ()\n \n \n /* This is called before c4x_override_options.  */\n+\n void\n c4x_optimization_options (level, size)\n      int level;\n@@ -252,6 +254,7 @@ c4x_optimization_options (level, size)\n     flag_branch_on_count_reg = 1;\n }\n \n+\n /* Write an ASCII string.  */\n \n #define C4X_ASCII_LIMIT 40\n@@ -329,20 +332,20 @@ c4x_hard_regno_mode_ok (regno, mode)\n   switch (mode)\n     {\n #if Pmode != QImode\n-    case Pmode:\t\t\t/* Pointer (24/32 bits) */\n+    case Pmode:\t\t\t/* Pointer (24/32 bits).  */\n #endif\n-    case QImode:\t\t/* Integer (32 bits) */\n+    case QImode:\t\t/* Integer (32 bits).  */\n       return IS_INT_REGNO (regno);\n \n-    case QFmode:\t\t/* Float, Double (32 bits) */\n-    case HFmode:\t\t/* Long Double (40 bits) */\n+    case QFmode:\t\t/* Float, Double (32 bits).  */\n+    case HFmode:\t\t/* Long Double (40 bits).  */\n       return IS_EXT_REGNO (regno);\n \n-    case CCmode:\t\t/* Condition Codes */\n-    case CC_NOOVmode:\t\t/* Condition Codes */\n+    case CCmode:\t\t/* Condition Codes.  */\n+    case CC_NOOVmode:\t\t/* Condition Codes.  */\n       return IS_ST_REGNO (regno);\n \n-    case HImode:\t\t/* Long Long (64 bits) */\n+    case HImode:\t\t/* Long Long (64 bits).  */\n       /* We need two registers to store long longs.  Note that \n \t it is much easier to constrain the first register\n \t to start on an even boundary.  */\n@@ -351,7 +354,7 @@ c4x_hard_regno_mode_ok (regno, mode)\n \t&& (regno & 1) == 0;\n \n     default:\n-      return 0;\t\t\t/* We don't support these modes */\n+      return 0;\t\t\t/* We don't support these modes.  */\n     }\n \n   return 0;\n@@ -401,9 +404,9 @@ static int c4x_fp_reglist[2] = {R2_REGNO, R3_REGNO};\n \n void\n c4x_init_cumulative_args (cum, fntype, libname)\n-     CUMULATIVE_ARGS *cum;\t/* argument info to initialize */\n-     tree fntype;\t\t/* tree ptr for function decl */\n-     rtx libname;\t\t/* SYMBOL_REF of library name or 0 */\n+     CUMULATIVE_ARGS *cum;\t/* Argument info to initialize.  */\n+     tree fntype;\t\t/* Tree ptr for function decl.  */\n+     rtx libname;\t\t/* SYMBOL_REF of library name or 0.  */\n {\n   tree param, next_param;\n \n@@ -480,10 +483,10 @@ c4x_init_cumulative_args (cum, fntype, libname)\n \n void\n c4x_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* whether or not the argument was named */\n+     CUMULATIVE_ARGS *cum;\t/* Current arg information.  */\n+     enum machine_mode mode;\t/* Current arg mode.  */\n+     tree type;\t\t\t/* Type of the arg or 0 if lib support.  */\n+     int named;\t\t\t/* Whether or not the argument was named.  */\n {\n   if (TARGET_DEBUG)\n     fprintf (stderr, \"c4x_function_adv(mode=%s, named=%d)\\n\\n\",\n@@ -527,16 +530,16 @@ c4x_function_arg_advance (cum, mode, type, named)\n \n struct rtx_def *\n c4x_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named;\t\t\t/* != 0 for normal args, == 0 for ... args */\n+     CUMULATIVE_ARGS *cum;\t/* Current arg information.  */\n+     enum machine_mode mode;\t/* Current arg mode.  */\n+     tree type;\t\t\t/* Type of the arg or 0 if lib support.  */\n+     int named;\t\t\t/* != 0 for normal args, == 0 for ... args.  */\n {\n-  int reg = 0;\t\t\t/* default to passing argument on stack */\n+  int reg = 0;\t\t\t/* Default to passing argument on stack.  */\n \n   if (! cum->init)\n     {\n-      /* We can handle at most 2 floats in R2, R3 */\n+      /* We can handle at most 2 floats in R2, R3.  */\n       cum->maxfloats = (cum->floats > 2) ? 2 : cum->floats;\n \n       /* We can handle at most 6 integers minus number of floats passed \n@@ -615,7 +618,7 @@ c4x_va_start (stdarg_p, valist, nextarg)\n \n \n /* C[34]x arguments grow in weird ways (downwards) that the standard\n-   varargs stuff can't handle. */\n+   varargs stuff can't handle..  */\n rtx\n c4x_va_arg (valist, type)\n      tree valist, type;\n@@ -702,7 +705,7 @@ c4x_interrupt_function_p ()\n \t\t\tTYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n     return 1;\n \n-  /* Look for TI style c_intnn  */\n+  /* Look for TI style c_intnn.  */\n   return current_function_name[0] == 'c'\n     && current_function_name[1] == '_'\n     && current_function_name[2] == 'i'\n@@ -757,7 +760,7 @@ c4x_function_prologue (file, size)\n \t  if (c4x_isr_reg_used_p (regno))\n \t    {\n \t      fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n-\t      if (IS_EXT_REGNO (regno))\t/* save 32MSB of R0--R11 */\n+\t      if (IS_EXT_REGNO (regno))\t/* Save 32MSB of R0--R11.  */\n \t\tfprintf (file, \"\\tpushf\\t%s\\n\", float_reg_names[regno]);\n \t    }\n \t}\n@@ -834,7 +837,7 @@ c4x_function_prologue (file, size)\n \t    {\n \t      if ((regno == R6_REGNO) || (regno == R7_REGNO))\n \t\t{\n-\t\t  /* R6 and R7 are saved as floating point */\n+\t\t  /* R6 and R7 are saved as floating point.  */\n \t\t  if (TARGET_PRESERVE_FLOAT)\n \t\t    fprintf (file, \"\\tpush\\t%s\\n\", reg_names[regno]);\n \t\t  fprintf (file, \"\\tpushf\\t%s\\n\", float_reg_names[regno]);\n@@ -872,7 +875,7 @@ c4x_function_epilogue (file, size)\n   /* For __assembler__ function build no epilogue.  */\n   if (c4x_assembler_function_p ())\n     {\n-      fprintf (file, \"\\trets\\n\");\t/* Play it safe */\n+      fprintf (file, \"\\trets\\n\");\t/* Play it safe.  */\n       return;\n     }\n \n@@ -929,7 +932,7 @@ c4x_function_epilogue (file, size)\n \t}\n       else\n \t{\n-\t  dont_pop_ar3 = 0;\t/* If we use ar3, we need to pop it */\n+\t  dont_pop_ar3 = 0;\t/* If we use ar3, we need to pop it.  */\n \t  if (size || current_function_args_size)\n \t    {\n \t      /* If we are ommitting the frame pointer, we still have\n@@ -1306,9 +1309,9 @@ c4x_check_legit_addr (mode, addr, strict)\n      rtx addr;\n      int strict;\n {\n-  rtx base = NULL_RTX;\t\t/* Base register (AR0-AR7) */\n-  rtx indx = NULL_RTX;\t\t/* Index register (IR0,IR1) */\n-  rtx disp = NULL_RTX;\t\t/* Displacement */\n+  rtx base = NULL_RTX;\t\t/* Base register (AR0-AR7).  */\n+  rtx indx = NULL_RTX;\t\t/* Index register (IR0,IR1).  */\n+  rtx disp = NULL_RTX;\t\t/* Displacement.  */\n   enum rtx_code code;\n \n   code = GET_CODE (addr);\n@@ -1369,7 +1372,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \t  case REG:\n \t    if (REG_P (op1))\n \t      {\n-\t\tbase = op0;\t/* base + index */\n+\t\tbase = op0;\t/* Base + index.  */\n \t\tindx = op1;\n \t\tif (IS_INDEX_REG (base) || IS_ADDR_REG (indx))\n \t\t  {\n@@ -1379,7 +1382,7 @@ c4x_check_legit_addr (mode, addr, strict)\n \t      }\n \t    else\n \t      {\n-\t\tbase = op0;\t/* base + displacement */\n+\t\tbase = op0;\t/* Base + displacement.  */\n \t\tdisp = op1;\n \t      }\n \t    break;\n@@ -1723,16 +1726,16 @@ c4x_output_cbranch (form, seq)\n \n void\n c4x_print_operand (file, op, letter)\n-     FILE *file;\t\t/* file to write to */\n-     rtx op;\t\t\t/* operand to print */\n-     int letter;\t\t/* %<letter> or 0 */\n+     FILE *file;\t\t/* File to write to.  */\n+     rtx op;\t\t\t/* Operand to print.  */\n+     int letter;\t\t/* %<letter> or 0.  */\n {\n   rtx op1;\n   enum rtx_code code;\n \n   switch (letter)\n     {\n-    case '#':\t\t\t/* delayed */\n+    case '#':\t\t\t/* Delayed.  */\n       if (final_sequence)\n \tasm_fprintf (file, \"d\");\n       return;\n@@ -1741,32 +1744,32 @@ c4x_print_operand (file, op, letter)\n   code = GET_CODE (op);\n   switch (letter)\n     {\n-    case 'A':\t\t\t/* direct address */\n+    case 'A':\t\t\t/* Direct address.  */\n       if (code == CONST_INT || code == SYMBOL_REF)\n \tasm_fprintf (file, \"@\");\n       break;\n \n-    case 'H':\t\t\t/* sethi */\n+    case 'H':\t\t\t/* Sethi.  */\n       output_addr_const (file, op);\n       return;\n \n-    case 'I':\t\t\t/* reversed condition */\n+    case 'I':\t\t\t/* Reversed condition.  */\n       code = reverse_condition (code);\n       break;\n \n-    case 'L':\t\t\t/* log 2 of constant */\n+    case 'L':\t\t\t/* Log 2 of constant.  */\n       if (code != CONST_INT)\n \tfatal_insn (\"c4x_print_operand: %%L inconsistency\", op);\n       fprintf (file, \"%d\", exact_log2 (INTVAL (op)));\n       return;\n \n-    case 'N':\t\t\t/* ones complement of small constant */\n+    case 'N':\t\t\t/* Ones complement of small constant.  */\n       if (code != CONST_INT)\n \tfatal_insn (\"c4x_print_operand: %%N inconsistency\", op);\n       fprintf (file, \"%d\", ~INTVAL (op));\n       return;\n \n-    case 'K':\t\t\t/* generate ldp(k) if direct address */\n+    case 'K':\t\t\t/* Generate ldp(k) if direct address.  */\n       if (! TARGET_SMALL\n \t  && code == MEM\n \t  && GET_CODE (XEXP (op, 0)) == LO_SUM\n@@ -1783,8 +1786,8 @@ c4x_print_operand (file, op, letter)\n \t}\n       return;\n \n-    case 'M':\t\t\t/* generate ldp(k) if direct address */\n-      if (! TARGET_SMALL\t\t/* only used in asm statements */\n+    case 'M':\t\t\t/* Generate ldp(k) if direct address.  */\n+      if (! TARGET_SMALL\t/* Only used in asm statements.  */\n \t  && code == MEM\n \t  && (GET_CODE (XEXP (op, 0)) == CONST\n \t      || GET_CODE (XEXP (op, 0)) == SYMBOL_REF))\n@@ -1795,7 +1798,7 @@ c4x_print_operand (file, op, letter)\n \t}\n       return;\n \n-    case 'O':\t\t\t/* offset address */\n+    case 'O':\t\t\t/* Offset address.  */\n       if (code == MEM && c4x_autoinc_operand (op, Pmode))\n \tbreak;\n       else if (code == MEM)\n@@ -1806,10 +1809,10 @@ c4x_print_operand (file, op, letter)\n \tfatal_insn (\"c4x_print_operand: %%O inconsistency\", op);\n       return;\n \n-    case 'C':\t\t\t/* call */\n+    case 'C':\t\t\t/* Call.  */\n       break;\n \n-    case 'U':\t\t\t/* call/callu */\n+    case 'U':\t\t\t/* Call/callu.  */\n       if (code != SYMBOL_REF)\n \tasm_fprintf (file, \"u\");\n       return;\n@@ -1988,26 +1991,26 @@ c4x_print_operand_address (file, addr)\n \t\t  {\n \t\t    fprintf (file, \"*+%s(%s)\",\n \t\t\t     reg_names[REGNO (op1)],\n-\t\t\t     reg_names[REGNO (op0)]);\t/* index + base */\n+\t\t\t     reg_names[REGNO (op0)]);\t/* Index + base.  */\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    fprintf (file, \"*+%s(%s)\",\n \t\t\t     reg_names[REGNO (op0)],\n-\t\t\t     reg_names[REGNO (op1)]);\t/* base + index */\n+\t\t\t     reg_names[REGNO (op1)]);\t/* Base + index.  */\n \t\t  }\n \t      }\n \t    else if (INTVAL (op1) < 0)\n \t      {\n \t\tfprintf (file, \"*-%s(%d)\",\n \t\t\t reg_names[REGNO (op0)],\n-\t\t\t -INTVAL (op1));\t/* base - displacement */\n+\t\t\t -INTVAL (op1));\t/* Base - displacement.  */\n \t      }\n \t    else\n \t      {\n \t\tfprintf (file, \"*+%s(%d)\",\n \t\t\t reg_names[REGNO (op0)],\n-\t\t\t INTVAL (op1));\t\t/* base + displacement */\n+\t\t\t INTVAL (op1));\t/* Base + displacement.  */\n \t      }\n \t  }\n \telse\n@@ -2043,8 +2046,10 @@ c4x_print_operand_address (file, addr)\n     }\n }\n \n+\n /* Return nonzero if the floating point operand will fit\n    in the immediate field.  */\n+\n static int\n c4x_immed_float_p (op)\n      rtx op;\n@@ -2062,16 +2067,17 @@ c4x_immed_float_p (op)\n       convval[1] = 0;\n     }\n \n-  /* sign extend exponent */\n+  /* Sign extend exponent.  */\n   exponent = (((convval[0] >> 24) & 0xff) ^ 0x80) - 0x80;\n   if (exponent == -128)\n-    return 1;\t\t\t/* 0.0 */\n+    return 1;\t\t\t/* 0.0  */\n   if ((convval[0] & 0x00000fff) != 0 || convval[1] != 0)\n-    return 0;\t\t\t/* Precision doesn't fit */\n-  return (exponent <= 7)\t/* Positive exp */\n-    && (exponent >= -7);\t/* Negative exp */\n+    return 0;\t\t\t/* Precision doesn't fit.  */\n+  return (exponent <= 7)\t/* Positive exp.  */\n+    && (exponent >= -7);\t/* Negative exp.  */\n }\n \n+\n /* The last instruction in a repeat block cannot be a Bcond, DBcound,\n    CALL, CALLCond, TRAPcond, RETIcond, RETScond, IDLE, RPTB or RPTS.\n \n@@ -2144,6 +2150,7 @@ c4x_rptb_nop_p (insn)\n   Any additional labels can be emitted at this point.  In addition, if\n   the desired loop count register was not allocated, this routine does\n   nothing.  */\n+\n void\n c4x_rptb_insert (insn)\n      rtx insn;\n@@ -2411,7 +2418,7 @@ c4x_Q_constraint (op)\n \n \n /* ARx + 5-bit unsigned const\n-   *ARx, *+ARx(n) for n < 32 */\n+   *ARx, *+ARx(n) for n < 32.  */\n \n int\n c4x_R_constraint (op)\n@@ -2526,7 +2533,7 @@ c4x_S_constraint (op)\n \top0 = XEXP (op1, 0);\n \top1 = XEXP (op1, 1);\n \treturn REG_P (op0) && REG_P (op1);\n-\t/* pre or post_modify with a displacement of 0 or 1 \n+\t/* Pre or post_modify with a displacement of 0 or 1 \n \t   should not be generated.  */\n       }\n       break;\n@@ -2599,7 +2606,7 @@ c4x_S_indirect (op)\n \top1 = XEXP (op1, 1);\n \treturn REG_P (op0) && IS_ADDR_OR_PSEUDO_REG (op0)\n \t  && REG_P (op1) && IS_INDEX_OR_PSEUDO_REG (op1);\n-\t/* pre or post_modify with a displacement of 0 or 1 \n+\t/* Pre or post_modify with a displacement of 0 or 1 \n \t   should not be generated.  */\n       }\n \n@@ -3066,7 +3073,9 @@ symbolic_address_operand (op, mode)\n     }\n }\n \n+\n /* Check dst operand of a move instruction.  */\n+\n int\n dst_operand (op, mode)\n      rtx op;\n@@ -3084,6 +3093,7 @@ dst_operand (op, mode)\n \n \n /* Check src operand of two operand arithmetic instructions.  */\n+\n int\n src_operand (op, mode)\n      rtx op;\n@@ -3315,7 +3325,7 @@ c4x_S_address_parse (op, base, incdec, index, disp)\n \t    return;\n \t  }\n       }\n-      /* Fallthrough  */\n+      /* Fallthrough.  */\n \n     default:\n       fatal_insn (\"Invalid indirect (S) memory address\", op);\n@@ -3444,23 +3454,23 @@ valid_parallel_load_store (operands, mode)\n \t  || (GET_CODE (op3) == MEM && reg_mentioned_p (op0, XEXP (op3, 0)))))\n     return 0;\n \n-  /* LDI||LDI  */\n+  /* LDI||LDI.  */\n   if (GET_CODE (op0) == REG && GET_CODE (op2) == REG)\n     return (REGNO (op0) != REGNO (op2))\n       && GET_CODE (op1) == MEM && GET_CODE (op3) == MEM\n       && ! c4x_address_conflict (op1, op3, 0, 0);\n \n-  /* STI||STI  */\n+  /* STI||STI.  */\n   if (GET_CODE (op1) == REG && GET_CODE (op3) == REG)\n     return GET_CODE (op0) == MEM && GET_CODE (op2) == MEM\n       && ! c4x_address_conflict (op0, op2, 1, 1);\n \n-  /* LDI||STI  */\n+  /* LDI||STI.  */\n   if (GET_CODE (op0) == REG && GET_CODE (op3) == REG)\n     return GET_CODE (op1) == MEM && GET_CODE (op2) == MEM\n       && ! c4x_address_conflict (op1, op2, 0, 1);\n \n-  /* STI||LDI  */\n+  /* STI||LDI.  */\n   if (GET_CODE (op1) == REG && GET_CODE (op2) == REG)\n     return GET_CODE (op0) == MEM && GET_CODE (op3) == MEM\n       && ! c4x_address_conflict (op0, op3, 1, 0);\n@@ -3726,7 +3736,7 @@ int valid_operands (code, operands, mode)\n      valid one into an invalid one, when the second operand is also a\n      memory operand.  The alternative is not to allow two memory\n      operands for an insn when not optimizing.  The problem only rarely\n-     occurs, for example with the C-torture program DFcmp.c  */\n+     occurs, for example with the C-torture program DFcmp.c.  */\n \n   return ! optimize || c4x_valid_operands (code, operands, mode, 0);\n }\n@@ -4126,7 +4136,8 @@ ir1_mem_operand (op, mode)\n }\n \n \n-/* We allow autoincrement addressing.  */\n+/* This is similar to operand_subword but allows autoincrement\n+   addressing.  */\n \n rtx\n c4x_operand_subword (op, i, validate_address, mode)\n@@ -4298,25 +4309,25 @@ c4x_handle_pragma (p_getc, p_ungetc, pname)\n     data_tree = chainon (data_tree, new);\n   \n   else if (strcmp (pname, \"FUNC_CANNOT_INLINE\") == 0)\n-      ; /* ignore */\n+      ; /* Ignore.  */\n   \n   else if (strcmp (pname, \"FUNC_EXT_CALLED\") == 0)\n-      ; /* ignore */\n+      ; /* Ignore.  */\n   \n   else if (strcmp (pname, \"FUNC_IS_PURE\") == 0)\n      pure_tree = chainon (pure_tree, new);\n   \n   else if (strcmp (pname, \"FUNC_IS_SYSTEM\") == 0)\n-      ; /* ignore */\n+      ; /* Ignore.  */\n   \n   else if (strcmp (pname, \"FUNC_NEVER_RETURNS\") == 0)\n     noreturn_tree = chainon (noreturn_tree, new);\n   \n   else if (strcmp (pname, \"FUNC_NO_GLOBAL_ASG\") == 0)\n-      ; /* ignore */\n+      ; /* Ignore.  */\n   \n   else if (strcmp (pname, \"FUNC_NO_IND_ASG\") == 0)\n-      ; /* ignore */\n+      ; /* Ignore.  */\n   \n   else if (strcmp (pname, \"INTERRUPT\") == 0)\n     interrupt_tree = chainon (interrupt_tree, new);\n@@ -4395,6 +4406,7 @@ c4x_valid_type_attribute_p (type, attributes, identifier, args)\n \n \n /* !!! FIXME to emit RPTS correctly.  */\n+\n int\n c4x_rptb_rpts_p (insn, op)\n      rtx insn, op;\n@@ -4443,10 +4455,12 @@ c4x_rptb_rpts_p (insn, op)\n    A set of an address register followed by a use occurs a 2 cycle\n    stall (reduced to a single cycle on the c40 using LDA), while\n    a read of an address register followed by a use occurs a single cycle.  */\n+\n #define\tSET_USE_COST\t3\n #define\tSETLDA_USE_COST\t2\n #define\tREAD_USE_COST\t2\n \n+\n int\n c4x_adjust_cost (insn, link, dep_insn, cost)\n      rtx insn;"}, {"sha": "b6b43bebe32a068e74930efbad2565349ddb842d", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 129, "deletions": 127, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975ab1312f8486b7b950dba91733bf81222ecb86/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=975ab1312f8486b7b950dba91733bf81222ecb86", "patch": "@@ -21,15 +21,15 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-/* RUN-TIME TARGET SPECIFICATION */\n+/* RUN-TIME TARGET SPECIFICATION.  */\n \n #define C4x   1\n \n-/* Name of the c4x assembler */\n+/* Name of the c4x assembler.  */\n \n #define ASM_PROG \"c4x-as\"\n \n-/* Name of the c4x linker */\n+/* Name of the c4x linker.  */\n \n #define LD_PROG \"c4x-ld\"\n \n@@ -90,32 +90,32 @@\n \n /* Target compilation option flags.  */\n \n-#define SMALL_MEMORY_FLAG   0x0000001 /* small memory model */\n-#define MPYI_FLAG           0x0000002 /* use 24-bit MPYI for C3x */\n-#define FAST_FIX_FLAG       0x0000004 /* fast fixing of floats */\n-#define RPTS_FLAG           0x0000008 /* allow use of RPTS */\n-#define C3X_FLAG            0x0000010 /* emit C3x code */\n-#define TI_FLAG             0x0000020 /* be compatible with TI assembler */\n-#define PARANOID_FLAG       0x0000040 /* be paranoid about DP reg. in ISRs */\n-#define MEMPARM_FLAG        0x0000080 /* pass arguments on stack */\n-#define DEVEL_FLAG          0x0000100 /* enable features under development */\n-#define RPTB_FLAG           0x0000200 /* enable repeat block */\n-#define BK_FLAG             0x0000400 /* use BK as general register */\n-#define DB_FLAG             0x0000800 /* use decrement and branch for C3x */\n-#define DEBUG_FLAG          0x0001000 /* enable debugging of GCC */\n-#define HOIST_FLAG          0x0002000 /* force constants into registers */\n-#define LOOP_UNSIGNED_FLAG  0x0004000 /* allow unsigned loop counters */\n-#define FORCE_FLAG          0x0008000 /* force op0 and op1 to be same */\n-#define PRESERVE_FLOAT_FLAG 0x0010000 /* save all 40 bits for floats */\n-#define PARALLEL_PACK_FLAG  0x0020000 /* allow parallel insn packing */\n-#define PARALLEL_MPY_FLAG   0x0040000 /* allow MPY||ADD, MPY||SUB insns */\n-#define ALIASES_FLAG\t    0x0080000 /* assume mem refs possibly aliased */\n-\n-#define C30_FLAG            0x0100000 /* emit C30 code */\n-#define C31_FLAG            0x0200000 /* emit C31 code */\n-#define C32_FLAG            0x0400000 /* emit C32 code */\n-#define C40_FLAG            0x1000000 /* emit C40 code */\n-#define C44_FLAG            0x2000000 /* emit C44 code */\n+#define SMALL_MEMORY_FLAG   0x0000001 /* Small memory model.  */\n+#define MPYI_FLAG           0x0000002 /* Use 24-bit MPYI for C3x.  */\n+#define FAST_FIX_FLAG       0x0000004 /* Fast fixing of floats.  */\n+#define RPTS_FLAG           0x0000008 /* Allow use of RPTS.  */\n+#define C3X_FLAG            0x0000010 /* Emit C3x code.  */\n+#define TI_FLAG             0x0000020 /* Be compatible with TI assembler.  */\n+#define PARANOID_FLAG       0x0000040 /* Be paranoid about DP reg. in ISRs.  */\n+#define MEMPARM_FLAG        0x0000080 /* Pass arguments on stack.  */\n+#define DEVEL_FLAG          0x0000100 /* Enable features under development.  */\n+#define RPTB_FLAG           0x0000200 /* Enable repeat block.  */\n+#define BK_FLAG             0x0000400 /* Use BK as general register.  */\n+#define DB_FLAG             0x0000800 /* Use decrement and branch for C3x.  */\n+#define DEBUG_FLAG          0x0001000 /* Enable debugging of GCC.  */\n+#define HOIST_FLAG          0x0002000 /* Force constants into registers.  */\n+#define LOOP_UNSIGNED_FLAG  0x0004000 /* Allow unsigned loop counters.  */\n+#define FORCE_FLAG          0x0008000 /* Force op0 and op1 to be same.  */\n+#define PRESERVE_FLOAT_FLAG 0x0010000 /* Save all 40 bits for floats.  */\n+#define PARALLEL_PACK_FLAG  0x0020000 /* Allow parallel insn packing.  */\n+#define PARALLEL_MPY_FLAG   0x0040000 /* Allow MPY||ADD, MPY||SUB insns.  */\n+#define ALIASES_FLAG\t    0x0080000 /* Assume mem refs possibly aliased.  */\n+\n+#define C30_FLAG            0x0100000 /* Emit C30 code.  */\n+#define C31_FLAG            0x0200000 /* Emit C31 code.  */\n+#define C32_FLAG            0x0400000 /* Emit C32 code.  */\n+#define C40_FLAG            0x1000000 /* Emit C40 code.  */\n+#define C44_FLAG            0x2000000 /* Emit C44 code.  */\n \n /* Run-time compilation parameters selecting different hardware subsets.\n \n@@ -218,7 +218,7 @@\n     \"Assume that pointers not aliased\" }, \\\n   { \"\", TARGET_DEFAULT, \"\"} }\n \n-/* Default target switches */\n+/* Default target switches.  */\n \n /* Play safe, not the fastest code.  */\n #define TARGET_DEFAULT\t\tALIASES_FLAG | PARALLEL_PACK_FLAG \\\n@@ -279,7 +279,7 @@ extern int target_flags;\n \n #define\tBCT_CHECK_LOOP_ITERATIONS  !(TARGET_LOOP_UNSIGNED)\n \n-/* -mcpu=XX    with XX = target DSP version number */\n+/* -mcpu=XX    with XX = target DSP version number.  */\n \n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n@@ -318,11 +318,11 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE) c4x_optimization_options(LEVEL, SIZE)\n \n-/* Run Time Target Specification  */\n+/* Run Time Target Specification.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (TMS320C[34]x, TI syntax)\");\n \n-/* Storage Layout  */\n+/* Storage Layout.  */\n \n #define BITS_BIG_ENDIAN\t\t0\n #define BYTES_BIG_ENDIAN\t0\n@@ -350,7 +350,7 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n #define EMPTY_FIELD_BOUNDARY\t32\n #define STRICT_ALIGNMENT\t0\n #define TARGET_FLOAT_FORMAT\tC4X_FLOAT_FORMAT\n-#define MAX_FIXED_MODE_SIZE\t64 /* HImode */\n+#define MAX_FIXED_MODE_SIZE\t64 /* HImode.  */\n \n /* Number of bits in the high and low parts of a two stage\n    load of an immediate constant.  */\n@@ -509,9 +509,9 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n #define FIXED_REGISTERS \\\n {\t\t\t\t\t\t\t\t\t\\\n-/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 */\t\\\n+/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7.  */\t\\\n     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\t\\\n-/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11 */\t\\\n+/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11.  */\t\\\n     1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0\t\\\n }\n \n@@ -528,9 +528,9 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n \n #define CALL_USED_REGISTERS \\\n {\t\t\t\t\t\t\t\t\t\\\n-/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 */\t\\\n+/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7.  */\t\\\n     1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,\t\\\n-/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11 */\t\\\n+/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11.  */\t\\\n     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1\t\\\n }\n \n@@ -548,9 +548,9 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n       {\t\t\t\t\t\t\t\\\n \t int i;                                          \\\n \t\t\t\t\t\t\t \\\n-\t reg_names[DIE_REGNO] = \"ie\";  /* clobber die */ \\\n-\t reg_names[IF_REGNO] = \"if\";   /* clobber iie */ \\\n-\t reg_names[IOF_REGNO] = \"iof\"; /* clobber iif */ \\\n+\t reg_names[DIE_REGNO] = \"ie\";  /* Clobber die.  */ \\\n+\t reg_names[IF_REGNO] = \"if\";   /* Clobber iie.  */ \\\n+\t reg_names[IOF_REGNO] = \"iof\"; /* Clobber iif.  */ \\\n \t \t\t\t\t\t\t\\\n \t for (i = R8_REGNO; i <= R11_REGNO; i++)\t\\\n \t {\t\t\t\t\t\t\\\n@@ -565,7 +565,7 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n       }\t\t\t\t\t\t\t\\\n    }\n \n-/* Order of Allocation of Registers  */\n+/* Order of Allocation of Registers.  */\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n@@ -653,20 +653,20 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n enum reg_class\n   {\n     NO_REGS,\n-    R0R1_REGS,\t\t\t/* 't' */\n-    R2R3_REGS,\t\t\t/* 'u' */\n-    EXT_LOW_REGS,\t\t/* 'q' */\n-    EXT_REGS,\t\t\t/* 'f' */\n-    ADDR_REGS,\t\t\t/* 'a' */\n-    INDEX_REGS,\t\t\t/* 'x' */\n-    BK_REG,\t\t\t/* 'k' */\n-    SP_REG,\t\t\t/* 'b' */\n-    RC_REG,\t\t\t/* 'v' */\n+    R0R1_REGS,\t\t\t/* 't'.  */\n+    R2R3_REGS,\t\t\t/* 'u'.  */\n+    EXT_LOW_REGS,\t\t/* 'q'.  */\n+    EXT_REGS,\t\t\t/* 'f'.  */\n+    ADDR_REGS,\t\t\t/* 'a'.  */\n+    INDEX_REGS,\t\t\t/* 'x'.  */\n+    BK_REG,\t\t\t/* 'k'.  */\n+    SP_REG,\t\t\t/* 'b'.  */\n+    RC_REG,\t\t\t/* 'v'.  */\n     COUNTER_REGS,\t\t/*  */\n-    INT_REGS,\t\t\t/* 'c' */\n-    GENERAL_REGS,\t\t/* 'r' */\n-    DP_REG,\t\t\t/* 'z' */\n-    ST_REG,\t\t\t/* 'y' */\n+    INT_REGS,\t\t\t/* 'c'.  */\n+    GENERAL_REGS,\t\t/* 'r'.  */\n+    DP_REG,\t\t\t/* 'z'.  */\n+    ST_REG,\t\t\t/* 'y'.  */\n     ALL_REGS,\n     LIM_REG_CLASSES\n   };\n@@ -701,22 +701,22 @@ enum reg_class\n \n #define REG_CLASS_CONTENTS \\\n {\t\t\t\t\t\t\\\n- {0x00000000}, /*     No registers */\t\t\\\n- {0x00000003}, /* 't' R0-R1\t */\t\t\\\n- {0x0000000c}, /* 'u' R2-R3\t */\t\t\\\n- {0x000000ff}, /* 'q' R0-R7\t */\t\t\\\n+ {0x00000000}, /*     No registers.  */\t\t\\\n+ {0x00000003}, /* 't' R0-R1\t.  */\t\t\\\n+ {0x0000000c}, /* 'u' R2-R3\t.  */\t\t\\\n+ {0x000000ff}, /* 'q' R0-R7\t.  */\t\t\\\n  {0xf00000ff}, /* 'f' R0-R11       */\t\t\\\n- {0x0000ff00}, /* 'a' AR0-AR7 */\t\t\\\n- {0x00060000}, /* 'x' IR0-IR1 */\t\t\\\n- {0x00080000}, /* 'k' BK */\t\t\t\\\n- {0x00100000}, /* 'b' SP */\t\t\t\\\n- {0x08000000}, /* 'v' RC */\t\t\t\\\n- {0x0800ff00}, /*     RC,AR0-AR7 */\t\t\\\n- {0x0e1eff00}, /* 'c' AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC */\t\\\n- {0xfe1effff}, /* 'r' R0-R11, AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC */\\\n- {0x00010000}, /* 'z' DP */\t\t\t\\\n- {0x00200000}, /* 'y' ST */\t\t\t\\\n- {0xffffffff}, /*     All registers */\t\t\\\n+ {0x0000ff00}, /* 'a' AR0-AR7.  */\t\t\\\n+ {0x00060000}, /* 'x' IR0-IR1.  */\t\t\\\n+ {0x00080000}, /* 'k' BK.  */\t\t\t\\\n+ {0x00100000}, /* 'b' SP.  */\t\t\t\\\n+ {0x08000000}, /* 'v' RC.  */\t\t\t\\\n+ {0x0800ff00}, /*     RC,AR0-AR7.  */\t\t\\\n+ {0x0e1eff00}, /* 'c' AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC.  */\t\\\n+ {0xfe1effff}, /* 'r' R0-R11, AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC.  */\\\n+ {0x00010000}, /* 'z' DP.  */\t\t\t\\\n+ {0x00200000}, /* 'y' ST.  */\t\t\t\\\n+ {0xffffffff}, /*     All registers.  */\t\t\\\n }\n \n /* The same information, inverted:\n@@ -821,26 +821,27 @@ enum reg_class\n (((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : ((MODE) == HFmode) ? 1 : \\\n ((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-#define IS_INT5_CONST(VAL) (((VAL) <= 15) && ((VAL) >= -16))\t/* 'K' */\n+#define IS_INT5_CONST(VAL) (((VAL) <= 15) && ((VAL) >= -16))\t/* 'K'.  */\n \n-#define IS_UINT5_CONST(VAL) (((VAL) <= 31) && ((VAL) >= 0))\t/* 'R' */\n+#define IS_UINT5_CONST(VAL) (((VAL) <= 31) && ((VAL) >= 0))\t/* 'R'.  */\n \n-#define IS_INT8_CONST(VAL) (((VAL) <= 127) && ((VAL) >= -128))\t/* 'J' */\n+#define IS_INT8_CONST(VAL) (((VAL) <= 127) && ((VAL) >= -128))\t/* 'J'.  */\n \n-#define IS_UINT8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= 0))\t/* 'M' */\n+#define IS_UINT8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= 0))\t/* 'M'.  */\n \n-#define IS_INT16_CONST(VAL) (((VAL) <= 32767) && ((VAL) >= -32768)) /* 'I' */\n+#define IS_INT16_CONST(VAL) (((VAL) <= 32767) && ((VAL) >= -32768)) /* 'I'.  */\n \n-#define IS_UINT16_CONST(VAL) (((VAL) <= 65535) && ((VAL) >= 0))\t/* 'L' */\n+#define IS_UINT16_CONST(VAL) (((VAL) <= 65535) && ((VAL) >= 0))\t/* 'L'.  */\n \n-#define IS_NOT_UINT16_CONST(VAL) IS_UINT16_CONST(~(VAL))\t/* 'N' */\n+#define IS_NOT_UINT16_CONST(VAL) IS_UINT16_CONST(~(VAL))\t/* 'N'.  */\n \n-#define IS_HIGH_CONST(VAL) (! TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O' */\n+#define IS_HIGH_CONST(VAL) \\\n+(! TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O'.  */\n \n \n-#define IS_DISP1_CONST(VAL) (((VAL) <= 1) && ((VAL) >= -1)) /* 'S' */\n+#define IS_DISP1_CONST(VAL) (((VAL) <= 1) && ((VAL) >= -1)) /* 'S'.  */\n \n-#define IS_DISP8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= -255))\t/* 'Q' */\n+#define IS_DISP8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= -255))\t/* 'Q'.  */\n \n #define IS_DISP1_OFF_CONST(VAL) (IS_DISP1_CONST (VAL) \\\n \t\t\t\t && IS_DISP1_CONST (VAL + 1))\n@@ -973,7 +974,7 @@ enum reg_class\n #define C4X_ARG0 -2\n #define C4X_LOC0 1\n \n-/* Basic Stack Layout  */\n+/* Basic Stack Layout.  */\n      \n /* The stack grows upward, stack frame grows upward, and args grow\n    downward.  */\n@@ -986,25 +987,25 @@ enum reg_class\n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n \n-/* #define STACK_GROWS_DOWNWARD */\n-/* Like the dsp16xx, i370, i960, and we32k ports */\n+/* #define STACK_GROWS_DOWNWARD.  */\n+/* Like the dsp16xx, i370, i960, and we32k ports.  */\n \n /* Define this if the nominal address of the stack frame\n    is at the high-address end of the local variables;\n    that is, each additional local variable allocated\n    goes at a more negative offset in the frame.  */\n \n-/* #define FRAME_GROWS_DOWNWARD */\n+/* #define FRAME_GROWS_DOWNWARD.  */\n \n \n-/* Registers That Address the Stack Frame  */\n+/* Registers That Address the Stack Frame.  */\n \n-#define STACK_POINTER_REGNUM\tSP_REGNO\t/* SP */\n-#define FRAME_POINTER_REGNUM\tAR3_REGNO\t/* AR3 */\n-#define ARG_POINTER_REGNUM\tAR3_REGNO\t/* AR3 */\n-#define STATIC_CHAIN_REGNUM\tAR0_REGNO\t/* AR0 */\n+#define STACK_POINTER_REGNUM\tSP_REGNO\t/* SP.  */\n+#define FRAME_POINTER_REGNUM\tAR3_REGNO\t/* AR3.  */\n+#define ARG_POINTER_REGNUM\tAR3_REGNO\t/* AR3.  */\n+#define STATIC_CHAIN_REGNUM\tAR0_REGNO\t/* AR0.  */\n \n-/* Eliminating Frame Pointer and Arg Pointer  */\n+/* Eliminating Frame Pointer and Arg Pointer.  */\n \n #define FRAME_POINTER_REQUIRED\t0\n \n@@ -1020,7 +1021,7 @@ enum reg_class\n   (DEPTH) = -(offset + get_frame_size ());\t\t\t\\\n }\n \n-/* This is a hack... We need to specify a register.  */\n+/* This is a hack...  We need to specify a register.  */\n #define\tELIMINABLE_REGS \t\t\t\t\t\\\n   {{ FRAME_POINTER_REGNUM, FRAME_POINTER_REGNUM }}\n \n@@ -1041,14 +1042,14 @@ enum reg_class\n }\n \n \n-/* Passing Function Arguments on the Stack  */\n+/* Passing Function Arguments on the Stack.  */\n \n #if 0\n #define PUSH_ROUNDING(BYTES) (BYTES)\n #endif\n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n \n-/* The following structure is used by calls.c, function.c, c4x.c  */\n+/* The following structure is used by calls.c, function.c, c4x.c.  */\n \n typedef struct c4x_args\n {\n@@ -1088,29 +1089,29 @@ CUMULATIVE_ARGS;\n /* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n-\t(  (   ((REGNO) == AR2_REGNO)\t/* AR2 */\t\\\n-\t    || ((REGNO) == R2_REGNO)\t/* R2 */\t\\\n-\t    || ((REGNO) == R3_REGNO)\t/* R3 */\t\\\n-\t    || ((REGNO) == RC_REGNO)\t/* RC */\t\\\n-\t    || ((REGNO) == RS_REGNO)\t/* RS */\t\\\n-\t    || ((REGNO) == RE_REGNO))\t/* RE */\t\\\n+\t(  (   ((REGNO) == AR2_REGNO)\t/* AR2.  */\t\\\n+\t    || ((REGNO) == R2_REGNO)\t/* R2.  */\t\\\n+\t    || ((REGNO) == R3_REGNO)\t/* R3.  */\t\\\n+\t    || ((REGNO) == RC_REGNO)\t/* RC.  */\t\\\n+\t    || ((REGNO) == RS_REGNO)\t/* RS.  */\t\\\n+\t    || ((REGNO) == RE_REGNO))\t/* RE.  */\t\\\n \t ? 1\t\t\t\t\t\t\\\n \t : 0)\n \n-/* How Scalar Function Values Are Returned  */\n+/* How Scalar Function Values Are Returned.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-\tgen_rtx(REG, TYPE_MODE(VALTYPE), R0_REGNO)\t/* Return in R0 */\n+\tgen_rtx(REG, TYPE_MODE(VALTYPE), R0_REGNO)\t/* Return in R0.  */\n \n #define LIBCALL_VALUE(MODE) \\\n-\tgen_rtx(REG, MODE, R0_REGNO)\t/* Return in R0 */\n+\tgen_rtx(REG, MODE, R0_REGNO)\t/* Return in R0.  */\n \n #define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == R0_REGNO)\n \n-/* How Large Values Are Returned  */\n+/* How Large Values Are Returned.  */\n \n #define DEFAULT_PCC_STRUCT_RETURN\t0\n-#define STRUCT_VALUE_REGNUM\t\tAR0_REGNO\t/* AR0 */\n+#define STRUCT_VALUE_REGNUM\t\tAR0_REGNO\t/* AR0.  */\n \n /* Varargs handling.  */\n \n@@ -1120,13 +1121,13 @@ CUMULATIVE_ARGS;\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   c4x_va_arg (valist, type)\n \n-/* Function Entry and Exit  */\n+/* Function Entry and Exit.  */\n \n #define FUNCTION_PROLOGUE(FILE, SIZE)\tc4x_function_prologue(FILE, SIZE)\n #define FUNCTION_EPILOGUE(FILE, SIZE)\tc4x_function_epilogue(FILE, SIZE)\n \n \n-/* Generating Code for Profiling  */\n+/* Generating Code for Profiling.  */\n \n /* Note that the generated assembly uses the ^ operator to load the 16\n    MSBs of the address.  This is not supported by the TI assembler. \n@@ -1412,7 +1413,7 @@ CUMULATIVE_ARGS;\n \tasm(\"\tpopf\tr0\");\t\t\\\n \tasm(\"\tpop\tr0\");\t\t\\\n \n-/* Implicit Calls to Library Routines  */\n+/* Implicit Calls to Library Routines.  */\n \n #define MULQI3_LIBCALL      \"__mulqi3\"\n #define DIVQI3_LIBCALL      \"__divqi3\"\n@@ -1571,7 +1572,7 @@ CUMULATIVE_ARGS;\n     || GET_MODE (Y) == ABS)\t\t\t\t\t\\\n     ? CC_NOOVmode : CCmode)\n \n-/* Addressing Modes  */\n+/* Addressing Modes.  */\n \n #define HAVE_POST_INCREMENT 1\n #define HAVE_PRE_INCREMENT 1\n@@ -1722,7 +1723,7 @@ CUMULATIVE_ARGS;\n \n #define ENCODE_SECTION_INFO(DECL) c4x_encode_section_info (DECL);\n \n-/* Descripting Relative Cost of Operations  */\n+/* Descripting Relative Cost of Operations.  */\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE. \n@@ -1843,7 +1844,7 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n #define REGISTER_MOVE_COST(FROM, TO)\t2\n \n /* Memory move cost is same as fast register move.  Maybe this should\n-   be bumped up? */\n+   be bumped up?.  */\n \n #define MEMORY_MOVE_COST(M,C,I)\t\t4\n \n@@ -2028,7 +2029,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if ((0 && RELOC)\t/* should be (flag_pic && RELOC) */\t\t\\\n+      if ((0 && RELOC)\t/* Should be (flag_pic && RELOC).  */\t\t\\\n \t  || ! TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n \t  || ! DECL_INITIAL (DECL)\t\t\t\t\t\\\n \t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n@@ -2050,7 +2051,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #define SELECT_RTX_SECTION(MODE, RTX) const_section()\n \n \n-/* Overall Framework of an Assembler File  */\n+/* Overall Framework of an Assembler File.  */\n \n #define ASM_FILE_START(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n@@ -2148,9 +2149,9 @@ dtors_section ()\t\t\t\t\t\t\t\\\n #define ASM_CLOSE_PAREN \")\"\n \n \n-/* Output and Generation of Labels  */\n+/* Output and Generation of Labels.  */\n \n-#define NO_DOT_IN_LABEL\t\t/* Only required for TI format */\n+#define NO_DOT_IN_LABEL\t\t/* Only required for TI format.  */\n \n #define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0);\n@@ -2207,7 +2208,7 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n   sprintf ((OUTPUT), \"%s%d\", (NAME), (LABELNO)))\n \n \n-/* Output of Dispatch Tables  */\n+/* Output of Dispatch Tables.  */\n \n /* This is how to output an element of a case-vector that is absolute.  */\n \n@@ -2235,7 +2236,7 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n #define LONG_LONG_TYPE_SIZE\t64\n #define FLOAT_TYPE_SIZE\t\t32\n #define DOUBLE_TYPE_SIZE\t32\n-#define LONG_DOUBLE_TYPE_SIZE\t64 /* actually only 40 */\n+#define LONG_DOUBLE_TYPE_SIZE\t64 /* Actually only 40.  */\n \n /* Allow #sccs in preprocessor.  */\n \n@@ -2248,7 +2249,7 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n \n #define CPP_PREDEFINES \"\"\n \n-/* Output of Uninitialized Variables  */\n+/* Output of Uninitialized Variables.  */\n \n /* This says how to output an assembler line to define a local\n    uninitialized variable.  */\n@@ -2270,12 +2271,12 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n    assemble_name (FILE, (NAME)),\t\\\n    fprintf (FILE, \",%u\\n\", (ROUNDED)))\n \n-/* Macros Controlling Initialization Routines  */\n+/* Macros Controlling Initialization Routines.  */\n \n #define OBJECT_FORMAT_COFF\n #define REAL_NM_FILE_NAME \"c4x-nm\"\n \n-/* Output of Assembler Instructions  */\n+/* Output of Assembler Instructions.  */\n \n /* Register names when used for integer modes.  */\n \n@@ -2321,7 +2322,7 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n #define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n   (c4x_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n \n-/* Assembler Commands for Alignment  */\n+/* Assembler Commands for Alignment.  */\n \n #define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n { int c = SIZE; \\\n@@ -2339,7 +2340,7 @@ asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n \n \n /* Macros for SDB and DWARF Output  (use .sdef instead of .def\n-   to avoid conflict with TI's use of .def)  */\n+   to avoid conflict with TI's use of .def).  */\n \n #define SDB_DELIM \"\\n\"\n #define SDB_DEBUGGING_INFO\n@@ -2530,7 +2531,7 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n /* MOVE_RATIO is the number of move instructions that is better than a\n    block move.  */\n \n-#define MOVE_RATIO 2\t\t/* Default value */\n+#define MOVE_RATIO 2\t\t/* Default value.  */\n \n #define BSS_SECTION_ASM_OP \".bss\"\n \n@@ -2616,11 +2617,12 @@ if (final_sequence != NULL_RTX)\t\t\\\n \n /* Variables in c4x.c */\n \n-extern enum reg_class c4x_regclass_map[];/* smallest class containing REGNO */\n+/* Smallest class containing REGNO.  */\n+extern enum reg_class c4x_regclass_map[];\n extern enum machine_mode c4x_caller_save_map[];\n \n-extern struct rtx_def *c4x_compare_op0;\t/* operand 0 for comparisons */\n-extern struct rtx_def *c4x_compare_op1;\t/* operand 1 for comparisons */\n+extern struct rtx_def *c4x_compare_op0;\t/* Operand 0 for comparisons.  */\n+extern struct rtx_def *c4x_compare_op1;\t/* Operand 1 for comparisons.  */\n \n-extern int c4x_rpts_cycles;\t        /* max cycles for RPTS */\n-extern int c4x_cpu_version;\t\t/* cpu version C30/31/32/40/44 */\n+extern int c4x_rpts_cycles;\t        /* Max cycles for RPTS.  */\n+extern int c4x_cpu_version;\t\t/* Cpu version C30/31/32/40/44.  */"}]}