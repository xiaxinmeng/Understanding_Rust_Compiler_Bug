{"sha": "4027b0158d3e9249d9269f2eff144e76904cde8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyN2IwMTU4ZDNlOTI0OWQ5MjY5ZjJlZmYxNDRlNzY5MDRjZGU4Yw==", "commit": {"author": {"name": "Siva Chandra Reddy", "email": "sivachandra@google.com", "date": "2014-10-13T11:23:10Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-10-13T11:23:10Z"}, "message": "xmethods.py: Add xmethods for std::array, std::deque, std::forward_list, std::list, std::vector.\n\n2014-10-13  Siva Chandra Reddy  <sivachandra@google.com>\n\n\t* python/libstdcxx/v6/xmethods.py: Add xmethods for std::array,\n\tstd::deque, std::forward_list, std::list, std::vector.\n\t* testsuite/libstdc++-xmethods/array.cc: New file.\n\t* testsuite/libstdc++-xmethods/deque.cc: Likewise.\n\t* testsuite/libstdc++-xmethods/forwardlist.cc: Likewise.\n\t* testsuite/libstdc++-xmethods/list.cc: Likewise.\n\t* testsuite/libstdc++-xmethods/vector.cc: Add tests.\n\nFrom-SVN: r216145", "tree": {"sha": "5461961c608752f7654f3b2d5947a5d362f20fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5461961c608752f7654f3b2d5947a5d362f20fd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4027b0158d3e9249d9269f2eff144e76904cde8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4027b0158d3e9249d9269f2eff144e76904cde8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4027b0158d3e9249d9269f2eff144e76904cde8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4027b0158d3e9249d9269f2eff144e76904cde8c/comments", "author": {"login": "sivachandra", "id": 635361, "node_id": "MDQ6VXNlcjYzNTM2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/635361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sivachandra", "html_url": "https://github.com/sivachandra", "followers_url": "https://api.github.com/users/sivachandra/followers", "following_url": "https://api.github.com/users/sivachandra/following{/other_user}", "gists_url": "https://api.github.com/users/sivachandra/gists{/gist_id}", "starred_url": "https://api.github.com/users/sivachandra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sivachandra/subscriptions", "organizations_url": "https://api.github.com/users/sivachandra/orgs", "repos_url": "https://api.github.com/users/sivachandra/repos", "events_url": "https://api.github.com/users/sivachandra/events{/privacy}", "received_events_url": "https://api.github.com/users/sivachandra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "913f32a121d0c3801de4b226e2cc24c39b84f84d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/913f32a121d0c3801de4b226e2cc24c39b84f84d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/913f32a121d0c3801de4b226e2cc24c39b84f84d"}], "stats": {"total": 671, "additions": 646, "deletions": 25}, "files": [{"sha": "a5436de0fe32dde139559facbf757efc9d34cd53", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -1,3 +1,13 @@\n+2014-10-13  Siva Chandra Reddy  <sivachandra@google.com>\n+\n+\t* python/libstdcxx/v6/xmethods.py: Add xmethods for std::array,\n+\tstd::deque, std::forward_list, std::list, std::vector.\n+\t* testsuite/libstdc++-xmethods/array.cc: New file.\n+\t* testsuite/libstdc++-xmethods/deque.cc: Likewise.\n+\t* testsuite/libstdc++-xmethods/forwardlist.cc: Likewise.\n+\t* testsuite/libstdc++-xmethods/list.cc: Likewise.\n+\t* testsuite/libstdc++-xmethods/vector.cc: Add tests.\n+\n 2014-10-13  R\u00fcdiger Sonderfeld  <ruediger@c-plusplus.de>\n \n \t* include/std/memory (align): Define."}, {"sha": "6af1c95bc28702eea0a014542f6a800858c4d321", "filename": "libstdc++-v3/python/libstdcxx/v6/xmethods.py", "status": "modified", "additions": 382, "deletions": 17, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -1,4 +1,4 @@\n-# Xmethods for libstc++.\n+# Xmethods for libstdc++.\n \n # Copyright (C) 2014 Free Software Foundation, Inc.\n \n@@ -21,45 +21,406 @@\n \n matcher_name_prefix = 'libstdc++::'\n \n-# Xmethods for std::vector\n+class LibStdCxxXMethod(gdb.xmethod.XMethod):\n+    def __init__(self, name, worker_class):\n+        gdb.xmethod.XMethod.__init__(self, name)\n+        self.worker_class = worker_class\n+\n+# Xmethods for std::array\n+\n+class ArrayWorkerBase(gdb.xmethod.XMethodWorker):\n+    def __init__(self, valtype, size):\n+        self._valtype = valtype\n+        self._size = size\n+\n+    def null_value(self):\n+        nullptr = gdb.parse_and_eval('(void *) 0')\n+        return nullptr.cast(self._valtype.pointer()).dereference()\n+\n+class ArraySizeWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return self._size\n+\n+class ArrayEmptyWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return (int(self._size) == 0)\n+\n+class ArrayFrontWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        if int(self._size) > 0:\n+            return obj['_M_elems'][0]\n+        else:\n+            return self.null_value()\n+\n+class ArrayBackWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        if int(self._size) > 0:\n+            return obj['_M_elems'][self._size - 1]\n+        else:\n+            return self.null_value()\n+\n+class ArrayAtWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return gdb.lookup_type('std::size_t')\n+\n+    def __call__(self, obj, index):\n+        if int(index) >= int(self._size):\n+            raise IndexError('Array index \"%d\" should not be >= %d.' %\n+                             ((int(index), self._size)))\n+        return obj['_M_elems'][index]\n+\n+class ArraySubscriptWorker(ArrayWorkerBase):\n+    def __init__(self, valtype, size):\n+        ArrayWorkerBase.__init__(self, valtype, size)\n+\n+    def get_arg_types(self):\n+        return gdb.lookup_type('std::size_t')\n+\n+    def __call__(self, obj, index):\n+        if int(self._size) > 0:\n+            return obj['_M_elems'][index]\n+        else:\n+            return self.null_value()\n \n-class VectorSizeWorker(gdb.xmethod.XMethodWorker):\n+class ArrayMethodsMatcher(gdb.xmethod.XMethodMatcher):\n     def __init__(self):\n-        self.name = 'size'\n-        self.enabled = True\n+        gdb.xmethod.XMethodMatcher.__init__(self,\n+                                            matcher_name_prefix + 'array')\n+        self._method_dict = {\n+            'size': LibStdCxxXMethod('size', ArraySizeWorker),\n+            'empty': LibStdCxxXMethod('empty', ArrayEmptyWorker),\n+            'front': LibStdCxxXMethod('front', ArrayFrontWorker),\n+            'back': LibStdCxxXMethod('back', ArrayBackWorker),\n+            'at': LibStdCxxXMethod('at', ArrayAtWorker),\n+            'operator[]': LibStdCxxXMethod('operator[]', ArraySubscriptWorker),\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n+\n+    def match(self, class_type, method_name):\n+        if not re.match('^std::array<.*>$', class_type.tag):\n+            return None\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        try:\n+            value_type = class_type.template_argument(0)\n+            size = class_type.template_argument(1)\n+        except:\n+            return None\n+        return method.worker_class(value_type, size)\n+\n+# Xmethods for std::deque\n+\n+class DequeWorkerBase(gdb.xmethod.XMethodWorker):\n+    def __init__(self, elemtype):\n+        self._bufsize = (512 / elemtype.sizeof) or 1\n+\n+    def size(self, obj):\n+        first_node = obj['_M_impl']['_M_start']['_M_node']\n+        last_node = obj['_M_impl']['_M_finish']['_M_node']\n+        cur = obj['_M_impl']['_M_finish']['_M_cur']\n+        first = obj['_M_impl']['_M_finish']['_M_first']\n+        return (last_node - first_node) * self._bufsize + (cur - first)\n+\n+    def index(self, obj, index):\n+        first_node = obj['_M_impl']['_M_start']['_M_node']\n+        index_node = first_node + index / self._bufsize\n+        return index_node[0][index % self._bufsize]\n+\n+class DequeEmptyWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return (obj['_M_impl']['_M_start']['_M_cur'] ==\n+                obj['_M_impl']['_M_finish']['_M_cur'])\n+\n+class DequeSizeWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return self.size(obj)\n+\n+class DequeFrontWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return obj['_M_impl']['_M_start']['_M_cur'][0]\n+\n+class DequeBackWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        if (obj['_M_impl']['_M_finish']['_M_cur'] ==\n+            obj['_M_impl']['_M_finish']['_M_first']):\n+            prev_node = obj['_M_impl']['_M_finish']['_M_node'] - 1\n+            return prev_node[0][self._bufsize - 1]\n+        else:\n+            return obj['_M_impl']['_M_finish']['_M_cur'][-1]\n+\n+class DequeSubscriptWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return gdb.lookup_type('std::size_t')\n+\n+    def __call__(self, obj, subscript):\n+        return self.index(obj, subscript)\n+\n+class DequeAtWorker(DequeWorkerBase):\n+    def get_arg_types(self):\n+        return gdb.lookup_type('std::size_t')\n+\n+    def __call__(self, obj, index):\n+        deque_size = int(self.size(obj))\n+        if int(index) >= deque_size:\n+            raise IndexError('Deque index \"%d\" should not be >= %d.' %\n+                             (int(index), deque_size))\n+        else:\n+           return self.index(obj, index)\n+\n+class DequeMethodsMatcher(gdb.xmethod.XMethodMatcher):\n+    def __init__(self):\n+        gdb.xmethod.XMethodMatcher.__init__(self,\n+                                            matcher_name_prefix + 'deque')\n+        self._method_dict = {\n+            'empty': LibStdCxxXMethod('empty', DequeEmptyWorker),\n+            'size': LibStdCxxXMethod('size', DequeSizeWorker),\n+            'front': LibStdCxxXMethod('front', DequeFrontWorker),\n+            'back': LibStdCxxXMethod('back', DequeBackWorker),\n+            'operator[]': LibStdCxxXMethod('operator[]', DequeSubscriptWorker),\n+            'at': LibStdCxxXMethod('at', DequeAtWorker)\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n+\n+    def match(self, class_type, method_name):\n+        if not re.match('^std::deque<.*>$', class_type.tag):\n+            return None\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        return method.worker_class(class_type.template_argument(0))\n+\n+# Xmethods for std::forward_list\n+\n+class ForwardListWorkerBase(gdb.xmethod.XMethodMatcher):\n+    def __init__(self, elem_type, node_type):\n+        self._elem_type = elem_type\n+        self._node_type = node_type\n \n     def get_arg_types(self):\n         return None\n \n+class ForwardListEmptyWorker(ForwardListWorkerBase):\n+    def __call__(self, obj):\n+        return obj['_M_impl']['_M_head']['_M_next'] == 0\n+\n+class ForwardListFrontWorker(ForwardListWorkerBase):\n     def __call__(self, obj):\n-        return obj['_M_impl']['_M_finish'] - obj['_M_impl']['_M_start']\n+        node = obj['_M_impl']['_M_head']['_M_next'].cast(self._node_type)\n+        elem_address = node['_M_storage']['_M_storage'].address\n+        return elem_address.cast(self._elem_type.pointer()).dereference()\n \n-class VectorSubscriptWorker(gdb.xmethod.XMethodWorker):\n+class ForwardListMethodsMatcher(gdb.xmethod.XMethodMatcher):\n     def __init__(self):\n-        self.name = 'operator[]'\n-        self.enabled = True\n+        matcher_name = matcher_name_prefix + 'forward_list'\n+        gdb.xmethod.XMethodMatcher.__init__(self, matcher_name)\n+        self._method_dict = {\n+            'empty': LibStdCxxXMethod('empty', ForwardListEmptyWorker),\n+            'front': LibStdCxxXMethod('front', ForwardListFrontWorker)\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n+\n+    def match(self, class_type, method_name):\n+        if not re.match('^std::forward_list<.*>$', class_type.tag):\n+            return None\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        elem_type = class_type.template_argument(0)\n+        node_type = gdb.lookup_type(str(class_type) + '::_Node').pointer()\n+        return method.worker_class(elem_type, node_type)\n+\n+# Xmethods for std::list\n+\n+class ListWorkerBase(gdb.xmethod.XMethodWorker):\n+    def __init__(self, node_type):\n+        self._node_type = node_type\n+\n+    def get_arg_types(self):\n+        return None\n+\n+class ListEmptyWorker(ListWorkerBase):\n+    def __call__(self, obj):\n+        base_node = obj['_M_impl']['_M_node']\n+        if base_node['_M_next'] == base_node.address:\n+            return True\n+        else:\n+            return False\n+\n+class ListSizeWorker(ListWorkerBase):\n+    def __call__(self, obj):\n+        begin_node = obj['_M_impl']['_M_node']['_M_next']\n+        end_node = obj['_M_impl']['_M_node'].address\n+        size = 0\n+        while begin_node != end_node:\n+            begin_node = begin_node['_M_next']\n+            size += 1\n+        return size\n+\n+class ListFrontWorker(ListWorkerBase):\n+    def __call__(self, obj):\n+        node = obj['_M_impl']['_M_node']['_M_next'].cast(self._node_type)\n+        return node['_M_data']\n+\n+class ListBackWorker(ListWorkerBase):\n+    def __call__(self, obj):\n+        prev_node = obj['_M_impl']['_M_node']['_M_prev'].cast(self._node_type)\n+        return prev_node['_M_data']\n+\n+class ListMethodsMatcher(gdb.xmethod.XMethodMatcher):\n+    def __init__(self):\n+        gdb.xmethod.XMethodMatcher.__init__(self,\n+                                            matcher_name_prefix + 'list')\n+        self._method_dict = {\n+            'empty': LibStdCxxXMethod('empty', ListEmptyWorker),\n+            'size': LibStdCxxXMethod('size', ListSizeWorker),\n+            'front': LibStdCxxXMethod('front', ListFrontWorker),\n+            'back': LibStdCxxXMethod('back', ListBackWorker)\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n+\n+    def match(self, class_type, method_name):\n+        if not re.match('^std::list<.*>$', class_type.tag):\n+            return None\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        node_type = gdb.lookup_type(str(class_type) + '::_Node').pointer()\n+        return method.worker_class(node_type)\n+\n+# Xmethods for std::vector\n+\n+class VectorWorkerBase(gdb.xmethod.XMethodWorker):\n+    def __init__(self, elemtype):\n+        self._elemtype = elemtype\n+\n+    def size(self, obj):\n+        if self._elemtype.code == gdb.TYPE_CODE_BOOL:\n+            start = obj['_M_impl']['_M_start']['_M_p']\n+            finish = obj['_M_impl']['_M_finish']['_M_p']\n+            finish_offset = obj['_M_impl']['_M_finish']['_M_offset']\n+            bit_size = start.dereference().type.sizeof * 8\n+            return (finish - start) * bit_size + finish_offset\n+        else:\n+            return obj['_M_impl']['_M_finish'] - obj['_M_impl']['_M_start']\n+\n+    def get(self, obj, index):\n+        if self._elemtype.code == gdb.TYPE_CODE_BOOL:\n+            start = obj['_M_impl']['_M_start']['_M_p']\n+            bit_size = start.dereference().type.sizeof * 8\n+            valp = start + index / bit_size\n+            offset = index % bit_size\n+            return (valp.dereference() & (1 << offset)) > 0\n+        else:\n+            return obj['_M_impl']['_M_start'][index]\n+\n+class VectorEmptyWorker(VectorWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return int(self.size(obj)) == 0\n+\n+class VectorSizeWorker(VectorWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return self.size(obj)\n+\n+class VectorFrontWorker(VectorWorkerBase):\n+    def get_arg_types(self):\n+        return None\n+\n+    def __call__(self, obj):\n+        return self.get(obj, 0)\n+\n+class VectorBackWorker(VectorWorkerBase):\n+    def get_arg_types(self):\n+        return None\n \n+    def __call__(self, obj):\n+        return self.get(obj, int(self.size(obj)) - 1)\n+\n+class VectorAtWorker(VectorWorkerBase):\n+    def get_arg_types(self):\n+        return gdb.lookup_type('std::size_t')\n+\n+    def __call__(self, obj, index):\n+        size = int(self.size(obj))\n+        if int(index) >= size:\n+            raise IndexError('Vector index \"%d\" should not be >= %d.' %\n+                             ((int(index), size)))\n+        return self.get(obj, int(index))\n+\n+class VectorSubscriptWorker(VectorWorkerBase):\n     def get_arg_types(self):\n         return gdb.lookup_type('std::size_t')\n \n     def __call__(self, obj, subscript):\n-        return obj['_M_impl']['_M_start'][subscript]\n+        return self.get(obj, int(subscript))\n \n class VectorMethodsMatcher(gdb.xmethod.XMethodMatcher):\n     def __init__(self):\n         gdb.xmethod.XMethodMatcher.__init__(self,\n                                             matcher_name_prefix + 'vector')\n-        self._subscript_worker = VectorSubscriptWorker()\n-        self._size_worker = VectorSizeWorker()\n-        self.methods = [self._subscript_worker, self._size_worker]\n+        self._method_dict = {\n+            'size': LibStdCxxXMethod('size', VectorSizeWorker),\n+            'empty': LibStdCxxXMethod('empty', VectorEmptyWorker),\n+            'front': LibStdCxxXMethod('front', VectorFrontWorker),\n+            'back': LibStdCxxXMethod('back', VectorBackWorker),\n+            'at': LibStdCxxXMethod('at', VectorAtWorker),\n+            'operator[]': LibStdCxxXMethod('operator[]',\n+                                           VectorSubscriptWorker),\n+        }\n+        self.methods = [self._method_dict[m] for m in self._method_dict]\n \n     def match(self, class_type, method_name):\n         if not re.match('^std::vector<.*>$', class_type.tag):\n             return None\n-        if method_name == 'operator[]' and self._subscript_worker.enabled:\n-            return self._subscript_worker\n-        elif method_name == 'size' and self._size_worker.enabled:\n-            return self._size_worker\n+        method = self._method_dict.get(method_name)\n+        if method is None or not method.enabled:\n+            return None\n+        return method.worker_class(class_type.template_argument(0))\n \n # Xmethods for std::unique_ptr\n \n@@ -99,5 +460,9 @@ def match(self, class_type, method_name):\n             return self._get_worker\n \f\n def register_libstdcxx_xmethods(locus):\n+    gdb.xmethod.register_xmethod_matcher(locus, ArrayMethodsMatcher())\n+    gdb.xmethod.register_xmethod_matcher(locus, ForwardListMethodsMatcher())\n+    gdb.xmethod.register_xmethod_matcher(locus, DequeMethodsMatcher())\n+    gdb.xmethod.register_xmethod_matcher(locus, ListMethodsMatcher())\n     gdb.xmethod.register_xmethod_matcher(locus, VectorMethodsMatcher())\n     gdb.xmethod.register_xmethod_matcher(locus, UniquePtrMethodsMatcher())"}, {"sha": "b2d908414b8c90acbbb2eedb0544b54c43360f73", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/array.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Farray.cc?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++11 -g -O0\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <array>\n+\n+int\n+main ()\n+{\n+  std::array<int, 10> a;\n+  std::array<int, 0> a1;\n+\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 100 + i;\n+\n+// { dg-final { note-test a.size() 10 } }\n+// { dg-final { note-test a.empty() false } }\n+// { dg-final { note-test a1.empty() true } }\n+// { dg-final { note-test a1.size() 0 } }\n+// { dg-final { note-test a.front() 100 } }\n+// { dg-final { note-test a.back() 109 } }\n+// { dg-final { note-test a.at(5) 105 } }\n+// { dg-final { note-test a\\[0\\] 100 } }\n+// { dg-final { note-test a\\[4\\] 104 } }\n+// { dg-final { note-test a\\[9\\] 109 } }\n+\n+  return 0;  // Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT {} 1 } }"}, {"sha": "cc0d832e66e56a3ecc50f5b0d28e65fe34a1df57", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/deque.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fdeque.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fdeque.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fdeque.cc?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do run }\n+// { dg-options \"-g -O0\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <deque>\n+\n+const int max_deque_node_size = 512;\n+\n+int\n+main ()\n+{\n+  std::deque<int> q0, q1, q2, q3;\n+  int int_size = sizeof (int);\n+\n+  // The xmethod logic is exercised differently for deques of different size.\n+  // Let q1 be a deque requiring only 1 node. Let q2 be a deque filling up\n+  // exactly 2 nodes. Let q3 be of size which would require 1 node and part\n+  // of the second node.\n+  int q1_size = max_deque_node_size / int_size / 2;\n+  int q2_size = max_deque_node_size / int_size * 2;\n+  int q3_size = max_deque_node_size / int_size * 3 / 2;\n+\n+  for (int i = 0; i < q1_size; i++)\n+    q1.push_back (100 + i);\n+\n+  for (int i = 0; i < q2_size; i++)\n+    q2.push_back (200 + i);\n+\n+  for  (int i = 0; i < q3_size; i++)\n+    q3.push_back (300 + i);\n+\n+// { dg-final { note-test q0.empty() true } }\n+// { dg-final { note-test q1.empty() false } }\n+// { dg-final { note-test q0.size() 0 } }\n+// { dg-final { note-test q1.size()==q1_size true } }\n+// { dg-final { note-test q2.size()==q2_size true } }\n+// { dg-final { note-test q3.size()==q3_size true } }\n+// { dg-final { note-test q1.front() 100 } }\n+// { dg-final { note-test q2.front() 200 } }\n+// { dg-final { note-test q3.front() 300 } }\n+// { dg-final { note-test q1.back()==(100+q1_size-1) true } }\n+// { dg-final { note-test q2.back()==(200+q2_size-1) true } }\n+// { dg-final { note-test q3.back()==(300+q3_size-1) true } }\n+// { dg-final { note-test q3\\[0\\] 300 } }\n+// { dg-final { note-test q3\\[q3_size/2\\]==(300+q3_size/2) true } }\n+// { dg-final { note-test q3\\[q3_size-1]==(300+q3_size-1) true } }\n+\n+  return 0;  // Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT {} 1 } }"}, {"sha": "93e2770dfbf41b979c69ce1303bbde68bce7064d", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/forwardlist.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fforwardlist.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fforwardlist.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fforwardlist.cc?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+// { dg-options \"-std=gnu++11 -g -O0\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+\n+int\n+main ()\n+{\n+  std::forward_list<int> l0, l1;\n+\n+  l1.push_front (0);\n+  l1.push_front (1);\n+  l1.push_front (2);\n+  l1.push_front (11011);\n+\n+// { dg-final { note-test l0.empty() true } }\n+// { dg-final { note-test l1.empty() false } }\n+// { dg-final { note-test l1.front() 11011 } }\n+\n+  return 0;  // Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT {} 1 } }"}, {"sha": "fe056c4bd6348cba12e9014aee98ee5eb22b39c9", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/list.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Flist.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Flist.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Flist.cc?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+// { dg-options \"-g -O0\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <list>\n+\n+int\n+main ()\n+{\n+  std::list<int> l0, l1;\n+\n+  l1.push_back (123);\n+  l1.push_back (456);\n+  l1.push_back (789);\n+\n+// { dg-final { note-test l0.empty() true } }\n+// { dg-final { note-test l1.empty() false } }\n+// { dg-final { note-test l1.size() 3 } }\n+// { dg-final { note-test l1.front() 123 } }\n+// { dg-final { note-test l1.back() 789 } }\n+\n+\n+  return 0;  // Mark SPOT\n+}\n+\n+// { dg-final { gdb-test SPOT {} 1 } }"}, {"sha": "51ff0d4704ca8b778e1374e5c93935efbcccaa35", "filename": "libstdc++-v3/testsuite/libstdc++-xmethods/vector.cc", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fvector.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4027b0158d3e9249d9269f2eff144e76904cde8c/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fvector.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-xmethods%2Fvector.cc?ref=4027b0158d3e9249d9269f2eff144e76904cde8c", "patch": "@@ -23,14 +23,65 @@\n int\n main ()\n {\n-  std::vector<int> v;\n-  v.push_back(1);\n-  v.push_back(2);\n-  v.push_back(3);\n-// { dg-final { note-test v\\[0\\] 1 } }\n-// { dg-final { note-test v\\[1\\] 2 } }\n-// { dg-final { note-test v\\[2\\] 3 } }\n-// { dg-final { note-test v.size() 3 } }\n+  std::vector<int> v0, v1;\n+  std::vector<bool> bv0, bv1, bv2, bv3;\n+\n+  v1.push_back (1);\n+  v1.push_back (2);\n+  v1.push_back (3);\n+\n+  for (int i = 0; i < 15; i++)\n+    bv1.push_back (i % 3);\n+\n+  for (int i = 0; i < 64; i++)\n+    bv2.push_back (i % 2);\n+\n+  for (int i = 0; i < 65; i++)\n+    bv3.push_back (i % 2);\n+\n+// { dg-final { note-test v1\\[0\\] 1 } }\n+// { dg-final { note-test v1\\[1\\] 2 } }\n+// { dg-final { note-test v1\\[2\\] 3 } }\n+// { dg-final { note-test bv1\\[0\\] false } }\n+// { dg-final { note-test bv1\\[1\\] true } }\n+// { dg-final { note-test bv1\\[14\\] true } }\n+// { dg-final { note-test bv2\\[0\\] false } }\n+// { dg-final { note-test bv2\\[1\\] true } }\n+// { dg-final { note-test bv2\\[63\\] true } }\n+// { dg-final { note-test bv3\\[0\\] false } }\n+// { dg-final { note-test bv3\\[1\\] true } }\n+// { dg-final { note-test bv3\\[63\\] true } }\n+// { dg-final { note-test v0.size() 0 } }\n+// { dg-final { note-test bv0.size() 0 } }\n+// { dg-final { note-test v1.size() 3 } }\n+// { dg-final { note-test bv1.size() 15 } }\n+// { dg-final { note-test bv2.size() 64 } }\n+// { dg-final { note-test bv3.size() 65 } }\n+// { dg-final { note-test v0.empty() true } }\n+// { dg-final { note-test v1.empty() false } }\n+// { dg-final { note-test bv0.empty() true } }\n+// { dg-final { note-test bv1.empty() false } }\n+// { dg-final { note-test bv2.empty() false } }\n+// { dg-final { note-test bv3.empty() false } }\n+// { dg-final { note-test v1.front() 1 } }\n+// { dg-final { note-test v1.back() 3 } }\n+// { dg-final { note-test bv1.front() false } }\n+// { dg-final { note-test bv1.back() true } }\n+// { dg-final { note-test bv2.front() false } }\n+// { dg-final { note-test bv2.back() true } }\n+// { dg-final { note-test bv3.front() false } }\n+// { dg-final { note-test bv3.back() false } }\n+// { dg-final { note-test v1.at(1) 2 } }\n+// { dg-final { note-test bv1.at(0) false } }\n+// { dg-final { note-test bv1.at(1) true } }\n+// { dg-final { note-test bv1.at(14) true } }\n+// { dg-final { note-test bv2.at(0) false } }\n+// { dg-final { note-test bv2.at(1) true } }\n+// { dg-final { note-test bv2.at(63) true } }\n+// { dg-final { note-test bv3.at(0) false } }\n+// { dg-final { note-test bv3.at(1) true } }\n+// { dg-final { note-test bv3.at(63) true } }\n+// { dg-final { note-test bv3.at(64) false } }\n \n   return 0;  // Mark SPOT\n }"}]}