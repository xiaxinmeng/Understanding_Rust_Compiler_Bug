{"sha": "dfdf9085d31a1be25cd434328b0ba466c397edb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkZjkwODVkMzFhMWJlMjVjZDQzNDMyOGIwYmE0NjZjMzk3ZWRiMg==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2020-07-29T06:38:39Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-08-06T05:56:52Z"}, "message": "vect/rs6000: Support vector with length cost modeling\n\nThis patch is to add the cost modeling for vector with length,\nit mainly follows what we generate for vector with length in\nfunctions vect_set_loop_controls_directly and vect_gen_len\nat the worst case.\n\nFor Power, the length is expected to be in bits 0-7 (high bits),\nwe have to model the cost of shifting bits, which is implemented\nin adjust_vect_cost_per_loop.\n\nBootstrapped/regtested on powerpc64le-linux-gnu (P9) with explicit\nparam vect-partial-vector-usage=1.\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.c (rs6000_adjust_vect_cost_per_loop): New\n\tfunction.\n\t(rs6000_finish_cost): Call rs6000_adjust_vect_cost_per_loop.\n\t* tree-vect-loop.c (vect_estimate_min_profitable_iters): Add cost\n\tmodeling for vector with length.\n\t(vect_rgroup_iv_might_wrap_p): New function, factored out from...\n\t* tree-vect-loop-manip.c (vect_set_loop_controls_directly): ...this.\n\tUpdate function comment.\n\t* tree-vect-stmts.c (vect_gen_len): Update function comment.\n\t* tree-vectorizer.h (vect_rgroup_iv_might_wrap_p): New declare.", "tree": {"sha": "50358b2e48753081ce6f79663300fa576ea72af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50358b2e48753081ce6f79663300fa576ea72af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfdf9085d31a1be25cd434328b0ba466c397edb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdf9085d31a1be25cd434328b0ba466c397edb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfdf9085d31a1be25cd434328b0ba466c397edb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdf9085d31a1be25cd434328b0ba466c397edb2/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea858d09571f3f6dcce92d8bfaf077f9d44c6ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea858d09571f3f6dcce92d8bfaf077f9d44c6ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea858d09571f3f6dcce92d8bfaf077f9d44c6ad6"}], "stats": {"total": 142, "additions": 127, "deletions": 15}, "files": [{"sha": "d26a18f3ece2fb9c682fcde6b666be893ef24be1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dfdf9085d31a1be25cd434328b0ba466c397edb2", "patch": "@@ -5181,6 +5181,34 @@ rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n   return retval;\n }\n \n+/* For some target specific vectorization cost which can't be handled per stmt,\n+   we check the requisite conditions and adjust the vectorization cost\n+   accordingly if satisfied.  One typical example is to model shift cost for\n+   vector with length by counting number of required lengths under condition\n+   LOOP_VINFO_FULLY_WITH_LENGTH_P.  */\n+\n+static void\n+rs6000_adjust_vect_cost_per_loop (rs6000_cost_data *data)\n+{\n+  struct loop *loop = data->loop_info;\n+  gcc_assert (loop);\n+  loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n+\n+  if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n+    {\n+      rgroup_controls *rgc;\n+      unsigned int num_vectors_m1;\n+      unsigned int shift_cnt = 0;\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_LENS (loop_vinfo), num_vectors_m1, rgc)\n+\tif (rgc->type)\n+\t  /* Each length needs one shift to fill into bits 0-7.  */\n+\t  shift_cnt += num_vectors_m1 + 1;\n+\n+      rs6000_add_stmt_cost (loop_vinfo, (void *) data, shift_cnt, scalar_stmt,\n+\t\t\t    NULL, NULL_TREE, 0, vect_body);\n+    }\n+}\n+\n /* Implement targetm.vectorize.finish_cost.  */\n \n static void\n@@ -5190,7 +5218,10 @@ rs6000_finish_cost (void *data, unsigned *prologue_cost,\n   rs6000_cost_data *cost_data = (rs6000_cost_data*) data;\n \n   if (cost_data->loop_info)\n-    rs6000_density_test (cost_data);\n+    {\n+      rs6000_adjust_vect_cost_per_loop (cost_data);\n+      rs6000_density_test (cost_data);\n+    }\n \n   /* Don't vectorize minimum-vectorization-factor, simple copy loops\n      that require versioning for any reason.  The vectorization is at"}, {"sha": "47cfa6f4061a104e0baae24b25c738c0a2a58267", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=dfdf9085d31a1be25cd434328b0ba466c397edb2", "patch": "@@ -412,7 +412,11 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_controls *dest_rgm,\n \n    This means that we cannot guarantee that such an induction variable\n    would ever hit a value that produces a set of all-false masks or zero\n-   lengths for RGC.  */\n+   lengths for RGC.\n+\n+   Note: the cost of the code generated by this function is modeled\n+   by vect_estimate_min_profitable_iters, so changes here may need\n+   corresponding changes there.  */\n \n static tree\n vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n@@ -711,8 +715,6 @@ vect_set_loop_condition_partial_vectors (class loop *loop,\n   else\n     niters = gimple_convert (&preheader_seq, compare_type, niters);\n \n-  widest_int iv_limit = vect_iv_limit_for_partial_vectors (loop_vinfo);\n-\n   /* Iterate over all the rgroups and fill in their controls.  We could use\n      the first control from any rgroup for the loop condition; here we\n      arbitrarily pick the last.  */\n@@ -739,11 +741,7 @@ vect_set_loop_condition_partial_vectors (class loop *loop,\n \n \t/* See whether zero-based IV would ever generate all-false masks\n \t   or zero length before wrapping around.  */\n-\tunsigned nitems_per_iter = rgc->max_nscalars_per_iter * rgc->factor;\n-\tbool might_wrap_p\n-\t  = (iv_limit == -1\n-\t     || (wi::min_precision (iv_limit * nitems_per_iter, UNSIGNED)\n-\t\t > compare_precision));\n+\tbool might_wrap_p = vect_rgroup_iv_might_wrap_p (loop_vinfo, rgc);\n \n \t/* Set up all controls for this group.  */\n \ttest_ctrl = vect_set_loop_controls_directly (loop, loop_vinfo,"}, {"sha": "dba230f63204911b11fb70095ed50edc9f90db8e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=dfdf9085d31a1be25cd434328b0ba466c397edb2", "patch": "@@ -3798,6 +3798,58 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       (void) add_stmt_cost (loop_vinfo, target_cost_data, num_masks - 1,\n \t\t\t    vector_stmt, NULL, NULL_TREE, 0, vect_body);\n     }\n+  else if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n+    {\n+      /* Referring to the functions vect_set_loop_condition_partial_vectors\n+\t and vect_set_loop_controls_directly, we need to generate each\n+\t length in the prologue and in the loop body if required. Although\n+\t there are some possible optimizations, we consider the worst case\n+\t here.  */\n+\n+      bool niters_known_p = LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo);\n+      bool need_iterate_p\n+\t= (!LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n+\t   && !vect_known_niters_smaller_than_vf (loop_vinfo));\n+\n+      /* Calculate how many statements to be added.  */\n+      unsigned int prologue_stmts = 0;\n+      unsigned int body_stmts = 0;\n+\n+      rgroup_controls *rgc;\n+      unsigned int num_vectors_m1;\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_LENS (loop_vinfo), num_vectors_m1, rgc)\n+\tif (rgc->type)\n+\t  {\n+\t    /* May need one SHIFT for nitems_total computation.  */\n+\t    unsigned nitems = rgc->max_nscalars_per_iter * rgc->factor;\n+\t    if (nitems != 1 && !niters_known_p)\n+\t      prologue_stmts += 1;\n+\n+\t    /* May need one MAX and one MINUS for wrap around.  */\n+\t    if (vect_rgroup_iv_might_wrap_p (loop_vinfo, rgc))\n+\t      prologue_stmts += 2;\n+\n+\t    /* Need one MAX and one MINUS for each batch limit excepting for\n+\t       the 1st one.  */\n+\t    prologue_stmts += num_vectors_m1 * 2;\n+\n+\t    unsigned int num_vectors = num_vectors_m1 + 1;\n+\n+\t    /* Need to set up lengths in prologue, only one MIN required\n+\t       for each since start index is zero.  */\n+\t    prologue_stmts += num_vectors;\n+\n+\t    /* Each may need two MINs and one MINUS to update lengths in body\n+\t       for next iteration.  */\n+\t    if (need_iterate_p)\n+\t      body_stmts += 3 * num_vectors;\n+\t  }\n+\n+      (void) add_stmt_cost (loop_vinfo, target_cost_data, prologue_stmts,\n+\t\t\t    scalar_stmt, NULL, NULL_TREE, 0, vect_prologue);\n+      (void) add_stmt_cost (loop_vinfo, target_cost_data, body_stmts,\n+\t\t\t    scalar_stmt, NULL, NULL_TREE, 0, vect_body);\n+    }\n \n   /* FORNOW: The scalar outside cost is incremented in one of the\n      following ways:\n@@ -3932,8 +3984,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     }\n \n   /* ??? The \"if\" arm is written to handle all cases; see below for what\n-     we would do for !LOOP_VINFO_FULLY_MASKED_P.  */\n-  if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+     we would do for !LOOP_VINFO_USING_PARTIAL_VECTORS_P.  */\n+  if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       /* Rewriting the condition above in terms of the number of\n \t vector iterations (vniters) rather than the number of\n@@ -3960,7 +4012,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \tdump_printf (MSG_NOTE, \"  Minimum number of vector iterations: %d\\n\",\n \t\t     min_vec_niters);\n \n-      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n \t{\n \t  /* Now that we know the minimum number of vector iterations,\n \t     find the minimum niters for which the scalar cost is larger:\n@@ -4015,6 +4067,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       && min_profitable_iters < (assumed_vf + peel_iters_prologue))\n     /* We want the vectorized loop to execute at least once.  */\n     min_profitable_iters = assumed_vf + peel_iters_prologue;\n+  else if (min_profitable_iters < peel_iters_prologue)\n+    /* For LOOP_VINFO_USING_PARTIAL_VECTORS_P, we need to ensure the\n+       vectorized loop executes at least once.  */\n+    min_profitable_iters = peel_iters_prologue;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -4032,7 +4088,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   if (vec_outside_cost <= 0)\n     min_profitable_estimate = 0;\n-  else if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+  else if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n       /* This is a repeat of the code above, but with + SOC rather\n \t than - SOC.  */\n@@ -4044,7 +4100,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       if (outside_overhead > 0)\n \tmin_vec_niters = outside_overhead / saving_per_viter + 1;\n \n-      if (LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+      if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n \t{\n \t  int threshold = (vec_inside_cost * min_vec_niters\n \t\t\t   + vec_outside_cost\n@@ -9351,3 +9407,25 @@ vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo)\n   return iv_limit;\n }\n \n+/* For the given rgroup_controls RGC, check whether an induction variable\n+   would ever hit a value that produces a set of all-false masks or zero\n+   lengths before wrapping around.  Return true if it's possible to wrap\n+   around before hitting the desirable value, otherwise return false.  */\n+\n+bool\n+vect_rgroup_iv_might_wrap_p (loop_vec_info loop_vinfo, rgroup_controls *rgc)\n+{\n+  widest_int iv_limit = vect_iv_limit_for_partial_vectors (loop_vinfo);\n+\n+  if (iv_limit == -1)\n+    return true;\n+\n+  tree compare_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n+  unsigned int compare_precision = TYPE_PRECISION (compare_type);\n+  unsigned nitems = rgc->max_nscalars_per_iter * rgc->factor;\n+\n+  if (wi::min_precision (iv_limit * nitems, UNSIGNED) > compare_precision)\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "65e30bac4249d6a5fb18e4713556b4cee629a0e7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=dfdf9085d31a1be25cd434328b0ba466c397edb2", "patch": "@@ -12109,7 +12109,11 @@ vect_get_vector_types_for_stmt (vec_info *vinfo, stmt_vec_info stmt_info,\n    min_of_start_and_end = min (START_INDEX, END_INDEX);\n    left_len = END_INDEX - min_of_start_and_end;\n    rhs = min (left_len, LEN_LIMIT);\n-   LEN = rhs;  */\n+   LEN = rhs;\n+\n+   Note: the cost of the code generated by this function is modeled\n+   by vect_estimate_min_profitable_iters, so changes here may need\n+   corresponding changes there.  */\n \n gimple_seq\n vect_gen_len (tree len, tree start_index, tree end_index, tree len_limit)"}, {"sha": "7ab6d8234ac73f34dde09ed028d02fa9b3fa67b1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfdf9085d31a1be25cd434328b0ba466c397edb2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=dfdf9085d31a1be25cd434328b0ba466c397edb2", "patch": "@@ -1960,6 +1960,7 @@ extern tree vect_create_addr_base_for_vector_ref (vec_info *,\n \n /* In tree-vect-loop.c.  */\n extern widest_int vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo);\n+bool vect_rgroup_iv_might_wrap_p (loop_vec_info, rgroup_controls *);\n /* Used in tree-vect-loop-manip.c */\n extern void determine_peel_for_niter (loop_vec_info);\n /* Used in gimple-loop-interchange.c and tree-parloops.c.  */"}]}