{"sha": "266eb58af385276cae6011361178c827f812e40f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2ZWI1OGFmMzg1Mjc2Y2FlNjAxMTM2MTE3OGM4MjdmODEyZTQwZg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-01-22T19:12:22Z"}, "committer": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-01-22T19:12:22Z"}, "message": "PowerPC64 DImode patterns\n\nFrom-SVN: r11080", "tree": {"sha": "382790b806b4e17f58fda855220b86cf0b6480d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/382790b806b4e17f58fda855220b86cf0b6480d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266eb58af385276cae6011361178c827f812e40f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266eb58af385276cae6011361178c827f812e40f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266eb58af385276cae6011361178c827f812e40f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266eb58af385276cae6011361178c827f812e40f/comments", "author": null, "committer": null, "parents": [{"sha": "b73fd26c62b8c663b36f7953c4b35d60c07dbdcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73fd26c62b8c663b36f7953c4b35d60c07dbdcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73fd26c62b8c663b36f7953c4b35d60c07dbdcf"}], "stats": {"total": 1012, "additions": 889, "deletions": 123}, "files": [{"sha": "bd8c0d2c6a3bac8cb8e6013dfc23419809fe3930", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 889, "deletions": 123, "changes": 1012, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266eb58af385276cae6011361178c827f812e40f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266eb58af385276cae6011361178c827f812e40f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=266eb58af385276cae6011361178c827f812e40f", "patch": "@@ -3618,7 +3618,7 @@\n ;; (for example, having an input in 7,8 and an output in 6,7).  We\n ;; also allow for the the output being the same as one of the inputs.\n \n-(define_insn \"adddi3\"\n+(define_insn \"*adddi3_noppc64\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r,r,r\")\n \t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,0,0\")\n \t\t (match_operand:DI 2 \"reg_or_short_operand\" \"r,I,r,I\")))]\n@@ -3636,11 +3636,11 @@\n }\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"subddi3\"\n+(define_insn \"*subdi3_noppc64\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,&r,r,r,r\")\n \t(minus:DI (match_operand:DI 1 \"reg_or_short_operand\" \"r,I,0,r,I\")\n \t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r,r,0,0\")))]\n-  \"TARGET_POWER && ! TARGET_POWERPC64\"\n+  \"! TARGET_POWERPC64\"\n   \"*\n {\n   if (WORDS_BIG_ENDIAN)\n@@ -3654,13 +3654,7 @@\n }\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_expand \"negdi2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n+(define_insn \"*negdi2_noppc64\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n \t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))]\n   \"! TARGET_POWERPC64\"\n@@ -3831,156 +3825,875 @@\n   \"mulhw %0,%1,%2\"\n   [(set_attr \"type\" \"imul\")])\n \n-(define_insn \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(truncate:SI\n-\t (lshiftrt:DI (mult:DI (zero_extend:DI\n-\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t\t       (zero_extend:DI\n-\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n-\t\t      (const_int 32))))]\n-  \"TARGET_POWERPC\"\n-  \"mulhwu %0,%1,%2\"\n-  [(set_attr \"type\" \"imul\")])\n+(define_insn \"umulsi3_highpart\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (zero_extend:DI\n+\t\t\t\t(match_operand:SI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (zero_extend:DI\n+\t\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))]\n+  \"TARGET_POWERPC\"\n+  \"mulhwu %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n+;; If operands 0 and 2 are in the same register, we have a problem.  But\n+;; operands 0 and 1 (the usual case) can be in the same register.  That's\n+;; why we have the strange constraints below.\n+(define_insn \"ashldi3_power\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,&r\")\n+\t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r,0,r\")\n+\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"M,i,r,r\")))\n+   (clobber (match_scratch:SI 3 \"=X,q,q,q\"))]\n+  \"TARGET_POWER\"\n+  \"@\n+   {sli|slwi} %0,%L1,%h2\\;{cal %L0,0(0)|li %L0,0}\n+   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n+   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n+   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"lshrdi3_power\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r,r,&r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r,0,r\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"M,i,r,r\")))\n+   (clobber (match_scratch:SI 3 \"=X,q,q,q\"))]\n+  \"TARGET_POWER\"\n+  \"@\n+   {cal %0,0(0)|li %0,0}\\;{s%A2i|s%A2wi} %L0,%1,%h2\n+   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\n+   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\n+   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\"\n+  [(set_attr \"length\" \"8\")])\n+\n+;; Shift by a variable amount is too complex to be worth open-coding.  We\n+;; just handle shifts by constants.\n+(define_insn \"ashrdi3_power\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"M,i\")))\n+   (clobber (match_scratch:SI 3 \"=X,q\"))]\n+  \"TARGET_POWER\"\n+  \"@\n+   {srai|srawi} %0,%1,31\\;{srai|srawi} %L0,%1,%h2\n+   sraiq %0,%1,%h2\\;srliq %L0,%L1,%h2\"\n+  [(set_attr \"length\" \"8\")])\n+\f\n+;; PowerPC64 DImode operations.\n+\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_POWERPC64 && non_add_cint_operand (operands[2], DImode))\n+    FAIL;\n+}\")\n+\n+;; Discourage ai/addic because of carry but provide it in an alternative\n+;; allowing register zero as source.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,?r,r\")\n+\t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,b,r,b\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"r,I,I,J\")))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   add %0,%1,%2\n+   addi %0,%1,%2\n+   addic %0,%1,%2\n+   addis %0,%1,%u2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n+\t(compare:CC (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r,r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   add. %3,%1,%2\n+   addic. %3,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x\")\n+\t(compare:CC (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r\")\n+\t\t\t     (match_operand:DI 2 \"reg_or_short_operand\" \"r,I\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(plus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   add. %0,%1,%2\n+   addic. %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+;; Split an add that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.  Note that the low-order\n+;; add should be last in case the result gets used in an address.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:DI 2 \"non_add_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n+\"\n+{\n+  int low = INTVAL (operands[2]) & 0xffff;\n+  int high = (unsigned) INTVAL (operands[2]) >> 16;\n+\n+  if (low & 0x8000)\n+    high++, low |= 0xffff0000;\n+\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, high << 16);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, low);\n+}\")\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"nor %0,%1,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 2 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"nor. %2,%1,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(not:DI (match_dup 1)))]\n+  \"TARGET_POWERPC64\"\n+  \"nor. %0,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(minus:DI (match_operand:DI 1 \"reg_or_short_operand\" \"r,I\")\n+\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r,r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   subf %0,%2,%1\n+   subfic %0,%2,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (minus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t      (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"subf. %3,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (minus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t      (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(minus:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"subf. %0,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(minus:DI (match_operand:DI 1 \"reg_or_short_operand\" \"\")\n+\t\t  (match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      emit_insn (gen_adddi3 (operands[0], operands[1],\n+\t\t\t     negate_rtx (DImode, operands[2])));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"absdi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n+\t(abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))\n+   (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"sradi %2,%1,31\\;xor %0,%2,%1\\;subf %0,%2,%0\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n+\t(abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\")))\n+   (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n+  \"TARGET_POWERPC64 && reload_completed\"\n+  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 31)))\n+   (set (match_dup 0) (xor:DI (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (minus:DI (match_dup 2) (match_dup 0)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n+\t(neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\"))))\n+   (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"sradi %2,%1,31\\;xor %0,%2,%1\\;subf %0,%0,%2\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r\")\n+\t(neg:DI (abs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,0\"))))\n+   (clobber (match_scratch:DI 2 \"=&r,&r\"))]\n+  \"TARGET_POWERPC64 && reload_completed\"\n+  [(set (match_dup 2) (ashiftrt:DI (match_dup 1) (const_int 31)))\n+   (set (match_dup 0) (xor:DI (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (minus:DI (match_dup 0) (match_dup 2)))]\n+  \"\")\n+\n+(define_expand \"negdi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"neg %0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 2 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"neg. %2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (neg:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(neg:DI (match_dup 1)))]\n+  \"TARGET_POWERPC64\"\n+  \"neg. %0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"ffsdi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r\")\n+\t(ffs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"neg %0,%1\\;and %0,%0,%1\\;cntlzd %0,%0\\;subfic %0,%0,64\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(mult:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"mulld %0,%1,%2\"\n+   [(set_attr \"type\" \"imul\")])\n+\n+(define_insn \"smuldi3_highpart\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:DI\n+\t (lshiftrt:TI (mult:TI (sign_extend:TI\n+\t\t\t\t(match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (sign_extend:TI\n+\t\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 64))))]\n+  \"TARGET_POWERPC64\"\n+  \"mulhd %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n+(define_insn \"umuldi3_highpart\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(truncate:DI\n+\t (lshiftrt:TI (mult:TI (zero_extend:TI\n+\t\t\t\t(match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t       (zero_extend:TI\n+\t\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t      (const_int 64))))]\n+  \"TARGET_POWERPC64\"\n+  \"mulhdu %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n+(define_expand \"divdi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && exact_log2 (INTVAL (operands[2])) >= 0)\n+    ;\n+  else\n+    operands[2] = force_reg (DImode, operands[2]);\n+}\")\n+\n+(define_expand \"moddi3\"\n+  [(use (match_operand:DI 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:DI 2 \"reg_or_cint_operand\" \"\"))]\n+  \"TARGET_POWERPC64\"\n+  \"\n+{\n+  int i = exact_log2 (INTVAL (operands[2]));\n+  rtx temp1;\n+  rtx temp2;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT || i < 0)\n+    FAIL;\n+\n+  temp1 = gen_reg_rtx (DImode);\n+  temp2 = gen_reg_rtx (DImode);\n+\n+  emit_insn (gen_divdi3 (temp1, operands[1], operands[2]));\n+  emit_insn (gen_ashldi3 (temp2, temp1, GEN_INT (i)));\n+  emit_insn (gen_subdi3 (operands[0], operands[1], temp2));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t(match_operand:DI 2 \"const_int_operand\" \"N\")))]\n+  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"sradi %0,%1,%p2\\;addze %0,%0\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"N\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"sradi %3,%1,%p2\\;addze. %3,%3\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"N\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(div:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"sradi %0,%1,%p2\\;addze. %0,%0\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+        (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"divd %0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")])\n+\n+(define_insn \"udivdi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+        (udiv:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POWERPC64\"\n+  \"divdu %0,%1,%2\"\n+  [(set_attr \"type\" \"idiv\")])\n+\n+(define_insn \"rotldi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl %0,%1,%h2,0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %3,%1,%h2,0\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(rotate:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"rld%I2cl. %0,%1,%h2,0\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_expand \"ashldi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64 || TARGET_POWER\"\n+  \"\n+{\n+  if (TARGET_POWERPC64)\n+    ;\n+  else if (TARGET_POWER)\n+    {\n+      emit_insn (gen_ashldi3_power (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n+  \"TARGET_POWERPC64\"\n+  \"sld%I2 %0,%1,%2\"\n+  [(set_attr \"length\" \"8\")])\n+  \n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"sld%I2. %3,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+  \n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ashift:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"sld%I2. %0,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64 || TARGET_POWER\"\n+  \"\n+{\n+  if (TARGET_POWERPC64)\n+    ;\n+  else if (TARGET_POWER)\n+    {\n+      emit_insn (gen_lshrdi3_power (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n+  \"TARGET_POWERPC64\"\n+  \"srd%I2 %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"srd%I2. %3,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(lshiftrt:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"srd%I2. %0,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_expand \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64 || TARGET_POWER\"\n+  \"\n+{\n+  if (TARGET_POWERPC64)\n+    ;\n+  else if (TARGET_POWER && GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      emit_insn (gen_ashrdi3_power (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\")))]\n+  \"TARGET_POWERPC64\"\n+  \"srad%I2 %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"srad%I2. %3,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ashiftrt:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"srad%I2. %0,%1,%2\"\n+  [(set_attr \"type\" \"delayed_compare\")])\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t\t(match_operand:DI 2 \"and_operand\" \"?r,K,J\")))\n+   (clobber (match_scratch:CC 3 \"=X,x,x\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   and %0,%1,%2\n+   andi. %0,%1,%b2\n+   andis. %0,%1,%u2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and_operand\" \"r,K,J\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r,r,r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   and. %3,%1,%2\n+   andi. %3,%1,%b2\n+   andis. %3,%1,%u2\"\n+  [(set_attr \"type\" \"compare,compare,compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x\")\n+\t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t\t\t    (match_operand:DI 2 \"and_operand\" \"r,K,J\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(and:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   and. %0,%1,%2\n+   andi. %0,%1,%b2\n+   andis. %0,%1,%u2\"\n+  [(set_attr \"type\" \"compare,compare,compare\")])\n+\n+;; Take a AND with a constant that cannot be done in a single insn and try to\n+;; split it into two insns.  This does not verify that the insns are valid\n+;; since this need not be done as combine will do it.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"non_and_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  [(set (match_dup 0) (and:DI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (and:DI (match_dup 0) (match_dup 4)))]\n+  \"\n+{\n+  int maskval = INTVAL (operands[2]);\n+  int i, transitions, last_bit_value;\n+  int orig = maskval, first_c = maskval, second_c;\n+\n+  /* We know that MASKVAL must have more than 2 bit-transitions.  Start at\n+     the low-order bit and count for the third transition.  When we get there,\n+     make a first mask that has everything to the left of that position\n+     a one.  Then make the second mask to turn off whatever else is needed.  */\n+\n+  for (i = 1, transitions = 0, last_bit_value = maskval & 1; i < 32; i++)\n+    {\n+      if (((maskval >>= 1) & 1) != last_bit_value)\n+\tlast_bit_value ^= 1, transitions++;\n+\n+      if (transitions > 2)\n+\t{\n+\t  first_c |= (~0) << i;\n+\t  break;\n+\t}\n+    }\n+\n+  second_c = orig | ~ first_c;\n+\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode, first_c);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, second_c);\n+}\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t\t(match_operand:DI 2 \"logical_operand\" \"r,K,J\")))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   or %0,%1,%2\n+   ori %0,%1,%b2\n+   oris %0,%1,%u2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"or. %3,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"or. %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+;; Split an IOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"non_logical_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  [(set (match_dup 0) (ior:DI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (ior:DI (match_dup 0) (match_dup 4)))]\n+\"\n+{\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n+}\")\n \n-;; If operands 0 and 2 are in the same register, we have a problem.  But\n-;; operands 0 and 1 (the usual case) can be in the same register.  That's\n-;; why we have the strange constraints below.\n-(define_insn \"ashldi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r,&r\")\n-\t(ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r,0,r\")\n-\t\t   (match_operand:SI 2 \"reg_or_cint_operand\" \"M,i,r,r\")))\n-   (clobber (match_scratch:SI 3 \"=X,q,q,q\"))]\n-  \"TARGET_POWER\"\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\")\n+\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r,r,r\")\n+\t\t(match_operand:DI 2 \"logical_operand\" \"r,K,J\")))]\n+  \"TARGET_POWERPC64\"\n   \"@\n-   {sli|slwi} %0,%L1,%h2\\;{cal %L0,0(0)|li %L0,0}\n-   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n-   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\n-   sl%I2q %L0,%L1,%h2\\;sll%I2q %0,%1,%h2\"\n-  [(set_attr \"length\" \"8\")])\n+   xor %0,%1,%2\n+   xori %0,%1,%b2\n+   xoris %0,%1,%u2\")\n \n-(define_insn \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r,r,r,&r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r,0,r\")\n-\t\t     (match_operand:SI 2 \"reg_or_cint_operand\" \"M,i,r,r\")))\n-   (clobber (match_scratch:SI 3 \"=X,q,q,q\"))]\n-  \"TARGET_POWER\"\n-  \"@\n-   {cal %0,0(0)|li %0,0}\\;{s%A2i|s%A2wi} %L0,%1,%h2\n-   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\n-   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\n-   sr%I2q %0,%1,%h2\\;srl%I2q %L0,%L1,%h2\"\n-  [(set_attr \"length\" \"8\")])\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"xor. %3,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n \n-;; Shift by a variable amount is too complex to be worth open-coding.  We\n-;; just handle shifts by constants.\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(xor:DI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"xor. %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n \n-(define_expand \"ashrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t(match_operand:SI 2 \"general_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 3 \"\"))])]\n-  \"TARGET_POWER\"\n-  \"\n-{ if (GET_CODE (operands[2]) != CONST_INT)\n-    FAIL;\n+;; Split an XOR that we can't do in one insn into two insns, each of which\n+;; does one 16-bit part.  This is used by combine.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t(match_operand:DI 2 \"non_logical_cint_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  [(set (match_dup 0) (xor:DI (match_dup 1) (match_dup 3)))\n+   (set (match_dup 0) (xor:DI (match_dup 0) (match_dup 4)))]\n+\"\n+{\n+  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t INTVAL (operands[2]) & 0xffff0000);\n+  operands[4] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0xffff);\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"M,i\")))\n-   (clobber (match_scratch:SI 3 \"=X,q\"))]\n-  \"TARGET_POWER\"\n-  \"@\n-   {srai|srawi} %0,%1,31\\;{srai|srawi} %L0,%1,%h2\n-   sraiq %0,%1,%h2\\;srliq %L0,%L1,%h2\"\n-  [(set_attr \"length\" \"8\")])\n-\f\n-;; PowerPC64 DImode operations.\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n+   \"TARGET_POWERPC64\"\n+   \"eqv %0,%1,%2\")\n \n-(define_insn \"ffsdi2\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=&r\")\n-\t(ffs:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_POWERPC64\"\n-  \"neg %0,%1\\;and %0,%0,%1\\;cntlzd %0,%0\\;subfic %0,%0,64\"\n-  [(set_attr \"length\" \"16\")])\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+   \"TARGET_POWERPC64\"\n+   \"eqv. %3,%1,%2\"\n+   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"muldi3\"\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (not:DI (xor:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n+\t\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_dup 1) (match_dup 2))))]\n+   \"TARGET_POWERPC64\"\n+   \"eqv. %0,%1,%2\"\n+   [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(mult:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+\t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64\"\n-  \"mulld %0,%1,%2\"\n-   [(set_attr \"type\" \"imul\")])\n+  \"andc %0,%2,%1\")\n \n-(define_insn \"smuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (sign_extend:TI\n-\t\t\t\t(match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t\t       (sign_extend:TI\n-\t\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n-\t\t      (const_int 64))))]\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n   \"TARGET_POWERPC64\"\n-  \"mulhd %0,%1,%2\"\n-  [(set_attr \"type\" \"imul\")])\n+  \"andc. %3,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"umuldi3_highpart\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(truncate:DI\n-\t (lshiftrt:TI (mult:TI (zero_extend:TI\n-\t\t\t\t(match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n-\t\t\t       (zero_extend:TI\n-\t\t\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n-\t\t      (const_int 64))))]\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:DI (not:DI (match_dup 1)) (match_dup 2)))]\n   \"TARGET_POWERPC64\"\n-  \"mulhdu %0,%1,%2\"\n-  [(set_attr \"type\" \"imul\")])\n+  \"andc. %0,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"divdi3\"\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-        (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+\t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC64\"\n-  \"divd %0,%1,%2\"\n-  [(set_attr \"type\" \"idiv\")])\n+  \"orc %0,%2,%1\")\n \n-(define_insn \"udivdi3\"\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"orc. %3,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\"))\n+\t\t\t    (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_dup 1)) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"orc. %0,%2,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-        (udiv:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n+\t(ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"TARGET_POWERPC64\"\n-  \"divdu %0,%1,%2\"\n-  [(set_attr \"type\" \"idiv\")])\n+  \"nand %0,%1,%2\")\n \n-(define_insn \"rotldi3\"\n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t    (const_int 0)))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_POWERPC64\"\n+  \"nand. %3,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n+\t(compare:CC (ior:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n+\t\t    (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n+  \"TARGET_POWERPC64\"\n+  \"nand. %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\")))]\n+\t(and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t(not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))))]\n   \"TARGET_POWERPC64\"\n-  \"rld%I2cl %0,%1,%h2,0\")\n+  \"nor %0,%1,%2\")\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x\")\n-\t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 3 \"=r\"))]\n   \"TARGET_POWERPC64\"\n-  \"rld%I2cl. %3,%1,%h2,0\"\n-  [(set_attr \"type\" \"delayed_compare\")])\n+  \"nor. %3,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x\")\n-\t(compare:CC (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t\t       (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n+\t(compare:CC (and:DI (not:DI (match_operand:DI 1 \"gpc_reg_operand\" \"%r\"))\n+\t\t\t    (not:DI (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(rotate:DI (match_dup 1) (match_dup 2)))]\n+\t(and:DI (not:DI (match_dup 1)) (not:DI (match_dup 2))))]\n   \"TARGET_POWERPC64\"\n-  \"rld%I2cl. %0,%1,%h2,0\"\n-  [(set_attr \"type\" \"delayed_compare\")])\n+  \"nor. %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n \f\n ;; Now define ways of moving data around.\n \n@@ -6002,6 +6715,25 @@\n   DONE;\n }\")\n \n+(define_expand \"cmpdi\"\n+  [(set (cc0)\n+        (compare (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+  \t\t (match_operand:DI 1 \"reg_or_short_operand\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  \"\n+{\n+  /* Take care of the possibility that operands[1] might be negative but\n+     this might be a logical operation.  That insn doesn't exist.  */\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) < 0)\n+    operands[1] = force_reg (DImode, operands[1]);\n+\n+  rs6000_compare_op0 = operands[0];\n+  rs6000_compare_op1 = operands[1];\n+  rs6000_compare_fp_p = 0;\n+  DONE;\n+}\")\n+\n (define_expand \"cmpsf\"\n   [(set (cc0) (compare (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t\t       (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n@@ -6319,6 +7051,14 @@\n   \"{cmp%I2|cmpw%I2} %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"reg_or_short_operand\" \"rI\")))]\n+  \"TARGET_POWERPC64\"\n+  \"cmpd%I2 %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n ;; If we are comparing a register for equality with a large constant,\n ;; we can do this with an XOR followed by a compare.  But we need a scratch\n ;; register for the result of the XOR.\n@@ -6355,6 +7095,14 @@\n   \"{cmpl%I2|cmplw%I2} %0,%1,%W2\"\n   [(set_attr \"type\" \"compare\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:CCUNS 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCUNS (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t       (match_operand:DI 2 \"reg_or_u_short_operand\" \"rI\")))]\n+  \"\"\n+  \"cmpld%I2 %0,%1,%W2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n ;; The following two insns don't exist as single insns, but if we provide\n ;; them, we can swap an add and compare, which will enable us to overlap more\n ;; of the required delay between a compare and branch.  We generate code for\n@@ -7606,6 +8354,14 @@\n    {br|blr}\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n+(define_insn \"\"\n+  [(set (pc) (match_operand:DI 0 \"register_operand\" \"c,l\"))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   bctr\n+   {br|blr}\"\n+  [(set_attr \"type\" \"jmpreg\")])\n+\n ;; Table jump for switch statements:\n (define_expand \"tablejump\"\n   [(set (match_dup 3)\n@@ -7630,6 +8386,16 @@\n    {br|blr}\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n+(define_insn \"\"\n+  [(set (pc)\n+\t(match_operand:DI 0 \"register_operand\" \"c,l\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   bctr\n+   {br|blr}\"\n+  [(set_attr \"type\" \"jmpreg\")])\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\""}]}