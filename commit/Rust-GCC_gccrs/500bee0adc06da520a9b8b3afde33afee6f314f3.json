{"sha": "500bee0adc06da520a9b8b3afde33afee6f314f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAwYmVlMGFkYzA2ZGE1MjBhOWI4YjNhZmRlMzNhZmVlNmYzMTRmMw==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-04-23T02:22:27Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-04-23T02:22:27Z"}, "message": "line-map.h (struct line_maps): New field highest_line.\n\n\n\t* line-map.h (struct line_maps):  New field highest_line.\n\t(linemap_position_for_column):  Make non-inline function.\n\t(LINEMAP_POSITION_FOR_COLUMN):  New macro.\n\t* line-map.c (linemap_init):  Clear highest_line field.\n\t(linemap_add):  Set highest_line field.\n\t(linemap_line_start):  Minor optimization - use highest_line field.\n\tReduce maximum column hint to 10000.  Update highest_line field.\n\t(linemap_position_for_column):  Moved from line-map.h.  Optimize a bit.\n\t* cpphash.h (struct cpp_reader):  Remove line field - instead use\n\tline_table->highest_line.\n\t(saved_line):  Remove unused field.\n\t(CPP_INCREMENT_FILE):  Don't do linemap_lookup - just use newest map.\n\tUse  line_table's highest_line field instead of cpp_reader's line.\n\t* cpplib.c (start_directive):  Likewise use highest_line field.\n\t(do_line, do_linemarker):  Likewise just use newest map.\n\t(_cpp_do_file_change):  Don't need to set cpp_reader's line field.\n\t* cpperror.c (cpp_error):  Likewise use highest_line field.\n\t* cppfiles.c (open_file_failed:  Likewise.\n\t(cpp_make_system_header):  Likewise use newest map and highest_line.\n\t* cppinit.c (cpp_create_reader):  Don't initialize removed field.\n\t* cpplex.c (_cpp_process_line_notes, _cpp_skip_block_comment,\n\tskip_line_comment, skip_whitespace, _cpp_get_fresh_line,\n\t_cpp_lex_direct):  Likewise use highest_line.\n\t(_cpp_lex_direct):  Use new LINEMAP_POSITION_FOR_COLUMN macro.\n\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise use highest_line,\n\tand use newest map.\n\t* cpppch.c (cpp_read_state):  Don't save+restore cpp_reader's line.\n\t* cpptrad.c (_cpp_overlay_buffer):  Don't save cpp_reader's line.\n\t(copy_comment, _cpp_scan_out_logical_line):  Likewise use highest_line.\n\nFrom-SVN: r81074", "tree": {"sha": "04a13ceb8485dc1405388eb42a55f0a9c7a8ebbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04a13ceb8485dc1405388eb42a55f0a9c7a8ebbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/500bee0adc06da520a9b8b3afde33afee6f314f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500bee0adc06da520a9b8b3afde33afee6f314f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500bee0adc06da520a9b8b3afde33afee6f314f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500bee0adc06da520a9b8b3afde33afee6f314f3/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9344fdb9407d69218d02c2e509a358e80cf64eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9344fdb9407d69218d02c2e509a358e80cf64eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9344fdb9407d69218d02c2e509a358e80cf64eb6"}], "stats": {"total": 191, "additions": 117, "deletions": 74}, "files": [{"sha": "aac5802e8c665ef8f338664863f161ecfe65169d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -1,3 +1,35 @@\n+2004-04-22  Per Bothner  <per@bothner.com>\n+\n+\t* line-map.h (struct line_maps):  New field highest_line.\n+\t(linemap_position_for_column):  Make non-inline function.\n+\t(LINEMAP_POSITION_FOR_COLUMN):  New macro.\n+\t* line-map.c (linemap_init):  Clear highest_line field.\n+\t(linemap_add):  Set highest_line field.\n+\t(linemap_line_start):  Minor optimization - use highest_line field.\n+\tReduce maximum column hint to 10000.  Update highest_line field.\n+\t(linemap_position_for_column):  Moved from line-map.h.  Optimize a bit.\n+\t* cpphash.h (struct cpp_reader):  Remove line field - instead use\n+\tline_table->highest_line.\n+\t(saved_line):  Remove unused field.\n+\t(CPP_INCREMENT_FILE):  Don't do linemap_lookup - just use newest map.\n+\tUse  line_table's highest_line field instead of cpp_reader's line.\n+\t* cpplib.c (start_directive):  Likewise use highest_line field.\n+\t(do_line, do_linemarker):  Likewise just use newest map.\n+\t(_cpp_do_file_change):  Don't need to set cpp_reader's line field.\n+\t* cpperror.c (cpp_error):  Likewise use highest_line field.\n+\t* cppfiles.c (open_file_failed:  Likewise.\n+\t(cpp_make_system_header):  Likewise use newest map and highest_line.\n+\t* cppinit.c (cpp_create_reader):  Don't initialize removed field.\n+\t* cpplex.c (_cpp_process_line_notes, _cpp_skip_block_comment,\n+\tskip_line_comment, skip_whitespace, _cpp_get_fresh_line,\n+\t_cpp_lex_direct):  Likewise use highest_line.\n+\t(_cpp_lex_direct):  Use new LINEMAP_POSITION_FOR_COLUMN macro.\n+\t* cppmacro.c (_cpp_builtin_macro_text):  Likewise use highest_line,\n+\tand use newest map.\n+\t* cpppch.c (cpp_read_state):  Don't save+restore cpp_reader's line.\n+\t* cpptrad.c (_cpp_overlay_buffer):  Don't save cpp_reader's line.\n+\t(copy_comment, _cpp_scan_out_logical_line):  Likewise use highest_line.\n+\n 2004-04-23  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR bootstrap/14992"}, {"sha": "362c1c5f2e00d2da41ae7131d32e0b2513bca519", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -144,7 +144,7 @@ cpp_error (cpp_reader * pfile, int level, const char *msgid, ...)\n       if (pfile->state.in_directive)\n \tsrc_loc = pfile->directive_line;\n       else\n-\tsrc_loc = pfile->line;\n+\tsrc_loc = pfile->line_table->highest_line;\n     }\n   else\n     {"}, {"sha": "bdfaa3f9ac6f14e4f70e3a95cb5f54cf2d13d28b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -806,7 +806,7 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n static void\n open_file_failed (cpp_reader *pfile, _cpp_file *file)\n {\n-  int sysp = pfile->line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;\n+  int sysp = pfile->line_table->highest_line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;\n   bool print_dep = CPP_OPTION (pfile, deps.style) > !!sysp;\n \n   errno = file->err_no;\n@@ -987,14 +987,15 @@ void\n cpp_make_system_header (cpp_reader *pfile, int syshdr, int externc)\n {\n   int flags = 0;\n-  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n+  const struct line_maps *line_table = pfile->line_table;\n+  const struct line_map *map = &line_table->maps[line_table->used-1];\n \n   /* 1 = system header, 2 = system header to be treated as C.  */\n   if (syshdr)\n     flags = 1 + (externc != 0);\n   pfile->buffer->sysp = flags;\n   _cpp_do_file_change (pfile, LC_RENAME, map->to_file,\n-\t\t       SOURCE_LINE (map, pfile->line), flags);\n+\t\t       SOURCE_LINE (map, pfile->line_table->highest_line), flags);\n }\n \n /* Allow the client to change the current file.  Used by the front end"}, {"sha": "1c5015173e0d87ad0d7c988abe6c40c2920dd580", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -65,10 +65,10 @@ typedef unsigned char uchar;\n #define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n \n #define CPP_INCREMENT_LINE(PFILE, COLS_HINT) do { \\\n-    const struct line_map *map \\\n-      = linemap_lookup (PFILE->line_table, PFILE->line); \\\n-    unsigned int line = SOURCE_LINE (map, PFILE->line) + 1; \\\n-    PFILE->line = linemap_line_start (PFILE->line_table, line, COLS_HINT); \\\n+    const struct line_maps *line_table = PFILE->line_table; \\\n+    const struct line_map *map = &line_table->maps[line_table->used-1]; \\\n+    unsigned int line = SOURCE_LINE (map, line_table->highest_line); \\\n+    linemap_line_start (PFILE->line_table, line + 1, COLS_HINT); \\\n   } while (0)\n \n /* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n@@ -344,7 +344,6 @@ struct cpp_reader\n \n   /* Source line tracking.  */\n   struct line_maps *line_table;\n-  fileline line;\n \n   /* The line of the '#' of the current directive.  */\n   fileline directive_line;\n@@ -466,10 +465,6 @@ struct cpp_reader\n   /* Used for buffer overlays by cpptrad.c.  */\n   const uchar *saved_cur, *saved_rlimit, *saved_line_base;\n \n-  /* Used to save the original line number during traditional\n-     preprocessing.  */\n-  unsigned int saved_line;\n-\n   /* A saved list of the defined macros, for dependency checking\n      of precompiled headers.  */\n   struct cpp_savedstate *savedstate;"}, {"sha": "55323b4ea9b4f238827f8486dcdcfe379b693163", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -172,10 +172,8 @@ cpp_create_reader (enum c_lang lang, hash_table *table,\n      other entries are correct zero-initialized.  */\n   pfile->no_search_path.name = (char *) \"\";\n \n-  /* Initialize the line map.  Start at logical line 1, so we can use\n-     a line number of zero for special states.  */\n+  /* Initialize the line map.  */\n   pfile->line_table = line_table;\n-  pfile->line = 1;\n \n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);"}, {"sha": "d03096cdc638c8e4e2d580304cc40347106f9516", "filename": "gcc/cpplex.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -270,12 +270,12 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n       if (note->type == '\\\\' || note->type == ' ')\n \t{\n \t  if (note->type == ' ' && !in_comment)\n-\t    cpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line, col,\n+\t    cpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line_table->highest_line, col,\n \t\t\t\t \"backslash and newline separated by space\");\n \n \t  if (buffer->next_line > buffer->rlimit)\n \t    {\n-\t      cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line, col,\n+\t      cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line_table->highest_line, col,\n \t\t\t\t   \"backslash-newline at end of file\");\n \t      /* Prevent \"no newline at end of file\" warning.  */\n \t      buffer->next_line = buffer->rlimit;\n@@ -290,14 +290,14 @@ _cpp_process_line_notes (cpp_reader *pfile, int in_comment)\n \t      && (!in_comment || warn_in_comment (pfile, note)))\n \t    {\n \t      if (CPP_OPTION (pfile, trigraphs))\n-\t\tcpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line, col,\n+\t\tcpp_error_with_line (pfile, CPP_DL_WARNING, pfile->line_table->highest_line, col,\n \t\t\t\t     \"trigraph ??%c converted to %c\",\n \t\t\t\t     note->type,\n \t\t\t\t     (int) _cpp_trigraph_map[note->type]);\n \t      else\n \t\t{\n \t\t  cpp_error_with_line \n-\t\t    (pfile, CPP_DL_WARNING, pfile->line, col,\n+\t\t    (pfile, CPP_DL_WARNING, pfile->line_table->highest_line, col,\n \t\t     \"trigraph ??%c ignored, use -trigraphs to enable\",\n \t\t     note->type);\n \t\t}\n@@ -343,7 +343,7 @@ _cpp_skip_block_comment (cpp_reader *pfile)\n \t    {\n \t      buffer->cur = cur;\n \t      cpp_error_with_line (pfile, CPP_DL_WARNING,\n-\t\t\t\t   pfile->line, CPP_BUF_COL (buffer),\n+\t\t\t\t   pfile->line_table->highest_line, CPP_BUF_COL (buffer),\n \t\t\t\t   \"\\\"/*\\\" within comment\");\n \t    }\n \t}\n@@ -375,13 +375,13 @@ static int\n skip_line_comment (cpp_reader *pfile)\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned int orig_line = pfile->line;\n+  unsigned int orig_line = pfile->line_table->highest_line;\n \n   while (*buffer->cur != '\\n')\n     buffer->cur++;\n \n   _cpp_process_line_notes (pfile, true);\n-  return orig_line != pfile->line;\n+  return orig_line != pfile->line_table->highest_line;\n }\n \n /* Skips whitespace, saving the next non-whitespace character.  */\n@@ -400,7 +400,7 @@ skip_whitespace (cpp_reader *pfile, cppchar_t c)\n       else if (c == '\\0')\n \tsaw_NUL = true;\n       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))\n-\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line,\n+\tcpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line_table->highest_line,\n \t\t\t     CPP_BUF_COL (buffer),\n \t\t\t     \"%s in preprocessing directive\",\n \t\t\t     c == '\\f' ? \"form feed\" : \"vertical tab\");\n@@ -777,7 +777,7 @@ _cpp_get_fresh_line (cpp_reader *pfile)\n \t{\n \t  /* Only warn once.  */\n \t  buffer->next_line = buffer->rlimit;\n-\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line,\n+\t  cpp_error_with_line (pfile, CPP_DL_PEDWARN, pfile->line_table->highest_line,\n \t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur),\n \t\t\t       \"no newline at end of file\");\n \t}\n@@ -828,7 +828,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t  if (!pfile->state.in_directive)\n \t    {\n \t      /* Tell the compiler the line number of the EOF token.  */\n-\t      result->src_loc = pfile->line;\n+\t      result->src_loc = pfile->line_table->highest_line;\n \t      result->flags = BOL;\n \t    }\n \t  return result;\n@@ -845,19 +845,19 @@ _cpp_lex_direct (cpp_reader *pfile)\n     }\n   buffer = pfile->buffer;\n  update_tokens_line:\n-  result->src_loc = pfile->line;\n+  result->src_loc = pfile->line_table->highest_line;\n \n  skipped_white:\n   if (buffer->cur >= buffer->notes[buffer->cur_note].pos\n       && !pfile->overlaid_buffer)\n     {\n       _cpp_process_line_notes (pfile, false);\n-      result->src_loc = pfile->line;\n+      result->src_loc = pfile->line_table->highest_line;\n     }\n   c = *buffer->cur++;\n \n-  result->src_loc = linemap_position_for_column (pfile->line_table,\n-\t\t\t\t\t\t CPP_BUF_COLUMN (buffer, buffer->cur));\n+  LINEMAP_POSITION_FOR_COLUMN (result->src_loc, pfile->line_table,\n+\t\t\t       CPP_BUF_COLUMN (buffer, buffer->cur));\n \n   switch (c)\n     {"}, {"sha": "808dcdaa2b1ebfd535e15c5d6c5c58dcef998a84", "filename": "gcc/cpplib.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -228,7 +228,7 @@ start_directive (cpp_reader *pfile)\n   pfile->state.save_comments = 0;\n \n   /* Some handlers need the position of the # for diagnostics.  */\n-  pfile->directive_line = pfile->line;\n+  pfile->directive_line = pfile->line_table->highest_line;\n }\n \n /* Called when leaving a directive, _Pragma or command-line directive.  */\n@@ -777,7 +777,8 @@ strtoul_for_line (const uchar *str, unsigned int len, long unsigned int *nump)\n static void\n do_line (cpp_reader *pfile)\n {\n-  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n+  const struct line_maps *line_table = pfile->line_table;\n+  const struct line_map *map = &line_table->maps[line_table->used - 1];\n   const cpp_token *token;\n   const char *new_file = map->to_file;\n   unsigned long new_lineno;\n@@ -827,7 +828,8 @@ do_line (cpp_reader *pfile)\n static void\n do_linemarker (cpp_reader *pfile)\n {\n-  const struct line_map *map = linemap_lookup (pfile->line_table, pfile->line);\n+  const struct line_maps *line_table = pfile->line_table;\n+  const struct line_map *map = &line_table->maps[line_table->used - 1];\n   const cpp_token *token;\n   const char *new_file = map->to_file;\n   unsigned long new_lineno;\n@@ -907,10 +909,8 @@ _cpp_do_file_change (cpp_reader *pfile, enum lc_reason reason,\n {\n   const struct line_map *map = linemap_add (pfile->line_table, reason, sysp,\n \t\t\t\t\t    to_file, file_line);\n-  if (map == NULL)\n-    pfile->line = 0;\n-  else\n-    pfile->line = linemap_line_start (pfile->line_table, map->to_line, 127);\n+  if (map != NULL)\n+    linemap_line_start (pfile->line_table, map->to_line, 127);\n \n   if (pfile->cb.file_change)\n     pfile->cb.file_change (pfile, map);"}, {"sha": "e3d0dc37b29fd896f3c2cdc99ca59f1cb2abffb1", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -133,7 +133,7 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n \tunsigned int len;\n \tconst char *name;\n \tuchar *buf;\n-\tmap = linemap_lookup (pfile->line_table, pfile->line);\n+\tmap = linemap_lookup (pfile->line_table, pfile->line_table->highest_line);\n \n \tif (node->value.builtin == BT_BASE_FILE)\n \t  while (! MAIN_FILE_P (map))\n@@ -158,12 +158,12 @@ _cpp_builtin_macro_text (cpp_reader *pfile, cpp_hashnode *node)\n       break;\n \n     case BT_SPECLINE:\n-      map = linemap_lookup (pfile->line_table, pfile->line);\n+      map = &pfile->line_table->maps[pfile->line_table->used-1];\n       /* If __LINE__ is embedded in a macro, it must expand to the\n \t line of the macro's invocation, not its definition.\n \t Otherwise things like assert() will not work properly.  */\n       if (CPP_OPTION (pfile, traditional))\n-\tnumber = pfile->line;\n+\tnumber = pfile->line_table->highest_line;\n       else\n \tnumber = pfile->cur_token[-1].src_loc;\n       number = SOURCE_LINE (map, number);"}, {"sha": "815235c6c4053ef9d53a01592343b57f674a573c", "filename": "gcc/cpppch.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpppch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpppch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpppch.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -618,7 +618,6 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n   struct lexer_state old_state;\n   struct save_macro_item *d;\n   size_t i, mac_count;\n-  int saved_line = r->line;\n \n   /* Restore spec_nodes, which will be full of references to the old \n      hashtable entries and so will now be invalid.  */\n@@ -707,7 +706,6 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n     }\n \n   r->state = old_state;\n-  r->line = saved_line;\n   free (defn);\n   defn = NULL;\n "}, {"sha": "e2b11cb41158b5f09be1d856605cf0c881f8cc27", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -148,7 +148,7 @@ static const uchar *\n copy_comment (cpp_reader *pfile, const uchar *cur, int in_define)\n {\n   bool unterminated, copy = false;\n-  source_location src_loc = pfile->line;\n+  source_location src_loc = pfile->line_table->highest_line;\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->cur = cur;\n@@ -271,7 +271,6 @@ _cpp_overlay_buffer (cpp_reader *pfile, const uchar *start, size_t len)\n   pfile->saved_cur = buffer->cur;\n   pfile->saved_rlimit = buffer->rlimit;\n   pfile->saved_line_base = buffer->next_line;\n-  pfile->saved_line = pfile->line;\n   buffer->need_line = false;\n \n   buffer->cur = start;\n@@ -360,7 +359,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n   CUR (pfile->context) = pfile->buffer->cur;\n   RLIMIT (pfile->context) = pfile->buffer->rlimit;\n   pfile->out.cur = pfile->out.base;\n-  pfile->out.first_line = pfile->line;\n+  pfile->out.first_line = pfile->line_table->highest_line;\n   /* start_of_input_line is needed to make sure that directives really,\n      really start at the first character of the line.  */\n   start_of_input_line = pfile->buffer->cur;\n@@ -488,7 +487,7 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro)\n \t\t    {\n \t\t      maybe_start_funlike (pfile, node, out_start, &fmacro);\n \t\t      lex_state = ls_fun_open;\n-\t\t      fmacro.line = pfile->line;\n+\t\t      fmacro.line = pfile->line_table->highest_line;\n \t\t      continue;\n \t\t    }\n \t\t  else if (!recursive_macro (pfile, node))"}, {"sha": "e7d41b652e0914054905cca9907ceca520f0a7ac", "filename": "gcc/line-map.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -40,6 +40,7 @@ linemap_init (struct line_maps *set)\n   set->depth = 0;\n   set->cache = 0;\n   set->highest_location = 0;\n+  set->highest_line = 0;\n   set->max_column_hint = 0;\n }\n \n@@ -154,6 +155,7 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   set->cache = set->used++;\n   map->column_bits = 0;\n   set->highest_location = start_location;\n+  set->highest_line = start_location;\n   set->max_column_hint = 0;\n \n   if (reason == LC_ENTER)\n@@ -181,7 +183,7 @@ linemap_line_start (struct line_maps *set, unsigned int to_line,\n   struct line_map *map = &set->maps[set->used - 1];\n   source_location highest = set->highest_location;\n   source_location r;\n-  unsigned int last_line = SOURCE_LINE (map, highest);\n+  unsigned int last_line = SOURCE_LINE (map, set->highest_line);\n   int line_delta = to_line - last_line;\n   bool add_map = false;\n   if (line_delta < 0\n@@ -196,7 +198,7 @@ linemap_line_start (struct line_maps *set, unsigned int to_line,\n   if (add_map)\n     {\n       int column_bits;\n-      if (max_column_hint > 1000000 || highest > 0xC0000000)\n+      if (max_column_hint > 100000 || highest > 0xC0000000)\n \t{\n \t  max_column_hint = 0;\n \t  if (highest >0xF0000000)\n@@ -221,12 +223,36 @@ linemap_line_start (struct line_maps *set, unsigned int to_line,\n   else\n     r = highest - SOURCE_COLUMN (map, highest)\n       + (line_delta << map->column_bits);\n+  set->highest_line = r;\n   if (r > set->highest_location)\n     set->highest_location = r;\n   set->max_column_hint = max_column_hint;\n   return r;\n }\n \n+source_location\n+linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n+{\n+  source_location r = set->highest_line;\n+  if (to_column >= set->max_column_hint)\n+    {\n+      if (r >= 0xC000000 || to_column > 100000)\n+\t{\n+\t  /* Running low on source_locations - disable column numbers.  */\n+\t  return r;\n+\t}\n+      else\n+\t{\n+\t  struct line_map *map = &set->maps[set->used - 1];\n+\t  r = linemap_line_start (set, SOURCE_LINE (map, r), to_column + 50);\n+\t}\n+    }\n+  r = r + to_column;\n+  if (r >= set->highest_location)\n+    set->highest_location = r;\n+  return r;\n+}\n+\n /* Given a logical line, returns the map from which the corresponding\n    (source file, line) pair can be deduced.  Since the set is built\n    chronologically, the logical lines are monotonic increasing, and so"}, {"sha": "73631be229f3dacbc6891913741e27be38e9b593", "filename": "gcc/line-map.h", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500bee0adc06da520a9b8b3afde33afee6f314f3/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=500bee0adc06da520a9b8b3afde33afee6f314f3", "patch": "@@ -84,6 +84,9 @@ struct line_maps\n   /* Highest source_location \"given out\".  */\n   source_location highest_location;\n \n+  /* Start of line of highest source_location \"given out\".  */\n+  source_location highest_line;\n+\n   /* The maximum column number we can quickly allocate.  Higher numbers\n      may require allocating a new line_map.  */\n   unsigned int max_column_hint;\n@@ -157,32 +160,23 @@ extern void linemap_print_containing_files (struct line_maps *,\n /* Nonzero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n \n-/* Get a source position that for the same line as the most recent\n+/* Set LOC to a source position that is the same line as the most recent\n    linemap_line_start, but with the specified TO_COLUMN column number.  */\n \n-static inline source_location\n-linemap_position_for_column (struct line_maps *set, unsigned int to_column)\n-{\n-  struct line_map *map = &set->maps[set->used - 1];\n-  source_location r = set->highest_location;\n-  if (__builtin_expect (to_column > set->max_column_hint, 0))\n-    {\n-      if (r >= 0xC000000 || to_column > 1000000) /* FIXME */\n-\t{\n-\t  /* Running low on source_locations - disable column numbers.  */\n-\t  return r - SOURCE_COLUMN (map, r);\n-\t}\n-      else\n-\t{\n-\t  r = linemap_line_start (set, SOURCE_LINE (map, r), to_column + 50);\n-\t  map = &set->maps[set->used - 1];\n-\t  r = set->highest_location;\n-\t}\n-    }\n-  r = r - SOURCE_COLUMN (map, r) + to_column;\n-  if (r >= set->highest_location)\n-    set->highest_location = r;\n-  return r;\n-}\n-\t\t\t\t\t\t  \n+#define LINEMAP_POSITION_FOR_COLUMN(LOC, SET, TO_COLUMN) { \\\n+  unsigned int to_column = (TO_COLUMN); \\\n+  struct line_maps *set = (SET); \\\n+  if (__builtin_expect (to_column >= set->max_column_hint, 0)) \\\n+    (LOC) = linemap_position_for_column (set, to_column); \\\n+  else { \\\n+    source_location r = set->highest_line; \\\n+    r = r + to_column; \\\n+    if (r >= set->highest_location) \\\n+      set->highest_location = r; \\\n+    (LOC) = r;\t\t\t \\\n+  }}\n+    \n+\n+extern source_location\n+linemap_position_for_column (struct line_maps *set, unsigned int to_column);\n #endif /* !GCC_LINE_MAP_H  */"}]}