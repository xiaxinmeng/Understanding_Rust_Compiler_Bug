{"sha": "3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JkZjVhZDEzODUyYWFhODcxYWI0MWE2ZThmNTA5ODA5YzhjMTA0ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-05-31T18:37:31Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-05-31T18:37:31Z"}, "message": "Makefile.in (c-decl.o): Depend on rtl.h and expr.h.\n\n\t* Makefile.in (c-decl.o): Depend on rtl.h and expr.h.\n\t* alias.c (struct alias_entry): alias_set is HOST_WIDE_INT.\n\t(REG_BASE_VALUE): Remove unneeded cast to unsigned.\n\t(get_alias_set_entry): ALIAS_SET arg is HOST_WIDE_INT.\n\t(find_base_decl): New function, from c_find_base_decl in c-common.c.\n\t(new_alias_set): Moved from tree.c; return is HOST_WIDE_INT.\n\t(get_alias_set): Likewise.\n\tMajor rework to do more things and allow language-specific code\n\tto just handle special-cases.\n\t(record_alias_subset): Args are HOST_WIDE_INT.\n\t(record_component_alias): Local vars are HOST_WIDE_INT.\n\tDon't handle COMPLEX_EXPR.\n\t(get_varargs_alias_set): Moved from builtins.c.\n\t(get_frame_alias_set): New function.\n\t* builtins.c (expand_builtin_return_address): Use frame alias set.\n\t(expand_builtin_setjmp, expand_builtin_longjmp): Use alias set\n\tfor setjmp buffer.\n\t(get_memory_rtx): Rework to use set_mem_attributes.\n\t(get_varargs_alias_set): Deleted from here.\n\t* c-common.c (c_apply_type_quals_to_decl): Alias sets now HOST_WIDE_INT.\n\t(c_find_base_decl): Deleted from here.\n\t(c_get_alias_set): Remove many cases and rework to just handle\n\tC-specific cases.\n\t* c-common.h (c_get_alias_set): Returns HOST_WIDE_INT.\n\t* c-decl.c (rtl.h, expr.h): Now included.\n\t(init_decl_processing): Call record_component_aliases on array types.\n\t(grokdeclarator): Likewise.\n\tSet TREE_ADDRESSABLE for all fields that are not bitfields.\n\t* c-typeck.c (common_type): Call record_component_aliases for array.\n\t* caller-save.c (setup_save_areas): Rework register loop for unsigned.\n\tSet all save areas to the frame alias set.\n\t* calls.c (initialie_argument_information): Call set_mem_attributes.\n\t(compute_argument_addresses, expand_call): Likewise.\n\t* explow.c (set_mem_attributes): New function.\n\t(stabilize): Use MEM_COPY_ATTRIBUTES and force_reg.\n\t* expr.c (struct move_by_pieces): Remove {to,from}_{struct,readonly}.\n\tLEN and OFFSET now HOST_WIDE_INT.\n\t(clear_by_pieces): Similar changes.\n\t(move_by_pieces): LEN now HOST_WIDE_INT; don't set deleted fields.\n\t(move_by_pieces_ninsns): Now returns unsigned HOST_WIDE_INT.\n\t(move_by_pieces_1): Don't use deleted fields, use MEM_COPY_ATTRIBUTES.\n\t(clear_by_pieces_1): Likewise.\n\t(emit_push_insn): Call set_mem_attributes.\n\t(expand_expr, case INDIRECT_REF): Likewise.\n\t(expand_expr, case VAR_DECL): Call change_address.\n\t* expr.h (ADD_PARM_SIZE, SUB_PARM_SIZE): Use host_integerp and\n\ttree_low_cst.\n\t(get_varargs_alias_set, get_frame_alias_set): New decls.\n\t(record_base_value, record_alias_subset, lang_get_alias_set): Likewise.\n\t(new_alias_set, set_mem_attributes): Likewse.\n\t* function.c (struct temp_slot): ALIAS_SET is HOST_WIDE_INT.\n\t(assign_stack_temp_for_type): Likewise.\n\tCan split slot even if alias set since can copy.\n\tSet MEM_ALIAS_SET and MEM_SET_IN_STRUCT_P.\n\t(assign_temp): Use host_integerp and tree_low_cst.\n\t(put_var_into_stack): Properly handle SAVE_EXPR.\n\t(put_addressof_into_stack): Likewise.\n\t(assign_parms): Call set_mem_attributes.\n\tDelete #if 0 code.\n\t(fix_lexical_address): Put reference to chain into frame alias set.\n\t(expand_function_start): Call set_mem_attributes.\n\t* integrate.c (expand_inline_function): Likewise.\n\t* recog.c (adj_offsettable_operand): Use MEM_COPY_ATTRIBUTES.\n\t* regmove.c (try_apply_stack_adjustment): Likewise.\n\t* reload.c (push_reload, make_memloc): Likewise.\n\t* reload1.c (alter_reg): Make alias sets for spilled pseudos.\n\t* rtl.def (MEM): Update comment.\n\t* rtl.h (MEM_ALIAS_SET): Now uses XCWINT.\n\t(move_by_pieces): Change length to HOST_WIDE_INT.\n\t(record_base_value, record_alias_subset): Delete from here.\n\t* stmt.c (expand_decl): Call set_mem_attributes.\n\t* stor-layout.c (finish_record_layout): Call record_component_aliases.i\n\t* toplev.c (compile_file): Call init_alias_once earlier.\n\t* tree.c (lang_get_alias_set, get_alias_set, new_alias_set): Deleted\n\tfrom here: now in alias.c.\n\t* tree.h (struct tree_type): alias_set is HOST_WIDE_INT.\n\t(struct tree_decl): Likewise.\n\t(get_alias_set, new_alias_set, lang_get_alias_set): Deleted from here.\n\t* varasm.c (make_function_rtl, make_decl_rtl): Call set_mem_attributes.\n\t(output_constant_def, force_const_mem): Likewise.\n\t* cp/Makefile.in (decl.o): Include ../expr.h.\n\t* cp/decl.c (expr.h): Include.\n\t(init_decl_processing): Call record_component_aliases for arrays.\n\t(grokdeclarator): Likewise.\n\tSet TREE_ADDRESSABLE for fields that aren't bitfields.\n\t* cp/tree.c (build_cplus_array_type_1): Call record_component_aliases.\n\nFrom-SVN: r34305", "tree": {"sha": "b0b7fe92ad1922c85f0e4c70693ee5b33b128261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b7fe92ad1922c85f0e4c70693ee5b33b128261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/comments", "author": null, "committer": null, "parents": [{"sha": "99923eedd0700c7055810224f548f70bcd009267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99923eedd0700c7055810224f548f70bcd009267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99923eedd0700c7055810224f548f70bcd009267"}], "stats": {"total": 1316, "additions": 739, "deletions": 577}, "files": [{"sha": "62555cb6ea2a6dff05c849ab5245794d4e5c4d45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -32,6 +32,87 @@ Wed May 31 13:17:20 2000  Philippe De Muyter  <phdm@macqel.be>\n \n Wed May 31 08:07:52 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* Makefile.in (c-decl.o): Depend on rtl.h and expr.h.\n+\t* alias.c (struct alias_entry): alias_set is HOST_WIDE_INT.\n+\t(REG_BASE_VALUE): Remove unneeded cast to unsigned.\n+\t(get_alias_set_entry): ALIAS_SET arg is HOST_WIDE_INT.\n+\t(find_base_decl): New function, from c_find_base_decl in c-common.c.\n+\t(new_alias_set): Moved from tree.c; return is HOST_WIDE_INT.\n+\t(get_alias_set): Likewise.\n+\tMajor rework to do more things and allow language-specific code\n+\tto just handle special-cases.\n+\t(record_alias_subset): Args are HOST_WIDE_INT.\n+\t(record_component_alias): Local vars are HOST_WIDE_INT.\n+\tDon't handle COMPLEX_EXPR.\n+\t(get_varargs_alias_set): Moved from builtins.c.\n+\t(get_frame_alias_set): New function.\n+\t* builtins.c (expand_builtin_return_address): Use frame alias set.\n+\t(expand_builtin_setjmp, expand_builtin_longjmp): Use alias set\n+\tfor setjmp buffer.\n+\t(get_memory_rtx): Rework to use set_mem_attributes.\n+\t(get_varargs_alias_set): Deleted from here.\n+\t* c-common.c (c_apply_type_quals_to_decl): Alias sets now HOST_WIDE_INT.\n+\t(c_find_base_decl): Deleted from here.\n+\t(c_get_alias_set): Remove many cases and rework to just handle\n+\tC-specific cases.\n+\t* c-common.h (c_get_alias_set): Returns HOST_WIDE_INT.\n+\t* c-decl.c (rtl.h, expr.h): Now included.\n+\t(init_decl_processing): Call record_component_aliases on array types.\n+\t(grokdeclarator): Likewise.\n+\tSet TREE_ADDRESSABLE for all fields that are not bitfields.\n+\t* c-typeck.c (common_type): Call record_component_aliases for array.\n+\t* caller-save.c (setup_save_areas): Rework register loop for unsigned.\n+\tSet all save areas to the frame alias set.\n+\t* calls.c (initialie_argument_information): Call set_mem_attributes.\n+\t(compute_argument_addresses, expand_call): Likewise.\n+\t* explow.c (set_mem_attributes): New function.\n+\t(stabilize): Use MEM_COPY_ATTRIBUTES and force_reg.\n+\t* expr.c (struct move_by_pieces): Remove {to,from}_{struct,readonly}.\n+\tLEN and OFFSET now HOST_WIDE_INT.\n+\t(clear_by_pieces): Similar changes.\n+\t(move_by_pieces): LEN now HOST_WIDE_INT; don't set deleted fields.\n+\t(move_by_pieces_ninsns): Now returns unsigned HOST_WIDE_INT.\n+\t(move_by_pieces_1): Don't use deleted fields, use MEM_COPY_ATTRIBUTES.\n+\t(clear_by_pieces_1): Likewise.\n+\t(emit_push_insn): Call set_mem_attributes.\n+\t(expand_expr, case INDIRECT_REF): Likewise.\n+\t(expand_expr, case VAR_DECL): Call change_address.\n+\t* expr.h (ADD_PARM_SIZE, SUB_PARM_SIZE): Use host_integerp and\n+\ttree_low_cst.\n+\t(get_varargs_alias_set, get_frame_alias_set): New decls.\n+\t(record_base_value, record_alias_subset, lang_get_alias_set): Likewise.\n+\t(new_alias_set, set_mem_attributes): Likewse.\n+\t* function.c (struct temp_slot): ALIAS_SET is HOST_WIDE_INT.\n+\t(assign_stack_temp_for_type): Likewise.\n+\tCan split slot even if alias set since can copy.\n+\tSet MEM_ALIAS_SET and MEM_SET_IN_STRUCT_P.\n+\t(assign_temp): Use host_integerp and tree_low_cst.\n+\t(put_var_into_stack): Properly handle SAVE_EXPR.\n+\t(put_addressof_into_stack): Likewise.\n+\t(assign_parms): Call set_mem_attributes.\n+\tDelete #if 0 code.\n+\t(fix_lexical_address): Put reference to chain into frame alias set.\n+\t(expand_function_start): Call set_mem_attributes.\n+\t* integrate.c (expand_inline_function): Likewise.\n+\t* recog.c (adj_offsettable_operand): Use MEM_COPY_ATTRIBUTES.\n+\t* regmove.c (try_apply_stack_adjustment): Likewise.\n+\t* reload.c (push_reload, make_memloc): Likewise.\n+\t* reload1.c (alter_reg): Make alias sets for spilled pseudos.\n+\t* rtl.def (MEM): Update comment.\n+\t* rtl.h (MEM_ALIAS_SET): Now uses XCWINT.\n+\t(move_by_pieces): Change length to HOST_WIDE_INT.\n+\t(record_base_value, record_alias_subset): Delete from here.\n+\t* stmt.c (expand_decl): Call set_mem_attributes.\n+\t* stor-layout.c (finish_record_layout): Call record_component_aliases.i\n+\t* toplev.c (compile_file): Call init_alias_once earlier.\n+\t* tree.c (lang_get_alias_set, get_alias_set, new_alias_set): Deleted\n+\tfrom here: now in alias.c.\n+\t* tree.h (struct tree_type): alias_set is HOST_WIDE_INT.\n+\t(struct tree_decl): Likewise.\n+\t(get_alias_set, new_alias_set, lang_get_alias_set): Deleted from here.\n+\t* varasm.c (make_function_rtl, make_decl_rtl): Call set_mem_attributes.\n+\t(output_constant_def, force_const_mem): Likewise.\n+\t\n \t* flow.c (propagate_block): If block has no successors, stores to\n \tframe are dead if not used.\n "}, {"sha": "f131dabafbfde73ac294fae825dde62a6c4759f0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1092,12 +1092,13 @@ $(srcdir)/c-gperf.h: c-parse.gperf\n \texit 1 )\n \t $(SHELL) $(srcdir)/move-if-change tmp-gperf.h $(srcdir)/c-gperf.h\n \n-c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h $(GGC_H) \\\n-    c-lex.h flags.h function.h output.h toplev.h defaults.h\n+c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n+    c-common.h $(GGC_H) c-lex.h flags.h function.h output.h expr.h toplev.h \\\n+    defaults.h\n c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n     flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h\n-c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h $(GGC_H) \\\n-    c-lex.h toplev.h output.h function.h\n+c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n+    $(GGC_H)  c-lex.h toplev.h output.h function.h\n c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n     c-common.h $(srcdir)/c-parse.h $(srcdir)/c-gperf.h c-pragma.h input.h \\\n     intl.h flags.h toplev.h output.h mbchar.h $(GGC_H)"}, {"sha": "feed5415ad83c9d015ce920ba815b5cf580f26a9", "filename": "gcc/alias.c", "status": "modified", "additions": 210, "deletions": 16, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -57,10 +57,10 @@ Boston, MA 02111-1307, USA.  */\n     In this situation we say the alias set for `struct S' is the\n    `superset' and that those for `int' and `double' are `subsets'.\n \n-   To see whether two alias sets can point to the same memory, we must go\n-   down the list of decendents of each and see if there is some alias set\n-   in common.  We need not trace past immediate decendents, however, since\n-   we propagate all grandchildren up one level.\n+   To see whether two alias sets can point to the same memory, we must\n+   see if either alias set is a subset of the other. We need not trace\n+   past immediate decendents, however, since we propagate all\n+   grandchildren up one level.\n \n    Alias set zero is implicitly a superset of all other alias sets.\n    However, this is no actual entry for alias set zero.  It is an\n@@ -69,7 +69,7 @@ Boston, MA 02111-1307, USA.  */\n typedef struct alias_set_entry\n {\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n-  int alias_set;\n+  HOST_WIDE_INT alias_set;\n \n   /* The children of the alias set.  These are not just the immediate\n      children, but, in fact, all decendents.  So, if we have:\n@@ -81,6 +81,10 @@ typedef struct alias_set_entry\n   splay_tree children;\n } *alias_set_entry;\n \n+/* The language-specific function for alias analysis.  If NULL, the\n+   language does not do any special alias analysis.  */\n+HOST_WIDE_INT (*lang_get_alias_set) PARAMS ((tree));\n+\n static int rtx_equal_for_memref_p\tPARAMS ((rtx, rtx));\n static rtx find_symbolic_term\t\tPARAMS ((rtx));\n static rtx get_addr\t\t\tPARAMS ((rtx));\n@@ -93,9 +97,10 @@ static int base_alias_check\t\tPARAMS ((rtx, rtx, enum machine_mode,\n static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n-static alias_set_entry get_alias_set_entry PARAMS ((int));\n+static tree find_base_decl            PARAMS ((tree));\n+static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n-\t\t\t\t\t\t      int (*)(rtx)));\n+\t\t\t\t\t\t      int (*) (rtx)));\n static int aliases_everything_p         PARAMS ((rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_reference_p         PARAMS ((rtx));\n@@ -140,7 +145,7 @@ static rtx *new_reg_base_value;\n static unsigned int reg_base_value_size; /* size of reg_base_value array */\n \n #define REG_BASE_VALUE(X) \\\n-  ((unsigned) REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n+  (REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n \n /* Vector of known invariant relationships between registers.  Set in\n    loop unrolling.  Indexed by register number, if nonzero the value\n@@ -187,7 +192,7 @@ static splay_tree alias_sets;\n \n static alias_set_entry\n get_alias_set_entry (alias_set)\n-     int alias_set;\n+     HOST_WIDE_INT alias_set;\n {\n   splay_tree_node sn\n     = splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n@@ -236,8 +241,7 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n   if (MEM_ALIAS_SET (mem1) == MEM_ALIAS_SET (mem2))\n     return 0;\n \n-  /* Iterate through each of the children of the first alias set,\n-     comparing it with the second alias set.  */\n+  /* See if the first alias set is a subset of the second.  */\n   ase = get_alias_set_entry (MEM_ALIAS_SET (mem1));\n   if (ase != 0 && splay_tree_lookup (ase->children,\n \t\t\t\t     (splay_tree_key) MEM_ALIAS_SET (mem2)))\n@@ -266,6 +270,168 @@ insert_subset_children (node, data)\n \n   return 0;\n }\n+\f\n+/* T is an expression with pointer type.  Find the DECL on which this\n+   expression is based.  (For example, in `a[i]' this would be `a'.)\n+   If there is no such DECL, or a unique decl cannot be determined,\n+   NULL_TREE is retured.  */\n+\n+static tree\n+find_base_decl (t)\n+     tree t;\n+{\n+  tree d0, d1, d2;\n+\n+  if (t == 0 || t == error_mark_node || ! POINTER_TYPE_P (TREE_TYPE (t)))\n+    return 0;\n+\n+  /* If this is a declaration, return it.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+    return t;\n+\n+  /* Handle general expressions.  It would be nice to deal with\n+     COMPONENT_REFs here.  If we could tell that `a' and `b' were the\n+     same, then `a->f' and `b->f' are also the same.  */\n+  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+    {\n+    case '1':\n+      return find_base_decl (TREE_OPERAND (t, 0));\n+\n+    case '2':\n+      /* Return 0 if found in neither or both are the same.  */\n+      d0 = find_base_decl (TREE_OPERAND (t, 0));\n+      d1 = find_base_decl (TREE_OPERAND (t, 1));\n+      if (d0 == d1)\n+\treturn d0;\n+      else if (d0 == 0)\n+\treturn d1;\n+      else if (d1 == 0)\n+\treturn d0;\n+      else\n+\treturn 0;\n+\n+    case '3':\n+      d0 = find_base_decl (TREE_OPERAND (t, 0));\n+      d1 = find_base_decl (TREE_OPERAND (t, 1));\n+      d0 = find_base_decl (TREE_OPERAND (t, 0));\n+      d2 = find_base_decl (TREE_OPERAND (t, 2));\n+\n+      /* Set any nonzero values from the last, then from the first.  */\n+      if (d1 == 0) d1 = d2;\n+      if (d0 == 0) d0 = d1;\n+      if (d1 == 0) d1 = d0;\n+      if (d2 == 0) d2 = d1;\n+\n+      /* At this point all are nonzero or all are zero.  If all three are the\n+\t same, return it.  Otherwise, return zero.  */\n+      return (d0 == d1 && d1 == d2) ? d0 : 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return the alias set for T, which may be either a type or an\n+   expression.  Call language-specific routine for help, if needed.  */\n+\n+HOST_WIDE_INT\n+get_alias_set (t)\n+     tree t;\n+{\n+  HOST_WIDE_INT set;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int volatilep, unsignedp;\n+  unsigned int alignment;\n+\n+  /* If we're not doing any alias analysis, just assume everything\n+     aliases everything else.  Also return 0 if this or its type is\n+     an error.  */\n+  if (! flag_strict_aliasing || t == error_mark_node\n+      || (! TYPE_P (t)\n+\t  && (TREE_TYPE (t) == 0 || TREE_TYPE (t) == error_mark_node)))\n+    return 0;\n+\n+  /* We can be passed either an expression or a type.  This and the\n+     language-specific routine may make mutually-recursive calls to\n+     each other to figure out what to do.  At each juncture, we see if\n+     this is a tree that the language may need to handle specially.\n+     But first remove nops since we care only about the actual object.  */\n+  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n+\t || TREE_CODE (t) == NON_LVALUE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  /* Now give the language a chance to do something.  */\n+  if (lang_get_alias_set != 0\n+      && (set = (*lang_get_alias_set) (t)) != -1)\n+    return set;\n+\n+  /* If this is a reference, go inside it and use the underlying object.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'r')\n+    t = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t     &unsignedp, &volatilep, &alignment);\n+\n+  if (TREE_CODE (t) == INDIRECT_REF)\n+    {\n+      /* Check for accesses through restrict-qualified pointers.  */\n+      tree decl = find_base_decl (TREE_OPERAND (t, 0));\n+\n+      if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n+\t/* We use the alias set indicated in the declaration.  */\n+\treturn DECL_POINTER_ALIAS_SET (decl);\n+\n+      /* If we have an INDIRECT_REF via a void pointer, we don't know anything\n+\t about what that might alias.  */\n+      if (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE)\n+\treturn 0;\n+    }\n+\n+  /* Give the language another chance to do something special.  */\n+  if (lang_get_alias_set != 0\n+      && (set = (*lang_get_alias_set) (t)) != -1)\n+    return set;\n+\n+  /* Now we are done with expressions, so get the type if this isn't\n+     a type.  */\n+  if (! TYPE_P (t))\n+    t = TREE_TYPE (t);\n+\n+  /* Variant qualifiers don't affect the alias set, so get the main\n+     variant. If this is a type with a known alias set, return it.  */\n+  t = TYPE_MAIN_VARIANT (t);\n+  if (TYPE_P (t) && TYPE_ALIAS_SET_KNOWN_P (t))\n+    return TYPE_ALIAS_SET (t);\n+\n+  /* See if the language has special handling for this type.  */\n+  if (lang_get_alias_set != 0\n+      && (set = (*lang_get_alias_set) (t)) != -1)\n+    ;\n+  /* There are no objects of FUNCTION_TYPE, so there's no point in\n+     using up an alias set for them.  (There are, of course, pointers\n+     and references to functions, but that's different.)  */\n+  else if (TREE_CODE (t) == FUNCTION_TYPE)\n+    set = 0;\n+  else\n+    /* Otherwise make a new alias set for this type.  */\n+    set = new_alias_set ();\n+\n+  TYPE_ALIAS_SET (t) = set;\n+  return set;\n+}\n+\n+/* Return a brand-new alias set.  */\n+\n+HOST_WIDE_INT\n+new_alias_set ()\n+{\n+  static HOST_WIDE_INT last_alias_set;\n+\n+  if (flag_strict_aliasing)\n+    return ++last_alias_set;\n+  else\n+    return 0;\n+}\n \n /* Indicate that things in SUBSET can alias things in SUPERSET, but\n    not vice versa.  For example, in C, a store to an `int' can alias a\n@@ -278,8 +444,8 @@ insert_subset_children (node, data)\n \n void\n record_alias_subset (superset, subset)\n-     int superset;\n-     int subset;\n+     HOST_WIDE_INT superset;\n+     HOST_WIDE_INT subset;\n {\n   alias_set_entry superset_entry;\n   alias_set_entry subset_entry;\n@@ -326,8 +492,8 @@ void\n record_component_aliases (type)\n      tree type;\n {\n-  int superset = get_alias_set (type);\n-  int subset;\n+  HOST_WIDE_INT superset = get_alias_set (type);\n+  HOST_WIDE_INT subset;\n   tree field;\n \n   if (superset == 0)\n@@ -336,7 +502,6 @@ record_component_aliases (type)\n   switch (TREE_CODE (type))\n     {\n     case ARRAY_TYPE:\n-    case COMPLEX_TYPE:\n       subset = get_alias_set (TREE_TYPE (type));\n       if (subset != 0)\n \trecord_alias_subset (superset, subset);\n@@ -358,6 +523,34 @@ record_component_aliases (type)\n     }\n }\n \n+/* Allocate an alias set for use in storing and reading from the varargs\n+   spill area.  */\n+\n+HOST_WIDE_INT\n+get_varargs_alias_set ()\n+{\n+  static HOST_WIDE_INT set = -1;\n+\n+  if (set == -1)\n+    set = new_alias_set ();\n+\n+  return set;\n+}\n+\n+/* Likewise, but used for the fixed portions of the frame, e.g., register\n+   save areas.  */\n+\n+HOST_WIDE_INT\n+get_frame_alias_set ()\n+{\n+  static HOST_WIDE_INT set = -1;\n+\n+  if (set == -1)\n+    set = new_alias_set ();\n+\n+  return set;\n+}\n+\n /* Inside SRC, the source of a SET, find a base address.  */\n \n static rtx\n@@ -975,6 +1168,7 @@ base_alias_check (x, y, x_mode, y_mode)\n /* Convert the address X into something we can use.  This is done by returning\n    it unchanged unless it is a value; in the latter case we call cselib to get\n    a more useful rtx.  */\n+\n static rtx\n get_addr (x)\n      rtx x;"}, {"sha": "0e89481a12b923df37b5ac5e48bd960a86ecf5fb", "filename": "gcc/builtins.c", "status": "modified", "additions": 56, "deletions": 62, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -288,6 +288,7 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n #endif\n       tem = memory_address (Pmode, tem);\n       tem = copy_to_reg (gen_rtx_MEM (Pmode, tem));\n+      MEM_ALIAS_SET (tem) = get_frame_alias_set ();\n     }\n \n   /* For __builtin_frame_address, return what we've got.  */\n@@ -302,10 +303,14 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n   tem = memory_address (Pmode,\n \t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n   tem = gen_rtx_MEM (Pmode, tem);\n+  MEM_ALIAS_SET (tem) = get_frame_alias_set ();\n #endif\n   return tem;\n }\n \n+/* Alias set used for setjmp buffer.  */\n+static HOST_WIDE_INT setjmp_alias_set = -1;\n+\n /* __builtin_setjmp is passed a pointer to an array of five words (not\n    all will be used on all machines).  It operates similarly to the C\n    library function of the same name, but is more efficient.  Much of\n@@ -326,9 +331,13 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n   enum machine_mode value_mode;\n   rtx stack_save;\n+  rtx mem;\n \n   value_mode = TYPE_MODE (integer_type_node);\n \n+  if (setjmp_alias_set == -1)\n+    setjmp_alias_set = new_alias_set ();\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n   buf_addr = convert_memory_address (Pmode, buf_addr);\n #endif\n@@ -349,17 +358,20 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n #define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx\n #endif\n \n-  emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n-\t\t  BUILTIN_SETJMP_FRAME_VALUE);\n-  emit_move_insn (validize_mem\n-\t\t  (gen_rtx_MEM (Pmode,\n-\t\t\t\tplus_constant (buf_addr,\n-\t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n+  mem = gen_rtx_MEM (Pmode, buf_addr);\n+  MEM_ALIAS_SET (mem) = setjmp_alias_set;\n+  emit_move_insn (mem, BUILTIN_SETJMP_FRAME_VALUE);\n+\n+  mem = gen_rtx_MEM (Pmode, plus_constant (buf_addr, GET_MODE_SIZE (Pmode))),\n+  MEM_ALIAS_SET (mem) = setjmp_alias_set;\n+\n+  emit_move_insn (validize_mem (mem),\n \t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));\n \n   stack_save = gen_rtx_MEM (sa_mode,\n \t\t\t    plus_constant (buf_addr,\n \t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n+  MEM_ALIAS_SET (stack_save) = setjmp_alias_set;\n   emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n \n   /* If there is further processing to do, do it.  */\n@@ -464,6 +476,9 @@ expand_builtin_longjmp (buf_addr, value)\n   rtx fp, lab, stack;\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n \n+  if (setjmp_alias_set == -1)\n+    setjmp_alias_set = new_alias_set ();\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n   buf_addr = convert_memory_address (Pmode, buf_addr);\n #endif\n@@ -489,6 +504,8 @@ expand_builtin_longjmp (buf_addr, value)\n \n       stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n \t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n+      MEM_ALIAS_SET (fp) = MEM_ALIAS_SET (lab) = MEM_ALIAS_SET (stack)\n+\t= setjmp_alias_set;\n \n       /* Pick up FP, label, and SP from the block and jump.  This code is\n \t from expand_goto in stmt.c; see there for detailed comments.  */\n@@ -513,53 +530,34 @@ expand_builtin_longjmp (buf_addr, value)\n     }\n }\n \n-/* Get a MEM rtx for expression EXP which can be used in a string instruction\n-   (cmpstrsi, movstrsi, ..).  */\n+/* Get a MEM rtx for expression EXP which is the address of an operand\n+   to be used to be used in a string instruction (cmpstrsi, movstrsi, ..).  */\n+\n static rtx\n get_memory_rtx (exp)\n      tree exp;\n {\n-  rtx mem;\n-  int is_aggregate;\n-\n-  mem = gen_rtx_MEM (BLKmode,\n-\t\t     memory_address (BLKmode,\n-\t\t\t\t     expand_expr (exp, NULL_RTX,\n-\t\t\t\t\t\t  ptr_mode, EXPAND_SUM)));\n-\n-  RTX_UNCHANGING_P (mem) = TREE_READONLY (exp);\n-\n-  /* Figure out the type of the object pointed to.  Set MEM_IN_STRUCT_P\n-     if the value is the address of a structure or if the expression is\n-     cast to a pointer to structure type.  */\n-  is_aggregate = 0;\n-\n-  while (TREE_CODE (exp) == NOP_EXPR)\n-    {\n-      tree cast_type = TREE_TYPE (exp);\n-      if (TREE_CODE (cast_type) == POINTER_TYPE\n-\t  && AGGREGATE_TYPE_P (TREE_TYPE (cast_type)))\n-\t{\n-\t  is_aggregate = 1;\n-\t  break;\n-\t}\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-\n-  if (is_aggregate == 0)\n-    {\n-      tree type;\n-\n-      if (TREE_CODE (exp) == ADDR_EXPR)\n-\t/* If this is the address of an object, check whether the\n-\t   object is an array.  */\n-\ttype = TREE_TYPE (TREE_OPERAND (exp, 0));\n-      else\n-\ttype = TREE_TYPE (TREE_TYPE (exp));\n-      is_aggregate = AGGREGATE_TYPE_P (type);\n-    }\n+  rtx mem = gen_rtx_MEM (BLKmode,\n+\t\t\t memory_address (BLKmode,\n+\t\t\t\t\t expand_expr (exp, NULL_RTX,\n+\t\t\t\t\t\t      ptr_mode, EXPAND_SUM)));\n+\n+  /* Get an expression we can use to find the attributes to assign to MEM.\n+     If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if\n+     we can.  First remove any nops.  */\n+  while ((TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR\n+\t || TREE_CODE (exp) == NON_LVALUE_EXPR)\n+\t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    exp = TREE_OPERAND (exp, 0);\n+  else if (POINTER_TYPE_P (TREE_TYPE (exp)))\n+    exp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (exp)), exp);\n+  else\n+    return mem;\n \n-  MEM_SET_IN_STRUCT_P (mem, is_aggregate);\n+  set_mem_attributes (mem, exp, 0);\n   return mem;\n }\n \f\n@@ -1306,6 +1304,7 @@ expand_builtin_mathfn (exp, target, subtarget)\n    if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient (and in mode MODE if that's\n    convenient).  */\n+\n static rtx\n expand_builtin_strlen (exp, target, mode)\n      tree exp;\n@@ -1377,8 +1376,9 @@ expand_builtin_strlen (exp, target, mode)\n \t\t\t   TYPE_MODE (integer_type_node));\n \n       char_rtx = const0_rtx;\n-      char_mode = insn_data[(int)icode].operand[2].mode;\n-      if (! (*insn_data[(int)icode].operand[2].predicate) (char_rtx, char_mode))\n+      char_mode = insn_data[(int) icode].operand[2].mode;\n+      if (! (*insn_data[(int) icode].operand[2].predicate) (char_rtx,\n+\t\t\t\t\t\t\t    char_mode))\n \tchar_rtx = copy_to_mode_reg (char_mode, char_rtx);\n \n       pat = GEN_FCN (icode) (result, gen_rtx_MEM (BLKmode, src_reg),\n@@ -1390,7 +1390,7 @@ expand_builtin_strlen (exp, target, mode)\n       /* Now that we are assured of success, expand the source.  */\n       start_sequence ();\n       pat = memory_address (BLKmode, \n-\t\texpand_expr (src, src_reg, ptr_mode, EXPAND_SUM));\n+\t\t\t    expand_expr (src, src_reg, ptr_mode, EXPAND_SUM));\n       if (pat != src_reg)\n \temit_move_insn (src_reg, pat);\n       pat = gen_sequence ();\n@@ -1814,6 +1814,7 @@ expand_builtin_saveregs ()\n /* __builtin_args_info (N) returns word N of the arg space info\n    for the current function.  The number and meanings of words\n    is controlled by the definition of CUMULATIVE_ARGS.  */\n+\n static rtx\n expand_builtin_args_info (exp)\n      tree exp;\n@@ -2007,19 +2008,9 @@ expand_builtin_va_start (stdarg_p, arglist)\n   return const0_rtx;\n }\n \n-/* Allocate an alias set for use in storing and reading from the varargs\n-   spill area.  */\n-int\n-get_varargs_alias_set ()\n-{\n-  static int set = -1;\n-  if (set == -1)\n-    set = new_alias_set ();\n-  return set;\n-}\n-\n /* The \"standard\" implementation of va_arg: read the value from the\n    current (padded) address and increment by the (padded) size.  */\n+\n rtx\n std_expand_builtin_va_arg (valist, type)\n      tree valist, type;\n@@ -2063,6 +2054,7 @@ std_expand_builtin_va_arg (valist, type)\n \n /* Expand __builtin_va_arg, which is not really a builtin function, but\n    a very special sort of operator.  */\n+\n rtx\n expand_builtin_va_arg (valist, type)\n      tree valist, type;\n@@ -2146,6 +2138,7 @@ expand_builtin_va_arg (valist, type)\n }\n \n /* Expand ARGLIST, from a call to __builtin_va_end.  */\n+\n static rtx\n expand_builtin_va_end (arglist)\n      tree arglist;\n@@ -2168,6 +2161,7 @@ expand_builtin_va_end (arglist)\n /* Expand ARGLIST, from a call to __builtin_va_copy.  We do this as a \n    builtin rather than just as an assignment in stdarg.h because of the\n    nastiness of array-type va_list types.  */\n+\n static rtx\n expand_builtin_va_copy (arglist)\n      tree arglist;"}, {"sha": "5cc34c960a1678ddae46c9ac39ca5dd4b62dade1", "filename": "gcc/c-common.c", "status": "modified", "additions": 30, "deletions": 154, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -156,7 +156,6 @@ static void init_attributes\t\tPARAMS ((void));\n static void record_function_format\tPARAMS ((tree, tree, enum format_type,\n \t\t\t\t\t\t int, int));\n static void record_international_format\tPARAMS ((tree, tree, int));\n-static tree c_find_base_decl            PARAMS ((tree));\n static int default_valid_lang_attribute PARAMS ((tree, tree, tree, tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n@@ -3245,10 +3244,10 @@ c_apply_type_quals_to_decl (type_quals, decl)\n \t     alias set for the type pointed to by the type of the\n \t     decl.  */\n \n-\t  int pointed_to_alias_set\n+\t  HOST_WIDE_INT pointed_to_alias_set\n \t    = get_alias_set (TREE_TYPE (TREE_TYPE (decl)));\n \n-\t  if (!pointed_to_alias_set)\n+\t  if (pointed_to_alias_set == 0)\n \t    /* It's not legal to make a subset of alias set zero.  */\n \t    ;\n \t  else\n@@ -3261,91 +3260,16 @@ c_apply_type_quals_to_decl (type_quals, decl)\n     }\n }\n \n-/* T is an expression with pointer type.  Find the DECL on which this\n-   expression is based.  (For example, in `a[i]' this would be `a'.)\n-   If there is no such DECL, or a unique decl cannot be determined,\n-   NULL_TREE is retured.  */\n-\n-static tree\n-c_find_base_decl (t)\n-     tree t;\n-{\n-  int i;\n-  tree decl;\n-\n-  if (t == NULL_TREE || t == error_mark_node)\n-    return NULL_TREE;\n-\n-  if (!POINTER_TYPE_P (TREE_TYPE (t)))\n-    return NULL_TREE;\n-\n-  decl = NULL_TREE;\n-\n-  if (TREE_CODE (t) == FIELD_DECL\n-      || TREE_CODE (t) == PARM_DECL\n-      || TREE_CODE (t) == VAR_DECL)\n-    /* Aha, we found a pointer-typed declaration.  */\n-    return t;\n-\n-  /* It would be nice to deal with COMPONENT_REFs here.  If we could\n-     tell that `a' and `b' were the same, then `a->f' and `b->f' are\n-     also the same.  */\n-\n-  /* Handle general expressions.  */\n-  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n-    {\n-    case '1':\n-    case '2':\n-    case '3':\n-      for (i = TREE_CODE_LENGTH (TREE_CODE (t)); --i >= 0;)\n-\t{\n-\t  tree d = c_find_base_decl (TREE_OPERAND (t, i));\n-\t  if (d)\n-\t    {\n-\t      if (!decl)\n-\t\tdecl = d;\n-\t      else if (d && d != decl)\n-\t\t/* Two different declarations.  That's confusing; let's\n-\t\t   just assume we don't know what's going on.  */\n-\t\tdecl = NULL_TREE;\n-\t    }\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return decl;\n-}\n \n /* Return the typed-based alias set for T, which may be an expression\n-   or a type.  */\n+   or a type.  Return -1 if we don't do anything special.  */\n \n-int\n+HOST_WIDE_INT\n c_get_alias_set (t)\n      tree t;\n {\n-  tree type;\n   tree u;\n \n-  if (t == error_mark_node)\n-    return 0;\n-\n-  /* For a bit field reference that's not to a specific field,\n-     all we can say is the aliasing information for the underlying object. */\n-  if (TREE_CODE (t) == BIT_FIELD_REF)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* If this is a type, use it, otherwise get the type of the expression.\n-     If the type is an error type, say this may alias anything.  */\n-  type = TYPE_P (t) ? t : TREE_TYPE (t);\n-  if (type == error_mark_node)\n-    return 0;\n-\n-  /* Deal with special cases first; for certain kinds of references\n-     we're interested in more than just the type.  */\n-\n   /* Permit type-punning when accessing a union, provided the access\n      is directly through the union.  For example, this code does not\n      permit taking the address of a union member and then storing\n@@ -3359,81 +3283,37 @@ c_get_alias_set (t)\n \t&& TREE_CODE (TREE_TYPE (TREE_OPERAND (u, 0))) == UNION_TYPE)\n       return 0;\n \n-  if (TREE_CODE (t) == INDIRECT_REF)\n-    {\n-      /* Check for accesses through restrict-qualified pointers.  */\n-      tree op = TREE_OPERAND (t, 0);\n-      tree decl = c_find_base_decl (op);\n-\n-      if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n-\t/* We use the alias set indicated in the declaration.  */\n-\treturn DECL_POINTER_ALIAS_SET (decl);\n-\n-      /* If this is a char *, the ANSI C standard says it can alias\n-         anything.  */\n-      if (TREE_CODE (TREE_TYPE (op)) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (op))\n-\t      == TYPE_PRECISION (char_type_node)))\n-\treturn 0;\n-    }\n+  /* If this is a char *, the ANSI C standard says it can alias\n+     anything.  */\n+  else if (TREE_CODE (t) == INDIRECT_REF\n+\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == INTEGER_TYPE\n+\t   && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t       == TYPE_PRECISION (char_type_node)))\n+    return 0;\n \n-  /* From here on, only the type matters.  */\n-\n-  if (TREE_CODE (t) == COMPONENT_REF\n-      && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)))\n-    /* Since build_modify_expr calls get_unwidened for stores to\n-       component references, the type of a bit field can be changed\n-       from (say) `unsigned int : 16' to `unsigned short' or from\n-       `enum E : 16' to `short'.  We want the real type of the\n-       bit-field in this case, not some the integral equivalent.  */\n-    type = DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1));\n-\n-  if (TYPE_ALIAS_SET_KNOWN_P (type))\n-    /* If we've already calculated the value, just return it.  */\n-    return TYPE_ALIAS_SET (type);\n-  else if (TYPE_MAIN_VARIANT (type) != type)\n-    /* The C standard specifically allows aliasing between\n-       cv-qualified variants of types.  */\n-    TYPE_ALIAS_SET (type) = c_get_alias_set (TYPE_MAIN_VARIANT (type));\n-  else if (TREE_CODE (type) == INTEGER_TYPE)\n-    {\n-      tree signed_variant;\n+  /* That's all the expressions we handle specially.  */\n+  if (! TYPE_P (t))\n+    return -1;\n \n+  if (TREE_CODE (t) == INTEGER_TYPE)\n+    {\n       /* The C standard specifically allows aliasing between signed and\n \t unsigned variants of the same type.  We treat the signed\n \t variant as canonical.  */\n-      signed_variant = signed_type (type);\n+      tree signed_variant = signed_type (t);\n \n-      if (signed_variant != type)\n-\tTYPE_ALIAS_SET (type) = c_get_alias_set (signed_variant);\n-      else if (signed_variant == signed_char_type_node)\n+      if (signed_variant == signed_char_type_node)\n \t/* The C standard guarantess that any object may be accessed\n \t   via an lvalue that has character type.  We don't have to\n \t   check for unsigned_char_type_node or char_type_node because\n \t   we are specifically looking at the signed variant.  */\n-\tTYPE_ALIAS_SET (type) = 0;\n+\treturn 0;\n+      else if (signed_variant  != t)\n+\treturn get_alias_set (signed_variant);\n     }\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    /* Anything that can alias one of the array elements can alias\n-       the entire array as well.  */\n-    TYPE_ALIAS_SET (type) = c_get_alias_set (TREE_TYPE (type));\n-  else if (TREE_CODE (type) == FUNCTION_TYPE)\n-    /* There are no objects of FUNCTION_TYPE, so there's no point in\n-       using up an alias set for them.  (There are, of course,\n-       pointers and references to functions, but that's\n-       different.)  */\n-    TYPE_ALIAS_SET (type) = 0;\n-  else if (TREE_CODE (type) == RECORD_TYPE\n-\t   || TREE_CODE (type) == UNION_TYPE)\n-    /* If TYPE is a struct or union type then we're reading or\n-       writing an entire struct.  Thus, we don't know anything about\n-       aliasing.  (In theory, such an access can only alias objects\n-       whose type is the same as one of the fields, recursively, but\n-       we don't yet make any use of that information.)  */\n-    TYPE_ALIAS_SET (type) = 0;\n-  else if (POINTER_TYPE_P (type))\n+  else if (POINTER_TYPE_P (t))\n     {\n-      tree t;\n+      tree t1;\n \n       /* Unfortunately, there is no canonical form of a pointer type.\n \t In particular, if we have `typedef int I', then `int *', and\n@@ -3458,19 +3338,14 @@ c_get_alias_set (t)\n \t can dereference IPP and CIPP.  So, we ignore cv-qualifiers on\n \t the pointed-to types.  This issue has been reported to the\n \t C++ committee.  */\n-      t = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      t = ((TREE_CODE (type) == POINTER_TYPE)\n-\t   ? build_pointer_type (t) : build_reference_type (t));\n-      if (t != type)\n-\tTYPE_ALIAS_SET (type) = c_get_alias_set (t);\n+      t1 = TYPE_MAIN_VARIANT (TREE_TYPE (t));\n+      t1 = ((TREE_CODE (t) == POINTER_TYPE)\n+\t   ? build_pointer_type (t1) : build_reference_type (t1));\n+      if (t1 != t)\n+\treturn get_alias_set (t1);\n     }\n \n-  if (! TYPE_ALIAS_SET_KNOWN_P (type))\n-    /* TYPE is something we haven't seen before.  Put it in a new\n-       alias set.  */\n-    TYPE_ALIAS_SET (type) = new_alias_set ();\n-\n-  return TYPE_ALIAS_SET (type);\n+  return -1;\n }\n \n /* Build tree nodes and builtin functions common to both C and C++ language\n@@ -3480,6 +3355,7 @@ c_get_alias_set (t)\n    NO_BUILTINS and NO_NONANSI_BUILTINS contain the respective values of\n    the language frontend flags flag_no_builtin and\n    flag_no_nonansi_builtin.  */\n+\n void\n c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n     int cplus_mode, no_builtins, no_nonansi_builtins;"}, {"sha": "30f58f850ab98b7e9574f3c04e5f6aaf8f4b6483", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -97,7 +97,7 @@ extern void decl_attributes\t\t\tPARAMS ((tree, tree, tree));\n extern void init_function_format_info\t\tPARAMS ((void));\n extern void check_function_format\t\tPARAMS ((tree, tree, tree));\n extern void c_apply_type_quals_to_decl\t\tPARAMS ((int, tree));\n-extern int c_get_alias_set\t\t\tPARAMS ((tree));\n+extern HOST_WIDE_INT c_get_alias_set\t\tPARAMS ((tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error\t\t\tPARAMS ((enum tree_code));"}, {"sha": "1d8624241c6fa55e01740d835541eae496304f5f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -313,6 +313,7 @@ common_type (t1, t2)\n \t  return build_type_attribute_variant (t2, attributes);\n \t/* Merge the element types, and have a size if either arg has one.  */\n \tt1 = build_array_type (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n+\trecord_component_aliases (t1);\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n "}, {"sha": "f939de778582ce42f56ead3fa7ebceb3f7a49c02", "filename": "gcc/caller-save.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -256,6 +256,7 @@ void\n setup_save_areas ()\n {\n   int i, j, k;\n+  unsigned int r;\n   HARD_REG_SET hard_regs_used;\n \n   /* Allocate space in the save area for the largest multi-register\n@@ -267,16 +268,13 @@ setup_save_areas ()\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] >= 0 && REG_N_CALLS_CROSSED (i) > 0)\n       {\n-\tint regno = reg_renumber[i];\n-\tint endregno \n+\tunsigned int regno = reg_renumber[i];\n+\tunsigned int endregno \n \t  = regno + HARD_REGNO_NREGS (regno, GET_MODE (regno_reg_rtx[i]));\n-\tint nregs = endregno - regno;\n \n-\tfor (j = 0; j < nregs; j++)\n-\t  {\n-\t    if (call_used_regs[regno+j]) \n-\t      SET_HARD_REG_BIT (hard_regs_used, regno+j);\n-\t  }\n+\tfor (r = regno; r < endregno; r++)\n+\t  if (call_used_regs[r])\n+\t    SET_HARD_REG_BIT (hard_regs_used, r);\n       }\n \n   /* Now run through all the call-used hard-registers and allocate\n@@ -322,16 +320,24 @@ setup_save_areas ()\n \t  {\n \t    /* This should not depend on WORDS_BIG_ENDIAN.\n \t       The order of words in regs is the same as in memory.  */\n-\t    rtx temp = gen_rtx_MEM (regno_save_mode[i+k][1], \n+\t    rtx temp = gen_rtx_MEM (regno_save_mode[i + k][1], \n \t\t\t\t    XEXP (regno_save_mem[i][j], 0));\n \n-\t    regno_save_mem[i+k][1] \n+\t    regno_save_mem[i + k][1] \n \t      = adj_offsettable_operand (temp, k * UNITS_PER_WORD);\n \t  }\n       }\n+\n+  /* Now loop again and set the alias set of any save areas we made to\n+     the alias set used to represent frame objects.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    for (j = MOVE_MAX_WORDS; j > 0; j--)\n+      if (regno_save_mem[i][j] != 0)\n+\tMEM_ALIAS_SET (regno_save_mem[i][j]) = get_frame_alias_set ();\n }\n \f\n /* Find the places where hard regs are live across calls and save them.  */\n+\n void\n save_call_clobbered_regs ()\n {"}, {"sha": "d59c15b94aef83ec8a47a0850d6d401480470a4d", "filename": "gcc/calls.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -850,6 +850,7 @@ precompute_register_parameters (num_actuals, args, reg_parm_seen)\n   /* The argument list is the property of the called routine and it\n      may clobber it.  If the fixed area has been used for previous\n      parameters, we must save and restore it.  */\n+\n static rtx\n save_fixed_argument_area (reg_parm_stack_space, argblock,\n \t\t\t  low_to_save, high_to_save)\n@@ -891,10 +892,11 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n \tsave_mode = BLKmode;\n \n #ifdef ARGS_GROW_DOWNWARD\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       - *high_to_save)));\n+      stack_area\n+\t= gen_rtx_MEM (save_mode,\n+\t\t       memory_address (save_mode,\n+\t\t\t\t       plus_constant (argblock,\n+\t\t\t\t\t\t      - *high_to_save)));\n #else\n       stack_area = gen_rtx_MEM (save_mode,\n \t\t\t\tmemory_address (save_mode,\n@@ -1191,17 +1193,12 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\t    }\n \n \t\t  copy = gen_rtx_MEM (BLKmode,\n-\t\t\t\t      allocate_dynamic_stack_space (size_rtx,\n-\t\t\t\t\t\t\t\t    NULL_RTX,\n-\t\t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n+\t\t\t\t      allocate_dynamic_stack_space\n+\t\t\t\t      (size_rtx, NULL_RTX, TYPE_ALIGN (type)));\n+\t\t  set_mem_attributes (copy, type, 1);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  int size = int_size_in_bytes (type);\n-\t\t  copy = assign_stack_temp (TYPE_MODE (type), size, 0);\n-\t\t}\n-\n-\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n+\t\tcopy = assign_temp (type, 0, 1, 0);\n \n \t      store_expr (args[i].tree_value, copy, 0);\n \t      *ecf_flags &= ~(ECF_CONST | ECF_PURE);\n@@ -1585,9 +1582,8 @@ compute_argument_addresses (args, argblock, num_actuals)\n \n \t  addr = plus_constant (addr, arg_offset);\n \t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n-\t  MEM_SET_IN_STRUCT_P \n-\t    (args[i].stack,\n-\t     AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value)));\n+\t  set_mem_attributes (args[i].stack,\n+\t\t\t      TREE_TYPE (args[i].tree_value), 1);\n \n \t  if (GET_CODE (slot_offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n@@ -1596,6 +1592,8 @@ compute_argument_addresses (args, argblock, num_actuals)\n \n \t  addr = plus_constant (addr, arg_offset);\n \t  args[i].stack_slot = gen_rtx_MEM (args[i].mode, addr);\n+\t  set_mem_attributes (args[i].stack_slot,\n+\t\t\t      TREE_TYPE (args[i].tree_value), 1);\n \t}\n     }\n }\n@@ -3058,11 +3056,11 @@ expand_call (exp, target, ignore)\n \t{\n \t  if (target == 0 || GET_CODE (target) != MEM)\n \t    {\n-\t      target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t\t    memory_address (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t\t\t\t    structure_value_addr));\n-\t      MEM_SET_IN_STRUCT_P (target,\n-\t\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n+\t      target\n+\t\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t       memory_address (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\t\t       structure_value_addr));\n+\t      set_mem_attributes (target, exp, 1);\n \t    }\n \t}\n       else if (pcc_struct_value)\n@@ -3072,7 +3070,7 @@ expand_call (exp, target, ignore)\n \t     never use this value more than once in one expression.  */\n \t  target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t\tcopy_to_reg (valreg));\n-\t  MEM_SET_IN_STRUCT_P (target, AGGREGATE_TYPE_P (TREE_TYPE (exp)));\n+\t  set_mem_attributes (target, exp, 1);\n \t}\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */"}, {"sha": "ffe112af56de223329bb7af1e0adebc37ea3e7a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1,3 +1,12 @@\n+Wed May 31 14:09:00 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Makefile.in (decl.o): Include ../expr.h.\n+\t* decl.c (expr.h): Include.\n+\t(init_decl_processing): Call record_component_aliases for arrays.\n+\t(grokdeclarator): Likewise.\n+\tSet TREE_ADDRESSABLE for fields that aren't bitfields.\n+\t* tree.c (build_cplus_array_type_1): Call record_component_aliases.\n+\n 2000-05-31  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (build_cp_library_fn): Set DECL_CONTEXT."}, {"sha": "e162294c1a6c5e553f3ce6d9ba90d57abc77cd80", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -256,7 +256,7 @@ lex.o : lex.c $(CXX_TREE_H) \\\n   $(srcdir)/../output.h $(srcdir)/../mbchar.h $(GGC_H) \\\n   $(srcdir)/../input.h operators.def\n decl.o : decl.c $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n+  lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h $(srcdir)/../expr.h \\\n   $(srcdir)/../except.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../hash.h $(GGC_H) $(RTL_H) operators.def\n decl2.o : decl2.c $(CXX_TREE_H) $(srcdir)/../flags.h \\"}, {"sha": "6640b9007489b5882cddb2182f12829caf3030dd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"flags.h\"\n #include \"cp-tree.h\"\n #include \"decl.h\"\n@@ -6455,10 +6456,14 @@ init_decl_processing ()\n      array type.  */\n   char_array_type_node\n     = build_array_type (char_type_node, array_domain_type);\n+\n   /* Likewise for arrays of ints.  */\n   int_array_type_node\n     = build_array_type (integer_type_node, array_domain_type);\n \n+  record_component_aliases (char_array_type_node);\n+  record_component_aliases (int_array_type_node);\n+\n   if (flag_new_abi)\n     delta_type_node = ptrdiff_type_node;\n   else if (flag_huge_objects)\n@@ -6522,6 +6527,7 @@ init_decl_processing ()\n   /* This is for wide string constants.  */\n   wchar_array_type_node\n     = build_array_type (wchar_type_node, array_domain_type);\n+  record_component_aliases (wchar_array_type_node);\n \n   if (flag_vtable_thunks)\n     {\n@@ -11588,6 +11594,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    else\n \t      {\n \t\tdecl = build_decl (FIELD_DECL, declarator, type);\n+\t\tTREE_ADDRESSABLE (decl) = ! bitfield;\n \t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;"}, {"sha": "95fafada6973aeef5dbe4e3fbd60a11c514cff44", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -500,7 +500,10 @@ build_cplus_array_type_1 (elt_type, index_type)\n       TYPE_DOMAIN (t) = index_type;\n     }\n   else\n-    t = build_array_type (elt_type, index_type);\n+    {\n+      t = build_array_type (elt_type, index_type);\n+      record_component_aliases (t);\n+    }\n \n   /* Push these needs up so that initialization takes place\n      more easily.  */"}, {"sha": "6ca93bcbffb1b25febb59dd5b45b90c25cc0b103", "filename": "gcc/explow.c", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -628,6 +628,61 @@ validize_mem (ref)\n   return change_address (ref, GET_MODE (ref), XEXP (ref, 0));\n }\n \f\n+/* Given REF, a MEM, and T, either the type of X or the expression\n+   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n+   if we are making a new object of this type.  */\n+\n+void\n+set_mem_attributes (ref, t, objectp)\n+     rtx ref;\n+     tree t;\n+     int objectp;\n+{\n+  tree type = TYPE_P (t) ? t : TREE_TYPE (t);\n+\n+  /* Get the alias set from the expression or type (perhaps using a\n+     front-end routine) and then copy bits from the type.  */\n+  MEM_ALIAS_SET (ref) = get_alias_set (t);\n+  RTX_UNCHANGING_P (ref) = TYPE_READONLY (type);\n+  MEM_VOLATILE_P (ref) = TYPE_VOLATILE (type);\n+  MEM_IN_STRUCT_P (ref) = AGGREGATE_TYPE_P (type);\n+\n+  /* If we are making an object of this type, we know that it is a scalar if\n+     the type is not an aggregate. */\n+  if (objectp && ! AGGREGATE_TYPE_P (type))\n+    MEM_SCALAR_P (ref) = 1;\n+\n+  /* If T is a type, this is all we can do.  Otherwise, we may be able\n+     to deduce some more information about the expression.  */\n+  if (TYPE_P (t))\n+    return;\n+\n+  if (TREE_READONLY (t) || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n+    RTX_UNCHANGING_P (ref) = 1;\n+  if (TREE_THIS_VOLATILE (t))\n+    MEM_VOLATILE_P (ref) = 1;\n+\n+  /* Now see if we can say more about whether it's an aggregate or\n+     scalar.  If we already know it's an aggregate, don't bother.  */\n+  if (MEM_IN_STRUCT_P (ref))\n+    return;\n+\n+  /* Now remove any NOPs: they don't change what the underlying object is.\n+     Likewise for SAVE_EXPR.  */\n+  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n+\t || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+\n+  /* Since we already know the type isn't an aggregate, if this is a decl,\n+     it must be a scalar.  Or if it is a reference into an aggregate,\n+     this is part of an aggregate.   Otherwise we don't know.  */\n+  if (DECL_P (t))\n+    MEM_SCALAR_P (ref) = 1;\n+  else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n+\t   || TREE_CODE (t) == BIT_FIELD_REF)\n+    MEM_IN_STRUCT_P (ref) = 1;\n+}\n+\f\n /* Return a modified copy of X with its memory address copied\n    into a temporary register to protect it from side effects.\n    If X is not a MEM, it is returned unchanged (and not copied).\n@@ -638,25 +693,17 @@ stabilize (x)\n      rtx x;\n {\n   register rtx addr;\n+\n   if (GET_CODE (x) != MEM)\n     return x;\n+\n   addr = XEXP (x, 0);\n   if (rtx_unstable_p (addr))\n     {\n-      rtx temp = copy_all_regs (addr);\n-      rtx mem;\n-\n-      if (GET_CODE (temp) != REG)\n-\ttemp = copy_to_reg (temp);\n-      mem = gen_rtx_MEM (GET_MODE (x), temp);\n-\n-      /* Mark returned memref with in_struct if it's in an array or\n-\t structure.  Copy everything else from original memref.  */\n+      rtx temp = force_reg (Pmode, copy_all_regs (addr));\n+      rtx mem = gen_rtx_MEM (GET_MODE (x), temp);\n \n       MEM_COPY_ATTRIBUTES (mem, x);\n-      if (GET_CODE (addr) == PLUS)\n-\tMEM_SET_IN_STRUCT_P (mem, 1);\n-\n       return mem;\n     }\n   return x;"}, {"sha": "cb397288c0d0e6e6b003487b0204d23e398cdefe", "filename": "gcc/expr.c", "status": "modified", "additions": 90, "deletions": 85, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -115,16 +115,12 @@ struct move_by_pieces\n   rtx to_addr;\n   int autinc_to;\n   int explicit_inc_to;\n-  int to_struct;\n-  int to_readonly;\n   rtx from;\n   rtx from_addr;\n   int autinc_from;\n   int explicit_inc_from;\n-  int from_struct;\n-  int from_readonly;\n-  int len;\n-  int offset;\n+  unsigned HOST_WIDE_INT len;\n+  HOST_WIDE_INT offset;\n   int reverse;\n };\n \n@@ -137,9 +133,8 @@ struct clear_by_pieces\n   rtx to_addr;\n   int autinc_to;\n   int explicit_inc_to;\n-  int to_struct;\n-  int len;\n-  int offset;\n+  unsigned HOST_WIDE_INT len;\n+  HOST_WIDE_INT offset;\n   int reverse;\n };\n \n@@ -148,10 +143,13 @@ extern struct obstack permanent_obstack;\n static rtx get_push_address\tPARAMS ((int));\n \n static rtx enqueue_insn\t\tPARAMS ((rtx, rtx));\n-static int move_by_pieces_ninsns PARAMS ((unsigned int, unsigned int));\n+static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n+\t\t\t\tPARAMS ((unsigned HOST_WIDE_INT,\n+\t\t\t\t\t unsigned int));\n static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t\t struct move_by_pieces *));\n-static void clear_by_pieces\tPARAMS ((rtx, int, unsigned int));\n+static void clear_by_pieces\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t\t unsigned int));\n static void clear_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...),\n \t\t\t\t\t enum machine_mode,\n \t\t\t\t\t struct clear_by_pieces *));\n@@ -1381,7 +1379,7 @@ convert_modes (mode, oldmode, x, unsignedp)\n void\n move_by_pieces (to, from, len, align)\n      rtx to, from;\n-     int len;\n+     unsigned HOST_WIDE_INT len;\n      unsigned int align;\n {\n   struct move_by_pieces data;\n@@ -1410,11 +1408,6 @@ move_by_pieces (to, from, len, align)\n   if (data.reverse) data.offset = len;\n   data.len = len;\n \n-  data.to_struct = MEM_IN_STRUCT_P (to);\n-  data.from_struct = MEM_IN_STRUCT_P (from);\n-  data.to_readonly = RTX_UNCHANGING_P (to);\n-  data.from_readonly = RTX_UNCHANGING_P (from);\n-\n   /* If copying requires more than two move insns,\n      copy addresses to registers (to make displacements shorter)\n      and use post-increment if available.  */\n@@ -1489,13 +1482,13 @@ move_by_pieces (to, from, len, align)\n /* Return number of insns required to move L bytes by pieces.\n    ALIGN (in bytes) is maximum alignment we can assume.  */\n \n-static int\n+static unsigned HOST_WIDE_INT\n move_by_pieces_ninsns (l, align)\n-     unsigned int l;\n+     unsigned HOST_WIDE_INT l;\n      unsigned int align;\n {\n-  register int n_insns = 0;\n-  unsigned int max_size = MOVE_MAX + 1;\n+  unsigned HOST_WIDE_INT n_insns = 0;\n+  unsigned HOST_WIDE_INT max_size = MOVE_MAX + 1;\n \n   if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX * BITS_PER_UNIT || align >= BIGGEST_ALIGNMENT)\n@@ -1534,42 +1527,46 @@ move_by_pieces_1 (genfun, mode, data)\n      enum machine_mode mode;\n      struct move_by_pieces *data;\n {\n-  register int size = GET_MODE_SIZE (mode);\n-  register rtx to1, from1;\n+  unsigned int size = GET_MODE_SIZE (mode);\n+  rtx to1, from1;\n \n   while (data->len >= size)\n     {\n-      if (data->reverse) data->offset -= size;\n-\n-      to1 = (data->autinc_to\n-\t     ? gen_rtx_MEM (mode, data->to_addr)\n-\t     : copy_rtx (change_address (data->to, mode,\n-\t\t\t\t\t plus_constant (data->to_addr,\n-\t\t\t\t\t\t\tdata->offset))));\n-      MEM_IN_STRUCT_P (to1) = data->to_struct;\n-      RTX_UNCHANGING_P (to1) = data->to_readonly;\n-\n-      from1\n-\t= (data->autinc_from\n-\t   ? gen_rtx_MEM (mode, data->from_addr)\n-\t   : copy_rtx (change_address (data->from, mode,\n-\t\t\t\t       plus_constant (data->from_addr,\n-\t\t\t\t\t\t      data->offset))));\n-      MEM_IN_STRUCT_P (from1) = data->from_struct;\n-      RTX_UNCHANGING_P (from1) = data->from_readonly;\n+      if (data->reverse)\n+\tdata->offset -= size;\n+\n+      if (data->autinc_to)\n+\t{\n+\t  to1 = gen_rtx_MEM (mode, data->to_addr);\n+\t  MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t}\n+      else\n+\tto1 = change_address (data->to, mode,\n+\t\t\t      plus_constant (data->to_addr, data->offset));\n+\n+      if (data->autinc_from)\n+\t{\n+\t  from1 = gen_rtx_MEM (mode, data->from_addr);\n+\t  MEM_COPY_ATTRIBUTES (from1, data->from);\n+\t}\n+      else\n+\tfrom1 = change_address (data->from, mode,\n+\t\t\t\tplus_constant (data->from_addr, data->offset));\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n       if (HAVE_PRE_DECREMENT && data->explicit_inc_from < 0)\n \temit_insn (gen_add2_insn (data->from_addr, GEN_INT (-size)));\n \n       emit_insn ((*genfun) (to1, from1));\n+\n       if (HAVE_POST_INCREMENT && data->explicit_inc_to > 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));\n       if (HAVE_POST_INCREMENT && data->explicit_inc_from > 0)\n \temit_insn (gen_add2_insn (data->from_addr, GEN_INT (size)));\n \n-      if (! data->reverse) data->offset += size;\n+      if (! data->reverse)\n+\tdata->offset += size;\n \n       data->len -= size;\n     }\n@@ -2243,12 +2240,12 @@ use_group_regs (call_fusage, regs)\n static void\n clear_by_pieces (to, len, align)\n      rtx to;\n-     int len;\n+     unsigned HOST_WIDE_INT len;\n      unsigned int align;\n {\n   struct clear_by_pieces data;\n   rtx to_addr = XEXP (to, 0);\n-  unsigned int max_size = MOVE_MAX_PIECES + 1;\n+  unsigned HOST_WIDE_INT max_size = MOVE_MAX_PIECES + 1;\n   enum machine_mode mode = VOIDmode, tmode;\n   enum insn_code icode;\n \n@@ -2265,8 +2262,6 @@ clear_by_pieces (to, len, align)\n   if (data.reverse) data.offset = len;\n   data.len = len;\n \n-  data.to_struct = MEM_IN_STRUCT_P (to);\n-\n   /* If copying requires more than two move insns,\n      copy addresses to registers (to make displacements shorter)\n      and use post-increment if available.  */\n@@ -2285,13 +2280,16 @@ clear_by_pieces (to, len, align)\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = -1;\n \t}\n-      if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_to)\n+\n+      if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse\n+\t  && ! data.autinc_to)\n \t{\n \t  data.to_addr = copy_addr_to_reg (to_addr);\n \t  data.autinc_to = 1;\n \t  data.explicit_inc_to = 1;\n \t}\n-      if (!data.autinc_to && CONSTANT_P (to_addr))\n+\n+      if ( !data.autinc_to && CONSTANT_P (to_addr))\n \tdata.to_addr = copy_addr_to_reg (to_addr);\n     }\n \n@@ -2334,28 +2332,33 @@ clear_by_pieces_1 (genfun, mode, data)\n      enum machine_mode mode;\n      struct clear_by_pieces *data;\n {\n-  register int size = GET_MODE_SIZE (mode);\n-  register rtx to1;\n+  unsigned int size = GET_MODE_SIZE (mode);\n+  rtx to1;\n \n   while (data->len >= size)\n     {\n-      if (data->reverse) data->offset -= size;\n+      if (data->reverse)\n+\tdata->offset -= size;\n \n-      to1 = (data->autinc_to\n-\t     ? gen_rtx_MEM (mode, data->to_addr)\n-\t     : copy_rtx (change_address (data->to, mode,\n-\t\t\t\t\t plus_constant (data->to_addr,\n-\t\t\t\t\t\t\tdata->offset))));\n-      MEM_IN_STRUCT_P (to1) = data->to_struct;\n+      if (data->autinc_to)\n+\t{\n+\t  to1 = gen_rtx_MEM (mode, data->to_addr);\n+\t  MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t}\n+      else \n+\tto1 = change_address (data->to, mode,\n+\t\t\t      plus_constant (data->to_addr, data->offset));\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n \n       emit_insn ((*genfun) (to1, const0_rtx));\n+\n       if (HAVE_POST_INCREMENT && data->explicit_inc_to > 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));\n \n-      if (! data->reverse) data->offset += size;\n+      if (! data->reverse)\n+\tdata->offset += size;\n \n       data->len -= size;\n     }\n@@ -2627,17 +2630,17 @@ emit_move_insn_1 (x, y)\n \t     regardless of machine's endianness.  */\n #ifdef STACK_GROWS_DOWNWARD\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, XEXP (x, 0)),\n \t\t      gen_imagpart (submode, y)));\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, XEXP (x, 0)),\n \t\t      gen_realpart (submode, y)));\n #else\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, XEXP (x, 0)),\n \t\t      gen_realpart (submode, y)));\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, XEXP (x, 0)),\n \t\t      gen_imagpart (submode, y)));\n #endif\n \t}\n@@ -2866,7 +2869,7 @@ push_block (size, extra, below)\n \t\t\t      - INTVAL (size) - (below ? 0 : extra));\n       else if (extra != 0 && !below)\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t\tnegate_rtx (Pmode, plus_constant (size, extra)));\n+\t\t\t     negate_rtx (Pmode, plus_constant (size, extra)));\n       else\n \ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t\t     negate_rtx (Pmode, size));\n@@ -3105,6 +3108,11 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  if (GET_CODE (size) == CONST_INT\n \t      && MOVE_BY_PIECES_P ((unsigned) INTVAL (size), align))\n \t    {\n+\t      rtx target = gen_rtx_MEM (BLKmode, temp);\n+\n+\t      if (type != 0)\n+\t\tset_mem_attributes (target, type, 1);\n+\n \t      move_by_pieces (gen_rtx_MEM (BLKmode, temp), xinner,\n \t\t\t      INTVAL (size), align);\n \t      goto ret;\n@@ -3115,6 +3123,9 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      enum machine_mode mode;\n \t      rtx target = gen_rtx_MEM (BLKmode, temp);\n \n+\t      if (type != 0)\n+\t\tset_mem_attributes (target, type, 1);\n+\n \t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t\t   mode != VOIDmode;\n \t\t   mode = GET_MODE_WIDER_MODE (mode))\n@@ -3251,6 +3262,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n     {\n       rtx addr;\n       rtx target = NULL_RTX;\n+      rtx dest;\n \n       /* Push padding now if padding above and stack grows down,\n \t or if padding below and stack grows up.\n@@ -3279,7 +3291,11 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  target = addr;\n \t}\n \n-      emit_move_insn (gen_rtx_MEM (mode, addr), x);\n+      dest = gen_rtx_MEM (mode, addr);\n+      if (type != 0)\n+\tset_mem_attributes (dest, type, 1);\n+\n+      emit_move_insn (dest, x);\n \n       if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t{\n@@ -3994,6 +4010,10 @@ store_expr (exp, target, want_value)\n \n \t      if (size != const0_rtx)\n \t\t{\n+\t\t  rtx dest = gen_rtx_MEM (BLKmode, addr);\n+\n+\t\t  MEM_COPY_ATTRIBUTES (dest, target);\n+\n \t\t  /* Be sure we can write on ADDR.  */\n \t\t  in_check_memory_usage = 1;\n \t\t  if (current_function_check_memory_usage)\n@@ -4003,7 +4023,7 @@ store_expr (exp, target, want_value)\n  \t\t\t\t       GEN_INT (MEMORY_USE_WO), \n \t\t\t\t       TYPE_MODE (integer_type_node));\n \t\t  in_check_memory_usage = 0;\n-\t\t  clear_storage (gen_rtx_MEM (BLKmode, addr), size, align);\n+\t\t  clear_storage (target, size, align);\n \t\t}\n \n \t      if (label)\n@@ -5980,10 +6000,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n \t  if (GET_CODE (addr) == MEM)\n-\t    addr = gen_rtx_MEM (Pmode,\n-\t\t\t\tfix_lexical_addr (XEXP (addr, 0), exp));\n+\t    addr = change_address (addr, Pmode, \n+\t\t\t\t   fix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n+\n \t  temp = change_address (DECL_RTL (exp), mode, addr);\n \t}\n \n@@ -6418,7 +6439,6 @@ expand_expr (exp, target, tmode, modifier)\n     case INDIRECT_REF:\n       {\n \ttree exp1 = TREE_OPERAND (exp, 0);\n-\ttree exp2;\n \ttree index;\n  \ttree string = string_constant (exp1, &index);\n  \n@@ -6456,19 +6476,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \ttemp = gen_rtx_MEM (mode, op0);\n-\t/* If address was computed by addition,\n-\t   mark this as an element of an aggregate.  */\n-\tif (TREE_CODE (exp1) == PLUS_EXPR\n-\t    || (TREE_CODE (exp1) == SAVE_EXPR\n-\t\t&& TREE_CODE (TREE_OPERAND (exp1, 0)) == PLUS_EXPR)\n-\t    || AGGREGATE_TYPE_P (TREE_TYPE (exp))\n-\t    || (TREE_CODE (exp1) == ADDR_EXPR\n-\t\t&& (exp2 = TREE_OPERAND (exp1, 0))\n-\t\t&& AGGREGATE_TYPE_P (TREE_TYPE (exp2))))\n-\t  MEM_SET_IN_STRUCT_P (temp, 1);\n-\n-\tMEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) | flag_volatile;\n-\tMEM_ALIAS_SET (temp) = get_alias_set (exp);\n+\tset_mem_attributes (temp, exp, 0);\n \n \t/* It is incorrect to set RTX_UNCHANGING_P from TREE_READONLY\n \t   here, because, in C and C++, the fact that a location is accessed\n@@ -6893,13 +6901,10 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\tplus_constant (XEXP (op0, 0),\n \t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n \n-\tif (GET_CODE (op0) == MEM)\n-\t  MEM_ALIAS_SET (op0) = get_alias_set (exp);\n- \n+\tset_mem_attributes (op0, exp, 0);\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n \t  mark_reg_pointer (XEXP (op0, 0), alignment);\n \n-\tMEM_SET_IN_STRUCT_P (op0, 1);\n \tMEM_VOLATILE_P (op0) |= volatilep;\n \tif (mode == mode1 || mode1 == BLKmode || mode1 == tmode\n \t    || modifier == EXPAND_CONST_ADDRESS"}, {"sha": "ca82ab1fe49560e501c06cf1f67551caa39bce45", "filename": "gcc/expr.h", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -94,17 +94,17 @@ struct args_size\n \n #define ADD_PARM_SIZE(TO, INC)\t\\\n { tree inc = (INC);\t\t\t\t\\\n-  if (TREE_CODE (inc) == INTEGER_CST)\t\t\\\n-    (TO).constant += TREE_INT_CST_LOW (inc);\t\\\n+  if (host_integerp (inc, 0))\t\t\t\\\n+    (TO).constant += tree_low_cst (inc, 0);\t\\\n   else if ((TO).var == 0)\t\t\t\\\n     (TO).var = inc;\t\t\t\t\\\n   else\t\t\t\t\t\t\\\n     (TO).var = size_binop (PLUS_EXPR, (TO).var, inc); }\n \n #define SUB_PARM_SIZE(TO, DEC)\t\\\n { tree dec = (DEC);\t\t\t\t\\\n-  if (TREE_CODE (dec) == INTEGER_CST)\t\t\\\n-    (TO).constant -= TREE_INT_CST_LOW (dec);\t\\\n+  if (host_integerp (dec, 0))\t\t\t\\\n+    (TO).constant -= tree_low_cst (dec, 0);\t\\\n   else if ((TO).var == 0)\t\t\t\\\n     (TO).var = size_binop (MINUS_EXPR, ssize_int (0), dec); \\\n   else\t\t\t\t\t\t\\\n@@ -915,7 +915,16 @@ extern rtx expand_builtin_va_arg PARAMS ((tree, tree));\n extern rtx expand_builtin_setjmp PARAMS ((rtx, rtx, rtx, rtx));\n extern void expand_builtin_longjmp PARAMS ((rtx, rtx));\n extern rtx expand_builtin_saveregs PARAMS ((void));\n-extern int get_varargs_alias_set PARAMS ((void));\n+extern HOST_WIDE_INT get_varargs_alias_set PARAMS ((void));\n+extern HOST_WIDE_INT get_frame_alias_set PARAMS ((void));\n+extern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\n+extern void record_alias_subset         PARAMS ((HOST_WIDE_INT,\n+\t\t\t\t\t\t HOST_WIDE_INT));\n+#ifdef TREE_CODE\n+extern HOST_WIDE_INT get_alias_set\t\tPARAMS ((tree));\n+extern HOST_WIDE_INT (*lang_get_alias_set)\tPARAMS ((tree));\n+#endif\n+extern HOST_WIDE_INT new_alias_set\t\tPARAMS ((void));\n \f\n /* Functions from expr.c:  */\n \n@@ -1013,10 +1022,9 @@ extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,\n \t\t\t\t    int, rtx));\n \n /* Emit library call.  */\n-extern void emit_library_call PARAMS ((rtx orgfun, int no_queue,\n-  enum machine_mode outmode, int nargs, ...));\n-extern rtx emit_library_call_value PARAMS ((rtx orgfun, rtx value, int no_queue,\n-  enum machine_mode outmode, int nargs, ...));\n+extern void emit_library_call PARAMS ((rtx, int, enum machine_mode, int, ...));\n+extern rtx emit_library_call_value PARAMS ((rtx, rtx, int, enum machine_mode,\n+\t\t\t\t\t    int, ...));\n \n /* Expand an assignment that stores the value of FROM into TO. */\n extern rtx expand_assignment PARAMS ((tree, tree, int, int));\n@@ -1100,10 +1108,17 @@ extern rtx prepare_call_address\tPARAMS ((rtx, tree, rtx *, int));\n \n extern rtx expand_call PARAMS ((tree, rtx, int));\n \n-extern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n-extern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n-extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *, struct args_size *));\n+extern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree,\n+\t\t\t\t rtx, int));\n+extern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx,\n+\t\t\t\t  rtx, rtx, int));\n+extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, tree,\n+\t\t\t\t\t struct args_size *,\n+\t\t\t\t\t struct args_size *,\n+\t\t\t\t\t struct args_size *,\n+\t\t\t\t\t struct args_size *));\n extern rtx expand_inline_function PARAMS ((tree, tree, rtx, int, tree, rtx));\n+\n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n extern rtx label_rtx PARAMS ((tree));\n #endif\n@@ -1132,9 +1147,15 @@ extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n-\n extern rtx validize_mem PARAMS ((rtx));\n \n+#ifdef TREE_CODE\n+/* Given REF, a MEM, and T, either the type of X or the expression\n+   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n+   if we are making a new object of this type.  */\n+extern void set_mem_attributes PARAMS ((rtx, tree, int));\n+#endif\n+\n /* Assemble the static constant template for function entry trampolines.  */\n extern rtx assemble_trampoline_template PARAMS ((void));\n "}, {"sha": "978dc817eb5353fa4e86763626949b0b84fdff31", "filename": "gcc/function.c", "status": "modified", "additions": 41, "deletions": 84, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -204,7 +204,7 @@ struct temp_slot\n      imposed on the memory.  For example, if the stack slot is the\n      call frame for an inline functioned, we have no idea what alias\n      sets will be assigned to various pieces of the call frame.  */\n-  int alias_set;\n+  HOST_WIDE_INT alias_set;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n   tree rtl_expr;\n   /* Non-zero if this temporary is currently in use.  */\n@@ -628,6 +628,7 @@ assign_stack_local_1 (mode, size, align, function)\n \n /* Wrapper around assign_stack_local_1;  assign a local stack slot for the\n    current function.  */\n+\n rtx\n assign_stack_local (mode, size, align)\n      enum machine_mode mode;\n@@ -662,7 +663,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n      tree type;\n {\n   int align;\n-  int alias_set;\n+  HOST_WIDE_INT alias_set;\n   struct temp_slot *p, *best_p = 0;\n \n   /* If SIZE is -1 it means that somebody tried to allocate a temporary\n@@ -684,6 +685,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \n   if (! type)\n     type = type_for_mode (mode, 0);\n+\n   if (type)\n     align = LOCAL_ALIGNMENT (type, align);\n \n@@ -693,7 +695,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   for (p = temp_slots; p; p = p->next)\n     if (p->align >= align && p->size >= size && GET_MODE (p->slot) == mode\n \t&& ! p->in_use\n-\t&& (!flag_strict_aliasing\n+\t&& (! flag_strict_aliasing\n \t    || (alias_set && p->alias_set == alias_set))\n \t&& (best_p == 0 || best_p->size > p->size\n \t    || (best_p->size == p->size && best_p->align > p->align)))\n@@ -712,11 +714,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n       /* If there are enough aligned bytes left over, make them into a new\n \t temp_slot so that the extra bytes don't get wasted.  Do this only\n \t for BLKmode slots, so that we can be sure of the alignment.  */\n-      if (GET_MODE (best_p->slot) == BLKmode\n-\t  /* We can't split slots if -fstrict-aliasing because the\n-\t     information about the alias set for the new slot will be\n-\t     lost.  */\n-\t  && !flag_strict_aliasing)\n+      if (GET_MODE (best_p->slot) == BLKmode)\n \t{\n \t  int alignment = best_p->align / BITS_PER_UNIT;\n \t  HOST_WIDE_INT rounded_size = CEIL_ROUND (size, alignment);\n@@ -734,6 +732,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \t      p->align = best_p->align;\n \t      p->address = 0;\n \t      p->rtl_expr = 0;\n+\t      p->alias_set = best_p->alias_set;\n \t      p->next = temp_slots;\n \t      temp_slots = p;\n \n@@ -824,7 +823,11 @@ assign_stack_temp_for_type (mode, size, keep, type)\n   RTX_UNCHANGING_P (p->slot) = 0;\n   MEM_IN_STRUCT_P (p->slot) = 0;\n   MEM_SCALAR_P (p->slot) = 0;\n-  MEM_ALIAS_SET (p->slot) = 0;\n+  MEM_ALIAS_SET (p->slot) = alias_set;\n+\n+  if (type != 0)\n+    MEM_SET_IN_STRUCT_P (p->slot, AGGREGATE_TYPE_P (type));\n+\n   return p->slot;\n }\n \n@@ -875,11 +878,10 @@ assign_temp (type, keep, memory_required, dont_promote)\n \t instead.  This is the case for Chill variable-sized strings.  */\n       if (size == -1 && TREE_CODE (type) == ARRAY_TYPE\n \t  && TYPE_ARRAY_MAX_SIZE (type) != NULL_TREE\n-\t  && TREE_CODE (TYPE_ARRAY_MAX_SIZE (type)) == INTEGER_CST)\n-\tsize = TREE_INT_CST_LOW (TYPE_ARRAY_MAX_SIZE (type));\n+\t  && host_integerp (TYPE_ARRAY_MAX_SIZE (type), 1))\n+\tsize = tree_low_cst (TYPE_ARRAY_MAX_SIZE (type), 1);\n \n       tmp = assign_stack_temp_for_type (mode, size, keep, type);\n-      MEM_SET_IN_STRUCT_P (tmp, AGGREGATE_TYPE_P (type));\n       return tmp;\n     }\n \n@@ -1397,8 +1399,12 @@ put_var_into_stack (decl)\n       else\n \tput_reg_into_stack (function, reg, TREE_TYPE (decl),\n \t\t\t    promoted_mode, decl_mode,\n-\t\t\t    TREE_SIDE_EFFECTS (decl), 0,\n-\t\t\t    TREE_USED (decl) || DECL_INITIAL (decl) != 0,\n+\t\t\t    (TREE_CODE (decl) != SAVE_EXPR\n+\t\t\t     && TREE_THIS_VOLATILE (decl)),\n+\t\t\t    0,\n+\t\t\t    (TREE_USED (decl)\n+\t\t\t     || (TREE_CODE (decl) != SAVE_EXPR\n+\t\t\t\t && DECL_INITIAL (decl) != 0)),\n \t\t\t    0);\n     }\n   else if (GET_CODE (reg) == CONCAT)\n@@ -2840,9 +2846,14 @@ put_addressof_into_stack (r, ht)\n     abort ();\n \n   put_reg_into_stack (0, reg, TREE_TYPE (decl), GET_MODE (reg),\n-\t\t      DECL_MODE (decl), TREE_SIDE_EFFECTS (decl),\n+\t\t      GET_MODE (reg),\n+\t\t      (TREE_CODE (decl) != SAVE_EXPR\n+\t\t       && TREE_THIS_VOLATILE (decl)),\n \t\t      ADDRESSOF_REGNO (r),\n-\t\t      TREE_USED (decl) || DECL_INITIAL (decl) != 0, ht);\n+\t\t      (TREE_USED (decl)\n+\t\t       || (TREE_CODE (decl) != SAVE_EXPR\n+\t\t\t   && DECL_INITIAL (decl) != 0)),\n+\t\t      ht);\n }\n \n /* List of replacements made below in purge_addressof_1 when creating\n@@ -4168,7 +4179,6 @@ assign_parms (fndecl)\n \n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n-      int aggregate = AGGREGATE_TYPE_P (TREE_TYPE (parm));\n       struct args_size stack_offset;\n       struct args_size arg_size;\n       int passed_pointer = 0;\n@@ -4325,12 +4335,7 @@ assign_parms (fndecl)\n \t\t\t\t\t\t  internal_arg_pointer,\n \t\t\t\t\t\t  offset_rtx));\n \n-\t/* If this is a memory ref that contains aggregate components,\n-\t   mark it as such for cse and loop optimize.  Likewise if it\n-\t   is readonly.  */\n-\tMEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n-\tRTX_UNCHANGING_P (stack_parm) = TREE_READONLY (parm);\n-\tMEM_ALIAS_SET (stack_parm) = get_alias_set (parm);\n+\tset_mem_attributes (stack_parm, parm, 1);\n       }\n \n       /* If this parameter was passed both in registers and in the stack,\n@@ -4435,38 +4440,6 @@ assign_parms (fndecl)\n \t  && nominal_mode != BLKmode && nominal_mode != passed_mode)\n \tstack_parm = 0;\n \n-#if 0\n-      /* Now adjust STACK_PARM to the mode and precise location\n-\t where this parameter should live during execution,\n-\t if we discover that it must live in the stack during execution.\n-\t To make debuggers happier on big-endian machines, we store\n-\t the value in the last bytes of the space available.  */\n-\n-      if (nominal_mode != BLKmode && nominal_mode != passed_mode\n-\t  && stack_parm != 0)\n-\t{\n-\t  rtx offset_rtx;\n-\n-\t  if (BYTES_BIG_ENDIAN\n-\t      && GET_MODE_SIZE (nominal_mode) < UNITS_PER_WORD)\n-\t    stack_offset.constant += (GET_MODE_SIZE (passed_mode)\n-\t\t\t\t      - GET_MODE_SIZE (nominal_mode));\n-\n-\t  offset_rtx = ARGS_SIZE_RTX (stack_offset);\n-\t  if (offset_rtx == const0_rtx)\n-\t    stack_parm = gen_rtx_MEM (nominal_mode, internal_arg_pointer);\n-\t  else\n-\t    stack_parm = gen_rtx_MEM (nominal_mode,\n-\t\t\t\t      gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t\t    internal_arg_pointer,\n-\t\t\t\t\t\t    offset_rtx));\n-\n-\t  /* If this is a memory ref that contains aggregate components,\n-\t     mark it as such for cse and loop optimize.  */\n-\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n-\t}\n-#endif /* 0 */\n-\n       /* ENTRY_PARM is an RTX for the parameter as it arrives,\n \t in the mode in which it arrives.\n \t STACK_PARM is an RTX for a stack slot where the parameter can live\n@@ -4506,18 +4479,12 @@ assign_parms (fndecl)\n \t\t  stack_parm\n \t\t    = assign_stack_local (GET_MODE (entry_parm),\n \t\t\t\t\t  size_stored, 0);\n-\n-\t\t  /* If this is a memory ref that contains aggregate\n-\t\t     components, mark it as such for cse and loop optimize.  */\n-\t\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n+\t\t  set_mem_attributes (stack_parm, parm, 1);\n \t\t}\n \n \t      else if (PARM_BOUNDARY % BITS_PER_WORD != 0)\n \t\tabort ();\n \n-\t      if (TREE_READONLY (parm))\n-\t\tRTX_UNCHANGING_P (stack_parm) = 1;\n-\n \t      /* Handle calls that pass values in multiple non-contiguous\n \t\t locations.  The Irix 6 ABI has examples of this.  */\n \t      if (GET_CODE (entry_parm) == PARALLEL)\n@@ -4566,7 +4533,7 @@ assign_parms (fndecl)\n \t    {\n \t      DECL_RTL (parm)\n \t\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n-\t      MEM_SET_IN_STRUCT_P (DECL_RTL (parm), aggregate);\n+\t      set_mem_attributes (DECL_RTL (parm), parm, 1);\n \t    }\n \t  else\n \t    DECL_RTL (parm) = parmreg;\n@@ -4672,8 +4639,7 @@ assign_parms (fndecl)\n \t      else\n \t\tcopy = assign_stack_temp (TYPE_MODE (type),\n \t\t\t\t\t  int_size_in_bytes (type), 1);\n-\t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n-\t      RTX_UNCHANGING_P (copy) = TREE_READONLY (parm);\n+\t      set_mem_attributes (copy, parm);\n \n \t      store_expr (parm, copy, 0);\n \t      emit_move_insn (parmreg, XEXP (copy, 0));\n@@ -4824,9 +4790,7 @@ assign_parms (fndecl)\n \t\t  stack_parm\n \t\t    = assign_stack_local (GET_MODE (entry_parm),\n \t\t\t\t\t  GET_MODE_SIZE (GET_MODE (entry_parm)), 0);\n-\t\t  /* If this is a memory ref that contains aggregate components,\n-\t\t     mark it as such for cse and loop optimize.  */\n-\t\t  MEM_SET_IN_STRUCT_P (stack_parm, aggregate);\n+\t\t  set_mem_attributes (stack_parm, parm, 1);\n \t\t}\n \n \t      if (promoted_mode != nominal_mode)\n@@ -4863,19 +4827,12 @@ assign_parms (fndecl)\n       if (parm == function_result_decl)\n \t{\n \t  tree result = DECL_RESULT (fndecl);\n-\t  tree restype = TREE_TYPE (result);\n \n \t  DECL_RTL (result)\n \t    = gen_rtx_MEM (DECL_MODE (result), DECL_RTL (parm));\n \n-\t  MEM_SET_IN_STRUCT_P (DECL_RTL (result), \n-\t\t\t       AGGREGATE_TYPE_P (restype));\n+\t  set_mem_attributes (DECL_RTL (result), result, 1);\n \t}\n-\n-      if (TREE_THIS_VOLATILE (parm))\n-\tMEM_VOLATILE_P (DECL_RTL (parm)) = 1;\n-      if (TREE_READONLY (parm))\n-\tRTX_UNCHANGING_P (DECL_RTL (parm)) = 1;\n     }\n \n   /* Output all parameter conversion instructions (possibly including calls)\n@@ -5398,7 +5355,9 @@ fix_lexical_addr (addr, var)\n       addr = fix_lexical_addr (XEXP (fp->x_arg_pointer_save_area, 0), var);\n       addr = memory_address (Pmode, addr);\n \n-      base = copy_to_reg (gen_rtx_MEM (Pmode, addr));\n+      base = gen_rtx_MEM (Pmode, addr);\n+      MEM_ALIAS_SET (base) = get_frame_alias_set ();\n+      base = copy_to_reg (base);\n #else\n       displacement += (FIRST_PARM_OFFSET (context) - STARTING_FRAME_OFFSET);\n       base = lookup_static_chain (var);\n@@ -6149,10 +6108,8 @@ expand_function_start (subr, parms_have_cleanups)\n \t{\n \t  DECL_RTL (DECL_RESULT (subr))\n \t    = gen_rtx_MEM (DECL_MODE (DECL_RESULT (subr)), value_address);\n-\t  MEM_SET_IN_STRUCT_P (DECL_RTL (DECL_RESULT (subr)),\n-\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE\n-\t\t\t\t\t\t (DECL_RESULT\n-\t\t\t\t\t\t  (subr))));\n+\t  set_mem_attributes (DECL_RTL (DECL_RESULT (subr)),\n+\t\t\t      DECL_RESULT (subr), 1);\n \t}\n     }\n   else if (DECL_MODE (DECL_RESULT (subr)) == VOIDmode)\n@@ -6247,9 +6204,9 @@ expand_function_start (subr, parms_have_cleanups)\n #ifdef FRAME_GROWS_DOWNWARD\n \t  last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n #endif\n-\t  last_ptr = copy_to_reg (gen_rtx_MEM (Pmode,\n-\t\t\t\t\t       memory_address (Pmode,\n-\t\t\t\t\t\t\t       last_ptr)));\n+\t  last_ptr = gen_rtx_MEM (Pmode, memory_address (Pmode, last_ptr));\n+\t  MEM_ALIAS_SET (last_ptr) = get_frame_alias_set ();\n+\t  last_ptr = copy_to_reg (last_ptr);\n \n \t  /* If we are not optimizing, ensure that we know that this\n \t     piece of context is live over the entire function.  */"}, {"sha": "556f9f98b29be8695906d14512f89577c8900ae0", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1939,11 +1939,10 @@ mode_independent_operand (op, mode)\n   return 0;\n }\n \n-/* Given an operand OP that is a valid memory reference\n-   which satisfies offsettable_memref_p,\n-   return a new memory reference whose address has been adjusted by OFFSET.\n-   OFFSET should be positive and less than the size of the object referenced.\n-*/\n+/* Given an operand OP that is a valid memory reference which\n+   satisfies offsettable_memref_p, return a new memory reference whose\n+   address has been adjusted by OFFSET.  OFFSET should be positive and\n+   less than the size of the object referenced.  */\n \n rtx\n adj_offsettable_operand (op, offset)\n@@ -1961,7 +1960,7 @@ adj_offsettable_operand (op, offset)\n \t{\n \t  new = gen_rtx_MEM (GET_MODE (op),\n \t\t\t     plus_constant_for_output (y, offset));\n-\t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n+\t  MEM_COPY_ATTRIBUTES (new, op);\n \t  return new;\n \t}\n \n@@ -1981,7 +1980,7 @@ adj_offsettable_operand (op, offset)\n \t}\n \n       new = gen_rtx_MEM (GET_MODE (op), plus_constant_for_output (y, offset));\n-      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n+      MEM_COPY_ATTRIBUTES (new, op);\n       return new;\n     }\n   abort ();"}, {"sha": "44d63e254194ab5670d84993be5c67ef1600917e", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -2234,6 +2234,8 @@ try_apply_stack_adjustment (insn, memlist, new_adjust, delta)\n   for (ml = memlist; ml ; ml = ml->next)\n     {\n       HOST_WIDE_INT c = ml->sp_offset - delta;\n+      rtx new = gen_rtx_MEM (GET_MODE (*ml->mem),\n+\t\t\t     plus_constant (stack_pointer_rtx, c));\n \n       /* Don't reference memory below the stack pointer.  */\n       if (c < 0)\n@@ -2242,9 +2244,8 @@ try_apply_stack_adjustment (insn, memlist, new_adjust, delta)\n \t  return 0;\n \t}\n \n-      validate_change (ml->insn, ml->mem,\n-\t\t       gen_rtx_MEM (GET_MODE (*ml->mem),\n-\t\t\t\t    plus_constant (stack_pointer_rtx, c)), 1);\n+      MEM_COPY_ATTRIBUTES (new, *ml->mem);\n+      validate_change (ml->insn, ml->mem, new, 1);\n     }\n \n   if (apply_change_group ())"}, {"sha": "0a6d14cd7e5666669e44191fb4be0da4d3d9105e", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -860,10 +860,20 @@ push_reload (in, out, inloc, outloc, class,\n     {\n       if (GET_CODE (XEXP (in, 0)) == POST_INC\n \t  || GET_CODE (XEXP (in, 0)) == POST_DEC)\n-\tin = gen_rtx_MEM (GET_MODE (in), XEXP (XEXP (in, 0), 0));\n+\t{\n+\t  rtx new = gen_rtx_MEM (GET_MODE (in), XEXP (XEXP (in, 0), 0));\n+\n+\t  MEM_COPY_ATTRIBUTES (new, in);\n+\t  in = new;\n+\t}\n       if (GET_CODE (XEXP (in, 0)) == PRE_INC\n \t  || GET_CODE (XEXP (in, 0)) == PRE_DEC)\n-\tout = gen_rtx_MEM (GET_MODE (out), XEXP (XEXP (out, 0), 0));\n+\t{\n+\t  rtx new = gen_rtx_MEM (GET_MODE (out), XEXP (XEXP (out, 0), 0));\n+\n+\t  MEM_COPY_ATTRIBUTES (new, out);\n+\t  out = new;\n+\t}\n     }\n \n   /* If we are reloading a (SUBREG constant ...), really reload just the\n@@ -4344,7 +4354,7 @@ make_memloc (ad, regno)\n     tem = copy_rtx (tem);\n \n   tem = gen_rtx_MEM (GET_MODE (ad), tem);\n-  RTX_UNCHANGING_P (tem) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n+  MEM_COPY_ATTRIBUTES (tem, reg_equiv_memory_loc[regno]);\n   return tem;\n }\n "}, {"sha": "3378a689d61ca77e23ad7bfa84276dbbe7a6af8a", "filename": "gcc/reload1.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1913,20 +1913,26 @@ alter_reg (i, from_reg)\n \t    adjust = inherent_size - total_size;\n \n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[i]);\n+\n+\t  /* Nothing can alias this slot except this pseudo.  */\n+\t  MEM_ALIAS_SET (x) = new_alias_set ();\n \t}\n+\n       /* Reuse a stack slot if possible.  */\n       else if (spill_stack_slot[from_reg] != 0\n \t       && spill_stack_slot_width[from_reg] >= total_size\n \t       && (GET_MODE_SIZE (GET_MODE (spill_stack_slot[from_reg]))\n \t\t   >= inherent_size))\n \tx = spill_stack_slot[from_reg];\n+\n       /* Allocate a bigger slot.  */\n       else\n \t{\n \t  /* Compute maximum size needed, both for inherent size\n \t     and for total size.  */\n \t  enum machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n \t  rtx stack_slot;\n+\n \t  if (spill_stack_slot[from_reg])\n \t    {\n \t      if (GET_MODE_SIZE (GET_MODE (spill_stack_slot[from_reg]))\n@@ -1935,10 +1941,18 @@ alter_reg (i, from_reg)\n \t      if (spill_stack_slot_width[from_reg] > total_size)\n \t\ttotal_size = spill_stack_slot_width[from_reg];\n \t    }\n+\n \t  /* Make a slot with that size.  */\n \t  x = assign_stack_local (mode, total_size,\n \t\t\t\t  inherent_size == total_size ? 0 : -1);\n \t  stack_slot = x;\n+\n+\t  /* All pseudos mapped to this slot can alias each other.  */\n+\t  if (spill_stack_slot[from_reg])\n+\t    MEM_ALIAS_SET (x) = MEM_ALIAS_SET (spill_stack_slot[from_reg]);\n+\t  else\n+\t    MEM_ALIAS_SET (x) = new_alias_set ();\n+\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n \t      /* Cancel the  big-endian correction done in assign_stack_local.\n@@ -1952,6 +1966,7 @@ alter_reg (i, from_reg)\n \t\t\t\t\t\t\t MODE_INT, 1),\n \t\t\t\t\t  plus_constant (XEXP (x, 0), adjust));\n \t    }\n+\n \t  spill_stack_slot[from_reg] = stack_slot;\n \t  spill_stack_slot_width[from_reg] = total_size;\n \t}\n@@ -1965,16 +1980,11 @@ alter_reg (i, from_reg)\n \t wrong mode, make a new stack slot.  */\n       if (adjust != 0 || GET_MODE (x) != GET_MODE (regno_reg_rtx[i]))\n \t{\n-\t  x = gen_rtx_MEM (GET_MODE (regno_reg_rtx[i]),\n-\t\t\t   plus_constant (XEXP (x, 0), adjust));\n-\n-\t  /* If this was shared among registers, must ensure we never\n-\t     set it readonly since that can cause scheduling\n-\t     problems.  Note we would only have in this adjustment\n-\t     case in any event, since the code above doesn't set it.  */\n+\t  rtx new = gen_rtx_MEM (GET_MODE (regno_reg_rtx[i]),\n+\t\t\t\t plus_constant (XEXP (x, 0), adjust));\n \n-\t  if (from_reg == -1)\n-\t    RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[i]);\n+\t  MEM_COPY_ATTRIBUTES (new, x);\n+\t  x = new;\n \t}\n \n       /* Save the stack slot for later.   */\n@@ -2496,9 +2506,7 @@ eliminate_regs (x, mem_mode, insn)\n       if (new != XEXP (x, 0))\n \t{\n \t  new = gen_rtx_MEM (GET_MODE (x), new);\n-\t  new->volatil = x->volatil;\n-\t  new->unchanging = x->unchanging;\n-\t  new->in_struct = x->in_struct;\n+\t  MEM_COPY_ATTRIBUTES (new, x);\n \t  return new;\n \t}\n       else"}, {"sha": "dc0d95b698312f75e157403090d49c7d12694618", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -628,7 +628,7 @@ DEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", 'o')\n \n /* A memory location; operand is the address.  Can be nested inside a\n    VOLATILE.  The second operand is the alias set to which this MEM\n-   belongs.  We use `0' instead of `i' for this field so that the\n+   belongs.  We use `0' instead of `w' for this field so that the\n    field need not be specified in machine descriptions.  */\n DEF_RTL_EXPR(MEM, \"mem\", \"e0\", 'o')\n "}, {"sha": "cca5d52a7aa6e6352b4cd8627abe72b35b9b5bf0", "filename": "gcc/rtl.h", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -746,31 +746,26 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC ((RTX), 4, ASM_OPERANDS)\n #define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP ((RTX), 3, (N), ASM_OPERANDS)\n #define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN ((RTX), 3, ASM_OPERANDS)\n-#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) XSTR (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS), 0)\n-#define ASM_OPERANDS_INPUT_MODE(RTX, N) GET_MODE (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS))\n+#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) \\\n+\t\t\tXSTR (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS), 0)\n+#define ASM_OPERANDS_INPUT_MODE(RTX, N)  \\\n+\t\t\tGET_MODE (XCVECEXP ((RTX), 4, (N), ASM_OPERANDS))\n #define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR ((RTX), 5, ASM_OPERANDS)\n #define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT ((RTX), 6, ASM_OPERANDS)\n \n /* For a MEM rtx, 1 if it's a volatile reference.\n    Also in an ASM_OPERANDS rtx.  */\n #define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n \n-/* For a MEM rtx, 1 if it refers to a field of an aggregate.  If zero,\n-   RTX may or may not refer to a field of an aggregate.  */\n+/* For a MEM rtx, 1 if it refers to an aggregate, either to the\n+   aggregate itself of to a field of the aggregate.  If zero, RTX may\n+   or may not be such a refrence.  */\n #define MEM_IN_STRUCT_P(RTX) ((RTX)->in_struct)\n \n /* For a MEM rtx, 1 if it refers to a scalar.  If zero, RTX may or may\n    not refer to a scalar.*/\n #define MEM_SCALAR_P(RTX) ((RTX)->frame_related)\n \n-/* Copy the attributes that apply to memory locations from RHS to LHS.  */\n-#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\\n-  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\\\n-   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\\\n-   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\\\n-   MEM_ALIAS_SET (LHS) = MEM_ALIAS_SET (RHS),\t\t\\\n-   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS))\n-\n /* If VAL is non-zero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n    RTX.  Otherwise, vice versa.  Use this macro only when you are\n    *sure* that you know that the MEM is in a structure, or is a\n@@ -797,7 +792,15 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n    some front-ends, these numbers may correspond in some way to types,\n    or other language-level entities, but they need not, and the\n    back-end makes no such assumptions.  */\n-#define MEM_ALIAS_SET(RTX) XCINT(RTX, 1, MEM)\n+#define MEM_ALIAS_SET(RTX) XCWINT(RTX, 1, MEM)\n+\n+/* Copy the attributes that apply to memory locations from RHS to LHS.  */\n+#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\\n+  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\\\n+   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\\\n+   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\\\n+   MEM_ALIAS_SET (LHS) = MEM_ALIAS_SET (RHS),\t\t\\\n+   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS))\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */\n@@ -1645,7 +1648,9 @@ extern int preserve_subexpressions_p\tPARAMS ((void));\n \n /* In expr.c */\n extern void init_expr_once\t\tPARAMS ((void));\n-extern void move_by_pieces\t\tPARAMS ((rtx, rtx, int, unsigned int));\n+extern void move_by_pieces\t\tPARAMS ((rtx, rtx,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t unsigned int));\n \n /* In flow.c */\n extern void allocate_bb_life_data\tPARAMS ((void));\n@@ -1821,9 +1826,6 @@ extern void mark_constant_function\tPARAMS ((void));\n extern void init_alias_once\t\tPARAMS ((void));\n extern void init_alias_analysis\t\tPARAMS ((void));\n extern void end_alias_analysis\t\tPARAMS ((void));\n-\n-extern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\n-extern void record_alias_subset         PARAMS ((int, int));\n extern rtx addr_side_effect_eval\tPARAMS ((rtx, int, int));\n \n /* In sibcall.c */"}, {"sha": "f134de17fee21768302b673b5c4a9bd194c6fc10", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -3792,7 +3792,8 @@ expand_decl (decl)\n \t/* An initializer is going to decide the size of this array.\n \t   Until we know the size, represent its address with a reg.  */\n \tDECL_RTL (decl) = gen_rtx_MEM (BLKmode, gen_reg_rtx (Pmode));\n-      MEM_SET_IN_STRUCT_P (DECL_RTL (decl), AGGREGATE_TYPE_P (type));\n+\n+      set_mem_attributes (DECL_RTL (decl), decl, 1);\n     }\n   else if (DECL_MODE (decl) != BLKmode\n \t   /* If -ffloat-store, don't put explicit float vars\n@@ -3817,6 +3818,8 @@ expand_decl (decl)\n \tmark_reg_pointer (DECL_RTL (decl),\n \t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n \t\t\t  \n+      if (TREE_READONLY (decl))\n+\tRTX_UNCHANGING_P (DECL_RTL (decl)) = 1;\n     }\n \n   else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST\n@@ -3841,8 +3844,6 @@ expand_decl (decl)\n \t}\n \n       DECL_RTL (decl) = assign_temp (TREE_TYPE (decl), 1, 1, 1);\n-      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n-\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n \n       /* Set alignment we actually gave this decl.  */\n       DECL_ALIGN (decl) = (DECL_MODE (decl) == BLKmode ? BIGGEST_ALIGNMENT\n@@ -3854,20 +3855,6 @@ expand_decl (decl)\n \t  if (addr != oldaddr)\n \t    emit_move_insn (oldaddr, addr);\n \t}\n-\n-      /* If this is a memory ref that contains aggregate components,\n-\t mark it as such for cse and loop optimize.  */\n-      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n-\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n-#if 0\n-      /* If this is in memory because of -ffloat-store,\n-\t set the volatile bit, to prevent optimizations from\n-\t undoing the effects.  */\n-      if (flag_float_store && TREE_CODE (type) == REAL_TYPE)\n-\tMEM_VOLATILE_P (DECL_RTL (decl)) = 1;\n-#endif\n-\n-      MEM_ALIAS_SET (DECL_RTL (decl)) = get_alias_set (decl);\n     }\n   else\n     /* Dynamic-size object: must push space on the stack.  */\n@@ -3905,10 +3892,7 @@ expand_decl (decl)\n       /* Reference the variable indirect through that rtx.  */\n       DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl), address);\n \n-      /* If this is a memory ref that contains aggregate components,\n-\t mark it as such for cse and loop optimize.  */\n-      MEM_SET_IN_STRUCT_P (DECL_RTL (decl),\n-\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)));\n+      set_mem_attributes (DECL_RTL (decl), decl, 1);\n \n       /* Indicate the alignment we actually gave this variable.  */\n #ifdef STACK_BOUNDARY\n@@ -3917,12 +3901,6 @@ expand_decl (decl)\n       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n #endif\n     }\n-\n-  if (TREE_THIS_VOLATILE (decl))\n-    MEM_VOLATILE_P (DECL_RTL (decl)) = 1;\n-\n-  if (TREE_READONLY (decl))\n-    RTX_UNCHANGING_P (DECL_RTL (decl)) = 1;\n }\n \f\n /* Emit code to perform the initialization of a declaration DECL.  */"}, {"sha": "a581d1fef0a2a66f2985cc2442a5e79baa03c813", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1173,6 +1173,9 @@ finish_record_layout (rli)\n       rli->pending_statics = TREE_CHAIN (rli->pending_statics);\n     }\n \n+  /* Show any alias subsetting we need.  */\n+  record_component_aliases (rli->t);\n+\n   /* Clean up.  */\n   free (rli);\n }"}, {"sha": "5fa9851dd99479eac34cd37b45cfe74d61f6e108", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -2090,13 +2090,13 @@ compile_file (name)\n \t\t  || flag_test_coverage\n \t\t  || warn_notreached);\n   init_regs ();\n+  init_alias_once ();\n   init_decl_processing ();\n   init_optabs ();\n   init_stmt ();\n   init_eh ();\n   init_loop ();\n   init_reload ();\n-  init_alias_once ();\n   init_function_once ();\n   init_stor_layout_once ();\n   init_varasm_once ();"}, {"sha": "2a356edba8d7ae6b3cacac79b89597865a570106", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -246,10 +246,6 @@ static int next_decl_uid;\n /* Unique id for next type created.  */\n static int next_type_uid = 1;\n \n-/* The language-specific function for alias analysis.  If NULL, the\n-   language does not do any special alias analysis.  */\n-int (*lang_get_alias_set) PARAMS ((tree));\n-\n /* Here is how primitive or already-canonicalized types' hash\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)\n@@ -5614,38 +5610,6 @@ tree_class_check_failed (node, cl, file, line, function)\n \n #endif /* ENABLE_TREE_CHECKING */\n \n-/* Return the alias set for T, which may be either a type or an\n-   expression.  */\n-\n-int\n-get_alias_set (t)\n-     tree t;\n-{\n-  /* If we're not doing any lanaguage-specific alias analysis, just\n-     assume everything aliases everything else.  */\n-  if (! flag_strict_aliasing || lang_get_alias_set == 0)\n-    return 0;\n-\n-  /* If this is a type with a known alias set, return it since this must\n-     be the correct thing to do.  */\n-  else if (TYPE_P (t) && TYPE_ALIAS_SET_KNOWN_P (t))\n-    return TYPE_ALIAS_SET (t);\n-  else\n-    return (*lang_get_alias_set) (t);\n-}\n-\n-/* Return a brand-new alias set.  */\n-\n-int\n-new_alias_set ()\n-{\n-  static int last_alias_set;\n-\n-  if (flag_strict_aliasing)\n-    return ++last_alias_set;\n-  else\n-    return 0;\n-}\n \f\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT"}, {"sha": "09758cbb275c23162bcf81b14ed8929f60d761a5", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bdf5ad13852aaa871ab41a6e8f509809c8c104d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3bdf5ad13852aaa871ab41a6e8f509809c8c104d", "patch": "@@ -1114,7 +1114,7 @@ struct tree_type\n   union tree_node *noncopied_parts;\n   union tree_node *context;\n   struct obstack *obstack;\n-  int alias_set;\n+  HOST_WIDE_INT alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_type *lang_specific;\n };\n@@ -1620,7 +1620,7 @@ struct tree_decl\n   } u2;\n \n   union tree_node *vindex;\n-  int pointer_alias_set;\n+  HOST_WIDE_INT pointer_alias_set;\n   /* Points to a structure whose details depend on the language in use.  */\n   struct lang_decl *lang_specific;\n };\n@@ -2373,9 +2373,6 @@ extern tree get_file_function_name_long \tPARAMS ((const char *));\n extern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));\n extern tree get_set_constructor_bytes\t\tPARAMS ((tree,\n \t\t\t\t\t\t       unsigned char *, int));\n-extern int get_alias_set                        PARAMS ((tree));\n-extern int new_alias_set\t\t\tPARAMS ((void));\n-extern int (*lang_get_alias_set)                PARAMS ((tree));\n extern tree get_callee_fndecl                   PARAMS ((tree));\n \f\n /* In stmt.c */"}]}