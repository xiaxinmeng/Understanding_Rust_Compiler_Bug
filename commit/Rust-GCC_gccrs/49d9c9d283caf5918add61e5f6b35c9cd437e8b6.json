{"sha": "49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlkOWM5ZDI4M2NhZjU5MThhZGQ2MWU1ZjZiMzVjOWNkNDM3ZThiNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-09T17:52:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-09T17:52:56Z"}, "message": "ipa-inline-analysis.c (do_estimate_growth_1): Add support for capping the growth cumulated.\n\n\n\t* ipa-inline-analysis.c (do_estimate_growth_1): Add support for\n\tcapping the growth cumulated.\n\t(offline_size): Break out from ...\n\t(estimate_growth): ... here.\n\t(check_callers): Add N, OFFLINE and MIN_SIZE and KNOWN_EDGE\n\tparameters.\n\t(growth_likely_positive): Turn to ...\n\t(growth_positive_p): Re-implement.\n\t* ipa-inline.h (growth_likely_positive): Remove.\n\t(growth_positive_p): Declare.\n\t* ipa-inline.c (want_inline_small_function_p): Use\n\tgrowth_positive_p.\n\t(want_inline_function_to_all_callers_p): Likewise.\n\nFrom-SVN: r278007", "tree": {"sha": "0db402ab020b3a5690e4253c117311e4c15806b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0db402ab020b3a5690e4253c117311e4c15806b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/comments", "author": null, "committer": null, "parents": [{"sha": "e3bd08dde17aa654c1aecade0807251e082c702c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3bd08dde17aa654c1aecade0807251e082c702c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3bd08dde17aa654c1aecade0807251e082c702c"}], "stats": {"total": 193, "additions": 126, "deletions": 67}, "files": [{"sha": "1a1c68c3d8ab35f941e52005022318e6c1ff4607", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "patch": "@@ -1,3 +1,19 @@\n+2019-11-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (do_estimate_growth_1): Add support for\n+\tcapping the growth cumulated.\n+\t(offline_size): Break out from ...\n+\t(estimate_growth): ... here.\n+\t(check_callers): Add N, OFFLINE and MIN_SIZE and KNOWN_EDGE\n+\tparameters.\n+\t(growth_likely_positive): Turn to ...\n+\t(growth_positive_p): Re-implement.\n+\t* ipa-inline.h (growth_likely_positive): Remove.\n+\t(growth_positive_p): Declare.\n+\t* ipa-inline.c (want_inline_small_function_p): Use\n+\tgrowth_positive_p.\n+\t(want_inline_function_to_all_callers_p): Likewise.\n+\n 2019-11-09  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-fnsummary.c (ipa_call_context::estimate_size_and_time): Fix"}, {"sha": "9839cae43a3fbf808cc7bbcfff7cd30f4f605175", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 103, "deletions": 60, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "patch": "@@ -387,6 +387,7 @@ struct growth_data\n   bool self_recursive;\n   bool uninlinable;\n   int growth;\n+  int cap;\n };\n \n \n@@ -406,59 +407,75 @@ do_estimate_growth_1 (struct cgraph_node *node, void *data)\n \t  || !opt_for_fn (e->caller->decl, optimize))\n \t{\n \t  d->uninlinable = true;\n+\t  if (d->cap < INT_MAX)\n+\t    return true;\n           continue;\n \t}\n \n       if (e->recursive_p ())\n \t{\n \t  d->self_recursive = true;\n+\t  if (d->cap < INT_MAX)\n+\t    return true;\n \t  continue;\n \t}\n       d->growth += estimate_edge_growth (e);\n+      if (d->growth > d->cap)\n+\treturn true;\n     }\n   return false;\n }\n \n+/* Return estimated savings for eliminating offline copy of NODE by inlining\n+   it everywhere.  */\n+\n+static int\n+offline_size (struct cgraph_node *node, ipa_size_summary *info)\n+{\n+  if (!DECL_EXTERNAL (node->decl))\n+    {\n+      if (node->will_be_removed_from_program_if_no_direct_calls_p ())\n+\treturn info->size;\n+      /* COMDAT functions are very often not shared across multiple units\n+         since they come from various template instantiations.\n+         Take this into account.  */\n+      else if (DECL_COMDAT (node->decl)\n+\t       && node->can_remove_if_no_direct_calls_p ())\n+\treturn (info->size\n+\t        * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n+\t        + 50) / 100;\n+    }\n+  return 0;\n+}\n \n /* Estimate the growth caused by inlining NODE into all callees.  */\n \n int\n estimate_growth (struct cgraph_node *node)\n {\n-  struct growth_data d = { node, false, false, 0 };\n-  class ipa_size_summary *info = ipa_size_summaries->get (node);\n+  struct growth_data d = { node, false, false, 0, INT_MAX };\n+  ipa_size_summary *info = ipa_size_summaries->get (node);\n \n-  node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true);\n+  if (node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true))\n+    return 1;\n \n   /* For self recursive functions the growth estimation really should be\n      infinity.  We don't want to return very large values because the growth\n      plays various roles in badness computation fractions.  Be sure to not\n      return zero or negative growths. */\n   if (d.self_recursive)\n     d.growth = d.growth < info->size ? info->size : d.growth;\n-  else if (DECL_EXTERNAL (node->decl) || d.uninlinable)\n-    ;\n-  else\n-    {\n-      if (node->will_be_removed_from_program_if_no_direct_calls_p ())\n-\td.growth -= info->size;\n-      /* COMDAT functions are very often not shared across multiple units\n-         since they come from various template instantiations.\n-         Take this into account.  */\n-      else if (DECL_COMDAT (node->decl)\n-\t       && node->can_remove_if_no_direct_calls_p ())\n-\td.growth -= (info->size\n-\t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n-\t\t     + 50) / 100;\n-    }\n+  else if (!d.uninlinable)\n+    d.growth -= offline_size (node, info);\n \n   return d.growth;\n }\n \n /* Verify if there are fewer than MAX_CALLERS.  */\n \n static bool\n-check_callers (cgraph_node *node, int *max_callers)\n+check_callers (cgraph_node *node, int *growth, int *n, int offline,\n+\t       int min_size, struct cgraph_edge *known_edge)\n {\n   ipa_ref *ref;\n \n@@ -467,70 +484,96 @@ check_callers (cgraph_node *node, int *max_callers)\n \n   for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n     {\n-      (*max_callers)--;\n-      if (!*max_callers\n-\t  || cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+      edge_growth_cache_entry *entry;\n+\n+      if (e == known_edge)\n+\tcontinue;\n+      if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+\treturn true;\n+      if (edge_growth_cache != NULL\n+\t  && (entry = edge_growth_cache->get (e)) != NULL\n+\t  && entry->size != 0)\n+\t*growth += entry->size - (entry->size > 0);\n+      else\n+\t{\n+\t  class ipa_call_summary *es = ipa_call_summaries->get (e);\n+\t  if (!es)\n+\t    return true;\n+\t  *growth += min_size - es->call_stmt_size;\n+\t  if (--(*n) < 0)\n+\t    return false;\n+\t}\n+      if (*growth > offline)\n \treturn true;\n     }\n \n-  FOR_EACH_ALIAS (node, ref)\n-    if (check_callers (dyn_cast <cgraph_node *> (ref->referring), max_callers))\n-      return true;\n+  if (*n > 0)\n+    FOR_EACH_ALIAS (node, ref)\n+      if (check_callers (dyn_cast <cgraph_node *> (ref->referring), growth, n,\n+\t\t\t offline, min_size, known_edge))\n+\treturn true;\n \n   return false;\n }\n \n \n-/* Make cheap estimation if growth of NODE is likely positive knowing\n-   EDGE_GROWTH of one particular edge. \n-   We assume that most of other edges will have similar growth\n-   and skip computation if there are too many callers.  */\n+/* Decide if growth of NODE is positive.  This is cheaper than calculating\n+   actual growth.  If edge growth of KNOWN_EDGE is known\n+   it is passed by EDGE_GROWTH.  */\n \n bool\n-growth_likely_positive (struct cgraph_node *node,\n-\t\t        int edge_growth)\n+growth_positive_p (struct cgraph_node *node,\n+\t\t   struct cgraph_edge * known_edge, int edge_growth)\n {\n-  int max_callers;\n   struct cgraph_edge *e;\n-  gcc_checking_assert (edge_growth > 0);\n+\n+  ipa_size_summary *s = ipa_size_summaries->get (node);\n \n   /* First quickly check if NODE is removable at all.  */\n-  if (DECL_EXTERNAL (node->decl))\n-    return true;\n-  if (!node->can_remove_if_no_direct_calls_and_refs_p ()\n-      || node->address_taken)\n+  int offline = offline_size (node, s);\n+  if (offline <= 0 && known_edge && edge_growth > 0)\n     return true;\n \n-  max_callers = ipa_size_summaries->get (node)->size * 4 / edge_growth + 2;\n+  int min_size = ipa_fn_summaries->get (node)->min_size;\n+  int n = 10;\n \n+  int min_growth = known_edge ? edge_growth : 0;\n   for (e = node->callers; e; e = e->next_caller)\n     {\n-      max_callers--;\n-      if (!max_callers\n-\t  || cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+      edge_growth_cache_entry *entry;\n+\n+      if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+\treturn true;\n+      if (e == known_edge)\n+\tcontinue;\n+      if (edge_growth_cache != NULL\n+\t  && (entry = edge_growth_cache->get (e)) != NULL\n+\t  && entry->size != 0)\n+\tmin_growth += entry->size - (entry->size > 0);\n+      else\n+\t{\n+\t  class ipa_call_summary *es = ipa_call_summaries->get (e);\n+\t  if (!es)\n+\t    return true;\n+\t  min_growth += min_size - es->call_stmt_size;\n+\t  if (--n <= 0)\n+\t    break;\n+\t}\n+      if (min_growth > offline)\n \treturn true;\n     }\n \n   ipa_ref *ref;\n-  FOR_EACH_ALIAS (node, ref)\n-    if (check_callers (dyn_cast <cgraph_node *> (ref->referring), &max_callers))\n-      return true;\n-\n-  /* Unlike for functions called once, we play unsafe with\n-     COMDATs.  We can allow that since we know functions\n-     in consideration are small (and thus risk is small) and\n-     moreover grow estimates already accounts that COMDAT\n-     functions may or may not disappear when eliminated from\n-     current unit. With good probability making aggressive\n-     choice in all units is going to make overall program\n-     smaller.  */\n-  if (DECL_COMDAT (node->decl))\n-    {\n-      if (!node->can_remove_if_no_direct_calls_p ())\n+  if (n > 0)\n+    FOR_EACH_ALIAS (node, ref)\n+      if (check_callers (dyn_cast <cgraph_node *> (ref->referring),\n+\t\t\t &min_growth, &n, offline, min_size, known_edge))\n \treturn true;\n-    }\n-  else if (!node->will_be_removed_from_program_if_no_direct_calls_p ())\n-    return true;\n \n-  return estimate_growth (node) > 0;\n+  struct growth_data d = { node, false, false, 0, offline };\n+  if (node->call_for_symbol_and_aliases (do_estimate_growth_1, &d, true))\n+    return true;\n+  if (d.self_recursive || d.uninlinable)\n+    return true;\n+  return (d.growth > offline);\n }"}, {"sha": "83764f6100a8b4a1ff57debaff460994aa6a03df", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "patch": "@@ -883,9 +883,9 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && !opt_for_fn (e->caller->decl, flag_inline_functions)\n \t       && growth >= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SMALL))\n \t{\n-\t  /* growth_likely_positive is expensive, always test it last.  */\n+\t  /* growth_positive_p is expensive, always test it last.  */\n           if (growth >= inline_insns_single (e->caller, false)\n-\t      || growth_likely_positive (callee, growth))\n+\t      || growth_positive_p (callee, e, growth))\n \t    {\n               e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t      want_inline = false;\n@@ -899,9 +899,9 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t   || growth >= inline_insns_auto (e->caller, true)\n \t\t   || !big_speedup_p (e)))\n \t{\n-\t  /* growth_likely_positive is expensive, always test it last.  */\n+\t  /* growth_positive_p is expensive, always test it last.  */\n           if (growth >= inline_insns_single (e->caller, false)\n-\t      || growth_likely_positive (callee, growth))\n+\t      || growth_positive_p (callee, e, growth))\n \t    {\n \t      if (opt_for_fn (e->caller->decl, optimize) >= 3)\n \t\te->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -913,7 +913,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       /* If call is cold, do not inline when function body would grow. */\n       else if (!e->maybe_hot_p ()\n \t       && (growth >= inline_insns_single (e->caller, false)\n-\t\t   || growth_likely_positive (callee, growth)))\n+\t\t   || growth_positive_p (callee, e, growth)))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;\n@@ -1075,7 +1075,7 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n   if (!node->call_for_symbol_and_aliases (has_caller_p, NULL, true))\n     return false;\n   /* Inlining into all callers would increase size?  */\n-  if (estimate_growth (node) > 0)\n+  if (growth_positive_p (node, NULL, INT_MIN) > 0)\n     return false;\n   /* All inlines must be possible.  */\n   if (node->call_for_symbol_and_aliases (check_callers, &has_hot_call,"}, {"sha": "f650b0e83fae086d93333e56a673d8965fbba015", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49d9c9d283caf5918add61e5f6b35c9cd437e8b6/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=49d9c9d283caf5918add61e5f6b35c9cd437e8b6", "patch": "@@ -44,7 +44,7 @@ extern fast_call_summary<edge_growth_cache_entry *, va_heap> *edge_growth_cache;\n /* In ipa-inline-analysis.c  */\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_growth (struct cgraph_node *);\n-bool growth_likely_positive (struct cgraph_node *, int);\n+bool growth_positive_p (struct cgraph_node *, struct cgraph_edge *, int);\n int do_estimate_edge_size (struct cgraph_edge *edge);\n sreal do_estimate_edge_time (struct cgraph_edge *edge);\n ipa_hints do_estimate_edge_hints (struct cgraph_edge *edge);"}]}