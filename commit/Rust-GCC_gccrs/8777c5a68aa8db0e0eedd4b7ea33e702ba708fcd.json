{"sha": "8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc3N2M1YTY4YWE4ZGIwZTBlZWRkNGI3ZWEzM2U3MDJiYTcwOGZjZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T12:16:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T12:16:20Z"}, "message": "[multiple changes]\n\n2012-05-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb, sem_util.adb, s-stposu.adb, exp_ch4.adb: Minor\n\treformatting.\n\n2012-05-15  Geert Bosch  <bosch@adacore.com>\n\n\t* uintp.adb (UI_Rem): Remove optimizations, as they are complex and are\n\tnot needed.\n\t(Sum_Digits): Remove, no longer used.\n\t(Sum_Double_Digits): Likewise.\n\n2012-05-15  Yannick Moy  <moy@adacore.com>\n\n\t* aspects.ads: Minor typo.\n\n2012-05-15  Thomas Quinot  <quinot@adacore.com>\n\n\t* gnat_rm.texi (Scalar_Storage_Order): Fix RM reference.\n\t* sem_ch13.adb: Minor comment fix: incorrect RM reference.\n\n2012-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Propagate\n\tatomicity from an object to its underlying type only if it\n\tis composite.\n\nFrom-SVN: r187532", "tree": {"sha": "82825f5ae7579fc9073dec10a400741c1a32ca4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82825f5ae7579fc9073dec10a400741c1a32ca4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/comments", "author": null, "committer": null, "parents": [{"sha": "b25ce290ca03957618015e02f49fbcf79062c7fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25ce290ca03957618015e02f49fbcf79062c7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25ce290ca03957618015e02f49fbcf79062c7fc"}], "stats": {"total": 461, "additions": 64, "deletions": 397}, "files": [{"sha": "f2742ff6da4ede8b1396f4c136171f80c8d232e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -1,3 +1,30 @@\n+2012-05-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb, sem_util.adb, s-stposu.adb, exp_ch4.adb: Minor\n+\treformatting.\n+\n+2012-05-15  Geert Bosch  <bosch@adacore.com>\n+\n+\t* uintp.adb (UI_Rem): Remove optimizations, as they are complex and are\n+\tnot needed.\n+\t(Sum_Digits): Remove, no longer used.\n+\t(Sum_Double_Digits): Likewise.\n+\n+2012-05-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* aspects.ads: Minor typo.\n+\n+2012-05-15  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* gnat_rm.texi (Scalar_Storage_Order): Fix RM reference.\n+\t* sem_ch13.adb: Minor comment fix: incorrect RM reference.\n+\n+2012-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_prag.adb (Process_Atomic_Shared_Volatile): Propagate\n+\tatomicity from an object to its underlying type only if it\n+\tis composite.\n+\n 2012-05-15  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch5.adb (Analyze_Iterator_Specification): Set kind of"}, {"sha": "b21b1e239730f21380c2a13100ef8a663cda4f84", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -56,7 +56,7 @@\n --       This may involve adding some nodes to the tree to perform additional\n --       treatments later.\n \n---    5. Ff the semantic analysis of expressions/names in the aspect should not\n+--    5. If the semantic analysis of expressions/names in the aspect should not\n --       occur at the point the aspect is defined, add code in the adequate\n --       semantic analysis procedure for the aspect. For example, this is the\n --       case for aspects Pre and Post on subprograms, which are pre-analyzed"}, {"sha": "28d89e37df1779e71421c0c0586ab4d9b8c0602c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -10117,6 +10117,7 @@ package body Exp_Ch4 is\n    -------------------------------\n \n    procedure Insert_Dereference_Action (N : Node_Id) is\n+\n       function Is_Checked_Storage_Pool (P : Entity_Id) return Boolean;\n       --  Return true if type of P is derived from Checked_Pool;\n \n@@ -10183,6 +10184,7 @@ package body Exp_Ch4 is\n       end if;\n \n       --  Extract the address of the dereferenced object. Generate:\n+\n       --    Addr : System.Address := <N>'Pool_Address;\n \n       Addr := Make_Temporary (Loc, 'P');\n@@ -10198,6 +10200,7 @@ package body Exp_Ch4 is\n               Attribute_Name => Name_Pool_Address)));\n \n       --  Calculate the size of the dereferenced object. Generate:\n+\n       --    Size : Storage_Count := <N>.all'Size / Storage_Unit;\n \n       Deref :=\n@@ -10210,8 +10213,10 @@ package body Exp_Ch4 is\n       Insert_Action (N,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Size,\n+\n           Object_Definition   =>\n             New_Reference_To (RTE (RE_Storage_Count), Loc),\n+\n           Expression          =>\n             Make_Op_Divide (Loc,\n               Left_Opnd   =>"}, {"sha": "dc09cc541e40d589fddae24a843d4ef65a49ee19", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -6780,7 +6780,7 @@ component value, possibly applying some shift and mask operatings on the\n enclosing machine scalar), and the opposite operation is done for\n writes.\n \n-In that case, the restrictions set forth in 10.3/2 for scalar components\n+In that case, the restrictions set forth in 13.5.1(10.3/2) for scalar components\n are relaxed. Instead, the following rules apply:\n \n @itemize @bullet"}, {"sha": "7838e48d8e84978fa084737baf100fce25c8341a", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -56,6 +56,10 @@ package body System.Storage_Pools.Subpools is\n    procedure Detach (N : not null SP_Node_Ptr);\n    --  Unhook a subpool node from an arbitrary subpool list\n \n+   -----------------------------------\n+   -- Adjust_Controlled_Dereference --\n+   -----------------------------------\n+\n    procedure Adjust_Controlled_Dereference\n      (Addr         : in out System.Address;\n       Storage_Size : in out System.Storage_Elements.Storage_Count;"}, {"sha": "984462a025fade309a0fa60cec91f0740d670e23", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -423,7 +423,7 @@ package body Sem_Ch13 is\n                               end if;\n                            end if;\n \n-                        --  Give error message for RM 13.4.1(10) violation\n+                        --  Give error message for RM 13.5.1(10) violation\n \n                         else\n                            Error_Msg_FE"}, {"sha": "749393b5d783b5d1f54ec54a70fd185708c8bf8f", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -1683,7 +1683,7 @@ package body Sem_Ch5 is\n          begin\n             Typ := Etype (Iter_Name);\n \n-            --  Protect against malformed iterator.\n+            --  Protect against malformed iterator\n \n             if Typ = Any_Type then\n                Error_Msg_N (\"invalid expression in loop iterator\", Iter_Name);"}, {"sha": "5279fb240974ed1c095c0dc9fa45e919df416a74", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -3022,16 +3022,29 @@ package body Sem_Prag is\n                   Set_Has_Delayed_Freeze (E);\n                end if;\n \n-               --  An interesting improvement here. If an object of type X is\n-               --  declared atomic, and the type X is not atomic, that's a\n+               --  An interesting improvement here. If an object of composite\n+               --  type X is declared atomic, and the type X isn't, that's a\n                --  pity, since it may not have appropriate alignment etc. We\n                --  can rescue this in the special case where the object and\n                --  type are in the same unit by just setting the type as\n                --  atomic, so that the back end will process it as atomic.\n \n+               --  Note: we used to do this for elementary types as well,\n+               --  but that turns out to be a bad idea and can have unwanted\n+               --  effects, most notably if the type is elementary, the object\n+               --  a simple component within a record, and both are in a spec:\n+               --  every object of this type in the entire program will be\n+               --  treated as atomic, thus incurring a potentially costly\n+               --  synchronization operation for every access.\n+\n+               --  Of course it would be best if the back end could just adjust\n+               --  the alignment etc for the specific object, but that's not\n+               --  something we are capable of doing at this point.\n+\n                Utyp := Underlying_Type (Etype (E));\n \n                if Present (Utyp)\n+                 and then Is_Composite_Type (Utyp)\n                  and then Sloc (E) > No_Location\n                  and then Sloc (Utyp) > No_Location\n                  and then"}, {"sha": "1ca02d1133279314ec29c27794800e5535c3ac14", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -8684,7 +8684,7 @@ package body Sem_Util is\n       then\n          return True;\n \n-      --  A function call is never a variable.\n+      --  A function call is never a variable\n \n       elsif Nkind (N) = N_Function_Call then\n          return False;"}, {"sha": "ca7127970d03ac02cb5db8b27cad03bd89fb17ac", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 8, "deletions": 390, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=8777c5a68aa8db0e0eedd4b7ea33e702ba708fcd", "patch": "@@ -157,13 +157,6 @@ package body Uintp is\n    pragma Inline (N_Digits);\n    --  Returns number of \"digits\" in a Uint\n \n-   function Sum_Digits (Left : Uint; Sign : Int) return Int;\n-   --  If Sign = 1 return the sum of the \"digits\" of Abs (Left). If the total\n-   --  has more than one digit then return Sum_Digits of total.\n-\n-   function Sum_Double_Digits (Left : Uint; Sign : Int) return Int;\n-   --  Same as above but work in New_Base = Base * Base\n-\n    procedure UI_Div_Rem\n      (Left, Right       : Uint;\n       Quotient          : out Uint;\n@@ -738,234 +731,6 @@ package body Uintp is\n       end if;\n    end Release_And_Save;\n \n-   ----------------\n-   -- Sum_Digits --\n-   ----------------\n-\n-   --  This is done in one pass\n-\n-   --  Mathematically: assume base congruent to 1 and compute an equivalent\n-   --  integer to Left.\n-\n-   --  If Sign = -1 return the alternating sum of the \"digits\"\n-\n-   --     D1 - D2 + D3 - D4 + D5 ...\n-\n-   --  (where D1 is Least Significant Digit)\n-\n-   --  Mathematically: assume base congruent to -1 and compute an equivalent\n-   --  integer to Left.\n-\n-   --  This is used in Rem and Base is assumed to be 2 ** 15\n-\n-   --  Note: The next two functions are very similar, any style changes made\n-   --  to one should be reflected in both.  These would be simpler if we\n-   --  worked base 2 ** 32.\n-\n-   function Sum_Digits (Left : Uint; Sign : Int) return Int is\n-   begin\n-      pragma Assert (Sign = Int_1 or else Sign = Int (-1));\n-\n-      --  First try simple case;\n-\n-      if Direct (Left) then\n-         declare\n-            Tmp_Int : Int := Direct_Val (Left);\n-\n-         begin\n-            if Tmp_Int >= Base then\n-               Tmp_Int := (Tmp_Int / Base) +\n-                  Sign * (Tmp_Int rem Base);\n-\n-                  --  Now Tmp_Int is in [-(Base - 1) .. 2 * (Base - 1)]\n-\n-               if Tmp_Int >= Base then\n-\n-                  --  Sign must be 1\n-\n-                  Tmp_Int := (Tmp_Int / Base) + 1;\n-\n-               end if;\n-\n-               --  Now Tmp_Int is in [-(Base - 1) .. (Base - 1)]\n-\n-            end if;\n-\n-            return Tmp_Int;\n-         end;\n-\n-      --  Otherwise full circuit is needed\n-\n-      else\n-         declare\n-            L_Length : constant Int := N_Digits (Left);\n-            L_Vec    : UI_Vector (1 .. L_Length);\n-            Tmp_Int  : Int;\n-            Carry    : Int;\n-            Alt      : Int;\n-\n-         begin\n-            Init_Operand (Left, L_Vec);\n-            L_Vec (1) := abs L_Vec (1);\n-            Tmp_Int := 0;\n-            Carry := 0;\n-            Alt := 1;\n-\n-            for J in reverse 1 .. L_Length loop\n-               Tmp_Int := Tmp_Int + Alt * (L_Vec (J) + Carry);\n-\n-               --  Tmp_Int is now between [-2 * Base + 1 .. 2 * Base - 1],\n-               --  since old Tmp_Int is between [-(Base - 1) .. Base - 1]\n-               --  and L_Vec is in [0 .. Base - 1] and Carry in [-1 .. 1]\n-\n-               if Tmp_Int >= Base then\n-                  Tmp_Int := Tmp_Int - Base;\n-                  Carry := 1;\n-\n-               elsif Tmp_Int <= -Base then\n-                  Tmp_Int := Tmp_Int + Base;\n-                  Carry := -1;\n-\n-               else\n-                  Carry := 0;\n-               end if;\n-\n-               --  Tmp_Int is now between [-Base + 1 .. Base - 1]\n-\n-               Alt := Alt * Sign;\n-            end loop;\n-\n-            Tmp_Int := Tmp_Int + Alt * Carry;\n-\n-            --  Tmp_Int is now between [-Base .. Base]\n-\n-            if Tmp_Int >= Base then\n-               Tmp_Int := Tmp_Int - Base + Alt * Sign * 1;\n-\n-            elsif Tmp_Int <= -Base then\n-               Tmp_Int := Tmp_Int + Base + Alt * Sign * (-1);\n-            end if;\n-\n-            --  Now Tmp_Int is in [-(Base - 1) .. (Base - 1)]\n-\n-            return Tmp_Int;\n-         end;\n-      end if;\n-   end Sum_Digits;\n-\n-   -----------------------\n-   -- Sum_Double_Digits --\n-   -----------------------\n-\n-   --  Note: This is used in Rem, Base is assumed to be 2 ** 15\n-\n-   function Sum_Double_Digits (Left : Uint; Sign : Int) return Int is\n-   begin\n-      --  First try simple case;\n-\n-      pragma Assert (Sign = Int_1 or else Sign = Int (-1));\n-\n-      if Direct (Left) then\n-         return Direct_Val (Left);\n-\n-      --  Otherwise full circuit is needed\n-\n-      else\n-         declare\n-            L_Length      : constant Int := N_Digits (Left);\n-            L_Vec         : UI_Vector (1 .. L_Length);\n-            Most_Sig_Int  : Int;\n-            Least_Sig_Int : Int;\n-            Carry         : Int;\n-            J             : Int;\n-            Alt           : Int;\n-\n-         begin\n-            Init_Operand (Left, L_Vec);\n-            L_Vec (1) := abs L_Vec (1);\n-            Most_Sig_Int := 0;\n-            Least_Sig_Int := 0;\n-            Carry := 0;\n-            Alt := 1;\n-            J := L_Length;\n-\n-            while J > Int_1 loop\n-               Least_Sig_Int := Least_Sig_Int + Alt * (L_Vec (J) + Carry);\n-\n-               --  Least is in [-2 Base + 1 .. 2 * Base - 1]\n-               --  Since L_Vec in [0 .. Base - 1] and Carry in [-1 .. 1]\n-               --  and old Least in [-Base + 1 .. Base - 1]\n-\n-               if Least_Sig_Int >= Base then\n-                  Least_Sig_Int := Least_Sig_Int - Base;\n-                  Carry := 1;\n-\n-               elsif Least_Sig_Int <= -Base then\n-                  Least_Sig_Int := Least_Sig_Int + Base;\n-                  Carry := -1;\n-\n-               else\n-                  Carry := 0;\n-               end if;\n-\n-               --  Least is now in [-Base + 1 .. Base - 1]\n-\n-               Most_Sig_Int := Most_Sig_Int + Alt * (L_Vec (J - 1) + Carry);\n-\n-               --  Most is in [-2 Base + 1 .. 2 * Base - 1]\n-               --  Since L_Vec in [0 ..  Base - 1] and Carry in  [-1 .. 1]\n-               --  and old Most in [-Base + 1 .. Base - 1]\n-\n-               if Most_Sig_Int >= Base then\n-                  Most_Sig_Int := Most_Sig_Int - Base;\n-                  Carry := 1;\n-\n-               elsif Most_Sig_Int <= -Base then\n-                  Most_Sig_Int := Most_Sig_Int + Base;\n-                  Carry := -1;\n-               else\n-                  Carry := 0;\n-               end if;\n-\n-               --  Most is now in [-Base + 1 .. Base - 1]\n-\n-               J := J - 2;\n-               Alt := Alt * Sign;\n-            end loop;\n-\n-            if J = Int_1 then\n-               Least_Sig_Int := Least_Sig_Int + Alt * (L_Vec (J) + Carry);\n-            else\n-               Least_Sig_Int := Least_Sig_Int + Alt * Carry;\n-            end if;\n-\n-            if Least_Sig_Int >= Base then\n-               Least_Sig_Int := Least_Sig_Int - Base;\n-               Most_Sig_Int := Most_Sig_Int + Alt * 1;\n-\n-            elsif Least_Sig_Int <= -Base then\n-               Least_Sig_Int := Least_Sig_Int + Base;\n-               Most_Sig_Int := Most_Sig_Int + Alt * (-1);\n-            end if;\n-\n-            if Most_Sig_Int >= Base then\n-               Most_Sig_Int := Most_Sig_Int - Base;\n-               Alt := Alt * Sign;\n-               Least_Sig_Int :=\n-                 Least_Sig_Int + Alt * 1; -- cannot overflow again\n-\n-            elsif Most_Sig_Int <= -Base then\n-               Most_Sig_Int := Most_Sig_Int + Base;\n-               Alt := Alt * Sign;\n-               Least_Sig_Int :=\n-                 Least_Sig_Int + Alt * (-1); --  cannot overflow again.\n-            end if;\n-\n-            return Most_Sig_Int * Base + Least_Sig_Int;\n-         end;\n-      end if;\n-   end Sum_Double_Digits;\n-\n    ---------------\n    -- Tree_Read --\n    ---------------\n@@ -2370,168 +2135,21 @@ package body Uintp is\n    end UI_Rem;\n \n    function UI_Rem (Left, Right : Uint) return Uint is\n-      Sign : Int;\n-      Tmp  : Int;\n-\n-      subtype Int1_12 is Integer range 1 .. 12;\n+      Remainder : Uint;\n+      Quotient  : Uint;\n+      pragma Warnings (Off, Quotient);\n \n    begin\n       pragma Assert (Right /= Uint_0);\n \n-      if Direct (Right) then\n-         if Direct (Left) then\n-            return UI_From_Int (Direct_Val (Left) rem Direct_Val (Right));\n-\n-         else\n-\n-            --  Special cases when Right is less than 13 and Left is larger\n-            --  larger than one digit. All of these algorithms depend on the\n-            --  base being 2 ** 15. We work with Abs (Left) and Abs(Right)\n-            --  then multiply result by Sign (Left).\n-\n-            if (Right <= Uint_12) and then (Right >= Uint_Minus_12) then\n-\n-               if Left < Uint_0 then\n-                  Sign := -1;\n-               else\n-                  Sign := 1;\n-               end if;\n-\n-               --  All cases are listed, grouped by mathematical method. It is\n-               --  not inefficient to do have this case list out of order since\n-               --  GCC sorts the cases we list.\n-\n-               case Int1_12 (abs (Direct_Val (Right))) is\n-\n-                  when 1 =>\n-                     return Uint_0;\n-\n-                  --  Powers of two are simple AND's with the least significant\n-                  --  digit of Left. GCC will recognise these constants as\n-                  --  powers of 2 and replace the rem with simpler operations\n-                  --  where possible.\n-\n-                  --  Least_Sig_Digit might return Negative numbers\n-\n-                  when 2 =>\n-                     return UI_From_Int (\n-                        Sign * (Least_Sig_Digit (Left) mod 2));\n+      if Direct (Right) and then Direct (Left) then\n+         return UI_From_Int (Direct_Val (Left) rem Direct_Val (Right));\n \n-                  when 4 =>\n-                     return UI_From_Int (\n-                        Sign * (Least_Sig_Digit (Left) mod 4));\n-\n-                  when 8 =>\n-                     return UI_From_Int (\n-                        Sign * (Least_Sig_Digit (Left) mod 8));\n-\n-                  --  Some number theoretical tricks:\n-\n-                  --    If B Rem Right = 1 then\n-                  --    Left Rem Right = Sum_Of_Digits_Base_B (Left) Rem Right\n-\n-                  --  Note: 2^30 mod 3 = 1\n-\n-                  when 3 =>\n-                     return UI_From_Int (\n-                        Sign * (Sum_Double_Digits (Left, 1) rem Int (3)));\n-\n-                  --  Note: 2^15 mod 7 = 1\n-\n-                  when 7 =>\n-                     return UI_From_Int (\n-                        Sign * (Sum_Digits (Left, 1) rem Int (7)));\n-\n-                  --  Note: 2^30 mod 5 = -1\n-\n-                  --  Alternating sums might be negative, but rem is always\n-                  --  positive hence we must use mod here.\n-\n-                  when 5 =>\n-                     Tmp := Sum_Double_Digits (Left, -1) mod Int (5);\n-                     return UI_From_Int (Sign * Tmp);\n-\n-                  --  Note: 2^15 mod 9 = -1\n-\n-                  --  Alternating sums might be negative, but rem is always\n-                  --  positive hence we must use mod here.\n-\n-                  when 9  =>\n-                     Tmp := Sum_Digits (Left, -1) mod Int (9);\n-                     return UI_From_Int (Sign * Tmp);\n-\n-                  --  Note: 2^15 mod 11 = -1\n-\n-                  --  Alternating sums might be negative, but rem is always\n-                  --  positive hence we must use mod here.\n-\n-                  when 11 =>\n-                     Tmp := Sum_Digits (Left, -1) mod Int (11);\n-                     return UI_From_Int (Sign * Tmp);\n-\n-                  --  Now resort to Chinese Remainder theorem to reduce 6, 10,\n-                  --  12 to previous special cases\n-\n-                  --  There is no reason we could not add more cases like these\n-                  --  if it proves useful.\n-\n-                  --  Perhaps we should go up to 16, however we have no \"trick\"\n-                  --  for 13.\n-\n-                  --  To find u mod m we:\n-\n-                  --  Pick m1, m2 S.T.\n-                  --     GCD(m1, m2) = 1 AND m = (m1 * m2).\n-\n-                  --  Next we pick (Basis) M1, M2 small S.T.\n-                  --     (M1 mod m1) = (M2 mod m2) = 1 AND\n-                  --     (M1 mod m2) = (M2 mod m1) = 0\n-\n-                  --  So u mod m = (u1 * M1 + u2 * M2) mod m where u1 = (u mod\n-                  --  m1) AND u2 = (u mod m2); Under typical circumstances the\n-                  --  last mod m can be done with a (possible) single\n-                  --  subtraction.\n-\n-                  --  m1 = 2; m2 = 3; M1 = 3; M2 = 4;\n-\n-                  when 6  =>\n-                     Tmp := 3 * (Least_Sig_Digit (Left) rem 2) +\n-                              4 * (Sum_Double_Digits (Left, 1) rem 3);\n-                     return UI_From_Int (Sign * (Tmp rem 6));\n-\n-                  --  m1 = 2; m2 = 5; M1 = 5; M2 = 6;\n-\n-                  when 10 =>\n-                     Tmp := 5 * (Least_Sig_Digit (Left) rem 2) +\n-                              6 * (Sum_Double_Digits (Left, -1) mod 5);\n-                     return UI_From_Int (Sign * (Tmp rem 10));\n-\n-                  --  m1 = 3; m2 = 4; M1 = 4; M2 = 9;\n-\n-                  when 12 =>\n-                     Tmp := 4 * (Sum_Double_Digits (Left, 1) rem 3) +\n-                              9 * (Least_Sig_Digit (Left) rem 4);\n-                     return UI_From_Int (Sign * (Tmp rem 12));\n-               end case;\n-\n-            end if;\n-\n-            --  Else fall through to general case\n-\n-            --  The special case Length (Left) = Length (Right) = 1 in Div\n-            --  looks slow. It uses UI_To_Int when Int should suffice. ???\n-         end if;\n-      end if;\n-\n-      declare\n-         Remainder : Uint;\n-         Quotient  : Uint;\n-         pragma Warnings (Off, Quotient);\n-      begin\n+      else\n          UI_Div_Rem\n-           (Left, Right, Quotient, Remainder, Discard_Quotient  => True);\n+           (Left, Right, Quotient, Remainder, Discard_Quotient => True);\n          return Remainder;\n-      end;\n+      end if;\n    end UI_Rem;\n \n    ------------"}]}