{"sha": "9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmYzJlYzIyNWE1YThmMGE1ZDJhOWI1ODUzZDBhMTlkNzI4ZTEyOQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2003-10-01T16:22:13Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-10-01T16:22:13Z"}, "message": "jcf-parse.c (java_parse_file): Write otable and atable.\n\n2003-10-01  Andrew Haley  <aph@redhat.com>\n\n        * jcf-parse.c (java_parse_file): Write otable and atable.\n        * java-tree.h (atable_methods): New.\n        (atable_decl): New.\n        (atable_syms_decl): New.\n        (enum java_tree_index): Add JTI_ATABLE_METHODS, JTI_ATABLE_DECL,\n        JTI_ATABLE_SYMS_DECL.  Rename JTI_METHOD_SYMBOL* to JTI_SYMBOL*.\n        (symbol_*type): Rename method_symbol* to symbol*type.\n        (emit_offset_symbol_table): Delete.\n        (emit_symbol_table): New.\n        (get_symbol_table_index): New.\n        (atable_type): New.\n        * expr.c (build_field_ref): Handle flag_indirect_dispatch.\n        (build_known_method_ref): Likewise.\n        (get_symbol_table_index): Rename from get_offset_table_index.\n        Parameterize to allow re-use by differing types of symbol table.\n        (build_invokevirtual): Pass table to get_offset_table_index.\n        * decl.c (java_init_decl_processing): Push types and decls for\n        atable and atable_syyms.\n        * class.c (build_static_field_ref): Handle flag_indirect_dispatch.\n        (make_class_data): Add new fields atable and atable_syms.\n        (emit_symbol_table): Rename from emit_offset_symbol_table.\n        Parameterize to allow re-use by different types of symbol table.\n        (build_symbol_entry): Renamed from build_method_symbols_entry.\n\n2003-10-01  Andrew Haley  <aph@redhat.com>\n\n        * java/lang/natClass.cc (initializeClass): Check for otable and\n        atable.\n        (_Jv_LinkOffsetTable): Check for existence of atable.  Rewrite\n        loops using for().  Search superinterfaces.  Check for fields as\n        well as methods.  Initialize atable as well as otable: check for\n        static methods as well as virtual methods.\n        * java/lang/Class.h (struct _Jv_AddressTable): New.\n        (atable): New.\n        (atable_syms): New.\n        * include/jvm.h (_Jv_equalUtf8Consts): constify.\n        * prims.cc (_Jv_equalUtf8Consts): constify.\n\nFrom-SVN: r71979", "tree": {"sha": "2dba069aa1abbb8cef2f212c67ca484cf5f8a674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dba069aa1abbb8cef2f212c67ca484cf5f8a674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "530ce5517ce00a43761d303a614b25d3371dd030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530ce5517ce00a43761d303a614b25d3371dd030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/530ce5517ce00a43761d303a614b25d3371dd030"}], "stats": {"total": 625, "additions": 473, "deletions": 152}, "files": [{"sha": "ee3a016ba7d0b2067bb1b2e26ce1b5c736f7668f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -1,3 +1,29 @@\n+2003-10-01  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (java_parse_file): Write otable and atable.\n+\t* java-tree.h (atable_methods): New.\n+\t(atable_decl): New.\n+\t(atable_syms_decl): New.\n+\t(enum java_tree_index): Add JTI_ATABLE_METHODS, JTI_ATABLE_DECL,\n+\tJTI_ATABLE_SYMS_DECL.  Rename JTI_METHOD_SYMBOL* to JTI_SYMBOL*.\n+\t(symbol_*type): Rename method_symbol* to symbol*type.\t\n+\t(emit_offset_symbol_table): Delete.\n+\t(emit_symbol_table): New.\n+\t(get_symbol_table_index): New.\n+\t(atable_type): New.\n+\t* expr.c (build_field_ref): Handle flag_indirect_dispatch.\n+\t(build_known_method_ref): Likewise.\n+\t(get_symbol_table_index): Rename from get_offset_table_index.\n+\tParameterize to allow re-use by differing types of symbol table.\n+\t(build_invokevirtual): Pass table to get_offset_table_index.\n+\t* decl.c (java_init_decl_processing): Push types and decls for\n+\tatable and atable_syyms.\n+\t* class.c (build_static_field_ref): Handle flag_indirect_dispatch.\n+\t(make_class_data): Add new fields atable and atable_syms.\n+\t(emit_symbol_table): Rename from emit_offset_symbol_table.\n+\tParameterize to allow re-use by different types of symbol table.\n+\t(build_symbol_entry): Renamed from build_method_symbols_entry.\n+\t\n 2003-09-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* jcf-write.c (generate_bytecode_insns): Implement evaluate-once"}, {"sha": "d64db51fbd373c7188e1d7c31810f4fb94ed9e44", "filename": "gcc/java/class.c", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -59,7 +59,7 @@ static void add_interface_do (tree, tree, int);\n static tree maybe_layout_super_class (tree, tree);\n static void add_miranda_methods (tree, tree);\n static int assume_compiled (const char *);\n-static tree build_method_symbols_entry (tree);\n+static tree build_symbol_entry (tree);\n \n static GTY(()) rtx registerClass_libfunc;\n \n@@ -925,7 +925,8 @@ build_static_field_ref (tree fdecl)\n      However, currently sometimes gcj is too eager and will end up\n      returning the field itself, leading to an incorrect external\n      reference being generated.  */\n-  if (is_compiled\n+  if ((is_compiled \n+       && (! flag_indirect_dispatch || current_class == fclass))\n       || (FIELD_FINAL (fdecl) && DECL_INITIAL (fdecl) != NULL_TREE\n \t  && (JSTRING_TYPE_P (TREE_TYPE (fdecl))\n \t      || JNUMERIC_TYPE_P (TREE_TYPE (fdecl)))\n@@ -939,7 +940,18 @@ build_static_field_ref (tree fdecl)\n \t}\n       return fdecl;\n     }\n-  else\n+\n+  if (flag_indirect_dispatch)\n+    {\n+      tree table_index \n+\t= build_int_2 (get_symbol_table_index (fdecl, &atable_methods), 0);\n+      tree field_address\n+\t= build (ARRAY_REF, build_pointer_type (TREE_TYPE (fdecl)), \n+\t\t atable_decl, table_index);\n+      return fold (build1 (INDIRECT_REF, TREE_TYPE (fdecl), \n+\t\t\t   field_address));\n+    }\n+  else  \n     {\n       /* Compile as:\n        * *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr */\n@@ -1500,7 +1512,6 @@ make_class_data (tree type)\n \t\t      : build (PLUS_EXPR, dtable_ptr_type,\n \t\t\t       build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl),\n \t\t\t       dtable_start_offset));\n-  \n   if (otable_methods == NULL_TREE)\n     {\n       PUSH_FIELD_VALUE (cons, \"otable\", null_pointer_node);\n@@ -1511,9 +1522,25 @@ make_class_data (tree type)\n       PUSH_FIELD_VALUE (cons, \"otable\",\n \t\t\tbuild1 (ADDR_EXPR, otable_ptr_type, otable_decl));\n       PUSH_FIELD_VALUE (cons, \"otable_syms\",\n-\t\t\tbuild1 (ADDR_EXPR, method_symbols_array_ptr_type,\n+\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n \t\t\t\totable_syms_decl));\n+      TREE_CONSTANT (otable_decl) = 1;\n+    }\n+  if (atable_methods == NULL_TREE)\n+    {\n+      PUSH_FIELD_VALUE (cons, \"atable\", null_pointer_node);\n+      PUSH_FIELD_VALUE (cons, \"atable_syms\", null_pointer_node);\n     }\n+  else\n+    {\n+      PUSH_FIELD_VALUE (cons, \"atable\",\n+\t\t\tbuild1 (ADDR_EXPR, atable_ptr_type, atable_decl));\n+      PUSH_FIELD_VALUE (cons, \"atable_syms\",\n+\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n+\t\t\t\tatable_syms_decl));\n+      TREE_CONSTANT (atable_decl) = 1;\n+    }\n+\n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"interface_count\", build_int_2 (interface_len, 0));\n@@ -2098,58 +2125,59 @@ emit_register_classes (void)\n     }\n }\n \n-/* Make a method_symbol_type (_Jv_MethodSymbol) node for METHOD. */\n+/* Make a symbol_type (_Jv_MethodSymbol) node for DECL. */\n \n static tree\n-build_method_symbols_entry (tree method)\n+build_symbol_entry (tree decl)\n {\n-  tree clname, name, signature, method_symbol;\n+  tree clname, name, signature, sym;\n   \n-  clname = build_utf8_ref (DECL_NAME (TYPE_NAME (DECL_CONTEXT (method))));\n-  name = build_utf8_ref (DECL_NAME (method));\n-  signature = build_java_signature (TREE_TYPE (method));\n+  clname = build_utf8_ref (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));\n+  name = build_utf8_ref (DECL_NAME (decl));\n+  signature = build_java_signature (TREE_TYPE (decl));\n   signature = build_utf8_ref (unmangle_classname \n \t\t\t      (IDENTIFIER_POINTER (signature),\n \t\t\t       IDENTIFIER_LENGTH (signature)));\n \n-  START_RECORD_CONSTRUCTOR (method_symbol, method_symbol_type);\n-  PUSH_FIELD_VALUE (method_symbol, \"clname\", clname);\n-  PUSH_FIELD_VALUE (method_symbol, \"name\", name);\n-  PUSH_FIELD_VALUE (method_symbol, \"signature\", signature);\n-  FINISH_RECORD_CONSTRUCTOR (method_symbol);\n-  TREE_CONSTANT (method_symbol) = 1;\n+  START_RECORD_CONSTRUCTOR (sym, symbol_type);\n+  PUSH_FIELD_VALUE (sym, \"clname\", clname);\n+  PUSH_FIELD_VALUE (sym, \"name\", name);\n+  PUSH_FIELD_VALUE (sym, \"signature\", signature);\n+  FINISH_RECORD_CONSTRUCTOR (sym);\n+  TREE_CONSTANT (sym) = 1;\n \n-  return method_symbol;\n+  return sym;\n } \n \n-/* Emit the offset symbols table for indirect virtual dispatch. */\n+/* Emit a symbol table: used by -findirect-dispatch.  */\n \n-void\n-emit_offset_symbol_table (void)\n+tree\n+emit_symbol_table (tree name, tree the_table, tree decl_list, tree the_syms_decl, \n+\t\t\t  tree the_array_element_type)\n {\n   tree method_list, method, table, list, null_symbol;\n-  tree otable_bound, otable_array_type;\n+  tree table_size, the_array_type;\n   int index;\n   \n-  /* Only emit an offset table if this translation unit actually made virtual \n-     calls. */\n-  if (otable_methods == NULL_TREE)\n-    return;\n+  /* Only emit a table if this translation unit actually made any\n+     references via it. */\n+  if (decl_list == NULL_TREE)\n+    return the_table;\n \n   /* Build a list of _Jv_MethodSymbols for each entry in otable_methods. */\n   index = 0;\n-  method_list = otable_methods;\n+  method_list = decl_list;\n   list = NULL_TREE;  \n   while (method_list != NULL_TREE)\n     {\n       method = TREE_VALUE (method_list);\n-      list = tree_cons (NULL_TREE, build_method_symbols_entry (method), list);\n+      list = tree_cons (NULL_TREE, build_symbol_entry (method), list);\n       method_list = TREE_CHAIN (method_list);\n       index++;\n     }\n \n   /* Terminate the list with a \"null\" entry. */\n-  START_RECORD_CONSTRUCTOR (null_symbol, method_symbol_type);\n+  START_RECORD_CONSTRUCTOR (null_symbol, symbol_type);\n   PUSH_FIELD_VALUE (null_symbol, \"clname\", null_pointer_node);\n   PUSH_FIELD_VALUE (null_symbol, \"name\", null_pointer_node);\n   PUSH_FIELD_VALUE (null_symbol, \"signature\", null_pointer_node);\n@@ -2159,24 +2187,26 @@ emit_offset_symbol_table (void)\n \n   /* Put the list in the right order and make it a constructor. */\n   list = nreverse (list);\n-  table = build_constructor (method_symbols_array_type, list);  \n+  table = build_constructor (symbols_array_type, list);  \n \n   /* Make it the initial value for otable_syms and emit the decl. */\n-  DECL_INITIAL (otable_syms_decl) = table;\n-  DECL_ARTIFICIAL (otable_syms_decl) = 1;\n-  DECL_IGNORED_P (otable_syms_decl) = 1;\n-  rest_of_decl_compilation (otable_syms_decl, NULL, 1, 0);\n+  DECL_INITIAL (the_syms_decl) = table;\n+  DECL_ARTIFICIAL (the_syms_decl) = 1;\n+  DECL_IGNORED_P (the_syms_decl) = 1;\n+  rest_of_decl_compilation (the_syms_decl, NULL, 1, 0);\n   \n-  /* Now that its size is known, redefine otable as an uninitialized static \n-     array of INDEX + 1 integers. The extra entry is used by the runtime \n-     to track whether the otable has been initialized. */\n-  otable_bound = build_index_type (build_int_2 (index, 0));\n-  otable_array_type = build_array_type (integer_type_node, otable_bound);\n-  otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"), \n-\t\t\t    otable_array_type);\n-  TREE_STATIC (otable_decl) = 1;\n-  TREE_READONLY (otable_decl) = 1;  \n-  rest_of_decl_compilation (otable_decl, NULL, 1, 0);\n+  /* Now that its size is known, redefine the table as an\n+     uninitialized static array of INDEX + 1 elements. The extra entry\n+     is used by the runtime to track whether the table has been\n+     initialized. */\n+  table_size = build_index_type (build_int_2 (index, 0));\n+  the_array_type = build_array_type (the_array_element_type, table_size);\n+  the_table = build_decl (VAR_DECL, name, the_array_type);\n+  TREE_STATIC (the_table) = 1;\n+  TREE_READONLY (the_table) = 1;  \n+  rest_of_decl_compilation (the_table, NULL, 1, 0);\n+\n+  return the_table;\n }\n \n void"}, {"sha": "8355431be583be3b5a93844d6a0c1e5c0a35939b", "filename": "gcc/java/decl.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -621,32 +621,46 @@ java_init_decl_processing (void)\n \t\t\t\t  one_elt_array_domain_type);\n   TYPE_NONALIASED_COMPONENT (otable_type) = 1;\n   otable_ptr_type = build_pointer_type (otable_type);\n+  atable_type = build_array_type (ptr_type_node, \n+\t\t\t\t  one_elt_array_domain_type);\n+  TYPE_NONALIASED_COMPONENT (atable_type) = 1;\n+  atable_ptr_type = build_pointer_type (atable_type);\n \n-  method_symbol_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (method_symbol_type, field, \"clname\", utf8const_ptr_type);\n-  PUSH_FIELD (method_symbol_type, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (method_symbol_type, field, \"signature\", utf8const_ptr_type);\n-  FINISH_RECORD (method_symbol_type);\n+  symbol_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (symbol_type, field, \"clname\", utf8const_ptr_type);\n+  PUSH_FIELD (symbol_type, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (symbol_type, field, \"signature\", utf8const_ptr_type);\n+  FINISH_RECORD (symbol_type);\n \n-  method_symbols_array_type = build_array_type (method_symbol_type, \n-\t\t\t\t\t\tone_elt_array_domain_type);\n-  method_symbols_array_ptr_type = build_pointer_type \n-\t\t\t\t  (method_symbols_array_type);\n+  symbols_array_type = build_array_type (symbol_type, \n+\t\t\t\t\t one_elt_array_domain_type);\n+  symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n \n   if (flag_indirect_dispatch)\n     {\n-      otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"),\n-\t\t\t\totable_type);\n+      otable_decl = build_decl (VAR_DECL, get_identifier (\"otable\"), otable_type);\n       DECL_EXTERNAL (otable_decl) = 1;\n       TREE_STATIC (otable_decl) = 1;\n       TREE_READONLY (otable_decl) = 1;\n-      pushdecl (otable_decl);\n-  \n+      TREE_CONSTANT (otable_decl) = 1;\n+      pushdecl (otable_decl);  \n       otable_syms_decl = build_decl (VAR_DECL, get_identifier (\"otable_syms\"), \n-\t\t\t\t     method_symbols_array_type);\n+\t\t\t\t     symbols_array_type);\n       TREE_STATIC (otable_syms_decl) = 1;\n       TREE_CONSTANT (otable_syms_decl) = 1;\n       pushdecl (otable_syms_decl);\n+\n+      atable_decl = build_decl (VAR_DECL, get_identifier (\"atable\"), atable_type);\n+      DECL_EXTERNAL (atable_decl) = 1;\n+      TREE_STATIC (atable_decl) = 1;\n+      TREE_READONLY (atable_decl) = 1;\n+      TREE_CONSTANT (atable_decl) = 1;\n+      pushdecl (atable_decl);  \n+      atable_syms_decl = build_decl (VAR_DECL, get_identifier (\"atable_syms\"), \n+\t\t\t\t     symbols_array_type);\n+      TREE_STATIC (atable_syms_decl) = 1;\n+      TREE_CONSTANT (atable_syms_decl) = 1;\n+      pushdecl (atable_syms_decl);\n     }\n   \n   PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n@@ -684,7 +698,10 @@ java_init_decl_processing (void)\n   PUSH_FIELD (class_type_node, field, \"vtable\", dtable_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"otable\", otable_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"otable_syms\", \n-  \t      method_symbols_array_ptr_type);\n+  \t      symbols_array_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"atable\", atable_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"atable_syms\", \n+  \t      symbols_array_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"interfaces\",\n \t      build_pointer_type (class_ptr_type));\n   PUSH_FIELD (class_type_node, field, \"loader\", ptr_type_node);"}, {"sha": "2c9ac09e7358bd55e9302cb4df95948af2a0496a", "filename": "gcc/java/expr.c", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -84,7 +84,6 @@ static tree build_java_check_indexed_type (tree, tree);\n static tree case_identity (tree, tree); \n static unsigned char peek_opcode_at_pc (struct JCF *, int, int);\n static int emit_init_test_initialization (void **entry, void * ptr);\n-static int get_offset_table_index (tree);\n \n static GTY(()) tree operand_type[59];\n \n@@ -1510,6 +1509,25 @@ build_field_ref (tree self_value, tree self_class, tree name)\n       tree base_type = promote_type (base_class);\n       if (base_type != TREE_TYPE (self_value))\n \tself_value = fold (build1 (NOP_EXPR, base_type, self_value));\n+      if (flag_indirect_dispatch\n+\t  && current_class != self_class)\n+\t/* FIXME: current_class != self_class is not exactly the right\n+\t   test.  What we really want to know is whether self_class is\n+\t   in the same translation unit as current_class.  If it is,\n+\t   we can make a direct reference.  */\n+\t{\n+\t  tree otable_index \n+\t    = build_int_2 \n+\t    (get_symbol_table_index (field_decl, &otable_methods), 0);\n+\t  tree field_offset = build (ARRAY_REF, integer_type_node, otable_decl, \n+\t\t\t\t     otable_index);\n+\t  tree address \n+\t    = fold (build (PLUS_EXPR, \n+\t\t\t   build_pointer_type (TREE_TYPE (field_decl)),\n+\t\t\t   self_value, field_offset));\n+\t  return fold (build1 (INDIRECT_REF, TREE_TYPE (field_decl), address));\n+\t}\n+\n       self_value = build_java_indirect_ref (TREE_TYPE (TREE_TYPE (self_value)),\n \t\t\t\t\t    self_value, check);\n       return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n@@ -1744,8 +1762,19 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n   tree func;\n   if (is_compiled_class (self_type))\n     {\n-      make_decl_rtl (method, NULL);\n-      func = build1 (ADDR_EXPR, method_ptr_type_node, method);\n+      if (!flag_indirect_dispatch\n+\t  || (!TREE_PUBLIC (method) && DECL_CONTEXT (method)))\n+\t{\n+\t  make_decl_rtl (method, NULL);\n+\t  func = build1 (ADDR_EXPR, method_ptr_type_node, method);\n+\t}\n+      else\n+\t{\n+\t  tree table_index = build_int_2 (get_symbol_table_index \n+\t\t\t\t\t  (method, &atable_methods), 0);\n+\t  func = build (ARRAY_REF,  method_ptr_type_node, atable_decl, \n+\t\t\ttable_index);\n+\t}\n     }\n   else\n     {\n@@ -1816,27 +1845,29 @@ invoke_build_dtable (int is_invoke_interface, tree arg_list)\n   return dtable;\n }\n \n-/* Determine the index in the virtual offset table (otable) for a call to\n-   METHOD. If this method has not been seen before, it will be added to the \n-   otable_methods. If it has, the existing otable slot will be reused. */\n+/* Determine the index in SYMBOL_TABLE for a reference to the decl\n+   T. If this decl has not been seen before, it will be added to the\n+   otable_methods. If it has, the existing table slot will be\n+   reused. */\n \n-static int\n-get_offset_table_index (tree method)\n+int\n+get_symbol_table_index (tree t, tree *symbol_table)\n {\n   int i = 1;\n   tree method_list;\n-  \n-  if (otable_methods == NULL_TREE)\n+\n+  if (*symbol_table == NULL_TREE)\n     {\n-      otable_methods = build_tree_list (method, method);\n+      *symbol_table = build_tree_list (t, t);\n       return 1;\n     }\n   \n-  method_list = otable_methods;\n+  method_list = *symbol_table;\n   \n   while (1)\n     {\n-      if (TREE_VALUE (method_list) == method)\n+      tree value = TREE_VALUE (method_list);\n+      if (value == t)\n         return i;\n       i++;\n       if (TREE_CHAIN (method_list) == NULL_TREE)\n@@ -1845,7 +1876,7 @@ get_offset_table_index (tree method)\n         method_list = TREE_CHAIN (method_list);\n     }\n \n-  TREE_CHAIN (method_list) = build_tree_list (method, method);\n+  TREE_CHAIN (method_list) = build_tree_list (t, t);\n   return i;\n }\n \n@@ -1860,7 +1891,8 @@ build_invokevirtual (tree dtable, tree method)\n \n   if (flag_indirect_dispatch)\n     {\n-      otable_index = build_int_2 (get_offset_table_index (method), 0);\n+      otable_index \n+\t= build_int_2 (get_symbol_table_index (method, &otable_methods), 0);\n       method_index = build (ARRAY_REF, integer_type_node, otable_decl, \n \t\t\t    otable_index);\n     }\n@@ -1924,7 +1956,8 @@ build_invokeinterface (tree dtable, tree method)\n   \n   if (flag_indirect_dispatch)\n     {\n-      otable_index = build_int_2 (get_offset_table_index (method), 0);\n+      otable_index \n+\t= build_int_2 (get_symbol_table_index (method, &otable_methods), 0);\n       idx = build (ARRAY_REF, integer_type_node, otable_decl, otable_index);\n     }\n   else"}, {"sha": "42f99b57e95c71eb6eceff3a84b6584f92b8d0b2", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -146,17 +146,26 @@ extern int compiling_from_source;\n /* List of all class filenames seen so far.  */\n #define all_class_filename java_global_trees [JTI_ALL_CLASS_FILENAME]\n \n-/* List of virtual method decls called in this translation unit, used to \n-   generate virtual method offset symbol table. */\n+/* List of virtual decls referred to by this translation unit, used to\n+   generate virtual method offset symbol table.  */\n #define otable_methods java_global_trees [JTI_OTABLE_METHODS]\n+/* List of static decls referred to by this translation unit, used to\n+   generate virtual method offset symbol table.  */\n+#define atable_methods java_global_trees [JTI_ATABLE_METHODS]\n \n-/* The virtual method offset table. This is emitted as uninitialized data of \n-   the required length, and filled out at run time during class linking. */\n+/* The virtual offset table.  This is emitted as uninitialized data of\n+   the required length, and filled out at run time during class\n+   linking. */\n #define otable_decl java_global_trees [JTI_OTABLE_DECL]\n+/* The static address table.  */\n+#define atable_decl java_global_trees [JTI_ATABLE_DECL]\n \n-/* The virtual method offset symbol table. Used by the runtime to fill out the\n-   otable. */\n+/* The virtual offset symbol table. Used by the runtime to fill out\n+   the otable. */\n #define otable_syms_decl java_global_trees [JTI_OTABLE_SYMS_DECL]\n+/* The static symbol table. Used by the runtime to fill out the\n+   otable. */\n+#define atable_syms_decl java_global_trees [JTI_ATABLE_SYMS_DECL]\n \n extern int flag_emit_class_files;\n \n@@ -364,9 +373,11 @@ enum java_tree_index\n   JTI_METHOD_PTR_TYPE_NODE,\n   JTI_OTABLE_TYPE,\n   JTI_OTABLE_PTR_TYPE,\n-  JTI_METHOD_SYMBOL_TYPE,\n-  JTI_METHOD_SYMBOLS_ARRAY_TYPE,\n-  JTI_METHOD_SYMBOLS_ARRAY_PTR_TYPE,\n+  JTI_ATABLE_TYPE,\n+  JTI_ATABLE_PTR_TYPE,\n+  JTI_SYMBOL_TYPE,\n+  JTI_SYMBOLS_ARRAY_TYPE,\n+  JTI_SYMBOLS_ARRAY_PTR_TYPE,\n \n   JTI_END_PARAMS_NODE,\n \n@@ -409,6 +420,10 @@ enum java_tree_index\n   JTI_OTABLE_DECL,\n   JTI_OTABLE_SYMS_DECL,\n \n+  JTI_ATABLE_METHODS,\n+  JTI_ATABLE_DECL,\n+  JTI_ATABLE_SYMS_DECL,\n+\n   JTI_PREDEF_FILENAMES,\n \n   JTI_MAX\n@@ -602,14 +617,18 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_METHOD_PTR_TYPE_NODE]\n #define otable_type \\\n   java_global_trees[JTI_OTABLE_TYPE]\n+#define atable_type \\\n+  java_global_trees[JTI_ATABLE_TYPE]\n #define otable_ptr_type \\\n   java_global_trees[JTI_OTABLE_PTR_TYPE]\n-#define method_symbol_type \\\n-  java_global_trees[JTI_METHOD_SYMBOL_TYPE]\n-#define method_symbols_array_type \\\n-  java_global_trees[JTI_METHOD_SYMBOLS_ARRAY_TYPE]\n-#define method_symbols_array_ptr_type \\\n-  java_global_trees[JTI_METHOD_SYMBOLS_ARRAY_PTR_TYPE]\n+#define atable_ptr_type \\\n+  java_global_trees[JTI_ATABLE_PTR_TYPE]\n+#define symbol_type \\\n+  java_global_trees[JTI_SYMBOL_TYPE]\n+#define symbols_array_type \\\n+  java_global_trees[JTI_SYMBOLS_ARRAY_TYPE]\n+#define symbols_array_ptr_type \\\n+  java_global_trees[JTI_SYMBOLS_ARRAY_PTR_TYPE]\n \n #define end_params_node \\\n   java_global_trees[JTI_END_PARAMS_NODE]\n@@ -1199,7 +1218,7 @@ extern void make_class_data (tree);\n extern void register_class (void);\n extern int alloc_name_constant (int, tree);\n extern void emit_register_classes (void);\n-extern void emit_offset_symbol_table (void);\n+extern tree emit_symbol_table (tree, tree, tree, tree, tree);\n extern void lang_init_source (int);\n extern void write_classfile (tree);\n extern char *print_int_node (tree);\n@@ -1299,6 +1318,7 @@ extern void init_resource_processing (void);\n extern void start_complete_expand_method (tree);\n extern void java_expand_body (tree);\n \n+extern int get_symbol_table_index (tree, tree *);\n \n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n \n@@ -1658,11 +1678,11 @@ extern tree *type_map;\n /* Append a field initializer to CONS for a field with the given VALUE.\n    NAME is a char* string used for error checking;\n    the initializer must be specified in order. */\n-#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) {\\\n-  tree field = TREE_CHAIN(CONS);\\\n-  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) abort();\\\n-  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n-  TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n+  #define PUSH_FIELD_VALUE(CONS, NAME, VALUE) {\\\n+    tree field = TREE_CHAIN(CONS);\\\n+    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) abort();\\\n+    CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n+    TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n \n /* Finish creating a record CONSTRUCTOR CONS. */\n #define FINISH_RECORD_CONSTRUCTOR(CONS) \\"}, {"sha": "de4b213a6c68bc83bbff00a81c6b94cd30668bb4", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -1127,7 +1127,16 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       /* Emit the .jcf section.  */\n       emit_register_classes ();\n       if (flag_indirect_dispatch)\n-\temit_offset_symbol_table ();\n+\t{\n+\t  otable_decl \n+\t    = emit_symbol_table \n+\t    (get_identifier (\"otable\"), \n+\t     otable_decl, otable_methods, otable_syms_decl, integer_type_node);\n+\t  atable_decl \n+\t    = emit_symbol_table \n+\t    (get_identifier (\"atable\"), \n+\t     atable_decl, atable_methods, atable_syms_decl, ptr_type_node);\n+\t}\n     }\n \n   write_resource_constructor ();"}, {"sha": "a86041acd2d44a2193d3d155a936a84f29b0676e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -1,3 +1,17 @@\n+2003-10-01  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClass.cc (initializeClass): Check for otable and\n+\tatable.\n+\t(_Jv_LinkOffsetTable): Check for existence of atable.  Rewrite\n+\tloops using for().  Search superinterfaces.  Check for fields as\n+\twell as methods.  Initialize atable as well as otable: check for\n+\tstatic methods as well as virtual methods.\n+\t* java/lang/Class.h (struct _Jv_AddressTable): New.\n+\t(atable): New.\n+\t(atable_syms): New.\n+\t* include/jvm.h (_Jv_equalUtf8Consts): constify.\n+\t* prims.cc (_Jv_equalUtf8Consts): constify.\n+\n 2003-09-29  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/10596:"}, {"sha": "b28f61a0e970c635fc6e66fdb270441e14bbe4ca", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -145,7 +145,7 @@ extern int _Jv_strLengthUtf8(char* str, int len);\n typedef struct _Jv_Utf8Const Utf8Const;\n _Jv_Utf8Const *_Jv_makeUtf8Const (char *s, int len);\n _Jv_Utf8Const *_Jv_makeUtf8Const (jstring string);\n-extern jboolean _Jv_equalUtf8Consts (_Jv_Utf8Const *, _Jv_Utf8Const *);\n+extern jboolean _Jv_equalUtf8Consts (const _Jv_Utf8Const *, const _Jv_Utf8Const *);\n extern jboolean _Jv_equal (_Jv_Utf8Const *, jstring, jint);\n extern jboolean _Jv_equaln (_Jv_Utf8Const *, jstring, jint);\n "}, {"sha": "7572c6cfdb2920566d8c79d17762d4f1138b1d60", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -125,6 +125,12 @@ struct _Jv_OffsetTable\n   jint offsets[];\n };\n \n+struct _Jv_AddressTable\n+{\n+  jint state;\n+  void *addresses[];\n+};\n+\n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n \n #define JV_CLASS(Obj) ((jclass) (*(_Jv_VTable **) Obj)->clas)\n@@ -324,7 +330,7 @@ class java::lang::Class : public java::lang::Object\n   friend jstring _Jv_GetMethodString(jclass, _Jv_Utf8Const *);\n   friend jshort _Jv_AppendPartialITable (jclass, jclass, void **, jshort);\n   friend jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n-  friend void _Jv_LinkOffsetTable (jclass);\n+  friend void _Jv_LinkSymbolTable (jclass);\n   friend void _Jv_LayoutVTableMethods (jclass klass);\n   friend void _Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n   friend void _Jv_MakeVTable (jclass);\n@@ -404,6 +410,8 @@ class java::lang::Class : public java::lang::Object\n   _Jv_OffsetTable *otable;\n   // Offset table symbols.\n   _Jv_MethodSymbol *otable_syms;\n+  _Jv_AddressTable *atable;\n+  _Jv_MethodSymbol *atable_syms;\n   // Interfaces implemented by this class.\n   jclass *interfaces;\n   // The class loader for this class."}, {"sha": "aa5867fc8711db8916e2c9c41ab8b226205d7e7a", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 212, "deletions": 48, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -36,6 +36,7 @@ details.  */\n #include <java/lang/IllegalAccessError.h>\n #include <java/lang/IllegalArgumentException.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/NoSuchFieldError.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/InstantiationException.h>\n #include <java/lang/NoClassDefFoundError.h>\n@@ -790,7 +791,7 @@ java::lang::Class::initializeClass (void)\n          so ensure internal tables are built.  */\n       _Jv_PrepareConstantTimeTables (this);\n       _Jv_MakeVTable(this);\n-      _Jv_LinkOffsetTable(this);\n+      _Jv_LinkSymbolTable(this);\n \n       return;\n     }\n@@ -830,8 +831,8 @@ java::lang::Class::initializeClass (void)\n   if (vtable == NULL)\n     _Jv_MakeVTable(this);\n \n-  if (otable != NULL && otable->state == 0)\n-    _Jv_LinkOffsetTable(this);\n+  if (otable || atable)\n+    _Jv_LinkSymbolTable(this);\n \n   // Steps 8, 9, 10, 11.\n   try\n@@ -1533,75 +1534,238 @@ java::lang::Class::getProtectionDomain0 ()\n   return protectionDomain;\n }\n \n-// Functions for indirect dispatch (symbolic virtual method binding) support.\n+// Functions for indirect dispatch (symbolic virtual binding) support.\n+\n+// There are two tables, atable and otable.  atable is an array of\n+// addresses, and otable is an array of offsets, and these are used\n+// for static and virtual members respectively.\n+\n+// {a,o}table_syms is an array of _Jv_MethodSymbols.  Each such symbol\n+// is a tuple of {classname, member name, signature}.\n+// _Jv_LinkSymbolTable() scans these two arrays and fills in the\n+// corresponding atable and otable with the addresses of static\n+// members and the offsets of virtual members.\n+\n+// The offset (in bytes) for each resolved method or field is placed\n+// at the corresponding position in the virtual method offset table\n+// (klass->otable). \n+\n+// The same otable and atable may be shared by many classes.\n \n-// Resolve entries in the virtual method offset symbol table \n-// (klass->otable_syms). The vtable offset (in bytes) for each resolved method \n-// is placed at the corresponding position in the virtual method offset table \n-// (klass->otable). A single otable and otable_syms pair may be shared by many \n-// classes.\n void\n-_Jv_LinkOffsetTable(jclass klass)\n+_Jv_LinkSymbolTable(jclass klass)\n {\n-  //// FIXME: Need to lock the otable ////\n+  //// FIXME: Need to lock the tables ////\n   \n+  int index = 0;\n+  _Jv_MethodSymbol sym;\n   if (klass->otable == NULL\n       || klass->otable->state != 0)\n-    return;\n-  \n+    goto atable;\n+   \n   klass->otable->state = 1;\n \n-  int index = 0;\n-  _Jv_MethodSymbol sym = klass->otable_syms[0];\n-\n-  while (sym.name != NULL)\n+  for (index = 0; sym = klass->otable_syms[index], sym.name != NULL; index++)\n     {\n       jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n       _Jv_Method *meth = NULL;            \n+\n+      const _Jv_Utf8Const *signature = sym.signature;\n+\n+      // FIXME: This should be special index for ThrowNoSuchMethod().\n+      klass->otable->offsets[index] = -1;\n       \n-      if (target_class != NULL)\n-\tif (target_class->isInterface())\n+      if (target_class == NULL)\n+\tcontinue;\n+\n+      if (target_class->isInterface())\n+\t{\n+\t  // FIXME: This does not yet fully conform to binary compatibility\n+\t  // rules. It will break if a declaration is moved into a \n+\t  // superinterface.\n+\t  for (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n+\t    {\n+\t      for (int i=0; i < cls->method_count; i++)\n+\t\t{\n+\t\t  meth = &cls->methods[i];\n+\t\t  if (_Jv_equalUtf8Consts (sym.name, meth->name)\n+\t\t      && _Jv_equalUtf8Consts (signature, meth->signature))\n+\t\t    {\n+\t\t      klass->otable->offsets[index] = i + 1;\n+\t\t      goto found;\n+\t\t    }\n+\t\t}\n+\t    \n+\t    }\n+\tfound:\n+\t  continue;\n+\t}\n+\n+      // We're looking for a field or a method, and we can tell\n+      // which is needed by looking at the signature.\n+      if (signature->length >= 2\n+\t  && signature->data[0] == '(')\n+\t{\n+ \t  // If the target class does not have a vtable_method_count yet, \n+\t  // then we can't tell the offsets for its methods, so we must lay \n+\t  // it out now.\n+\t  if (target_class->vtable_method_count == -1)\n+\t    {\n+\t      JvSynchronize sync (target_class);\n+\t      _Jv_LayoutVTableMethods (target_class);\n+\t    }\n+\t\t\n+\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t\t\t\t\t  sym.signature);\n+\t\t\n+\t  if (meth != NULL)\n+\t    {\n+\t      klass->otable->offsets[index] = \n+\t\t_Jv_VTable::idx_to_offset (meth->index);\t      \n+\t    }\n+\n+\t  continue;\n+\t}\n+\n+      // try fields\n+      {\n+\t_Jv_Field *the_field = NULL;\n+\n+\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n \t  {\n-\t    // FIXME: This does not yet fully conform to binary compatibility\n-\t    // rules. It will break if a declaration is moved into a \n-\t    // superinterface.\n-\t    for (int i=0; i < target_class->method_count; i++)\n+\t    for (int i = 0; i < cls->field_count; i++)\n \t      {\n-\t\tmeth = &target_class->methods[i];\n-\t\tif (_Jv_equalUtf8Consts (sym.name, meth->name)\n-\t\t    && _Jv_equalUtf8Consts (sym.signature, meth->signature))\n-\t\t  {\n-\t\t    klass->otable->offsets[index] = i + 1;\n-\t\t    break;\n-\t\t  }\n+\t\t_Jv_Field *field = &cls->fields[i];\n+\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n+\t\t  continue;\n+\n+\t\t// FIXME: What access checks should we perform here?\n+// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n+// \t\t  {\n+\n+\t\tif (!field->isResolved ())\n+\t\t  _Jv_ResolveField (field, cls->loader);\n+\n+// \t\tif (field_type != 0 && field->type != field_type)\n+// \t\t  throw new java::lang::LinkageError\n+// \t\t    (JvNewStringLatin1 \n+// \t\t     (\"field type mismatch with different loaders\"));\n+\n+\t\tthe_field = field;\n+\t\tgoto end_of_field_search;\n \t      }\n \t  }\n-\telse\n+      end_of_field_search:\n+\tif (the_field != NULL)\n \t  {\n-\t    // If the target class does not have a vtable_method_count yet, \n-\t    // then we can't tell the offsets for its methods, so we must lay \n-\t    // it out now.\n-\t    if (target_class->vtable_method_count == -1)\n+\t    if (the_field->flags & 0x0008 /* Modifier::STATIC */)\n+\t      {\t      \n+\t\tthrow new java::lang::IncompatibleClassChangeError;\n+\t      }\n+\t    else\n \t      {\n-\t\tJvSynchronize sync (target_class);\n-\t\t_Jv_LayoutVTableMethods (target_class);\n+\t\tklass->otable->offsets[index] = the_field->u.boffset;\n \t      }\n+\t  }\n+\telse\n+\t  {\n+\t    throw new java::lang::NoSuchFieldError\n+\t      (_Jv_NewStringUtf8Const (sym.name));\n+\t  }\n+      }\n+    }\n+\n+ atable:\n+  if (klass->atable == NULL\n+      || klass->atable->state != 0)\n+    return;\n+\n+  klass->atable->state = 1;\n+\n+  for (index = 0; sym = klass->atable_syms[index], sym.name != NULL; index++)\n+    {\n+      jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n+      _Jv_Method *meth = NULL;            \n+      const _Jv_Utf8Const *signature = sym.signature;\n+\n+      // ??? Setting this pointer to null will at least get us a\n+      // NullPointerException\n+      klass->atable->addresses[index] = NULL;\n+      \n+      if (target_class == NULL)\n+\tcontinue;\n+      \n+      // We're looking for a static field or a static method, and we\n+      // can tell which is needed by looking at the signature.\n+      if (signature->length >= 2\n+\t  && signature->data[0] == '(')\n+\t{\n+ \t  // If the target class does not have a vtable_method_count yet, \n+\t  // then we can't tell the offsets for its methods, so we must lay \n+\t  // it out now.\n+\t  if (target_class->vtable_method_count == -1)\n+\t    {\n+\t      JvSynchronize sync (target_class);\n+\t      _Jv_LayoutVTableMethods (target_class);\n+\t    }\n+\t  \n+\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t\t\t\t\t  sym.signature);\n+\t  \n+\t  if (meth != NULL)\n+\t    klass->atable->addresses[index] = meth->ncode;\n+\t  else\n+\t    klass->atable->addresses[index] = (void *)_Jv_ThrowNoSuchMethodError;\n \n-            meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n-\t\t\t\t\t    sym.signature);\n+\t  continue;\n+\t}\n+\n+      // try fields\n+      {\n+\t_Jv_Field *the_field = NULL;\n \n-\t    if (meth != NULL)\n+\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n+\t  {\n+\t    for (int i = 0; i < cls->field_count; i++)\n \t      {\n-\t\tklass->otable->offsets[index] = \n-\t\t  _Jv_VTable::idx_to_offset (meth->index);\n+\t\t_Jv_Field *field = &cls->fields[i];\n+\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n+\t\t  continue;\n+\n+\t\t// FIXME: What access checks should we perform here?\n+// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n+// \t\t  {\n+\n+\t\tif (!field->isResolved ())\n+\t\t  _Jv_ResolveField (field, cls->loader);\n+\t\t\n+// \t\tif (field_type != 0 && field->type != field_type)\n+// \t\t  throw new java::lang::LinkageError\n+// \t\t    (JvNewStringLatin1 \n+// \t\t     (\"field type mismatch with different loaders\"));\n+\n+\t\tthe_field = field;\n+\t\tgoto end_of_static_field_search;\n \t      }\n \t  }\n-\n-      if (meth == NULL)\n-\t// FIXME: This should be special index for ThrowNoSuchMethod().\n-\tklass->otable->offsets[index] = -1;\n-\n-      sym = klass->otable_syms[++index];\n+      end_of_static_field_search:\n+\tif (the_field != NULL)\n+\t  {\n+\t    if (the_field->flags & 0x0008 /* Modifier::STATIC */)\n+\t      {\t      \n+\t\tklass->atable->addresses[index] = the_field->u.addr;\n+\t      }\n+\t    else\n+\t      {\n+\t\tthrow new java::lang::IncompatibleClassChangeError;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    throw new java::lang::NoSuchFieldError\n+\t      (_Jv_NewStringUtf8Const (sym.name));\n+\t  }\n+      }\n     }\n }\n "}, {"sha": "2f21fb46735b48511b15005d70789b6eb475627b", "filename": "libjava/java/util/LinkedList.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Futil%2FLinkedList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fjava%2Futil%2FLinkedList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLinkedList.java?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -1,4 +1,4 @@\n-/* LinkedList.java -- Linked list implementation of the List interface\n+ /* LinkedList.java -- Linked list implementation of the List interface\n    Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath."}, {"sha": "f15c24b796291332830f1f7b88ea24341a63672d", "filename": "libjava/prims.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=9dfc2ec225a5a8f0a5d2a9b5853d0a19d728e129", "patch": "@@ -165,19 +165,19 @@ SIGNAL_HANDLER (catch_fpe)\n \f\n \n jboolean\n-_Jv_equalUtf8Consts (Utf8Const* a, Utf8Const *b)\n+_Jv_equalUtf8Consts (const Utf8Const* a, const Utf8Const *b)\n {\n   int len;\n-  _Jv_ushort *aptr, *bptr;\n+  const _Jv_ushort *aptr, *bptr;\n   if (a == b)\n     return true;\n   if (a->hash != b->hash)\n     return false;\n   len = a->length;\n   if (b->length != len)\n     return false;\n-  aptr = (_Jv_ushort *)a->data;\n-  bptr = (_Jv_ushort *)b->data;\n+  aptr = (const _Jv_ushort *)a->data;\n+  bptr = (const _Jv_ushort *)b->data;\n   len = (len + 1) >> 1;\n   while (--len >= 0)\n     if (*aptr++ != *bptr++)"}]}