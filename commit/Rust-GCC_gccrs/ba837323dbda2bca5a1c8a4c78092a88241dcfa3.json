{"sha": "ba837323dbda2bca5a1c8a4c78092a88241dcfa3", "node_id": "C_kwDOANBUbNoAKGJhODM3MzIzZGJkYTJiY2E1YTFjOGE0Yzc4MDkyYTg4MjQxZGNmYTM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-06T08:40:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-06T08:40:12Z"}, "message": "openmp: Optimize for OpenMP atomics 2x__builtin_clear_padding+__builtin_memcmp if possible\n\nFor the few long double types that do have padding bits, e.g. on x86\nthe clear_type_padding_in_mask computed mask is\nff ff ff ff ff ff ff ff ff ff 00 00 for 32-bit and\nff ff ff ff ff ff ff ff ff ff 00 00 00 00 00 00 for 64-bit.\nInstead of doing __builtin_clear_padding on both operands that will clear the\nlast 2 or 6 bytes and then memcmp on the whole 12/16 bytes, we can just\nmemcmp 10 bytes.  The code also handles if the padding would be at the start\nor both at the start and end, but everything on byte boundaries only and\nnon-padding bits being contiguous.\nThis works around a tree-ssa-dse.c bug (but we need to fix it anyway,\nas libstdc++ won't do this and as it can deal with arbitrary types, it even\ncan't do that generally).\n\n2021-10-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/102571\n\t* c-omp.c (c_finish_omp_atomic): Optimize the case where type has\n\tpadding, but the non-padding bits are contiguous set of bytes\n\tby adjusting the memcmp call arguments instead of emitting\n\t__builtin_clear_padding and then comparing all the type's bytes.", "tree": {"sha": "d40c513e48bc98f7c1a2f9564bffcb1e6bacbc2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40c513e48bc98f7c1a2f9564bffcb1e6bacbc2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba837323dbda2bca5a1c8a4c78092a88241dcfa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba837323dbda2bca5a1c8a4c78092a88241dcfa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba837323dbda2bca5a1c8a4c78092a88241dcfa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba837323dbda2bca5a1c8a4c78092a88241dcfa3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8892d532d66910e518bc135a851a104322385ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8892d532d66910e518bc135a851a104322385ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8892d532d66910e518bc135a851a104322385ca2"}], "stats": {"total": 50, "additions": 48, "deletions": 2}, "files": [{"sha": "d8b98552fb9e31daa365589b0591ec2d6684d70b", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba837323dbda2bca5a1c8a4c78092a88241dcfa3/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba837323dbda2bca5a1c8a4c78092a88241dcfa3/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=ba837323dbda2bca5a1c8a4c78092a88241dcfa3", "patch": "@@ -379,6 +379,8 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n       if (SCALAR_FLOAT_TYPE_P (cmptype) && !test)\n \t{\n \t  bool clear_padding = false;\n+\t  HOST_WIDE_INT non_padding_start = 0;\n+\t  HOST_WIDE_INT non_padding_end = 0;\n \t  if (BITS_PER_UNIT == 8 && CHAR_BIT == 8)\n \t    {\n \t      HOST_WIDE_INT sz = int_size_in_bytes (cmptype), i;\n@@ -392,6 +394,40 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t\t    clear_padding = true;\n \t\t    break;\n \t\t  }\n+\t      if (clear_padding && buf[i] == 0)\n+\t\t{\n+\t\t  /* Try to optimize.  In the common case where\n+\t\t     non-padding bits are all continuous and start\n+\t\t     and end at a byte boundary, we can just adjust\n+\t\t     the memcmp call arguments and don't need to\n+\t\t     emit __builtin_clear_padding calls.  */\n+\t\t  if (i == 0)\n+\t\t    {\n+\t\t      for (i = 0; i < sz; i++)\n+\t\t\tif (buf[i] != 0)\n+\t\t\t  break;\n+\t\t      if (i < sz && buf[i] == (unsigned char) ~0)\n+\t\t\t{\n+\t\t\t  non_padding_start = i;\n+\t\t\t  for (; i < sz; i++)\n+\t\t\t    if (buf[i] != (unsigned char) ~0)\n+\t\t\t      break;\n+\t\t\t}\n+\t\t      else\n+\t\t\ti = 0;\n+\t\t    }\n+\t\t  if (i != 0)\n+\t\t    {\n+\t\t      non_padding_end = i;\n+\t\t      for (; i < sz; i++)\n+\t\t\tif (buf[i] != 0)\n+\t\t\t  {\n+\t\t\t    non_padding_start = 0;\n+\t\t\t    non_padding_end = 0;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n \t    }\n \t  tree inttype = NULL_TREE;\n \t  if (!clear_padding && tree_fits_uhwi_p (TYPE_SIZE (cmptype)))\n@@ -428,12 +464,22 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n \t      tmp2 = build4 (TARGET_EXPR, cmptype, tmp2,\n \t\t\t     TREE_OPERAND (rhs1, 1), NULL, NULL);\n \t      tmp2 = build1 (ADDR_EXPR, pcmptype, tmp2);\n+\t      if (non_padding_start)\n+\t\t{\n+\t\t  tmp1 = build2 (POINTER_PLUS_EXPR, pcmptype, tmp1,\n+\t\t\t\t size_int (non_padding_start));\n+\t\t  tmp2 = build2 (POINTER_PLUS_EXPR, pcmptype, tmp2,\n+\t\t\t\t size_int (non_padding_start));\n+\t\t}\n \t      tree fndecl = builtin_decl_explicit (BUILT_IN_MEMCMP);\n \t      rhs1 = build_call_expr_loc (loc, fndecl, 3, tmp1, tmp2,\n-\t\t\t\t\t  TYPE_SIZE_UNIT (cmptype));\n+\t\t\t\t\t  non_padding_end\n+\t\t\t\t\t  ? size_int (non_padding_end\n+\t\t\t\t\t\t      - non_padding_start)\n+\t\t\t\t\t  : TYPE_SIZE_UNIT (cmptype));\n \t      rhs1 = build2 (EQ_EXPR, boolean_type_node, rhs1,\n \t\t\t     integer_zero_node);\n-\t      if (clear_padding)\n+\t      if (clear_padding && non_padding_end == 0)\n \t\t{\n \t\t  fndecl = builtin_decl_explicit (BUILT_IN_CLEAR_PADDING);\n \t\t  tree cp1 = build_call_expr_loc (loc, fndecl, 1, tmp1);"}]}