{"sha": "71bfb77a025867eaea935a09e0f45b4149b2f5da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFiZmI3N2EwMjU4NjdlYWVhOTM1YTA5ZTBmNDViNDE0OWIyZjVkYQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-08-01T16:37:24Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-08-01T16:37:24Z"}, "message": "This patch optimizes the prolog and epilog code to reduce the number of instructions and avoid multiple writes to SP.\n\nThis patch optimizes the prolog and epilog code to reduce the number of\ninstructions and avoid multiple writes to SP.  The key idea is that epilogs\nare almost exact reverses of prologs, and thus all the decisions only need\nto be taken once.  The frame layout is decided in aarch64_layout_frame()\nand decisions recorded in the new aarch64_frame fields initial_adjust,\ncallee_adjust, callee_offset and final_adjust.\n\nA generic frame setup consists of 5 basic steps:\n\n1. sub sp, sp, initial_adjust\n2. stp reg1, reg2, [sp, -callee_adjust]!      (push if callee_adjust != 0)\n3. add fp, sp, callee_offset                  (if frame_pointer_needed)\n4. stp reg3, reg4, [sp, callee_offset + N*16] (store remaining callee-saves)\n5. sub sp, sp, final_adjust\n\nThe epilog reverses this, and may omit step 3 if alloca wasn't used.\n\n    gcc/\n\t* config/aarch64/aarch64.h (aarch64_frame):\n\tRemove padding0 and hardfp_offset.  Add locals_offset,\n\tinitial_adjust, callee_adjust, callee_offset and final_adjust.\n\t* config/aarch64/aarch64.c (aarch64_layout_frame):\n\tRemove unused padding0 and hardfp_offset initializations.\n\tChoose frame layout and set frame variables accordingly.\n\tUse INVALID_REGNUM instead of FIRST_PSEUDO_REGISTER.\n\t(aarch64_push_regs): Use INVALID_REGNUM, not FIRST_PSEUDO_REGISTER.\n\t(aarch64_pop_regs): Likewise.\n\t(aarch64_expand_prologue): Remove all decision code, just emit\n\tprolog according to frame variables.\n\t(aarch64_expand_epilogue): Remove all decision code, just emit\n\tepilog according to frame variables.\n\t(aarch64_initial_elimination_offset): Use offset to local/arg area.\n\n    testsuite/\n\t* gcc.target/aarch64/test_frame_10.c: Fix test to check for a\n\tsingle stack adjustment, no writeback.\t\n\t* gcc.target/aarch64/test_frame_12.c: Likewise.\n\t* gcc.target/aarch64/test_frame_13.c: Likewise.\n\t* gcc.target/aarch64/test_frame_15.c: Likewise.\n\t* gcc.target/aarch64/test_frame_6.c: Likewise.\n\t* gcc.target/aarch64/test_frame_7.c: Likewise.\n\t* gcc.target/aarch64/test_frame_8.c: Likewise.\n\t* gcc.target/aarch64/test_frame_16.c: New test.\n\nFrom-SVN: r238960", "tree": {"sha": "df4eedfb99680e45d6aa78e03d9b41f2d7cea674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df4eedfb99680e45d6aa78e03d9b41f2d7cea674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71bfb77a025867eaea935a09e0f45b4149b2f5da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71bfb77a025867eaea935a09e0f45b4149b2f5da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71bfb77a025867eaea935a09e0f45b4149b2f5da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71bfb77a025867eaea935a09e0f45b4149b2f5da/comments", "author": null, "committer": null, "parents": [{"sha": "0f86525ae07131b2cb6ec0fe22243b49ca63490c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f86525ae07131b2cb6ec0fe22243b49ca63490c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f86525ae07131b2cb6ec0fe22243b49ca63490c"}], "stats": {"total": 481, "additions": 260, "deletions": 221}, "files": [{"sha": "5d7616ef37c9bc3144729d2e4f55b34e96f8d9ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -1,3 +1,20 @@\n+2016-08-01  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.h (aarch64_frame):\n+\tRemove padding0 and hardfp_offset.  Add locals_offset,\n+\tinitial_adjust, callee_adjust, callee_offset and final_adjust.\n+\t* config/aarch64/aarch64.c (aarch64_layout_frame):\n+\tRemove unused padding0 and hardfp_offset initializations.\n+\tChoose frame layout and set frame variables accordingly.\n+\tUse INVALID_REGNUM instead of FIRST_PSEUDO_REGISTER.\n+\t(aarch64_push_regs): Use INVALID_REGNUM, not FIRST_PSEUDO_REGISTER.\n+\t(aarch64_pop_regs): Likewise.\n+\t(aarch64_expand_prologue): Remove all decision code, just emit\n+\tprolog according to frame variables.\n+\t(aarch64_expand_epilogue): Remove all decision code, just emit\n+\tepilog according to frame variables.\n+\t(aarch64_initial_elimination_offset): Use offset to local/arg area.\n+\n 2015-08-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/72748"}, {"sha": "f161bff83ec275f1722ca097fa769a4181053407", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 166, "deletions": 193, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -2728,8 +2728,8 @@ aarch64_layout_frame (void)\n #define SLOT_NOT_REQUIRED (-2)\n #define SLOT_REQUIRED     (-1)\n \n-  cfun->machine->frame.wb_candidate1 = FIRST_PSEUDO_REGISTER;\n-  cfun->machine->frame.wb_candidate2 = FIRST_PSEUDO_REGISTER;\n+  cfun->machine->frame.wb_candidate1 = INVALID_REGNUM;\n+  cfun->machine->frame.wb_candidate2 = INVALID_REGNUM;\n \n   /* First mark all the registers that really need to be saved...  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n@@ -2763,7 +2763,6 @@ aarch64_layout_frame (void)\n       cfun->machine->frame.wb_candidate1 = R29_REGNUM;\n       cfun->machine->frame.reg_offset[R30_REGNUM] = UNITS_PER_WORD;\n       cfun->machine->frame.wb_candidate2 = R30_REGNUM;\n-      cfun->machine->frame.hardfp_offset = 2 * UNITS_PER_WORD;\n       offset += 2 * UNITS_PER_WORD;\n     }\n \n@@ -2772,9 +2771,9 @@ aarch64_layout_frame (void)\n     if (cfun->machine->frame.reg_offset[regno] == SLOT_REQUIRED)\n       {\n \tcfun->machine->frame.reg_offset[regno] = offset;\n-\tif (cfun->machine->frame.wb_candidate1 == FIRST_PSEUDO_REGISTER)\n+\tif (cfun->machine->frame.wb_candidate1 == INVALID_REGNUM)\n \t  cfun->machine->frame.wb_candidate1 = regno;\n-\telse if (cfun->machine->frame.wb_candidate2 == FIRST_PSEUDO_REGISTER)\n+\telse if (cfun->machine->frame.wb_candidate2 == INVALID_REGNUM)\n \t  cfun->machine->frame.wb_candidate2 = regno;\n \toffset += UNITS_PER_WORD;\n       }\n@@ -2783,31 +2782,101 @@ aarch64_layout_frame (void)\n     if (cfun->machine->frame.reg_offset[regno] == SLOT_REQUIRED)\n       {\n \tcfun->machine->frame.reg_offset[regno] = offset;\n-\tif (cfun->machine->frame.wb_candidate1 == FIRST_PSEUDO_REGISTER)\n+\tif (cfun->machine->frame.wb_candidate1 == INVALID_REGNUM)\n \t  cfun->machine->frame.wb_candidate1 = regno;\n-\telse if (cfun->machine->frame.wb_candidate2 == FIRST_PSEUDO_REGISTER\n+\telse if (cfun->machine->frame.wb_candidate2 == INVALID_REGNUM\n \t\t && cfun->machine->frame.wb_candidate1 >= V0_REGNUM)\n \t  cfun->machine->frame.wb_candidate2 = regno;\n \toffset += UNITS_PER_WORD;\n       }\n \n-  cfun->machine->frame.padding0 =\n-    (ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT) - offset);\n   offset = ROUND_UP (offset, STACK_BOUNDARY / BITS_PER_UNIT);\n \n   cfun->machine->frame.saved_regs_size = offset;\n \n+  HOST_WIDE_INT varargs_and_saved_regs_size\n+    = offset + cfun->machine->frame.saved_varargs_size;\n+\n   cfun->machine->frame.hard_fp_offset\n-    = ROUND_UP (cfun->machine->frame.saved_varargs_size\n-\t\t+ get_frame_size ()\n-\t\t+ cfun->machine->frame.saved_regs_size,\n+    = ROUND_UP (varargs_and_saved_regs_size + get_frame_size (),\n \t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n \n   cfun->machine->frame.frame_size\n     = ROUND_UP (cfun->machine->frame.hard_fp_offset\n \t\t+ crtl->outgoing_args_size,\n \t\tSTACK_BOUNDARY / BITS_PER_UNIT);\n \n+  cfun->machine->frame.locals_offset = cfun->machine->frame.saved_varargs_size;\n+\n+  cfun->machine->frame.initial_adjust = 0;\n+  cfun->machine->frame.final_adjust = 0;\n+  cfun->machine->frame.callee_adjust = 0;\n+  cfun->machine->frame.callee_offset = 0;\n+\n+  HOST_WIDE_INT max_push_offset = 0;\n+  if (cfun->machine->frame.wb_candidate2 != INVALID_REGNUM)\n+    max_push_offset = 512;\n+  else if (cfun->machine->frame.wb_candidate1 != INVALID_REGNUM)\n+    max_push_offset = 256;\n+\n+  if (cfun->machine->frame.frame_size < max_push_offset\n+      && crtl->outgoing_args_size == 0)\n+    {\n+      /* Simple, small frame with no outgoing arguments:\n+\t stp reg1, reg2, [sp, -frame_size]!\n+\t stp reg3, reg4, [sp, 16]  */\n+      cfun->machine->frame.callee_adjust = cfun->machine->frame.frame_size;\n+    }\n+  else if ((crtl->outgoing_args_size\n+\t    + cfun->machine->frame.saved_regs_size < 512)\n+\t   && !(cfun->calls_alloca\n+\t\t&& cfun->machine->frame.hard_fp_offset < max_push_offset))\n+    {\n+      /* Frame with small outgoing arguments:\n+\t sub sp, sp, frame_size\n+\t stp reg1, reg2, [sp, outgoing_args_size]\n+\t stp reg3, reg4, [sp, outgoing_args_size + 16]  */\n+      cfun->machine->frame.initial_adjust = cfun->machine->frame.frame_size;\n+      cfun->machine->frame.callee_offset\n+\t= cfun->machine->frame.frame_size - cfun->machine->frame.hard_fp_offset;\n+    }\n+  else if (cfun->machine->frame.hard_fp_offset < max_push_offset)\n+    {\n+      /* Frame with large outgoing arguments but a small local area:\n+\t stp reg1, reg2, [sp, -hard_fp_offset]!\n+\t stp reg3, reg4, [sp, 16]\n+\t sub sp, sp, outgoing_args_size  */\n+      cfun->machine->frame.callee_adjust = cfun->machine->frame.hard_fp_offset;\n+      cfun->machine->frame.final_adjust\n+\t= cfun->machine->frame.frame_size - cfun->machine->frame.callee_adjust;\n+    }\n+  else if (!frame_pointer_needed\n+\t   && varargs_and_saved_regs_size < max_push_offset)\n+    {\n+      /* Frame with large local area and outgoing arguments (this pushes the\n+\t callee-saves first, followed by the locals and outgoing area):\n+\t stp reg1, reg2, [sp, -varargs_and_saved_regs_size]!\n+\t stp reg3, reg4, [sp, 16]\n+\t sub sp, sp, frame_size - varargs_and_saved_regs_size  */\n+      cfun->machine->frame.callee_adjust = varargs_and_saved_regs_size;\n+      cfun->machine->frame.final_adjust\n+\t= cfun->machine->frame.frame_size - cfun->machine->frame.callee_adjust;\n+      cfun->machine->frame.hard_fp_offset = cfun->machine->frame.callee_adjust;\n+      cfun->machine->frame.locals_offset = cfun->machine->frame.hard_fp_offset;\n+    }\n+  else\n+    {\n+      /* Frame with large local area and outgoing arguments using frame pointer:\n+\t sub sp, sp, hard_fp_offset\n+\t stp x29, x30, [sp, 0]\n+\t add x29, sp, 0\n+\t stp reg3, reg4, [sp, 16]\n+\t sub sp, sp, outgoing_args_size  */\n+      cfun->machine->frame.initial_adjust = cfun->machine->frame.hard_fp_offset;\n+      cfun->machine->frame.final_adjust\n+\t= cfun->machine->frame.frame_size - cfun->machine->frame.initial_adjust;\n+    }\n+\n   cfun->machine->frame.laid_out = true;\n }\n \n@@ -2866,7 +2935,7 @@ aarch64_push_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment)\n   rtx_insn *insn;\n   machine_mode mode = (regno1 <= R30_REGNUM) ? DImode : DFmode;\n \n-  if (regno2 == FIRST_PSEUDO_REGISTER)\n+  if (regno2 == INVALID_REGNUM)\n     return aarch64_pushwb_single_reg (mode, regno1, adjustment);\n \n   rtx reg1 = gen_rtx_REG (mode, regno1);\n@@ -2905,7 +2974,7 @@ aarch64_pop_regs (unsigned regno1, unsigned regno2, HOST_WIDE_INT adjustment,\n \n   *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg1, *cfi_ops);\n \n-  if (regno2 == FIRST_PSEUDO_REGISTER)\n+  if (regno2 == INVALID_REGNUM)\n     {\n       rtx mem = plus_constant (Pmode, stack_pointer_rtx, adjustment);\n       mem = gen_rtx_POST_MODIFY (Pmode, stack_pointer_rtx, mem);\n@@ -3106,23 +3175,16 @@ aarch64_restore_callee_saves (machine_mode mode,\n void\n aarch64_expand_prologue (void)\n {\n-  /* sub sp, sp, #<frame_size>\n-     stp {fp, lr}, [sp, #<frame_size> - 16]\n-     add fp, sp, #<frame_size> - hardfp_offset\n-     stp {cs_reg}, [fp, #-16] etc.\n-\n-     sub sp, sp, <final_adjustment_if_any>\n-  */\n-  HOST_WIDE_INT frame_size, offset;\n-  HOST_WIDE_INT fp_offset;\t\t/* Offset from hard FP to SP.  */\n-  HOST_WIDE_INT hard_fp_offset;\n-  rtx_insn *insn;\n-\n   aarch64_layout_frame ();\n \n-  offset = frame_size = cfun->machine->frame.frame_size;\n-  hard_fp_offset = cfun->machine->frame.hard_fp_offset;\n-  fp_offset = frame_size - hard_fp_offset;\n+  HOST_WIDE_INT frame_size = cfun->machine->frame.frame_size;\n+  HOST_WIDE_INT initial_adjust = cfun->machine->frame.initial_adjust;\n+  HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;\n+  HOST_WIDE_INT final_adjust = cfun->machine->frame.final_adjust;\n+  HOST_WIDE_INT callee_offset = cfun->machine->frame.callee_offset;\n+  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  rtx_insn *insn;\n \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = frame_size;\n@@ -3139,94 +3201,29 @@ aarch64_expand_prologue (void)\n \taarch64_emit_probe_stack_range (STACK_CHECK_PROTECT, frame_size);\n     }\n \n-  /* Store pairs and load pairs have a range only -512 to 504.  */\n-  if (offset >= 512)\n-    {\n-      /* When the frame has a large size, an initial decrease is done on\n-\t the stack pointer to jump over the callee-allocated save area for\n-\t register varargs, the local variable area and/or the callee-saved\n-\t register area.  This will allow the pre-index write-back\n-\t store pair instructions to be used for setting up the stack frame\n-\t efficiently.  */\n-      offset = hard_fp_offset;\n-      if (offset >= 512)\n-\toffset = cfun->machine->frame.saved_regs_size;\n-\n-      frame_size -= (offset + crtl->outgoing_args_size);\n-      fp_offset = 0;\n+  aarch64_add_constant (Pmode, SP_REGNUM, IP0_REGNUM, -initial_adjust, true);\n \n-      aarch64_add_constant (Pmode, SP_REGNUM, IP0_REGNUM, -frame_size, true);\n-    }\n-  else\n-    frame_size = -1;\n+  if (callee_adjust != 0)\n+    aarch64_push_regs (reg1, reg2, callee_adjust);\n \n-  if (offset > 0)\n+  if (frame_pointer_needed)\n     {\n-      bool skip_wb = false;\n-\n-      if (frame_pointer_needed)\n-\t{\n-\t  skip_wb = true;\n-\n-\t  if (fp_offset)\n-\t    {\n-\t      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t\t       GEN_INT (-offset)));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\n-\t      aarch64_save_callee_saves (DImode, fp_offset, R29_REGNUM,\n-\t\t\t\t\t R30_REGNUM, false);\n-\t    }\n-\t  else\n-\t    aarch64_push_regs (R29_REGNUM, R30_REGNUM, offset);\n-\n-\t  /* Set up frame pointer to point to the location of the\n-\t     previous frame pointer on the stack.  */\n-\t  insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t   GEN_INT (fp_offset)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n-\t}\n-      else\n-\t{\n-\t  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n-\t  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n-\n-\t  if (fp_offset\n-\t      || reg1 == FIRST_PSEUDO_REGISTER\n-\t      || (reg2 == FIRST_PSEUDO_REGISTER\n-\t\t  && offset >= 256))\n-\t    {\n-\t      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n-\t\t\t\t\t       GEN_INT (-offset)));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      aarch64_push_regs (reg1, reg2, offset);\n-\t      skip_wb = true;\n-\t    }\n-\t}\n-\n-      aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM, R30_REGNUM,\n-\t\t\t\t skip_wb);\n-      aarch64_save_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\t skip_wb);\n+      if (callee_adjust == 0)\n+\taarch64_save_callee_saves (DImode, callee_offset, R29_REGNUM,\n+\t\t\t\t   R30_REGNUM, false);\n+      insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (callee_offset)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n \n-  /* when offset >= 512,\n-     sub sp, sp, #<outgoing_args_size> */\n-  if (frame_size > -1)\n-    {\n-      if (crtl->outgoing_args_size > 0)\n-\t{\n-\t  insn = emit_insn (gen_add2_insn\n-\t\t\t    (stack_pointer_rtx,\n-\t\t\t     GEN_INT (- crtl->outgoing_args_size)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n-    }\n+  aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n+\t\t\t     callee_adjust != 0 || frame_pointer_needed);\n+  aarch64_save_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t     callee_adjust != 0 || frame_pointer_needed);\n+  aarch64_add_constant (Pmode, SP_REGNUM, IP1_REGNUM, -final_adjust,\n+\t\t\t!frame_pointer_needed);\n }\n \n /* Return TRUE if we can use a simple_return insn.\n@@ -3249,104 +3246,80 @@ aarch64_use_return_insn_p (void)\n   return cfun->machine->frame.frame_size == 0;\n }\n \n-/* Generate the epilogue instructions for returning from a function.  */\n+/* Generate the epilogue instructions for returning from a function.\n+   This is almost exactly the reverse of the prolog sequence, except\n+   that we need to insert barriers to avoid scheduling loads that read\n+   from a deallocated stack, and we optimize the unwind records by\n+   emitting them all together if possible.  */\n void\n aarch64_expand_epilogue (bool for_sibcall)\n {\n-  HOST_WIDE_INT frame_size, offset;\n-  HOST_WIDE_INT fp_offset;\n-  HOST_WIDE_INT hard_fp_offset;\n-  rtx_insn *insn;\n-  /* We need to add memory barrier to prevent read from deallocated stack.  */\n-  bool need_barrier_p = (get_frame_size () != 0\n-\t\t\t || cfun->machine->frame.saved_varargs_size);\n-\n   aarch64_layout_frame ();\n \n-  offset = frame_size = cfun->machine->frame.frame_size;\n-  hard_fp_offset = cfun->machine->frame.hard_fp_offset;\n-  fp_offset = frame_size - hard_fp_offset;\n+  HOST_WIDE_INT initial_adjust = cfun->machine->frame.initial_adjust;\n+  HOST_WIDE_INT callee_adjust = cfun->machine->frame.callee_adjust;\n+  HOST_WIDE_INT final_adjust = cfun->machine->frame.final_adjust;\n+  HOST_WIDE_INT callee_offset = cfun->machine->frame.callee_offset;\n+  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  rtx cfi_ops = NULL;\n+  rtx_insn *insn;\n \n-  /* Store pairs and load pairs have a range only -512 to 504.  */\n-  if (offset >= 512)\n-    {\n-      offset = hard_fp_offset;\n-      if (offset >= 512)\n-\toffset = cfun->machine->frame.saved_regs_size;\n+  /* We need to add memory barrier to prevent read from deallocated stack.  */\n+  bool need_barrier_p = (get_frame_size ()\n+\t\t\t + cfun->machine->frame.saved_varargs_size) != 0;\n \n-      frame_size -= (offset + crtl->outgoing_args_size);\n-      fp_offset = 0;\n-      if (!frame_pointer_needed && crtl->outgoing_args_size > 0)\n-\t{\n-\t  insn = emit_insn (gen_add2_insn\n-\t\t\t    (stack_pointer_rtx,\n-\t\t\t     GEN_INT (crtl->outgoing_args_size)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n+  /* Emit a barrier to prevent loads from a deallocated stack.  */\n+  if (final_adjust > crtl->outgoing_args_size || cfun->calls_alloca)\n+    {\n+      emit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n+      need_barrier_p = false;\n     }\n-  else\n-    frame_size = -1;\n \n-  /* If there were outgoing arguments or we've done dynamic stack\n-     allocation, then restore the stack pointer from the frame\n-     pointer.  This is at most one insn and more efficient than using\n-     GCC's internal mechanism.  */\n-  if (frame_pointer_needed\n-      && (crtl->outgoing_args_size || cfun->calls_alloca))\n+  /* Restore the stack pointer from the frame pointer if it may not\n+     be the same as the stack pointer.  */\n+  if (frame_pointer_needed && (final_adjust || cfun->calls_alloca))\n     {\n-      if (cfun->calls_alloca)\n-\temit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n-\n       insn = emit_insn (gen_add3_insn (stack_pointer_rtx,\n \t\t\t\t       hard_frame_pointer_rtx,\n-\t\t\t\t       GEN_INT (0)));\n-      offset = offset - fp_offset;\n+\t\t\t\t       GEN_INT (-callee_offset)));\n+      /* If writeback is used when restoring callee-saves, the CFA\n+\t is restored on the instruction doing the writeback.  */\n+      RTX_FRAME_RELATED_P (insn) = callee_adjust == 0;\n     }\n+  else\n+    aarch64_add_constant (Pmode, SP_REGNUM, IP1_REGNUM, final_adjust, true);\n \n-  if (offset > 0)\n-    {\n-      unsigned reg1 = cfun->machine->frame.wb_candidate1;\n-      unsigned reg2 = cfun->machine->frame.wb_candidate2;\n-      bool skip_wb = true;\n-      rtx cfi_ops = NULL;\n-\n-      if (frame_pointer_needed)\n-\tfp_offset = 0;\n-      else if (fp_offset\n-\t       || reg1 == FIRST_PSEUDO_REGISTER\n-\t       || (reg2 == FIRST_PSEUDO_REGISTER\n-\t\t   && offset >= 256))\n-\tskip_wb = false;\n-\n-      aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM, R30_REGNUM,\n-\t\t\t\t    skip_wb, &cfi_ops);\n-      aarch64_restore_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\t    skip_wb, &cfi_ops);\n+  aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n+\t\t\t\tcallee_adjust != 0, &cfi_ops);\n+  aarch64_restore_callee_saves (DFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n+\t\t\t\tcallee_adjust != 0, &cfi_ops);\n \n-      if (need_barrier_p)\n-\temit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n+  if (need_barrier_p)\n+    emit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n \n-      if (skip_wb)\n-\taarch64_pop_regs (reg1, reg2, offset, &cfi_ops);\n-      else\n-\temit_insn (gen_add2_insn (stack_pointer_rtx, GEN_INT (offset)));\n+  if (callee_adjust != 0)\n+    aarch64_pop_regs (reg1, reg2, callee_adjust, &cfi_ops);\n \n-      /* Reset the CFA to be SP + FRAME_SIZE.  */\n-      rtx new_cfa = stack_pointer_rtx;\n-      if (frame_size > 0)\n-\tnew_cfa = plus_constant (Pmode, new_cfa, frame_size);\n-      cfi_ops = alloc_reg_note (REG_CFA_DEF_CFA, new_cfa, cfi_ops);\n+  if (callee_adjust != 0 || initial_adjust > 65536)\n+    {\n+      /* Emit delayed restores and set the CFA to be SP + initial_adjust.  */\n       insn = get_last_insn ();\n-      REG_NOTES (insn) = cfi_ops;\n+      rtx new_cfa = plus_constant (Pmode, stack_pointer_rtx, initial_adjust);\n+      REG_NOTES (insn) = alloc_reg_note (REG_CFA_DEF_CFA, new_cfa, cfi_ops);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      cfi_ops = NULL;\n     }\n \n-  if (frame_size > 0)\n-    {\n-      if (need_barrier_p)\n-\temit_insn (gen_stack_tie (stack_pointer_rtx, stack_pointer_rtx));\n+  aarch64_add_constant (Pmode, SP_REGNUM, IP0_REGNUM, initial_adjust, true);\n \n-      aarch64_add_constant (Pmode, SP_REGNUM, IP0_REGNUM, frame_size, true);\n+  if (cfi_ops)\n+    {\n+      /* Emit delayed restores and reset the CFA to be SP.  */\n+      insn = get_last_insn ();\n+      cfi_ops = alloc_reg_note (REG_CFA_DEF_CFA, stack_pointer_rtx, cfi_ops);\n+      REG_NOTES (insn) = cfi_ops;\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* Stack adjustment for exception handler.  */\n@@ -5211,18 +5184,18 @@ aarch64_initial_elimination_offset (unsigned from, unsigned to)\n   if (to == HARD_FRAME_POINTER_REGNUM)\n     {\n       if (from == ARG_POINTER_REGNUM)\n-\treturn cfun->machine->frame.frame_size - crtl->outgoing_args_size;\n+\treturn cfun->machine->frame.hard_fp_offset;\n \n       if (from == FRAME_POINTER_REGNUM)\n-\treturn (cfun->machine->frame.hard_fp_offset\n-\t\t- cfun->machine->frame.saved_varargs_size);\n+\treturn cfun->machine->frame.hard_fp_offset\n+\t       - cfun->machine->frame.locals_offset;\n     }\n \n   if (to == STACK_POINTER_REGNUM)\n     {\n       if (from == FRAME_POINTER_REGNUM)\n-\t  return (cfun->machine->frame.frame_size\n-\t\t  - cfun->machine->frame.saved_varargs_size);\n+\t  return cfun->machine->frame.frame_size\n+\t\t - cfun->machine->frame.locals_offset;\n     }\n \n   return cfun->machine->frame.frame_size;"}, {"sha": "003fec87e41db618570663f28cc2387a87e8252a", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -550,11 +550,14 @@ struct GTY (()) aarch64_frame\n      STACK_BOUNDARY.  */\n   HOST_WIDE_INT saved_varargs_size;\n \n+  /* The size of the saved callee-save int/FP registers.  */\n+\n   HOST_WIDE_INT saved_regs_size;\n-  /* Padding if needed after the all the callee save registers have\n-     been saved.  */\n-  HOST_WIDE_INT padding0;\n-  HOST_WIDE_INT hardfp_offset;\t/* HARD_FRAME_POINTER_REGNUM */\n+\n+  /* Offset from the base of the frame (incomming SP) to the\n+     top of the locals area.  This value is always a multiple of\n+     STACK_BOUNDARY.  */\n+  HOST_WIDE_INT locals_offset;\n \n   /* Offset from the base of the frame (incomming SP) to the\n      hard_frame_pointer.  This value is always a multiple of\n@@ -564,12 +567,25 @@ struct GTY (()) aarch64_frame\n   /* The size of the frame.  This value is the offset from base of the\n    * frame (incomming SP) to the stack_pointer.  This value is always\n    * a multiple of STACK_BOUNDARY.  */\n+  HOST_WIDE_INT frame_size;\n+\n+  /* The size of the initial stack adjustment before saving callee-saves.  */\n+  HOST_WIDE_INT initial_adjust;\n+\n+  /* The writeback value when pushing callee-save registers.\n+     It is zero when no push is used.  */\n+  HOST_WIDE_INT callee_adjust;\n+\n+  /* The offset from SP to the callee-save registers after initial_adjust.\n+     It may be non-zero if no push is used (ie. callee_adjust == 0).  */\n+  HOST_WIDE_INT callee_offset;\n+\n+  /* The size of the stack adjustment after saving callee-saves.  */\n+  HOST_WIDE_INT final_adjust;\n \n   unsigned wb_candidate1;\n   unsigned wb_candidate2;\n \n-  HOST_WIDE_INT frame_size;\n-\n   bool laid_out;\n };\n "}, {"sha": "16311187e3fd61aec03b5cddd840e1fb582ae6ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -1,3 +1,15 @@\n+2016-08-01  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc.target/aarch64/test_frame_10.c: Fix test to check for a\n+\tsingle stack adjustment, no writeback.\t\n+\t* gcc.target/aarch64/test_frame_12.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_13.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_15.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_6.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_7.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_8.c: Likewise.\n+\t* gcc.target/aarch64/test_frame_16.c: New test.\n+\n 2015-08-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/72748"}, {"sha": "e23a4a83528b71a0de0c95752a9e530bf4ca79e5", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_10.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_10.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -4,8 +4,7 @@\n      * total frame size > 512.\n        area except outgoing <= 512\n      * number of callee-saved reg >= 2.\n-     * Split stack adjustment into two subtractions.\n-       the first subtractions could be optimized into \"stp !\".  */\n+     * Use a single stack adjustment, no writeback.  */\n \n /* { dg-do run } */\n /* { dg-options \"-O2 -fomit-frame-pointer --save-temps\" } */\n@@ -15,6 +14,6 @@\n t_frame_pattern_outgoing (test10, 480, \"x19\", 24, a[8], a[9], a[10])\n t_frame_run (test10)\n \n-/* { dg-final { scan-assembler-times \"stp\\tx19, x30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 1 } } */\n-/* { dg-final { scan-assembler-times \"ldp\\tx19, x30, \\\\\\[sp\\\\\\], \\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stp\\tx19, x30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldp\\tx19, x30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */\n "}, {"sha": "3d7d3594610c645d2d6f449b6ee0400fdd395849", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_12.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_12.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -13,6 +13,6 @@ t_frame_run (test12)\n \n /* { dg-final { scan-assembler-times \"sub\\tsp, sp, #\\[0-9\\]+\" 1 } } */\n \n-/* Check epilogue using write-back.  */\n-/* { dg-final { scan-assembler-times \"ldp\\tx29, x30, \\\\\\[sp\\\\\\], \\[0-9\\]+\" 3 } } */\n+/* Check epilogue using no write-back.  */\n+/* { dg-final { scan-assembler-times \"ldp\\tx29, x30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */\n "}, {"sha": "74b3370fa463b652265e00fff80cc8856524d509", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_13.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_13.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -2,8 +2,7 @@\n      * without outgoing.\n      * total frame size > 512.\n      * number of callee-save reg >= 2.\n-     * split the stack adjustment into two substractions,\n-       the second could be optimized into \"stp !\".  */\n+     * Use a single stack adjustment, no writeback.  */\n \n /* { dg-do run } */\n /* { dg-options \"-O2 --save-temps\" } */\n@@ -14,4 +13,4 @@ t_frame_pattern (test13, 700, )\n t_frame_run (test13)\n \n /* { dg-final { scan-assembler-times \"sub\\tsp, sp, #\\[0-9\\]+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"stp\\tx29, x30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 2 } } */\n+/* { dg-final { scan-assembler-times \"stp\\tx29, x30, \\\\\\[sp\\\\\\]\" 1 } } */"}, {"sha": "bed6714b4fe529a3b81ad8c5253924aa97bf8806", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_15.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_15.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -3,8 +3,7 @@\n      * total frame size > 512.\n        area except outgoing <= 512\n      * number of callee-save reg >= 2.\n-     * split the stack adjustment into two substractions,\n-       the first could be optimized into \"stp !\".  */\n+     * Use a single stack adjustment, no writeback.  */\n \n /* { dg-do run } */\n /* { dg-options \"-O2 --save-temps\" } */\n@@ -15,4 +14,4 @@ t_frame_pattern_outgoing (test15, 480, , 8, a[8])\n t_frame_run (test15)\n \n /* { dg-final { scan-assembler-times \"sub\\tsp, sp, #\\[0-9\\]+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"stp\\tx29, x30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 3 } } */\n+/* { dg-final { scan-assembler-times \"stp\\tx29, x30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */"}, {"sha": "28f3826adadd5eaa6486659e4d6b6d7c5960b9d2", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_16.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_16.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -0,0 +1,25 @@\n+/* Verify:\n+     * with outgoing.\n+     * single int register push.\n+     * varargs and callee-save size >= 256\n+     * Use 2 stack adjustments.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer --save-temps\" } */\n+\n+#define REP8(X) X,X,X,X,X,X,X,X\n+#define REP64(X) REP8(REP8(X))\n+\n+void outgoing (__builtin_va_list, ...);\n+\n+double vararg_outgoing (int x1, ...)\n+{\n+  double a1 = x1, a2 = x1 * 2, a3 = x1 * 3, a4 = x1 * 4, a5 = x1 * 5, a6 = x1 * 6;\n+  __builtin_va_list vl;\n+  __builtin_va_start (vl, x1);\n+  outgoing (vl, a1, a2, a3, a4, a5, a6, REP64 (1));\n+  __builtin_va_end (vl);\n+  return a1 + a2 + a3 + a4 + a5 + a6;\n+}\n+\n+/* { dg-final { scan-assembler-times \"sub\\tsp, sp, #\\[0-9\\]+\" 2 } } */"}, {"sha": "6a753dff87e28fa71a2f69df5fb95559163fa6cd", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_6.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -3,8 +3,7 @@\n      * without outgoing.\n      * total frame size > 512.\n      * number of callee-saved reg == 1.\n-     * split stack adjustment into two subtractions.\n-       the second subtraction should use \"str !\".  */\n+     * use a single stack adjustment, no writeback.  */\n \n /* { dg-do run } */\n /* { dg-options \"-O2 -fomit-frame-pointer --save-temps\" } */\n@@ -14,6 +13,7 @@\n t_frame_pattern (test6, 700, )\n t_frame_run (test6)\n \n-/* { dg-final { scan-assembler-times \"str\\tx30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 2 } } */\n-/* { dg-final { scan-assembler-times \"ldr\\tx30, \\\\\\[sp\\\\\\], \\[0-9\\]+\" 2 } } */\n+/* { dg-final { scan-assembler-times \"str\\tx30, \\\\\\[sp\\\\\\]\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldr\\tx30, \\\\\\[sp\\\\\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ldr\\tx30, \\\\\\[sp\\\\\\],\" 1 } } */\n "}, {"sha": "f2a8713d19d9f7df49073e9588c5d74661491fb6", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_7.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_7.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -3,8 +3,7 @@\n      * without outgoing.\n      * total frame size > 512.\n      * number of callee-saved reg == 2.\n-     * split stack adjustment into two subtractions.\n-       the second subtraction should use \"stp !\".  */\n+     * use a single stack adjustment, no writeback.  */\n \n /* { dg-do run } */\n /* { dg-options \"-O2 -fomit-frame-pointer --save-temps\" } */\n@@ -14,6 +13,6 @@\n t_frame_pattern (test7, 700, \"x19\")\n t_frame_run (test7)\n \n-/* { dg-final { scan-assembler-times \"stp\\tx19, x30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 1 } } */\n-/* { dg-final { scan-assembler-times \"ldp\\tx19, x30, \\\\\\[sp\\\\\\], \\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stp\\tx19, x30, \\\\\\[sp]\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldp\\tx19, x30, \\\\\\[sp\\\\\\]\" 1 } } */\n "}, {"sha": "9b6c6939eb5c3ae1bdcab7fb854b6c519f054c20", "filename": "gcc/testsuite/gcc.target/aarch64/test_frame_8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71bfb77a025867eaea935a09e0f45b4149b2f5da/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftest_frame_8.c?ref=71bfb77a025867eaea935a09e0f45b4149b2f5da", "patch": "@@ -12,6 +12,6 @@\n t_frame_pattern_outgoing (test8, 700, , 8, a[8])\n t_frame_run (test8)\n \n-/* { dg-final { scan-assembler-times \"str\\tx30, \\\\\\[sp, -\\[0-9\\]+\\\\\\]!\" 3 } } */\n-/* { dg-final { scan-assembler-times \"ldr\\tx30, \\\\\\[sp\\\\\\], \\[0-9\\]+\" 3 } } */\n+/* { dg-final { scan-assembler-times \"str\\tx30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldr\\tx30, \\\\\\[sp, \\[0-9\\]+\\\\\\]\" 1 } } */\n "}]}