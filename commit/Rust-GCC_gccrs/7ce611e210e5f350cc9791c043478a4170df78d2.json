{"sha": "7ce611e210e5f350cc9791c043478a4170df78d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NlNjExZTIxMGU1ZjM1MGNjOTc5MWMwNDM0NzhhNDE3MGRmNzhkMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T17:53:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:53:50Z"}, "message": "exp_attr.adb:\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n        \n        * exp_attr.adb: \n        (Expand_Access_To_Protected_Op): If the context indicates that an access\n        to a local operation may be transfered outside of the object, create an\n        access to the wrapper operation that must be used in an external call.\n\t(Expand_N_Attribute_Reference, case Attribute_Valid): For the AAMP\n\ttarget, pass the Valid attribute applied to a floating-point prefix on\n\tto the back end without expansion.\n\t(Storage_Size): Use the new run-time function Storage_Size to retrieve\n\tthe allocated storage when it is specified by a per-object expression.\n\t(Expand_N_Attribute_Reference): Add case for Attribute_Stub_Type.\n\tNothing to do here, the attribute has been rewritten during semantic\n\tanalysis.\n\t(Expand_Attribute_Reference): Handle expansion of the new Priority\n\tattribute\n\t(Find_Fat_Info): Handle case of universal real\n\t(Expand_Access_To_Protected_Op): Fix use of access to protected\n\tsubprogram from inside the body of a protected entry.\n\t(Expand_Access_To_Protected_Op): Common procedure for the expansion of\n\t'Access and 'Unrestricted_Access, to transform the attribute reference\n\tinto a fat pointer.\n\t(Is_Constrained_Aliased_View): New predicate to help determine whether a\n\tsubcomponent's enclosing variable is aliased with a constrained subtype.\n\t(Expand_N_Attribute_Reference, case Attribute_Constrained): For Ada_05,\n\ttest Is_Constrained_Aliased_View rather than Is_Aliased_View, because\n\tan aliased prefix must be known to be constrained in order to use True\n\tfor the attribute value, and now it's possible for some aliased views\n\tto be unconstrained.\n\nFrom-SVN: r118254", "tree": {"sha": "257317be75d9cd3386a2bc7ac15d6d6a7f398630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/257317be75d9cd3386a2bc7ac15d6d6a7f398630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ce611e210e5f350cc9791c043478a4170df78d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ce611e210e5f350cc9791c043478a4170df78d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ce611e210e5f350cc9791c043478a4170df78d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ce611e210e5f350cc9791c043478a4170df78d2/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5ee5ad288f320f565e51d9b6ce836750bd31eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ee5ad288f320f565e51d9b6ce836750bd31eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ee5ad288f320f565e51d9b6ce836750bd31eec"}], "stats": {"total": 491, "additions": 364, "deletions": 127}, "files": [{"sha": "9d2bae12e74870fb8d74e9bb796a7de7183ea5f2", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 364, "deletions": 127, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ce611e210e5f350cc9791c043478a4170df78d2/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ce611e210e5f350cc9791c043478a4170df78d2/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=7ce611e210e5f350cc9791c043478a4170df78d2", "patch": "@@ -83,6 +83,15 @@ package body Exp_Attr is\n    --  are like assignments, out of range values due to uninitialized storage,\n    --  or other invalid values do NOT cause a Constraint_Error to be raised.\n \n+   procedure Expand_Access_To_Protected_Op\n+     (N    : Node_Id;\n+      Pref : Node_Id;\n+      Typ  : Entity_Id);\n+\n+   --  An attribute reference to a protected subprogram is transformed into\n+   --  a pair of pointers: one to the object, and one to the operations.\n+   --  This expansion is performed for 'Access and for 'Unrestricted_Access.\n+\n    procedure Expand_Fpt_Attribute\n      (N    : Node_Id;\n       Pkg  : RE_Id;\n@@ -198,6 +207,141 @@ package body Exp_Attr is\n       end if;\n    end Compile_Stream_Body_In_Scope;\n \n+   -----------------------------------\n+   -- Expand_Access_To_Protected_Op --\n+   -----------------------------------\n+\n+   procedure Expand_Access_To_Protected_Op\n+     (N    : Node_Id;\n+      Pref : Node_Id;\n+      Typ  : Entity_Id)\n+   is\n+      --  The value of the attribute_reference is a record containing two\n+      --  fields: an access to the protected object, and an access to the\n+      --  subprogram itself. The prefix is a selected component.\n+\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Agg     : Node_Id;\n+      Btyp    : constant Entity_Id := Base_Type (Typ);\n+      Sub     : Entity_Id;\n+      E_T     : constant Entity_Id := Equivalent_Type (Btyp);\n+      Acc     : constant Entity_Id :=\n+                  Etype (Next_Component (First_Component (E_T)));\n+      Obj_Ref : Node_Id;\n+      Curr    : Entity_Id;\n+\n+      function May_Be_External_Call return Boolean;\n+      --  If the 'Access is to a local operation, but appears in a context\n+      --  where it may lead to a call from outside the object, we must treat\n+      --  this as an external call. Clearly we cannot tell without full\n+      --  flow analysis, and a subsequent call that uses this 'Access may\n+      --  lead to a bounded error (trying to seize locks twice, e.g.). For\n+      --  now we treat 'Access as a potential external call if it is an actual\n+      --  in a call to an outside subprogram.\n+\n+      --------------------------\n+      -- May_Be_External_Call --\n+      --------------------------\n+\n+      function May_Be_External_Call return Boolean is\n+         Subp : Entity_Id;\n+      begin\n+         if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n+              or else Nkind (Parent (N)) = N_Function_Call)\n+            and then Is_Entity_Name (Name (Parent (N)))\n+         then\n+            Subp := Entity (Name (Parent (N)));\n+            return not In_Open_Scopes (Scope (Subp));\n+         else\n+            return False;\n+         end if;\n+      end May_Be_External_Call;\n+\n+   --  Start of processing for Expand_Access_To_Protected_Op\n+\n+   begin\n+      --  Within the body of the protected type, the prefix\n+      --  designates a local operation, and the object is the first\n+      --  parameter of the corresponding protected body of the\n+      --  current enclosing operation.\n+\n+      if Is_Entity_Name (Pref) then\n+         pragma Assert (In_Open_Scopes (Scope (Entity (Pref))));\n+\n+         if May_Be_External_Call then\n+            Sub :=\n+              New_Occurrence_Of\n+                (External_Subprogram (Entity (Pref)), Loc);\n+         else\n+            Sub :=\n+              New_Occurrence_Of\n+                (Protected_Body_Subprogram (Entity (Pref)), Loc);\n+         end if;\n+\n+         Curr := Current_Scope;\n+         while Scope (Curr) /= Scope (Entity (Pref)) loop\n+            Curr := Scope (Curr);\n+         end loop;\n+\n+         --  In case of protected entries the first formal of its Protected_\n+         --  Body_Subprogram is the address of the object.\n+\n+         if Ekind (Curr) = E_Entry then\n+            Obj_Ref :=\n+               New_Occurrence_Of\n+                 (First_Formal\n+                   (Protected_Body_Subprogram (Curr)), Loc);\n+\n+         --  In case of protected subprograms the first formal of its\n+         --  Protected_Body_Subprogram is the object and we get its address.\n+\n+         else\n+            Obj_Ref :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix =>\n+                   New_Occurrence_Of\n+                     (First_Formal\n+                        (Protected_Body_Subprogram (Curr)), Loc),\n+                Attribute_Name => Name_Address);\n+         end if;\n+\n+      --  Case where the prefix is not an entity name. Find the\n+      --  version of the protected operation to be called from\n+      --  outside the protected object.\n+\n+      else\n+         Sub :=\n+           New_Occurrence_Of\n+             (External_Subprogram\n+               (Entity (Selector_Name (Pref))), Loc);\n+\n+         Obj_Ref :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix => Relocate_Node (Prefix (Pref)),\n+               Attribute_Name => Name_Address);\n+      end if;\n+\n+      Agg :=\n+        Make_Aggregate (Loc,\n+          Expressions =>\n+            New_List (\n+              Obj_Ref,\n+              Unchecked_Convert_To (Acc,\n+                Make_Attribute_Reference (Loc,\n+                  Prefix => Sub,\n+                  Attribute_Name => Name_Address))));\n+\n+      Rewrite (N, Agg);\n+\n+      Analyze_And_Resolve (N, E_T);\n+\n+      --  For subsequent analysis,  the node must retain its type.\n+      --  The backend will replace it with the equivalent type where\n+      --  needed.\n+\n+      Set_Etype (N, Typ);\n+   end Expand_Access_To_Protected_Op;\n+\n    ---------------------------\n    -- Expand_Access_To_Type --\n    ---------------------------\n@@ -522,81 +666,7 @@ package body Exp_Attr is\n       when Attribute_Access =>\n \n          if Ekind (Btyp) = E_Access_Protected_Subprogram_Type then\n-\n-            --  The value of the attribute_reference is a record containing\n-            --  two fields: an access to the protected object, and an access\n-            --  to the subprogram itself. The prefix is a selected component.\n-\n-            declare\n-               Agg     : Node_Id;\n-               Sub     : Entity_Id;\n-               E_T     : constant Entity_Id := Equivalent_Type (Btyp);\n-               Acc     : constant Entity_Id :=\n-                           Etype (Next_Component (First_Component (E_T)));\n-               Obj_Ref : Node_Id;\n-               Curr    : Entity_Id;\n-\n-            begin\n-               --  Within the body of the protected type, the prefix\n-               --  designates a local operation, and the object is the first\n-               --  parameter of the corresponding protected body of the\n-               --  current enclosing operation.\n-\n-               if Is_Entity_Name (Pref) then\n-                  pragma Assert (In_Open_Scopes (Scope (Entity (Pref))));\n-                  Sub :=\n-                    New_Occurrence_Of\n-                      (Protected_Body_Subprogram (Entity (Pref)), Loc);\n-                  Curr := Current_Scope;\n-\n-                  while Scope (Curr) /= Scope (Entity (Pref)) loop\n-                     Curr := Scope (Curr);\n-                  end loop;\n-\n-                  Obj_Ref :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                         New_Occurrence_Of\n-                           (First_Formal\n-                              (Protected_Body_Subprogram (Curr)), Loc),\n-                      Attribute_Name => Name_Address);\n-\n-               --  Case where the prefix is not an entity name. Find the\n-               --  version of the protected operation to be called from\n-               --  outside the protected object.\n-\n-               else\n-                  Sub :=\n-                    New_Occurrence_Of\n-                      (External_Subprogram\n-                        (Entity (Selector_Name (Pref))), Loc);\n-\n-                  Obj_Ref :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix => Relocate_Node (Prefix (Pref)),\n-                        Attribute_Name => Name_Address);\n-               end if;\n-\n-               Agg :=\n-                 Make_Aggregate (Loc,\n-                   Expressions =>\n-                     New_List (\n-                       Obj_Ref,\n-                       Unchecked_Convert_To (Acc,\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix => Sub,\n-                           Attribute_Name => Name_Address))));\n-\n-               Rewrite (N, Agg);\n-\n-               Analyze_And_Resolve (N, E_T);\n-\n-               --  For subsequent analysis,  the node must retain its type.\n-               --  The backend will replace it with the equivalent type where\n-               --  needed.\n-\n-               Set_Etype (N, Typ);\n-            end;\n+            Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n          elsif Ekind (Btyp) = E_General_Access_Type then\n             declare\n@@ -903,7 +973,7 @@ package body Exp_Attr is\n       --  the unsigned constant created in the main program by the binder.\n \n       --  A special exception occurs for Standard, where the string\n-      --  returned is a copy of the library  string in gnatvsn.ads.\n+      --  returned is a copy of the library string in gnatvsn.ads.\n \n       when Attribute_Body_Version | Attribute_Version => Version : declare\n          E    : constant Entity_Id :=\n@@ -1144,6 +1214,41 @@ package body Exp_Attr is\n          Formal_Ent : constant Entity_Id := Param_Entity (Pref);\n          Typ        : constant Entity_Id := Etype (Pref);\n \n+         function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean;\n+         --  Ada 2005 (AI-363): Returns True if the object name Obj denotes a\n+         --  view of an aliased object whose subtype is constrained.\n+\n+         ---------------------------------\n+         -- Is_Constrained_Aliased_View --\n+         ---------------------------------\n+\n+         function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean is\n+            E : Entity_Id;\n+\n+         begin\n+            if Is_Entity_Name (Obj) then\n+               E := Entity (Obj);\n+\n+               if Present (Renamed_Object (E)) then\n+                  return Is_Constrained_Aliased_View (Renamed_Object (E));\n+\n+               else\n+                  return Is_Aliased (E) and then Is_Constrained (Etype (E));\n+               end if;\n+\n+            else\n+               return Is_Aliased_View (Obj)\n+                        and then\n+                      (Is_Constrained (Etype (Obj))\n+                         or else (Nkind (Obj) = N_Explicit_Dereference\n+                                    and then\n+                                      not Has_Constrained_Partial_View\n+                                            (Base_Type (Etype (Obj)))));\n+            end if;\n+         end Is_Constrained_Aliased_View;\n+\n+      --  Start of processing for Constrained\n+\n       begin\n          --  Reference to a parameter where the value is passed as an extra\n          --  actual, corresponding to the extra formal referenced by the\n@@ -1205,9 +1310,15 @@ package body Exp_Attr is\n                --  definitely true; if it's a formal parameter without\n                --  an associated extra formal, then treat it as constrained.\n \n+               --  Ada 2005 (AI-363): An aliased prefix must be known to be\n+               --  constrained in order to set the attribute to True.\n+\n                elsif not Is_Variable (Pref)\n                  or else Present (Formal_Ent)\n-                 or else Is_Aliased_View (Pref)\n+                 or else (Ada_Version < Ada_05\n+                            and then Is_Aliased_View (Pref))\n+                 or else (Ada_Version >= Ada_05\n+                            and then Is_Constrained_Aliased_View (Pref))\n                then\n                   Res := True;\n \n@@ -1376,10 +1487,15 @@ package body Exp_Attr is\n             --  image into the current string literal, with double underline\n             --  between components.\n \n+            ----------------------\n+            -- Make_Elab_String --\n+            ----------------------\n+\n             procedure Make_Elab_String (Nod : Node_Id) is\n             begin\n                if Nkind (Nod) = N_Selected_Component then\n                   Make_Elab_String (Prefix (Nod));\n+\n                   if Java_VM then\n                      Store_String_Char ('$');\n                   else\n@@ -2871,6 +2987,77 @@ package body Exp_Attr is\n          end if;\n       end Pred;\n \n+      --------------\n+      -- Priority --\n+      --------------\n+\n+      --  Ada 2005 (AI-327): Dynamic ceiling priorities\n+\n+      --  We rewrite X'Priority as the following run-time call:\n+\n+      --     Get_Ceiling (X._Object)\n+\n+      --  Note that although X'Priority is notionally an object, it is quite\n+      --  deliberately not defined as an aliased object in the RM. This means\n+      --  that it works fine to rewrite it as a call, without having to worry\n+      --  about complications that would other arise from X'Priority'Access,\n+      --  which is illegal, because of the lack of aliasing.\n+\n+      when Attribute_Priority =>\n+         declare\n+            Call           : Node_Id;\n+            Conctyp        : Entity_Id;\n+            Object_Parm    : Node_Id;\n+            Subprg         : Entity_Id;\n+            RT_Subprg_Name : Node_Id;\n+\n+         begin\n+            --  Look for the enclosing concurrent type\n+\n+            Conctyp := Current_Scope;\n+            while not Is_Concurrent_Type (Conctyp) loop\n+               Conctyp := Scope (Conctyp);\n+            end loop;\n+\n+            pragma Assert (Is_Protected_Type (Conctyp));\n+\n+            --  Generate the actual of the call\n+\n+            Subprg := Current_Scope;\n+            while not Present (Protected_Body_Subprogram (Subprg)) loop\n+               Subprg := Scope (Subprg);\n+            end loop;\n+\n+            Object_Parm :=\n+              Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   Make_Selected_Component (Loc,\n+                     Prefix => New_Reference_To\n+                                 (First_Entity\n+                                   (Protected_Body_Subprogram (Subprg)), Loc),\n+                   Selector_Name =>\n+                       Make_Identifier (Loc, Name_uObject)),\n+                 Attribute_Name => Name_Unchecked_Access);\n+\n+            --  Select the appropriate run-time subprogram\n+\n+            if Number_Entries (Conctyp) = 0 then\n+               RT_Subprg_Name :=\n+                 New_Reference_To (RTE (RE_Get_Ceiling), Loc);\n+            else\n+               RT_Subprg_Name :=\n+                 New_Reference_To (RTE (RO_PE_Get_Ceiling), Loc);\n+            end if;\n+\n+            Call :=\n+              Make_Function_Call (Loc,\n+                Name => RT_Subprg_Name,\n+                Parameter_Associations => New_List (Object_Parm));\n+\n+            Rewrite (N, Call);\n+            Analyze_And_Resolve (N, Typ);\n+         end;\n+\n       ------------------\n       -- Range_Length --\n       ------------------\n@@ -3407,79 +3594,100 @@ package body Exp_Attr is\n                    Make_Function_Call (Loc,\n                      Name =>\n                        New_Reference_To\n-                        (Find_Prim_Op\n-                          (Etype (Associated_Storage_Pool (Root_Type (Ptyp))),\n-                           Attribute_Name (N)),\n-                         Loc),\n+                         (Find_Prim_Op\n+                           (Etype (Associated_Storage_Pool (Root_Type (Ptyp))),\n+                            Attribute_Name (N)),\n+                          Loc),\n+\n+                     Parameter_Associations => New_List (\n+                       New_Reference_To\n+                         (Associated_Storage_Pool (Root_Type (Ptyp)), Loc)))));\n \n-                     Parameter_Associations => New_List (New_Reference_To (\n-                       Associated_Storage_Pool (Root_Type (Ptyp)), Loc)))));\n             else\n                Rewrite (N, Make_Integer_Literal (Loc, 0));\n             end if;\n \n             Analyze_And_Resolve (N, Typ);\n \n-         --  The case of a task type (an obsolescent feature) is handled the\n-         --  same way, seems as reasonable as anything, and it is what the\n-         --  ACVC tests (e.g. CD1009K) seem to expect.\n+         --  For tasks, we retrieve the size directly from the TCB. The\n+         --  size may depend on a discriminant of the type, and therefore\n+         --  can be a per-object expression, so type-level information is\n+         --  not sufficient in general. There are four cases to consider:\n \n-         --  If there is no Storage_Size variable, then we return the default\n-         --  task stack size, otherwise, expand a Storage_Size attribute as\n-         --  follows:\n+         --  a) If the attribute appears within a task body, the designated\n+         --    TCB is obtained by a call to Self.\n \n-         --  Typ (Adjust_Storage_Size (taskZ))\n+         --  b) If the prefix of the attribute is the name of a task object,\n+         --  the designated TCB is the one stored in the corresponding record.\n \n-         --  except for the case of a task object which has a Storage_Size\n-         --  pragma:\n+         --  c) If the prefix is a task type, the size is obtained from the\n+         --  size variable created for each task type\n \n-         --  Typ (Adjust_Storage_Size (taskV!(name)._Size))\n+         --  d) If no storage_size was specified for the type , there is no\n+         --  size variable, and the value is a system-specific default.\n \n          else\n-            if No (Storage_Size_Variable (Ptyp)) then\n+            if In_Open_Scopes (Ptyp) then\n+\n+               --  Storage_Size (Self)\n+\n                Rewrite (N,\n                  Convert_To (Typ,\n                    Make_Function_Call (Loc,\n                      Name =>\n-                       New_Occurrence_Of (RTE (RE_Default_Stack_Size), Loc))));\n+                       New_Occurrence_Of (RTE (RE_Storage_Size), Loc),\n+                     Parameter_Associations =>\n+                       New_List (\n+                         Make_Function_Call (Loc,\n+                           Name =>\n+                             New_Reference_To (RTE (RE_Self), Loc))))));\n \n-            else\n-               if not (Is_Entity_Name (Pref) and then\n-                 Is_Task_Type (Entity (Pref))) and then\n-                   Chars (Last_Entity (Corresponding_Record_Type (Ptyp))) =\n-                     Name_uSize\n-               then\n-                  Rewrite (N,\n-                    Convert_To (Typ,\n-                      Make_Function_Call (Loc,\n-                        Name => New_Occurrence_Of (\n-                          RTE (RE_Adjust_Storage_Size), Loc),\n-                        Parameter_Associations =>\n+            elsif not Is_Entity_Name (Pref)\n+              or else not Is_Type (Entity (Pref))\n+            then\n+               --  Storage_Size (Rec (Obj).Size)\n+\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Occurrence_Of (RTE (RE_Storage_Size), Loc),\n+                       Parameter_Associations =>\n                           New_List (\n                             Make_Selected_Component (Loc,\n                               Prefix =>\n                                 Unchecked_Convert_To (\n                                   Corresponding_Record_Type (Ptyp),\n-                                  New_Copy_Tree (Pref)),\n+                                    New_Copy_Tree (Pref)),\n                               Selector_Name =>\n-                                Make_Identifier (Loc, Name_uSize))))));\n+                                 Make_Identifier (Loc, Name_uTask_Id))))));\n \n-               --  Task not having Storage_Size pragma\n+            elsif Present (Storage_Size_Variable (Ptyp)) then\n \n-               else\n-                  Rewrite (N,\n-                    Convert_To (Typ,\n-                      Make_Function_Call (Loc,\n-                        Name => New_Occurrence_Of (\n-                          RTE (RE_Adjust_Storage_Size), Loc),\n-                        Parameter_Associations =>\n-                          New_List (\n-                            New_Reference_To (\n-                              Storage_Size_Variable (Ptyp), Loc)))));\n-               end if;\n+               --  Static storage size pragma given for type: retrieve value\n+               --  from its allocated storage variable.\n \n-               Analyze_And_Resolve (N, Typ);\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                   Make_Function_Call (Loc,\n+                     Name => New_Occurrence_Of (\n+                       RTE (RE_Adjust_Storage_Size), Loc),\n+                     Parameter_Associations =>\n+                       New_List (\n+                         New_Reference_To (\n+                           Storage_Size_Variable (Ptyp), Loc)))));\n+            else\n+               --  Get system default\n+\n+               Rewrite (N,\n+                 Convert_To (Typ,\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Occurrence_Of (\n+                        RTE (RE_Default_Stack_Size), Loc))));\n             end if;\n+\n+            Analyze_And_Resolve (N, Typ);\n          end if;\n       end Storage_Size;\n \n@@ -3496,8 +3704,9 @@ package body Exp_Attr is\n          --  the Stream_Size if the size of the type.\n \n          if Has_Stream_Size_Clause (Ptyp) then\n-            Size := UI_To_Int\n-              (Static_Integer (Expression (Stream_Size_Clause (Ptyp))));\n+            Size :=\n+              UI_To_Int\n+                (Static_Integer (Expression (Stream_Size_Clause (Ptyp))));\n          else\n             Size := UI_To_Int (Esize (Ptyp));\n          end if;\n@@ -3790,11 +3999,14 @@ package body Exp_Attr is\n \n       when Attribute_Unrestricted_Access =>\n \n+         if Ekind (Btyp) = E_Access_Protected_Subprogram_Type then\n+            Expand_Access_To_Protected_Op (N, Pref, Typ);\n+\n          --  Ada 2005 (AI-251): If the designated type is an interface, then\n          --  rewrite the referenced object as a conversion to force the\n          --  displacement of the pointer to the secondary dispatch table.\n \n-         if Is_Interface (Directly_Designated_Type (Btyp)) then\n+         elsif Is_Interface (Directly_Designated_Type (Btyp)) then\n             declare\n                Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n                Conversion : Node_Id;\n@@ -3956,6 +4168,13 @@ package body Exp_Attr is\n                if Vax_Float (Btyp) then\n                   Expand_Vax_Valid (N);\n \n+               --  The AAMP back end handles Valid for floating-point types\n+\n+               elsif Is_AAMP_Float (Btyp) then\n+                  Analyze_And_Resolve (Pref, Ptyp);\n+                  Set_Etype (N, Standard_Boolean);\n+                  Set_Analyzed (N);\n+\n                --  Non VAX float case\n \n                else\n@@ -4262,8 +4481,13 @@ package body Exp_Attr is\n       --  semantics of Wide_Value in all cases, and results in a very simple\n       --  implementation approach.\n \n-      --  It's not quite right where typ = Wide_Character, because the encoding\n-      --  method may not cover the whole character type ???\n+      --  Note: for this approach to be fully standard compliant for the cases\n+      --  where typ is Wide_Character and Wide_Wide_Character, the encoding\n+      --  method must cover the entire character range (e.g. UTF-8). But that\n+      --  is a reasonable requirement when dealing with encoded character\n+      --  sequences. Presumably if one of the restrictive encoding mechanisms\n+      --  is in use such as Shift-JIS, then characters that cannot be\n+      --  represented using this encoding will not appear in any case.\n \n       when Attribute_Wide_Value => Wide_Value :\n       begin\n@@ -4555,6 +4779,7 @@ package body Exp_Attr is\n            Attribute_Signed_Zeros                 |\n            Attribute_Small                        |\n            Attribute_Storage_Unit                 |\n+           Attribute_Stub_Type                    |\n            Attribute_Target_Name                  |\n            Attribute_Type_Class                   |\n            Attribute_Unconstrained_Array          |\n@@ -4680,12 +4905,24 @@ package body Exp_Attr is\n \n          if Fat_Type = Standard_Short_Float then\n             Fat_Pkg := RE_Attr_Short_Float;\n+\n          elsif Fat_Type = Standard_Float then\n             Fat_Pkg := RE_Attr_Float;\n+\n          elsif Fat_Type = Standard_Long_Float then\n             Fat_Pkg := RE_Attr_Long_Float;\n+\n          elsif Fat_Type = Standard_Long_Long_Float then\n             Fat_Pkg := RE_Attr_Long_Long_Float;\n+\n+         --  Universal real (which is its own root type) is treated as being\n+         --  equivalent to Standard.Long_Long_Float, since it is defined to\n+         --  have the same precision as the longest Float type.\n+\n+         elsif Fat_Type = Universal_Real then\n+            Fat_Type := Standard_Long_Long_Float;\n+            Fat_Pkg := RE_Attr_Long_Long_Float;\n+\n          else\n             raise Program_Error;\n          end if;"}]}