{"sha": "1612b1febdd5b6b6ad17c96c980a218bfd40c025", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYxMmIxZmViZGQ1YjZiNmFkMTdjOTZjOTgwYTIxOGJmZDQwYzAyNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-06-21T06:48:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-06-21T06:48:57Z"}, "message": "omp-low.c (lower_rec_simd_input_clauses): Add rvar2 argument...\n\n\t* omp-low.c (lower_rec_simd_input_clauses): Add rvar2 argument,\n\tcreate another \"omp scan inscan exclusive\" array if\n\t!ctx->scan_inclusive.\n\t(lower_rec_input_clauses): Handle exclusive scan inscan reductions.\n\t(lower_omp_scan): Likewise.\n\t* tree-vectorizer.h (struct _stmt_vec_info): Use 3-bit instead of\n\t2-bit bitfield for simd_lane_access_p member.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Also handle\n\taux == (void *)-4 as simd lane access.\n\t* tree-vect-stmts.c (check_scan_store): Handle exclusive scan.  Update\n\tcomment with permutations to show the canonical permutation order.\n\t(vectorizable_scan_store): Handle exclusive scan.\n\t(vectorizable_store): Call vectorizable_scan_store even for\n\tSTMT_VINFO_SIMD_LANE_ACCESS_P > 3.\n\n\t* gcc.dg/vect/vect-simd-12.c: New test.\n\t* gcc.dg/vect/vect-simd-13.c: New test.\n\t* gcc.dg/vect/vect-simd-14.c: New test.\n\t* gcc.dg/vect/vect-simd-15.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-12.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-13.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-14.c: New test.\n\t* gcc.target/i386/sse2-vect-simd-15.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-12.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-13.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-14.c: New test.\n\t* gcc.target/i386/avx2-vect-simd-15.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-12.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-13.c: New test.\n\t* gcc.target/i386/avx512f-vect-simd-14.c: New test.\n\t* gcc.target/i386/avx512bw-vect-simd-15.c: New test.\n\t* g++.dg/vect/simd-6.cc: New test.\n\t* g++.dg/vect/simd-7.cc: New test.\n\t* g++.dg/vect/simd-8.cc: New test.\n\t* g++.dg/vect/simd-9.cc: New test.\n\t* c-c++-common/gomp/scan-2.c: Don't expect any diagnostics.\n\nFrom-SVN: r272544", "tree": {"sha": "e99a70a4f060da6af668cd4690a60f7cf5f610ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e99a70a4f060da6af668cd4690a60f7cf5f610ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1612b1febdd5b6b6ad17c96c980a218bfd40c025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1612b1febdd5b6b6ad17c96c980a218bfd40c025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1612b1febdd5b6b6ad17c96c980a218bfd40c025", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1612b1febdd5b6b6ad17c96c980a218bfd40c025/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e73fb06d5a1386fe0a18285d52bcc7865a13a84c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73fb06d5a1386fe0a18285d52bcc7865a13a84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73fb06d5a1386fe0a18285d52bcc7865a13a84c"}], "stats": {"total": 1820, "additions": 1757, "deletions": 63}, "files": [{"sha": "3a6b86bd26617c8eecfd8c21c98752b1d817470b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -1,5 +1,20 @@\n 2019-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* omp-low.c (lower_rec_simd_input_clauses): Add rvar2 argument,\n+\tcreate another \"omp scan inscan exclusive\" array if\n+\t!ctx->scan_inclusive.\n+\t(lower_rec_input_clauses): Handle exclusive scan inscan reductions.\n+\t(lower_omp_scan): Likewise.\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Use 3-bit instead of\n+\t2-bit bitfield for simd_lane_access_p member.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Also handle\n+\taux == (void *)-4 as simd lane access.\n+\t* tree-vect-stmts.c (check_scan_store): Handle exclusive scan.  Update\n+\tcomment with permutations to show the canonical permutation order.\n+\t(vectorizable_scan_store): Handle exclusive scan.\n+\t(vectorizable_store): Call vectorizable_scan_store even for\n+\tSTMT_VINFO_SIMD_LANE_ACCESS_P > 3.\n+\n \t* tree-vect-data-refs.c (vect_find_stmt_data_reference): Handle\n \t\"omp simd array\" arrays with one byte elements.\n "}, {"sha": "6b1e6a8a624f746c507d0aedee8314da81e924e1", "filename": "gcc/omp-low.c", "status": "modified", "additions": 182, "deletions": 18, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -3692,7 +3692,8 @@ struct omplow_simd_context {\n static bool\n lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t\t\t      omplow_simd_context *sctx, tree &ivar,\n-\t\t\t      tree &lvar, tree *rvar = NULL)\n+\t\t\t      tree &lvar, tree *rvar = NULL,\n+\t\t\t      tree *rvar2 = NULL)\n {\n   if (known_eq (sctx->max_vf, 0U))\n     {\n@@ -3767,6 +3768,25 @@ lower_rec_simd_input_clauses (tree new_var, omp_context *ctx,\n \t  *rvar = build4 (ARRAY_REF, TREE_TYPE (new_var), iavar,\n \t\t\t  sctx->lastlane, NULL_TREE, NULL_TREE);\n \t  TREE_THIS_NOTRAP (*rvar) = 1;\n+\n+\t  if (!ctx->scan_inclusive)\n+\t    {\n+\t      /* And for exclusive scan yet another one, which will\n+\t\t hold the value during the scan phase.  */\n+\t      tree savar = create_tmp_var_raw (atype);\n+\t      if (TREE_ADDRESSABLE (new_var))\n+\t\tTREE_ADDRESSABLE (savar) = 1;\n+\t      DECL_ATTRIBUTES (savar)\n+\t\t= tree_cons (get_identifier (\"omp simd array\"), NULL,\n+\t\t\t     tree_cons (get_identifier (\"omp simd inscan \"\n+\t\t\t\t\t\t\t\"exclusive\"), NULL,\n+\t\t\t\t\tDECL_ATTRIBUTES (savar)));\n+\t      gimple_add_tmp_var (savar);\n+\t      ctx->cb.decl_map->put (iavar, savar);\n+\t      *rvar2 = build4 (ARRAY_REF, TREE_TYPE (new_var), savar,\n+\t\t\t       sctx->idx, NULL_TREE, NULL_TREE);\n+\t      TREE_THIS_NOTRAP (*rvar2) = 1;\n+\t    }\n \t}\n       ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), iavar, sctx->idx,\n \t\t     NULL_TREE, NULL_TREE);\n@@ -5185,14 +5205,15 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      new_vard = TREE_OPERAND (new_var, 0);\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n-\t\t  tree rvar = NULL_TREE, *rvarp = NULL;\n+\t\t  tree rvar = NULL_TREE, *rvarp = NULL, rvar2 = NULL_TREE;\n \t\t  if (is_simd\n \t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t\t    rvarp = &rvar;\n \t\t  if (is_simd\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n-\t\t\t\t\t\t       ivar, lvar, rvarp))\n+\t\t\t\t\t\t       ivar, lvar, rvarp,\n+\t\t\t\t\t\t       &rvar2))\n \t\t    {\n \t\t      if (new_vard == new_var)\n \t\t\t{\n@@ -5220,6 +5241,14 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t    (c, ivar2, build_outer_var_ref (var, ctx));\n \t\t\t      gimplify_and_add (x, &llist[0]);\n \n+\t\t\t      if (rvar2)\n+\t\t\t\t{\n+\t\t\t\t  x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t\t(c, unshare_expr (rvar2),\n+\t\t\t\t\t build_outer_var_ref (var, ctx));\n+\t\t\t\t  gimplify_and_add (x, &llist[0]);\n+\t\t\t\t}\n+\n \t\t\t      /* For types that need construction, add another\n \t\t\t\t private var which will be default constructed\n \t\t\t\t and optionally initialized with\n@@ -5229,7 +5258,9 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t\t iteration.  */\n \t\t\t      tree nv = create_tmp_var_raw (TREE_TYPE (ivar));\n \t\t\t      gimple_add_tmp_var (nv);\n-\t\t\t      ctx->cb.decl_map->put (TREE_OPERAND (ivar, 0),\n+\t\t\t      ctx->cb.decl_map->put (TREE_OPERAND (rvar2\n+\t\t\t\t\t\t\t\t   ? rvar2\n+\t\t\t\t\t\t\t\t   : ivar, 0),\n \t\t\t\t\t\t     nv);\n \t\t\t      x = lang_hooks.decls.omp_clause_default_ctor\n \t\t\t\t    (c, nv, build_outer_var_ref (var, ctx));\n@@ -5296,6 +5327,18 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      gimplify_stmt (&dtor, &tseq);\n \t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n \t\t\t    }\n+\n+\t\t\t  if (rvar2)\n+\t\t\t    {\n+\t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, rvar2);\n+\t\t\t      if (x)\n+\t\t\t\t{\n+\t\t\t\t  tseq = NULL;\n+\t\t\t\t  dtor = x;\n+\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n+\t\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t\t}\n+\t\t\t    }\n \t\t\t  break;\n \t\t\t}\n \t\t      if (x)\n@@ -5390,6 +5433,24 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      gimple_seq_add_seq (ilist, tseq);\n \t\t\t    }\n \t\t\t  OMP_CLAUSE_REDUCTION_GIMPLE_INIT (c) = NULL;\n+\t\t\t  if (!ctx->scan_inclusive)\n+\t\t\t    {\n+\t\t\t      tree nv2\n+\t\t\t\t= create_tmp_var_raw (TREE_TYPE (new_var));\n+\t\t\t      gimple_add_tmp_var (nv2);\n+\t\t\t      ctx->cb.decl_map->put (nv, nv2);\n+\t\t\t      x = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t    (c, nv2, build_outer_var_ref (var, ctx));\n+\t\t\t      gimplify_and_add (x, ilist);\n+\t\t\t      x = lang_hooks.decls.omp_clause_dtor (c, nv2);\n+\t\t\t      if (x)\n+\t\t\t\t{\n+\t\t\t\t  tseq = NULL;\n+\t\t\t\t  dtor = x;\n+\t\t\t\t  gimplify_stmt (&dtor, &tseq);\n+\t\t\t\t  gimple_seq_add_seq (dlist, tseq);\n+\t\t\t\t}\n+\t\t\t    }\n \t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, nv);\n \t\t\t  if (x)\n \t\t\t    {\n@@ -5399,6 +5460,21 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t      gimple_seq_add_seq (dlist, tseq);\n \t\t\t    }\n \t\t\t}\n+\t\t      else if (!ctx->scan_inclusive\n+\t\t\t       && TREE_ADDRESSABLE (TREE_TYPE (new_var)))\n+\t\t\t{\n+\t\t\t  tree nv2 = create_tmp_var_raw (TREE_TYPE (new_var));\n+\t\t\t  gimple_add_tmp_var (nv2);\n+\t\t\t  ctx->cb.decl_map->put (new_vard, nv2);\n+\t\t\t  x = lang_hooks.decls.omp_clause_dtor (c, nv2);\n+\t\t\t  if (x)\n+\t\t\t    {\n+\t\t\t      tseq = NULL;\n+\t\t\t      dtor = x;\n+\t\t\t      gimplify_stmt (&dtor, &tseq);\n+\t\t\t      gimple_seq_add_seq (dlist, tseq);\n+\t\t\t    }\n+\t\t\t}\n \t\t      DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n \t\t      goto do_dtor;\n \t\t    }\n@@ -5487,14 +5563,15 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      new_vard = TREE_OPERAND (new_var, 0);\n \t\t      gcc_assert (DECL_P (new_vard));\n \t\t    }\n-\t\t  tree rvar = NULL_TREE, *rvarp = NULL;\n+\t\t  tree rvar = NULL_TREE, *rvarp = NULL, rvar2 = NULL_TREE;\n \t\t  if (is_simd\n \t\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      && OMP_CLAUSE_REDUCTION_INSCAN (c))\n \t\t    rvarp = &rvar;\n \t\t  if (is_simd\n \t\t      && lower_rec_simd_input_clauses (new_var, ctx, &sctx,\n-\t\t\t\t\t\t       ivar, lvar, rvarp))\n+\t\t\t\t\t\t       ivar, lvar, rvarp,\n+\t\t\t\t\t\t       &rvar2))\n \t\t    {\n \t\t      if (new_vard != new_var)\n \t\t\t{\n@@ -8573,18 +8650,40 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gimple_seq before = NULL;\n   omp_context *octx = ctx->outer;\n   gcc_assert (octx);\n+  if (!octx->scan_inclusive && !has_clauses)\n+    {\n+      gimple_stmt_iterator gsi2 = *gsi_p;\n+      gsi_next (&gsi2);\n+      gimple *stmt2 = gsi_stmt (gsi2);\n+      /* For exclusive scan, swap GIMPLE_OMP_SCAN without clauses\n+\t with following GIMPLE_OMP_SCAN with clauses, so that input_phase,\n+\t the one with exclusive clause(s), comes first.  */\n+      if (stmt2\n+\t  && gimple_code (stmt2) == GIMPLE_OMP_SCAN\n+\t  && gimple_omp_scan_clauses (as_a <gomp_scan *> (stmt2)) != NULL)\n+\t{\n+\t  gsi_remove (gsi_p, false);\n+\t  gsi_insert_after (gsi_p, stmt, GSI_SAME_STMT);\n+\t  ctx = maybe_lookup_ctx (stmt2);\n+\t  gcc_assert (ctx);\n+\t  lower_omp_scan (gsi_p, ctx);\n+\t  return;\n+\t}\n+    }\n+\n   bool input_phase = has_clauses ^ octx->scan_inclusive;\n   if (gimple_code (octx->stmt) == GIMPLE_OMP_FOR\n       && (gimple_omp_for_kind (octx->stmt) & GF_OMP_FOR_SIMD)\n-      && !gimple_omp_for_combined_into_p (octx->stmt)\n-      && octx->scan_inclusive)\n+      && !gimple_omp_for_combined_into_p (octx->stmt))\n     {\n       if (tree c = omp_find_clause (gimple_omp_for_clauses (octx->stmt),\n \t\t\t\t    OMP_CLAUSE__SIMDUID_))\n \t{\n \t  tree uid = OMP_CLAUSE__SIMDUID__DECL (c);\n \t  lane = create_tmp_var (unsigned_type_node);\n-\t  tree t = build_int_cst (integer_type_node, 1 + !input_phase);\n+\t  tree t = build_int_cst (integer_type_node,\n+\t\t\t\t  input_phase ? 1\n+\t\t\t\t  : octx->scan_inclusive ? 2 : 3);\n \t  gimple *g\n \t    = gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 2, uid, t);\n \t  gimple_call_set_lhs (g, lane);\n@@ -8601,6 +8700,8 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    tree val = new_var;\n \t    tree var2 = NULL_TREE;\n \t    tree var3 = NULL_TREE;\n+\t    tree var4 = NULL_TREE;\n+\t    tree lane0 = NULL_TREE;\n \t    tree new_vard = new_var;\n \t    if (omp_is_reference (var))\n \t      {\n@@ -8623,16 +8724,26 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t\t  DECL_ATTRIBUTES (v)))\n \t\t      {\n \t\t\tval = unshare_expr (val);\n+\t\t\tlane0 = TREE_OPERAND (val, 1);\n \t\t\tTREE_OPERAND (val, 1) = lane;\n \t\t\tvar2 = lookup_decl (v, octx);\n+\t\t\tif (!octx->scan_inclusive)\n+\t\t\t  var4 = lookup_decl (var2, octx);\n \t\t\tif (input_phase\n \t\t\t    && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n-\t\t\t  var3 = maybe_lookup_decl (var2, octx);\n+\t\t\t  var3 = maybe_lookup_decl (var4 ? var4 : var2, octx);\n \t\t\tif (!input_phase)\n \t\t\t  {\n \t\t\t    var2 = build4 (ARRAY_REF, TREE_TYPE (val),\n \t\t\t\t\t   var2, lane, NULL_TREE, NULL_TREE);\n \t\t\t    TREE_THIS_NOTRAP (var2) = 1;\n+\t\t\t    if (!octx->scan_inclusive)\n+\t\t\t      {\n+\t\t\t\tvar4 = build4 (ARRAY_REF, TREE_TYPE (val),\n+\t\t\t\t\t       var4, lane, NULL_TREE,\n+\t\t\t\t\t       NULL_TREE);\n+\t\t\t\tTREE_THIS_NOTRAP (var4) = 1;\n+\t\t\t      }\n \t\t\t  }\n \t\t\telse\n \t\t\t  var2 = val;\n@@ -8643,12 +8754,28 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    else\n \t      {\n \t\tvar2 = build_outer_var_ref (var, octx);\n-\t\tif (input_phase && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t\tif (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t\t  {\n \t\t    var3 = maybe_lookup_decl (new_vard, octx);\n-\t\t    if (var3 == new_vard)\n+\t\t    if (var3 == new_vard || var3 == NULL_TREE)\n \t\t      var3 = NULL_TREE;\n+\t\t    else if (!octx->scan_inclusive && !input_phase)\n+\t\t      {\n+\t\t\tvar4 = maybe_lookup_decl (var3, octx);\n+\t\t\tif (var4 == var3 || var4 == NULL_TREE)\n+\t\t\t  {\n+\t\t\t    if (TREE_ADDRESSABLE (TREE_TYPE (new_var)))\n+\t\t\t      {\n+\t\t\t\tvar4 = var3;\n+\t\t\t\tvar3 = NULL_TREE;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      var4 = NULL_TREE;\n+\t\t\t  }\n+\t\t      }\n \t\t  }\n+\t\tif (!octx->scan_inclusive && !input_phase && var4 == NULL_TREE)\n+\t\t  var4 = create_tmp_var (TREE_TYPE (val));\n \t      }\n \t    if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t      {\n@@ -8689,9 +8816,17 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  }\n \t\telse\n \t\t  {\n+\t\t    tree x;\n+\t\t    if (!octx->scan_inclusive)\n+\t\t      {\n+\t\t\ttree v4 = unshare_expr (var4);\n+\t\t\ttree v2 = unshare_expr (var2);\n+\t\t\tx = lang_hooks.decls.omp_clause_assign_op (c, v4, v2);\n+\t\t\tgimplify_and_add (x, &before);\n+\t\t      }\n \t\t    gimple_seq tseq = OMP_CLAUSE_REDUCTION_GIMPLE_MERGE (c);\n-\t\t    tree x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n-\t\t\t      ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n+\t\t    x = (DECL_HAS_VALUE_EXPR_P (new_vard)\n+\t\t\t ? DECL_VALUE_EXPR (new_vard) : NULL_TREE);\n \t\t    tree vexpr = val;\n \t\t    if (x && omp_is_reference (var))\n \t\t      vexpr = build_fold_addr_expr_loc (clause_loc, val);\n@@ -8706,8 +8841,18 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t      SET_DECL_VALUE_EXPR (new_vard, x);\n \t\t    SET_DECL_VALUE_EXPR (placeholder, NULL_TREE);\n \t\t    DECL_HAS_VALUE_EXPR_P (placeholder) = 0;\n-\t\t    x = lang_hooks.decls.omp_clause_assign_op (c, val, var2);\n-\t\t    gimplify_and_add (x, &before);\n+\t\t    if (octx->scan_inclusive)\n+\t\t      {\n+\t\t\tx = lang_hooks.decls.omp_clause_assign_op (c, val,\n+\t\t\t\t\t\t\t\t   var2);\n+\t\t\tgimplify_and_add (x, &before);\n+\t\t      }\n+\t\t    else if (lane0 == NULL_TREE)\n+\t\t      {\n+\t\t\tx = lang_hooks.decls.omp_clause_assign_op (c, val,\n+\t\t\t\t\t\t\t\t   var4);\n+\t\t\tgimplify_and_add (x, &before);\n+\t\t      }\n \t\t  }\n \t      }\n \t    else\n@@ -8728,10 +8873,29 @@ lower_omp_scan (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n \t\t    tree x = build2 (code, TREE_TYPE (var2),\n \t\t\t\t     unshare_expr (var2), unshare_expr (val));\n-\t\t    gimplify_assign (unshare_expr (var2), x, &before);\n-\t\t    gimplify_assign (val, var2, &before);\n+\t\t    if (octx->scan_inclusive)\n+\t\t      {\n+\t\t\tgimplify_assign (unshare_expr (var2), x, &before);\n+\t\t\tgimplify_assign (val, var2, &before);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tgimplify_assign (unshare_expr (var4),\n+\t\t\t\t\t unshare_expr (var2), &before);\n+\t\t\tgimplify_assign (var2, x, &before);\n+\t\t\tif (lane0 == NULL_TREE)\n+\t\t\t  gimplify_assign (val, var4, &before);\n+\t\t      }\n \t\t  }\n \t      }\n+\t    if (!octx->scan_inclusive && !input_phase && lane0)\n+\t      {\n+\t\ttree vexpr = unshare_expr (var4);\n+\t\tTREE_OPERAND (vexpr, 1) = lane0;\n+\t\tif (omp_is_reference (var))\n+\t\t  vexpr = build_fold_addr_expr_loc (clause_loc, vexpr);\n+\t\tSET_DECL_VALUE_EXPR (new_vard, vexpr);\n+\t      }\n \t  }\n     }\n   else if (has_clauses)"}, {"sha": "c5bb4508539a8ecc307bda1a3e039ab251eb5fb2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -1,5 +1,27 @@\n 2019-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/vect/vect-simd-12.c: New test.\n+\t* gcc.dg/vect/vect-simd-13.c: New test.\n+\t* gcc.dg/vect/vect-simd-14.c: New test.\n+\t* gcc.dg/vect/vect-simd-15.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-12.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-13.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-14.c: New test.\n+\t* gcc.target/i386/sse2-vect-simd-15.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-12.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-13.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-14.c: New test.\n+\t* gcc.target/i386/avx2-vect-simd-15.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-12.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-13.c: New test.\n+\t* gcc.target/i386/avx512f-vect-simd-14.c: New test.\n+\t* gcc.target/i386/avx512bw-vect-simd-15.c: New test.\n+\t* g++.dg/vect/simd-6.cc: New test.\n+\t* g++.dg/vect/simd-7.cc: New test.\n+\t* g++.dg/vect/simd-8.cc: New test.\n+\t* g++.dg/vect/simd-9.cc: New test.\n+\t* c-c++-common/gomp/scan-2.c: Don't expect any diagnostics.\n+\n \tPR c++/90950\n \t* g++.dg/gomp/lastprivate-1.C: New test.\n "}, {"sha": "4f322ab65de658b22c6d3de64de06deffd8d360a", "filename": "gcc/testsuite/c-c++-common/gomp/scan-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fscan-2.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -8,7 +8,7 @@ f1 (int *c, int *d)\n   for (i = 0; i < 64; i++)\n     {\n       d[i] = a;\n-      #pragma omp scan exclusive (a)\t\t/* { dg-message \"sorry, unimplemented: '#pragma omp scan' not supported yet\" } */\n+      #pragma omp scan exclusive (a)\n       a += c[i];\n     }\n }"}, {"sha": "997f7b1cf92a6c7ae9708c24411022e4302d9b14", "filename": "gcc/testsuite/g++.dg/vect/simd-6.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-6.cc?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,161 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+template <typename T>\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  T s;\n+};\n+\n+template <typename T>\n+S<T>::S () : s (0)\n+{\n+}\n+\n+template <typename T>\n+S<T>::~S ()\n+{\n+}\n+\n+template <typename T>\n+S<T>::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+template <typename T>\n+S<T> &\n+S<T>::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+template <typename T>\n+static inline void\n+ini (S<T> &x)\n+{\n+  x.s = 0;\n+}\n+\n+S<int> r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S<int>: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S<int>: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+foo (S<T> *a, S<T> *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) S<T>\n+bar (void)\n+{\n+  S<T> s;\n+  #pragma omp simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<T> (s);\n+}\n+\n+__attribute__((noipa)) void\n+baz (S<int> *a, S<int> *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S<int>\n+qux (void)\n+{\n+  S<int> s;\n+  #pragma omp simd if (0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return S<int> (s);\n+}\n+\n+int\n+main ()\n+{\n+  S<int> s;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar<int> ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "1467849e0c6baa791016b039ca21cfa2cc63ce7f", "filename": "gcc/testsuite/g++.dg/vect/simd-7.cc", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-7.cc?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,124 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+int r, a[1024], b[1024], q;\n+\n+template <typename T, typename U>\n+__attribute__((noipa)) void\n+foo (T a, T b, U r)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) T\n+bar (void)\n+{\n+  T &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) void\n+baz (T *a, T *b, T &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r) if (simd: 0)\n+  for (T i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+template <typename T>\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  T s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, +:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo<int *, int &> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar<int> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz<int> (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux<int &> () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "8e297e246bd41a2f63469260f4fdcfcb5a68a62e", "filename": "gcc/testsuite/g++.dg/vect/simd-8.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-8.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-8.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-8.cc?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,122 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+int r, a[1024], b[1024], q;\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, int &r)\n+{\n+  #pragma omp simd reduction (inscan, foo:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int &s = q;\n+  q = 0;\n+  #pragma omp simd reduction (inscan, foo:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b, r);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "bfef445d1210bad33695e70c819e4410da6c0f7a", "filename": "gcc/testsuite/g++.dg/vect/simd-9.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-9.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-9.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fsimd-9.cc?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,153 @@\n+// { dg-require-effective-target size32plus }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { xfail *-*-* } } }\n+\n+#include \"../../gcc.dg/vect/tree-vect.h\"\n+\n+struct S {\n+  inline S ();\n+  inline ~S ();\n+  inline S (const S &);\n+  inline S & operator= (const S &);\n+  int s;\n+};\n+\n+S::S () : s (0)\n+{\n+}\n+\n+S::~S ()\n+{\n+}\n+\n+S::S (const S &x)\n+{\n+  s = x.s;\n+}\n+\n+S &\n+S::operator= (const S &x)\n+{\n+  s = x.s;\n+  return *this;\n+}\n+\n+static inline void\n+ini (S &x)\n+{\n+  x.s = 0;\n+}\n+\n+S r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (+: S: omp_out.s += omp_in.s)\n+#pragma omp declare reduction (plus: S: omp_out.s += omp_in.s) initializer (ini (omp_priv))\n+\n+__attribute__((noipa)) void\n+foo (S *a, S *b, S &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+bar (void)\n+{\n+  S s;\n+  #pragma omp simd reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (S *a, S *b, S &r)\n+{\n+  #pragma omp simd reduction (inscan, +:r) simdlen(1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r.s += a[i].s;\n+    }\n+}\n+\n+__attribute__((noipa)) S\n+qux (void)\n+{\n+  S s;\n+  #pragma omp simd if (0) reduction (inscan, plus:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s.s += 2 * a[i].s;\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  check_vect ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i].s = i;\n+      b[i].s = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (bar ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  r.s = 0;\n+  baz (a, b, r);\n+  if (r.s != 1024 * 1023 / 2)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      else\n+\tb[i].s = 25;\n+      s.s += i;\n+    }\n+  if (qux ().s != 1024 * 1023)\n+    abort ();\n+  s.s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i].s != s.s)\n+\tabort ();\n+      s.s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "cdfec81a6e6d761b6959fd434fc3367ad01d7026", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-12.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-12.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,122 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#ifndef main\n+#include \"tree-vect.h\"\n+#endif\n+\n+int r, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, +:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, +:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, +:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+#ifndef main\n+  check_vect ();\n+#endif\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "aee5244d85e18e707163a34cb93a9cd5b1317fc3", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-13.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-13.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#ifndef main\n+#include \"tree-vect.h\"\n+#endif\n+\n+int r, a[1024], b[1024];\n+\n+#pragma omp declare reduction (foo: int: omp_out += omp_in) initializer (omp_priv = 0)\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, foo:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, foo:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b)\n+{\n+  #pragma omp simd reduction (inscan, foo:r) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r += a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (void)\n+{\n+  int s = 0;\n+  #pragma omp simd reduction (inscan, foo:s) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s += 2 * a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+#ifndef main\n+  check_vect ();\n+#endif\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = 25;\n+      s += i;\n+    }\n+  if (bar () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -1;\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  baz (a, b);\n+  if (r != 1024 * 1023 / 2)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -25;\n+      s += i;\n+    }\n+  if (qux () != 1024 * 1023)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "43663bbc598f5ac10455020a8947067c3a2a0c0d", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-14.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-14.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#ifndef main\n+#include \"tree-vect.h\"\n+#endif\n+\n+float r = 1.0f, a[1024], b[1024];\n+\n+__attribute__((noipa)) void\n+foo (float *a, float *b)\n+{\n+  #pragma omp simd reduction (inscan, *:r)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = r;\n+      #pragma omp scan exclusive(r)\n+      r *= a[i];\n+    }\n+}\n+\n+__attribute__((noipa)) float\n+bar (void)\n+{\n+  float s = -__builtin_inff ();\n+  #pragma omp simd reduction (inscan, max:s)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      b[i] = s;\n+      #pragma omp scan exclusive(s)\n+      s = s > a[i] ? s : a[i];\n+    }\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  float s = 1.0f;\n+#ifndef main\n+  check_vect ();\n+#endif\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (i < 80)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 200)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else if (i < 280)\n+\ta[i] = (i & 1) ? 0.25f : 0.5f;\n+      else if (i < 380)\n+\ta[i] = (i % 3) == 0 ? 2.0f : (i % 3) == 1 ? 4.0f : 1.0f;\n+      else\n+\tswitch (i % 6)\n+\t  {\n+\t  case 0: a[i] = 0.25f; break;\n+\t  case 1: a[i] = 2.0f; break;\n+\t  case 2: a[i] = -1.0f; break;\n+\t  case 3: a[i] = -4.0f; break;\n+\t  case 4: a[i] = 0.5f; break;\n+\t  case 5: a[i] = 1.0f; break;\n+\t  default: a[i] = 0.0f; break;\n+\t  }\n+      b[i] = -19.0f;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b);\n+  if (r * 16384.0f != 0.125f)\n+    abort ();\n+  float m = -175.25f;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      else\n+\tb[i] = -231.75f;\n+      s *= a[i];\n+      a[i] = m - ((i % 3) == 1 ? 2.0f : (i % 3) == 2 ? 4.0f : 0.0f);\n+      m += 0.75f;\n+    }\n+  if (bar () != 592.0f)\n+    abort ();\n+  s = -__builtin_inff ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s)\n+\tabort ();\n+      if (s < a[i])\n+\ts = a[i];\n+    }\n+  return 0;\n+}"}, {"sha": "91e34cd6428c4b841ab55226e49a5fc10444df57", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-15.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-15.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,186 @@\n+/* { dg-require-effective-target size32plus } */\n+/* { dg-additional-options \"-fopenmp-simd\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#ifndef main\n+#include \"tree-vect.h\"\n+#endif\n+\n+int r, a[1024], b[1024];\n+unsigned short r2, b2[1024];\n+unsigned char r3, b3[1024];\n+\n+__attribute__((noipa)) void\n+foo (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp simd reduction (inscan, +:r, r2, r3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      { r += a[i]; r2 += a[i]; r3 += a[i]; }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp simd reduction (inscan, +:s, s2, s3)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      {\n+\ts += 2 * a[i];\n+\ts2 += 2 * a[i];\n+\ts3 += 2 * a[i];\n+      }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+__attribute__((noipa)) void\n+baz (int *a, int *b, unsigned short *b2, unsigned char *b3)\n+{\n+  #pragma omp simd reduction (inscan, +:r, r2, r3) if (simd: 0)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      {\n+\tb[i] = r;\n+\tb2[i] = r2;\n+\tb3[i] = r3;\n+      }\n+      #pragma omp scan exclusive(r, r2, r3)\n+      {\n+\tr += a[i];\n+\tr2 += a[i];\n+\tr3 += a[i];\n+      }\n+    }\n+}\n+\n+__attribute__((noipa)) int\n+qux (unsigned short *s2p, unsigned char *s3p)\n+{\n+  int s = 0;\n+  unsigned short s2 = 0;\n+  unsigned char s3 = 0;\n+  #pragma omp simd reduction (inscan, +:s, s2, s3) simdlen (1)\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      { b[i] = s; b2[i] = s2; b3[i] = s3; }\n+      #pragma omp scan exclusive(s, s2, s3)\n+      { s += 2 * a[i]; s2 += 2 * a[i]; s3 += 2 * a[i]; }\n+    }\n+  *s2p = s2;\n+  *s3p = s3;\n+  return s;\n+}\n+\n+int\n+main ()\n+{\n+  int s = 0;\n+  unsigned short s2;\n+  unsigned char s3;\n+#ifndef main\n+  check_vect ();\n+#endif\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = -1;\n+      b2[i] = -1;\n+      b3[i] = -1;\n+      asm (\"\" : \"+g\" (i));\n+    }\n+  foo (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  if (bar (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = -1;\n+\t  b2[i] = -1;\n+\t  b3[i] = -1;\n+\t}\n+      s += 2 * i;\n+    }\n+  r = 0;\n+  r2 = 0;\n+  r3 = 0;\n+  baz (a, b, b2, b3);\n+  if (r != 1024 * 1023 / 2\n+      || r2 != (unsigned short) r\n+      || r3 != (unsigned char) r)\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      else\n+\t{\n+\t  b[i] = 25;\n+\t  b2[i] = 24;\n+\t  b3[i] = 26;\n+\t}\n+      s += i;\n+    }\n+  s2 = 0;\n+  s3 = 0;\n+  if (qux (&s2, &s3) != 1024 * 1023)\n+    abort ();\n+  if (s2 != (unsigned short) (1024 * 1023)\n+      || s3 != (unsigned char) (1024 * 1023))\n+    abort ();\n+  s = 0;\n+  for (int i = 0; i < 1024; ++i)\n+    {\n+      if (b[i] != s\n+\t  || b2[i] != (unsigned short) s\n+\t  || b3[i] != (unsigned char) s)\n+\tabort ();\n+      s += 2 * i;\n+    }\n+  return 0;\n+}"}, {"sha": "b170faaf080ef998bb9eac5b31f5d39db74fda2d", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-12.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-12.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "e9fb68db459047dc41a62d8bbbcfde1109adeda3", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-13.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-13.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-13.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "3293d14d727819fb9d4af6906e1e0d4ae406f592", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-14.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-14.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-14.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "0cb5e8663cb3abe9ad0d30d4dfc6c1bb3777ab69", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-simd-15.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-simd-15.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx2 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-15.c\"\n+\n+static void\n+avx2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "8c14e2091e845df6fe5445328c47cfb472f262be", "filename": "gcc/testsuite/gcc.target/i386/avx512bw-vect-simd-15.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-vect-simd-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-vect-simd-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-vect-simd-15.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512bw -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512bw } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512bw-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-15.c\"\n+\n+static void\n+avx512bw_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "87c46d7018d5538d6c94624cd5044865ec9ae1d7", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-12.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-12.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "a8a28dc9d18e1d9e5e815b51c832ea5dd1b9e6e3", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-13.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-13.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-13.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "eba9228091f2c6d1aeb2b3b7186dc27ee1df07be", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vect-simd-14.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vect-simd-14.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -mavx512f -mprefer-vector-width=512 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"avx512f-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-14.c\"\n+\n+static void\n+avx512f_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "e6f15910c55665bd459365e08f021f446d37651e", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-12.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-12.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-12.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "5ad65b1c46090db918167826b03d1244c011dd53", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-13.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-13.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-13.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "8274d42ffaad075423d10e58074365ff4eacbb88", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-14.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-14.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-14.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "8098d20b202fdfea2f6f0c52700d5a3a2845f616", "filename": "gcc/testsuite/gcc.target/i386/sse2-vect-simd-15.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-vect-simd-15.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fopenmp-simd -msse2 -mno-sse3 -fdump-tree-vect-details\" } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 2 \"vect\" } } */\n+\n+#include \"sse2-check.h\"\n+\n+#define main() do_main ()\n+\n+#include \"../../gcc.dg/vect/vect-simd-15.c\"\n+\n+static void\n+sse2_test (void)\n+{\n+  do_main ();\n+}"}, {"sha": "1a72cffc8d41372705de7a4928cc6c522ed5f2aa", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -4223,7 +4223,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf)\n       /* See if this was detected as SIMD lane access.  */\n       if (dr->aux == (void *)-1\n \t  || dr->aux == (void *)-2\n-\t  || dr->aux == (void *)-3)\n+\t  || dr->aux == (void *)-3\n+\t  || dr->aux == (void *)-4)\n \t{\n \t  if (nested_in_vect_loop_p (loop, stmt_info))\n \t    return opt_result::failure_at (stmt_info->stmt,"}, {"sha": "800c000fdc85c638a647247028a9a3ea7b5412d0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 257, "deletions": 42, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -6512,7 +6512,37 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n      kinds are there in order to allow optimizing the initializer store\n      and combiner sequence, e.g. if it is originally some C++ish user\n      defined reduction, but allow the vectorizer to pattern recognize it\n-     and turn into the appropriate vectorized scan.  */\n+     and turn into the appropriate vectorized scan.\n+\n+     For exclusive scan, this is slightly different:\n+     #pragma omp simd reduction(inscan,+:r)\n+     for (...)\n+       {\n+\t use (r);\n+\t #pragma omp scan exclusive (r)\n+\t r += something ();\n+       }\n+     shall have body with:\n+       // Initialization for input phase, store the reduction initializer:\n+       _20 = .GOMP_SIMD_LANE (simduid.3_14(D), 0);\n+       _21 = .GOMP_SIMD_LANE (simduid.3_14(D), 1);\n+       D.2042[_21] = 0;\n+       // Actual input phase:\n+       ...\n+       r.0_5 = D.2042[_20];\n+       _6 = _4 + r.0_5;\n+       D.2042[_20] = _6;\n+       // Initialization for scan phase:\n+       _25 = .GOMP_SIMD_LANE (simduid.3_14(D), 3);\n+       _26 = D.2043[_25];\n+       D.2044[_25] = _26;\n+       _27 = D.2042[_25];\n+       _28 = _26 + _27;\n+       D.2043[_25] = _28;\n+       // Actual scan phase:\n+       ...\n+       r.1_8 = D.2044[_20];\n+       ...  */\n \n   if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 2)\n     {\n@@ -6553,26 +6583,52 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n   if (TREE_CODE (rhs) != SSA_NAME)\n     goto fail;\n \n-  use_operand_p use_p;\n-  imm_use_iterator iter;\n   gimple *other_store_stmt = NULL;\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, rhs)\n+  tree var = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n+  bool inscan_var_store\n+    = lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var)) != NULL;\n+\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4)\n     {\n-      gimple *use_stmt = USE_STMT (use_p);\n-      if (use_stmt == stmt || is_gimple_debug (use_stmt))\n-\tcontinue;\n-      if (gimple_bb (use_stmt) != gimple_bb (stmt)\n-\t  || !gimple_store_p (use_stmt)\n-\t  || other_store_stmt)\n-\tgoto fail;\n-      other_store_stmt = use_stmt;\n+      if (!inscan_var_store)\n+\t{\n+\t  use_operand_p use_p;\n+\t  imm_use_iterator iter;\n+\t  FOR_EACH_IMM_USE_FAST (use_p, iter, rhs)\n+\t    {\n+\t      gimple *use_stmt = USE_STMT (use_p);\n+\t      if (use_stmt == stmt || is_gimple_debug (use_stmt))\n+\t\tcontinue;\n+\t      if (gimple_bb (use_stmt) != gimple_bb (stmt)\n+\t\t  || !is_gimple_assign (use_stmt)\n+\t\t  || gimple_assign_rhs_class (use_stmt) != GIMPLE_BINARY_RHS\n+\t\t  || other_store_stmt\n+\t\t  || TREE_CODE (gimple_assign_lhs (use_stmt)) != SSA_NAME)\n+\t\tgoto fail;\n+\t      other_store_stmt = use_stmt;\n+\t    }\n+\t  if (other_store_stmt == NULL)\n+\t    goto fail;\n+\t  rhs = gimple_assign_lhs (other_store_stmt);\n+\t  if (!single_imm_use (rhs, &use_p, &other_store_stmt))\n+\t    goto fail;\n+\t}\n     }\n-  if (other_store_stmt == NULL)\n-    goto fail;\n-  stmt_vec_info other_store_stmt_info\n-    = loop_vinfo->lookup_stmt (other_store_stmt);\n-  if (other_store_stmt_info == NULL\n-      || STMT_VINFO_SIMD_LANE_ACCESS_P (other_store_stmt_info) != 3)\n+  else if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 3)\n+    {\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, rhs)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt == stmt || is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  if (other_store_stmt)\n+\t    goto fail;\n+\t  other_store_stmt = use_stmt;\n+\t}\n+    }\n+  else\n     goto fail;\n \n   gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n@@ -6599,8 +6655,7 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n \n   tree rhs1 = gimple_assign_rhs1 (def_stmt);\n   tree rhs2 = gimple_assign_rhs2 (def_stmt);\n-  if (TREE_CODE (rhs1) != SSA_NAME\n-      || TREE_CODE (rhs2) != SSA_NAME)\n+  if (TREE_CODE (rhs1) != SSA_NAME || TREE_CODE (rhs2) != SSA_NAME)\n     goto fail;\n \n   gimple *load1_stmt = SSA_NAME_DEF_STMT (rhs1);\n@@ -6615,22 +6670,83 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n   stmt_vec_info load2_stmt_info = loop_vinfo->lookup_stmt (load2_stmt);\n   if (load1_stmt_info == NULL\n       || load2_stmt_info == NULL\n-      || STMT_VINFO_SIMD_LANE_ACCESS_P (load1_stmt_info) != 3\n-      || STMT_VINFO_SIMD_LANE_ACCESS_P (load2_stmt_info) != 3)\n+      || (STMT_VINFO_SIMD_LANE_ACCESS_P (load1_stmt_info)\n+\t  != STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info))\n+      || (STMT_VINFO_SIMD_LANE_ACCESS_P (load2_stmt_info)\n+\t  != STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info)))\n     goto fail;\n \n-  if (scan_operand_equal_p (gimple_assign_lhs (stmt),\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4 && inscan_var_store)\n+    {\n+      dr_vec_info *load1_dr_info = STMT_VINFO_DR_INFO (load1_stmt_info);\n+      if (TREE_CODE (DR_BASE_ADDRESS (load1_dr_info->dr)) != ADDR_EXPR\n+\t  || !VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (load1_dr_info->dr), 0)))\n+\tgoto fail;\n+      tree var1 = TREE_OPERAND (DR_BASE_ADDRESS (load1_dr_info->dr), 0);\n+      tree lrhs;\n+      if (lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var1)))\n+\tlrhs = rhs1;\n+      else\n+\tlrhs = rhs2;\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, lrhs)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt == def_stmt || is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  if (other_store_stmt)\n+\t    goto fail;\n+\t  other_store_stmt = use_stmt;\n+\t}\n+    }\n+\n+  if (other_store_stmt == NULL)\n+    goto fail;\n+  if (gimple_bb (other_store_stmt) != gimple_bb (stmt)\n+      || !gimple_store_p (other_store_stmt))\n+    goto fail;\n+\n+  stmt_vec_info other_store_stmt_info\n+    = loop_vinfo->lookup_stmt (other_store_stmt);\n+  if (other_store_stmt_info == NULL\n+      || (STMT_VINFO_SIMD_LANE_ACCESS_P (other_store_stmt_info)\n+\t  != STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info)))\n+    goto fail;\n+\n+  gimple *stmt1 = stmt;\n+  gimple *stmt2 = other_store_stmt;\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4 && !inscan_var_store)\n+    std::swap (stmt1, stmt2);\n+  if (scan_operand_equal_p (gimple_assign_lhs (stmt1),\n \t\t\t    gimple_assign_rhs1 (load2_stmt)))\n     {\n       std::swap (rhs1, rhs2);\n       std::swap (load1_stmt, load2_stmt);\n       std::swap (load1_stmt_info, load2_stmt_info);\n     }\n-  if (!scan_operand_equal_p (gimple_assign_lhs (stmt),\n-\t\t\t     gimple_assign_rhs1 (load1_stmt))\n-      || !scan_operand_equal_p (gimple_assign_lhs (other_store_stmt),\n+  if (!scan_operand_equal_p (gimple_assign_lhs (stmt1),\n+\t\t\t     gimple_assign_rhs1 (load1_stmt)))\n+    goto fail;\n+\n+  tree var3 = NULL_TREE;\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 3\n+      && !scan_operand_equal_p (gimple_assign_lhs (stmt2),\n \t\t\t\tgimple_assign_rhs1 (load2_stmt)))\n     goto fail;\n+  else if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4)\n+    {\n+      dr_vec_info *load2_dr_info = STMT_VINFO_DR_INFO (load2_stmt_info);\n+      if (TREE_CODE (DR_BASE_ADDRESS (load2_dr_info->dr)) != ADDR_EXPR\n+\t  || !VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (load2_dr_info->dr), 0)))\n+\tgoto fail;\n+      var3 = TREE_OPERAND (DR_BASE_ADDRESS (load2_dr_info->dr), 0);\n+      if (!lookup_attribute (\"omp simd array\", DECL_ATTRIBUTES (var3))\n+\t  || lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var3))\n+\t  || lookup_attribute (\"omp simd inscan exclusive\",\n+\t\t\t       DECL_ATTRIBUTES (var3)))\n+\tgoto fail;\n+    }\n \n   dr_vec_info *other_dr_info = STMT_VINFO_DR_INFO (other_store_stmt_info);\n   if (TREE_CODE (DR_BASE_ADDRESS (other_dr_info->dr)) != ADDR_EXPR\n@@ -6648,13 +6764,22 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n   if (lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var1)))\n     std::swap (var1, var2);\n \n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4)\n+    {\n+      if (!lookup_attribute (\"omp simd inscan exclusive\",\n+\t\t\t     DECL_ATTRIBUTES (var1)))\n+\tgoto fail;\n+      var1 = var3;\n+    }\n+\n   if (loop_vinfo->scan_map == NULL)\n     goto fail;\n   tree *init = loop_vinfo->scan_map->get (var1);\n   if (init == NULL)\n     goto fail;\n \n   /* The IL is as expected, now check if we can actually vectorize it.\n+     Inclusive scan:\n        _26 = D.2043[_25];\n        _27 = D.2042[_25];\n        _28 = _26 + _27;\n@@ -6664,21 +6789,49 @@ check_scan_store (stmt_vec_info stmt_info, tree vectype,\n      from the D.2042[_21] = 0; store):\n        _30 = MEM <vector(8) int> [(int *)&D.2043];\n        _31 = MEM <vector(8) int> [(int *)&D.2042];\n-       _32 = VEC_PERM_EXPR <_31, _40, { 8, 0, 1, 2, 3, 4, 5, 6 }>;\n+       _32 = VEC_PERM_EXPR <_40, _31, { 0, 8, 9, 10, 11, 12, 13, 14 }>;\n        _33 = _31 + _32;\n        // _33 = { _31[0], _31[0]+_31[1], _31[1]+_31[2], ..., _31[6]+_31[7] };\n-       _34 = VEC_PERM_EXPR <_33, _40, { 8, 9, 0, 1, 2, 3, 4, 5 }>;\n+       _34 = VEC_PERM_EXPR <_40, _33, { 0, 1, 8, 9, 10, 11, 12, 13 }>;\n        _35 = _33 + _34;\n        // _35 = { _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n        //         _31[1]+.._31[4], ... _31[4]+.._31[7] };\n-       _36 = VEC_PERM_EXPR <_35, _40, { 8, 9, 10, 11, 0, 1, 2, 3 }>;\n+       _36 = VEC_PERM_EXPR <_40, _35, { 0, 1, 2, 3, 8, 9, 10, 11 }>;\n        _37 = _35 + _36;\n        // _37 = { _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n        //         _31[0]+.._31[4], ... _31[0]+.._31[7] };\n        _38 = _30 + _37;\n        _39 = VEC_PERM_EXPR <_38, _38, { 7, 7, 7, 7, 7, 7, 7, 7 }>;\n        MEM <vector(8) int> [(int *)&D.2043] = _39;\n-       MEM <vector(8) int> [(int *)&D.2042] = _38;  */\n+       MEM <vector(8) int> [(int *)&D.2042] = _38;\n+     Exclusive scan:\n+       _26 = D.2043[_25];\n+       D.2044[_25] = _26;\n+       _27 = D.2042[_25];\n+       _28 = _26 + _27;\n+       D.2043[_25] = _28;\n+     should be vectorized as (where _40 is the vectorized rhs\n+     from the D.2042[_21] = 0; store):\n+       _30 = MEM <vector(8) int> [(int *)&D.2043];\n+       _31 = MEM <vector(8) int> [(int *)&D.2042];\n+       _32 = VEC_PERM_EXPR <_40, _31, { 0, 8, 9, 10, 11, 12, 13, 14 }>;\n+       _33 = VEC_PERM_EXPR <_40, _32, { 0, 8, 9, 10, 11, 12, 13, 14 }>;\n+       _34 = _32 + _33;\n+       // _34 = { 0, _31[0], _31[0]+_31[1], _31[1]+_31[2], _31[2]+_31[3],\n+       //         _31[3]+_31[4], ... _31[5]+.._31[6] };\n+       _35 = VEC_PERM_EXPR <_40, _34, { 0, 1, 8, 9, 10, 11, 12, 13 }>;\n+       _36 = _34 + _35;\n+       // _36 = { 0, _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n+       //         _31[1]+.._31[4], ... _31[3]+.._31[6] };\n+       _37 = VEC_PERM_EXPR <_40, _36, { 0, 1, 2, 3, 8, 9, 10, 11 }>;\n+       _38 = _36 + _37;\n+       // _38 = { 0, _31[0], _31[0]+_31[1], _31[0]+.._31[2], _31[0]+.._31[3],\n+       //         _31[0]+.._31[4], ... _31[0]+.._31[6] };\n+       _39 = _30 + _38;\n+       _50 = _31 + _39;\n+       _51 = VEC_PERM_EXPR <_50, _50, { 7, 7, 7, 7, 7, 7, 7, 7 }>;\n+       MEM <vector(8) int> [(int *)&D.2044] = _39;\n+       MEM <vector(8) int> [(int *)&D.2042] = _51;  */\n   enum machine_mode vec_mode = TYPE_MODE (vectype);\n   optab optab = optab_for_tree_code (code, vectype, optab_default);\n   if (!optab || optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n@@ -6715,6 +6868,24 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   tree rhs = gimple_assign_rhs1 (stmt);\n   gcc_assert (TREE_CODE (rhs) == SSA_NAME);\n \n+  tree var = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n+  bool inscan_var_store\n+    = lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var)) != NULL;\n+\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4 && !inscan_var_store)\n+    {\n+      use_operand_p use_p;\n+      imm_use_iterator iter;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, rhs)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (use_stmt == stmt || is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  rhs = gimple_assign_lhs (use_stmt);\n+\t  break;\n+\t}\n+    }\n+\n   gimple *def_stmt = SSA_NAME_DEF_STMT (rhs);\n   enum tree_code code = gimple_assign_rhs_code (def_stmt);\n   if (code == POINTER_PLUS_EXPR)\n@@ -6737,15 +6908,12 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     {\n       std::swap (rhs1, rhs2);\n       std::swap (var1, var2);\n+      std::swap (load1_dr_info, load2_dr_info);\n     }\n \n   tree *init = loop_vinfo->scan_map->get (var1);\n   gcc_assert (init);\n \n-  tree var = TREE_OPERAND (DR_BASE_ADDRESS (dr_info->dr), 0);\n-  bool inscan_var_store\n-    = lookup_attribute (\"omp simd inscan\", DECL_ATTRIBUTES (var)) != NULL;\n-\n   unsigned HOST_WIDE_INT nunits;\n   if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant (&nunits))\n     gcc_unreachable ();\n@@ -6789,29 +6957,50 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   tree vec_oprnd1 = NULL_TREE;\n   tree vec_oprnd2 = NULL_TREE;\n   tree vec_oprnd3 = NULL_TREE;\n-  tree dataref_ptr = unshare_expr (DR_BASE_ADDRESS (dr_info->dr));\n+  tree dataref_ptr = DR_BASE_ADDRESS (dr_info->dr);\n   tree dataref_offset = build_int_cst (ref_type, 0);\n   tree bump = vect_get_data_ptr_increment (dr_info, vectype, VMAT_CONTIGUOUS);\n+  tree ldataref_ptr = NULL_TREE;\n   tree orig = NULL_TREE;\n+  if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4 && !inscan_var_store)\n+    ldataref_ptr = DR_BASE_ADDRESS (load1_dr_info->dr);\n   for (int j = 0; j < ncopies; j++)\n     {\n       stmt_vec_info new_stmt_info;\n       if (j == 0)\n \t{\n \t  vec_oprnd1 = vect_get_vec_def_for_operand (*init, stmt_info);\n-\t  vec_oprnd2 = vect_get_vec_def_for_operand (rhs1, stmt_info);\n+\t  if (ldataref_ptr == NULL)\n+\t    vec_oprnd2 = vect_get_vec_def_for_operand (rhs1, stmt_info);\n \t  vec_oprnd3 = vect_get_vec_def_for_operand (rhs2, stmt_info);\n \t  orig = vec_oprnd3;\n \t}\n       else\n \t{\n \t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd1);\n-\t  vec_oprnd2 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd2);\n+\t  if (ldataref_ptr == NULL)\n+\t    vec_oprnd2 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd2);\n \t  vec_oprnd3 = vect_get_vec_def_for_stmt_copy (vinfo, vec_oprnd3);\n \t  if (!inscan_var_store)\n \t    dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n \t}\n \n+      if (ldataref_ptr)\n+\t{\n+\t  vec_oprnd2 = make_ssa_name (vectype);\n+\t  tree data_ref = fold_build2 (MEM_REF, vectype,\n+\t\t\t\t       unshare_expr (ldataref_ptr),\n+\t\t\t\t       dataref_offset);\n+\t  vect_copy_ref_info (data_ref, DR_REF (load1_dr_info->dr));\n+\t  gimple *g = gimple_build_assign (vec_oprnd2, data_ref);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t  if (prev_stmt_info == NULL)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\t}\n+\n       tree v = vec_oprnd2;\n       for (int i = 0; i < units_log2; ++i)\n \t{\n@@ -6848,6 +7037,17 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      new_temp = new_temp2;\n \t    }\n \n+\t  /* For exclusive scan, perform the perms[i] permutation once\n+\t     more.  */\n+\t  if (i == 0\n+\t      && STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4\n+\t      && v == vec_oprnd2)\n+\t    {\n+\t      v = new_temp;\n+\t      --i;\n+\t      continue;\n+\t    }\n+\n \t  tree new_temp2 = make_ssa_name (vectype);\n \t  g = gimple_build_assign (new_temp2, code, v, new_temp);\n \t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n@@ -6863,16 +7063,30 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n       prev_stmt_info = new_stmt_info;\n \n+      tree last_perm_arg = new_temp;\n+      /* For exclusive scan, new_temp computed above is the exclusive scan\n+\t prefix sum.  Turn it into inclusive prefix sum for the broadcast\n+\t of the last element into orig.  */\n+      if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 4)\n+\t{\n+\t  last_perm_arg = make_ssa_name (vectype);\n+\t  g = gimple_build_assign (last_perm_arg, code, new_temp, vec_oprnd2);\n+\t  new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n+\t  prev_stmt_info = new_stmt_info;\n+\t}\n+\n       orig = make_ssa_name (vectype);\n-      g = gimple_build_assign (orig, VEC_PERM_EXPR, new_temp, new_temp,\n-\t\t\t       perms[units_log2]);\n+      g = gimple_build_assign (orig, VEC_PERM_EXPR, last_perm_arg,\n+\t\t\t       last_perm_arg, perms[units_log2]);\n       new_stmt_info = vect_finish_stmt_generation (stmt_info, g, gsi);\n       STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n       prev_stmt_info = new_stmt_info;\n \n       if (!inscan_var_store)\n \t{\n-\t  tree data_ref = fold_build2 (MEM_REF, vectype, dataref_ptr,\n+\t  tree data_ref = fold_build2 (MEM_REF, vectype,\n+\t\t\t\t       unshare_expr (dataref_ptr),\n \t\t\t\t       dataref_offset);\n \t  vect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n \t  g = gimple_build_assign (data_ref, new_temp);\n@@ -6888,7 +7102,8 @@ vectorizable_scan_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \tif (j != 0)\n \t  dataref_offset = int_const_binop (PLUS_EXPR, dataref_offset, bump);\n \n-\ttree data_ref = fold_build2 (MEM_REF, vectype, dataref_ptr,\n+\ttree data_ref = fold_build2 (MEM_REF, vectype,\n+\t\t\t\t     unshare_expr (dataref_ptr),\n \t\t\t\t     dataref_offset);\n \tvect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n \tgimple *g = gimple_build_assign (data_ref, orig);\n@@ -7325,7 +7540,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t}\n       return true;\n     }\n-  else if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) == 3)\n+  else if (STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) >= 3)\n     return vectorizable_scan_store (stmt_info, gsi, vec_stmt, ncopies);\n \n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))"}, {"sha": "5fc8f9fc640d6550369ea9bde916c23df453e2be", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1612b1febdd5b6b6ad17c96c980a218bfd40c025/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1612b1febdd5b6b6ad17c96c980a218bfd40c025", "patch": "@@ -917,7 +917,7 @@ struct _stmt_vec_info {\n   bool strided_p;\n \n   /* For both loads and stores.  */\n-  unsigned simd_lane_access_p : 2;\n+  unsigned simd_lane_access_p : 3;\n \n   /* Classifies how the load or store is going to be implemented\n      for loop vectorization.  */"}]}