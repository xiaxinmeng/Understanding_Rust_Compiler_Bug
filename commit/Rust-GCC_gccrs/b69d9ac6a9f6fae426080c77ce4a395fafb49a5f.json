{"sha": "b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5ZDlhYzZhOWY2ZmFlNDI2MDgwYzc3Y2U0YTM5NWZhZmI0OWE1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-08T13:16:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-08T13:16:44Z"}, "message": "predict.c (maybe_hot_bb_p): Do not check profile status.\n\n\n\t* predict.c (maybe_hot_bb_p): Do not check profile status.\n\t(maybe_hot_edge_p): Likewise.\n\t(probably_never_executed): Check for zero counts even if profile\n\tis not read.\n\t(unlikely_executed_edge_p): New function.\n\t(unlikely_executed_stmt_p): New function.\n\t(unlikely_executed_bb_p): New function.\n\t(set_even_probabilities): Use unlikely predicates.\n\t(combine_predictions_for_bb): Likewise.\n\t(predict_paths_for_bb): Likewise.\n\t(predict_paths_leading_to_edge): Likewise.\n\t(determine_unlikely_bbs): New function.\n\t(estimate_bb_frequencies): Use it.\n\t(compute_function_frequency): Use zero counts even if profile is\n\tnot read.\n\t* profile-count.h: Fix typo.\n\n\t* g++.dg/tree-ssa/counts-1.C: New testcase.\n\t* gcc.dg/tree-ssa/counts-1.c: New testcase.\n\nFrom-SVN: r249013", "tree": {"sha": "70e06d0d036ff5e480b61732710afb7406205bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e06d0d036ff5e480b61732710afb7406205bfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/comments", "author": null, "committer": null, "parents": [{"sha": "c46f9051654ff52ed083084c109e9247b7fce9aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46f9051654ff52ed083084c109e9247b7fce9aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46f9051654ff52ed083084c109e9247b7fce9aa"}], "stats": {"total": 325, "additions": 304, "deletions": 21}, "files": [{"sha": "ddc675bde45cc0d196d26712b0b20ff4b85eeff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -1,3 +1,22 @@\n+2017-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (maybe_hot_bb_p): Do not check profile status.\n+\t(maybe_hot_edge_p): Likewise.\n+\t(probably_never_executed): Check for zero counts even if profile\n+\tis not read.\n+\t(unlikely_executed_edge_p): New function.\n+\t(unlikely_executed_stmt_p): New function.\n+\t(unlikely_executed_bb_p): New function.\n+\t(set_even_probabilities): Use unlikely predicates.\n+\t(combine_predictions_for_bb): Likewise.\n+\t(predict_paths_for_bb): Likewise.\n+\t(predict_paths_leading_to_edge): Likewise.\n+\t(determine_unlikely_bbs): New function.\n+\t(estimate_bb_frequencies): Use it.\n+\t(compute_function_frequency): Use zero counts even if profile is\n+\tnot read.\n+\t* profile-count.h: Fix typo.\n+\n 2017-08-08  Julia Koval  <julia.koval@intel.com>\n \n \t* config/i386/avx512bwintrin.h (_mm512_mask_cvtepi16_storeu_epi8,"}, {"sha": "7c7a35d4de6a49324c413a031377d5018fab3959", "filename": "gcc/predict.c", "status": "modified", "additions": 223, "deletions": 20, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -189,8 +189,8 @@ bool\n maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n {\n   gcc_checking_assert (fun);\n-  if (profile_status_for_fn (fun) == PROFILE_READ)\n-    return maybe_hot_count_p (fun, bb->count);\n+  if (!maybe_hot_count_p (fun, bb->count))\n+    return false;\n   return maybe_hot_frequency_p (fun, bb->frequency);\n }\n \n@@ -200,8 +200,8 @@ maybe_hot_bb_p (struct function *fun, const_basic_block bb)\n bool\n maybe_hot_edge_p (edge e)\n {\n-  if (profile_status_for_fn (cfun) == PROFILE_READ)\n-    return maybe_hot_count_p (cfun, e->count);\n+  if (!maybe_hot_count_p (cfun, e->count))\n+    return false;\n   return maybe_hot_frequency_p (cfun, EDGE_FREQUENCY (e));\n }\n \n@@ -213,11 +213,10 @@ probably_never_executed (struct function *fun,\n                          profile_count count, int)\n {\n   gcc_checking_assert (fun);\n+  if (count == profile_count::zero ())\n+    return true;\n   if (count.initialized_p () && profile_status_for_fn (fun) == PROFILE_READ)\n     {\n-      if (count == profile_count::zero ())\n-\treturn true;\n-\n       int unlikely_count_fraction = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n       if (count.apply_scale (unlikely_count_fraction, 1) >= profile_info->runs)\n \treturn false;\n@@ -763,6 +762,69 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n   fprintf (file, \"\\n\");\n }\n \n+/* Return true if E is unlikely executed.  */\n+\n+static bool\n+unlikely_executed_edge_p (edge e)\n+{\n+  return e->count == profile_count::zero ()\n+\t || (e->flags & (EDGE_EH | EDGE_FAKE));\n+}\n+\n+/* Return true if STMT is known to be unlikely executed.  */\n+\n+static bool\n+unlikely_executed_stmt_p (gimple *stmt)\n+{\n+  if (!is_gimple_call (stmt))\n+    return false;\n+  /* NORETURN attribute enough is not strong enough: exit() may be quite\n+     likely executed once during program run.  */\n+  if (gimple_call_fntype (stmt)\n+      && lookup_attribute (\"cold\",\n+\t\t\t   TYPE_ATTRIBUTES (gimple_call_fntype (stmt)))\n+      && !lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl)))\n+    return true;\n+  tree decl = gimple_call_fndecl (stmt);\n+  if (!decl)\n+    return false;\n+  if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (decl))\n+      && !lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl)))\n+    return true;\n+\n+  cgraph_node *n = cgraph_node::get (decl);\n+  if (!n)\n+    return false;\n+  enum availability avail;\n+  n = n->ultimate_alias_target (&avail);\n+  if (avail < AVAIL_AVAILABLE)\n+    return NULL;\n+  if (!n->analyzed\n+      || n->decl == current_function_decl)\n+    return false;\n+  return n->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED;\n+}\n+\n+/* Return true if BB is unlikely executed.  */\n+\n+static bool\n+unlikely_executed_bb_p (basic_block bb)\n+{\n+  if (bb->count == profile_count::zero ())\n+    return true;\n+  if (bb == ENTRY_BLOCK_PTR_FOR_FN (cfun) || bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    return false;\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+       !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      if (unlikely_executed_stmt_p (gsi_stmt (gsi)))\n+        return true;\n+      if (stmt_can_terminate_bb_p (gsi_stmt (gsi)))\n+\treturn false;\n+    }\n+  return false;\n+}\n+\n /* We can not predict the probabilities of outgoing edges of bb.  Set them\n    evenly and hope for the best.  If UNLIKELY_EDGES is not null, distribute\n    even probability for all edges not mentioned in the set.  These edges\n@@ -777,7 +839,7 @@ set_even_probabilities (basic_block bb,\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+    if (!unlikely_executed_edge_p (e))\n       nedges ++;\n \n   /* Make the distribution even if all edges are unlikely.  */\n@@ -791,7 +853,7 @@ set_even_probabilities (basic_block bb,\n   unsigned c = nedges - unlikely_count;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+    if (!unlikely_executed_edge_p (e))\n       {\n \tif (unlikely_edges != NULL && unlikely_edges->contains (e))\n \t  e->probability = PROB_VERY_UNLIKELY;\n@@ -1056,7 +1118,7 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+    if (!unlikely_executed_edge_p (e))\n       {\n \tnedges ++;\n \tif (first && !second)\n@@ -1107,7 +1169,7 @@ combine_predictions_for_bb (basic_block bb, bool dry_run)\n \t\t       \"%i edges in bb %i predicted with some unlikely edges\\n\",\n \t\t       nedges, bb->index);\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+\t\tif (!unlikely_executed_edge_p (e))\n \t\t  dump_prediction (dump_file, PRED_COMBINED, e->probability,\n \t\t   bb, REASON_NONE, e);\n \t    }\n@@ -1758,7 +1820,7 @@ predict_loops (void)\n \n       exits = get_loop_exit_edges (loop);\n       FOR_EACH_VEC_ELT (exits, j, ex)\n-\tif (!(ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL | EDGE_FAKE)))\n+\tif (!unlikely_executed_edge_p (ex) && !(ex->flags & EDGE_ABNORMAL_CALL))\n \t  n_exits ++;\n       if (!n_exits)\n \t{\n@@ -1792,7 +1854,8 @@ predict_loops (void)\n \t  enum br_predictor predictor;\n \t  widest_int nit;\n \n-\t  if (ex->flags & (EDGE_EH | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n+\t  if (unlikely_executed_edge_p (ex)\n+\t      || (ex->flags & EDGE_ABNORMAL_CALL))\n \t    continue;\n \t  /* Loop heuristics do not expect exit conditional to be inside\n \t     inner loop.  We predict from innermost to outermost loop.  */\n@@ -2609,7 +2672,7 @@ tree_bb_level_predictions (void)\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-    if (!(e->flags & (EDGE_ABNORMAL | EDGE_FAKE | EDGE_EH)))\n+    if (!unlikely_executed_edge_p (e) && !(e->flags & EDGE_ABNORMAL_CALL))\n       {\n         has_return_edges = true;\n \tbreak;\n@@ -2863,15 +2926,15 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n       bool found = false;\n \n       /* Ignore fake edges and eh, we predict them as not taken anyway.  */\n-      if (e->flags & (EDGE_EH | EDGE_FAKE))\n+      if (unlikely_executed_edge_p (e))\n \tcontinue;\n       gcc_assert (bb == cur || dominated_by_p (CDI_POST_DOMINATORS, cur, bb));\n \n       /* See if there is an edge from e->src that is not abnormal\n \t and does not lead to BB and does not exit the loop.  */\n       FOR_EACH_EDGE (e2, ei2, e->src->succs)\n \tif (e2 != e\n-\t    && !(e2->flags & (EDGE_EH | EDGE_FAKE))\n+\t    && !unlikely_executed_edge_p (e2)\n \t    && !dominated_by_p (CDI_POST_DOMINATORS, e2->dest, bb)\n \t    && (!in_loop || !loop_exit_edge_p (in_loop, e2)))\n \t  {\n@@ -2923,7 +2986,7 @@ predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n   basic_block bb = e->src;\n   FOR_EACH_EDGE (e2, ei, bb->succs)\n     if (e2->dest != e->src && e2->dest != e->dest\n-\t&& !(e->flags & (EDGE_EH | EDGE_FAKE))\n+\t&& !unlikely_executed_edge_p (e)\n \t&& !dominated_by_p (CDI_POST_DOMINATORS, e->src, e2->dest))\n       {\n \thas_nonloop_edge = true;\n@@ -3341,6 +3404,142 @@ expensive_function_p (int threshold)\n   return false;\n }\n \n+/* Determine basic blocks/edges that are known to be unlikely executed and set\n+   their counters to zero.\n+   This is done with first identifying obviously unlikely BBs/edges and then\n+   propagating in both directions.  */\n+\n+static void\n+determine_unlikely_bbs ()\n+{\n+  basic_block bb;\n+  auto_vec<basic_block, 64> worklist;\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (!(bb->count == profile_count::zero ())\n+\t  && unlikely_executed_bb_p (bb))\n+\t{\n+          if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Basic block %i is locally unlikely\\n\",\n+\t\t     bb->index);\n+\t  bb->count = profile_count::zero ();\n+\t}\n+\n+      if (bb->count == profile_count::zero ())\n+\t{\n+\t  bb->frequency = 0;\n+          FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    e->count = profile_count::zero ();\n+\t}\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (!(e->count == profile_count::zero ())\n+\t    && unlikely_executed_edge_p (e))\n+\t  {\n+            if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Edge %i->%i is locally unlikely\\n\",\n+\t\t       bb->index, e->dest->index);\n+\t    e->count = profile_count::zero ();\n+\t  }\n+\n+      gcc_checking_assert (!bb->aux);\n+    }\n+\n+  if (!(ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ()))\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux = (void *)(size_t) 1;\n+      worklist.safe_push (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+      while (worklist.length () > 0)\n+\t{\n+\t  bb = worklist.pop ();\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if (!(e->count == profile_count::zero ())\n+\t\t&& !(e->dest->count == profile_count::zero ())\n+\t\t&& !e->dest->aux)\n+\t      {\n+\t\te->dest->aux = (void *)(size_t) 1;\n+\t\tworklist.safe_push (e->dest);\n+\t      }\n+\t}\n+    }\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      if (!bb->aux)\n+\t{\n+\t  if (!(bb->count == profile_count::zero ())\n+\t      && (dump_file && (dump_flags & TDF_DETAILS)))\n+\t    fprintf (dump_file,\n+\t\t     \"Basic block %i is marked unlikely by forward prop\\n\",\n+\t\t     bb->index);\n+\t  bb->count = profile_count::zero ();\n+\t  bb->frequency = 0;\n+          FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    e->count = profile_count::zero ();\n+\t}\n+      else\n+        bb->aux = NULL;\n+    }\n+\n+  auto_vec<int, 64> nsuccs;\n+  nsuccs.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+  FOR_ALL_BB_FN (bb, cfun)\n+    if (!(bb->count == profile_count::zero ())\n+\t&& bb != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+      {\n+\tnsuccs[bb->index] = 0;\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (!(e->count == profile_count::zero ()))\n+\t    nsuccs[bb->index]++;\n+\tif (!nsuccs[bb->index])\n+\t  worklist.safe_push (bb);\n+      }\n+  while (worklist.length () > 0)\n+    {\n+      bb = worklist.pop ();\n+      if (bb != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t{\n+\t  bool found = false;\n+          for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+               !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    if (stmt_can_terminate_bb_p (gsi_stmt (gsi))\n+\t\t/* stmt_can_terminate_bb_p special cases noreturns because it\n+\t\t   assumes that fake edges are created.  We want to know that\n+\t\t   noreturn alone does not imply BB to be unlikely.  */\n+\t\t|| (is_gimple_call (gsi_stmt (gsi))\n+\t\t    && (gimple_call_flags (gsi_stmt (gsi)) & ECF_NORETURN)))\n+\t      {\n+\t\tfound = true;\n+\t\tbreak;\n+\t      }\n+\t  if (found)\n+\t    continue;\n+\t}\n+      if (!(bb->count == profile_count::zero ())\n+\t  && (dump_file && (dump_flags & TDF_DETAILS)))\n+\tfprintf (dump_file,\n+\t\t \"Basic block %i is marked unlikely by backward prop\\n\",\n+\t\t bb->index);\n+      bb->count = profile_count::zero ();\n+      bb->frequency = 0;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!(e->count == profile_count::zero ()))\n+\t  {\n+\t    e->count = profile_count::zero ();\n+\t    if (!(e->src->count == profile_count::zero ()))\n+\t      {\n+\t        nsuccs[e->src->index]--;\n+\t        if (!nsuccs[e->src->index])\n+\t\t  worklist.safe_push (e->src);\n+\t      }\n+\t  }\n+    }\n+}\n+\n /* Estimate and propagate basic block frequencies using the given branch\n    probabilities.  If FORCE is true, the frequencies are used to estimate\n    the counts even when there are already non-zero profile counts.  */\n@@ -3351,7 +3550,10 @@ estimate_bb_frequencies (bool force)\n   basic_block bb;\n   sreal freq_max;\n \n-  if (force || profile_status_for_fn (cfun) != PROFILE_READ || !counts_to_freqs ())\n+  determine_unlikely_bbs ();\n+\n+  if (force || profile_status_for_fn (cfun) != PROFILE_READ\n+      || !counts_to_freqs ())\n     {\n       static int real_values_initialized = 0;\n \n@@ -3423,8 +3625,9 @@ compute_function_frequency (void)\n   if (profile_status_for_fn (cfun) != PROFILE_READ)\n     {\n       int flags = flags_from_decl_or_type (current_function_decl);\n-      if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl))\n-\t  != NULL)\n+      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count == profile_count::zero ()\n+\t  || lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl))\n+\t     != NULL)\n         node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n       else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (current_function_decl))\n \t       != NULL)"}, {"sha": "78ffee99ad031cb6d687c9f121d895a8d49281c8", "filename": "gcc/profile-count.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n    profile counts known while other do not - for example when LTO optimizing\n    partly profiled program or when profile was lost due to COMDAT merging.\n \n-   For this information profile_count tracks more information than\n+   For this reason profile_count tracks more information than\n    just unsigned integer and it is also ready for profile mismatches.\n    The API of this data type represent operations that are natural\n    on profile counts - sum, difference and operation with scales and"}, {"sha": "d709baff8c4fc98473f36fce85a3227f2e690758", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -1,3 +1,8 @@\n+2017-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/tree-ssa/counts-1.C: New testcase.\n+\t* gcc.dg/tree-ssa/counts-1.c: New testcase.\n+\n 2017-08-08  Julia Koval  <julia.koval@intel.com>\n \n \t* gcc.target/i386/avx512bw-vpmovswb-1.c: Add new intrinsics to test."}, {"sha": "1759618300f10754a8e25bcf36674bd4865aead5", "filename": "gcc/testsuite/g++.dg/tree-ssa/counts-1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcounts-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcounts-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcounts-1.C?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+void foo();\n+extern void abort (void);\n+\n+static __attribute__ ((noinline))\n+void mark_me_unlikely ()\n+{\n+  foo();\n+  foo();\n+  foo();\n+  foo();\n+}\n+\n+void i_am_not_unlikely()\n+{\n+  try { foo(); }\n+  catch (int) {mark_me_unlikely ();}\n+}\n+/* { dg-final { scan-tree-dump \"mark_me_unlikely\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-not \"i_am_not_unlikely\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\"} } */"}, {"sha": "466895556ca56f4ec66aca07d8bba00cbeb99288", "filename": "gcc/testsuite/gcc.dg/tree-ssa/counts-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcounts-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69d9ac6a9f6fae426080c77ce4a395fafb49a5f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcounts-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcounts-1.c?ref=b69d9ac6a9f6fae426080c77ce4a395fafb49a5f", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+void unlikely () __attribute__ ((cold));\n+void unlikely2 () __attribute__ ((cold));\n+\n+__attribute__ ((noinline)) void\n+i_am_also_unlikely (int a)\n+{\n+  if (a)\n+    unlikely ();\n+  else\n+    unlikely2 ();\n+}\n+\n+\n+void\n+i_am_also_unlikely2 (int a,int b)\n+{\n+  if (b)\n+    i_am_also_unlikely (a);\n+  else\n+    unlikely ();\n+}\n+\n+void\n+i_am_not_unlikely (int a,int b,int c)\n+{\n+  if (c)\n+    __builtin_exit (0);\n+  i_am_also_unlikely2 (a,b);\n+}\n+/* Detect i_am_also_unlikely i_am_also_unlikely2 as unlikely.  */\n+/* { dg-final { scan-tree-dump \"i_am_also_unlikely\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \"i_am_also_unlikely2\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-not \"i_am_not_unlikely\\[^\\r\\n\\]*(unlikely executed)\" \"optimized\"} } */"}]}