{"sha": "89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkOWQ5OGFlNTMzN2E0YzMyZmZlM2MzYjRiZTU5YjJjZTNmMmRkYg==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2007-08-10T15:35:55Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2007-08-10T15:35:55Z"}, "message": "re PR libffi/28313 (libffi has not been ported to mips64-linux-gnu)\n\n\tPR libffi/28313\n\t* configure.ac: Don't treat mips64 as a special case.\n\t* Makefile.am (nodist_libffi_la_SOURCES): Add n32.S.\n\t* configure: Regenerate\n\t* Makefile.in: Ditto.\n\t* fficonfig.h.in: Ditto.\n\t* src/mips/ffitarget.h (REG_L, REG_S, SUBU, ADDU, SRL, LI): Indent.\n\t(LA, EH_FRAME_ALIGN, FDE_ADDR_BYTES): New preprocessor macros.\n\t(FFI_DEFAULT_ABI): Set for n64 case.\n\t(FFI_CLOSURES, FFI_TRAMPOLINE_SIZE): Define for n32 and n64 cases.\n\t* src/mips/n32.S (ffi_call_N32): Add debug macros and labels for FDE.\n\t(ffi_closure_N32): New function.\n\t(.eh_frame): New section\n\t* src/mips/o32.S: Clean up comments.\n\t(ffi_closure_O32): Pass ffi_closure parameter in $12.\n\t* src/mips/ffi.c: Use FFI_MIPS_N32 instead of\n\t_MIPS_SIM == _ABIN32 throughout.\n\t(FFI_MIPS_STOP_HERE): New, use in place of\n\tffi_stop_here.\n\t(ffi_prep_args): Use unsigned long to hold pointer values.  Rewrite\n\tto support n32/n64 ABIs.\n\t(calc_n32_struct_flags): Rewrite.\n\t(calc_n32_return_struct_flags): Remove unused variable.  Reverse\n\tposition of flag bits.\n\t(ffi_prep_cif_machdep): Rewrite n32 portion.\n\t(ffi_call): Enable for n64.  Add special handling for small structure\n\treturn values.\n\t(ffi_prep_closure_loc): Add n32 and n64 support.\n\t(ffi_closure_mips_inner_O32): Add cast to silence warning.\n\t(copy_struct_N32, ffi_closure_mips_inner_N32): New functions.\n\nFrom-SVN: r127336", "tree": {"sha": "7f34b10176eedc697f1ada58dd6a727f07371578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f34b10176eedc697f1ada58dd6a727f07371578"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/comments", "author": null, "committer": null, "parents": [{"sha": "2fbe0e5aec26f9a07df2146aeb427b94fdabe27e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbe0e5aec26f9a07df2146aeb427b94fdabe27e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbe0e5aec26f9a07df2146aeb427b94fdabe27e"}], "stats": {"total": 731, "additions": 635, "deletions": 96}, "files": [{"sha": "8a3ddc98f6df83fe94cae61bd538498881a0767b", "filename": "libffi/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -1,3 +1,36 @@\n+2007-08-10  David Daney  <ddaney@avtrex.com>\n+\n+\tPR libffi/28313\n+\t* configure.ac: Don't treat mips64 as a special case.\n+\t* Makefile.am (nodist_libffi_la_SOURCES): Add n32.S.\n+\t* configure: Regenerate\n+\t* Makefile.in: Ditto.\n+\t* fficonfig.h.in: Ditto.\n+\t* src/mips/ffitarget.h (REG_L, REG_S, SUBU, ADDU, SRL, LI): Indent.\n+\t(LA, EH_FRAME_ALIGN, FDE_ADDR_BYTES): New preprocessor macros.\n+\t(FFI_DEFAULT_ABI): Set for n64 case.\n+\t(FFI_CLOSURES, FFI_TRAMPOLINE_SIZE): Define for n32 and n64 cases.\n+\t* src/mips/n32.S (ffi_call_N32): Add debug macros and labels for FDE.\n+\t(ffi_closure_N32): New function.\n+\t(.eh_frame): New section\n+\t* src/mips/o32.S: Clean up comments.\n+\t(ffi_closure_O32): Pass ffi_closure parameter in $12.\n+\t* src/mips/ffi.c: Use FFI_MIPS_N32 instead of\n+\t_MIPS_SIM == _ABIN32 throughout.\n+\t(FFI_MIPS_STOP_HERE): New, use in place of\n+\tffi_stop_here.\n+\t(ffi_prep_args): Use unsigned long to hold pointer values.  Rewrite\n+\tto support n32/n64 ABIs.\n+\t(calc_n32_struct_flags): Rewrite.\n+\t(calc_n32_return_struct_flags): Remove unused variable.  Reverse\n+\tposition of flag bits.\n+\t(ffi_prep_cif_machdep): Rewrite n32 portion.\n+\t(ffi_call): Enable for n64.  Add special handling for small structure\n+\treturn values.\n+\t(ffi_prep_closure_loc): Add n32 and n64 support.\n+\t(ffi_closure_mips_inner_O32): Add cast to silence warning.\n+\t(copy_struct_N32, ffi_closure_mips_inner_N32): New functions.\n+\n 2007-08-08  David Daney  <ddaney@avtrex.com>\n \n \t* testsuite/libffi.call/ffitest.h (ffi_type_mylong): Remove definition."}, {"sha": "2a2d174c4925f9afe6ccd9eb6ce02a10dbb42c3d", "filename": "libffi/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -88,7 +88,7 @@ if MIPS_IRIX\n nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n endif\n if MIPS_LINUX\n-nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S\n+nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n endif\n if X86\n nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/sysv.S"}, {"sha": "42a444d395fe90afcbfe8ecf2ab7be174fc37c68", "filename": "libffi/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -38,7 +38,7 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n @MIPS_IRIX_TRUE@am__append_1 = src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n-@MIPS_LINUX_TRUE@am__append_2 = src/mips/ffi.c src/mips/o32.S\n+@MIPS_LINUX_TRUE@am__append_2 = src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n @X86_TRUE@am__append_3 = src/x86/ffi.c src/x86/sysv.S\n @X86_WIN32_TRUE@am__append_4 = src/x86/ffi.c src/x86/win32.S\n @X86_DARWIN_TRUE@am__append_5 = src/x86/ffi.c src/x86/darwin.S src/x86/ffi64.c src/x86/darwin64.S\n@@ -97,7 +97,8 @@ am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n \tsrc/raw_api.lo src/java_raw_api.lo src/closures.lo\n @MIPS_IRIX_TRUE@am__objects_1 = src/mips/ffi.lo src/mips/o32.lo \\\n @MIPS_IRIX_TRUE@\tsrc/mips/n32.lo\n-@MIPS_LINUX_TRUE@am__objects_2 = src/mips/ffi.lo src/mips/o32.lo\n+@MIPS_LINUX_TRUE@am__objects_2 = src/mips/ffi.lo src/mips/o32.lo \\\n+@MIPS_LINUX_TRUE@\tsrc/mips/n32.lo\n @X86_TRUE@am__objects_3 = src/x86/ffi.lo src/x86/sysv.lo\n @X86_WIN32_TRUE@am__objects_4 = src/x86/ffi.lo src/x86/win32.lo\n @X86_DARWIN_TRUE@am__objects_5 = src/x86/ffi.lo src/x86/darwin.lo \\"}, {"sha": "68165201f1e43aab503ae9b6fb6c7b56b524de55", "filename": "libffi/configure", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -10324,8 +10324,6 @@ case \"$host\" in\n \tTARGET=M68K; TARGETDIR=m68k\n \t;;\n \n-  mips64*-*)\n-\t;;\n   mips-sgi-irix5.* | mips-sgi-irix6.*)\n \tTARGET=MIPS_IRIX; TARGETDIR=mips\n \t;;"}, {"sha": "e47013f39ab3b82a5201371058bc5879f0519ebd", "filename": "libffi/configure.ac", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -94,8 +94,6 @@ case \"$host\" in\n \tTARGET=M68K; TARGETDIR=m68k\n \t;;\n \n-  mips64*-*)\n-\t;;\n   mips-sgi-irix5.* | mips-sgi-irix6.*)\n \tTARGET=MIPS_IRIX; TARGETDIR=mips\n \t;;"}, {"sha": "e93cf8ae77b1b0e9763d9ad75a05582d6c7d4691", "filename": "libffi/fficonfig.h.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -37,6 +37,9 @@\n    */\n #undef HAVE_AS_SPARC_UA_PCREL\n \n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n /* Define if __attribute__((visibility(\"hidden\"))) is supported. */\n #undef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE\n \n@@ -91,6 +94,10 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n /* Define to 1 if your C compiler doesn't accept -c and -o together. */\n #undef NO_MINUS_C_MINUS_O\n "}, {"sha": "cc2a42e7a9f5e9072348b4880a58ac7dd5d79e7b", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 313, "deletions": 56, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -28,13 +28,19 @@\n \n #include <stdlib.h>\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_DEBUG\n+# define FFI_MIPS_STOP_HERE() ffi_stop_here()\n+#else\n+# define FFI_MIPS_STOP_HERE() do {} while(0)\n+#endif\n+\n+#ifdef FFI_MIPS_N32\n #define FIX_ARGP \\\n FFI_ASSERT(argp <= &stack[bytes]); \\\n if (argp == &stack[bytes]) \\\n { \\\n   argp = stack; \\\n-  ffi_stop_here(); \\\n+  FFI_MIPS_STOP_HERE(); \\\n }\n #else\n #define FIX_ARGP \n@@ -54,7 +60,7 @@ static void ffi_prep_args(char *stack,\n   char *argp;\n   ffi_type **p_arg;\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_MIPS_N32\n   /* If more than 8 double words are used, the remainder go\n      on the stack. We reorder stuff on the stack here to \n      support this easily. */\n@@ -68,7 +74,7 @@ static void ffi_prep_args(char *stack,\n \n   memset(stack, 0, bytes);\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_MIPS_N32\n   if ( ecif->cif->rstruct_flag != 0 )\n #else\n   if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT )\n@@ -91,7 +97,7 @@ static void ffi_prep_args(char *stack,\n       if (a < sizeof(ffi_arg))\n         a = sizeof(ffi_arg);\n       \n-      if ((a - 1) & (unsigned int) argp)\n+      if ((a - 1) & (unsigned long) argp)\n \t{\n \t  argp = (char *) ALIGN(argp, a);\n \t  FIX_ARGP;\n@@ -100,9 +106,15 @@ static void ffi_prep_args(char *stack,\n       z = (*p_arg)->size;\n       if (z <= sizeof(ffi_arg))\n \t{\n+          int type = (*p_arg)->type;\n \t  z = sizeof(ffi_arg);\n \n-\t  switch ((*p_arg)->type)\n+          /* The size of a pointer depends on the ABI */\n+          if (type == FFI_TYPE_POINTER)\n+            type =\n+              (ecif->cif->abi == FFI_N64) ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n+\n+\t  switch (type)\n \t    {\n \t      case FFI_TYPE_SINT8:\n \t\t*(ffi_arg *)argp = *(SINT8 *)(* p_argv);\n@@ -125,7 +137,6 @@ static void ffi_prep_args(char *stack,\n \t\tbreak;\n \t\t  \n \t      case FFI_TYPE_UINT32:\n-\t      case FFI_TYPE_POINTER:\n \t\t*(ffi_arg *)argp = *(UINT32 *)(* p_argv);\n \t\tbreak;\n \n@@ -134,21 +145,20 @@ static void ffi_prep_args(char *stack,\n \t\t*(float *) argp = *(float *)(* p_argv);\n \t\tbreak;\n \n-\t      /* Handle small structures.  */\n-\t      case FFI_TYPE_STRUCT:\n+\t      /* Handle structures.  */\n \t      default:\n \t\tmemcpy(argp, *p_argv, (*p_arg)->size);\n \t\tbreak;\n \t    }\n \t}\n       else\n \t{\n-#if _MIPS_SIM == _ABIO32\n+#ifdef FFI_MIPS_O32\n \t  memcpy(argp, *p_argv, z);\n #else\n \t  {\n-\t    unsigned end = (unsigned) argp+z;\n-\t    unsigned cap = (unsigned) stack+bytes;\n+\t    unsigned long end = (unsigned long) argp + z;\n+\t    unsigned long cap = (unsigned long) stack + bytes;\n \n \t    /* Check if the data will fit within the register space.\n \t       Handle it if it doesn't.  */\n@@ -157,12 +167,13 @@ static void ffi_prep_args(char *stack,\n \t      memcpy(argp, *p_argv, z);\n \t    else\n \t      {\n-\t\tunsigned portion = end - cap;\n+\t\tunsigned long portion = cap - (unsigned long)argp;\n \n \t\tmemcpy(argp, *p_argv, portion);\n \t\targp = stack;\n-\t\tmemcpy(argp,\n-\t\t       (void*)((unsigned)(*p_argv)+portion), z - portion);\n+                z -= portion;\n+\t\tmemcpy(argp, (void*)((unsigned long)(*p_argv) + portion),\n+                       z);\n \t      }\n \t  }\n #endif\n@@ -173,43 +184,49 @@ static void ffi_prep_args(char *stack,\n     }\n }\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_MIPS_N32\n \n /* The n32 spec says that if \"a chunk consists solely of a double \n    float field (but not a double, which is part of a union), it\n    is passed in a floating point register. Any other chunk is\n    passed in an integer register\". This code traverses structure\n    definitions and generates the appropriate flags. */\n \n-unsigned calc_n32_struct_flags(ffi_type *arg, unsigned *shift)\n+static unsigned\n+calc_n32_struct_flags(ffi_type *arg, unsigned *loc, unsigned *arg_reg)\n {\n   unsigned flags = 0;\n   unsigned index = 0;\n \n   ffi_type *e;\n \n-  while (e = arg->elements[index])\n+  while ((e = arg->elements[index]))\n     {\n+      /* Align this object.  */\n+      *loc = ALIGN(*loc, e->alignment);\n       if (e->type == FFI_TYPE_DOUBLE)\n \t{\n-\t  flags += (FFI_TYPE_DOUBLE << *shift);\n-\t  *shift += FFI_FLAG_BITS;\n+          /* Already aligned to FFI_SIZEOF_ARG.  */\n+          *arg_reg = *loc / FFI_SIZEOF_ARG;\n+          if (*arg_reg > 7)\n+            break;\n+\t  flags += (FFI_TYPE_DOUBLE << (*arg_reg * FFI_FLAG_BITS));\n+          *loc += e->size;\n \t}\n-      else if (e->type == FFI_TYPE_STRUCT)\n-\t  flags += calc_n32_struct_flags(e, shift);\n       else\n-\t*shift += FFI_FLAG_BITS;\n-\n+        *loc += e->size;\n       index++;\n     }\n+  /* Next Argument register at alignment of FFI_SIZEOF_ARG.  */\n+  *arg_reg = ALIGN(*loc, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \n   return flags;\n }\n \n-unsigned calc_n32_return_struct_flags(ffi_type *arg)\n+static unsigned\n+calc_n32_return_struct_flags(ffi_type *arg)\n {\n   unsigned flags = 0;\n-  unsigned index = 0;\n   unsigned small = FFI_TYPE_SMALLSTRUCT;\n   ffi_type *e;\n \n@@ -228,16 +245,16 @@ unsigned calc_n32_return_struct_flags(ffi_type *arg)\n \n   e = arg->elements[0];\n   if (e->type == FFI_TYPE_DOUBLE)\n-    flags = FFI_TYPE_DOUBLE << FFI_FLAG_BITS;\n+    flags = FFI_TYPE_DOUBLE;\n   else if (e->type == FFI_TYPE_FLOAT)\n-    flags = FFI_TYPE_FLOAT << FFI_FLAG_BITS;\n+    flags = FFI_TYPE_FLOAT;\n \n   if (flags && (e = arg->elements[1]))\n     {\n       if (e->type == FFI_TYPE_DOUBLE)\n-\tflags += FFI_TYPE_DOUBLE;\n+\tflags += FFI_TYPE_DOUBLE << FFI_FLAG_BITS;\n       else if (e->type == FFI_TYPE_FLOAT)\n-\tflags += FFI_TYPE_FLOAT;\n+\tflags += FFI_TYPE_FLOAT << FFI_FLAG_BITS;\n       else \n \treturn small;\n \n@@ -262,7 +279,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n   cif->flags = 0;\n \n-#if _MIPS_SIM == _ABIO32\n+#ifdef FFI_MIPS_O32\n   /* Set the flags necessary for O32 processing.  FFI_O32_SOFT_FLOAT\n    * does not have special handling for floating point args.\n    */\n@@ -350,10 +367,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     }\n #endif\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_MIPS_N32\n   /* Set the flags necessary for N32 processing */\n   {\n-    unsigned shift = 0;\n+    unsigned arg_reg = 0;\n+    unsigned loc = 0;\n     unsigned count = (cif->nargs < 8) ? cif->nargs : 8;\n     unsigned index = 0;\n \n@@ -368,7 +386,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t    /* This means that the structure is being passed as\n \t       a hidden argument */\n \n-\t    shift = FFI_FLAG_BITS;\n+\t    arg_reg = 1;\n \t    count = (cif->nargs < 7) ? cif->nargs : 7;\n \n \t    cif->rstruct_flag = !0;\n@@ -379,23 +397,37 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     else\n       cif->rstruct_flag = 0;\n \n-    while (count-- > 0)\n+    while (count-- > 0 && arg_reg < 8)\n       {\n \tswitch ((cif->arg_types)[index]->type)\n \t  {\n \t  case FFI_TYPE_FLOAT:\n \t  case FFI_TYPE_DOUBLE:\n-\t    cif->flags += ((cif->arg_types)[index]->type << shift);\n-\t    shift += FFI_FLAG_BITS;\n+\t    cif->flags +=\n+              ((cif->arg_types)[index]->type << (arg_reg * FFI_FLAG_BITS));\n+\t    arg_reg++;\n \t    break;\n+          case FFI_TYPE_LONGDOUBLE:\n+            /* Align it.  */\n+            arg_reg = ALIGN(arg_reg, 2);\n+            /* Treat it as two adjacent doubles.  */\n+\t    cif->flags +=\n+              (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n+            arg_reg++;\n+\t    cif->flags +=\n+              (FFI_TYPE_DOUBLE << (arg_reg * FFI_FLAG_BITS));\n+            arg_reg++;\n+            break;\n \n \t  case FFI_TYPE_STRUCT:\n+            loc = arg_reg * FFI_SIZEOF_ARG;\n \t    cif->flags += calc_n32_struct_flags((cif->arg_types)[index],\n-\t\t\t\t\t\t&shift);\n+\t\t\t\t\t\t&loc, &arg_reg);\n \t    break;\n \n \t  default:\n-\t    shift += FFI_FLAG_BITS;\n+\t    arg_reg++;\n+            break;\n \t  }\n \n \tindex++;\n@@ -430,7 +462,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       case FFI_TYPE_DOUBLE:\n \tcif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);\n \tbreak;\n-\t\n+\n       default:\n \tcif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);\n \tbreak;\n@@ -469,18 +501,33 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     \n   switch (cif->abi) \n     {\n-#if _MIPS_SIM == _ABIO32\n+#ifdef FFI_MIPS_O32\n     case FFI_O32:\n     case FFI_O32_SOFT_FLOAT:\n       ffi_call_O32(ffi_prep_args, &ecif, cif->bytes, \n \t\t   cif->flags, ecif.rvalue, fn);\n       break;\n #endif\n \n-#if _MIPS_SIM == _ABIN32\n+#ifdef FFI_MIPS_N32\n     case FFI_N32:\n-      ffi_call_N32(ffi_prep_args, &ecif, cif->bytes, \n-\t\t   cif->flags, ecif.rvalue, fn);\n+    case FFI_N64:\n+      {\n+        int copy_rvalue = 0;\n+        void *rvalue_copy = ecif.rvalue;\n+        if (cif->rtype->type == FFI_TYPE_STRUCT && cif->rtype->size < 16)\n+          {\n+            /* For structures smaller than 16 bytes we clobber memory\n+               in 8 byte increments.  Make a copy so we don't clobber\n+               the callers memory outside of the struct bounds.  */\n+            rvalue_copy = alloca(16);\n+            copy_rvalue = 1;\n+          }\n+        ffi_call_N32(ffi_prep_args, &ecif, cif->bytes,\n+                     cif->flags, rvalue_copy, fn);\n+        if (copy_rvalue)\n+          memcpy(ecif.rvalue, rvalue_copy, cif->rtype->size);\n+      }\n       break;\n #endif\n \n@@ -490,9 +537,11 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     }\n }\n \n-#if FFI_CLOSURES  /* N32 not implemented yet, FFI_CLOSURES not defined */\n+#if FFI_CLOSURES\n #if defined(FFI_MIPS_O32)\n extern void ffi_closure_O32(void);\n+#else\n+extern void ffi_closure_N32(void);\n #endif /* FFI_MIPS_O32 */\n \n ffi_status\n@@ -503,23 +552,58 @@ ffi_prep_closure_loc (ffi_closure *closure,\n \t\t      void *codeloc)\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n-  unsigned int fn;\n-  unsigned int ctx = (unsigned int) codeloc;\n+  void * fn;\n   char *clear_location = (char *) codeloc;\n \n #if defined(FFI_MIPS_O32)\n   FFI_ASSERT(cif->abi == FFI_O32 || cif->abi == FFI_O32_SOFT_FLOAT);\n-  fn = (unsigned int) ffi_closure_O32;\n+  fn = ffi_closure_O32;\n #else /* FFI_MIPS_N32 */\n-  FFI_ASSERT(cif->abi == FFI_N32);\n-  FFI_ASSERT(!\"not implemented\");\n+  FFI_ASSERT(cif->abi == FFI_N32 || cif->abi == FFI_N64);\n+  fn = ffi_closure_N32;\n #endif /* FFI_MIPS_O32 */\n \n-  tramp[0] = 0x3c190000 | (fn >> 16);     /* lui  $25,high(fn) */\n-  tramp[1] = 0x37390000 | (fn & 0xffff);  /* ori  $25,low(fn)  */\n-  tramp[2] = 0x3c080000 | (ctx >> 16);    /* lui  $8,high(ctx) */\n-  tramp[3] = 0x03200008;                  /* jr   $25          */\n-  tramp[4] = 0x35080000 | (ctx & 0xffff); /* ori  $8,low(ctx)  */\n+#if defined(FFI_MIPS_O32) || (_MIPS_SIM ==_ABIN32)\n+  /* lui  $25,high(fn) */\n+  tramp[0] = 0x3c190000 | ((unsigned)fn >> 16);\n+  /* ori  $25,low(fn)  */\n+  tramp[1] = 0x37390000 | ((unsigned)fn & 0xffff);\n+  /* lui  $12,high(codeloc) */\n+  tramp[2] = 0x3c0c0000 | ((unsigned)codeloc >> 16);\n+  /* jr   $25          */\n+  tramp[3] = 0x03200008;\n+  /* ori  $12,low(codeloc)  */\n+  tramp[4] = 0x358c0000 | ((unsigned)codeloc & 0xffff);\n+#else\n+  /* N64 has a somewhat larger trampoline.  */\n+  /* lui  $25,high(fn) */\n+  tramp[0] = 0x3c190000 | ((unsigned long)fn >> 48);\n+  /* lui  $12,high(codeloc) */\n+  tramp[1] = 0x3c0c0000 | ((unsigned long)codeloc >> 48);\n+  /* ori  $25,mid-high(fn)  */\n+  tramp[2] = 0x37390000 | (((unsigned long)fn >> 32 ) & 0xffff);\n+  /* ori  $12,mid-high(codeloc)  */\n+  tramp[3] = 0x358c0000 | (((unsigned long)codeloc >> 32) & 0xffff);\n+  /* dsll $25,$25,16 */\n+  tramp[4] = 0x0019cc38;\n+  /* dsll $12,$12,16 */\n+  tramp[5] = 0x000c6438;\n+  /* ori  $25,mid-low(fn)  */\n+  tramp[6] = 0x37390000 | (((unsigned long)fn >> 16 ) & 0xffff);\n+  /* ori  $12,mid-low(codeloc)  */\n+  tramp[7] = 0x358c0000 | (((unsigned long)codeloc >> 16) & 0xffff);\n+  /* dsll $25,$25,16 */\n+  tramp[8] = 0x0019cc38;\n+  /* dsll $12,$12,16 */\n+  tramp[9] = 0x000c6438;\n+  /* ori  $25,low(fn)  */\n+  tramp[10] = 0x37390000 | ((unsigned long)fn  & 0xffff);\n+  /* jr   $25          */\n+  tramp[11] = 0x03200008;\n+  /* ori  $12,low(codeloc)  */\n+  tramp[12] = 0x358c0000 | ((unsigned long)codeloc & 0xffff);\n+\n+#endif\n \n   closure->cif = cif;\n   closure->fun = fun;\n@@ -567,7 +651,7 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \n   if ((cif->flags >> (FFI_FLAG_BITS * 2)) == FFI_TYPE_STRUCT)\n     {\n-      rvalue = (void *) ar[0];\n+      rvalue = (void *)(UINT32)ar[0];\n       argn = 1;\n     }\n \n@@ -645,4 +729,177 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n     }\n }\n \n+#if defined(FFI_MIPS_N32)\n+\n+static void\n+copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,\n+                int argn, unsigned arg_offset, ffi_arg *ar,\n+                ffi_arg *fpr)\n+{\n+  ffi_type **elt_typep = type->elements;\n+  while(*elt_typep)\n+    {\n+      ffi_type *elt_type = *elt_typep;\n+      unsigned o;\n+      char *tp;\n+      char *argp;\n+      char *fpp;\n+\n+      o = ALIGN(offset, elt_type->alignment);\n+      arg_offset += o - offset;\n+      offset = o;\n+      argn += arg_offset / sizeof(ffi_arg);\n+      arg_offset = arg_offset % sizeof(ffi_arg);\n+\n+      argp = (char *)(ar + argn);\n+      fpp = (char *)(argn >= 8 ? ar + argn : fpr + argn);\n+\n+      tp = target + offset;\n+\n+      if (elt_type->type == FFI_TYPE_DOUBLE)\n+        *(double *)tp = *(double *)fpp;\n+      else\n+        memcpy(tp, argp + arg_offset, elt_type->size);\n+\n+      offset += elt_type->size;\n+      arg_offset += elt_type->size;\n+      elt_typep++;\n+      argn += arg_offset / sizeof(ffi_arg);\n+      arg_offset = arg_offset % sizeof(ffi_arg);\n+    }\n+}\n+\n+/*\n+ * Decodes the arguments to a function, which will be stored on the\n+ * stack. AR is the pointer to the beginning of the integer\n+ * arguments. FPR is a pointer to the area where floating point\n+ * registers have been saved.\n+ *\n+ * RVALUE is the location where the function return value will be\n+ * stored. CLOSURE is the prepared closure to invoke.\n+ *\n+ * This function should only be called from assembly, which is in\n+ * turn called from a trampoline.\n+ *\n+ * Returns the function return flags.\n+ *\n+ */\n+int\n+ffi_closure_mips_inner_N32 (ffi_closure *closure,\n+\t\t\t    void *rvalue, ffi_arg *ar,\n+\t\t\t    ffi_arg *fpr)\n+{\n+  ffi_cif *cif;\n+  void **avaluep;\n+  ffi_arg *avalue;\n+  ffi_type **arg_types;\n+  int i, avn, argn;\n+\n+  cif = closure->cif;\n+  avalue = alloca (cif->nargs * sizeof (ffi_arg));\n+  avaluep = alloca (cif->nargs * sizeof (ffi_arg));\n+\n+  argn = 0;\n+\n+  if (cif->rstruct_flag)\n+    {\n+#if _MIPS_SIM==_ABIN32\n+      rvalue = (void *)(UINT32)ar[0];\n+#else /* N64 */\n+      rvalue = (void *)ar[0];\n+#endif\n+      argn = 1;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n+  while (i < avn)\n+    {\n+      if (arg_types[i]->type == FFI_TYPE_FLOAT\n+          || arg_types[i]->type == FFI_TYPE_DOUBLE)\n+        {\n+          ffi_arg *argp = argn >= 8 ? ar + argn : fpr + argn;\n+#ifdef __MIPSEB__\n+          if (arg_types[i]->type == FFI_TYPE_FLOAT && argn < 8)\n+            avaluep[i] = ((char *) argp) + sizeof (float);\n+          else\n+#endif\n+            avaluep[i] = (char *) argp;\n+        }\n+      else\n+        {\n+          unsigned type = arg_types[i]->type;\n+\n+          if (arg_types[i]->alignment > sizeof(ffi_arg))\n+            argn = ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));\n+\n+          ffi_arg *argp = ar + argn;\n+\n+          /* The size of a pointer depends on the ABI */\n+          if (type == FFI_TYPE_POINTER)\n+            type = (cif->abi == FFI_N64) ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;\n+\n+          switch (type)\n+            {\n+            case FFI_TYPE_SINT8:\n+              avaluep[i] = &avalue[i];\n+              *(SINT8 *) &avalue[i] = (SINT8) *argp;\n+              break;\n+\n+            case FFI_TYPE_UINT8:\n+              avaluep[i] = &avalue[i];\n+              *(UINT8 *) &avalue[i] = (UINT8) *argp;\n+              break;\n+\n+            case FFI_TYPE_SINT16:\n+              avaluep[i] = &avalue[i];\n+              *(SINT16 *) &avalue[i] = (SINT16) *argp;\n+              break;\n+\n+            case FFI_TYPE_UINT16:\n+              avaluep[i] = &avalue[i];\n+              *(UINT16 *) &avalue[i] = (UINT16) *argp;\n+              break;\n+\n+            case FFI_TYPE_SINT32:\n+              avaluep[i] = &avalue[i];\n+              *(SINT32 *) &avalue[i] = (SINT32) *argp;\n+              break;\n+\n+            case FFI_TYPE_UINT32:\n+              avaluep[i] = &avalue[i];\n+              *(UINT32 *) &avalue[i] = (UINT32) *argp;\n+              break;\n+\n+            case FFI_TYPE_STRUCT:\n+              if (argn < 8)\n+                {\n+                  /* Allocate space for the struct as at least part of\n+                     it was passed in registers.  */\n+                  avaluep[i] = alloca(arg_types[i]->size);\n+                  copy_struct_N32(avaluep[i], 0, cif->abi, arg_types[i],\n+                                  argn, 0, ar, fpr);\n+\n+                  break;\n+                }\n+              /* Else fall through.  */\n+            default:\n+              avaluep[i] = (char *) argp;\n+              break;\n+            }\n+        }\n+      argn += ALIGN(arg_types[i]->size, sizeof(ffi_arg)) / sizeof(ffi_arg);\n+      i++;\n+    }\n+\n+  /* Invoke the closure. */\n+  (closure->fun) (cif, rvalue, avaluep, closure->user_data);\n+\n+  return cif->flags >> (FFI_FLAG_BITS * 8);\n+}\n+\n+#endif /* FFI_MIPS_N32 */\n+\n #endif /* FFI_CLOSURES */"}, {"sha": "08f03c3e42a3c202bad15b7bef3a0a580fefecc5", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -104,19 +104,28 @@\n #define ra $31\t\t\n \n #ifdef FFI_MIPS_O32\n-#define REG_L\tlw\n-#define REG_S\tsw\n-#define SUBU\tsubu\n-#define ADDU\taddu\n-#define SRL\tsrl\n-#define LI\tli\n+# define REG_L\tlw\n+# define REG_S\tsw\n+# define SUBU\tsubu\n+# define ADDU\taddu\n+# define SRL\tsrl\n+# define LI\tli\n #else /* !FFI_MIPS_O32 */\n-#define REG_L\tld\n-#define REG_S\tsd\n-#define SUBU\tdsubu\n-#define ADDU\tdaddu\n-#define SRL\tdsrl\n-#define LI \tdli\n+# define REG_L\tld\n+# define REG_S\tsd\n+# define SUBU\tdsubu\n+# define ADDU\tdaddu\n+# define SRL\tdsrl\n+# define LI \tdli\n+# if (_MIPS_SIM==_ABI64)\n+#  define LA dla\n+#  define EH_FRAME_ALIGN 3\n+#  define FDE_ADDR_BYTES .8byte\n+# else\n+#  define LA la\n+#  define EH_FRAME_ALIGN 2\n+#  define FDE_ADDR_BYTES .4byte\n+# endif /* _MIPS_SIM==_ABI64 */\n #endif /* !FFI_MIPS_O32 */\n #else /* !LIBFFI_ASM */\n #ifdef FFI_MIPS_O32\n@@ -143,7 +152,11 @@ typedef enum ffi_abi {\n   FFI_DEFAULT_ABI = FFI_O32,\n #endif\n #else\n+# if _MIPS_SIM==_ABI64\n+  FFI_DEFAULT_ABI = FFI_N64,\n+# else\n   FFI_DEFAULT_ABI = FFI_N32,\n+# endif\n #endif\n \n   FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n@@ -158,8 +171,13 @@ typedef enum ffi_abi {\n #define FFI_CLOSURES 1\n #define FFI_TRAMPOLINE_SIZE 20\n #else\n-/* N32/N64 not implemented yet. */\n-#define FFI_CLOSURES 0\n+/* N32/N64. */\n+# define FFI_CLOSURES 1\n+#if _MIPS_SIM==_ABI64\n+#define FFI_TRAMPOLINE_SIZE 52\n+#else\n+#define FFI_TRAMPOLINE_SIZE 20\n+#endif\n #endif /* FFI_MIPS_O32 */\n #define FFI_NATIVE_RAW_API 0\n "}, {"sha": "ff268c6a173ad43147e1baa223532cbd71dd4866", "filename": "libffi/src/mips/n32.S", "status": "modified", "additions": 225, "deletions": 1, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fn32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fn32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fn32.S?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -45,13 +45,19 @@\n \t.globl\tffi_call_N32\n \t.ent\tffi_call_N32\n ffi_call_N32:\t\n+.LFB3:\n+\t.frame\t$fp, SIZEOF_FRAME, ra\n+\t.mask\t0xc0000000,-FFI_SIZEOF_ARG\n+\t.fmask\t0x00000000,0\n \n \t# Prologue\n \tSUBU\t$sp, SIZEOF_FRAME\t\t\t# Frame size\n+.LCFI0:\n \tREG_S\t$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp)\t# Save frame pointer\n \tREG_S\tra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)\t# Save return address\n+.LCFI1:\n \tmove\t$fp, $sp\n-\n+.LCFI3:\n \tmove\tt9, callback\t# callback function pointer\n \tREG_S\tbytes, 2*FFI_SIZEOF_ARG($fp) # bytes\n \tREG_S\tflags, 3*FFI_SIZEOF_ARG($fp) # flags\n@@ -315,6 +321,224 @@ epilogue:\n \tADDU\t$sp, SIZEOF_FRAME\t\t      # Fix stack pointer\n \tj\tra\n \n+.LFE3:\n \t.end\tffi_call_N32\n+\n+/* ffi_closure_N32. Expects address of the passed-in ffi_closure in t0\n+   ($12). Stores any arguments passed in registers onto the stack,\n+   then calls ffi_closure_mips_inner_N32, which then decodes\n+   them.\n+\t\n+\tStack layout:\n+\n+\t20 - Start of parameters, original sp\n+\t19 - Called function a7 save\n+\t18 - Called function a6 save\n+\t17 - Called function a5 save\n+\t16 - Called function a4 save\n+\t15 - Called function a3 save\n+\t14 - Called function a2 save\n+\t13 - Called function a1 save\n+\t12 - Called function a0 save\n+\t11 - Called function f19\n+\t10 - Called function f18\n+\t 9 - Called function f17\n+\t 8 - Called function f16\n+\t 7 - Called function f15\n+         6 - Called function f14\n+         5 - Called function f13\n+         4 - Called function f12\n+\t 3 - return value high (v1 or $f2)\n+\t 2 - return value low (v0 or $f0)\n+\t 1 - ra save\n+\t 0 - gp save our sp  points here\n+\t */\n+\n+#define SIZEOF_FRAME2\t(20 * FFI_SIZEOF_ARG)\n+\t\n+#define A7_OFF2\t\t(19 * FFI_SIZEOF_ARG)\n+#define A6_OFF2\t\t(18 * FFI_SIZEOF_ARG)\n+#define A5_OFF2\t\t(17 * FFI_SIZEOF_ARG)\n+#define A4_OFF2\t\t(16 * FFI_SIZEOF_ARG)\n+#define A3_OFF2\t\t(15 * FFI_SIZEOF_ARG)\n+#define A2_OFF2\t\t(14 * FFI_SIZEOF_ARG)\n+#define A1_OFF2\t\t(13 * FFI_SIZEOF_ARG)\n+#define A0_OFF2\t\t(12 * FFI_SIZEOF_ARG)\t\n+\n+#define F19_OFF2\t(11 * FFI_SIZEOF_ARG)\n+#define F18_OFF2\t(10 * FFI_SIZEOF_ARG)\n+#define F17_OFF2\t(9  * FFI_SIZEOF_ARG)\n+#define F16_OFF2\t(8  * FFI_SIZEOF_ARG)\n+#define F15_OFF2\t(7  * FFI_SIZEOF_ARG)\n+#define F14_OFF2\t(6  * FFI_SIZEOF_ARG)\n+#define F13_OFF2\t(5  * FFI_SIZEOF_ARG)\n+#define F12_OFF2\t(4  * FFI_SIZEOF_ARG)\n+\n+#define V1_OFF2\t\t(3  * FFI_SIZEOF_ARG)\n+#define V0_OFF2\t\t(2  * FFI_SIZEOF_ARG)\n+\n+#define RA_OFF2\t\t(1  * FFI_SIZEOF_ARG)\n+#define GP_OFF2\t\t(0  * FFI_SIZEOF_ARG)\n+\n+\t.align\t2\n+\t.globl\tffi_closure_N32\n+\t.ent\tffi_closure_N32\n+ffi_closure_N32:\n+.LFB2:\n+\t.frame\t$sp, SIZEOF_FRAME2, ra\n+\t.mask\t0x90000000,-(SIZEOF_FRAME2 - RA_OFF2)\n+\t.fmask\t0x00000000,0\n+\tSUBU\t$sp, SIZEOF_FRAME2\n+.LCFI5:\n+\t.cpsetup t9, GP_OFF2, ffi_closure_N32\n+\tREG_S\tra, RA_OFF2($sp)\t# Save return address\n+.LCFI6:\n+\t# Store all possible argument registers. If there are more than\n+\t# fit in registers, then they were stored on the stack.\n+\tREG_S\ta0, A0_OFF2($sp)\n+\tREG_S\ta1, A1_OFF2($sp)\n+\tREG_S\ta2, A2_OFF2($sp)\n+\tREG_S\ta3, A3_OFF2($sp)\n+\tREG_S\ta4, A4_OFF2($sp)\n+\tREG_S\ta5, A5_OFF2($sp)\n+\tREG_S\ta6, A6_OFF2($sp)\n+\tREG_S\ta7, A7_OFF2($sp)\n+\n+\t# Store all possible float/double registers.\n+\ts.d\t$f12, F12_OFF2($sp)\n+\ts.d\t$f13, F13_OFF2($sp)\n+\ts.d\t$f14, F14_OFF2($sp)\n+\ts.d\t$f15, F15_OFF2($sp)\n+\ts.d\t$f16, F16_OFF2($sp)\n+\ts.d\t$f17, F17_OFF2($sp)\n+\ts.d\t$f18, F18_OFF2($sp)\n+\ts.d\t$f19, F19_OFF2($sp)\n+\n+\t# Call ffi_closure_mips_inner_N32 to do the real work.\n+\tLA\tt9, ffi_closure_mips_inner_N32\n+\tmove\ta0, $12\t # Pointer to the ffi_closure\n+\taddu\ta1, $sp, V0_OFF2\n+\taddu\ta2, $sp, A0_OFF2\n+\taddu\ta3, $sp, F12_OFF2\n+\tjalr\tt9\n+\n+\t# Return flags are in v0\n+\tbne     v0, FFI_TYPE_INT, cls_retfloat\n+\tREG_L\tv0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\n+cls_retfloat:\n+\tbne     v0, FFI_TYPE_FLOAT, cls_retdouble\n+\tl.s\t$f0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\n+cls_retdouble:\t\n+\tbne\tv0, FFI_TYPE_DOUBLE, cls_retstruct_d\n+\tl.d\t$f0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\n+cls_retstruct_d:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_D, cls_retstruct_f\n+\tl.d\t$f0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_f:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_F, cls_retstruct_d_d\n+\tl.s\t$f0, V0_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_d_d:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_DD, cls_retstruct_f_f\n+\tl.d\t$f0, V0_OFF2($sp)\n+\tl.d\t$f2, V1_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_f_f:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_FF, cls_retstruct_d_f\n+\tl.s\t$f0, V0_OFF2($sp)\n+\tl.s\t$f2, V1_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_d_f:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_DF, cls_retstruct_f_d\n+\tl.d\t$f0, V0_OFF2($sp)\n+\tl.s\t$f2, V1_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_f_d:\t\n+\tbne\tv0, FFI_TYPE_STRUCT_FD, cls_retstruct_small2\n+\tl.s\t$f0, V0_OFF2($sp)\n+\tl.d\t$f2, V1_OFF2($sp)\n+\tb\tcls_epilogue\n+\t\n+cls_retstruct_small2:\t\n+\tREG_L\tv0, V0_OFF2($sp)\n+\tREG_L\tv1, V1_OFF2($sp)\n+\t\n+\t# Epilogue\n+cls_epilogue:\t\n+\tREG_L\tra,  RA_OFF2($sp)\t # Restore return address\n+\t.cpreturn\n+\tADDU\t$sp, SIZEOF_FRAME2\n+\tj\tra\n+.LFE2:\t\n+\t.end\tffi_closure_N32\n+\n+        .section        .eh_frame,\"aw\",@progbits\n+.Lframe1:\n+        .4byte  .LECIE1-.LSCIE1\t\t# length\n+.LSCIE1:\n+        .4byte  0x0\t\t\t# CIE\n+        .byte   0x1\t\t\t# Version 1\n+        .ascii  \"\\000\"\t\t\t# Augmentation\n+        .uleb128 0x1\t\t\t# Code alignment 1\n+        .sleb128 -4\t\t\t# Data alignment -4\n+        .byte   0x1f\t\t\t# Return Address $31\n+        .byte   0xc\t\t\t# DW_CFA_def_cfa\n+        .uleb128 0x1d\t\t\t# in $sp\n+        .uleb128 0x0\t\t\t# offset 0\n+        .align  EH_FRAME_ALIGN\n+.LECIE1:\n+\n+.LSFDE1:\n+        .4byte  .LEFDE1-.LASFDE1\t# length.\n+.LASFDE1:\n+        .4byte  .LASFDE1-.Lframe1\t# CIE_pointer.\n+        FDE_ADDR_BYTES  .LFB3\t\t# initial_location.\n+        FDE_ADDR_BYTES  .LFE3-.LFB3\t# address_range.\n+        .byte   0x4\t\t\t# DW_CFA_advance_loc4\n+        .4byte  .LCFI0-.LFB3\t\t# to .LCFI0\n+        .byte   0xe\t\t\t# DW_CFA_def_cfa_offset\n+        .uleb128 SIZEOF_FRAME\t\t# adjust stack.by SIZEOF_FRAME\n+        .byte   0x4\t\t\t# DW_CFA_advance_loc4\n+        .4byte  .LCFI1-.LCFI0\t\t# to .LCFI1\n+        .byte   0x9e\t\t\t# DW_CFA_offset of $fp\n+        .uleb128 2*FFI_SIZEOF_ARG/4\t# \n+        .byte   0x9f\t\t\t# DW_CFA_offset of ra\n+        .uleb128 1*FFI_SIZEOF_ARG/4\t# \n+        .byte   0x4\t\t\t# DW_CFA_advance_loc4\n+        .4byte  .LCFI3-.LCFI1\t\t# to .LCFI3\n+        .byte   0xd\t\t\t# DW_CFA_def_cfa_register\n+        .uleb128 0x1e\t\t\t# in $fp\n+        .align  EH_FRAME_ALIGN\n+.LEFDE1:\n+.LSFDE3:\n+\t.4byte\t.LEFDE3-.LASFDE3\t# length\n+.LASFDE3:\n+\t.4byte\t.LASFDE3-.Lframe1\t# CIE_pointer.\n+\tFDE_ADDR_BYTES\t.LFB2\t\t# initial_location.\n+\tFDE_ADDR_BYTES\t.LFE2-.LFB2\t# address_range.\n+\t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI5-.LFB2\t\t# to .LCFI5\n+\t.byte\t0xe\t\t\t# DW_CFA_def_cfa_offset\n+\t.uleb128 SIZEOF_FRAME2\t\t# adjust stack.by SIZEOF_FRAME\n+\t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI6-.LCFI5\t\t# to .LCFI6\n+\t.byte\t0x9c\t\t\t# DW_CFA_offset of $gp ($28)\n+\t.uleb128 (SIZEOF_FRAME2 - GP_OFF2)/4\n+\t.byte\t0x9f\t\t\t# DW_CFA_offset of ra ($31)\n+\t.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4\n+\t.align\tEH_FRAME_ALIGN\n+.LEFDE3:\n \t\n #endif"}, {"sha": "f6363cb6c54854350e1033811f8eeb92bf6ee342", "filename": "libffi/src/mips/o32.S", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fo32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb/libffi%2Fsrc%2Fmips%2Fo32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fo32.S?ref=89d9d98ae5337a4c32ffe3c3b4be59b2ce3f2ddb", "patch": "@@ -183,27 +183,30 @@ $LFE0:\n \n \n /* ffi_closure_O32. Expects address of the passed-in ffi_closure\n-\tin t0. Stores any arguments passed in registers onto the\n+\tin t4 ($12). Stores any arguments passed in registers onto the\n \tstack, then calls ffi_closure_mips_inner_O32, which\n \tthen decodes them.\n \t\n \tStack layout:\n \n-\t14 - Start of parameters, original sp\n-\t13 - ra save\n-\t12 - fp save\n-\t11 - $16 (s0) save\n-\t10 - cprestore\n-\t 9 - return value high (v1)\n-\t 8 - return value low (v0)\n-\t 7 - f14 (le high, be low)\n-\t 6 - f14 (le low, be high)\n-\t 5 - f12 (le high, be low)\n-\t 4 - f12 (le low, be high)\n-\t 3 - Called function a3 save\n-\t 2 - Called function a2 save\n-\t 1 - Called function a1 save\n-\t 0 - Called function a0 save our sp, fp point here\n+\t 3 - a3 save\n+\t 2 - a2 save\n+\t 1 - a1 save\n+\t 0 - a0 save, original sp\n+\t-1 - ra save\n+\t-2 - fp save\n+\t-3 - $16 (s0) save\n+\t-4 - cprestore\n+\t-5 - return value high (v1)\n+\t-6 - return value low (v0)\n+\t-7 - f14 (le high, be low)\n+\t-8 - f14 (le low, be high)\n+\t-9 - f12 (le high, be low)\n+       -10 - f12 (le low, be high)\n+       -11 - Called function a3 save\n+       -12 - Called function a2 save\n+       -13 - Called function a1 save\n+       -14 - Called function a0 save, our sp and fp point here\n \t */\n \t\n #define SIZEOF_FRAME2\t(14 * FFI_SIZEOF_ARG)\n@@ -251,7 +254,7 @@ $LCFI7:\n \tREG_S\ta3, A3_OFF2($fp)\n \n \t# Load ABI enum to s0\n-\tREG_L\t$16, 20($8)\t# cif pointer follows tramp.\n+\tREG_L\t$16, 20($12)\t# cif pointer follows tramp.\n \tREG_L\t$16, 0($16)\t# abi is first member.\n \n \tli\t$13, 1\t\t# FFI_O32\n@@ -263,7 +266,7 @@ $LCFI7:\n 1:\t\n \t# Call ffi_closure_mips_inner_O32 to do the work.\n \tla\tt9, ffi_closure_mips_inner_O32\n-\tmove\ta0, $8\t # Pointer to the ffi_closure\n+\tmove\ta0, $12\t # Pointer to the ffi_closure\n \taddu\ta1, $fp, V0_OFF2\n \taddu\ta2, $fp, A0_OFF2\n \taddu\ta3, $fp, FA_0_0_OFF2"}]}