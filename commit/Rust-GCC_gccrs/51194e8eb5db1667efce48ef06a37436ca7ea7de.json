{"sha": "51194e8eb5db1667efce48ef06a37436ca7ea7de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTExOTRlOGViNWRiMTY2N2VmY2U0OGVmMDZhMzc0MzZjYTdlYTdkZQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-15T22:27:39Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-15T22:27:39Z"}, "message": "In libobjc/: 2010-10-15 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-private/runtime.h (__objc_update_classes_with_methods): New.\n        * class.c (__objc_update_classes_with_methods): New.\n        (objc_getClassList): Do not lock the class lock.\n        * methods.c (method_exchangeImplementations): New.\n        (method_setImplementation): New.\n        * objc/runtime.h (method_setImplementation): New.\n        (method_exchangeImplementations): New.\n\nFrom-SVN: r165525", "tree": {"sha": "4a6954b1f7b91675bedaa8e8b7d3351ee0f9d7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a6954b1f7b91675bedaa8e8b7d3351ee0f9d7d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51194e8eb5db1667efce48ef06a37436ca7ea7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51194e8eb5db1667efce48ef06a37436ca7ea7de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51194e8eb5db1667efce48ef06a37436ca7ea7de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51194e8eb5db1667efce48ef06a37436ca7ea7de/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef7659966d956c7dcb34fad217fffafc1911f69d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef7659966d956c7dcb34fad217fffafc1911f69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef7659966d956c7dcb34fad217fffafc1911f69d"}], "stats": {"total": 146, "additions": 141, "deletions": 5}, "files": [{"sha": "0561f88d15e99f81c44d9dfb74bf82ce6c0efcb6", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=51194e8eb5db1667efce48ef06a37436ca7ea7de", "patch": "@@ -1,3 +1,13 @@\n+2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-private/runtime.h (__objc_update_classes_with_methods): New.\n+\t* class.c (__objc_update_classes_with_methods): New.\n+\t(objc_getClassList): Do not lock the class lock.\n+\t* methods.c (method_exchangeImplementations): New.\n+\t(method_setImplementation): New.\n+\t* objc/runtime.h (method_setImplementation): New.\n+\t(method_exchangeImplementations): New.\n+\t\n 2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Protocol.m: Include objc/runtime.h and"}, {"sha": "8c6f989a8e9bfee366b3119c5ef026909fddadf7", "filename": "libobjc/class.c", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=51194e8eb5db1667efce48ef06a37436ca7ea7de", "patch": "@@ -93,6 +93,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc/thr.h\"\n #include \"objc-private/module-abi-8.h\"  /* For CLS_ISCLASS and similar.  */\n #include \"objc-private/runtime.h\"       /* the kitchen sink */\n+#include \"objc-private/sarray.h\"        /* For sarray_put_at_safe.  */\n #include <string.h>                     /* For memset */\n \n /* We use a table which maps a class name to the corresponding class\n@@ -546,8 +547,6 @@ objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn)\n   /* Iterate over all entries in the table.  */\n   int hash, count = 0;\n \n-  objc_mutex_lock (__class_table_lock); \n-\n   for (hash = 0; hash < CLASS_TABLE_SIZE; hash++)\n     {\n       class_node_ptr node = class_table_array[hash];\n@@ -560,7 +559,6 @@ objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn)\n \t\treturnValue[count] = node->pointer;\n \t      else\n \t\t{\n-\t\t  objc_mutex_unlock (__class_table_lock);\n \t\t  return count;\n \t\t}\n \t    }\n@@ -569,7 +567,6 @@ objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn)\n \t}\n     }\n   \n-  objc_mutex_unlock (__class_table_lock);\n   return count;\n }\n \n@@ -647,6 +644,62 @@ objc_next_class (void **enum_state)\n   return class;\n }\n \n+/* This is used when the implementation of a method changes.  It goes\n+   through all classes, looking for the ones that have these methods\n+   (either method_a or method_b; method_b can be NULL), and reloads\n+   the implementation for these.  You should call this with the\n+   runtime mutex already locked.  */\n+void\n+__objc_update_classes_with_methods (struct objc_method *method_a, struct objc_method *method_b)\n+{\n+  int hash;\n+\n+  /* Iterate over all classes.  */\n+  for (hash = 0; hash < CLASS_TABLE_SIZE; hash++)\n+    {\n+      class_node_ptr node = class_table_array[hash];\n+      \n+      while (node != NULL)\n+\t{\n+\t  /* Iterate over all methods in the class.  */\n+\t  Class class = node->pointer;\n+\t  struct objc_method_list * method_list = class->methods;\n+\n+\t  while (method_list)\n+\t    {\n+\t      int i;\n+\n+\t      for (i = 0; i < method_list->method_count; ++i)\n+\t\t{\n+\t\t  struct objc_method *method = &method_list->method_list[i];\n+\n+\t\t  /* If the method is one of the ones we are looking\n+\t\t     for, update the implementation.  */\n+\t\t  if (method == method_a)\n+\t\t    {\n+\t\t      sarray_at_put_safe (class->dtable,\n+\t\t\t\t\t  (sidx) method_a->method_name->sel_id,\n+\t\t\t\t\t  method_a->method_imp);\n+\t\t    }\n+\n+\t\t  if (method == method_b)\n+\t\t    {\n+\t\t      if (method_b != NULL)\n+\t\t\t{\n+\t\t\t  sarray_at_put_safe (class->dtable,\n+\t\t\t\t\t      (sidx) method_b->method_name->sel_id,\n+\t\t\t\t\t      method_b->method_imp);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t  \n+\t      method_list = method_list->method_next;\n+\t    }\n+\t  node = node->next;\n+\t}\n+    }\n+}\n+\n /* Resolve super/subclass links for all classes.  The only thing we\n    can be sure of is that the class_pointer for class objects point to\n    the right meta class objects.  */"}, {"sha": "b4faee533c28a008f6b7ad75035a833f21399c4b", "filename": "libobjc/methods.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fmethods.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fmethods.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmethods.c?ref=51194e8eb5db1667efce48ef06a37436ca7ea7de", "patch": "@@ -124,3 +124,54 @@ class_copyMethodList (Class class_, unsigned int *numberOfReturnedMethods)\n \n   return returnValue;\n }\n+\n+IMP\n+method_setImplementation (struct objc_method * method, IMP implementation)\n+{\n+  IMP old_implementation;\n+\n+  if (method == NULL  ||  implementation == NULL)\n+    return NULL;\n+\n+  /* We lock the runtime mutex so that concurrent calls to change the\n+     same method won't conflict with each other.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  old_implementation = method->method_imp;\n+  method->method_imp = implementation;\n+\n+  /* That was easy :-).  But now we need to find all classes that use\n+     this method, and update the IMP in the dispatch tables.  */\n+  __objc_update_classes_with_methods (method, NULL);\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+\n+  return old_implementation;\n+}\n+\n+void\n+method_exchangeImplementations (struct objc_method * method_a, struct objc_method * method_b)\n+{\n+  IMP old_implementation_a;\n+  IMP old_implementation_b;\n+\n+  if (method_a == NULL  ||  method_b == NULL)\n+    return;\n+\n+  /* We lock the runtime mutex so that concurrent calls to exchange\n+     similar methods won't conflict with each other.  Each of them\n+     should be atomic.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  old_implementation_a = method_a->method_imp;\n+  old_implementation_b = method_b->method_imp;\n+\n+  method_a->method_imp = old_implementation_b;\n+  method_b->method_imp = old_implementation_a;\n+\n+  /* That was easy :-).  But now we need to find all classes that use\n+     these methods, and update the IMP in the dispatch tables.  */\n+  __objc_update_classes_with_methods (method_a, method_b);\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+}"}, {"sha": "ff924becd937f74477ac67ee86edf843b5d94aef", "filename": "libobjc/objc-private/runtime.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fobjc-private%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fobjc-private%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fruntime.h?ref=51194e8eb5db1667efce48ef06a37436ca7ea7de", "patch": "@@ -74,6 +74,9 @@ extern void class_add_method_list(Class, struct objc_method_list *);\n extern void __objc_register_instance_methods_to_class(Class);\n extern struct objc_method * search_for_method_in_list(struct objc_method_list * list, SEL op);\n \n+extern void\n+__objc_update_classes_with_methods (struct objc_method *method_a, struct objc_method *method_b); /* class.c */\n+\n /* True when class links has been resolved */     \n extern BOOL __objc_class_links_resolved;\n "}, {"sha": "bb241acd5b33f198039c8b66358f8f7e231c5368", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51194e8eb5db1667efce48ef06a37436ca7ea7de/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=51194e8eb5db1667efce48ef06a37436ca7ea7de", "patch": "@@ -545,7 +545,26 @@ objc_EXPORT void method_getReturnType (Method method, char *returnValue,\n objc_EXPORT void method_getArgumentType (Method method, unsigned int argumentNumber,\n \t\t\t\t\t char *returnValue, size_t returnValueSize);\n \n-\n+/* Change the implementation of the method.  It also searches all\n+   classes for any class implementing the method, and replaces the\n+   existing implementation with the new one.  For that to work,\n+   'method' must be a method returned by class_getInstanceMethod() or\n+   class_getClassMethod() as the matching is done by comparing the\n+   pointers; in that case, only the implementation in the class is\n+   modified.  Return the previous implementation that has been\n+   replaced.  If method or implementation is NULL, do nothing and\n+   return NULL.  */\n+objc_EXPORT IMP\n+method_setImplementation (Method method, IMP implementation);\n+\n+/* Swap the implementation of two methods in a single, atomic\n+   operation.  This is equivalent to getting the implementation of\n+   each method and then calling method_setImplementation() on the\n+   other one.  For this to work, the two methods must have been\n+   returned by class_getInstanceMethod() or class_getClassMethod().\n+   If 'method_a' or 'method_b' is NULL, do nothing.  */\n+objc_EXPORT void\n+method_exchangeImplementations (Method method_a, Method method_b);\n \n /** Implementation: the following functions are in protocols.c.  */\n "}]}