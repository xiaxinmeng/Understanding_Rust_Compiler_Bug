{"sha": "5ec3397e38713089e0cef0cb948c29642bea05b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjMzM5N2UzODcxMzA4OWUwY2VmMGNiOTQ4YzI5NjQyYmVhMDViNA==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-01-08T19:37:33Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-01-08T19:37:33Z"}, "message": "rs6000-string.c (do_load_for_compare_from_addr): New function.\n\n2018-01-08  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-string.c (do_load_for_compare_from_addr): New\n\tfunction.\n\t(do_ifelse): New function.\n\t(do_isel): New function.\n\t(do_sub3): New function.\n\t(do_add3): New function.\n\t(do_load_mask_compare): New function.\n\t(do_overlap_load_compare): New function.\n\t(expand_compare_loop): New function.\n\t(expand_block_compare): Call expand_compare_loop() when appropriate.\n\t* config/rs6000/rs6000.opt (-mblock-compare-inline-limit): Change\n\toption description.\n\t(-mblock-compare-inline-loop-limit): New option.\n\nFrom-SVN: r256351", "tree": {"sha": "a86351b508c29fd1237c2ebff8d3956299d441b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86351b508c29fd1237c2ebff8d3956299d441b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ec3397e38713089e0cef0cb948c29642bea05b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec3397e38713089e0cef0cb948c29642bea05b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec3397e38713089e0cef0cb948c29642bea05b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec3397e38713089e0cef0cb948c29642bea05b4/comments", "author": null, "committer": null, "parents": [{"sha": "5a2a87e1e2452eddae38e0ae1af4239f92d8c281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2a87e1e2452eddae38e0ae1af4239f92d8c281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2a87e1e2452eddae38e0ae1af4239f92d8c281"}], "stats": {"total": 1152, "additions": 1118, "deletions": 34}, "files": [{"sha": "afc774e8a88da9da739f5a8dc21472a98d56be4c", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 993, "deletions": 25, "changes": 1018, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=5ec3397e38713089e0cef0cb948c29642bea05b4", "patch": "@@ -303,6 +303,959 @@ compute_current_alignment (unsigned HOST_WIDE_INT base_align,\n   return MIN (base_align, offset & -offset);\n }\n \n+/* Prepare address and then do a load.\n+\n+   MODE is the mode to use for the load.\n+   DEST is the destination register for the data.\n+   ADDR is the address to be loaded.\n+   ORIG_ADDR is the original address expression.  */\n+static void\n+do_load_for_compare_from_addr (machine_mode mode, rtx dest, rtx addr,\n+\t\t\t       rtx orig_addr)\n+{\n+  rtx mem = gen_rtx_MEM (mode, addr);\n+  MEM_COPY_ATTRIBUTES (mem, orig_addr);\n+  set_mem_size (mem, GET_MODE_SIZE (mode));\n+  do_load_for_compare (dest, mem, mode);\n+  return;\n+}\n+\n+/* Do a branch for an if/else decision.\n+\n+   CMPMODE is the mode to use for the comparison.\n+   COMPARISON is the rtx code for the compare needed.\n+   A is the first thing to be compared.\n+   B is the second thing to be compared.\n+   CR is the condition code reg input, or NULL_RTX.\n+   TRUE_LABEL is the label to branch to if the condition is true.\n+\n+   The return value is the CR used for the comparison.\n+   If CR is null_rtx, then a new register of CMPMODE is generated.\n+   If A and B are both null_rtx, then CR must not be null, and the\n+   compare is not generated so you can use this with a dot form insn.  */\n+\n+static void\n+do_ifelse (machine_mode cmpmode, rtx_code comparison,\n+\t   rtx a, rtx b, rtx cr, rtx true_label)\n+{\n+  gcc_assert ((a == NULL_RTX && b == NULL_RTX && cr != NULL_RTX)\n+\t      || (a != NULL_RTX && b != NULL_RTX));\n+\n+  if (cr != NULL_RTX)\n+    gcc_assert (GET_MODE (cr) == cmpmode);\n+  else\n+    cr = gen_reg_rtx (cmpmode);\n+\n+  rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, true_label);\n+\n+  if (a != NULL_RTX)\n+    emit_move_insn (cr, gen_rtx_COMPARE (cmpmode, a, b));\n+\n+  rtx cmp_rtx = gen_rtx_fmt_ee (comparison, VOIDmode, cr, const0_rtx);\n+\n+  rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, cmp_rtx, label_ref, pc_rtx);\n+  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n+  JUMP_LABEL (j) = true_label;\n+  LABEL_NUSES (true_label) += 1;\n+}\n+\n+/* Emit an isel of the proper mode for DEST.\n+\n+   DEST is the isel destination register.\n+   SRC1 is the isel source if CR is true.\n+   SRC2 is the isel source if CR is false.\n+   CR is the condition for the isel.  */\n+static void\n+do_isel (rtx dest, rtx cmp, rtx src_t, rtx src_f, rtx cr)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_isel_signed_di (dest, cmp, src_t, src_f, cr));\n+  else\n+    emit_insn (gen_isel_signed_si (dest, cmp, src_t, src_f, cr));\n+}\n+\n+/* Emit a subtract of the proper mode for DEST.\n+\n+   DEST is the destination register for the subtract.\n+   SRC1 is the first subtract input.\n+   SRC2 is the second subtract input.\n+\n+   Computes DEST = SRC1-SRC2.  */\n+static void\n+do_sub3 (rtx dest, rtx src1, rtx src2)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_subdi3 (dest, src1, src2));\n+  else\n+    emit_insn (gen_subsi3 (dest, src1, src2));\n+}\n+\n+/* Emit an add of the proper mode for DEST.\n+\n+   DEST is the destination register for the add.\n+   SRC1 is the first add input.\n+   SRC2 is the second add input.\n+\n+   Computes DEST = SRC1+SRC2.  */\n+static void\n+do_add3 (rtx dest, rtx src1, rtx src2)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_adddi3 (dest, src1, src2));\n+  else\n+    emit_insn (gen_addsi3 (dest, src1, src2));\n+}\n+\n+/* Generate rtl for a load, shift, and compare of less than a full word.\n+\n+   LOAD_MODE is the machine mode for the loads.\n+   DIFF is the reg for the difference.\n+   CMP_REM is the reg containing the remaining bytes to compare.\n+   DCOND is the CCUNS reg for the compare if we are doing P9 code with setb.\n+   SRC1_ADDR is the first source address.\n+   SRC2_ADDR is the second source address.\n+   ORIG_SRC1 is the original first source block's address rtx.\n+   ORIG_SRC2 is the original second source block's address rtx.  */\n+static void\n+do_load_mask_compare (const machine_mode load_mode, rtx diff, rtx cmp_rem, rtx dcond,\n+\t\t      rtx src1_addr, rtx src2_addr, rtx orig_src1, rtx orig_src2)\n+{\n+  HOST_WIDE_INT load_mode_size = GET_MODE_SIZE (load_mode);\n+  rtx shift_amount = gen_reg_rtx (word_mode);\n+  rtx d1 = gen_reg_rtx (word_mode);\n+  rtx d2 = gen_reg_rtx (word_mode);\n+\n+  do_load_for_compare_from_addr (load_mode, d1, src1_addr, orig_src1);\n+  do_load_for_compare_from_addr (load_mode, d2, src2_addr, orig_src2);\n+  do_sub3 (shift_amount, GEN_INT (load_mode_size), cmp_rem);\n+\n+  if (word_mode == DImode)\n+    {\n+      emit_insn (gen_ashldi3 (shift_amount, shift_amount,\n+\t\t\t      GEN_INT (LOG2_BITS_PER_UNIT)));\n+      emit_insn (gen_lshrdi3 (d1, d1,\n+\t\t\t      gen_lowpart (SImode, shift_amount)));\n+      emit_insn (gen_lshrdi3 (d2, d2,\n+\t\t\t      gen_lowpart (SImode, shift_amount)));\n+    }\n+  else\n+    {\n+      emit_insn (gen_ashlsi3 (shift_amount, shift_amount,\n+\t\t\t      GEN_INT (LOG2_BITS_PER_UNIT)));\n+      emit_insn (gen_lshrsi3 (d1, d1, shift_amount));\n+      emit_insn (gen_lshrsi3 (d2, d2, shift_amount));\n+    }\n+\n+  if (TARGET_P9_MISC)\n+    {\n+      /* Generate a compare, and convert with a setb later.  */\n+      rtx cmp = gen_rtx_COMPARE (CCUNSmode, d1, d2);\n+      emit_insn (gen_rtx_SET (dcond, cmp));\n+    }\n+  else\n+    {\n+      if (word_mode == DImode)\n+\temit_insn (gen_subfdi3_carry (diff, d2, d1));\n+      else\n+\temit_insn (gen_subfsi3_carry (diff, d2, d1));\n+    }\n+}\n+\n+/* Generate rtl for an overlapping load and compare of less than a\n+   full load_mode.  This assumes that the previous word is part of the\n+   block being compared so it's ok to back up part of a word so we can\n+   compare the last unaligned full word that ends at the end of the block.\n+\n+   LOAD_MODE is the machine mode for the loads.\n+   ISCONST tells whether the remaining length is a constant or in a register.\n+   BYTES_REM is the remaining length if ISCONST is true.\n+   DIFF is the reg for the difference.\n+   CMP_REM is the reg containing the remaining bytes to compare if !ISCONST.\n+   DCOND is the CCUNS reg for the compare if we are doing P9 code with setb.\n+   SRC1_ADDR is the first source address.\n+   SRC2_ADDR is the second source address.\n+   ORIG_SRC1 is the original first source block's address rtx.\n+   ORIG_SRC2 is the original second source block's address rtx.  */\n+static void\n+do_overlap_load_compare (machine_mode load_mode, bool isConst,\n+\t\t\tHOST_WIDE_INT bytes_rem, rtx diff,\n+\t\t\trtx cmp_rem, rtx dcond, rtx src1_addr, rtx src2_addr,\n+\t\t\trtx orig_src1, rtx orig_src2)\n+{\n+  HOST_WIDE_INT load_mode_size = GET_MODE_SIZE (load_mode);\n+  HOST_WIDE_INT addr_adj = load_mode_size - bytes_rem;\n+  rtx d1 = gen_reg_rtx (word_mode);\n+  rtx d2 = gen_reg_rtx (word_mode);\n+\n+  rtx addr1, addr2;\n+  if (!isConst || addr_adj)\n+    {\n+      rtx adj_reg = gen_reg_rtx (word_mode);\n+      if (isConst)\n+\temit_move_insn (adj_reg, GEN_INT (-addr_adj));\n+      else\n+\t{\n+\t  rtx reg_lms = gen_reg_rtx (word_mode);\n+\t  emit_move_insn (reg_lms, GEN_INT (load_mode_size));\n+\t  do_sub3 (adj_reg, cmp_rem, reg_lms);\n+\t}\n+\n+      addr1 = gen_rtx_PLUS (word_mode, src1_addr, adj_reg);\n+      addr2 = gen_rtx_PLUS (word_mode, src2_addr, adj_reg);\n+    }\n+  else\n+    {\n+      addr1 = src1_addr;\n+      addr2 = src2_addr;\n+    }\n+\n+  do_load_for_compare_from_addr (load_mode, d1, addr1, orig_src1);\n+  do_load_for_compare_from_addr (load_mode, d2, addr2, orig_src2);\n+\n+  if (TARGET_P9_MISC)\n+    {\n+      /* Generate a compare, and convert with a setb later.  */\n+      rtx cmp = gen_rtx_COMPARE (CCUNSmode, d1, d2);\n+      emit_insn (gen_rtx_SET (dcond, cmp));\n+    }\n+  else\n+    {\n+      if (word_mode == DImode)\n+\temit_insn (gen_subfdi3_carry (diff, d2, d1));\n+      else\n+\temit_insn (gen_subfsi3_carry (diff, d2, d1));\n+    }\n+}\n+\n+/* Expand a block compare operation using loop code, and return true\n+   if successful.  Return false if we should let the compiler generate\n+   normal code, probably a memcmp call.\n+\n+   OPERANDS[0] is the target (result).\n+   OPERANDS[1] is the first source.\n+   OPERANDS[2] is the second source.\n+   OPERANDS[3] is the length.\n+   OPERANDS[4] is the alignment.  */\n+bool\n+expand_compare_loop (rtx operands[])\n+{\n+  rtx target = operands[0];\n+  rtx orig_src1 = operands[1];\n+  rtx orig_src2 = operands[2];\n+  rtx bytes_rtx = operands[3];\n+  rtx align_rtx = operands[4];\n+\n+  /* This case is complicated to handle because the subtract\n+     with carry instructions do not generate the 64-bit\n+     carry and so we must emit code to calculate it ourselves.\n+     We choose not to implement this yet.  */\n+  if (TARGET_32BIT && TARGET_POWERPC64)\n+    return false;\n+\n+  /* Allow non-const length.  */\n+  int bytes_is_const = CONST_INT_P (bytes_rtx);\n+\n+  /* This must be a fixed size alignment.  */\n+  if (!CONST_INT_P (align_rtx))\n+    return false;\n+\n+  HOST_WIDE_INT align1 = MEM_ALIGN (orig_src1) / BITS_PER_UNIT;\n+  HOST_WIDE_INT align2 = MEM_ALIGN (orig_src2) / BITS_PER_UNIT;\n+  HOST_WIDE_INT minalign = MIN (align1, align2);\n+\n+  bool isP7 = (rs6000_tune == PROCESSOR_POWER7);\n+\n+  gcc_assert (GET_MODE (target) == SImode);\n+\n+  /* Anything to move?\t*/\n+  HOST_WIDE_INT bytes = 0;\n+  if (bytes_is_const)\n+    bytes = INTVAL (bytes_rtx);\n+\n+  if (bytes_is_const && bytes == 0)\n+    return true;\n+\n+  /* Limit the amount we compare, if known statically.  */\n+  HOST_WIDE_INT max_bytes;\n+  switch (rs6000_tune)\n+    {\n+    case PROCESSOR_POWER7:\n+      if (!bytes_is_const)\n+\tif (minalign < 8)\n+\t  max_bytes = 0;\n+\telse\n+\t  max_bytes = 128;\n+      else\n+\tif (minalign < 8)\n+\t  max_bytes = 32;\n+\telse\n+\t  max_bytes = 128;\n+      break;\n+    case PROCESSOR_POWER8:\n+      if (!bytes_is_const)\n+\tmax_bytes = 0;\n+      else\n+\tif (minalign < 8)\n+\t  max_bytes = 128;\n+\telse\n+\t  max_bytes = 64;\n+      break;\n+    case PROCESSOR_POWER9:\n+      if (bytes_is_const)\n+\tmax_bytes = 191;\n+      else\n+\tmax_bytes = 0;\n+      break;\n+    default:\n+      max_bytes = 128;\n+    }\n+\n+  /* Allow the option to override the default.  */\n+  if (rs6000_block_compare_inline_loop_limit >= 0)\n+    max_bytes = (unsigned HOST_WIDE_INT) rs6000_block_compare_inline_loop_limit;\n+\n+  if (max_bytes == 0)\n+    return false;\n+\n+  rtx cmp_rem = gen_reg_rtx (word_mode);  /* Remainder for library call.  */\n+  rtx loop_cmp = gen_reg_rtx (word_mode); /* Actual amount compared by loop.  */\n+  HOST_WIDE_INT niter;\n+  rtx iter = gen_reg_rtx (word_mode);\n+  rtx iv1 = gen_reg_rtx (word_mode);\n+  rtx iv2 = gen_reg_rtx (word_mode);\n+  rtx d1_1 = gen_reg_rtx (word_mode);  /* Addr expression src1+iv1 */\n+  rtx d1_2 = gen_reg_rtx (word_mode);  /* Addr expression src1+iv2 */\n+  rtx d2_1 = gen_reg_rtx (word_mode);  /* Addr expression src2+iv1 */\n+  rtx d2_2 = gen_reg_rtx (word_mode);  /* Addr expression src2+iv2 */\n+\n+  /* Strip unneeded subreg from length if there is one.  */\n+  if (SUBREG_P (bytes_rtx) && subreg_lowpart_p (bytes_rtx))\n+    bytes_rtx = SUBREG_REG (bytes_rtx);\n+  /* Extend bytes_rtx to word_mode if needed.  But, we expect only to\n+   maybe have to deal with the case were bytes_rtx is SImode and\n+   word_mode is DImode.  */\n+  if (!bytes_is_const)\n+    {\n+      if (GET_MODE_SIZE (GET_MODE (bytes_rtx)) > GET_MODE_SIZE (word_mode))\n+\t/* Do not expect length longer than word_mode.  */\n+\treturn false; \n+      else if (GET_MODE_SIZE (GET_MODE (bytes_rtx)) < GET_MODE_SIZE (word_mode))\n+\t{\n+\t  bytes_rtx = force_reg (GET_MODE (bytes_rtx), bytes_rtx);\n+\t  bytes_rtx = force_reg (word_mode,\n+\t\t\t\t gen_rtx_fmt_e (ZERO_EXTEND, word_mode,\n+\t\t\t\t\t\tbytes_rtx));\n+\t}\n+      else\n+\t/* Make sure it's in a register before we get started.  */\n+\tbytes_rtx = force_reg (GET_MODE (bytes_rtx), bytes_rtx);\n+    }\n+\n+  machine_mode load_mode = word_mode;\n+  HOST_WIDE_INT load_mode_size = GET_MODE_SIZE (load_mode);\n+\n+  /* Number of bytes per iteration of the unrolled loop.  */\n+  HOST_WIDE_INT loop_bytes = 2 * load_mode_size;\n+  /* max iters and bytes compared in the loop.  */\n+  HOST_WIDE_INT max_loop_iter = max_bytes / loop_bytes;\n+  HOST_WIDE_INT max_loop_bytes = max_loop_iter * loop_bytes;\n+  int l2lb = floor_log2 (loop_bytes);\n+\n+  if (bytes_is_const && (max_bytes < load_mode_size\n+\t\t\t || !IN_RANGE (bytes, load_mode_size, max_bytes)))\n+    return false;\n+\n+  bool no_remainder_code = false;\n+  rtx final_label = gen_label_rtx ();\n+  rtx final_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n+  rtx diff_label = gen_label_rtx ();\n+  rtx library_call_label = NULL;\n+  rtx cleanup_label = gen_label_rtx ();\n+\n+  rtx cr;\n+\n+  rtx src1_addr = copy_addr_to_reg (XEXP (orig_src1, 0));\n+  rtx src2_addr = copy_addr_to_reg (XEXP (orig_src2, 0));\n+\n+  /* Difference found is stored here before jump to diff_label.  */\n+  rtx diff = gen_reg_rtx (word_mode);\n+  rtx j;\n+\n+  /* Example of generated code for 35 bytes aligned 1 byte.\n+     \n+\t     mtctr 8\n+\t     li 6,0\n+\t     li 5,8\n+     .L13:\n+\t     ldbrx 7,3,6\n+\t     ldbrx 9,10,6\n+\t     ldbrx 0,3,5\n+\t     ldbrx 4,10,5\n+\t     addi 6,6,16\n+\t     addi 5,5,16\n+\t     subfc. 9,9,7\n+\t     bne 0,.L10\n+\t     subfc. 9,4,0\n+\t     bdnzt 2,.L13\n+\t     bne 0,.L10\n+\t     add 3,3,6\n+\t     add 10,10,6\n+\t     addi 9,3,-5\n+\t     ldbrx 7,0,9\n+\t     addi 9,10,-5\n+\t     ldbrx 9,0,9\n+\t     subfc 9,9,7\n+\t     .p2align 4,,15\n+     .L10:\n+\t     popcntd 9,9\n+\t     subfe 10,10,10\n+\t     or 9,9,10\n+     \n+     Compiled with -fno-reorder-blocks for clarity.  */\n+\n+  /* Structure of what we're going to do:\n+     Two separate lengths: what we will compare before bailing to library\n+\tcall (max_bytes), and the total length to be checked.\n+     if length <= 16, branch to linear cleanup code starting with\n+\tremainder length check (length not known at compile time)\n+     set up 2 iv's and load count reg, compute remainder length\n+     unrollx2 compare loop\n+     if loop exit due to a difference, branch to difference handling code\n+     if remainder length < 8, branch to final cleanup compare\n+     load and compare 8B\n+     final cleanup comparison (depends on alignment and length)\n+\tload 8B, shift off bytes past length, compare\n+\tload 8B ending at last byte and compare\n+\tload/compare 1 byte at a time (short block abutting 4k boundary)\n+     difference handling, 64->32 conversion\n+     final result\n+     branch around memcmp call\n+     memcmp library call\n+  */\n+\n+  /* If bytes is not const, compare length and branch directly\n+     to the cleanup code that can handle 0-16 bytes if length\n+     is >= 16.  Stash away bytes-max_bytes for the library call.  */\n+  if (bytes_is_const)\n+    {\n+      /* These need to be set for some of the places we may jump to.  */\n+      if (bytes > max_bytes)\n+\t{\n+\t  no_remainder_code = true;\n+\t  niter = max_loop_iter;\n+\t  library_call_label = gen_label_rtx ();\n+\t}\n+      else\n+\t{\n+\t  niter = bytes / loop_bytes;\n+\t}\n+      emit_move_insn (iter, GEN_INT (niter));\n+      emit_move_insn (loop_cmp, GEN_INT (niter * loop_bytes));\n+      emit_move_insn (cmp_rem, GEN_INT (bytes - niter * loop_bytes));\n+    }\n+  else\n+    {\n+      library_call_label = gen_label_rtx ();\n+\n+      /* If we go to the cleanup code, it expects length to be in cmp_rem.  */\n+      emit_move_insn (cmp_rem, bytes_rtx);\n+\n+      /* Check for > max_bytes bytes.  We want to bail out as quickly as\n+\t possible if we have to go over to memcmp.  */\n+      do_ifelse (CCmode, GT, bytes_rtx, GEN_INT (max_bytes),\n+\t\t NULL_RTX, library_call_label);\n+\n+      /* Check for < loop_bytes bytes.  */\n+      do_ifelse (CCmode, LT, bytes_rtx, GEN_INT (loop_bytes),\n+\t\t NULL_RTX, cleanup_label);\n+\n+      /* Loop compare bytes and iterations if bytes>max_bytes.  */\n+      rtx mb_reg = gen_reg_rtx (word_mode);\n+      emit_move_insn (mb_reg, GEN_INT (max_loop_bytes));\n+      rtx mi_reg = gen_reg_rtx (word_mode);\n+      emit_move_insn (mi_reg, GEN_INT (max_loop_iter));\n+\n+      /* Compute number of loop iterations if bytes <= max_bytes.  */\n+      if (word_mode == DImode)\n+\temit_insn (gen_lshrdi3 (iter, bytes_rtx, GEN_INT (l2lb)));\n+      else\n+\temit_insn (gen_lshrsi3 (iter, bytes_rtx, GEN_INT (l2lb)));\n+\n+      /* Compute bytes to compare in loop if bytes <= max_bytes.  */\n+      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << l2lb);\n+      if (word_mode == DImode)\n+\t{\n+\t  emit_insn (gen_anddi3 (loop_cmp, bytes_rtx, mask));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_andsi3 (loop_cmp, bytes_rtx, mask));\n+\t}\n+\n+      /* Check for bytes <= max_bytes.  */\n+      if (TARGET_ISEL)\n+\t{\n+\t  /* P9 has fast isel so we use one compare and two isel.  */\n+\t  cr = gen_reg_rtx (CCmode);\n+\t  rtx compare_rtx = gen_rtx_COMPARE (CCmode, bytes_rtx,\n+\t\t\t\t\t     GEN_INT (max_bytes));\n+\t  emit_move_insn (cr, compare_rtx);\n+\t  rtx cmp_rtx = gen_rtx_LE (VOIDmode, cr, const0_rtx);\n+\t  do_isel (loop_cmp, cmp_rtx, loop_cmp, mb_reg, cr);\n+\t  do_isel (iter, cmp_rtx, iter, mi_reg, cr);\n+\t}\n+      else\n+\t{\n+\t  rtx lab_after = gen_label_rtx ();\n+\t  do_ifelse (CCmode, LE, bytes_rtx, GEN_INT (max_bytes),\n+\t\t     NULL_RTX, lab_after);\n+\t  emit_move_insn (loop_cmp, mb_reg);\n+\t  emit_move_insn (iter, mi_reg);\n+\t  emit_label (lab_after);\n+\t}\n+\n+      /* Now compute remainder bytes which isn't used until after the loop.  */\n+      do_sub3 (cmp_rem, bytes_rtx, loop_cmp);\n+    }\n+\n+  rtx dcond = NULL_RTX; /* Used for when we jump to diff_label.  */\n+  /* For p9 we need to have just one of these as multiple places define\n+     it and it gets used by the setb at the end.  */\n+  if (TARGET_P9_MISC)\n+    dcond = gen_reg_rtx (CCUNSmode);\n+\n+  if (!bytes_is_const || bytes >= loop_bytes)\n+    {\n+      /* It should not be possible to come here if remaining bytes is\n+\t < 16 in the runtime case either.  Compute number of loop\n+\t iterations.  We compare 2*word_mode per iteration so 16B for\n+\t 64-bit code and 8B for 32-bit.  Set up two induction\n+\t variables and load count register.  */\n+\n+      /* HACK ALERT: create hard reg for CTR here.  If we just use a\n+\t pseudo, cse will get rid of it and then the allocator will\n+\t see it used in the lshr above and won't give us ctr.  */\n+      rtx ctr = gen_rtx_REG (Pmode, CTR_REGNO);\n+      emit_move_insn (ctr, iter);\n+      emit_move_insn (diff, GEN_INT (0));\n+      emit_move_insn (iv1, GEN_INT (0));\n+      emit_move_insn (iv2, GEN_INT (load_mode_size));\n+\n+      /* inner loop to compare 2*word_mode */\n+      rtx loop_top_label = gen_label_rtx ();\n+      emit_label (loop_top_label);\n+\n+      rtx src1_ix1 = gen_rtx_PLUS (word_mode, src1_addr, iv1);\n+      rtx src2_ix1 = gen_rtx_PLUS (word_mode, src2_addr, iv1);\n+\n+      do_load_for_compare_from_addr (load_mode, d1_1,\n+\t\t\t\t     src1_ix1, orig_src1);\n+      do_load_for_compare_from_addr (load_mode, d2_1,\n+\t\t\t\t     src2_ix1, orig_src2);\n+      do_add3 (iv1, iv1, GEN_INT (loop_bytes));\n+\n+      rtx src1_ix2 = gen_rtx_PLUS (word_mode, src1_addr, iv2);\n+      rtx src2_ix2 = gen_rtx_PLUS (word_mode, src2_addr, iv2);\n+\n+      do_load_for_compare_from_addr (load_mode, d1_2,\n+\t\t\t\t     src1_ix2, orig_src1);\n+      do_load_for_compare_from_addr (load_mode, d2_2,\n+\t\t\t\t     src2_ix2, orig_src2);\n+      do_add3 (iv2, iv2, GEN_INT (loop_bytes));\n+\n+      if (TARGET_P9_MISC)\n+\t{\n+\t  /* Generate a compare, and convert with a setb later.  */\n+\t  rtx cmp = gen_rtx_COMPARE (CCUNSmode, d1_1, d2_1);\n+\t  emit_insn (gen_rtx_SET (dcond, cmp));\n+\t}\n+      else\n+\t{\n+\t  dcond = gen_reg_rtx (CCmode);\n+\t  if (word_mode == DImode)\n+\t    emit_insn (gen_subfdi3_carry_dot2 (diff, d2_1, d1_1, dcond));\n+\t  else\n+\t    emit_insn (gen_subfsi3_carry_dot2 (diff, d2_1, d1_1, dcond));\n+\t}\n+\n+      do_ifelse (GET_MODE (dcond), NE, NULL_RTX, NULL_RTX,\n+\t\t dcond, diff_label);\n+\n+      if (TARGET_P9_MISC)\n+\t{\n+\t  /* Generate a compare, and convert with a setb later.  */\n+\t  rtx cmp = gen_rtx_COMPARE (CCUNSmode, d1_2, d2_2);\n+\t  emit_insn (gen_rtx_SET (dcond, cmp));\n+\t}\n+      else\n+\t{\n+\t  dcond = gen_reg_rtx (CCmode);\n+\t  if (word_mode == DImode)\n+\t    emit_insn (gen_subfdi3_carry_dot2 (diff, d2_2, d1_2, dcond));\n+\t  else\n+\t    emit_insn (gen_subfsi3_carry_dot2 (diff, d2_2, d1_2, dcond));\n+\t}\n+\n+      rtx eqrtx = gen_rtx_EQ (VOIDmode, d1_2, d2_2);\n+      if (TARGET_64BIT)\n+\tj = emit_jump_insn (gen_bdnztf_di (loop_top_label, ctr, ctr,\n+\t\t\t\t\t   eqrtx, dcond));\n+      else\n+\tj = emit_jump_insn (gen_bdnztf_si (loop_top_label, ctr, ctr,\n+\t\t\t\t\t   eqrtx, dcond));\n+      JUMP_LABEL (j) = loop_top_label;\n+      LABEL_NUSES (loop_top_label) += 1;\n+    }\n+\n+  HOST_WIDE_INT bytes_remaining = 0;\n+  if (bytes_is_const)\n+    bytes_remaining = (bytes % loop_bytes);\n+\n+  /* If diff is nonzero, branch to difference handling\n+     code.  If we exit here with a nonzero diff, it is\n+     because the second word differed.  */\n+  if (TARGET_P9_MISC)\n+    do_ifelse (CCUNSmode, NE, NULL_RTX, NULL_RTX, dcond, diff_label);\n+  else\n+    do_ifelse (CCmode, NE, diff, const0_rtx, NULL_RTX, diff_label);\n+\n+  if (library_call_label != NULL && bytes_is_const && bytes > max_bytes)\n+    {\n+      /* If the length is known at compile time, then we will always\n+\t have a remainder to go to the library call with.  */\n+      rtx library_call_ref = gen_rtx_LABEL_REF (VOIDmode, library_call_label);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, library_call_ref));\n+      JUMP_LABEL (j) = library_call_label;\n+      LABEL_NUSES (library_call_label) += 1;\n+      emit_barrier ();\n+    }\n+\n+  if (bytes_is_const && bytes_remaining == 0)\n+    {\n+      /* No remainder and if we are here then diff is 0 so just return 0 */\n+      if (TARGET_64BIT)\n+\temit_insn (gen_movsi (target, gen_lowpart (SImode, diff)));\n+      else\n+\temit_move_insn (target, diff);\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, final_ref));\n+      JUMP_LABEL (j) = final_label;\n+      LABEL_NUSES (final_label) += 1;\n+      emit_barrier ();\n+    }\n+  else if (!no_remainder_code)\n+    {\n+      /* Update addresses to point to the next word to examine.  */\n+      do_add3 (src1_addr, src1_addr, iv1);\n+      do_add3 (src2_addr, src2_addr, iv1);\n+\n+      emit_label (cleanup_label);\n+\n+      if (!bytes_is_const)\n+\t{\n+\t  /* If we're dealing with runtime length, we have to check if\n+\t     it's zero after the loop. When length is known at compile\n+\t     time the no-remainder condition is dealt with above.  By\n+\t     doing this after cleanup_label, we also deal with the\n+\t     case where length is 0 at the start and we bypass the\n+\t     loop with a branch to cleanup_label.  */\n+\t  emit_move_insn (target, const0_rtx);\n+\t  do_ifelse (CCmode, EQ, cmp_rem, const0_rtx,\n+\t\t     NULL_RTX, final_label);\n+\t}\n+\n+      rtx final_cleanup = gen_label_rtx ();\n+      rtx cmp_rem_before = gen_reg_rtx (word_mode);\n+      /* Compare one more word_mode chunk if needed.  */\n+      if (!bytes_is_const\n+\t  || (bytes_is_const && bytes_remaining >= load_mode_size))\n+\t{\n+\t  /* If remainder length < word length, branch to final\n+\t     cleanup compare.  */\n+\t  if (!bytes_is_const)\n+\t    do_ifelse (CCmode, LT, cmp_rem, GEN_INT (load_mode_size),\n+\t\t       NULL_RTX, final_cleanup);\n+\n+\t  /* load and compare 8B */\n+\t  do_load_for_compare_from_addr (load_mode, d1_1,\n+\t\t\t\t\t src1_addr, orig_src1);\n+\t  do_load_for_compare_from_addr (load_mode, d2_1,\n+\t\t\t\t\t src2_addr, orig_src2);\n+\n+\t  /* Compare the word, see if we need to do the last partial.  */\n+\t  if (TARGET_P9_MISC)\n+\t    {\n+\t      /* Generate a compare, and convert with a setb later.  */\n+\t      rtx cmp = gen_rtx_COMPARE (CCUNSmode, d1_1, d2_1);\n+\t      emit_insn (gen_rtx_SET (dcond, cmp));\n+\t    }\n+\t  else\n+\t    {\n+\t      dcond = gen_reg_rtx (CCmode);\n+\t      if (word_mode == DImode)\n+\t\temit_insn (gen_subfdi3_carry_dot2 (diff, d2_1, d1_1, dcond));\n+\t      else\n+\t\temit_insn (gen_subfsi3_carry_dot2 (diff, d2_1, d1_1, dcond));\n+\t    }\n+\n+\t  do_ifelse (GET_MODE (dcond), NE, NULL_RTX, NULL_RTX,\n+\t\t     dcond, diff_label);\n+\n+\t  do_add3 (src1_addr, src1_addr, GEN_INT (load_mode_size));\n+\t  do_add3 (src2_addr, src2_addr, GEN_INT (load_mode_size));\n+\t  emit_move_insn (cmp_rem_before, cmp_rem);\n+\t  do_add3 (cmp_rem, cmp_rem, GEN_INT (-load_mode_size));\n+\t  if (bytes_is_const)\n+\t    bytes_remaining -= load_mode_size;\n+\t  else\n+\t    /* See if remaining length is now zero.  We previously set\n+\t       target to 0 so we can just jump to the end.  */\n+\t    do_ifelse (CCmode, EQ, cmp_rem, const0_rtx,\n+\t\t       NULL_RTX, final_label);\n+\n+\t}\n+\n+      /* Cases:\n+\t bytes_is_const\n+\t   We can always shift back to do an overlapping compare\n+\t   of the last chunk because we know length >= 8.\n+\n+\t !bytes_is_const\n+\t   align>=load_mode_size\n+\t     Read word_mode and mask\n+\t   align<load_mode_size\n+\t     avoid stepping past end\n+\n+\t  Three strategies:\n+\t  * decrement address and do overlapping compare\n+\t  * read word_mode and mask\n+\t  * carefully avoid crossing 4k boundary\n+       */\n+\n+      if ((!bytes_is_const || (bytes_is_const && bytes_remaining && isP7))\n+\t  && align1 >= load_mode_size && align2 >= load_mode_size)\n+\t{\n+\t  /* Alignment is larger than word_mode so we do not need to be\n+\t     concerned with extra page crossings.  But, we do not know\n+\t     that the length is larger than load_mode_size so we might\n+\t     end up compareing against data before the block if we try\n+\t     an overlapping compare.  Also we use this on P7 for fixed length\n+\t     remainder because P7 doesn't like overlapping unaligned.\n+\t     Strategy: load 8B, shift off bytes past length, and compare.  */\n+\t  emit_label (final_cleanup);\n+\t  do_load_mask_compare (load_mode, diff, cmp_rem, dcond,\n+\t\t\t\tsrc1_addr, src2_addr, orig_src1, orig_src2);\n+\t}\n+      else if (bytes_remaining && bytes_is_const)\n+\t{\n+\t  /* We do not do loop expand if length < 32 so we know at the\n+\t     end we can do an overlapping compare.\n+\t     Strategy: shift address back and do word_mode load that\n+\t     ends at the end of the block.  */\n+\t  emit_label (final_cleanup);\n+\t  do_overlap_load_compare (load_mode, true, bytes_remaining, diff,\n+\t\t\t\t   cmp_rem, dcond, src1_addr, src2_addr,\n+\t\t\t\t   orig_src1, orig_src2);\n+\t}\n+      else if (!bytes_is_const)\n+\t{\n+\t  rtx handle4k_label = gen_label_rtx ();\n+\t  rtx nonconst_overlap = gen_label_rtx ();\n+\t  emit_label (nonconst_overlap);\n+\n+\t  /* Here we have to handle the case where whe have runtime\n+\t     length which may be too short for overlap compare, and\n+\t     alignment is not at least load_mode_size so we have to\n+\t     tread carefully to avoid stepping across 4k boundaries.  */\n+\n+\t  /* If the length after the loop was larger than word_mode\n+\t     size, we can just do an overlapping compare and we're\n+\t     done.  We fall through to this code from the word_mode\n+\t     compare that preceeds this.  */\n+\t  do_overlap_load_compare (load_mode, false, 0, diff,\n+\t\t\t\t   cmp_rem, dcond, src1_addr, src2_addr,\n+\t\t\t\t   orig_src1, orig_src2);\n+\n+\t  rtx diff_ref = gen_rtx_LABEL_REF (VOIDmode, diff_label);\n+\t  j = emit_jump_insn (gen_rtx_SET (pc_rtx, diff_ref));\n+\t  JUMP_LABEL (j) = diff_label;\n+\t  LABEL_NUSES (diff_label) += 1;\n+\t  emit_barrier ();\n+\n+\t  /* If we couldn't do the overlap compare we have to be more\n+\t     careful of the 4k boundary.  Test to see if either\n+\t     address is less than word_mode_size away from a 4k\n+\t     boundary.  If not, then we can do a load/shift/compare\n+\t     and we are done.  We come to this code if length was less\n+\t     than word_mode_size.  */\n+\n+\t  emit_label (final_cleanup);\n+\n+\t  /* We can still avoid the slow case if the length was larger\n+\t     than one loop iteration, in which case go do the overlap\n+\t     load compare path.  */\n+\t  do_ifelse (CCmode, GT, bytes_rtx, GEN_INT (loop_bytes),\n+\t\t     NULL_RTX, nonconst_overlap);\n+\n+\t  rtx rem4k = gen_reg_rtx (word_mode);\n+\t  rtx dist1 = gen_reg_rtx (word_mode);\n+\t  rtx dist2 = gen_reg_rtx (word_mode);\n+\t  do_sub3 (rem4k, GEN_INT (4096), cmp_rem);\n+\t  if (word_mode == SImode)\n+\t    emit_insn (gen_andsi3 (dist1, src1_addr, GEN_INT (0xfff)));\n+\t  else\n+\t    emit_insn (gen_anddi3 (dist1, src1_addr, GEN_INT (0xfff)));\n+\t  do_ifelse (CCmode, LE, dist1, rem4k, NULL_RTX, handle4k_label);\n+\t  if (word_mode == SImode)\n+\t    emit_insn (gen_andsi3 (dist2, src2_addr, GEN_INT (0xfff)));\n+\t  else\n+\t    emit_insn (gen_anddi3 (dist2, src2_addr, GEN_INT (0xfff)));\n+\t  do_ifelse (CCmode, LE, dist2, rem4k, NULL_RTX, handle4k_label);\n+\n+\t  /* We don't have a 4k boundary to deal with, so do\n+\t     a load/shift/compare and jump to diff.  */\n+\n+\t  do_load_mask_compare (load_mode, diff, cmp_rem, dcond,\n+\t\t\t\tsrc1_addr, src2_addr, orig_src1, orig_src2);\n+\n+\t  j = emit_jump_insn (gen_rtx_SET (pc_rtx, diff_ref));\n+\t  JUMP_LABEL (j) = diff_label;\n+\t  LABEL_NUSES (diff_label) += 1;\n+\t  emit_barrier ();\n+\n+\t  /* Finally in the unlikely case we are inching up to a\n+\t     4k boundary we use a compact lbzx/compare loop to do\n+\t     it a byte at a time.  */\n+\n+\t  emit_label (handle4k_label);\n+\n+\t  rtx ctr = gen_rtx_REG (Pmode, CTR_REGNO);\n+\t  emit_move_insn (ctr, cmp_rem);\n+\t  rtx ixreg = gen_reg_rtx (Pmode);\n+\t  emit_move_insn (ixreg, const0_rtx);\n+\n+\t  rtx src1_ix = gen_rtx_PLUS (word_mode, src1_addr, ixreg);\n+\t  rtx src2_ix = gen_rtx_PLUS (word_mode, src2_addr, ixreg);\n+\t  rtx d1 = gen_reg_rtx (word_mode);\n+\t  rtx d2 = gen_reg_rtx (word_mode);\n+\n+\t  rtx fc_loop = gen_label_rtx ();\n+\t  emit_label (fc_loop);\n+\n+\t  do_load_for_compare_from_addr (QImode, d1, src1_ix, orig_src1);\n+\t  do_load_for_compare_from_addr (QImode, d2, src2_ix, orig_src2);\n+\n+\t  do_add3 (ixreg, ixreg, const1_rtx);\n+\n+\t  rtx cond = gen_reg_rtx (CCmode);\n+\t  rtx subexpr = gen_rtx_MINUS (word_mode, d1, d2);\n+\t  rs6000_emit_dot_insn (diff, subexpr, 2, cond);\n+\n+\t  rtx eqrtx = gen_rtx_EQ (VOIDmode, d1, d2);\n+\t  if (TARGET_64BIT)\n+\t    j = emit_jump_insn (gen_bdnztf_di (fc_loop, ctr, ctr,\n+\t\t\t\t\t       eqrtx, cond));\n+\t  else\n+\t    j = emit_jump_insn (gen_bdnztf_si (fc_loop, ctr, ctr,\n+\t\t\t\t\t       eqrtx, cond));\n+\t  JUMP_LABEL (j) = fc_loop;\n+\t  LABEL_NUSES (fc_loop) += 1;\n+\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_movsi (target, gen_lowpart (SImode, diff)));\n+\t  else\n+\t    emit_move_insn (target, diff);\n+\n+\t  /* Since we are comparing bytes, the difference can be used\n+\t     as the final result and we are done here.  */\n+\t  j = emit_jump_insn (gen_rtx_SET (pc_rtx, final_ref));\n+\t  JUMP_LABEL (j) = final_label;\n+\t  LABEL_NUSES (final_label) += 1;\n+\t  emit_barrier ();\n+\t}\n+    }\n+\n+  emit_label (diff_label);\n+  /* difference handling, 64->32 conversion */\n+\n+  /* We need to produce DI result from sub, then convert to target SI\n+     while maintaining <0 / ==0 / >0 properties.  This sequence works:\n+     subfc L,A,B\n+     subfe H,H,H\n+     popcntd L,L\n+     rldimi L,H,6,0\n+\n+     This is an alternate one Segher cooked up if somebody\n+     wants to expand this for something that doesn't have popcntd:\n+     subfc L,a,b\n+     subfe H,x,x\n+     addic t,L,-1\n+     subfe v,t,L\n+     or z,v,H\n+\n+     And finally, p9 can just do this:\n+     cmpld A,B\n+     setb r */\n+\n+  if (TARGET_P9_MISC)\n+    emit_insn (gen_setb_unsigned (target, dcond));\n+  else\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  rtx tmp_reg_ca = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_subfdi3_carry_in_xx (tmp_reg_ca));\n+\t  emit_insn (gen_popcntddi2 (diff, diff));\n+\t  emit_insn (gen_iordi3 (diff, diff, tmp_reg_ca));\n+\t  emit_insn (gen_movsi (target, gen_lowpart (SImode, diff)));\n+\t}\n+      else\n+\t{\n+\t  rtx tmp_reg_ca = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_subfsi3_carry_in_xx (tmp_reg_ca));\n+\t  emit_insn (gen_popcntdsi2 (diff, diff));\n+\t  emit_insn (gen_iorsi3 (target, diff, tmp_reg_ca));\n+\t}\n+    }\n+\n+  if (library_call_label != NULL)\n+    {\n+      /* Branch around memcmp call.  */\n+      j = emit_jump_insn (gen_rtx_SET (pc_rtx, final_ref));\n+      JUMP_LABEL (j) = final_label;\n+      LABEL_NUSES (final_label) += 1;\n+      emit_barrier ();\n+\n+      /* Make memcmp library call.  cmp_rem is the remaining bytes that\n+\t were compared and cmp_rem is the expected amount to be compared\n+\t by memcmp.  If we don't find a difference in the loop compare, do\n+\t the library call directly instead of doing a small compare just\n+\t to get to an arbitrary boundary before calling it anyway.\n+\t Also, update addresses to point to the next word to examine.  */\n+      emit_label (library_call_label);\n+\n+      rtx len_rtx = gen_reg_rtx (word_mode);\n+      if (bytes_is_const)\n+\t{\n+\t  emit_move_insn (len_rtx, cmp_rem);\n+\t  do_add3 (src1_addr, src1_addr, iv1);\n+\t  do_add3 (src2_addr, src2_addr, iv1);\n+\t}\n+      else\n+\temit_move_insn (len_rtx, bytes_rtx);\n+\n+      tree fun = builtin_decl_explicit (BUILT_IN_MEMCMP);\n+      emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n+\t\t\t       target, LCT_NORMAL, GET_MODE (target),\n+\t\t\t       src1_addr, Pmode,\n+\t\t\t       src2_addr, Pmode,\n+\t\t\t       len_rtx, GET_MODE (len_rtx));\n+    }\n+\n+  /* emit final_label */\n+  emit_label (final_label);\n+  return true;\n+}\n+\n /* Expand a block compare operation, and return true if successful.\n    Return false if we should let the compiler generate normal code,\n    probably a memcmp call.\n@@ -331,36 +1284,43 @@ expand_block_compare (rtx operands[])\n   if (TARGET_32BIT && TARGET_POWERPC64)\n     return false;\n \n-  /* If this is not a fixed size compare, just call memcmp.  */\n-  if (!CONST_INT_P (bytes_rtx))\n+  bool isP7 = (rs6000_tune == PROCESSOR_POWER7);\n+\n+  /* Allow this param to shut off all expansion.  */\n+  if (rs6000_block_compare_inline_limit == 0)\n+    return false;\n+\n+  /* targetm.slow_unaligned_access -- don't do unaligned stuff.\n+     However slow_unaligned_access returns true on P7 even though the\n+     performance of this code is good there.  */\n+  if (!isP7\n+      && (targetm.slow_unaligned_access (word_mode, MEM_ALIGN (orig_src1))\n+\t  || targetm.slow_unaligned_access (word_mode, MEM_ALIGN (orig_src2))))\n     return false;\n \n+  /* Unaligned l*brx traps on P7 so don't do this.  However this should\n+     not affect much because LE isn't really supported on P7 anyway.  */\n+  if (isP7 && !BYTES_BIG_ENDIAN)\n+    return false;\n+\n+  /* If this is not a fixed size compare, try generating loop code and\n+     if that fails just call memcmp.  */\n+  if (!CONST_INT_P (bytes_rtx))\n+    return expand_compare_loop (operands);\n+\n   /* This must be a fixed size alignment.  */\n   if (!CONST_INT_P (align_rtx))\n     return false;\n \n   unsigned int base_align = UINTVAL (align_rtx) / BITS_PER_UNIT;\n \n-  /* targetm.slow_unaligned_access -- don't do unaligned stuff.  */\n-  if (targetm.slow_unaligned_access (word_mode, MEM_ALIGN (orig_src1))\n-      || targetm.slow_unaligned_access (word_mode, MEM_ALIGN (orig_src2)))\n-    return false;\n-\n   gcc_assert (GET_MODE (target) == SImode);\n \n   /* Anything to move?  */\n   unsigned HOST_WIDE_INT bytes = UINTVAL (bytes_rtx);\n   if (bytes == 0)\n     return true;\n \n-  /* The code generated for p7 and older is not faster than glibc\n-     memcmp if alignment is small and length is not short, so bail\n-     out to avoid those conditions.  */\n-  if (!TARGET_EFFICIENT_OVERLAPPING_UNALIGNED\n-      && ((base_align == 1 && bytes > 16)\n-\t  || (base_align == 2 && bytes > 32)))\n-    return false;\n-\n   rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n   rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n   /* P7/P8 code uses cond for subfc. but P9 uses\n@@ -383,10 +1343,18 @@ expand_block_compare (rtx operands[])\n     select_block_compare_mode (offset, bytes, base_align, word_mode_ok);\n   unsigned int load_mode_size = GET_MODE_SIZE (load_mode);\n \n-  /* We don't want to generate too much code.  */\n-  unsigned HOST_WIDE_INT max_bytes =\n-    load_mode_size * (unsigned HOST_WIDE_INT) rs6000_block_compare_inline_limit;\n+  /* We don't want to generate too much code.  The loop code can take\n+     over for lengths greater than 31 bytes.  */\n+  unsigned HOST_WIDE_INT max_bytes = rs6000_block_compare_inline_limit;\n   if (!IN_RANGE (bytes, 1, max_bytes))\n+    return expand_compare_loop (operands);\n+\n+  /* The code generated for p7 and older is not faster than glibc\n+     memcmp if alignment is small and length is not short, so bail\n+     out to avoid those conditions.  */\n+  if (!TARGET_EFFICIENT_OVERLAPPING_UNALIGNED\n+      && ((base_align == 1 && bytes > 16)\n+\t  || (base_align == 2 && bytes > 32)))\n     return false;\n \n   bool generate_6432_conversion = false;\n@@ -461,14 +1429,14 @@ expand_block_compare (rtx operands[])\n \t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n \t  src1 = replace_equiv_address (src1, src1_reg);\n \t}\n-      set_mem_size (src1, load_mode_size);\n+      set_mem_size (src1, cmp_bytes);\n \n       if (!REG_P (XEXP (src2, 0)))\n \t{\n \t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n \t  src2 = replace_equiv_address (src2, src2_reg);\n \t}\n-      set_mem_size (src2, load_mode_size);\n+      set_mem_size (src2, cmp_bytes);\n \n       do_load_for_compare (tmp_reg_src1, src1, load_mode);\n       do_load_for_compare (tmp_reg_src2, src2, load_mode);\n@@ -536,7 +1504,7 @@ expand_block_compare (rtx operands[])\n \t\t{\n \t\t  rtx fin_ref = gen_rtx_LABEL_REF (VOIDmode, final_label);\n \t\t  rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, fin_ref));\n-\t\t  JUMP_LABEL(j) = final_label;\n+\t\t  JUMP_LABEL (j) = final_label;\n \t\t  LABEL_NUSES (final_label) += 1;\n \t\t  emit_barrier ();\n \t\t}\n@@ -576,7 +1544,7 @@ expand_block_compare (rtx operands[])\n \t      rtx ifelse = gen_rtx_IF_THEN_ELSE (VOIDmode, ne_rtx,\n \t\t\t\t\t\t cvt_ref, pc_rtx);\n \t      rtx j = emit_jump_insn (gen_rtx_SET (pc_rtx, ifelse));\n-\t      JUMP_LABEL(j) = convert_label;\n+\t      JUMP_LABEL (j) = convert_label;\n \t      LABEL_NUSES (convert_label) += 1;\n \t    }\n \t  else\n@@ -791,9 +1759,9 @@ expand_strn_compare (rtx operands[], int no_length)\n       rtx jmp;\n \n       /* Strncmp for power8 in glibc does this:\n-\t rldicl\tr8,r3,0,52\n-\t cmpldi\tcr7,r8,4096-16\n-\t bgt\tcr7,L(pagecross) */\n+\t rldicl r8,r3,0,52\n+\t cmpldi cr7,r8,4096-16\n+\t bgt    cr7,L(pagecross) */\n \n       /* Make sure that the length we use for the alignment test and\n          the subsequent code generation are in agreement so we do not"}, {"sha": "ed6a9bdd0e59cf3596fcd941bc03dadee57562d4", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=5ec3397e38713089e0cef0cb948c29642bea05b4", "patch": "@@ -331,8 +331,12 @@ Target Report Var(rs6000_block_move_inline_limit) Init(0) RejectNegative Joined\n Specify how many bytes should be moved inline before calling out to memcpy/memmove.\n \n mblock-compare-inline-limit=\n-Target Report Var(rs6000_block_compare_inline_limit) Init(5) RejectNegative Joined UInteger Save\n-Specify the maximum number pairs of load instructions that should be generated inline for the compare.  If the number needed exceeds the limit, a call to memcmp will be generated instead.\n+Target Report Var(rs6000_block_compare_inline_limit) Init(31) RejectNegative Joined UInteger Save\n+Specify the maximum number of bytes to compare inline with non-looping code. If this is set to 0, all inline expansion (non-loop and loop) of memcmp is disabled.\n+\n+mblock-compare-inline-loop-limit=\n+Target Report Var(rs6000_block_compare_inline_loop_limit) Init(-1) RejectNegative Joined UInteger Save\n+Specify the maximum number of bytes to compare inline with loop code generation.  If the length is not known at compile time, memcmp will be called after this many bytes are compared. By default, a length will be picked depending on the tuning target.\n \n mstring-compare-inline-limit=\n Target Report Var(rs6000_string_compare_inline_limit) Init(8) RejectNegative Joined UInteger Save"}, {"sha": "889c7ed90616e2d837e72ede9b803e71a50f4307", "filename": "gcc/testsuite/gcc.dg/memcmp-1.c", "status": "modified", "additions": 101, "deletions": 7, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c?ref=5ec3397e38713089e0cef0cb948c29642bea05b4", "patch": "@@ -14,11 +14,80 @@ int lib_strncmp(const char *a, const char *b, size_t n) asm(\"strncmp\");\n #ifndef NRAND\n #define NRAND 10000\n #endif\n-#define MAX_SZ 200\n+#define MAX_SZ 600\n+\n+#define DEF_RS(ALIGN)                                                      \\\n+static void test_memcmp_runtime_size_ ## ALIGN (const char *str1, \t   \\\n+\t\t\t\t\t\tconst char *str2,\t   \\\n+\t\t\t\t\t\tsize_t sz, int expect)\t   \\\n+{\t\t\t\t\t\t\t\t\t   \\\n+  char three[8192] __attribute__ ((aligned (4096)));\t\t\t   \\\n+  char four[8192] __attribute__ ((aligned (4096)));\t\t\t   \\\n+  char *a, *b;\t\t\t\t\t\t\t\t   \\\n+  int i,j,a1,a2,r;\t\t\t\t\t\t\t   \\\n+  for (j = 0; j < 2; j++)\t\t\t\t\t\t   \\\n+    {\t\t\t\t\t\t\t\t\t   \\\n+      for (i = 0; i < 2; i++)\t\t\t\t\t\t   \\\n+\t{\t\t\t\t\t\t\t\t   \\\n+\t  a = three+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t   \\\n+\t  b = four+i*ALIGN+j*(4096-2*i*ALIGN);\t\t\t\t   \\\n+\t  memcpy(a,str1,sz);\t\t\t\t\t\t   \\\n+\t  memcpy(b,str2,sz);\t\t\t\t\t\t   \\\n+\t  asm(\" \");\t\t\t\t\t\t\t   \\\n+\t  r = memcmp(a,b,sz);\t\t\t\t\t\t   \\\n+\t  asm(\" \");\t\t\t\t\t\t\t   \\\n+\t  if ( r < 0 && !(expect < 0) ) abort();\t\t\t   \\\n+\t  if ( r > 0 && !(expect > 0) )\tabort();\t\t\t   \\\n+\t  if ( r == 0 && !(expect == 0) ) abort();\t\t\t   \\\n+\t}\t\t\t\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t\t   \\\n+}\n+\n+DEF_RS(1)\n+DEF_RS(2)\n+DEF_RS(4)\n+DEF_RS(8)\n+DEF_RS(16)\n+\n+static void test_memcmp_runtime_size (const char *str1, const char *str2,\n+\t\t\t\t      size_t sz, int expect)\n+{\n+  char three[8192] __attribute__ ((aligned (4096)));\n+  char four[8192] __attribute__ ((aligned (4096)));\n+  char *a, *b;\n+  int i,j,a1,a2,r;\n+  test_memcmp_runtime_size_1 (str1,str2,sz,expect);\n+  test_memcmp_runtime_size_2 (str1,str2,sz,expect);\n+  test_memcmp_runtime_size_4 (str1,str2,sz,expect);\n+  test_memcmp_runtime_size_8 (str1,str2,sz,expect);\n+  test_memcmp_runtime_size_16 (str1,str2,sz,expect);\n+  for (j = 0; j < 2; j++)\n+    {\n+      for (i = 0; i < 2; i++)\n+\t{\n+\t  for (a1=0; a1 < 2*sizeof(void *); a1++)\n+\t    {\n+\t      for (a2=0; a2 < 2*sizeof(void *); a2++)\n+\t\t{\n+\t\t  a = three+i*a1+j*(4096-2*i*a1);\n+\t\t  b = four+i*a2+j*(4096-2*i*a2);\n+\t\t  memcpy(a,str1,sz);\n+\t\t  memcpy(b,str2,sz);\n+\t\t  asm(\" \");\n+\t\t  r = memcmp(a,b,sz);\n+\t\t  asm(\" \");\n+\t\t  if ( r < 0 && !(expect < 0) ) abort();\n+\t\t  if ( r > 0 && !(expect > 0) )\tabort();\n+\t\t  if ( r == 0 && !(expect == 0) ) abort();\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n \n static void test_driver_memcmp (void (test_memcmp)(const char *, const char *, int),\n \t\t\t\tvoid (test_strncmp)(const char *, const char *, int),\n-\t\t\t\tsize_t sz, int align)\n+  size_t sz, int align)\n {\n   char buf1[MAX_SZ*2+10],buf2[MAX_SZ*2+10];\n   size_t test_sz = (sz<MAX_SZ)?sz:MAX_SZ;\n@@ -35,11 +104,12 @@ static void test_driver_memcmp (void (test_memcmp)(const char *, const char *, i\n \tbuf1[j] = rand() & 0xff;\n \tbuf2[j] = rand() & 0xff;\n       }\n+      e = lib_memcmp(buf1,buf2,sz);\n+      (*test_memcmp)(buf1,buf2,e);\n+      test_memcmp_runtime_size (buf1, buf2, sz, e);\n+      e = lib_strncmp(buf1,buf2,sz);\n+      (*test_strncmp)(buf1,buf2,e);\n     }\n-    e = lib_memcmp(buf1,buf2,sz);\n-    (*test_memcmp)(buf1,buf2,e);\n-    e = lib_strncmp(buf1,buf2,sz);\n-    (*test_strncmp)(buf1,buf2,e);\n   }\n   for(diff_pos = ((test_sz>10)?(test_sz-10):0); diff_pos < test_sz+10; diff_pos++)\n     for(zero_pos = ((test_sz>10)?(test_sz-10):0); zero_pos < test_sz+10; zero_pos++)\n@@ -53,6 +123,9 @@ static void test_driver_memcmp (void (test_memcmp)(const char *, const char *, i\n \t(*test_memcmp)(buf1,buf2,e);\n \t(*test_memcmp)(buf2,buf1,-e);\n \t(*test_memcmp)(buf2,buf2,0);\n+\ttest_memcmp_runtime_size (buf1, buf2, sz, e);\n+\ttest_memcmp_runtime_size (buf2, buf1, sz, -e);\n+\ttest_memcmp_runtime_size (buf2, buf2, sz, 0);\n \te = lib_strncmp(buf1,buf2,sz);\n \t(*test_strncmp)(buf1,buf2,e);\n \t(*test_strncmp)(buf2,buf1,-e);\n@@ -61,13 +134,16 @@ static void test_driver_memcmp (void (test_memcmp)(const char *, const char *, i\n \tbuf2[diff_pos] = 0;\n \te = lib_memcmp(buf1,buf2,sz);\n \t(*test_memcmp)(buf1,buf2,e);\n+\ttest_memcmp_runtime_size (buf1, buf2, sz, e);\n \te = lib_strncmp(buf1,buf2,sz);\n \t(*test_strncmp)(buf1,buf2,e);\n \tmemset(buf2+diff_pos,'B',sizeof(buf2)-diff_pos);\n \tbuf2[zero_pos] = 0;\n \te = lib_memcmp(buf1,buf2,sz);\n \t(*test_memcmp)(buf1,buf2,e);\n \t(*test_memcmp)(buf2,buf1,-e);\n+\ttest_memcmp_runtime_size (buf1, buf2, sz, e);\n+\ttest_memcmp_runtime_size (buf2, buf1, sz, -e);\n \te = lib_strncmp(buf1,buf2,sz);\n \t(*test_strncmp)(buf1,buf2,e);\n \t(*test_strncmp)(buf2,buf1,-e);\n@@ -371,7 +447,14 @@ DEF_TEST(100,2)\n DEF_TEST(100,4)\n DEF_TEST(100,8)\n DEF_TEST(100,16)\n+DEF_TEST(191,1)\n+DEF_TEST(192,1)\n+DEF_TEST(193,1)\n+DEF_TEST(200,1)\n+DEF_TEST(400,1)\n #else\n+DEF_TEST(1,1)\n+DEF_TEST(2,1)\n DEF_TEST(3,1)\n DEF_TEST(4,1)\n DEF_TEST(5,1)\n@@ -389,13 +472,15 @@ DEF_TEST(16,1)\n DEF_TEST(32,1)\n DEF_TEST(100,1)\n DEF_TEST(100,8)\n+DEF_TEST(180,1)\n+DEF_TEST(180,8)\n #endif\n \n int\n main(int argc, char **argv)\n {\n #ifdef TEST_ALL\n-  RUN_TEST(1,1)\n+    RUN_TEST(1,1)\n     RUN_TEST(1,2)\n     RUN_TEST(1,4)\n     RUN_TEST(1,8)\n@@ -645,7 +730,14 @@ main(int argc, char **argv)\n     RUN_TEST(100,4)\n     RUN_TEST(100,8)\n     RUN_TEST(100,16)\n+    RUN_TEST(191,1)\n+    RUN_TEST(192,1)\n+    RUN_TEST(193,1)\n+    RUN_TEST(200,1)\n+    RUN_TEST(400,1)\n #else\n+    RUN_TEST(1,1)\n+    RUN_TEST(2,1)\n     RUN_TEST(3,1)\n     RUN_TEST(4,1)\n     RUN_TEST(5,1)\n@@ -663,5 +755,7 @@ main(int argc, char **argv)\n     RUN_TEST(32,1)\n     RUN_TEST(100,1)\n     RUN_TEST(100,8)\n+    RUN_TEST(180,1)\n+    RUN_TEST(180,8)\n #endif\n }"}, {"sha": "f5555ba40817588b4ed7fed5a3ca0b87a3a9fccd", "filename": "gcc/testsuite/gcc.dg/strncmp-2.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec3397e38713089e0cef0cb948c29642bea05b4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrncmp-2.c?ref=5ec3397e38713089e0cef0cb948c29642bea05b4", "patch": "@@ -81,6 +81,15 @@ DEF_TEST(13)\n DEF_TEST(14)\n DEF_TEST(15)\n DEF_TEST(16)\n+DEF_TEST(32)\n+DEF_TEST(64)\n+DEF_TEST(65)\n+DEF_TEST(66)\n+DEF_TEST(67)\n+DEF_TEST(68)\n+DEF_TEST(69)\n+DEF_TEST(70)\n+DEF_TEST(71)\n \n int\n main(int argc, char **argv)\n@@ -101,5 +110,14 @@ main(int argc, char **argv)\n   RUN_TEST(14);\n   RUN_TEST(15);\n   RUN_TEST(16);\n+  RUN_TEST(32);\n+  RUN_TEST(64);\n+  RUN_TEST(65);\n+  RUN_TEST(66);\n+  RUN_TEST(67);\n+  RUN_TEST(68);\n+  RUN_TEST(69);\n+  RUN_TEST(70);\n+  RUN_TEST(71);\n   return 0;\n }"}]}