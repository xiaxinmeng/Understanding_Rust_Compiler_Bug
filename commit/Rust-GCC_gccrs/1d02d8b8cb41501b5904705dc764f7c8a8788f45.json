{"sha": "1d02d8b8cb41501b5904705dc764f7c8a8788f45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQwMmQ4YjhjYjQxNTAxYjU5MDQ3MDVkYzc2NGY3YzhhODc4OGY0NQ==", "commit": {"author": {"name": "Terry Guo", "email": "terry.guo@arm.com", "date": "2014-06-11T09:47:35Z"}, "committer": {"name": "Xuepeng Guo", "email": "xguo@gcc.gnu.org", "date": "2014-06-11T09:47:35Z"}, "message": "arm.md (*thumb1_adddi3): Move into new file thumb1.md.\n\n2014-06-11  Terry Guo  <terry.guo@arm.com>\n\n\t* config/arm/arm.md (*thumb1_adddi3): Move into new file thumb1.md.\n\t(*thumb1_addsi3): Ditto.\n\t(*thumb_subdi3): Ditto.\n\t(thumb1_subsi3_insn): Ditto.\n\t(*thumb_mulsi3): Ditto.\n\t(*thumb_mulsi3_v6): Ditto.\n\t(*thumb1_andsi3_insn): Ditto.\n\t(thumb1_bicsi3): Ditto.\n\t(*thumb1_iorsi3_insn): Ditto.\n\t(*thumb1_xorsi3_insn): Ditto.\n\t(*thumb1_ashlsi3): Ditto.\n\t(*thumb1_ashrsi3): Ditto.\n\t(*thumb1_lshrsi3): Ditto.\n\t(*thumb1_rotrsi3): Ditto.\n\t(*thumb1_negdi2): Ditto.\n\t(*thumb1_negsi2): Ditto.\n\t(*thumb1_abssi2): Ditto.\n\t(*thumb1_neg_abssi2): Ditto.\n\t(*thumb1_one_cmplsi2): Ditto.\n\t(*thumb1_zero_extendhisi2): Ditto.\n\t(*thumb1_zero_extendqisi2): Ditto.\n\t(*thumb1_zero_extendqisi2_v6): Ditto.\n\t(thumb1_extendhisi2): Ditto.\n\t(thumb1_extendqisi2): Ditto.\n\t(*thumb1_movdi_insn): Ditto.\n\t(*thumb1_movsi_insn): Ditto.\n\t(*thumb1_movhi_insn): Ditto.\n\t(thumb_movhi_clobber): Ditto.\n\t(*thumb1_movqi_insn): Ditto.\n\t(*thumb1_movhf): Ditto.\n\t(*thumb1_movsf_insn): Ditto.\n\t(*thumb_movdf_insn): Ditto.\n\t(movmem12b): Ditto.\n\t(movmem8b): Ditto.\n\t(cbranchqi4): Ditto.\n\t(cbranchsi4_insn): Ditto.\n\t(cbranchsi4_scratch): Ditto.\n\t(*negated_cbranchsi4): Ditto.\n\t(*tbit_cbranch): Ditto.\n\t(*tlobits_cbranch): Ditto.\n\t(*tstsi3_cbranch): Ditto.\n\t(*cbranchne_decr1): Ditto.\n\t(*addsi3_cbranch): Ditto.\n\t(*addsi3_cbranch_scratch): Ditto.\n\t(*thumb_cmpdi_zero): Ditto.\n\t(cstoresi_eq0_thumb1): Ditto.\n\t(cstoresi_ne0_thumb1): Ditto.\n\t(*cstoresi_eq0_thumb1_insn): Ditto.\n\t(*cstoresi_ne0_thumb1_insn): Ditto.\n\t(cstoresi_nltu_thumb1): Ditto.\n\t(cstoresi_ltu_thumb1): Ditto.\n\t(thumb1_addsi3_addgeu): Ditto.\n\t(*thumb_jump): Ditto.\n\t(*call_reg_thumb1_v5): Ditto.\n\t(*call_reg_thumb1): Ditto.\n\t(*call_value_reg_thumb1_v5): Ditto.\n\t(*call_value_reg_thumb1): Ditto.\n\t(*call_insn): Ditto.\n\t(*call_value_insn): Ditto.\n\t(thumb1_casesi_internal_pic): Ditto.\n\t(thumb1_casesi_dispatch): Ditto.\n\t(*thumb1_indirect_jump): Ditto.\n\t(prologue_thumb1_interwork): Ditto.\n\t(*epilogue_insns): Ditto.\n\t(consttable_1): Ditto.\n\t(consttable_2): Ditto.\n\t(tablejump): Ditto.\n\t(*thumb1_tablejump): Ditto.\n\t(thumb_eh_return): Ditto.\n\t(define_peephole2): Two of them are thumb1 only and got moved into\n\tnew file thumb1.md.\n\t(define_split): Six of them are thumb1 only and got moved into new\n\tfile thumb1.md.\n\t* config/arm/thumb1.md: New file comprised of above thumb1 only\n\tpatterns.\n\nFrom-SVN: r211443", "tree": {"sha": "b260a006fc30c53129b5ee6975c8b8b242984632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b260a006fc30c53129b5ee6975c8b8b242984632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d02d8b8cb41501b5904705dc764f7c8a8788f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02d8b8cb41501b5904705dc764f7c8a8788f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d02d8b8cb41501b5904705dc764f7c8a8788f45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02d8b8cb41501b5904705dc764f7c8a8788f45/comments", "author": null, "committer": null, "parents": [{"sha": "338329a085ccce3c898694e0326831ea9a39ff05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338329a085ccce3c898694e0326831ea9a39ff05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338329a085ccce3c898694e0326831ea9a39ff05"}], "stats": {"total": 3661, "additions": 1882, "deletions": 1779}, "files": [{"sha": "d46861d2f581127a6595d2d19d0183a0215ece8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d02d8b8cb41501b5904705dc764f7c8a8788f45", "patch": "@@ -1,3 +1,81 @@\n+2014-06-11  Terry Guo  <terry.guo@arm.com>\n+\n+\t* config/arm/arm.md (*thumb1_adddi3): Move into new file thumb1.md.\n+\t(*thumb1_addsi3): Ditto.\n+\t(*thumb_subdi3): Ditto.\n+\t(thumb1_subsi3_insn): Ditto.\n+\t(*thumb_mulsi3): Ditto.\n+\t(*thumb_mulsi3_v6): Ditto.\n+\t(*thumb1_andsi3_insn): Ditto.\n+\t(thumb1_bicsi3): Ditto.\n+\t(*thumb1_iorsi3_insn): Ditto.\n+\t(*thumb1_xorsi3_insn): Ditto.\n+\t(*thumb1_ashlsi3): Ditto.\n+\t(*thumb1_ashrsi3): Ditto.\n+\t(*thumb1_lshrsi3): Ditto.\n+\t(*thumb1_rotrsi3): Ditto.\n+\t(*thumb1_negdi2): Ditto.\n+\t(*thumb1_negsi2): Ditto.\n+\t(*thumb1_abssi2): Ditto.\n+\t(*thumb1_neg_abssi2): Ditto.\n+\t(*thumb1_one_cmplsi2): Ditto.\n+\t(*thumb1_zero_extendhisi2): Ditto.\n+\t(*thumb1_zero_extendqisi2): Ditto.\n+\t(*thumb1_zero_extendqisi2_v6): Ditto.\n+\t(thumb1_extendhisi2): Ditto.\n+\t(thumb1_extendqisi2): Ditto.\n+\t(*thumb1_movdi_insn): Ditto.\n+\t(*thumb1_movsi_insn): Ditto.\n+\t(*thumb1_movhi_insn): Ditto.\n+\t(thumb_movhi_clobber): Ditto.\n+\t(*thumb1_movqi_insn): Ditto.\n+\t(*thumb1_movhf): Ditto.\n+\t(*thumb1_movsf_insn): Ditto.\n+\t(*thumb_movdf_insn): Ditto.\n+\t(movmem12b): Ditto.\n+\t(movmem8b): Ditto.\n+\t(cbranchqi4): Ditto.\n+\t(cbranchsi4_insn): Ditto.\n+\t(cbranchsi4_scratch): Ditto.\n+\t(*negated_cbranchsi4): Ditto.\n+\t(*tbit_cbranch): Ditto.\n+\t(*tlobits_cbranch): Ditto.\n+\t(*tstsi3_cbranch): Ditto.\n+\t(*cbranchne_decr1): Ditto.\n+\t(*addsi3_cbranch): Ditto.\n+\t(*addsi3_cbranch_scratch): Ditto.\n+\t(*thumb_cmpdi_zero): Ditto.\n+\t(cstoresi_eq0_thumb1): Ditto.\n+\t(cstoresi_ne0_thumb1): Ditto.\n+\t(*cstoresi_eq0_thumb1_insn): Ditto.\n+\t(*cstoresi_ne0_thumb1_insn): Ditto.\n+\t(cstoresi_nltu_thumb1): Ditto.\n+\t(cstoresi_ltu_thumb1): Ditto.\n+\t(thumb1_addsi3_addgeu): Ditto.\n+\t(*thumb_jump): Ditto.\n+\t(*call_reg_thumb1_v5): Ditto.\n+\t(*call_reg_thumb1): Ditto.\n+\t(*call_value_reg_thumb1_v5): Ditto.\n+\t(*call_value_reg_thumb1): Ditto.\n+\t(*call_insn): Ditto.\n+\t(*call_value_insn): Ditto.\n+\t(thumb1_casesi_internal_pic): Ditto.\n+\t(thumb1_casesi_dispatch): Ditto.\n+\t(*thumb1_indirect_jump): Ditto.\n+\t(prologue_thumb1_interwork): Ditto.\n+\t(*epilogue_insns): Ditto.\n+\t(consttable_1): Ditto.\n+\t(consttable_2): Ditto.\n+\t(tablejump): Ditto.\n+\t(*thumb1_tablejump): Ditto.\n+\t(thumb_eh_return): Ditto.\n+\t(define_peephole2): Two of them are thumb1 only and got moved into\n+\tnew file thumb1.md.\n+\t(define_split): Six of them are thumb1 only and got moved into new\n+\tfile thumb1.md.\n+\t* config/arm/thumb1.md: New file comprised of above thumb1 only\n+\tpatterns.\n+\n 2014-06-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config.gcc (aarch64*-*-*): Add arm_acle.h to extra headers."}, {"sha": "6ae240e8b6ec127bdde5dfe8953fc574a6854040", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 15, "deletions": 1779, "changes": 1794, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=1d02d8b8cb41501b5904705dc764f7c8a8788f45", "patch": "@@ -437,18 +437,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_adddi3\"\n-  [(set (match_operand:DI          0 \"register_operand\" \"=l\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"l\")))\n-   (clobber (reg:CC CC_REGNUM))\n-  ]\n-  \"TARGET_THUMB1\"\n-  \"add\\\\t%Q0, %Q0, %Q2\\;adc\\\\t%R0, %R0, %R2\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn_and_split \"*arm_adddi3\"\n   [(set (match_operand:DI          0 \"s_register_operand\" \"=&r,&r,&r,&r,&r\")\n \t(plus:DI (match_operand:DI 1 \"s_register_operand\" \"%0, 0, r, 0, r\")\n@@ -613,71 +601,6 @@\n  ]\n )\n \n-(define_insn_and_split \"*thumb1_addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*rk,*hk,l,k,l,l,l\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,k,k,0,l,k\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*hk,*rk,M,O,Pa,Pb,Pc\")))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-   static const char * const asms[] = \n-   {\n-     \\\"add\\\\t%0, %0, %2\\\",\n-     \\\"sub\\\\t%0, %0, #%n2\\\",\n-     \\\"add\\\\t%0, %1, %2\\\",\n-     \\\"add\\\\t%0, %0, %2\\\",\n-     \\\"add\\\\t%0, %0, %2\\\",\n-     \\\"add\\\\t%0, %1, %2\\\",\n-     \\\"add\\\\t%0, %1, %2\\\",\n-     \\\"#\\\",\n-     \\\"#\\\",\n-     \\\"#\\\"\n-   };\n-   if ((which_alternative == 2 || which_alternative == 6)\n-       && CONST_INT_P (operands[2])\n-       && INTVAL (operands[2]) < 0)\n-     return \\\"sub\\\\t%0, %1, #%n2\\\";\n-   return asms[which_alternative];\n-  \"\n-  \"&& reload_completed && CONST_INT_P (operands[2])\n-   && ((operands[1] != stack_pointer_rtx\n-        && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255))\n-       || (operands[1] == stack_pointer_rtx\n- \t   && INTVAL (operands[2]) > 1020))\"\n-  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n-  {\n-    HOST_WIDE_INT offset = INTVAL (operands[2]);\n-    if (operands[1] == stack_pointer_rtx)\n-      offset -= 1020;\n-    else\n-      {\n-        if (offset > 255)\n-\t  offset = 255;\n-\telse if (offset < -255)\n-\t  offset = -255;\n-      }\n-    operands[3] = GEN_INT (offset);\n-    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);\n-  }\n-  [(set_attr \"length\" \"2,2,2,2,2,2,2,4,4,4\")\n-   (set_attr \"type\" \"alus_imm,alus_imm,alus_reg,alus_reg,alus_reg,\n-\t\t     alus_reg,alus_reg,multiple,multiple,multiple\")]\n-)\n-\n-;; Reloading and elimination of the frame pointer can\n-;; sometimes cause this optimization to be missed.\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0) (reg:SI SP_REGNUM)))]\n-  \"TARGET_THUMB1\n-   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024\n-   && (INTVAL (operands[1]) & 3) == 0\"\n-  [(set (match_dup 0) (plus:SI (reg:SI SP_REGNUM) (match_dup 1)))]\n-  \"\"\n-)\n-\n (define_insn \"addsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV\n@@ -1090,17 +1013,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_insn \"*thumb_subdi3\"\n-  [(set (match_operand:DI           0 \"register_operand\" \"=l\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\"  \"0\")\n-\t\t  (match_operand:DI 2 \"register_operand\"  \"l\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_THUMB1\"\n-  \"sub\\\\t%Q0, %Q0, %Q2\\;sbc\\\\t%R0, %R0, %R2\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn_and_split \"*subdi_di_zesidi\"\n   [(set (match_operand:DI           0 \"s_register_operand\" \"=&r,&r\")\n \t(minus:DI (match_operand:DI 1 \"s_register_operand\"  \"0,r\")\n@@ -1256,17 +1168,6 @@\n   \"\n )\n \n-(define_insn \"thumb1_subsi3_insn\"\n-  [(set (match_operand:SI           0 \"register_operand\" \"=l\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n-\t\t  (match_operand:SI 2 \"reg_or_int_operand\" \"lPd\")))]\n-  \"TARGET_THUMB1\"\n-  \"sub\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"alus_reg\")]\n-)\n-\n ; ??? Check Thumb-2 split length\n (define_insn_and_split \"*arm_subsi3_insn\"\n   [(set (match_operand:SI           0 \"s_register_operand\" \"=l,l ,l ,l ,r ,r,r,rk,r\")\n@@ -1408,39 +1309,6 @@\n    (set_attr \"predicable_short_it\" \"yes,yes,no\")]\n )\n \n-; Unfortunately with the Thumb the '&'/'0' trick can fails when operands \n-; 1 and 2; are the same, because reload will make operand 0 match \n-; operand 1 without realizing that this conflicts with operand 2.  We fix \n-; this by adding another alternative to match this case, and then `reload' \n-; it ourselves.  This alternative must come first.\n-(define_insn \"*thumb_mulsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=&l,&l,&l\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%l,*h,0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"l,l,l\")))]\n-  \"TARGET_THUMB1 && !arm_arch6\"\n-  \"*\n-  if (which_alternative < 2)\n-    return \\\"mov\\\\t%0, %1\\;mul\\\\t%0, %2\\\";\n-  else\n-    return \\\"mul\\\\t%0, %2\\\";\n-  \"\n-  [(set_attr \"length\" \"4,4,2\")\n-   (set_attr \"type\" \"muls\")]\n-)\n-\n-(define_insn \"*thumb_mulsi3_v6\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"0,l,0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"l,0,0\")))]\n-  \"TARGET_THUMB1 && arm_arch6\"\n-  \"@\n-   mul\\\\t%0, %2\n-   mul\\\\t%0, %1\n-   mul\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"muls\")]\n-)\n-\n (define_insn \"*mulsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV (mult:SI\n@@ -2295,16 +2163,6 @@\n    (set_attr \"type\" \"logic_imm,logic_imm,logic_reg,logic_reg,logic_imm\")]\n )\n \n-(define_insn \"*thumb1_andsi3_insn\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"and\\\\t%0, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\"  \"logic_imm\")\n-   (set_attr \"conds\" \"set\")])\n-\n (define_insn \"*andsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV\n@@ -2493,23 +2351,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))\n-   (clobber (match_operand:SI 4 \"s_register_operand\" \"\"))]\n-  \"TARGET_THUMB1\"\n-  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (lshiftrt:SI (match_dup 4) (match_dup 3)))]\n-  \"{\n-     HOST_WIDE_INT temp = INTVAL (operands[2]);\n-\n-     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n-     operands[3] = GEN_INT (32 - temp);\n-   }\"\n-)\n-\n ;; ??? Use Thumb-2 has bitfield insert/extract instructions.\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n@@ -2533,22 +2374,6 @@\n    }\"\n )\n   \n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"TARGET_THUMB1\"\n-  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 3)))]\n-  \"{\n-     HOST_WIDE_INT temp = INTVAL (operands[2]);\n-\n-     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n-     operands[3] = GEN_INT (32 - temp);\n-   }\"\n-)\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(match_operator:SI 1 \"shiftable_operator\"\n@@ -2921,17 +2746,6 @@\n    (set_attr \"type\" \"logic_reg\")]\n )\n \n-(define_insn \"thumb1_bicsi3\"\n-  [(set (match_operand:SI                 0 \"register_operand\" \"=l\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"l\"))\n-\t\t(match_operand:SI         2 \"register_operand\" \"0\")))]\n-  \"TARGET_THUMB1\"\n-  \"bic\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"logics_reg\")]\n-)\n-\n (define_insn \"andsi_not_shiftsi_si\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(and:SI (not:SI (match_operator:SI 4 \"shift_operator\"\n@@ -3111,16 +2925,6 @@\n    (set_attr \"type\" \"logic_imm,logic_reg,logic_imm,logic_reg,logic_reg\")]\n )\n \n-(define_insn \"*thumb1_iorsi3_insn\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"orr\\\\t%0, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"logics_reg\")])\n-\n (define_peephole2\n   [(match_scratch:SI 3 \"r\")\n    (set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n@@ -3287,17 +3091,6 @@\n    (set_attr \"type\"  \"logic_imm,logic_reg,logic_reg,multiple\")]\n )\n \n-(define_insn \"*thumb1_xorsi3_insn\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"eor\\\\t%0, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"logics_reg\")]\n-)\n-\n (define_insn \"*xorsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV (xor:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\")\n@@ -3903,16 +3696,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_ashlsi3\"\n-  [(set (match_operand:SI            0 \"register_operand\" \"=l,l\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"TARGET_THUMB1\"\n-  \"lsl\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"shift_imm,shift_reg\")\n-   (set_attr \"conds\" \"set\")])\n-\n (define_expand \"ashrdi3\"\n   [(set (match_operand:DI              0 \"s_register_operand\" \"\")\n         (ashiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n@@ -3984,16 +3767,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_ashrsi3\"\n-  [(set (match_operand:SI              0 \"register_operand\" \"=l,l\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"TARGET_THUMB1\"\n-  \"asr\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"shift_imm,shift_reg\")\n-   (set_attr \"conds\" \"set\")])\n-\n (define_expand \"lshrdi3\"\n   [(set (match_operand:DI              0 \"s_register_operand\" \"\")\n         (lshiftrt:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n@@ -4068,16 +3841,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_lshrsi3\"\n-  [(set (match_operand:SI              0 \"register_operand\" \"=l,l\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"TARGET_THUMB1\"\n-  \"lsr\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"shift_imm,shift_reg\")\n-   (set_attr \"conds\" \"set\")])\n-\n (define_expand \"rotlsi3\"\n   [(set (match_operand:SI              0 \"s_register_operand\" \"\")\n \t(rotatert:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -4115,16 +3878,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_rotrsi3\"\n-  [(set (match_operand:SI              0 \"register_operand\" \"=l\")\n-\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"ror\\\\t%0, %0, %2\"\n-  [(set_attr \"type\" \"shift_reg\")\n-   (set_attr \"length\" \"2\")]\n-)\n-\n (define_insn \"*arm_shiftsi3\"\n   [(set (match_operand:SI   0 \"s_register_operand\" \"=l,l,r,r\")\n \t(match_operator:SI  3 \"shift_operator\"\n@@ -4592,16 +4345,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_insn \"*thumb1_negdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&l\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\" \"l\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_THUMB1\"\n-  \"mov\\\\t%R0, #0\\;neg\\\\t%Q0, %Q1\\;sbc\\\\t%R0, %R1\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"negsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(neg:SI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n@@ -4621,15 +4364,6 @@\n    (set_attr \"type\" \"alu_reg\")]\n )\n \n-(define_insn \"*thumb1_negsi2\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"neg\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"alu_imm\")]\n-)\n-\n (define_expand \"negsf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"\")\n \t(neg:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n@@ -4843,21 +4577,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_insn_and_split \"*thumb1_abssi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n-\t(abs:SI (match_operand:SI 1 \"s_register_operand\" \"l\")))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"#\"\n-  \"TARGET_THUMB1 && reload_completed\"\n-  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))\n-   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]\n-  \"\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn_and_split \"*arm_neg_abssi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,&r\")\n \t(neg:SI (abs:SI (match_operand:SI 1 \"s_register_operand\" \"0,r\"))))\n@@ -4915,21 +4634,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_insn_and_split \"*thumb1_neg_abssi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n-\t(neg:SI (abs:SI (match_operand:SI 1 \"s_register_operand\" \"l\"))))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"#\"\n-  \"TARGET_THUMB1 && reload_completed\"\n-  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))\n-   (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]\n-  \"\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"abssf2\"\n   [(set (match_operand:SF         0 \"s_register_operand\" \"\")\n \t(abs:SF (match_operand:SF 1 \"s_register_operand\" \"\")))]\n@@ -4999,15 +4703,6 @@\n    (set_attr \"type\" \"mvn_reg\")]\n )\n \n-(define_insn \"*thumb1_one_cmplsi2\"\n-  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\"  \"l\")))]\n-  \"TARGET_THUMB1\"\n-  \"mvn\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"mvn_reg\")]\n-)\n-\n (define_insn \"*notsi_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV (not:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n@@ -5251,49 +4946,6 @@\n   operands[2] = gen_lowpart (SImode, operands[1]);\n })\n \n-(define_insn \"*thumb1_zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))]\n-  \"TARGET_THUMB1\"\n-{\n-  rtx mem;\n-\n-  if (which_alternative == 0 && arm_arch6)\n-    return \"uxth\\t%0, %1\";\n-  if (which_alternative == 0)\n-    return \"#\";\n-\n-  mem = XEXP (operands[1], 0);\n-\n-  if (GET_CODE (mem) == CONST)\n-    mem = XEXP (mem, 0);\n-    \n-  if (GET_CODE (mem) == PLUS)\n-    {\n-      rtx a = XEXP (mem, 0);\n-\n-      /* This can happen due to bugs in reload.  */\n-      if (REG_P (a) && REGNO (a) == SP_REGNUM)\n-        {\n-          rtx ops[2];\n-          ops[0] = operands[0];\n-          ops[1] = a;\n-      \n-          output_asm_insn (\"mov\\t%0, %1\", ops);\n-\n-          XEXP (mem, 0) = operands[0];\n-       }\n-    }\n-    \n-  return \"ldrh\\t%0, %1\";\n-}\n-  [(set_attr_alternative \"length\"\n-\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n-\t\t\t\t       (const_int 2) (const_int 4))\n-\t\t\t (const_int 4)])\n-   (set_attr \"type\" \"extend,load_byte\")]\n-)\n-\n (define_insn \"*arm_zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -5364,29 +5016,6 @@\n     }\n })\n \n-(define_insn \"*thumb1_zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n-  \"TARGET_THUMB1 && !arm_arch6\"\n-  \"@\n-   #\n-   ldrb\\\\t%0, %1\"\n-  [(set_attr \"length\" \"4,2\")\n-   (set_attr \"type\" \"alu_shift_reg,load_byte\")\n-   (set_attr \"pool_range\" \"*,32\")]\n-)\n-\n-(define_insn \"*thumb1_zero_extendqisi2_v6\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n-  \"TARGET_THUMB1 && arm_arch6\"\n-  \"@\n-   uxtb\\\\t%0, %1\n-   ldrb\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"extend,load_byte\")]\n-)\n-\n (define_insn \"*arm_zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n@@ -5512,80 +5141,6 @@\n   operands[2] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n })\n \n-;; We used to have an early-clobber on the scratch register here.\n-;; However, there's a bug somewhere in reload which means that this\n-;; can be partially ignored during spill allocation if the memory\n-;; address also needs reloading; this causes us to die later on when\n-;; we try to verify the operands.  Fortunately, we don't really need\n-;; the early-clobber: we can always use operand 0 if operand 2\n-;; overlaps the address.\n-(define_insn \"thumb1_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))\n-   (clobber (match_scratch:SI 2 \"=X,l\"))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  {\n-    rtx ops[4];\n-    rtx mem;\n-\n-    if (which_alternative == 0 && !arm_arch6)\n-      return \\\"#\\\";\n-    if (which_alternative == 0)\n-      return \\\"sxth\\\\t%0, %1\\\";\n-\n-    mem = XEXP (operands[1], 0);\n-\n-    /* This code used to try to use 'V', and fix the address only if it was\n-       offsettable, but this fails for e.g. REG+48 because 48 is outside the\n-       range of QImode offsets, and offsettable_address_p does a QImode\n-       address check.  */\n-       \n-    if (GET_CODE (mem) == CONST)\n-      mem = XEXP (mem, 0);\n-    \n-    if (GET_CODE (mem) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n-    \n-    if (GET_CODE (mem) == PLUS)\n-      {\n-        rtx a = XEXP (mem, 0);\n-        rtx b = XEXP (mem, 1);\n-\n-        if (GET_CODE (a) == LABEL_REF\n-\t    && CONST_INT_P (b))\n-          return \\\"ldr\\\\t%0, %1\\\";\n-\n-        if (REG_P (b))\n-          return \\\"ldrsh\\\\t%0, %1\\\";\n-\t  \n-        ops[1] = a;\n-        ops[2] = b;\n-      }\n-    else\n-      {\n-        ops[1] = mem;\n-        ops[2] = const0_rtx;\n-      }\n-      \n-    gcc_assert (REG_P (ops[1]));\n-\n-    ops[0] = operands[0];\n-    if (reg_mentioned_p (operands[2], ops[1]))\n-      ops[3] = ops[0];\n-    else\n-      ops[3] = operands[2];\n-    output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n-    return \\\"\\\";\n-  }\"\n-  [(set_attr_alternative \"length\"\n-\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n-\t\t\t\t\t(const_int 2) (const_int 4))\n-\t\t\t  (const_int 4)])\n-   (set_attr \"type\" \"extend,load_byte\")\n-   (set_attr \"pool_range\" \"*,1018\")]\n-)\n-\n ;; This pattern will only be used when ldsh is not available\n (define_expand \"extendhisi2_mem\"\n   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 \"\" \"\")))\n@@ -5774,105 +5329,6 @@\n    (set_attr \"predicable_short_it\" \"no\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"\")))]\n-  \"TARGET_THUMB1 && reload_completed\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (sign_extend:SI (match_dup 3)))]\n-{\n-  rtx addr = XEXP (operands[1], 0);\n-\n-  if (GET_CODE (addr) == CONST)\n-    addr = XEXP (addr, 0);\n-\n-  if (GET_CODE (addr) == PLUS\n-      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n-    /* No split necessary.  */\n-    FAIL;\n-\n-  if (GET_CODE (addr) == PLUS\n-      && !REG_P (XEXP (addr, 0)) && !REG_P (XEXP (addr, 1)))\n-    FAIL;\n-\n-  if (reg_overlap_mentioned_p (operands[0], addr))\n-    {\n-      rtx t = gen_lowpart (QImode, operands[0]);\n-      emit_move_insn (t, operands[1]);\n-      emit_insn (gen_thumb1_extendqisi2 (operands[0], t));\n-      DONE;\n-    }\n-\n-  if (REG_P (addr))\n-    {\n-      addr = gen_rtx_PLUS (Pmode, addr, operands[0]);\n-      operands[2] = const0_rtx;\n-    }\n-  else if (GET_CODE (addr) != PLUS)\n-    FAIL;\n-  else if (REG_P (XEXP (addr, 0)))\n-    {\n-      operands[2] = XEXP (addr, 1);\n-      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 0), operands[0]);\n-    }\n-  else\n-    {\n-      operands[2] = XEXP (addr, 0);\n-      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 1), operands[0]);\n-    }\n-\n-  operands[3] = change_address (operands[1], QImode, addr);\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0) (match_operand 1 \"const_int_operand\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"\") (const_int 0))\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 4 \"memory_operand\" \"\")))]\n-  \"TARGET_THUMB1\n-   && GET_CODE (XEXP (operands[4], 0)) == PLUS\n-   && rtx_equal_p (operands[0], XEXP (XEXP (operands[4], 0), 0))\n-   && rtx_equal_p (operands[2], XEXP (XEXP (operands[4], 0), 1))\n-   && (peep2_reg_dead_p (3, operands[0])\n-       || rtx_equal_p (operands[0], operands[3]))\n-   && (peep2_reg_dead_p (3, operands[2])\n-       || rtx_equal_p (operands[2], operands[3]))\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 3) (sign_extend:SI (match_dup 4)))]\n-{\n-  rtx addr = gen_rtx_PLUS (Pmode, operands[0], operands[2]);\n-  operands[4] = change_address (operands[4], QImode, addr);\n-})\n-\n-(define_insn \"thumb1_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,l\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,V,m\")))]\n-  \"TARGET_THUMB1\"\n-{\n-  rtx addr;\n-\n-  if (which_alternative == 0 && arm_arch6)\n-    return \"sxtb\\\\t%0, %1\";\n-  if (which_alternative == 0)\n-    return \"#\";\n-\n-  addr = XEXP (operands[1], 0);\n-  if (GET_CODE (addr) == PLUS\n-      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n-    return \"ldrsb\\\\t%0, %1\";\n-      \n-  return \"#\";\n-}\n-  [(set_attr_alternative \"length\"\n-\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n-\t\t\t\t\t(const_int 2) (const_int 4))\n-\t\t\t  (const_int 2)\n-\t\t\t  (if_then_else (eq_attr \"is_arch6\" \"yes\")\n-\t\t\t\t\t(const_int 4) (const_int 6))])\n-   (set_attr \"type\" \"extend,load_byte,load_byte\")]\n-)\n-\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF                  0 \"s_register_operand\" \"\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\"  \"\")))]\n@@ -6087,52 +5543,6 @@\n   \"\n )\n \n-;;; ??? This should have alternatives for constants.\n-;;; ??? This was originally identical to the movdf_insn pattern.\n-;;; ??? The 'i' constraint looks funny, but it should always be replaced by\n-;;; thumb_reorg with a memory reference.\n-(define_insn \"*thumb1_movdi_insn\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=l,l,l,l,>,l, m,*r\")\n-\t(match_operand:DI 1 \"general_operand\"      \"l, I,J,>,l,mi,l,*r\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode))\"\n-  \"*\n-  {\n-  switch (which_alternative)\n-    {\n-    default:\n-    case 0:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"add\\\\t%0,  %1,  #0\\;add\\\\t%H0, %H1, #0\\\";\n-      return   \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0,  %1,  #0\\\";\n-    case 1:\n-      return \\\"mov\\\\t%Q0, %1\\;mov\\\\t%R0, #0\\\";\n-    case 2:\n-      operands[1] = GEN_INT (- INTVAL (operands[1]));\n-      return \\\"mov\\\\t%Q0, %1\\;neg\\\\t%Q0, %Q0\\;asr\\\\t%R0, %Q0, #31\\\";\n-    case 3:\n-      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n-    case 4:\n-      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n-    case 5:\n-      return thumb_load_double_from_address (operands);\n-    case 6:\n-      operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t     plus_constant (Pmode, XEXP (operands[0], 0), 4));\n-      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n-      return \\\"\\\";\n-    case 7:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n-      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n-    }\n-  }\"\n-  [(set_attr \"length\" \"4,4,6,2,2,6,4,4\")\n-   (set_attr \"type\" \"multiple,multiple,multiple,load2,store2,load2,store2,multiple\")\n-   (set_attr \"pool_range\" \"*,*,*,*,*,1018,*,*\")]\n-)\n-\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n         (match_operand:SI 1 \"general_operand\" \"\"))]\n@@ -6324,95 +5734,20 @@\n   DONE;\n })\n \n-(define_insn \"*thumb1_movsi_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=l,l,l,l,l,>,l, m,*l*h*k\")\n-\t(match_operand:SI 1 \"general_operand\"      \"l, I,J,K,>,l,mi,l,*l*h*k\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], SImode) \n-       || register_operand (operands[1], SImode))\"\n-  \"@\n-   mov\t%0, %1\n-   mov\t%0, %1\n-   #\n-   #\n-   ldmia\\\\t%1, {%0}\n-   stmia\\\\t%0, {%1}\n-   ldr\\\\t%0, %1\n-   str\\\\t%1, %0\n-   mov\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2,2,4,4,2,2,2,2,2\")\n-   (set_attr \"type\" \"mov_reg,mov_imm,multiple,multiple,load1,store1,load1,store1,mov_reg\")\n-   (set_attr \"pool_range\" \"*,*,*,*,*,*,1018,*,*\")\n-   (set_attr \"conds\" \"set,clob,*,*,nocond,nocond,nocond,nocond,nocond\")])\n-\n-(define_split \n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_THUMB1 && satisfies_constraint_J (operands[1])\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (neg:SI (match_dup 2)))]\n-  \"\n-  {\n-    operands[1] = GEN_INT (- INTVAL (operands[1]));\n-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n-  }\"\n-)\n+;; When generating pic, we need to load the symbol offset into a register.\n+;; So that the optimizer does not confuse this with a normal symbol load\n+;; we use an unspec.  The offset will be loaded from a constant pool entry,\n+;; since that is the only type of relocation we can use.\n \n-(define_split \n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_THUMB1 && satisfies_constraint_K (operands[1])\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (ashift:SI (match_dup 2) (match_dup 3)))]\n-  \"\n-  {\n-    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;\n-    unsigned HOST_WIDE_INT mask = 0xff;\n-    int i;\n-    \n-    for (i = 0; i < 25; i++)\n-      if ((val & (mask << i)) == val)\n-        break;\n-\n-    /* Don't split if the shift is zero.  */\n-    if (i == 0)\n-      FAIL;\n-\n-    operands[1] = GEN_INT (val >> i);\n-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n-    operands[3] = GEN_INT (i);\n-  }\"\n-)\n-\n-;; For thumb1 split imm move [256-510] into mov [1-255] and add #255\n-(define_split \n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_THUMB1 && satisfies_constraint_Pe (operands[1])\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 3)))]\n-  \"\n-  {\n-    operands[1] = GEN_INT (INTVAL (operands[1]) - 255);\n-    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n-    operands[3] = GEN_INT (255);\n-  }\"\n-)\n-\n-;; When generating pic, we need to load the symbol offset into a register.\n-;; So that the optimizer does not confuse this with a normal symbol load\n-;; we use an unspec.  The offset will be loaded from a constant pool entry,\n-;; since that is the only type of relocation we can use.\n-\n-;; Wrap calculation of the whole PIC address in a single pattern for the\n-;; benefit of optimizers, particularly, PRE and HOIST.  Calculation of\n-;; a PIC address involves two loads from memory, so we want to CSE it\n-;; as often as possible.\n-;; This pattern will be split into one of the pic_load_addr_* patterns\n-;; and a move after GCSE optimizations.\n-;;\n-;; Note: Update arm.c: legitimize_pic_address() when changing this pattern.\n-(define_expand \"calculate_pic_address\"\n+;; Wrap calculation of the whole PIC address in a single pattern for the\n+;; benefit of optimizers, particularly, PRE and HOIST.  Calculation of\n+;; a PIC address involves two loads from memory, so we want to CSE it\n+;; as often as possible.\n+;; This pattern will be split into one of the pic_load_addr_* patterns\n+;; and a move after GCSE optimizations.\n+;;\n+;; Note: Update arm.c: legitimize_pic_address() when changing this pattern.\n+(define_expand \"calculate_pic_address\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t\t (unspec:SI [(match_operand:SI 2 \"\" \"\")]\n@@ -6903,44 +6238,6 @@\n   \"\n )\n \n-(define_insn \"*thumb1_movhi_insn\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n-\t(match_operand:HI 1 \"general_operand\"       \"l,m,l,*h,*r,I\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\"\n-  \"*\n-  switch (which_alternative)\n-    {\n-    case 0: return \\\"add\t%0, %1, #0\\\";\n-    case 2: return \\\"strh\t%1, %0\\\";\n-    case 3: return \\\"mov\t%0, %1\\\";\n-    case 4: return \\\"mov\t%0, %1\\\";\n-    case 5: return \\\"mov\t%0, %1\\\";\n-    default: gcc_unreachable ();\n-    case 1:\n-      /* The stack pointer can end up being taken as an index register.\n-          Catch this case here and deal with it.  */\n-      if (GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t  && REG_P (XEXP (XEXP (operands[1], 0), 0))\n-\t  && REGNO    (XEXP (XEXP (operands[1], 0), 0)) == SP_REGNUM)\n-        {\n-\t  rtx ops[2];\n-          ops[0] = operands[0];\n-          ops[1] = XEXP (XEXP (operands[1], 0), 0);\n-      \n-          output_asm_insn (\\\"mov\t%0, %1\\\", ops);\n-\n-          XEXP (XEXP (operands[1], 0), 0) = operands[0];\n-    \n-\t}\n-      return \\\"ldrh\t%0, %1\\\";\n-    }\"\n-  [(set_attr \"length\" \"2,4,2,2,2,2\")\n-   (set_attr \"type\" \"alus_imm,load1,store1,mov_reg,mov_reg,mov_imm\")\n-   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,clob\")])\n-\n-\n (define_expand \"movhi_bytes\"\n   [(set (match_dup 2) (zero_extend:SI (match_operand:HI 1 \"\" \"\")))\n    (set (match_dup 3)\n@@ -7027,23 +6324,6 @@\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"mov_imm,mov_reg,mvn_imm\")]\n )\n-\n-(define_expand \"thumb_movhi_clobber\"\n-  [(set (match_operand:HI     0 \"memory_operand\"   \"\")\n-\t(match_operand:HI     1 \"register_operand\" \"\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"\"))]\n-  \"TARGET_THUMB1\"\n-  \"\n-  if (strict_memory_address_p (HImode, XEXP (operands[0], 0))\n-      && REGNO (operands[1]) <= LAST_LO_REGNUM)\n-    {\n-      emit_insn (gen_movhi (operands[0], operands[1]));\n-      DONE;\n-    }\n-  /* XXX Fixme, need to handle other cases here as well.  */\n-  gcc_unreachable ();\n-  \"\n-)\n \t\n ;; We use a DImode scratch because we may occasionally need an additional\n ;; temporary if the address isn't offsettable -- push_reload doesn't seem\n@@ -7171,24 +6451,6 @@\n    (set_attr \"length\" \"2,4,4,2,4,2,2,4,4\")]\n )\n \n-(define_insn \"*thumb1_movqi_insn\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n-\t(match_operand:QI 1 \"general_operand\"      \"l, m,l,*h,*r,I\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   ldrb\\\\t%0, %1\n-   strb\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"alu_imm,load1,store1,mov_reg,mov_imm,mov_imm\")\n-   (set_attr \"pool_range\" \"*,32,*,*,*,*\")\n-   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,clob\")])\n-\n ;; HFmode moves\n (define_expand \"movhf\"\n   [(set (match_operand:HF 0 \"general_operand\" \"\")\n@@ -7255,40 +6517,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"*thumb1_movhf\"\n-  [(set (match_operand:HF     0 \"nonimmediate_operand\" \"=l,l,m,*r,*h\")\n-\t(match_operand:HF     1 \"general_operand\"      \"l,mF,l,*h,*r\"))]\n-  \"TARGET_THUMB1\n-   && (\t  s_register_operand (operands[0], HFmode) \n-       || s_register_operand (operands[1], HFmode))\"\n-  \"*\n-  switch (which_alternative)\n-    {\n-    case 1:\n-      {\n-\trtx addr;\n-\tgcc_assert (MEM_P (operands[1]));\n-\taddr = XEXP (operands[1], 0);\n-\tif (GET_CODE (addr) == LABEL_REF\n-\t    || (GET_CODE (addr) == CONST\n-\t\t&& GET_CODE (XEXP (addr, 0)) == PLUS\n-\t\t&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF\n-\t\t&& CONST_INT_P (XEXP (XEXP (addr, 0), 1))))\n-\t  {\n-\t    /* Constant pool entry.  */\n-\t    return \\\"ldr\\\\t%0, %1\\\";\n-\t  }\n-\treturn \\\"ldrh\\\\t%0, %1\\\";\n-      }\n-    case 2: return \\\"strh\\\\t%1, %0\\\";\n-    default: return \\\"mov\\\\t%0, %1\\\";\n-    }\n-  \"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"mov_reg,load1,store1,mov_reg,mov_reg\")\n-   (set_attr \"pool_range\" \"*,1018,*,*,*\")\n-   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond\")])\n-\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n@@ -7347,27 +6575,6 @@\n    (set_attr \"thumb2_neg_pool_range\" \"*,0,*\")]\n )\n \n-;;; ??? This should have alternatives for constants.\n-(define_insn \"*thumb1_movsf_insn\"\n-  [(set (match_operand:SF     0 \"nonimmediate_operand\" \"=l,l,>,l, m,*r,*h\")\n-\t(match_operand:SF     1 \"general_operand\"      \"l, >,l,mF,l,*h,*r\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], SFmode) \n-       || register_operand (operands[1], SFmode))\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   ldmia\\\\t%1, {%0}\n-   stmia\\\\t%0, {%1}\n-   ldr\\\\t%0, %1\n-   str\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"alus_imm,load1,store1,load1,store1,mov_reg,mov_reg\")\n-   (set_attr \"pool_range\" \"*,*,*,1018,*,*,*\")\n-   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,nocond,nocond\")]\n-)\n-\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n@@ -7457,47 +6664,6 @@\n    (set_attr \"arm_neg_pool_range\" \"*,*,*,1004,*\")\n    (set_attr \"thumb2_neg_pool_range\" \"*,*,*,0,*\")]\n )\n-\n-;;; ??? This should have alternatives for constants.\n-;;; ??? This was originally identical to the movdi_insn pattern.\n-;;; ??? The 'F' constraint looks funny, but it should always be replaced by\n-;;; thumb_reorg with a memory reference.\n-(define_insn \"*thumb_movdf_insn\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=l,l,>,l, m,*r\")\n-\t(match_operand:DF 1 \"general_operand\"      \"l, >,l,mF,l,*r\"))]\n-  \"TARGET_THUMB1\n-   && (   register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n-  \"*\n-  switch (which_alternative)\n-    {\n-    default:\n-    case 0:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n-      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n-    case 1:\n-      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n-    case 2:\n-      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n-    case 3:\n-      return thumb_load_double_from_address (operands);\n-    case 4:\n-      operands[2] = gen_rtx_MEM (SImode,\n-\t\t\t\t plus_constant (Pmode,\n-\t\t\t\t\t\tXEXP (operands[0], 0), 4));\n-      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n-      return \\\"\\\";\n-    case 5:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n-      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n-    }\n-  \"\n-  [(set_attr \"length\" \"4,2,2,6,4,4\")\n-   (set_attr \"type\" \"multiple,load2,store2,load2,store2,multiple\")\n-   (set_attr \"pool_range\" \"*,*,*,1018,*,*\")]\n-)\n \f\n \n ;; load- and store-multiple insns\n@@ -7591,50 +6757,6 @@\n     }\n   \"\n )\n-\n-;; Thumb block-move insns\n-\n-(define_insn \"movmem12b\"\n-  [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n-\t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n-   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t(mem:SI (plus:SI (match_dup 3) (const_int 4))))\n-   (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n-\t(mem:SI (plus:SI (match_dup 3) (const_int 8))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(plus:SI (match_dup 2) (const_int 12)))\n-   (set (match_operand:SI 1 \"register_operand\" \"=l\")\n-\t(plus:SI (match_dup 3) (const_int 12)))\n-   (clobber (match_scratch:SI 4 \"=&l\"))\n-   (clobber (match_scratch:SI 5 \"=&l\"))\n-   (clobber (match_scratch:SI 6 \"=&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"* return thumb_output_move_mem_multiple (3, operands);\"\n-  [(set_attr \"length\" \"4\")\n-   ; This isn't entirely accurate...  It loads as well, but in terms of\n-   ; scheduling the following insn it is better to consider it as a store\n-   (set_attr \"type\" \"store3\")]\n-)\n-\n-(define_insn \"movmem8b\"\n-  [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n-\t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n-   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n-\t(mem:SI (plus:SI (match_dup 3) (const_int 4))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(plus:SI (match_dup 2) (const_int 8)))\n-   (set (match_operand:SI 1 \"register_operand\" \"=l\")\n-\t(plus:SI (match_dup 3) (const_int 8)))\n-   (clobber (match_scratch:SI 4 \"=&l\"))\n-   (clobber (match_scratch:SI 5 \"=&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"* return thumb_output_move_mem_multiple (2, operands);\"\n-  [(set_attr \"length\" \"4\")\n-   ; This isn't entirely accurate...  It loads as well, but in terms of\n-   ; scheduling the following insn it is better to consider it as a store\n-   (set_attr \"type\" \"store2\")]\n-)\n-\n \f\n \n ;; Compare & branch insns\n@@ -7681,30 +6803,6 @@\n     operands[2] = force_reg (SImode, operands[2]);\n   \")\n \n-;; A pattern to recognize a special situation and optimize for it.\n-;; On the thumb, zero-extension from memory is preferrable to sign-extension\n-;; due to the available addressing modes.  Hence, convert a signed comparison\n-;; with zero into an unsigned comparison with 127 if possible.\n-(define_expand \"cbranchqi4\"\n-  [(set (pc) (if_then_else\n-\t      (match_operator 0 \"lt_ge_comparison_operator\"\n-\t       [(match_operand:QI 1 \"memory_operand\" \"\")\n-\t        (match_operand:QI 2 \"const0_operand\" \"\")])\n-\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))]\n-  \"TARGET_THUMB1\"\n-{\n-  rtx xops[4];\n-  xops[1] = gen_reg_rtx (SImode);\n-  emit_insn (gen_zero_extendqisi2 (xops[1], operands[1]));\n-  xops[2] = GEN_INT (127);\n-  xops[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]) == GE ? LEU : GTU,\n-\t\t\t    VOIDmode, xops[1], xops[2]);\n-  xops[3] = operands[3];\n-  emit_insn (gen_cbranchsi4 (xops[0], xops[1], xops[2], xops[3]));\n-  DONE;\n-})\n-\n (define_expand \"cbranchsf4\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"expandable_comparison_operator\"\n@@ -7746,524 +6844,6 @@\n    }\"\n )\n \n-(define_insn \"cbranchsi4_insn\"\n-  [(set (pc) (if_then_else\n-\t      (match_operator 0 \"arm_comparison_operator\"\n-\t       [(match_operand:SI 1 \"s_register_operand\" \"l,l*h\")\n-\t        (match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\")])\n-\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))]\n-  \"TARGET_THUMB1\"\n-{\n-  rtx t = cfun->machine->thumb1_cc_insn;\n-  if (t != NULL_RTX)\n-    {\n-      if (!rtx_equal_p (cfun->machine->thumb1_cc_op0, operands[1])\n-\t  || !rtx_equal_p (cfun->machine->thumb1_cc_op1, operands[2]))\n-\tt = NULL_RTX;\n-      if (cfun->machine->thumb1_cc_mode == CC_NOOVmode)\n-\t{\n-\t  if (!noov_comparison_operator (operands[0], VOIDmode))\n-\t    t = NULL_RTX;\n-\t}\n-      else if (cfun->machine->thumb1_cc_mode != CCmode)\n-\tt = NULL_RTX;\n-    }\n-  if (t == NULL_RTX)\n-    {\n-      output_asm_insn (\"cmp\\t%1, %2\", operands);\n-      cfun->machine->thumb1_cc_insn = insn;\n-      cfun->machine->thumb1_cc_op0 = operands[1];\n-      cfun->machine->thumb1_cc_op1 = operands[2];\n-      cfun->machine->thumb1_cc_mode = CCmode;\n-    }\n-  else\n-    /* Ensure we emit the right type of condition code on the jump.  */\n-    XEXP (operands[0], 0) = gen_rtx_REG (cfun->machine->thumb1_cc_mode,\n-\t\t\t\t\t CC_REGNUM);\n-\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d0\\\\t%l3\\\";\n-    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-}\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"cbranchsi4_scratch\"\n-  [(set (pc) (if_then_else\n-\t      (match_operator 4 \"arm_comparison_operator\"\n-\t       [(match_operand:SI 1 \"s_register_operand\" \"l,0\")\n-\t        (match_operand:SI 2 \"thumb1_cmpneg_operand\" \"L,J\")])\n-\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t      (pc)))\n-   (clobber (match_scratch:SI 0 \"=l,l\"))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  output_asm_insn (\\\"add\\\\t%0, %1, #%n2\\\", operands);\n-\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d4\\\\t%l3\\\";\n-    case 6:  return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*negated_cbranchsi4\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"equality_operator\"\n-\t  [(match_operand:SI 1 \"s_register_operand\" \"l\")\n-\t   (neg:SI (match_operand:SI 2 \"s_register_operand\" \"l\"))])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  output_asm_insn (\\\"cmn\\\\t%1, %2\\\", operands);\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d0\\\\t%l3\\\";\n-    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*tbit_cbranch\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"equality_operator\"\n-\t  [(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"l\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t   (const_int 0)])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))\n-   (clobber (match_scratch:SI 4 \"=l\"))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  {\n-  rtx op[3];\n-  op[0] = operands[4];\n-  op[1] = operands[1];\n-  op[2] = GEN_INT (32 - 1 - INTVAL (operands[2]));\n-\n-  output_asm_insn (\\\"lsl\\\\t%0, %1, %2\\\", op);\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d0\\\\t%l3\\\";\n-    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-  }\"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-  \n-(define_insn \"*tlobits_cbranch\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"equality_operator\"\n-\t  [(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"l\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t    (const_int 0))\n-\t   (const_int 0)])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))\n-   (clobber (match_scratch:SI 4 \"=l\"))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  {\n-  rtx op[3];\n-  op[0] = operands[4];\n-  op[1] = operands[1];\n-  op[2] = GEN_INT (32 - INTVAL (operands[2]));\n-\n-  output_asm_insn (\\\"lsl\\\\t%0, %1, %2\\\", op);\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d0\\\\t%l3\\\";\n-    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-  }\"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*tstsi3_cbranch\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 3 \"equality_operator\"\n-\t  [(and:SI (match_operand:SI 0 \"s_register_operand\" \"%l\")\n-\t\t   (match_operand:SI 1 \"s_register_operand\" \"l\"))\n-\t   (const_int 0)])\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  {\n-  output_asm_insn (\\\"tst\\\\t%0, %1\\\", operands);\n-  switch (get_attr_length (insn))\n-    {\n-    case 4:  return \\\"b%d3\\\\t%l2\\\";\n-    case 6:  return \\\"b%D3\\\\t.LCB%=\\;b\\\\t%l2\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D3\\\\t.LCB%=\\;bl\\\\t%l2\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-  }\"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n-\t         (le (minus (match_dup 2) (pc)) (const_int 256)))\n-\t    (const_int 4)\n-\t    (if_then_else\n-\t        (and (ge (minus (match_dup 2) (pc)) (const_int -2040))\n-\t\t     (le (minus (match_dup 2) (pc)) (const_int 2048)))\n-\t\t(const_int 6)\n-\t\t(const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-  \n-(define_insn \"*cbranchne_decr1\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 3 \"equality_operator\"\n-\t\t       [(match_operand:SI 2 \"s_register_operand\" \"l,l,1,l\")\n-\t\t        (const_int 0)])\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,*?h,*?m,*?m\")\n-\t(plus:SI (match_dup 2) (const_int -1)))\n-   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-   {\n-     rtx cond[2];\n-     cond[0] = gen_rtx_fmt_ee ((GET_CODE (operands[3]) == NE\n-\t\t\t\t? GEU : LTU),\n-\t\t\t       VOIDmode, operands[2], const1_rtx);\n-     cond[1] = operands[4];\n-\n-     if (which_alternative == 0)\n-       output_asm_insn (\\\"sub\\\\t%0, %2, #1\\\", operands);\n-     else if (which_alternative == 1)\n-       {\n-\t /* We must provide an alternative for a hi reg because reload \n-\t    cannot handle output reloads on a jump instruction, but we\n-\t    can't subtract into that.  Fortunately a mov from lo to hi\n-\t    does not clobber the condition codes.  */\n-\t output_asm_insn (\\\"sub\\\\t%1, %2, #1\\\", operands);\n-\t output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n-       }\n-     else\n-       {\n-\t /* Similarly, but the target is memory.  */\n-\t output_asm_insn (\\\"sub\\\\t%1, %2, #1\\\", operands);\n-\t output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n-       }\n-\n-     switch (get_attr_length (insn) - (which_alternative ? 2 : 0))\n-       {\n-\t case 4:\n-\t   output_asm_insn (\\\"b%d0\\\\t%l1\\\", cond);\n-\t   return \\\"\\\";\n-\t case 6:\n-\t   output_asm_insn (\\\"b%D0\\\\t.LCB%=\\\", cond);\n-\t   return \\\"b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n-\t default:\n-\t   output_asm_insn (\\\"b%D0\\\\t.LCB%=\\\", cond);\n-\t   return \\\"bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n-       }\n-   }\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n-\t                  (const_int 0))\n-\t\t      (eq_attr \"length\" \"8\"))\n-\t\t (eq_attr \"length\" \"10\"))\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set_attr_alternative \"length\"\n-      [\n-       ;; Alternative 0\n-       (if_then_else\n-\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n-\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n-\t (const_int 4)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n-\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n-\t   (const_int 6)\n-\t   (const_int 8)))\n-       ;; Alternative 1\n-       (if_then_else\n-\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n-\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n-\t (const_int 6)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n-\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n-\t   (const_int 8)\n-\t   (const_int 10)))\n-       ;; Alternative 2\n-       (if_then_else\n-\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n-\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n-\t (const_int 6)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n-\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n-\t   (const_int 8)\n-\t   (const_int 10)))\n-       ;; Alternative 3\n-       (if_then_else\n-\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n-\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n-\t (const_int 6)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n-\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n-\t   (const_int 8)\n-\t   (const_int 10)))])\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*addsi3_cbranch\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 4 \"arm_comparison_operator\"\n-\t  [(plus:SI\n-\t    (match_operand:SI 2 \"s_register_operand\" \"%0,l,*l,1,1,1\")\n-\t    (match_operand:SI 3 \"reg_or_int_operand\" \"IJ,lL,*l,lIJ,lIJ,lIJ\"))\n-\t   (const_int 0)])\n-\t (label_ref (match_operand 5 \"\" \"\"))\n-\t (pc)))\n-   (set\n-    (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,l,*!h,*?h,*?m,*?m\")\n-    (plus:SI (match_dup 2) (match_dup 3)))\n-   (clobber (match_scratch:SI 1 \"=X,X,l,l,&l,&l\"))]\n-  \"TARGET_THUMB1\n-   && (GET_CODE (operands[4]) == EQ\n-       || GET_CODE (operands[4]) == NE\n-       || GET_CODE (operands[4]) == GE\n-       || GET_CODE (operands[4]) == LT)\"\n-  \"*\n-   {\n-     rtx cond[3];\n-\n-     cond[0] = (which_alternative < 2) ? operands[0] : operands[1];\n-     cond[1] = operands[2];\n-     cond[2] = operands[3];\n-\n-     if (CONST_INT_P (cond[2]) && INTVAL (cond[2]) < 0)\n-       output_asm_insn (\\\"sub\\\\t%0, %1, #%n2\\\", cond);\n-     else\n-       output_asm_insn (\\\"add\\\\t%0, %1, %2\\\", cond);\n-\n-     if (which_alternative >= 2\n-\t && which_alternative < 4)\n-       output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n-     else if (which_alternative >= 4)\n-       output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n-\n-     switch (get_attr_length (insn) - ((which_alternative >= 2) ? 2 : 0))\n-       {\n-\t case 4:\n-\t   return \\\"b%d4\\\\t%l5\\\";\n-\t case 6:\n-\t   return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l5\\\\t%@long jump\\\\n.LCB%=:\\\";\n-\t default:\n-\t   return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l5\\\\t%@far jump\\\\n.LCB%=:\\\";\n-       }\n-   }\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (ior (and (lt (symbol_ref (\"which_alternative\"))\n-\t                  (const_int 2))\n-\t\t      (eq_attr \"length\" \"8\"))\n-\t\t (eq_attr \"length\" \"10\"))\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\")\n-     (if_then_else\n-       (lt (symbol_ref (\"which_alternative\"))\n-\t\t       (const_int 2))\n-       (if_then_else\n-\t (and (ge (minus (match_dup 5) (pc)) (const_int -250))\n-\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n-\t (const_int 4)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))\n-\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n-\t   (const_int 6)\n-\t   (const_int 8)))\n-       (if_then_else\n-\t (and (ge (minus (match_dup 5) (pc)) (const_int -248))\n-\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n-\t (const_int 6)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))\n-\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n-\t   (const_int 8)\n-\t   (const_int 10)))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*addsi3_cbranch_scratch\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 3 \"arm_comparison_operator\"\n-\t  [(plus:SI\n-\t    (match_operand:SI 1 \"s_register_operand\" \"%l,l,l,0\")\n-\t    (match_operand:SI 2 \"reg_or_int_operand\" \"J,l,L,IJ\"))\n-\t   (const_int 0)])\n-\t (label_ref (match_operand 4 \"\" \"\"))\n-\t (pc)))\n-   (clobber (match_scratch:SI 0 \"=X,X,l,l\"))]\n-  \"TARGET_THUMB1\n-   && (GET_CODE (operands[3]) == EQ\n-       || GET_CODE (operands[3]) == NE\n-       || GET_CODE (operands[3]) == GE\n-       || GET_CODE (operands[3]) == LT)\"\n-  \"*\n-   {\n-     switch (which_alternative)\n-       {\n-       case 0:\n-\t output_asm_insn (\\\"cmp\\t%1, #%n2\\\", operands);\n-\t break;\n-       case 1:\n-\t output_asm_insn (\\\"cmn\\t%1, %2\\\", operands);\n-\t break;\n-       case 2:\n-\t if (INTVAL (operands[2]) < 0)\n-\t   output_asm_insn (\\\"sub\\t%0, %1, %2\\\", operands);\n-\t else\n-\t   output_asm_insn (\\\"add\\t%0, %1, %2\\\", operands);\n-\t break;\n-       case 3:\n-\t if (INTVAL (operands[2]) < 0)\n-\t   output_asm_insn (\\\"sub\\t%0, %0, %2\\\", operands);\n-\t else\n-\t   output_asm_insn (\\\"add\\t%0, %0, %2\\\", operands);\n-\t break;\n-       }\n-\n-     switch (get_attr_length (insn))\n-       {\n-\t case 4:\n-\t   return \\\"b%d3\\\\t%l4\\\";\n-\t case 6:\n-\t   return \\\"b%D3\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n-\t default:\n-\t   return \\\"b%D3\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n-       }\n-   }\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"8\")\n-\t    (const_string \"yes\")\n-            (const_string \"no\")))\n-   (set (attr \"length\")\n-       (if_then_else\n-\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n-\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n-\t (const_int 4)\n-\t (if_then_else\n-\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n-\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n-\t   (const_int 6)\n-\t   (const_int 8))))\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-\n ;; Comparison and test insns\n \n (define_insn \"*arm_cmpsi_insn\"\n@@ -8409,18 +6989,6 @@\n    (set_attr \"type\" \"logics_reg\")]\n )\n \n-(define_insn \"*thumb_cmpdi_zero\"\n-  [(set (reg:CC_Z CC_REGNUM)\n-\t(compare:CC_Z (match_operand:DI 0 \"s_register_operand\" \"l\")\n-\t\t      (const_int 0)))\n-   (clobber (match_scratch:SI 1 \"=l\"))]\n-  \"TARGET_THUMB1\"\n-  \"orr\\\\t%1, %Q0, %R0\"\n-  [(set_attr \"conds\" \"set\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"logics_reg\")]\n-)\n-\n ; This insn allows redundant compares to be removed by cse, nothing should\n ; ever appear in the output file since (set (reg x) (reg x)) is a no-op that\n ; is deleted later on. The match_dup will match the mode here, so that\n@@ -8750,88 +7318,6 @@\n    }\"\n )\n \n-(define_expand \"cstoresi_eq0_thumb1\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t  (eq:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n-\t\t (const_int 0)))\n-     (clobber (match_dup:SI 2))])]\n-  \"TARGET_THUMB1\"\n-  \"operands[2] = gen_reg_rtx (SImode);\"\n-)\n-\n-(define_expand \"cstoresi_ne0_thumb1\"\n-  [(parallel\n-    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t  (ne:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n-\t\t (const_int 0)))\n-     (clobber (match_dup:SI 2))])]\n-  \"TARGET_THUMB1\"\n-  \"operands[2] = gen_reg_rtx (SImode);\"\n-)\n-\n-(define_insn \"*cstoresi_eq0_thumb1_insn\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=&l,l\")\n-\t(eq:SI (match_operand:SI 1 \"s_register_operand\" \"l,0\")\n-\t       (const_int 0)))\n-   (clobber (match_operand:SI 2 \"s_register_operand\" \"=X,l\"))]\n-  \"TARGET_THUMB1\"\n-  \"@\n-   neg\\\\t%0, %1\\;adc\\\\t%0, %0, %1\n-   neg\\\\t%2, %1\\;adc\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn \"*cstoresi_ne0_thumb1_insn\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n-\t(ne:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n-\t       (const_int 0)))\n-   (clobber (match_operand:SI 2 \"s_register_operand\" \"=l\"))]\n-  \"TARGET_THUMB1\"\n-  \"sub\\\\t%2, %1, #1\\;sbc\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;; Used as part of the expansion of thumb ltu and gtu sequences\n-(define_insn \"cstoresi_nltu_thumb1\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l,l\")\n-        (neg:SI (ltu:SI (match_operand:SI 1 \"s_register_operand\" \"l,*h\")\n-\t\t\t(match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\"))))]\n-  \"TARGET_THUMB1\"\n-  \"cmp\\\\t%1, %2\\;sbc\\\\t%0, %0, %0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-(define_insn_and_split \"cstoresi_ltu_thumb1\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l,l\")\n-        (ltu:SI (match_operand:SI 1 \"s_register_operand\" \"l,*h\")\n-\t\t(match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\")))]\n-  \"TARGET_THUMB1\"\n-  \"#\"\n-  \"TARGET_THUMB1\"\n-  [(set (match_dup 3)\n-\t(neg:SI (ltu:SI (match_dup 1) (match_dup 2))))\n-   (set (match_dup 0) (neg:SI (match_dup 3)))]\n-  \"operands[3] = gen_reg_rtx (SImode);\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n-;; Used as part of the expansion of thumb les sequence.\n-(define_insn \"thumb1_addsi3_addgeu\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n-        (plus:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n-\t\t\t  (match_operand:SI 2 \"s_register_operand\" \"l\"))\n-\t\t (geu:SI (match_operand:SI 3 \"s_register_operand\" \"l\")\n-\t\t\t (match_operand:SI 4 \"thumb1_cmp_operand\" \"lI\"))))]\n-  \"TARGET_THUMB1\"\n-  \"cmp\\\\t%3, %4\\;adc\\\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n \f\n ;; Conditional move insns\n \n@@ -9051,29 +7537,6 @@\n    (set_attr \"type\" \"branch\")]\n )\n \n-(define_insn \"*thumb_jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  if (get_attr_length (insn) == 2)\n-    return \\\"b\\\\t%l0\\\";\n-  return \\\"bl\\\\t%l0\\\\t%@ far jump\\\";\n-  \"\n-  [(set (attr \"far_jump\")\n-        (if_then_else\n-\t    (eq_attr \"length\" \"4\")\n-\t    (const_string \"yes\")\n-\t    (const_string \"no\")))\n-   (set (attr \"length\") \n-        (if_then_else\n-\t    (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n-\t\t (le (minus (match_dup 0) (pc)) (const_int 2048)))\n-  \t    (const_int 2)\n-\t    (const_int 4)))\n-   (set_attr \"type\" \"branch\")]\n-)\n-\n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n \t            (match_operand 1 \"general_operand\" \"\"))\n@@ -9151,37 +7614,6 @@\n    (set_attr \"type\" \"call\")]\n )\n \n-(define_insn \"*call_reg_thumb1_v5\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1 && arm_arch5 && !SIBLING_CALL_P (insn)\"\n-  \"blx\\\\t%0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"call\")]\n-)\n-\n-(define_insn \"*call_reg_thumb1\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1 && !arm_arch5 && !SIBLING_CALL_P (insn)\"\n-  \"*\n-  {\n-    if (!TARGET_CALLER_INTERWORKING)\n-      return thumb_call_via_reg (operands[0]);\n-    else if (operands[1] == const0_rtx)\n-      return \\\"bl\\\\t%__interwork_call_via_%0\\\";\n-    else if (frame_pointer_needed)\n-      return \\\"bl\\\\t%__interwork_r7_call_via_%0\\\";\n-    else\n-      return \\\"bl\\\\t%__interwork_r11_call_via_%0\\\";\n-  }\"\n-  [(set_attr \"type\" \"call\")]\n-)\n-\n (define_expand \"call_value\"\n   [(parallel [(set (match_operand       0 \"\" \"\")\n \t           (call (match_operand 1 \"memory_operand\" \"\")\n@@ -9262,39 +7694,6 @@\n    (set_attr \"type\" \"call\")]\n )\n \n-(define_insn \"*call_value_reg_thumb1_v5\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1 && arm_arch5\"\n-  \"blx\\\\t%1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"call\")]\n-)\n-\n-(define_insn \"*call_value_reg_thumb1\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1 && !arm_arch5\"\n-  \"*\n-  {\n-    if (!TARGET_CALLER_INTERWORKING)\n-      return thumb_call_via_reg (operands[1]);\n-    else if (operands[2] == const0_rtx)\n-      return \\\"bl\\\\t%__interwork_call_via_%1\\\";\n-    else if (frame_pointer_needed)\n-      return \\\"bl\\\\t%__interwork_r7_call_via_%1\\\";\n-    else\n-      return \\\"bl\\\\t%__interwork_r11_call_via_%1\\\";\n-  }\"\n-  [(set_attr \"type\" \"call\")]\n-)\n-\n ;; Allow calls to SYMBOL_REFs specially as they are not valid general addresses\n ;; The 'a' causes the operand to be treated as an address, i.e. no '#' output.\n \n@@ -9331,33 +7730,6 @@\n   [(set_attr \"type\" \"call\")]\n )\n \n-(define_insn \"*call_insn\"\n-  [(call (mem:SI (match_operand:SI 0 \"\" \"\"))\n-\t (match_operand:SI 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1\n-   && GET_CODE (operands[0]) == SYMBOL_REF\n-   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))\"\n-  \"bl\\\\t%a0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")]\n-)\n-\n-(define_insn \"*call_value_insn\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand 1 \"\" \"\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n-   (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB1\n-   && GET_CODE (operands[1]) == SYMBOL_REF\n-   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))\"\n-  \"bl\\\\t%a1\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"call\")]\n-)\n-\n ;; We may also be able to do sibcalls for Thumb, but it's much harder...\n (define_expand \"sibcall\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n@@ -9755,38 +8127,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_expand \"thumb1_casesi_internal_pic\"\n-  [(match_operand:SI 0 \"s_register_operand\" \"\")\n-   (match_operand:SI 1 \"thumb1_cmp_operand\" \"\")\n-   (match_operand 2 \"\" \"\")\n-   (match_operand 3 \"\" \"\")]\n-  \"TARGET_THUMB1\"\n-  {\n-    rtx reg0;\n-    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[1]);\n-    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[1],\n-\t\t\t\t    operands[3]));\n-    reg0 = gen_rtx_REG (SImode, 0);\n-    emit_move_insn (reg0, operands[0]);\n-    emit_jump_insn (gen_thumb1_casesi_dispatch (operands[2]/*, operands[3]*/));\n-    DONE;\n-  }\n-)\n-\n-(define_insn \"thumb1_casesi_dispatch\"\n-  [(parallel [(set (pc) (unspec [(reg:SI 0)\n-\t\t\t\t (label_ref (match_operand 0 \"\" \"\"))\n-;;\t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n-]\n-\t\t\t UNSPEC_THUMB1_CASESI))\n-\t      (clobber (reg:SI IP_REGNUM))\n-              (clobber (reg:SI LR_REGNUM))])]\n-  \"TARGET_THUMB1\"\n-  \"* return thumb1_output_casesi(operands);\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"indirect_jump\"\n   [(set (pc)\n \t(match_operand:SI 0 \"s_register_operand\" \"\"))]\n@@ -9825,17 +8165,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-;; NB Never uses BX.\n-(define_insn \"*thumb1_indirect_jump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"register_operand\" \"l*r\"))]\n-  \"TARGET_THUMB1\"\n-  \"mov\\\\tpc, %0\"\n-  [(set_attr \"conds\" \"clob\")\n-   (set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"branch\")]\n-)\n-\n \f\n ;; Misc insns\n \n@@ -11792,14 +10121,6 @@\n   \"\n )\n \n-(define_insn \"prologue_thumb1_interwork\"\n-  [(unspec_volatile [(const_int 0)] VUNSPEC_THUMB1_INTERWORK)]\n-  \"TARGET_THUMB1\"\n-  \"* return thumb1_output_interwork ();\"\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n ;; Note - although unspec_volatile's USE all hard registers,\n ;; USEs are ignored after relaod has completed.  Thus we need\n ;; to add an unspec of the link register to ensure that flow\n@@ -11815,21 +10136,6 @@\n    \"\n )\n \n-(define_insn \"*epilogue_insns\"\n-  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n-  \"TARGET_THUMB1\"\n-  \"*\n-    return thumb1_unexpanded_epilogue ();\n-  \"\n-  ; Length is absolute worst case\n-  [(set_attr \"length\" \"44\")\n-   (set_attr \"type\" \"block\")\n-   ;; We don't clobber the conditions, but the potential length of this\n-   ;; operation is sufficient to make conditionalizing the sequence \n-   ;; unlikely to be profitable.\n-   (set_attr \"conds\" \"clob\")]\n-)\n-\n (define_expand \"eh_epilogue\"\n   [(use (match_operand:SI 0 \"register_operand\" \"\"))\n    (use (match_operand:SI 1 \"register_operand\" \"\"))\n@@ -12240,33 +10546,6 @@\n   [(set_attr \"type\" \"no_insn\")]\n )\n \n-(define_insn \"consttable_1\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_1)]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  making_const_table = TRUE;\n-  assemble_integer (operands[0], 1, BITS_PER_WORD, 1);\n-  assemble_zeros (3);\n-  return \\\"\\\";\n-  \"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"no_insn\")]\n-)\n-\n-(define_insn \"consttable_2\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_2)]\n-  \"TARGET_THUMB1\"\n-  \"*\n-  making_const_table = TRUE;\n-  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);\n-  assemble_integer (operands[0], 2, BITS_PER_WORD, 1);\n-  assemble_zeros (2);\n-  return \\\"\\\";\n-  \"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"no_insn\")]\n-)\n-\n (define_insn \"consttable_4\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_4)]\n   \"TARGET_EITHER\"\n@@ -12354,35 +10633,6 @@\n    (set_attr \"type\" \"no_insn\")]\n )\n \n-;; Miscellaneous Thumb patterns\n-\n-(define_expand \"tablejump\"\n-  [(parallel [(set (pc) (match_operand:SI 0 \"register_operand\" \"\"))\n-\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n-  \"TARGET_THUMB1\"\n-  \"\n-  if (flag_pic)\n-    {\n-      /* Hopefully, CSE will eliminate this copy.  */\n-      rtx reg1 = copy_addr_to_reg (gen_rtx_LABEL_REF (Pmode, operands[1]));\n-      rtx reg2 = gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_addsi3 (reg2, operands[0], reg1));\n-      operands[0] = reg2;\n-    }\n-  \"\n-)\n-\n-;; NB never uses BX.\n-(define_insn \"*thumb1_tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_THUMB1\"\n-  \"mov\\\\t%|pc, %0\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"no_insn\")]\n-)\n-\n ;; V5 Instructions,\n \n (define_insn \"clzsi2\"\n@@ -12477,22 +10727,6 @@\n   }\"\n )\n \n-(define_insn_and_split \"thumb_eh_return\"\n-  [(unspec_volatile [(match_operand:SI 0 \"s_register_operand\" \"l\")]\n-\t\t    VUNSPEC_EH_RETURN)\n-   (clobber (match_scratch:SI 1 \"=&l\"))]\n-  \"TARGET_THUMB1\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  \"\n-  {\n-    thumb_set_return_address (operands[0], operands[1]);\n-    DONE;\n-  }\"\n-  [(set_attr \"type\" \"mov_reg\")]\n-)\n-\n \f\n ;; TLS support\n \n@@ -12878,6 +11112,8 @@\n (include \"iwmmxt.md\")\n ;; Load the VFP co-processor patterns\n (include \"vfp.md\")\n+;; Thumb-1 patterns\n+(include \"thumb1.md\")\n ;; Thumb-2 patterns\n (include \"thumb2.md\")\n ;; Neon patterns"}, {"sha": "379e14c9d928f0d9a11959e2506aed267a7d15bd", "filename": "gcc/config/arm/thumb1.md", "status": "added", "additions": 1789, "deletions": 0, "changes": 1789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02d8b8cb41501b5904705dc764f7c8a8788f45/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=1d02d8b8cb41501b5904705dc764f7c8a8788f45", "patch": "@@ -0,0 +1,1789 @@\n+;; ARM Thumb-1 Machine Description\n+;; Copyright (C) 2007-2014 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+\f\n+;;---------------------------------------------------------------------------\n+;; Insn patterns\n+;;\n+\n+(define_insn \"*thumb1_adddi3\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=l\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"l\")))\n+   (clobber (reg:CC CC_REGNUM))\n+  ]\n+  \"TARGET_THUMB1\"\n+  \"add\\\\t%Q0, %Q0, %Q2\\;adc\\\\t%R0, %R0, %R2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn_and_split \"*thumb1_addsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*rk,*hk,l,k,l,l,l\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,k,k,0,l,k\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*hk,*rk,M,O,Pa,Pb,Pc\")))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+   static const char * const asms[] =\n+   {\n+     \\\"add\\\\t%0, %0, %2\\\",\n+     \\\"sub\\\\t%0, %0, #%n2\\\",\n+     \\\"add\\\\t%0, %1, %2\\\",\n+     \\\"add\\\\t%0, %0, %2\\\",\n+     \\\"add\\\\t%0, %0, %2\\\",\n+     \\\"add\\\\t%0, %1, %2\\\",\n+     \\\"add\\\\t%0, %1, %2\\\",\n+     \\\"#\\\",\n+     \\\"#\\\",\n+     \\\"#\\\"\n+   };\n+   if ((which_alternative == 2 || which_alternative == 6)\n+       && CONST_INT_P (operands[2])\n+       && INTVAL (operands[2]) < 0)\n+     return \\\"sub\\\\t%0, %1, #%n2\\\";\n+   return asms[which_alternative];\n+  \"\n+  \"&& reload_completed && CONST_INT_P (operands[2])\n+   && ((operands[1] != stack_pointer_rtx\n+        && (INTVAL (operands[2]) > 255 || INTVAL (operands[2]) < -255))\n+       || (operands[1] == stack_pointer_rtx\n+ \t   && INTVAL (operands[2]) > 1020))\"\n+  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n+  {\n+    HOST_WIDE_INT offset = INTVAL (operands[2]);\n+    if (operands[1] == stack_pointer_rtx)\n+      offset -= 1020;\n+    else\n+      {\n+        if (offset > 255)\n+\t  offset = 255;\n+\telse if (offset < -255)\n+\t  offset = -255;\n+      }\n+    operands[3] = GEN_INT (offset);\n+    operands[2] = GEN_INT (INTVAL (operands[2]) - offset);\n+  }\n+  [(set_attr \"length\" \"2,2,2,2,2,2,2,4,4,4\")\n+   (set_attr \"type\" \"alus_imm,alus_imm,alus_reg,alus_reg,alus_reg,\n+\t\t     alus_reg,alus_reg,multiple,multiple,multiple\")]\n+)\n+\n+;; Reloading and elimination of the frame pointer can\n+;; sometimes cause this optimization to be missed.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0) (reg:SI SP_REGNUM)))]\n+  \"TARGET_THUMB1\n+   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024\n+   && (INTVAL (operands[1]) & 3) == 0\"\n+  [(set (match_dup 0) (plus:SI (reg:SI SP_REGNUM) (match_dup 1)))]\n+  \"\"\n+)\n+\n+(define_insn \"*thumb_subdi3\"\n+  [(set (match_operand:DI           0 \"register_operand\" \"=l\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\"  \"0\")\n+\t\t  (match_operand:DI 2 \"register_operand\"  \"l\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_THUMB1\"\n+  \"sub\\\\t%Q0, %Q0, %Q2\\;sbc\\\\t%R0, %R0, %R2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"thumb1_subsi3_insn\"\n+  [(set (match_operand:SI           0 \"register_operand\" \"=l\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n+\t\t  (match_operand:SI 2 \"reg_or_int_operand\" \"lPd\")))]\n+  \"TARGET_THUMB1\"\n+  \"sub\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_reg\")]\n+)\n+\n+; Unfortunately with the Thumb the '&'/'0' trick can fails when operands\n+; 1 and 2; are the same, because reload will make operand 0 match\n+; operand 1 without realizing that this conflicts with operand 2.  We fix\n+; this by adding another alternative to match this case, and then `reload'\n+; it ourselves.  This alternative must come first.\n+(define_insn \"*thumb_mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=&l,&l,&l\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%l,*h,0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"l,l,l\")))]\n+ \"TARGET_THUMB1 && !arm_arch6\"\n+  \"*\n+  if (which_alternative < 2)\n+    return \\\"mov\\\\t%0, %1\\;mul\\\\t%0, %2\\\";\n+  else\n+    return \\\"mul\\\\t%0, %2\\\";\n+  \"\n+  [(set_attr \"length\" \"4,4,2\")\n+   (set_attr \"type\" \"muls\")]\n+)\n+\n+(define_insn \"*thumb_mulsi3_v6\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"0,l,0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"l,0,0\")))]\n+  \"TARGET_THUMB1 && arm_arch6\"\n+  \"@\n+   mul\\\\t%0, %2\n+   mul\\\\t%0, %1\n+   mul\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"muls\")]\n+)\n+\n+(define_insn \"*thumb1_andsi3_insn\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"and\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\"  \"logic_imm\")\n+   (set_attr \"conds\" \"set\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))\n+   (clobber (match_operand:SI 4 \"s_register_operand\" \"\"))]\n+  \"TARGET_THUMB1\"\n+  [(set (match_dup 4) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 4) (match_dup 3)))]\n+  \"{\n+     HOST_WIDE_INT temp = INTVAL (operands[2]);\n+\n+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n+     operands[3] = GEN_INT (32 - temp);\n+   }\"\n+)\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_THUMB1\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 3)))]\n+  \"{\n+     HOST_WIDE_INT temp = INTVAL (operands[2]);\n+\n+     operands[2] = GEN_INT (32 - temp - INTVAL (operands[3]));\n+     operands[3] = GEN_INT (32 - temp);\n+   }\"\n+)\n+\n+(define_insn \"thumb1_bicsi3\"\n+  [(set (match_operand:SI                 0 \"register_operand\" \"=l\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"l\"))\n+\t\t(match_operand:SI         2 \"register_operand\" \"0\")))]\n+  \"TARGET_THUMB1\"\n+  \"bic\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"logics_reg\")]\n+)\n+\n+(define_insn \"*thumb1_iorsi3_insn\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"orr\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"logics_reg\")])\n+\n+(define_insn \"*thumb1_xorsi3_insn\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"eor\\\\t%0, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"logics_reg\")]\n+)\n+\n+(define_insn \"*thumb1_ashlsi3\"\n+  [(set (match_operand:SI            0 \"register_operand\" \"=l,l\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"TARGET_THUMB1\"\n+  \"lsl\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"shift_imm,shift_reg\")\n+   (set_attr \"conds\" \"set\")])\n+\n+(define_insn \"*thumb1_ashrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=l,l\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"TARGET_THUMB1\"\n+  \"asr\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"shift_imm,shift_reg\")\n+   (set_attr \"conds\" \"set\")])\n+\n+(define_insn \"*thumb1_lshrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=l,l\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n+  \"TARGET_THUMB1\"\n+  \"lsr\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"shift_imm,shift_reg\")\n+   (set_attr \"conds\" \"set\")])\n+\n+(define_insn \"*thumb1_rotrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=l\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"ror\\\\t%0, %0, %2\"\n+  [(set_attr \"type\" \"shift_reg\")\n+   (set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"*thumb1_negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&l\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"l\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_THUMB1\"\n+  \"mov\\\\t%R0, #0\\;neg\\\\t%Q0, %Q1\\;sbc\\\\t%R0, %R1\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*thumb1_negsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"neg\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"alu_imm\")]\n+)\n+\n+(define_insn_and_split \"*thumb1_abssi2\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+\t(abs:SI (match_operand:SI 1 \"s_register_operand\" \"l\")))\n+   (clobber (match_scratch:SI 2 \"=&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"#\"\n+  \"TARGET_THUMB1 && reload_completed\"\n+  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn_and_split \"*thumb1_neg_abssi2\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+\t(neg:SI (abs:SI (match_operand:SI 1 \"s_register_operand\" \"l\"))))\n+   (clobber (match_scratch:SI 2 \"=&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"#\"\n+  \"TARGET_THUMB1 && reload_completed\"\n+  [(set (match_dup 2) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+   (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))\n+   (set (match_dup 0) (xor:SI (match_dup 0) (match_dup 2)))]\n+  \"\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*thumb1_one_cmplsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=l\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\"  \"l\")))]\n+  \"TARGET_THUMB1\"\n+  \"mvn\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"mvn_reg\")]\n+)\n+\n+(define_insn \"*thumb1_zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))]\n+  \"TARGET_THUMB1\"\n+{\n+  rtx mem;\n+\n+  if (which_alternative == 0 && arm_arch6)\n+    return \"uxth\\t%0, %1\";\n+  if (which_alternative == 0)\n+    return \"#\";\n+\n+  mem = XEXP (operands[1], 0);\n+\n+  if (GET_CODE (mem) == CONST)\n+    mem = XEXP (mem, 0);\n+\n+  if (GET_CODE (mem) == PLUS)\n+    {\n+      rtx a = XEXP (mem, 0);\n+\n+      /* This can happen due to bugs in reload.  */\n+      if (REG_P (a) && REGNO (a) == SP_REGNUM)\n+        {\n+          rtx ops[2];\n+          ops[0] = operands[0];\n+          ops[1] = a;\n+\n+          output_asm_insn (\"mov\\t%0, %1\", ops);\n+\n+          XEXP (mem, 0) = operands[0];\n+       }\n+    }\n+\n+  return \"ldrh\\t%0, %1\";\n+}\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t       (const_int 2) (const_int 4))\n+\t\t\t (const_int 4)])\n+   (set_attr \"type\" \"extend,load_byte\")]\n+)\n+\n+(define_insn \"*thumb1_zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n+  \"TARGET_THUMB1 && !arm_arch6\"\n+  \"@\n+   #\n+   ldrb\\\\t%0, %1\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"type\" \"alu_shift_reg,load_byte\")\n+   (set_attr \"pool_range\" \"*,32\")]\n+)\n+\n+(define_insn \"*thumb1_zero_extendqisi2_v6\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n+  \"TARGET_THUMB1 && arm_arch6\"\n+  \"@\n+   uxtb\\\\t%0, %1\n+   ldrb\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"extend,load_byte\")]\n+)\n+\n+;; We used to have an early-clobber on the scratch register here.\n+;; However, there's a bug somewhere in reload which means that this\n+;; can be partially ignored during spill allocation if the memory\n+;; address also needs reloading; this causes us to die later on when\n+;; we try to verify the operands.  Fortunately, we don't really need\n+;; the early-clobber: we can always use operand 0 if operand 2\n+;; overlaps the address.\n+(define_insn \"thumb1_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))\n+   (clobber (match_scratch:SI 2 \"=X,l\"))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  {\n+    rtx ops[4];\n+    rtx mem;\n+\n+    if (which_alternative == 0 && !arm_arch6)\n+      return \\\"#\\\";\n+    if (which_alternative == 0)\n+      return \\\"sxth\\\\t%0, %1\\\";\n+\n+    mem = XEXP (operands[1], 0);\n+\n+    /* This code used to try to use 'V', and fix the address only if it was\n+       offsettable, but this fails for e.g. REG+48 because 48 is outside the\n+       range of QImode offsets, and offsettable_address_p does a QImode\n+       address check.  */\n+\n+    if (GET_CODE (mem) == CONST)\n+      mem = XEXP (mem, 0);\n+\n+    if (GET_CODE (mem) == LABEL_REF)\n+      return \\\"ldr\\\\t%0, %1\\\";\n+\n+    if (GET_CODE (mem) == PLUS)\n+      {\n+        rtx a = XEXP (mem, 0);\n+        rtx b = XEXP (mem, 1);\n+\n+        if (GET_CODE (a) == LABEL_REF\n+\t    && CONST_INT_P (b))\n+          return \\\"ldr\\\\t%0, %1\\\";\n+\n+        if (REG_P (b))\n+          return \\\"ldrsh\\\\t%0, %1\\\";\n+\n+        ops[1] = a;\n+        ops[2] = b;\n+      }\n+    else\n+      {\n+        ops[1] = mem;\n+        ops[2] = const0_rtx;\n+      }\n+\n+    gcc_assert (REG_P (ops[1]));\n+\n+    ops[0] = operands[0];\n+    if (reg_mentioned_p (operands[2], ops[1]))\n+      ops[3] = ops[0];\n+    else\n+      ops[3] = operands[2];\n+    output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n+    return \\\"\\\";\n+  }\"\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 2) (const_int 4))\n+\t\t\t  (const_int 4)])\n+   (set_attr \"type\" \"extend,load_byte\")\n+   (set_attr \"pool_range\" \"*,1018\")]\n+)\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"\")))]\n+  \"TARGET_THUMB1 && reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (sign_extend:SI (match_dup 3)))]\n+{\n+  rtx addr = XEXP (operands[1], 0);\n+\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n+    /* No split necessary.  */\n+    FAIL;\n+\n+  if (GET_CODE (addr) == PLUS\n+      && !REG_P (XEXP (addr, 0)) && !REG_P (XEXP (addr, 1)))\n+    FAIL;\n+\n+  if (reg_overlap_mentioned_p (operands[0], addr))\n+    {\n+      rtx t = gen_lowpart (QImode, operands[0]);\n+      emit_move_insn (t, operands[1]);\n+      emit_insn (gen_thumb1_extendqisi2 (operands[0], t));\n+      DONE;\n+    }\n+\n+  if (REG_P (addr))\n+    {\n+      addr = gen_rtx_PLUS (Pmode, addr, operands[0]);\n+      operands[2] = const0_rtx;\n+    }\n+  else if (GET_CODE (addr) != PLUS)\n+    FAIL;\n+  else if (REG_P (XEXP (addr, 0)))\n+    {\n+      operands[2] = XEXP (addr, 1);\n+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 0), operands[0]);\n+    }\n+  else\n+    {\n+      operands[2] = XEXP (addr, 0);\n+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 1), operands[0]);\n+    }\n+\n+  operands[3] = change_address (operands[1], QImode, addr);\n+})\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0) (match_operand 1 \"const_int_operand\")))\n+   (set (match_operand:SI 2 \"register_operand\" \"\") (const_int 0))\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 4 \"memory_operand\" \"\")))]\n+  \"TARGET_THUMB1\n+   && GET_CODE (XEXP (operands[4], 0)) == PLUS\n+   && rtx_equal_p (operands[0], XEXP (XEXP (operands[4], 0), 0))\n+   && rtx_equal_p (operands[2], XEXP (XEXP (operands[4], 0), 1))\n+   && (peep2_reg_dead_p (3, operands[0])\n+       || rtx_equal_p (operands[0], operands[3]))\n+   && (peep2_reg_dead_p (3, operands[2])\n+       || rtx_equal_p (operands[2], operands[3]))\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 3) (sign_extend:SI (match_dup 4)))]\n+{\n+  rtx addr = gen_rtx_PLUS (Pmode, operands[0], operands[2]);\n+  operands[4] = change_address (operands[4], QImode, addr);\n+})\n+\n+(define_insn \"thumb1_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l,l\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,V,m\")))]\n+  \"TARGET_THUMB1\"\n+{\n+  rtx addr;\n+\n+  if (which_alternative == 0 && arm_arch6)\n+    return \"sxtb\\\\t%0, %1\";\n+  if (which_alternative == 0)\n+    return \"#\";\n+\n+  addr = XEXP (operands[1], 0);\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n+    return \"ldrsb\\\\t%0, %1\";\n+\n+  return \"#\";\n+}\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 2) (const_int 4))\n+\t\t\t  (const_int 2)\n+\t\t\t  (if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 4) (const_int 6))])\n+   (set_attr \"type\" \"extend,load_byte,load_byte\")]\n+)\n+\n+;;; ??? This should have alternatives for constants.\n+;;; ??? This was originally identical to the movdf_insn pattern.\n+;;; ??? The 'i' constraint looks funny, but it should always be replaced by\n+;;; thumb_reorg with a memory reference.\n+(define_insn \"*thumb1_movdi_insn\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=l,l,l,l,>,l, m,*r\")\n+\t(match_operand:DI 1 \"general_operand\"      \"l, I,J,>,l,mi,l,*r\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], DImode)\n+       || register_operand (operands[1], DImode))\"\n+  \"*\n+  {\n+  switch (which_alternative)\n+    {\n+    default:\n+    case 0:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"add\\\\t%0,  %1,  #0\\;add\\\\t%H0, %H1, #0\\\";\n+      return   \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0,  %1,  #0\\\";\n+    case 1:\n+      return \\\"mov\\\\t%Q0, %1\\;mov\\\\t%R0, #0\\\";\n+    case 2:\n+      operands[1] = GEN_INT (- INTVAL (operands[1]));\n+      return \\\"mov\\\\t%Q0, %1\\;neg\\\\t%Q0, %Q0\\;asr\\\\t%R0, %Q0, #31\\\";\n+    case 3:\n+      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n+    case 4:\n+      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n+    case 5:\n+      return thumb_load_double_from_address (operands);\n+    case 6:\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t     plus_constant (Pmode, XEXP (operands[0], 0), 4));\n+      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n+      return \\\"\\\";\n+    case 7:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n+      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n+    }\n+  }\"\n+  [(set_attr \"length\" \"4,4,6,2,2,6,4,4\")\n+   (set_attr \"type\" \"multiple,multiple,multiple,load2,store2,load2,store2,multiple\")\n+   (set_attr \"pool_range\" \"*,*,*,*,*,1018,*,*\")]\n+)\n+\n+(define_insn \"*thumb1_movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=l,l,l,l,l,>,l, m,*l*h*k\")\n+\t(match_operand:SI 1 \"general_operand\"      \"l, I,J,K,>,l,mi,l,*l*h*k\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"@\n+   mov\t%0, %1\n+   mov\t%0, %1\n+   #\n+   #\n+   ldmia\\\\t%1, {%0}\n+   stmia\\\\t%0, {%1}\n+   ldr\\\\t%0, %1\n+   str\\\\t%1, %0\n+   mov\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2,2,4,4,2,2,2,2,2\")\n+   (set_attr \"type\" \"mov_reg,mov_imm,multiple,multiple,load1,store1,load1,store1,mov_reg\")\n+   (set_attr \"pool_range\" \"*,*,*,*,*,*,1018,*,*\")\n+   (set_attr \"conds\" \"set,clob,*,*,nocond,nocond,nocond,nocond,nocond\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_THUMB1 && satisfies_constraint_J (operands[1])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (neg:SI (match_dup 2)))]\n+  \"\n+  {\n+    operands[1] = GEN_INT (- INTVAL (operands[1]));\n+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n+  }\"\n+)\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_THUMB1 && satisfies_constraint_K (operands[1])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (ashift:SI (match_dup 2) (match_dup 3)))]\n+  \"\n+  {\n+    unsigned HOST_WIDE_INT val = INTVAL (operands[1]) & 0xffffffffu;\n+    unsigned HOST_WIDE_INT mask = 0xff;\n+    int i;\n+\n+    for (i = 0; i < 25; i++)\n+      if ((val & (mask << i)) == val)\n+        break;\n+\n+    /* Don't split if the shift is zero.  */\n+    if (i == 0)\n+      FAIL;\n+\n+    operands[1] = GEN_INT (val >> i);\n+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n+    operands[3] = GEN_INT (i);\n+  }\"\n+)\n+\n+;; For thumb1 split imm move [256-510] into mov [1-255] and add #255\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_THUMB1 && satisfies_constraint_Pe (operands[1])\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (plus:SI (match_dup 2) (match_dup 3)))]\n+  \"\n+  {\n+    operands[1] = GEN_INT (INTVAL (operands[1]) - 255);\n+    operands[2] = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];\n+    operands[3] = GEN_INT (255);\n+  }\"\n+)\n+\n+(define_insn \"*thumb1_movhi_insn\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n+\t(match_operand:HI 1 \"general_operand\"       \"l,m,l,*h,*r,I\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"add\t%0, %1, #0\\\";\n+    case 2: return \\\"strh\t%1, %0\\\";\n+    case 3: return \\\"mov\t%0, %1\\\";\n+    case 4: return \\\"mov\t%0, %1\\\";\n+    case 5: return \\\"mov\t%0, %1\\\";\n+    default: gcc_unreachable ();\n+    case 1:\n+      /* The stack pointer can end up being taken as an index register.\n+          Catch this case here and deal with it.  */\n+      if (GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t  && REG_P (XEXP (XEXP (operands[1], 0), 0))\n+\t  && REGNO    (XEXP (XEXP (operands[1], 0), 0)) == SP_REGNUM)\n+        {\n+\t  rtx ops[2];\n+          ops[0] = operands[0];\n+          ops[1] = XEXP (XEXP (operands[1], 0), 0);\n+\n+          output_asm_insn (\\\"mov\t%0, %1\\\", ops);\n+\n+          XEXP (XEXP (operands[1], 0), 0) = operands[0];\n+\n+\t}\n+      return \\\"ldrh\t%0, %1\\\";\n+    }\"\n+  [(set_attr \"length\" \"2,4,2,2,2,2\")\n+   (set_attr \"type\" \"alus_imm,load1,store1,mov_reg,mov_reg,mov_imm\")\n+   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,clob\")])\n+\n+(define_expand \"thumb_movhi_clobber\"\n+  [(set (match_operand:HI     0 \"memory_operand\"   \"\")\n+\t(match_operand:HI     1 \"register_operand\" \"\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"\"))]\n+  \"TARGET_THUMB1\"\n+  \"\n+  if (strict_memory_address_p (HImode, XEXP (operands[0], 0))\n+      && REGNO (operands[1]) <= LAST_LO_REGNUM)\n+    {\n+      emit_insn (gen_movhi (operands[0], operands[1]));\n+      DONE;\n+    }\n+  /* XXX Fixme, need to handle other cases here as well.  */\n+  gcc_unreachable ();\n+  \"\n+)\n+\n+(define_insn \"*thumb1_movqi_insn\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n+\t(match_operand:QI 1 \"general_operand\"      \"l, m,l,*h,*r,I\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode))\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   ldrb\\\\t%0, %1\n+   strb\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"alu_imm,load1,store1,mov_reg,mov_imm,mov_imm\")\n+   (set_attr \"pool_range\" \"*,32,*,*,*,*\")\n+   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,clob\")])\n+\n+(define_insn \"*thumb1_movhf\"\n+  [(set (match_operand:HF     0 \"nonimmediate_operand\" \"=l,l,m,*r,*h\")\n+\t(match_operand:HF     1 \"general_operand\"      \"l,mF,l,*h,*r\"))]\n+  \"TARGET_THUMB1\n+   && (\t  s_register_operand (operands[0], HFmode)\n+       || s_register_operand (operands[1], HFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 1:\n+      {\n+\trtx addr;\n+\tgcc_assert (MEM_P (operands[1]));\n+\taddr = XEXP (operands[1], 0);\n+\tif (GET_CODE (addr) == LABEL_REF\n+\t    || (GET_CODE (addr) == CONST\n+\t\t&& GET_CODE (XEXP (addr, 0)) == PLUS\n+\t\t&& GET_CODE (XEXP (XEXP (addr, 0), 0)) == LABEL_REF\n+\t\t&& CONST_INT_P (XEXP (XEXP (addr, 0), 1))))\n+\t  {\n+\t    /* Constant pool entry.  */\n+\t    return \\\"ldr\\\\t%0, %1\\\";\n+\t  }\n+\treturn \\\"ldrh\\\\t%0, %1\\\";\n+      }\n+    case 2: return \\\"strh\\\\t%1, %0\\\";\n+    default: return \\\"mov\\\\t%0, %1\\\";\n+    }\n+  \"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"mov_reg,load1,store1,mov_reg,mov_reg\")\n+   (set_attr \"pool_range\" \"*,1018,*,*,*\")\n+   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond\")])\n+;;; ??? This should have alternatives for constants.\n+(define_insn \"*thumb1_movsf_insn\"\n+  [(set (match_operand:SF     0 \"nonimmediate_operand\" \"=l,l,>,l, m,*r,*h\")\n+\t(match_operand:SF     1 \"general_operand\"      \"l, >,l,mF,l,*h,*r\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   add\\\\t%0, %1, #0\n+   ldmia\\\\t%1, {%0}\n+   stmia\\\\t%0, {%1}\n+   ldr\\\\t%0, %1\n+   str\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   mov\\\\t%0, %1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"alus_imm,load1,store1,load1,store1,mov_reg,mov_reg\")\n+   (set_attr \"pool_range\" \"*,*,*,1018,*,*,*\")\n+   (set_attr \"conds\" \"clob,nocond,nocond,nocond,nocond,nocond,nocond\")]\n+)\n+\n+;;; ??? This should have alternatives for constants.\n+;;; ??? This was originally identical to the movdi_insn pattern.\n+;;; ??? The 'F' constraint looks funny, but it should always be replaced by\n+;;; thumb_reorg with a memory reference.\n+(define_insn \"*thumb_movdf_insn\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=l,l,>,l, m,*r\")\n+\t(match_operand:DF 1 \"general_operand\"      \"l, >,l,mF,l,*r\"))]\n+  \"TARGET_THUMB1\n+   && (   register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    default:\n+    case 0:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n+      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n+    case 1:\n+      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n+    case 2:\n+      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n+    case 3:\n+      return thumb_load_double_from_address (operands);\n+    case 4:\n+      operands[2] = gen_rtx_MEM (SImode,\n+\t\t\t\t plus_constant (Pmode,\n+\t\t\t\t\t\tXEXP (operands[0], 0), 4));\n+      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n+      return \\\"\\\";\n+    case 5:\n+      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n+\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n+      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n+    }\n+  \"\n+  [(set_attr \"length\" \"4,2,2,6,4,4\")\n+   (set_attr \"type\" \"multiple,load2,store2,load2,store2,multiple\")\n+   (set_attr \"pool_range\" \"*,*,*,1018,*,*\")]\n+)\n+\f\n+\n+;; Thumb block-move insns\n+\n+(define_insn \"movmem12b\"\n+  [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n+\t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n+   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t(mem:SI (plus:SI (match_dup 3) (const_int 4))))\n+   (set (mem:SI (plus:SI (match_dup 2) (const_int 8)))\n+\t(mem:SI (plus:SI (match_dup 3) (const_int 8))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(plus:SI (match_dup 2) (const_int 12)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=l\")\n+\t(plus:SI (match_dup 3) (const_int 12)))\n+   (clobber (match_scratch:SI 4 \"=&l\"))\n+   (clobber (match_scratch:SI 5 \"=&l\"))\n+   (clobber (match_scratch:SI 6 \"=&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"* return thumb_output_move_mem_multiple (3, operands);\"\n+  [(set_attr \"length\" \"4\")\n+   ; This isn't entirely accurate...  It loads as well, but in terms of\n+   ; scheduling the following insn it is better to consider it as a store\n+   (set_attr \"type\" \"store3\")]\n+)\n+\n+(define_insn \"movmem8b\"\n+  [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n+\t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n+   (set (mem:SI (plus:SI (match_dup 2) (const_int 4)))\n+\t(mem:SI (plus:SI (match_dup 3) (const_int 4))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(plus:SI (match_dup 2) (const_int 8)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=l\")\n+\t(plus:SI (match_dup 3) (const_int 8)))\n+   (clobber (match_scratch:SI 4 \"=&l\"))\n+   (clobber (match_scratch:SI 5 \"=&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"* return thumb_output_move_mem_multiple (2, operands);\"\n+  [(set_attr \"length\" \"4\")\n+   ; This isn't entirely accurate...  It loads as well, but in terms of\n+   ; scheduling the following insn it is better to consider it as a store\n+   (set_attr \"type\" \"store2\")]\n+)\n+\n+\f\n+;; A pattern to recognize a special situation and optimize for it.\n+;; On the thumb, zero-extension from memory is preferrable to sign-extension\n+;; due to the available addressing modes.  Hence, convert a signed comparison\n+;; with zero into an unsigned comparison with 127 if possible.\n+(define_expand \"cbranchqi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"lt_ge_comparison_operator\"\n+\t       [(match_operand:QI 1 \"memory_operand\" \"\")\n+\t        (match_operand:QI 2 \"const0_operand\" \"\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_THUMB1\"\n+{\n+  rtx xops[4];\n+  xops[1] = gen_reg_rtx (SImode);\n+  emit_insn (gen_zero_extendqisi2 (xops[1], operands[1]));\n+  xops[2] = GEN_INT (127);\n+  xops[0] = gen_rtx_fmt_ee (GET_CODE (operands[0]) == GE ? LEU : GTU,\n+\t\t\t    VOIDmode, xops[1], xops[2]);\n+  xops[3] = operands[3];\n+  emit_insn (gen_cbranchsi4 (xops[0], xops[1], xops[2], xops[3]));\n+  DONE;\n+})\n+\n+(define_insn \"cbranchsi4_insn\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"arm_comparison_operator\"\n+\t       [(match_operand:SI 1 \"s_register_operand\" \"l,l*h\")\n+\t        (match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_THUMB1\"\n+{\n+  rtx t = cfun->machine->thumb1_cc_insn;\n+  if (t != NULL_RTX)\n+    {\n+      if (!rtx_equal_p (cfun->machine->thumb1_cc_op0, operands[1])\n+\t  || !rtx_equal_p (cfun->machine->thumb1_cc_op1, operands[2]))\n+\tt = NULL_RTX;\n+      if (cfun->machine->thumb1_cc_mode == CC_NOOVmode)\n+\t{\n+\t  if (!noov_comparison_operator (operands[0], VOIDmode))\n+\t    t = NULL_RTX;\n+\t}\n+      else if (cfun->machine->thumb1_cc_mode != CCmode)\n+\tt = NULL_RTX;\n+    }\n+  if (t == NULL_RTX)\n+    {\n+      output_asm_insn (\"cmp\\t%1, %2\", operands);\n+      cfun->machine->thumb1_cc_insn = insn;\n+      cfun->machine->thumb1_cc_op0 = operands[1];\n+      cfun->machine->thumb1_cc_op1 = operands[2];\n+      cfun->machine->thumb1_cc_mode = CCmode;\n+    }\n+  else\n+    /* Ensure we emit the right type of condition code on the jump.  */\n+    XEXP (operands[0], 0) = gen_rtx_REG (cfun->machine->thumb1_cc_mode,\n+\t\t\t\t\t CC_REGNUM);\n+\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+}\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"cbranchsi4_scratch\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 4 \"arm_comparison_operator\"\n+\t       [(match_operand:SI 1 \"s_register_operand\" \"l,0\")\n+\t        (match_operand:SI 2 \"thumb1_cmpneg_operand\" \"L,J\")])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (match_scratch:SI 0 \"=l,l\"))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  output_asm_insn (\\\"add\\\\t%0, %1, #%n2\\\", operands);\n+\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d4\\\\t%l3\\\";\n+    case 6:  return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*negated_cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(match_operand:SI 1 \"s_register_operand\" \"l\")\n+\t   (neg:SI (match_operand:SI 2 \"s_register_operand\" \"l\"))])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  output_asm_insn (\\\"cmn\\\\t%1, %2\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*tbit_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"l\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  {\n+  rtx op[3];\n+  op[0] = operands[4];\n+  op[1] = operands[1];\n+  op[2] = GEN_INT (32 - 1 - INTVAL (operands[2]));\n+\n+  output_asm_insn (\\\"lsl\\\\t%0, %1, %2\\\", op);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*tlobits_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"equality_operator\"\n+\t  [(zero_extract:SI (match_operand:SI 1 \"s_register_operand\" \"l\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t\t\t    (const_int 0))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 4 \"=l\"))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  {\n+  rtx op[3];\n+  op[0] = operands[4];\n+  op[1] = operands[1];\n+  op[2] = GEN_INT (32 - INTVAL (operands[2]));\n+\n+  output_asm_insn (\\\"lsl\\\\t%0, %1, %2\\\", op);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d0\\\\t%l3\\\";\n+    case 6:  return \\\"b%D0\\\\t.LCB%=\\;b\\\\t%l3\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D0\\\\t.LCB%=\\;bl\\\\t%l3\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 3) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 3) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 3) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 3) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*tstsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"equality_operator\"\n+\t  [(and:SI (match_operand:SI 0 \"s_register_operand\" \"%l\")\n+\t\t   (match_operand:SI 1 \"s_register_operand\" \"l\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  {\n+  output_asm_insn (\\\"tst\\\\t%0, %1\\\", operands);\n+  switch (get_attr_length (insn))\n+    {\n+    case 4:  return \\\"b%d3\\\\t%l2\\\";\n+    case 6:  return \\\"b%D3\\\\t.LCB%=\\;b\\\\t%l2\\\\t%@long jump\\\\n.LCB%=:\\\";\n+    default: return \\\"b%D3\\\\t.LCB%=\\;bl\\\\t%l2\\\\t%@far jump\\\\n.LCB%=:\\\";\n+    }\n+  }\"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 2) (pc)) (const_int -250))\n+\t         (le (minus (match_dup 2) (pc)) (const_int 256)))\n+\t    (const_int 4)\n+\t    (if_then_else\n+\t        (and (ge (minus (match_dup 2) (pc)) (const_int -2040))\n+\t\t     (le (minus (match_dup 2) (pc)) (const_int 2048)))\n+\t\t(const_int 6)\n+\t\t(const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*cbranchne_decr1\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"equality_operator\"\n+\t\t       [(match_operand:SI 2 \"s_register_operand\" \"l,l,1,l\")\n+\t\t        (const_int 0)])\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,*?h,*?m,*?m\")\n+\t(plus:SI (match_dup 2) (const_int -1)))\n+   (clobber (match_scratch:SI 1 \"=X,l,&l,&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+   {\n+     rtx cond[2];\n+     cond[0] = gen_rtx_fmt_ee ((GET_CODE (operands[3]) == NE\n+\t\t\t\t? GEU : LTU),\n+\t\t\t       VOIDmode, operands[2], const1_rtx);\n+     cond[1] = operands[4];\n+\n+     if (which_alternative == 0)\n+       output_asm_insn (\\\"sub\\\\t%0, %2, #1\\\", operands);\n+     else if (which_alternative == 1)\n+       {\n+\t /* We must provide an alternative for a hi reg because reload\n+\t    cannot handle output reloads on a jump instruction, but we\n+\t    can't subtract into that.  Fortunately a mov from lo to hi\n+\t    does not clobber the condition codes.  */\n+\t output_asm_insn (\\\"sub\\\\t%1, %2, #1\\\", operands);\n+\t output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+       }\n+     else\n+       {\n+\t /* Similarly, but the target is memory.  */\n+\t output_asm_insn (\\\"sub\\\\t%1, %2, #1\\\", operands);\n+\t output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+       }\n+\n+     switch (get_attr_length (insn) - (which_alternative ? 2 : 0))\n+       {\n+\t case 4:\n+\t   output_asm_insn (\\\"b%d0\\\\t%l1\\\", cond);\n+\t   return \\\"\\\";\n+\t case 6:\n+\t   output_asm_insn (\\\"b%D0\\\\t.LCB%=\\\", cond);\n+\t   return \\\"b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   output_asm_insn (\\\"b%D0\\\\t.LCB%=\\\", cond);\n+\t   return \\\"bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (eq (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 0))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set_attr_alternative \"length\"\n+      [\n+       ;; Alternative 0\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       ;; Alternative 1\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))\n+       ;; Alternative 2\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))\n+       ;; Alternative 3\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))])\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*addsi3_cbranch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 4 \"arm_comparison_operator\"\n+\t  [(plus:SI\n+\t    (match_operand:SI 2 \"s_register_operand\" \"%0,l,*l,1,1,1\")\n+\t    (match_operand:SI 3 \"reg_or_int_operand\" \"IJ,lL,*l,lIJ,lIJ,lIJ\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 5 \"\" \"\"))\n+\t (pc)))\n+   (set\n+    (match_operand:SI 0 \"thumb_cbrch_target_operand\" \"=l,l,*!h,*?h,*?m,*?m\")\n+    (plus:SI (match_dup 2) (match_dup 3)))\n+   (clobber (match_scratch:SI 1 \"=X,X,l,l,&l,&l\"))]\n+  \"TARGET_THUMB1\n+   && (GET_CODE (operands[4]) == EQ\n+       || GET_CODE (operands[4]) == NE\n+       || GET_CODE (operands[4]) == GE\n+       || GET_CODE (operands[4]) == LT)\"\n+  \"*\n+   {\n+     rtx cond[3];\n+\n+     cond[0] = (which_alternative < 2) ? operands[0] : operands[1];\n+     cond[1] = operands[2];\n+     cond[2] = operands[3];\n+\n+     if (CONST_INT_P (cond[2]) && INTVAL (cond[2]) < 0)\n+       output_asm_insn (\\\"sub\\\\t%0, %1, #%n2\\\", cond);\n+     else\n+       output_asm_insn (\\\"add\\\\t%0, %1, %2\\\", cond);\n+\n+     if (which_alternative >= 2\n+\t && which_alternative < 4)\n+       output_asm_insn (\\\"mov\\\\t%0, %1\\\", operands);\n+     else if (which_alternative >= 4)\n+       output_asm_insn (\\\"str\\\\t%1, %0\\\", operands);\n+\n+     switch (get_attr_length (insn) - ((which_alternative >= 2) ? 2 : 0))\n+       {\n+\t case 4:\n+\t   return \\\"b%d4\\\\t%l5\\\";\n+\t case 6:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;b\\\\t%l5\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   return \\\"b%D4\\\\t.LCB%=\\;bl\\\\t%l5\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (ior (and (lt (symbol_ref (\"which_alternative\"))\n+\t                  (const_int 2))\n+\t\t      (eq_attr \"length\" \"8\"))\n+\t\t (eq_attr \"length\" \"10\"))\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+     (if_then_else\n+       (lt (symbol_ref (\"which_alternative\"))\n+\t\t       (const_int 2))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8)))\n+       (if_then_else\n+\t (and (ge (minus (match_dup 5) (pc)) (const_int -248))\n+\t      (le (minus (match_dup 5) (pc)) (const_int 256)))\n+\t (const_int 6)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 5) (pc)) (const_int -2038))\n+\t\t(le (minus (match_dup 5) (pc)) (const_int 2048)))\n+\t   (const_int 8)\n+\t   (const_int 10)))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*addsi3_cbranch_scratch\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 3 \"arm_comparison_operator\"\n+\t  [(plus:SI\n+\t    (match_operand:SI 1 \"s_register_operand\" \"%l,l,l,0\")\n+\t    (match_operand:SI 2 \"reg_or_int_operand\" \"J,l,L,IJ\"))\n+\t   (const_int 0)])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (clobber (match_scratch:SI 0 \"=X,X,l,l\"))]\n+  \"TARGET_THUMB1\n+   && (GET_CODE (operands[3]) == EQ\n+       || GET_CODE (operands[3]) == NE\n+       || GET_CODE (operands[3]) == GE\n+       || GET_CODE (operands[3]) == LT)\"\n+  \"*\n+   {\n+     switch (which_alternative)\n+       {\n+       case 0:\n+\t output_asm_insn (\\\"cmp\\t%1, #%n2\\\", operands);\n+\t break;\n+       case 1:\n+\t output_asm_insn (\\\"cmn\\t%1, %2\\\", operands);\n+\t break;\n+       case 2:\n+\t if (INTVAL (operands[2]) < 0)\n+\t   output_asm_insn (\\\"sub\\t%0, %1, %2\\\", operands);\n+\t else\n+\t   output_asm_insn (\\\"add\\t%0, %1, %2\\\", operands);\n+\t break;\n+       case 3:\n+\t if (INTVAL (operands[2]) < 0)\n+\t   output_asm_insn (\\\"sub\\t%0, %0, %2\\\", operands);\n+\t else\n+\t   output_asm_insn (\\\"add\\t%0, %0, %2\\\", operands);\n+\t break;\n+       }\n+\n+     switch (get_attr_length (insn))\n+       {\n+\t case 4:\n+\t   return \\\"b%d3\\\\t%l4\\\";\n+\t case 6:\n+\t   return \\\"b%D3\\\\t.LCB%=\\;b\\\\t%l4\\\\t%@long jump\\\\n.LCB%=:\\\";\n+\t default:\n+\t   return \\\"b%D3\\\\t.LCB%=\\;bl\\\\t%l4\\\\t%@far jump\\\\n.LCB%=:\\\";\n+       }\n+   }\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"8\")\n+\t    (const_string \"yes\")\n+            (const_string \"no\")))\n+   (set (attr \"length\")\n+       (if_then_else\n+\t (and (ge (minus (match_dup 4) (pc)) (const_int -250))\n+\t      (le (minus (match_dup 4) (pc)) (const_int 256)))\n+\t (const_int 4)\n+\t (if_then_else\n+\t   (and (ge (minus (match_dup 4) (pc)) (const_int -2040))\n+\t\t(le (minus (match_dup 4) (pc)) (const_int 2048)))\n+\t   (const_int 6)\n+\t   (const_int 8))))\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*thumb_cmpdi_zero\"\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z (match_operand:DI 0 \"s_register_operand\" \"l\")\n+\t\t      (const_int 0)))\n+   (clobber (match_scratch:SI 1 \"=l\"))]\n+  \"TARGET_THUMB1\"\n+  \"orr\\\\t%1, %Q0, %R0\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"logics_reg\")]\n+)\n+\n+(define_expand \"cstoresi_eq0_thumb1\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t  (eq:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t (const_int 0)))\n+     (clobber (match_dup:SI 2))])]\n+  \"TARGET_THUMB1\"\n+  \"operands[2] = gen_reg_rtx (SImode);\"\n+)\n+\n+(define_expand \"cstoresi_ne0_thumb1\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t  (ne:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t\t (const_int 0)))\n+     (clobber (match_dup:SI 2))])]\n+  \"TARGET_THUMB1\"\n+  \"operands[2] = gen_reg_rtx (SImode);\"\n+)\n+\n+(define_insn \"*cstoresi_eq0_thumb1_insn\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&l,l\")\n+\t(eq:SI (match_operand:SI 1 \"s_register_operand\" \"l,0\")\n+\t       (const_int 0)))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"=X,l\"))]\n+  \"TARGET_THUMB1\"\n+  \"@\n+   neg\\\\t%0, %1\\;adc\\\\t%0, %0, %1\n+   neg\\\\t%2, %1\\;adc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*cstoresi_ne0_thumb1_insn\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+\t(ne:SI (match_operand:SI 1 \"s_register_operand\" \"0\")\n+\t       (const_int 0)))\n+   (clobber (match_operand:SI 2 \"s_register_operand\" \"=l\"))]\n+  \"TARGET_THUMB1\"\n+  \"sub\\\\t%2, %1, #1\\;sbc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")]\n+)\n+\n+;; Used as part of the expansion of thumb ltu and gtu sequences\n+(define_insn \"cstoresi_nltu_thumb1\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l,l\")\n+        (neg:SI (ltu:SI (match_operand:SI 1 \"s_register_operand\" \"l,*h\")\n+\t\t\t(match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\"))))]\n+  \"TARGET_THUMB1\"\n+  \"cmp\\\\t%1, %2\\;sbc\\\\t%0, %0, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn_and_split \"cstoresi_ltu_thumb1\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l,l\")\n+        (ltu:SI (match_operand:SI 1 \"s_register_operand\" \"l,*h\")\n+\t\t(match_operand:SI 2 \"thumb1_cmp_operand\" \"lI*h,*r\")))]\n+  \"TARGET_THUMB1\"\n+  \"#\"\n+  \"TARGET_THUMB1\"\n+  [(set (match_dup 3)\n+\t(neg:SI (ltu:SI (match_dup 1) (match_dup 2))))\n+   (set (match_dup 0) (neg:SI (match_dup 3)))]\n+  \"operands[3] = gen_reg_rtx (SImode);\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+;; Used as part of the expansion of thumb les sequence.\n+(define_insn \"thumb1_addsi3_addgeu\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n+        (plus:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"%0\")\n+\t\t\t  (match_operand:SI 2 \"s_register_operand\" \"l\"))\n+\t\t (geu:SI (match_operand:SI 3 \"s_register_operand\" \"l\")\n+\t\t\t (match_operand:SI 4 \"thumb1_cmp_operand\" \"lI\"))))]\n+  \"TARGET_THUMB1\"\n+  \"cmp\\\\t%3, %4\\;adc\\\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+\f\n+(define_insn \"*thumb_jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  if (get_attr_length (insn) == 2)\n+    return \\\"b\\\\t%l0\\\";\n+  return \\\"bl\\\\t%l0\\\\t%@ far jump\\\";\n+  \"\n+  [(set (attr \"far_jump\")\n+        (if_then_else\n+\t    (eq_attr \"length\" \"4\")\n+\t    (const_string \"yes\")\n+\t    (const_string \"no\")))\n+   (set (attr \"length\")\n+        (if_then_else\n+\t    (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n+\t\t (le (minus (match_dup 0) (pc)) (const_int 2048)))\n+  \t    (const_int 2)\n+\t    (const_int 4)))\n+   (set_attr \"type\" \"branch\")]\n+)\n+\n+(define_insn \"*call_reg_thumb1_v5\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1 && arm_arch5 && !SIBLING_CALL_P (insn)\"\n+  \"blx\\\\t%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_reg_thumb1\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1 && !arm_arch5 && !SIBLING_CALL_P (insn)\"\n+  \"*\n+  {\n+    if (!TARGET_CALLER_INTERWORKING)\n+      return thumb_call_via_reg (operands[0]);\n+    else if (operands[1] == const0_rtx)\n+      return \\\"bl\\\\t%__interwork_call_via_%0\\\";\n+    else if (frame_pointer_needed)\n+      return \\\"bl\\\\t%__interwork_r7_call_via_%0\\\";\n+    else\n+      return \\\"bl\\\\t%__interwork_r11_call_via_%0\\\";\n+  }\"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_value_reg_thumb1_v5\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1 && arm_arch5\"\n+  \"blx\\\\t%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_value_reg_thumb1\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1 && !arm_arch5\"\n+  \"*\n+  {\n+    if (!TARGET_CALLER_INTERWORKING)\n+      return thumb_call_via_reg (operands[1]);\n+    else if (operands[2] == const0_rtx)\n+      return \\\"bl\\\\t%__interwork_call_via_%1\\\";\n+    else if (frame_pointer_needed)\n+      return \\\"bl\\\\t%__interwork_r7_call_via_%1\\\";\n+    else\n+      return \\\"bl\\\\t%__interwork_r11_call_via_%1\\\";\n+  }\"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"\" \"\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1\n+   && GET_CODE (operands[0]) == SYMBOL_REF\n+   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[0]))\"\n+  \"bl\\\\t%a0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_value_insn\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand 1 \"\" \"\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB1\n+   && GET_CODE (operands[1]) == SYMBOL_REF\n+   && !arm_is_long_call_p (SYMBOL_REF_DECL (operands[1]))\"\n+  \"bl\\\\t%a1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n+(define_expand \"thumb1_casesi_internal_pic\"\n+  [(match_operand:SI 0 \"s_register_operand\" \"\")\n+   (match_operand:SI 1 \"thumb1_cmp_operand\" \"\")\n+   (match_operand 2 \"\" \"\")\n+   (match_operand 3 \"\" \"\")]\n+  \"TARGET_THUMB1\"\n+  {\n+    rtx reg0;\n+    rtx test = gen_rtx_GTU (VOIDmode, operands[0], operands[1]);\n+    emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[1],\n+\t\t\t\t    operands[3]));\n+    reg0 = gen_rtx_REG (SImode, 0);\n+    emit_move_insn (reg0, operands[0]);\n+    emit_jump_insn (gen_thumb1_casesi_dispatch (operands[2]/*, operands[3]*/));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"thumb1_casesi_dispatch\"\n+  [(parallel [(set (pc) (unspec [(reg:SI 0)\n+\t\t\t\t (label_ref (match_operand 0 \"\" \"\"))\n+;;\t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n+]\n+\t\t\t UNSPEC_THUMB1_CASESI))\n+\t      (clobber (reg:SI IP_REGNUM))\n+              (clobber (reg:SI LR_REGNUM))])]\n+  \"TARGET_THUMB1\"\n+  \"* return thumb1_output_casesi(operands);\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+;; NB Never uses BX.\n+(define_insn \"*thumb1_indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"l*r\"))]\n+  \"TARGET_THUMB1\"\n+  \"mov\\\\tpc, %0\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"branch\")]\n+)\n+\n+\f\n+(define_insn \"prologue_thumb1_interwork\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_THUMB1_INTERWORK)]\n+  \"TARGET_THUMB1\"\n+  \"* return thumb1_output_interwork ();\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"multiple\")]\n+)\n+\n+(define_insn \"*epilogue_insns\"\n+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n+  \"TARGET_THUMB1\"\n+  \"*\n+    return thumb1_unexpanded_epilogue ();\n+  \"\n+  ; Length is absolute worst case\n+  [(set_attr \"length\" \"44\")\n+   (set_attr \"type\" \"block\")\n+   ;; We don't clobber the conditions, but the potential length of this\n+   ;; operation is sufficient to make conditionalizing the sequence\n+   ;; unlikely to be profitable.\n+   (set_attr \"conds\" \"clob\")]\n+)\n+\n+(define_insn \"consttable_1\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_1)]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  making_const_table = TRUE;\n+  assemble_integer (operands[0], 1, BITS_PER_WORD, 1);\n+  assemble_zeros (3);\n+  return \\\"\\\";\n+  \"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"no_insn\")]\n+)\n+\n+(define_insn \"consttable_2\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_2)]\n+  \"TARGET_THUMB1\"\n+  \"*\n+  making_const_table = TRUE;\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (operands[0])) != MODE_FLOAT);\n+  assemble_integer (operands[0], 2, BITS_PER_WORD, 1);\n+  assemble_zeros (2);\n+  return \\\"\\\";\n+  \"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"no_insn\")]\n+)\n+\n+;; Miscellaneous Thumb patterns\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand:SI 0 \"register_operand\" \"\"))\n+\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"TARGET_THUMB1\"\n+  \"\n+  if (flag_pic)\n+    {\n+      /* Hopefully, CSE will eliminate this copy.  */\n+      rtx reg1 = copy_addr_to_reg (gen_rtx_LABEL_REF (Pmode, operands[1]));\n+      rtx reg2 = gen_reg_rtx (SImode);\n+\n+      emit_insn (gen_addsi3 (reg2, operands[0], reg1));\n+      operands[0] = reg2;\n+    }\n+  \"\n+)\n+\n+;; NB never uses BX.\n+(define_insn \"*thumb1_tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_THUMB1\"\n+  \"mov\\\\t%|pc, %0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"no_insn\")]\n+)\n+\n+(define_insn_and_split \"thumb_eh_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"s_register_operand\" \"l\")]\n+\t\t    VUNSPEC_EH_RETURN)\n+   (clobber (match_scratch:SI 1 \"=&l\"))]\n+  \"TARGET_THUMB1\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  {\n+    thumb_set_return_address (operands[0], operands[1]);\n+    DONE;\n+  }\"\n+  [(set_attr \"type\" \"mov_reg\")]\n+)\n+\f"}]}