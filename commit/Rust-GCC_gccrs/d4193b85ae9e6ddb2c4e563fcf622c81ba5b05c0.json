{"sha": "d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQxOTNiODVhZTllNmRkYjJjNGU1NjNmY2Y2MjJjODFiYTViMDVjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-01-17T12:49:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-01-17T12:49:41Z"}, "message": "re PR tree-optimization/77445 (Performance drop after r239219 on coremark test)\n\n\n\tPR middle-end/77445\n\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges):\n\tcorrectly set frequency of oudgoing edge.\n\t(duplicate_thread_path): Fix profile updating.\n\t* gcc.dg/tree-ssa/pr77445-2.c: New testcase.\n\t* gcc.dg/tree-ssa/pr77445.c: New testcase.\n\nFrom-SVN: r244528", "tree": {"sha": "5297f57935ba851deb9924ed23484bff2cb445df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5297f57935ba851deb9924ed23484bff2cb445df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/comments", "author": null, "committer": null, "parents": [{"sha": "906e771270b3d969f4e6aa436d0dfa3e79dd5324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906e771270b3d969f4e6aa436d0dfa3e79dd5324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906e771270b3d969f4e6aa436d0dfa3e79dd5324"}], "stats": {"total": 270, "additions": 227, "deletions": 43}, "files": [{"sha": "5754ee21f8135ebde12fdaac84057ec5bf8e4e97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "patch": "@@ -1,3 +1,10 @@\n+2017-01-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/77445\n+\t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges):\n+\tcorrectly set frequency of oudgoing edge.\n+\t(duplicate_thread_path): Fix profile updating.\n+\n 2017-01-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/79046"}, {"sha": "c34cac3d7ffe3ae63f6ecc83cc9d05eb483bde54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "patch": "@@ -1,3 +1,9 @@\n+2017-01-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/77445\n+\t* gcc.dg/tree-ssa/pr77445-2.c: New testcase.\n+\t* gcc.dg/tree-ssa/pr77445.c: New testcase.\n+\n 2017-01-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/tree-ssa/ssa-dse-2.C (size_t): Typedef to __SIZE_TYPE__"}, {"sha": "47402ec5c4fe0f7994e5e940f2ecac52ae4c57c2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445-2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c?ref=d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "patch": "@@ -0,0 +1,123 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-thread1-details-blocks-stats\" } */\n+typedef enum STATES {\n+\tSTART=0,\n+\tINVALID,\n+\tS1,\n+\tS2,\n+\tINT,\n+\tFLOAT ,\n+\tEXPONENT,\n+\tSCIENTIFIC,\n+\tNUM_STATES\n+} state_e ;\n+\n+typedef unsigned char u8;\n+typedef unsigned int  u32;\n+\n+static u8 is_digit(u8 c) {\n+\treturn (u8)((c>='0') & (c<='9')) ? 1 : 0;\n+}\n+\n+enum STATES FMS( u8 **in , u32 *transitions) {\n+\tu8 *str = *in;\n+\tu8 NEXT_SYMBOL;\n+\tenum STATES state=START;\n+\tfor( ; *str && state != INVALID; str++ ) {\n+\t\tNEXT_SYMBOL = *str;\n+\t\tif (NEXT_SYMBOL==',') /* end of this input */ {\n+\t\t\ttransitions[state]++;\n+\t\t\tstr++;\n+\t\t\tbreak;\n+\t\t}\n+\t\tswitch(state) {\n+\t\tcase START:\n+\t\t\tif(is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = INT;\n+\t\t\t}\n+\t\t\telse if( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {\n+\t\t\t\tstate = S1;\n+\t\t\t}\n+\t\t\telse if( NEXT_SYMBOL == '.' ) {\n+\t\t\t\tstate = FLOAT ;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tstate = INVALID;\n+\t\t\t}\n+\t\t\ttransitions[START]++;\n+\t\t\tbreak;\n+\t\tcase S1:\n+\t\t\tif(is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = INT;\n+\t\t\t\ttransitions[S1]++;\n+\t\t\t}\n+\t\t\telse if( NEXT_SYMBOL == '.' ) {\n+\t\t\t\tstate = FLOAT ;\n+\t\t\t\ttransitions[S1]++;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tstate = INVALID;\n+\t\t\t\ttransitions[S1]++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase INT:\n+\t\t\tif( NEXT_SYMBOL == '.' ) {\n+\t\t\t\tstate = FLOAT ;\n+\t\t\t\ttransitions[INT]++;\n+\t\t\t}\n+\t\t\telse if(!is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = INVALID;\n+\t\t\t\ttransitions[INT]++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase FLOAT :\n+\t\t\tif( NEXT_SYMBOL == 'E' || NEXT_SYMBOL == 'e' ) {\n+\t\t\t\tstate = S2;\n+\t\t\t\ttransitions[FLOAT ]++;\n+\t\t\t}\n+\t\t\telse if(!is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = INVALID;\n+\t\t\t\ttransitions[FLOAT ]++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase S2:\n+\t\t\tif( NEXT_SYMBOL == '+' || NEXT_SYMBOL == '-' ) {\n+\t\t\t\tstate = EXPONENT;\n+\t\t\t\ttransitions[S2]++;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tstate = INVALID;\n+\t\t\t\ttransitions[S2]++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase EXPONENT:\n+\t\t\tif(is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = SCIENTIFIC;\n+\t\t\t\ttransitions[EXPONENT]++;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tstate = INVALID;\n+\t\t\t\ttransitions[EXPONENT]++;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase SCIENTIFIC:\n+\t\t\tif(!is_digit(NEXT_SYMBOL)) {\n+\t\t\t\tstate = INVALID;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (state==INVALID)\n+\t\ttransitions[INVALID]++;\n+\t\n+\t*in = str;\n+\treturn state;\n+}\n+\n+/* The profile is not updated perfectly because it is inconsitent from\n+   profile estimation stage. But the number of inconsistencies should not\n+   increase much.  */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 16\" \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum\" 2 \"thread1\" } } */"}, {"sha": "98eb0f2cec61c24a8ecc09505f2cd98aa6cd13bd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445.c?ref=d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-thread3-details-blocks -fno-early-inlining -fno-tree-vrp -fno-tree-dominator-opts\" } */\n+\n+static int a;\n+static int b;\n+void test2 ();\n+void\n+test ()\n+{\n+  b = 7;\n+}\n+\n+void\n+main (int argc)\n+{\n+  if (argc)\n+    {\n+      a = 7;\n+      test ();\n+    }\n+  else\n+    a = 0;\n+  if (a)\n+    test2 ();\n+  if (b)\n+    test2 ();\n+}\n+/* { dg-final { scan-tree-dump-times \"Registering FSM jump thread\" 2 \"thread3\" } } */\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"thread3\" } } */"}, {"sha": "f85fed314f0f4601883ef044448d22258e67a9fd", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=d4193b85ae9e6ddb2c4e563fcf622c81ba5b05c0", "patch": "@@ -301,7 +301,11 @@ remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n \t  remove_edge (e);\n \t}\n       else\n-\tei_next (&ei);\n+\t{\n+\t  e->probability = REG_BR_PROB_BASE;\n+\t  e->count = bb->count;\n+\t  ei_next (&ei);\n+\t}\n     }\n \n   /* If the remaining edge is a loop exit, there must have\n@@ -2212,8 +2216,8 @@ duplicate_thread_path (edge entry, edge exit,\n   struct loop *loop = entry->dest->loop_father;\n   edge exit_copy;\n   edge redirected;\n-  int total_freq = 0, entry_freq = 0;\n-  gcov_type total_count = 0, entry_count = 0;\n+  int curr_freq;\n+  gcov_type curr_count;\n \n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n@@ -2240,27 +2244,6 @@ duplicate_thread_path (edge entry, edge exit,\n       free_region_copy = true;\n     }\n \n-  if (entry->dest->count)\n-    {\n-      total_count = entry->dest->count;\n-      entry_count = entry->count;\n-      /* Fix up corner cases, to avoid division by zero or creation of negative\n-\t frequencies.  */\n-      if (entry_count > total_count)\n-\tentry_count = total_count;\n-    }\n-  else\n-    {\n-      total_freq = entry->dest->frequency;\n-      entry_freq = EDGE_FREQUENCY (entry);\n-      /* Fix up corner cases, to avoid division by zero or creation of negative\n-\t frequencies.  */\n-      if (total_freq == 0)\n-\ttotal_freq = 1;\n-      else if (entry_freq > total_freq)\n-\tentry_freq = total_freq;\n-    }\n-\n   copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n \t    split_edge_bb_loc (entry), false);\n \n@@ -2270,17 +2253,61 @@ duplicate_thread_path (edge entry, edge exit,\n      invalidating the property that is propagated by executing all the blocks of\n      the jump-thread path in order.  */\n \n+  curr_count = entry->count;\n+  curr_freq = EDGE_FREQUENCY (entry);\n+\n   for (i = 0; i < n_region; i++)\n     {\n       edge e;\n       edge_iterator ei;\n       basic_block bb = region_copy[i];\n \n+      /* Watch inconsistent profile.  */\n+      if (curr_count > region[i]->count)\n+\tcurr_count = region[i]->count;\n+      if (curr_freq > region[i]->frequency)\n+\tcurr_freq = region[i]->frequency;\n+      /* Scale current BB.  */\n+      if (region[i]->count)\n+\t{\n+\t  /* In the middle of the path we only scale the frequencies.\n+\t     In last BB we need to update probabilities of outgoing edges\n+\t     because we know which one is taken at the threaded path.  */\n+\t  if (i + 1 != n_region)\n+\t    scale_bbs_frequencies_gcov_type (region + i, 1,\n+\t\t\t\t\t     region[i]->count - curr_count,\n+\t\t\t\t\t     region[i]->count);\n+\t  else\n+\t    update_bb_profile_for_threading (region[i],\n+\t\t\t\t\t     curr_freq, curr_count,\n+\t\t\t\t\t     exit);\n+\t  scale_bbs_frequencies_gcov_type (region_copy + i, 1, curr_count,\n+\t\t\t\t\t   region_copy[i]->count);\n+\t}\n+      else if (region[i]->frequency)\n+\t{\n+\t  if (i + 1 != n_region)\n+\t    scale_bbs_frequencies_int (region + i, 1,\n+\t\t\t\t       region[i]->frequency - curr_freq,\n+\t\t\t\t       region[i]->frequency);\n+\t  else\n+\t    update_bb_profile_for_threading (region[i],\n+\t\t\t\t\t     curr_freq, curr_count,\n+\t\t\t\t\t     exit);\n+\t  scale_bbs_frequencies_int (region_copy + i, 1, curr_freq,\n+\t\t\t\t     region_copy[i]->frequency);\n+\t}\n+\n       if (single_succ_p (bb))\n \t{\n \t  /* Make sure the successor is the next node in the path.  */\n \t  gcc_assert (i + 1 == n_region\n \t\t      || region_copy[i + 1] == single_succ_edge (bb)->dest);\n+\t  if (i + 1 != n_region)\n+\t    {\n+\t      curr_freq = EDGE_FREQUENCY (single_succ_edge (bb));\n+\t      curr_count = single_succ_edge (bb)->count;\n+\t    }\n \t  continue;\n \t}\n \n@@ -2307,22 +2334,13 @@ duplicate_thread_path (edge entry, edge exit,\n \t    if (orig)\n \t      redirect_edge_and_branch_force (e, orig);\n \t  }\n+\telse\n+\t  {\n+\t    curr_freq = EDGE_FREQUENCY (e);\n+\t    curr_count = e->count;\n+\t  }\n     }\n \n-  if (total_count)\n-    {\n-      scale_bbs_frequencies_gcov_type (region, n_region,\n-\t\t\t\t       total_count - entry_count,\n-\t\t\t\t       total_count);\n-      scale_bbs_frequencies_gcov_type (region_copy, n_region, entry_count,\n-\t\t\t\t       total_count);\n-    }\n-  else\n-    {\n-      scale_bbs_frequencies_int (region, n_region, total_freq - entry_freq,\n-\t\t\t\t total_freq);\n-      scale_bbs_frequencies_int (region_copy, n_region, entry_freq, total_freq);\n-    }\n \n   if (flag_checking)\n     verify_jump_thread (region_copy, n_region);\n@@ -2337,11 +2355,12 @@ duplicate_thread_path (edge entry, edge exit,\n \n   edge e = make_edge (region_copy[n_region - 1], exit->dest, EDGE_FALLTHRU);\n \n-  if (e) {\n-    rescan_loop_exit (e, true, false);\n-    e->probability = REG_BR_PROB_BASE;\n-    e->count = region_copy[n_region - 1]->count;\n-  }\n+  if (e)\n+    {\n+      rescan_loop_exit (e, true, false);\n+      e->probability = REG_BR_PROB_BASE;\n+      e->count = region_copy[n_region - 1]->count;\n+    }\n \n   /* Redirect the entry and add the phi node arguments.  */\n   if (entry->dest == loop->header)"}]}