{"sha": "5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg5NWY3OTM4NDQwMGZlMGJiNGY4ZGE4MTYyZjY4YThlN2I5MmNiNA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-10-09T18:42:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-10-09T18:42:34Z"}, "message": "arm.c: Miscellaneous white space and comment clean-ups.\n\n* arm.c: Miscellaneous white space and comment clean-ups.  No\nfunctional change.\n* arm.md: Likewise.\n\nFrom-SVN: r36812", "tree": {"sha": "29dcf8ff88d70c6ca96a9db7336c647ebba9c255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29dcf8ff88d70c6ca96a9db7336c647ebba9c255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/comments", "author": null, "committer": null, "parents": [{"sha": "9121d9b1a220b88b71318cabe0d488449278d0bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9121d9b1a220b88b71318cabe0d488449278d0bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9121d9b1a220b88b71318cabe0d488449278d0bf"}], "stats": {"total": 2394, "additions": 1256, "deletions": 1138}, "files": [{"sha": "4f04b522e2feda774d7e7b9a24a52bc2808e5486", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "patch": "@@ -1,3 +1,9 @@\n+2000-10-09  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c: Miscellaneous white space and comment clean-ups.  No \n+\tfunctional change.\n+\t* arm.md: Likewise.\n+\n 2000-10-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-common.c (c_expand_builtin_printf): Set the TREE_TYPE of a new"}, {"sha": "217306113cdbf384db9f6313a31e78e4076a6d7c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 190, "deletions": 191, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5895f79384400fe0bb4f8da8162f68a8e7b92cb4", "patch": "@@ -302,8 +302,8 @@ bit_count (value)\n   \n   while (value)\n     {\n-      value &= ~(value & - value);\n-      ++ count;\n+      value &= ~(value & -value);\n+      ++count;\n     }\n \n   return count;\n@@ -325,7 +325,7 @@ arm_override_options ()\n         {\n \t  const struct processors * sel;\n \n-          for (sel = ptr->processors; sel->name != NULL; sel ++)\n+          for (sel = ptr->processors; sel->name != NULL; sel++)\n             if (streq (ptr->string, sel->name))\n               {\n \t\tif (i == 2)\n@@ -380,7 +380,7 @@ arm_override_options ()\n       struct cpu_default * def;\n \t  \n       /* Find the default.  */\n-      for (def = cpu_defaults; def->name; def ++)\n+      for (def = cpu_defaults; def->name; def++)\n \tif (def->cpu == TARGET_CPU_DEFAULT)\n \t  break;\n \n@@ -389,7 +389,7 @@ arm_override_options ()\n \tabort ();\n       \n       /* Find the default CPU's flags.  */\n-      for (sel = all_cores; sel->name != NULL; sel ++)\n+      for (sel = all_cores; sel->name != NULL; sel++)\n \tif (streq (def->name, sel->name))\n \t  break;\n       \n@@ -413,17 +413,17 @@ arm_override_options ()\n \t     interworking.  Therefore we force FL_MODE26 to be removed\n \t     from insn_flags here (if it was set), so that the search\n \t     below will always be able to find a compatible processor.  */\n-\t  insn_flags &= ~ FL_MODE26;\n+\t  insn_flags &= ~FL_MODE26;\n \t}\n-      else if (! TARGET_APCS_32)\n+      else if (!TARGET_APCS_32)\n \tsought |= FL_MODE26;\n       \n       if (sought != 0 && ((sought & insn_flags) != sought))\n \t{\n \t  /* Try to locate a CPU type that supports all of the abilities\n \t     of the default CPU, plus the extra abilities requested by\n \t     the user.  */\n-\t  for (sel = all_cores; sel->name != NULL; sel ++)\n+\t  for (sel = all_cores; sel->name != NULL; sel++)\n \t    if ((sel->flags & sought) == (sought | insn_flags))\n \t      break;\n \n@@ -445,7 +445,7 @@ arm_override_options ()\n \t\t options.  Instead if we cannot find a cpu that has both the\n \t\t characteristics of the default cpu and the given command line\n \t\t options we scan the array again looking for a best match.  */\n-\t      for (sel = all_cores; sel->name != NULL; sel ++)\n+\t      for (sel = all_cores; sel->name != NULL; sel++)\n \t\tif ((sel->flags & sought) == sought)\n \t\t  {\n \t\t    unsigned int count;\n@@ -483,9 +483,9 @@ arm_override_options ()\n \t \"-mapcs-32 -mcpu=arm2\" then we loose here.  */\n       if ((TARGET_DEFAULT & ARM_FLAG_APCS_32) == 0)\n \twarning (\"target CPU does not support APCS-32\" );\n-      target_flags &= ~ ARM_FLAG_APCS_32;\n+      target_flags &= ~ARM_FLAG_APCS_32;\n     }\n-  else if (! TARGET_APCS_32 && !(insn_flags & FL_MODE26))\n+  else if (!TARGET_APCS_32 && !(insn_flags & FL_MODE26))\n     {\n       warning (\"target CPU does not support APCS-26\" );\n       target_flags |= ARM_FLAG_APCS_32;\n@@ -524,12 +524,12 @@ arm_override_options ()\n   /* If interworking is enabled then APCS-32 must be selected as well.  */\n   if (TARGET_INTERWORK)\n     {\n-      if (! TARGET_APCS_32)\n+      if (!TARGET_APCS_32)\n \twarning (\"interworking forces APCS-32 to be used\" );\n       target_flags |= ARM_FLAG_APCS_32;\n     }\n   \n-  if (TARGET_APCS_STACK && ! TARGET_APCS_FRAME)\n+  if (TARGET_APCS_STACK && !TARGET_APCS_FRAME)\n     {\n       warning (\"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n       target_flags |= ARM_FLAG_APCS_FRAME;\n@@ -548,13 +548,13 @@ arm_override_options ()\n      are turned off and debugging is turned on.  */\n   if (TARGET_ARM\n       && write_symbols != NO_DEBUG\n-      && ! TARGET_APCS_FRAME\n+      && !TARGET_APCS_FRAME\n       && (TARGET_DEFAULT & ARM_FLAG_APCS_FRAME))\n     warning (\"-g with -mno-apcs-frame may not give sensible debugging\");\n   \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n-  if (flag_pic && ! TARGET_APCS_STACK)\n+  if (flag_pic && !TARGET_APCS_STACK)\n     arm_pic_register = 10;\n   \n   if (TARGET_APCS_FLOAT)\n@@ -616,7 +616,7 @@ arm_override_options ()\n     {\n       int pic_register;\n \n-      if (! flag_pic)\n+      if (!flag_pic)\n \twarning (\"-mpic-register= is useless without -fpic\");\n \n       pic_register = decode_reg_name (arm_pic_register_string);\n@@ -673,15 +673,15 @@ use_return_insn (iscond)\n   int regno;\n \n   /* Never use a return instruction before reload has run.  */\n-  if (! reload_completed\n+  if (!reload_completed\n       /* Or if the function is variadic.  */\n       || current_function_pretend_args_size\n       || current_function_anonymous_args\n       /* Of if the function calls __builtin_eh_return () */\n       || cfun->machine->eh_epilogue_sp_ofs != NULL\n       /* Or if there is no frame pointer and there is a stack adjustment.  */\n       || ((get_frame_size () + current_function_outgoing_args_size != 0)\n-\t  && ! frame_pointer_needed))\n+\t  && !frame_pointer_needed))\n     return 0;\n \n   /* Can't be done if interworking with Thumb, and any registers have been\n@@ -694,7 +694,7 @@ use_return_insn (iscond)\n       || TARGET_INTERWORK)\n     {\n       for (regno = 0; regno <= LAST_ARM_REGNUM; regno++)\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\n+\tif (regs_ever_live[regno] && !call_used_regs[regno])\n \t  return 0;\n \n       if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n@@ -705,7 +705,7 @@ use_return_insn (iscond)\n      requires an insn.  */\n   if (TARGET_HARD_FLOAT)\n     for (regno = FIRST_ARM_FP_REGNUM; regno <= LAST_ARM_FP_REGNUM; regno++)\n-      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\n \treturn 0;\n \n   /* If a function is naked, don't use the \"return\" insn.  */\n@@ -721,14 +721,14 @@ int\n const_ok_for_arm (i)\n      HOST_WIDE_INT i;\n {\n-  unsigned HOST_WIDE_INT mask = ~ HOST_UINT (0xFF);\n+  unsigned HOST_WIDE_INT mask = ~HOST_UINT (0xFF);\n \n   /* For machines with >32 bit HOST_WIDE_INT, the bits above bit 31 must \n      be all zero, or all one.  */\n-  if ((i & ~ HOST_UINT (0xffffffff)) != 0\n-      && ((i & ~ HOST_UINT (0xffffffff)) \n-\t  != ((~ HOST_UINT (0))\n-\t      & ~ HOST_UINT (0xffffffff))))\n+  if ((i & ~HOST_UINT (0xffffffff)) != 0\n+      && ((i & ~HOST_UINT (0xffffffff)) \n+\t  != ((~HOST_UINT (0))\n+\t      & ~HOST_UINT (0xffffffff))))\n     return FALSE;\n   \n   /* Fast return for 0 and powers of 2 */\n@@ -742,7 +742,7 @@ const_ok_for_arm (i)\n       mask =\n \t  (mask << 2) | ((mask & HOST_UINT (0xffffffff))\n \t\t\t >> (32 - 2)) | ~(HOST_UINT (0xffffffff));\n-    } while (mask != ~ HOST_UINT (0xFF));\n+    } while (mask != ~HOST_UINT (0xFF));\n \n   return FALSE;\n }\n@@ -806,7 +806,7 @@ arm_split_constant (code, mode, val, target, source, subtargets)\n \n \t Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c\n       */\n-      if (! after_arm_reorg\n+      if (!after_arm_reorg\n \t  && (arm_gen_constant (code, mode, val, target, source, 1, 0)\n \t      > arm_constant_limit + (code != SET)))\n \t{\n@@ -1063,7 +1063,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t    {\n \t      if ((((temp2 | (temp2 << i))\n \t\t    & HOST_UINT (0xffffffff)) == remainder)\n-\t\t  && ! const_ok_for_arm (temp2))\n+\t\t  && !const_ok_for_arm (temp2))\n \t\t{\n \t\t  rtx new_src = (subtargets\n \t\t\t\t ? (generate ? gen_reg_rtx (mode) : NULL_RTX)\n@@ -1086,7 +1086,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t  for (i = 17; i < 24; i++)\n \t    {\n \t      if (((temp1 | (temp1 >> i)) == remainder)\n-\t\t  && ! const_ok_for_arm (temp1))\n+\t\t  && !const_ok_for_arm (temp1))\n \t\t{\n \t\t  rtx new_src = (subtargets\n \t\t\t\t ? (generate ? gen_reg_rtx (mode) : NULL_RTX)\n@@ -1115,9 +1115,9 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t then this can be done in two instructions instead of 3-4.  */\n       if (subtargets\n \t  /* TARGET can't be NULL if SUBTARGETS is 0 */\n-\t  || (reload_completed && ! reg_mentioned_p (target, source)))\n+\t  || (reload_completed && !reg_mentioned_p (target, source)))\n \t{\n-\t  if (const_ok_for_arm (ARM_SIGN_EXTEND (~ val)))\n+\t  if (const_ok_for_arm (ARM_SIGN_EXTEND (~val)))\n \t    {\n \t      if (generate)\n \t\t{\n@@ -1176,7 +1176,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t  return 2;\n \t}\n \n-      if (const_ok_for_arm (temp1 = ARM_SIGN_EXTEND (~ val)))\n+      if (const_ok_for_arm (temp1 = ARM_SIGN_EXTEND (~val)))\n \t{\n \t  if (generate)\n \t    {\n@@ -1302,9 +1302,9 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       {\n \tint consecutive_zeros = 0;\n \n-\tif (! (remainder & (3 << i)))\n+\tif (!(remainder & (3 << i)))\n \t  {\n-\t    while ((i < 32) && ! (remainder & (3 << i)))\n+\t    while ((i < 32) && !(remainder & (3 << i)))\n \t      {\n \t\tconsecutive_zeros += 2;\n \t\ti += 2;\n@@ -1405,29 +1405,28 @@ arm_canonicalize_comparison (code, op1)\n \n     case GT:\n     case LE:\n-      if (i != (((HOST_UINT (1)) << (HOST_BITS_PER_WIDE_INT - 1))\n-\t\t- 1)\n-\t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n+      if (i != (((HOST_UINT (1)) << (HOST_BITS_PER_WIDE_INT - 1)) - 1)\n+\t  && (const_ok_for_arm (i + 1) || const_ok_for_arm (-(i + 1))))\n \t{\n-\t  *op1 = GEN_INT (i+1);\n+\t  *op1 = GEN_INT (i + 1);\n \t  return code == GT ? GE : LT;\n \t}\n       break;\n \n     case GE:\n     case LT:\n       if (i != ((HOST_UINT (1)) << (HOST_BITS_PER_WIDE_INT - 1))\n-\t  && (const_ok_for_arm (i-1) || const_ok_for_arm (- (i-1))))\n+\t  && (const_ok_for_arm (i - 1) || const_ok_for_arm (-(i - 1))))\n \t{\n-\t  *op1 = GEN_INT (i-1);\n+\t  *op1 = GEN_INT (i - 1);\n \t  return code == GE ? GT : LE;\n \t}\n       break;\n \n     case GTU:\n     case LEU:\n-      if (i != ~ (HOST_UINT (0))\n-\t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n+      if (i != ~(HOST_UINT (0))\n+\t  && (const_ok_for_arm (i + 1) || const_ok_for_arm (-(i + 1))))\n \t{\n \t  *op1 = GEN_INT (i + 1);\n \t  return code == GTU ? GEU : LTU;\n@@ -1437,7 +1436,7 @@ arm_canonicalize_comparison (code, op1)\n     case GEU:\n     case LTU:\n       if (i != 0\n-\t  && (const_ok_for_arm (i - 1) || const_ok_for_arm (- (i - 1))))\n+\t  && (const_ok_for_arm (i - 1) || const_ok_for_arm (-(i - 1))))\n \t{\n \t  *op1 = GEN_INT (i - 1);\n \t  return code == GEU ? GTU : LEU;\n@@ -1458,7 +1457,7 @@ int\n arm_return_in_memory (type)\n      tree type;\n {\n-  if (! AGGREGATE_TYPE_P (type))\n+  if (!AGGREGATE_TYPE_P (type))\n     /* All simple types are returned in registers.  */\n     return 0;\n   \n@@ -1510,7 +1509,7 @@ arm_return_in_memory (type)\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \t  \n-\t  if (! DECL_BIT_FIELD_TYPE (field))\n+\t  if (!DECL_BIT_FIELD_TYPE (field))\n \t    return 1;\n \t}\n \n@@ -1597,7 +1596,7 @@ arm_function_arg (pcum, mode, type, named)\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (pcum->call_cookie);\n   \n-  if (! named || pcum->nregs >= NUM_ARG_REGS)\n+  if (!named || pcum->nregs >= NUM_ARG_REGS)\n     return NULL_RTX;\n   \n   return gen_rtx_REG (mode, pcum->nregs);\n@@ -1772,7 +1771,7 @@ current_file_function_operand (sym_ref)\n      unit.  if it s a weak defintion however, then this may not be the real\n      defintion of the function, and so we have to say no.  */\n   if (sym_ref == XEXP (DECL_RTL (current_function_decl), 0)\n-      && ! DECL_WEAK (current_function_decl))\n+      && !DECL_WEAK (current_function_decl))\n     return 1;\n \n   /* We cannot make the determination - default to returning 0.  */\n@@ -1806,7 +1805,7 @@ arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n   int call_cookie;\n   int call_symbol;\n {\n-  if (! call_symbol)\n+  if (!call_symbol)\n     {\n       if (GET_CODE (sym_ref) != MEM)\n \treturn 0;\n@@ -1852,13 +1851,13 @@ arm_function_ok_for_sibcall (decl)\n   /* Cannot tail-call to long calls, since these are out of range of\n      a branch instruction.  However, if not compiling PIC, we know\n      we can reach the symbol if it is in this compilation unit.  */\n-  if (call_type == CALL_LONG && (flag_pic || ! TREE_ASM_WRITTEN (decl)))\n+  if (call_type == CALL_LONG && (flag_pic || !TREE_ASM_WRITTEN (decl)))\n     return 0;\n \n   /* If we are interworking and the function is not declared static\n      then we can't tail-call it unless we know that it exists in this \n      compilation unit (since it might be a Thumb routine).  */\n-  if (TARGET_INTERWORK && TREE_PUBLIC (decl) && ! TREE_ASM_WRITTEN (decl))\n+  if (TARGET_INTERWORK && TREE_PUBLIC (decl) && !TREE_ASM_WRITTEN (decl))\n     return 0;\n \n   /* Everything else is ok.  */\n@@ -1959,7 +1958,7 @@ legitimize_pic_address (orig, mode, reg)\n \t     test the index for the appropriate mode.  */\n \t  GO_IF_LEGITIMATE_INDEX (mode, 0, offset, win);\n \n-\t  if (! no_new_pseudos)\n+\t  if (!no_new_pseudos)\n \t    offset = force_reg (Pmode, offset);\n \t  else\n \t    abort ();\n@@ -2019,7 +2018,7 @@ arm_finalize_pic ()\n   if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n     return;\n \n-  if (! flag_pic)\n+  if (!flag_pic)\n     abort ();\n \n   start_sequence ();\n@@ -2098,7 +2097,7 @@ arm_rtx_costs (x, code, outer)\n \t      while (i)\t\t\t\t\t\t\n \t\t{\t\t\t\t\t\t\t\n \t\t  i >>= 2;\t\t\t\t\t\t\n-\t\t  cycles ++;\t\t\t\t\t\t\n+\t\t  cycles++;\t\t\t\t\t\t\n \t\t}\t\t\t\t\t\t\t\n \t      return COSTS_N_INSNS (2) + cycles;\t\t\t\n \t    }\n@@ -2420,11 +2419,11 @@ arm_rtx_costs (x, code, outer)\n       if (const_ok_for_arm (INTVAL (x)))\t\t\t\n \treturn outer == SET ? 2 : -1;\t    \t\t\n       else if (outer == AND                  \t\t\n-\t       && const_ok_for_arm (~ INTVAL (x)))\t\t\n+\t       && const_ok_for_arm (~INTVAL (x)))\t\t\n \treturn -1;\t                              \t\t\n       else if ((outer == COMPARE             \t\t\n \t\t|| outer == PLUS || outer == MINUS)     \n-\t       && const_ok_for_arm (- INTVAL (x)))\t\t\n+\t       && const_ok_for_arm (-INTVAL (x)))\t\t\n \treturn -1;\t                              \t\t\n       else                                        \t\t\n \treturn 5;\n@@ -2622,7 +2621,7 @@ arm_reload_memory_operand (op, mode)\n {\n   int regno = true_regnum (op);\n \n-  return (! CONSTANT_P (op)\n+  return (!CONSTANT_P (op)\n \t  && (regno == -1\n \t      || (GET_CODE (op) == REG\n \t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n@@ -2640,7 +2639,7 @@ bad_signed_byte_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n #if 0\n-  if ((mode == QImode && ! memory_operand (op, mode)) || GET_CODE (op) != MEM)\n+  if ((mode == QImode && !memory_operand (op, mode)) || GET_CODE (op) != MEM)\n     return 0;\n #endif\n   if (GET_CODE (op) != MEM)\n@@ -2650,8 +2649,8 @@ bad_signed_byte_operand (op, mode)\n \n   /* A sum of anything more complex than reg + reg or reg + const is bad.  */\n   if ((GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n-      && (! s_register_operand (XEXP (op, 0), VOIDmode)\n-\t  || (! s_register_operand (XEXP (op, 1), VOIDmode)\n+      && (!s_register_operand (XEXP (op, 0), VOIDmode)\n+\t  || (!s_register_operand (XEXP (op, 1), VOIDmode)\n \t      && GET_CODE (XEXP (op, 1)) != CONST_INT)))\n     return 1;\n \n@@ -3273,7 +3272,7 @@ load_multiple_operation (op, mode)\n           || GET_CODE (SET_SRC (elt)) != MEM\n           || GET_MODE (SET_SRC (elt)) != SImode\n           || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-          || ! rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+          || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n           || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n           || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != (i - base) * 4)\n         return 0;\n@@ -3335,7 +3334,7 @@ store_multiple_operation (op, mode)\n           || GET_CODE (SET_DEST (elt)) != MEM\n           || GET_MODE (SET_DEST (elt)) != SImode\n           || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-          || ! rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+          || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n           || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n           || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != (i - base) * 4)\n         return 0;\n@@ -4143,8 +4142,8 @@ select_dominance_cc_mode (x, y, cond_or)\n   /* If the comparisons are not equal, and one doesn't dominate the other,\n      then we can't do this.  */\n   if (cond1 != cond2 \n-      && ! comparison_dominates_p (cond1, cond2)\n-      && (swapped = 1, ! comparison_dominates_p (cond2, cond1)))\n+      && !comparison_dominates_p (cond1, cond2)\n+      && (swapped = 1, !comparison_dominates_p (cond2, cond1)))\n     return CCmode;\n \n   if (swapped)\n@@ -4157,7 +4156,7 @@ select_dominance_cc_mode (x, y, cond_or)\n   switch (cond1)\n     {\n     case EQ:\n-      if (cond2 == EQ || ! cond_or)\n+      if (cond2 == EQ || !cond_or)\n \treturn CC_DEQmode;\n \n       switch (cond2)\n@@ -4172,7 +4171,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case LT:\n-      if (cond2 == LT || ! cond_or)\n+      if (cond2 == LT || !cond_or)\n \treturn CC_DLTmode;\n       if (cond2 == LE)\n \treturn CC_DLEmode;\n@@ -4181,7 +4180,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case GT:\n-      if (cond2 == GT || ! cond_or)\n+      if (cond2 == GT || !cond_or)\n \treturn CC_DGTmode;\n       if (cond2 == GE)\n \treturn CC_DGEmode;\n@@ -4190,7 +4189,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n       \n     case LTU:\n-      if (cond2 == LTU || ! cond_or)\n+      if (cond2 == LTU || !cond_or)\n \treturn CC_DLTUmode;\n       if (cond2 == LEU)\n \treturn CC_DLEUmode;\n@@ -4199,7 +4198,7 @@ select_dominance_cc_mode (x, y, cond_or)\n       break;\n \n     case GTU:\n-      if (cond2 == GTU || ! cond_or)\n+      if (cond2 == GTU || !cond_or)\n \treturn CC_DGTUmode;\n       if (cond2 == GEU)\n \treturn CC_DGEUmode;\n@@ -4439,7 +4438,7 @@ arm_reload_in_hi (operands)\n \t\t\t\t   gen_rtx_MEM (QImode, \n \t\t\t\t\t\tplus_constant (base,\n \t\t\t\t\t\t\t       offset + 1))));\n-  if (! BYTES_BIG_ENDIAN)\n+  if (!BYTES_BIG_ENDIAN)\n     emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_SUBREG (SImode, operands[0], 0),\n \t\t\tgen_rtx_IOR (SImode, \n \t\t\t\t     gen_rtx_ASHIFT\n@@ -4513,7 +4512,7 @@ arm_reload_out_hi (operands)\n \t{\n \t  /* Updating base_plus might destroy outval, see if we can\n \t     swap the scratch and base_plus.  */\n-\t  if (! reg_overlap_mentioned_p (scratch, outval))\n+\t  if (!reg_overlap_mentioned_p (scratch, outval))\n \t    {\n \t      rtx tmp = scratch;\n \t      scratch = base_plus;\n@@ -4559,7 +4558,7 @@ arm_reload_out_hi (operands)\n \n       hi = ((((offset - lo) & HOST_INT (0xffffffff))\n \t     ^ HOST_INT (0x80000000))\n-\t    -  HOST_INT (0x80000000));\n+\t    - HOST_INT (0x80000000));\n \n       if (hi + lo != offset)\n \tabort ();\n@@ -4573,7 +4572,7 @@ arm_reload_out_hi (operands)\n \t    {\n \t      /* Updating base_plus might destroy outval, see if we\n \t\t can swap the scratch and base_plus.  */\n-\t      if (! reg_overlap_mentioned_p (scratch, outval))\n+\t      if (!reg_overlap_mentioned_p (scratch, outval))\n \t\t{\n \t\t  rtx tmp = scratch;\n \t\t  scratch = base_plus;\n@@ -5480,7 +5479,7 @@ note_invalid_constants (insn, address)\n \n   extract_insn (insn);\n \n-  if (! constrain_operands (1))\n+  if (!constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n   /* Fill in recog_op_alt with information about the constraints of this\n@@ -5707,7 +5706,7 @@ fp_const_from_val (r)\n {\n   int i;\n \n-  if (! fpa_consts_inited)\n+  if (!fpa_consts_inited)\n     init_fpa_table ();\n \n   for (i = 0; i < 8; i++)\n@@ -6498,14 +6497,14 @@ output_ascii_pseudo_op (stream, p, len)\n \tcase '\\\"':\n \tcase '\\\\':\n \t  putc ('\\\\', stream);\n-\t  len_so_far ++;\n+\t  len_so_far++;\n \t  /* drop through.  */\n \n \tdefault:\n \t  if (c >= ' ' && c <= '~')\n \t    {\n \t      putc (c, stream);\n-\t      len_so_far ++;\n+\t      len_so_far++;\n \t    }\n \t  else\n \t    {\n@@ -6555,20 +6554,20 @@ output_return_instruction (operand, really_return, reverse)\n       return \"\";\n     }\n       \n-  if (current_function_calls_alloca && ! really_return)\n+  if (current_function_calls_alloca && !really_return)\n     abort ();\n   \n   for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+    if (regs_ever_live[reg] && !call_used_regs[reg])\n       live_regs++;\n \n-  if (! TARGET_APCS_FRAME\n-      && ! frame_pointer_needed\n+  if (!TARGET_APCS_FRAME\n+      && !frame_pointer_needed\n       && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n     live_regs++;\n \n-  if (flag_pic && ! TARGET_SINGLE_PIC_BASE\n+  if (flag_pic && !TARGET_SINGLE_PIC_BASE\n       && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     live_regs++;\n \n@@ -6582,7 +6581,7 @@ output_return_instruction (operand, really_return, reverse)\n      load a single register.  On other architectures, the cost is the same.  */\n   if (live_regs == 1\n       && regs_ever_live[LR_REGNUM]\n-      && ! really_return)\n+      && !really_return)\n     output_asm_insn (reverse ? \"ldr%?%D0\\t%|lr, [%|sp], #4\" \n \t\t     : \"ldr%?%d0\\t%|lr, [%|sp], #4\", &operand);\n   else if (live_regs == 1\n@@ -6592,7 +6591,7 @@ output_return_instruction (operand, really_return, reverse)\n \t\t     : \"ldr%?%d0\\t%|pc, [%|sp], #4\", &operand);\n   else if (live_regs)\n     {\n-      if (! regs_ever_live[LR_REGNUM])\n+      if (!regs_ever_live[LR_REGNUM])\n         live_regs++;\n \n       if (frame_pointer_needed)\n@@ -6604,8 +6603,8 @@ output_return_instruction (operand, really_return, reverse)\n \n       for (reg = 0; reg <= 10; reg++)\n         if (regs_ever_live[reg]\n-\t    && (! call_used_regs[reg]\n-\t\t|| (flag_pic && ! TARGET_SINGLE_PIC_BASE\n+\t    && (!call_used_regs[reg]\n+\t\t|| (flag_pic && !TARGET_SINGLE_PIC_BASE\n \t\t    && reg == PIC_OFFSET_TABLE_REGNUM)))\n           {\n \t    strcat (instr, \"%|\");\n@@ -6623,14 +6622,14 @@ output_return_instruction (operand, really_return, reverse)\n           strcat (instr, reg_names[13]);\n           strcat (instr, \", \");\n \t  strcat (instr, \"%|\");\n-\t  strcat (instr, TARGET_INTERWORK || (! really_return)\n+\t  strcat (instr, TARGET_INTERWORK || (!really_return)\n \t\t  ? reg_names[LR_REGNUM] : reg_names[PC_REGNUM] );\n         }\n       else\n \t{\n-\t  if (! TARGET_APCS_FRAME\n+\t  if (!TARGET_APCS_FRAME\n \t      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-\t      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+\t      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n \t    {\n \t      strcat (instr, \"%|\");\n \t      strcat (instr, reg_names[HARD_FRAME_POINTER_REGNUM]);\n@@ -6655,7 +6654,7 @@ output_return_instruction (operand, really_return, reverse)\n \t  strcat (instr, \"\\t%|\");\n \t  strcat (instr, frame_pointer_needed ? \"lr\" : \"ip\");\n \n-\t  output_asm_insn (instr, & operand);\n+\t  output_asm_insn (instr, &operand);\n \t}\n     }\n   else if (really_return)\n@@ -6666,7 +6665,7 @@ output_return_instruction (operand, really_return, reverse)\n \tsprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n \t\t reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n       \n-      output_asm_insn (instr, & operand);\n+      output_asm_insn (instr, &operand);\n     }\n \n   return \"\";\n@@ -6772,16 +6771,16 @@ output_arm_prologue (f, frame_size)\n     store_arg_regs = 1;\n \n   for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+    if (regs_ever_live[reg] && !call_used_regs[reg])\n       live_regs_mask |= (1 << reg);\n \n-  if (! TARGET_APCS_FRAME\n-      && ! frame_pointer_needed\n+  if (!TARGET_APCS_FRAME\n+      && !frame_pointer_needed\n       && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n     live_regs_mask |= (1 << HARD_FRAME_POINTER_REGNUM);\n \n-  if (flag_pic && ! TARGET_SINGLE_PIC_BASE\n+  if (flag_pic && !TARGET_SINGLE_PIC_BASE\n       && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n \n@@ -6833,7 +6832,7 @@ arm_output_epilogue (really_return)\n \n   /* If we are throwing an exception, then we really must be doing a return,\n      so we can't tail-call.  */\n-  if (eh_ofs && ! really_return)\n+  if (eh_ofs && !really_return)\n     abort();\n \n   /* A volatile function should never return.  Call abort.  */\n@@ -6847,25 +6846,25 @@ arm_output_epilogue (really_return)\n     }\n \n   for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+    if (regs_ever_live[reg] && !call_used_regs[reg])\n       {\n         live_regs_mask |= (1 << reg);\n \tfloats_offset += 4;\n       }\n \n   /* Handle the frame pointer as a special case.  */\n-  if (! TARGET_APCS_FRAME\n-      && ! frame_pointer_needed\n+  if (!TARGET_APCS_FRAME\n+      && !frame_pointer_needed\n       && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n     {\n       live_regs_mask |= (1 << HARD_FRAME_POINTER_REGNUM);\n       floats_offset += 4;\n     }\n \n   /* If we aren't loading the PIC register, don't stack it even though it may\n      be live.  */\n-  if (flag_pic && ! TARGET_SINGLE_PIC_BASE \n+  if (flag_pic && !TARGET_SINGLE_PIC_BASE \n       && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n       live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n@@ -6877,7 +6876,7 @@ arm_output_epilogue (really_return)\n       if (arm_fpu_arch == FP_SOFT2)\n \t{\n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n-\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tfloats_offset += 12;\n \t\tasm_fprintf (f, \"\\tldfe\\t%r, [%r, #-%d]\\n\", \n@@ -6890,7 +6889,7 @@ arm_output_epilogue (really_return)\n \n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg--)\n \t    {\n-\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n \t\t  floats_offset += 12;\n \t\t  \n@@ -6929,7 +6928,7 @@ arm_output_epilogue (really_return)\n \t  if (really_return)\n \t    asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n \t}\n-      else if (eh_ofs || ! really_return)\n+      else if (eh_ofs || !really_return)\n \t{\n \t  live_regs_mask |= 0x6800;\n \t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask, FALSE);\n@@ -6964,7 +6963,7 @@ arm_output_epilogue (really_return)\n       if (arm_fpu_arch == FP_SOFT2)\n \t{\n \t  for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n-\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      asm_fprintf (f, \"\\tldfe\\t%r, [%r], #12\\n\",\n \t\t\t   reg, SP_REGNUM);\n \t}\n@@ -6974,7 +6973,7 @@ arm_output_epilogue (really_return)\n \n \t  for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n \t    {\n-\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n \t\t  if (reg - start_reg == 3)\n \t\t    {\n@@ -7040,11 +7039,11 @@ arm_output_epilogue (really_return)\n \t      /* Jump to the target; even in 26-bit mode.  */\n \t      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n \t    }\n-\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && ! really_return)\n+\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && !really_return)\n \t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n \t  else if (TARGET_APCS_32 && live_regs_mask == 0 && really_return)\n \t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", PC_REGNUM, SP_REGNUM);\n-\t  else if (! really_return)\n+\t  else if (!really_return)\n \t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM,\n \t\t\t     live_regs_mask | (1 << LR_REGNUM), FALSE);\n \t  else\n@@ -7117,7 +7116,7 @@ output_func_epilogue (frame_size)\n       if (use_return_insn (FALSE)\n \t  && return_used_this_function\n \t  && (frame_size + current_function_outgoing_args_size) != 0\n-\t  && ! frame_pointer_needed)\n+\t  && !frame_pointer_needed)\n \tabort ();\n \n       /* Reset the ARM-specific per-function variables.  */\n@@ -7143,7 +7142,7 @@ emit_multi_reg_push (mask)\n \n   for (i = 0; i <= LAST_ARM_REGNUM; i++)\n     if (mask & (1 << i))\n-      num_regs ++;\n+      num_regs++;\n \n   if (num_regs == 0 || num_regs > 16)\n     abort ();\n@@ -7318,16 +7317,16 @@ arm_expand_prologue ()\n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n-  if (! volatile_func)\n+  if (!volatile_func)\n     {\n       for (reg = 0; reg <= 10; reg++)\n-\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n+\tif (regs_ever_live[reg] && !call_used_regs[reg])\n \t  live_regs_mask |= 1 << reg;\n \n-      if (! TARGET_APCS_FRAME\n-\t  && ! frame_pointer_needed\n+      if (!TARGET_APCS_FRAME\n+\t  && !frame_pointer_needed\n \t  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+\t  && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n \tlive_regs_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n       \n       if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n@@ -7368,12 +7367,12 @@ arm_expand_prologue ()\n       \n   /* For now the integer regs are still pushed in output_arm_epilogue ().  */\n \n-  if (! volatile_func)\n+  if (!volatile_func)\n     {\n       if (arm_fpu_arch == FP_SOFT2)\n \t{\n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg --)\n-\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n \t      {\n \t\tinsn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n \t\tinsn = gen_rtx_MEM (XFmode, insn);\n@@ -7388,7 +7387,7 @@ arm_expand_prologue ()\n \n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg --)\n \t    {\n-\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      if (regs_ever_live[reg] && !call_used_regs[reg])\n \t\t{\n \t\t  if (start_reg - reg == 3)\n \t\t    {\n@@ -7519,7 +7518,7 @@ arm_print_operand (stream, x, code)\n       if (GET_CODE (x) == CONST_INT)\n \t{\n \t  HOST_WIDE_INT val;\n-\t  val = ARM_SIGN_EXTEND (~ INTVAL (x));\n+\t  val = ARM_SIGN_EXTEND (~INTVAL (x));\n \t  fprintf (stream, HOST_WIDE_INT_PRINT_DEC, val);\n \t}\n       else\n@@ -7540,11 +7539,11 @@ arm_print_operand (stream, x, code)\n     case 'S':\n       {\n \tHOST_WIDE_INT val;\n-\tconst char * shift = shift_op (x, & val);\n+\tconst char * shift = shift_op (x, &val);\n \n \tif (shift)\n \t  {\n-\t    fprintf (stream, \", %s \", shift_op (x, & val));\n+\t    fprintf (stream, \", %s \", shift_op (x, &val));\n \t    if (val == -1)\n \t      arm_print_operand (stream, XEXP (x, 1), 0);\n \t    else\n@@ -7614,7 +7613,7 @@ arm_print_operand (stream, x, code)\n       return;\n \n     case 'd':\n-      if (! x)\n+      if (!x)\n \treturn;\n       \n       if (TARGET_ARM)\n@@ -7625,7 +7624,7 @@ arm_print_operand (stream, x, code)\n       return;\n \n     case 'D':\n-      if (! x)\n+      if (!x)\n \treturn;\n \n       if (TARGET_ARM)\n@@ -8057,8 +8056,8 @@ arm_final_prescan_insn (insn)\n \t      /* Fail if a conditional return is undesirable (eg on a\n \t\t StrongARM), but still allow this if optimizing for size.  */\n \t      else if (GET_CODE (scanbody) == RETURN\n-\t\t       && ! use_return_insn (TRUE)\n-\t\t       && ! optimize_size)\n+\t\t       && !use_return_insn (TRUE)\n+\t\t       && !optimize_size)\n \t\tfail = TRUE;\n \t      else if (GET_CODE (scanbody) == RETURN\n \t\t       && seeking_return)\n@@ -8086,8 +8085,8 @@ arm_final_prescan_insn (insn)\n \t      /* Instructions using or affecting the condition codes make it\n \t\t fail.  */\n \t      scanbody = PATTERN (this_insn);\n-\t      if (! (GET_CODE (scanbody) == SET\n-\t\t     || GET_CODE (scanbody) == PARALLEL)\n+\t      if (!(GET_CODE (scanbody) == SET\n+\t\t    || GET_CODE (scanbody) == PARALLEL)\n \t\t  || get_attr_conds (this_insn) != CONDS_NOCOND)\n \t\tfail = TRUE;\n \t      break;\n@@ -8204,7 +8203,7 @@ arm_debugger_arg_offset (value, addr)\n   \n   /* If we are using the stack pointer to point at the\n      argument, then an offset of 0 is correct.  */\n-  if ((TARGET_THUMB || ! frame_pointer_needed)\n+  if ((TARGET_THUMB || !frame_pointer_needed)\n       && REGNO (addr) == SP_REGNUM)\n     return 0;\n   \n@@ -8281,7 +8280,7 @@ replace_symbols_in_block (block, orig, new)\n     {\n       tree sym;\n       \n-      if (! TREE_USED (block))\n+      if (!TREE_USED (block))\n \tcontinue;\n \n       for (sym = BLOCK_VARS (block); sym; sym = TREE_CHAIN (sym))\n@@ -8290,7 +8289,7 @@ replace_symbols_in_block (block, orig, new)\n \t      || DECL_IGNORED_P (sym)\n \t      || TREE_CODE (sym) != VAR_DECL\n \t      || DECL_EXTERNAL (sym)\n-\t      || ! rtx_equal_p (DECL_RTL (sym), orig)\n+\t      || !rtx_equal_p (DECL_RTL (sym), orig)\n \t      )\n \t    continue;\n \n@@ -8314,7 +8313,7 @@ number_of_first_bit_set (mask)\n \n   for (bit = 0;\n        (mask & (1 << bit)) == 0;\n-       ++ bit)\n+       ++bit)\n     continue;\n \n   return bit;\n@@ -8352,7 +8351,7 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n \tabort ();\n \n       regs_to_pop |= 1 << LR_REGNUM;\n-      ++ pops_needed;\n+      ++pops_needed;\n     }\n \n   if (TARGET_BACKTRACE)\n@@ -8375,9 +8374,9 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n   /* Otherwise if we are not supporting interworking and we have not created\n      a backtrace structure and the function was not entered in ARM mode then\n      just pop the return address straight into the PC.  */\n-  else if (   ! TARGET_INTERWORK\n-\t   && ! TARGET_BACKTRACE\n-\t   && ! is_called_in_ARM_mode (current_function_decl))\n+  else if (!TARGET_INTERWORK\n+\t   && !TARGET_BACKTRACE\n+\t   && !is_called_in_ARM_mode (current_function_decl))\n     {\n       if (eh_ofs)\n \t{\n@@ -8449,7 +8448,7 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n \n   /* If we have any popping registers left over, remove them.  */\n   if (available > 0)\n-    regs_available_for_popping &= ~ available;\n+    regs_available_for_popping &= ~available;\n   \n   /* Otherwise if we need another popping register we can use\n      the fourth argument register.  */\n@@ -8477,7 +8476,7 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n \t  /* The fourth argument register is available.  */\n \t  regs_available_for_popping |= 1 << LAST_ARG_REGNUM;\n \t  \n-\t  -- pops_needed;\n+\t  --pops_needed;\n \t}\n     }\n \n@@ -8488,14 +8487,14 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n   if (reg_containing_return_addr == -1)\n     {\n       /* The return address was popped into the lowest numbered register.  */\n-      regs_to_pop &= ~ (1 << LR_REGNUM);\n+      regs_to_pop &= ~(1 << LR_REGNUM);\n       \n       reg_containing_return_addr =\n \tnumber_of_first_bit_set (regs_available_for_popping);\n \n       /* Remove this register for the mask of available registers, so that\n          the return address will not be corrupted by futher pops.  */\n-      regs_available_for_popping &= ~ (1 << reg_containing_return_addr);\n+      regs_available_for_popping &= ~(1 << reg_containing_return_addr);\n     }\n \n   /* If we popped other registers then handle them here.  */\n@@ -8511,8 +8510,8 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n \t\t   ARM_HARD_FRAME_POINTER_REGNUM, frame_pointer);\n \n       /* (Temporarily) remove it from the mask of popped registers.  */\n-      regs_available_for_popping &= ~ (1 << frame_pointer);\n-      regs_to_pop &= ~ (1 << ARM_HARD_FRAME_POINTER_REGNUM);\n+      regs_available_for_popping &= ~(1 << frame_pointer);\n+      regs_to_pop &= ~(1 << ARM_HARD_FRAME_POINTER_REGNUM);\n       \n       if (regs_available_for_popping)\n \t{\n@@ -8572,9 +8571,9 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n \n       asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", move_to, popped_into);\n \n-      regs_to_pop &= ~ (1 << move_to);\n+      regs_to_pop &= ~(1 << move_to);\n \n-      -- pops_needed;\n+      --pops_needed;\n     }\n   \n   /* If we still have not popped everything then we must have only\n@@ -8623,7 +8622,7 @@ thumb_pushpop (f, mask, push)\n   int regno;\n   int lo_mask = mask & 0xFF;\n \n-  if (lo_mask == 0 && ! push && (mask & (1 << 15)))\n+  if (lo_mask == 0 && !push && (mask & (1 << 15)))\n     {\n       /* Special case.  Do not generate a POP PC statement here, do it in\n \t thumb_exit() */\n@@ -8634,7 +8633,7 @@ thumb_pushpop (f, mask, push)\n   fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n \n   /* Look at the low registers first.  */\n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno ++, lo_mask >>= 1)\n+  for (regno = 0; regno <= LAST_LO_REGNUM; regno++, lo_mask >>= 1)\n     {\n       if (lo_mask & 1)\n \t{\n@@ -8712,7 +8711,7 @@ thumb_far_jump_used_p (int in_prologue)\n   rtx insn;\n \n   /* This test is only important for leaf functions.  */\n-  /* assert (! leaf_function_p ()); */\n+  /* assert (!leaf_function_p ()); */\n   \n   /* If we have already decided that far jumps may be used,\n      do not bother checking again, and always return true even if\n@@ -8725,7 +8724,7 @@ thumb_far_jump_used_p (int in_prologue)\n   /* If this function is not being called from the prologue/epilogue\n      generation code then it must be being called from the\n      INITIAL_ELIMINATION_OFFSET macro.  */\n-  if (! in_prologue)\n+  if (!in_prologue)\n     {\n       /* In this case we know that we are being asked about the elimination\n \t of the arg pointer register.  If that register is not being used,\n@@ -8747,7 +8746,7 @@ thumb_far_jump_used_p (int in_prologue)\n \t hope that this does not occur too often.  */\n       if (regs_ever_live [ARG_POINTER_REGNUM])\n \tcfun->machine->arg_pointer_live = 1;\n-      else if (! cfun->machine->arg_pointer_live)\n+      else if (!cfun->machine->arg_pointer_live)\n \treturn 0;\n     }\n \n@@ -8806,15 +8805,15 @@ thumb_unexpanded_epilogue ()\n     return \"\";\n \n   for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n+    if (regs_ever_live[regno] && !call_used_regs[regno]\n+\t&& !(TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n       live_regs_mask |= 1 << regno;\n \n   for (regno = 8; regno < 13; regno++)\n     {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n-\thigh_regs_pushed ++;\n+      if (regs_ever_live[regno] && !call_used_regs[regno]\n+\t  && !(TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n+\thigh_regs_pushed++;\n     }\n \n   /* The prolog may have pushed some high registers to use as\n@@ -8859,8 +8858,8 @@ thumb_unexpanded_epilogue ()\n \tfatal (\"No low registers available for popping high registers\");\n       \n       for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n-\tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n-\t    && ! (TARGET_SINGLE_PIC_BASE && (next_hi_reg == arm_pic_register)))\n+\tif (regs_ever_live[next_hi_reg] && !call_used_regs[next_hi_reg]\n+\t    && !(TARGET_SINGLE_PIC_BASE && (next_hi_reg == arm_pic_register)))\n \t  break;\n \n       while (high_regs_pushed)\n@@ -8889,17 +8888,17 @@ thumb_unexpanded_epilogue ()\n \t\t\t       regno);\n \t\t  \n \t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n-\t\t    if (regs_ever_live[next_hi_reg] && \n-\t\t\t! call_used_regs[next_hi_reg]\n-\t\t\t&& ! (TARGET_SINGLE_PIC_BASE \n-\t\t\t      && (next_hi_reg == arm_pic_register)))\n+\t\t    if (regs_ever_live[next_hi_reg]\n+\t\t\t&& !call_used_regs[next_hi_reg]\n+\t\t\t&& !(TARGET_SINGLE_PIC_BASE \n+\t\t\t     && (next_hi_reg == arm_pic_register)))\n \t\t      break;\n \t\t}\n \t    }\n \t}\n     }\n \n-  had_to_push_lr = (live_regs_mask || ! leaf_function\n+  had_to_push_lr = (live_regs_mask || !leaf_function\n \t\t    || thumb_far_jump_used_p (1));\n   \n   if (TARGET_BACKTRACE\n@@ -8915,8 +8914,8 @@ thumb_unexpanded_epilogue ()\n   if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n       if (had_to_push_lr\n-\t  && ! is_called_in_ARM_mode (current_function_decl)\n-\t  && ! eh_ofs)\n+\t  && !is_called_in_ARM_mode (current_function_decl)\n+\t  && !eh_ofs)\n \tlive_regs_mask |= 1 << PC_REGNUM;\n \n       /* Either no argument registers were pushed or a backtrace\n@@ -8940,7 +8939,7 @@ thumb_unexpanded_epilogue ()\n   else\n     {\n       /* Pop everything but the return address.  */\n-      live_regs_mask &= ~ (1 << PC_REGNUM);\n+      live_regs_mask &= ~(1 << PC_REGNUM);\n       \n       if (live_regs_mask)\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE);\n@@ -9007,7 +9006,7 @@ arm_return_addr (count, frame)\n       reg = gen_reg_rtx (Pmode);\n       cfun->machine->ra_rtx = reg;\n       \n-      if (! TARGET_APCS_32)\n+      if (!TARGET_APCS_32)\n \tinit = gen_rtx_AND (Pmode, gen_rtx_REG (Pmode, LR_REGNUM),\n \t\t\t    GEN_INT (RETURN_ADDR_MASK26));\n       else\n@@ -9053,7 +9052,7 @@ thumb_expand_prologue ()\n       \n       if (amount < 512)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (- amount)));\n+\t\t\t       GEN_INT (-amount)));\n       else\n \t{\n \t  int regno;\n@@ -9075,10 +9074,10 @@ thumb_expand_prologue ()\n \t     it now.  */\n \t  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)\n \t    if (regs_ever_live[regno]\n-\t\t&& ! call_used_regs[regno] /* Paranoia */\n-\t\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register))\n-\t\t&& ! (frame_pointer_needed\n-\t\t      && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))\n+\t\t&& !call_used_regs[regno] /* Paranoia */\n+\t\t&& !(TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register))\n+\t\t&& !(frame_pointer_needed\n+\t\t     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))\n \t      break;\n \n \t  if (regno > LAST_LO_REGNUM) /* Very unlikely */\n@@ -9092,7 +9091,7 @@ thumb_expand_prologue ()\n \t      emit_insn (gen_movsi (spare, reg));\n \n \t      /* Decrement the stack.  */\n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n+\t      emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     reg));\n \n@@ -9109,7 +9108,7 @@ thumb_expand_prologue ()\n \t    {\n \t      reg = gen_rtx (REG, SImode, regno);\n \n-\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n+\t      emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n \t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     reg));\n \t    }\n@@ -9219,7 +9218,7 @@ output_thumb_prologue (f)\n \t  \n \t  for (regno = LAST_ARG_REGNUM + 1 - num_pushes;\n \t       regno <= LAST_ARG_REGNUM;\n-\t       regno ++)\n+\t       regno++)\n \t    asm_fprintf (f, \"%r%s\", regno,\n \t\t\t regno == LAST_ARG_REGNUM ? \"\" : \", \");\n \n@@ -9231,12 +9230,12 @@ output_thumb_prologue (f)\n \t\t     current_function_pretend_args_size);\n     }\n \n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno ++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n+  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n+    if (regs_ever_live[regno] && !call_used_regs[regno]\n+\t&& !(TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n       live_regs_mask |= 1 << regno;\n \n-  if (live_regs_mask || ! leaf_function_p () || thumb_far_jump_used_p (1))\n+  if (live_regs_mask || !leaf_function_p () || thumb_far_jump_used_p (1))\n     live_regs_mask |= 1 << LR_REGNUM;\n \n   if (TARGET_BACKTRACE)\n@@ -9335,9 +9334,9 @@ output_thumb_prologue (f)\n \n   for (regno = 8; regno < 13; regno++)\n     {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n-\thigh_regs_pushed ++;\n+      if (regs_ever_live[regno] && !call_used_regs[regno]\n+\t  && !(TARGET_SINGLE_PIC_BASE && (regno == arm_pic_register)))\n+\thigh_regs_pushed++;\n     }\n \n   if (high_regs_pushed)\n@@ -9348,9 +9347,9 @@ output_thumb_prologue (f)\n \n       for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n \t{\n-\t  if (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n-\t      && ! (TARGET_SINGLE_PIC_BASE\n-\t\t    && (next_hi_reg == arm_pic_register)))\n+\t  if (regs_ever_live[next_hi_reg] && !call_used_regs[next_hi_reg]\n+\t      && !(TARGET_SINGLE_PIC_BASE\n+\t\t   && (next_hi_reg == arm_pic_register)))\n \t    break;\n \t}\n \n@@ -9360,7 +9359,7 @@ output_thumb_prologue (f)\n \t{\n \t  /* Desperation time -- this probably will never happen.  */\n \t  if (regs_ever_live[LAST_ARG_REGNUM]\n-\t      || ! call_used_regs[LAST_ARG_REGNUM])\n+\t      || !call_used_regs[LAST_ARG_REGNUM])\n \t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, LAST_ARG_REGNUM);\n \t  mask = 1 << LAST_ARG_REGNUM;\n \t}\n@@ -9373,21 +9372,21 @@ output_thumb_prologue (f)\n \t\t{\n \t\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", regno, next_hi_reg);\n \t\t  \n-\t\t  high_regs_pushed --;\n+\t\t  high_regs_pushed--;\n \t\t  \n \t\t  if (high_regs_pushed)\n \t\t    for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;\n \t\t\t next_hi_reg--)\n \t\t      {\n \t\t\tif (regs_ever_live[next_hi_reg]\n-\t\t\t    && ! call_used_regs[next_hi_reg]\n-\t\t\t    && ! (TARGET_SINGLE_PIC_BASE \n-\t\t\t\t  && (next_hi_reg == arm_pic_register)))\n+\t\t\t    && !call_used_regs[next_hi_reg]\n+\t\t\t    && !(TARGET_SINGLE_PIC_BASE \n+\t\t\t\t && (next_hi_reg == arm_pic_register)))\n \t\t\t  break;\n \t\t      }\n \t\t  else\n \t\t    {\n-\t\t      mask &= ~ ((1 << regno) - 1);\n+\t\t      mask &= ~((1 << regno) - 1);\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -9398,7 +9397,7 @@ output_thumb_prologue (f)\n \n       if (pushable_regs == 0\n \t  && (regs_ever_live[LAST_ARG_REGNUM]\n-\t      || ! call_used_regs[LAST_ARG_REGNUM]))\n+\t      || !call_used_regs[LAST_ARG_REGNUM]))\n \tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", LAST_ARG_REGNUM, IP_REGNUM);\n     }\n }\n@@ -9743,7 +9742,7 @@ aof_pic_entry (x)\n       /* We mark this here and not in arm_add_gc_roots() to avoid\n \t polluting even more code with ifdefs, and because it never\n \t contains anything useful until we assign to it here.  */\n-      ggc_add_rtx_root (& aof_pic_label, 1);\n+      ggc_add_rtx_root (&aof_pic_label, 1);\n       /* This needs to persist throughout the compilation.  */\n       end_temporary_allocation ();\n       aof_pic_label = gen_rtx_SYMBOL_REF (Pmode, \"x$adcons\");"}, {"sha": "b718ea8ff293ad25b0b655ba575f23c49dfaae98", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1060, "deletions": 947, "changes": 2007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5895f79384400fe0bb4f8da8162f68a8e7b92cb4/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5895f79384400fe0bb4f8da8162f68a8e7b92cb4"}]}