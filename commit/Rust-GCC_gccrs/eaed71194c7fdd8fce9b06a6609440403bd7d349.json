{"sha": "eaed71194c7fdd8fce9b06a6609440403bd7d349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlZDcxMTk0YzdmZGQ4ZmNlOWIwNmE2NjA5NDQwNDAzYmQ3ZDM0OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T02:55:45Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T02:55:45Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r894", "tree": {"sha": "516bfcccfb276bc8cc55d263bcb2bec51f7e8969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/516bfcccfb276bc8cc55d263bcb2bec51f7e8969"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaed71194c7fdd8fce9b06a6609440403bd7d349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaed71194c7fdd8fce9b06a6609440403bd7d349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaed71194c7fdd8fce9b06a6609440403bd7d349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaed71194c7fdd8fce9b06a6609440403bd7d349/comments", "author": null, "committer": null, "parents": [{"sha": "b6422cca6ec7b3cc3704dd2b4ea27b5969b239e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6422cca6ec7b3cc3704dd2b4ea27b5969b239e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6422cca6ec7b3cc3704dd2b4ea27b5969b239e7"}], "stats": {"total": 502, "additions": 319, "deletions": 183}, "files": [{"sha": "b4e8c77c4a1287b8165094112f8fb9da95224bd3", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 319, "deletions": 183, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaed71194c7fdd8fce9b06a6609440403bd7d349/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaed71194c7fdd8fce9b06a6609440403bd7d349/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=eaed71194c7fdd8fce9b06a6609440403bd7d349", "patch": "@@ -90,9 +90,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n \n-static struct obstack obstack, obstack1;\n+static struct obstack obstack, obstack1, obstack2;\n struct obstack *rtl_obstack = &obstack;\n struct obstack *hash_obstack = &obstack1;\n+struct obstack *accum_obstack = &obstack2;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -275,8 +276,8 @@ static rtx insert_right_side ();\n static rtx make_alternative_compare ();\n static int compute_alternative_mask ();\n static rtx evaluate_eq_attr ();\n-static rtx simplify_and_tree ();\n-static rtx simplify_or_tree ();\n+/* static rtx simplify_and_tree ();\n+static rtx simplify_or_tree (); */\n static rtx simplify_test_exp ();\n static void optimize_attrs ();\n static void gen_attr ();\n@@ -1696,6 +1697,8 @@ simplify_cond (exp, insn_code, insn_index)\n   /* We store the desired contents here,\n      then build a new expression if they don't match EXP.  */\n   rtx defval = XEXP (exp, 1);\n+  rtx new_defval = XEXP (exp, 1);\n+\n   int len = XVECLEN (exp, 0);\n   rtx *tests = (rtx *) alloca (len * sizeof (rtx));\n   int allsame = 1;\n@@ -1708,7 +1711,7 @@ simplify_cond (exp, insn_code, insn_index)\n \n   /* See if default value needs simplification.  */\n   if (GET_CODE (defval) == COND)\n-    defval = simplify_cond (defval, insn_code, insn_index);\n+    new_defval = simplify_cond (defval, insn_code, insn_index);\n \n   /* Simplify now, just to see what tests we can get rid of.  */\n \n@@ -1733,6 +1736,7 @@ simplify_cond (exp, insn_code, insn_index)\n \t     and discard this + any following tests.  */\n \t  len = i;\n \t  defval = tests[i];\n+\t  new_defval = newval;\n \t}\n \n       else if (newtest == false_rtx)\n@@ -1746,15 +1750,14 @@ simplify_cond (exp, insn_code, insn_index)\n \n       /* If this is the last condition in a COND and our value is the same\n \t as the default value, our test isn't needed.  */\n-      else if (i == len - 2 && rtx_equal_p (newval, defval))\n+      else if (i == len - 2 && rtx_equal_p (newval, new_defval))\n \tlen -= 2;\n     }\n \n   obstack_free (rtl_obstack, first_spacer);\n \n   if (len == 0)\n     {\n-      defval = XEXP (exp, 1);\n       if (GET_CODE (defval) == COND)\n \treturn simplify_cond (defval, insn_code, insn_index);\n       return defval;\n@@ -2063,6 +2066,288 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n     return newexp;\n }\n \f\n+/* These are used by simplify_boolean to accumulate and sort terms.  */\n+\n+struct term\n+{\n+  rtx exp;\n+  int hash;\n+  int ignore;\n+  struct term *next;\n+};\n+\n+struct term *termlist;\n+\n+void\n+extract_terms (code, exp, pnterms, insn_code, insn_index)\n+     enum rtx_code code;\n+     rtx exp;\n+     int *pnterms;\n+     int insn_code, insn_index;\n+{\n+  if (GET_CODE (exp) == code)\n+    {\n+      extract_terms (code, XEXP (exp, 0), pnterms, insn_code, insn_index);\n+      extract_terms (code, XEXP (exp, 1), pnterms, insn_code, insn_index);\n+    }\n+  else\n+    {\n+      struct term *save = termlist;\n+      exp = SIMPLIFY_TEST_EXP (exp, insn_code, insn_index);\n+      termlist = save;\n+\n+      if (GET_CODE (exp) == code)\n+\t{\n+\t  extract_terms (code, XEXP (exp, 0), pnterms, insn_code, insn_index);\n+\t  extract_terms (code, XEXP (exp, 1), pnterms, insn_code, insn_index);\n+\t}\n+      else\n+\t{\n+\t  struct term t;\n+\t  t.exp = exp;\n+\t  t.hash = hash_term (exp);\n+\t  t.ignore = 0;\n+\t  t.next = termlist;\n+\t  termlist = (struct term *) obstack_copy (accum_obstack,\n+\t\t\t\t\t\t   &t, sizeof t);\n+\n+\t  (*pnterms)++;\n+\t}\n+    }\n+}\n+\n+/* Compare two terms for sorting.\n+   This particular sort function treats any term and its negation as \"equal\"\n+   so that they sort together.  */\n+\n+int\n+compare_terms (pt1, pt2)\n+     struct term *pt1, *pt2;\n+{\n+  return pt1->hash - pt2->hash;\n+}\n+\n+int\n+hash_term (term)\n+     rtx term;\n+{\n+  while (GET_CODE (term) == NOT)\n+    term = XEXP (term, 0);\n+\n+  if (RTX_UNCHANGING_P (term))\n+    return (int) term;\n+\n+  switch (GET_CODE (term))\n+    {\n+    case AND:\n+      return (hash_term (XEXP (term, 0))\n+\t      + (hash_term (XEXP (term, 1)) << 3)\n+\t      + (int) AND);\n+\n+    case IOR:\n+      return (hash_term (XEXP (term, 0))\n+\t      + (hash_term (XEXP (term, 1)) << 4)\n+\t      + (int) IOR);\n+\n+    default:\n+      return (int) term;\n+    }\n+}\n+\f\n+/* Simplify a boolean expression made from applying CODE (which is AND or IOR)\n+   to the two expressions EXP1 and EXP2.\n+\n+   EXP3 is another expression we can assume is true (if CODE is AND)\n+   or assume is false (if CODE is IOR).\n+\n+   STABLE is either true or false.\n+   It is the truth value which, when input to CODE, makes itself the output.\n+   UNSTABLE is the other truth value: the one which is CODE of no operands.  */\n+\n+rtx\n+simplify_boolean (code, exp1, exp2, exp3, stable, unstable,\n+\t\t  insn_code, insn_index)\n+     enum rtx_code code;\n+     rtx exp1, exp2, exp3;\n+     rtx stable, unstable;\n+     int insn_code, insn_index;\n+{\n+  struct term *vector;\n+  int nterms = 0;\n+  int nignores = 0;\n+  int i, j;\n+  char *spacer = (char *) obstack_finish (accum_obstack);\n+  rtx combined;\n+  rtx common_term;\n+  enum rtx_code other_code = (code == AND ? IOR : AND);\n+  static struct term dummy = {0, 0, 0, 0};\n+\n+  termlist = 0;\n+\n+  nterms = 1; /* Count one dummy element.  */\n+  extract_terms (code, exp1, &nterms, insn_code, insn_index);\n+  if (exp2)\n+    extract_terms (code, exp2, &nterms, insn_code, insn_index);\n+\n+  if (exp3)\n+    extract_terms (code, exp3, &nignores, insn_code, insn_index);\n+  nterms += nignores;\n+\n+  vector = (struct term *) alloca (nterms * sizeof (struct term));\n+\n+  /* Copy the terms from the list into the vector.\n+     Set the ignore flag in those which came from EXP3.\n+     That way, we won't include them in the final result.  */\n+\n+  vector[0] = dummy;\n+  for (i = 1; i < nterms; i++)\n+    {\n+      vector[i] = *termlist;\n+      if (i < nignores)\n+\tvector[i].ignore = 1;\n+      termlist = termlist->next;\n+    }\n+  \n+  /* Free what we used in the obstack.  */\n+  obstack_free (accum_obstack, spacer);\n+\n+  qsort (vector, nterms, sizeof (struct term), compare_terms);\n+\n+  if (insn_code >= 0)\n+    {\n+      i = (compute_alternative_mask (exp1, code)\n+\t   & compute_alternative_mask (exp2, code));\n+      if (i & ~insn_alternatives[insn_code])\n+\tfatal (\"invalid alternative specified for pattern number %d\",\n+\t       insn_index);\n+\n+      /* If all alternatives are excluded for AND (included for IOR),\n+\t this is false (true). */\n+      i ^= insn_alternatives[insn_code];\n+      if (i == 0)\n+\t{\n+\t  return stable;\n+\t}\n+      else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n+\t{\n+\t  /* If just one included for AND (excluded for IOR),\n+\t     add one term which tests for that alternative.\n+\t     We do not want to do this if the insn has one\n+\t     alternative and we have tested none of them!  */\n+\t  vector[0].exp = make_alternative_compare (i);\n+\t  if (code == IOR)\n+\t    vector[0].exp = attr_rtx (NOT, vector[0].exp);\n+\t}\n+    }\n+\n+  /* Try distributive law in one simple way.  */\n+  common_term = 0;\n+  for (i = 0; i < nterms; i++)\n+    if (vector[i].exp != 0)\n+      {\n+\tif (GET_CODE (vector[i].exp) != other_code)\n+\t  break;\n+\tif (common_term == 0)\n+\t  common_term = XEXP (vector[i].exp, 0);\n+\telse if (!rtx_equal_p (XEXP (vector[i].exp, 0), common_term))\n+\t  break;\n+      }\n+  if (i != nterms)\n+    common_term = 0;\n+\n+  /* If we found a subterm in common, remove it from each term.  */\n+  if (common_term)\n+    for (i = 0; i < nterms; i++)\n+      if (vector[i].exp != 0)\n+\tvector[i].exp = XEXP (vector[i].exp, 1);\n+\n+  /* See if any two adjacent terms are equivalent or contrary.\n+     Equivalent or contrary terms should be adjacent because of sorting.  */\n+  for (i = 0; i < nterms - 1; i++)\n+    {\n+      rtx base0 = vector[i].exp;\n+      rtx base1 = vector[i + 1].exp;\n+      if (base0 != 0 && base1 != 0)\n+\t{\n+\t  if (GET_CODE (base0) == NOT)\n+\t    base0 = XEXP (base0, 0);\n+\t  if (GET_CODE (base1) == NOT)\n+\t    base1 = XEXP (base1, 0);\n+\t  if (rtx_equal_p (base0, base1))\n+\t    {\n+\t      if (! rtx_equal_p (vector[i].exp, vector[i + 1].exp))\n+\t\t{\n+\t\t  /* There are two contrary terms:\n+\t\t     The value is true for IOR, false for AND.  */\n+\t\t  return common_term ? common_term : stable;\n+\t\t}\n+\t      /* Delete one of a pair of equivalent terms.  */\n+\t      vector[i].exp = 0;\n+\t      vector[i].ignore |= vector[i + 1].ignore;\n+\t    }\n+\t}\n+    }\n+\n+  /* Take advantage of the fact that two different values for the same\n+     attribute are contradictory.  */\n+  if (code == AND)\n+    {\n+      for (i = 0; i < nterms; i++)\n+\tif (vector[i].exp != 0 && GET_CODE (vector[i].exp) == EQ_ATTR)\n+\t  {\n+\t    char *aname = XSTR (vector[i].exp, 0);\n+\n+\t    for (j = i + 1; j < nterms; j++)\n+\t      {\n+\t\tif (vector[j].exp != 0 && GET_CODE (vector[j].exp) == EQ_ATTR\n+\t\t    && XSTR (vector[i].exp, 0) == aname)\n+\t\t  {\n+\t\t    return common_term ? common_term : stable;\n+\t\t  }\n+\n+\t\tif (vector[i].exp != 0 && GET_CODE (vector[i].exp) == NOT\n+\t\t    && GET_CODE (XEXP (vector[i].exp, 0)) == EQ_ATTR\n+\t\t    && XSTR (XEXP (vector[i].exp, 0), 0) == aname)\n+\t\t  vector[i].exp = 0;\n+\t      }\n+\t  }\n+    }\n+\n+  /* Now build up rtl from the terms we didn't get rid of.  */\n+  combined = unstable;\n+  for (i = 0; i < nterms; i++)\n+    if (vector[i].exp != 0 && ! vector[i].ignore)\n+      {\n+\tif (combined == unstable)\n+\t  combined = vector[i].exp;\n+\telse\n+\t  combined = attr_rtx (code, vector[i].exp, combined);\n+      }\n+  if (common_term)\n+    return attr_rtx (other_code, common_term, combined);\n+  return combined;\n+}\n+\n+rtx\n+simplify_ands (exp1, exp2, exp3, insn_code, insn_index)\n+     rtx exp1, exp2, exp3;\n+     int insn_code, insn_index;\n+{\n+  return simplify_boolean (AND, exp1, exp2, exp3, false_rtx, true_rtx, \n+\t\t\t   insn_code, insn_index);\n+}\n+\n+rtx\n+simplify_iors (exp1, exp2, exp3, insn_code, insn_index)\n+     rtx exp1, exp2, exp3;\n+     int insn_code, insn_index;\n+{\n+  return simplify_boolean (IOR, exp1, exp2, exp3, true_rtx, false_rtx,\n+\t\t\t   insn_code, insn_index);\n+}\n+\f\n+#if 0\n+\n /* This routine is called when an AND of a term with a tree of AND's is\n    encountered.  If the term or its complement is present in the tree, it\n    can be replaced with TRUE or FALSE, respectively.\n@@ -2263,6 +2548,8 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \n   return exp;\n }\n+\n+#endif\n \f\n /* Given an expression, see if it can be simplified for a particular insn\n    code based on the values of other attributes being tested.  This can\n@@ -2303,176 +2590,39 @@ simplify_test_exp (exp, insn_code, insn_index)\n   switch (GET_CODE (exp))\n     {\n     case AND:\n-      left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n-      right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n-\n-      /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n-\t present on both sides, apply the distributive law since this will\n-\t yield simplifications.  */\n-      if ((GET_CODE (left) == IOR || GET_CODE (right) == IOR)\n-\t  && compute_alternative_mask (left, IOR)\n-\t  && compute_alternative_mask (right, IOR))\n+      exp = simplify_ands (XEXP (exp, 0), XEXP (exp, 1), 0,\n+\t\t\t   insn_code, insn_index);\n+      if (GET_CODE (exp) == AND)\n \t{\n-\t  if (GET_CODE (left) == IOR)\n+\t  left = XEXP (exp, 0);\n+\t  right = XEXP (exp, 1);\n+\n+\t  /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n+\t     present on both sides, apply the distributive law since this will\n+\t     yield simplifications.  */\n+\t  if ((GET_CODE (left) == IOR || GET_CODE (right) == IOR)\n+\t      && compute_alternative_mask (left, IOR)\n+\t      && compute_alternative_mask (right, IOR))\n \t    {\n-\t      rtx tem = left;\n-\t      left = right;\n-\t      right = tem;\n-\t    }\n-\n-\t  newexp = attr_rtx (IOR,\n-\t\t\t     attr_rtx (AND, left, XEXP (right, 0)),\n-\t\t\t     attr_rtx (AND, left, XEXP (right, 1)));\n-\n-\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n-\t}\n-\n-      /* Try with the term on both sides.  */\n-      right = simplify_and_tree (right, &left, insn_code, insn_index);\n-      if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n-\tleft = simplify_and_tree (left, &right, insn_code, insn_index);\n-\n-      if (left == false_rtx || right == false_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return false_rtx;\n-\t}\n-      else if (left == true_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n-\t}\n-      else if (right == true_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n-\t}\n+\t      if (GET_CODE (left) == IOR)\n+\t\t{\n+\t\t  rtx tem = left;\n+\t\t  left = right;\n+\t\t  right = tem;\n+\t\t}\n \n-      /* See if all or all but one of the insn's alternatives are specified\n-\t in this tree.  Optimize if so.  */\n-\n-      else if (insn_code >= 0\n-\t       && (GET_CODE (left) == AND\n-\t\t   || (GET_CODE (left) == NOT\n-\t\t       && GET_CODE (XEXP (left, 0)) == EQ_ATTR\n-\t\t       && XSTR (XEXP (left, 0), 0) == alternative_name)\n-\t\t   || GET_CODE (right) == AND\n-\t\t   || (GET_CODE (right) == NOT\n-\t\t       && GET_CODE (XEXP (right, 0)) == EQ_ATTR\n-\t\t       && XSTR (XEXP (right, 0), 0) == alternative_name)))\n-\t{\n-\t  i = compute_alternative_mask (exp, AND);\n-\t  if (i & ~insn_alternatives[insn_code])\n-\t    fatal (\"Illegal alternative specified for pattern number %d\",\n-\t\t   insn_index);\n-\n-\t  /* If all alternatives are excluded, this is false. */\n-\t  i ^= insn_alternatives[insn_code];\n-\t  if (i == 0)\n-\t    return false_rtx;\n-\t  else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n-\t    {\n-\t      /* If just one excluded, AND a comparison with that one to the\n-\t\t front of the tree.  The others will be eliminated by\n-\t\t optimization.  We do not want to do this if the insn has one\n-\t\t alternative and we have tested none of them!  */\n-\t      left = make_alternative_compare (i);\n-\t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n-\t      newexp = attr_rtx (AND, left, right);\n+\t      newexp = attr_rtx (IOR,\n+\t\t\t\t attr_rtx (AND, left, XEXP (right, 0)),\n+\t\t\t\t attr_rtx (AND, left, XEXP (right, 1)));\n \n \t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t    }\n \t}\n-\n-      if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n-\t{\n-\t  newexp = attr_rtx (AND, left, right);\n-\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n-\t}\n-      break;\n+      return exp;\n \n     case IOR:\n-      left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n-      right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n-\n-      right = simplify_or_tree (right, &left, insn_code, insn_index);\n-      if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n-\tleft = simplify_or_tree (left, &right, insn_code, insn_index);\n-\n-      if (right == true_rtx || left == true_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return true_rtx;\n-\t}\n-      else if (left == false_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n-\t}\n-      else if (right == false_rtx)\n-\t{\n-\t  obstack_free (rtl_obstack, spacer);\n-\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n-\t}\n-\n-      /* Test for simple cases where the distributive law is useful.  I.e.,\n-\t    convert (ior (and (x) (y))\n-\t\t\t (and (x) (z)))\n-\t    to      (and (x)\n-\t\t\t (ior (y) (z)))\n-       */\n-\n-      else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n-\t  && rtx_equal_p (XEXP (left, 0), XEXP (right, 0)))\n-\t{\n-\t  newexp = attr_rtx (IOR, XEXP (left, 1), XEXP (right, 1));\n-\n-\t  left = XEXP (left, 0);\n-\t  right = newexp;\n-\t  newexp = attr_rtx (AND, left, right);\n-\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n-\t}\n-\n-      /* See if all or all but one of the insn's alternatives are specified\n-\t in this tree.  Optimize if so.  */\n-\n-      else if (insn_code >= 0\n-\t  && (GET_CODE (left) == IOR\n-\t      || (GET_CODE (left) == EQ_ATTR\n-\t\t  && XSTR (left, 0) == alternative_name)\n-\t      || GET_CODE (right) == IOR\n-\t      || (GET_CODE (right) == EQ_ATTR\n-\t\t  && XSTR (right, 0) == alternative_name)))\n-\t{\n-\t  i = compute_alternative_mask (exp, IOR);\n-\t  if (i & ~insn_alternatives[insn_code])\n-\t    fatal (\"Illegal alternative specified for pattern number %d\",\n-\t\t   insn_index);\n-\n-\t  /* If all alternatives are included, this is true. */\n-\t  i ^= insn_alternatives[insn_code];\n-\t  if (i == 0)\n-\t    return true_rtx;\n-\t  else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n-\t    {\n-\t      /* If just one excluded, IOR a comparison with that one to the\n-\t\t front of the tree.  The others will be eliminated by\n-\t\t optimization.  We do not want to do this if the insn has one\n-\t\t alternative and we have tested none of them!  */\n-\t      left = make_alternative_compare (i);\n-\t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n-\t      newexp = attr_rtx (IOR, attr_rtx (NOT, left), right);\n-\n-\t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n-\t    }\n-\t}\n-\n-      if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n-\t{\n-\t  newexp = attr_rtx (IOR, left, right);\n-\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n-\t}\n-      break;\n+      return simplify_iors (XEXP (exp, 0), XEXP (exp, 1), 0,\n+\t\t\t    insn_code, insn_index);\n \n     case NOT:\n       if (GET_CODE (XEXP (exp, 0)) == NOT)\n@@ -3244,22 +3394,7 @@ eliminate_known_true (known_true, exp, insn_code, insn_index)\n {\n   rtx term;\n \n-  known_true = SIMPLIFY_TEST_EXP (known_true, insn_code, insn_index);\n-\n-  if (GET_CODE (known_true) == AND)\n-    {\n-      exp = eliminate_known_true (XEXP (known_true, 0), exp,\n-\t\t\t\t  insn_code, insn_index);\n-      exp = eliminate_known_true (XEXP (known_true, 1), exp,\n-\t\t\t\t  insn_code, insn_index);\n-    }\n-  else\n-    {\n-      term = known_true;\n-      exp = simplify_and_tree (exp, &term, insn_code, insn_index);\n-    }\n-\n-  return exp;\n+  return simplify_ands (exp, 0, known_true, insn_code, insn_index);\n }\n \f\n /* Write out a series of tests and assignment statements to perform tests and\n@@ -4014,6 +4149,7 @@ main (argc, argv)\n \n   obstack_init (rtl_obstack);\n   obstack_init (hash_obstack);\n+  obstack_init (accum_obstack);\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");"}]}