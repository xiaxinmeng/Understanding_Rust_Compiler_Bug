{"sha": "393b783549e1247dfed5b86f098fb10d1eaf6659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzYjc4MzU0OWUxMjQ3ZGZlZDViODZmMDk4ZmIxMGQxZWFmNjY1OQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-20T14:19:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-20T17:56:53Z"}, "message": "Reuse fold-const.c from GCC to enforce const array capacities\n\nRust allows for constant eval for cases like array capacity, the initial\nversion of this code forced the programmer to only use literals which was\nnot correct but got the type system off the ground.\n\nThis now takes advantage of the GCC backend object to offer 3 helpers.\n\n 1. check for constant Bexpression* are equal\n 2. extract a size_t constant value from the Bexpression*\n 3. to string the Bexpression constant\n\nWe can get away with the extraction of the value here because we know its\ngoing to be a usize for array capacity but some thought is needed if these\nmethods are to be reused in other cases.\n\nThere is a new ConstFold namespace which should be extensible for const\nfunctions later on and const generics.\n\nFixes: #296", "tree": {"sha": "628921f4b47bc83ab588fa3f7109ddfd7702bfd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/628921f4b47bc83ab588fa3f7109ddfd7702bfd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/393b783549e1247dfed5b86f098fb10d1eaf6659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393b783549e1247dfed5b86f098fb10d1eaf6659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393b783549e1247dfed5b86f098fb10d1eaf6659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393b783549e1247dfed5b86f098fb10d1eaf6659/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5afc03f94e8a76c1b1b9306849cd932d5d9090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee5afc03f94e8a76c1b1b9306849cd932d5d9090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee5afc03f94e8a76c1b1b9306849cd932d5d9090"}], "stats": {"total": 1091, "additions": 942, "deletions": 149}, "files": [{"sha": "9ba545733e6e78e5e84ed2dc7f9017b1f0c02240", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -79,7 +79,8 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n-\trust/rust-hir-liveness.o \\\n+    rust/rust-hir-const-fold.o \\\n+    rust/rust-hir-liveness.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "226cec6290c38739fde073e8bf8f8b077ce262af", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-compile-tyty.h\"\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-hir-const-fold-ctx.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -43,7 +44,8 @@ class Context\n   Context (::Backend *backend)\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n-      mappings (Analysis::Mappings::get ())\n+      mappings (Analysis::Mappings::get ()),\n+      const_ctx (ConstFold::Context::get ())\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -104,6 +106,7 @@ class Context\n   Resolver::Resolver *get_resolver () { return resolver; }\n   Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n   Analysis::Mappings *get_mappings () { return mappings; }\n+  ConstFold::Context *get_const_ctx () { return const_ctx; }\n \n   void push_block (Bblock *scope)\n   {\n@@ -260,6 +263,7 @@ class Context\n   Resolver::Resolver *resolver;\n   Resolver::TypeCheckContext *tyctx;\n   Analysis::Mappings *mappings;\n+  ConstFold::Context *const_ctx;\n \n   // state\n   std::vector<fncontext> fn_stack;\n@@ -420,16 +424,10 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &type) override\n   {\n-    mpz_t ival;\n-    mpz_init_set_ui (ival, type.get_capacity ());\n-\n-    Btype *capacity_type = ctx->get_backend ()->integer_type (true, 32);\n-    Bexpression *length\n-      = ctx->get_backend ()->integer_constant_expression (capacity_type, ival);\n-\n     Btype *element_type\n       = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n-    translated = ctx->get_backend ()->array_type (element_type, length);\n+    translated\n+      = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n   }\n \n   void visit (TyTy::BoolType &type) override"}, {"sha": "59ae815937f81b21f66428f6946f57d5075c97ad", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -275,7 +275,12 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *array_type = TyTyResolveCompile::compile (ctx, tyty);\n+    rust_assert (tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+    TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n+    capacity_expr = array_tyty->get_capacity ();\n+\n+    Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+    rust_assert (array_type != nullptr);\n \n     expr.get_internal_elements ()->accept_vis (*this);\n     std::vector<unsigned long> indexes;\n@@ -302,7 +307,11 @@ class CompileExpr : public HIRCompileBase\n     Bexpression *translated_expr\n       = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n \n-    for (size_t i = 0; i < elems.get_num_elements (); ++i)\n+    size_t capacity;\n+    bool ok = ctx->get_backend ()->const_size_cast (capacity_expr, &capacity);\n+    rust_assert (ok);\n+\n+    for (size_t i = 0; i < capacity; ++i)\n       constructor.push_back (translated_expr);\n   }\n \n@@ -786,9 +795,12 @@ class CompileExpr : public HIRCompileBase\n   }\n \n private:\n-  CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+  CompileExpr (Context *ctx)\n+    : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n+  {}\n \n   Bexpression *translated;\n+  Bexpression *capacity_expr;\n   std::vector<Bexpression *> constructor;\n };\n "}, {"sha": "33fc45bc2e59c6044b8ed0a651a4694725ce3279", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -27,42 +27,6 @@\n namespace Rust {\n namespace HIR {\n \n-class ArrayCapacityConstant : public ASTLoweringBase\n-{\n-  using Rust::HIR::ASTLoweringBase::visit;\n-\n-public:\n-  static bool fold (AST::Expr *expr, size_t *folded_result)\n-  {\n-    ArrayCapacityConstant folder;\n-    expr->accept_vis (folder);\n-    *folded_result = folder.result;\n-    return folder.ok;\n-  }\n-\n-  void visit (AST::LiteralExpr &expr) override\n-  {\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase AST::Literal::LitType::INT: {\n-\t  ok = true;\n-\t  std::stringstream ss (expr.as_string ());\n-\t  ss >> result;\n-\t}\n-\tbreak;\n-\n-      default:\n-\treturn;\n-      }\n-  }\n-\n-private:\n-  ArrayCapacityConstant () : ok (false), result (-1) {}\n-\n-  bool ok;\n-  size_t result;\n-}; // namespace Resolver\n-\n class ASTLowerPathInExpression : public ASTLoweringBase\n {\n   using Rust::HIR::ASTLoweringBase::visit;\n@@ -332,18 +296,9 @@ class ASTLoweringExpr : public ASTLoweringBase\n     HIR::Expr *num_copies\n       = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n \n-    size_t folded;\n-    if (!ArrayCapacityConstant::fold (elems.get_num_copies ().get (), &folded))\n-      {\n-\trust_fatal_error (elems.get_num_copies ()->get_locus_slow (),\n-\t\t\t  \"failed to fold capacity constant\");\n-\treturn;\n-      }\n-\n     translated_array_elems\n       = new HIR::ArrayElemsCopied (std::unique_ptr<HIR::Expr> (element),\n-\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies),\n-\t\t\t\t   folded);\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies));\n   }\n \n   void visit (AST::LiteralExpr &expr) override"}, {"sha": "100c527ca7ce3eb2c8edd17c57734e8a36425326", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -825,8 +825,6 @@ class ArrayElems\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n-  virtual size_t get_num_elements () const = 0;\n-\n protected:\n   // pure virtual clone implementation\n   virtual ArrayElems *clone_array_elems_impl () const = 0;\n@@ -870,7 +868,7 @@ class ArrayElemsValues : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  size_t get_num_elements () const override { return values.size (); }\n+  size_t get_num_elements () const { return values.size (); }\n \n   void iterate (std::function<bool (Expr *)> cb)\n   {\n@@ -893,33 +891,26 @@ class ArrayElemsCopied : public ArrayElems\n {\n   std::unique_ptr<Expr> elem_to_copy;\n   std::unique_ptr<Expr> num_copies;\n-  size_t folded_copy_amount;\n-\n-  // TODO: should this store location data?\n \n public:\n   // Constructor requires pointers for polymorphism\n   ArrayElemsCopied (std::unique_ptr<Expr> copied_elem,\n-\t\t    std::unique_ptr<Expr> copy_amount,\n-\t\t    size_t folded_copy_amount)\n+\t\t    std::unique_ptr<Expr> copy_amount)\n     : elem_to_copy (std::move (copied_elem)),\n-      num_copies (std::move (copy_amount)),\n-      folded_copy_amount (folded_copy_amount)\n+      num_copies (std::move (copy_amount))\n   {}\n \n   // Copy constructor required due to unique_ptr - uses custom clone\n   ArrayElemsCopied (ArrayElemsCopied const &other)\n     : elem_to_copy (other.elem_to_copy->clone_expr ()),\n-      num_copies (other.num_copies->clone_expr ()),\n-      folded_copy_amount (other.folded_copy_amount)\n+      num_copies (other.num_copies->clone_expr ())\n   {}\n \n   // Overloaded assignment operator for deep copying\n   ArrayElemsCopied &operator= (ArrayElemsCopied const &other)\n   {\n     elem_to_copy = other.elem_to_copy->clone_expr ();\n     num_copies = other.num_copies->clone_expr ();\n-    folded_copy_amount = other.folded_copy_amount;\n \n     return *this;\n   }\n@@ -932,10 +923,10 @@ class ArrayElemsCopied : public ArrayElems\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  size_t get_num_elements () const override { return folded_copy_amount; }\n-\n   Expr *get_elem_to_copy () { return elem_to_copy.get (); }\n \n+  Expr *get_num_copies_expr () { return num_copies.get (); }\n+\n protected:\n   ArrayElemsCopied *clone_array_elems_impl () const override\n   {"}, {"sha": "b999c41b10189a39dbd3e47b585ce24c6fc0dbcc", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -217,10 +217,7 @@ class ResolveType : public ResolverBase\n       }\n   }\n \n-  void visit (AST::ArrayType &type) override\n-  {\n-    type.get_elem_type ()->accept_vis (*this);\n-  }\n+  void visit (AST::ArrayType &type) override;\n \n   void visit (AST::ReferenceType &type) override\n   {"}, {"sha": "41c6938ea6132af44982aac2902ea29618f0f389", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -589,5 +589,14 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     }\n }\n \n+// rust-ast-resolve-type.h\n+\n+void\n+ResolveType::visit (AST::ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e71d81ed1cca54f1e9594787a9eda4423df26881", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -93,6 +93,11 @@ class Backend\n   virtual void debug (Bvariable *) = 0;\n   virtual void debug (Blabel *) = 0;\n \n+  // const folder helpers\n+  virtual bool const_size_cast (Bexpression *, size_t *) = 0;\n+  virtual std::string const_size_val_to_string (Bexpression *) = 0;\n+  virtual bool const_values_equal (Bexpression *, Bexpression *) = 0;\n+\n   // Types.\n \n   // Produce an error type.  Actually the backend could probably just\n@@ -283,6 +288,9 @@ class Backend\n   // going without crashing.\n   virtual Bexpression *error_expression () = 0;\n \n+  // return whether this is error_mark_node\n+  virtual bool is_error_expression (Bexpression *) = 0;\n+\n   // Create a nil pointer expression.\n   virtual Bexpression *nil_pointer_expression () = 0;\n "}, {"sha": "ed89c94ebee282588583c1088d6b9618e67aa4a6", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -167,7 +167,6 @@ class Gcc_backend : public Backend\n   void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n \n   // Types.\n-\n   Btype *error_type () { return this->make_type (error_mark_node); }\n \n   Btype *void_type () { return this->make_type (void_type_node); }\n@@ -176,6 +175,46 @@ class Gcc_backend : public Backend\n \n   Btype *char_type () { return this->make_type (char_type_node); }\n \n+  bool const_size_cast (Bexpression *expr, size_t *result)\n+  {\n+    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+\n+    unsigned char buf[sizeof (size_t) + 1];\n+    memset (buf, 0, sizeof (buf));\n+\n+    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    if (ret <= 0)\n+      return false;\n+\n+    size_t *tmp = (size_t *) buf;\n+    *result = *tmp;\n+    return true;\n+  }\n+\n+  std::string const_size_val_to_string (Bexpression *expr)\n+  {\n+    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+\n+    unsigned char buf[sizeof (size_t) + 1];\n+    memset (buf, 0, sizeof (buf));\n+\n+    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    rust_assert (ret > 0);\n+\n+    size_t *ptr = (size_t *) buf;\n+    return std::to_string (*ptr);\n+  }\n+\n+  bool const_values_equal (Bexpression *a, Bexpression *b)\n+  {\n+    return operand_equal_p (a->get_tree (), b->get_tree (),\n+\t\t\t    OEP_ONLY_CONST | OEP_PURE_SAME);\n+    // printf (\"comparing!\\n\");\n+    // debug_tree (a->get_tree ());\n+    // debug_tree (b->get_tree ());\n+    // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n+  }\n+\n   Btype *wchar_type ()\n   {\n     // i think this is meant to be 32 bit from\n@@ -250,6 +289,11 @@ class Gcc_backend : public Backend\n     return this->make_expression (error_mark_node);\n   }\n \n+  bool is_error_expression (Bexpression *expr)\n+  {\n+    return expr->get_tree () == error_mark_node;\n+  }\n+\n   Bexpression *nil_pointer_expression ()\n   {\n     return this->make_expression (null_pointer_node);"}, {"sha": "da788b563d54a3fc2f4898b6a4ec69a8fef98840", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -52,6 +52,7 @@\n #include \"rust-hir-scan-deadcode.h\"\n #include \"rust-tycheck-dump.h\"\n #include \"rust-ast-resolve-unused.h\"\n+#include \"rust-hir-const-fold.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -325,6 +326,9 @@ Session::init ()\n \n   // setup backend to GCC GIMPLE\n   backend = rust_get_backend ();\n+\n+  // the constant folder uses gcc\n+  ConstFold::Context::init (backend);\n }\n \n /* Initialise default options. Actually called before handle_option, unlike init"}, {"sha": "bcb59ef23c8f340f118b8c47bdb629a8249b31d6", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,235 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_BASE_H\n+#define RUST_HIR_CONST_FOLD_BASE_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-const-fold-ctx.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+// base class to allow derivatives to overload as needed\n+class ConstFoldBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~ConstFoldBase () {}\n+\n+  virtual void visit (HIR::Token &) override {}\n+  virtual void visit (HIR::DelimTokenTree &) override {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n+  virtual void visit (HIR::IdentifierExpr &) override {}\n+  virtual void visit (HIR::Lifetime &) override {}\n+  virtual void visit (HIR::LifetimeParam &) override {}\n+  virtual void visit (HIR::PathInExpression &) override {}\n+  virtual void visit (HIR::TypePathSegment &) override {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &) override {}\n+  virtual void visit (HIR::TypePathSegmentFunction &) override {}\n+  virtual void visit (HIR::TypePath &) override {}\n+  virtual void visit (HIR::QualifiedPathInExpression &) override {}\n+  virtual void visit (HIR::QualifiedPathInType &) override {}\n+\n+  virtual void visit (HIR::LiteralExpr &) override {}\n+  virtual void visit (HIR::AttrInputLiteral &) override {}\n+  virtual void visit (HIR::MetaItemLitExpr &) override {}\n+  virtual void visit (HIR::MetaItemPathLit &) override {}\n+  virtual void visit (HIR::BorrowExpr &) override {}\n+  virtual void visit (HIR::DereferenceExpr &) override {}\n+  virtual void visit (HIR::ErrorPropagationExpr &) override {}\n+  virtual void visit (HIR::NegationExpr &) override {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (HIR::ComparisonExpr &) override {}\n+  virtual void visit (HIR::LazyBooleanExpr &) override {}\n+  virtual void visit (HIR::TypeCastExpr &) override {}\n+  virtual void visit (HIR::AssignmentExpr &) override {}\n+\n+  virtual void visit (HIR::GroupedExpr &) override {}\n+\n+  virtual void visit (HIR::ArrayElemsValues &) override {}\n+  virtual void visit (HIR::ArrayElemsCopied &) override {}\n+  virtual void visit (HIR::ArrayExpr &) override {}\n+  virtual void visit (HIR::ArrayIndexExpr &) override {}\n+  virtual void visit (HIR::TupleExpr &) override {}\n+  virtual void visit (HIR::TupleIndexExpr &) override {}\n+  virtual void visit (HIR::StructExprStruct &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::StructExprStructFields &) override {}\n+  virtual void visit (HIR::StructExprStructBase &) override {}\n+  virtual void visit (HIR::StructExprTuple &) override {}\n+  virtual void visit (HIR::StructExprUnit &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::EnumExprStruct &) override {}\n+  virtual void visit (HIR::EnumExprTuple &) override {}\n+  virtual void visit (HIR::EnumExprFieldless &) override {}\n+  virtual void visit (HIR::CallExpr &) override {}\n+  virtual void visit (HIR::MethodCallExpr &) override {}\n+  virtual void visit (HIR::FieldAccessExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInner &) override {}\n+  virtual void visit (HIR::BlockExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &) override {}\n+  virtual void visit (HIR::ContinueExpr &) override {}\n+  virtual void visit (HIR::BreakExpr &) override {}\n+  virtual void visit (HIR::RangeFromToExpr &) override {}\n+  virtual void visit (HIR::RangeFromExpr &) override {}\n+  virtual void visit (HIR::RangeToExpr &) override {}\n+  virtual void visit (HIR::RangeFullExpr &) override {}\n+  virtual void visit (HIR::RangeFromToInclExpr &) override {}\n+  virtual void visit (HIR::RangeToInclExpr &) override {}\n+  virtual void visit (HIR::ReturnExpr &) override {}\n+  virtual void visit (HIR::UnsafeBlockExpr &) override {}\n+  virtual void visit (HIR::LoopExpr &) override {}\n+  virtual void visit (HIR::WhileLoopExpr &) override {}\n+  virtual void visit (HIR::WhileLetLoopExpr &) override {}\n+  virtual void visit (HIR::ForLoopExpr &) override {}\n+  virtual void visit (HIR::IfExpr &) override {}\n+  virtual void visit (HIR::IfExprConseqElse &) override {}\n+  virtual void visit (HIR::IfExprConseqIf &) override {}\n+  virtual void visit (HIR::IfExprConseqIfLet &) override {}\n+  virtual void visit (HIR::IfLetExpr &) override {}\n+  virtual void visit (HIR::IfLetExprConseqElse &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIf &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (HIR::MatchExpr &) override {}\n+  virtual void visit (HIR::AwaitExpr &) override {}\n+  virtual void visit (HIR::AsyncBlockExpr &) override {}\n+\n+  virtual void visit (HIR::TypeParam &) override {}\n+\n+  virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (HIR::Method &) override {}\n+  virtual void visit (HIR::ModuleBodied &) override {}\n+  virtual void visit (HIR::ModuleNoBody &) override {}\n+  virtual void visit (HIR::ExternCrate &) override {}\n+\n+  virtual void visit (HIR::UseTreeGlob &) override {}\n+  virtual void visit (HIR::UseTreeList &) override {}\n+  virtual void visit (HIR::UseTreeRebind &) override {}\n+  virtual void visit (HIR::UseDeclaration &) override {}\n+  virtual void visit (HIR::Function &) override {}\n+  virtual void visit (HIR::TypeAlias &) override {}\n+  virtual void visit (HIR::StructStruct &) override {}\n+  virtual void visit (HIR::TupleStruct &) override {}\n+  virtual void visit (HIR::EnumItem &) override {}\n+  virtual void visit (HIR::EnumItemTuple &) override {}\n+  virtual void visit (HIR::EnumItemStruct &) override {}\n+  virtual void visit (HIR::EnumItemDiscriminant &) override {}\n+  virtual void visit (HIR::Enum &) override {}\n+  virtual void visit (HIR::Union &) override {}\n+  virtual void visit (HIR::ConstantItem &) override {}\n+  virtual void visit (HIR::StaticItem &) override {}\n+  virtual void visit (HIR::TraitItemFunc &) override {}\n+  virtual void visit (HIR::TraitItemMethod &) override {}\n+  virtual void visit (HIR::TraitItemConst &) override {}\n+  virtual void visit (HIR::TraitItemType &) override {}\n+  virtual void visit (HIR::Trait &) override {}\n+  virtual void visit (HIR::InherentImpl &) override {}\n+  virtual void visit (HIR::TraitImpl &) override {}\n+\n+  virtual void visit (HIR::ExternalStaticItem &) override {}\n+  virtual void visit (HIR::ExternalFunctionItem &) override {}\n+  virtual void visit (HIR::ExternBlock &) override {}\n+\n+  virtual void visit (HIR::MacroMatchFragment &) override {}\n+  virtual void visit (HIR::MacroMatchRepetition &) override {}\n+  virtual void visit (HIR::MacroMatcher &) override {}\n+  virtual void visit (HIR::MacroRulesDefinition &) override {}\n+  virtual void visit (HIR::MacroInvocation &) override {}\n+  virtual void visit (HIR::MetaItemPath &) override {}\n+  virtual void visit (HIR::MetaItemSeq &) override {}\n+  virtual void visit (HIR::MetaWord &) override {}\n+  virtual void visit (HIR::MetaNameValueStr &) override {}\n+  virtual void visit (HIR::MetaListPaths &) override {}\n+  virtual void visit (HIR::MetaListNameValueStr &) override {}\n+\n+  virtual void visit (HIR::LiteralPattern &) override {}\n+  virtual void visit (HIR::IdentifierPattern &) override {}\n+  virtual void visit (HIR::WildcardPattern &) override {}\n+\n+  virtual void visit (HIR::RangePatternBoundLiteral &) override {}\n+  virtual void visit (HIR::RangePatternBoundPath &) override {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &) override {}\n+  virtual void visit (HIR::RangePattern &) override {}\n+  virtual void visit (HIR::ReferencePattern &) override {}\n+\n+  virtual void visit (HIR::StructPatternFieldTuplePat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdent &) override {}\n+  virtual void visit (HIR::StructPattern &) override {}\n+\n+  virtual void visit (HIR::TupleStructItemsNoRange &) override {}\n+  virtual void visit (HIR::TupleStructItemsRange &) override {}\n+  virtual void visit (HIR::TupleStructPattern &) override {}\n+\n+  virtual void visit (HIR::TuplePatternItemsMultiple &) override {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &) override {}\n+  virtual void visit (HIR::TuplePattern &) override {}\n+  virtual void visit (HIR::GroupedPattern &) override {}\n+  virtual void visit (HIR::SlicePattern &) override {}\n+\n+  virtual void visit (HIR::EmptyStmt &) override {}\n+  virtual void visit (HIR::LetStmt &) override {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  virtual void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (HIR::TraitBound &) override {}\n+  virtual void visit (HIR::ImplTraitType &) override {}\n+  virtual void visit (HIR::TraitObjectType &) override {}\n+  virtual void visit (HIR::ParenthesisedType &) override {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n+  virtual void visit (HIR::TupleType &) override {}\n+  virtual void visit (HIR::NeverType &) override {}\n+  virtual void visit (HIR::RawPointerType &) override {}\n+  virtual void visit (HIR::ReferenceType &) override {}\n+  virtual void visit (HIR::ArrayType &) override {}\n+  virtual void visit (HIR::SliceType &) override {}\n+  virtual void visit (HIR::InferredType &) override {}\n+  virtual void visit (HIR::BareFunctionType &) override {}\n+\n+protected:\n+  ConstFoldBase ()\n+    : mappings (Analysis::Mappings::get ()),\n+      resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()), ctx (Context::get ())\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Context *ctx;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_BASE_H"}, {"sha": "7ec296c66c37d5bde8d793c7e875cf8458bbd79b", "filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_CTX_H\n+#define RUST_HIR_CONST_FOLD_CTX_H\n+\n+#include \"rust-backend.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+class Context\n+{\n+public:\n+  ~Context () {}\n+\n+  static void init (::Backend *backend);\n+\n+  static Context *get ();\n+\n+  ::Backend *get_backend () { return backend; }\n+\n+  bool lookup_const (HirId id, Bexpression **expr);\n+\n+  void insert_const (HirId, Bexpression *expr);\n+\n+private:\n+  Context (::Backend *backend);\n+\n+  ::Backend *backend;\n+  std::map<HirId, Bexpression *> ctx;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_CTX_H"}, {"sha": "ecad200e518aadb98ff48d9841e29e7f884295c9", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-const-fold-ctx.h\"\n+#include \"rust-hir-const-fold.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+static Context *context = nullptr;\n+\n+Context::Context (::Backend *backend) : backend (backend) {}\n+\n+void\n+Context::init (::Backend *backend)\n+{\n+  rust_assert (context == nullptr);\n+  context = new Context (backend);\n+}\n+\n+Context *\n+Context::get ()\n+{\n+  rust_assert (context != nullptr);\n+  return context;\n+}\n+\n+bool\n+Context::lookup_const (HirId id, Bexpression **expr)\n+{\n+  auto it = ctx.find (id);\n+  if (it == ctx.end ())\n+    return false;\n+\n+  *expr = it->second;\n+  return true;\n+}\n+\n+void\n+Context::insert_const (HirId id, Bexpression *expr)\n+{\n+  rust_assert (ctx.find (id) == ctx.end ());\n+  ctx[id] = expr;\n+}\n+\n+// rust-hir-const-fold.h\n+\n+void\n+ConstFoldItem::visit (HIR::ConstantItem &item)\n+{\n+  auto folded_expr = ConstFoldExpr::fold (item.get_expr ());\n+  if (folded_expr == nullptr)\n+    return;\n+\n+  folded = folded_expr;\n+}\n+\n+} // namespace ConstFold\n+} // namespace Rust"}, {"sha": "f6cd6eac761048578b9255331f1107e8be1165d9", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,364 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_CONST_FOLD_H\n+#define RUST_HIR_CONST_FOLD_H\n+\n+#include \"rust-hir-const-fold-base.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace ConstFold {\n+\n+class ConstFoldType : public TyTy::TyVisitor\n+{\n+public:\n+  static Btype *fold (TyTy::BaseType *type, ::Backend *backend)\n+  {\n+    ConstFoldType folder (backend);\n+    type->accept_vis (folder);\n+    return folder.translated;\n+  };\n+\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::FnType &) override { gcc_unreachable (); }\n+\n+  void visit (TyTy::TupleType &type) override\n+  {\n+    if (type.num_fields () == 0)\n+      translated = backend->void_type ();\n+    else\n+      gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::BoolType &) override\n+  {\n+    translated = backend->named_type (\"bool\", backend->bool_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::IntType &type) override\n+  {\n+    switch (type.get_int_kind ())\n+      {\n+      case TyTy::IntType::I8:\n+\ttranslated\n+\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I64:\n+\ttranslated\n+\t  = backend->named_type (\"i64\", backend->integer_type (false, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I128:\n+\ttranslated\n+\t  = backend->named_type (\"i128\", backend->integer_type (false, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UintType &type) override\n+  {\n+    switch (type.get_uint_kind ())\n+      {\n+      case TyTy::UintType::U8:\n+\ttranslated = backend->named_type (\"u8\", backend->integer_type (true, 8),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U16:\n+\ttranslated\n+\t  = backend->named_type (\"u16\", backend->integer_type (true, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U32:\n+\ttranslated\n+\t  = backend->named_type (\"u32\", backend->integer_type (true, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U64:\n+\ttranslated\n+\t  = backend->named_type (\"u64\", backend->integer_type (true, 64),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U128:\n+\ttranslated\n+\t  = backend->named_type (\"u128\", backend->integer_type (true, 128),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::FloatType &type) override\n+  {\n+    switch (type.get_float_kind ())\n+      {\n+      case TyTy::FloatType::F32:\n+\ttranslated = backend->named_type (\"f32\", backend->float_type (32),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::FloatType::F64:\n+\ttranslated = backend->named_type (\"f64\", backend->float_type (64),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::USizeType &) override\n+  {\n+    translated = backend->named_type (\n+      \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::ISizeType &) override\n+  {\n+    translated = backend->named_type (\n+      \"isize\", backend->integer_type (false, backend->get_pointer_size ()),\n+      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::CharType &) override\n+  {\n+    translated = backend->named_type (\"char\", backend->wchar_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::StrType &) override\n+  {\n+    Btype *raw_str = backend->raw_str_type ();\n+    translated\n+      = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n+  }\n+\n+private:\n+  ConstFoldType (::Backend *backend)\n+    : backend (backend), translated (backend->error_type ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Btype *translated;\n+};\n+\n+class ConstFoldItem : public ConstFoldBase\n+{\n+  using ConstFoldBase::visit;\n+\n+public:\n+  static Bexpression *fold (HIR::Item &item)\n+  {\n+    ConstFoldItem folder;\n+    item.accept_vis (folder);\n+    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n+      {\n+\trust_error_at (item.get_locus_slow (), \"non const value\");\n+\treturn nullptr;\n+      }\n+\n+    folder.ctx->insert_const (item.get_mappings ().get_hirid (), folder.folded);\n+    return folder.folded;\n+  };\n+\n+  void visit (HIR::ConstantItem &item) override;\n+\n+private:\n+  ConstFoldItem ()\n+    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  Bexpression *folded;\n+};\n+\n+class ConstFoldExpr : public ConstFoldBase\n+{\n+  using ConstFoldBase::visit;\n+\n+public:\n+  static Bexpression *fold (HIR::Expr *expr)\n+  {\n+    ConstFoldExpr folder;\n+    expr->accept_vis (folder);\n+    if (folder.ctx->get_backend ()->is_error_expression (folder.folded))\n+      {\n+\trust_error_at (expr->get_locus_slow (), \"non const value\");\n+\treturn nullptr;\n+      }\n+\n+    folder.ctx->insert_const (expr->get_mappings ().get_hirid (),\n+\t\t\t      folder.folded);\n+    return folder.folded;\n+  };\n+\n+  void visit (HIR::IdentifierExpr &expr) override\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tResolver::Definition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // lookup constant\n+    ctx->lookup_const (ref, &folded);\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr) override\n+  {\n+    auto literal_value = expr.get_literal ();\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::INT: {\n+\t  mpz_t ival;\n+\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n+\t      != 0)\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n+\t      return;\n+\t    }\n+\n+\t  TyTy::BaseType *tyty = nullptr;\n+\t  if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this literal expr\");\n+\t      return;\n+\t    }\n+\n+\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  folded\n+\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n+\t}\n+\treturn;\n+\n+\t/* handle other literals */\n+\n+      default:\n+\tgcc_unreachable ();\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n+  {\n+    auto lhs = ConstFoldExpr::fold (expr.get_lhs ());\n+    if (lhs == nullptr)\n+      return;\n+\n+    auto rhs = ConstFoldExpr::fold (expr.get_rhs ());\n+    if (rhs == nullptr)\n+      return;\n+\n+    auto op = expr.get_expr_type ();\n+    auto location = expr.get_locus ();\n+\n+    folded\n+      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t       location);\n+  }\n+\n+  void visit (HIR::NegationExpr &expr) override\n+  {\n+    auto negated_expr = ConstFoldExpr::fold (expr.get_expr ());\n+    if (negated_expr == nullptr)\n+      return;\n+\n+    auto op = expr.get_expr_type ();\n+    auto location = expr.get_locus ();\n+\n+    folded\n+      = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n+  }\n+\n+private:\n+  ConstFoldExpr ()\n+    : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n+  {}\n+\n+  Bexpression *folded;\n+};\n+\n+} // namespace ConstFold\n+} // namespace Rust\n+\n+#endif // RUST_HIR_CONST_FOLD_H"}, {"sha": "787b37dfec78c5ef246038dc688e3dd2c9a31824", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-hir-method-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-const-fold.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -676,21 +677,23 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::ArrayType *array_type = (TyTy::ArrayType *) infered;\n+    TyTy::ArrayType *array_type = static_cast<TyTy::ArrayType *> (infered);\n     infered = array_type->get_element_type ()->clone ();\n   }\n \n   void visit (HIR::ArrayExpr &expr) override\n   {\n     HIR::ArrayElems *elements = expr.get_internal_elements ();\n-    size_t num_elems = elements->get_num_elements ();\n \n-    // Check the type of array elements\n     elements->accept_vis (*this);\n-    rust_assert (infered_array_elems != nullptr);\n+    if (infered_array_elems == nullptr)\n+      return;\n+    if (folded_array_capacity == nullptr)\n+      return;\n \n     infered\n-      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (), num_elems,\n+      = new TyTy::ArrayType (expr.get_mappings ().get_hirid (),\n+\t\t\t     folded_array_capacity,\n \t\t\t     TyTy::TyVar (infered_array_elems->get_ref ()));\n   }\n \n@@ -712,10 +715,40 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tinfered_array_elems->append_reference (elem->get_ref ());\n       }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    std::string capacity_str = std::to_string (elems.get_num_elements ());\n+    HIR::LiteralExpr implicit_literal_capacity (\n+      mapping, capacity_str, HIR::Literal::LitType::INT,\n+      PrimitiveCoreType::CORETYPE_USIZE, Location ());\n+\n+    // mark the type for this implicit node\n+    context->insert_type (mapping, new TyTy::USizeType (mapping.get_hirid ()));\n+\n+    folded_array_capacity\n+      = ConstFold::ConstFoldExpr::fold (&implicit_literal_capacity);\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n   {\n+    auto capacity_type\n+      = TypeCheckExpr::Resolve (elems.get_num_copies_expr (), false);\n+\n+    TyTy::USizeType *expected_ty = new TyTy::USizeType (\n+      elems.get_num_copies_expr ()->get_mappings ().get_hirid ());\n+    context->insert_type (elems.get_num_copies_expr ()->get_mappings (),\n+\t\t\t  expected_ty);\n+\n+    auto unified = expected_ty->unify (capacity_type);\n+    if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    folded_array_capacity\n+      = ConstFold::ConstFoldExpr::fold (elems.get_num_copies_expr ());\n+\n     infered_array_elems\n       = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n   }\n@@ -973,7 +1006,7 @@ class TypeCheckExpr : public TypeCheckBase\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n-      inside_loop (inside_loop)\n+      folded_array_capacity (nullptr), inside_loop (inside_loop)\n   {}\n \n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n@@ -1057,6 +1090,8 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n \t       || (type->get_kind () == TyTy::TypeKind::FLOAT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL))\n@@ -1070,6 +1105,8 @@ class TypeCheckExpr : public TypeCheckBase\n       case ArithmeticOrLogicalOperator::BITWISE_XOR:\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::BOOL)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n@@ -1080,6 +1117,8 @@ class TypeCheckExpr : public TypeCheckBase\n       case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n \treturn (type->get_kind () == TyTy::TypeKind::INT)\n \t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::USIZE)\n+\t       || (type->get_kind () == TyTy::TypeKind::ISIZE)\n \t       || (type->get_kind () == TyTy::TypeKind::INFER\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL));\n@@ -1093,6 +1132,7 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n+  Bexpression *folded_array_capacity;\n \n   bool inside_loop;\n }; // namespace Resolver"}, {"sha": "7426a7531a16a18bcdf060e376f08bbd00e455ab", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -48,6 +48,9 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+\n+    // notify the constant folder of this\n+    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "d1d5681fb17a7b481eb5b45aaf9d479cb3c9a994", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -140,6 +140,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n       = TypeCheckExpr::Resolve (constant.get_expr (), false);\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n+\n+    // notify the constant folder of this\n+    ConstFold::ConstFoldItem::fold (constant);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "74e3ed3e126eed9cb13bccacab0ba22194ee5071", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -26,45 +26,6 @@\n namespace Rust {\n namespace Resolver {\n \n-class ArrayCapacityConstant : public TypeCheckBase\n-{\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n-public:\n-  static bool fold (HIR::Expr *expr, size_t *folded_result)\n-  {\n-    ArrayCapacityConstant folder;\n-    expr->accept_vis (folder);\n-    *folded_result = folder.result;\n-    return folder.ok;\n-  }\n-\n-  virtual ~ArrayCapacityConstant () {}\n-\n-  void visit (HIR::LiteralExpr &expr) override\n-  {\n-    auto literal_value = expr.get_literal ();\n-    switch (expr.get_lit_type ())\n-      {\n-\tcase HIR::Literal::LitType::INT: {\n-\t  ok = true;\n-\t  std::stringstream ss (literal_value->as_string ());\n-\t  ss >> result;\n-\t}\n-\tbreak;\n-\n-      default:\n-\treturn;\n-      }\n-  }\n-\n-private:\n-  ArrayCapacityConstant () : TypeCheckBase (), ok (false), result (-1) {}\n-\n-  bool ok;\n-  size_t result;\n-}; // namespace Resolver\n-\n class TypeCheckResolveGenericArguments : public TypeCheckBase\n {\n   using Rust::Resolver::TypeCheckBase::visit;\n@@ -218,20 +179,7 @@ class TypeCheckType : public TypeCheckBase\n       }\n   }\n \n-  void visit (HIR::ArrayType &type) override\n-  {\n-    size_t capacity;\n-    if (!ArrayCapacityConstant::fold (type.get_size_expr (), &capacity))\n-      {\n-\trust_error_at (type.get_size_expr ()->get_locus_slow (),\n-\t\t       \"non-constant value\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n-    translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (),\n-\t\t\t\t      capacity, TyTy::TyVar (base->get_ref ()));\n-  }\n+  void visit (HIR::ArrayType &type) override;\n \n   void visit (HIR::ReferenceType &type) override\n   {"}, {"sha": "8f635bcd3b30aa5c7bab359e0991ac95a87f5740", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-inherent-impl-overlap.h\"\n+#include \"rust-hir-const-fold.h\"\n \n extern bool\n saw_errors (void);\n@@ -392,5 +393,31 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n     }\n }\n \n+// rust-hir-type-check-type.h\n+\n+void\n+TypeCheckType::visit (HIR::ArrayType &type)\n+{\n+  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr (), false);\n+  if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  TyTy::USizeType *expected_ty\n+    = new TyTy::USizeType (type.get_size_expr ()->get_mappings ().get_hirid ());\n+  context->insert_type (type.get_size_expr ()->get_mappings (), expected_ty);\n+\n+  auto unified = expected_ty->unify (capacity_type);\n+  if (unified->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  auto capacity = ConstFold::ConstFoldExpr::fold (type.get_size_expr ());\n+  if (capacity == nullptr)\n+    return;\n+\n+  TyTy::BaseType *base = TypeCheckType::Resolve (type.get_element_type ());\n+  translated = new TyTy::ArrayType (type.get_mappings ().get_hirid (), capacity,\n+\t\t\t\t    TyTy::TyVar (base->get_ref ()));\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "c5d2ced9181d2bed82aa1d20ad753fd136c95877", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -25,6 +25,9 @@\n #include \"rust-hir-map.h\"\n #include \"rust-hir-type-check.h\"\n \n+extern ::Backend *\n+rust_get_backend ();\n+\n namespace Rust {\n namespace TyTy {\n \n@@ -706,11 +709,12 @@ class ArrayRules : public BaseRules\n \treturn;\n       }\n \n+    auto backend = rust_get_backend ();\n+\n     // need to check the base types and capacity\n-    if (type.get_capacity () != base->get_capacity ())\n+    if (!backend->const_values_equal (type.get_capacity (),\n+\t\t\t\t      base->get_capacity ()))\n       {\n-\tLocation locus = mappings->lookup_location (type.get_ref ());\n-\trust_error_at (locus, \"mismatch in array capacity\");\n \tBaseRules::visit (type);\n \treturn;\n       }"}, {"sha": "88743cb32b2515973494dc5abb89d95e5eb5d82b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -26,6 +26,9 @@\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n+extern ::Backend *\n+rust_get_backend ();\n+\n namespace Rust {\n namespace TyTy {\n \n@@ -801,8 +804,14 @@ ArrayType::accept_vis (TyVisitor &vis)\n std::string\n ArrayType::as_string () const\n {\n-  return \"[\" + get_element_type ()->as_string () + \":\"\n-\t + std::to_string (capacity) + \"]\";\n+  return \"[\" + get_element_type ()->as_string () + \":\" + capacity_string ()\n+\t + \"]\";\n+}\n+\n+std::string\n+ArrayType::capacity_string () const\n+{\n+  return rust_get_backend ()->const_size_val_to_string (get_capacity ());\n }\n \n BaseType *"}, {"sha": "e139bfdf4336c9130f524e32ea6b4a52eec44348", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_TYTY\n #define RUST_TYTY\n \n+#include \"rust-backend.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-hir-full.h\"\n \n@@ -870,13 +871,13 @@ class FnPtr : public BaseType\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, size_t capacity, TyVar base,\n+  ArrayType (HirId ref, Bexpression *capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, size_t capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, Bexpression *capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n@@ -893,7 +894,8 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  size_t get_capacity () const { return capacity; }\n+  Bexpression *get_capacity () const { return capacity; }\n+  std::string capacity_string () const;\n \n   BaseType *get_element_type () const;\n \n@@ -905,7 +907,7 @@ class ArrayType : public BaseType\n   }\n \n private:\n-  size_t capacity;\n+  Bexpression *capacity;\n   TyVar element_type;\n };\n "}, {"sha": "372d969aa07746a3069da5ceabd5571a2581fa3b", "filename": "gcc/testsuite/rust.test/compile/arrays3.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays3.rs?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,6 @@\n+const TEST: usize = 6;\n+\n+fn main() {\n+    let a: [_; 12] = [123; TEST * 2];\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "ac317fedf44fef5c635366bb13f85cbc246fc2a4", "filename": "gcc/testsuite/rust.test/compile/arrays4.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farrays4.rs?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -0,0 +1,6 @@\n+const TEST: usize = 4;\n+\n+fn main() {\n+    let a: [_; TEST + 1 + 2] = [123; 7];\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "e35508050d5f8a807b03db4f25006333befc467a", "filename": "gcc/testsuite/rust.test/xfail_compile/arrays2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393b783549e1247dfed5b86f098fb10d1eaf6659/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farrays2.rs?ref=393b783549e1247dfed5b86f098fb10d1eaf6659", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let array: [i32; 5] = [1, 2, 3]; // { dg-error \"mismatch in array capacity\" }\n-                                     // { dg-error \"expected ..i32:5.. got ..i32:3..\" \"\" { target { *-*-* } } .-1 }\n+    let array: [i32; 5] = [1, 2, 3];\n+    // { dg-error \"expected ..i32:5.. got ..i32:3..\" \"\" { target { *-*-* } } .-1 }\n }"}]}