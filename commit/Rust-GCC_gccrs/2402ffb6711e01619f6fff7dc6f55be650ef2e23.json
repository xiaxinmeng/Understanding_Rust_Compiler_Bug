{"sha": "2402ffb6711e01619f6fff7dc6f55be650ef2e23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQwMmZmYjY3MTFlMDE2MTlmNmZmZjdkYzZmNTViZTY1MGVmMmUyMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-22T12:00:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-22T12:00:55Z"}, "message": "re PR tree-optimization/82291 (wrong code at -O3 on x86_64-linux-gnu)\n\n2017-09-22  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82291\n\t* tree-if-conv.c (predicate_mem_writes): Make sure to\n\tremove writes in blocks predicated with false.\n\n\t* gcc.dg/torture/pr82291.c: New testcase.\n\nFrom-SVN: r253093", "tree": {"sha": "89a49fc754b8cdb2d7bb9f8184629b3ac7b28b85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89a49fc754b8cdb2d7bb9f8184629b3ac7b28b85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2402ffb6711e01619f6fff7dc6f55be650ef2e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2402ffb6711e01619f6fff7dc6f55be650ef2e23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2402ffb6711e01619f6fff7dc6f55be650ef2e23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2402ffb6711e01619f6fff7dc6f55be650ef2e23/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c818750d8bebb4b929dcffcce4c8f3fa2de4f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c818750d8bebb4b929dcffcce4c8f3fa2de4f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c818750d8bebb4b929dcffcce4c8f3fa2de4f35"}], "stats": {"total": 238, "additions": 148, "deletions": 90}, "files": [{"sha": "5b9217c4b0a5f435716682cdc8596b99bb09a665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2402ffb6711e01619f6fff7dc6f55be650ef2e23", "patch": "@@ -1,3 +1,9 @@\n+2017-09-22  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82291\n+\t* tree-if-conv.c (predicate_mem_writes): Make sure to\n+\tremove writes in blocks predicated with false.\n+\n 2017-09-22  Richard Biener  <rguenther@suse.de>\n \n \t* sese.c: Include cfganal.h."}, {"sha": "1c2776af002eefc2320c5d16e96e63dfca26e689", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2402ffb6711e01619f6fff7dc6f55be650ef2e23", "patch": "@@ -1,3 +1,8 @@\n+2017-09-22  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82291\n+\t* gcc.dg/torture/pr82291.c: New testcase.\n+\n 2017-09-22  Sergey Shalnov  <sergey.shalnov@intel.com>\n \n         * gcc.target/i386/avx512f-constant-set.c: New test."}, {"sha": "daa1665af209305dcc8a84952fbce3278816cec3", "filename": "gcc/testsuite/gcc.dg/torture/pr82291.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr82291.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr82291.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr82291.c?ref=2402ffb6711e01619f6fff7dc6f55be650ef2e23", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+\n+int a, c, d, *h;\n+unsigned b;\n+\n+int *fn1 ()\n+{ \n+  int *f[3], g = 0;\n+  for (; g < 3; g++)\n+    f[g] = &a;\n+  if (--b > a)\n+    { \n+      if (a > b)\n+\td++;\n+      return f[0];\n+    }\n+}\n+\n+void fn2 ()\n+{ \n+  for (; c >= 0; --c)\n+    { \n+      int j[] = { 0, 0, 0, 0, 0 };\n+      int *k = fn1 ();\n+      if (!k)\n+\t__builtin_abort ();\n+      h = &j[4];\n+    }\n+}\n+\n+int main ()\n+{ \n+  fn2 ();\n+  if (d != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "e2fce3c114a55e418db4e26fea230b5dcdb2cd78", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2402ffb6711e01619f6fff7dc6f55be650ef2e23/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=2402ffb6711e01619f6fff7dc6f55be650ef2e23", "patch": "@@ -2197,7 +2197,7 @@ predicate_mem_writes (loop_p loop)\n       gimple *stmt;\n       int index;\n \n-      if (is_true_predicate (cond) || is_false_predicate (cond))\n+      if (is_true_predicate (cond))\n \tcontinue;\n \n       swap = false;\n@@ -2210,97 +2210,107 @@ predicate_mem_writes (loop_p loop)\n       vect_sizes.truncate (0);\n       vect_masks.truncate (0);\n \n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tif (!gimple_assign_single_p (stmt = gsi_stmt (gsi)))\n-\t  continue;\n-\telse if (gimple_plf (stmt, GF_PLF_2))\n-\t  {\n-\t    tree lhs = gimple_assign_lhs (stmt);\n-\t    tree rhs = gimple_assign_rhs1 (stmt);\n-\t    tree ref, addr, ptr, mask;\n-\t    gcall *new_stmt;\n-\t    gimple_seq stmts = NULL;\n-\t    int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n-\t    ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n-\t    mark_addressable (ref);\n-\t    addr = force_gimple_operand_gsi (&gsi, build_fold_addr_expr (ref),\n-\t\t\t\t\t     true, NULL_TREE, true,\n-\t\t\t\t\t     GSI_SAME_STMT);\n-\t    if (!vect_sizes.is_empty ()\n-\t\t&& (index = mask_exists (bitsize, vect_sizes)) != -1)\n-\t      /* Use created mask.  */\n-\t      mask = vect_masks[index];\n-\t    else\n-\t      {\n-\t\tif (COMPARISON_CLASS_P (cond))\n-\t\t  mask = gimple_build (&stmts, TREE_CODE (cond),\n-\t\t\t\t       boolean_type_node,\n-\t\t\t\t       TREE_OPERAND (cond, 0),\n-\t\t\t\t       TREE_OPERAND (cond, 1));\n-\t\telse\n-\t\t  {\n-\t\t    gcc_assert (TREE_CODE (cond) == SSA_NAME);\n-\t\t    mask = cond;\n-\t\t  }\n-\n-\t\tif (swap)\n-\t\t  {\n-\t\t    tree true_val\n-\t\t      = constant_boolean_node (true, TREE_TYPE (mask));\n-\t\t    mask = gimple_build (&stmts, BIT_XOR_EXPR,\n-\t\t\t\t\t TREE_TYPE (mask), mask, true_val);\n-\t\t  }\n-\t\tgsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n-\n-\t\tmask = ifc_temp_var (TREE_TYPE (mask), mask, &gsi);\n-\t\t/* Save mask and its size for further use.  */\n-\t        vect_sizes.safe_push (bitsize);\n-\t\tvect_masks.safe_push (mask);\n-\t      }\n-\t    ptr = build_int_cst (reference_alias_ptr_type (ref),\n-\t\t\t\t get_object_alignment (ref));\n-\t    /* Copy points-to info if possible.  */\n-\t    if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n-\t      copy_ref_info (build2 (MEM_REF, TREE_TYPE (ref), addr, ptr),\n-\t\t\t     ref);\n-\t    if (TREE_CODE (lhs) == SSA_NAME)\n-\t      {\n-\t\tnew_stmt\n-\t\t  = gimple_build_call_internal (IFN_MASK_LOAD, 3, addr,\n-\t\t\t\t\t\tptr, mask);\n-\t\tgimple_call_set_lhs (new_stmt, lhs);\n-\t\tgimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t      }\n-\t    else\n-\t      {\n-\t\tnew_stmt\n-\t\t  = gimple_build_call_internal (IFN_MASK_STORE, 4, addr, ptr,\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  if (!gimple_assign_single_p (stmt = gsi_stmt (gsi)))\n+\t    ;\n+\t  else if (is_false_predicate (cond))\n+\t    {\n+\t      unlink_stmt_vdef (stmt);\n+\t      gsi_remove (&gsi, true);\n+\t      release_defs (stmt);\n+\t      continue;\n+\t    }\n+\t  else if (gimple_plf (stmt, GF_PLF_2))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      tree ref, addr, ptr, mask;\n+\t      gcall *new_stmt;\n+\t      gimple_seq stmts = NULL;\n+\t      int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n+\t      ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n+\t      mark_addressable (ref);\n+\t      addr = force_gimple_operand_gsi (&gsi, build_fold_addr_expr (ref),\n+\t\t\t\t\t       true, NULL_TREE, true,\n+\t\t\t\t\t       GSI_SAME_STMT);\n+\t      if (!vect_sizes.is_empty ()\n+\t\t  && (index = mask_exists (bitsize, vect_sizes)) != -1)\n+\t\t/* Use created mask.  */\n+\t\tmask = vect_masks[index];\n+\t      else\n+\t\t{\n+\t\t  if (COMPARISON_CLASS_P (cond))\n+\t\t    mask = gimple_build (&stmts, TREE_CODE (cond),\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t TREE_OPERAND (cond, 0),\n+\t\t\t\t\t TREE_OPERAND (cond, 1));\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_assert (TREE_CODE (cond) == SSA_NAME);\n+\t\t      mask = cond;\n+\t\t    }\n+\n+\t\t  if (swap)\n+\t\t    {\n+\t\t      tree true_val\n+\t\t\t= constant_boolean_node (true, TREE_TYPE (mask));\n+\t\t      mask = gimple_build (&stmts, BIT_XOR_EXPR,\n+\t\t\t\t\t   TREE_TYPE (mask), mask, true_val);\n+\t\t    }\n+\t\t  gsi_insert_seq_before (&gsi, stmts, GSI_SAME_STMT);\n+\n+\t\t  mask = ifc_temp_var (TREE_TYPE (mask), mask, &gsi);\n+\t\t  /* Save mask and its size for further use.  */\n+\t\t  vect_sizes.safe_push (bitsize);\n+\t\t  vect_masks.safe_push (mask);\n+\t\t}\n+\t      ptr = build_int_cst (reference_alias_ptr_type (ref),\n+\t\t\t\t   get_object_alignment (ref));\n+\t      /* Copy points-to info if possible.  */\n+\t      if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n+\t\tcopy_ref_info (build2 (MEM_REF, TREE_TYPE (ref), addr, ptr),\n+\t\t\t       ref);\n+\t      if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t{\n+\t\t  new_stmt\n+\t\t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, addr,\n+\t\t\t\t\t\t  ptr, mask);\n+\t\t  gimple_call_set_lhs (new_stmt, lhs);\n+\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  new_stmt\n+\t\t    = gimple_build_call_internal (IFN_MASK_STORE, 4, addr, ptr,\n \t\t\t\t\t\t  mask, rhs);\n-\t\tgimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t\tgimple_set_vdef (new_stmt, gimple_vdef (stmt));\n-\t\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\t      }\n-\t    gimple_call_set_nothrow (new_stmt, true);\n+\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+\t\t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+\t\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+\t\t}\n+\t      gimple_call_set_nothrow (new_stmt, true);\n \n-\t    gsi_replace (&gsi, new_stmt, true);\n-\t  }\n-\telse if (gimple_vdef (stmt))\n-\t  {\n-\t    tree lhs = gimple_assign_lhs (stmt);\n-\t    tree rhs = gimple_assign_rhs1 (stmt);\n-\t    tree type = TREE_TYPE (lhs);\n-\n-\t    lhs = ifc_temp_var (type, unshare_expr (lhs), &gsi);\n-\t    rhs = ifc_temp_var (type, unshare_expr (rhs), &gsi);\n-\t    if (swap)\n-\t      std::swap (lhs, rhs);\n-\t    cond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n-\t\t\t\t\t       is_gimple_condexpr, NULL_TREE,\n-\t\t\t\t\t       true, GSI_SAME_STMT);\n-\t    rhs = fold_build_cond_expr (type, unshare_expr (cond), rhs, lhs);\n-\t    gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n-\t    update_stmt (stmt);\n-\t  }\n+\t      gsi_replace (&gsi, new_stmt, true);\n+\t    }\n+\t  else if (gimple_vdef (stmt))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      tree type = TREE_TYPE (lhs);\n+\n+\t      lhs = ifc_temp_var (type, unshare_expr (lhs), &gsi);\n+\t      rhs = ifc_temp_var (type, unshare_expr (rhs), &gsi);\n+\t      if (swap)\n+\t\tstd::swap (lhs, rhs);\n+\t      cond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n+\t\t\t\t\t\t is_gimple_condexpr, NULL_TREE,\n+\t\t\t\t\t\t true, GSI_SAME_STMT);\n+\t      rhs = fold_build_cond_expr (type, unshare_expr (cond), rhs, lhs);\n+\t      gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n+\t      update_stmt (stmt);\n+\t    }\n+\t  gsi_next (&gsi);\n+\t}\n     }\n }\n "}]}