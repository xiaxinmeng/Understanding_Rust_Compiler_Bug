{"sha": "d95828db91607d1060c4301ab5631cb5a75cc787", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1ODI4ZGI5MTYwN2QxMDYwYzQzMDFhYjU2MzFjYjVhNzVjYzc4Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-10-12T06:24:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-10-12T06:24:07Z"}, "message": "rtl.h: Include hashtab.h.\n\n\t* rtl.h: Include hashtab.h.\n\t(iterative_hash_rtx): New prototype.\n\t* rtl.c (iterative_hash_rtx): New function.\n\t* dwarf2out.c (dw_loc_list_node): Add hash and emitted fields.\n\t(output_loc_list): Return immediately if emitted is set,\n\tset it.\n\t(hash_loc_operands, hash_locs, hash_loc_list,\n\tcompare_loc_operands, compare_locs, loc_list_hash, loc_list_eq,\n\toptimize_location_lists_1, optimize_location_lists): New function.\n\t(dwarf2out_finish): Call optimize_location_lists.\n\t* Makefile.in (RTL_BASE_H): Depend on $(HASHTAB_H).\n\nFrom-SVN: r165351", "tree": {"sha": "4255e8245018661107838a186d047ddb5e1f3550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4255e8245018661107838a186d047ddb5e1f3550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d95828db91607d1060c4301ab5631cb5a75cc787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95828db91607d1060c4301ab5631cb5a75cc787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95828db91607d1060c4301ab5631cb5a75cc787", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95828db91607d1060c4301ab5631cb5a75cc787/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8207e1fb1b9452bb5660167b2e17d96b259e9fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8207e1fb1b9452bb5660167b2e17d96b259e9fe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8207e1fb1b9452bb5660167b2e17d96b259e9fe2"}], "stats": {"total": 470, "additions": 469, "deletions": 1}, "files": [{"sha": "20f20df5238c840f4fc1c07edd7318714bf4f601", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d95828db91607d1060c4301ab5631cb5a75cc787", "patch": "@@ -1,3 +1,17 @@\n+2010-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* rtl.h: Include hashtab.h.\n+\t(iterative_hash_rtx): New prototype.\n+\t* rtl.c (iterative_hash_rtx): New function.\n+\t* dwarf2out.c (dw_loc_list_node): Add hash and emitted fields.\n+\t(output_loc_list): Return immediately if emitted is set,\n+\tset it.\n+\t(hash_loc_operands, hash_locs, hash_loc_list,\n+\tcompare_loc_operands, compare_locs, loc_list_hash, loc_list_eq,\n+\toptimize_location_lists_1, optimize_location_lists): New function.\n+\t(dwarf2out_finish): Call optimize_location_lists.\n+\t* Makefile.in (RTL_BASE_H): Depend on $(HASHTAB_H).\n+\n 2010-10-12  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR testsuite/45974"}, {"sha": "ddb6854da048df0079368ab2d114e0a167df49c1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d95828db91607d1060c4301ab5631cb5a75cc787", "patch": "@@ -874,7 +874,8 @@ HOSTHOOKS_DEF_H = hosthooks-def.h $(HOOKS_H)\n LANGHOOKS_DEF_H = langhooks-def.h $(HOOKS_H)\n TARGET_DEF_H = target-def.h target-hooks-def.h $(HOOKS_H) targhooks.h\n RTL_BASE_H = rtl.h rtl.def $(MACHMODE_H) reg-notes.def insn-notes.def \\\n-  $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) $(FIXED_VALUE_H) alias.h\n+  $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) $(FIXED_VALUE_H) alias.h \\\n+  $(HASHTAB_H)\n FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h\n RTL_H = $(RTL_BASE_H) genrtl.h vecir.h\n RTL_ERROR_H = $(RTL_H) $(DIAGNOSTIC_CORE_H)"}, {"sha": "9832fa90b9b368536e4e1fd622e8ee7912a8f718", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d95828db91607d1060c4301ab5631cb5a75cc787", "patch": "@@ -4376,6 +4376,8 @@ typedef struct GTY(()) dw_loc_list_struct {\n \t\t      Only on head of list */\n   const char *section; /* Section this loclist is relative to */\n   dw_loc_descr_ref expr;\n+  hashval_t hash;\n+  bool emitted;\n } dw_loc_list_node;\n \n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n@@ -10883,6 +10885,10 @@ output_loc_list (dw_loc_list_ref list_head)\n {\n   dw_loc_list_ref curr = list_head;\n \n+  if (list_head->emitted)\n+    return;\n+  list_head->emitted = true;\n+\n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n \n   /* Walk the location list, and output each range + expression.  */\n@@ -22400,7 +22406,376 @@ resolve_addr (dw_die_ref die)\n \n   FOR_EACH_CHILD (die, c, resolve_addr (c));\n }\n+\f\n+/* Helper routines for optimize_location_lists.\n+   This pass tries to share identical local lists in .debug_loc\n+   section.  */\n+\n+/* Iteratively hash operands of LOC opcode.  */\n+\n+static inline hashval_t\n+hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)\n+{\n+  dw_val_ref val1 = &loc->dw_loc_oprnd1;\n+  dw_val_ref val2 = &loc->dw_loc_oprnd2;\n+\n+  switch (loc->dw_loc_opc)\n+    {\n+    case DW_OP_const4u:\n+    case DW_OP_const8u:\n+      if (loc->dtprel)\n+\tgoto hash_addr;\n+      /* FALLTHRU */\n+    case DW_OP_const1u:\n+    case DW_OP_const1s:\n+    case DW_OP_const2u:\n+    case DW_OP_const2s:\n+    case DW_OP_const4s:\n+    case DW_OP_const8s:\n+    case DW_OP_constu:\n+    case DW_OP_consts:\n+    case DW_OP_pick:\n+    case DW_OP_plus_uconst:\n+    case DW_OP_breg0:\n+    case DW_OP_breg1:\n+    case DW_OP_breg2:\n+    case DW_OP_breg3:\n+    case DW_OP_breg4:\n+    case DW_OP_breg5:\n+    case DW_OP_breg6:\n+    case DW_OP_breg7:\n+    case DW_OP_breg8:\n+    case DW_OP_breg9:\n+    case DW_OP_breg10:\n+    case DW_OP_breg11:\n+    case DW_OP_breg12:\n+    case DW_OP_breg13:\n+    case DW_OP_breg14:\n+    case DW_OP_breg15:\n+    case DW_OP_breg16:\n+    case DW_OP_breg17:\n+    case DW_OP_breg18:\n+    case DW_OP_breg19:\n+    case DW_OP_breg20:\n+    case DW_OP_breg21:\n+    case DW_OP_breg22:\n+    case DW_OP_breg23:\n+    case DW_OP_breg24:\n+    case DW_OP_breg25:\n+    case DW_OP_breg26:\n+    case DW_OP_breg27:\n+    case DW_OP_breg28:\n+    case DW_OP_breg29:\n+    case DW_OP_breg30:\n+    case DW_OP_breg31:\n+    case DW_OP_regx:\n+    case DW_OP_fbreg:\n+    case DW_OP_piece:\n+    case DW_OP_deref_size:\n+    case DW_OP_xderef_size:\n+      hash = iterative_hash_object (val1->v.val_int, hash);\n+      break;\n+    case DW_OP_skip:\n+    case DW_OP_bra:\n+      {\n+\tint offset;\n+\n+\tgcc_assert (val1->val_class == dw_val_class_loc);\n+\toffset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n+\thash = iterative_hash_object (offset, hash);\n+      }\n+      break;\n+    case DW_OP_implicit_value:\n+      hash = iterative_hash_object (val1->v.val_unsigned, hash);\n+      switch (val2->val_class)\n+\t{\n+\tcase dw_val_class_const:\n+\t  hash = iterative_hash_object (val2->v.val_int, hash);\n+\t  break;\n+\tcase dw_val_class_vec:\n+\t  {\n+\t    unsigned int elt_size = val2->v.val_vec.elt_size;\n+\t    unsigned int len = val2->v.val_vec.length;\n+\n+\t    hash = iterative_hash_object (elt_size, hash);\n+\t    hash = iterative_hash_object (len, hash);\n+\t    hash = iterative_hash (val2->v.val_vec.array,\n+\t\t\t\t   len * elt_size, hash);\n+\t  }\n+\t  break;\n+\tcase dw_val_class_const_double:\n+\t  hash = iterative_hash_object (val2->v.val_double.low, hash);\n+\t  hash = iterative_hash_object (val2->v.val_double.high, hash);\n+\t  break;\n+\tcase dw_val_class_addr:\n+\t  hash = iterative_hash_rtx (val2->v.val_addr, hash);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    case DW_OP_bregx:\n+    case DW_OP_bit_piece:\n+      hash = iterative_hash_object (val1->v.val_int, hash);\n+      hash = iterative_hash_object (val2->v.val_int, hash);\n+      break;\n+    case DW_OP_addr:\n+    hash_addr:\n+      if (loc->dtprel)\n+\t{\n+\t  unsigned char dtprel = 0xd1;\n+\t  hash = iterative_hash_object (dtprel, hash);\n+\t}\n+      hash = iterative_hash_rtx (val1->v.val_addr, hash);\n+      break;\n+    case DW_OP_GNU_implicit_pointer:\n+      hash = iterative_hash_object (val2->v.val_int, hash);\n+      break;\n+\n+    default:\n+      /* Other codes have no operands.  */\n+      break;\n+    }\n+  return hash;\n+}\n+\n+/* Iteratively hash the whole DWARF location expression LOC.  */\n \n+static inline hashval_t\n+hash_locs (dw_loc_descr_ref loc, hashval_t hash)\n+{\n+  dw_loc_descr_ref l;\n+  bool sizes_computed = false;\n+  /* Compute sizes, so that DW_OP_skip/DW_OP_bra can be checksummed.  */\n+  size_of_locs (loc);\n+\n+  for (l = loc; l != NULL; l = l->dw_loc_next)\n+    {\n+      enum dwarf_location_atom opc = l->dw_loc_opc;\n+      hash = iterative_hash_object (opc, hash);\n+      if ((opc == DW_OP_skip || opc == DW_OP_bra) && !sizes_computed)\n+\t{\n+\t  size_of_locs (loc);\n+\t  sizes_computed = true;\n+\t}\n+      hash = hash_loc_operands (l, hash);\n+    }\n+  return hash;\n+}\n+\n+/* Compute hash of the whole location list LIST_HEAD.  */\n+\n+static inline void\n+hash_loc_list (dw_loc_list_ref list_head)\n+{\n+  dw_loc_list_ref curr = list_head;\n+  hashval_t hash = 0;\n+\n+  for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n+    {\n+      hash = iterative_hash (curr->begin, strlen (curr->begin) + 1, hash);\n+      hash = iterative_hash (curr->end, strlen (curr->end) + 1, hash);\n+      if (curr->section)\n+\thash = iterative_hash (curr->section, strlen (curr->section) + 1,\n+\t\t\t       hash);\n+      hash = hash_locs (curr->expr, hash);\n+    }\n+  list_head->hash = hash;\n+}\n+\n+/* Return true if X and Y opcodes have the same operands.  */\n+\n+static inline bool\n+compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n+{\n+  dw_val_ref valx1 = &x->dw_loc_oprnd1;\n+  dw_val_ref valx2 = &x->dw_loc_oprnd2;\n+  dw_val_ref valy1 = &y->dw_loc_oprnd1;\n+  dw_val_ref valy2 = &y->dw_loc_oprnd2;\n+\n+  switch (x->dw_loc_opc)\n+    {\n+    case DW_OP_const4u:\n+    case DW_OP_const8u:\n+      if (x->dtprel)\n+\tgoto hash_addr;\n+      /* FALLTHRU */\n+    case DW_OP_const1u:\n+    case DW_OP_const1s:\n+    case DW_OP_const2u:\n+    case DW_OP_const2s:\n+    case DW_OP_const4s:\n+    case DW_OP_const8s:\n+    case DW_OP_constu:\n+    case DW_OP_consts:\n+    case DW_OP_pick:\n+    case DW_OP_plus_uconst:\n+    case DW_OP_breg0:\n+    case DW_OP_breg1:\n+    case DW_OP_breg2:\n+    case DW_OP_breg3:\n+    case DW_OP_breg4:\n+    case DW_OP_breg5:\n+    case DW_OP_breg6:\n+    case DW_OP_breg7:\n+    case DW_OP_breg8:\n+    case DW_OP_breg9:\n+    case DW_OP_breg10:\n+    case DW_OP_breg11:\n+    case DW_OP_breg12:\n+    case DW_OP_breg13:\n+    case DW_OP_breg14:\n+    case DW_OP_breg15:\n+    case DW_OP_breg16:\n+    case DW_OP_breg17:\n+    case DW_OP_breg18:\n+    case DW_OP_breg19:\n+    case DW_OP_breg20:\n+    case DW_OP_breg21:\n+    case DW_OP_breg22:\n+    case DW_OP_breg23:\n+    case DW_OP_breg24:\n+    case DW_OP_breg25:\n+    case DW_OP_breg26:\n+    case DW_OP_breg27:\n+    case DW_OP_breg28:\n+    case DW_OP_breg29:\n+    case DW_OP_breg30:\n+    case DW_OP_breg31:\n+    case DW_OP_regx:\n+    case DW_OP_fbreg:\n+    case DW_OP_piece:\n+    case DW_OP_deref_size:\n+    case DW_OP_xderef_size:\n+      return valx1->v.val_int == valy1->v.val_int;\n+    case DW_OP_skip:\n+    case DW_OP_bra:\n+      gcc_assert (valx1->val_class == dw_val_class_loc\n+\t\t  && valy1->val_class == dw_val_class_loc\n+\t\t  && x->dw_loc_addr == y->dw_loc_addr);\n+      return valx1->v.val_loc->dw_loc_addr == valy1->v.val_loc->dw_loc_addr;\n+    case DW_OP_implicit_value:\n+      if (valx1->v.val_unsigned != valy1->v.val_unsigned\n+\t  || valx2->val_class != valy2->val_class)\n+\treturn false;\n+      switch (valx2->val_class)\n+\t{\n+\tcase dw_val_class_const:\n+\t  return valx2->v.val_int == valy2->v.val_int;\n+\tcase dw_val_class_vec:\n+\t  return valx2->v.val_vec.elt_size == valy2->v.val_vec.elt_size\n+\t\t && valx2->v.val_vec.length == valy2->v.val_vec.length\n+\t\t && memcmp (valx2->v.val_vec.array, valy2->v.val_vec.array,\n+\t\t\t    valx2->v.val_vec.elt_size\n+\t\t\t    * valx2->v.val_vec.length) == 0;\n+\tcase dw_val_class_const_double:\n+\t  return valx2->v.val_double.low == valy2->v.val_double.low\n+\t\t && valx2->v.val_double.high == valy2->v.val_double.high;\n+\tcase dw_val_class_addr:\n+\t  return rtx_equal_p (valx2->v.val_addr, valy2->v.val_addr);\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    case DW_OP_bregx:\n+    case DW_OP_bit_piece:\n+      return valx1->v.val_int == valy1->v.val_int\n+\t     && valx2->v.val_int == valy2->v.val_int;\n+    case DW_OP_addr:\n+    hash_addr:\n+      return rtx_equal_p (valx1->v.val_addr, valx2->v.val_addr);\n+    case DW_OP_GNU_implicit_pointer:\n+      return valx1->val_class == dw_val_class_die_ref\n+\t     && valx1->val_class == valy1->val_class\n+\t     && valx1->v.val_die_ref.die == valy1->v.val_die_ref.die\n+\t     && valx2->v.val_int == valy2->v.val_int;\n+    default:\n+      /* Other codes have no operands.  */\n+      return true;\n+    }\n+}\n+\n+/* Return true if DWARF location expressions X and Y are the same.  */\n+\n+static inline bool\n+compare_locs (dw_loc_descr_ref x, dw_loc_descr_ref y)\n+{\n+  for (; x != NULL && y != NULL; x = x->dw_loc_next, y = y->dw_loc_next)\n+    if (x->dw_loc_opc != y->dw_loc_opc\n+\t|| x->dtprel != y->dtprel\n+\t|| !compare_loc_operands (x, y))\n+      break;\n+  return x == NULL && y == NULL;\n+}\n+\n+/* Return precomputed hash of location list X.  */\n+\n+static hashval_t\n+loc_list_hash (const void *x)\n+{\n+  return ((const struct dw_loc_list_struct *) x)->hash;\n+}\n+\n+/* Return 1 if location lists X and Y are the same.  */\n+\n+static int\n+loc_list_eq (const void *x, const void *y)\n+{\n+  const struct dw_loc_list_struct *a = (const struct dw_loc_list_struct *) x;\n+  const struct dw_loc_list_struct *b = (const struct dw_loc_list_struct *) y;\n+  if (a == b)\n+    return 1;\n+  if (a->hash != b->hash)\n+    return 0;\n+  for (; a != NULL && b != NULL; a = a->dw_loc_next, b = b->dw_loc_next)\n+    if (strcmp (a->begin, b->begin) != 0\n+\t|| strcmp (a->end, b->end) != 0\n+\t|| (a->section == NULL) != (b->section == NULL)\n+\t|| (a->section && strcmp (a->section, b->section) != 0)\n+\t|| !compare_locs (a->expr, b->expr))\n+      break;\n+  return a == NULL && b == NULL;\n+}\n+\n+/* Recursively optimize location lists referenced from DIE\n+   children and share them whenever possible.  */\n+\n+static void\n+optimize_location_lists_1 (dw_die_ref die, htab_t htab)\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+  unsigned ix;\n+  void **slot;\n+\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+    if (AT_class (a) == dw_val_class_loc_list)\n+      {\n+\tdw_loc_list_ref list = AT_loc_list (a);\n+\t/* TODO: perform some optimizations here, before hashing\n+\t   it and storing into the hash table.  */\n+\thash_loc_list (list);\n+\tslot = htab_find_slot_with_hash (htab, list, list->hash,\n+\t\t\t\t\t INSERT);\n+\tif (*slot == NULL)\n+\t  *slot = (void *) list;\n+\telse\n+\t  a->dw_attr_val.v.val_loc_list = (dw_loc_list_ref) *slot;\n+      }\n+\n+  FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));\n+}\n+\n+/* Optimize location lists referenced from DIE\n+   children and share them whenever possible.  */\n+\n+static void\n+optimize_location_lists (dw_die_ref die)\n+{\n+  htab_t htab = htab_create (500, loc_list_hash, loc_list_eq, NULL);\n+  optimize_location_lists_1 (die, htab);\n+  htab_delete (htab);\n+}\n+\f\n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n \n@@ -22621,6 +22996,9 @@ dwarf2out_finish (const char *filename)\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     add_AT_macptr (comp_unit_die (), DW_AT_macro_info, macinfo_section_label);\n \n+  if (have_location_lists)\n+    optimize_location_lists (die);\n+\n   /* Output all of the compilation units.  We put the main one last so that\n      the offsets are available to output_pubnames.  */\n   for (node = limbo_die_list; node; node = node->next)"}, {"sha": "6f349798c752462105ecc69c1536b7e2cb37b6ea", "filename": "gcc/rtl.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=d95828db91607d1060c4301ab5631cb5a75cc787", "patch": "@@ -601,6 +601,79 @@ rtx_equal_p (const_rtx x, const_rtx y)\n   return 1;\n }\n \n+/* Iteratively hash rtx X.  */\n+\n+hashval_t\n+iterative_hash_rtx (const_rtx x, hashval_t hash)\n+{\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  int i, j;\n+  const char *fmt;\n+\n+  if (x == NULL_RTX)\n+    return hash;\n+  code = GET_CODE (x);\n+  hash = iterative_hash_object (code, hash);\n+  mode = GET_MODE (x);\n+  hash = iterative_hash_object (mode, hash);\n+  switch (code)\n+    {\n+    case REG:\n+      i = REGNO (x);\n+      return iterative_hash_object (i, hash);\n+    case CONST_INT:\n+      return iterative_hash_object (INTVAL (x), hash);\n+    case SYMBOL_REF:\n+      if (XSTR (x, 0))\n+\treturn iterative_hash (XSTR (x, 0), strlen (XSTR (x, 0)) + 1,\n+\t\t\t       hash);\n+      return hash;\n+    case LABEL_REF:\n+    case DEBUG_EXPR:\n+    case VALUE:\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case DEBUG_IMPLICIT_PTR:\n+      return hash;\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'w':\n+\thash = iterative_hash_object (XWINT (x, i), hash);\n+\tbreak;\n+      case 'n':\n+      case 'i':\n+\thash = iterative_hash_object (XINT (x, i), hash);\n+\tbreak;\n+      case 'V':\n+      case 'E':\n+\tj = XVECLEN (x, i);\n+\thash = iterative_hash_object (j, hash);\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  hash = iterative_hash_rtx (XVECEXP (x, i, j), hash);\n+\tbreak;\n+      case 'e':\n+\thash = iterative_hash_rtx (XEXP (x, i), hash);\n+\tbreak;\n+      case 'S':\n+      case 's':\n+\tif (XSTR (x, i))\n+\t  hash = iterative_hash (XSTR (x, 0), strlen (XSTR (x, 0)) + 1,\n+\t\t\t\t hash);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+  return hash;\n+}\n+\n void\n dump_rtx_statistics (void)\n {"}, {"sha": "3e1df2c9bd98d5bb1cd0d5fe2a9014e78b410e6c", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95828db91607d1060c4301ab5631cb5a75cc787/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d95828db91607d1060c4301ab5631cb5a75cc787", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecir.h\"\n #include \"fixed-value.h\"\n #include \"alias.h\"\n+#include \"hashtab.h\"\n \n #undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n #undef FLOAT /* Likewise.  */\n@@ -1622,6 +1623,7 @@ extern unsigned int rtx_size (const_rtx);\n extern rtx shallow_copy_rtx_stat (const_rtx MEM_STAT_DECL);\n #define shallow_copy_rtx(a) shallow_copy_rtx_stat (a MEM_STAT_INFO)\n extern int rtx_equal_p (const_rtx, const_rtx);\n+extern hashval_t iterative_hash_rtx (const_rtx, hashval_t);\n \n /* In emit-rtl.c */\n extern rtvec gen_rtvec_v (int, rtx *);"}]}