{"sha": "809330ab8450261e05919b472783bf15e4b000f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5MzMwYWI4NDUwMjYxZTA1OTE5YjQ3Mjc4M2JmMTVlNGIwMDBmNw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-07-06T14:10:18Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-08-24T10:45:13Z"}, "message": "arm: Add tests for VLLDM mitigation [PR102035]\n\nNew tests for the erratum mitigation.\n\ngcc/testsuite:\n\tPR target/102035\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c: New test.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c: Likewise.\n\t* gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c: Likewise.", "tree": {"sha": "fbb5947f0c0ae1fabc8f56dfc339a96380773089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb5947f0c0ae1fabc8f56dfc339a96380773089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809330ab8450261e05919b472783bf15e4b000f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809330ab8450261e05919b472783bf15e4b000f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809330ab8450261e05919b472783bf15e4b000f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809330ab8450261e05919b472783bf15e4b000f7/comments", "author": null, "committer": null, "parents": [{"sha": "30461cf8dba3d3adb15a125e4da48800eb2b9b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30461cf8dba3d3adb15a125e4da48800eb2b9b8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30461cf8dba3d3adb15a125e4da48800eb2b9b8f"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "553cc7837e1f5ea7ddc6bb4ce496c0929386d4bc", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-13a.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-13a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=soft\" } } */\n+\n+#include \"../../../cmse-13.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[1,4-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[1,4-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "ce02fdea643fecd5716d709755dd8f02b9453e51", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-7a.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-7a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=soft\" } } */\n+\n+#include \"../../../cmse-7.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "75e161152aa656e8246582999294a47da5ab459f", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/soft/cmse-8a.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoft%2Fcmse-8a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=soft\" } } */\n+\n+#include \"../../../cmse-8.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "dad72660d8725dfba8ecc0f783de2a61ee1af0d8", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-7a.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-7a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16 -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=softfp\" } } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+\n+#include \"../../../cmse-7.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "faa0448137291004d5f8852492b7a78efe59386d", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp-sp/cmse-8a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp-sp%2Fcmse-8a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16 -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=softfp\" } } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+\n+#include \"../../../cmse-8.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "bceba44e4969b1c0b54432b7cdb9077fa10daab4", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-13a.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-13a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=softfp\" } } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+\n+#include \"../../../cmse-13.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[1,4-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr2, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr3, r4\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r1, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[1,4-9\\]|r10|fp|ip), ){9}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[1,4-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "c74ebbdc231e051cb8814527d2098218913f25b9", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-7a.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-7a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=softfp\" } } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+\n+#include \"../../../cmse-7.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[0-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r0, )?(r1, )?(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[0-9\\]|r10|fp|ip), ){12}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[0-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}, {"sha": "ffb67a777fd8832cfa99dc0c1fda62f57977bcc3", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/8_1m/softfp/cmse-8a.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809330ab8450261e05919b472783bf15e4b000f7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2F8_1m%2Fsoftfp%2Fcmse-8a.c?ref=809330ab8450261e05919b472783bf15e4b000f7", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16 -mfix-cmse-cve-2021-35465\" }  */\n+/* { dg-skip-if \"Incompatible float ABI\" { *-*-* } { \"-mfloat-abi=*\" } { \"-mfloat-abi=softfp\" } } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+\n+#include \"../../../cmse-8.x\"\n+\n+/* Checks for saving and clearing prior to function call.  */\n+/* Shift on the same register as blxns.  */\n+/* { dg-final { scan-assembler \"lsrs\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler \"lsls\\t(r\\[2-9\\]|r10|fp|ip), \\\\1, #1.*blxns\\t\\\\1\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, r4\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr1, r4\" } } */\n+/* { dg-final { scan-assembler \"push\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+/* { dg-final { scan-assembler \"vlstm\\tsp\" } } */\n+/* Check the right registers are cleared and none appears twice.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{(r2, )?(r3, )?(r4, )?(r5, )?(r6, )?(r7, )?(r8, )?(r9, )?(r10, )?(fp, )?(ip, )?APSR\\}\" } } */\n+/* Check that the right number of registers is cleared and thus only one\n+   register is missing.  */\n+/* { dg-final { scan-assembler \"clrm\\t\\{((r\\[2-9\\]|r10|fp|ip), ){10}APSR\\}\" } } */\n+/* Check that no cleared register is used for blxns.  */\n+/* { dg-final { scan-assembler-not \"clrm\\t\\{\\[^\\}\\]\\+(r\\[2-9\\]|r10|fp|ip),\\[^\\}\\]\\+\\}.*blxns\\t\\\\1\" } } */\n+/* Check for v8.1-m variant of erratum work-around.  */\n+/* { dg-final { scan-assembler \"vscclrm\\t\\{vpr\\}\" } } */\n+/* { dg-final { scan-assembler \"vlldm\\tsp\" } } */\n+/* { dg-final { scan-assembler \"pop\\t\\{r4, r5, r6, r7, r8, r9, r10, fp\\}\" } } */\n+\n+/* Now we check that we use the correct intrinsic to call.  */\n+/* { dg-final { scan-assembler \"blxns\" } } */"}]}