{"sha": "a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlZTdjYmFjNDBiOGJhOTVlNmYxN2RkYjkzZGU3ZGRhNDJhNGE3Ng==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-12-22T23:19:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-12-22T23:19:49Z"}, "message": "re PR rtl-optimization/25432 (Reload ICE in gen_add2_insn)\n\n\tPR rtl-optimization/25432\n\t* reload1.c (eliminate_regs_in_insn): Update insn code on\n\tsuccessfully re-recognizing modified insn.\n\n\t* gcc.c-torture/compile/20051216-1.c: New test.\n\nFrom-SVN: r108985", "tree": {"sha": "8f81b8ae34b7f06c2308e23acc8f1703b67d349b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f81b8ae34b7f06c2308e23acc8f1703b67d349b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/comments", "author": null, "committer": null, "parents": [{"sha": "0c4fc6c9ed572c2a5332fd37fdcedefb7778f2bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c4fc6c9ed572c2a5332fd37fdcedefb7778f2bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c4fc6c9ed572c2a5332fd37fdcedefb7778f2bb"}], "stats": {"total": 152, "additions": 142, "deletions": 10}, "files": [{"sha": "0ee56c05528df0e032bb7690df60cecab520aa84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "patch": "@@ -1,3 +1,9 @@\n+2005-12-23  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR rtl-optimization/25432\n+\t* reload1.c (eliminate_regs_in_insn): Update insn code on\n+\tsuccessfully re-recognizing modified insn.\n+\n 2005-12-22  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (tree_fold_gcd): Use build_int_cst where appropriate."}, {"sha": "01943f3a7a015d980dcf0ec7742e3462a59ff8c4", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "patch": "@@ -1831,8 +1831,6 @@ find_reload_regs (struct insn_chain *chain)\n \t  && rld[r].regno == -1)\n \tif (! find_reg (chain, i))\n \t  {\n- \t    if (dump_file)\n- \t      fprintf (dump_file, \"reload failure for reload %d\\n\", r);\n \t    spill_failure (chain->insn, rld[r].class);\n \t    failure = 1;\n \t    return;\n@@ -1901,12 +1899,6 @@ spill_failure (rtx insn, enum reg_class class)\n     {\n       error (\"unable to find a register to spill in class %qs\",\n \t     reg_class_names[class]);\n- \n-      if (dump_file)\n- \t{\n- \t  fprintf (dump_file, \"\\nReloads for insn # %d\\n\", INSN_UID (insn));\n- \t  debug_reload_to_stream (dump_file);\n- \t}\n       fatal_insn (\"this is the insn:\", insn);\n     }\n }\n@@ -3241,8 +3233,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t      || GET_CODE (SET_SRC (old_set)) == PLUS))\n \t{\n \t  int new_icode = recog (PATTERN (insn), insn, 0);\n-\t  if (new_icode < 0)\n-\t    INSN_CODE (insn) = icode;\n+\t  if (new_icode >= 0)\n+\t    INSN_CODE (insn) = new_icode;\n \t}\n     }\n "}, {"sha": "23222eabd9ef760902fb4f361e063fff3e4adc5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "patch": "@@ -1,5 +1,8 @@\n 2005-12-23  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR rtl-optimization/25432\n+\t* gcc.c-torture/compile/20051216-1.c: New test.\n+\n \tPR objc/25328\n \t* objc/execute/pr25328.m: New test.\n "}, {"sha": "ed6ac723069cbc577f07660d7f3bad7fc3acc631", "filename": "gcc/testsuite/gcc.c-torture/compile/20051216-1.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20051216-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20051216-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20051216-1.c?ref=a5ee7cbac40b8ba95e6f17ddb93de7dda42a4a76", "patch": "@@ -0,0 +1,131 @@\n+/* PR rtl-optimization/25432 */\n+\n+void *malloc (__SIZE_TYPE__);\n+void *realloc (void *, __SIZE_TYPE__);\n+\n+struct A { double x, y; };\n+struct B { double x0, y0, x1, y1; };\n+struct C { int n_points; int dir; struct B bbox; struct A *points; };\n+struct D { int n_segs; struct C segs[1]; };\n+\n+void foo (int, int, int *, int, int *, struct A **, int *, int *,\n+\t  struct D *, int *, struct D **, int *, int **);\n+int baz (struct A, struct A, struct A, struct A);\n+\n+static void\n+bar (struct D *svp, int *n_points_max,\n+     struct A p, int *seg_map, int *active_segs, int i)\n+{\n+  int asi, n_points;\n+  struct C *seg;\n+\n+  asi = seg_map[active_segs[i]];\n+  seg = &svp->segs[asi];\n+  n_points = seg->n_points;\n+  seg->points = ((struct A *)\n+\t\trealloc (seg->points, (n_points_max[asi] <<= 1) * sizeof (struct A)));\n+  seg->points[n_points] = p;\n+  seg->bbox.y1 = p.y;\n+  seg->n_points++;\n+}\n+\n+struct D *\n+test (struct D *vp)\n+{\n+  int *active_segs, n_active_segs, *cursor, seg_idx;\n+  double y, share_x;\n+  int tmp1, tmp2, asi, i, j, *n_ips, *n_ips_max, n_segs_max;\n+  struct A **ips, p_curs, *pts;\n+  struct D *new_vp;\n+  int *n_points_max, *seg_map, first_share;\n+\n+  n_segs_max = 16;\n+  new_vp = (struct D *) malloc (sizeof (struct D) +\n+\t\t\t\t(n_segs_max - 1) * sizeof (struct C));\n+  new_vp->n_segs = 0;\n+\n+  if (vp->n_segs == 0)\n+    return new_vp;\n+\n+  active_segs = ((int *) malloc ((vp->n_segs) * sizeof (int)));\n+  cursor = ((int *) malloc ((vp->n_segs) * sizeof (int)));\n+\n+  seg_map = ((int *) malloc ((vp->n_segs) * sizeof (int)));\n+  n_ips = ((int *) malloc ((vp->n_segs) * sizeof (int)));\n+  n_ips_max = ((int *) malloc ((vp->n_segs) * sizeof (int)));\n+  ips = ((struct A * *) malloc ((vp->n_segs) * sizeof (struct A *)));\n+\n+  n_points_max = ((int *) malloc ((n_segs_max) * sizeof (int)));\n+\n+  n_active_segs = 0;\n+  seg_idx = 0;\n+  y = vp->segs[0].points[0].y;\n+  while (seg_idx < vp->n_segs || n_active_segs > 0)\n+    {\n+      for (i = 0; i < n_active_segs; i++)\n+\t{\n+\t  asi = active_segs[i];\n+\t  if (vp->segs[asi].n_points - 1 == cursor[asi] &&\n+\t      vp->segs[asi].points[cursor[asi]].y == y)\n+\t    i--;\n+\t}\n+\n+      while (seg_idx < vp->n_segs && y == vp->segs[seg_idx].points[0].y)\n+\t{\n+\t  cursor[seg_idx] = 0;\n+\t  n_ips[seg_idx] = 1;\n+\t  n_ips_max[seg_idx] = 2;\n+\t  ips[seg_idx] =\n+\t    ((struct A *) malloc ((n_ips_max[seg_idx]) * sizeof (struct A)));\n+\t  ips[seg_idx][0] = vp->segs[seg_idx].points[0];\n+\t  pts = ((struct A *) malloc ((16) * sizeof (struct A)));\n+\t  pts[0] = vp->segs[seg_idx].points[0];\n+\t  tmp1 = seg_idx;\n+\t  for (j = i; j < n_active_segs; j++)\n+\t    {\n+\t      tmp2 = active_segs[j];\n+\t      active_segs[j] = tmp1;\n+\t      tmp1 = tmp2;\n+\t    }\n+\t  active_segs[n_active_segs] = tmp1;\n+\t  n_active_segs++;\n+\t  seg_idx++;\n+\t}\n+      first_share = -1;\n+      share_x = 0;\n+\n+      for (i = 0; i < n_active_segs; i++)\n+\t{\n+\t  asi = active_segs[i];\n+\t  p_curs = ips[asi][1];\n+\t  if (p_curs.y == y)\n+\t    {\n+\t      bar (new_vp, n_points_max,\n+\t\t   p_curs, seg_map, active_segs, i);\n+\n+\t      n_ips[asi]--;\n+\t      for (j = 0; j < n_ips[asi]; j++)\n+\t\tips[asi][j] = ips[asi][j + 1];\n+\n+\t      if (first_share < 0 || p_curs.x != share_x)\n+\t\t{\n+\t\t  foo (first_share, i,\n+\t\t       active_segs, n_active_segs,\n+\t\t       cursor, ips, n_ips, n_ips_max, vp, seg_map,\n+\t\t       &new_vp, &n_segs_max, &n_points_max);\n+\t\t  first_share = i;\n+\t\t  share_x = p_curs.x;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      foo (first_share, i,\n+\t\t   active_segs, n_active_segs,\n+\t\t   cursor, ips, n_ips, n_ips_max, vp, seg_map,\n+\t\t   &new_vp, &n_segs_max, &n_points_max);\n+\t      first_share = -1;\n+\t    }\n+\t}\n+    }\n+  return new_vp;\n+}"}]}