{"sha": "be2861fe8c527a5952257462ceca899bb43b1452", "node_id": "C_kwDOANBUbNoAKGJlMjg2MWZlOGM1MjdhNTk1MjI1NzQ2MmNlY2E4OTliYjQzYjE0NTI", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-06-03T06:59:03Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-06-03T06:59:03Z"}, "message": "[PR105665] ivopts: check defs of names in base for undefs\n\nThe patch for PR 100810 tested for undefined SSA_NAMEs appearing\ndirectly in the base expression of the potential IV candidate, but\nthat's not enough.  The testcase for PR105665 shows an undefined\nSSA_NAME has the same ill effect if it's referenced as an PHI_NODE arg\nin the referenced SSA_NAME.  The variant of that test shows it can be\nfurther removed from the referenced SSA_NAME.\n\nTo avoid deep recursion, precompute maybe-undefined SSA_NAMEs: start\nfrom known-undefined nonvirtual default defs, and propagate them to\nany PHI nodes reached by a maybe-undefined arg, as long as there\naren't intervening non-PHI uses, that would imply the maybe-undefined\nname must be defined at that point, otherwise it would invoke\nundefined behavior.  Also test for intervening non-PHI uses of DEFs in\nthe base expr.\n\nThe test for intervening uses implemented herein relies on dominance;\nthis could be further extended, regarding conditional uses in every\npath leading to a point as an unconditional use dominating that point,\nbut I haven't implemented that.\n\n\nfor  gcc/ChangeLog\n\n\tPR tree-optimization/105665\n\tPR tree-optimization/100810\n\t* tree-ssa-loop-ivopts.cc\n\t(ssa_name_maybe_undef_p, ssa_name_set_maybe_undef): New.\n\t(ssa_name_any_use_dominates_bb_p, mark_ssa_maybe_undefs): New.\n\t(find_ssa_undef): Check precomputed flag and intervening uses.\n\t(tree_ssa_iv_optimize): Call mark_ssa_maybe_undefs.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR tree-optimization/105665\n\tPR tree-optimization/100810\n\t* gcc.dg/torture/pr105665.c: New.", "tree": {"sha": "e21344bd929f923cc1a013a6c36a19bc0f9a7722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e21344bd929f923cc1a013a6c36a19bc0f9a7722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be2861fe8c527a5952257462ceca899bb43b1452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2861fe8c527a5952257462ceca899bb43b1452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2861fe8c527a5952257462ceca899bb43b1452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2861fe8c527a5952257462ceca899bb43b1452/comments", "author": null, "committer": null, "parents": [{"sha": "39ab2e4c3921136136cdb08ca5c81bd0c3fe7d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ab2e4c3921136136cdb08ca5c81bd0c3fe7d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ab2e4c3921136136cdb08ca5c81bd0c3fe7d73"}], "stats": {"total": 145, "additions": 141, "deletions": 4}, "files": [{"sha": "34cfc65843495359307a8f046ec883987d9954af", "filename": "gcc/testsuite/gcc.dg/torture/pr105665.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be2861fe8c527a5952257462ceca899bb43b1452/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105665.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be2861fe8c527a5952257462ceca899bb43b1452/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105665.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105665.c?ref=be2861fe8c527a5952257462ceca899bb43b1452", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+\n+int a, b, c[1], d[2], *e = c;\n+int main() {\n+  int f = 0;\n+  for (; b < 2; b++) {\n+    int g;\n+    if (f)\n+      g++, b = 40;\n+    a = d[b * b];\n+    for (f = 0; f < 3; f++) {\n+      if (e)\n+        break;\n+      g--;\n+      if (a)\n+        a = g;\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "549168aebd632a63023f9ec2c92d74300ee208d5", "filename": "gcc/tree-ssa-loop-ivopts.cc", "status": "modified", "additions": 121, "deletions": 4, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be2861fe8c527a5952257462ceca899bb43b1452/gcc%2Ftree-ssa-loop-ivopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be2861fe8c527a5952257462ceca899bb43b1452/gcc%2Ftree-ssa-loop-ivopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.cc?ref=be2861fe8c527a5952257462ceca899bb43b1452", "patch": "@@ -3071,13 +3071,129 @@ get_loop_invariant_expr (struct ivopts_data *data, tree inv_expr)\n   return *slot;\n }\n \n-/* Find the first undefined SSA name in *TP.  */\n+/* Return TRUE iff VAR is marked as maybe-undefined.  See\n+   mark_ssa_maybe_undefs.  */\n+\n+static inline bool\n+ssa_name_maybe_undef_p (tree var)\n+{\n+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n+  return TREE_VISITED (var);\n+}\n+\n+/* Set (or clear, depending on VALUE) VAR's maybe-undefined mark.  */\n+\n+static inline void\n+ssa_name_set_maybe_undef (tree var, bool value = true)\n+{\n+  gcc_checking_assert (TREE_CODE (var) == SSA_NAME);\n+  TREE_VISITED (var) = value;\n+}\n+\n+/* Return TRUE iff there are any non-PHI uses of VAR that dominate the\n+   end of BB.  If we return TRUE and BB is a loop header, then VAR we\n+   be assumed to be defined within the loop, even if it is marked as\n+   maybe-undefined.  */\n+\n+static inline bool\n+ssa_name_any_use_dominates_bb_p (tree var, basic_block bb)\n+{\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    {\n+      if (is_a <gphi *> (USE_STMT (use_p))\n+\t  || is_gimple_debug (USE_STMT (use_p)))\n+\tcontinue;\n+      basic_block dombb = gimple_bb (USE_STMT (use_p));\n+      if (dominated_by_p (CDI_DOMINATORS, bb, dombb))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Mark as maybe_undef any SSA_NAMEs that are unsuitable as ivopts\n+   candidates for potentially involving undefined behavior.  */\n+\n+static void\n+mark_ssa_maybe_undefs (void)\n+{\n+  auto_vec<tree> queue;\n+\n+  /* Scan all SSA_NAMEs, marking the definitely-undefined ones as\n+     maybe-undefined and queuing them for propagation, while clearing\n+     the mark on others.  */\n+  unsigned int i;\n+  tree var;\n+  FOR_EACH_SSA_NAME (i, var, cfun)\n+    {\n+      if (SSA_NAME_IS_VIRTUAL_OPERAND (var)\n+\t  || !ssa_undefined_value_p (var, false))\n+\tssa_name_set_maybe_undef (var, false);\n+      else\n+\t{\n+\t  ssa_name_set_maybe_undef (var);\n+\t  queue.safe_push (var);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"marking _%i as maybe-undef\\n\",\n+\t\t     SSA_NAME_VERSION (var));\n+\t}\n+    }\n+\n+  /* Now propagate maybe-undefined from a DEF to any other PHI that\n+     uses it, as long as there isn't any intervening use of DEF.  */\n+  while (!queue.is_empty ())\n+    {\n+      var = queue.pop ();\n+      imm_use_iterator iter;\n+      use_operand_p use_p;\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+\t{\n+\t  /* Any uses of VAR that aren't PHI args imply VAR must be\n+\t     defined, otherwise undefined behavior would have been\n+\t     definitely invoked.  Only PHI args may hold\n+\t     maybe-undefined values without invoking undefined\n+\t     behavior for that reason alone.  */\n+\t  if (!is_a <gphi *> (USE_STMT (use_p)))\n+\t    continue;\n+\t  gphi *phi = as_a <gphi *> (USE_STMT (use_p));\n+\n+\t  tree def = gimple_phi_result (phi);\n+\t  if (ssa_name_maybe_undef_p (def))\n+\t    continue;\n+\n+\t  /* Look for any uses of the maybe-unused SSA_NAME that\n+\t     dominates the block that reaches the incoming block\n+\t     corresponding to the PHI arg in which it is mentioned.\n+\t     That means we can assume the SSA_NAME is defined in that\n+\t     path, so we only mark a PHI result as maybe-undef if we\n+\t     find an unused reaching SSA_NAME.  */\n+\t  int idx = phi_arg_index_from_use (use_p);\n+\t  basic_block bb = gimple_phi_arg_edge (phi, idx)->src;\n+\t  if (ssa_name_any_use_dominates_bb_p (var, bb))\n+\t    continue;\n+\n+\t  ssa_name_set_maybe_undef (def);\n+\t  queue.safe_push (def);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"marking _%i as maybe-undef because of _%i\\n\",\n+\t\t     SSA_NAME_VERSION (def), SSA_NAME_VERSION (var));\n+\t}\n+    }\n+}\n+\n+/* Return *TP if it is an SSA_NAME marked with TREE_VISITED, i.e., as\n+   unsuitable as ivopts candidates for potentially involving undefined\n+   behavior.  */\n \n static tree\n-find_ssa_undef (tree *tp, int *walk_subtrees, void *)\n+find_ssa_undef (tree *tp, int *walk_subtrees, void *bb_)\n {\n+  basic_block bb = (basic_block) bb_;\n   if (TREE_CODE (*tp) == SSA_NAME\n-      && ssa_undefined_value_p (*tp, false))\n+      && ssa_name_maybe_undef_p (*tp)\n+      && !ssa_name_any_use_dominates_bb_p (*tp, bb))\n     return *tp;\n   if (!EXPR_P (*tp))\n     *walk_subtrees = 0;\n@@ -3114,7 +3230,7 @@ add_candidate_1 (struct ivopts_data *data, tree base, tree step, bool important,\n   /* If BASE contains undefined SSA names make sure we only record\n      the original IV.  */\n   bool involves_undefs = false;\n-  if (walk_tree (&base, find_ssa_undef, NULL, NULL))\n+  if (walk_tree (&base, find_ssa_undef, data->current_loop->header, NULL))\n     {\n       if (pos != IP_ORIGINAL)\n \treturn NULL;\n@@ -8192,6 +8308,7 @@ tree_ssa_iv_optimize (void)\n   auto_bitmap toremove;\n \n   tree_ssa_iv_optimize_init (&data);\n+  mark_ssa_maybe_undefs ();\n \n   /* Optimize the loops starting with the innermost ones.  */\n   for (auto loop : loops_list (cfun, LI_FROM_INNERMOST))"}]}