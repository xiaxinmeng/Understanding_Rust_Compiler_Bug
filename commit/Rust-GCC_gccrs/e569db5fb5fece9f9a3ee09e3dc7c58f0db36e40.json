{"sha": "e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2OWRiNWZiNWZlY2U5ZjlhM2VlMDllM2RjN2M1OGYwZGIzNmU0MA==", "commit": {"author": {"name": "Venkataramanan Kumar", "email": "venkataramanan.kumar@amd.com", "date": "2016-05-23T09:48:54Z"}, "committer": {"name": "Venkataramanan Kumar", "email": "vekumar@gcc.gnu.org", "date": "2016-05-23T09:48:54Z"}, "message": "re PR tree-optimization/58135 ([x86] Missed opportunities for partial SLP)\n\nFix PR58135.\n\n2016-05-23  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n\n\tPR tree-optimization/58135\n\t* tree-vect-slp.c: When group size is not multiple\n\tof vector size, allow splitting of store group at\n\tvector boundary.\n\n2016-05-23  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n\n\t* gcc.dg/vect/bb-slp-19.c:  Remove XFAIL.\n\t* gcc.dg/vect/pr58135.c:  Add new.\n\t* gfortran.dg/pr46519-1.f: Adjust test case.\n\nFrom-SVN: r236582", "tree": {"sha": "48036aca109da55b9eeb6b0c3a90a81825bd9489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48036aca109da55b9eeb6b0c3a90a81825bd9489"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/comments", "author": null, "committer": null, "parents": [{"sha": "e4b7111409eaf52d327a92c32a4ddf7d6e33d47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b7111409eaf52d327a92c32a4ddf7d6e33d47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b7111409eaf52d327a92c32a4ddf7d6e33d47b"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "56ccb0ef7c9e27a6543732c0cd325799be1a3eac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -1,3 +1,10 @@\n+2016-05-23  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n+\n+\tPR tree-optimization/58135\n+\t* tree-vect-slp.c: When group size is not multiple\n+\tof vector size, allow splitting of store group at\n+\tvector boundary.\n+\n 2016-05-23  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* config/arm/arm_neon.h (vtst_p16, vtstq_p16): New."}, {"sha": "b0ba70f85c79ad72caec2e8df90cbe5d74f4fd45", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -1,3 +1,9 @@\n+2016-05-23  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n+\n+\t* gcc.dg/vect/bb-slp-19.c:  Remove XFAIL. \n+\t* gcc.dg/vect/pr58135.c:  Add new.\n+\t* gfortran.dg/pr46519-1.f: Adjust test case.\n+\n 2016-05-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53401"}, {"sha": "c2821551c8628ea70baa8389518c6a0e27bf6744", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -53,5 +53,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\"  { xfail *-*-* }  } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */\n   "}, {"sha": "ca250000c8534ee4ea07441bb3ae4bdea8efbc09", "filename": "gcc/testsuite/gcc.dg/vect/pr58135.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr58135.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr58135.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr58135.c?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+int a[100];\n+void foo ()\n+{\n+  a[0] = a[1] = a[2] = a[3] = a[4]= 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */"}, {"sha": "46be9f590ddec7d865422ed8847bf6a2cf267930", "filename": "gcc/testsuite/gfortran.dg/pr46519-1.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-1.f?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile { target i?86-*-* x86_64-*-* } }\n-! { dg-options \"-O3 -mavx -mvzeroupper -mtune=generic -dp\" }\n+! { dg-options \"-O3 -mavx -mvzeroupper -fno-tree-slp-vectorize -mtune=generic -dp\" }\n \n       PROGRAM MG3XDEMO \n       INTEGER LM, NM, NV, NR, NIT"}, {"sha": "3de53d1188c690cddc2a95ee4d0dde7628fde004", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e569db5fb5fece9f9a3ee09e3dc7c58f0db36e40", "patch": "@@ -1757,18 +1757,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n     }\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  /* Calculate the unrolling factor.  */\n-  unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n-  if (unrolling_factor != 1 && is_a <bb_vec_info> (vinfo))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"Build SLP failed: unrolling required in basic\"\n-\t\t\t \" block SLP\\n\");\n-\n-      return false;\n-    }\n-\n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n   next = stmt;\n@@ -1804,26 +1792,36 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n-  if ((node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n+  node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n \t\t\t\t   &max_nunits, &loads, matches, &npermutes,\n-\t\t\t\t   NULL, max_tree_size)) != NULL)\n+\t\t\t      NULL, max_tree_size);\n+  if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n-      if (max_nunits > nunits)\n-        unrolling_factor = least_common_multiple (max_nunits, group_size)\n-                           / group_size;\n+      unrolling_factor\n+\t= least_common_multiple (max_nunits, group_size) / group_size;\n+\n+      if (unrolling_factor != 1\n+\t  && is_a <bb_vec_info> (vinfo))\n+\t{\n \n-      if (unrolling_factor != 1 && is_a <bb_vec_info> (vinfo))\n+\t  if (max_nunits > group_size)\n         {\n-          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Build SLP failed: unrolling required in basic\"\n-\t\t\t     \" block SLP\\n\");\n+\t\t\t       \"Build SLP failed: store group \"\n+\t\t\t       \"size not a multiple of the vector size \"\n+\t\t\t       \"in basic block SLP\\n\");\n \t  vect_free_slp_tree (node);\n \t  loads.release ();\n           return false;\n         }\n-\n+\t  /* Fatal mismatch.  */\n+\t  matches[group_size/max_nunits * max_nunits] = false;\n+\t  vect_free_slp_tree (node);\n+\t  loads.release ();\n+\t}\n+      else\n+\t{\n       /* Create a new SLP instance.  */\n       new_instance = XNEW (struct _slp_instance);\n       SLP_INSTANCE_TREE (new_instance) = node;\n@@ -1845,8 +1843,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n \t    {\n-\t      int load_place\n-\t\t= vect_get_place_in_interleaving_chain (load, first_stmt);\n+\t\t  int load_place = vect_get_place_in_interleaving_chain\n+\t\t\t\t     (load, first_stmt);\n \t      gcc_assert (load_place != -1);\n \t      if (load_place != j)\n \t\tthis_load_permuted = true;\n@@ -1876,15 +1874,16 @@ vect_analyze_slp_instance (vec_info *vinfo,\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"Build SLP failed: unsupported load \"\n \t\t\t\t   \"permutation \");\n-                  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t\tTDF_SLIM, stmt, 0);\n                   dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                 }\n               vect_free_slp_instance (new_instance);\n               return false;\n             }\n         }\n \n-      /* If the loads and stores can be handled with load/store-lane\n+\t  /* If the loads and stores can be handled with load/store-lan\n \t instructions do not generate this SLP instance.  */\n       if (is_a <loop_vec_info> (vinfo)\n \t  && loads_permuted\n@@ -1896,7 +1895,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      gimple *first_stmt = GROUP_FIRST_ELEMENT\n \t\t  (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (load_node)[0]));\n \t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (first_stmt);\n-\t      /* Use SLP for strided accesses (or if we can't load-lanes).  */\n+\t\t  /* Use SLP for strided accesses (or if we\n+\t\t     can't load-lanes).  */\n \t      if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n \t\t  || ! vect_load_lanes_supported\n \t\t\t(STMT_VINFO_VECTYPE (stmt_vinfo),\n@@ -1925,11 +1925,14 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n       return true;\n     }\n-\n+    }\n+  else\n+    {\n   /* Failed to SLP.  */\n   /* Free the allocated memory.  */\n   scalar_stmts.release ();\n   loads.release ();\n+    }\n \n   /* For basic block SLP, try to break the group up into multiples of the\n      vector size.  */"}]}