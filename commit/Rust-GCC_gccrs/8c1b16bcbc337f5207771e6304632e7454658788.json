{"sha": "8c1b16bcbc337f5207771e6304632e7454658788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxYjE2YmNiYzMzN2Y1MjA3NzcxZTYzMDQ2MzJlNzQ1NDY1ODc4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-08-29T15:41:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-08-29T15:41:45Z"}, "message": "re PR ada/21053 (Warnings from init.c)\n\n2005-08-29  Arnaud Charlet  <charlet@adacore.com>\n\t    Doug Rupp  <rupp@adacore.com>\n\n\t* s-stalib.adb: Add missing pragma Warnings (On) to reenable Warnings\n\twhen needed.\n\t(Inside_Elab_Final_Code): Moved to init.c to avoid having to keep\n\tthis code in the GNAT run-time.\n\n\t* decl.c, fe.h: Replace GCC_ZCX by Back_End_Exceptions.\n\n\tPR ada/21053\n\t* init.c (__gnat_error_handler [many]): Mark \"msg\" as const\n\t(__gnat_error_handler [HPUX]): Mark siginfo parameter as unused\n\n\t(__gnat_inside_elab_final_code): Moved here from\n\tStandard_Library and only defined for the compiler.\n\t__gnat_error_handler [VMS]: Adjust sigargs to account for PC & PSL.\n\t(__gnat_inum_to_ivec): Do not define this function on VxWorks when\n\tusing RTPs because directly vectored Interrupt routines are not\n\tsupported on this configuration.\n\t(getpid): Do not redefine this function on VxWorks when using RTPs\n\tbecause this primitive is well supported by the RTP libraries.\n\t(copy_msg): Correct the code that checks for buffer overflow.\n\tDiscovered during code reading.\n\nFrom-SVN: r103606", "tree": {"sha": "be2a5f4c6ed1ddb1400c50e75831f84c8a404728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be2a5f4c6ed1ddb1400c50e75831f84c8a404728"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c1b16bcbc337f5207771e6304632e7454658788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1b16bcbc337f5207771e6304632e7454658788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1b16bcbc337f5207771e6304632e7454658788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1b16bcbc337f5207771e6304632e7454658788/comments", "author": null, "committer": null, "parents": [{"sha": "b794e321c163674e83fa0b8f7a7aa1b4359c918c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b794e321c163674e83fa0b8f7a7aa1b4359c918c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b794e321c163674e83fa0b8f7a7aa1b4359c918c"}], "stats": {"total": 166, "additions": 72, "deletions": 94}, "files": [{"sha": "701501e88896d8a8f6e4695eb8d2d5ce653d46f8", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=8c1b16bcbc337f5207771e6304632e7454658788", "patch": "@@ -497,6 +497,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t || Present (Renamed_Object (gnat_entity))));\n \tbool inner_const_flag = const_flag;\n \tbool static_p = Is_Statically_Allocated (gnat_entity);\n+\tbool mutable_p = false;\n \ttree gnu_ext_name = NULL_TREE;\n \ttree renamed_obj = NULL_TREE;\n \n@@ -594,7 +595,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t     (Etype\n \t\t\t      (Expression (Declaration_Node (gnat_entity)))));\n \t    else\n-\t      gnu_size = max_size (TYPE_SIZE (gnu_type), true);\n+\t      {\n+\t\tgnu_size = max_size (TYPE_SIZE (gnu_type), true);\n+\t\tmutable_p = true;\n+\t      }\n \t  }\n \n \t/* If the size is zero bytes, make it one byte since some linkers have\n@@ -928,7 +932,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       If we have a template initializer only (that we made above),\n \t       pretend there is none and rely on what build_allocator creates\n \t       again anyway.  Otherwise (if we have a full initializer), get\n-\t       the data part and feed that to build_allocator.  */\n+\t       the data part and feed that to build_allocator.\n+\n+\t       If we are elaborating a mutable object, tell build_allocator to\n+\t       ignore a possibly simpler size from the initializer, if any, as\n+\t       we must allocate the maximum possible size in this case.  */\n \n \t    if (definition)\n \t      {\n@@ -959,7 +967,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t      gnat_entity);\n \n \t\tgnu_expr = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n-\t\t\t\t\t    0, 0, gnat_entity, false);\n+\t\t\t\t\t    0, 0, gnat_entity, mutable_p);\n \t      }\n \t    else\n \t      {\n@@ -1104,7 +1112,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   exception handler, we must force this variable in memory to\n \t   suppress an invalid optimization.  */\n \tif (Has_Nested_Block_With_Handler (Scope (gnat_entity))\n-\t    && Exception_Mechanism != GCC_ZCX)\n+\t    && Exception_Mechanism != Back_End_Exceptions)\n \t  TREE_ADDRESSABLE (gnu_decl) = 1;\n \n \t/* Back-annotate the Alignment of the object if not already in the"}, {"sha": "5e49ab9c6e7d6ed3bc68d3c41188302a15c880f8", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=8c1b16bcbc337f5207771e6304632e7454658788", "patch": "@@ -155,7 +155,7 @@ extern Boolean In_Same_Source_Unit              (Node_Id, Node_Id);\n #define Exception_Mechanism            opt__exception_mechanism\n #define Back_Annotate_Rep_Info         opt__back_annotate_rep_info\n \n-typedef enum {Setjmp_Longjmp, Front_End_ZCX, GCC_ZCX} Exception_Mechanism_Type;\n+typedef enum {Setjmp_Longjmp, Back_End_Exceptions} Exception_Mechanism_Type;\n \n extern Boolean Global_Discard_Names;\n extern Boolean Exception_Locations_Suppressed;"}, {"sha": "8e2a222bf992078fb9ffd37762c58e26f1ecbbdc", "filename": "gcc/ada/init.c", "status": "modified", "additions": 53, "deletions": 80, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=8c1b16bcbc337f5207771e6304632e7454658788", "patch": "@@ -80,10 +80,6 @@ extern void (*Lock_Task) (void);\n #define Unlock_Task system__soft_links__unlock_task\n extern void (*Unlock_Task) (void);\n \n-#define Get_Machine_State_Addr \\\n-                      system__soft_links__get_machine_state_addr\n-extern struct Machine_State *(*Get_Machine_State_Addr) (void);\n-\n #define Check_Abort_Status     \\\n                       system__soft_links__check_abort_status\n extern int (*Check_Abort_Status) (void);\n@@ -92,12 +88,6 @@ extern int (*Check_Abort_Status) (void);\n                       ada__exceptions__raise_from_signal_handler\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n \n-#define Propagate_Signal_Exception \\\n-                      __gnat_propagate_sig_exc\n-extern void Propagate_Signal_Exception (struct Machine_State *,\n-                                        struct Exception_Data *,\n-                                        const char *);\n-\n /* Copies of global values computed by the binder */\n int   __gl_main_priority            = -1;\n int   __gl_time_slice_val           = -1;\n@@ -117,6 +107,12 @@ int   __gl_detect_blocking          = 0;\n    installed by a previous call to adainit */\n int  __gnat_handler_installed      = 0;\n \n+#ifndef IN_RTS\n+int __gnat_inside_elab_final_code = 0;\n+/* ??? This variable is obsolete since 2001-08-29 but is kept to allow\n+   bootstrap from old GNAT versions (< 3.15). */\n+#endif\n+\n /* HAVE_GNAT_INIT_FLOAT must be set on every targets where a __gnat_init_float\n    is defined. If this is not set them a void implementation will be defined\n    at the end of this unit. */\n@@ -405,18 +401,14 @@ __gnat_install_handler (void)\n static void __gnat_error_handler (int, siginfo_t *, struct sigcontext *);\n extern char *__gnat_get_code_loc (struct sigcontext *);\n extern void __gnat_set_code_loc (struct sigcontext *, char *);\n-extern void __gnat_enter_handler (struct sigcontext *, char *);\n extern size_t __gnat_machine_state_length (void);\n \n-extern long exc_lookup_gp (char *);\n-extern void exc_resume (struct sigcontext *);\n-\n static void\n-__gnat_error_handler (int sig, siginfo_t *sip, struct sigcontext *context)\n+__gnat_error_handler\n+  (int sig, siginfo_t *sip, struct sigcontext *context ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n-  struct sigcontext *mstate;\n   const char *msg;\n \n   /* If this was an explicit signal from a \"kill\", just resignal it.  */\n@@ -474,10 +466,6 @@ __gnat_error_handler (int sig, siginfo_t *sip, struct sigcontext *context)\n     }\n \n   recurse = 0;\n-  mstate = (struct sigcontext *) (*Get_Machine_State_Addr) ();\n-  if (mstate != 0)\n-    *mstate = *context;\n-\n   Raise_From_Signal_Handler (exception, (char *) msg);\n }\n \n@@ -526,14 +514,6 @@ __gnat_set_code_loc (struct sigcontext *context, char *pc)\n }\n \n \n-void\n-__gnat_enter_handler (struct sigcontext *context, char *pc)\n-{\n-  context->sc_pc = (long) pc;\n-  context->sc_regs[SC_GP] = exc_lookup_gp (pc);\n-  exc_resume (context);\n-}\n-\n size_t\n __gnat_machine_state_length (void)\n {\n@@ -569,10 +549,11 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n }\n \n static void\n-__gnat_error_handler (int sig, siginfo_t *siginfo, void *ucontext)\n+__gnat_error_handler\n+  (int sig, siginfo_t *siginfo ATTRIBUTE_UNUSED, void *ucontext)\n {\n   struct Exception_Data *exception;\n-  char *msg;\n+  const char *msg;\n \n   switch (sig)\n     {\n@@ -800,7 +781,7 @@ static void\n __gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n-  char *msg;\n+  const char *msg;\n \n   switch (sig)\n     {\n@@ -870,11 +851,6 @@ __gnat_install_handler (void)\n #define SIGNAL_STACK_SIZE 4096\n #define SIGNAL_STACK_ALIGNMENT 64\n \n-struct Machine_State\n-{\n-  sigcontext_t context;\n-};\n-\n static void __gnat_error_handler (int, int, sigcontext_t *);\n \n /* We are not setting the SA_SIGINFO bit in the sigaction flags when\n@@ -890,9 +866,8 @@ static void __gnat_error_handler (int, int, sigcontext_t *);\n */\n \n static void\n-__gnat_error_handler (int sig, int code, sigcontext_t *sc)\n+__gnat_error_handler (int sig, int code, sigcontext_t *sc ATTRIBUTE_UNUSED)\n {\n-  struct Machine_State  *mstate;\n   struct Exception_Data *exception;\n   const char *msg;\n \n@@ -967,10 +942,6 @@ __gnat_error_handler (int sig, int code, sigcontext_t *sc)\n       msg = \"unhandled signal\";\n     }\n \n-  mstate = (*Get_Machine_State_Addr) ();\n-  if (mstate != 0)\n-    memcpy ((void *) mstate, (const void *) sc, sizeof (sigcontext_t));\n-\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1389,7 +1360,7 @@ copy_msg (msgdesc, message)\n   /* Check for buffer overflow and truncate if necessary */\n   copy_len = (len + msgdesc->len <= Default_Exception_Msg_Max_Length - 1 ?\n \t      msgdesc->len :\n-\t      len + msgdesc->len - Default_Exception_Msg_Max_Length);\n+\t      Default_Exception_Msg_Max_Length - 1 - len);\n   strncpy (&message [len], msgdesc->adr, copy_len);\n   message [len + copy_len] = 0;\n \n@@ -1404,10 +1375,9 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n   struct descriptor_s gnat_facility = {4,0,\"GNAT\"};\n   char message [Default_Exception_Msg_Max_Length];\n \n-  char *msg = \"\";\n+  const char *msg = \"\";\n   char curr_icb[544];\n   long curr_invo_handle;\n-  long *mstate;\n \n   /* Check for conditions to resignal which aren't effected by pragma\n      Import_Exception.  */\n@@ -1423,7 +1393,11 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n   if (exception)\n     {\n       message [0] = 0;\n+\n+      /* Subtract PC & PSL fields which messes with PUTMSG */\n+      sigargs [0] -= 2;\n       SYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n+      sigargs [0] += 2;\n       msg = message;\n \n       exception->Name_Length = 19;\n@@ -1470,24 +1444,20 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n \t{\n \t  int i;\n \n-\t  /* Scan the DEC Ada exception condition table for a match and fetch the\n-\t     associated GNAT exception pointer */\n+\t  /* Scan the DEC Ada exception condition table for a match and fetch\n+\t     the associated GNAT exception pointer */\n \t  for (i = 0;\n \t       dec_ada_cond_except_table [i].cond &&\n-\t       !LIB$MATCH_COND (&sigargs [1], &dec_ada_cond_except_table [i].cond);\n+\t       !LIB$MATCH_COND (&sigargs [1],\n+\t\t\t        &dec_ada_cond_except_table [i].cond);\n \t       i++);\n-\t  exception = (struct Exception_Data *) dec_ada_cond_except_table [i].except;\n-\n-\t  if (exception)\n-\t    /* DEC Ada exceptions never have a PC and PSL appended, but LIB$STOP\n-\t       (which is how we got here from Bliss code)\n-\t       allows slots for them and the result is 2 words of garbage on the\n-\t       end, so the count must be decremented. */\n-\t    sigargs [0] -= 2;\n-\t  else\n+\t  exception = (struct Exception_Data *)\n+\t    dec_ada_cond_except_table [i].except;\n+\n+\t  if (!exception)\n \t    {\n-\t      /* Scan the VMS standard condition table for a match and fetch the\n-\t\t associated GNAT exception pointer */\n+\t      /* Scan the VMS standard condition table for a match and fetch\n+\t\t the associated GNAT exception pointer */\n \t      for (i = 0;\n \t\t   cond_except_table [i].cond &&\n \t\t   !LIB$MATCH_COND (&sigargs [1], &cond_except_table [i].cond);\n@@ -1504,20 +1474,14 @@ __gnat_error_handler (int *sigargs, void *mechargs)\n \texception = &program_error;\n #endif\n \tmessage [0] = 0;\n+\t/* Subtract PC & PSL fields which messes with PUTMSG */\n+\tsigargs [0] -= 2;\n \tSYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n+\tsigargs [0] += 2;\n \tmsg = message;\n \tbreak;\n       }\n \n-  mstate = (long *) (*Get_Machine_State_Addr) ();\n-  if (mstate != 0)\n-    {\n-      lib_get_curr_invo_context (&curr_icb);\n-      lib_get_prev_invo_context (&curr_icb);\n-      lib_get_prev_invo_context (&curr_icb);\n-      curr_invo_handle = lib_get_invo_handle (&curr_icb);\n-      *mstate = curr_invo_handle;\n-    }\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n@@ -1618,21 +1582,37 @@ __gnat_install_handler ()\n \n #include <signal.h>\n #include <taskLib.h>\n+\n+#ifndef __RTP__\n #include <intLib.h>\n #include <iv.h>\n+#endif\n \n #ifdef VTHREADS\n #include \"private/vThreadsP.h\"\n #endif\n \n-extern int __gnat_inum_to_ivec (int);\n static void __gnat_error_handler (int, int, struct sigcontext *);\n void __gnat_map_signal (int);\n \n-#ifndef __alpha_vxworks\n+#ifndef __RTP__\n+\n+/* Directly vectored Interrupt routines are not supported when using RTPs */\n+\n+extern int __gnat_inum_to_ivec (int);\n+\n+/* This is needed by the GNAT run time to handle Vxworks interrupts */\n+int\n+__gnat_inum_to_ivec (int num)\n+{\n+  return INUM_TO_IVEC (num);\n+}\n+#endif\n+\n+#if !defined(__alpha_vxworks) && (_WRS_VXWORKS_MAJOR != 6) && !defined(__RTP__)\n \n /* getpid is used by s-parint.adb, but is not defined by VxWorks, except\n-   on Alpha VxWorks */\n+   on Alpha VxWorks and VxWorks 6.x (including RTPs). */\n \n extern long getpid (void);\n \n@@ -1643,13 +1623,6 @@ getpid (void)\n }\n #endif\n \n-/* This is needed by the GNAT run time to handle Vxworks interrupts */\n-int\n-__gnat_inum_to_ivec (int num)\n-{\n-  return INUM_TO_IVEC (num);\n-}\n-\n /* VxWorks expects the field excCnt to be zeroed when a signal is handled.\n    The VxWorks version of longjmp does this; gcc's builtin_longjmp does not */\n void\n@@ -1662,13 +1635,13 @@ __gnat_clear_exception_count (void)\n #endif\n }\n \n-/* Exported to 5zintman.adb in order to handle different signal\n+/* Exported to s-intman-vxworks.adb in order to handle different signal\n    to exception mappings in different VxWorks versions */\n void\n __gnat_map_signal (int sig)\n {\n   struct Exception_Data *exception;\n-  char *msg;\n+  const char *msg;\n \n   switch (sig)\n     {"}, {"sha": "d1a0a6f1c5a9b78e67097d18cef8748842eb72aa", "filename": "gcc/ada/s-stalib.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Fs-stalib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1b16bcbc337f5207771e6304632e7454658788/gcc%2Fada%2Fs-stalib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stalib.adb?ref=8c1b16bcbc337f5207771e6304632e7454658788", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1995-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1995-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,13 +36,13 @@\n --  of System.Standard_Library, since this would cause order of elaboration\n --  problems (Elaborate_Body would have the same problem).\n \n-pragma Warnings (Off);\n---  Kill warnings from unused withs\n-\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with Ada.Exceptions if polling is on.\n \n+pragma Warnings (Off);\n+--  Kill warnings from unused withs\n+\n with System.Soft_Links;\n --  Referenced directly from generated code using external symbols so it\n --  must always be present in a build, even if no unit has a direct with\n@@ -56,17 +56,14 @@ with System.Memory;\n --  must always be present in a build, even if no unit has a direct with\n --  of this unit.\n \n+pragma Warnings (On);\n+\n package body System.Standard_Library is\n \n    Runtime_Finalized : Boolean := False;\n    --  Set to True when adafinal is called. Used to ensure that subsequent\n    --  calls to adafinal after the first have no effect.\n \n-   Inside_Elab_Final_Code : Integer := 0;\n-   pragma Export (C, Inside_Elab_Final_Code, \"__gnat_inside_elab_final_code\");\n-   --  ???This variable is obsolete since 2001-08-29 but cannot be removed\n-   --  ???right away due to the bootstrap problems\n-\n    --------------------------\n    -- Abort_Undefer_Direct --\n    --------------------------"}]}