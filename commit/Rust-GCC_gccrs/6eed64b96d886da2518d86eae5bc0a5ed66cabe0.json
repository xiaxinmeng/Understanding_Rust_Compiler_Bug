{"sha": "6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVlZDY0Yjk2ZDg4NmRhMjUxOGQ4NmVhZTViYzBhNWVkNjZjYWJlMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-13T09:05:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-13T09:05:59Z"}, "message": "Avoid accounting for non-existent vector loop versioning\n\nvect_analyze_loop_costing uses two profitability thresholds: a runtime\none and a static compile-time one.  The runtime one is simply the point\nat which the vector loop is cheaper than the scalar loop, while the\nstatic one also takes into account the cost of choosing between the\nscalar and vector loops at runtime.  We compare this static cost against\nthe expected execution frequency to decide whether it's worth generating\nany vector code at all.\n\nHowever, we never reclaimed the cost of applying the runtime threshold\nif it turned out that the vector code can always be used.  And we only\nknow whether that's true once we've calculated what the runtime\nthreshold would be.\n\n2019-11-13  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_apply_runtime_profitability_check_p):\n\tNew function.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Use it.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n\t(vect_transform_loop): Likewise.\n\t(vect_analyze_loop_costing): Don't take the cost of versioning\n\tinto account for the static profitability threshold if it turns\n\tout that no versioning is needed.\n\nFrom-SVN: r278124", "tree": {"sha": "37497aa97fda968edca614ae83fa11d8b58c66d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37497aa97fda968edca614ae83fa11d8b58c66d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4b44b834e3ac1b92ffb165e7bdaf641a211c34b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b44b834e3ac1b92ffb165e7bdaf641a211c34b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b44b834e3ac1b92ffb165e7bdaf641a211c34b"}], "stats": {"total": 59, "additions": 48, "deletions": 11}, "files": [{"sha": "e7b04334fb5142462ca00806a03cbdeaf811e9a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "patch": "@@ -1,3 +1,14 @@\n+2019-11-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_apply_runtime_profitability_check_p):\n+\tNew function.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Use it.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n+\t(vect_transform_loop): Likewise.\n+\t(vect_analyze_loop_costing): Don't take the cost of versioning\n+\tinto account for the static profitability threshold if it turns\n+\tout that no versioning is needed.\n+\n 2019-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa.c (cgraph_build_static_cdtor): Pass optimization_default_node"}, {"sha": "beee5fe088e1c128fce448fbdbe4201f8e06d882", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "patch": "@@ -3171,8 +3171,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo)\n     = LOOP_REQUIRES_VERSIONING_FOR_SIMD_IF_COND (loop_vinfo);\n   unsigned th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n \n-  if (th >= vect_vf_for_cost (loop_vinfo)\n-      && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+  if (vect_apply_runtime_profitability_check_p (loop_vinfo)\n       && !ordered_p (th, versioning_threshold))\n     cond_expr = fold_build2 (GE_EXPR, boolean_type_node, scalar_loop_iters,\n \t\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters),"}, {"sha": "83fb8486640d6dda236b98d1b6dad08021b8c7f7", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "patch": "@@ -1690,6 +1690,24 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n       return 0;\n     }\n \n+  /* The static profitablity threshold min_profitable_estimate includes\n+     the cost of having to check at runtime whether the scalar loop\n+     should be used instead.  If it turns out that we don't need or want\n+     such a check, the threshold we should use for the static estimate\n+     is simply the point at which the vector loop becomes more profitable\n+     than the scalar loop.  */\n+  if (min_profitable_estimate > min_profitable_iters\n+      && !LOOP_REQUIRES_VERSIONING (loop_vinfo)\n+      && !LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n+      && !LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+      && !vect_apply_runtime_profitability_check_p (loop_vinfo))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"no need for a runtime\"\n+\t\t\t \" choice between the scalar and vector loops\\n\");\n+      min_profitable_estimate = min_profitable_iters;\n+    }\n+\n   HOST_WIDE_INT estimated_niter;\n \n   /* If we are vectorizing an epilogue then we know the maximum number of\n@@ -2226,8 +2244,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \n       /*  Use the same condition as vect_transform_loop to decide when to use\n \t  the cost to determine a versioning threshold.  */\n-      if (th >= vect_vf_for_cost (loop_vinfo)\n-\t  && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      if (vect_apply_runtime_profitability_check_p (loop_vinfo)\n \t  && ordered_p (th, niters_th))\n \tniters_th = ordered_max (poly_uint64 (th), niters_th);\n \n@@ -8250,14 +8267,13 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      run at least the (estimated) vectorization factor number of times\n      checking is pointless, too.  */\n   th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n-  if (th >= vect_vf_for_cost (loop_vinfo)\n-      && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+  if (vect_apply_runtime_profitability_check_p (loop_vinfo))\n     {\n-\tif (dump_enabled_p ())\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Profitability threshold is %d loop iterations.\\n\",\n-\t\t\t   th);\n-\tcheck_profitability = true;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Profitability threshold is %d loop iterations.\\n\",\n+\t\t\t th);\n+      check_profitability = true;\n     }\n \n   /* Make sure there exists a single-predecessor exit bb.  Do this before "}, {"sha": "56a9a1569931c124b61bdb320ad116ab1fad2824", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eed64b96d886da2518d86eae5bc0a5ed66cabe0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6eed64b96d886da2518d86eae5bc0a5ed66cabe0", "patch": "@@ -1556,6 +1556,17 @@ vect_get_scalar_dr_size (dr_vec_info *dr_info)\n   return tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_info->dr))));\n }\n \n+/* Return true if LOOP_VINFO requires a runtime check for whether the\n+   vector loop is profitable.  */\n+\n+inline bool\n+vect_apply_runtime_profitability_check_p (loop_vec_info loop_vinfo)\n+{\n+  unsigned int th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n+  return (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t  && th >= vect_vf_for_cost (loop_vinfo));\n+}\n+\n /* Source location + hotness information. */\n extern dump_user_location_t vect_location;\n "}]}