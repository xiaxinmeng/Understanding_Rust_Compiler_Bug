{"sha": "665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1ZmNhZDgzNWJiNmFjOWQyZDQxMDc3YmQ3NGI4YmE2NmViZmVjYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-12-08T00:09:30Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-12-08T00:09:30Z"}, "message": "re PR middle-end/17340 (Internal error compiling with -O3)\n\n        PR tree-optimization/17340\n        * tree-ssa-pre.c (compute_antic): Fix comment.\n        (compute_avail): Do not recurse, instead do a DFS using a stack\n        and a loop.\n        (execute_pre): Adjust.\n\nFrom-SVN: r91835", "tree": {"sha": "170d95ee71d8e7f2e8a18434bc3280ada3b2c415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/170d95ee71d8e7f2e8a18434bc3280ada3b2c415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc/comments", "author": null, "committer": null, "parents": [{"sha": "c7baa14599b771e8d118b5cd33423c84a40e5097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7baa14599b771e8d118b5cd33423c84a40e5097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7baa14599b771e8d118b5cd33423c84a40e5097"}], "stats": {"total": 104, "additions": 64, "deletions": 40}, "files": [{"sha": "7542d680cc59fff55da232914f01954ed1a7d127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "patch": "@@ -1,3 +1,11 @@\n+2004-12-07  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR tree-optimization/17340\n+\t* tree-ssa-pre.c (compute_antic): Fix comment.\n+\t(compute_avail): Do not recurse, instead do a DFS using a stack\n+\tand a loop.\n+\t(execute_pre): Adjust.\n+\n 2004-12-07  Ziemowit Laski  <zlaski@apple.com>\n \n \t* c-tree.h (struct lang_type): Rename 'objc_protocols' field"}, {"sha": "87e5d14a7fc57e6cf30ed35c559b47fd85763aaf", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/665fcad835bb6ac9d2d41077bd74b8ba66ebfecc/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=665fcad835bb6ac9d2d41077bd74b8ba66ebfecc", "patch": "@@ -1106,20 +1106,19 @@ DEF_VEC_MALLOC_P (basic_block);\n \n /* Compute the ANTIC set for BLOCK.\n \n-ANTIC_OUT[BLOCK] = intersection of ANTIC_IN[b] for all succ(BLOCK), if\n-succs(BLOCK) > 1\n-ANTIC_OUT[BLOCK] = phi_translate (ANTIC_IN[succ(BLOCK)]) if\n-succs(BLOCK) == 1\n+   If succs(BLOCK) > 1 then\n+     ANTIC_OUT[BLOCK] = intersection of ANTIC_IN[b] for all succ(BLOCK)\n+   else if succs(BLOCK) == 1 then\n+     ANTIC_OUT[BLOCK] = phi_translate (ANTIC_IN[succ(BLOCK)])\n \n-ANTIC_IN[BLOCK] = clean(ANTIC_OUT[BLOCK] U EXP_GEN[BLOCK] -\n-TMP_GEN[BLOCK])\n+   ANTIC_IN[BLOCK] = clean(ANTIC_OUT[BLOCK] U EXP_GEN[BLOCK] - TMP_GEN[BLOCK])\n \n-Iterate until fixpointed.\n+   Iterate until fixpointed.\n \n-XXX: It would be nice to either write a set_clear, and use it for\n-antic_out, or to mark the antic_out set as deleted at the end\n-of this routine, so that the pool can hand the same memory back out\n-again for the next antic_out.  */\n+   XXX: It would be nice to either write a set_clear, and use it for\n+   ANTIC_OUT, or to mark the antic_out set as deleted at the end\n+   of this routine, so that the pool can hand the same memory back out\n+   again for the next ANTIC_OUT.  */\n \n \n static bool\n@@ -1733,45 +1732,60 @@ create_value_expr_from (tree expr, basic_block block, vuse_optype vuses)\n }\n \n \n-/* Compute the AVAIL set for BLOCK.\n-   This function performs value numbering of the statements in BLOCK. \n-   The AVAIL sets are built from information we glean while doing this\n-   value numbering, since the AVAIL sets contain only one entry per\n+/* Compute the AVAIL set for all basic blocks.\n+\n+   This function performs value numbering of the statements in each basic\n+   block.  The AVAIL sets are built from information we glean while doing\n+   this value numbering, since the AVAIL sets contain only one entry per\n    value.\n    \n    AVAIL_IN[BLOCK] = AVAIL_OUT[dom(BLOCK)].\n    AVAIL_OUT[BLOCK] = AVAIL_IN[BLOCK] U PHI_GEN[BLOCK] U TMP_GEN[BLOCK].  */\n \n static void\n-compute_avail (basic_block block)\n+compute_avail (void)\n {\n-  basic_block son;\n-  \n+  basic_block block, son;\n+  basic_block *worklist;\n+  size_t sp = 0;\n+  tree param;\n+\n   /* For arguments with default definitions, we pretend they are\n      defined in the entry block.  */\n-  if (block == ENTRY_BLOCK_PTR)\n+  for (param = DECL_ARGUMENTS (current_function_decl);\n+       param;\n+       param = TREE_CHAIN (param))\n     {\n-      tree param;\n-      for (param = DECL_ARGUMENTS (current_function_decl);\n-\t   param;\n-\t   param = TREE_CHAIN (param))\n+      if (default_def (param) != NULL)\n \t{\n-\t  if (default_def (param) != NULL)\n-\t    {\n-\t      tree val;\n-\t      tree def = default_def (param);\n-\t      val = vn_lookup_or_add (def, NULL);\n-\t      bitmap_insert_into_set (TMP_GEN (block), def);\n-\t      bitmap_value_insert_into_set (AVAIL_OUT (block), def);\n-\t    }\n+\t  tree val;\n+\t  tree def = default_def (param);\n+\t  val = vn_lookup_or_add (def, NULL);\n+\t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), def);\n+\t  bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), def);\n \t}\n     }\n-  else if (block)\n+\n+  /* Allocate the worklist.  */\n+  worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+\n+  /* Seed the algorithm by putting the dominator children of the entry\n+     block on the worklist.  */\n+  for (son = first_dom_son (CDI_DOMINATORS, ENTRY_BLOCK_PTR);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    worklist[sp++] = son;\n+\n+  /* Loop until the worklist is empty.  */\n+  while (sp)\n     {\n       block_stmt_iterator bsi;\n       tree stmt, phi;\n       basic_block dom;\n \n+      /* Pick a block from the worklist.  */\n+      block = worklist[--sp];\n+\n       /* Initially, the set of available values in BLOCK is that of\n \t its immediate dominator.  */\n       dom = get_immediate_dominator (CDI_DOMINATORS, block);\n@@ -1857,13 +1871,16 @@ compute_avail (basic_block block)\n \t\t\t    AVAIL_OUT (block));\n \t    }\n \t}\n+\n+      /* Put the dominator children of BLOCK on the worklist of blocks\n+\t to compute available sets for.  */\n+      for (son = first_dom_son (CDI_DOMINATORS, block);\n+\t   son;\n+\t   son = next_dom_son (CDI_DOMINATORS, son))\n+\tworklist[sp++] = son;\n     }\n \n-  /* Compute available sets for the dominator children of BLOCK.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, block);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    compute_avail (son);\n+  free (worklist);\n }\n \n \n@@ -2048,9 +2065,8 @@ execute_pre (bool do_fre)\n {\n   init_pre ();\n \n-  /* Collect and value number expressions computed in each basic\n-     block.  */\n-  compute_avail (ENTRY_BLOCK_PTR);\n+  /* Collect and value number expressions computed in each basic block.  */\n+  compute_avail ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}]}