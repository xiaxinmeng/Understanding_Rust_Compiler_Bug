{"sha": "3c95dcfdc2d82abb353997589f7c9c85e462657f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5NWRjZmRjMmQ4MmFiYjM1Mzk5NzU4OWY3YzljODVlNDYyNjU3Zg==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-08-10T09:56:03Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-08-10T09:56:03Z"}, "message": "java-stack.h (GetAccessControlStack): Change return type.\n\n2006-08-10  Gary Benson  <gbenson@redhat.com>\n\n\t* include/java-stack.h (GetAccessControlStack): Change return\n\ttype.\n\t* stacktrace.cc (accesscontrol_trace_fn): Record the number of\n\tJava frames encountered.\n\t(GetAccessControlStack): Return a flag indicating whether a call to\n\tdoPrivileged was encountered rather than an array of method names.\n\t* java/security/natVMAccessController.cc (getStack): Change return\n\ttype.\n\t* java/security/VMAccessController.java (getStack): Likewise.\n\t(getContext): Change to reflect the above.\n\nFrom-SVN: r116058", "tree": {"sha": "ea99d08538a2e3928204d850e7a3c5dc199cd010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea99d08538a2e3928204d850e7a3c5dc199cd010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c95dcfdc2d82abb353997589f7c9c85e462657f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c95dcfdc2d82abb353997589f7c9c85e462657f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c95dcfdc2d82abb353997589f7c9c85e462657f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c95dcfdc2d82abb353997589f7c9c85e462657f/comments", "author": null, "committer": null, "parents": [{"sha": "9f6b5d5953c984aecff1756a72d222f028fe6429", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f6b5d5953c984aecff1756a72d222f028fe6429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f6b5d5953c984aecff1756a72d222f028fe6429"}], "stats": {"total": 114, "additions": 59, "deletions": 55}, "files": [{"sha": "4792cec6e78cadc482a434ac85d4ea34ae121da0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3c95dcfdc2d82abb353997589f7c9c85e462657f", "patch": "@@ -1,3 +1,16 @@\n+2006-08-10  Gary Benson  <gbenson@redhat.com>\n+\n+\t* include/java-stack.h (GetAccessControlStack): Change return\n+\ttype.\n+\t* stacktrace.cc (accesscontrol_trace_fn): Record the number of\n+\tJava frames encountered.\n+\t(GetAccessControlStack): Return a flag indicating whether a call to\n+\tdoPrivileged was encountered rather than an array of method names.\n+\t* java/security/natVMAccessController.cc (getStack): Change return\n+\ttype.\n+\t* java/security/VMAccessController.java (getStack): Likewise.\n+\t(getContext): Change to reflect the above.\n+\n 2006-08-09  Gary Benson  <gbenson@redhat.com>\n \n \t* stacktrace.cc (accesscontrol_trace_fn): Skip non-Java frames."}, {"sha": "f7209512b2c83bd959a3ca4963acafd229d321c3", "filename": "libjava/include/java-stack.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=3c95dcfdc2d82abb353997589f7c9c85e462657f", "patch": "@@ -125,7 +125,7 @@ class _Jv_StackTrace\n   static void GetCallerInfo (jclass checkClass, jclass *, _Jv_Method **);\n   static JArray<jclass> *GetClassContext (jclass checkClass);\n   static ClassLoader *GetFirstNonSystemClassLoader (void);\n-  static JArray<jobjectArray> *GetAccessControlStack ();\n+  static jobjectArray GetAccessControlStack ();\n   \n };\n "}, {"sha": "85d0313b3a363a2ddeefebc9409f076d89428349", "filename": "libjava/java/security/VMAccessController.java", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fjava%2Fsecurity%2FVMAccessController.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fjava%2Fsecurity%2FVMAccessController.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FVMAccessController.java?ref=3c95dcfdc2d82abb353997589f7c9c85e462657f", "patch": "@@ -178,50 +178,41 @@ static AccessControlContext getContext()\n \n     inGetContext.set(Boolean.TRUE);\n \n-    Object[][] stack = getStack();\n+    Object[] stack = getStack();\n     Class[] classes = (Class[]) stack[0];\n-    String[] methods = (String[]) stack[1];\n+    boolean privileged = ((Boolean) stack[1]).booleanValue();\n \n     if (DEBUG)\n       debug(\"got trace of length \" + classes.length);\n \n     HashSet domains = new HashSet();\n     HashSet seenDomains = new HashSet();\n     AccessControlContext context = null;\n-    int privileged = 0;\n \n     // We walk down the stack, adding each ProtectionDomain for each\n     // class in the call stack. If we reach a call to doPrivileged,\n     // we don't add any more stack frames. We skip the first three stack\n     // frames, since they comprise the calls to getStack, getContext,\n     // and AccessController.getContext.\n-    for (int i = 3; i < classes.length && privileged < 2; i++)\n+    for (int i = 3; i < classes.length; i++)\n       {\n         Class clazz = classes[i];\n-        String method = methods[i];\n \n         if (DEBUG)\n           {\n-            debug(\"checking \" + clazz + \".\" + method);\n+            debug(\"checking \" + clazz);\n             // subject to getClassLoader RuntimePermission\n             debug(\"loader = \" + clazz.getClassLoader());\n           }\n \n-        // If the previous frame was a call to doPrivileged, then this is\n-        // the last frame we look at.\n-        if (privileged == 1)\n-          privileged = 2;\n-\n-        if (clazz.equals (AccessController.class)\n-            && method.equals (\"doPrivileged\"))\n+        if (privileged && i == classes.length - 2)\n           {\n             // If there was a call to doPrivileged with a supplied context,\n             // return that context. If using JAAS doAs*, it should be \n \t    // a context with a SubjectDomainCombiner\n             LinkedList l = (LinkedList) contexts.get();\n             if (l != null)\n               context = (AccessControlContext) l.getFirst();\n-            privileged = 1;\n           }\n \n         // subject to getProtectionDomain RuntimePermission\n@@ -270,16 +261,14 @@ static AccessControlContext getContext()\n   }\n \n   /**\n-   * Returns a snapshot of the current call stack as a pair of arrays:\n-   * the first an array of classes in the call stack, the second an array\n-   * of strings containing the method names in the call stack. The two\n-   * arrays match up, meaning that method <i>i</i> is declared in class\n-   * <i>i</i>. The arrays are clean; it will only contain Java methods,\n-   * and no element of the list should be null.\n+   * Returns a snapshot of the current call stack as a two-element\n+   * array. The first element is an array of classes in the call\n+   * stack, and the second element is a boolean value indicating\n+   * whether the trace stopped early because a call to doPrivileged\n+   * was encountered.  If this boolean value is true then the call to\n+   * doPrivileged will be the second-last frame in the returned trace.\n    *\n-   * @return A pair of arrays describing the current call stack. The first\n-   *    element is an array of Class objects, and the second is an array\n-   *    of Strings comprising the method names.\n+   * @return A snapshot of the current call stack.\n    */\n-  private static native Object[][] getStack();\n+  private static native Object[] getStack();\n }"}, {"sha": "9a0ae489e808d4793bd16c35aaea7a3131034617", "filename": "libjava/java/security/natVMAccessController.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc?ref=3c95dcfdc2d82abb353997589f7c9c85e462657f", "patch": "@@ -16,7 +16,7 @@ details.  */\n \n #include <java/security/VMAccessController.h>\n \n-JArray<jobjectArray> *\n+jobjectArray\n java::security::VMAccessController::getStack ()\n {\n   return _Jv_StackTrace::GetAccessControlStack ();"}, {"sha": "fe2c2e058f9e6123f7541bfd27f0af095d509617", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c95dcfdc2d82abb353997589f7c9c85e462657f/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=3c95dcfdc2d82abb353997589f7c9c85e462657f", "patch": "@@ -18,6 +18,7 @@ details.  */\n \n #include <stdio.h>\n \n+#include <java/lang/Boolean.h>\n #include <java/lang/Class.h>\n #include <java/lang/Long.h>\n #include <java/security/AccessController.h>\n@@ -536,73 +537,74 @@ _Jv_StackTrace::GetFirstNonSystemClassLoader ()\n   return NULL;\n }\n \n+struct AccessControlTraceData\n+{\n+  jint length;\n+  jboolean privileged;\n+};\n+\n _Unwind_Reason_Code\n _Jv_StackTrace::accesscontrol_trace_fn (_Jv_UnwindState *state)\n {\n+  AccessControlTraceData *trace_data = (AccessControlTraceData *)\n+    state->trace_data;\n   _Jv_StackFrame *frame = &state->frames[state->pos];\n   FillInFrameInfo (frame);\n \n   if (!(frame->klass && frame->meth))\n     return _URC_NO_REASON;\n \n-  bool *stopping = (bool *) state->trace_data;\n-  if (*stopping)\n+  trace_data->length++;\n+\n+  // If the previous frame was a call to doPrivileged, then this is\n+  // the last frame we look at.\n+  if (trace_data->privileged)\n     return _URC_NORMAL_STOP;\n   \n   if (frame->klass == &::java::security::AccessController::class$\n       && strcmp (frame->meth->name->chars(), \"doPrivileged\") == 0)\n-    *stopping = true;\n+    trace_data->privileged = true;\n \n   return _URC_NO_REASON;\n }\n \n-JArray<jobjectArray> *\n+jobjectArray\n _Jv_StackTrace::GetAccessControlStack (void)\n {\n   int trace_size = 100;\n   _Jv_StackFrame frames[trace_size];\n   _Jv_UnwindState state (trace_size);\n   state.frames = (_Jv_StackFrame *) &frames;\n+\n+  AccessControlTraceData trace_data;\n+  trace_data.length = 0;\n+  trace_data.privileged = false;\n+  \n   state.trace_function = accesscontrol_trace_fn;\n-  bool stopping = false;\n-  state.trace_data = (void *) &stopping;\n+  state.trace_data = (void *) &trace_data;\n \n   UpdateNCodeMap();\n   _Unwind_Backtrace (UnwindTraceFn, &state);\n-  \n-  jint length = 0;\n \n-  for (int i = 0; i < state.pos; i++)\n-    {\n-      _Jv_StackFrame *frame = &state.frames[i];\n-\n-      if (frame->klass && frame->meth)\n-\tlength++;\n-    }\n-\n-  jclass array_class = _Jv_GetArrayClass (&::java::lang::Object::class$, NULL);\n-  JArray<jobjectArray> *result =\n-    (JArray<jobjectArray> *) _Jv_NewObjectArray (2, array_class, NULL);\n   JArray<jclass> *classes = (JArray<jclass> *)\n-    _Jv_NewObjectArray (length, &::java::lang::Class::class$, NULL);\n-  JArray<jstring> *methods = (JArray<jstring> *)\n-    _Jv_NewObjectArray (length, &::java::lang::String::class$, NULL);\n-  jclass  *c = elements (classes);\n-  jstring *m = elements (methods);\n+    _Jv_NewObjectArray (trace_data.length, &::java::lang::Class::class$, NULL);\n+  jclass *c = elements (classes);\n \n   for (int i = 0, j = 0; i < state.pos; i++)\n     {\n       _Jv_StackFrame *frame = &state.frames[i];\n       if (!frame->klass || !frame->meth)\n \tcontinue;\n       c[j] = frame->klass;\n-      m[j] = JvNewStringUTF (frame->meth->name->chars());\n       j++;\n     }\n \n-  jobjectArray *elems = elements (result);\n-  elems[0] = (jobjectArray) classes;\n-  elems[1] = (jobjectArray) methods;\n-\n+  jobjectArray result =\n+    (jobjectArray) _Jv_NewObjectArray (2, &::java::lang::Object::class$,\n+\t\t\t\t\t NULL);\n+  jobject *r = elements (result);\n+  r[0] = (jobject) classes;\n+  r[1] = (jobject) new Boolean (trace_data.privileged);\n+  \n   return result;\n }"}]}