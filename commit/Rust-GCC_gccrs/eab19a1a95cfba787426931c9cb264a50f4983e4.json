{"sha": "eab19a1a95cfba787426931c9cb264a50f4983e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFiMTlhMWE5NWNmYmE3ODc0MjY5MzFjOWNiMjY0YTUwZjQ5ODNlNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-03-28T21:30:26Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-03-28T21:30:26Z"}, "message": "re PR fortran/45159 (Unnecessary temporaries)\n\n2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45159\n\t* gfortran.h (gfc_dep_difference):  Add prototype.\n\t* dependency.c (discard_nops):  New function.\n\t(gfc_dep_difference):  New function.\n\t(check_section_vs_section):  Use gfc_dep_difference\n\tto calculate the difference of starting indices.\n\t* trans-expr.c (gfc_conv_substring):  Use\n\tgfc_dep_difference to calculate the length of\n\tsubstrings where possible.\n\n2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45159\n\t* gfortran.dg/string_length_2.f90:  New test.\n\t* gfortran.dg/dependency_41.f90:  New test.\n\nFrom-SVN: r197217", "tree": {"sha": "de0dd9008c209a681b4e6c663313253716f5df2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de0dd9008c209a681b4e6c663313253716f5df2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eab19a1a95cfba787426931c9cb264a50f4983e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab19a1a95cfba787426931c9cb264a50f4983e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab19a1a95cfba787426931c9cb264a50f4983e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab19a1a95cfba787426931c9cb264a50f4983e4/comments", "author": null, "committer": null, "parents": [{"sha": "4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4099436d98dcdd96a0cbfd4332da1ddc961ba7f7"}], "stats": {"total": 363, "additions": 353, "deletions": 10}, "files": [{"sha": "f1f176573c430b9f1f74462cadcc307a2d1a401c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -1,3 +1,15 @@\n+2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45159\n+\t* gfortran.h (gfc_dep_difference):  Add prototype.\n+\t* dependency.c (discard_nops):  New function.\n+\t(gfc_dep_difference):  New function.\n+\t(check_section_vs_section):  Use gfc_dep_difference\n+\tto calculate the difference of starting indices.\n+\t* trans-expr.c (gfc_conv_substring):  Use\n+\tgfc_dep_difference to calculate the length of\n+\tsubstrings where possible.\n+\n 2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/55806"}, {"sha": "062b1c5837a6dc7e008026309ef9508abc5a1842", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 270, "deletions": 7, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -501,6 +501,272 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n }\n \n \n+/* Helper function to look through parens and unary plus.  */\n+\n+static gfc_expr*\n+discard_nops (gfc_expr *e)\n+{\n+\n+  while (e && e->expr_type == EXPR_OP\n+\t && (e->value.op.op == INTRINSIC_UPLUS\n+\t     || e->value.op.op == INTRINSIC_PARENTHESES))\n+    e = e->value.op.op1;\n+\n+  return e;\n+}\n+\n+\n+/* Return the difference between two expressions.  Integer expressions of\n+   the form \n+\n+   X + constant, X - constant and constant + X\n+\n+   are handled.  Return true on success, false on failure. result is assumed\n+   to be uninitialized on entry, and will be initialized on success.\n+*/\n+\n+bool\n+gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n+{\n+  gfc_expr *e1_op1, *e1_op2, *e2_op1, *e2_op2;\n+\n+  if (e1 == NULL || e2 == NULL)\n+    return false;\n+\n+  if (e1->ts.type != BT_INTEGER || e2->ts.type != BT_INTEGER)\n+    return false;\n+\n+  e1 = discard_nops (e1);\n+  e2 = discard_nops (e2);\n+\n+  /* Inizialize tentatively, clear if we don't return anything.  */\n+  mpz_init (*result);\n+\n+  /* Case 1: c1 - c2 = c1 - c2, trivially.  */\n+\n+  if (e1->expr_type == EXPR_CONSTANT && e2->expr_type == EXPR_CONSTANT)\n+    {\n+      mpz_sub (*result, e1->value.integer, e2->value.integer);\n+      return true;\n+    }\n+\n+  if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_PLUS)\n+    {\n+      e1_op1 = discard_nops (e1->value.op.op1);\n+      e1_op2 = discard_nops (e1->value.op.op2);\n+\n+      /* Case 2: (X + c1) - X = c1.  */\n+      if (e1_op2->expr_type == EXPR_CONSTANT\n+\t  && gfc_dep_compare_expr (e1_op1, e2) == 0)\n+\t{\n+\t  mpz_set (*result, e1_op2->value.integer);\n+\t  return true;\n+\t}\n+\n+      /* Case 3: (c1 + X) - X = c1. */\n+      if (e1_op1->expr_type == EXPR_CONSTANT\n+\t  && gfc_dep_compare_expr (e1_op2, e2) == 0)\n+\t{\n+\t  mpz_set (*result, e1_op1->value.integer);\n+\t  return true;\n+\t}\n+\n+      if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n+\t{\n+\t  e2_op1 = discard_nops (e2->value.op.op1);\n+\t  e2_op2 = discard_nops (e2->value.op.op2);\n+\n+\t  if (e1_op2->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      /* Case 4: X + c1 - (X + c2) = c1 - c2.  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e1_op2->value.integer,\n+\t\t\t   e2_op2->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t      /* Case 5: X + c1 - (c2 + X) = c1 - c2.  */\n+\t      if (e2_op1->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op2) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e1_op2->value.integer,\n+\t\t\t   e2_op1->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  else if (e1_op1->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      /* Case 6: c1 + X - (X + c2) = c1 - c2.  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op2, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e1_op1->value.integer,\n+\t\t\t   e2_op2->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t      /* Case 7: c1 + X - (c2 + X) = c1 - c2.  */\n+\t      if (e2_op1->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op2, e2_op2) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e1_op1->value.integer,\n+\t\t\t   e2_op1->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n+\t{\n+\t  e2_op1 = discard_nops (e2->value.op.op1);\n+\t  e2_op2 = discard_nops (e2->value.op.op2);\n+\n+\t  if (e1_op2->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      /* Case 8: X + c1 - (X - c2) = c1 + c2.  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_add (*result, e1_op2->value.integer,\n+\t\t\t   e2_op2->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t  if (e1_op1->expr_type == EXPR_CONSTANT)\n+\t    {\n+\t      /* Case 9: c1 + X - (X - c2) = c1 + c2.  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op2, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_add (*result, e1_op1->value.integer,\n+\t\t\t   e2_op2->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (e1->expr_type == EXPR_OP && e1->value.op.op == INTRINSIC_MINUS)\n+    {\n+      e1_op1 = discard_nops (e1->value.op.op1);\n+      e1_op2 = discard_nops (e1->value.op.op2);\n+\n+      if (e1_op2->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  /* Case 10: (X - c1) - X = -c1  */\n+\n+\t  if (gfc_dep_compare_expr (e1_op1, e2) == 0)\n+\t    {\n+\t      mpz_neg (*result, e1_op2->value.integer);\n+\t      return true;\n+\t    }\n+\n+\t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n+\t    {\n+\t      e2_op1 = discard_nops (e2->value.op.op1);\n+\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\n+\t      /* Case 11: (X - c1) - (X + c2) = -( c1 + c2).  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_add (*result, e1_op2->value.integer,\n+\t\t\t   e2_op2->value.integer);\n+\t\t  mpz_neg (*result, *result);\n+\t\t  return true;\n+\t\t}\n+\n+\t      /* Case 12: X - c1 - (c2 + X) = - (c1 + c2).  */\n+\t      if (e2_op1->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op2) == 0)\n+\t\t{\n+\t\t  mpz_add (*result, e1_op2->value.integer,\n+\t\t\t   e2_op1->value.integer);\n+\t\t  mpz_neg (*result, *result);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\n+\t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n+\t    {\n+\t      e2_op1 = discard_nops (e2->value.op.op1);\n+\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\n+\t      /* Case 13: (X - c1) - (X - c2) = c2 - c1.  */\n+\t      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t\t  && gfc_dep_compare_expr (e1_op1, e2_op1) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e2_op2->value.integer,\n+\t\t\t   e1_op2->value.integer);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+      if (e1_op1->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n+\t    {\n+\t      e2_op1 = discard_nops (e2->value.op.op1);\n+\t      e2_op2 = discard_nops (e2->value.op.op2);\n+\t      \n+\t      /* Case 14: (c1 - X) - (c2 - X) == c1 - c2.  */\n+\t      if (gfc_dep_compare_expr (e1_op2, e2_op2) == 0)\n+\t\t{\n+\t\t  mpz_sub (*result, e1_op1->value.integer,\n+\t\t\t   e2_op1->value.integer);\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\n+\t}\n+    }\n+\n+  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_PLUS)\n+    {\n+      e2_op1 = discard_nops (e2->value.op.op1);\n+      e2_op2 = discard_nops (e2->value.op.op2);\n+\n+      /* Case 15: X - (X + c2) = -c2.  */\n+      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t  && gfc_dep_compare_expr (e1, e2_op1) == 0)\n+\t{\n+\t  mpz_neg (*result, e2_op2->value.integer);\n+\t  return true;\n+\t}\n+      /* Case 16: X - (c2 + X) = -c2.  */\n+      if (e2_op1->expr_type == EXPR_CONSTANT\n+\t  && gfc_dep_compare_expr (e1, e2_op2) == 0)\n+\t{\n+\t  mpz_neg (*result, e2_op1->value.integer);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (e2->expr_type == EXPR_OP && e2->value.op.op == INTRINSIC_MINUS)\n+    {\n+      e2_op1 = discard_nops (e2->value.op.op1);\n+      e2_op2 = discard_nops (e2->value.op.op2);\n+\n+      /* Case 17: X - (X - c2) = c2.  */\n+      if (e2_op2->expr_type == EXPR_CONSTANT\n+\t  && gfc_dep_compare_expr (e1, e2_op1) == 0)\n+\t{\n+\t  mpz_set (*result, e2_op2->value.integer);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (gfc_dep_compare_expr(e1, e2) == 0)\n+    {\n+      /* Case 18: X - X = 0.  */\n+      mpz_set_si (*result, 0);\n+      return true;\n+    }\n+\n+  mpz_clear (*result);\n+  return false;\n+}\n+\n /* Returns 1 if the two ranges are the same and 0 if they are not (or if the\n    results are indeterminate). 'n' is the dimension to compare.  */\n \n@@ -1140,6 +1406,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n   int r_dir;\n   int stride_comparison;\n   int start_comparison;\n+  mpz_t tmp;\n \n   /* If they are the same range, return without more ado.  */\n   if (is_same_range (l_ar, r_ar, n))\n@@ -1275,24 +1542,20 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n      (l_start - r_start) / gcd(l_stride, r_stride) is\n      nonzero.\n      TODO:\n-       - Handle cases where x is an expression.\n        - Cases like a(1:4:2) = a(2:3) are still not handled.\n   */\n \n #define IS_CONSTANT_INTEGER(a) ((a) && ((a)->expr_type == EXPR_CONSTANT) \\\n \t\t\t      && (a)->ts.type == BT_INTEGER)\n \n-  if (IS_CONSTANT_INTEGER(l_start) && IS_CONSTANT_INTEGER(r_start)\n-      && IS_CONSTANT_INTEGER(l_stride) && IS_CONSTANT_INTEGER(r_stride))\n+  if (IS_CONSTANT_INTEGER(l_stride) && IS_CONSTANT_INTEGER(r_stride)\n+      && gfc_dep_difference (l_start, r_start, &tmp))\n     {\n-      mpz_t gcd, tmp;\n+      mpz_t gcd;\n       int result;\n \n       mpz_init (gcd);\n-      mpz_init (tmp);\n-\n       mpz_gcd (gcd, l_stride->value.integer, r_stride->value.integer);\n-      mpz_sub (tmp, l_start->value.integer, r_start->value.integer);\n \n       mpz_fdiv_r (tmp, tmp, gcd);\n       result = mpz_cmp_si (tmp, 0L);"}, {"sha": "4ebe9872b28327de652ad86fd52c6b2e1e9ca874", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -2969,6 +2969,7 @@ gfc_namespace* gfc_build_block_ns (gfc_namespace *);\n /* dependency.c */\n int gfc_dep_compare_functions (gfc_expr *, gfc_expr *, bool);\n int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);\n+bool gfc_dep_difference (gfc_expr *, gfc_expr *, mpz_t *);\n \n /* check.c */\n gfc_try gfc_check_same_strlen (const gfc_expr*, const gfc_expr*, const char*);"}, {"sha": "d0a9446fccea61654915e5147a5714325f5919a1", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -1437,6 +1437,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   gfc_se start;\n   gfc_se end;\n   char *msg;\n+  mpz_t length;\n \n   type = gfc_get_character_type (kind, ref->u.ss.length);\n   type = build_pointer_type (type);\n@@ -1520,10 +1521,19 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       free (msg);\n     }\n \n-  /* If the start and end expressions are equal, the length is one.  */\n+  /* Try to calculate the length from the start and end expressions.  */\n   if (ref->u.ss.end\n-      && gfc_dep_compare_expr (ref->u.ss.start, ref->u.ss.end) == 0)\n-    tmp = build_int_cst (gfc_charlen_type_node, 1);\n+      && gfc_dep_difference (ref->u.ss.end, ref->u.ss.start, &length))\n+    {\n+      int i_len;\n+\n+      i_len = mpz_get_si (length) + 1;\n+      if (i_len < 0)\n+\ti_len = 0;\n+\n+      tmp = build_int_cst (gfc_charlen_type_node, i_len);\n+      mpz_clear (length);  /* Was initialized by gfc_dep_difference.  */\n+    }\n   else\n     {\n       tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_charlen_type_node,"}, {"sha": "a7ccaadacf6965d4a5725b60bf9d4b68355912ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -1,3 +1,9 @@\n+2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45159\n+\t* gfortran.dg/string_length_2.f90:  New test.\n+\t* gfortran.dg/dependency_41.f90:  New test.\n+\n 2013-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/55806"}, {"sha": "db9e0e6288eb5764bdf0a6a93f43a3520daa73f3", "filename": "gcc/testsuite/gfortran.dg/dependency_41.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_41.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_41.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_41.f90?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-options \"-Warray-temporaries\" }\n+! No temporary should be generated in this case.\n+program main\n+  implicit none\n+  integer :: i,n\n+  integer :: a(10)\n+  integer :: b(10)\n+  do i=1,10\n+     a(i) = i\n+     b(i) = i\n+  end do\n+  n = 1\n+  ! Same result when assigning to a or b\n+  b(n+1:10:4) = a(n+2:8:2)\n+  a(n+1:10:4) = a(n+2:8:2)\n+  if (any (a/=b)) call abort\n+end program main\n+"}, {"sha": "63cea9e1dab50eea63d453ea2adbbf8d28ecb834", "filename": "gcc/testsuite/gfortran.dg/string_length_2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_length_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab19a1a95cfba787426931c9cb264a50f4983e4/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_length_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_length_2.f90?ref=eab19a1a95cfba787426931c9cb264a50f4983e4", "patch": "@@ -0,0 +1,32 @@\n+! { dg-run }\n+! { dg-options \"-fdump-tree-original\" }\n+! Test that all string length calculations are\n+! optimized away.\n+program main\n+  character (len=999) :: c\n+  character (len=5) :: unit\n+  unit = '    '\n+  read (unit=unit,fmt='(I5)') i   ! Hide from optimizers\n+  j = 7\n+  c = '123456789'\n+  if (len(c(         3        : 5                )) /= 3) call abort ! Case  1\n+  if (len(c(     i*(i+1)      :     (i+1)*i + 2  )) /= 3) call abort ! Case  2\n+  if (len(c(     i*(i+1)      : 2 + (i+1)*i      )) /= 3) call abort ! Case  3\n+  if (len(c(     i*(i+1) + 2  :     (i+1)*i + 3  )) /= 2) call abort ! Case  4\n+  if (len(c( 2 + i*(i+1)      :     (i+1)*i + 3  )) /= 2) call abort ! Case  5\n+  if (len(c(     i*(i+1) + 2  : 3 + (i+1)*i      )) /= 2) call abort ! Case  6\n+  if (len(c( 2 + i*(i+1)      : 3 + (i+1)*i      )) /= 2) call abort ! Case  7\n+  if (len(c(     i*(i+1) - 1  :     (i+1)*i + 1  )) /= 3) call abort ! Case  8\n+  if (len(c(     i*(i+1) - 1  : 1 + (i+1)*i      )) /= 3) call abort ! Case  9\n+  if (len(c(     i*(i+1)      :     (i+1)*i -(-1))) /= 2) call abort ! Case 10\n+  if (len(c(     i*(i+1) +(-2):     (i+1)*i - 1  )) /= 2) call abort ! Case 11 \n+  if (len(c(     i*(i+1) + 2  :     (i+1)*i -(-4))) /= 3) call abort ! Case 12\n+  if (len(c(     i*(i+1) - 3  :     (i+1)*i - 1  )) /= 3) call abort ! Case 13\n+  if (len(c(13 - i*(i+1)      :15 - (i+1)*i      )) /= 3) call abort ! Case 14\n+  if (len(c(     i*(i+1) +(-1):     (i+1)*i      )) /= 2) call abort ! Case 15\n+  if (len(c(-1 + i*(i+1)      :     (i+1)*i      )) /= 2) call abort ! Case 16\n+  if (len(c(     i*(i+1) - 2  :     (i+1)*i      )) /= 3) call abort ! Case 17\n+  if (len(c(  (i-2)*(i-3)     :   (i-3)*(i-2)    )) /= 1)       call abort ! Case 18\n+end program main\n+! { dg-final { scan-tree-dump-times \"_abort\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}