{"sha": "e69a816d8f323ba1f2660480da8e73ef3b30780d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5YTgxNmQ4ZjMyM2JhMWYyNjYwNDgwZGE4ZTczZWYzYjMwNzgwZA==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-11-29T12:22:06Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-11-29T12:22:06Z"}, "message": "[AArch64] Fix ICE due to store_pair_lanes\n\nThe recently added store_pair_lanes causes ICEs in output_operand.\nThis is due to aarch64_classify_address treating it like a 128-bit STR\nrather than a STP.  The valid immediate offsets don't fully overlap,\ncausing it to return false.  Eg. offset 264 is a valid 8-byte STP offset\nbut not a valid 16-byte STR offset since it isn't a multiple of 16.\n\nThe original instruction isn't passed in the printing code, so the context\nis unclear.  The solution is to add a new operand formatting specifier\nwhich is used for LDP/STP instructions like this.  This, like the Uml\nconstraint that applies to store_pair_lanes, uses PARALLEL when calling\naarch64_classify_address so that it knows it is an STP.\nAlso add the 'z' specifier for future use by load/store pair instructions.\n\n    gcc/\n\t* config/aarch64/aarch64.c (aarch64_print_operand): Add new\n\tcases for printing LDP/STP memory addresses.\n\t(aarch64_print_address_internal): Renamed from\n\taarch64_print_operand_address, added parameter, add Pmode check.\n\t(aarch64_print_ldpstp_address): New function for LDP/STP addresses.\n\t(aarch64_print_operand_address): Indirect to\n\taarch64_print_address_internal.\n\t* config/aarch64/aarch64-simd.md (store_pair_lanes): Use new\n\t'y' operand output specifier.\n\nFrom-SVN: r255230", "tree": {"sha": "231273b6d07fa122a9132d96525cae3b118d0c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/231273b6d07fa122a9132d96525cae3b118d0c9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e69a816d8f323ba1f2660480da8e73ef3b30780d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69a816d8f323ba1f2660480da8e73ef3b30780d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69a816d8f323ba1f2660480da8e73ef3b30780d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69a816d8f323ba1f2660480da8e73ef3b30780d/comments", "author": null, "committer": null, "parents": [{"sha": "65d5e454e5944531df80d0a9b5dcf2344c146fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d5e454e5944531df80d0a9b5dcf2344c146fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d5e454e5944531df80d0a9b5dcf2344c146fb8"}], "stats": {"total": 73, "additions": 66, "deletions": 7}, "files": [{"sha": "01d6a9291ba320a7608da8d730178691ff6ddbe0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e69a816d8f323ba1f2660480da8e73ef3b30780d", "patch": "@@ -1,3 +1,15 @@\n+2017-11-29  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_print_operand): Add new\n+\tcases for printing LDP/STP memory addresses.\n+\t(aarch64_print_address_internal): Renamed from\n+\taarch64_print_operand_address, added parameter, add Pmode check.\n+\t(aarch64_print_ldpstp_address): New function for LDP/STP addresses.\n+\t(aarch64_print_operand_address): Indirect to\n+\taarch64_print_address_internal.\n+\t* config/aarch64/aarch64-simd.md (store_pair_lanes): Use new\n+\t'y' operand output specifier.\n+\n 2017-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/83185"}, {"sha": "02f0ff0dd2dcb07ee0f8ab271874e0846b10bfb1", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=e69a816d8f323ba1f2660480da8e73ef3b30780d", "patch": "@@ -3047,8 +3047,8 @@\n \t   (match_operand:VDC 2 \"register_operand\" \"w, r\")))]\n   \"TARGET_SIMD\"\n   \"@\n-   stp\\\\t%d1, %d2, %0\n-   stp\\\\t%x1, %x2, %0\"\n+   stp\\\\t%d1, %d2, %y0\n+   stp\\\\t%x1, %x2, %y0\"\n   [(set_attr \"type\" \"neon_stp, store_16\")]\n )\n "}, {"sha": "904afa9d0e775da196d0194c84ec786fd20e510f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69a816d8f323ba1f2660480da8e73ef3b30780d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e69a816d8f323ba1f2660480da8e73ef3b30780d", "patch": "@@ -150,6 +150,7 @@ static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t\t bool is_packed);\n static machine_mode\n aarch64_simd_container_mode (scalar_mode mode, unsigned width);\n+static void aarch64_print_ldpstp_address (FILE *f, machine_mode mode, rtx x);\n \n /* Major revision number of the ARM Architecture implemented by the target.  */\n unsigned aarch64_architecture_version;\n@@ -5225,7 +5226,11 @@ static const int aarch64_nzcv_codes[] =\n      'L':\t\tOutput constant address specified by X\n \t\t\twith a relocation offset if appropriate.\n      'G':\t\tPrints address of X, specifying a PC relative\n-\t\t\trelocation mode if appropriate.  */\n+\t\t\trelocation mode if appropriate.\n+     'y':\t\tOutput address of LDP or STP - this is used for\n+\t\t\tsome LDP/STPs which don't use a PARALLEL in their\n+\t\t\tpattern (so the mode needs to be adjusted).\n+     'z':\t\tOutput address of a typical LDP or STP.  */\n \n static void\n aarch64_print_operand (FILE *f, rtx x, int code)\n@@ -5427,8 +5432,6 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n \n \tcase MEM:\n \t  output_address (GET_MODE (x), XEXP (x, 0));\n-\t  /* Check all memory references are Pmode - even with ILP32.  */\n-\t  gcc_assert (GET_MODE (XEXP (x, 0)) == Pmode);\n \t  break;\n \n \tcase CONST:\n@@ -5592,18 +5595,48 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n       }\n       break;\n \n+    case 'y':\n+    case 'z':\n+      {\n+\tmachine_mode mode = GET_MODE (x);\n+\n+\tif (GET_CODE (x) != MEM)\n+\t  {\n+\t    output_operand_lossage (\"invalid operand for '%%%c'\", code);\n+\t    return;\n+\t  }\n+\n+\tif (code == 'y')\n+\t  {\n+\t    /* LDP/STP which uses a single double-width memory operand.\n+\t       Adjust the mode to appear like a typical LDP/STP.\n+\t       Currently this is supported for 16-byte accesses only.  */\n+\t    gcc_assert (GET_MODE_SIZE (mode) == 16);\n+\t    mode = DFmode;\n+\t  }\n+\n+\taarch64_print_ldpstp_address (f, mode, XEXP (x, 0));\n+      }\n+      break;\n+\n     default:\n       output_operand_lossage (\"invalid operand prefix '%%%c'\", code);\n       return;\n     }\n }\n \n+/* Print address 'x' of a memory access with mode 'mode'.\n+   'op' is the context required by aarch64_classify_address.  It can either be\n+   MEM for a normal memory access or PARALLEL for LDP/STP.  */\n static void\n-aarch64_print_operand_address (FILE *f, machine_mode mode, rtx x)\n+aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x, RTX_CODE op)\n {\n   struct aarch64_address_info addr;\n \n-  if (aarch64_classify_address (&addr, x, mode, MEM, true))\n+  /* Check all addresses are Pmode - including ILP32.  */\n+  gcc_assert (GET_MODE (x) == Pmode);\n+\n+  if (aarch64_classify_address (&addr, x, mode, op, true))\n     switch (addr.type)\n       {\n       case ADDRESS_REG_IMM:\n@@ -5686,6 +5719,20 @@ aarch64_print_operand_address (FILE *f, machine_mode mode, rtx x)\n   output_addr_const (f, x);\n }\n \n+/* Print address 'x' of a LDP/STP with mode 'mode'.  */\n+static void\n+aarch64_print_ldpstp_address (FILE *f, machine_mode mode, rtx x)\n+{\n+  aarch64_print_address_internal (f, mode, x, PARALLEL);\n+}\n+\n+/* Print address 'x' of a memory access with mode 'mode'.  */\n+static void\n+aarch64_print_operand_address (FILE *f, machine_mode mode, rtx x)\n+{\n+  aarch64_print_address_internal (f, mode, x, MEM);\n+}\n+\n bool\n aarch64_label_mentioned_p (rtx x)\n {"}]}